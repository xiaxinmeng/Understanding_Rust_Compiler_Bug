{"sha": "d51b5cdd82ec0e36212fc75b83652372980d56ca", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1MWI1Y2RkODJlYzBlMzYyMTJmYzc1YjgzNjUyMzcyOTgwZDU2Y2E=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-02-02T10:56:55Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-02-21T19:03:34Z"}, "message": "Clean up MIR match lowering\n\n* Adjust fake borrows to only be live over guards.\n* Remove unused `slice_len_checked` field.\n* Split the methods on builder into those for matches and those for all\n  kinds of pattern bindings.", "tree": {"sha": "e1acb0489f9aee67b26bd05dc9e54395659dedb2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1acb0489f9aee67b26bd05dc9e54395659dedb2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d51b5cdd82ec0e36212fc75b83652372980d56ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d51b5cdd82ec0e36212fc75b83652372980d56ca", "html_url": "https://github.com/rust-lang/rust/commit/d51b5cdd82ec0e36212fc75b83652372980d56ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d51b5cdd82ec0e36212fc75b83652372980d56ca/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c15437c0c6beb2b7be4b86569e124c8b2ccd03bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/c15437c0c6beb2b7be4b86569e124c8b2ccd03bb", "html_url": "https://github.com/rust-lang/rust/commit/c15437c0c6beb2b7be4b86569e124c8b2ccd03bb"}], "stats": {"total": 1642, "additions": 838, "deletions": 804}, "files": [{"sha": "a287659ec8e60b1e8da44288620e631390e2b007", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 480, "deletions": 366, "changes": 846, "blob_url": "https://github.com/rust-lang/rust/blob/d51b5cdd82ec0e36212fc75b83652372980d56ca/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51b5cdd82ec0e36212fc75b83652372980d56ca/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=d51b5cdd82ec0e36212fc75b83652372980d56ca", "patch": "@@ -1,7 +1,9 @@\n-//! Code related to match expressions. These are sufficiently complex\n-//! to warrant their own module and submodules. :) This main module\n-//! includes the high-level algorithm, the submodules contain the\n-//! details.\n+//! Code related to match expressions. These are sufficiently complex to\n+//! warrant their own module and submodules. :) This main module includes the\n+//! high-level algorithm, the submodules contain the details.\n+//!\n+//! This also includes code for pattern bindings in `let` statements and\n+//! function parameters.\n \n use crate::build::scope::{CachedBlock, DropKind};\n use crate::build::ForGuard::{self, OutsideGuard, RefWithinGuard, ValWithinGuard};\n@@ -23,12 +25,78 @@ mod util;\n \n use std::convert::TryFrom;\n \n-/// ArmHasGuard is isomorphic to a boolean flag. It indicates whether\n-/// a match arm has a guard expression attached to it.\n-#[derive(Copy, Clone, Debug)]\n-pub(crate) struct ArmHasGuard(pub bool);\n-\n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n+    /// Generates MIR for a `match` expression.\n+    ///\n+    /// The MIR that we generate for a match looks like this.\n+    ///\n+    /// ```text\n+    /// [ 0. Pre-match ]\n+    ///        |\n+    /// [ 1. Evaluate Scrutinee]\n+    /// [ (fake read of scrutinee) ]\n+    ///        |\n+    /// [ 2. Decision tree -- check discriminants ] <--------+\n+    ///        |                                             |\n+    ///        | (once a specific arm is chosen)             |\n+    ///        |                                             |\n+    /// [pre_binding_block]                           [otherwise_block]\n+    ///        |                                             |\n+    /// [ 3. Create \"guard bindings\" for arm ]               |\n+    /// [ (create fake borrows) ]                            |\n+    ///        |                                             |\n+    /// [ 4. Execute guard code ]                            |\n+    /// [ (read fake borrows) ] --(guard is false)-----------+\n+    ///        |\n+    ///        | (guard results in true)\n+    ///        |\n+    /// [ 5. Create real bindings and execute arm ]\n+    ///        |\n+    /// [ Exit match ]\n+    /// ```\n+    ///\n+    /// All of the different arms have been stacked on top of each other to\n+    /// simplify the diagram. For an arm with no guard the blocks marked 3 and\n+    /// 4 and the fake borrows are omitted.\n+    ///\n+    /// We generate MIR in the following steps:\n+    ///\n+    /// 1. Evaluate the scrutinee and add the fake read of it.\n+    /// 2. Create the prebinding and otherwise blocks.\n+    /// 3. Create the decision tree and record the places that we bind or test.\n+    /// 4. Determine the fake borrows that are needed from the above places.\n+    ///    Create the required temporaries for them.\n+    /// 5. Create everything else: Create everything else: the guards and the\n+    ///    arms.\n+    ///\n+    /// ## Fake Reads and borrows\n+    ///\n+    /// Match exhaustiveness checking is no able to handle the case where the\n+    /// place being matched on is mutated in the guards. There is an AST check\n+    /// that tries to stop this but it is buggy and overly restrictive. Instead\n+    /// we add \"fake borrows\" to the guards that prevent any mutation of the\n+    /// place being matched. There are a some subtleties:\n+    ///\n+    /// 1. Borrowing `*x` doesn't prevent assigning to `x`. If `x` is a shared\n+    ///    refence, the borrow isn't even tracked. As such we have to add fake\n+    ///    borrows of any prefixes of a place\n+    /// 2. We don't want `match x { _ => (), }` to conflict with mutable\n+    ///    borrows of `x`, so we only add fake borrows for places which are\n+    ///    bound or tested by the match.\n+    /// 3. We don't want the fake borrows to conflict with `ref mut` bindings,\n+    ///    so we lower `ref mut` bindings as two-phase borrows for the guard.\n+    /// 4. The fake borrows may be of places in inactive variants, so it would\n+    ///    be UB to generate code for them. They therefore have to be removed\n+    ///    by a MIR pass run after borrow checking.\n+    ///\n+    /// ## False edges\n+    ///\n+    /// We don't want to have the exact structure of the decision tree be\n+    /// visible through borrow checking. False edges ensure that the CFG as\n+    /// seen by borrow checking doesn't encode this. False edges are added:\n+    ///\n+    /// * From each prebinding block to the next prebinding block.\n+    /// * From each otherwise block to the next prebinding block.\n     pub fn match_expr(\n         &mut self,\n         destination: &Place<'tcx>,\n@@ -38,6 +106,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         arms: Vec<Arm<'tcx>>,\n     ) -> BlockAnd<()> {\n         let tcx = self.hir.tcx();\n+\n+        // Step 1. Evaluate the scrutinee and add the fake read of it.\n+\n         let discriminant_span = discriminant.span();\n         let discriminant_place = unpack!(block = self.as_place(block, discriminant));\n \n@@ -66,125 +137,89 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ),\n         });\n \n-        let mut arm_blocks = ArmBlocks {\n-            blocks: arms.iter().map(|_| self.cfg.start_new_block()).collect(),\n-        };\n-\n-        // Get the arm bodies and their scopes, while declaring bindings.\n-        let arm_bodies: Vec<_> = arms.iter()\n-            .map(|arm| {\n-                // BUG: use arm lint level\n-                let body = self.hir.mirror(arm.body.clone());\n-                let scope = self.declare_bindings(\n-                    None,\n-                    body.span,\n-                    LintLevel::Inherited,\n-                    &arm.patterns[..],\n-                    ArmHasGuard(arm.guard.is_some()),\n-                    Some((Some(&discriminant_place), discriminant_span)),\n-                );\n-                (body, scope.unwrap_or(self.source_scope))\n-            })\n-            .collect();\n+        // Step 2. Create the otherwise and prebinding blocks.\n \n         // create binding start block for link them by false edges\n         let candidate_count = arms.iter().map(|c| c.patterns.len()).sum::<usize>();\n         let pre_binding_blocks: Vec<_> = (0..=candidate_count)\n             .map(|_| self.cfg.start_new_block())\n             .collect();\n \n-        let mut has_guard = false;\n-\n-        // assemble a list of candidates: there is one candidate per\n-        // pattern, which means there may be more than one candidate\n-        // *per arm*. These candidates are kept sorted such that the\n-        // highest priority candidate comes first in the list.\n-        // (i.e., same order as in source)\n-\n-        let candidates: Vec<_> = arms.iter()\n-            .enumerate()\n-            .flat_map(|(arm_index, arm)| {\n-                arm.patterns\n-                    .iter()\n-                    .enumerate()\n-                    .map(move |(pat_index, pat)| (arm_index, pat_index, pat, arm.guard.clone()))\n-            })\n-            .zip(\n-                pre_binding_blocks\n-                    .iter()\n-                    .zip(pre_binding_blocks.iter().skip(1)),\n-            )\n-            .map(\n-                |(\n-                    (arm_index, pat_index, pattern, guard),\n-                    (pre_binding_block, next_candidate_pre_binding_block)\n-                )| {\n-                    has_guard |= guard.is_some();\n-\n-                    // One might ask: why not build up the match pair such that it\n-                    // matches via `borrowed_input_temp.deref()` instead of\n-                    // using the `discriminant_place` directly, as it is doing here?\n-                    //\n-                    // The basic answer is that if you do that, then you end up with\n-                    // accceses to a shared borrow of the input and that conflicts with\n-                    // any arms that look like e.g.\n-                    //\n-                    // match Some(&4) {\n-                    //     ref mut foo => {\n-                    //         ... /* mutate `foo` in arm body */ ...\n-                    //     }\n-                    // }\n-                    //\n-                    // (Perhaps we could further revise the MIR\n-                    //  construction here so that it only does a\n-                    //  shared borrow at the outset and delays doing\n-                    //  the mutable borrow until after the pattern is\n-                    //  matched *and* the guard (if any) for the arm\n-                    //  has been run.)\n-\n-                    Candidate {\n-                        span: pattern.span,\n-                        match_pairs: vec![MatchPair::new(discriminant_place.clone(), pattern)],\n-                        bindings: vec![],\n-                        ascriptions: vec![],\n-                        guard,\n-                        arm_index,\n-                        pat_index,\n-                        pre_binding_block: *pre_binding_block,\n-                        next_candidate_pre_binding_block: *next_candidate_pre_binding_block,\n-                    }\n-                },\n-            )\n-            .collect();\n-\n+        // There's one move pre_binding block that there are candidates so that\n+        // every candidate has a next prebinding_block.\n         let outer_source_info = self.source_info(span);\n         self.cfg.terminate(\n             *pre_binding_blocks.last().unwrap(),\n             outer_source_info,\n             TerminatorKind::Unreachable,\n         );\n \n+        let mut match_has_guard = false;\n+\n+        let mut candidate_pre_binding_blocks = pre_binding_blocks.iter();\n+        let mut next_candidate_pre_binding_blocks = pre_binding_blocks.iter().skip(1);\n+\n+        // Assemble a list of candidates: there is one candidate per pattern,\n+        // which means there may be more than one candidate *per arm*.\n+        let mut arm_candidates: Vec<_> = arms\n+            .iter()\n+            .map(|arm| {\n+                let arm_has_guard = arm.guard.is_some();\n+                match_has_guard |= arm_has_guard;\n+                let arm_candidates: Vec<_> = arm.patterns\n+                    .iter()\n+                    .zip(candidate_pre_binding_blocks.by_ref())\n+                    .zip(next_candidate_pre_binding_blocks.by_ref())\n+                    .map(\n+                        |((pattern, pre_binding_block), next_candidate_pre_binding_block)| {\n+                            Candidate {\n+                                span: pattern.span,\n+                                match_pairs: vec![\n+                                    MatchPair::new(discriminant_place.clone(), pattern),\n+                                ],\n+                                bindings: vec![],\n+                                ascriptions: vec![],\n+                                otherwise_block: if arm_has_guard {\n+                                    Some(self.cfg.start_new_block())\n+                                } else {\n+                                    None\n+                                },\n+                                pre_binding_block: *pre_binding_block,\n+                                next_candidate_pre_binding_block:\n+                                    *next_candidate_pre_binding_block,\n+                            }\n+                        },\n+                    )\n+                    .collect();\n+                (arm, arm_candidates)\n+            })\n+            .collect();\n+\n+        // Step 3. Create the decision tree and record the places that we bind or test.\n+\n         // Maps a place to the kind of Fake borrow that we want to perform on\n         // it: either Shallow or Shared, depending on whether the place is\n         // bound in the match, or just switched on.\n         // If there are no match guards then we don't need any fake borrows,\n         // so don't track them.\n-        let mut fake_borrows = if has_guard && tcx.generate_borrow_of_any_match_input() {\n+        let mut fake_borrows = if match_has_guard && tcx.generate_borrow_of_any_match_input() {\n             Some(FxHashMap::default())\n         } else {\n             None\n         };\n \n-        let pre_binding_blocks: Vec<_> = candidates\n-            .iter()\n-            .map(|cand| (cand.pre_binding_block, cand.span))\n-            .collect();\n+        // These candidates are kept sorted such that the highest priority\n+        // candidate comes first in the list. (i.e., same order as in source)\n+        // As we gnerate the decision tree,\n+        let candidates = &mut arm_candidates\n+            .iter_mut()\n+            .flat_map(|(_, candidates)| candidates)\n+            .collect::<Vec<_>>();\n \n         // this will generate code to test discriminant_place and\n         // branch to the appropriate arm block\n         let otherwise = self.match_candidates(\n             discriminant_span,\n-            &mut arm_blocks,\n             candidates,\n             block,\n             &mut fake_borrows,\n@@ -197,36 +232,67 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             //\n             // In that case, the inexhaustive tips of the decision tree\n             // can't be reached - terminate them with an `unreachable`.\n-            let source_info = self.source_info(span);\n-\n             let mut otherwise = otherwise;\n             otherwise.sort();\n             otherwise.dedup(); // variant switches can introduce duplicate target blocks\n             for block in otherwise {\n                 self.cfg\n-                    .terminate(block, source_info, TerminatorKind::Unreachable);\n+                    .terminate(block, outer_source_info, TerminatorKind::Unreachable);\n             }\n         }\n \n-        if let Some(fake_borrows) = fake_borrows {\n-            self.add_fake_borrows(&pre_binding_blocks, fake_borrows, source_info, block);\n-        }\n+        // Step 4. Determine the fake borrows that are needed from the above\n+        // places. Create the required temporaries for them.\n+\n+        let fake_borrow_temps = if let Some(ref borrows) = fake_borrows {\n+            self.calculate_fake_borrows(borrows, discriminant_span)\n+        } else {\n+            Vec::new()\n+        };\n+\n+        // Step 5. Create everything else: the guards and the arms.\n \n         // all the arm blocks will rejoin here\n         let end_block = self.cfg.start_new_block();\n \n         let outer_source_info = self.source_info(span);\n-        for (arm_index, (body, source_scope)) in arm_bodies.into_iter().enumerate() {\n-            let mut arm_block = arm_blocks.blocks[arm_index];\n-            // Re-enter the source scope we created the bindings in.\n-            self.source_scope = source_scope;\n+\n+        for (arm, candidates) in arm_candidates {\n+            let mut arm_block = self.cfg.start_new_block();\n+\n+            let body = self.hir.mirror(arm.body.clone());\n+            let scope = self.declare_bindings(\n+                None,\n+                body.span,\n+                LintLevel::Inherited,\n+                &arm.patterns[..],\n+                ArmHasGuard(arm.guard.is_some()),\n+                Some((Some(&discriminant_place), discriminant_span)),\n+            );\n+\n+            for (pat_index, candidate) in candidates.into_iter().enumerate() {\n+                self.bind_and_guard_matched_candidate(\n+                    candidate,\n+                    arm.guard.clone(),\n+                    arm_block,\n+                    &fake_borrow_temps,\n+                    discriminant_span,\n+                    pat_index,\n+                );\n+            }\n+\n+            if let Some(source_scope) = scope {\n+                self.source_scope = source_scope;\n+            }\n+\n             unpack!(arm_block = self.into(destination, arm_block, body));\n             self.cfg.terminate(\n                 arm_block,\n                 outer_source_info,\n                 TerminatorKind::Goto { target: end_block },\n             );\n         }\n+\n         self.source_scope = outer_source_info.scope;\n \n         end_block.unit()\n@@ -359,11 +425,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             match_pairs: vec![MatchPair::new(initializer.clone(), &irrefutable_pat)],\n             bindings: vec![],\n             ascriptions: vec![],\n-            guard: None,\n \n-            // since we don't call `match_candidates`, next fields is unused\n-            arm_index: 0,\n-            pat_index: 0,\n+            // since we don't call `match_candidates`, next fields are unused\n+            otherwise_block: None,\n             pre_binding_block: block,\n             next_candidate_pre_binding_block: block,\n         };\n@@ -613,13 +677,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     }\n }\n \n-/// List of blocks for each arm (and potentially other metadata in the\n-/// future).\n-struct ArmBlocks {\n-    blocks: Vec<BasicBlock>,\n-}\n-\n-#[derive(Clone, Debug)]\n+#[derive(Debug)]\n pub struct Candidate<'pat, 'tcx: 'pat> {\n     // span of the original pattern that gave rise to this candidate\n     span: Span,\n@@ -630,21 +688,15 @@ pub struct Candidate<'pat, 'tcx: 'pat> {\n     // ...these bindings established...\n     bindings: Vec<Binding<'tcx>>,\n \n-    // ...these types asserted...\n+    // ...and these types asserted...\n     ascriptions: Vec<Ascription<'tcx>>,\n \n-    // ...and the guard must be evaluated...\n-    guard: Option<Guard<'tcx>>,\n-\n-    // ...and then we branch to arm with this index.\n-    arm_index: usize,\n+    // ...and the guard must be evaluated, if false branch to Block...\n+    otherwise_block: Option<BasicBlock>,\n \n     // ...and the blocks for add false edges between candidates\n     pre_binding_block: BasicBlock,\n     next_candidate_pre_binding_block: BasicBlock,\n-\n-    // This uniquely identifies this candidate *within* the arm.\n-    pat_index: usize,\n }\n \n #[derive(Clone, Debug)]\n@@ -676,13 +728,6 @@ pub struct MatchPair<'pat, 'tcx: 'pat> {\n \n     // ... must match this pattern.\n     pattern: &'pat Pattern<'tcx>,\n-\n-    // HACK(eddyb) This is used to toggle whether a Slice pattern\n-    // has had its length checked. This is only necessary because\n-    // the \"rest\" part of the pattern right now has type &[T] and\n-    // as such, it requires an Rvalue::Slice to be generated.\n-    // See RFC 495 / issue #23121 for the eventual (proper) solution.\n-    slice_len_checked: bool,\n }\n \n #[derive(Clone, Debug, PartialEq)]\n@@ -722,6 +767,11 @@ pub struct Test<'tcx> {\n     kind: TestKind<'tcx>,\n }\n \n+/// ArmHasGuard is isomorphic to a boolean flag. It indicates whether\n+/// a match arm has a guard expression attached to it.\n+#[derive(Copy, Clone, Debug)]\n+pub(crate) struct ArmHasGuard(pub bool);\n+\n ///////////////////////////////////////////////////////////////////////////\n // Main matching algorithm\n \n@@ -732,7 +782,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// candidates are sorted such that the first item in the list\n     /// has the highest priority. When a candidate is found to match\n     /// the value, we will generate a branch to the appropriate\n-    /// block found in `arm_blocks`.\n+    /// prebinding block.\n     ///\n     /// The return value is a list of \"otherwise\" blocks. These are\n     /// points in execution where we found that *NONE* of the\n@@ -747,13 +797,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// list. This is important to keep the size of the generated code\n     /// under control. See `test_candidates` for more details.\n     ///\n-    /// If `add_fake_borrows` is true, then places which need fake borrows\n+    /// If `fake_borrows` is Some, then places which need fake borrows\n     /// will be added to it.\n     fn match_candidates<'pat>(\n         &mut self,\n         span: Span,\n-        arm_blocks: &mut ArmBlocks,\n-        mut candidates: Vec<Candidate<'pat, 'tcx>>,\n+        candidates: &mut [&mut Candidate<'pat, 'tcx>],\n         mut block: BasicBlock,\n         fake_borrows: &mut Option<FxHashMap<Place<'tcx>, BorrowKind>>,\n     ) -> Vec<BasicBlock> {\n@@ -762,17 +811,16 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             span, block, candidates\n         );\n \n-        // Start by simplifying candidates. Once this process is\n-        // complete, all the match pairs which remain require some\n-        // form of test, whether it be a switch or pattern comparison.\n-        for candidate in &mut candidates {\n+        // Start by simplifying candidates. Once this process is complete, all\n+        // the match pairs which remain require some form of test, whether it\n+        // be a switch or pattern comparison.\n+        for candidate in &mut *candidates {\n             self.simplify_candidate(candidate);\n         }\n \n-        // The candidates are sorted by priority. Check to see\n-        // whether the higher priority candidates (and hence at\n-        // the front of the vec) have satisfied all their match\n-        // pairs.\n+        // The candidates are sorted by priority. Check to see whether the\n+        // higher priority candidates (and hence at the front of the slice)\n+        // have satisfied all their match pairs.\n         let fully_matched = candidates\n             .iter()\n             .take_while(|c| c.match_pairs.is_empty())\n@@ -781,87 +829,172 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             \"match_candidates: {:?} candidates fully matched\",\n             fully_matched\n         );\n-        let mut unmatched_candidates = candidates.split_off(fully_matched);\n+        let (matched_candidates, unmatched_candidates) = candidates.split_at_mut(fully_matched);\n+\n+        if !matched_candidates.is_empty() {\n+            block = if let Some(last_otherwise_block) = self.select_matched_candidates(\n+                matched_candidates,\n+                block,\n+                fake_borrows,\n+            ) {\n+                last_otherwise_block\n+            } else {\n+                // Any remaining candidates are unreachable.\n+                if unmatched_candidates.is_empty() {\n+                    return Vec::new();\n+                } else {\n+                    self.cfg.start_new_block()\n+                }\n+            };\n+        }\n+\n+        // If there are no candidates that still need testing, we're\n+        // done. Since all matches are exhaustive, execution should\n+        // never reach this point.\n+        if unmatched_candidates.is_empty() {\n+            return vec![block];\n+        }\n+\n+        // Test candidates where possible.\n+        let (otherwise, untested_candidates) = self.test_candidates(\n+            span,\n+            unmatched_candidates,\n+            block,\n+            fake_borrows,\n+        );\n+\n+        // If the target candidates were exhaustive, then we are done.\n+        // But for borrowck continue build decision tree.\n+        if untested_candidates.is_empty() {\n+            return otherwise;\n+        }\n+\n+        // Otherwise, let's process those remaining candidates.\n+        let join_block = self.join_otherwise_blocks(span, otherwise);\n+        self.match_candidates(\n+            span,\n+            untested_candidates,\n+            join_block,\n+            &mut None,\n+        )\n+    }\n+\n+    /// Link up matched candidates. For example, if we have something like\n+    /// this:\n+    ///\n+    /// ...\n+    /// Some(x) if cond => ...\n+    /// Some(x) => ...\n+    /// Some(x) if cond => ...\n+    /// ...\n+    ///\n+    /// We generate real edges from:\n+    /// * `block` to the prebinding_block of the first pattern,\n+    /// * the otherwise block of the first pattern to the second pattern,\n+    /// * the otherwise block of the third pattern to the a block with an\n+    ///   Unreachable terminator.\n+    ///\n+    /// As well as that we add fake edges from the otherwise blocks to the\n+    /// prebinding block of the next candidate in the original set of\n+    /// candidates.\n+    fn select_matched_candidates(\n+        &mut self,\n+        matched_candidates: &mut [&mut Candidate<'_, 'tcx>],\n+        block: BasicBlock,\n+        fake_borrows: &mut Option<FxHashMap<Place<'tcx>, BorrowKind>>,\n+    ) -> Option<BasicBlock> {\n+        debug_assert!(\n+            !matched_candidates.is_empty(),\n+            \"select_matched_candidates called with no candidates\",\n+        );\n \n         // Insert a *Shared* borrow of any places that are bound.\n         if let Some(fake_borrows) = fake_borrows {\n             for Binding { source, .. }\n-                in candidates.iter().flat_map(|candidate| &candidate.bindings)\n+                in matched_candidates.iter().flat_map(|candidate| &candidate.bindings)\n             {\n                 fake_borrows.insert(source.clone(), BorrowKind::Shared);\n             }\n         }\n \n-        let fully_matched_with_guard = candidates.iter().take_while(|c| c.guard.is_some()).count();\n+        let fully_matched_with_guard = matched_candidates\n+            .iter()\n+            .position(|c| c.otherwise_block.is_none())\n+            .unwrap_or(matched_candidates.len() - 1);\n \n-        let unreachable_candidates = if fully_matched_with_guard + 1 < candidates.len() {\n-            candidates.split_off(fully_matched_with_guard + 1)\n-        } else {\n-            vec![]\n-        };\n+        let (reachable_candidates, unreachable_candidates)\n+            = matched_candidates.split_at_mut(fully_matched_with_guard + 1);\n \n-        for candidate in candidates {\n-            // If so, apply any bindings, test the guard (if any), and\n-            // branch to the arm.\n-            if let Some(b) = self.bind_and_guard_matched_candidate(block, arm_blocks, candidate) {\n-                block = b;\n-            } else {\n-                // if None is returned, then any remaining candidates\n-                // are unreachable (at least not through this path).\n-                // Link them with false edges.\n-                debug!(\n-                    \"match_candidates: add false edges for unreachable {:?} and unmatched {:?}\",\n-                    unreachable_candidates, unmatched_candidates\n-                );\n-                for candidate in unreachable_candidates {\n-                    let source_info = self.source_info(candidate.span);\n-                    let target = self.cfg.start_new_block();\n-                    if let Some(otherwise) =\n-                        self.bind_and_guard_matched_candidate(target, arm_blocks, candidate)\n-                    {\n-                        self.cfg\n-                            .terminate(otherwise, source_info, TerminatorKind::Unreachable);\n-                    }\n-                }\n+        let first_candidate = &reachable_candidates[0];\n \n-                if unmatched_candidates.is_empty() {\n-                    return vec![];\n+        let candidate_source_info = self.source_info(first_candidate.span);\n+\n+        self.cfg.terminate(\n+            block,\n+            candidate_source_info,\n+            TerminatorKind::Goto {\n+                target: first_candidate.pre_binding_block,\n+            },\n+        );\n+\n+        for window in reachable_candidates.windows(2) {\n+            if let [first_candidate, second_candidate] = window {\n+                let source_info = self.source_info(first_candidate.span);\n+                if let Some(otherwise_block) = first_candidate.otherwise_block {\n+                    self.cfg.terminate(\n+                        otherwise_block,\n+                        source_info,\n+                        TerminatorKind::FalseEdges {\n+                            real_target: second_candidate.pre_binding_block,\n+                            imaginary_targets: vec![\n+                                first_candidate.next_candidate_pre_binding_block\n+                            ],\n+                        }\n+                    )\n                 } else {\n-                    let target = self.cfg.start_new_block();\n-                    return self.match_candidates(\n-                        span,\n-                        arm_blocks,\n-                        unmatched_candidates,\n-                        target,\n-                        &mut None,\n-                    );\n+                    bug!(\"candidate other than the last has no guard\");\n                 }\n+            } else {\n+                bug!(\"<[_]>::windows returned incorrectly sized window\");\n             }\n         }\n \n-        // If there are no candidates that still need testing, we're done.\n-        // Since all matches are exhaustive, execution should never reach this point.\n-        if unmatched_candidates.is_empty() {\n-            return vec![block];\n-        }\n \n-        // Test candidates where possible.\n-        let (otherwise, tested_candidates) =\n-            self.test_candidates(span, arm_blocks, &unmatched_candidates, block, fake_borrows);\n+        // if None is returned, then\n+        debug!(\"match_candidates: add false edges for unreachable {:?}\", unreachable_candidates);\n+        for candidate in unreachable_candidates {\n+            if let Some(otherwise) = candidate.otherwise_block {\n+                let source_info = self.source_info(candidate.span);\n+                let unreachable = self.cfg.start_new_block();\n+                self.cfg.terminate(\n+                    otherwise,\n+                    source_info,\n+                    TerminatorKind::FalseEdges {\n+                        real_target: unreachable,\n+                        imaginary_targets: vec![candidate.next_candidate_pre_binding_block],\n+                    }\n+                );\n+                self.cfg.terminate(unreachable, source_info, TerminatorKind::Unreachable);\n+            }\n+        }\n \n-        // If the target candidates were exhaustive, then we are done.\n-        // But for borrowck continue build decision tree.\n+        let last_candidate = reachable_candidates.last().unwrap();\n \n-        // If all candidates were sorted into `target_candidates` somewhere, then\n-        // the initial set was inexhaustive.\n-        let untested_candidates = unmatched_candidates.split_off(tested_candidates);\n-        if untested_candidates.len() == 0 {\n-            return otherwise;\n+        if let Some(otherwise) = last_candidate.otherwise_block {\n+            let source_info = self.source_info(last_candidate.span);\n+            let block = self.cfg.start_new_block();\n+            self.cfg.terminate(\n+                otherwise,\n+                source_info,\n+                TerminatorKind::FalseEdges {\n+                    real_target: block,\n+                    imaginary_targets: vec![last_candidate.next_candidate_pre_binding_block]\n+                }\n+            );\n+            Some(block)\n+        } else {\n+            None\n         }\n-\n-        // Otherwise, let's process those remaining candidates.\n-        let join_block = self.join_otherwise_blocks(span, otherwise);\n-        self.match_candidates(span, arm_blocks, untested_candidates, join_block, &mut None)\n     }\n \n     fn join_otherwise_blocks(&mut self, span: Span, mut otherwise: Vec<BasicBlock>) -> BasicBlock {\n@@ -995,17 +1128,17 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// In addition to avoiding exponential-time blowups, this algorithm\n     /// also has nice property that each guard and arm is only generated\n     /// once.\n-    fn test_candidates<'pat>(\n+    fn test_candidates<'pat, 'b, 'c>(\n         &mut self,\n         span: Span,\n-        arm_blocks: &mut ArmBlocks,\n-        candidates: &[Candidate<'pat, 'tcx>],\n+        mut candidates: &'b mut [&'c mut Candidate<'pat, 'tcx>],\n         block: BasicBlock,\n         fake_borrows: &mut Option<FxHashMap<Place<'tcx>, BorrowKind>>,\n-    ) -> (Vec<BasicBlock>, usize) {\n+    ) -> (Vec<BasicBlock>, &'b mut [&'c mut Candidate<'pat, 'tcx>]) {\n         // extract the match-pair from the highest priority candidate\n         let match_pair = &candidates.first().unwrap().match_pairs[0];\n         let mut test = self.test(match_pair);\n+        let match_place = match_pair.place.clone();\n \n         // most of the time, the test to perform is simply a function\n         // of the main candidate; but for a test like SwitchInt, we\n@@ -1019,7 +1152,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             } => {\n                 for candidate in candidates.iter() {\n                     if !self.add_cases_to_switch(\n-                        &match_pair.place,\n+                        &match_place,\n                         candidate,\n                         switch_ty,\n                         options,\n@@ -1034,7 +1167,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 ref mut variants,\n             } => {\n                 for candidate in candidates.iter() {\n-                    if !self.add_variants_to_switch(&match_pair.place, candidate, variants) {\n+                    if !self.add_variants_to_switch(&match_place, candidate, variants) {\n                         break;\n                     }\n                 }\n@@ -1044,7 +1177,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         // Insert a Shallow borrow of any places that is switched on.\n         fake_borrows.as_mut().map(|fb| {\n-            fb.entry(match_pair.place.clone()).or_insert(BorrowKind::Shallow)\n+            fb.entry(match_place.clone()).or_insert(BorrowKind::Shallow)\n         });\n \n         // perform the test, branching to one of N blocks. For each of\n@@ -1055,25 +1188,29 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             \"match_candidates: test={:?} match_pair={:?}\",\n             test, match_pair\n         );\n-        let target_blocks = self.perform_test(block, &match_pair.place, &test);\n-        let mut target_candidates = vec![vec![]; target_blocks.len()];\n+        let target_blocks = self.perform_test(block, &match_place, &test);\n+        let mut target_candidates: Vec<Vec<&mut Candidate<'pat, 'tcx>>> = vec![];\n+        target_candidates.resize_with(target_blocks.len(), Default::default);\n+\n+        let total_candidate_count = candidates.len();\n \n         // Sort the candidates into the appropriate vector in\n         // `target_candidates`. Note that at some point we may\n         // encounter a candidate where the test is not relevant; at\n         // that point, we stop sorting.\n-        let tested_candidates = candidates\n-            .iter()\n-            .take_while(|c| {\n-                self.sort_candidate(&match_pair.place, &test, c, &mut target_candidates)\n-            })\n-            .count();\n-        assert!(tested_candidates > 0); // at least the last candidate ought to be tested\n-        debug!(\"tested_candidates: {}\", tested_candidates);\n-        debug!(\n-            \"untested_candidates: {}\",\n-            candidates.len() - tested_candidates\n-        );\n+        while let Some(candidate) = candidates.first_mut() {\n+            if let Some(idx) = self.sort_candidate(&match_place, &test, candidate) {\n+                let (candidate, rest) = candidates.split_first_mut().unwrap();\n+                target_candidates[idx].push(candidate);\n+                candidates = rest;\n+            } else {\n+                break;\n+            }\n+        }\n+        // at least the first candidate ought to be tested\n+        assert!(total_candidate_count > candidates.len());\n+        debug!(\"tested_candidates: {}\", total_candidate_count - candidates.len());\n+        debug!(\"untested_candidates: {}\", candidates.len());\n \n         // For each outcome of test, process the candidates that still\n         // apply. Collect a list of blocks where control flow will\n@@ -1082,59 +1219,99 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let otherwise: Vec<_> = target_blocks\n             .into_iter()\n             .zip(target_candidates)\n-            .flat_map(|(target_block, target_candidates)| {\n+            .flat_map(|(target_block, mut target_candidates)| {\n                 self.match_candidates(\n                     span,\n-                    arm_blocks,\n-                    target_candidates,\n+                    &mut *target_candidates,\n                     target_block,\n                     fake_borrows,\n                 )\n             })\n             .collect();\n \n-        (otherwise, tested_candidates)\n+        (otherwise, candidates)\n+    }\n+\n+    // Determine the fake borrows that are needed to ensure that the place\n+    // will evaluate to the same thing until an arm has been chosen.\n+    fn calculate_fake_borrows<'b>(\n+        &mut self,\n+        fake_borrows: &'b FxHashMap<Place<'tcx>, BorrowKind>,\n+        temp_span: Span,\n+    ) -> Vec<(&'b Place<'tcx>, BorrowKind, Local)> {\n+        let tcx = self.hir.tcx();\n+\n+        debug!(\"add_fake_borrows fake_borrows = {:?}\", fake_borrows);\n+\n+        let mut all_fake_borrows = Vec::with_capacity(fake_borrows.len());\n+\n+        // Insert a Shallow borrow of the prefixes of any fake borrows.\n+        for (place, borrow_kind) in fake_borrows\n+        {\n+            let mut prefix_cursor = place;\n+            while let Place::Projection(box Projection { base, elem }) = prefix_cursor {\n+                if let ProjectionElem::Deref = elem {\n+                    // Insert a shallow borrow after a deref. For other\n+                    // projections the borrow of prefix_cursor will\n+                    // conflict with any mutation of base.\n+                    all_fake_borrows.push((base, BorrowKind::Shallow));\n+                }\n+                prefix_cursor = base;\n+            }\n+\n+            all_fake_borrows.push((place, *borrow_kind));\n+        }\n+\n+        // Deduplicate and ensure a deterministic order.\n+        all_fake_borrows.sort();\n+        all_fake_borrows.dedup();\n+\n+        debug!(\"add_fake_borrows all_fake_borrows = {:?}\", all_fake_borrows);\n+\n+        all_fake_borrows.into_iter().map(|(matched_place, borrow_kind)| {\n+            let fake_borrow_deref_ty = matched_place.ty(&self.local_decls, tcx).to_ty(tcx);\n+            let fake_borrow_ty = tcx.mk_imm_ref(tcx.types.re_erased, fake_borrow_deref_ty);\n+            let fake_borrow_temp = self.local_decls.push(\n+                LocalDecl::new_temp(fake_borrow_ty, temp_span)\n+            );\n+\n+            (matched_place, borrow_kind, fake_borrow_temp)\n+        }).collect()\n     }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Pattern binding - used for `let` and function parameters as well.\n \n+impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Initializes each of the bindings from the candidate by\n-    /// moving/copying/ref'ing the source as appropriate. Tests the\n-    /// guard, if any, and then branches to the arm. Returns the block\n-    /// for the case where the guard fails.\n+    /// moving/copying/ref'ing the source as appropriate. Tests the guard, if\n+    /// any, and then branches to the arm. Returns the block for the case where\n+    /// the guard fails.\n     ///\n-    /// Note: we check earlier that if there is a guard, there cannot\n-    /// be move bindings. This isn't really important for the\n-    /// self-consistency of this fn, but the reason for it should be\n-    /// clear: after we've done the assignments, if there were move\n-    /// bindings, further tests would be a use-after-move (which would\n-    /// in turn be detected by the borrowck code that runs on the\n-    /// MIR).\n+    /// Note: we check earlier that if there is a guard, there cannot be move\n+    /// bindings (unless feature(bind_by_move_pattern_guards) is used). This\n+    /// isn't really important for the self-consistency of this fn, but the\n+    /// reason for it should be clear: after we've done the assignments, if\n+    /// there were move bindings, further tests would be a use-after-move.\n+    /// bind_by_move_pattern_guards avoids this by only moving the binding once\n+    /// the guard has evaluated to true (see below).\n     fn bind_and_guard_matched_candidate<'pat>(\n         &mut self,\n-        mut block: BasicBlock,\n-        arm_blocks: &mut ArmBlocks,\n         candidate: Candidate<'pat, 'tcx>,\n-    ) -> Option<BasicBlock> {\n-        debug!(\n-            \"bind_and_guard_matched_candidate(block={:?}, candidate={:?})\",\n-            block, candidate\n-        );\n+        guard: Option<Guard<'tcx>>,\n+        arm_block: BasicBlock,\n+        fake_borrows: &Vec<(&Place<'tcx>, BorrowKind, Local)>,\n+        discriminant_span: Span,\n+        pat_index: usize,\n+    ) {\n+        debug!(\"bind_and_guard_matched_candidate(candidate={:?})\", candidate);\n \n         debug_assert!(candidate.match_pairs.is_empty());\n \n-        self.ascribe_types(block, &candidate.ascriptions);\n-\n-        let arm_block = arm_blocks.blocks[candidate.arm_index];\n         let candidate_source_info = self.source_info(candidate.span);\n \n-        self.cfg.terminate(\n-            block,\n-            candidate_source_info,\n-            TerminatorKind::Goto {\n-                target: candidate.pre_binding_block,\n-            },\n-        );\n-\n-        block = self.cfg.start_new_block();\n+        let mut block = self.cfg.start_new_block();\n         self.cfg.terminate(\n             candidate.pre_binding_block,\n             candidate_source_info,\n@@ -1143,6 +1320,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 imaginary_targets: vec![candidate.next_candidate_pre_binding_block],\n             },\n         );\n+        self.ascribe_types(block, &candidate.ascriptions);\n \n         // rust-lang/rust#27282: The `autoref` business deserves some\n         // explanation here.\n@@ -1226,14 +1404,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         //      match input itself; it is up to us to create a place\n         //      holding a `&` or `&mut` that we can then borrow).\n \n-        let autoref = self.hir\n-            .tcx()\n-            .all_pat_vars_are_implicit_refs_within_guards();\n-        if let Some(guard) = candidate.guard {\n+        let tcx = self.hir.tcx();\n+        let autoref = tcx.all_pat_vars_are_implicit_refs_within_guards();\n+        if let Some(guard) = guard {\n             if autoref {\n                 self.bind_matched_candidate_for_guard(\n                     block,\n-                    candidate.pat_index,\n+                    pat_index,\n                     &candidate.bindings,\n                 );\n                 let guard_frame = GuardFrame {\n@@ -1249,12 +1426,29 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 self.bind_matched_candidate_for_arm_body(block, &candidate.bindings);\n             }\n \n+            let re_erased = tcx.types.re_erased;\n+            let discriminant_source_info = self.source_info(discriminant_span);\n+            for &(place, borrow_kind, temp) in fake_borrows {\n+                let borrow = Rvalue::Ref(\n+                    re_erased,\n+                    borrow_kind,\n+                    place.clone(),\n+                );\n+                self.cfg.push_assign(\n+                    block,\n+                    discriminant_source_info,\n+                    &Place::Local(temp),\n+                    borrow,\n+                );\n+            }\n+\n             // the block to branch to if the guard fails; if there is no\n             // guard, this block is simply unreachable\n             let guard = match guard {\n                 Guard::If(e) => self.hir.mirror(e),\n             };\n             let source_info = self.source_info(guard.span);\n+            let guard_end = self.source_info(tcx.sess.source_map().end_point(guard.span));\n             let cond = unpack!(block = self.as_local_operand(block, guard));\n             if autoref {\n                 let guard_frame = self.guard_context.pop().unwrap();\n@@ -1264,7 +1458,15 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 );\n             }\n \n-            let false_edge_block = self.cfg.start_new_block();\n+            for &(_, _, temp) in fake_borrows {\n+                self.cfg.push(block, Statement {\n+                    source_info: guard_end,\n+                    kind: StatementKind::FakeRead(\n+                        FakeReadCause::ForMatchGuard,\n+                        Place::Local(temp),\n+                    ),\n+                });\n+            }\n \n             // We want to ensure that the matched candidates are bound\n             // after we have confirmed this candidate *and* any\n@@ -1296,7 +1498,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             self.cfg.terminate(\n                 block,\n                 source_info,\n-                TerminatorKind::if_(self.hir.tcx(), cond, post_guard_block, false_edge_block),\n+                TerminatorKind::if_(\n+                    self.hir.tcx(),\n+                    cond,\n+                    post_guard_block,\n+                    candidate.otherwise_block.unwrap()\n+                ),\n             );\n \n             if autoref {\n@@ -1308,19 +1515,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 source_info,\n                 TerminatorKind::Goto { target: arm_block },\n             );\n-\n-            let otherwise = self.cfg.start_new_block();\n-\n-            self.cfg.terminate(\n-                false_edge_block,\n-                source_info,\n-                TerminatorKind::FalseEdges {\n-                    real_target: otherwise,\n-                    imaginary_targets: vec![candidate.next_candidate_pre_binding_block],\n-                },\n-            );\n-            Some(otherwise)\n         } else {\n+            assert!(candidate.otherwise_block.is_none());\n             // (Here, it is not too early to bind the matched\n             // candidate on `block`, because there is no guard result\n             // that we have to inspect before we bind them.)\n@@ -1330,7 +1526,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 candidate_source_info,\n                 TerminatorKind::Goto { target: arm_block },\n             );\n-            None\n         }\n     }\n \n@@ -1397,8 +1592,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             let ref_for_guard =\n                 self.storage_live_binding(block, binding.var_id, binding.span, RefWithinGuard);\n             // Question: Why schedule drops if bindings are all\n-            // shared-&'s?  Answer: Because schedule_drop_for_binding\n-            // also emits StorageDead's for those locals.\n+            // shared-&'s?\n+            // Answer: Because schedule_drop_for_binding also emits\n+            // StorageDead's for those locals.\n             self.schedule_drop_for_binding(binding.var_id, binding.span, RefWithinGuard);\n             match binding.binding_mode {\n                 BindingMode::ByValue => {\n@@ -1585,86 +1781,4 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         debug!(\"declare_binding: vars={:?}\", locals);\n         self.var_indices.insert(var_id, locals);\n     }\n-\n-    // Determine the fake borrows that are needed to ensure that the place\n-    // will evaluate to the same thing until an arm has been chosen.\n-    fn add_fake_borrows<'pat>(\n-        &mut self,\n-        pre_binding_blocks: &[(BasicBlock, Span)],\n-        fake_borrows: FxHashMap<Place<'tcx>, BorrowKind>,\n-        source_info: SourceInfo,\n-        start_block: BasicBlock,\n-    ) {\n-        let tcx = self.hir.tcx();\n-\n-        debug!(\"add_fake_borrows pre_binding_blocks = {:?}, fake_borrows = {:?}\",\n-               pre_binding_blocks, fake_borrows);\n-\n-        let mut all_fake_borrows = Vec::with_capacity(fake_borrows.len());\n-\n-        // Insert a Shallow borrow of the prefixes of any fake borrows.\n-        for (place, borrow_kind) in fake_borrows\n-        {\n-            {\n-                let mut prefix_cursor = &place;\n-                while let Place::Projection(box Projection { base, elem }) = prefix_cursor {\n-                    if let ProjectionElem::Deref = elem {\n-                        // Insert a shallow borrow after a deref. For other\n-                        // projections the borrow of prefix_cursor will\n-                        // conflict with any mutation of base.\n-                        all_fake_borrows.push((base.clone(), BorrowKind::Shallow));\n-                    }\n-                    prefix_cursor = base;\n-                }\n-            }\n-\n-            all_fake_borrows.push((place, borrow_kind));\n-        }\n-\n-        // Deduplicate and ensure a deterministic order.\n-        all_fake_borrows.sort();\n-        all_fake_borrows.dedup();\n-\n-        debug!(\"add_fake_borrows all_fake_borrows = {:?}\", all_fake_borrows);\n-\n-        // Add fake borrows to the start of the match and reads of them before\n-        // the start of each arm.\n-        let mut borrowed_input_temps = Vec::with_capacity(all_fake_borrows.len());\n-\n-        for (matched_place, borrow_kind) in all_fake_borrows {\n-            let borrowed_input =\n-                Rvalue::Ref(tcx.types.re_erased, borrow_kind, matched_place.clone());\n-            let borrowed_input_ty = borrowed_input.ty(&self.local_decls, tcx);\n-            let borrowed_input_temp = self.temp(borrowed_input_ty, source_info.span);\n-            self.cfg.push_assign(\n-                start_block,\n-                source_info,\n-                &borrowed_input_temp,\n-                borrowed_input\n-            );\n-            borrowed_input_temps.push(borrowed_input_temp);\n-        }\n-\n-        // FIXME: This could be a lot of reads (#fake borrows * #patterns).\n-        // The false edges that we currently generate would allow us to only do\n-        // this on the last Candidate, but it's possible that there might not be\n-        // so many false edges in the future, so we read for all Candidates for\n-        // now.\n-        // Another option would be to make our own block and add our own false\n-        // edges to it.\n-        if tcx.emit_read_for_match() {\n-            for &(pre_binding_block, span) in pre_binding_blocks {\n-                let pattern_source_info = self.source_info(span);\n-                for temp in &borrowed_input_temps {\n-                    self.cfg.push(pre_binding_block, Statement {\n-                        source_info: pattern_source_info,\n-                        kind: StatementKind::FakeRead(\n-                            FakeReadCause::ForMatchGuard,\n-                            temp.clone(),\n-                        ),\n-                    });\n-                }\n-            }\n-        }\n-    }\n }"}, {"sha": "72b92444dece9be37883af5998213616f8d597b5", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 99, "deletions": 167, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/d51b5cdd82ec0e36212fc75b83652372980d56ca/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51b5cdd82ec0e36212fc75b83652372980d56ca/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=d51b5cdd82ec0e36212fc75b83652372980d56ca", "patch": "@@ -69,8 +69,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            PatternKind::Slice { ref prefix, ref slice, ref suffix }\n-                    if !match_pair.slice_len_checked => {\n+            PatternKind::Slice { ref prefix, ref slice, ref suffix } => {\n                 let len = prefix.len() + suffix.len();\n                 let op = if slice.is_some() {\n                     BinOp::Ge\n@@ -85,7 +84,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n             PatternKind::AscribeUserType { .. } |\n             PatternKind::Array { .. } |\n-            PatternKind::Slice { .. } |\n             PatternKind::Wild |\n             PatternKind::Binding { .. } |\n             PatternKind::Leaf { .. } |\n@@ -433,77 +431,65 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         target_block\n     }\n \n-    /// Given that we are performing `test` against `test_place`,\n-    /// this job sorts out what the status of `candidate` will be\n-    /// after the test. The `resulting_candidates` vector stores, for\n-    /// each possible outcome of `test`, a vector of the candidates\n-    /// that will result. This fn should add a (possibly modified)\n-    /// clone of candidate into `resulting_candidates` wherever\n-    /// appropriate.\n+    /// Given that we are performing `test` against `test_place`, this job\n+    /// sorts out what the status of `candidate` will be after the test. See\n+    /// `test_candidates` for the usage of this function. The returned index is\n+    /// the index that this candiate should be placed in the\n+    /// `target_candidates` vec. The candidate may be modified to update its\n+    /// `match_pairs`.\n     ///\n-    /// So, for example, if this candidate is `x @ Some(P0)` and the\n-    /// Tests is a variant test, then we would add `(x as Option).0 @\n-    /// P0` to the `resulting_candidates` entry corresponding to the\n-    /// variant `Some`.\n+    /// So, for example, if this candidate is `x @ Some(P0)` and the `Test` is\n+    /// a variant test, then we would modify the candidate to be `(x as\n+    /// Option).0 @ P0` and return the index corresponding to the variant\n+    /// `Some`.\n     ///\n-    /// However, in some cases, the test may just not be relevant to\n-    /// candidate. For example, suppose we are testing whether `foo.x == 22`,\n-    /// but in one match arm we have `Foo { x: _, ... }`... in that case,\n-    /// the test for what value `x` has has no particular relevance\n-    /// to this candidate. In such cases, this function just returns false\n-    /// without doing anything. This is used by the overall `match_candidates`\n-    /// algorithm to structure the match as a whole. See `match_candidates` for\n-    /// more details.\n+    /// However, in some cases, the test may just not be relevant to candidate.\n+    /// For example, suppose we are testing whether `foo.x == 22`, but in one\n+    /// match arm we have `Foo { x: _, ... }`... in that case, the test for\n+    /// what value `x` has has no particular relevance to this candidate. In\n+    /// such cases, this function just returns None without doing anything.\n+    /// This is used by the overall `match_candidates` algorithm to structure\n+    /// the match as a whole. See `match_candidates` for more details.\n     ///\n-    /// FIXME(#29623). In some cases, we have some tricky choices to\n-    /// make.  for example, if we are testing that `x == 22`, but the\n-    /// candidate is `x @ 13..55`, what should we do? In the event\n-    /// that the test is true, we know that the candidate applies, but\n-    /// in the event of false, we don't know that it *doesn't*\n-    /// apply. For now, we return false, indicate that the test does\n-    /// not apply to this candidate, but it might be we can get\n+    /// FIXME(#29623). In some cases, we have some tricky choices to make.  for\n+    /// example, if we are testing that `x == 22`, but the candidate is `x @\n+    /// 13..55`, what should we do? In the event that the test is true, we know\n+    /// that the candidate applies, but in the event of false, we don't know\n+    /// that it *doesn't* apply. For now, we return false, indicate that the\n+    /// test does not apply to this candidate, but it might be we can get\n     /// tighter match code if we do something a bit different.\n-    pub fn sort_candidate<'pat>(&mut self,\n-                                test_place: &Place<'tcx>,\n-                                test: &Test<'tcx>,\n-                                candidate: &Candidate<'pat, 'tcx>,\n-                                resulting_candidates: &mut [Vec<Candidate<'pat, 'tcx>>])\n-                                -> bool {\n+    pub fn sort_candidate<'pat, 'cand>(\n+        &mut self,\n+        test_place: &Place<'tcx>,\n+        test: &Test<'tcx>,\n+        candidate: &mut Candidate<'pat, 'tcx>,\n+    ) -> Option<usize> {\n         // Find the match_pair for this place (if any). At present,\n         // afaik, there can be at most one. (In the future, if we\n         // adopted a more general `@` operator, there might be more\n         // than one, but it'd be very unusual to have two sides that\n         // both require tests; you'd expect one side to be simplified\n         // away.)\n-        let tested_match_pair = candidate.match_pairs.iter()\n-                                                     .enumerate()\n-                                                     .find(|&(_, mp)| mp.place == *test_place);\n-        let (match_pair_index, match_pair) = match tested_match_pair {\n-            Some(pair) => pair,\n-            None => {\n-                // We are not testing this place. Therefore, this\n-                // candidate applies to ALL outcomes.\n-                return false;\n-            }\n-        };\n+        let (match_pair_index, match_pair) = candidate.match_pairs\n+            .iter()\n+            .enumerate()\n+            .find(|&(_, mp)| mp.place == *test_place)?;\n \n         match (&test.kind, &*match_pair.pattern.kind) {\n             // If we are performing a variant switch, then this\n             // informs variant patterns, but nothing else.\n             (&TestKind::Switch { adt_def: tested_adt_def, .. },\n              &PatternKind::Variant { adt_def, variant_index, ref subpatterns, .. }) => {\n                 assert_eq!(adt_def, tested_adt_def);\n-                let new_candidate =\n-                    self.candidate_after_variant_switch(match_pair_index,\n-                                                        adt_def,\n-                                                        variant_index,\n-                                                        subpatterns,\n-                                                        candidate);\n-                resulting_candidates[variant_index.as_usize()].push(new_candidate);\n-                true\n+                self.candidate_after_variant_switch(match_pair_index,\n+                                                    adt_def,\n+                                                    variant_index,\n+                                                    subpatterns,\n+                                                    candidate);\n+                Some(variant_index.as_usize())\n             }\n \n-            (&TestKind::Switch { .. }, _) => false,\n+            (&TestKind::Switch { .. }, _) => None,\n \n             // If we are performing a switch over integers, then this informs integer\n             // equality, but nothing else.\n@@ -514,10 +500,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n              &PatternKind::Constant { ref value })\n             if is_switch_ty(match_pair.pattern.ty) => {\n                 let index = indices[value];\n-                let new_candidate = self.candidate_without_match_pair(match_pair_index,\n-                                                                      candidate);\n-                resulting_candidates[index].push(new_candidate);\n-                true\n+                self.candidate_without_match_pair(match_pair_index, candidate);\n+                Some(index)\n             }\n \n             (&TestKind::SwitchInt { switch_ty: _, ref options, ref indices },\n@@ -530,14 +514,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     // No switch values are contained in the pattern range,\n                     // so the pattern can be matched only if this test fails.\n                     let otherwise = options.len();\n-                    resulting_candidates[otherwise].push(candidate.clone());\n-                    true\n+                    Some(otherwise)\n                 } else {\n-                    false\n+                    None\n                 }\n             }\n \n-            (&TestKind::SwitchInt { .. }, _) => false,\n+            (&TestKind::SwitchInt { .. }, _) => None,\n \n             (&TestKind::Len { len: test_len, op: BinOp::Eq },\n              &PatternKind::Slice { ref prefix, ref slice, ref suffix }) => {\n@@ -546,32 +529,28 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     (Ordering::Equal, &None) => {\n                         // on true, min_len = len = $actual_length,\n                         // on false, len != $actual_length\n-                        resulting_candidates[0].push(\n-                            self.candidate_after_slice_test(match_pair_index,\n-                                                            candidate,\n-                                                            prefix,\n-                                                            slice.as_ref(),\n-                                                            suffix)\n-                        );\n-                        true\n+                        self.candidate_after_slice_test(match_pair_index,\n+                                                        candidate,\n+                                                        prefix,\n+                                                        slice.as_ref(),\n+                                                        suffix);\n+                        Some(0)\n                     }\n                     (Ordering::Less, _) => {\n                         // test_len < pat_len. If $actual_len = test_len,\n                         // then $actual_len < pat_len and we don't have\n                         // enough elements.\n-                        resulting_candidates[1].push(candidate.clone());\n-                        true\n+                        Some(1)\n                     }\n                     (Ordering::Equal, &Some(_)) | (Ordering::Greater, &Some(_)) => {\n                         // This can match both if $actual_len = test_len >= pat_len,\n                         // and if $actual_len > test_len. We can't advance.\n-                        false\n+                        None\n                     }\n                     (Ordering::Greater, &None) => {\n                         // test_len != pat_len, so if $actual_len = test_len, then\n                         // $actual_len != pat_len.\n-                        resulting_candidates[1].push(candidate.clone());\n-                        true\n+                        Some(1)\n                     }\n                 }\n             }\n@@ -584,45 +563,40 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     (Ordering::Equal, &Some(_))  => {\n                         // $actual_len >= test_len = pat_len,\n                         // so we can match.\n-                        resulting_candidates[0].push(\n-                            self.candidate_after_slice_test(match_pair_index,\n-                                                            candidate,\n-                                                            prefix,\n-                                                            slice.as_ref(),\n-                                                            suffix)\n-                        );\n-                        true\n+                        self.candidate_after_slice_test(match_pair_index,\n+                                                        candidate,\n+                                                        prefix,\n+                                                        slice.as_ref(),\n+                                                        suffix);\n+                        Some(0)\n                     }\n                     (Ordering::Less, _) | (Ordering::Equal, &None) => {\n                         // test_len <= pat_len. If $actual_len < test_len,\n                         // then it is also < pat_len, so the test passing is\n                         // necessary (but insufficient).\n-                        resulting_candidates[0].push(candidate.clone());\n-                        true\n+                        Some(0)\n                     }\n                     (Ordering::Greater, &None) => {\n                         // test_len > pat_len. If $actual_len >= test_len > pat_len,\n                         // then we know we won't have a match.\n-                        resulting_candidates[1].push(candidate.clone());\n-                        true\n+                        Some(1)\n                     }\n                     (Ordering::Greater, &Some(_)) => {\n                         // test_len < pat_len, and is therefore less\n                         // strict. This can still go both ways.\n-                        false\n+                        None\n                     }\n                 }\n             }\n \n             (&TestKind::Range(test),\n              &PatternKind::Range(pat)) => {\n                 if test == pat {\n-                    resulting_candidates[0]\n-                        .push(self.candidate_without_match_pair(\n-                            match_pair_index,\n-                            candidate,\n-                        ));\n-                    return true;\n+                    self.candidate_without_match_pair(\n+                        match_pair_index,\n+                        candidate,\n+                    );\n+                    return Some(0);\n                 }\n \n                 let no_overlap = (|| {\n@@ -649,26 +623,23 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 if no_overlap == Some(true) {\n                     // Testing range does not overlap with pattern range,\n                     // so the pattern can be matched only if this test fails.\n-                    resulting_candidates[1].push(candidate.clone());\n-                    true\n+                    Some(1)\n                 } else {\n-                    false\n+                    None\n                 }\n             }\n \n             (&TestKind::Range(range), &PatternKind::Constant { value }) => {\n                 if self.const_range_contains(range, value) == Some(false) {\n                     // `value` is not contained in the testing range,\n                     // so `value` can be matched only if this test fails.\n-                    resulting_candidates[1].push(candidate.clone());\n-                    true\n+                    Some(1)\n                 } else {\n-                    false\n+                    None\n                 }\n             }\n \n-            (&TestKind::Range { .. }, _) => false,\n-\n+            (&TestKind::Range { .. }, _) => None,\n \n             (&TestKind::Eq { .. }, _) |\n             (&TestKind::Len { .. }, _) => {\n@@ -677,73 +648,53 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // FIXME(#29623) we can be more clever here\n                 let pattern_test = self.test(&match_pair);\n                 if pattern_test.kind == test.kind {\n-                    let new_candidate = self.candidate_without_match_pair(match_pair_index,\n-                                                                          candidate);\n-                    resulting_candidates[0].push(new_candidate);\n-                    true\n+                    self.candidate_without_match_pair(match_pair_index, candidate);\n+                    Some(0)\n                 } else {\n-                    false\n+                    None\n                 }\n             }\n         }\n     }\n \n-    fn candidate_without_match_pair<'pat>(&mut self,\n-                                          match_pair_index: usize,\n-                                          candidate: &Candidate<'pat, 'tcx>)\n-                                          -> Candidate<'pat, 'tcx> {\n-        let other_match_pairs =\n-            candidate.match_pairs.iter()\n-                                 .enumerate()\n-                                 .filter(|&(index, _)| index != match_pair_index)\n-                                 .map(|(_, mp)| mp.clone())\n-                                 .collect();\n-        Candidate {\n-            span: candidate.span,\n-            match_pairs: other_match_pairs,\n-            bindings: candidate.bindings.clone(),\n-            ascriptions: candidate.ascriptions.clone(),\n-            guard: candidate.guard.clone(),\n-            arm_index: candidate.arm_index,\n-            pat_index: candidate.pat_index,\n-            pre_binding_block: candidate.pre_binding_block,\n-            next_candidate_pre_binding_block: candidate.next_candidate_pre_binding_block,\n-        }\n+    fn candidate_without_match_pair(\n+        &mut self,\n+        match_pair_index: usize,\n+        candidate: &mut Candidate<'_, 'tcx>,\n+    ) {\n+        candidate.match_pairs.remove(match_pair_index);\n     }\n \n     fn candidate_after_slice_test<'pat>(&mut self,\n                                         match_pair_index: usize,\n-                                        candidate: &Candidate<'pat, 'tcx>,\n+                                        candidate: &mut Candidate<'pat, 'tcx>,\n                                         prefix: &'pat [Pattern<'tcx>],\n                                         opt_slice: Option<&'pat Pattern<'tcx>>,\n-                                        suffix: &'pat [Pattern<'tcx>])\n-                                        -> Candidate<'pat, 'tcx> {\n-        let mut new_candidate =\n-            self.candidate_without_match_pair(match_pair_index, candidate);\n+                                        suffix: &'pat [Pattern<'tcx>]) {\n+        let removed_place = candidate.match_pairs.remove(match_pair_index).place;\n         self.prefix_slice_suffix(\n-            &mut new_candidate.match_pairs,\n-            &candidate.match_pairs[match_pair_index].place,\n+            &mut candidate.match_pairs,\n+            &removed_place,\n             prefix,\n             opt_slice,\n             suffix);\n-\n-        new_candidate\n     }\n \n-    fn candidate_after_variant_switch<'pat>(&mut self,\n-                                            match_pair_index: usize,\n-                                            adt_def: &'tcx ty::AdtDef,\n-                                            variant_index: VariantIdx,\n-                                            subpatterns: &'pat [FieldPattern<'tcx>],\n-                                            candidate: &Candidate<'pat, 'tcx>)\n-                                            -> Candidate<'pat, 'tcx> {\n-        let match_pair = &candidate.match_pairs[match_pair_index];\n+    fn candidate_after_variant_switch<'pat>(\n+        &mut self,\n+        match_pair_index: usize,\n+        adt_def: &'tcx ty::AdtDef,\n+        variant_index: VariantIdx,\n+        subpatterns: &'pat [FieldPattern<'tcx>],\n+        candidate: &mut Candidate<'pat, 'tcx>,\n+    ) {\n+        let match_pair = candidate.match_pairs.remove(match_pair_index);\n \n         // So, if we have a match-pattern like `x @ Enum::Variant(P1, P2)`,\n         // we want to create a set of derived match-patterns like\n         // `(x as Variant).0 @ P1` and `(x as Variant).1 @ P1`.\n         let elem = ProjectionElem::Downcast(adt_def, variant_index);\n-        let downcast_place = match_pair.place.clone().elem(elem); // `(x as Variant)`\n+        let downcast_place = match_pair.place.elem(elem); // `(x as Variant)`\n         let consequent_match_pairs =\n             subpatterns.iter()\n                        .map(|subpattern| {\n@@ -754,26 +705,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                            MatchPair::new(place, &subpattern.pattern)\n                        });\n \n-        // In addition, we need all the other match pairs from the old candidate.\n-        let other_match_pairs =\n-            candidate.match_pairs.iter()\n-                                 .enumerate()\n-                                 .filter(|&(index, _)| index != match_pair_index)\n-                                 .map(|(_, mp)| mp.clone());\n-\n-        let all_match_pairs = consequent_match_pairs.chain(other_match_pairs).collect();\n-\n-        Candidate {\n-            span: candidate.span,\n-            match_pairs: all_match_pairs,\n-            bindings: candidate.bindings.clone(),\n-            ascriptions: candidate.ascriptions.clone(),\n-            guard: candidate.guard.clone(),\n-            arm_index: candidate.arm_index,\n-            pat_index: candidate.pat_index,\n-            pre_binding_block: candidate.pre_binding_block,\n-            next_candidate_pre_binding_block: candidate.next_candidate_pre_binding_block,\n-        }\n+        candidate.match_pairs.extend(consequent_match_pairs);\n     }\n \n     fn error_simplifyable<'pat>(&mut self, match_pair: &MatchPair<'pat, 'tcx>) -> ! {"}, {"sha": "3b90ff7884f012a70341494a317d7148dcca54a1", "filename": "src/librustc_mir/build/matches/util.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d51b5cdd82ec0e36212fc75b83652372980d56ca/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51b5cdd82ec0e36212fc75b83652372980d56ca/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs?ref=d51b5cdd82ec0e36212fc75b83652372980d56ca", "patch": "@@ -72,7 +72,6 @@ impl<'pat, 'tcx> MatchPair<'pat, 'tcx> {\n         MatchPair {\n             place,\n             pattern,\n-            slice_len_checked: false,\n         }\n     }\n }"}, {"sha": "5b4ec483277ac0f6ccdc67a0b32abc5016a6ce08", "filename": "src/test/mir-opt/issue-49232.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d51b5cdd82ec0e36212fc75b83652372980d56ca/src%2Ftest%2Fmir-opt%2Fissue-49232.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51b5cdd82ec0e36212fc75b83652372980d56ca/src%2Ftest%2Fmir-opt%2Fissue-49232.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-49232.rs?ref=d51b5cdd82ec0e36212fc75b83652372980d56ca", "patch": "@@ -41,46 +41,46 @@ fn main() {\n //         StorageLive(_3);\n //         _3 = const true;\n //         FakeRead(ForMatchedPlace, _3);\n-//         switchInt(_3) -> [false: bb11, otherwise: bb10];\n+//         switchInt(_3) -> [false: bb9, otherwise: bb8];\n //     }\n //     bb4: {\n //         resume;\n //     }\n //     bb5: {\n-//         _2 = const 4i32;\n-//         goto -> bb14;\n+//         falseEdges -> [real: bb12, imaginary: bb6];\n //     }\n //     bb6: {\n-//         _0 = ();\n-//         goto -> bb15;\n+//         falseEdges -> [real: bb14, imaginary: bb7];\n //     }\n //     bb7: {\n-//         falseEdges -> [real: bb12, imaginary: bb8];\n+//         unreachable;\n //     }\n //     bb8: {\n-//         falseEdges -> [real: bb13, imaginary: bb9];\n+//         goto -> bb6;\n //     }\n //     bb9: {\n-//         unreachable;\n+//         goto -> bb5;\n //     }\n //     bb10: {\n-//         goto -> bb8;\n+//         FakeRead(ForLet, _2);\n+//         StorageDead(_3);\n+//         StorageLive(_6);\n+//         _6 = &_2;\n+//         _5 = const std::mem::drop(move _6) -> [return: bb19, unwind: bb4];\n //     }\n //     bb11: {\n-//         goto -> bb7;\n+//         _2 = const 4i32;\n+//         goto -> bb10;\n //     }\n //     bb12: {\n-//         goto -> bb5;\n+//         goto -> bb11;\n //     }\n //     bb13: {\n-//         goto -> bb6;\n+//         _0 = ();\n+//         goto -> bb15;\n //     }\n //     bb14: {\n-//         FakeRead(ForLet, _2);\n-//         StorageDead(_3);\n-//         StorageLive(_6);\n-//         _6 = &_2;\n-//         _5 = const std::mem::drop(move _6) -> [return: bb19, unwind: bb4];\n+//         goto -> bb13;\n //     }\n //     bb15: {\n //         StorageDead(_3);\n@@ -96,7 +96,7 @@ fn main() {\n //     }\n //     bb18: {\n //         StorageDead(_4);\n-//         goto -> bb14;\n+//         goto -> bb10;\n //     }\n //     bb19: {\n //         StorageDead(_6);"}, {"sha": "9faecf5b7af46952328e2a0158c807d8fc29c967", "filename": "src/test/mir-opt/match_false_edges.rs", "status": "modified", "additions": 163, "deletions": 173, "changes": 336, "blob_url": "https://github.com/rust-lang/rust/blob/d51b5cdd82ec0e36212fc75b83652372980d56ca/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51b5cdd82ec0e36212fc75b83652372980d56ca/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs?ref=d51b5cdd82ec0e36212fc75b83652372980d56ca", "patch": "@@ -44,72 +44,68 @@ fn main() {\n //      ...\n //      _2 = std::option::Option<i32>::Some(const 42i32,);\n //      FakeRead(ForMatchedPlace, _2);\n-//      _7 = discriminant(_2);\n-//      _9 = &shallow (promoted[2]: std::option::Option<i32>);\n-//      _10 = &(((promoted[1]: std::option::Option<i32>) as Some).0: i32);\n-//      switchInt(move _7) -> [0isize: bb5, 1isize: bb3, otherwise: bb7];\n+//      _3 = discriminant(_2);\n+//      switchInt(move _3) -> [0isize: bb4, 1isize: bb2, otherwise: bb7];\n //  }\n //  bb1: {\n //      resume;\n //  }\n-//  bb2: {  // arm1\n-//      _1 = (const 3i32, const 3i32);\n-//      goto -> bb13;\n+//  bb2: {\n+//      falseEdges -> [real: bb9, imaginary: bb3]; //pre_binding1\n //  }\n-//  bb3: { // binding3(empty) and arm3\n-//      FakeRead(ForMatchGuard, _9);\n-//      FakeRead(ForMatchGuard, _10);\n-//      falseEdges -> [real: bb8, imaginary: bb4]; //pre_binding1\n+//  bb3: {\n+//      falseEdges -> [real: bb12, imaginary: bb4]; //pre_binding2\n //  }\n //  bb4: {\n-//      FakeRead(ForMatchGuard, _9);\n-//      FakeRead(ForMatchGuard, _10);\n-//      falseEdges -> [real: bb12, imaginary: bb5]; //pre_binding2\n+//      falseEdges -> [real: bb13, imaginary: bb5]; //pre_binding3\n //  }\n //  bb5: {\n-//      FakeRead(ForMatchGuard, _9);\n-//      FakeRead(ForMatchGuard, _10);\n-//      falseEdges -> [real: bb2, imaginary: bb6]; //pre_binding3\n-//  }\n-//  bb6: {\n //      unreachable;\n //  }\n+//  bb6: { // to pre_binding2\n+//      falseEdges -> [real: bb3, imaginary: bb3];\n+//  }\n //  bb7: {\n //      unreachable;\n //  }\n-//  bb8: { // binding1 and guard\n-//      StorageLive(_5);\n-//      _5 = &(((promoted[0]: std::option::Option<i32>) as Some).0: i32);\n-//      StorageLive(_8);\n-//      _8 = const guard() -> [return: bb9, unwind: bb1];\n-//  }\n-//  bb9: {\n-//      switchInt(move _8) -> [false: bb10, otherwise: bb11];\n+//  bb8: {\n+//      ...\n+//      return;\n //  }\n-//  bb10: { // to pre_binding2\n-//      falseEdges -> [real: bb4, imaginary: bb4];\n+//  bb9: { // binding1 and guard\n+//      StorageLive(_8);\n+//      _8 = &(((promoted[2]: std::option::Option<i32>) as Some).0: i32);\n+//      _4 = &shallow (promoted[1]: std::option::Option<i32>);\n+//      _5 = &(((promoted[0]: std::option::Option<i32>) as Some).0: i32);\n+//      StorageLive(_9);\n+//      _9 = const guard() -> [return: bb10, unwind: bb1];\n //  }\n-//  bb11: { // bindingNoLandingPads.before.mir2 and arm2\n-//      StorageLive(_3);\n-//      _3 = ((_2 as Some).0: i32);\n-//      StorageLive(_11);\n-//      _11 = _3;\n-//      _1 = (const 1i32, move _11);\n-//      StorageDead(_11);\n-//      goto -> bb13;\n+//  bb10: {\n+//      FakeRead(ForMatchGuard, _4);\n+//      FakeRead(ForMatchGuard, _5);\n+//      switchInt(move _9) -> [false: bb6, otherwise: bb11];\n //  }\n-//  bb12: {\n+//  bb11: {\n //      StorageLive(_6);\n //      _6 = ((_2 as Some).0: i32);\n+//      StorageLive(_10);\n+//      _10 = _6;\n+//      _1 = (const 1i32, move _10);\n+//      StorageDead(_10);\n+//      goto -> bb8;\n+//  }\n+//  bb12: {\n+//      StorageLive(_11);\n+//      _11 = ((_2 as Some).0: i32);\n //      StorageLive(_12);\n-//      _12 = _6;\n-//      _1 = (const 2i32, move_12);\n+//      _12 = _11;\n+//      _1 = (const 2i32, move _12);\n //      StorageDead(_12);\n-//      goto -> bb13;\n+//      goto -> bb8;\n //  }\n //  bb13: {\n-//      ...\n-//      return;\n+//      _1 = (const 3i32, const 3i32);\n+//      goto -> bb8;\n //  }\n // END rustc.full_tested_match.QualifyAndPromoteConstants.after.mir\n //\n@@ -118,164 +114,158 @@ fn main() {\n //      ...\n //      _2 = std::option::Option<i32>::Some(const 42i32,);\n //      FakeRead(ForMatchedPlace, _2);\n-//      _7 = discriminant(_2);\n-//      _9 = &shallow _2;\n-//      _10 = &((_2 as Some).0: i32);\n-//      switchInt(move _7) -> [0isize: bb4, 1isize: bb3, otherwise: bb7];\n+//      _3 = discriminant(_2);\n+//      switchInt(move _3) -> [0isize: bb3, 1isize: bb2, otherwise: bb7];\n //  }\n //  bb1: {\n //      resume;\n //  }\n-//  bb2: { // arm2\n-//      _1 = (const 3i32, const 3i32);\n-//      goto -> bb13;\n+//  bb2: {\n+//      falseEdges -> [real: bb9, imaginary: bb3];\n //  }\n //  bb3: {\n-//      FakeRead(ForMatchGuard, _9);\n-//      FakeRead(ForMatchGuard, _10);\n-//      falseEdges -> [real: bb8, imaginary: bb4]; //pre_binding1\n+//      falseEdges -> [real: bb12, imaginary: bb4];\n //  }\n //  bb4: {\n-//      FakeRead(ForMatchGuard, _9);\n-//      FakeRead(ForMatchGuard, _10);\n-//      falseEdges -> [real: bb2, imaginary: bb5]; //pre_binding2\n+//      falseEdges -> [real: bb13, imaginary: bb5];\n //  }\n //  bb5: {\n-//      FakeRead(ForMatchGuard, _9);\n-//      FakeRead(ForMatchGuard, _10);\n-//      falseEdges -> [real: bb12, imaginary: bb6]; //pre_binding3\n-//  }\n-//  bb6: {\n //      unreachable;\n //  }\n+//  bb6: { // to pre_binding3 (can skip 2 since this is `Some`)\n+//      falseEdges -> [real: bb4, imaginary: bb3];\n+//  }\n //  bb7: {\n //      unreachable;\n //  }\n-//  bb8: { // binding1 and guard\n-//      StorageLive(_5);\n-//      _5 = &((_2 as Some).0: i32);\n-//      StorageLive(_8);\n-//      _8 = const guard() -> [return: bb9, unwind: bb1];\n+//  bb8: {\n+//      ...\n+//      return;\n //  }\n-//  bb9: { // end of guard\n-//      switchInt(move _8) -> [false: bb10, otherwise: bb11];\n+//  bb9: { // binding1 and guard\n+//      StorageLive(_8);\n+//      _8 = &((_2 as Some).0: i32);\n+//      _4 = &shallow _2;\n+//      _5 = &((_2 as Some).0: i32);\n+//      StorageLive(_9);\n+//      _9 = const guard() -> [return: bb10, unwind: bb1];\n //  }\n-//  bb10: { // to pre_binding3 (can skip 2 since this is `Some`)\n-//      falseEdges -> [real: bb5, imaginary: bb4];\n+//  bb10: { // end of guard\n+//      FakeRead(ForMatchGuard, _4);\n+//      FakeRead(ForMatchGuard, _5);\n+//      switchInt(move _9) -> [false: bb6, otherwise: bb11];\n //  }\n //  bb11: { // arm1\n-//      StorageLive(_3);\n-//      _3 = ((_2 as Some).0: i32);\n-//      StorageLive(_11);\n-//      _11 = _3;\n-//      _1 = (const 1i32, move _11);\n-//      StorageDead(_11);\n-//      goto -> bb13;\n-//  }\n-//  bb12: { // binding3 and arm3\n //      StorageLive(_6);\n //      _6 = ((_2 as Some).0: i32);\n+//      StorageLive(_10);\n+//      _10 = _6;\n+//      _1 = (const 1i32, move _10);\n+//      StorageDead(_10);\n+//      goto -> bb8;\n+//  }\n+//  bb12: { // arm2\n+//      _1 = (const 3i32, const 3i32);\n+//      goto -> bb8;\n+//  }\n+//  bb13: { // binding3 and arm3\n+//      StorageLive(_11);\n+//      _11 = ((_2 as Some).0: i32);\n //      StorageLive(_12);\n-//      _12 = _6;\n+//      _12 = _11;\n //      _1 = (const 2i32, move _12);\n //      StorageDead(_12);\n-//      goto -> bb13;\n-//  }\n-//  bb13: {\n-//      ...\n-//      return;\n+//      goto -> bb8;\n //  }\n // END rustc.full_tested_match2.QualifyAndPromoteConstants.before.mir\n //\n // START rustc.main.QualifyAndPromoteConstants.before.mir\n // bb0: {\n //     ...\n-//     _2 = std::option::Option<i32>::Some(const 1i32,);\n-//     FakeRead(ForMatchedPlace, _2);\n-//     _11 = discriminant(_2);\n-//    _16 = &shallow _2;\n-//    _17 = &((_2 as Some).0: i32);\n-//     switchInt(move _11) -> [1isize: bb2, otherwise: bb3];\n-// }\n-// bb1: {\n-//     resume;\n-// }\n-// bb2: {\n-//      FakeRead(ForMatchGuard, _16);\n-//      FakeRead(ForMatchGuard, _17);\n-//     falseEdges -> [real: bb7, imaginary: bb3]; //pre_binding1\n-// }\n-// bb3: {\n-//      FakeRead(ForMatchGuard, _16);\n-//      FakeRead(ForMatchGuard, _17);\n-//     falseEdges -> [real: bb11, imaginary: bb4]; //pre_binding2\n-// }\n-// bb4: {\n-//      FakeRead(ForMatchGuard, _16);\n-//      FakeRead(ForMatchGuard, _17);\n-//     falseEdges -> [real: bb12, imaginary: bb5]; //pre_binding3\n-// }\n-// bb5: {\n-//      FakeRead(ForMatchGuard, _16);\n-//      FakeRead(ForMatchGuard, _17);\n-//     falseEdges -> [real: bb16, imaginary: bb6]; //pre_binding4\n-// }\n-// bb6: {\n-//     unreachable;\n-// }\n-// bb7: { // binding1: Some(w) if guard()\n-//     StorageLive(_5);\n-//     _5 = &((_2 as Some).0: i32);\n-//     StorageLive(_12);\n-//     _12 = const guard() -> [return: bb8, unwind: bb1];\n-// }\n-// bb8: { //end of guard\n-//     switchInt(move _12) -> [false: bb9, otherwise: bb10];\n-// }\n-// bb9: { // to pre_binding2\n-//     falseEdges -> [real: bb3, imaginary: bb3];\n-// }\n-// bb10: { // set up bindings for arm1\n-//     StorageLive(_3);\n-//     _3 = ((_2 as Some).0: i32);\n-//     _1 = const 1i32;\n-//     goto -> bb17;\n-// }\n-// bb11: { // binding2 & arm2\n-//     StorageLive(_6);\n-//     _6 = _2;\n-//     _1 = const 2i32;\n-//     goto -> bb17;\n-// }\n-// bb12: { // binding3: Some(y) if guard2(y)\n-//     StorageLive(_9);\n-//     _9 = &((_2 as Some).0: i32);\n-//     StorageLive(_14);\n-//     StorageLive(_15);\n-//     _15 = (*_9);\n-//     _14 = const guard2(move _15) -> [return: bb13, unwind: bb1];\n-// }\n-// bb13: { // end of guard2\n-//     StorageDead(_15);\n-//     switchInt(move _14) -> [false: bb14, otherwise: bb15];\n-// }\n-// bb14: { // to pre_binding4\n-//     falseEdges -> [real: bb5, imaginary: bb5];\n-// }\n-// bb15: { // set up bindings for arm3\n-//     StorageLive(_7);\n-//     _7 = ((_2 as Some).0: i32);\n-//     _1 = const 3i32;\n-//     goto -> bb17;\n-// }\n-// bb16: { // binding4 & arm4\n-//     StorageLive(_10);\n-//     _10 = _2;\n-//     _1 = const 4i32;\n-//     goto -> bb17;\n-// }\n-// bb17: {\n-//     ...\n-//     return;\n-// }\n+//      _2 = std::option::Option<i32>::Some(const 1i32,);\n+//      FakeRead(ForMatchedPlace, _2);\n+//      _3 = discriminant(_2);\n+//      switchInt(move _3) -> [1isize: bb2, otherwise: bb3];\n+//  }\n+//  bb1: {\n+//      resume;\n+//  }\n+//  bb2: {\n+//      falseEdges -> [real: bb10, imaginary: bb3]; //pre_binding1\n+//  }\n+//  bb3: {\n+//      falseEdges -> [real: bb13, imaginary: bb4]; //pre_binding2\n+//  }\n+//  bb4: {\n+//      falseEdges -> [real: bb14, imaginary: bb5]; //pre_binding3\n+//  }\n+//  bb5: {\n+//      falseEdges -> [real: bb17, imaginary: bb6]; //pre_binding4\n+//  }\n+//  bb6: {\n+//      unreachable;\n+//  }\n+//  bb7: { // to pre_binding2\n+//      falseEdges -> [real: bb3, imaginary: bb3];\n+//  }\n+//  bb8: { // to pre_binding4\n+//      falseEdges -> [real: bb5, imaginary: bb5];\n+//  }\n+//  bb9: {\n+//      ...\n+//      return;\n+//  }\n+//  bb10: { // binding1: Some(w) if guard()\n+//      StorageLive(_9);\n+//      _9 = &((_2 as Some).0: i32);\n+//      _5 = &shallow _2;\n+//      _6 = &((_2 as Some).0: i32);\n+//      StorageLive(_10);\n+//      _10 = const guard() -> [return: bb11, unwind: bb1];\n+//  }\n+//  bb11: { //end of guard\n+//      FakeRead(ForMatchGuard, _5);\n+//      FakeRead(ForMatchGuard, _6);\n+//      switchInt(move _10) -> [false: bb7, otherwise: bb12];\n+//  }\n+//  bb12: { // set up bindings for arm1\n+//      StorageLive(_7);\n+//      _7 = ((_2 as Some).0: i32);\n+//      _1 = const 1i32;\n+//      goto -> bb9;\n+//  }\n+//  bb13: { // binding2 & arm2\n+//      StorageLive(_11);\n+//      _11 = _2;\n+//      _1 = const 2i32;\n+//      goto -> bb9;\n+//  }\n+//  bb14: { // binding3: Some(y) if guard2(y)\n+//      StorageLive(_14);\n+//      _14 = &((_2 as Some).0: i32);\n+//      _5 = &shallow _2;\n+//      _6 = &((_2 as Some).0: i32);\n+//      StorageLive(_15);\n+//      StorageLive(_16);\n+//      _16 = (*_14);\n+//      _15 = const guard2(move _16) -> [return: bb15, unwind: bb1];\n+//  }\n+//  bb15: { // end of guard2\n+//      StorageDead(_16);\n+//      FakeRead(ForMatchGuard, _5);\n+//      FakeRead(ForMatchGuard, _6);\n+//      switchInt(move _15) -> [false: bb8, otherwise: bb16];\n+//  }\n+//  bb16: { // binding4 & arm4\n+//      StorageLive(_12);\n+//      _12 = ((_2 as Some).0: i32);\n+//      _1 = const 3i32;\n+//      goto -> bb9;\n+//  }\n+//  bb17: {\n+//      StorageLive(_17);\n+//      _17 = _2;\n+//      _1 = const 4i32;\n+//      goto -> bb9;\n+//  }\n // END rustc.main.QualifyAndPromoteConstants.before.mir"}, {"sha": "835a5ce1200b9b30e240b4a4d7faaa6c8f9eafbc", "filename": "src/test/mir-opt/match_test.rs", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/d51b5cdd82ec0e36212fc75b83652372980d56ca/src%2Ftest%2Fmir-opt%2Fmatch_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51b5cdd82ec0e36212fc75b83652372980d56ca/src%2Ftest%2Fmir-opt%2Fmatch_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch_test.rs?ref=d51b5cdd82ec0e36212fc75b83652372980d56ca", "patch": "@@ -20,66 +20,67 @@ fn main() {\n // START rustc.main.SimplifyCfg-initial.after.mir\n //    bb0: {\n //        ...\n-//        _4 = Le(const 0i32, _1);\n-//        switchInt(move _4) -> [false: bb10, otherwise: bb11];\n+//        switchInt(move _4) -> [false: bb7, otherwise: bb8];\n //    }\n //    bb1: {\n-//        _3 = const 0i32;\n-//        goto -> bb16;\n+//        falseEdges -> [real: bb13, imaginary: bb2];\n //    }\n //    bb2: {\n-//        _3 = const 1i32;\n-//        goto -> bb16;\n+//        falseEdges -> [real: bb14, imaginary: bb3];\n //    }\n //    bb3: {\n-//        _3 = const 2i32;\n-//        goto -> bb16;\n+//        falseEdges -> [real: bb15, imaginary: bb4];\n //    }\n //    bb4: {\n-//        _3 = const 3i32;\n-//        goto -> bb16;\n+//        falseEdges -> [real: bb16, imaginary: bb5];\n //    }\n //    bb5: {\n-//        falseEdges -> [real: bb12, imaginary: bb6];\n+//        unreachable;\n //    }\n //    bb6: {\n-//        falseEdges -> [real: bb2, imaginary: bb7];\n+//        falseEdges -> [real: bb4, imaginary: bb2];\n //    }\n //    bb7: {\n-//        falseEdges -> [real: bb3, imaginary: bb8];\n+//        _6 = Le(const 10i32, _1);\n+//        switchInt(move _6) -> [false: bb9, otherwise: bb10];\n //    }\n //    bb8: {\n-//        falseEdges -> [real: bb4, imaginary: bb9];\n+//        _5 = Lt(_1, const 10i32);\n+//        switchInt(move _5) -> [false: bb7, otherwise: bb1];\n //    }\n //    bb9: {\n-//        unreachable;\n+//        switchInt(_1) -> [-1i32: bb3, otherwise: bb4];\n //    }\n //    bb10: {\n-//        _7 = Le(const 10i32, _1);\n-//        switchInt(move _7) -> [false: bb14, otherwise: bb15];\n+//        _7 = Le(_1, const 20i32);\n+//        switchInt(move _7) -> [false: bb9, otherwise: bb2];\n //    }\n //    bb11: {\n-//        _5 = Lt(_1, const 10i32);\n-//        switchInt(move _5) -> [false: bb10, otherwise: bb5];\n+//        StorageDead(_8);\n+//        _0 = ();\n+//        StorageDead(_2);\n+//        StorageDead(_1);\n+//        return;\n //    }\n //    bb12: {\n-//        StorageLive(_6);\n-//        _6 = _2;\n-//        switchInt(move _6) -> [false: bb13, otherwise: bb1];\n+//        _3 = const 0i32;\n+//        goto -> bb11;\n //    }\n //    bb13: {\n-//        falseEdges -> [real: bb8, imaginary: bb6];\n+//        StorageLive(_8);\n+//        _8 = _2;\n+//        switchInt(move _8) -> [false: bb6, otherwise: bb12];\n //    }\n //    bb14: {\n-//        switchInt(_1) -> [-1i32: bb7, otherwise: bb8];\n+//        _3 = const 1i32;\n+//        goto -> bb11;\n //    }\n //    bb15: {\n-//        _8 = Le(_1, const 20i32);\n-//        switchInt(move _8) -> [false: bb14, otherwise: bb6];\n+//        _3 = const 2i32;\n+//        goto -> bb11;\n //    }\n //    bb16: {\n-//        StorageDead(_6);\n-//        ...\n-//        return;\n+//        _3 = const 3i32;\n+//        goto -> bb11;\n //    }\n // END rustc.main.SimplifyCfg-initial.after.mir"}, {"sha": "fab4d28a936cac558c32fc6872829090a27aecae", "filename": "src/test/mir-opt/remove_fake_borrows.rs", "status": "modified", "additions": 48, "deletions": 50, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/d51b5cdd82ec0e36212fc75b83652372980d56ca/src%2Ftest%2Fmir-opt%2Fremove_fake_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51b5cdd82ec0e36212fc75b83652372980d56ca/src%2Ftest%2Fmir-opt%2Fremove_fake_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fremove_fake_borrows.rs?ref=d51b5cdd82ec0e36212fc75b83652372980d56ca", "patch": "@@ -4,65 +4,64 @@\n \n #![feature(nll)]\n \n-fn match_guard(x: Option<&&i32>) -> i32 {\n+fn match_guard(x: Option<&&i32>, c: bool) -> i32 {\n     match x {\n-        Some(0) if true => 0,\n+        Some(0) if c => 0,\n         _ => 1,\n     }\n }\n \n fn main() {\n-    match_guard(None);\n+    match_guard(None, true);\n }\n \n // END RUST SOURCE\n \n // START rustc.match_guard.CleanFakeReadsAndBorrows.before.mir\n // bb0: {\n //     FakeRead(ForMatchedPlace, _1);\n-//     _2 = discriminant(_1);\n-//     _3 = &shallow _1;\n-//     _4 = &shallow ((_1 as Some).0: &'<empty> &'<empty> i32);\n-//     _5 = &shallow (*((_1 as Some).0: &'<empty> &'<empty> i32));\n-//     _6 = &shallow (*(*((_1 as Some).0: &'<empty> &'<empty> i32)));\n-//     switchInt(move _2) -> [1isize: bb6, otherwise: bb4];\n+//     _3 = discriminant(_1);\n+//     switchInt(move _3) -> [1isize: bb5, otherwise: bb2];\n // }\n // bb1: {\n-//     _0 = const 0i32;\n-//     goto -> bb9;\n+//     goto -> bb8;\n // }\n // bb2: {\n-//     _0 = const 1i32;\n //     goto -> bb9;\n // }\n // bb3: {\n-//     FakeRead(ForMatchGuard, _3);\n-//     FakeRead(ForMatchGuard, _4);\n-//     FakeRead(ForMatchGuard, _5);\n-//     FakeRead(ForMatchGuard, _6);\n-//     goto -> bb7;\n+//     unreachable;\n // }\n // bb4: {\n-//     FakeRead(ForMatchGuard, _3);\n-//     FakeRead(ForMatchGuard, _4);\n-//     FakeRead(ForMatchGuard, _5);\n-//     FakeRead(ForMatchGuard, _6);\n //     goto -> bb2;\n // }\n // bb5: {\n-//     unreachable;\n+//     switchInt((*(*((_1 as Some).0: &'<empty> &'<empty> i32)))) -> [0i32: bb1, otherwise: bb2];\n // }\n // bb6: {\n-//     switchInt((*(*((_1 as Some).0: &'<empty> &'<empty> i32)))) -> [0i32: bb3, otherwise: bb4];\n+//     StorageDead(_8);\n+//     return;\n // }\n // bb7: {\n-//     goto -> bb1;\n+//     _0 = const 0i32;\n+//     goto -> bb6;\n // }\n // bb8: {\n-//     goto -> bb4;\n+//     _4 = &shallow _1;\n+//     _5 = &shallow ((_1 as Some).0: &'<empty> &'<empty> i32);\n+//     _6 = &shallow (*((_1 as Some).0: &'<empty> &'<empty> i32));\n+//     _7 = &shallow (*(*((_1 as Some).0: &'<empty> &'<empty> i32)));\n+//     StorageLive(_8);\n+//     _8 = _2;\n+//     FakeRead(ForMatchGuard, _4);\n+//     FakeRead(ForMatchGuard, _5);\n+//     FakeRead(ForMatchGuard, _6);\n+//     FakeRead(ForMatchGuard, _7);\n+//     switchInt(move _8) -> [false: bb4, otherwise: bb7];\n // }\n // bb9: {\n-//     return;\n+//     _0 = const 1i32;\n+//     goto -> bb6;\n // }\n // bb10: {\n //     resume;\n@@ -72,51 +71,50 @@ fn main() {\n // START rustc.match_guard.CleanFakeReadsAndBorrows.after.mir\n // bb0: {\n //     nop;\n-//     _2 = discriminant(_1);\n-//     nop;\n-//     nop;\n-//     nop;\n-//     nop;\n-//     switchInt(move _2) -> [1isize: bb6, otherwise: bb4];\n+//     _3 = discriminant(_1);\n+//     switchInt(move _3) -> [1isize: bb5, otherwise: bb2];\n // }\n // bb1: {\n-//     _0 = const 0i32;\n-//     goto -> bb9;\n+//     goto -> bb8;\n // }\n // bb2: {\n-//     _0 = const 1i32;\n //     goto -> bb9;\n // }\n // bb3: {\n-//     nop;\n-//     nop;\n-//     nop;\n-//     nop;\n-//     goto -> bb7;\n+//     unreachable;\n // }\n // bb4: {\n-//     nop;\n-//     nop;\n-//     nop;\n-//     nop;\n //     goto -> bb2;\n // }\n // bb5: {\n-//     unreachable;\n+//     switchInt((*(*((_1 as Some).0: &'<empty> &'<empty> i32)))) -> [0i32: bb1, otherwise: bb2];\n // }\n // bb6: {\n-//     switchInt((*(*((_1 as Some).0: &'<empty> &'<empty> i32)))) -> [0i32: bb3, otherwise: bb4];\n+//     StorageDead(_8);\n+//     return;\n // }\n // bb7: {\n-//     goto -> bb1;\n+//     _0 = const 0i32;\n+//     goto -> bb6;\n // }\n // bb8: {\n-//     goto -> bb4;\n+//     nop;\n+//     nop;\n+//     nop;\n+//     nop;\n+//     StorageLive(_8);\n+//     _8 = _2;\n+//     nop;\n+//     nop;\n+//     nop;\n+//     nop;\n+//     switchInt(move _8) -> [false: bb4, otherwise: bb7];\n // }\n // bb9: {\n-//     return;\n+//     _0 = const 1i32;\n+//     goto -> bb6;\n // }\n // bb10: {\n //     resume;\n-// }\n+//    }\n // END rustc.match_guard.CleanFakeReadsAndBorrows.after.mir"}]}