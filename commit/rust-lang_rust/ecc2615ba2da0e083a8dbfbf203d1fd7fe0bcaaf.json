{"sha": "ecc2615ba2da0e083a8dbfbf203d1fd7fe0bcaaf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjYzI2MTViYTJkYTBlMDgzYThkYmZiZjIwM2QxZmQ3ZmUwYmNhYWY=", "commit": {"author": {"name": "Matthew Hall", "email": "matthew@quickbeam.me.uk", "date": "2020-03-28T20:44:12Z"}, "committer": {"name": "Matthew Hall", "email": "matthew@quickbeam.me.uk", "date": "2020-03-28T20:58:46Z"}, "message": "Append new match arms rather than replacing all of them\n\nThis means we now retain comments when filling in match arms.", "tree": {"sha": "e35cea1b482c65b98e1025da47e9670df61e92ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e35cea1b482c65b98e1025da47e9670df61e92ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ecc2615ba2da0e083a8dbfbf203d1fd7fe0bcaaf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ecc2615ba2da0e083a8dbfbf203d1fd7fe0bcaaf", "html_url": "https://github.com/rust-lang/rust/commit/ecc2615ba2da0e083a8dbfbf203d1fd7fe0bcaaf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ecc2615ba2da0e083a8dbfbf203d1fd7fe0bcaaf/comments", "author": {"login": "mattyhall", "id": 5175499, "node_id": "MDQ6VXNlcjUxNzU0OTk=", "avatar_url": "https://avatars.githubusercontent.com/u/5175499?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mattyhall", "html_url": "https://github.com/mattyhall", "followers_url": "https://api.github.com/users/mattyhall/followers", "following_url": "https://api.github.com/users/mattyhall/following{/other_user}", "gists_url": "https://api.github.com/users/mattyhall/gists{/gist_id}", "starred_url": "https://api.github.com/users/mattyhall/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mattyhall/subscriptions", "organizations_url": "https://api.github.com/users/mattyhall/orgs", "repos_url": "https://api.github.com/users/mattyhall/repos", "events_url": "https://api.github.com/users/mattyhall/events{/privacy}", "received_events_url": "https://api.github.com/users/mattyhall/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mattyhall", "id": 5175499, "node_id": "MDQ6VXNlcjUxNzU0OTk=", "avatar_url": "https://avatars.githubusercontent.com/u/5175499?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mattyhall", "html_url": "https://github.com/mattyhall", "followers_url": "https://api.github.com/users/mattyhall/followers", "following_url": "https://api.github.com/users/mattyhall/following{/other_user}", "gists_url": "https://api.github.com/users/mattyhall/gists{/gist_id}", "starred_url": "https://api.github.com/users/mattyhall/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mattyhall/subscriptions", "organizations_url": "https://api.github.com/users/mattyhall/orgs", "repos_url": "https://api.github.com/users/mattyhall/repos", "events_url": "https://api.github.com/users/mattyhall/events{/privacy}", "received_events_url": "https://api.github.com/users/mattyhall/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c2d4135db867efe335a0654d86429bea7bb9caf", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c2d4135db867efe335a0654d86429bea7bb9caf", "html_url": "https://github.com/rust-lang/rust/commit/1c2d4135db867efe335a0654d86429bea7bb9caf"}], "stats": {"total": 215, "additions": 180, "deletions": 35}, "files": [{"sha": "c45981c5cc3a82bc60a0c0988637813d78a3a857", "filename": "crates/ra_assists/src/handlers/fill_match_arms.rs", "status": "modified", "additions": 68, "deletions": 5, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/ecc2615ba2da0e083a8dbfbf203d1fd7fe0bcaaf/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecc2615ba2da0e083a8dbfbf203d1fd7fe0bcaaf/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs?ref=ecc2615ba2da0e083a8dbfbf203d1fd7fe0bcaaf", "patch": "@@ -7,7 +7,7 @@ use itertools::Itertools;\n use ra_ide_db::RootDatabase;\n \n use crate::{Assist, AssistCtx, AssistId};\n-use ra_syntax::ast::{self, edit::IndentLevel, make, AstNode, NameOwner};\n+use ra_syntax::ast::{self, make, AstNode, NameOwner};\n \n use ast::{MatchArm, Pat};\n \n@@ -97,10 +97,8 @@ pub(crate) fn fill_match_arms(ctx: AssistCtx) -> Option<Assist> {\n     }\n \n     ctx.add_assist(AssistId(\"fill_match_arms\"), \"Fill match arms\", |edit| {\n-        arms.extend(missing_arms);\n-\n-        let indent_level = IndentLevel::from_node(match_arm_list.syntax());\n-        let new_arm_list = indent_level.increase_indent(make::match_arm_list(arms));\n+        let new_arm_list =\n+            match_arm_list.remove_placeholder().append_arms(missing_arms.into_iter());\n \n         edit.target(match_expr.syntax().text_range());\n         edit.set_cursor(expr.syntax().text_range().start());\n@@ -655,4 +653,69 @@ mod tests {\n             \"#,\n         );\n     }\n+\n+    #[test]\n+    fn fill_match_arms_preserves_comments() {\n+        check_assist(\n+            fill_match_arms,\n+            r#\"\n+            enum A {\n+                One,\n+                Two,\n+            }\n+            fn foo(a: A) {\n+                match a {\n+                    // TODO: Fill this in<|>\n+                    A::One => {}\n+                    // This is where the rest should be\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            enum A {\n+                One,\n+                Two,\n+            }\n+            fn foo(a: A) {\n+                match <|>a {\n+                    // TODO: Fill this in\n+                    A::One => {}\n+                    // This is where the rest should be\n+                    A::Two => {}\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn fill_match_arms_preserves_comments_empty() {\n+        check_assist(\n+            fill_match_arms,\n+            r#\"\n+            enum A {\n+                One,\n+                Two,\n+            }\n+            fn foo(a: A) {\n+                match a {\n+                    // TODO: Fill this in<|>\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            enum A {\n+                One,\n+                Two,\n+            }\n+            fn foo(a: A) {\n+                match <|>a {\n+                    // TODO: Fill this in\n+                    A::One => {}\n+                    A::Two => {}\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n }"}, {"sha": "437186888de7dbeb4d5d39fb76841ba49f6dbb7f", "filename": "crates/ra_syntax/src/ast/edit.rs", "status": "modified", "additions": 112, "deletions": 30, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/ecc2615ba2da0e083a8dbfbf203d1fd7fe0bcaaf/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecc2615ba2da0e083a8dbfbf203d1fd7fe0bcaaf/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs?ref=ecc2615ba2da0e083a8dbfbf203d1fd7fe0bcaaf", "patch": "@@ -46,12 +46,44 @@ impl ast::FnDef {\n     }\n }\n \n+fn make_multiline<N>(node: N) -> N\n+where\n+    N: AstNode + Clone,\n+{\n+    let l_curly = match node.syntax().children_with_tokens().find(|it| it.kind() == T!['{']) {\n+        Some(it) => it,\n+        None => return node,\n+    };\n+    let sibling = match l_curly.next_sibling_or_token() {\n+        Some(it) => it,\n+        None => return node,\n+    };\n+    let existing_ws = match sibling.as_token() {\n+        None => None,\n+        Some(tok) if tok.kind() != WHITESPACE => None,\n+        Some(ws) => {\n+            if ws.text().contains('\\n') {\n+                return node;\n+            }\n+            Some(ws.clone())\n+        }\n+    };\n+\n+    let indent = leading_indent(node.syntax()).unwrap_or_default();\n+    let ws = tokens::WsBuilder::new(&format!(\"\\n{}\", indent));\n+    let to_insert = iter::once(ws.ws().into());\n+    match existing_ws {\n+        None => node.insert_children(InsertPosition::After(l_curly), to_insert),\n+        Some(ws) => node.replace_children(single_node(ws), to_insert),\n+    }\n+}\n+\n impl ast::ItemList {\n     #[must_use]\n     pub fn append_items(&self, items: impl Iterator<Item = ast::ImplItem>) -> ast::ItemList {\n         let mut res = self.clone();\n         if !self.syntax().text().contains_char('\\n') {\n-            res = res.make_multiline();\n+            res = make_multiline(res);\n         }\n         items.for_each(|it| res = res.append_item(it));\n         res\n@@ -81,35 +113,6 @@ impl ast::ItemList {\n     fn l_curly(&self) -> Option<SyntaxElement> {\n         self.syntax().children_with_tokens().find(|it| it.kind() == T!['{'])\n     }\n-\n-    fn make_multiline(&self) -> ast::ItemList {\n-        let l_curly = match self.syntax().children_with_tokens().find(|it| it.kind() == T!['{']) {\n-            Some(it) => it,\n-            None => return self.clone(),\n-        };\n-        let sibling = match l_curly.next_sibling_or_token() {\n-            Some(it) => it,\n-            None => return self.clone(),\n-        };\n-        let existing_ws = match sibling.as_token() {\n-            None => None,\n-            Some(tok) if tok.kind() != WHITESPACE => None,\n-            Some(ws) => {\n-                if ws.text().contains('\\n') {\n-                    return self.clone();\n-                }\n-                Some(ws.clone())\n-            }\n-        };\n-\n-        let indent = leading_indent(self.syntax()).unwrap_or_default();\n-        let ws = tokens::WsBuilder::new(&format!(\"\\n{}\", indent));\n-        let to_insert = iter::once(ws.ws().into());\n-        match existing_ws {\n-            None => self.insert_children(InsertPosition::After(l_curly), to_insert),\n-            Some(ws) => self.replace_children(single_node(ws), to_insert),\n-        }\n-    }\n }\n \n impl ast::RecordFieldList {\n@@ -334,6 +337,85 @@ impl ast::UseTree {\n     }\n }\n \n+impl ast::MatchArmList {\n+    #[must_use]\n+    pub fn append_arms(&self, items: impl Iterator<Item = ast::MatchArm>) -> ast::MatchArmList {\n+        let mut res = self.clone();\n+        res = res.strip_if_only_whitespace();\n+        if !res.syntax().text().contains_char('\\n') {\n+            res = make_multiline(res);\n+        }\n+        items.for_each(|it| res = res.append_arm(it));\n+        res\n+    }\n+\n+    fn strip_if_only_whitespace(&self) -> ast::MatchArmList {\n+        let mut iter = self.syntax().children_with_tokens().skip_while(|it| it.kind() != T!['{']);\n+        iter.next(); // Eat the curly\n+        let mut inner = iter.take_while(|it| it.kind() != T!['}']);\n+        if !inner.clone().all(|it| it.kind() == WHITESPACE) {\n+            return self.clone();\n+        }\n+        let start = match inner.next() {\n+            Some(s) => s,\n+            None => return self.clone(),\n+        };\n+        let end = match inner.last() {\n+            Some(s) => s,\n+            None => start.clone(),\n+        };\n+        let res = self.replace_children(start..=end, &mut iter::empty());\n+        res\n+    }\n+\n+    #[must_use]\n+    pub fn remove_placeholder(&self) -> ast::MatchArmList {\n+        let placeholder = self.arms().find(|arm| {\n+            if let Some(ast::Pat::PlaceholderPat(_)) = arm.pat() {\n+                return true;\n+            }\n+            false\n+        });\n+        if let Some(placeholder) = placeholder {\n+            let s: SyntaxElement = placeholder.syntax().clone().into();\n+            let e = s.clone();\n+            self.replace_children(s..=e, &mut iter::empty())\n+        } else {\n+            self.clone()\n+        }\n+    }\n+\n+    #[must_use]\n+    pub fn append_arm(&self, item: ast::MatchArm) -> ast::MatchArmList {\n+        let r_curly = match self.syntax().children_with_tokens().find(|it| it.kind() == T!['}']) {\n+            Some(t) => t,\n+            None => return self.clone(),\n+        };\n+        let mut sib = r_curly.prev_sibling_or_token();\n+        while let Some(s) = sib.clone() {\n+            if let Some(tok) = s.as_token() {\n+                if tok.kind() != WHITESPACE {\n+                    break;\n+                }\n+                sib = s.prev_sibling_or_token();\n+            } else {\n+                break;\n+            }\n+        }\n+        let indent = \"    \".to_string() + &leading_indent(self.syntax()).unwrap_or_default();\n+        let sib = match sib {\n+            Some(s) => s,\n+            None => return self.clone(),\n+        };\n+        let position = InsertPosition::After(sib.into());\n+        let ws = tokens::WsBuilder::new(&format!(\"\\n{}\", indent));\n+        let to_insert: ArrayVec<[SyntaxElement; 2]> =\n+            [ws.ws().into(), item.syntax().clone().into()].into();\n+        let res = self.insert_children(position, to_insert);\n+        res\n+    }\n+}\n+\n #[must_use]\n pub fn remove_attrs_and_docs<N: ast::AttrsOwner>(node: &N) -> N {\n     N::cast(remove_attrs_and_docs_inner(node.syntax().clone())).unwrap()"}]}