{"sha": "156351419611f3ee6f6b1327e6021676630e64a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1NjM1MTQxOTYxMWYzZWU2ZjZiMTMyN2U2MDIxNjc2NjMwZTY0YTg=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-04T02:48:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-06-04T02:48:08Z"}, "message": "Rollup merge of #61409 - varkor:condition-trait-param-ice, r=oli-obk\n\nFix an ICE with a const argument in a trait\n\nThis goes some way towards fixing https://github.com/rust-lang/rust/issues/61383 (the reduced test case is fixed).", "tree": {"sha": "394818604f165ef372b5aad8d028678c88320a39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/394818604f165ef372b5aad8d028678c88320a39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/156351419611f3ee6f6b1327e6021676630e64a8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJc9dvoCRBK7hj4Ov3rIwAAdHIIAHm04tCvw/ATGtR+CLbcclLX\nLf3FrvZmAiI/3o6ejDRPCKsj5RKnaxgaeL5/V3qKglWXd5pcBLHU2N8FOIx9ekPH\nt7PKdYNNl92bLYrOntRDPPWEJt+eRlkHdd9p+RiyalfJ1KlcvtFM72FBiJvVIsXd\nVVB9BQdiHsM4qpIpKV0kGzYb/70JsaRwoE6k1xd5qgxezGh+B3+DL2VOyncNWxSV\nvPuy1PJHWaSc9jswayh+ex8gYJo16lDUN+COZ0+xycYV/uAIYc+wIZ53S2Owg8Cy\ngUsa/Ee/01bAL5MgcjWFcpaHbFqxLwMm3fHVcDEsg3s2ROkn/PgV/Z7TOGRWqkY=\n=7Ve2\n-----END PGP SIGNATURE-----\n", "payload": "tree 394818604f165ef372b5aad8d028678c88320a39\nparent fb4652e85f1729412f6298aea033cb26b4755de9\nparent 2b27c6235b4feb1e2aaac2dde5c5c67a29470127\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1559616488 +0200\ncommitter GitHub <noreply@github.com> 1559616488 +0200\n\nRollup merge of #61409 - varkor:condition-trait-param-ice, r=oli-obk\n\nFix an ICE with a const argument in a trait\n\nThis goes some way towards fixing https://github.com/rust-lang/rust/issues/61383 (the reduced test case is fixed).\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/156351419611f3ee6f6b1327e6021676630e64a8", "html_url": "https://github.com/rust-lang/rust/commit/156351419611f3ee6f6b1327e6021676630e64a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/156351419611f3ee6f6b1327e6021676630e64a8/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb4652e85f1729412f6298aea033cb26b4755de9", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb4652e85f1729412f6298aea033cb26b4755de9", "html_url": "https://github.com/rust-lang/rust/commit/fb4652e85f1729412f6298aea033cb26b4755de9"}, {"sha": "2b27c6235b4feb1e2aaac2dde5c5c67a29470127", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b27c6235b4feb1e2aaac2dde5c5c67a29470127", "html_url": "https://github.com/rust-lang/rust/commit/2b27c6235b4feb1e2aaac2dde5c5c67a29470127"}], "stats": {"total": 183, "additions": 107, "deletions": 76}, "files": [{"sha": "3034cacf6253f966a98d1971db00de78995358ba", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 82, "deletions": 73, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/156351419611f3ee6f6b1327e6021676630e64a8/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/156351419611f3ee6f6b1327e6021676630e64a8/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=156351419611f3ee6f6b1327e6021676630e64a8", "patch": "@@ -1335,88 +1335,97 @@ pub fn checked_type_of<'a, 'tcx>(\n \n                 Node::Ty(&hir::Ty { node: hir::TyKind::Path(_), .. }) |\n                 Node::Expr(&hir::Expr { node: ExprKind::Struct(..), .. }) |\n-                Node::Expr(&hir::Expr { node: ExprKind::Path(_), .. }) => {\n+                Node::Expr(&hir::Expr { node: ExprKind::Path(_), .. }) |\n+                Node::TraitRef(..) => {\n                     let path = match parent_node {\n-                        Node::Ty(&hir::Ty { node: hir::TyKind::Path(ref path), .. }) |\n-                        Node::Expr(&hir::Expr { node: ExprKind::Path(ref path), .. }) => {\n-                            path\n+                        Node::Ty(&hir::Ty {\n+                            node: hir::TyKind::Path(QPath::Resolved(_, ref path)),\n+                            ..\n+                        })\n+                        | Node::Expr(&hir::Expr {\n+                            node: ExprKind::Path(QPath::Resolved(_, ref path)),\n+                            ..\n+                        }) => {\n+                            Some(&**path)\n                         }\n                         Node::Expr(&hir::Expr { node: ExprKind::Struct(ref path, ..), .. }) => {\n-                            &*path\n+                            if let QPath::Resolved(_, ref path) = **path {\n+                                Some(&**path)\n+                            } else {\n+                                None\n+                            }\n                         }\n-                        _ => unreachable!(),\n+                        Node::TraitRef(&hir::TraitRef { ref path, .. }) => Some(path),\n+                        _ => None,\n                     };\n \n-                    match path {\n-                        QPath::Resolved(_, ref path) => {\n-                            let arg_index = path.segments.iter()\n-                                .filter_map(|seg| seg.args.as_ref())\n-                                .map(|generic_args| generic_args.args.as_ref())\n-                                .find_map(|args| {\n-                                    args.iter()\n-                                        .filter(|arg| arg.is_const())\n-                                        .enumerate()\n-                                        .filter(|(_, arg)| arg.id() == hir_id)\n-                                        .map(|(index, _)| index)\n-                                        .next()\n-                                })\n-                                .or_else(|| {\n-                                    if !fail {\n-                                        None\n-                                    } else {\n-                                        bug!(\"no arg matching AnonConst in path\")\n-                                    }\n-                                })?;\n-\n-                            // We've encountered an `AnonConst` in some path, so we need to\n-                            // figure out which generic parameter it corresponds to and return\n-                            // the relevant type.\n-                            let generics = match path.res {\n-                                Res::Def(DefKind::Ctor(..), def_id) =>\n-                                    tcx.generics_of(tcx.parent(def_id).unwrap()),\n-                                Res::Def(_, def_id) =>\n-                                    tcx.generics_of(def_id),\n-                                Res::Err =>\n-                                    return Some(tcx.types.err),\n-                                _ if !fail =>\n-                                    return None,\n-                                x => {\n-                                    tcx.sess.delay_span_bug(\n-                                        DUMMY_SP,\n-                                        &format!(\n-                                            \"unexpected const parent path def {:?}\", x\n-                                        ),\n-                                    );\n-                                    return Some(tcx.types.err);\n+                    if let Some(path) = path {\n+                        let arg_index = path.segments.iter()\n+                            .filter_map(|seg| seg.args.as_ref())\n+                            .map(|generic_args| generic_args.args.as_ref())\n+                            .find_map(|args| {\n+                                args.iter()\n+                                    .filter(|arg| arg.is_const())\n+                                    .enumerate()\n+                                    .filter(|(_, arg)| arg.id() == hir_id)\n+                                    .map(|(index, _)| index)\n+                                    .next()\n+                            })\n+                            .or_else(|| {\n+                                if !fail {\n+                                    None\n+                                } else {\n+                                    bug!(\"no arg matching AnonConst in path\")\n                                 }\n-                            };\n-\n-                            generics.params.iter()\n-                                .filter(|param| {\n-                                    if let ty::GenericParamDefKind::Const = param.kind {\n-                                        true\n-                                    } else {\n-                                        false\n-                                    }\n-                                })\n-                                .nth(arg_index)\n-                                .map(|param| tcx.type_of(param.def_id))\n-                                // This is no generic parameter associated with the arg. This is\n-                                // probably from an extra arg where one is not needed.\n-                                .unwrap_or(tcx.types.err)\n-                        }\n-                        x => {\n-                            if !fail {\n-                                return None;\n+                            })?;\n+\n+                        // We've encountered an `AnonConst` in some path, so we need to\n+                        // figure out which generic parameter it corresponds to and return\n+                        // the relevant type.\n+                        let generics = match path.res {\n+                            Res::Def(DefKind::Ctor(..), def_id) => {\n+                                tcx.generics_of(tcx.parent(def_id).unwrap())\n                             }\n-                            tcx.sess.delay_span_bug(\n-                                DUMMY_SP,\n-                                &format!(\n-                                    \"unexpected const parent path {:?}\", x\n-                                ),\n-                            );\n-                            tcx.types.err\n+                            Res::Def(_, def_id) => tcx.generics_of(def_id),\n+                            Res::Err => return Some(tcx.types.err),\n+                            _ if !fail => return None,\n+                            res => {\n+                                tcx.sess.delay_span_bug(\n+                                    DUMMY_SP,\n+                                    &format!(\n+                                        \"unexpected const parent path def {:?}\",\n+                                        res,\n+                                    ),\n+                                );\n+                                return Some(tcx.types.err);\n+                            }\n+                        };\n+\n+                        generics.params.iter()\n+                            .filter(|param| {\n+                                if let ty::GenericParamDefKind::Const = param.kind {\n+                                    true\n+                                } else {\n+                                    false\n+                                }\n+                            })\n+                            .nth(arg_index)\n+                            .map(|param| tcx.type_of(param.def_id))\n+                            // This is no generic parameter associated with the arg. This is\n+                            // probably from an extra arg where one is not needed.\n+                            .unwrap_or(tcx.types.err)\n+                    } else {\n+                        if !fail {\n+                            return None;\n                         }\n+                        tcx.sess.delay_span_bug(\n+                            DUMMY_SP,\n+                            &format!(\n+                                \"unexpected const parent path {:?}\",\n+                                parent_node,\n+                            ),\n+                        );\n+                        return Some(tcx.types.err);\n                     }\n                 }\n "}, {"sha": "671b313c7f24ba4a101883d02ce58b56910367a4", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/156351419611f3ee6f6b1327e6021676630e64a8/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/156351419611f3ee6f6b1327e6021676630e64a8/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=156351419611f3ee6f6b1327e6021676630e64a8", "patch": "@@ -5244,9 +5244,13 @@ impl<'a> Parser<'a> {\n                     // FIXME(const_generics): to distinguish between idents for types and consts,\n                     // we should introduce a GenericArg::Ident in the AST and distinguish when\n                     // lowering to the HIR. For now, idents for const args are not permitted.\n-                    return Err(\n-                        self.fatal(\"identifiers may currently not be used for const generics\")\n-                    );\n+                    if self.token.is_keyword(kw::True) || self.token.is_keyword(kw::False) {\n+                        self.parse_literal_maybe_minus()?\n+                    } else {\n+                        return Err(\n+                            self.fatal(\"identifiers may currently not be used for const generics\")\n+                        );\n+                    }\n                 } else {\n                     self.parse_literal_maybe_minus()?\n                 };"}, {"sha": "091fe904826d4e1939cfb2509db1739445ab8312", "filename": "src/test/ui/const-generics/condition-in-trait-const-arg.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/156351419611f3ee6f6b1327e6021676630e64a8/src%2Ftest%2Fui%2Fconst-generics%2Fcondition-in-trait-const-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/156351419611f3ee6f6b1327e6021676630e64a8/src%2Ftest%2Fui%2Fconst-generics%2Fcondition-in-trait-const-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fcondition-in-trait-const-arg.rs?ref=156351419611f3ee6f6b1327e6021676630e64a8", "patch": "@@ -0,0 +1,12 @@\n+// run-pass\n+\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+trait IsZeroTrait<const IS_ZERO: bool>{}\n+\n+impl IsZeroTrait<{0u8 == 0u8}> for () {}\n+\n+impl IsZeroTrait<true> for ((),) {}\n+\n+fn main() {}"}, {"sha": "7c85651e7082f5746afd56b1f4ac8475397b9638", "filename": "src/test/ui/const-generics/condition-in-trait-const-arg.stderr", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/156351419611f3ee6f6b1327e6021676630e64a8/src%2Ftest%2Fui%2Fconst-generics%2Fcondition-in-trait-const-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/156351419611f3ee6f6b1327e6021676630e64a8/src%2Ftest%2Fui%2Fconst-generics%2Fcondition-in-trait-const-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fcondition-in-trait-const-arg.stderr?ref=156351419611f3ee6f6b1327e6021676630e64a8", "patch": "@@ -0,0 +1,6 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/condition-in-trait-const-arg.rs:3:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+"}]}