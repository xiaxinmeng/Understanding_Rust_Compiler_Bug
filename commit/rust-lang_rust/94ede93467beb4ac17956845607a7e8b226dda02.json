{"sha": "94ede93467beb4ac17956845607a7e8b226dda02", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0ZWRlOTM0NjdiZWI0YWMxNzk1Njg0NTYwN2E3ZThiMjI2ZGRhMDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-05T11:42:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-05T11:42:59Z"}, "message": "Auto merge of #44042 - LukasKalbertodt:ascii-methods-on-instrinsics, r=alexcrichton\n\nCopy all `AsciiExt` methods to the primitive types directly in order to deprecate it later\n\n**EDIT:** [this PR is ready now](https://github.com/rust-lang/rust/pull/44042#issuecomment-333883548). I edited this post to reflect the current status of discussion, which is (apart from code review) pretty much settled.\n\n---\n\nThis is my current progress in order to prepare stabilization of #39658. As discussed there (and in #39659), the idea is to deprecated `AsciiExt` and copy all methods to the type directly. Apparently there isn't really a reason to have those methods in an extension trait\u00b9.\n\n~~This is **work in progress**: copy&pasting code while slightly modifying the documentation isn't the most exciting thing to do. Therefore I wanted to already open this WIP PR after doing basically 1/4 of the job (copying methods to `&[u8]`, `char` and `&str` is still missing) to get some feedback before I continue. Some questions possibly worth discussing:~~\n\n1. ~~Does everyone agree that deprecating `AsciiExt` is a good idea? Does everyone agree with the goal of this PR?~~ => apparently yes\n2. ~~Are my changes OK so far? Did I do something wrong?~~\n3. ~~The issue of the unstable-attribute is currently set to 0. I would wait until you say \"Ok\" to the whole thing, then create a tracking issue and then insert the correct issue id. Is that ok?~~\n4. ~~I tweaked `eq_ignore_ascii_case()`: it now takes the argument `other: u8` instead of `other: &u8`. The latter was enforced by the trait. Since we're not bound to a trait anymore, we can drop the reference, ok?~~ => I reverted this, because the interface has to match the `AsciiExt` interface exactly.\n\n\u00b9 ~~Could it be that we can't write `impl [u8] {}`? This might be the reason for `AsciiExt`. If that is the case: is there a good reason we can't write such an impl block? What can we do instead?~~ => we couldn't at the time this PR was opened, but Simon made it possible.\n\n/cc @SimonSapin @zackw", "tree": {"sha": "efce44ea2cdc5c71fa03405dbd4bca2a4a20b99b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/efce44ea2cdc5c71fa03405dbd4bca2a4a20b99b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94ede93467beb4ac17956845607a7e8b226dda02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94ede93467beb4ac17956845607a7e8b226dda02", "html_url": "https://github.com/rust-lang/rust/commit/94ede93467beb4ac17956845607a7e8b226dda02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94ede93467beb4ac17956845607a7e8b226dda02/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4efcc660f09ce3e83d194889f6d1161bf865f788", "url": "https://api.github.com/repos/rust-lang/rust/commits/4efcc660f09ce3e83d194889f6d1161bf865f788", "html_url": "https://github.com/rust-lang/rust/commit/4efcc660f09ce3e83d194889f6d1161bf865f788"}, {"sha": "ea55596d5bc29708232a0bb232bf35d5e2e6cbce", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea55596d5bc29708232a0bb232bf35d5e2e6cbce", "html_url": "https://github.com/rust-lang/rust/commit/ea55596d5bc29708232a0bb232bf35d5e2e6cbce"}], "stats": {"total": 2416, "additions": 1791, "deletions": 625}, "files": [{"sha": "38c94d4d8b5f36a64739c7b2d4192be4876b7e5d", "filename": "src/liballoc/benches/str.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/94ede93467beb4ac17956845607a7e8b226dda02/src%2Fliballoc%2Fbenches%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ede93467beb4ac17956845607a7e8b226dda02/src%2Fliballoc%2Fbenches%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fstr.rs?ref=94ede93467beb4ac17956845607a7e8b226dda02", "patch": "@@ -272,15 +272,12 @@ make_test!(match_indices_a_str, s, s.match_indices(\"a\").count());\n make_test!(split_a_str, s, s.split(\"a\").count());\n \n make_test!(trim_ascii_char, s, {\n-    use std::ascii::AsciiExt;\n     s.trim_matches(|c: char| c.is_ascii())\n });\n make_test!(trim_left_ascii_char, s, {\n-    use std::ascii::AsciiExt;\n     s.trim_left_matches(|c: char| c.is_ascii())\n });\n make_test!(trim_right_ascii_char, s, {\n-    use std::ascii::AsciiExt;\n     s.trim_right_matches(|c: char| c.is_ascii())\n });\n "}, {"sha": "e8aff0998715726bc21c4908b790a71f19400535", "filename": "src/liballoc/borrow.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/94ede93467beb4ac17956845607a7e8b226dda02/src%2Fliballoc%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ede93467beb4ac17956845607a7e8b226dda02/src%2Fliballoc%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fborrow.rs?ref=94ede93467beb4ac17956845607a7e8b226dda02", "patch": "@@ -191,7 +191,6 @@ impl<'a, B: ?Sized> Cow<'a, B>\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::ascii::AsciiExt;\n     /// use std::borrow::Cow;\n     ///\n     /// let mut cow = Cow::Borrowed(\"foo\");"}, {"sha": "a40ed060604a7b1e4f8e19f30366d2a6fd15413a", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/94ede93467beb4ac17956845607a7e8b226dda02/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ede93467beb4ac17956845607a7e8b226dda02/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=94ede93467beb4ac17956845607a7e8b226dda02", "patch": "@@ -83,6 +83,7 @@\n #![cfg_attr(not(test), feature(generator_trait))]\n #![cfg_attr(test, feature(rand, test))]\n #![feature(allow_internal_unstable)]\n+#![feature(ascii_ctype)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(cfg_target_has_atomic)]"}, {"sha": "b41cb912fe798d892ad01ba9119f74a469e3f38b", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/94ede93467beb4ac17956845607a7e8b226dda02/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ede93467beb4ac17956845607a7e8b226dda02/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=94ede93467beb4ac17956845607a7e8b226dda02", "patch": "@@ -1533,6 +1533,215 @@ impl<T> [T] {\n     }\n }\n \n+// FIXME(LukasKalbertodt): the `not(stage0)` constraint can be removed in the\n+// future once the stage0 compiler is new enough to know about the `slice_u8`\n+// lang item.\n+#[lang = \"slice_u8\"]\n+#[cfg(all(not(stage0), not(test)))]\n+impl [u8] {\n+    /// Checks if all bytes in this slice are within the ASCII range.\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn is_ascii(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii())\n+    }\n+\n+    /// Returns a vector containing a copy of this slice where each byte\n+    /// is mapped to its ASCII upper case equivalent.\n+    ///\n+    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To uppercase the value in-place, use [`make_ascii_uppercase`].\n+    ///\n+    /// [`make_ascii_uppercase`]: #method.make_ascii_uppercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn to_ascii_uppercase(&self) -> Vec<u8> {\n+        let mut me = self.to_vec();\n+        me.make_ascii_uppercase();\n+        me\n+    }\n+\n+    /// Returns a vector containing a copy of this slice where each byte\n+    /// is mapped to its ASCII lower case equivalent.\n+    ///\n+    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To lowercase the value in-place, use [`make_ascii_lowercase`].\n+    ///\n+    /// [`make_ascii_lowercase`]: #method.make_ascii_lowercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn to_ascii_lowercase(&self) -> Vec<u8> {\n+        let mut me = self.to_vec();\n+        me.make_ascii_lowercase();\n+        me\n+    }\n+\n+    /// Checks that two slices are an ASCII case-insensitive match.\n+    ///\n+    /// Same as `to_ascii_lowercase(a) == to_ascii_lowercase(b)`,\n+    /// but without allocating and copying temporaries.\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn eq_ignore_ascii_case(&self, other: &[u8]) -> bool {\n+        self.len() == other.len() &&\n+            self.iter().zip(other).all(|(a, b)| {\n+                a.eq_ignore_ascii_case(b)\n+            })\n+    }\n+\n+    /// Converts this slice to its ASCII upper case equivalent in-place.\n+    ///\n+    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To return a new uppercased value without modifying the existing one, use\n+    /// [`to_ascii_uppercase`].\n+    ///\n+    /// [`to_ascii_uppercase`]: #method.to_ascii_uppercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn make_ascii_uppercase(&mut self) {\n+        for byte in self {\n+            byte.make_ascii_uppercase();\n+        }\n+    }\n+\n+    /// Converts this slice to its ASCII lower case equivalent in-place.\n+    ///\n+    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To return a new lowercased value without modifying the existing one, use\n+    /// [`to_ascii_lowercase`].\n+    ///\n+    /// [`to_ascii_lowercase`]: #method.to_ascii_lowercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn make_ascii_lowercase(&mut self) {\n+        for byte in self {\n+            byte.make_ascii_lowercase();\n+        }\n+    }\n+\n+    /// Checks if all bytes of this slice are ASCII alphabetic characters:\n+    ///\n+    /// - U+0041 'A' ... U+005A 'Z', or\n+    /// - U+0061 'a' ... U+007A 'z'.\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[inline]\n+    pub fn is_ascii_alphabetic(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_alphabetic())\n+    }\n+\n+    /// Checks if all bytes of this slice are ASCII uppercase characters:\n+    /// U+0041 'A' ... U+005A 'Z'.\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[inline]\n+    pub fn is_ascii_uppercase(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_uppercase())\n+    }\n+\n+    /// Checks if all bytes of this slice are ASCII lowercase characters:\n+    /// U+0061 'a' ... U+007A 'z'.\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[inline]\n+    pub fn is_ascii_lowercase(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_lowercase())\n+    }\n+\n+    /// Checks if all bytes of this slice are ASCII alphanumeric characters:\n+    ///\n+    /// - U+0041 'A' ... U+005A 'Z', or\n+    /// - U+0061 'a' ... U+007A 'z', or\n+    /// - U+0030 '0' ... U+0039 '9'.\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[inline]\n+    pub fn is_ascii_alphanumeric(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_alphanumeric())\n+    }\n+\n+    /// Checks if all bytes of this slice are ASCII decimal digit:\n+    /// U+0030 '0' ... U+0039 '9'.\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[inline]\n+    pub fn is_ascii_digit(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_digit())\n+    }\n+\n+    /// Checks if all bytes of this slice are ASCII hexadecimal digits:\n+    ///\n+    /// - U+0030 '0' ... U+0039 '9', or\n+    /// - U+0041 'A' ... U+0046 'F', or\n+    /// - U+0061 'a' ... U+0066 'f'.\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[inline]\n+    pub fn is_ascii_hexdigit(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_hexdigit())\n+    }\n+\n+    /// Checks if all bytes of this slice are ASCII punctuation characters:\n+    ///\n+    /// - U+0021 ... U+002F `! \" # $ % & ' ( ) * + , - . /`, or\n+    /// - U+003A ... U+0040 `: ; < = > ? @`, or\n+    /// - U+005B ... U+0060 `[ \\\\ ] ^ _ \\``, or\n+    /// - U+007B ... U+007E `{ | } ~`\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[inline]\n+    pub fn is_ascii_punctuation(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_punctuation())\n+    }\n+\n+    /// Checks if all bytes of this slice are ASCII graphic characters:\n+    /// U+0021 '@' ... U+007E '~'.\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[inline]\n+    pub fn is_ascii_graphic(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_graphic())\n+    }\n+\n+    /// Checks if all bytes of this slice are ASCII whitespace characters:\n+    /// U+0020 SPACE, U+0009 HORIZONTAL TAB, U+000A LINE FEED,\n+    /// U+000C FORM FEED, or U+000D CARRIAGE RETURN.\n+    ///\n+    /// Rust uses the WhatWG Infra Standard's [definition of ASCII\n+    /// whitespace][infra-aw]. There are several other definitions in\n+    /// wide use. For instance, [the POSIX locale][pct] includes\n+    /// U+000B VERTICAL TAB as well as all the above characters,\n+    /// but\u2014from the very same specification\u2014[the default rule for\n+    /// \"field splitting\" in the Bourne shell][bfs] considers *only*\n+    /// SPACE, HORIZONTAL TAB, and LINE FEED as whitespace.\n+    ///\n+    /// If you are writing a program that will process an existing\n+    /// file format, check what that format's definition of whitespace is\n+    /// before using this function.\n+    ///\n+    /// [infra-aw]: https://infra.spec.whatwg.org/#ascii-whitespace\n+    /// [pct]: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap07.html#tag_07_03_01\n+    /// [bfs]: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_05\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[inline]\n+    pub fn is_ascii_whitespace(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_whitespace())\n+    }\n+\n+    /// Checks if all bytes of this slice are ASCII control characters:\n+    ///\n+    /// - U+0000 NUL ... U+001F UNIT SEPARATOR, or\n+    /// - U+007F DELETE.\n+    ///\n+    /// Note that most ASCII whitespace characters are control\n+    /// characters, but SPACE is not.\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[inline]\n+    pub fn is_ascii_control(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_control())\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Extension traits for slices over specific kinds of data\n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "5f0b4088fc07eaa53f5f3962985d53d327610da8", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 280, "deletions": 4, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/94ede93467beb4ac17956845607a7e8b226dda02/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ede93467beb4ac17956845607a7e8b226dda02/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=94ede93467beb4ac17956845607a7e8b226dda02", "patch": "@@ -390,8 +390,6 @@ impl str {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::ascii::AsciiExt;\n-    ///\n     /// let mut v = String::from(\"hello\");\n     /// // correct length\n     /// assert!(v.get_mut(0..5).is_some());\n@@ -617,8 +615,6 @@ impl str {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// use std::ascii::AsciiExt;\n-    ///\n     /// let mut s = \"Per Martin-L\u00f6f\".to_string();\n     /// {\n     ///     let (first, last) = s.split_at_mut(3);\n@@ -2070,6 +2066,286 @@ impl str {\n         s.extend((0..n).map(|_| self));\n         s\n     }\n+\n+    /// Checks if all characters in this string are within the ASCII range.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let ascii = \"hello!\\n\";\n+    /// let non_ascii = \"Gr\u00fc\u00dfe, J\u00fcrgen \u2764\";\n+    ///\n+    /// assert!(ascii.is_ascii());\n+    /// assert!(!non_ascii.is_ascii());\n+    /// ```\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn is_ascii(&self) -> bool {\n+        // We can treat each byte as character here: all multibyte characters\n+        // start with a byte that is not in the ascii range, so we will stop\n+        // there already.\n+        self.bytes().all(|b| b.is_ascii())\n+    }\n+\n+    /// Returns a copy of this string where each character is mapped to its\n+    /// ASCII upper case equivalent.\n+    ///\n+    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To uppercase the value in-place, use [`make_ascii_uppercase`].\n+    ///\n+    /// To uppercase ASCII characters in addition to non-ASCII characters, use\n+    /// [`to_uppercase`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = \"Gr\u00fc\u00dfe, J\u00fcrgen \u2764\";\n+    ///\n+    /// assert_eq!(\"GR\u00fc\u00dfE, J\u00fcRGEN \u2764\", s.to_ascii_uppercase());\n+    /// ```\n+    ///\n+    /// [`make_ascii_uppercase`]: #method.make_ascii_uppercase\n+    /// [`to_uppercase`]: #method.to_uppercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    pub fn to_ascii_uppercase(&self) -> String {\n+        let mut bytes = self.as_bytes().to_vec();\n+        bytes.make_ascii_uppercase();\n+        // make_ascii_uppercase() preserves the UTF-8 invariant.\n+        unsafe { String::from_utf8_unchecked(bytes) }\n+    }\n+\n+    /// Returns a copy of this string where each character is mapped to its\n+    /// ASCII lower case equivalent.\n+    ///\n+    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To lowercase the value in-place, use [`make_ascii_lowercase`].\n+    ///\n+    /// To lowercase ASCII characters in addition to non-ASCII characters, use\n+    /// [`to_lowercase`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = \"Gr\u00fc\u00dfe, J\u00fcrgen \u2764\";\n+    ///\n+    /// assert_eq!(\"gr\u00fc\u00dfe, j\u00fcrgen \u2764\", s.to_ascii_lowercase());\n+    /// ```\n+    ///\n+    /// [`make_ascii_lowercase`]: #method.make_ascii_lowercase\n+    /// [`to_lowercase`]: #method.to_lowercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    pub fn to_ascii_lowercase(&self) -> String {\n+        let mut bytes = self.as_bytes().to_vec();\n+        bytes.make_ascii_lowercase();\n+        // make_ascii_lowercase() preserves the UTF-8 invariant.\n+        unsafe { String::from_utf8_unchecked(bytes) }\n+    }\n+\n+    /// Checks that two strings are an ASCII case-insensitive match.\n+    ///\n+    /// Same as `to_ascii_lowercase(a) == to_ascii_lowercase(b)`,\n+    /// but without allocating and copying temporaries.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert!(\"Ferris\".eq_ignore_ascii_case(\"FERRIS\"));\n+    /// assert!(\"Ferr\u00f6s\".eq_ignore_ascii_case(\"FERR\u00f6S\"));\n+    /// assert!(!\"Ferr\u00f6s\".eq_ignore_ascii_case(\"FERR\u00d6S\"));\n+    /// ```\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    pub fn eq_ignore_ascii_case(&self, other: &str) -> bool {\n+        self.as_bytes().eq_ignore_ascii_case(other.as_bytes())\n+    }\n+\n+    /// Converts this string to its ASCII upper case equivalent in-place.\n+    ///\n+    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To return a new uppercased value without modifying the existing one, use\n+    /// [`to_ascii_uppercase`].\n+    ///\n+    /// [`to_ascii_uppercase`]: #method.to_ascii_uppercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[cfg(not(stage0))]\n+    pub fn make_ascii_uppercase(&mut self) {\n+        let me = unsafe { self.as_bytes_mut() };\n+        me.make_ascii_uppercase()\n+    }\n+\n+    /// Converts this string to its ASCII lower case equivalent in-place.\n+    ///\n+    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To return a new lowercased value without modifying the existing one, use\n+    /// [`to_ascii_lowercase`].\n+    ///\n+    /// [`to_ascii_lowercase`]: #method.to_ascii_lowercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[cfg(not(stage0))]\n+    pub fn make_ascii_lowercase(&mut self) {\n+        let me = unsafe { self.as_bytes_mut() };\n+        me.make_ascii_lowercase()\n+    }\n+\n+    /// Checks if all characters of this string are ASCII alphabetic\n+    /// characters:\n+    ///\n+    /// - U+0041 'A' ... U+005A 'Z', or\n+    /// - U+0061 'a' ... U+007A 'z'.\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[inline]\n+    pub fn is_ascii_alphabetic(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_alphabetic())\n+    }\n+\n+    /// Checks if all characters of this string are ASCII uppercase characters:\n+    /// U+0041 'A' ... U+005A 'Z'.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// #![feature(ascii_ctype)]\n+    ///\n+    /// // Only ascii uppercase characters\n+    /// assert!(\"HELLO\".is_ascii_uppercase());\n+    ///\n+    /// // While all characters are ascii, 'y' and 'e' are not uppercase\n+    /// assert!(!\"Bye\".is_ascii_uppercase());\n+    ///\n+    /// // While all characters are uppercase, '\u00dc' is not ascii\n+    /// assert!(!\"TSCH\u00dcSS\".is_ascii_uppercase());\n+    /// ```\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[inline]\n+    pub fn is_ascii_uppercase(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_uppercase())\n+    }\n+\n+    /// Checks if all characters of this string are ASCII lowercase characters:\n+    /// U+0061 'a' ... U+007A 'z'.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// #![feature(ascii_ctype)]\n+    ///\n+    /// // Only ascii uppercase characters\n+    /// assert!(\"hello\".is_ascii_lowercase());\n+    ///\n+    /// // While all characters are ascii, 'B' is not lowercase\n+    /// assert!(!\"Bye\".is_ascii_lowercase());\n+    ///\n+    /// // While all characters are lowercase, '\u00dc' is not ascii\n+    /// assert!(!\"tsch\u00fcss\".is_ascii_lowercase());\n+    /// ```\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[inline]\n+    pub fn is_ascii_lowercase(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_lowercase())\n+    }\n+\n+    /// Checks if all characters of this string are ASCII alphanumeric\n+    /// characters:\n+    ///\n+    /// - U+0041 'A' ... U+005A 'Z', or\n+    /// - U+0061 'a' ... U+007A 'z', or\n+    /// - U+0030 '0' ... U+0039 '9'.\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[inline]\n+    pub fn is_ascii_alphanumeric(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_alphanumeric())\n+    }\n+\n+    /// Checks if all characters of this string are ASCII decimal digit:\n+    /// U+0030 '0' ... U+0039 '9'.\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[inline]\n+    pub fn is_ascii_digit(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_digit())\n+    }\n+\n+    /// Checks if all characters of this string are ASCII hexadecimal digits:\n+    ///\n+    /// - U+0030 '0' ... U+0039 '9', or\n+    /// - U+0041 'A' ... U+0046 'F', or\n+    /// - U+0061 'a' ... U+0066 'f'.\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[inline]\n+    pub fn is_ascii_hexdigit(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_hexdigit())\n+    }\n+\n+    /// Checks if all characters of this string are ASCII punctuation\n+    /// characters:\n+    ///\n+    /// - U+0021 ... U+002F `! \" # $ % & ' ( ) * + , - . /`, or\n+    /// - U+003A ... U+0040 `: ; < = > ? @`, or\n+    /// - U+005B ... U+0060 `[ \\\\ ] ^ _ \\``, or\n+    /// - U+007B ... U+007E `{ | } ~`\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[inline]\n+    pub fn is_ascii_punctuation(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_punctuation())\n+    }\n+\n+    /// Checks if all characters of this string are ASCII graphic characters:\n+    /// U+0021 '@' ... U+007E '~'.\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[inline]\n+    pub fn is_ascii_graphic(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_graphic())\n+    }\n+\n+    /// Checks if all characters of this string are ASCII whitespace characters:\n+    /// U+0020 SPACE, U+0009 HORIZONTAL TAB, U+000A LINE FEED,\n+    /// U+000C FORM FEED, or U+000D CARRIAGE RETURN.\n+    ///\n+    /// Rust uses the WhatWG Infra Standard's [definition of ASCII\n+    /// whitespace][infra-aw]. There are several other definitions in\n+    /// wide use. For instance, [the POSIX locale][pct] includes\n+    /// U+000B VERTICAL TAB as well as all the above characters,\n+    /// but\u2014from the very same specification\u2014[the default rule for\n+    /// \"field splitting\" in the Bourne shell][bfs] considers *only*\n+    /// SPACE, HORIZONTAL TAB, and LINE FEED as whitespace.\n+    ///\n+    /// If you are writing a program that will process an existing\n+    /// file format, check what that format's definition of whitespace is\n+    /// before using this function.\n+    ///\n+    /// [infra-aw]: https://infra.spec.whatwg.org/#ascii-whitespace\n+    /// [pct]: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap07.html#tag_07_03_01\n+    /// [bfs]: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_05\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[inline]\n+    pub fn is_ascii_whitespace(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_whitespace())\n+    }\n+\n+    /// Checks if all characters of this string are ASCII control characters:\n+    ///\n+    /// - U+0000 NUL ... U+001F UNIT SEPARATOR, or\n+    /// - U+007F DELETE.\n+    ///\n+    /// Note that most ASCII whitespace characters are control\n+    /// characters, but SPACE is not.\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[inline]\n+    pub fn is_ascii_control(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_control())\n+    }\n }\n \n /// Converts a boxed slice of bytes to a boxed string slice without checking"}, {"sha": "25fcc1ccdab589e8c774572c82098967ec58a563", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ede93467beb4ac17956845607a7e8b226dda02/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ede93467beb4ac17956845607a7e8b226dda02/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=94ede93467beb4ac17956845607a7e8b226dda02", "patch": "@@ -773,8 +773,6 @@ impl String {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// use std::ascii::AsciiExt;\n-    ///\n     /// let mut s = String::from(\"foobar\");\n     /// let s_mut_str = s.as_mut_str();\n     ///"}, {"sha": "6b075e7ac0e0d0f47f1fbd776973306e048abcf6", "filename": "src/liballoc/tests/str.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/94ede93467beb4ac17956845607a7e8b226dda02/src%2Fliballoc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ede93467beb4ac17956845607a7e8b226dda02/src%2Fliballoc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstr.rs?ref=94ede93467beb4ac17956845607a7e8b226dda02", "patch": "@@ -706,7 +706,6 @@ fn test_split_at() {\n \n #[test]\n fn test_split_at_mut() {\n-    use std::ascii::AsciiExt;\n     let mut s = \"Hello World\".to_string();\n     {\n         let (a, b) = s.split_at_mut(5);"}, {"sha": "9cfde5dcc73c8433b0f37f030a30b1b0b6fbb9b0", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/94ede93467beb4ac17956845607a7e8b226dda02/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ede93467beb4ac17956845607a7e8b226dda02/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=94ede93467beb4ac17956845607a7e8b226dda02", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::ascii::AsciiExt;\n use std::borrow::Cow;\n use std::mem::size_of;\n use std::panic;\n@@ -966,5 +965,3 @@ fn drain_filter_complex() {\n         assert_eq!(vec, vec![1, 3, 5, 7, 9, 11, 13, 15, 17, 19]);\n     }\n }\n-\n-"}, {"sha": "5aca199cf40c068896632a566ab7bd30e0eed334", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ede93467beb4ac17956845607a7e8b226dda02/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ede93467beb4ac17956845607a7e8b226dda02/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=94ede93467beb4ac17956845607a7e8b226dda02", "patch": "@@ -853,8 +853,6 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::ascii::AsciiExt;\n-    ///\n     /// let mut vec = vec![\"foo\", \"bar\", \"Bar\", \"baz\", \"bar\"];\n     ///\n     /// vec.dedup_by(|a, b| a.eq_ignore_ascii_case(b));"}, {"sha": "7fe0aabeec9e90e4f14f41528a6379232de115cd", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 644, "deletions": 0, "changes": 644, "blob_url": "https://github.com/rust-lang/rust/blob/94ede93467beb4ac17956845607a7e8b226dda02/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ede93467beb4ac17956845607a7e8b226dda02/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=94ede93467beb4ac17956845607a7e8b226dda02", "patch": "@@ -2259,6 +2259,547 @@ impl u8 {\n         intrinsics::add_with_overflow,\n         intrinsics::sub_with_overflow,\n         intrinsics::mul_with_overflow }\n+\n+\n+    /// Checks if the value is within the ASCII range.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let ascii = 97u8;\n+    /// let non_ascii = 150u8;\n+    ///\n+    /// assert!(ascii.is_ascii());\n+    /// assert!(!non_ascii.is_ascii());\n+    /// ```\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn is_ascii(&self) -> bool {\n+        *self & 128 == 0\n+    }\n+\n+    /// Makes a copy of the value in its ASCII upper case equivalent.\n+    ///\n+    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To uppercase the value in-place, use [`make_ascii_uppercase`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let lowercase_a = 97u8;\n+    ///\n+    /// assert_eq!(65, lowercase_a.to_ascii_uppercase());\n+    /// ```\n+    ///\n+    /// [`make_ascii_uppercase`]: #method.make_ascii_uppercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn to_ascii_uppercase(&self) -> u8 {\n+        ASCII_UPPERCASE_MAP[*self as usize]\n+    }\n+\n+    /// Makes a copy of the value in its ASCII lower case equivalent.\n+    ///\n+    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To lowercase the value in-place, use [`make_ascii_lowercase`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let uppercase_a = 65u8;\n+    ///\n+    /// assert_eq!(97, uppercase_a.to_ascii_lowercase());\n+    /// ```\n+    ///\n+    /// [`make_ascii_lowercase`]: #method.make_ascii_lowercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn to_ascii_lowercase(&self) -> u8 {\n+        ASCII_LOWERCASE_MAP[*self as usize]\n+    }\n+\n+    /// Checks that two values are an ASCII case-insensitive match.\n+    ///\n+    /// This is equivalent to `to_ascii_lowercase(a) == to_ascii_lowercase(b)`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let lowercase_a = 97u8;\n+    /// let uppercase_a = 65u8;\n+    ///\n+    /// assert!(lowercase_a.eq_ignore_ascii_case(&uppercase_a));\n+    /// ```\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn eq_ignore_ascii_case(&self, other: &u8) -> bool {\n+        self.to_ascii_lowercase() == other.to_ascii_lowercase()\n+    }\n+\n+    /// Converts this value to its ASCII upper case equivalent in-place.\n+    ///\n+    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To return a new uppercased value without modifying the existing one, use\n+    /// [`to_ascii_uppercase`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut byte = b'a';\n+    ///\n+    /// byte.make_ascii_uppercase();\n+    ///\n+    /// assert_eq!(b'A', byte);\n+    /// ```\n+    ///\n+    /// [`to_ascii_uppercase`]: #method.to_ascii_uppercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn make_ascii_uppercase(&mut self) {\n+        *self = self.to_ascii_uppercase();\n+    }\n+\n+    /// Converts this value to its ASCII lower case equivalent in-place.\n+    ///\n+    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To return a new lowercased value without modifying the existing one, use\n+    /// [`to_ascii_lowercase`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut byte = b'A';\n+    ///\n+    /// byte.make_ascii_lowercase();\n+    ///\n+    /// assert_eq!(b'a', byte);\n+    /// ```\n+    ///\n+    /// [`to_ascii_lowercase`]: #method.to_ascii_lowercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn make_ascii_lowercase(&mut self) {\n+        *self = self.to_ascii_lowercase();\n+    }\n+\n+    /// Checks if the value is an ASCII alphabetic character:\n+    ///\n+    /// - U+0041 'A' ... U+005A 'Z', or\n+    /// - U+0061 'a' ... U+007A 'z'.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_ctype)]\n+    ///\n+    /// let uppercase_a = b'A';\n+    /// let uppercase_g = b'G';\n+    /// let a = b'a';\n+    /// let g = b'g';\n+    /// let zero = b'0';\n+    /// let percent = b'%';\n+    /// let space = b' ';\n+    /// let lf = b'\\n';\n+    /// let esc = 0x1b_u8;\n+    ///\n+    /// assert!(uppercase_a.is_ascii_alphabetic());\n+    /// assert!(uppercase_g.is_ascii_alphabetic());\n+    /// assert!(a.is_ascii_alphabetic());\n+    /// assert!(g.is_ascii_alphabetic());\n+    /// assert!(!zero.is_ascii_alphabetic());\n+    /// assert!(!percent.is_ascii_alphabetic());\n+    /// assert!(!space.is_ascii_alphabetic());\n+    /// assert!(!lf.is_ascii_alphabetic());\n+    /// assert!(!esc.is_ascii_alphabetic());\n+    /// ```\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[inline]\n+    pub fn is_ascii_alphabetic(&self) -> bool {\n+        if *self >= 0x80 { return false; }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            L | Lx | U | Ux => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// Checks if the value is an ASCII uppercase character:\n+    /// U+0041 'A' ... U+005A 'Z'.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_ctype)]\n+    ///\n+    /// let uppercase_a = b'A';\n+    /// let uppercase_g = b'G';\n+    /// let a = b'a';\n+    /// let g = b'g';\n+    /// let zero = b'0';\n+    /// let percent = b'%';\n+    /// let space = b' ';\n+    /// let lf = b'\\n';\n+    /// let esc = 0x1b_u8;\n+    ///\n+    /// assert!(uppercase_a.is_ascii_uppercase());\n+    /// assert!(uppercase_g.is_ascii_uppercase());\n+    /// assert!(!a.is_ascii_uppercase());\n+    /// assert!(!g.is_ascii_uppercase());\n+    /// assert!(!zero.is_ascii_uppercase());\n+    /// assert!(!percent.is_ascii_uppercase());\n+    /// assert!(!space.is_ascii_uppercase());\n+    /// assert!(!lf.is_ascii_uppercase());\n+    /// assert!(!esc.is_ascii_uppercase());\n+    /// ```\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[inline]\n+    pub fn is_ascii_uppercase(&self) -> bool {\n+        if *self >= 0x80 { return false }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            U | Ux => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// Checks if the value is an ASCII lowercase character:\n+    /// U+0061 'a' ... U+007A 'z'.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_ctype)]\n+    ///\n+    /// let uppercase_a = b'A';\n+    /// let uppercase_g = b'G';\n+    /// let a = b'a';\n+    /// let g = b'g';\n+    /// let zero = b'0';\n+    /// let percent = b'%';\n+    /// let space = b' ';\n+    /// let lf = b'\\n';\n+    /// let esc = 0x1b_u8;\n+    ///\n+    /// assert!(!uppercase_a.is_ascii_lowercase());\n+    /// assert!(!uppercase_g.is_ascii_lowercase());\n+    /// assert!(a.is_ascii_lowercase());\n+    /// assert!(g.is_ascii_lowercase());\n+    /// assert!(!zero.is_ascii_lowercase());\n+    /// assert!(!percent.is_ascii_lowercase());\n+    /// assert!(!space.is_ascii_lowercase());\n+    /// assert!(!lf.is_ascii_lowercase());\n+    /// assert!(!esc.is_ascii_lowercase());\n+    /// ```\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[inline]\n+    pub fn is_ascii_lowercase(&self) -> bool {\n+        if *self >= 0x80 { return false }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            L | Lx => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// Checks if the value is an ASCII alphanumeric character:\n+    ///\n+    /// - U+0041 'A' ... U+005A 'Z', or\n+    /// - U+0061 'a' ... U+007A 'z', or\n+    /// - U+0030 '0' ... U+0039 '9'.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_ctype)]\n+    ///\n+    /// let uppercase_a = b'A';\n+    /// let uppercase_g = b'G';\n+    /// let a = b'a';\n+    /// let g = b'g';\n+    /// let zero = b'0';\n+    /// let percent = b'%';\n+    /// let space = b' ';\n+    /// let lf = b'\\n';\n+    /// let esc = 0x1b_u8;\n+    ///\n+    /// assert!(uppercase_a.is_ascii_alphanumeric());\n+    /// assert!(uppercase_g.is_ascii_alphanumeric());\n+    /// assert!(a.is_ascii_alphanumeric());\n+    /// assert!(g.is_ascii_alphanumeric());\n+    /// assert!(zero.is_ascii_alphanumeric());\n+    /// assert!(!percent.is_ascii_alphanumeric());\n+    /// assert!(!space.is_ascii_alphanumeric());\n+    /// assert!(!lf.is_ascii_alphanumeric());\n+    /// assert!(!esc.is_ascii_alphanumeric());\n+    /// ```\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[inline]\n+    pub fn is_ascii_alphanumeric(&self) -> bool {\n+        if *self >= 0x80 { return false }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            D | L | Lx | U | Ux => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// Checks if the value is an ASCII decimal digit:\n+    /// U+0030 '0' ... U+0039 '9'.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_ctype)]\n+    ///\n+    /// let uppercase_a = b'A';\n+    /// let uppercase_g = b'G';\n+    /// let a = b'a';\n+    /// let g = b'g';\n+    /// let zero = b'0';\n+    /// let percent = b'%';\n+    /// let space = b' ';\n+    /// let lf = b'\\n';\n+    /// let esc = 0x1b_u8;\n+    ///\n+    /// assert!(!uppercase_a.is_ascii_digit());\n+    /// assert!(!uppercase_g.is_ascii_digit());\n+    /// assert!(!a.is_ascii_digit());\n+    /// assert!(!g.is_ascii_digit());\n+    /// assert!(zero.is_ascii_digit());\n+    /// assert!(!percent.is_ascii_digit());\n+    /// assert!(!space.is_ascii_digit());\n+    /// assert!(!lf.is_ascii_digit());\n+    /// assert!(!esc.is_ascii_digit());\n+    /// ```\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[inline]\n+    pub fn is_ascii_digit(&self) -> bool {\n+        if *self >= 0x80 { return false }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            D => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// Checks if the value is an ASCII hexadecimal digit:\n+    ///\n+    /// - U+0030 '0' ... U+0039 '9', or\n+    /// - U+0041 'A' ... U+0046 'F', or\n+    /// - U+0061 'a' ... U+0066 'f'.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_ctype)]\n+    ///\n+    /// let uppercase_a = b'A';\n+    /// let uppercase_g = b'G';\n+    /// let a = b'a';\n+    /// let g = b'g';\n+    /// let zero = b'0';\n+    /// let percent = b'%';\n+    /// let space = b' ';\n+    /// let lf = b'\\n';\n+    /// let esc = 0x1b_u8;\n+    ///\n+    /// assert!(uppercase_a.is_ascii_hexdigit());\n+    /// assert!(!uppercase_g.is_ascii_hexdigit());\n+    /// assert!(a.is_ascii_hexdigit());\n+    /// assert!(!g.is_ascii_hexdigit());\n+    /// assert!(zero.is_ascii_hexdigit());\n+    /// assert!(!percent.is_ascii_hexdigit());\n+    /// assert!(!space.is_ascii_hexdigit());\n+    /// assert!(!lf.is_ascii_hexdigit());\n+    /// assert!(!esc.is_ascii_hexdigit());\n+    /// ```\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[inline]\n+    pub fn is_ascii_hexdigit(&self) -> bool {\n+        if *self >= 0x80 { return false }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            D | Lx | Ux => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// Checks if the value is an ASCII punctuation character:\n+    ///\n+    /// - U+0021 ... U+002F `! \" # $ % & ' ( ) * + , - . /`, or\n+    /// - U+003A ... U+0040 `: ; < = > ? @`, or\n+    /// - U+005B ... U+0060 `[ \\\\ ] ^ _ \\``, or\n+    /// - U+007B ... U+007E `{ | } ~`\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_ctype)]\n+    ///\n+    /// let uppercase_a = b'A';\n+    /// let uppercase_g = b'G';\n+    /// let a = b'a';\n+    /// let g = b'g';\n+    /// let zero = b'0';\n+    /// let percent = b'%';\n+    /// let space = b' ';\n+    /// let lf = b'\\n';\n+    /// let esc = 0x1b_u8;\n+    ///\n+    /// assert!(!uppercase_a.is_ascii_punctuation());\n+    /// assert!(!uppercase_g.is_ascii_punctuation());\n+    /// assert!(!a.is_ascii_punctuation());\n+    /// assert!(!g.is_ascii_punctuation());\n+    /// assert!(!zero.is_ascii_punctuation());\n+    /// assert!(percent.is_ascii_punctuation());\n+    /// assert!(!space.is_ascii_punctuation());\n+    /// assert!(!lf.is_ascii_punctuation());\n+    /// assert!(!esc.is_ascii_punctuation());\n+    /// ```\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[inline]\n+    pub fn is_ascii_punctuation(&self) -> bool {\n+        if *self >= 0x80 { return false }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            P => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// Checks if the value is an ASCII graphic character:\n+    /// U+0021 '@' ... U+007E '~'.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_ctype)]\n+    ///\n+    /// let uppercase_a = b'A';\n+    /// let uppercase_g = b'G';\n+    /// let a = b'a';\n+    /// let g = b'g';\n+    /// let zero = b'0';\n+    /// let percent = b'%';\n+    /// let space = b' ';\n+    /// let lf = b'\\n';\n+    /// let esc = 0x1b_u8;\n+    ///\n+    /// assert!(uppercase_a.is_ascii_graphic());\n+    /// assert!(uppercase_g.is_ascii_graphic());\n+    /// assert!(a.is_ascii_graphic());\n+    /// assert!(g.is_ascii_graphic());\n+    /// assert!(zero.is_ascii_graphic());\n+    /// assert!(percent.is_ascii_graphic());\n+    /// assert!(!space.is_ascii_graphic());\n+    /// assert!(!lf.is_ascii_graphic());\n+    /// assert!(!esc.is_ascii_graphic());\n+    /// ```\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[inline]\n+    pub fn is_ascii_graphic(&self) -> bool {\n+        if *self >= 0x80 { return false; }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            Ux | U | Lx | L | D | P => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// Checks if the value is an ASCII whitespace character:\n+    /// U+0020 SPACE, U+0009 HORIZONTAL TAB, U+000A LINE FEED,\n+    /// U+000C FORM FEED, or U+000D CARRIAGE RETURN.\n+    ///\n+    /// Rust uses the WhatWG Infra Standard's [definition of ASCII\n+    /// whitespace][infra-aw]. There are several other definitions in\n+    /// wide use. For instance, [the POSIX locale][pct] includes\n+    /// U+000B VERTICAL TAB as well as all the above characters,\n+    /// but\u2014from the very same specification\u2014[the default rule for\n+    /// \"field splitting\" in the Bourne shell][bfs] considers *only*\n+    /// SPACE, HORIZONTAL TAB, and LINE FEED as whitespace.\n+    ///\n+    /// If you are writing a program that will process an existing\n+    /// file format, check what that format's definition of whitespace is\n+    /// before using this function.\n+    ///\n+    /// [infra-aw]: https://infra.spec.whatwg.org/#ascii-whitespace\n+    /// [pct]: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap07.html#tag_07_03_01\n+    /// [bfs]: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_05\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_ctype)]\n+    ///\n+    /// let uppercase_a = b'A';\n+    /// let uppercase_g = b'G';\n+    /// let a = b'a';\n+    /// let g = b'g';\n+    /// let zero = b'0';\n+    /// let percent = b'%';\n+    /// let space = b' ';\n+    /// let lf = b'\\n';\n+    /// let esc = 0x1b_u8;\n+    ///\n+    /// assert!(!uppercase_a.is_ascii_whitespace());\n+    /// assert!(!uppercase_g.is_ascii_whitespace());\n+    /// assert!(!a.is_ascii_whitespace());\n+    /// assert!(!g.is_ascii_whitespace());\n+    /// assert!(!zero.is_ascii_whitespace());\n+    /// assert!(!percent.is_ascii_whitespace());\n+    /// assert!(space.is_ascii_whitespace());\n+    /// assert!(lf.is_ascii_whitespace());\n+    /// assert!(!esc.is_ascii_whitespace());\n+    /// ```\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[inline]\n+    pub fn is_ascii_whitespace(&self) -> bool {\n+        if *self >= 0x80 { return false; }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            Cw | W => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// Checks if the value is an ASCII control character:\n+    /// U+0000 NUL ... U+001F UNIT SEPARATOR, or U+007F DELETE.\n+    /// Note that most ASCII whitespace characters are control\n+    /// characters, but SPACE is not.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_ctype)]\n+    ///\n+    /// let uppercase_a = b'A';\n+    /// let uppercase_g = b'G';\n+    /// let a = b'a';\n+    /// let g = b'g';\n+    /// let zero = b'0';\n+    /// let percent = b'%';\n+    /// let space = b' ';\n+    /// let lf = b'\\n';\n+    /// let esc = 0x1b_u8;\n+    ///\n+    /// assert!(!uppercase_a.is_ascii_control());\n+    /// assert!(!uppercase_g.is_ascii_control());\n+    /// assert!(!a.is_ascii_control());\n+    /// assert!(!g.is_ascii_control());\n+    /// assert!(!zero.is_ascii_control());\n+    /// assert!(!percent.is_ascii_control());\n+    /// assert!(!space.is_ascii_control());\n+    /// assert!(lf.is_ascii_control());\n+    /// assert!(esc.is_ascii_control());\n+    /// ```\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[inline]\n+    pub fn is_ascii_control(&self) -> bool {\n+        if *self >= 0x80 { return false; }\n+        match ASCII_CHARACTER_CLASS[*self as usize] {\n+            C | Cw => true,\n+            _ => false\n+        }\n+    }\n }\n \n #[lang = \"u16\"]\n@@ -2928,3 +3469,106 @@ impl_from! { u32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\"\n \n // Float -> Float\n impl_from! { f32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n+\n+static ASCII_LOWERCASE_MAP: [u8; 256] = [\n+    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n+    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n+    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n+    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n+    b' ', b'!', b'\"', b'#', b'$', b'%', b'&', b'\\'',\n+    b'(', b')', b'*', b'+', b',', b'-', b'.', b'/',\n+    b'0', b'1', b'2', b'3', b'4', b'5', b'6', b'7',\n+    b'8', b'9', b':', b';', b'<', b'=', b'>', b'?',\n+    b'@',\n+\n+          b'a', b'b', b'c', b'd', b'e', b'f', b'g',\n+    b'h', b'i', b'j', b'k', b'l', b'm', b'n', b'o',\n+    b'p', b'q', b'r', b's', b't', b'u', b'v', b'w',\n+    b'x', b'y', b'z',\n+\n+                      b'[', b'\\\\', b']', b'^', b'_',\n+    b'`', b'a', b'b', b'c', b'd', b'e', b'f', b'g',\n+    b'h', b'i', b'j', b'k', b'l', b'm', b'n', b'o',\n+    b'p', b'q', b'r', b's', b't', b'u', b'v', b'w',\n+    b'x', b'y', b'z', b'{', b'|', b'}', b'~', 0x7f,\n+    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n+    0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n+    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,\n+    0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,\n+    0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n+    0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,\n+    0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,\n+    0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,\n+    0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,\n+    0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,\n+    0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,\n+    0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,\n+    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,\n+    0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,\n+    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,\n+    0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,\n+];\n+\n+static ASCII_UPPERCASE_MAP: [u8; 256] = [\n+    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n+    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n+    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n+    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n+    b' ', b'!', b'\"', b'#', b'$', b'%', b'&', b'\\'',\n+    b'(', b')', b'*', b'+', b',', b'-', b'.', b'/',\n+    b'0', b'1', b'2', b'3', b'4', b'5', b'6', b'7',\n+    b'8', b'9', b':', b';', b'<', b'=', b'>', b'?',\n+    b'@', b'A', b'B', b'C', b'D', b'E', b'F', b'G',\n+    b'H', b'I', b'J', b'K', b'L', b'M', b'N', b'O',\n+    b'P', b'Q', b'R', b'S', b'T', b'U', b'V', b'W',\n+    b'X', b'Y', b'Z', b'[', b'\\\\', b']', b'^', b'_',\n+    b'`',\n+\n+          b'A', b'B', b'C', b'D', b'E', b'F', b'G',\n+    b'H', b'I', b'J', b'K', b'L', b'M', b'N', b'O',\n+    b'P', b'Q', b'R', b'S', b'T', b'U', b'V', b'W',\n+    b'X', b'Y', b'Z',\n+\n+                      b'{', b'|', b'}', b'~', 0x7f,\n+    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n+    0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n+    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,\n+    0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,\n+    0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n+    0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,\n+    0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,\n+    0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,\n+    0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,\n+    0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,\n+    0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,\n+    0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,\n+    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,\n+    0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,\n+    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,\n+    0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,\n+];\n+\n+enum AsciiCharacterClass {\n+    C,  // control\n+    Cw, // control whitespace\n+    W,  // whitespace\n+    D,  // digit\n+    L,  // lowercase\n+    Lx, // lowercase hex digit\n+    U,  // uppercase\n+    Ux, // uppercase hex digit\n+    P,  // punctuation\n+}\n+use self::AsciiCharacterClass::*;\n+\n+static ASCII_CHARACTER_CLASS: [AsciiCharacterClass; 128] = [\n+//  _0 _1 _2 _3 _4 _5 _6 _7 _8 _9 _a _b _c _d _e _f\n+    C, C, C, C, C, C, C, C, C, Cw,Cw,C, Cw,Cw,C, C, // 0_\n+    C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, // 1_\n+    W, P, P, P, P, P, P, P, P, P, P, P, P, P, P, P, // 2_\n+    D, D, D, D, D, D, D, D, D, D, P, P, P, P, P, P, // 3_\n+    P, Ux,Ux,Ux,Ux,Ux,Ux,U, U, U, U, U, U, U, U, U, // 4_\n+    U, U, U, U, U, U, U, U, U, U, U, P, P, P, P, P, // 5_\n+    P, Lx,Lx,Lx,Lx,Lx,Lx,L, L, L, L, L, L, L, L, L, // 6_\n+    L, L, L, L, L, L, L, L, L, L, L, P, P, P, P, C, // 7_\n+];"}, {"sha": "d648099d74d365e476619744d1462c40d0538448", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/94ede93467beb4ac17956845607a7e8b226dda02/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ede93467beb4ac17956845607a7e8b226dda02/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=94ede93467beb4ac17956845607a7e8b226dda02", "patch": "@@ -38,6 +38,7 @@ use hir::def_id::{CrateNum, LOCAL_CRATE};\n use hir::intravisit::{self, FnKind};\n use hir;\n use session::Session;\n+#[cfg(stage0)]\n use std::ascii::AsciiExt;\n use std::hash;\n use syntax::ast;"}, {"sha": "a38b37ff745f7d1b90244358f76ac1fe53518fce", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/94ede93467beb4ac17956845607a7e8b226dda02/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ede93467beb4ac17956845607a7e8b226dda02/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=94ede93467beb4ac17956845607a7e8b226dda02", "patch": "@@ -211,6 +211,7 @@ language_item_table! {\n     CharImplItem,                    \"char\",                    char_impl;\n     StrImplItem,                     \"str\",                     str_impl;\n     SliceImplItem,                   \"slice\",                   slice_impl;\n+    SliceU8ImplItem,                 \"slice_u8\",                slice_u8_impl;\n     ConstPtrImplItem,                \"const_ptr\",               const_ptr_impl;\n     MutPtrImplItem,                  \"mut_ptr\",                 mut_ptr_impl;\n     I8ImplItem,                      \"i8\",                      i8_impl;"}, {"sha": "81e5b2fe00a6ae895e73dfe1f0d5526b94c662a4", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/94ede93467beb4ac17956845607a7e8b226dda02/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ede93467beb4ac17956845607a7e8b226dda02/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=94ede93467beb4ac17956845607a7e8b226dda02", "patch": "@@ -431,6 +431,9 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             ty::TySlice(_) => {\n                 let lang_def_id = lang_items.slice_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n+\n+                let lang_def_id = lang_items.slice_u8_impl();\n+                self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyRawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n                 let lang_def_id = lang_items.const_ptr_impl();"}, {"sha": "569b6a2febb4509a631b3aecc84bb7bb8c315d83", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/94ede93467beb4ac17956845607a7e8b226dda02/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ede93467beb4ac17956845607a7e8b226dda02/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=94ede93467beb4ac17956845607a7e8b226dda02", "patch": "@@ -137,6 +137,13 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentCollect<'a, 'tcx> {\n                                           \"str\",\n                                           item.span);\n             }\n+            ty::TySlice(slice_item) if slice_item == self.tcx.types.u8 => {\n+                self.check_primitive_impl(def_id,\n+                                          lang_items.slice_u8_impl(),\n+                                          \"slice_u8\",\n+                                          \"[u8]\",\n+                                          item.span);\n+            }\n             ty::TySlice(_) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.slice_impl(),"}, {"sha": "915383d8189e0db2a797150a318453e9723d7a22", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/94ede93467beb4ac17956845607a7e8b226dda02/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ede93467beb4ac17956845607a7e8b226dda02/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=94ede93467beb4ac17956845607a7e8b226dda02", "patch": "@@ -15,6 +15,7 @@\n use std::mem;\n use std::fmt::{self, Write};\n use std::ops;\n+#[cfg(stage0)]\n use std::ascii::AsciiExt;\n \n use syntax::symbol::Symbol;"}, {"sha": "c132cf75e40a416499dac9a65e7625a089cab6cb", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/94ede93467beb4ac17956845607a7e8b226dda02/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ede93467beb4ac17956845607a7e8b226dda02/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=94ede93467beb4ac17956845607a7e8b226dda02", "patch": "@@ -30,7 +30,6 @@\n use libc;\n use std::slice;\n \n-use std::ascii::AsciiExt;\n use std::cell::RefCell;\n use std::collections::{HashMap, VecDeque};\n use std::default::Default;"}, {"sha": "f3a897d2121cb4c2f3345341a2fed5536e6290ac", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/94ede93467beb4ac17956845607a7e8b226dda02/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ede93467beb4ac17956845607a7e8b226dda02/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=94ede93467beb4ac17956845607a7e8b226dda02", "patch": "@@ -34,6 +34,7 @@\n //! both occur before the crate is rendered.\n pub use self::ExternalLocation::*;\n \n+#[cfg(stage0)]\n use std::ascii::AsciiExt;\n use std::cell::RefCell;\n use std::cmp::Ordering;"}, {"sha": "fcb25f7aef3d4b10e00dc02eeca5dc0c9528fe0f", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ede93467beb4ac17956845607a7e8b226dda02/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ede93467beb4ac17956845607a7e8b226dda02/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=94ede93467beb4ac17956845607a7e8b226dda02", "patch": "@@ -14,6 +14,7 @@\n        html_playground_url = \"https://play.rust-lang.org/\")]\n #![deny(warnings)]\n \n+#![feature(ascii_ctype)]\n #![feature(rustc_private)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n@@ -23,7 +24,6 @@\n #![feature(test)]\n #![feature(unicode)]\n #![feature(vec_remove_item)]\n-#![feature(ascii_ctype)]\n \n extern crate arena;\n extern crate getopts;"}, {"sha": "96d719c528c109bf5fad03ef6a48ad897ce36b4a", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 112, "deletions": 600, "changes": 712, "blob_url": "https://github.com/rust-lang/rust/blob/94ede93467beb4ac17956845607a7e8b226dda02/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ede93467beb4ac17956845607a7e8b226dda02/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=94ede93467beb4ac17956845607a7e8b226dda02", "patch": "@@ -38,8 +38,8 @@ use iter::FusedIterator;\n /// ```\n /// use std::ascii::AsciiExt;\n ///\n-/// assert_eq!(\"cafe\u0301\".to_ascii_uppercase(), \"CAFE\u0301\");\n-/// assert_eq!(\"caf\u00e9\".to_ascii_uppercase(), \"CAF\u00e9\");\n+/// assert_eq!(AsciiExt::to_ascii_uppercase(\"cafe\u0301\"), \"CAFE\u0301\");\n+/// assert_eq!(AsciiExt::to_ascii_uppercase(\"caf\u00e9\"), \"CAF\u00e9\");\n /// ```\n ///\n /// In the first example, the lowercased string is represented `\"cafe\\u{301}\"`\n@@ -60,19 +60,10 @@ pub trait AsciiExt {\n \n     /// Checks if the value is within the ASCII range.\n     ///\n-    /// # Examples\n+    /// # Note\n     ///\n-    /// ```\n-    /// use std::ascii::AsciiExt;\n-    ///\n-    /// let ascii = 'a';\n-    /// let non_ascii = '\u2764';\n-    /// let int_ascii = 97;\n-    ///\n-    /// assert!(ascii.is_ascii());\n-    /// assert!(!non_ascii.is_ascii());\n-    /// assert!(int_ascii.is_ascii());\n-    /// ```\n+    /// This method will be deprecated in favor of the identically-named\n+    /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_ascii(&self) -> bool;\n \n@@ -86,19 +77,10 @@ pub trait AsciiExt {\n     /// To uppercase ASCII characters in addition to non-ASCII characters, use\n     /// [`str::to_uppercase`].\n     ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::ascii::AsciiExt;\n-    ///\n-    /// let ascii = 'a';\n-    /// let non_ascii = '\u2764';\n-    /// let int_ascii = 97;\n+    /// # Note\n     ///\n-    /// assert_eq!('A', ascii.to_ascii_uppercase());\n-    /// assert_eq!('\u2764', non_ascii.to_ascii_uppercase());\n-    /// assert_eq!(65, int_ascii.to_ascii_uppercase());\n-    /// ```\n+    /// This method will be deprecated in favor of the identically-named\n+    /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n     ///\n     /// [`make_ascii_uppercase`]: #tymethod.make_ascii_uppercase\n     /// [`str::to_uppercase`]: ../primitive.str.html#method.to_uppercase\n@@ -115,19 +97,10 @@ pub trait AsciiExt {\n     /// To lowercase ASCII characters in addition to non-ASCII characters, use\n     /// [`str::to_lowercase`].\n     ///\n-    /// # Examples\n+    /// # Note\n     ///\n-    /// ```\n-    /// use std::ascii::AsciiExt;\n-    ///\n-    /// let ascii = 'A';\n-    /// let non_ascii = '\u2764';\n-    /// let int_ascii = 65;\n-    ///\n-    /// assert_eq!('a', ascii.to_ascii_lowercase());\n-    /// assert_eq!('\u2764', non_ascii.to_ascii_lowercase());\n-    /// assert_eq!(97, int_ascii.to_ascii_lowercase());\n-    /// ```\n+    /// This method will be deprecated in favor of the identically-named\n+    /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n     ///\n     /// [`make_ascii_lowercase`]: #tymethod.make_ascii_lowercase\n     /// [`str::to_lowercase`]: ../primitive.str.html#method.to_lowercase\n@@ -139,20 +112,10 @@ pub trait AsciiExt {\n     /// Same as `to_ascii_lowercase(a) == to_ascii_lowercase(b)`,\n     /// but without allocating and copying temporaries.\n     ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::ascii::AsciiExt;\n-    ///\n-    /// let ascii1 = 'A';\n-    /// let ascii2 = 'a';\n-    /// let ascii3 = 'A';\n-    /// let ascii4 = 'z';\n+    /// # Note\n     ///\n-    /// assert!(ascii1.eq_ignore_ascii_case(&ascii2));\n-    /// assert!(ascii1.eq_ignore_ascii_case(&ascii3));\n-    /// assert!(!ascii1.eq_ignore_ascii_case(&ascii4));\n-    /// ```\n+    /// This method will be deprecated in favor of the identically-named\n+    /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn eq_ignore_ascii_case(&self, other: &Self) -> bool;\n \n@@ -164,17 +127,10 @@ pub trait AsciiExt {\n     /// To return a new uppercased value without modifying the existing one, use\n     /// [`to_ascii_uppercase`].\n     ///\n-    /// # Examples\n+    /// # Note\n     ///\n-    /// ```\n-    /// use std::ascii::AsciiExt;\n-    ///\n-    /// let mut ascii = 'a';\n-    ///\n-    /// ascii.make_ascii_uppercase();\n-    ///\n-    /// assert_eq!('A', ascii);\n-    /// ```\n+    /// This method will be deprecated in favor of the identically-named\n+    /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n     ///\n     /// [`to_ascii_uppercase`]: #tymethod.to_ascii_uppercase\n     #[stable(feature = \"ascii\", since = \"1.9.0\")]\n@@ -188,17 +144,10 @@ pub trait AsciiExt {\n     /// To return a new lowercased value without modifying the existing one, use\n     /// [`to_ascii_lowercase`].\n     ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::ascii::AsciiExt;\n+    /// # Note\n     ///\n-    /// let mut ascii = 'A';\n-    ///\n-    /// ascii.make_ascii_lowercase();\n-    ///\n-    /// assert_eq!('a', ascii);\n-    /// ```\n+    /// This method will be deprecated in favor of the identically-named\n+    /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n     ///\n     /// [`to_ascii_lowercase`]: #tymethod.to_ascii_lowercase\n     #[stable(feature = \"ascii\", since = \"1.9.0\")]\n@@ -209,32 +158,10 @@ pub trait AsciiExt {\n     /// For strings, true if all characters in the string are\n     /// ASCII alphabetic.\n     ///\n-    /// # Examples\n+    /// # Note\n     ///\n-    /// ```\n-    /// #![feature(ascii_ctype)]\n-    /// # #![allow(non_snake_case)]\n-    /// use std::ascii::AsciiExt;\n-    /// let A = 'A';\n-    /// let G = 'G';\n-    /// let a = 'a';\n-    /// let g = 'g';\n-    /// let zero = '0';\n-    /// let percent = '%';\n-    /// let space = ' ';\n-    /// let lf = '\\n';\n-    /// let esc = '\\u{001b}';\n-    ///\n-    /// assert!(A.is_ascii_alphabetic());\n-    /// assert!(G.is_ascii_alphabetic());\n-    /// assert!(a.is_ascii_alphabetic());\n-    /// assert!(g.is_ascii_alphabetic());\n-    /// assert!(!zero.is_ascii_alphabetic());\n-    /// assert!(!percent.is_ascii_alphabetic());\n-    /// assert!(!space.is_ascii_alphabetic());\n-    /// assert!(!lf.is_ascii_alphabetic());\n-    /// assert!(!esc.is_ascii_alphabetic());\n-    /// ```\n+    /// This method will be deprecated in favor of the identically-named\n+    /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n     #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n     fn is_ascii_alphabetic(&self) -> bool { unimplemented!(); }\n \n@@ -243,32 +170,10 @@ pub trait AsciiExt {\n     /// For strings, true if all characters in the string are\n     /// ASCII uppercase.\n     ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(ascii_ctype)]\n-    /// # #![allow(non_snake_case)]\n-    /// use std::ascii::AsciiExt;\n-    /// let A = 'A';\n-    /// let G = 'G';\n-    /// let a = 'a';\n-    /// let g = 'g';\n-    /// let zero = '0';\n-    /// let percent = '%';\n-    /// let space = ' ';\n-    /// let lf = '\\n';\n-    /// let esc = '\\u{001b}';\n+    /// # Note\n     ///\n-    /// assert!(A.is_ascii_uppercase());\n-    /// assert!(G.is_ascii_uppercase());\n-    /// assert!(!a.is_ascii_uppercase());\n-    /// assert!(!g.is_ascii_uppercase());\n-    /// assert!(!zero.is_ascii_uppercase());\n-    /// assert!(!percent.is_ascii_uppercase());\n-    /// assert!(!space.is_ascii_uppercase());\n-    /// assert!(!lf.is_ascii_uppercase());\n-    /// assert!(!esc.is_ascii_uppercase());\n-    /// ```\n+    /// This method will be deprecated in favor of the identically-named\n+    /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n     #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n     fn is_ascii_uppercase(&self) -> bool { unimplemented!(); }\n \n@@ -277,32 +182,10 @@ pub trait AsciiExt {\n     /// For strings, true if all characters in the string are\n     /// ASCII lowercase.\n     ///\n-    /// # Examples\n+    /// # Note\n     ///\n-    /// ```\n-    /// #![feature(ascii_ctype)]\n-    /// # #![allow(non_snake_case)]\n-    /// use std::ascii::AsciiExt;\n-    /// let A = 'A';\n-    /// let G = 'G';\n-    /// let a = 'a';\n-    /// let g = 'g';\n-    /// let zero = '0';\n-    /// let percent = '%';\n-    /// let space = ' ';\n-    /// let lf = '\\n';\n-    /// let esc = '\\u{001b}';\n-    ///\n-    /// assert!(!A.is_ascii_lowercase());\n-    /// assert!(!G.is_ascii_lowercase());\n-    /// assert!(a.is_ascii_lowercase());\n-    /// assert!(g.is_ascii_lowercase());\n-    /// assert!(!zero.is_ascii_lowercase());\n-    /// assert!(!percent.is_ascii_lowercase());\n-    /// assert!(!space.is_ascii_lowercase());\n-    /// assert!(!lf.is_ascii_lowercase());\n-    /// assert!(!esc.is_ascii_lowercase());\n-    /// ```\n+    /// This method will be deprecated in favor of the identically-named\n+    /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n     #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n     fn is_ascii_lowercase(&self) -> bool { unimplemented!(); }\n \n@@ -312,32 +195,10 @@ pub trait AsciiExt {\n     /// For strings, true if all characters in the string are\n     /// ASCII alphanumeric.\n     ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(ascii_ctype)]\n-    /// # #![allow(non_snake_case)]\n-    /// use std::ascii::AsciiExt;\n-    /// let A = 'A';\n-    /// let G = 'G';\n-    /// let a = 'a';\n-    /// let g = 'g';\n-    /// let zero = '0';\n-    /// let percent = '%';\n-    /// let space = ' ';\n-    /// let lf = '\\n';\n-    /// let esc = '\\u{001b}';\n+    /// # Note\n     ///\n-    /// assert!(A.is_ascii_alphanumeric());\n-    /// assert!(G.is_ascii_alphanumeric());\n-    /// assert!(a.is_ascii_alphanumeric());\n-    /// assert!(g.is_ascii_alphanumeric());\n-    /// assert!(zero.is_ascii_alphanumeric());\n-    /// assert!(!percent.is_ascii_alphanumeric());\n-    /// assert!(!space.is_ascii_alphanumeric());\n-    /// assert!(!lf.is_ascii_alphanumeric());\n-    /// assert!(!esc.is_ascii_alphanumeric());\n-    /// ```\n+    /// This method will be deprecated in favor of the identically-named\n+    /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n     #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n     fn is_ascii_alphanumeric(&self) -> bool { unimplemented!(); }\n \n@@ -346,32 +207,10 @@ pub trait AsciiExt {\n     /// For strings, true if all characters in the string are\n     /// ASCII digits.\n     ///\n-    /// # Examples\n+    /// # Note\n     ///\n-    /// ```\n-    /// #![feature(ascii_ctype)]\n-    /// # #![allow(non_snake_case)]\n-    /// use std::ascii::AsciiExt;\n-    /// let A = 'A';\n-    /// let G = 'G';\n-    /// let a = 'a';\n-    /// let g = 'g';\n-    /// let zero = '0';\n-    /// let percent = '%';\n-    /// let space = ' ';\n-    /// let lf = '\\n';\n-    /// let esc = '\\u{001b}';\n-    ///\n-    /// assert!(!A.is_ascii_digit());\n-    /// assert!(!G.is_ascii_digit());\n-    /// assert!(!a.is_ascii_digit());\n-    /// assert!(!g.is_ascii_digit());\n-    /// assert!(zero.is_ascii_digit());\n-    /// assert!(!percent.is_ascii_digit());\n-    /// assert!(!space.is_ascii_digit());\n-    /// assert!(!lf.is_ascii_digit());\n-    /// assert!(!esc.is_ascii_digit());\n-    /// ```\n+    /// This method will be deprecated in favor of the identically-named\n+    /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n     #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n     fn is_ascii_digit(&self) -> bool { unimplemented!(); }\n \n@@ -381,32 +220,10 @@ pub trait AsciiExt {\n     /// For strings, true if all characters in the string are\n     /// ASCII hex digits.\n     ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(ascii_ctype)]\n-    /// # #![allow(non_snake_case)]\n-    /// use std::ascii::AsciiExt;\n-    /// let A = 'A';\n-    /// let G = 'G';\n-    /// let a = 'a';\n-    /// let g = 'g';\n-    /// let zero = '0';\n-    /// let percent = '%';\n-    /// let space = ' ';\n-    /// let lf = '\\n';\n-    /// let esc = '\\u{001b}';\n+    /// # Note\n     ///\n-    /// assert!(A.is_ascii_hexdigit());\n-    /// assert!(!G.is_ascii_hexdigit());\n-    /// assert!(a.is_ascii_hexdigit());\n-    /// assert!(!g.is_ascii_hexdigit());\n-    /// assert!(zero.is_ascii_hexdigit());\n-    /// assert!(!percent.is_ascii_hexdigit());\n-    /// assert!(!space.is_ascii_hexdigit());\n-    /// assert!(!lf.is_ascii_hexdigit());\n-    /// assert!(!esc.is_ascii_hexdigit());\n-    /// ```\n+    /// This method will be deprecated in favor of the identically-named\n+    /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n     #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n     fn is_ascii_hexdigit(&self) -> bool { unimplemented!(); }\n \n@@ -420,32 +237,10 @@ pub trait AsciiExt {\n     /// For strings, true if all characters in the string are\n     /// ASCII punctuation.\n     ///\n-    /// # Examples\n+    /// # Note\n     ///\n-    /// ```\n-    /// #![feature(ascii_ctype)]\n-    /// # #![allow(non_snake_case)]\n-    /// use std::ascii::AsciiExt;\n-    /// let A = 'A';\n-    /// let G = 'G';\n-    /// let a = 'a';\n-    /// let g = 'g';\n-    /// let zero = '0';\n-    /// let percent = '%';\n-    /// let space = ' ';\n-    /// let lf = '\\n';\n-    /// let esc = '\\u{001b}';\n-    ///\n-    /// assert!(!A.is_ascii_punctuation());\n-    /// assert!(!G.is_ascii_punctuation());\n-    /// assert!(!a.is_ascii_punctuation());\n-    /// assert!(!g.is_ascii_punctuation());\n-    /// assert!(!zero.is_ascii_punctuation());\n-    /// assert!(percent.is_ascii_punctuation());\n-    /// assert!(!space.is_ascii_punctuation());\n-    /// assert!(!lf.is_ascii_punctuation());\n-    /// assert!(!esc.is_ascii_punctuation());\n-    /// ```\n+    /// This method will be deprecated in favor of the identically-named\n+    /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n     #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n     fn is_ascii_punctuation(&self) -> bool { unimplemented!(); }\n \n@@ -454,32 +249,10 @@ pub trait AsciiExt {\n     /// For strings, true if all characters in the string are\n     /// ASCII punctuation.\n     ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(ascii_ctype)]\n-    /// # #![allow(non_snake_case)]\n-    /// use std::ascii::AsciiExt;\n-    /// let A = 'A';\n-    /// let G = 'G';\n-    /// let a = 'a';\n-    /// let g = 'g';\n-    /// let zero = '0';\n-    /// let percent = '%';\n-    /// let space = ' ';\n-    /// let lf = '\\n';\n-    /// let esc = '\\u{001b}';\n+    /// # Note\n     ///\n-    /// assert!(A.is_ascii_graphic());\n-    /// assert!(G.is_ascii_graphic());\n-    /// assert!(a.is_ascii_graphic());\n-    /// assert!(g.is_ascii_graphic());\n-    /// assert!(zero.is_ascii_graphic());\n-    /// assert!(percent.is_ascii_graphic());\n-    /// assert!(!space.is_ascii_graphic());\n-    /// assert!(!lf.is_ascii_graphic());\n-    /// assert!(!esc.is_ascii_graphic());\n-    /// ```\n+    /// This method will be deprecated in favor of the identically-named\n+    /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n     #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n     fn is_ascii_graphic(&self) -> bool { unimplemented!(); }\n \n@@ -505,32 +278,10 @@ pub trait AsciiExt {\n     /// [pct]: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap07.html#tag_07_03_01\n     /// [bfs]: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_05\n     ///\n-    /// # Examples\n+    /// # Note\n     ///\n-    /// ```\n-    /// #![feature(ascii_ctype)]\n-    /// # #![allow(non_snake_case)]\n-    /// use std::ascii::AsciiExt;\n-    /// let A = 'A';\n-    /// let G = 'G';\n-    /// let a = 'a';\n-    /// let g = 'g';\n-    /// let zero = '0';\n-    /// let percent = '%';\n-    /// let space = ' ';\n-    /// let lf = '\\n';\n-    /// let esc = '\\u{001b}';\n-    ///\n-    /// assert!(!A.is_ascii_whitespace());\n-    /// assert!(!G.is_ascii_whitespace());\n-    /// assert!(!a.is_ascii_whitespace());\n-    /// assert!(!g.is_ascii_whitespace());\n-    /// assert!(!zero.is_ascii_whitespace());\n-    /// assert!(!percent.is_ascii_whitespace());\n-    /// assert!(space.is_ascii_whitespace());\n-    /// assert!(lf.is_ascii_whitespace());\n-    /// assert!(!esc.is_ascii_whitespace());\n-    /// ```\n+    /// This method will be deprecated in favor of the identically-named\n+    /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n     #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n     fn is_ascii_whitespace(&self) -> bool { unimplemented!(); }\n \n@@ -539,36 +290,18 @@ pub trait AsciiExt {\n     /// Note that most ASCII whitespace characters are control\n     /// characters, but SPACE is not.\n     ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(ascii_ctype)]\n-    /// # #![allow(non_snake_case)]\n-    /// use std::ascii::AsciiExt;\n-    /// let A = 'A';\n-    /// let G = 'G';\n-    /// let a = 'a';\n-    /// let g = 'g';\n-    /// let zero = '0';\n-    /// let percent = '%';\n-    /// let space = ' ';\n-    /// let lf = '\\n';\n-    /// let esc = '\\u{001b}';\n+    /// # Note\n     ///\n-    /// assert!(!A.is_ascii_control());\n-    /// assert!(!G.is_ascii_control());\n-    /// assert!(!a.is_ascii_control());\n-    /// assert!(!g.is_ascii_control());\n-    /// assert!(!zero.is_ascii_control());\n-    /// assert!(!percent.is_ascii_control());\n-    /// assert!(!space.is_ascii_control());\n-    /// assert!(lf.is_ascii_control());\n-    /// assert!(esc.is_ascii_control());\n-    /// ```\n+    /// This method will be deprecated in favor of the identically-named\n+    /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n     #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n     fn is_ascii_control(&self) -> bool { unimplemented!(); }\n }\n \n+// FIXME(LukasKalbertodt): this impl block can be removed in the future. This is\n+// possible once the stage0 compiler is new enough to contain the inherent\n+// ascii methods for `[str]`. See FIXME comment further down.\n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsciiExt for str {\n     type Owned = String;\n@@ -660,6 +393,10 @@ impl AsciiExt for str {\n     }\n }\n \n+// FIXME(LukasKalbertodt): this impl block can be removed in the future. This is\n+// possible once the stage0 compiler is new enough to contain the inherent\n+// ascii methods for `[u8]`. See FIXME comment further down.\n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsciiExt for [u8] {\n     type Owned = Vec<u8>;\n@@ -753,201 +490,77 @@ impl AsciiExt for [u8] {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl AsciiExt for u8 {\n-    type Owned = u8;\n-    #[inline]\n-    fn is_ascii(&self) -> bool { *self & 128 == 0 }\n-    #[inline]\n-    fn to_ascii_uppercase(&self) -> u8 { ASCII_UPPERCASE_MAP[*self as usize] }\n-    #[inline]\n-    fn to_ascii_lowercase(&self) -> u8 { ASCII_LOWERCASE_MAP[*self as usize] }\n-    #[inline]\n-    fn eq_ignore_ascii_case(&self, other: &u8) -> bool {\n-        self.to_ascii_lowercase() == other.to_ascii_lowercase()\n-    }\n-    #[inline]\n-    fn make_ascii_uppercase(&mut self) { *self = self.to_ascii_uppercase(); }\n-    #[inline]\n-    fn make_ascii_lowercase(&mut self) { *self = self.to_ascii_lowercase(); }\n+macro_rules! impl_by_delegating {\n+    ($ty:ty, $owned:ty) => {\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl AsciiExt for $ty {\n+            type Owned = $owned;\n \n-    #[inline]\n-    fn is_ascii_alphabetic(&self) -> bool {\n-        if *self >= 0x80 { return false; }\n-        match ASCII_CHARACTER_CLASS[*self as usize] {\n-            L|Lx|U|Ux => true,\n-            _ => false\n-        }\n-    }\n+            #[inline]\n+            fn is_ascii(&self) -> bool { self.is_ascii() }\n \n-    #[inline]\n-    fn is_ascii_uppercase(&self) -> bool {\n-        if *self >= 0x80 { return false }\n-        match ASCII_CHARACTER_CLASS[*self as usize] {\n-            U|Ux => true,\n-            _ => false\n-        }\n-    }\n+            #[inline]\n+            fn to_ascii_uppercase(&self) -> Self::Owned { self.to_ascii_uppercase() }\n \n-    #[inline]\n-    fn is_ascii_lowercase(&self) -> bool {\n-        if *self >= 0x80 { return false }\n-        match ASCII_CHARACTER_CLASS[*self as usize] {\n-            L|Lx => true,\n-            _ => false\n-        }\n-    }\n+            #[inline]\n+            fn to_ascii_lowercase(&self) -> Self::Owned { self.to_ascii_lowercase() }\n \n-    #[inline]\n-    fn is_ascii_alphanumeric(&self) -> bool {\n-        if *self >= 0x80 { return false }\n-        match ASCII_CHARACTER_CLASS[*self as usize] {\n-            D|L|Lx|U|Ux => true,\n-            _ => false\n-        }\n-    }\n+            #[inline]\n+            fn eq_ignore_ascii_case(&self, o: &Self) -> bool { self.eq_ignore_ascii_case(o) }\n \n-    #[inline]\n-    fn is_ascii_digit(&self) -> bool {\n-        if *self >= 0x80 { return false }\n-        match ASCII_CHARACTER_CLASS[*self as usize] {\n-            D => true,\n-            _ => false\n-        }\n-    }\n+            #[inline]\n+            fn make_ascii_uppercase(&mut self) { self.make_ascii_uppercase(); }\n \n-    #[inline]\n-    fn is_ascii_hexdigit(&self) -> bool {\n-        if *self >= 0x80 { return false }\n-        match ASCII_CHARACTER_CLASS[*self as usize] {\n-            D|Lx|Ux => true,\n-            _ => false\n-        }\n-    }\n+            #[inline]\n+            fn make_ascii_lowercase(&mut self) { self.make_ascii_lowercase(); }\n \n-    #[inline]\n-    fn is_ascii_punctuation(&self) -> bool {\n-        if *self >= 0x80 { return false }\n-        match ASCII_CHARACTER_CLASS[*self as usize] {\n-            P => true,\n-            _ => false\n-        }\n-    }\n+            #[inline]\n+            fn is_ascii_alphabetic(&self) -> bool { self.is_ascii_alphabetic() }\n \n-    #[inline]\n-    fn is_ascii_graphic(&self) -> bool {\n-        if *self >= 0x80 { return false; }\n-        match ASCII_CHARACTER_CLASS[*self as usize] {\n-            Ux|U|Lx|L|D|P => true,\n-            _ => false\n-        }\n-    }\n+            #[inline]\n+            fn is_ascii_uppercase(&self) -> bool { self.is_ascii_uppercase() }\n \n-    #[inline]\n-    fn is_ascii_whitespace(&self) -> bool {\n-        if *self >= 0x80 { return false; }\n-        match ASCII_CHARACTER_CLASS[*self as usize] {\n-            Cw|W => true,\n-            _ => false\n-        }\n-    }\n-\n-    #[inline]\n-    fn is_ascii_control(&self) -> bool {\n-        if *self >= 0x80 { return false; }\n-        match ASCII_CHARACTER_CLASS[*self as usize] {\n-            C|Cw => true,\n-            _ => false\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl AsciiExt for char {\n-    type Owned = char;\n-    #[inline]\n-    fn is_ascii(&self) -> bool {\n-        *self as u32 <= 0x7F\n-    }\n+            #[inline]\n+            fn is_ascii_lowercase(&self) -> bool { self.is_ascii_lowercase() }\n \n-    #[inline]\n-    fn to_ascii_uppercase(&self) -> char {\n-        if self.is_ascii() {\n-            (*self as u8).to_ascii_uppercase() as char\n-        } else {\n-            *self\n-        }\n-    }\n+            #[inline]\n+            fn is_ascii_alphanumeric(&self) -> bool { self.is_ascii_alphanumeric() }\n \n-    #[inline]\n-    fn to_ascii_lowercase(&self) -> char {\n-        if self.is_ascii() {\n-            (*self as u8).to_ascii_lowercase() as char\n-        } else {\n-            *self\n-        }\n-    }\n+            #[inline]\n+            fn is_ascii_digit(&self) -> bool { self.is_ascii_digit() }\n \n-    #[inline]\n-    fn eq_ignore_ascii_case(&self, other: &char) -> bool {\n-        self.to_ascii_lowercase() == other.to_ascii_lowercase()\n-    }\n+            #[inline]\n+            fn is_ascii_hexdigit(&self) -> bool { self.is_ascii_hexdigit() }\n \n-    #[inline]\n-    fn make_ascii_uppercase(&mut self) { *self = self.to_ascii_uppercase(); }\n-    #[inline]\n-    fn make_ascii_lowercase(&mut self) { *self = self.to_ascii_lowercase(); }\n+            #[inline]\n+            fn is_ascii_punctuation(&self) -> bool { self.is_ascii_punctuation() }\n \n-    #[inline]\n-    fn is_ascii_alphabetic(&self) -> bool {\n-        (*self as u32 <= 0x7f) && (*self as u8).is_ascii_alphabetic()\n-    }\n+            #[inline]\n+            fn is_ascii_graphic(&self) -> bool { self.is_ascii_graphic() }\n \n-    #[inline]\n-    fn is_ascii_uppercase(&self) -> bool {\n-        (*self as u32 <= 0x7f) && (*self as u8).is_ascii_uppercase()\n-    }\n+            #[inline]\n+            fn is_ascii_whitespace(&self) -> bool { self.is_ascii_whitespace() }\n \n-    #[inline]\n-    fn is_ascii_lowercase(&self) -> bool {\n-        (*self as u32 <= 0x7f) && (*self as u8).is_ascii_lowercase()\n-    }\n-\n-    #[inline]\n-    fn is_ascii_alphanumeric(&self) -> bool {\n-        (*self as u32 <= 0x7f) && (*self as u8).is_ascii_alphanumeric()\n-    }\n-\n-    #[inline]\n-    fn is_ascii_digit(&self) -> bool {\n-        (*self as u32 <= 0x7f) && (*self as u8).is_ascii_digit()\n-    }\n-\n-    #[inline]\n-    fn is_ascii_hexdigit(&self) -> bool {\n-        (*self as u32 <= 0x7f) && (*self as u8).is_ascii_hexdigit()\n-    }\n-\n-    #[inline]\n-    fn is_ascii_punctuation(&self) -> bool {\n-        (*self as u32 <= 0x7f) && (*self as u8).is_ascii_punctuation()\n+            #[inline]\n+            fn is_ascii_control(&self) -> bool { self.is_ascii_control() }\n+        }\n     }\n+}\n \n-    #[inline]\n-    fn is_ascii_graphic(&self) -> bool {\n-        (*self as u32 <= 0x7f) && (*self as u8).is_ascii_graphic()\n-    }\n+impl_by_delegating!(u8, u8);\n+impl_by_delegating!(char, char);\n \n-    #[inline]\n-    fn is_ascii_whitespace(&self) -> bool {\n-        (*self as u32 <= 0x7f) && (*self as u8).is_ascii_whitespace()\n-    }\n+// FIXME(LukasKalbertodt): the macro invocation should replace the impl block\n+// for `[u8]` above. But this is not possible until the stage0 compiler is new\n+// enough to contain the inherent ascii methods for `[u8]`.\n+#[cfg(not(stage0))]\n+impl_by_delegating!([u8], Vec<u8>);\n \n-    #[inline]\n-    fn is_ascii_control(&self) -> bool {\n-        (*self as u32 <= 0x7f) && (*self as u8).is_ascii_control()\n-    }\n-}\n+// FIXME(LukasKalbertodt): the macro invocation should replace the impl block\n+// for `str` above. But this is not possible until the stage0 compiler is new\n+// enough to contain the inherent ascii methods for `str`.\n+#[cfg(not(stage0))]\n+impl_by_delegating!(str, String);\n \n /// An iterator over the escaped version of a byte.\n ///\n@@ -1066,112 +679,11 @@ impl fmt::Debug for EscapeDefault {\n }\n \n \n-static ASCII_LOWERCASE_MAP: [u8; 256] = [\n-    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n-    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n-    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n-    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n-    b' ', b'!', b'\"', b'#', b'$', b'%', b'&', b'\\'',\n-    b'(', b')', b'*', b'+', b',', b'-', b'.', b'/',\n-    b'0', b'1', b'2', b'3', b'4', b'5', b'6', b'7',\n-    b'8', b'9', b':', b';', b'<', b'=', b'>', b'?',\n-    b'@',\n-\n-          b'a', b'b', b'c', b'd', b'e', b'f', b'g',\n-    b'h', b'i', b'j', b'k', b'l', b'm', b'n', b'o',\n-    b'p', b'q', b'r', b's', b't', b'u', b'v', b'w',\n-    b'x', b'y', b'z',\n-\n-                      b'[', b'\\\\', b']', b'^', b'_',\n-    b'`', b'a', b'b', b'c', b'd', b'e', b'f', b'g',\n-    b'h', b'i', b'j', b'k', b'l', b'm', b'n', b'o',\n-    b'p', b'q', b'r', b's', b't', b'u', b'v', b'w',\n-    b'x', b'y', b'z', b'{', b'|', b'}', b'~', 0x7f,\n-    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n-    0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n-    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,\n-    0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,\n-    0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n-    0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,\n-    0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,\n-    0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,\n-    0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,\n-    0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,\n-    0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,\n-    0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,\n-    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,\n-    0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,\n-    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,\n-    0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,\n-];\n-\n-static ASCII_UPPERCASE_MAP: [u8; 256] = [\n-    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n-    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n-    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n-    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n-    b' ', b'!', b'\"', b'#', b'$', b'%', b'&', b'\\'',\n-    b'(', b')', b'*', b'+', b',', b'-', b'.', b'/',\n-    b'0', b'1', b'2', b'3', b'4', b'5', b'6', b'7',\n-    b'8', b'9', b':', b';', b'<', b'=', b'>', b'?',\n-    b'@', b'A', b'B', b'C', b'D', b'E', b'F', b'G',\n-    b'H', b'I', b'J', b'K', b'L', b'M', b'N', b'O',\n-    b'P', b'Q', b'R', b'S', b'T', b'U', b'V', b'W',\n-    b'X', b'Y', b'Z', b'[', b'\\\\', b']', b'^', b'_',\n-    b'`',\n-\n-          b'A', b'B', b'C', b'D', b'E', b'F', b'G',\n-    b'H', b'I', b'J', b'K', b'L', b'M', b'N', b'O',\n-    b'P', b'Q', b'R', b'S', b'T', b'U', b'V', b'W',\n-    b'X', b'Y', b'Z',\n-\n-                      b'{', b'|', b'}', b'~', 0x7f,\n-    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n-    0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n-    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,\n-    0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,\n-    0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n-    0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,\n-    0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,\n-    0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,\n-    0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,\n-    0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,\n-    0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,\n-    0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,\n-    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,\n-    0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,\n-    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,\n-    0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,\n-];\n-\n-enum AsciiCharacterClass {\n-    C,  // control\n-    Cw, // control whitespace\n-    W,  // whitespace\n-    D,  // digit\n-    L,  // lowercase\n-    Lx, // lowercase hex digit\n-    U,  // uppercase\n-    Ux, // uppercase hex digit\n-    P,  // punctuation\n-}\n-use self::AsciiCharacterClass::*;\n-\n-static ASCII_CHARACTER_CLASS: [AsciiCharacterClass; 128] = [\n-//  _0 _1 _2 _3 _4 _5 _6 _7 _8 _9 _a _b _c _d _e _f\n-    C, C, C, C, C, C, C, C, C, Cw,Cw,C, Cw,Cw,C, C, // 0_\n-    C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, // 1_\n-    W, P, P, P, P, P, P, P, P, P, P, P, P, P, P, P, // 2_\n-    D, D, D, D, D, D, D, D, D, D, P, P, P, P, P, P, // 3_\n-    P, Ux,Ux,Ux,Ux,Ux,Ux,U, U, U, U, U, U, U, U, U, // 4_\n-    U, U, U, U, U, U, U, U, U, U, U, P, P, P, P, P, // 5_\n-    P, Lx,Lx,Lx,Lx,Lx,Lx,L, L, L, L, L, L, L, L, L, // 6_\n-    L, L, L, L, L, L, L, L, L, L, L, P, P, P, P, C, // 7_\n-];\n-\n #[cfg(test)]\n mod tests {\n-    use super::*;\n+    //! Note that most of these tests are not testing `AsciiExt` methods, but\n+    //! test inherent ascii methods of char, u8, str and [u8]. `AsciiExt` is\n+    //! just using those methods, though.\n     use char::from_u32;\n \n     #[test]"}, {"sha": "429153dc58b4cb8e5bdd53f038375e07204f3b8e", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/94ede93467beb4ac17956845607a7e8b226dda02/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ede93467beb4ac17956845607a7e8b226dda02/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=94ede93467beb4ac17956845607a7e8b226dda02", "patch": "@@ -244,6 +244,7 @@\n #![feature(allow_internal_unstable)]\n #![feature(align_offset)]\n #![feature(array_error_internals)]\n+#![feature(ascii_ctype)]\n #![feature(asm)]\n #![feature(attr_literals)]\n #![feature(box_syntax)]"}, {"sha": "270878dc029c3d52fec5fb70a17b5e1e43fc4a15", "filename": "src/libstd/path.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/94ede93467beb4ac17956845607a7e8b226dda02/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ede93467beb4ac17956845607a7e8b226dda02/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=94ede93467beb4ac17956845607a7e8b226dda02", "patch": "@@ -77,7 +77,6 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use ascii::*;\n use borrow::{Borrow, Cow};\n use cmp;\n use error::Error;"}, {"sha": "98d62a0c953a6e6426546b075d2657af89579972", "filename": "src/libstd/sys/windows/path.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ede93467beb4ac17956845607a7e8b226dda02/src%2Flibstd%2Fsys%2Fwindows%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ede93467beb4ac17956845607a7e8b226dda02/src%2Flibstd%2Fsys%2Fwindows%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpath.rs?ref=94ede93467beb4ac17956845607a7e8b226dda02", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ascii::*;\n-\n use path::Prefix;\n use ffi::OsStr;\n use mem;"}, {"sha": "631d69b05e115871e02c51997a41f44af8d96b7a", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ede93467beb4ac17956845607a7e8b226dda02/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ede93467beb4ac17956845607a7e8b226dda02/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=94ede93467beb4ac17956845607a7e8b226dda02", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ascii::*;\n+use ascii::AsciiExt;\n use collections::HashMap;\n use collections;\n use env::split_paths;"}, {"sha": "c012bdcb6dbe3fe707a86c9330d3646d8957913f", "filename": "src/libstd_unicode/char.rs", "status": "modified", "additions": 523, "deletions": 0, "changes": 523, "blob_url": "https://github.com/rust-lang/rust/blob/94ede93467beb4ac17956845607a7e8b226dda02/src%2Flibstd_unicode%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ede93467beb4ac17956845607a7e8b226dda02/src%2Flibstd_unicode%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Fchar.rs?ref=94ede93467beb4ac17956845607a7e8b226dda02", "patch": "@@ -923,6 +923,529 @@ impl char {\n     pub fn to_uppercase(self) -> ToUppercase {\n         ToUppercase(CaseMappingIter::new(conversions::to_upper(self)))\n     }\n+\n+    /// Checks if the value is within the ASCII range.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let ascii = 'a';\n+    /// let non_ascii = '\u2764';\n+    ///\n+    /// assert!(ascii.is_ascii());\n+    /// assert!(!non_ascii.is_ascii());\n+    /// ```\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn is_ascii(&self) -> bool {\n+        *self as u32 <= 0x7F\n+    }\n+\n+    /// Makes a copy of the value in its ASCII upper case equivalent.\n+    ///\n+    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To uppercase the value in-place, use [`make_ascii_uppercase`].\n+    ///\n+    /// To uppercase ASCII characters in addition to non-ASCII characters, use\n+    /// [`to_uppercase`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let ascii = 'a';\n+    /// let non_ascii = '\u2764';\n+    ///\n+    /// assert_eq!('A', ascii.to_ascii_uppercase());\n+    /// assert_eq!('\u2764', non_ascii.to_ascii_uppercase());\n+    /// ```\n+    ///\n+    /// [`make_ascii_uppercase`]: #method.make_ascii_uppercase\n+    /// [`to_uppercase`]: #method.to_uppercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn to_ascii_uppercase(&self) -> char {\n+        if self.is_ascii() {\n+            (*self as u8).to_ascii_uppercase() as char\n+        } else {\n+            *self\n+        }\n+    }\n+\n+    /// Makes a copy of the value in its ASCII lower case equivalent.\n+    ///\n+    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To lowercase the value in-place, use [`make_ascii_lowercase`].\n+    ///\n+    /// To lowercase ASCII characters in addition to non-ASCII characters, use\n+    /// [`to_lowercase`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let ascii = 'A';\n+    /// let non_ascii = '\u2764';\n+    ///\n+    /// assert_eq!('a', ascii.to_ascii_lowercase());\n+    /// assert_eq!('\u2764', non_ascii.to_ascii_lowercase());\n+    /// ```\n+    ///\n+    /// [`make_ascii_lowercase`]: #method.make_ascii_lowercase\n+    /// [`to_lowercase`]: #method.to_lowercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn to_ascii_lowercase(&self) -> char {\n+        if self.is_ascii() {\n+            (*self as u8).to_ascii_lowercase() as char\n+        } else {\n+            *self\n+        }\n+    }\n+\n+    /// Checks that two values are an ASCII case-insensitive match.\n+    ///\n+    /// Equivalent to `to_ascii_lowercase(a) == to_ascii_lowercase(b)`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let upper_a = 'A';\n+    /// let lower_a = 'a';\n+    /// let lower_z = 'z';\n+    ///\n+    /// assert!(upper_a.eq_ignore_ascii_case(&lower_a));\n+    /// assert!(upper_a.eq_ignore_ascii_case(&upper_a));\n+    /// assert!(!upper_a.eq_ignore_ascii_case(&lower_z));\n+    /// ```\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn eq_ignore_ascii_case(&self, other: &char) -> bool {\n+        self.to_ascii_lowercase() == other.to_ascii_lowercase()\n+    }\n+\n+    /// Converts this type to its ASCII upper case equivalent in-place.\n+    ///\n+    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To return a new uppercased value without modifying the existing one, use\n+    /// [`to_ascii_uppercase`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut ascii = 'a';\n+    ///\n+    /// ascii.make_ascii_uppercase();\n+    ///\n+    /// assert_eq!('A', ascii);\n+    /// ```\n+    ///\n+    /// [`to_ascii_uppercase`]: #method.to_ascii_uppercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn make_ascii_uppercase(&mut self) {\n+        *self = self.to_ascii_uppercase();\n+    }\n+\n+    /// Converts this type to its ASCII lower case equivalent in-place.\n+    ///\n+    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To return a new lowercased value without modifying the existing one, use\n+    /// [`to_ascii_lowercase`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut ascii = 'A';\n+    ///\n+    /// ascii.make_ascii_lowercase();\n+    ///\n+    /// assert_eq!('a', ascii);\n+    /// ```\n+    ///\n+    /// [`to_ascii_lowercase`]: #method.to_ascii_lowercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn make_ascii_lowercase(&mut self) {\n+        *self = self.to_ascii_lowercase();\n+    }\n+\n+    /// Checks if the value is an ASCII alphabetic character:\n+    ///\n+    /// - U+0041 'A' ... U+005A 'Z', or\n+    /// - U+0061 'a' ... U+007A 'z'.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_ctype)]\n+    ///\n+    /// let uppercase_a = 'A';\n+    /// let uppercase_g = 'G';\n+    /// let a = 'a';\n+    /// let g = 'g';\n+    /// let zero = '0';\n+    /// let percent = '%';\n+    /// let space = ' ';\n+    /// let lf = '\\n';\n+    /// let esc: char = 0x1b_u8.into();\n+    ///\n+    /// assert!(uppercase_a.is_ascii_alphabetic());\n+    /// assert!(uppercase_g.is_ascii_alphabetic());\n+    /// assert!(a.is_ascii_alphabetic());\n+    /// assert!(g.is_ascii_alphabetic());\n+    /// assert!(!zero.is_ascii_alphabetic());\n+    /// assert!(!percent.is_ascii_alphabetic());\n+    /// assert!(!space.is_ascii_alphabetic());\n+    /// assert!(!lf.is_ascii_alphabetic());\n+    /// assert!(!esc.is_ascii_alphabetic());\n+    /// ```\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[inline]\n+    pub fn is_ascii_alphabetic(&self) -> bool {\n+        self.is_ascii() && (*self as u8).is_ascii_alphabetic()\n+    }\n+\n+    /// Checks if the value is an ASCII uppercase character:\n+    /// U+0041 'A' ... U+005A 'Z'.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_ctype)]\n+    ///\n+    /// let uppercase_a = 'A';\n+    /// let uppercase_g = 'G';\n+    /// let a = 'a';\n+    /// let g = 'g';\n+    /// let zero = '0';\n+    /// let percent = '%';\n+    /// let space = ' ';\n+    /// let lf = '\\n';\n+    /// let esc: char = 0x1b_u8.into();\n+    ///\n+    /// assert!(uppercase_a.is_ascii_uppercase());\n+    /// assert!(uppercase_g.is_ascii_uppercase());\n+    /// assert!(!a.is_ascii_uppercase());\n+    /// assert!(!g.is_ascii_uppercase());\n+    /// assert!(!zero.is_ascii_uppercase());\n+    /// assert!(!percent.is_ascii_uppercase());\n+    /// assert!(!space.is_ascii_uppercase());\n+    /// assert!(!lf.is_ascii_uppercase());\n+    /// assert!(!esc.is_ascii_uppercase());\n+    /// ```\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[inline]\n+    pub fn is_ascii_uppercase(&self) -> bool {\n+        self.is_ascii() && (*self as u8).is_ascii_uppercase()\n+    }\n+\n+    /// Checks if the value is an ASCII lowercase character:\n+    /// U+0061 'a' ... U+007A 'z'.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_ctype)]\n+    ///\n+    /// let uppercase_a = 'A';\n+    /// let uppercase_g = 'G';\n+    /// let a = 'a';\n+    /// let g = 'g';\n+    /// let zero = '0';\n+    /// let percent = '%';\n+    /// let space = ' ';\n+    /// let lf = '\\n';\n+    /// let esc: char = 0x1b_u8.into();\n+    ///\n+    /// assert!(!uppercase_a.is_ascii_lowercase());\n+    /// assert!(!uppercase_g.is_ascii_lowercase());\n+    /// assert!(a.is_ascii_lowercase());\n+    /// assert!(g.is_ascii_lowercase());\n+    /// assert!(!zero.is_ascii_lowercase());\n+    /// assert!(!percent.is_ascii_lowercase());\n+    /// assert!(!space.is_ascii_lowercase());\n+    /// assert!(!lf.is_ascii_lowercase());\n+    /// assert!(!esc.is_ascii_lowercase());\n+    /// ```\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[inline]\n+    pub fn is_ascii_lowercase(&self) -> bool {\n+        self.is_ascii() && (*self as u8).is_ascii_lowercase()\n+    }\n+\n+    /// Checks if the value is an ASCII alphanumeric character:\n+    ///\n+    /// - U+0041 'A' ... U+005A 'Z', or\n+    /// - U+0061 'a' ... U+007A 'z', or\n+    /// - U+0030 '0' ... U+0039 '9'.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_ctype)]\n+    ///\n+    /// let uppercase_a = 'A';\n+    /// let uppercase_g = 'G';\n+    /// let a = 'a';\n+    /// let g = 'g';\n+    /// let zero = '0';\n+    /// let percent = '%';\n+    /// let space = ' ';\n+    /// let lf = '\\n';\n+    /// let esc: char = 0x1b_u8.into();\n+    ///\n+    /// assert!(uppercase_a.is_ascii_alphanumeric());\n+    /// assert!(uppercase_g.is_ascii_alphanumeric());\n+    /// assert!(a.is_ascii_alphanumeric());\n+    /// assert!(g.is_ascii_alphanumeric());\n+    /// assert!(zero.is_ascii_alphanumeric());\n+    /// assert!(!percent.is_ascii_alphanumeric());\n+    /// assert!(!space.is_ascii_alphanumeric());\n+    /// assert!(!lf.is_ascii_alphanumeric());\n+    /// assert!(!esc.is_ascii_alphanumeric());\n+    /// ```\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[inline]\n+    pub fn is_ascii_alphanumeric(&self) -> bool {\n+        self.is_ascii() && (*self as u8).is_ascii_alphanumeric()\n+    }\n+\n+    /// Checks if the value is an ASCII decimal digit:\n+    /// U+0030 '0' ... U+0039 '9'.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_ctype)]\n+    ///\n+    /// let uppercase_a = 'A';\n+    /// let uppercase_g = 'G';\n+    /// let a = 'a';\n+    /// let g = 'g';\n+    /// let zero = '0';\n+    /// let percent = '%';\n+    /// let space = ' ';\n+    /// let lf = '\\n';\n+    /// let esc: char = 0x1b_u8.into();\n+    ///\n+    /// assert!(!uppercase_a.is_ascii_digit());\n+    /// assert!(!uppercase_g.is_ascii_digit());\n+    /// assert!(!a.is_ascii_digit());\n+    /// assert!(!g.is_ascii_digit());\n+    /// assert!(zero.is_ascii_digit());\n+    /// assert!(!percent.is_ascii_digit());\n+    /// assert!(!space.is_ascii_digit());\n+    /// assert!(!lf.is_ascii_digit());\n+    /// assert!(!esc.is_ascii_digit());\n+    /// ```\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[inline]\n+    pub fn is_ascii_digit(&self) -> bool {\n+        self.is_ascii() && (*self as u8).is_ascii_digit()\n+    }\n+\n+    /// Checks if the value is an ASCII hexadecimal digit:\n+    ///\n+    /// - U+0030 '0' ... U+0039 '9', or\n+    /// - U+0041 'A' ... U+0046 'F', or\n+    /// - U+0061 'a' ... U+0066 'f'.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_ctype)]\n+    ///\n+    /// let uppercase_a = 'A';\n+    /// let uppercase_g = 'G';\n+    /// let a = 'a';\n+    /// let g = 'g';\n+    /// let zero = '0';\n+    /// let percent = '%';\n+    /// let space = ' ';\n+    /// let lf = '\\n';\n+    /// let esc: char = 0x1b_u8.into();\n+    ///\n+    /// assert!(uppercase_a.is_ascii_hexdigit());\n+    /// assert!(!uppercase_g.is_ascii_hexdigit());\n+    /// assert!(a.is_ascii_hexdigit());\n+    /// assert!(!g.is_ascii_hexdigit());\n+    /// assert!(zero.is_ascii_hexdigit());\n+    /// assert!(!percent.is_ascii_hexdigit());\n+    /// assert!(!space.is_ascii_hexdigit());\n+    /// assert!(!lf.is_ascii_hexdigit());\n+    /// assert!(!esc.is_ascii_hexdigit());\n+    /// ```\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[inline]\n+    pub fn is_ascii_hexdigit(&self) -> bool {\n+        self.is_ascii() && (*self as u8).is_ascii_hexdigit()\n+    }\n+\n+    /// Checks if the value is an ASCII punctuation character:\n+    ///\n+    /// - U+0021 ... U+002F `! \" # $ % & ' ( ) * + , - . /`, or\n+    /// - U+003A ... U+0040 `: ; < = > ? @`, or\n+    /// - U+005B ... U+0060 `[ \\\\ ] ^ _ \\``, or\n+    /// - U+007B ... U+007E `{ | } ~`\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_ctype)]\n+    ///\n+    /// let uppercase_a = 'A';\n+    /// let uppercase_g = 'G';\n+    /// let a = 'a';\n+    /// let g = 'g';\n+    /// let zero = '0';\n+    /// let percent = '%';\n+    /// let space = ' ';\n+    /// let lf = '\\n';\n+    /// let esc: char = 0x1b_u8.into();\n+    ///\n+    /// assert!(!uppercase_a.is_ascii_punctuation());\n+    /// assert!(!uppercase_g.is_ascii_punctuation());\n+    /// assert!(!a.is_ascii_punctuation());\n+    /// assert!(!g.is_ascii_punctuation());\n+    /// assert!(!zero.is_ascii_punctuation());\n+    /// assert!(percent.is_ascii_punctuation());\n+    /// assert!(!space.is_ascii_punctuation());\n+    /// assert!(!lf.is_ascii_punctuation());\n+    /// assert!(!esc.is_ascii_punctuation());\n+    /// ```\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[inline]\n+    pub fn is_ascii_punctuation(&self) -> bool {\n+        self.is_ascii() && (*self as u8).is_ascii_punctuation()\n+    }\n+\n+    /// Checks if the value is an ASCII graphic character:\n+    /// U+0021 '@' ... U+007E '~'.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_ctype)]\n+    ///\n+    /// let uppercase_a = 'A';\n+    /// let uppercase_g = 'G';\n+    /// let a = 'a';\n+    /// let g = 'g';\n+    /// let zero = '0';\n+    /// let percent = '%';\n+    /// let space = ' ';\n+    /// let lf = '\\n';\n+    /// let esc: char = 0x1b_u8.into();\n+    ///\n+    /// assert!(uppercase_a.is_ascii_graphic());\n+    /// assert!(uppercase_g.is_ascii_graphic());\n+    /// assert!(a.is_ascii_graphic());\n+    /// assert!(g.is_ascii_graphic());\n+    /// assert!(zero.is_ascii_graphic());\n+    /// assert!(percent.is_ascii_graphic());\n+    /// assert!(!space.is_ascii_graphic());\n+    /// assert!(!lf.is_ascii_graphic());\n+    /// assert!(!esc.is_ascii_graphic());\n+    /// ```\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[inline]\n+    pub fn is_ascii_graphic(&self) -> bool {\n+        self.is_ascii() && (*self as u8).is_ascii_graphic()\n+    }\n+\n+    /// Checks if the value is an ASCII whitespace character:\n+    /// U+0020 SPACE, U+0009 HORIZONTAL TAB, U+000A LINE FEED,\n+    /// U+000C FORM FEED, or U+000D CARRIAGE RETURN.\n+    ///\n+    /// Rust uses the WhatWG Infra Standard's [definition of ASCII\n+    /// whitespace][infra-aw]. There are several other definitions in\n+    /// wide use. For instance, [the POSIX locale][pct] includes\n+    /// U+000B VERTICAL TAB as well as all the above characters,\n+    /// but\u2014from the very same specification\u2014[the default rule for\n+    /// \"field splitting\" in the Bourne shell][bfs] considers *only*\n+    /// SPACE, HORIZONTAL TAB, and LINE FEED as whitespace.\n+    ///\n+    /// If you are writing a program that will process an existing\n+    /// file format, check what that format's definition of whitespace is\n+    /// before using this function.\n+    ///\n+    /// [infra-aw]: https://infra.spec.whatwg.org/#ascii-whitespace\n+    /// [pct]: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap07.html#tag_07_03_01\n+    /// [bfs]: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_05\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_ctype)]\n+    ///\n+    /// let uppercase_a = 'A';\n+    /// let uppercase_g = 'G';\n+    /// let a = 'a';\n+    /// let g = 'g';\n+    /// let zero = '0';\n+    /// let percent = '%';\n+    /// let space = ' ';\n+    /// let lf = '\\n';\n+    /// let esc: char = 0x1b_u8.into();\n+    ///\n+    /// assert!(!uppercase_a.is_ascii_whitespace());\n+    /// assert!(!uppercase_g.is_ascii_whitespace());\n+    /// assert!(!a.is_ascii_whitespace());\n+    /// assert!(!g.is_ascii_whitespace());\n+    /// assert!(!zero.is_ascii_whitespace());\n+    /// assert!(!percent.is_ascii_whitespace());\n+    /// assert!(space.is_ascii_whitespace());\n+    /// assert!(lf.is_ascii_whitespace());\n+    /// assert!(!esc.is_ascii_whitespace());\n+    /// ```\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[inline]\n+    pub fn is_ascii_whitespace(&self) -> bool {\n+        self.is_ascii() && (*self as u8).is_ascii_whitespace()\n+    }\n+\n+    /// Checks if the value is an ASCII control character:\n+    /// U+0000 NUL ... U+001F UNIT SEPARATOR, or U+007F DELETE.\n+    /// Note that most ASCII whitespace characters are control\n+    /// characters, but SPACE is not.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_ctype)]\n+    ///\n+    /// let uppercase_a = 'A';\n+    /// let uppercase_g = 'G';\n+    /// let a = 'a';\n+    /// let g = 'g';\n+    /// let zero = '0';\n+    /// let percent = '%';\n+    /// let space = ' ';\n+    /// let lf = '\\n';\n+    /// let esc: char = 0x1b_u8.into();\n+    ///\n+    /// assert!(!uppercase_a.is_ascii_control());\n+    /// assert!(!uppercase_g.is_ascii_control());\n+    /// assert!(!a.is_ascii_control());\n+    /// assert!(!g.is_ascii_control());\n+    /// assert!(!zero.is_ascii_control());\n+    /// assert!(!percent.is_ascii_control());\n+    /// assert!(!space.is_ascii_control());\n+    /// assert!(lf.is_ascii_control());\n+    /// assert!(esc.is_ascii_control());\n+    /// ```\n+    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[inline]\n+    pub fn is_ascii_control(&self) -> bool {\n+        self.is_ascii() && (*self as u8).is_ascii_control()\n+    }\n }\n \n /// An iterator that decodes UTF-16 encoded code points from an iterator of `u16`s."}, {"sha": "65058b6554aa6d6a809c22f93764c2cd781dedbf", "filename": "src/libstd_unicode/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/94ede93467beb4ac17956845607a7e8b226dda02/src%2Flibstd_unicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ede93467beb4ac17956845607a7e8b226dda02/src%2Flibstd_unicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Flib.rs?ref=94ede93467beb4ac17956845607a7e8b226dda02", "patch": "@@ -30,6 +30,7 @@\n #![deny(warnings)]\n #![no_std]\n \n+#![feature(ascii_ctype)]\n #![feature(core_char_ext)]\n #![feature(str_internals)]\n #![feature(decode_utf8)]"}, {"sha": "a69bf53ee14a3e1306553758b8694948a0e02936", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/94ede93467beb4ac17956845607a7e8b226dda02/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ede93467beb4ac17956845607a7e8b226dda02/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=94ede93467beb4ac17956845607a7e8b226dda02", "patch": "@@ -35,7 +35,6 @@ use visit::{self, FnKind, Visitor};\n use parse::ParseSess;\n use symbol::Symbol;\n \n-use std::ascii::AsciiExt;\n use std::env;\n \n macro_rules! set {"}, {"sha": "3ed3297e05ed95a5976c1795ce3deccb9fe9e987", "filename": "src/test/ui/deref-suggestion.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94ede93467beb4ac17956845607a7e8b226dda02/src%2Ftest%2Fui%2Fderef-suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94ede93467beb4ac17956845607a7e8b226dda02/src%2Ftest%2Fui%2Fderef-suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderef-suggestion.stderr?ref=94ede93467beb4ac17956845607a7e8b226dda02", "patch": "@@ -10,8 +10,8 @@ error[E0308]: mismatched types\n            - .escape_debug()\n            - .escape_default()\n            - .escape_unicode()\n-           - .to_lowercase()\n-           - .to_uppercase()\n+           - .to_ascii_lowercase()\n+           - .to_ascii_uppercase()\n \n error[E0308]: mismatched types\n   --> $DIR/deref-suggestion.rs:23:10"}, {"sha": "a6c56a13076297824a26afe127dd1cbffafbbc74", "filename": "src/tools/cargotest/main.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94ede93467beb4ac17956845607a7e8b226dda02/src%2Ftools%2Fcargotest%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ede93467beb4ac17956845607a7e8b226dda02/src%2Ftools%2Fcargotest%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargotest%2Fmain.rs?ref=94ede93467beb4ac17956845607a7e8b226dda02", "patch": "@@ -165,6 +165,8 @@ fn run_cargo_test(cargo_path: &Path, crate_path: &Path, packages: &[&str]) -> bo\n     let status = command\n         // Disable rust-lang/cargo's cross-compile tests\n         .env(\"CFG_DISABLE_CROSS_TESTS\", \"1\")\n+        // Relax #![deny(warnings)] in some crates\n+        .env(\"RUSTFLAGS\", \"--cap-lints warn\")\n         .current_dir(crate_path)\n         .status()\n         .expect(\"\");"}]}