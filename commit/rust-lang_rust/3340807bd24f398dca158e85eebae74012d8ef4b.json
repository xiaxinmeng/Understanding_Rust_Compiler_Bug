{"sha": "3340807bd24f398dca158e85eebae74012d8ef4b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzNDA4MDdiZDI0ZjM5OGRjYTE1OGU4NWVlYmFlNzQwMTJkOGVmNGI=", "commit": {"author": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2019-01-16T19:26:58Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-19T12:37:25Z"}, "message": "Get basic struct pattern type inference working!", "tree": {"sha": "d0f94210a723ddbdcdfa9c64e66d59c68b52caca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d0f94210a723ddbdcdfa9c64e66d59c68b52caca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3340807bd24f398dca158e85eebae74012d8ef4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3340807bd24f398dca158e85eebae74012d8ef4b", "html_url": "https://github.com/rust-lang/rust/commit/3340807bd24f398dca158e85eebae74012d8ef4b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3340807bd24f398dca158e85eebae74012d8ef4b/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab5deb78117693d776723bc0144e7b34e6f782d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab5deb78117693d776723bc0144e7b34e6f782d1", "html_url": "https://github.com/rust-lang/rust/commit/ab5deb78117693d776723bc0144e7b34e6f782d1"}], "stats": {"total": 205, "additions": 124, "deletions": 81}, "files": [{"sha": "893bad9cd8478364e5d6b82c9fc9236ef972b482", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3340807bd24f398dca158e85eebae74012d8ef4b/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3340807bd24f398dca158e85eebae74012d8ef4b/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=3340807bd24f398dca158e85eebae74012d8ef4b", "patch": "@@ -331,8 +331,8 @@ impl_arena_id!(PatId);\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n pub struct FieldPat {\n-    name: Name,\n-    pat: Option<PatId>,\n+    pub(crate) name: Name,\n+    pub(crate) pat: Option<PatId>,\n }\n \n /// Close relative to rustc's hir::PatKind\n@@ -392,7 +392,9 @@ impl Pat {\n                 let total_iter = prefix.iter().chain(rest.iter()).chain(suffix.iter());\n                 total_iter.map(|pat| *pat).for_each(f);\n             }\n-            Pat::Struct { .. } => {} // TODO\n+            Pat::Struct { args, .. } => {\n+                args.iter().filter_map(|a| a.pat).for_each(f);\n+            }\n         }\n     }\n }\n@@ -814,23 +816,20 @@ impl ExprCollector {\n             ast::PatKind::PlaceholderPat(_) => Pat::Wild,\n             ast::PatKind::StructPat(p) => {\n                 let path = p.path().and_then(Path::from_ast);\n-\n-                if let Some(field_list) = p.field_pat_list() {\n-                    let fields = field_list\n-                        .field_pats()\n-                        .into_iter()\n-                        .map(|f| FieldPat {\n-                            name: Name::new(f.ident),\n-                            pat: f.pat.as_ref().map(|p| self.collect_pat(p)),\n-                        })\n-                        .collect();\n-\n-                    Pat::Struct {\n-                        path: path,\n-                        args: fields,\n-                    }\n-                } else {\n-                    Pat::Missing\n+                let fields = p\n+                    .field_pat_list()\n+                    .expect(\"every struct should have a field list\")\n+                    .field_pats()\n+                    .into_iter()\n+                    .map(|f| FieldPat {\n+                        name: Name::new(f.ident),\n+                        pat: f.pat.as_ref().map(|p| self.collect_pat(p)),\n+                    })\n+                    .collect();\n+\n+                Pat::Struct {\n+                    path: path,\n+                    args: fields,\n                 }\n             }\n "}, {"sha": "6bad61a2acf5efaed87b582618e18b34d89643b8", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 94, "deletions": 49, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/3340807bd24f398dca158e85eebae74012d8ef4b/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3340807bd24f398dca158e85eebae74012d8ef4b/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=3340807bd24f398dca158e85eebae74012d8ef4b", "patch": "@@ -36,7 +36,7 @@ use crate::{\n     db::HirDatabase,\n     type_ref::{TypeRef, Mutability},\n     name::KnownName,\n-    expr::{Body, Expr, Literal, ExprId, Pat, PatId, UnaryOp, BinaryOp, Statement},\n+    expr::{Body, Expr, Literal, ExprId, Pat, PatId, UnaryOp, BinaryOp, Statement, FieldPat},\n };\n \n /// The ID of a type variable.\n@@ -872,6 +872,90 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         }\n     }\n \n+    fn resolve_fields(&self, path: Option<&Path>) -> Option<(Ty, Vec<crate::adt::StructField>)> {\n+        let def = path\n+            .and_then(|path| self.module.resolve_path(self.db, &path).take_types())\n+            .map(|def_id| def_id.resolve(self.db));\n+\n+        let def = if let Some(def) = def {\n+            def\n+        } else {\n+            return None;\n+        };\n+\n+        match def {\n+            Def::Struct(s) => {\n+                let fields: Vec<_> = self\n+                    .db\n+                    .struct_data(s.def_id())\n+                    .variant_data\n+                    .fields()\n+                    .iter()\n+                    .cloned()\n+                    .collect();\n+                Some((type_for_struct(self.db, s), fields))\n+            }\n+            Def::EnumVariant(ev) => {\n+                let fields: Vec<_> = ev.variant_data(self.db).fields().iter().cloned().collect();\n+                Some((type_for_enum_variant(self.db, ev), fields))\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    fn infer_tuple_struct(&mut self, path: Option<&Path>, sub_pats: &[PatId]) -> Ty {\n+        let (ty, fields) = if let Some(x) = self.resolve_fields(path) {\n+            x\n+        } else {\n+            return Ty::Unknown;\n+        };\n+\n+        // walk subpats\n+        if fields.len() != sub_pats.len() {\n+            return Ty::Unknown;\n+        }\n+\n+        for (&sub_pat, field) in sub_pats.iter().zip(fields.iter()) {\n+            let sub_ty = Ty::from_hir(\n+                self.db,\n+                &self.module,\n+                self.impl_block.as_ref(),\n+                &field.type_ref,\n+            );\n+\n+            self.infer_pat(sub_pat, &Expectation::has_type(sub_ty));\n+        }\n+\n+        ty\n+    }\n+\n+    fn infer_struct(&mut self, path: Option<&Path>, sub_pats: &[FieldPat]) -> Ty {\n+        let (ty, fields) = if let Some(x) = self.resolve_fields(path) {\n+            x\n+        } else {\n+            return Ty::Unknown;\n+        };\n+\n+        for sub_pat in sub_pats {\n+            let tyref = fields\n+                .iter()\n+                .find(|field| field.name == sub_pat.name)\n+                .map(|field| &field.type_ref);\n+\n+            if let Some(typeref) = tyref {\n+                let sub_ty = Ty::from_hir(self.db, &self.module, self.impl_block.as_ref(), typeref);\n+\n+                if let Some(pat) = sub_pat.pat {\n+                    self.infer_pat(pat, &Expectation::has_type(sub_ty));\n+                } else {\n+                    // TODO: deal with this case: S { x, y }\n+                }\n+            }\n+        }\n+\n+        ty\n+    }\n+\n     // FIXME: Expectation should probably contain a reference to a Ty instead of\n     // a Ty itself\n     fn infer_pat(&mut self, pat: PatId, expected: &Expectation) -> Ty {\n@@ -900,54 +984,15 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     path: ref p,\n                     args: ref sub_pats,\n                 },\n-                _expected,\n-            ) => {\n-                let def = p\n-                    .as_ref()\n-                    .and_then(|path| self.module.resolve_path(self.db, &path).take_types())\n-                    .map(|def_id| def_id.resolve(self.db));\n-\n-                if let Some(def) = def {\n-                    let (ty, fields) = match def {\n-                        Def::Struct(s) => {\n-                            let fields: Vec<_> = self\n-                                .db\n-                                .struct_data(s.def_id())\n-                                .variant_data\n-                                .fields()\n-                                .iter()\n-                                .cloned()\n-                                .collect();\n-                            (type_for_struct(self.db, s), fields)\n-                        }\n-                        Def::EnumVariant(ev) => {\n-                            let fields: Vec<_> =\n-                                ev.variant_data(self.db).fields().iter().cloned().collect();\n-                            (type_for_enum_variant(self.db, ev), fields)\n-                        }\n-                        _ => unreachable!(),\n-                    };\n-                    // walk subpats\n-                    if fields.len() == sub_pats.len() {\n-                        for (&sub_pat, field) in sub_pats.iter().zip(fields.iter()) {\n-                            let sub_ty = Ty::from_hir(\n-                                self.db,\n-                                &self.module,\n-                                self.impl_block.as_ref(),\n-                                &field.type_ref,\n-                            );\n-\n-                            self.infer_pat(sub_pat, &Expectation::has_type(sub_ty));\n-                        }\n-\n-                        ty\n-                    } else {\n-                        expected.ty.clone()\n-                    }\n-                } else {\n-                    expected.ty.clone()\n-                }\n-            }\n+                _,\n+            ) => self.infer_tuple_struct(p.as_ref(), sub_pats),\n+            (\n+                &Pat::Struct {\n+                    path: ref p,\n+                    args: ref fields,\n+                },\n+                _,\n+            ) => self.infer_struct(p.as_ref(), fields),\n             (_, ref _expected_ty) => expected.ty.clone(),\n         };\n         // use a new type variable if we got Ty::Unknown here"}, {"sha": "41e9c9d349255fcf379b2dc5bd9d7a8fa03e7ea1", "filename": "crates/ra_hir/src/ty/tests/data/adt_pattern.txt", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3340807bd24f398dca158e85eebae74012d8ef4b/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fadt_pattern.txt", "raw_url": "https://github.com/rust-lang/rust/raw/3340807bd24f398dca158e85eebae74012d8ef4b/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fadt_pattern.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fadt_pattern.txt?ref=3340807bd24f398dca158e85eebae74012d8ef4b", "patch": "@@ -1,12 +1,11 @@\n-[49; 192) '{     ...  }; }': ()\n-[59; 60) 'e': E\n-[63; 76) 'E::A { x: 3 }': E\n-[73; 74) '3': usize\n-[82; 124) 'if let...     }': [unknown]\n-[105; 106) 'e': E\n-[107; 124) '{     ...     }': [unknown]\n-[117; 118) 'x': [unknown]\n-[130; 189) 'match ...     }': [unknown]\n-[136; 137) 'e': E\n-[162; 163) 'x': [unknown]\n-[181; 182) '1': i32\n+[68; 155) '{     ...= e; }': ()\n+[78; 79) 'e': E\n+[82; 95) 'E::A { x: 3 }': E\n+[92; 93) '3': usize\n+[106; 113) 'S(y, z)': S\n+[108; 109) 'y': u32\n+[111; 112) 'z': E\n+[116; 119) 'foo': S\n+[129; 148) 'E::A {..._var }': E\n+[139; 146) 'new_var': usize\n+[151; 152) 'e': E"}]}