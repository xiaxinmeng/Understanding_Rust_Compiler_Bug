{"sha": "f2ff646f5f71fd89b19ec11d7bb03128156f1af9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyZmY2NDZmNWY3MWZkODliMTllYzExZDdiYjAzMTI4MTU2ZjFhZjk=", "commit": {"author": {"name": "lukaramu", "email": "lukaramu@users.noreply.github.com", "date": "2017-08-07T11:49:11Z"}, "committer": {"name": "lukaramu", "email": "lukaramu@users.noreply.github.com", "date": "2017-08-07T21:10:16Z"}, "message": "Revise documentation in core::ops::bit\n\nPart of #29365.\n* Added \"real\" examples for `BitOrAssign`, `BitXorAssign`, `ShlAssign`,\n  and `ShrAssign`\n* Rewrote method summary senteces to be in 3rd person singular\n* Rephrased example introductions to be less redundant (\"in this example\"\n  etc.) and to not use \"trivial\"\n* Removed superfluous explicit `fn main()`s in examples\n* Added some missing periods", "tree": {"sha": "2fed554698cff477298ee2900d34b0a40ad6c3f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2fed554698cff477298ee2900d34b0a40ad6c3f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2ff646f5f71fd89b19ec11d7bb03128156f1af9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2ff646f5f71fd89b19ec11d7bb03128156f1af9", "html_url": "https://github.com/rust-lang/rust/commit/f2ff646f5f71fd89b19ec11d7bb03128156f1af9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2ff646f5f71fd89b19ec11d7bb03128156f1af9/comments", "author": null, "committer": null, "parents": [{"sha": "63fc1faf8298d2bd4e9385a2e0286b2ee0db6866", "url": "https://api.github.com/repos/rust-lang/rust/commits/63fc1faf8298d2bd4e9385a2e0286b2ee0db6866", "html_url": "https://github.com/rust-lang/rust/commit/63fc1faf8298d2bd4e9385a2e0286b2ee0db6866"}], "stats": {"total": 272, "additions": 122, "deletions": 150}, "files": [{"sha": "e6fadf616b028a2e98e6b93ca743cb9bc5bc5e7a", "filename": "src/libcore/ops/bit.rs", "status": "modified", "additions": 122, "deletions": 150, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/f2ff646f5f71fd89b19ec11d7bb03128156f1af9/src%2Flibcore%2Fops%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2ff646f5f71fd89b19ec11d7bb03128156f1af9/src%2Flibcore%2Fops%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fbit.rs?ref=f2ff646f5f71fd89b19ec11d7bb03128156f1af9", "patch": "@@ -41,11 +41,11 @@\n #[lang = \"not\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Not {\n-    /// The resulting type after applying the `!` operator\n+    /// The resulting type after applying the `!` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n-    /// The method for the unary `!` operator\n+    /// Performs the unary `!` operation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn not(self) -> Self::Output;\n }\n@@ -70,7 +70,7 @@ not_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///\n /// # Examples\n ///\n-/// In this example, the `&` operator is lifted to a trivial `Scalar` type.\n+/// An implementation of `BitAnd` for a wrapper around `bool`.\n ///\n /// ```\n /// use std::ops::BitAnd;\n@@ -87,16 +87,13 @@ not_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///     }\n /// }\n ///\n-/// fn main() {\n-///     assert_eq!(Scalar(true) & Scalar(true), Scalar(true));\n-///     assert_eq!(Scalar(true) & Scalar(false), Scalar(false));\n-///     assert_eq!(Scalar(false) & Scalar(true), Scalar(false));\n-///     assert_eq!(Scalar(false) & Scalar(false), Scalar(false));\n-/// }\n+/// assert_eq!(Scalar(true) & Scalar(true), Scalar(true));\n+/// assert_eq!(Scalar(true) & Scalar(false), Scalar(false));\n+/// assert_eq!(Scalar(false) & Scalar(true), Scalar(false));\n+/// assert_eq!(Scalar(false) & Scalar(false), Scalar(false));\n /// ```\n ///\n-/// In this example, the `BitAnd` trait is implemented for a `BooleanVector`\n-/// struct.\n+/// An implementation of `BitAnd` for a wrapper around `Vec<bool>`.\n ///\n /// ```\n /// use std::ops::BitAnd;\n@@ -114,22 +111,20 @@ not_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///     }\n /// }\n ///\n-/// fn main() {\n-///     let bv1 = BooleanVector(vec![true, true, false, false]);\n-///     let bv2 = BooleanVector(vec![true, false, true, false]);\n-///     let expected = BooleanVector(vec![true, false, false, false]);\n-///     assert_eq!(bv1 & bv2, expected);\n-/// }\n+/// let bv1 = BooleanVector(vec![true, true, false, false]);\n+/// let bv2 = BooleanVector(vec![true, false, true, false]);\n+/// let expected = BooleanVector(vec![true, false, false, false]);\n+/// assert_eq!(bv1 & bv2, expected);\n /// ```\n #[lang = \"bitand\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} & {RHS}`\"]\n pub trait BitAnd<RHS=Self> {\n-    /// The resulting type after applying the `&` operator\n+    /// The resulting type after applying the `&` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n-    /// The method for the `&` operator\n+    /// Performs the `&` operation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn bitand(self, rhs: RHS) -> Self::Output;\n }\n@@ -154,7 +149,7 @@ bitand_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///\n /// # Examples\n ///\n-/// In this example, the `|` operator is lifted to a trivial `Scalar` type.\n+/// An implementation of `BitOr` for a wrapper around `bool`.\n ///\n /// ```\n /// use std::ops::BitOr;\n@@ -171,16 +166,13 @@ bitand_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///     }\n /// }\n ///\n-/// fn main() {\n-///     assert_eq!(Scalar(true) | Scalar(true), Scalar(true));\n-///     assert_eq!(Scalar(true) | Scalar(false), Scalar(true));\n-///     assert_eq!(Scalar(false) | Scalar(true), Scalar(true));\n-///     assert_eq!(Scalar(false) | Scalar(false), Scalar(false));\n-/// }\n+/// assert_eq!(Scalar(true) | Scalar(true), Scalar(true));\n+/// assert_eq!(Scalar(true) | Scalar(false), Scalar(true));\n+/// assert_eq!(Scalar(false) | Scalar(true), Scalar(true));\n+/// assert_eq!(Scalar(false) | Scalar(false), Scalar(false));\n /// ```\n ///\n-/// In this example, the `BitOr` trait is implemented for a `BooleanVector`\n-/// struct.\n+/// An implementation of `BitOr` for a wrapper around `Vec<bool>`.\n ///\n /// ```\n /// use std::ops::BitOr;\n@@ -198,22 +190,20 @@ bitand_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///     }\n /// }\n ///\n-/// fn main() {\n-///     let bv1 = BooleanVector(vec![true, true, false, false]);\n-///     let bv2 = BooleanVector(vec![true, false, true, false]);\n-///     let expected = BooleanVector(vec![true, true, true, false]);\n-///     assert_eq!(bv1 | bv2, expected);\n-/// }\n+/// let bv1 = BooleanVector(vec![true, true, false, false]);\n+/// let bv2 = BooleanVector(vec![true, false, true, false]);\n+/// let expected = BooleanVector(vec![true, true, true, false]);\n+/// assert_eq!(bv1 | bv2, expected);\n /// ```\n #[lang = \"bitor\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} | {RHS}`\"]\n pub trait BitOr<RHS=Self> {\n-    /// The resulting type after applying the `|` operator\n+    /// The resulting type after applying the `|` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n-    /// The method for the `|` operator\n+    /// Performs the `|` operation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn bitor(self, rhs: RHS) -> Self::Output;\n }\n@@ -238,7 +228,7 @@ bitor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///\n /// # Examples\n ///\n-/// In this example, the `^` operator is lifted to a trivial `Scalar` type.\n+/// An implementation of `BitXor` that lifts `^` to a wrapper around `bool`.\n ///\n /// ```\n /// use std::ops::BitXor;\n@@ -255,16 +245,13 @@ bitor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///     }\n /// }\n ///\n-/// fn main() {\n-///     assert_eq!(Scalar(true) ^ Scalar(true), Scalar(false));\n-///     assert_eq!(Scalar(true) ^ Scalar(false), Scalar(true));\n-///     assert_eq!(Scalar(false) ^ Scalar(true), Scalar(true));\n-///     assert_eq!(Scalar(false) ^ Scalar(false), Scalar(false));\n-/// }\n+/// assert_eq!(Scalar(true) ^ Scalar(true), Scalar(false));\n+/// assert_eq!(Scalar(true) ^ Scalar(false), Scalar(true));\n+/// assert_eq!(Scalar(false) ^ Scalar(true), Scalar(true));\n+/// assert_eq!(Scalar(false) ^ Scalar(false), Scalar(false));\n /// ```\n ///\n-/// In this example, the `BitXor` trait is implemented for a `BooleanVector`\n-/// struct.\n+/// An implementation of `BitXor` trait for a wrapper around `Vec<bool>`.\n ///\n /// ```\n /// use std::ops::BitXor;\n@@ -285,22 +272,20 @@ bitor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///     }\n /// }\n ///\n-/// fn main() {\n-///     let bv1 = BooleanVector(vec![true, true, false, false]);\n-///     let bv2 = BooleanVector(vec![true, false, true, false]);\n-///     let expected = BooleanVector(vec![false, true, true, false]);\n-///     assert_eq!(bv1 ^ bv2, expected);\n-/// }\n+/// let bv1 = BooleanVector(vec![true, true, false, false]);\n+/// let bv2 = BooleanVector(vec![true, false, true, false]);\n+/// let expected = BooleanVector(vec![false, true, true, false]);\n+/// assert_eq!(bv1 ^ bv2, expected);\n /// ```\n #[lang = \"bitxor\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} ^ {RHS}`\"]\n pub trait BitXor<RHS=Self> {\n-    /// The resulting type after applying the `^` operator\n+    /// The resulting type after applying the `^` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n-    /// The method for the `^` operator\n+    /// Performs the `^` operation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn bitxor(self, rhs: RHS) -> Self::Output;\n }\n@@ -326,7 +311,7 @@ bitxor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n /// # Examples\n ///\n /// An implementation of `Shl` that lifts the `<<` operation on integers to a\n-/// `Scalar` struct.\n+/// wrapper around `usize`.\n ///\n /// ```\n /// use std::ops::Shl;\n@@ -342,9 +327,8 @@ bitxor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///         Scalar(lhs << rhs)\n ///     }\n /// }\n-/// fn main() {\n-///     assert_eq!(Scalar(4) << Scalar(2), Scalar(16));\n-/// }\n+///\n+/// assert_eq!(Scalar(4) << Scalar(2), Scalar(16));\n /// ```\n ///\n /// An implementation of `Shl` that spins a vector leftward by a given amount.\n@@ -361,7 +345,7 @@ bitxor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///     type Output = Self;\n ///\n ///     fn shl(self, rhs: usize) -> SpinVector<T> {\n-///         // rotate the vector by `rhs` places\n+///         // Rotate the vector by `rhs` places.\n ///         let (a, b) = self.vec.split_at(rhs);\n ///         let mut spun_vector: Vec<T> = vec![];\n ///         spun_vector.extend_from_slice(b);\n@@ -370,20 +354,18 @@ bitxor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///     }\n /// }\n ///\n-/// fn main() {\n-///     assert_eq!(SpinVector { vec: vec![0, 1, 2, 3, 4] } << 2,\n-///                SpinVector { vec: vec![2, 3, 4, 0, 1] });\n-/// }\n+/// assert_eq!(SpinVector { vec: vec![0, 1, 2, 3, 4] } << 2,\n+///            SpinVector { vec: vec![2, 3, 4, 0, 1] });\n /// ```\n #[lang = \"shl\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} << {RHS}`\"]\n pub trait Shl<RHS> {\n-    /// The resulting type after applying the `<<` operator\n+    /// The resulting type after applying the `<<` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n-    /// The method for the `<<` operator\n+    /// Performs the `<<` operation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn shl(self, rhs: RHS) -> Self::Output;\n }\n@@ -430,7 +412,7 @@ shl_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 isize i128 }\n /// # Examples\n ///\n /// An implementation of `Shr` that lifts the `>>` operation on integers to a\n-/// `Scalar` struct.\n+/// wrapper around `usize`.\n ///\n /// ```\n /// use std::ops::Shr;\n@@ -446,9 +428,8 @@ shl_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 isize i128 }\n ///         Scalar(lhs >> rhs)\n ///     }\n /// }\n-/// fn main() {\n-///     assert_eq!(Scalar(16) >> Scalar(2), Scalar(4));\n-/// }\n+///\n+/// assert_eq!(Scalar(16) >> Scalar(2), Scalar(4));\n /// ```\n ///\n /// An implementation of `Shr` that spins a vector rightward by a given amount.\n@@ -465,7 +446,7 @@ shl_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 isize i128 }\n ///     type Output = Self;\n ///\n ///     fn shr(self, rhs: usize) -> SpinVector<T> {\n-///         // rotate the vector by `rhs` places\n+///         // Rotate the vector by `rhs` places.\n ///         let (a, b) = self.vec.split_at(self.vec.len() - rhs);\n ///         let mut spun_vector: Vec<T> = vec![];\n ///         spun_vector.extend_from_slice(b);\n@@ -474,20 +455,18 @@ shl_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 isize i128 }\n ///     }\n /// }\n ///\n-/// fn main() {\n-///     assert_eq!(SpinVector { vec: vec![0, 1, 2, 3, 4] } >> 2,\n-///                SpinVector { vec: vec![3, 4, 0, 1, 2] });\n-/// }\n+/// assert_eq!(SpinVector { vec: vec![0, 1, 2, 3, 4] } >> 2,\n+///            SpinVector { vec: vec![3, 4, 0, 1, 2] });\n /// ```\n #[lang = \"shr\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} >> {RHS}`\"]\n pub trait Shr<RHS> {\n-    /// The resulting type after applying the `>>` operator\n+    /// The resulting type after applying the `>>` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n-    /// The method for the `>>` operator\n+    /// Performs the `>>` operation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn shr(self, rhs: RHS) -> Self::Output;\n }\n@@ -533,7 +512,8 @@ shr_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n ///\n /// # Examples\n ///\n-/// In this example, the `&=` operator is lifted to a trivial `Scalar` type.\n+/// An implementation of `BitAndAssign` that lifts the `&=` operator to a\n+/// wrapper around `bool`.\n ///\n /// ```\n /// use std::ops::BitAndAssign;\n@@ -548,27 +528,25 @@ shr_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n ///     }\n /// }\n ///\n-/// fn main() {\n-///     let mut scalar = Scalar(true);\n-///     scalar &= Scalar(true);\n-///     assert_eq!(scalar, Scalar(true));\n+/// let mut scalar = Scalar(true);\n+/// scalar &= Scalar(true);\n+/// assert_eq!(scalar, Scalar(true));\n ///\n-///     let mut scalar = Scalar(true);\n-///     scalar &= Scalar(false);\n-///     assert_eq!(scalar, Scalar(false));\n+/// let mut scalar = Scalar(true);\n+/// scalar &= Scalar(false);\n+/// assert_eq!(scalar, Scalar(false));\n ///\n-///     let mut scalar = Scalar(false);\n-///     scalar &= Scalar(true);\n-///     assert_eq!(scalar, Scalar(false));\n+/// let mut scalar = Scalar(false);\n+/// scalar &= Scalar(true);\n+/// assert_eq!(scalar, Scalar(false));\n ///\n-///     let mut scalar = Scalar(false);\n-///     scalar &= Scalar(false);\n-///     assert_eq!(scalar, Scalar(false));\n-/// }\n+/// let mut scalar = Scalar(false);\n+/// scalar &= Scalar(false);\n+/// assert_eq!(scalar, Scalar(false));\n /// ```\n ///\n-/// In this example, the `BitAndAssign` trait is implemented for a\n-/// `BooleanVector` struct.\n+/// Here, the `BitAndAssign` trait is implemented for a wrapper around\n+/// `Vec<bool>`.\n ///\n /// ```\n /// use std::ops::BitAndAssign;\n@@ -577,7 +555,7 @@ shr_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n /// struct BooleanVector(Vec<bool>);\n ///\n /// impl BitAndAssign for BooleanVector {\n-///     // rhs is the \"right-hand side\" of the expression `a &= b`\n+///     // `rhs` is the \"right-hand side\" of the expression `a &= b`.\n ///     fn bitand_assign(&mut self, rhs: Self) {\n ///         assert_eq!(self.0.len(), rhs.0.len());\n ///         *self = BooleanVector(self.0\n@@ -588,18 +566,16 @@ shr_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n ///     }\n /// }\n ///\n-/// fn main() {\n-///     let mut bv = BooleanVector(vec![true, true, false, false]);\n-///     bv &= BooleanVector(vec![true, false, true, false]);\n-///     let expected = BooleanVector(vec![true, false, false, false]);\n-///     assert_eq!(bv, expected);\n-/// }\n+/// let mut bv = BooleanVector(vec![true, true, false, false]);\n+/// bv &= BooleanVector(vec![true, false, true, false]);\n+/// let expected = BooleanVector(vec![true, false, false, false]);\n+/// assert_eq!(bv, expected);\n /// ```\n #[lang = \"bitand_assign\"]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} &= {Rhs}`\"]\n pub trait BitAndAssign<Rhs=Self> {\n-    /// The method for the `&=` operator\n+    /// Performs the `&=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn bitand_assign(&mut self, rhs: Rhs);\n }\n@@ -620,31 +596,31 @@ bitand_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///\n /// # Examples\n ///\n-/// A trivial implementation of `BitOrAssign`. When `Foo |= Foo` happens, it ends up\n-/// calling `bitor_assign`, and therefore, `main` prints `Bitwise Or-ing!`.\n-///\n /// ```\n /// use std::ops::BitOrAssign;\n ///\n-/// struct Foo;\n+/// #[derive(Debug, PartialEq)]\n+/// struct PersonalPreferences {\n+///     likes_cats: bool,\n+///     likes_dogs: bool,\n+/// }\n ///\n-/// impl BitOrAssign for Foo {\n-///     fn bitor_assign(&mut self, _rhs: Foo) {\n-///         println!(\"Bitwise Or-ing!\");\n+/// impl BitOrAssign for PersonalPreferences {\n+///     fn bitor_assign(&mut self, rhs: Self) {\n+///         self.likes_cats |= rhs.likes_cats;\n+///         self.likes_dogs |= rhs.likes_dogs;\n ///     }\n /// }\n ///\n-/// # #[allow(unused_assignments)]\n-/// fn main() {\n-///     let mut foo = Foo;\n-///     foo |= Foo;\n-/// }\n+/// let mut prefs = PersonalPreferences { likes_cats: true, likes_dogs: false };\n+/// prefs |= PersonalPreferences { likes_cats: false, likes_dogs: true };\n+/// assert_eq!(prefs, PersonalPreferences { likes_cats: true, likes_dogs: true });\n /// ```\n #[lang = \"bitor_assign\"]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} |= {Rhs}`\"]\n pub trait BitOrAssign<Rhs=Self> {\n-    /// The method for the `|=` operator\n+    /// Performs the `|=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn bitor_assign(&mut self, rhs: Rhs);\n }\n@@ -665,31 +641,31 @@ bitor_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///\n /// # Examples\n ///\n-/// A trivial implementation of `BitXorAssign`. When `Foo ^= Foo` happens, it ends up\n-/// calling `bitxor_assign`, and therefore, `main` prints `Bitwise Xor-ing!`.\n-///\n /// ```\n /// use std::ops::BitXorAssign;\n ///\n-/// struct Foo;\n+/// #[derive(Debug, PartialEq)]\n+/// struct Personality {\n+///     has_soul: bool,\n+///     likes_knitting: bool,\n+/// }\n ///\n-/// impl BitXorAssign for Foo {\n-///     fn bitxor_assign(&mut self, _rhs: Foo) {\n-///         println!(\"Bitwise Xor-ing!\");\n+/// impl BitXorAssign for Personality {\n+///     fn bitxor_assign(&mut self, rhs: Self) {\n+///         self.has_soul ^= rhs.has_soul;\n+///         self.likes_knitting ^= rhs.likes_knitting;\n ///     }\n /// }\n ///\n-/// # #[allow(unused_assignments)]\n-/// fn main() {\n-///     let mut foo = Foo;\n-///     foo ^= Foo;\n-/// }\n+/// let mut personality = Personality { has_soul: false, likes_knitting: true };\n+/// personality ^= Personality { has_soul: true, likes_knitting: true };\n+/// assert_eq!(personality, Personality { has_soul: true, likes_knitting: false});\n /// ```\n #[lang = \"bitxor_assign\"]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} ^= {Rhs}`\"]\n pub trait BitXorAssign<Rhs=Self> {\n-    /// The method for the `^=` operator\n+    /// Performs the `^=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn bitxor_assign(&mut self, rhs: Rhs);\n }\n@@ -710,31 +686,29 @@ bitxor_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///\n /// # Examples\n ///\n-/// A trivial implementation of `ShlAssign`. When `Foo <<= Foo` happens, it ends up\n-/// calling `shl_assign`, and therefore, `main` prints `Shifting left!`.\n+/// An implementation of `ShlAssign` for a wrapper around `usize`.\n ///\n /// ```\n /// use std::ops::ShlAssign;\n ///\n-/// struct Foo;\n+/// #[derive(Debug, PartialEq)]\n+/// struct Scalar(usize);\n ///\n-/// impl ShlAssign<Foo> for Foo {\n-///     fn shl_assign(&mut self, _rhs: Foo) {\n-///         println!(\"Shifting left!\");\n+/// impl ShlAssign<usize> for Scalar {\n+///     fn shl_assign(&mut self, rhs: usize) {\n+///         self.0 <<= rhs;\n ///     }\n /// }\n ///\n-/// # #[allow(unused_assignments)]\n-/// fn main() {\n-///     let mut foo = Foo;\n-///     foo <<= Foo;\n-/// }\n+/// let mut scalar = Scalar(4);\n+/// scalar <<= 2;\n+/// assert_eq!(scalar, Scalar(16));\n /// ```\n #[lang = \"shl_assign\"]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} <<= {Rhs}`\"]\n pub trait ShlAssign<Rhs> {\n-    /// The method for the `<<=` operator\n+    /// Performs the `<<=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn shl_assign(&mut self, rhs: Rhs);\n }\n@@ -776,31 +750,29 @@ shl_assign_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n ///\n /// # Examples\n ///\n-/// A trivial implementation of `ShrAssign`. When `Foo >>= Foo` happens, it ends up\n-/// calling `shr_assign`, and therefore, `main` prints `Shifting right!`.\n+/// An implementation of `ShrAssign` for a wrapper around `usize`.\n ///\n /// ```\n /// use std::ops::ShrAssign;\n ///\n-/// struct Foo;\n+/// #[derive(Debug, PartialEq)]\n+/// struct Scalar(usize);\n ///\n-/// impl ShrAssign<Foo> for Foo {\n-///     fn shr_assign(&mut self, _rhs: Foo) {\n-///         println!(\"Shifting right!\");\n+/// impl ShrAssign<usize> for Scalar {\n+///     fn shr_assign(&mut self, rhs: usize) {\n+///         self.0 >>= rhs;\n ///     }\n /// }\n ///\n-/// # #[allow(unused_assignments)]\n-/// fn main() {\n-///     let mut foo = Foo;\n-///     foo >>= Foo;\n-/// }\n+/// let mut scalar = Scalar(16);\n+/// scalar >>= 2;\n+/// assert_eq!(scalar, Scalar(4));\n /// ```\n #[lang = \"shr_assign\"]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} >>= {Rhs}`\"]\n pub trait ShrAssign<Rhs=Self> {\n-    /// The method for the `>>=` operator\n+    /// Performs the `>>=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn shr_assign(&mut self, rhs: Rhs);\n }"}]}