{"sha": "25368d24308d6a94ffe8b99f0122bcf5a2175322", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1MzY4ZDI0MzA4ZDZhOTRmZmU4Yjk5ZjAxMjJiY2Y1YTIxNzUzMjI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-09-01T09:26:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-09-01T09:26:10Z"}, "message": "Merge #9954\n\n9954: feat: Show try operator propogated types on ranged hover  r=matklad a=Veykril\n\nBasically this just shows the type of the inner expression of the `?` expression as well as the type of the expression that the `?` returns from:\r\n![Code_wIrCxMqLH9](https://user-images.githubusercontent.com/3757771/130111025-f7ee0742-214a-493b-947a-b4a671e4be92.png)\r\n\r\nUnless both of these types are `core::result::Result` in which case we show the error types only.\r\n![Code_Xruw5FCBNI](https://user-images.githubusercontent.com/3757771/130111024-f9caef82-92e4-4070-b3dd-f2ff9e5d87a9.png)\r\n\r\nIf both types are `core::option::Option` with different type params we do not show this special hover either as it would be pointless(instead fallback to default type hover)\r\n\r\nVery much open to changes to the hover text here(I suppose we also want to show the actual type of the `?` expression, that is its output type?).\r\n\r\nFixes #9931\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "7cfa958bfeb1d5e371263ce38c7c23ebec6bfb7a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7cfa958bfeb1d5e371263ce38c7c23ebec6bfb7a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25368d24308d6a94ffe8b99f0122bcf5a2175322", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhL0cyCRBK7hj4Ov3rIwAA7BgIAGDCNEJv4BdACWGa6KXpijd7\n6Mse5A+xlf+gdkikbUP32JD3Z3W31wvudt0WF+Pumj/IslrHUYz5YaUDMXSKHmCc\nWW4ZBwOSKdfLklIsPbFNjPIH905eWATjtK3eWYrDJpCV5FUtZBWfkQDPNIm6xnqV\n5z7A2UL8e2ZHUCpBblFrQ5SxWHmD0hJcHi8iOckD7AjtXp4ipdEtV6urzr7I9+6p\nZcyFDlSdJXB7oWo+FEINC7mHSVKNTcsXxHWPQrd5srFMs4UqZl+KeVCGtlwXR0JK\njNRrgut/ujtU6L0u80mqc69A71Xjxl98ghE1Om1DlM+yCGuUDNeyPPwHm6LL5/o=\n=GF4S\n-----END PGP SIGNATURE-----\n", "payload": "tree 7cfa958bfeb1d5e371263ce38c7c23ebec6bfb7a\nparent 75acb193944c8a3d6c4698e01080628c90b9df06\nparent 8bbfd45d97219a787f72d4f39adb9a529dc2065c\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1630488370 +0000\ncommitter GitHub <noreply@github.com> 1630488370 +0000\n\nMerge #9954\n\n9954: feat: Show try operator propogated types on ranged hover  r=matklad a=Veykril\n\nBasically this just shows the type of the inner expression of the `?` expression as well as the type of the expression that the `?` returns from:\r\n![Code_wIrCxMqLH9](https://user-images.githubusercontent.com/3757771/130111025-f7ee0742-214a-493b-947a-b4a671e4be92.png)\r\n\r\nUnless both of these types are `core::result::Result` in which case we show the error types only.\r\n![Code_Xruw5FCBNI](https://user-images.githubusercontent.com/3757771/130111024-f9caef82-92e4-4070-b3dd-f2ff9e5d87a9.png)\r\n\r\nIf both types are `core::option::Option` with different type params we do not show this special hover either as it would be pointless(instead fallback to default type hover)\r\n\r\nVery much open to changes to the hover text here(I suppose we also want to show the actual type of the `?` expression, that is its output type?).\r\n\r\nFixes #9931\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25368d24308d6a94ffe8b99f0122bcf5a2175322", "html_url": "https://github.com/rust-lang/rust/commit/25368d24308d6a94ffe8b99f0122bcf5a2175322", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25368d24308d6a94ffe8b99f0122bcf5a2175322/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75acb193944c8a3d6c4698e01080628c90b9df06", "url": "https://api.github.com/repos/rust-lang/rust/commits/75acb193944c8a3d6c4698e01080628c90b9df06", "html_url": "https://github.com/rust-lang/rust/commit/75acb193944c8a3d6c4698e01080628c90b9df06"}, {"sha": "8bbfd45d97219a787f72d4f39adb9a529dc2065c", "url": "https://api.github.com/repos/rust-lang/rust/commits/8bbfd45d97219a787f72d4f39adb9a529dc2065c", "html_url": "https://github.com/rust-lang/rust/commit/8bbfd45d97219a787f72d4f39adb9a529dc2065c"}], "stats": {"total": 223, "additions": 206, "deletions": 17}, "files": [{"sha": "5cd760393f4838b5a80e0cbf16c27c7abb154926", "filename": "crates/hir_ty/src/infer/pat.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/25368d24308d6a94ffe8b99f0122bcf5a2175322/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25368d24308d6a94ffe8b99f0122bcf5a2175322/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs?ref=25368d24308d6a94ffe8b99f0122bcf5a2175322", "patch": "@@ -1,7 +1,6 @@\n //! Type inference for patterns.\n \n-use std::iter::repeat;\n-use std::sync::Arc;\n+use std::{iter::repeat, sync::Arc};\n \n use chalk_ir::Mutability;\n use hir_def::{\n@@ -10,9 +9,10 @@ use hir_def::{\n };\n use hir_expand::name::Name;\n \n-use super::{BindingMode, Expectation, InferenceContext, TypeMismatch};\n use crate::{\n-    infer::{Adjust, Adjustment, AutoBorrow},\n+    infer::{\n+        Adjust, Adjustment, AutoBorrow, BindingMode, Expectation, InferenceContext, TypeMismatch,\n+    },\n     lower::lower_to_chalk_mutability,\n     static_lifetime, Interner, Substitution, Ty, TyBuilder, TyExt, TyKind,\n };"}, {"sha": "2a505c621f229882e72d0253f9208824bf2ed320", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 202, "deletions": 13, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/25368d24308d6a94ffe8b99f0122bcf5a2175322/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25368d24308d6a94ffe8b99f0122bcf5a2175322/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=25368d24308d6a94ffe8b99f0122bcf5a2175322", "patch": "@@ -12,8 +12,8 @@ use ide_db::{\n use itertools::Itertools;\n use stdx::format_to;\n use syntax::{\n-    algo, ast, display::fn_as_proc_macro_label, match_ast, AstNode, AstToken, Direction,\n-    SyntaxKind::*, SyntaxNode, SyntaxToken, T,\n+    algo, ast, display::fn_as_proc_macro_label, match_ast, AstNode, Direction, SyntaxKind::*,\n+    SyntaxNode, SyntaxToken, T,\n };\n \n use crate::{\n@@ -112,9 +112,8 @@ pub(crate) fn hover(\n         _ => 1,\n     })?;\n     let token = sema.descend_into_macros(token);\n-\n-    let mut range_override = None;\n     let node = token.parent()?;\n+    let mut range_override = None;\n     let definition = match_ast! {\n         match node {\n             ast::Name(name) => NameClass::classify(&sema, &name).map(|class| match class {\n@@ -138,7 +137,7 @@ pub(crate) fn hover(\n             ),\n             _ => {\n                 // intra-doc links\n-                if ast::Comment::cast(token.clone()).is_some() {\n+                if token.kind() == COMMENT {\n                     cov_mark::hit!(no_highlight_on_comment_hover);\n                     let (attributes, def) = doc_attributes(&sema, &node)?;\n                     let (docs, doc_mapping) = attributes.docs_with_rangemap(db)?;\n@@ -233,7 +232,7 @@ fn hover_ranged(\n     sema: &Semantics<RootDatabase>,\n     config: &HoverConfig,\n ) -> Option<RangeInfo<HoverResult>> {\n-    let expr = file.covering_element(range).ancestors().find_map(|it| {\n+    let expr_or_pat = file.covering_element(range).ancestors().find_map(|it| {\n         match_ast! {\n             match it {\n                 ast::Expr(expr) => Some(Either::Left(expr)),\n@@ -242,15 +241,111 @@ fn hover_ranged(\n             }\n         }\n     })?;\n-    hover_type_info(sema, config, &expr).map(|it| {\n-        let range = match expr {\n+    let res = match &expr_or_pat {\n+        Either::Left(ast::Expr::TryExpr(try_expr)) => hover_try_expr(sema, config, try_expr),\n+        _ => None,\n+    };\n+    let res = res.or_else(|| hover_type_info(sema, config, &expr_or_pat));\n+    res.map(|it| {\n+        let range = match expr_or_pat {\n             Either::Left(it) => it.syntax().text_range(),\n             Either::Right(it) => it.syntax().text_range(),\n         };\n         RangeInfo::new(range, it)\n     })\n }\n \n+fn hover_try_expr(\n+    sema: &Semantics<RootDatabase>,\n+    config: &HoverConfig,\n+    try_expr: &ast::TryExpr,\n+) -> Option<HoverResult> {\n+    let inner_ty = sema.type_of_expr(&try_expr.expr()?)?.original;\n+    let mut ancestors = try_expr.syntax().ancestors();\n+    let mut body_ty = loop {\n+        let next = ancestors.next()?;\n+        break match_ast! {\n+            match next {\n+                ast::Fn(fn_) => sema.to_def(&fn_)?.ret_type(sema.db),\n+                ast::Item(__) => return None,\n+                ast::ClosureExpr(closure) => sema.type_of_expr(&closure.body()?)?.original,\n+                ast::EffectExpr(effect) => if matches!(effect.effect(), ast::Effect::Async(_) | ast::Effect::Try(_)| ast::Effect::Const(_)) {\n+                    sema.type_of_expr(&effect.block_expr()?.into())?.original\n+                } else {\n+                    continue;\n+                },\n+                _ => continue,\n+            }\n+        };\n+    };\n+\n+    if inner_ty == body_ty {\n+        return None;\n+    }\n+\n+    let mut inner_ty = inner_ty;\n+    let mut s = \"Try Target\".to_owned();\n+\n+    let adts = inner_ty.as_adt().zip(body_ty.as_adt());\n+    if let Some((hir::Adt::Enum(inner), hir::Adt::Enum(body))) = adts {\n+        let famous_defs = FamousDefs(sema, sema.scope(&try_expr.syntax()).krate());\n+        // special case for two options, there is no value in showing them\n+        if let Some(option_enum) = famous_defs.core_option_Option() {\n+            if inner == option_enum && body == option_enum {\n+                cov_mark::hit!(hover_try_expr_opt_opt);\n+                return None;\n+            }\n+        }\n+\n+        // special case two results to show the error variants only\n+        if let Some(result_enum) = famous_defs.core_result_Result() {\n+            if inner == result_enum && body == result_enum {\n+                let error_type_args =\n+                    inner_ty.type_arguments().nth(1).zip(body_ty.type_arguments().nth(1));\n+                if let Some((inner, body)) = error_type_args {\n+                    inner_ty = inner;\n+                    body_ty = body;\n+                    s = \"Try Error\".to_owned();\n+                }\n+            }\n+        }\n+    }\n+\n+    let mut res = HoverResult::default();\n+\n+    let mut targets: Vec<hir::ModuleDef> = Vec::new();\n+    let mut push_new_def = |item: hir::ModuleDef| {\n+        if !targets.contains(&item) {\n+            targets.push(item);\n+        }\n+    };\n+    walk_and_push_ty(sema.db, &inner_ty, &mut push_new_def);\n+    walk_and_push_ty(sema.db, &body_ty, &mut push_new_def);\n+    res.actions.push(HoverAction::goto_type_from_targets(sema.db, targets));\n+\n+    let inner_ty = inner_ty.display(sema.db).to_string();\n+    let body_ty = body_ty.display(sema.db).to_string();\n+    let ty_len_max = inner_ty.len().max(body_ty.len());\n+\n+    let l = \"Propagated as: \".len() - \" Type: \".len();\n+    let static_text_len_diff = l as isize - s.len() as isize;\n+    let tpad = static_text_len_diff.max(0) as usize;\n+    let ppad = static_text_len_diff.min(0).abs() as usize;\n+\n+    res.markup = format!(\n+        \"{bt_start}{} Type: {:>pad0$}\\nPropagated as: {:>pad1$}\\n{bt_end}\",\n+        s,\n+        inner_ty,\n+        body_ty,\n+        pad0 = ty_len_max + tpad,\n+        pad1 = ty_len_max + ppad,\n+        bt_start = if config.markdown() { \"```text\\n\" } else { \"\" },\n+        bt_end = if config.markdown() { \"```\\n\" } else { \"\" }\n+    )\n+    .into();\n+    Some(res)\n+}\n+\n fn hover_type_info(\n     sema: &Semantics<RootDatabase>,\n     config: &HoverConfig,\n@@ -274,13 +369,15 @@ fn hover_type_info(\n         walk_and_push_ty(sema.db, &adjusted_ty, &mut push_new_def);\n         let original = original.display(sema.db).to_string();\n         let adjusted = adjusted_ty.display(sema.db).to_string();\n+        let static_text_diff_len = \"Coerced to: \".len() - \"Type: \".len();\n         format!(\n-            \"```text\\nType: {:>apad$}\\nCoerced to: {:>opad$}\\n```\\n\",\n-            uncoerced = original,\n-            coerced = adjusted,\n-            // 6 base padding for difference of length of the two text prefixes\n-            apad = 6 + adjusted.len().max(original.len()),\n+            \"{bt_start}Type: {:>apad$}\\nCoerced to: {:>opad$}\\n{bt_end}\",\n+            original,\n+            adjusted,\n+            apad = static_text_diff_len + adjusted.len().max(original.len()),\n             opad = original.len(),\n+            bt_start = if config.markdown() { \"```text\\n\" } else { \"\" },\n+            bt_end = if config.markdown() { \"```\\n\" } else { \"\" }\n         )\n         .into()\n     } else {\n@@ -4257,4 +4354,96 @@ fn foo() {\n             \"#]],\n         );\n     }\n+\n+    #[test]\n+    fn hover_try_expr_res() {\n+        check_hover_range(\n+            r#\"\n+//- minicore:result\n+struct FooError;\n+\n+fn foo() -> Result<(), FooError> {\n+    Ok($0Result::<(), FooError>::Ok(())?$0)\n+}\n+\"#,\n+            expect![[r#\"\n+                ```rust\n+                ()\n+                ```\"#]],\n+        );\n+        check_hover_range(\n+            r#\"\n+//- minicore:result\n+struct FooError;\n+struct BarError;\n+\n+fn foo() -> Result<(), FooError> {\n+    Ok($0Result::<(), BarError>::Ok(())?$0)\n+}\n+\"#,\n+            expect![[r#\"\n+                ```text\n+                Try Error Type: BarError\n+                Propagated as:  FooError\n+                ```\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn hover_try_expr() {\n+        check_hover_range(\n+            r#\"\n+struct NotResult<T, U>(T, U);\n+struct Short;\n+struct Looooong;\n+\n+fn foo() -> NotResult<(), Looooong> {\n+    $0NotResult((), Short)?$0;\n+}\n+\"#,\n+            expect![[r#\"\n+                ```text\n+                Try Target Type:    NotResult<(), Short>\n+                Propagated as:   NotResult<(), Looooong>\n+                ```\n+            \"#]],\n+        );\n+        check_hover_range(\n+            r#\"\n+struct NotResult<T, U>(T, U);\n+struct Short;\n+struct Looooong;\n+\n+fn foo() -> NotResult<(), Short> {\n+    $0NotResult((), Looooong)?$0;\n+}\n+\"#,\n+            expect![[r#\"\n+                ```text\n+                Try Target Type: NotResult<(), Looooong>\n+                Propagated as:      NotResult<(), Short>\n+                ```\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn hover_try_expr_option() {\n+        cov_mark::check!(hover_try_expr_opt_opt);\n+        check_hover_range(\n+            r#\"\n+//- minicore: option, try\n+\n+fn foo() -> Option<()> {\n+    $0Some(0)?$0;\n+    None\n+}\n+\"#,\n+            expect![[r#\"\n+                ```rust\n+                <Option<i32> as Try>::Output\n+                ```\"#]],\n+        );\n+    }\n }"}]}