{"sha": "823dbb38e4402b15ff543e615d560d7fb8626ff7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyM2RiYjM4ZTQ0MDJiMTVmZjU0M2U2MTVkNTYwZDdmYjg2MjZmZjc=", "commit": {"author": {"name": "b-naber", "email": "bn@client-141-23-143-226.wlan.tu-berlin.de", "date": "2020-11-19T17:28:38Z"}, "committer": {"name": "b-naber", "email": "bn@MacBook-Pro-42.local", "date": "2020-11-25T18:55:41Z"}, "message": "ast and parser", "tree": {"sha": "978cb01dc8808bbc9df94830a6cf658a131bc0b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/978cb01dc8808bbc9df94830a6cf658a131bc0b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/823dbb38e4402b15ff543e615d560d7fb8626ff7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/823dbb38e4402b15ff543e615d560d7fb8626ff7", "html_url": "https://github.com/rust-lang/rust/commit/823dbb38e4402b15ff543e615d560d7fb8626ff7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/823dbb38e4402b15ff543e615d560d7fb8626ff7/comments", "author": null, "committer": null, "parents": [{"sha": "e0ef0fc392963438af5f0343bf7caa46fb9c3ec3", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0ef0fc392963438af5f0343bf7caa46fb9c3ec3", "html_url": "https://github.com/rust-lang/rust/commit/e0ef0fc392963438af5f0343bf7caa46fb9c3ec3"}], "stats": {"total": 122, "additions": 94, "deletions": 28}, "files": [{"sha": "92b58782465bfa76dbc70d8031ef882464aef6fb", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/823dbb38e4402b15ff543e615d560d7fb8626ff7/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/823dbb38e4402b15ff543e615d560d7fb8626ff7/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=823dbb38e4402b15ff543e615d560d7fb8626ff7", "patch": "@@ -1845,6 +1845,7 @@ impl UintTy {\n pub struct AssocTyConstraint {\n     pub id: NodeId,\n     pub ident: Ident,\n+    pub gen_args: Option<GenericArgs>,\n     pub kind: AssocTyConstraintKind,\n     pub span: Span,\n }"}, {"sha": "878196a69338128541c9d45030effb51226e9718", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/823dbb38e4402b15ff543e615d560d7fb8626ff7/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/823dbb38e4402b15ff543e615d560d7fb8626ff7/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=823dbb38e4402b15ff543e615d560d7fb8626ff7", "patch": "@@ -441,11 +441,14 @@ pub fn noop_flat_map_arm<T: MutVisitor>(mut arm: Arm, vis: &mut T) -> SmallVec<[\n }\n \n pub fn noop_visit_ty_constraint<T: MutVisitor>(\n-    AssocTyConstraint { id, ident, kind, span }: &mut AssocTyConstraint,\n+    AssocTyConstraint { id, ident, gen_args, kind, span }: &mut AssocTyConstraint,\n     vis: &mut T,\n ) {\n     vis.visit_id(id);\n     vis.visit_ident(ident);\n+    if let Some(ref mut gen_args) = gen_args {\n+        vis.visit_generic_args(gen_args);\n+    }\n     match kind {\n         AssocTyConstraintKind::Equality { ref mut ty } => {\n             vis.visit_ty(ty);"}, {"sha": "60ff956bd96246ce941f168267fa5bef2d765dbc", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/823dbb38e4402b15ff543e615d560d7fb8626ff7/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/823dbb38e4402b15ff543e615d560d7fb8626ff7/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=823dbb38e4402b15ff543e615d560d7fb8626ff7", "patch": "@@ -485,6 +485,9 @@ pub fn walk_assoc_ty_constraint<'a, V: Visitor<'a>>(\n     constraint: &'a AssocTyConstraint,\n ) {\n     visitor.visit_ident(constraint.ident);\n+    if let Some(ref gen_args) = constraint.gen_args {\n+        visitor.visit_generic_args(gen_args.span(), gen_args);\n+    }\n     match constraint.kind {\n         AssocTyConstraintKind::Equality { ref ty } => {\n             visitor.visit_ty(ty);"}, {"sha": "b29e4012498bf43c5c0f9b647e448bfc42659434", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/823dbb38e4402b15ff543e615d560d7fb8626ff7/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/823dbb38e4402b15ff543e615d560d7fb8626ff7/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=823dbb38e4402b15ff543e615d560d7fb8626ff7", "patch": "@@ -1372,16 +1372,18 @@ fn deny_equality_constraints(\n                         if param.ident == *ident {\n                             let param = ident;\n                             match &full_path.segments[qself.position..] {\n-                                [PathSegment { ident, .. }] => {\n+                                [PathSegment { ident, args, .. }] => {\n                                     // Make a new `Path` from `foo::Bar` to `Foo<Bar = RhsTy>`.\n                                     let mut assoc_path = full_path.clone();\n                                     // Remove `Bar` from `Foo::Bar`.\n                                     assoc_path.segments.pop();\n                                     let len = assoc_path.segments.len() - 1;\n+                                    let gen_args = args.as_ref().map(|p| (**p).clone());\n                                     // Build `<Bar = RhsTy>`.\n                                     let arg = AngleBracketedArg::Constraint(AssocTyConstraint {\n                                         id: rustc_ast::node_id::DUMMY_NODE_ID,\n                                         ident: *ident,\n+                                        gen_args,\n                                         kind: AssocTyConstraintKind::Equality {\n                                             ty: predicate.rhs_ty.clone(),\n                                         },"}, {"sha": "d813924a63f7c7215bb2f00372a010116687c6d0", "filename": "compiler/rustc_parse/src/parser/path.rs", "status": "modified", "additions": 83, "deletions": 26, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/823dbb38e4402b15ff543e615d560d7fb8626ff7/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/823dbb38e4402b15ff543e615d560d7fb8626ff7/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs?ref=823dbb38e4402b15ff543e615d560d7fb8626ff7", "patch": "@@ -3,10 +3,9 @@ use super::{Parser, TokenType};\n use crate::maybe_whole;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Token};\n-use rustc_ast::{\n-    self as ast, AngleBracketedArg, AngleBracketedArgs, GenericArg, ParenthesizedArgs,\n-};\n+use rustc_ast::{self as ast, AngleBracketedArg, AngleBracketedArgs, ParenthesizedArgs};\n use rustc_ast::{AnonConst, AssocTyConstraint, AssocTyConstraintKind, BlockCheckMode};\n+use rustc_ast::{GenericArg, GenericArgs};\n use rustc_ast::{Path, PathSegment, QSelf};\n use rustc_errors::{pluralize, Applicability, PResult};\n use rustc_span::source_map::{BytePos, Span};\n@@ -414,32 +413,40 @@ impl<'a> Parser<'a> {\n \n     /// Parses a single argument in the angle arguments `<...>` of a path segment.\n     fn parse_angle_arg(&mut self) -> PResult<'a, Option<AngleBracketedArg>> {\n-        if self.check_ident() && self.look_ahead(1, |t| matches!(t.kind, token::Eq | token::Colon))\n-        {\n-            // Parse associated type constraint.\n-            let lo = self.token.span;\n-            let ident = self.parse_ident()?;\n-            let kind = if self.eat(&token::Eq) {\n-                let ty = self.parse_assoc_equality_term(ident, self.prev_token.span)?;\n-                AssocTyConstraintKind::Equality { ty }\n-            } else if self.eat(&token::Colon) {\n-                let bounds = self.parse_generic_bounds(Some(self.prev_token.span))?;\n-                AssocTyConstraintKind::Bound { bounds }\n-            } else {\n-                unreachable!();\n-            };\n+        let lo = self.token.span;\n+        let arg = self.parse_generic_arg()?;\n+        match arg {\n+            Some(arg) => {\n+                if self.check(&token::Colon) | self.check(&token::Eq) {\n+                    let (ident, gen_args) = self.get_ident_from_generic_arg(arg, lo)?;\n+                    let kind = if self.eat(&token::Colon) {\n+                        // Parse associated type constraint bound.\n+\n+                        let bounds = self.parse_generic_bounds(Some(self.prev_token.span))?;\n+                        AssocTyConstraintKind::Bound { bounds }\n+                    } else if self.eat(&token::Eq) {\n+                        // Parse associated type equality constraint\n+\n+                        let ty = self.parse_assoc_equality_term(ident, self.prev_token.span)?;\n+                        AssocTyConstraintKind::Equality { ty }\n+                    } else {\n+                        unreachable!();\n+                    };\n \n-            let span = lo.to(self.prev_token.span);\n+                    let span = lo.to(self.prev_token.span);\n \n-            // Gate associated type bounds, e.g., `Iterator<Item: Ord>`.\n-            if let AssocTyConstraintKind::Bound { .. } = kind {\n-                self.sess.gated_spans.gate(sym::associated_type_bounds, span);\n+                    // Gate associated type bounds, e.g., `Iterator<Item: Ord>`.\n+                    if let AssocTyConstraintKind::Bound { .. } = kind {\n+                        self.sess.gated_spans.gate(sym::associated_type_bounds, span);\n+                    }\n+                    let constraint =\n+                        AssocTyConstraint { id: ast::DUMMY_NODE_ID, ident, gen_args, kind, span };\n+                    Ok(Some(AngleBracketedArg::Constraint(constraint)))\n+                } else {\n+                    Ok(Some(AngleBracketedArg::Arg(arg)))\n+                }\n             }\n-\n-            let constraint = AssocTyConstraint { id: ast::DUMMY_NODE_ID, ident, kind, span };\n-            Ok(Some(AngleBracketedArg::Constraint(constraint)))\n-        } else {\n-            Ok(self.parse_generic_arg()?.map(AngleBracketedArg::Arg))\n+            _ => Ok(None),\n         }\n     }\n \n@@ -534,4 +541,54 @@ impl<'a> Parser<'a> {\n         };\n         Ok(Some(arg))\n     }\n+\n+    fn get_ident_from_generic_arg(\n+        &self,\n+        gen_arg: GenericArg,\n+        lo: Span,\n+    ) -> PResult<'a, (Ident, Option<GenericArgs>)> {\n+        let gen_arg_span = gen_arg.span();\n+        match gen_arg {\n+            GenericArg::Type(t) => match t.into_inner().kind {\n+                ast::TyKind::Path(qself, mut path) => {\n+                    if let Some(qself) = qself {\n+                        let mut err = self.struct_span_err(\n+                            gen_arg_span,\n+                            \"qualified paths cannot be used in associated type constraints\",\n+                        );\n+                        err.span_label(\n+                            qself.path_span,\n+                            \"not allowed in associated type constraints\",\n+                        );\n+                        return Err(err);\n+                    }\n+                    if path.segments.len() == 1 {\n+                        let path_seg = path.segments.remove(0);\n+                        let ident = path_seg.ident;\n+                        let gen_args = path_seg.args.map(|args| args.into_inner());\n+                        return Ok((ident, gen_args));\n+                    }\n+                    let err = self.struct_span_err(\n+                        path.span,\n+                        \"paths with multiple segments cannot be used in associated type constraints\",\n+                    );\n+                    return Err(err);\n+                }\n+                _ => {\n+                    let span = lo.to(self.prev_token.span);\n+                    let err = self.struct_span_err(\n+                        span,\n+                        \"only path types can be used in associated type constraints\",\n+                    );\n+                    return Err(err);\n+                }\n+            },\n+            _ => {\n+                let span = lo.to(self.prev_token.span);\n+                let err = self\n+                    .struct_span_err(span, \"only types can be used in associated type constraints\");\n+                return Err(err);\n+            }\n+        }\n+    }\n }"}]}