{"sha": "65b49902538b319f9fb07532beff9d02efd3197f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1YjQ5OTAyNTM4YjMxOWY5ZmIwNzUzMmJlZmY5ZDAyZWZkMzE5N2Y=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-03-14T17:11:37Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-03-14T23:43:03Z"}, "message": "Use a single Lock for CodeMap.stable_id_to_filemap and CodeMap.files", "tree": {"sha": "e629b28cc9e576c6d1f5c02a6712edc8183ec580", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e629b28cc9e576c6d1f5c02a6712edc8183ec580"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65b49902538b319f9fb07532beff9d02efd3197f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65b49902538b319f9fb07532beff9d02efd3197f", "html_url": "https://github.com/rust-lang/rust/commit/65b49902538b319f9fb07532beff9d02efd3197f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65b49902538b319f9fb07532beff9d02efd3197f/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8395ce9451c901a4b5ce3afd916bd20785e6db7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/8395ce9451c901a4b5ce3afd916bd20785e6db7f", "html_url": "https://github.com/rust-lang/rust/commit/8395ce9451c901a4b5ce3afd916bd20785e6db7f"}], "stats": {"total": 57, "additions": 32, "deletions": 25}, "files": [{"sha": "7027fdfa2fe3d42e2f031e85e8be944b67c0e143", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 31, "deletions": 24, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/65b49902538b319f9fb07532beff9d02efd3197f/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65b49902538b319f9fb07532beff9d02efd3197f/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=65b49902538b319f9fb07532beff9d02efd3197f", "patch": "@@ -124,13 +124,17 @@ impl StableFilemapId {\n // CodeMap\n //\n \n+pub(super) struct CodeMapFiles {\n+    pub(super) file_maps: Vec<Lrc<FileMap>>,\n+    stable_id_to_filemap: FxHashMap<StableFilemapId, Lrc<FileMap>>\n+}\n+\n pub struct CodeMap {\n-    pub(super) files: Lock<Vec<Lrc<FileMap>>>,\n+    pub(super) files: Lock<CodeMapFiles>,\n     file_loader: Box<FileLoader + Sync + Send>,\n     // This is used to apply the file path remapping as specified via\n     // --remap-path-prefix to all FileMaps allocated within this CodeMap.\n     path_mapping: FilePathMapping,\n-    stable_id_to_filemap: Lock<FxHashMap<StableFilemapId, Lrc<FileMap>>>,\n     /// In case we are in a doctest, replace all file names with the PathBuf,\n     /// and add the given offsets to the line info\n     doctest_offset: Option<(FileName, isize)>,\n@@ -139,10 +143,12 @@ pub struct CodeMap {\n impl CodeMap {\n     pub fn new(path_mapping: FilePathMapping) -> CodeMap {\n         CodeMap {\n-            files: Lock::new(Vec::new()),\n+            files: Lock::new(CodeMapFiles {\n+                file_maps: Vec::new(),\n+                stable_id_to_filemap: FxHashMap(),\n+            }),\n             file_loader: Box::new(RealFileLoader),\n             path_mapping,\n-            stable_id_to_filemap: Lock::new(FxHashMap()),\n             doctest_offset: None,\n         }\n     }\n@@ -160,10 +166,12 @@ impl CodeMap {\n                             path_mapping: FilePathMapping)\n                             -> CodeMap {\n         CodeMap {\n-            files: Lock::new(Vec::new()),\n+            files: Lock::new(CodeMapFiles {\n+                file_maps: Vec::new(),\n+                stable_id_to_filemap: FxHashMap(),\n+            }),\n             file_loader: file_loader,\n             path_mapping,\n-            stable_id_to_filemap: Lock::new(FxHashMap()),\n             doctest_offset: None,\n         }\n     }\n@@ -187,16 +195,15 @@ impl CodeMap {\n     }\n \n     pub fn files(&self) -> LockGuard<Vec<Lrc<FileMap>>> {\n-        self.files.borrow()\n+        LockGuard::map(self.files.borrow(), |files| &mut files.file_maps)\n     }\n \n     pub fn filemap_by_stable_id(&self, stable_id: StableFilemapId) -> Option<Lrc<FileMap>> {\n-        self.stable_id_to_filemap.borrow().get(&stable_id).map(|fm| fm.clone())\n+        self.files.borrow().stable_id_to_filemap.get(&stable_id).map(|fm| fm.clone())\n     }\n \n     fn next_start_pos(&self) -> usize {\n-        let files = self.files.borrow();\n-        match files.last() {\n+        match self.files.borrow().file_maps.last() {\n             None => 0,\n             // Add one so there is some space between files. This lets us distinguish\n             // positions in the codemap, even in the presence of zero-length files.\n@@ -206,6 +213,7 @@ impl CodeMap {\n \n     /// Creates a new filemap without setting its line information. If you don't\n     /// intend to set the line information yourself, you should use new_filemap_and_lines.\n+    /// This does not ensure that only one FileMap exists per file name.\n     pub fn new_filemap(&self, filename: FileName, src: String) -> Lrc<FileMap> {\n         let start_pos = self.next_start_pos();\n \n@@ -231,16 +239,16 @@ impl CodeMap {\n             Pos::from_usize(start_pos),\n         ));\n \n-        self.files.borrow_mut().push(filemap.clone());\n+        let mut files = self.files.borrow_mut();\n \n-        self.stable_id_to_filemap\n-            .borrow_mut()\n-            .insert(StableFilemapId::new(&filemap), filemap.clone());\n+        files.file_maps.push(filemap.clone());\n+        files.stable_id_to_filemap.insert(StableFilemapId::new(&filemap), filemap.clone());\n \n         filemap\n     }\n \n     /// Creates a new filemap and sets its line information.\n+    /// This does not ensure that only one FileMap exists per file name.\n     pub fn new_filemap_and_lines(&self, filename: &Path, src: &str) -> Lrc<FileMap> {\n         let fm = self.new_filemap(filename.to_owned().into(), src.to_owned());\n         let mut byte_pos: u32 = fm.start_pos.0;\n@@ -303,11 +311,10 @@ impl CodeMap {\n             name_hash,\n         });\n \n-        self.files.borrow_mut().push(filemap.clone());\n+        let mut files = self.files.borrow_mut();\n \n-        self.stable_id_to_filemap\n-            .borrow_mut()\n-            .insert(StableFilemapId::new(&filemap), filemap.clone());\n+        files.file_maps.push(filemap.clone());\n+        files.stable_id_to_filemap.insert(StableFilemapId::new(&filemap), filemap.clone());\n \n         filemap\n     }\n@@ -398,7 +405,7 @@ impl CodeMap {\n     pub fn lookup_line(&self, pos: BytePos) -> Result<FileMapAndLine, Lrc<FileMap>> {\n         let idx = self.lookup_filemap_idx(pos);\n \n-        let f = (*self.files.borrow())[idx].clone();\n+        let f = (*self.files.borrow().file_maps)[idx].clone();\n \n         match f.lookup_line(pos) {\n             Some(line) => Ok(FileMapAndLine { fm: f, line: line }),\n@@ -452,7 +459,7 @@ impl CodeMap {\n     }\n \n     pub fn span_to_string(&self, sp: Span) -> String {\n-        if self.files.borrow().is_empty() && sp.source_equal(&DUMMY_SP) {\n+        if self.files.borrow().file_maps.is_empty() && sp.source_equal(&DUMMY_SP) {\n             return \"no-location\".to_string();\n         }\n \n@@ -787,7 +794,7 @@ impl CodeMap {\n     }\n \n     pub fn get_filemap(&self, filename: &FileName) -> Option<Lrc<FileMap>> {\n-        for fm in self.files.borrow().iter() {\n+        for fm in self.files.borrow().file_maps.iter() {\n             if *filename == fm.name {\n                 return Some(fm.clone());\n             }\n@@ -798,15 +805,15 @@ impl CodeMap {\n     /// For a global BytePos compute the local offset within the containing FileMap\n     pub fn lookup_byte_offset(&self, bpos: BytePos) -> FileMapAndBytePos {\n         let idx = self.lookup_filemap_idx(bpos);\n-        let fm = (*self.files.borrow())[idx].clone();\n+        let fm = (*self.files.borrow().file_maps)[idx].clone();\n         let offset = bpos - fm.start_pos;\n         FileMapAndBytePos {fm: fm, pos: offset}\n     }\n \n     /// Converts an absolute BytePos to a CharPos relative to the filemap.\n     pub fn bytepos_to_file_charpos(&self, bpos: BytePos) -> CharPos {\n         let idx = self.lookup_filemap_idx(bpos);\n-        let map = &(*self.files.borrow())[idx];\n+        let map = &(*self.files.borrow().file_maps)[idx];\n \n         // The number of extra bytes due to multibyte chars in the FileMap\n         let mut total_extra_bytes = 0;\n@@ -832,7 +839,7 @@ impl CodeMap {\n     // Return the index of the filemap (in self.files) which contains pos.\n     pub fn lookup_filemap_idx(&self, pos: BytePos) -> usize {\n         let files = self.files.borrow();\n-        let files = &*files;\n+        let files = &files.file_maps;\n         let count = files.len();\n \n         // Binary search for the filemap."}, {"sha": "815ba49a60a72ffe5c6314d692b3f54ac737dd38", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/65b49902538b319f9fb07532beff9d02efd3197f/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65b49902538b319f9fb07532beff9d02efd3197f/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=65b49902538b319f9fb07532beff9d02efd3197f", "patch": "@@ -611,7 +611,7 @@ impl<'a> StringReader<'a> {\n                 // I guess this is the only way to figure out if\n                 // we're at the beginning of the file...\n                 let cmap = CodeMap::new(FilePathMapping::empty());\n-                cmap.files.borrow_mut().push(self.filemap.clone());\n+                cmap.files.borrow_mut().file_maps.push(self.filemap.clone());\n                 let loc = cmap.lookup_char_pos_adj(self.pos);\n                 debug!(\"Skipping a shebang\");\n                 if loc.line == 1 && loc.col == CharPos(0) {"}]}