{"sha": "4f9506416c95bbf4fbd46c6dafb13bb30bb2feee", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmOTUwNjQxNmM5NWJiZjRmYmQ0NmM2ZGFmYjEzYmIzMGJiMmZlZWU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-01-27T13:04:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-01-27T13:04:53Z"}, "message": "Merge #2887\n\n2887: Initial auto import action implementation r=matklad a=SomeoneToIgnore\n\nCloses https://github.com/rust-analyzer/rust-analyzer/issues/2180\r\n\r\nAdds an auto import action implementation.\r\n\r\nThis implementation is not ideal and has a few limitations:\r\n\r\n* The import search functionality should be moved into a separate crate accessible from ra_assists.\r\nThis requires a lot of changes and a preliminary design. \r\nCurrently the functionality is provided as a trait impl, more on that here: https://github.com/rust-analyzer/rust-analyzer/issues/2180#issuecomment-575690942\r\n\r\n* Due to the design desicion from the previous item, no doctests are run for the new aciton (look for a new FIXME in the PR)\r\n\r\n* For the same reason, I have to create the mock trait implementaion to test the assist\r\n\r\n* Ideally, I think we should have this feature as a diagnostics (that detects an absense of an import) that has a corresponding quickfix action that gets evaluated on demand.\r\nCurretly we perform the import search every time we resolve the import which looks suboptimal.\r\nThis requires `classify_name_ref` to be moved from ra_ide, so not done currently.\r\n\r\nA few improvements to the imports mechanism to be considered later:\r\n\r\n* Constants like `ra_syntax::SyntaxKind::NAME` are not imported, because they are not present in the database\r\n\r\n* Method usages are not imported, they are found in the database, but `find_use_path` does not return any import paths for them\r\n\r\n* Some import paths returned by the `find_use_path` method end up in `core::` or `alloc::` instead of `std:`, for example: `core::fmt::Debug` instead of `std::fmt::Debug`.\r\nThis is not an error techically, but still looks weird.\r\n\r\n* No detection of cases where a trait should be imported in order to be able to call a method\r\n\r\n* Improve `auto_import_text_edit` functionality: refactor it and move away from the place it is now, add better logic for merging the new import with already existing imports\n\nCo-authored-by: Kirill Bulatov <mail4score@gmail.com>", "tree": {"sha": "38e8d121c8a9790d2e3f2ab83c8dcb0a778681cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/38e8d121c8a9790d2e3f2ab83c8dcb0a778681cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f9506416c95bbf4fbd46c6dafb13bb30bb2feee", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeLt/1CRBK7hj4Ov3rIwAAdHIIAAS/ZCw/dxlcP7DNStIiKeiE\nSXGJpKxtgc0RzKNmEMu7EQzMQFR0cMRt61Y1u8GnmbzmoHrVVWjZs8AdsIOPiZ5O\nTH6c8i+7Bds/o3wrFVrYHhWreG5hkcE7qWeyT93EeISBU1p6a+EIDNaMTElzixl2\nFwQt1TNuEUzRLX5fNfab3W/u4lfMjAdd2NrhKBo9Ny4A6sywKzt+LlVDLZtrfYGw\nPoEJ7CmEXm9gV8tOlzqY1RnRbkyUzqsLsVXW7+GLGoWLTyjgZblcLZntNHDlpak3\nx5tYKeyJ0wpywWjp9ZJBShDKfC7YlgGEe3mrHxSnxObvtI0Ym2GzzEY40ylCAt4=\n=/OOI\n-----END PGP SIGNATURE-----\n", "payload": "tree 38e8d121c8a9790d2e3f2ab83c8dcb0a778681cd\nparent a108f22d835c8d67c93c66758d89371fff179b9a\nparent 9be1ab7ff948d89334a8acbc309c8235d4ab374f\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1580130293 +0000\ncommitter GitHub <noreply@github.com> 1580130293 +0000\n\nMerge #2887\n\n2887: Initial auto import action implementation r=matklad a=SomeoneToIgnore\n\nCloses https://github.com/rust-analyzer/rust-analyzer/issues/2180\r\n\r\nAdds an auto import action implementation.\r\n\r\nThis implementation is not ideal and has a few limitations:\r\n\r\n* The import search functionality should be moved into a separate crate accessible from ra_assists.\r\nThis requires a lot of changes and a preliminary design. \r\nCurrently the functionality is provided as a trait impl, more on that here: https://github.com/rust-analyzer/rust-analyzer/issues/2180#issuecomment-575690942\r\n\r\n* Due to the design desicion from the previous item, no doctests are run for the new aciton (look for a new FIXME in the PR)\r\n\r\n* For the same reason, I have to create the mock trait implementaion to test the assist\r\n\r\n* Ideally, I think we should have this feature as a diagnostics (that detects an absense of an import) that has a corresponding quickfix action that gets evaluated on demand.\r\nCurretly we perform the import search every time we resolve the import which looks suboptimal.\r\nThis requires `classify_name_ref` to be moved from ra_ide, so not done currently.\r\n\r\nA few improvements to the imports mechanism to be considered later:\r\n\r\n* Constants like `ra_syntax::SyntaxKind::NAME` are not imported, because they are not present in the database\r\n\r\n* Method usages are not imported, they are found in the database, but `find_use_path` does not return any import paths for them\r\n\r\n* Some import paths returned by the `find_use_path` method end up in `core::` or `alloc::` instead of `std:`, for example: `core::fmt::Debug` instead of `std::fmt::Debug`.\r\nThis is not an error techically, but still looks weird.\r\n\r\n* No detection of cases where a trait should be imported in order to be able to call a method\r\n\r\n* Improve `auto_import_text_edit` functionality: refactor it and move away from the place it is now, add better logic for merging the new import with already existing imports\n\nCo-authored-by: Kirill Bulatov <mail4score@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f9506416c95bbf4fbd46c6dafb13bb30bb2feee", "html_url": "https://github.com/rust-lang/rust/commit/4f9506416c95bbf4fbd46c6dafb13bb30bb2feee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f9506416c95bbf4fbd46c6dafb13bb30bb2feee/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a108f22d835c8d67c93c66758d89371fff179b9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a108f22d835c8d67c93c66758d89371fff179b9a", "html_url": "https://github.com/rust-lang/rust/commit/a108f22d835c8d67c93c66758d89371fff179b9a"}, {"sha": "9be1ab7ff948d89334a8acbc309c8235d4ab374f", "url": "https://api.github.com/repos/rust-lang/rust/commits/9be1ab7ff948d89334a8acbc309c8235d4ab374f", "html_url": "https://github.com/rust-lang/rust/commit/9be1ab7ff948d89334a8acbc309c8235d4ab374f"}], "stats": {"total": 527, "additions": 509, "deletions": 18}, "files": [{"sha": "2ab65ab99a63cd2871a6f5a9bf79f20413ef4061", "filename": "crates/ra_assists/src/assist_ctx.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f9506416c95bbf4fbd46c6dafb13bb30bb2feee/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9506416c95bbf4fbd46c6dafb13bb30bb2feee/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs?ref=4f9506416c95bbf4fbd46c6dafb13bb30bb2feee", "patch": "@@ -101,7 +101,6 @@ impl<'a, DB: HirDatabase> AssistCtx<'a, DB> {\n         Some(assist)\n     }\n \n-    #[allow(dead_code)] // will be used for auto import assist with multiple actions\n     pub(crate) fn add_assist_group(\n         self,\n         id: AssistId,\n@@ -168,7 +167,6 @@ pub(crate) struct ActionBuilder {\n }\n \n impl ActionBuilder {\n-    #[allow(dead_code)]\n     /// Adds a custom label to the action, if it needs to be different from the assist label\n     pub(crate) fn label(&mut self, label: impl Into<String>) {\n         self.label = Some(label.into())"}, {"sha": "9163cc662754c6aa6dc4084b36e88d1d17734954", "filename": "crates/ra_assists/src/assists/auto_import.rs", "status": "added", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/4f9506416c95bbf4fbd46c6dafb13bb30bb2feee/crates%2Fra_assists%2Fsrc%2Fassists%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9506416c95bbf4fbd46c6dafb13bb30bb2feee/crates%2Fra_assists%2Fsrc%2Fassists%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fauto_import.rs?ref=4f9506416c95bbf4fbd46c6dafb13bb30bb2feee", "patch": "@@ -0,0 +1,222 @@\n+use hir::db::HirDatabase;\n+use ra_syntax::{\n+    ast::{self, AstNode},\n+    SmolStr, SyntaxElement,\n+    SyntaxKind::{NAME_REF, USE_ITEM},\n+    SyntaxNode,\n+};\n+\n+use crate::{\n+    assist_ctx::{ActionBuilder, Assist, AssistCtx},\n+    auto_import_text_edit, AssistId, ImportsLocator,\n+};\n+\n+// Assist: auto_import\n+//\n+// If the name is unresolved, provides all possible imports for it.\n+//\n+// ```\n+// fn main() {\n+//     let map = HashMap<|>::new();\n+// }\n+// ```\n+// ->\n+// ```\n+// use std::collections::HashMap;\n+//\n+// fn main() {\n+//     let map = HashMap<|>::new();\n+// }\n+// ```\n+pub(crate) fn auto_import<F: ImportsLocator>(\n+    ctx: AssistCtx<impl HirDatabase>,\n+    imports_locator: &mut F,\n+) -> Option<Assist> {\n+    let path: ast::Path = ctx.find_node_at_offset()?;\n+    let module = path.syntax().ancestors().find_map(ast::Module::cast);\n+    let position = match module.and_then(|it| it.item_list()) {\n+        Some(item_list) => item_list.syntax().clone(),\n+        None => {\n+            let current_file = path.syntax().ancestors().find_map(ast::SourceFile::cast)?;\n+            current_file.syntax().clone()\n+        }\n+    };\n+    let source_analyzer = ctx.source_analyzer(&position, None);\n+    let module_with_name_to_import = source_analyzer.module()?;\n+    let path_to_import = ctx.covering_element().ancestors().find_map(ast::Path::cast)?;\n+    if source_analyzer.resolve_path(ctx.db, &path_to_import).is_some() {\n+        return None;\n+    }\n+\n+    let name_to_import = &find_applicable_name_ref(ctx.covering_element())?.syntax().to_string();\n+    let proposed_imports = imports_locator\n+        .find_imports(&name_to_import.to_string())\n+        .into_iter()\n+        .filter_map(|module_def| module_with_name_to_import.find_use_path(ctx.db, module_def))\n+        .filter(|use_path| !use_path.segments.is_empty())\n+        .take(20)\n+        .map(|import| import.to_string())\n+        .collect::<std::collections::BTreeSet<_>>();\n+    if proposed_imports.is_empty() {\n+        return None;\n+    }\n+\n+    ctx.add_assist_group(AssistId(\"auto_import\"), \"auto import\", || {\n+        proposed_imports\n+            .into_iter()\n+            .map(|import| import_to_action(import, &position, &path_to_import.syntax()))\n+            .collect()\n+    })\n+}\n+\n+fn find_applicable_name_ref(element: SyntaxElement) -> Option<ast::NameRef> {\n+    if element.ancestors().find(|ancestor| ancestor.kind() == USE_ITEM).is_some() {\n+        None\n+    } else if element.kind() == NAME_REF {\n+        Some(element.as_node().cloned().and_then(ast::NameRef::cast)?)\n+    } else {\n+        let parent = element.parent()?;\n+        if parent.kind() == NAME_REF {\n+            Some(ast::NameRef::cast(parent)?)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+fn import_to_action(import: String, position: &SyntaxNode, anchor: &SyntaxNode) -> ActionBuilder {\n+    let mut action_builder = ActionBuilder::default();\n+    action_builder.label(format!(\"Import `{}`\", &import));\n+    auto_import_text_edit(\n+        position,\n+        anchor,\n+        &[SmolStr::new(import)],\n+        action_builder.text_edit_builder(),\n+    );\n+    action_builder\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use crate::helpers::{\n+        check_assist_with_imports_locator, check_assist_with_imports_locator_not_applicable,\n+        TestImportsLocator,\n+    };\n+\n+    #[test]\n+    fn applicable_when_found_an_import() {\n+        check_assist_with_imports_locator(\n+            auto_import,\n+            TestImportsLocator::new,\n+            r\"\n+            PubStruct<|>\n+\n+            pub mod PubMod {\n+                pub struct PubStruct;\n+            }\n+            \",\n+            r\"\n+            use PubMod::PubStruct;\n+\n+            PubStruct<|>\n+\n+            pub mod PubMod {\n+                pub struct PubStruct;\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn applicable_when_found_multiple_imports() {\n+        check_assist_with_imports_locator(\n+            auto_import,\n+            TestImportsLocator::new,\n+            r\"\n+            PubStruct<|>\n+\n+            pub mod PubMod1 {\n+                pub struct PubStruct;\n+            }\n+            pub mod PubMod2 {\n+                pub struct PubStruct;\n+            }\n+            pub mod PubMod3 {\n+                pub struct PubStruct;\n+            }\n+            \",\n+            r\"\n+            use PubMod1::PubStruct;\n+\n+            PubStruct<|>\n+\n+            pub mod PubMod1 {\n+                pub struct PubStruct;\n+            }\n+            pub mod PubMod2 {\n+                pub struct PubStruct;\n+            }\n+            pub mod PubMod3 {\n+                pub struct PubStruct;\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_for_already_imported_types() {\n+        check_assist_with_imports_locator_not_applicable(\n+            auto_import,\n+            TestImportsLocator::new,\n+            r\"\n+            use PubMod::PubStruct;\n+\n+            PubStruct<|>\n+\n+            pub mod PubMod {\n+                pub struct PubStruct;\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_for_types_with_private_paths() {\n+        check_assist_with_imports_locator_not_applicable(\n+            auto_import,\n+            TestImportsLocator::new,\n+            r\"\n+            PrivateStruct<|>\n+\n+            pub mod PubMod {\n+                struct PrivateStruct;\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_when_no_imports_found() {\n+        check_assist_with_imports_locator_not_applicable(\n+            auto_import,\n+            TestImportsLocator::new,\n+            \"\n+            PubStruct<|>\",\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_in_import_statements() {\n+        check_assist_with_imports_locator_not_applicable(\n+            auto_import,\n+            TestImportsLocator::new,\n+            r\"\n+            use PubStruct<|>;\n+\n+            pub mod PubMod {\n+                pub struct PubStruct;\n+            }\",\n+        );\n+    }\n+}"}, {"sha": "65d51428bb19a29b69d261a401996ea07480ee6d", "filename": "crates/ra_assists/src/doc_tests.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f9506416c95bbf4fbd46c6dafb13bb30bb2feee/crates%2Fra_assists%2Fsrc%2Fdoc_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9506416c95bbf4fbd46c6dafb13bb30bb2feee/crates%2Fra_assists%2Fsrc%2Fdoc_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fdoc_tests.rs?ref=4f9506416c95bbf4fbd46c6dafb13bb30bb2feee", "patch": "@@ -11,6 +11,10 @@ use test_utils::{assert_eq_text, extract_range_or_offset};\n use crate::test_db::TestDB;\n \n fn check(assist_id: &str, before: &str, after: &str) {\n+    // FIXME we cannot get the imports search functionality here yet, but still need to generate a test and a doc for an assist\n+    if assist_id == \"auto_import\" {\n+        return;\n+    }\n     let (selection, before) = extract_range_or_offset(before);\n     let (db, file_id) = TestDB::with_single_file(&before);\n     let frange = FileRange { file_id, range: selection.into() };"}, {"sha": "ec4587ce7c7a935600009ac9d46e53bde53ffee3", "filename": "crates/ra_assists/src/doc_tests/generated.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4f9506416c95bbf4fbd46c6dafb13bb30bb2feee/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9506416c95bbf4fbd46c6dafb13bb30bb2feee/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs?ref=4f9506416c95bbf4fbd46c6dafb13bb30bb2feee", "patch": "@@ -214,6 +214,25 @@ fn main() {\n     )\n }\n \n+#[test]\n+fn doctest_auto_import() {\n+    check(\n+        \"auto_import\",\n+        r#####\"\n+fn main() {\n+    let map = HashMap<|>::new();\n+}\n+\"#####,\n+        r#####\"\n+use std::collections::HashMap;\n+\n+fn main() {\n+    let map = HashMap<|>::new();\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_change_visibility() {\n     check("}, {"sha": "625ebc4a2d306a7767b6850871cbc05a4bf5ca8a", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 164, "deletions": 13, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/4f9506416c95bbf4fbd46c6dafb13bb30bb2feee/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9506416c95bbf4fbd46c6dafb13bb30bb2feee/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=4f9506416c95bbf4fbd46c6dafb13bb30bb2feee", "patch": "@@ -14,7 +14,7 @@ mod test_db;\n pub mod ast_transform;\n \n use either::Either;\n-use hir::db::HirDatabase;\n+use hir::{db::HirDatabase, ModuleDef};\n use ra_db::FileRange;\n use ra_syntax::{TextRange, TextUnit};\n use ra_text_edit::TextEdit;\n@@ -77,6 +77,51 @@ where\n     })\n }\n \n+/// A functionality for locating imports for the given name.\n+///\n+/// Currently has to be a trait with the real implementation provided by the ra_ide_api crate,\n+/// due to the search functionality located there.\n+/// Later, this trait should be removed completely and the search functionality moved to a separate crate,\n+/// accessible from the ra_assists crate.\n+pub trait ImportsLocator {\n+    /// Finds all imports for the given name and the module that contains this name.\n+    fn find_imports(&mut self, name_to_import: &str) -> Vec<ModuleDef>;\n+}\n+\n+/// Return all the assists applicable at the given position\n+/// and additional assists that need the imports locator functionality to work.\n+///\n+/// Assists are returned in the \"resolved\" state, that is with edit fully\n+/// computed.\n+pub fn assists_with_imports_locator<H, F>(\n+    db: &H,\n+    range: FileRange,\n+    mut imports_locator: F,\n+) -> Vec<ResolvedAssist>\n+where\n+    H: HirDatabase + 'static,\n+    F: ImportsLocator,\n+{\n+    AssistCtx::with_ctx(db, range, true, |ctx| {\n+        let mut assists = assists::all()\n+            .iter()\n+            .map(|f| f(ctx.clone()))\n+            .chain(\n+                assists::all_with_imports_locator()\n+                    .iter()\n+                    .map(|f| f(ctx.clone(), &mut imports_locator)),\n+            )\n+            .filter_map(std::convert::identity)\n+            .map(|a| match a {\n+                Assist::Resolved { assist } => assist,\n+                Assist::Unresolved { .. } => unreachable!(),\n+            })\n+            .collect();\n+        sort_assists(&mut assists);\n+        assists\n+    })\n+}\n+\n /// Return all the assists applicable at the given position.\n ///\n /// Assists are returned in the \"resolved\" state, that is with edit fully\n@@ -85,8 +130,6 @@ pub fn assists<H>(db: &H, range: FileRange) -> Vec<ResolvedAssist>\n where\n     H: HirDatabase + 'static,\n {\n-    use std::cmp::Ordering;\n-\n     AssistCtx::with_ctx(db, range, true, |ctx| {\n         let mut a = assists::all()\n             .iter()\n@@ -95,19 +138,24 @@ where\n                 Assist::Resolved { assist } => assist,\n                 Assist::Unresolved { .. } => unreachable!(),\n             })\n-            .collect::<Vec<_>>();\n-        a.sort_by(|a, b| match (a.get_first_action().target, b.get_first_action().target) {\n-            (Some(a), Some(b)) => a.len().cmp(&b.len()),\n-            (Some(_), None) => Ordering::Less,\n-            (None, Some(_)) => Ordering::Greater,\n-            (None, None) => Ordering::Equal,\n-        });\n+            .collect();\n+        sort_assists(&mut a);\n         a\n     })\n }\n \n+fn sort_assists(assists: &mut Vec<ResolvedAssist>) {\n+    use std::cmp::Ordering;\n+    assists.sort_by(|a, b| match (a.get_first_action().target, b.get_first_action().target) {\n+        (Some(a), Some(b)) => a.len().cmp(&b.len()),\n+        (Some(_), None) => Ordering::Less,\n+        (None, Some(_)) => Ordering::Greater,\n+        (None, None) => Ordering::Equal,\n+    });\n+}\n+\n mod assists {\n-    use crate::{Assist, AssistCtx};\n+    use crate::{Assist, AssistCtx, ImportsLocator};\n     use hir::db::HirDatabase;\n \n     mod add_derive;\n@@ -116,6 +164,7 @@ mod assists {\n     mod add_custom_impl;\n     mod add_new;\n     mod apply_demorgan;\n+    mod auto_import;\n     mod invert_if;\n     mod flip_comma;\n     mod flip_binexpr;\n@@ -168,15 +217,69 @@ mod assists {\n             early_return::convert_to_guarded_return,\n         ]\n     }\n+\n+    pub(crate) fn all_with_imports_locator<'a, DB: HirDatabase, F: ImportsLocator>(\n+    ) -> &'a [fn(AssistCtx<DB>, &mut F) -> Option<Assist>] {\n+        &[auto_import::auto_import]\n+    }\n }\n \n #[cfg(test)]\n mod helpers {\n-    use ra_db::{fixture::WithFixture, FileRange};\n+    use hir::db::DefDatabase;\n+    use ra_db::{fixture::WithFixture, FileId, FileRange};\n     use ra_syntax::TextRange;\n     use test_utils::{add_cursor, assert_eq_text, extract_offset, extract_range};\n \n-    use crate::{test_db::TestDB, Assist, AssistCtx};\n+    use crate::{test_db::TestDB, Assist, AssistCtx, ImportsLocator};\n+    use std::sync::Arc;\n+\n+    // FIXME remove the `ModuleDefId` reexport from `ra_hir` when this gets removed.\n+    pub(crate) struct TestImportsLocator {\n+        db: Arc<TestDB>,\n+        test_file_id: FileId,\n+    }\n+\n+    impl TestImportsLocator {\n+        pub(crate) fn new(db: Arc<TestDB>, test_file_id: FileId) -> Self {\n+            TestImportsLocator { db, test_file_id }\n+        }\n+    }\n+\n+    impl ImportsLocator for TestImportsLocator {\n+        fn find_imports(&mut self, name_to_import: &str) -> Vec<hir::ModuleDef> {\n+            let crate_def_map = self.db.crate_def_map(self.db.test_crate());\n+            let mut findings = Vec::new();\n+\n+            let mut module_ids_to_process =\n+                crate_def_map.modules_for_file(self.test_file_id).collect::<Vec<_>>();\n+\n+            while !module_ids_to_process.is_empty() {\n+                let mut more_ids_to_process = Vec::new();\n+                for local_module_id in module_ids_to_process.drain(..) {\n+                    for (name, namespace_data) in\n+                        crate_def_map[local_module_id].scope.entries_without_primitives()\n+                    {\n+                        let found_a_match = &name.to_string() == name_to_import;\n+                        vec![namespace_data.types, namespace_data.values]\n+                            .into_iter()\n+                            .filter_map(std::convert::identity)\n+                            .for_each(|(module_def_id, _)| {\n+                                if found_a_match {\n+                                    findings.push(module_def_id.into());\n+                                }\n+                                if let hir::ModuleDefId::ModuleId(module_id) = module_def_id {\n+                                    more_ids_to_process.push(module_id.local_id);\n+                                }\n+                            });\n+                    }\n+                }\n+                module_ids_to_process = more_ids_to_process;\n+            }\n+\n+            findings\n+        }\n+    }\n \n     pub(crate) fn check_assist(\n         assist: fn(AssistCtx<TestDB>) -> Option<Assist>,\n@@ -206,6 +309,38 @@ mod helpers {\n         assert_eq_text!(after, &actual);\n     }\n \n+    pub(crate) fn check_assist_with_imports_locator<F: ImportsLocator>(\n+        assist: fn(AssistCtx<TestDB>, &mut F) -> Option<Assist>,\n+        imports_locator_provider: fn(db: Arc<TestDB>, file_id: FileId) -> F,\n+        before: &str,\n+        after: &str,\n+    ) {\n+        let (before_cursor_pos, before) = extract_offset(before);\n+        let (db, file_id) = TestDB::with_single_file(&before);\n+        let db = Arc::new(db);\n+        let mut imports_locator = imports_locator_provider(Arc::clone(&db), file_id);\n+        let frange =\n+            FileRange { file_id, range: TextRange::offset_len(before_cursor_pos, 0.into()) };\n+        let assist =\n+            AssistCtx::with_ctx(db.as_ref(), frange, true, |ctx| assist(ctx, &mut imports_locator))\n+                .expect(\"code action is not applicable\");\n+        let action = match assist {\n+            Assist::Unresolved { .. } => unreachable!(),\n+            Assist::Resolved { assist } => assist.get_first_action(),\n+        };\n+\n+        let actual = action.edit.apply(&before);\n+        let actual_cursor_pos = match action.cursor_position {\n+            None => action\n+                .edit\n+                .apply_to_offset(before_cursor_pos)\n+                .expect(\"cursor position is affected by the edit\"),\n+            Some(off) => off,\n+        };\n+        let actual = add_cursor(&actual, actual_cursor_pos);\n+        assert_eq_text!(after, &actual);\n+    }\n+\n     pub(crate) fn check_assist_range(\n         assist: fn(AssistCtx<TestDB>) -> Option<Assist>,\n         before: &str,\n@@ -279,6 +414,22 @@ mod helpers {\n         assert!(assist.is_none());\n     }\n \n+    pub(crate) fn check_assist_with_imports_locator_not_applicable<F: ImportsLocator>(\n+        assist: fn(AssistCtx<TestDB>, &mut F) -> Option<Assist>,\n+        imports_locator_provider: fn(db: Arc<TestDB>, file_id: FileId) -> F,\n+        before: &str,\n+    ) {\n+        let (before_cursor_pos, before) = extract_offset(before);\n+        let (db, file_id) = TestDB::with_single_file(&before);\n+        let db = Arc::new(db);\n+        let mut imports_locator = imports_locator_provider(Arc::clone(&db), file_id);\n+        let frange =\n+            FileRange { file_id, range: TextRange::offset_len(before_cursor_pos, 0.into()) };\n+        let assist =\n+            AssistCtx::with_ctx(db.as_ref(), frange, true, |ctx| assist(ctx, &mut imports_locator));\n+        assert!(assist.is_none());\n+    }\n+\n     pub(crate) fn check_assist_range_not_applicable(\n         assist: fn(AssistCtx<TestDB>) -> Option<Assist>,\n         before: &str,"}, {"sha": "9e2673d13357504221da9edd40f0088d9dea0068", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f9506416c95bbf4fbd46c6dafb13bb30bb2feee/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9506416c95bbf4fbd46c6dafb13bb30bb2feee/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=4f9506416c95bbf4fbd46c6dafb13bb30bb2feee", "patch": "@@ -56,6 +56,7 @@ pub use hir_def::{\n     nameres::ModuleSource,\n     path::{ModPath, Path, PathKind},\n     type_ref::Mutability,\n+    ModuleDefId, // FIXME this is exposed and should be used for implementing the `TestImportsLocator` in `ra_assists` only, should be removed later along with the trait and the implementation.\n };\n pub use hir_expand::{\n     name::Name, HirFileId, InFile, MacroCallId, MacroCallLoc, MacroDefId, MacroFile, Origin,"}, {"sha": "c43c45c654a8c54f1300c1794ca1e01afa1947a2", "filename": "crates/ra_ide/src/assists.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4f9506416c95bbf4fbd46c6dafb13bb30bb2feee/crates%2Fra_ide%2Fsrc%2Fassists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9506416c95bbf4fbd46c6dafb13bb30bb2feee/crates%2Fra_ide%2Fsrc%2Fassists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fassists.rs?ref=4f9506416c95bbf4fbd46c6dafb13bb30bb2feee", "patch": "@@ -2,8 +2,9 @@\n \n use ra_db::{FilePosition, FileRange};\n \n-use crate::{db::RootDatabase, FileId, SourceChange, SourceFileEdit};\n-\n+use crate::{\n+    db::RootDatabase, imports_locator::ImportsLocatorIde, FileId, SourceChange, SourceFileEdit,\n+};\n use either::Either;\n pub use ra_assists::AssistId;\n use ra_assists::{AssistAction, AssistLabel};\n@@ -16,7 +17,7 @@ pub struct Assist {\n }\n \n pub(crate) fn assists(db: &RootDatabase, frange: FileRange) -> Vec<Assist> {\n-    ra_assists::assists(db, frange)\n+    ra_assists::assists_with_imports_locator(db, frange, ImportsLocatorIde::new(db))\n         .into_iter()\n         .map(|assist| {\n             let file_id = frange.file_id;"}, {"sha": "48b014c7d0798f489db1018841cece375680512f", "filename": "crates/ra_ide/src/imports_locator.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/4f9506416c95bbf4fbd46c6dafb13bb30bb2feee/crates%2Fra_ide%2Fsrc%2Fimports_locator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9506416c95bbf4fbd46c6dafb13bb30bb2feee/crates%2Fra_ide%2Fsrc%2Fimports_locator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fimports_locator.rs?ref=4f9506416c95bbf4fbd46c6dafb13bb30bb2feee", "patch": "@@ -0,0 +1,76 @@\n+//! This module contains an import search funcionality that is provided to the ra_assists module.\n+//! Later, this should be moved away to a separate crate that is accessible from the ra_assists module.\n+\n+use crate::{\n+    db::RootDatabase,\n+    references::{classify_name, NameDefinition, NameKind},\n+    symbol_index::{self, FileSymbol},\n+    Query,\n+};\n+use hir::{db::HirDatabase, ModuleDef, SourceBinder};\n+use ra_assists::ImportsLocator;\n+use ra_prof::profile;\n+use ra_syntax::{ast, AstNode, SyntaxKind::NAME};\n+\n+pub(crate) struct ImportsLocatorIde<'a> {\n+    source_binder: SourceBinder<'a, RootDatabase>,\n+}\n+\n+impl<'a> ImportsLocatorIde<'a> {\n+    pub(crate) fn new(db: &'a RootDatabase) -> Self {\n+        Self { source_binder: SourceBinder::new(db) }\n+    }\n+\n+    fn get_name_definition(\n+        &mut self,\n+        db: &impl HirDatabase,\n+        import_candidate: &FileSymbol,\n+    ) -> Option<NameDefinition> {\n+        let _p = profile(\"get_name_definition\");\n+        let file_id = import_candidate.file_id.into();\n+        let candidate_node = import_candidate.ptr.to_node(&db.parse_or_expand(file_id)?);\n+        let candidate_name_node = if candidate_node.kind() != NAME {\n+            candidate_node.children().find(|it| it.kind() == NAME)?\n+        } else {\n+            candidate_node\n+        };\n+        classify_name(\n+            &mut self.source_binder,\n+            hir::InFile { file_id, value: &ast::Name::cast(candidate_name_node)? },\n+        )\n+    }\n+}\n+\n+impl ImportsLocator for ImportsLocatorIde<'_> {\n+    fn find_imports(&mut self, name_to_import: &str) -> Vec<ModuleDef> {\n+        let _p = profile(\"search_for_imports\");\n+        let db = self.source_binder.db;\n+\n+        let project_results = {\n+            let mut query = Query::new(name_to_import.to_string());\n+            query.exact();\n+            query.limit(40);\n+            symbol_index::world_symbols(db, query)\n+        };\n+        let lib_results = {\n+            let mut query = Query::new(name_to_import.to_string());\n+            query.libs();\n+            query.exact();\n+            query.limit(40);\n+            symbol_index::world_symbols(db, query)\n+        };\n+\n+        project_results\n+            .into_iter()\n+            .chain(lib_results.into_iter())\n+            .filter_map(|import_candidate| self.get_name_definition(db, &import_candidate))\n+            .filter_map(|name_definition_to_import| {\n+                if let NameKind::Def(module_def) = name_definition_to_import.kind {\n+                    Some(module_def)\n+                } else {\n+                    None\n+                }\n+            })\n+            .collect()\n+    }\n+}"}, {"sha": "03ad6b2c13c89a3f4ec59beb636c65fd1cb729bb", "filename": "crates/ra_ide/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f9506416c95bbf4fbd46c6dafb13bb30bb2feee/crates%2Fra_ide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f9506416c95bbf4fbd46c6dafb13bb30bb2feee/crates%2Fra_ide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Flib.rs?ref=4f9506416c95bbf4fbd46c6dafb13bb30bb2feee", "patch": "@@ -30,6 +30,7 @@ mod syntax_highlighting;\n mod parent_module;\n mod references;\n mod impls;\n+mod imports_locator;\n mod assists;\n mod diagnostics;\n mod syntax_tree;"}, {"sha": "c36c5df6a23c1e7adb8c89362e97c391b69c3623", "filename": "docs/user/assists.md", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4f9506416c95bbf4fbd46c6dafb13bb30bb2feee/docs%2Fuser%2Fassists.md", "raw_url": "https://github.com/rust-lang/rust/raw/4f9506416c95bbf4fbd46c6dafb13bb30bb2feee/docs%2Fuser%2Fassists.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fassists.md?ref=4f9506416c95bbf4fbd46c6dafb13bb30bb2feee", "patch": "@@ -209,6 +209,24 @@ fn main() {\n }\n ```\n \n+## `auto_import`\n+\n+If the name is unresolved, provides all possible imports for it.\n+\n+```rust\n+// BEFORE\n+fn main() {\n+    let map = HashMap\u2503::new();\n+}\n+\n+// AFTER\n+use std::collections::HashMap;\n+\n+fn main() {\n+    let map = HashMap\u2503::new();\n+}\n+```\n+\n ## `change_visibility`\n \n Adds or changes existing visibility specifier."}]}