{"sha": "cd2edbfd098b6c9351f8c168c8f36c190ce5e675", "node_id": "C_kwDOAAsO6NoAKGNkMmVkYmZkMDk4YjZjOTM1MWY4YzE2OGM4ZjM2YzE5MGNlNWU2NzU", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-08-05T21:47:28Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-08-09T17:59:34Z"}, "message": "ensure atomics happen on mutable allocations, and fix futex test", "tree": {"sha": "e454b468b8d42da2a5d4037c53ecb2e46d569ca5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e454b468b8d42da2a5d4037c53ecb2e46d569ca5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd2edbfd098b6c9351f8c168c8f36c190ce5e675", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd2edbfd098b6c9351f8c168c8f36c190ce5e675", "html_url": "https://github.com/rust-lang/rust/commit/cd2edbfd098b6c9351f8c168c8f36c190ce5e675", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd2edbfd098b6c9351f8c168c8f36c190ce5e675/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d630671a33942988391a6a5b52ae0346057e2cf7", "url": "https://api.github.com/repos/rust-lang/rust/commits/d630671a33942988391a6a5b52ae0346057e2cf7", "html_url": "https://github.com/rust-lang/rust/commit/d630671a33942988391a6a5b52ae0346057e2cf7"}], "stats": {"total": 72, "additions": 69, "deletions": 3}, "files": [{"sha": "51105ec98df01429586ab88962533725baac7d46", "filename": "src/concurrency/data_race.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cd2edbfd098b6c9351f8c168c8f36c190ce5e675/src%2Fconcurrency%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd2edbfd098b6c9351f8c168c8f36c190ce5e675/src%2Fconcurrency%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fdata_race.rs?ref=cd2edbfd098b6c9351f8c168c8f36c190ce5e675", "patch": "@@ -46,6 +46,7 @@ use std::{\n     mem,\n };\n \n+use rustc_ast::Mutability;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::{mir, ty::layout::TyAndLayout};\n@@ -476,6 +477,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n             align,\n             CheckInAllocMsg::MemoryAccessTest,\n         )?;\n+        // Ensure the allocation is mutable. Even failing (read-only) compare_exchange need mutable\n+        // memory on many targets (i.e., they segfault if taht memory is mapped read-only), and\n+        // atomic loads can be implemented via compare_exchange on some targets. See\n+        // <https://github.com/rust-lang/miri/issues/2463>.\n+        // We avoid `get_ptr_alloc` since we do *not* want to run the access hooks -- the actual\n+        // access will happen later.\n+        let (alloc_id, _offset, _prov) =\n+            this.ptr_try_get_alloc_id(place.ptr).expect(\"there are no zero-sized atomic accesses\");\n+        if this.get_alloc_mutability(alloc_id)? == Mutability::Not {\n+            throw_ub_format!(\"atomic operations cannot be performed on read-only memory\");\n+        }\n         Ok(())\n     }\n "}, {"sha": "cb6aeea665d3905b3c1d75e12a24f3d8ff94eddd", "filename": "tests/fail/concurrency/read_only_atomic_cmpxchg.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cd2edbfd098b6c9351f8c168c8f36c190ce5e675/tests%2Ffail%2Fconcurrency%2Fread_only_atomic_cmpxchg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd2edbfd098b6c9351f8c168c8f36c190ce5e675/tests%2Ffail%2Fconcurrency%2Fread_only_atomic_cmpxchg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Fread_only_atomic_cmpxchg.rs?ref=cd2edbfd098b6c9351f8c168c8f36c190ce5e675", "patch": "@@ -0,0 +1,11 @@\n+// Should not rely on the aliasing model for its failure.\n+//@compile-flags: -Zmiri-disable-stacked-borrows\n+\n+use std::sync::atomic::{AtomicI32, Ordering};\n+\n+fn main() {\n+    static X: i32 = 0;\n+    let x = &X as *const i32 as *const AtomicI32;\n+    let x = unsafe { &*x };\n+    x.compare_exchange(1, 2, Ordering::Relaxed, Ordering::Relaxed).unwrap_err(); //~ERROR: atomic operations cannot be performed on read-only memory\n+}"}, {"sha": "2753c492266b0780fc06961df3299caddc57ce7d", "filename": "tests/fail/concurrency/read_only_atomic_cmpxchg.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cd2edbfd098b6c9351f8c168c8f36c190ce5e675/tests%2Ffail%2Fconcurrency%2Fread_only_atomic_cmpxchg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cd2edbfd098b6c9351f8c168c8f36c190ce5e675/tests%2Ffail%2Fconcurrency%2Fread_only_atomic_cmpxchg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Fread_only_atomic_cmpxchg.stderr?ref=cd2edbfd098b6c9351f8c168c8f36c190ce5e675", "patch": "@@ -0,0 +1,15 @@\n+error: Undefined Behavior: atomic operations cannot be performed on read-only memory\n+  --> $DIR/read_only_atomic_cmpxchg.rs:LL:CC\n+   |\n+LL |     x.compare_exchange(1, 2, Ordering::Relaxed, Ordering::Relaxed).unwrap_err();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ atomic operations cannot be performed on read-only memory\n+   |\n+   = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n+   = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n+   = note: backtrace:\n+   = note: inside `main` at $DIR/read_only_atomic_cmpxchg.rs:LL:CC\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "6e92453e3c195e969713158c2bd5718eaefd288c", "filename": "tests/fail/concurrency/read_only_atomic_load.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cd2edbfd098b6c9351f8c168c8f36c190ce5e675/tests%2Ffail%2Fconcurrency%2Fread_only_atomic_load.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd2edbfd098b6c9351f8c168c8f36c190ce5e675/tests%2Ffail%2Fconcurrency%2Fread_only_atomic_load.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Fread_only_atomic_load.rs?ref=cd2edbfd098b6c9351f8c168c8f36c190ce5e675", "patch": "@@ -0,0 +1,13 @@\n+// Should not rely on the aliasing model for its failure.\n+//@compile-flags: -Zmiri-disable-stacked-borrows\n+\n+use std::sync::atomic::{AtomicI32, Ordering};\n+\n+fn main() {\n+    static X: i32 = 0;\n+    let x = &X as *const i32 as *const AtomicI32;\n+    let x = unsafe { &*x };\n+    // Some targets can implement atomic loads via compare_exchange, so we cannot allow them on\n+    // read-only memory.\n+    x.load(Ordering::Relaxed); //~ERROR: atomic operations cannot be performed on read-only memory\n+}"}, {"sha": "588081afc62c06803d7ec636bd2fcf5b8e4557fc", "filename": "tests/fail/concurrency/read_only_atomic_load.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cd2edbfd098b6c9351f8c168c8f36c190ce5e675/tests%2Ffail%2Fconcurrency%2Fread_only_atomic_load.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cd2edbfd098b6c9351f8c168c8f36c190ce5e675/tests%2Ffail%2Fconcurrency%2Fread_only_atomic_load.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Fread_only_atomic_load.stderr?ref=cd2edbfd098b6c9351f8c168c8f36c190ce5e675", "patch": "@@ -0,0 +1,15 @@\n+error: Undefined Behavior: atomic operations cannot be performed on read-only memory\n+  --> $DIR/read_only_atomic_load.rs:LL:CC\n+   |\n+LL |     x.load(Ordering::Relaxed);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ atomic operations cannot be performed on read-only memory\n+   |\n+   = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n+   = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n+   = note: backtrace:\n+   = note: inside `main` at $DIR/read_only_atomic_load.rs:LL:CC\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "2c99bfa1000cd0dd75e9d721728ac13d2c3d0100", "filename": "tests/pass/concurrency/linux-futex.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd2edbfd098b6c9351f8c168c8f36c190ce5e675/tests%2Fpass%2Fconcurrency%2Flinux-futex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd2edbfd098b6c9351f8c168c8f36c190ce5e675/tests%2Fpass%2Fconcurrency%2Flinux-futex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Flinux-futex.rs?ref=cd2edbfd098b6c9351f8c168c8f36c190ce5e675", "patch": "@@ -130,7 +130,7 @@ fn wait_absolute_timeout() {\n fn wait_wake() {\n     let start = Instant::now();\n \n-    static FUTEX: i32 = 0;\n+    static mut FUTEX: i32 = 0;\n \n     let t = thread::spawn(move || {\n         thread::sleep(Duration::from_millis(200));\n@@ -167,7 +167,7 @@ fn wait_wake() {\n fn wait_wake_bitset() {\n     let start = Instant::now();\n \n-    static FUTEX: i32 = 0;\n+    static mut FUTEX: i32 = 0;\n \n     let t = thread::spawn(move || {\n         thread::sleep(Duration::from_millis(200));\n@@ -277,8 +277,8 @@ fn concurrent_wait_wake() {\n \n     // Make sure we got the interesting case (of having woken a thread) at least once, but not *each* time.\n     let woken = WOKEN.load(Ordering::Relaxed);\n-    assert!(woken > 0 && woken < rounds);\n     //eprintln!(\"waking happened {woken} times\");\n+    assert!(woken > 0 && woken < rounds);\n }\n \n fn main() {"}]}