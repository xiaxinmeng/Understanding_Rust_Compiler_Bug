{"sha": "bdd31b38aaf320acc9dad5fa012ba2834348c1f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkZDMxYjM4YWFmMzIwYWNjOWRhZDVmYTAxMmJhMjgzNDM0OGMxZjg=", "commit": {"author": {"name": "Kang Seonghoon", "email": "public+git@mearie.org", "date": "2015-02-26T16:12:22Z"}, "committer": {"name": "Kang Seonghoon", "email": "public+git@mearie.org", "date": "2015-02-26T16:12:22Z"}, "message": "std: Include line numbers in backtraces.\n\nFixes #20978 for supported platforms (i.e. non-Android POSIX).\n\nThis uses `backtrace_pcinfo` to inspect the DWARF debug info\nand list the file and line pairs for given stack frame.\nSuch pair is not unique due to the presence of inlined functions\nand the updated routine correctly handles this case.\nThe code is modelled after libbacktrace's `backtrace_full` routine.\n\nThere is one known issue with this approach. Macros, when invoked,\ntake over the current frame and shadows the file and line pair\nwhich has invoked a macro. In particular, this makes many panicking\nmacros a bit harder to inspect. This really is a debuginfo problem,\nand the backtrace routine should print them correctly with\na correct debuginfo.", "tree": {"sha": "66827b883c569f0d3077fc9ed21b6ae6204464d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66827b883c569f0d3077fc9ed21b6ae6204464d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bdd31b38aaf320acc9dad5fa012ba2834348c1f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bdd31b38aaf320acc9dad5fa012ba2834348c1f8", "html_url": "https://github.com/rust-lang/rust/commit/bdd31b38aaf320acc9dad5fa012ba2834348c1f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bdd31b38aaf320acc9dad5fa012ba2834348c1f8/comments", "author": {"login": "lifthrasiir", "id": 323836, "node_id": "MDQ6VXNlcjMyMzgzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/323836?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lifthrasiir", "html_url": "https://github.com/lifthrasiir", "followers_url": "https://api.github.com/users/lifthrasiir/followers", "following_url": "https://api.github.com/users/lifthrasiir/following{/other_user}", "gists_url": "https://api.github.com/users/lifthrasiir/gists{/gist_id}", "starred_url": "https://api.github.com/users/lifthrasiir/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lifthrasiir/subscriptions", "organizations_url": "https://api.github.com/users/lifthrasiir/orgs", "repos_url": "https://api.github.com/users/lifthrasiir/repos", "events_url": "https://api.github.com/users/lifthrasiir/events{/privacy}", "received_events_url": "https://api.github.com/users/lifthrasiir/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lifthrasiir", "id": 323836, "node_id": "MDQ6VXNlcjMyMzgzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/323836?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lifthrasiir", "html_url": "https://github.com/lifthrasiir", "followers_url": "https://api.github.com/users/lifthrasiir/followers", "following_url": "https://api.github.com/users/lifthrasiir/following{/other_user}", "gists_url": "https://api.github.com/users/lifthrasiir/gists{/gist_id}", "starred_url": "https://api.github.com/users/lifthrasiir/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lifthrasiir/subscriptions", "organizations_url": "https://api.github.com/users/lifthrasiir/orgs", "repos_url": "https://api.github.com/users/lifthrasiir/repos", "events_url": "https://api.github.com/users/lifthrasiir/events{/privacy}", "received_events_url": "https://api.github.com/users/lifthrasiir/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "url": "https://api.github.com/repos/rust-lang/rust/commits/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "html_url": "https://github.com/rust-lang/rust/commit/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e"}], "stats": {"total": 278, "additions": 268, "deletions": 10}, "files": [{"sha": "8bc3ffd6ed1e07ad3bc01b593c04c70846757564", "filename": "src/libstd/sys/unix/backtrace.rs", "status": "modified", "additions": 106, "deletions": 10, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/bdd31b38aaf320acc9dad5fa012ba2834348c1f8/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdd31b38aaf320acc9dad5fa012ba2834348c1f8/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs?ref=bdd31b38aaf320acc9dad5fa012ba2834348c1f8", "patch": "@@ -127,7 +127,7 @@ pub fn write(w: &mut Writer) -> IoResult<()> {\n \n     // skipping the first one as it is write itself\n     let iter = (1..cnt).map(|i| {\n-        print(w, i as int, buf[i])\n+        print(w, i as int, buf[i], buf[i])\n     });\n     result::fold(iter, (), |_, _| ())\n }\n@@ -171,7 +171,16 @@ pub fn write(w: &mut Writer) -> IoResult<()> {\n     extern fn trace_fn(ctx: *mut uw::_Unwind_Context,\n                        arg: *mut libc::c_void) -> uw::_Unwind_Reason_Code {\n         let cx: &mut Context = unsafe { mem::transmute(arg) };\n-        let ip = unsafe { uw::_Unwind_GetIP(ctx) as *mut libc::c_void };\n+        let mut ip_before_insn = 0;\n+        let mut ip = unsafe {\n+            uw::_Unwind_GetIPInfo(ctx, &mut ip_before_insn) as *mut libc::c_void\n+        };\n+        if ip_before_insn == 0 {\n+            // this is a non-signaling frame, so `ip` refers to the address\n+            // after the calling instruction. account for that.\n+            ip = (ip as usize - 1) as *mut _;\n+        }\n+\n         // dladdr() on osx gets whiny when we use FindEnclosingFunction, and\n         // it appears to work fine without it, so we only use\n         // FindEnclosingFunction on non-osx platforms. In doing so, we get a\n@@ -182,7 +191,7 @@ pub fn write(w: &mut Writer) -> IoResult<()> {\n         // instructions after it. This means that the return instruction\n         // pointer points *outside* of the calling function, and by\n         // unwinding it we go back to the original function.\n-        let ip = if cfg!(target_os = \"macos\") || cfg!(target_os = \"ios\") {\n+        let symaddr = if cfg!(target_os = \"macos\") || cfg!(target_os = \"ios\") {\n             ip\n         } else {\n             unsafe { uw::_Unwind_FindEnclosingFunction(ip) }\n@@ -203,7 +212,7 @@ pub fn write(w: &mut Writer) -> IoResult<()> {\n         // Once we hit an error, stop trying to print more frames\n         if cx.last_error.is_some() { return uw::_URC_FAILURE }\n \n-        match print(cx.writer, cx.idx, ip) {\n+        match print(cx.writer, cx.idx, ip, symaddr) {\n             Ok(()) => {}\n             Err(e) => { cx.last_error = Some(e); }\n         }\n@@ -214,7 +223,8 @@ pub fn write(w: &mut Writer) -> IoResult<()> {\n }\n \n #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> {\n+fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void,\n+         symaddr: *mut libc::c_void) -> IoResult<()> {\n     use intrinsics;\n     #[repr(C)]\n     struct Dl_info {\n@@ -239,7 +249,8 @@ fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> {\n }\n \n #[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n-fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> {\n+fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void,\n+         symaddr: *mut libc::c_void) -> IoResult<()> {\n     use env;\n     use ptr;\n \n@@ -252,6 +263,12 @@ fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> {\n                       symname: *const libc::c_char,\n                       symval: libc::uintptr_t,\n                       symsize: libc::uintptr_t);\n+    type backtrace_full_callback =\n+        extern \"C\" fn(data: *mut libc::c_void,\n+                      pc: libc::uintptr_t,\n+                      filename: *const libc::c_char,\n+                      lineno: libc::c_int,\n+                      function: *const libc::c_char) -> libc::c_int;\n     type backtrace_error_callback =\n         extern \"C\" fn(data: *mut libc::c_void,\n                       msg: *const libc::c_char,\n@@ -272,12 +289,19 @@ fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> {\n                              cb: backtrace_syminfo_callback,\n                              error: backtrace_error_callback,\n                              data: *mut libc::c_void) -> libc::c_int;\n+        fn backtrace_pcinfo(state: *mut backtrace_state,\n+                            addr: libc::uintptr_t,\n+                            cb: backtrace_full_callback,\n+                            error: backtrace_error_callback,\n+                            data: *mut libc::c_void) -> libc::c_int;\n     }\n \n     ////////////////////////////////////////////////////////////////////////\n     // helper callbacks\n     ////////////////////////////////////////////////////////////////////////\n \n+    type FileLine = (*const libc::c_char, libc::c_int);\n+\n     extern fn error_cb(_data: *mut libc::c_void, _msg: *const libc::c_char,\n                        _errnum: libc::c_int) {\n         // do nothing for now\n@@ -290,6 +314,25 @@ fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> {\n         let slot = data as *mut *const libc::c_char;\n         unsafe { *slot = symname; }\n     }\n+    extern fn pcinfo_cb(data: *mut libc::c_void,\n+                        _pc: libc::uintptr_t,\n+                        filename: *const libc::c_char,\n+                        lineno: libc::c_int,\n+                        _function: *const libc::c_char) -> libc::c_int {\n+        if !filename.is_null() {\n+            let slot = data as *mut &mut [FileLine];\n+            let buffer = unsafe {ptr::read(slot)};\n+\n+            // if the buffer is not full, add file:line to the buffer\n+            // and adjust the buffer for next possible calls to pcinfo_cb.\n+            if !buffer.is_empty() {\n+                buffer[0] = (filename, lineno);\n+                unsafe { ptr::write(slot, &mut buffer[1..]); }\n+            }\n+        }\n+\n+        0\n+    }\n \n     // The libbacktrace API supports creating a state, but it does not\n     // support destroying a state. I personally take this to mean that a\n@@ -358,15 +401,42 @@ fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> {\n     let mut data = ptr::null();\n     let data_addr = &mut data as *mut *const libc::c_char;\n     let ret = unsafe {\n-        backtrace_syminfo(state, addr as libc::uintptr_t,\n+        backtrace_syminfo(state, symaddr as libc::uintptr_t,\n                           syminfo_cb, error_cb,\n                           data_addr as *mut libc::c_void)\n     };\n     if ret == 0 || data.is_null() {\n-        output(w, idx, addr, None)\n+        try!(output(w, idx, addr, None));\n     } else {\n-        output(w, idx, addr, Some(unsafe { CStr::from_ptr(data).to_bytes() }))\n+        try!(output(w, idx, addr, Some(unsafe { CStr::from_ptr(data).to_bytes() })));\n+    }\n+\n+    // pcinfo may return an arbitrary number of file:line pairs,\n+    // in the order of stack trace (i.e. inlined calls first).\n+    // in order to avoid allocation, we stack-allocate a fixed size of entries.\n+    const FILELINE_SIZE: usize = 32;\n+    let mut fileline_buf = [(ptr::null(), -1); FILELINE_SIZE];\n+    let ret;\n+    let fileline_count;\n+    {\n+        let mut fileline_win: &mut [FileLine] = &mut fileline_buf;\n+        let fileline_addr = &mut fileline_win as *mut &mut [FileLine];\n+        ret = unsafe {\n+            backtrace_pcinfo(state, addr as libc::uintptr_t,\n+                             pcinfo_cb, error_cb,\n+                             fileline_addr as *mut libc::c_void)\n+        };\n+        fileline_count = FILELINE_SIZE - fileline_win.len();\n+    }\n+    if ret == 0 {\n+        for (i, &(file, line)) in fileline_buf[..fileline_count].iter().enumerate() {\n+            if file.is_null() { continue; } // just to be sure\n+            let file = unsafe { CStr::from_ptr(file).to_bytes() };\n+            try!(output_fileline(w, file, line, i == FILELINE_SIZE - 1));\n+        }\n     }\n+\n+    Ok(())\n }\n \n // Finally, after all that work above, we can emit a symbol.\n@@ -380,6 +450,17 @@ fn output(w: &mut Writer, idx: int, addr: *mut libc::c_void,\n     w.write_all(&['\\n' as u8])\n }\n \n+fn output_fileline(w: &mut Writer, file: &[u8], line: libc::c_int,\n+                   more: bool) -> IoResult<()> {\n+    let file = str::from_utf8(file).ok().unwrap_or(\"<unknown>\");\n+    // prior line: \"  ##: {:2$} - func\"\n+    try!(write!(w, \"      {:3$}at {}:{}\", \"\", file, line, HEX_WIDTH));\n+    if more {\n+        try!(write!(w, \" <... and possibly more>\"));\n+    }\n+    w.write_all(&['\\n' as u8])\n+}\n+\n /// Unwind library interface used for backtraces\n ///\n /// Note that dead code is allowed as here are just bindings\n@@ -420,9 +501,12 @@ mod uw {\n                                  trace_argument: *mut libc::c_void)\n                     -> _Unwind_Reason_Code;\n \n+        // available since GCC 4.2.0, should be fine for our purpose\n         #[cfg(all(not(all(target_os = \"android\", target_arch = \"arm\")),\n                   not(all(target_os = \"linux\", target_arch = \"arm\"))))]\n-        pub fn _Unwind_GetIP(ctx: *mut _Unwind_Context) -> libc::uintptr_t;\n+        pub fn _Unwind_GetIPInfo(ctx: *mut _Unwind_Context,\n+                                 ip_before_insn: *mut libc::c_int)\n+                    -> libc::uintptr_t;\n \n         #[cfg(all(not(target_os = \"android\"),\n                   not(all(target_os = \"linux\", target_arch = \"arm\"))))]\n@@ -478,6 +562,18 @@ mod uw {\n         (val & !1) as libc::uintptr_t\n     }\n \n+    // This function doesn't exist on Android or ARM/Linux, so make it same\n+    // to _Unwind_GetIP\n+    #[cfg(any(target_os = \"android\",\n+              all(target_os = \"linux\", target_arch = \"arm\")))]\n+    pub unsafe fn _Unwind_GetIPInfo(ctx: *mut _Unwind_Context,\n+                                    ip_before_insn: *mut libc::c_int)\n+        -> libc::uintptr_t\n+    {\n+        *ip_before_insn = 0;\n+        _Unwind_GetIP(ctx)\n+    }\n+\n     // This function also doesn't exist on Android or ARM/Linux, so make it\n     // a no-op\n     #[cfg(any(target_os = \"android\","}, {"sha": "074ee97c37a1ef4a11f4b7ffe4af19188b1f4d30", "filename": "src/test/run-pass/backtrace-debuginfo-aux.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bdd31b38aaf320acc9dad5fa012ba2834348c1f8/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo-aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdd31b38aaf320acc9dad5fa012ba2834348c1f8/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo-aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo-aux.rs?ref=bdd31b38aaf320acc9dad5fa012ba2834348c1f8", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-test: not a test, used by backtrace-debuginfo.rs to test file!()\n+\n+#[inline(never)]\n+pub fn callback<F>(f: F) where F: FnOnce((&'static str, u32)) {\n+    f((file!(), line!()))\n+}\n+\n+#[inline(always)]\n+pub fn callback_inlined<F>(f: F) where F: FnOnce((&'static str, u32)) {\n+    f((file!(), line!()))\n+}\n+"}, {"sha": "618a6b6e30925742dbe6b345fafa935c9709d868", "filename": "src/test/run-pass/backtrace-debuginfo.rs", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/bdd31b38aaf320acc9dad5fa012ba2834348c1f8/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdd31b38aaf320acc9dad5fa012ba2834348c1f8/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo.rs?ref=bdd31b38aaf320acc9dad5fa012ba2834348c1f8", "patch": "@@ -0,0 +1,140 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-g\n+\n+#![feature(asm)]\n+\n+use std::old_io::stderr;\n+use std::env;\n+\n+#[path = \"backtrace-debuginfo-aux.rs\"] mod aux;\n+\n+macro_rules! pos {\n+    () => ((file!(), line!()))\n+}\n+\n+// we can't use a function as it will alter the backtrace\n+macro_rules! check {\n+    ($counter:expr; $($pos:expr),*) => ({\n+        if *$counter == 0 {\n+            // XXX we cannot include the current position because\n+            // the macro span takes over the last frame's file/line.\n+            dump_filelines(&[$($pos),*]);\n+            panic!();\n+        } else {\n+            *$counter -= 1;\n+        }\n+    })\n+}\n+\n+type Pos = (&'static str, u32);\n+\n+// this goes to stdout and each line has to be occurred\n+// in the following backtrace to stderr with a correct order.\n+fn dump_filelines(filelines: &[Pos]) {\n+    for &(file, line) in filelines.iter().rev() {\n+        // extract a basename\n+        let basename = file.split(&['/', '\\\\'][..]).last().unwrap();\n+        println!(\"{}:{}\", basename, line);\n+    }\n+}\n+\n+#[inline(never)]\n+fn inner(counter: &mut u32, main_pos: Pos, outer_pos: Pos) {\n+    check!(counter; main_pos, outer_pos);\n+    check!(counter; main_pos, outer_pos);\n+    let inner_pos = pos!(); aux::callback(|aux_pos| {\n+        check!(counter; main_pos, outer_pos, inner_pos, aux_pos);\n+    });\n+    let inner_pos = pos!(); aux::callback_inlined(|aux_pos| {\n+        check!(counter; main_pos, outer_pos, inner_pos, aux_pos);\n+    });\n+}\n+\n+#[inline(always)]\n+fn inner_inlined(counter: &mut u32, main_pos: Pos, outer_pos: Pos) {\n+    check!(counter; main_pos, outer_pos);\n+    check!(counter; main_pos, outer_pos);\n+\n+    #[inline(always)]\n+    fn inner_further_inlined(counter: &mut u32, main_pos: Pos, outer_pos: Pos, inner_pos: Pos) {\n+        check!(counter; main_pos, outer_pos, inner_pos);\n+    }\n+    inner_further_inlined(counter, main_pos, outer_pos, pos!());\n+\n+    let inner_pos = pos!(); aux::callback(|aux_pos| {\n+        check!(counter; main_pos, outer_pos, inner_pos, aux_pos);\n+    });\n+    let inner_pos = pos!(); aux::callback_inlined(|aux_pos| {\n+        check!(counter; main_pos, outer_pos, inner_pos, aux_pos);\n+    });\n+\n+    // this tests a distinction between two independent calls to the inlined function.\n+    // (un)fortunately, LLVM somehow merges two consecutive such calls into one node.\n+    inner_further_inlined(counter, main_pos, outer_pos, pos!());\n+}\n+\n+#[inline(never)]\n+fn outer(mut counter: u32, main_pos: Pos) {\n+    inner(&mut counter, main_pos, pos!());\n+    inner_inlined(&mut counter, main_pos, pos!());\n+}\n+\n+fn check_trace(output: &str, error: &str) {\n+    // reverse the position list so we can start with the last item (which was the first line)\n+    let mut remaining: Vec<&str> = output.lines().map(|s| s.trim()).rev().collect();\n+\n+    assert!(error.contains(\"stack backtrace\"), \"no backtrace in the error: {}\", error);\n+    for line in error.lines() {\n+        if !remaining.is_empty() && line.contains(remaining.last().unwrap()) {\n+            remaining.pop();\n+        }\n+    }\n+    assert!(remaining.is_empty(),\n+            \"trace does not match position list: {}\\n---\\n{}\", error, output);\n+}\n+\n+fn run_test(me: &str) {\n+    use std::str;\n+    use std::old_io::process::Command;\n+\n+    let mut template = Command::new(me);\n+    template.env(\"RUST_BACKTRACE\", \"1\");\n+\n+    let mut i = 0;\n+    loop {\n+        let p = template.clone().arg(i.to_string()).spawn().unwrap();\n+        let out = p.wait_with_output().unwrap();\n+        let output = str::from_utf8(&out.output).unwrap();\n+        let error = str::from_utf8(&out.error).unwrap();\n+        if out.status.success() {\n+            assert!(output.contains(\"done.\"), \"bad output for successful run: {}\", output);\n+            break;\n+        } else {\n+            check_trace(output, error);\n+        }\n+        i += 1;\n+    }\n+}\n+\n+#[inline(never)]\n+fn main() {\n+    let args: Vec<String> = env::args().collect();\n+    if args.len() >= 2 {\n+        let case = args[1].parse().unwrap();\n+        writeln!(&mut stderr(), \"test case {}\", case).unwrap();\n+        outer(case, pos!());\n+        println!(\"done.\");\n+    } else {\n+        run_test(&args[0]);\n+    }\n+}\n+"}]}