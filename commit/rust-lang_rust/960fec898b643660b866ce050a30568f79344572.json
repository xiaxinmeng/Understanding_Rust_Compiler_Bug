{"sha": "960fec898b643660b866ce050a30568f79344572", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2MGZlYzg5OGI2NDM2NjBiODY2Y2UwNTBhMzA1NjhmNzkzNDQ1NzI=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-11-02T12:43:33Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-11-02T12:43:33Z"}, "message": "Force to use block for closure's body when there is only a single control expr", "tree": {"sha": "e08217b088bc4e6c6f26718f3634438c0f5e2dc0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e08217b088bc4e6c6f26718f3634438c0f5e2dc0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/960fec898b643660b866ce050a30568f79344572", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/960fec898b643660b866ce050a30568f79344572", "html_url": "https://github.com/rust-lang/rust/commit/960fec898b643660b866ce050a30568f79344572", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/960fec898b643660b866ce050a30568f79344572/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4f13dfdd6d2d644bacc38a3d6eb8c991e47c294", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4f13dfdd6d2d644bacc38a3d6eb8c991e47c294", "html_url": "https://github.com/rust-lang/rust/commit/e4f13dfdd6d2d644bacc38a3d6eb8c991e47c294"}], "stats": {"total": 52, "additions": 50, "deletions": 2}, "files": [{"sha": "eb1b13cc0a17ace9c3930190ce5c3bf0653d599f", "filename": "src/expr.rs", "status": "modified", "additions": 50, "deletions": 2, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/960fec898b643660b866ce050a30568f79344572/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/960fec898b643660b866ce050a30568f79344572/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=960fec898b643660b866ce050a30568f79344572", "patch": "@@ -641,8 +641,12 @@ fn rewrite_closure(\n         };\n         if no_return_type && !needs_block {\n             // block.stmts.len() == 1\n-            if let Some(expr) = stmt_expr(&block.stmts[0]) {\n-                if let Some(rw) = rewrite_closure_expr(expr, &prefix, context, body_shape) {\n+            if let Some(ref expr) = stmt_expr(&block.stmts[0]) {\n+                if let Some(rw) = if is_block_closure_forced(expr) {\n+                    rewrite_closure_with_block(context, shape, &prefix, expr)\n+                } else {\n+                    rewrite_closure_expr(expr, &prefix, context, body_shape)\n+                } {\n                     return Some(rw);\n                 }\n             }\n@@ -2247,7 +2251,34 @@ fn rewrite_last_closure(\n         if prefix.contains('\\n') {\n             return None;\n         }\n+        // If we are inside macro, we do not want to add or remove block from closure body.\n+        if context.inside_macro {\n+            return expr.rewrite(context, shape);\n+        }\n+\n         let body_shape = shape.offset_left(extra_offset)?;\n+\n+        // We force to use block for the body of the closure for certain kinds of expressions.\n+        if is_block_closure_forced(body) {\n+            return rewrite_closure_with_block(context, body_shape, &prefix, body).and_then(\n+                |body_str| {\n+                    // If the expression can fit in a single line, we need not force block closure.\n+                    if body_str.lines().count() <= 7 {\n+                        match rewrite_closure_expr(body, &prefix, context, shape) {\n+                            Some(ref single_line_body_str)\n+                                if !single_line_body_str.contains('\\n') =>\n+                            {\n+                                Some(single_line_body_str.clone())\n+                            }\n+                            _ => Some(body_str),\n+                        }\n+                    } else {\n+                        Some(body_str)\n+                    }\n+                },\n+            );\n+        }\n+\n         // When overflowing the closure which consists of a single control flow expression,\n         // force to use block if its condition uses multi line.\n         let is_multi_lined_cond = rewrite_cond(context, body, body_shape)\n@@ -2263,6 +2294,23 @@ fn rewrite_last_closure(\n     None\n }\n \n+fn is_block_closure_forced(expr: &ast::Expr) -> bool {\n+    match expr.node {\n+        ast::ExprKind::If(..) |\n+        ast::ExprKind::IfLet(..) |\n+        ast::ExprKind::Loop(..) |\n+        ast::ExprKind::While(..) |\n+        ast::ExprKind::WhileLet(..) |\n+        ast::ExprKind::ForLoop(..) => true,\n+        ast::ExprKind::AddrOf(_, ref expr) |\n+        ast::ExprKind::Box(ref expr) |\n+        ast::ExprKind::Try(ref expr) |\n+        ast::ExprKind::Unary(_, ref expr) |\n+        ast::ExprKind::Cast(ref expr, _) => is_block_closure_forced(expr),\n+        _ => false,\n+    }\n+}\n+\n fn rewrite_last_arg_with_overflow<'a, T>(\n     context: &RewriteContext,\n     args: &[&T],"}]}