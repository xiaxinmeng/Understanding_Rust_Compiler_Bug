{"sha": "5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlNzIyOWI3MmNiMGE3ZmMxYjZhOWRkNDgxNTUxN2Q2YTRiYjIxMjc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-09T13:09:58Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-09T14:11:59Z"}, "message": "reduce self type to a special type parameter", "tree": {"sha": "52c920e4cd53060b5fe02bf12704aac2b8fbddb5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52c920e4cd53060b5fe02bf12704aac2b8fbddb5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127", "html_url": "https://github.com/rust-lang/rust/commit/5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d41af13334148b114b7f7d61f49d269ee293826f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d41af13334148b114b7f7d61f49d269ee293826f", "html_url": "https://github.com/rust-lang/rust/commit/d41af13334148b114b7f7d61f49d269ee293826f"}], "stats": {"total": 613, "additions": 289, "deletions": 324}, "files": [{"sha": "644a38b8c8dcd942ca8042f9acac96bcff45c1e1", "filename": "src/rustc/metadata/tydecode.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127/src%2Frustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127/src%2Frustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftydecode.rs?ref=5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127", "patch": "@@ -199,12 +199,16 @@ fn parse_vstore(st: @pstate) -> ty::vstore {\n fn parse_substs(st: @pstate, conv: conv_did) -> ty::substs {\n     let self_r = parse_opt(st) {|| parse_region(st) };\n \n+    let self_ty = parse_opt(st) {|| parse_ty(st, conv) };\n+\n     assert next(st) == '[';\n     let mut params: [ty::t] = [];\n     while peek(st) != ']' { params += [parse_ty(st, conv)]; }\n     st.pos = st.pos + 1u;\n \n-    ret {self_r: self_r, tps: params};\n+    ret {self_r: self_r,\n+         self_ty: self_ty,\n+         tps: params};\n }\n \n fn parse_bound_region(st: @pstate) -> ty::bound_region {\n@@ -298,10 +302,7 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n         ret ty::mk_param(st.tcx, parse_int(st) as uint, did);\n       }\n       's' {\n-        assert next(st) == '[';\n-        let substs = parse_substs(st, conv);\n-        assert next(st) == ']';\n-        ret ty::mk_self(st.tcx, substs);\n+        ret ty::mk_self(st.tcx);\n       }\n       '@' { ret ty::mk_box(st.tcx, parse_mt(st, conv)); }\n       '~' { ret ty::mk_uniq(st.tcx, parse_mt(st, conv)); }"}, {"sha": "4f42ab4e1007f1de3b197d9d640858771ecae3d9", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127", "patch": "@@ -115,6 +115,7 @@ fn enc_opt<T>(w: io::writer, t: option<T>, enc_f: fn(T)) {\n \n fn enc_substs(w: io::writer, cx: @ctxt, substs: ty::substs) {\n     enc_opt(w, substs.self_r) { |r| enc_region(w, cx, r) }\n+    enc_opt(w, substs.self_ty) { |t| enc_ty(w, cx, t) }\n     w.write_char('[');\n     for substs.tps.each { |t| enc_ty(w, cx, t); }\n     w.write_char(']');\n@@ -281,10 +282,8 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n         w.write_char('|');\n         w.write_str(uint::str(id));\n       }\n-      ty::ty_self(substs) {\n-        w.write_str(\"s[\"/&);\n-        enc_substs(w, cx, substs);\n-        w.write_char(']');\n+      ty::ty_self {\n+        w.write_char('s');\n       }\n       ty::ty_type { w.write_char('Y'); }\n       ty::ty_opaque_closure_ptr(ty::ck_block) { w.write_str(\"C&\"/&); }"}, {"sha": "cd46f53c35794a5ef0246b59df4a59d7da630722", "filename": "src/rustc/middle/infer.rs", "status": "modified", "additions": 51, "deletions": 7, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127/src%2Frustc%2Fmiddle%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127/src%2Frustc%2Fmiddle%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Finfer.rs?ref=5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127", "patch": "@@ -630,12 +630,15 @@ impl methods for resolve_state {\n     fn resolve1(typ: ty::t) -> ty::t {\n         #debug(\"Resolve1(%s)\", typ.to_str(self.infcx));\n         indent(fn&() -> ty::t {\n-            if !ty::get(typ).has_vars { ret typ; }\n+            if !ty::type_needs_infer(typ) { ret typ; }\n \n-            let tb = ty::get(typ);\n-            alt tb.struct {\n-              ty::ty_var(vid) { self.resolve_ty_var(vid) }\n-              _ if !tb.has_regions && !self.deep { typ }\n+            alt ty::get(typ).struct {\n+              ty::ty_var(vid) {\n+                self.resolve_ty_var(vid)\n+              }\n+              _ if !ty::type_has_regions(typ) && !self.deep {\n+                typ\n+              }\n               _ {\n                 ty::fold_regions_and_ty(\n                     self.infcx.tcx, typ,\n@@ -935,6 +938,7 @@ iface combine {\n     fn contratys(a: ty::t, b: ty::t) -> cres<ty::t>;\n     fn tys(a: ty::t, b: ty::t) -> cres<ty::t>;\n     fn tps(as: [ty::t], bs: [ty::t]) -> cres<[ty::t]>;\n+    fn self_tys(a: option<ty::t>, b: option<ty::t>) -> cres<option<ty::t>>;\n     fn substs(as: ty::substs, bs: ty::substs) -> cres<ty::substs>;\n     fn fns(a: ty::fn_ty, b: ty::fn_ty) -> cres<ty::fn_ty>;\n     fn flds(a: ty::field, b: ty::field) -> cres<ty::field>;\n@@ -982,8 +986,10 @@ fn super_substs<C:combine>(\n     }\n \n     self.tps(a.tps, b.tps).chain { |tps|\n-        eq_opt_regions(self.infcx(), a.self_r, b.self_r).chain { |self_r|\n-            ok({self_r: self_r, tps: tps})\n+        self.self_tys(a.self_ty, b.self_ty).chain { |self_ty|\n+            eq_opt_regions(self.infcx(), a.self_r, b.self_r).chain { |self_r|\n+                ok({self_r: self_r, self_ty: self_ty, tps: tps})\n+            }\n         }\n     }\n }\n@@ -995,6 +1001,7 @@ fn super_tps<C:combine>(\n     // (otherwise the type system would be unsound).  In the\n     // future we could allow type parameters to declare a\n     // variance.\n+\n     if check vec::same_length(as, bs) {\n         iter2(as, bs) {|a, b| self.infcx().eq_tys(a, b) }.then {||\n             ok(as)\n@@ -1004,6 +1011,31 @@ fn super_tps<C:combine>(\n     }\n }\n \n+fn super_self_tys<C:combine>(\n+    self: C, a: option<ty::t>, b: option<ty::t>) -> cres<option<ty::t>> {\n+\n+    // Note: the self type parameter is (currently) always treated as\n+    // *invariant* (otherwise the type system would be unsound).\n+\n+    alt (a, b) {\n+      (none, none) {\n+        ok(none)\n+      }\n+      (some(a), some(b)) {\n+        self.infcx().eq_tys(a, b).then {||\n+            ok(some(a))\n+        }\n+      }\n+      (none, some(_)) |\n+      (some(_), none) {\n+        // I think it should never happen that we unify two substs and\n+        // one of them has a self_ty and one doesn't...? I could be\n+        // wrong about this.\n+        err(ty::terr_self_substs)\n+      }\n+    }\n+}\n+\n fn super_flds<C:combine>(\n     self: C, a: ty::field, b: ty::field) -> cres<ty::field> {\n \n@@ -1374,6 +1406,10 @@ impl of combine for sub {\n     fn tps(as: [ty::t], bs: [ty::t]) -> cres<[ty::t]> {\n         super_tps(self, as, bs)\n     }\n+\n+    fn self_tys(a: option<ty::t>, b: option<ty::t>) -> cres<option<ty::t>> {\n+        super_self_tys(self, a, b)\n+    }\n }\n \n impl of combine for lub {\n@@ -1549,6 +1585,10 @@ impl of combine for lub {\n     fn tps(as: [ty::t], bs: [ty::t]) -> cres<[ty::t]> {\n         super_tps(self, as, bs)\n     }\n+\n+    fn self_tys(a: option<ty::t>, b: option<ty::t>) -> cres<option<ty::t>> {\n+        super_self_tys(self, a, b)\n+    }\n }\n \n impl of combine for glb {\n@@ -1739,6 +1779,10 @@ impl of combine for glb {\n     fn tps(as: [ty::t], bs: [ty::t]) -> cres<[ty::t]> {\n         super_tps(self, as, bs)\n     }\n+\n+    fn self_tys(a: option<ty::t>, b: option<ty::t>) -> cres<option<ty::t>> {\n+        super_self_tys(self, a, b)\n+    }\n }\n \n // ______________________________________________________________________"}, {"sha": "b7f360cd3377ec31e592bd60f826716fd21c74fc", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127", "patch": "@@ -916,7 +916,9 @@ fn field_idx_strict(cx: ty::ctxt, sp: span, ident: ast::ident,\n }\n \n fn dummy_substs(tps: [ty::t]) -> ty::substs {\n-    {self_r: some(ty::re_bound(ty::br_self)), tps: tps}\n+    {self_r: some(ty::re_bound(ty::br_self)),\n+     self_ty: none,\n+     tps: tps}\n }\n \n //"}, {"sha": "ec49a0ec7cb24de02023fbb2ab7f418338229664", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127", "patch": "@@ -256,7 +256,7 @@ fn make_impl_vtable(ccx: @crate_ctxt, impl_id: ast::def_id, substs: [ty::t],\n     let has_tps = (*ty::lookup_item_type(ccx.tcx, impl_id).bounds).len() > 0u;\n     make_vtable(ccx, vec::map(*ty::iface_methods(tcx, ifce_id)) {|im|\n         let fty = ty::subst_tps(tcx, substs, ty::mk_fn(tcx, im.fty));\n-        if (*im.tps).len() > 0u || ty::type_has_vars(fty) {\n+        if (*im.tps).len() > 0u || ty::type_has_self(fty) {\n             C_null(T_ptr(T_nil()))\n         } else {\n             let m_id = method_with_name(ccx, impl_id, im.ident);"}, {"sha": "14215efb199c3169649455f27526e2f5f5b78852", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127", "patch": "@@ -457,7 +457,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n       ty::ty_fn({proto: ast::proto_bare, _}) { [shape_bare_fn] }\n       ty::ty_opaque_closure_ptr(_) { [shape_opaque_closure_ptr] }\n       ty::ty_constr(inner_t, _) { shape_of(ccx, inner_t, ty_param_map) }\n-      ty::ty_var(_) | ty::ty_self(_) {\n+      ty::ty_var(_) | ty::ty_self {\n         ccx.sess.bug(\"shape_of: unexpected type struct found\");\n       }\n     }"}, {"sha": "16646472de87a1fb292bb261819d8e201d84f2ea", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127", "patch": "@@ -44,7 +44,7 @@ fn type_of_fn_from_ty(cx: @crate_ctxt, fty: ty::t) -> TypeRef {\n }\n \n fn type_of_non_gc_box(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n-    assert !ty::type_has_vars(t);\n+    assert !ty::type_needs_infer(t);\n \n     let t_norm = ty::normalize_ty(cx.tcx, t);\n     if t != t_norm {\n@@ -62,7 +62,7 @@ fn type_of_non_gc_box(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n }\n \n fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n-    assert !ty::type_has_vars(t);\n+    assert !ty::type_needs_infer(t);\n \n     #debug(\"type_of %?: %?\", t, ty::get(t));\n \n@@ -149,8 +149,7 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n             };\n             T_struct(tys)\n           }\n-          ty::ty_self(_) { cx.tcx.sess.unimpl(\"type_of: ty_self \\\n-                                               not implemented\"); }\n+          ty::ty_self { cx.tcx.sess.unimpl(\"type_of: ty_self\"); }\n           ty::ty_var(_) { cx.tcx.sess.bug(\"type_of shouldn't see a ty_var\"); }\n         }\n     };"}, {"sha": "87daf62d800059fc9793128acd574ba729de860c", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 94, "deletions": 117, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127", "patch": "@@ -35,7 +35,7 @@ export expr_ty;\n export expr_ty_params_and_ty;\n export expr_is_lval;\n export field_ty;\n-export fold_ty, fold_sty_to_ty, fold_region, fold_regions, fold_ty_var;\n+export fold_ty, fold_sty_to_ty, fold_region, fold_regions;\n export fold_regions_and_ty, walk_regions_and_ty;\n export field;\n export field_idx;\n@@ -61,7 +61,7 @@ export sequence_element_type;\n export sort_methods;\n export stmt_node_id;\n export sty;\n-export subst, subst_tps, substs_is_noop, substs;\n+export subst, subst_tps, substs_is_noop, substs_to_str, substs;\n export t;\n export new_ty_hash;\n export enum_variants, substd_enum_variants;\n@@ -97,10 +97,11 @@ export ty_type, mk_type;\n export ty_uint, mk_uint, mk_mach_uint;\n export ty_uniq, mk_uniq, mk_imm_uniq, type_is_unique_box;\n export ty_var, mk_var, type_is_var;\n-export ty_self, mk_self;\n+export ty_self, mk_self, type_has_self;\n export region, bound_region;\n-export get, type_has_params, type_has_vars, type_has_regions;\n+export get, type_has_params, type_needs_infer, type_has_regions;\n export type_has_resources, type_id;\n+export tbox_has_flag;\n export ty_var_id;\n export ty_to_def_id;\n export ty_fn_args;\n@@ -230,12 +231,21 @@ type ctxt =\n       borrowings: hashmap<ast::node_id, ()>,\n       normalized_cache: hashmap<t, t>};\n \n+enum tbox_flag {\n+    has_params = 1,\n+    has_self = 2,\n+    needs_infer = 4,\n+    has_regions = 8,\n+    has_resources = 16,\n+\n+    // a meta-flag: subst may be required if the type has parameters, a self\n+    // type, or references bound regions\n+    needs_subst = 1 | 2 | 8\n+}\n+\n type t_box = @{struct: sty,\n                id: uint,\n-               has_params: bool,\n-               has_vars: bool,\n-               has_regions: bool,\n-               has_resources: bool,\n+               flags: uint,\n                o_def_id: option<ast::def_id>};\n \n // To reduce refcounting cost, we're representing types as unsafe pointers\n@@ -253,10 +263,14 @@ pure fn get(t: t) -> t_box unsafe {\n     t3\n }\n \n-fn type_has_params(t: t) -> bool { get(t).has_params }\n-fn type_has_vars(t: t) -> bool { get(t).has_vars }\n-fn type_has_regions(t: t) -> bool { get(t).has_regions }\n-fn type_has_resources(t: t) -> bool { get(t).has_resources }\n+fn tbox_has_flag(tb: t_box, flag: tbox_flag) -> bool {\n+    (tb.flags & (flag as uint)) != 0u\n+}\n+fn type_has_params(t: t) -> bool { tbox_has_flag(get(t), has_params) }\n+fn type_has_self(t: t) -> bool { tbox_has_flag(get(t), has_self) }\n+fn type_needs_infer(t: t) -> bool { tbox_has_flag(get(t), needs_infer) }\n+fn type_has_regions(t: t) -> bool { tbox_has_flag(get(t), has_regions) }\n+fn type_has_resources(t: t) -> bool { tbox_has_flag(get(t), has_resources) }\n fn type_def_id(t: t) -> option<ast::def_id> { get(t).o_def_id }\n fn type_id(t: t) -> uint { get(t).id }\n \n@@ -301,6 +315,7 @@ type opt_region = option<region>;\n // `&self.T` within the type and report an error.\n type substs = {\n     self_r: opt_region,\n+    self_ty: option<ty::t>,\n     tps: [t]\n };\n \n@@ -331,7 +346,7 @@ enum sty {\n \n     ty_var(ty_vid), // type variable during typechecking\n     ty_param(uint, def_id), // type parameter\n-    ty_self(substs), // interface method self type\n+    ty_self, // special, implicit `self` type parameter\n \n     ty_type, // type_desc*\n     ty_opaque_box, // used by monomorphizer to represent any @ box\n@@ -371,7 +386,8 @@ enum type_err {\n     terr_regions_differ(region, region),\n     terr_vstores_differ(terr_vstore_kind, vstore, vstore),\n     terr_in_field(@type_err, str),\n-    terr_sorts(t, t)\n+    terr_sorts(t, t),\n+    terr_self_substs\n }\n \n enum param_bound {\n@@ -480,95 +496,65 @@ fn mk_t_with_id(cx: ctxt, st: sty, o_def_id: option<ast::def_id>) -> t {\n       some(t) { unsafe { ret unsafe::reinterpret_cast(t); } }\n       _ {}\n     }\n-    let mut has_params = false, has_vars = false, has_regions = false,\n-    has_resources = false;\n-    fn derive_flags(&has_params: bool, &has_vars: bool, &has_regions: bool,\n-                    &has_resources: bool, tt: t) {\n-        let t = get(tt);\n-        has_params |= t.has_params;\n-        has_vars |= t.has_vars;\n-        has_regions |= t.has_regions;\n-        has_resources |= t.has_resources;\n-    }\n-    fn derive_rflags(&has_vars: bool, &has_regions: bool, r: region) {\n-        has_regions = true;\n-        alt r {\n-          ty::re_var(_) { has_vars = true; }\n-          _ { }\n+    let mut flags = 0u;\n+    fn rflags(r: region) -> uint {\n+        (has_regions as uint) | {\n+            alt r {\n+              ty::re_var(_) {needs_infer as uint}\n+              _ {0u}\n+            }\n         }\n     }\n-    fn derive_sflags(&has_params: bool, &has_vars: bool, &has_regions: bool,\n-                     &has_resources: bool, substs: substs) {\n-        for substs.tps.each {|tt|\n-            derive_flags(has_params, has_vars, has_regions,\n-                         has_resources, tt);\n-        }\n-        substs.self_r.iter { |r| derive_rflags(has_vars, has_regions, r) }\n+    fn sflags(substs: substs) -> uint {\n+        let mut f = 0u;\n+        for substs.tps.each {|tt| f |= get(tt).flags; }\n+        substs.self_r.iter { |r| f |= rflags(r) }\n+        ret f;\n     }\n     alt st {\n       ty_estr(vstore_slice(r)) {\n-        derive_rflags(has_vars, has_regions, r);\n+        flags |= rflags(r);\n       }\n       ty_evec(mt, vstore_slice(r)) {\n-        derive_rflags(has_vars, has_regions, r);\n-        derive_flags(has_params, has_vars, has_regions,\n-                     has_resources, mt.ty);\n+        flags |= rflags(r);\n+        flags |= get(mt.ty).flags;\n       }\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n       ty_str | ty_estr(_) | ty_type | ty_opaque_closure_ptr(_) |\n       ty_opaque_box {}\n-      ty_param(_, _) { has_params = true; }\n-      ty_var(_) | ty_self(_) { has_vars = true; }\n+      ty_param(_, _) { flags |= has_params as uint; }\n+      ty_var(_) { flags |= needs_infer as uint; }\n+      ty_self { flags |= has_self as uint; }\n       ty_enum(_, substs) | ty_class(_, substs) | ty_iface(_, substs) {\n-        derive_sflags(has_params, has_vars, has_regions,\n-                      has_resources, substs);\n+        flags |= sflags(substs);\n       }\n       ty_box(m) | ty_uniq(m) | ty_vec(m) | ty_evec(m, _) | ty_ptr(m) {\n-        derive_flags(has_params, has_vars, has_regions,\n-                     has_resources, m.ty);\n+        flags |= get(m.ty).flags;\n       }\n       ty_rptr(r, m) {\n-        derive_rflags(has_vars, has_regions, r);\n-        derive_flags(has_params, has_vars, has_regions,\n-                     has_resources, m.ty);\n+        flags |= rflags(r);\n+        flags |= get(m.ty).flags;\n       }\n       ty_rec(flds) {\n-        for flds.each {|f|\n-          derive_flags(has_params, has_vars, has_regions,\n-                       has_resources, f.mt.ty);\n-        }\n+        for flds.each {|f| flags |= get(f.mt.ty).flags; }\n       }\n       ty_tup(ts) {\n-        for ts.each {|tt| derive_flags(has_params, has_vars,\n-                                       has_regions, has_resources, tt); }\n+        for ts.each {|tt| flags |= get(tt).flags; }\n       }\n       ty_fn(f) {\n-        for f.inputs.each {|a|\n-          derive_flags(has_params, has_vars, has_regions,\n-                       has_resources, a.ty);\n-        }\n-        derive_flags(has_params, has_vars, has_regions,\n-                     has_resources, f.output);\n+        for f.inputs.each {|a| flags |= get(a.ty).flags; }\n+        flags |= get(f.output).flags;\n       }\n       ty_res(_, tt, substs) {\n-        has_resources = true;\n-        derive_flags(has_params, has_vars, has_regions,\n-                     has_resources, tt);\n-        derive_sflags(has_params, has_vars, has_regions,\n-                      has_resources, substs);\n+        flags |= (has_resources as uint);\n+        flags |= get(tt).flags;\n+        flags |= sflags(substs);\n       }\n       ty_constr(tt, _) {\n-        derive_flags(has_params, has_vars, has_regions,\n-                     has_resources, tt);\n+        flags |= get(tt).flags;\n       }\n     }\n-    let t = @{struct: st,\n-              id: cx.next_id,\n-              has_params: has_params,\n-              has_vars: has_vars,\n-              has_regions: has_regions,\n-              has_resources: has_resources,\n-              o_def_id: o_def_id};\n+    let t = @{struct: st, id: cx.next_id, flags: flags, o_def_id: o_def_id};\n     cx.interner.insert(key, t);\n     cx.next_id += 1u;\n     unsafe { unsafe::reinterpret_cast(t) }\n@@ -660,7 +646,7 @@ fn mk_res(cx: ctxt, did: ast::def_id,\n \n fn mk_var(cx: ctxt, v: ty_vid) -> t { mk_t(cx, ty_var(v)) }\n \n-fn mk_self(cx: ctxt, substs: substs) -> t { mk_t(cx, ty_self(substs)) }\n+fn mk_self(cx: ctxt) -> t { mk_t(cx, ty_self) }\n \n fn mk_param(cx: ctxt, n: uint, k: def_id) -> t { mk_t(cx, ty_param(n, k)) }\n \n@@ -699,14 +685,15 @@ fn maybe_walk_ty(ty: t, f: fn(t) -> bool) {\n     if !f(ty) { ret; }\n     alt get(ty).struct {\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n-      ty_str | ty_estr(_) | ty_type | ty_opaque_box |\n-      ty_opaque_closure_ptr(_) | ty_var(_) | ty_param(_, _) {}\n+      ty_str | ty_estr(_) | ty_type | ty_opaque_box | ty_self |\n+      ty_opaque_closure_ptr(_) | ty_var(_) | ty_param(_, _) {\n+      }\n       ty_box(tm) | ty_vec(tm) | ty_evec(tm, _) |\n       ty_ptr(tm) | ty_rptr(_, tm) {\n         maybe_walk_ty(tm.ty, f);\n       }\n       ty_enum(_, substs) | ty_class(_, substs) |\n-      ty_iface(_, substs) | ty_self(substs) {\n+      ty_iface(_, substs) {\n         for substs.tps.each {|subty| maybe_walk_ty(subty, f); }\n       }\n       ty_rec(fields) {\n@@ -733,6 +720,7 @@ fn fold_sty_to_ty(tcx: ty::ctxt, sty: sty, foldop: fn(t) -> t) -> t {\n fn fold_sty(sty: sty, fldop: fn(t) -> t) -> sty {\n     fn fold_substs(substs: substs, fldop: fn(t) -> t) -> substs {\n         {self_r: substs.self_r,\n+         self_ty: substs.self_ty.map { |t| fldop(t) },\n          tps: substs.tps.map { |t| fldop(t) }}\n     }\n \n@@ -758,9 +746,6 @@ fn fold_sty(sty: sty, fldop: fn(t) -> t) -> sty {\n       ty_iface(did, substs) {\n         ty_iface(did, fold_substs(substs, fldop))\n       }\n-      ty_self(substs) {\n-        ty_self(fold_substs(substs, fldop))\n-      }\n       ty_rec(fields) {\n         let new_fields = vec::map(fields) {|fl|\n             let new_ty = fldop(fl.mt.ty);\n@@ -796,7 +781,7 @@ fn fold_sty(sty: sty, fldop: fn(t) -> t) -> sty {\n       }\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n       ty_str | ty_estr(_) | ty_type | ty_opaque_closure_ptr(_) |\n-      ty_opaque_box | ty_var(_) | ty_param(_, _) {\n+      ty_opaque_box | ty_var(_) | ty_param(*) | ty_self {\n         sty\n       }\n     }\n@@ -808,15 +793,6 @@ fn fold_ty(cx: ctxt, t0: t, fldop: fn(t) -> t) -> t {\n     fldop(mk_t(cx, sty))\n }\n \n-fn fold_ty_var(cx: ctxt, t0: t, fldop: fn(ty_vid) -> t) -> t {\n-    let tb = get(t0);\n-    if !tb.has_vars { ret t0; }\n-    alt tb.struct {\n-      ty_var(id) { fldop(id) }\n-      sty { fold_sty_to_ty(cx, sty) {|t| fold_ty_var(cx, t, fldop) } }\n-    }\n-}\n-\n fn walk_regions_and_ty(\n     cx: ctxt,\n     ty: t,\n@@ -845,6 +821,7 @@ fn fold_regions_and_ty(\n         fldt: fn(t: t) -> t) -> substs {\n \n         {self_r: substs.self_r.map { |r| fldr(r) },\n+         self_ty: substs.self_ty.map { |t| fldt(t) },\n          tps: substs.tps.map { |t| fldt(t) }}\n     }\n \n@@ -873,9 +850,6 @@ fn fold_regions_and_ty(\n       ty_iface(def_id, substs) {\n         ty::mk_iface(cx, def_id, fold_substs(substs, fldr, fldt))\n       }\n-      ty_self(substs) {\n-        ty::mk_self(cx, fold_substs(substs, fldr, fldt))\n-      }\n       ty_res(def_id, t, substs) {\n         ty::mk_res(cx, def_id, fldt(t),\n                    fold_substs(substs, fldr, fldt))\n@@ -916,7 +890,7 @@ fn fold_region(cx: ctxt, t0: t, fldop: fn(region, bool) -> region) -> t {\n     fn do_fold(cx: ctxt, t0: t, under_r: bool,\n                fldop: fn(region, bool) -> region) -> t {\n         let tb = get(t0);\n-        if !tb.has_regions { ret t0; }\n+        if !tbox_has_flag(tb, has_regions) { ret t0; }\n         alt tb.struct {\n           ty_rptr(r, {ty: t1, mutbl: m}) {\n             let m_r = fldop(r, under_r);\n@@ -951,20 +925,23 @@ fn fold_region(cx: ctxt, t0: t, fldop: fn(region, bool) -> region) -> t {\n fn subst_tps(cx: ctxt, tps: [t], typ: t) -> t {\n     if tps.len() == 0u { ret typ; }\n     let tb = ty::get(typ);\n-    if !tb.has_params { ret typ; }\n+    if !tbox_has_flag(tb, has_params) { ret typ; }\n     alt tb.struct {\n       ty_param(idx, _) { tps[idx] }\n       sty { fold_sty_to_ty(cx, sty) {|t| subst_tps(cx, tps, t) } }\n     }\n }\n \n fn substs_is_noop(substs: substs) -> bool {\n-    substs.tps.len() == 0u && substs.self_r.is_none()\n+    substs.tps.len() == 0u &&\n+        substs.self_r.is_none() &&\n+        substs.self_ty.is_none()\n }\n \n fn substs_to_str(cx: ctxt, substs: substs) -> str {\n-    #fmt[\"substs(self_r=%s, tps=%?)\",\n+    #fmt[\"substs(self_r=%s, self_ty=%s, tps=%?)\",\n          substs.self_r.map_default(\"none\", { |r| region_to_str(cx, r) }),\n+         substs.self_ty.map_default(\"none\", { |t| ty_to_str(cx, t) }),\n          substs.tps.map { |t| ty_to_str(cx, t) }]\n }\n \n@@ -985,20 +962,17 @@ fn subst(cx: ctxt,\n                 substs: substs,\n                 typ: t) -> t {\n         let tb = get(typ);\n-        if !tb.has_params && !tb.has_regions { ret typ; }\n+        if !tbox_has_flag(tb, needs_subst) { ret typ; }\n         alt tb.struct {\n-          ty_param(idx, _) { substs.tps[idx] }\n+          ty_param(idx, _) {substs.tps[idx]}\n+          ty_self {substs.self_ty.get()}\n           _ {\n             fold_regions_and_ty(\n                 cx, typ,\n                 { |r|\n                     alt r {\n-                      re_bound(br_self) {\n-                        option::get(substs.self_r)\n-                      }\n-                      _ {\n-                        r\n-                      }\n+                      re_bound(br_self) {substs.self_r.get()}\n+                      _ {r}\n                     }\n                 },\n                 { |t| do_subst(cx, substs, t) },\n@@ -1406,14 +1380,14 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n         }\n         lowest\n       }\n-      // Resources are always noncopyable.\n       ty_res(did, inner, tps) { kind_noncopyable }\n       ty_param(_, did) {\n           param_bounds_to_kind(cx.ty_param_bounds.get(did.node))\n       }\n       ty_constr(t, _) { type_kind(cx, t) }\n-      ty_var(_) { fail \"FIXME\"; }\n-      ty_self(_) { kind_noncopyable }\n+      ty_self { kind_noncopyable }\n+\n+      ty_var(_) { cx.sess.bug(\"Asked to compute kind of a type variable\"); }\n     };\n \n     cx.kind_cache.insert(ty, result);\n@@ -1459,7 +1433,7 @@ fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n           ty_fn(_) |\n           ty_var(_) |\n           ty_param(_, _) |\n-          ty_self(_) |\n+          ty_self |\n           ty_type |\n           ty_opaque_box |\n           ty_opaque_closure_ptr(_) |\n@@ -1850,9 +1824,7 @@ fn hash_type_structure(st: sty) -> uint {\n       }\n       ty_var(v) { hash_uint(30u, v.to_uint()) }\n       ty_param(pid, did) { hash_def(hash_uint(31u, pid), did) }\n-      ty_self(substs) {\n-        hash_substs(28u, substs)\n-      }\n+      ty_self { 28u }\n       ty_type { 32u }\n       ty_bot { 34u }\n       ty_ptr(mt) { hash_subty(35u, mt.ty) }\n@@ -2081,7 +2053,7 @@ fn sort_methods(meths: [method]) -> [method] {\n \n fn occurs_check(tcx: ctxt, sp: span, vid: ty_vid, rt: t) {\n     // Fast path\n-    if !type_has_vars(rt) { ret; }\n+    if !type_needs_infer(rt) { ret; }\n \n     // Occurs check!\n     if vec::contains(vars_in_type(rt), vid) {\n@@ -2190,7 +2162,7 @@ fn ty_sort_str(cx: ctxt, t: t) -> str {\n       ty_tup(_) { \"tuple\" }\n       ty_var(_) { \"variable\" }\n       ty_param(_, _) { \"type parameter\" }\n-      ty_self(_) { \"self\" }\n+      ty_self { \"self\" }\n       ty_constr(t, _) { ty_sort_str(cx, t) }\n     }\n }\n@@ -2274,6 +2246,9 @@ fn type_err_to_str(cx: ctxt, err: type_err) -> str {\n       terr_sorts(exp, act) {\n         ret #fmt(\"%s vs %s\", ty_sort_str(cx, exp), ty_sort_str(cx, act));\n       }\n+      terr_self_substs {\n+        ret \"inconsistent self substitution\"; // XXX this is more of a bug\n+      }\n     }\n }\n \n@@ -2730,7 +2705,9 @@ fn normalize_ty(cx: ctxt, t: t) -> t {\n             alt r.self_r {\n               some(_) {\n                 // This enum has a self region. Get rid of it\n-                mk_enum(cx, did, {self_r: none, tps: r.tps })\n+                mk_enum(cx, did, {self_r: none,\n+                                  self_ty: none,\n+                                  tps: r.tps})\n               }\n               none { t }\n             }"}, {"sha": "6023d830229041ebcf90bc5be5b51f056811ed50", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 79, "deletions": 170, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127", "patch": "@@ -272,7 +272,7 @@ fn instantiate_path(fcx: @fn_ctxt,\n         pth.types.map { |aty| fcx.to_ty(aty) }\n     };\n \n-    let substs = {self_r: self_r, tps: tps};\n+    let substs = {self_r: self_r, self_ty: none, tps: tps};\n     fcx.write_ty_substs(id, tpt.ty, substs);\n }\n \n@@ -340,6 +340,8 @@ iface ast_conv {\n     fn tcx() -> ty::ctxt;\n     fn ccx() -> @crate_ctxt;\n     fn get_item_ty(id: ast::def_id) -> ty::ty_param_bounds_and_ty;\n+\n+    // what type should we use when a type is omitted?\n     fn ty_infer(span: span) -> ty::t;\n }\n \n@@ -536,7 +538,7 @@ fn ast_path_to_substs_and_ty<AC: ast_conv, RS: region_scope copy>(\n     }\n     let tps = path.types.map { |a_t| ast_ty_to_ty(self, rscope, a_t) };\n \n-    let substs = {self_r: self_r, tps: tps};\n+    let substs = {self_r:self_r, self_ty:none, tps:tps};\n     {substs: substs, ty: ty::subst(tcx, substs, decl_ty)}\n }\n \n@@ -569,9 +571,11 @@ fn instantiate_iface_ref(ccx: @crate_ctxt, t: @ast::iface_ref,\n     let sp = t.path.span, err = \"can only implement interface types\",\n         sess = ccx.tcx.sess;\n \n+    let rscope = type_rscope(rp);\n+\n     alt lookup_def_tcx(ccx.tcx, t.path.span, t.id) {\n       ast::def_ty(t_id) {\n-        let tpt = ast_path_to_ty(ccx, type_rscope(rp), t_id, t.path, t.id);\n+        let tpt = ast_path_to_ty(ccx, rscope, t_id, t.path, t.id);\n         alt ty::get(tpt.ty).struct {\n            ty::ty_iface(*) {\n               (t_id, tpt)\n@@ -740,11 +744,11 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy>(\n             check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n             ty::mk_param(tcx, n, id)\n           }\n-          ast::def_self(self_id) {\n-            let {substs, ty: _} =\n-                ast_path_to_substs_and_ty(self, rscope,\n-                                          local_def(self_id), path);\n-            ty::mk_self(tcx, substs)\n+          ast::def_self(_) {\n+            // n.b.: resolve guarantees that the self type only appears in an\n+            // iface, which we rely upon in various places when creating\n+            // substs\n+            ty::mk_self(tcx)\n           }\n           _ {\n             tcx.sess.span_fatal(ast_ty.span,\n@@ -1137,30 +1141,35 @@ fn ty_of_native_fn_decl(ccx: @crate_ctxt,\n fn ty_param_bounds(ccx: @crate_ctxt,\n                    params: [ast::ty_param]) -> @[ty::param_bounds] {\n \n+    fn compute_bounds(ccx: @crate_ctxt,\n+                      param: ast::ty_param) -> ty::param_bounds {\n+        @vec::flat_map(*param.bounds) { |b|\n+            alt b {\n+              ast::bound_send { [ty::bound_send] }\n+              ast::bound_copy { [ty::bound_copy] }\n+              ast::bound_iface(t) {\n+                let ity = ast_ty_to_ty(ccx, empty_rscope, t);\n+                alt ty::get(ity).struct {\n+                  ty::ty_iface(*) {\n+                    [ty::bound_iface(ity)]\n+                  }\n+                  _ {\n+                    ccx.tcx.sess.span_err(\n+                        t.span, \"type parameter bounds must be \\\n+                                 interface types\");\n+                    []\n+                  }\n+                }\n+              }\n+            }\n+        }\n+    }\n+\n     @params.map { |param|\n         alt ccx.tcx.ty_param_bounds.find(param.id) {\n           some(bs) { bs }\n           none {\n-            let bounds = @vec::flat_map(*param.bounds) { |b|\n-                alt b {\n-                  ast::bound_send { [ty::bound_send] }\n-                  ast::bound_copy { [ty::bound_copy] }\n-                  ast::bound_iface(t) {\n-                    let ity = ccx.to_ty(empty_rscope, t);\n-                    alt ty::get(ity).struct {\n-                      ty::ty_iface(_, _) {\n-                        [ty::bound_iface(ity)]\n-                      }\n-                      _ {\n-                        ccx.tcx.sess.span_err(\n-                            t.span, \"type parameter bounds must be \\\n-                                     interface types\");\n-                        []\n-                      }\n-                    }\n-                  }\n-                }\n-            };\n+            let bounds = compute_bounds(ccx, param);\n             ccx.tcx.ty_param_bounds.insert(param.id, bounds);\n             bounds\n           }\n@@ -1354,7 +1363,7 @@ fn mk_substs(ccx: @crate_ctxt, atps: [ast::ty_param], rp: ast::region_param)\n       ast::rp_self { some(ty::re_bound(ty::br_self)) }\n       ast::rp_none { none }\n     };\n-    {bounds: bounds, substs: {self_r: self_r, tps: params}}\n+    {bounds: bounds, substs: {self_r: self_r, self_ty: none, tps: params}}\n }\n \n fn compare_impl_method(tcx: ty::ctxt, sp: span, impl_m: ty::method,\n@@ -1375,7 +1384,7 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span, impl_m: ty::method,\n     } else {\n         let auto_modes = vec::map2(impl_m.fty.inputs, if_m.fty.inputs, {|i, f|\n             alt ty::get(f.ty).struct {\n-              ty::ty_param(_, _) | ty::ty_self(_)\n+              ty::ty_param(*) | ty::ty_self\n               if alt i.mode { ast::infer(_) { true } _ { false } } {\n                 {mode: ast::expl(ast::by_ref) with i}\n               }\n@@ -1387,13 +1396,13 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span, impl_m: ty::method,\n         // Add dummy substs for the parameters of the impl method\n         let substs = {\n             self_r: substs.self_r,\n+            self_ty: some(self_ty),\n             tps: substs.tps + vec::from_fn(vec::len(*if_m.tps), {|i|\n                 ty::mk_param(tcx, i + impl_tps, {crate: 0, node: 0})\n             })\n         };\n         let mut if_fty = ty::mk_fn(tcx, if_m.fty);\n         if_fty = ty::subst(tcx, substs, if_fty);\n-        if_fty = fixup_self_full(tcx, if_fty, substs, self_ty, impl_tps);\n         require_same_types(\n             tcx, sp, impl_fty, if_fty,\n             {|| \"method `\" + if_m.ident +\n@@ -1402,104 +1411,6 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span, impl_m: ty::method,\n     }\n }\n \n-// Mangles an iface method ty to make its self type conform to the self type\n-// of a specific impl or bounded type parameter. This is rather involved\n-// because the type parameters of ifaces and impls are not required to line up\n-// (an impl can have less or more parameters than the iface it implements), so\n-// some mangling of the substituted types is required.\n-fn fixup_self_full(cx: ty::ctxt, mty: ty::t, m_substs: ty::substs,\n-                   selfty: ty::t, impl_n_tps: uint) -> ty::t {\n-\n-    if !ty::type_has_vars(mty) { ret mty; }\n-\n-    ty::fold_ty(cx, mty) {|t|\n-        alt ty::get(t).struct {\n-          ty::ty_self(substs) if ty::substs_is_noop(substs) {\n-            selfty\n-          }\n-          ty::ty_self(substs) {\n-            // Move the substs into the type param system of the\n-            // context.\n-            let mut substs_tps = vec::map(substs.tps) {|t|\n-                let f = fixup_self_full(cx, t, m_substs, selfty, impl_n_tps);\n-                ty::subst(cx, m_substs, f)\n-            };\n-\n-            // Add extra substs for impl type parameters.\n-            while vec::len(substs_tps) < impl_n_tps {\n-                substs_tps += [ty::mk_param(cx, substs_tps.len(),\n-                                            {crate: 0, node: 0})];\n-            }\n-\n-            // And for method type parameters.\n-            let method_n_tps = (\n-                m_substs.tps.len() - substs_tps.len()) as int;\n-            if method_n_tps > 0 {\n-                substs_tps += vec::tailn(\n-                    m_substs.tps,\n-                    m_substs.tps.len() - (method_n_tps as uint));\n-            }\n-\n-            // And then instantiate the self type using all those.\n-            let substs_1 = {\n-                self_r: substs.self_r,\n-                tps: substs_tps\n-            };\n-            ty::subst(cx, substs_1, selfty)\n-          }\n-          _ {\n-              t\n-          }\n-        }\n-    }\n-}\n-\n-// Mangles an iface method ty to make its self type conform to the self type\n-// of a specific impl or bounded type parameter. This is rather involved\n-// because the type parameters of ifaces and impls are not required to line up\n-// (an impl can have less or more parameters than the iface it implements), so\n-// some mangling of the substituted types is required.\n-fn fixup_self_param(fcx: @fn_ctxt, mty: ty::t, m_substs: ty::substs,\n-                    selfty: ty::t, sp: span) -> ty::t {\n-    if !ty::type_has_vars(mty) { ret mty; }\n-\n-    let tcx = fcx.ccx.tcx;\n-    ty::fold_ty(tcx, mty) {|t|\n-        alt ty::get(t).struct {\n-          ty::ty_self(substs) if ty::substs_is_noop(substs) {\n-            selfty\n-          }\n-          ty::ty_self(substs) {\n-            // Move the substs into the type param system of the context.\n-            let tps_p = vec::map(substs.tps) {|t|\n-                let f = fixup_self_param(fcx, t, m_substs, selfty, sp);\n-                ty::subst(tcx, m_substs, f)\n-            };\n-            let substs_p = {self_r: substs.self_r, tps: tps_p};\n-            let self_p = ty::mk_self(tcx, substs_p);\n-            let m_self = ty::mk_self(tcx, m_substs);\n-            demand::suptype(fcx, sp, m_self, self_p);\n-            selfty\n-          }\n-          _ { t }\n-        }\n-    }\n-}\n-\n-// Replaces all occurrences of the `self` region with `with_region`.  Note\n-// that we descend into `fn()` types here, because `fn()` does not bind the\n-// `self` region.\n-fn replace_self_region(tcx: ty::ctxt, with_region: ty::region,\n-                       ty: ty::t) -> ty::t {\n-\n-   ty::fold_region(tcx, ty) {|r, _under_rptr|\n-       alt r {\n-           ty::re_bound(re_self) { with_region }\n-           _ { r }\n-       }\n-   }\n-}\n-\n // Item collection - a pair of bootstrap passes:\n //\n // (1) Collect the IDs of all type items (typedefs) and store them in a table.\n@@ -1932,7 +1843,7 @@ mod writeback {\n \n     fn resolve_type_vars_in_type(fcx: @fn_ctxt, sp: span, typ: ty::t) ->\n        option<ty::t> {\n-        if !ty::type_has_vars(typ) { ret some(typ); }\n+        if !ty::type_needs_infer(typ) { ret some(typ); }\n         alt infer::resolve_deep(fcx.infcx, typ, true) {\n           result::ok(new_type) { ret some(new_type); }\n           result::err(e) {\n@@ -2571,7 +2482,8 @@ fn impl_self_ty(fcx: @fn_ctxt, did: ast::def_id) -> ty_param_substs_and_ty {\n                       {self_r: alt rp {\n                           ast::rp_self { some(fcx.next_region_var()) }\n                           ast::rp_none { none }},\n-                      tps: ty::ty_params_to_tys(tcx, ts)})}\n+                       self_ty: none,\n+                       tps: ty::ty_params_to_tys(tcx, ts)})}\n           }\n           _ { tcx.sess.bug(\"impl_self_ty: unbound item or item that \\\n                doesn't have a self_ty\"); }\n@@ -2589,7 +2501,7 @@ fn impl_self_ty(fcx: @fn_ctxt, did: ast::def_id) -> ty_param_substs_and_ty {\n     };\n     let tps = fcx.next_ty_vars(n_tps);\n \n-    let substs = {self_r: self_r, tps: tps};\n+    let substs = {self_r: self_r, self_ty: none, tps: tps};\n     let substd_ty = ty::subst(tcx, substs, raw_ty);\n     {substs: substs, ty: substd_ty}\n }\n@@ -2657,8 +2569,18 @@ impl methods for lookup {\n               }\n \n               some(pos) {\n+                // Replace any appearance of `self` with the type of the\n+                // generic parameter itself.  Note that this is the only case\n+                // where this replacement is necessary: in all other cases, we\n+                // are either invoking a method directly from an impl or class\n+                // (where the self type is not permitted), or from a iface\n+                // type (in which case methods that refer to self are not\n+                // permitted).\n+                let substs = {self_ty: some(self.self_ty)\n+                              with bound_substs};\n+\n                 ret some(self.write_mty_from_m(\n-                    some(self.self_ty), bound_substs, ifce_methods[pos],\n+                    substs, ifce_methods[pos],\n                     method_param(iid, pos, n, iface_bnd_idx)));\n               }\n             }\n@@ -2675,23 +2597,28 @@ impl methods for lookup {\n \n             let m_fty = ty::mk_fn(self.tcx(), m.fty);\n \n-            if ty::type_has_vars(m_fty) {\n-                self.tcx().sess.span_fatal(\n+            if ty::type_has_self(m_fty) {\n+                self.tcx().sess.span_err(\n                     self.expr.span,\n                     \"can not call a method that contains a \\\n                      self type through a boxed iface\");\n             }\n \n             if (*m.tps).len() > 0u {\n-                self.tcx().sess.span_fatal(\n+                self.tcx().sess.span_err(\n                     self.expr.span,\n                     \"can not call a generic method through a \\\n                      boxed iface\");\n             }\n \n+            // Note: although it is illegal to invoke a method that uses self\n+            // through a iface instance, we use a dummy subst here so that we\n+            // can soldier on with the compilation.\n+            let substs = {self_ty: some(self.self_ty)\n+                          with iface_substs};\n+\n             ret some(self.write_mty_from_m(\n-                none, iface_substs, m,\n-                method_iface(did, i)));\n+                substs, m, method_iface(did, i)));\n         }\n \n         ret none;\n@@ -2717,7 +2644,7 @@ impl methods for lookup {\n                 self.tcx(), did, self.m_name, self.expr.span);\n \n             ret some(self.write_mty_from_m(\n-                none, class_substs, m,\n+                class_substs, m,\n                 method_static(m_declared)));\n         }\n \n@@ -2813,16 +2740,15 @@ impl methods for lookup {\n                 let (self_substs, n_tps, did) = results[0];\n                 let fty = self.ty_from_did(did);\n                 ret some(self.write_mty_from_fty(\n-                    none, self_substs, n_tps, fty,\n+                    self_substs, n_tps, fty,\n                     method_static(did)));\n             }\n         }\n \n         ret none;\n     }\n \n-    fn write_mty_from_m(self_ty_sub: option<ty::t>,\n-                        self_substs: ty::substs,\n+    fn write_mty_from_m(self_substs: ty::substs,\n                         m: ty::method,\n                         origin: method_origin) -> method_origin {\n         let tcx = self.fcx.ccx.tcx;\n@@ -2831,18 +2757,16 @@ impl methods for lookup {\n         // a.b has a protocol like fn@() (perhaps eventually fn&()):\n         let fty = ty::mk_fn(tcx, {proto: ast::proto_box with m.fty});\n \n-        ret self.write_mty_from_fty(self_ty_sub, self_substs,\n-                                    (*m.tps).len(), fty, origin);\n+        ret self.write_mty_from_fty(self_substs, (*m.tps).len(),\n+                                    fty, origin);\n     }\n \n-    fn write_mty_from_fty(self_ty_sub: option<ty::t>,\n-                          self_substs: ty::substs,\n+    fn write_mty_from_fty(self_substs: ty::substs,\n                           n_tps_m: uint,\n                           fty: ty::t,\n                           origin: method_origin) -> method_origin {\n \n         let tcx = self.fcx.ccx.tcx;\n-        let has_self = ty::type_has_vars(fty);\n \n         // Here I will use the \"c_\" prefix to refer to the method's\n         // owner.  You can read it as class, but it may also be an iface.\n@@ -2867,25 +2791,10 @@ impl methods for lookup {\n             }\n         };\n \n-        let all_substs = {self_r: self_substs.self_r,\n-                          tps: self_substs.tps + m_substs};\n-        self.fcx.write_ty_substs(self.node_id, fty, all_substs);\n+        let all_substs = {tps: self_substs.tps + m_substs\n+                          with self_substs};\n \n-        // n.b. This treatment of self is risky but ok.  As a rule of thumb,\n-        // one ought to substitute all type parameters at once, and we are not\n-        // doing so here.  The danger you open up has to do with the\n-        // possibility that one of the substs in `all_substs` maps to a self\n-        // type.  However, right now I think it is safe because the types in\n-        // `all_substs` may not refer to self.  This may not stay true\n-        // forever, though.\n-\n-        if has_self && !option::is_none(self_ty_sub) {\n-            let fty = self.fcx.node_ty(self.node_id);\n-            let fty = fixup_self_param(\n-                self.fcx, fty, all_substs, self_ty_sub.get(),\n-                self.expr.span);\n-            self.fcx.write_ty(self.node_id, fty);\n-        }\n+        self.fcx.write_ty_substs(self.node_id, fty, all_substs);\n \n         ret origin;\n     }\n@@ -4697,13 +4606,13 @@ mod vtable {\n     }\n \n     fn fixup_substs(fcx: @fn_ctxt, sp: span,\n-                    substs: ty::substs) -> ty::substs {\n+                    id: ast::def_id, substs: ty::substs) -> ty::substs {\n         let tcx = fcx.ccx.tcx;\n         // use a dummy type just to package up the substs that need fixing up\n-        let t = ty::mk_self(tcx, substs);\n+        let t = ty::mk_iface(tcx, id, substs);\n         let t_f = fixup_ty(fcx, sp, t);\n         alt check ty::get(t_f).struct {\n-          ty::ty_self(substs_f) { substs_f }\n+          ty::ty_iface(_, substs_f) { substs_f }\n         }\n     }\n \n@@ -4754,7 +4663,7 @@ mod vtable {\n             relate_iface_tys(fcx, sp, iface_ty, ty);\n             if !allow_unsafe {\n                 for vec::each(*ty::iface_methods(tcx, did)) {|m|\n-                    if ty::type_has_vars(ty::mk_fn(tcx, m.fty)) {\n+                    if ty::type_has_self(ty::mk_fn(tcx, m.fty)) {\n                         tcx.sess.span_err(\n                             sp, \"a boxed iface with self types may not be \\\n                                  passed as a bounded type\");\n@@ -4804,7 +4713,7 @@ mod vtable {\n \n                     // recursively process the bounds\n                     let iface_tps = iface_substs.tps;\n-                    let substs_f = fixup_substs(fcx, sp, substs);\n+                    let substs_f = fixup_substs(fcx, sp, iface_id, substs);\n                     connect_iface_tps(fcx, sp, substs_f.tps,\n                                       iface_tps, im.did);\n                     let subres = lookup_vtables(fcx, isc, sp,"}, {"sha": "08455b5104a012be5114691da07f72a5b89838b9", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127", "patch": "@@ -97,7 +97,7 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n         let modestr = alt canon_mode(cx, mode) {\n           ast::infer(_) { \"\" }\n           ast::expl(m) {\n-            if !ty::type_has_vars(ty) &&\n+            if !ty::type_needs_infer(ty) &&\n                 m == ty::default_arg_mode_for_ty(ty) {\n                 \"\"\n             } else {\n@@ -185,9 +185,7 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n       ty_param(id, _) {\n         \"'\" + str::from_bytes([('a' as u8) + (id as u8)])\n       }\n-      ty_self(substs) {\n-        parameterized(cx, \"self\", substs.self_r, substs.tps)\n-      }\n+      ty_self { \"self\" }\n       ty_enum(did, substs) | ty_res(did, _, substs) | ty_class(did, substs) {\n         let path = ty::item_path(cx, did);\n         let base = ast_map::path_to_str(path);"}, {"sha": "8bd0a2eb614b36a27ff5601bb6f5a88ad834e888", "filename": "src/test/compile-fail/issue-2149.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs?ref=5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127", "patch": "@@ -1,7 +1,4 @@\n-iface monad<A> {\n-    fn bind<B>(fn(A) -> self<B>);\n-}\n-impl monad<A> of monad<A> for [A] {\n+impl monad<A> for [A] {\n     fn bind<B>(f: fn(A) -> [B]) {\n         let mut r = fail;\n         for self.each {|elt| r += f(elt); }"}, {"sha": "b4c6cf5c82db7c926796b7bc9aaffef9128c2066", "filename": "src/test/compile-fail/selftype-astparam.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127/src%2Ftest%2Fcompile-fail%2Fselftype-astparam.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127/src%2Ftest%2Fcompile-fail%2Fselftype-astparam.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fselftype-astparam.rs?ref=5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127", "patch": "@@ -0,0 +1,15 @@\n+iface add {\n+    fn +(x: self) -> self;\n+}\n+\n+impl of add for int {\n+    fn +(x: int) -> int { self + x }\n+}\n+\n+fn do_add<A:add>(x: A, y: A) -> A { x + y }\n+\n+fn main() {\n+    let x = 3 as add;\n+    let y = 4 as add;\n+    do_add(x, y); //! ERROR a boxed iface with self types may not be passed as a bounded type\n+}"}, {"sha": "2772b3598495385e1e2863a87e2ca67590b1b744", "filename": "src/test/compile-fail/selftype-ifacetype.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127/src%2Ftest%2Fcompile-fail%2Fselftype-ifacetype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127/src%2Ftest%2Fcompile-fail%2Fselftype-ifacetype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fselftype-ifacetype.rs?ref=5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127", "patch": "@@ -0,0 +1,9 @@\n+iface add {\n+    fn +(x: self) -> self;\n+}\n+\n+fn do_add(x: add, y: add) -> add {\n+    x + y //! ERROR can not call a method that contains a self type through a boxed iface\n+}\n+\n+fn main() {}"}, {"sha": "d14de311d9e82708c679f7eee01a5a20fbc9d61c", "filename": "src/test/run-pass/monad.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127/src%2Ftest%2Frun-pass%2Fmonad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127/src%2Ftest%2Frun-pass%2Fmonad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmonad.rs?ref=5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127", "patch": "@@ -1,16 +1,12 @@\n-iface monad<A> {\n-    fn bind<B>(fn(A) -> self<B>) -> self<B>;\n-}\n-\n-impl <A> of monad<A> for [A] {\n+impl monad<A> for [A] {\n     fn bind<B>(f: fn(A) -> [B]) -> [B] {\n         let mut r = [];\n         for self.each {|elt| r += f(elt); }\n         r\n     }\n }\n \n-impl <A> of monad<A> for option<A> {\n+impl monad<A> for option<A> {\n     fn bind<B>(f: fn(A) -> option<B>) -> option<B> {\n         alt self {\n           some(a) { f(a) }"}, {"sha": "dabb700da357d28cc2a0d2130266a81e99c39a53", "filename": "src/test/run-pass/selftype-add-ints.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127/src%2Ftest%2Frun-pass%2Fselftype-add-ints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127/src%2Ftest%2Frun-pass%2Fselftype-add-ints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fselftype-add-ints.rs?ref=5e7229b72cb0a7fc1b6a9dd4815517d6a4bb2127", "patch": "@@ -0,0 +1,19 @@\n+iface add {\n+    fn +(x: self) -> self;\n+}\n+\n+impl of add for int {\n+    fn +(x: int) -> int { self + x }\n+}\n+\n+impl of add for @const int {\n+    fn +(x: @const int) -> @const int { @(*self + *x) }\n+}\n+\n+fn do_add<A:add>(+x: A, +y: A) -> A { x + y }\n+\n+fn main() {\n+    assert do_add(3, 4) == 7;\n+    assert do_add(@3, @4) == @7;\n+    assert do_add(@mut 3, @mut 4) == @mut 7;\n+}"}]}