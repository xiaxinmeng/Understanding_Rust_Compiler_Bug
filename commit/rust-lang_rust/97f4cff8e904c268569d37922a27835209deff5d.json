{"sha": "97f4cff8e904c268569d37922a27835209deff5d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3ZjRjZmY4ZTkwNGMyNjg1NjlkMzc5MjJhMjc4MzUyMDlkZWZmNWQ=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-01-08T08:16:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-01-08T08:16:58Z"}, "message": "Merge pull request #597 from RalfJung/range-map\n\nrewrite range map", "tree": {"sha": "5d5022479d1323c32c8ff94890c12d2f348f481c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d5022479d1323c32c8ff94890c12d2f348f481c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97f4cff8e904c268569d37922a27835209deff5d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcNFx6CRBK7hj4Ov3rIwAAdHIIAKeAJcR7EneMZsqNcnd2kaGm\nfYm5xDKUujY82UKTlC90XTpT2TpZMu7jZ5YmKUMbIYI1XoI1uGh4DfCEJ3JPZrKy\nVkCHrX8e6RhWEyzld8FCEGEUmobfX3BhhxNUy51eBODq9gDTVQPYPcrIQEhIIiyb\niQE8sIn98R8y6/aK8skUbm4NzYMEFxUaH+KMZkI+LR+7E81wYbVu/UYio5r+Vddb\n7uHdSGr8R8QkA1Tzpz4LxRSjnbVRiD6xp0/wFJohAn0THS4Rc4qKhHSlNM+cSZ62\nb6lPvdsSCXhk8FLYMjFkmXRByCs601LyfF6QWzhbna3z1fW6sWr9g9pfC70jhKA=\n=zthv\n-----END PGP SIGNATURE-----\n", "payload": "tree 5d5022479d1323c32c8ff94890c12d2f348f481c\nparent ee582b6eb37693482a0a88ce18b762427bd815a5\nparent a13b6f183b519025fe181fd4d1230287d34b1f3e\nauthor Oliver Scherer <github35764891676564198441@oli-obk.de> 1546935418 +0100\ncommitter GitHub <noreply@github.com> 1546935418 +0100\n\nMerge pull request #597 from RalfJung/range-map\n\nrewrite range map"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97f4cff8e904c268569d37922a27835209deff5d", "html_url": "https://github.com/rust-lang/rust/commit/97f4cff8e904c268569d37922a27835209deff5d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97f4cff8e904c268569d37922a27835209deff5d/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee582b6eb37693482a0a88ce18b762427bd815a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee582b6eb37693482a0a88ce18b762427bd815a5", "html_url": "https://github.com/rust-lang/rust/commit/ee582b6eb37693482a0a88ce18b762427bd815a5"}, {"sha": "a13b6f183b519025fe181fd4d1230287d34b1f3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a13b6f183b519025fe181fd4d1230287d34b1f3e", "html_url": "https://github.com/rust-lang/rust/commit/a13b6f183b519025fe181fd4d1230287d34b1f3e"}], "stats": {"total": 357, "additions": 226, "deletions": 131}, "files": [{"sha": "7b4c2dc758faa5dae1cd623c9b5f2ce9bde259a5", "filename": "bench-cargo-miri/mse/Cargo.toml", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/97f4cff8e904c268569d37922a27835209deff5d/bench-cargo-miri%2Fmse%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/97f4cff8e904c268569d37922a27835209deff5d/bench-cargo-miri%2Fmse%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/bench-cargo-miri%2Fmse%2FCargo.toml?ref=97f4cff8e904c268569d37922a27835209deff5d", "patch": "@@ -0,0 +1,7 @@\n+[package]\n+name = \"mse\"\n+version = \"0.1.0\"\n+authors = [\"Ralf Jung <post@ralfj.de>\"]\n+edition = \"2018\"\n+\n+[dependencies]"}, {"sha": "696de93442ed106c1297300cf1179da698b83abf", "filename": "bench-cargo-miri/mse/src/main.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/97f4cff8e904c268569d37922a27835209deff5d/bench-cargo-miri%2Fmse%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f4cff8e904c268569d37922a27835209deff5d/bench-cargo-miri%2Fmse%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/bench-cargo-miri%2Fmse%2Fsrc%2Fmain.rs?ref=97f4cff8e904c268569d37922a27835209deff5d", "patch": "@@ -0,0 +1,28 @@\n+static EXPECTED: &[u8] = &[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 0, 0, 255, 255, 0, 0, 255, 255, 0, 0, 255, 255, 0, 0, 255, 255, 0, 0, 255, 255, 0, 0, 255, 255, 0, 0, 255, 255, 0, 0, 255, 255, 0, 0, 255, 255, 0, 0, 255, 255, 0, 0, 255, 255, 0, 0, 255, 255, 0, 0, 0, 0, 0, 0, 255, 255, 0, 0, 255, 255, 0, 0, 255, 255, 0, 0, 255, 255, 0, 0, 255, 255, 0, 0, 255, 255, 0, 0, 255, 255, 1, 0, 255, 255, 1, 0, 255, 255, 1, 0, 255, 255, 1, 0, 255, 255, 0, 0, 255, 255, 0, 0, 255, 255, 0, 0, 255, 255, 0, 0, 254, 255, 0, 0, 254, 255, 0, 0, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 255, 255, 1, 0, 255, 255, 1, 0, 0, 0, 1, 0, 255, 255, 2, 0, 255, 255, 2, 0, 255, 255, 2, 0, 255, 255, 2, 0, 255, 255, 2, 0, 255, 255, 1, 0, 255, 255, 1, 0, 255, 255, 0, 0, 254, 255, 0, 0, 254, 255, 0, 0, 254, 255, 255, 255, 254, 255, 254, 255, 254, 255, 253, 255, 253, 255, 253, 255, 253, 255, 252, 255, 254, 255, 251, 255, 254, 255, 251, 255, 254, 255, 252, 255, 255, 255, 252, 255, 0, 0, 252, 255, 0, 0, 252, 255, 1, 0, 252, 255, 1, 0, 252, 255, 2, 0, 252, 255, 2, 0, 252, 255, 2, 0, 252, 255, 2, 0, 252, 255, 2, 0, 253, 255, 1, 0, 252, 255, 0, 0, 252, 255, 255, 255, 251, 255, 0, 0, 251, 255, 0, 0, 251, 255, 0, 0, 252, 255, 2, 0, 252, 255, 3, 0, 252, 255, 4, 0, 253, 255, 5, 0, 254, 255, 5, 0, 253, 255, 6, 0, 253, 255, 6, 0, 253, 255, 5, 0, 253, 255, 5, 0, 254, 255, 4, 0, 254, 255, 3, 0, 251, 255, 0, 0, 250, 255, 255, 255, 253, 255, 254, 255, 252, 255, 252, 255, 247, 255, 251, 255, 247, 255, 252, 255, 252, 255, 254, 255, 252, 255, 254, 255, 252, 255, 255, 255, 254, 255, 1, 0, 1, 0, 1, 0, 4, 0, 2, 0, 8, 0, 2, 0, 12, 0, 1, 0, 13, 0, 0, 0, 12, 0, 0, 0, 11, 0, 255, 255, 8, 0, 254, 255, 7, 0, 0, 0, 7, 0, 253, 255, 11, 0, 248, 255, 15, 0, 247, 255, 17, 0, 250, 255, 17, 0, 251, 255, 13, 0, 253, 255, 7, 0, 255, 255, 3, 0, 255, 255, 254, 255, 255, 255, 252, 255, 255, 255, 252, 255, 254, 255, 250, 255, 255, 255, 242, 255, 254, 255, 239, 255, 252, 255, 248, 255, 255, 255, 249, 255, 5, 0, 239, 255, 7, 0, 238, 255, 10, 0, 249, 255, 18, 0, 254, 255, 25, 0, 253, 255, 27, 0, 0, 0, 31, 0, 4, 0, 34, 0, 4, 0, 34, 0, 8, 0, 36, 0, 8, 0, 37, 0, 2, 0, 36, 0, 4, 0, 34, 0, 8, 0, 28, 0, 3, 0, 15, 0, 255, 255, 11, 0, 0, 0, 12, 0, 251, 255, 8, 0, 252, 255, 10, 0, 0, 0, 23, 0, 252, 255, 31, 0, 248, 255, 30, 0, 254, 255, 30, 0, 255, 255, 26, 0, 250, 255, 22, 0, 250, 255, 20, 0, 244, 255, 15, 0, 237, 255, 10, 0, 246, 255, 13, 0, 242, 255, 6, 0, 213, 255, 243, 255, 213, 255, 240, 255, 247, 255, 244, 255, 246, 255, 227, 255, 214, 255, 216, 255, 219, 255, 228, 255, 251, 255, 235, 255, 1, 0, 232, 255, 248, 255, 236, 255, 4, 0, 238, 255, 26, 0, 232, 255, 44, 0, 230, 255, 66, 0, 226, 255, 86, 0, 219, 255, 88, 0, 215, 255, 72, 0, 210, 255, 50, 0, 225, 255, 28, 0, 23, 0, 14, 0, 64, 0, 16, 0, 51, 0, 26, 0, 32, 0, 34, 0, 39, 0, 42, 0, 48, 0, 35, 0, 58, 0, 255, 255, 72, 0, 220, 255, 69, 0, 197, 255, 58, 0, 158, 255, 54, 0, 132, 255, 36, 0, 153, 255, 12, 0, 146, 255, 5, 0, 83, 255, 237, 255, 110, 255, 197, 255, 252, 255, 214, 255, 51, 0, 1, 0, 233, 255, 250, 255, 226, 255, 250, 255, 45, 0, 46, 0, 47, 0, 70, 0, 6, 0, 55, 0, 19, 0, 60, 0, 38, 0, 62, 0, 42, 0, 47, 0, 61, 0, 46, 0, 40, 0, 42, 0, 237, 255, 22, 0, 222, 255, 6, 0, 221, 255, 206, 255, 195, 255, 115, 255, 219, 255, 85, 255, 17, 0, 93, 255, 26, 0, 76, 255, 46, 0, 102, 255, 80, 0, 193, 255, 48, 0, 252, 255, 18, 0, 20, 0, 50, 0, 47, 0, 58, 0, 53, 0, 44, 0, 61, 0, 57, 0, 85, 0, 37, 0, 80, 0, 0, 0, 86, 0, 248, 255, 106, 0, 161, 255, 49, 0, 43, 255, 248, 255, 125, 255, 47, 0, 49, 0, 63, 0, 40, 0, 217, 255, 187, 255, 182, 255, 219, 255, 236, 255, 63, 0, 244, 255, 58, 0, 242, 255, 244, 255, 25, 0, 225, 255, 41, 0, 11, 0, 45, 0, 76, 0, 47, 0, 167, 0, 5, 0, 5, 1, 219, 255, 21, 1, 173, 255, 183, 0, 84, 255, 35, 0, 134, 255, 177, 255, 138, 0, 186, 255, 10, 1, 69, 0, 124, 0, 228, 0, 0, 0, 135, 1, 227, 255, 82, 2, 172, 255, 190, 2, 178, 255, 115, 2, 248, 255, 39, 2, 243, 255, 253, 1, 13, 0, 116, 1, 120, 0, 96, 1, 125, 0, 110, 2, 127, 0, 179, 2, 223, 0, 106, 1, 126, 0, 130, 1, 223, 255, 147, 3, 198, 0, 190, 3, 201, 1, 200, 1, 42, 1, 244, 1, 233, 0, 3, 4, 213, 1, 72, 4, 170, 1, 150, 3, 160, 0, 43, 4, 141, 0, 196, 4, 189, 0, 221, 4, 164, 0, 95, 5, 41, 1, 98, 5, 247, 1, 19, 5, 190, 2, 14, 6, 161, 3, 7, 7, 87, 3, 216, 6, 35, 2, 38, 7, 90, 2, 136, 7, 64, 3, 200, 6, 28, 3, 199, 6, 165, 3, 169, 7, 105, 5, 143, 7, 26, 6, 57, 8, 205, 5, 156, 10, 169, 5, 132, 11, 25, 5, 208, 10, 181, 4, 156, 10, 66, 5, 227, 9, 170, 5, 166, 9, 117, 6, 45, 12, 63, 8, 42, 13, 128, 8, 136, 10, 155, 7, 109, 11, 1, 9, 6, 15, 98, 10, 121, 9, 136, 8, 147, 252, 189, 7, 43, 247, 63, 10, 147, 249, 92, 11, 172, 248, 172, 10, 112, 245, 137, 11, 76, 246, 44, 12, 184, 247, 138, 11, 118, 246, 144, 12, 94, 246, 171, 13, 112, 247, 162, 12, 168, 246, 33, 13, 63, 246, 29, 15, 226, 247, 188, 14, 190, 248, 75, 15, 238, 247, 86, 17, 19, 247, 118, 11, 10, 247, 232, 254, 238, 247, 30, 249, 56, 248, 124, 250, 6, 247, 1, 250, 161, 246, 3, 249, 81, 247, 117, 250, 60, 247, 202, 250, 212, 247, 60, 250, 15, 249, 140, 250, 34, 248, 221, 249, 105, 247, 218, 249, 205, 248, 113, 251, 138, 248, 90, 250, 41, 248, 230, 248];\n+static PCM: &[i16] = &[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, -2, 0, -2, 0, -2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 1, 0, 1, 0, 0, -2, 0, -2, 0, -2, 0, -2, -2, -2, -3, -3, -3, -3, -4, -2, -5, -2, -5, -2, -4, 0, -4, 0, -4, 0, -4, 1, -4, 1, -4, 2, -4, 2, -4, 2, -4, 2, -4, 2, -3, 1, -4, 0, -4, 0, -5, 0, -5, 0, -5, 0, -4, 2, -4, 3, -4, 4, -3, 5, -2, 5, -3, 6, -3, 6, -3, 5, -3, 5, -2, 4, -2, 3, -5, 0, -6, 0, -3, -2, -4, -4, -9, -5, -9, -4, -4, -2, -4, -2, -4, 0, -2, 1, 1, 1, 4, 2, 8, 2, 12, 1, 13, 0, 12, 0, 11, 0, 8, -2, 7, 0, 7, -3, 11, -8, 15, -9, 17, -6, 17, -5, 13, -3, 7, 0, 3, 0, -2, 0, -4, 0, -4, -2, -6, 0, -14, -2, -17, -4, -8, 0, -7, 5, -17, 7, -18, 10, -7, 18, -2, 25, -3, 27, 0, 31, 4, 34, 4, 34, 8, 36, 8, 37, 2, 36, 4, 34, 8, 28, 3, 15, 0, 11, 0, 12, -5, 8, -4, 10, 0, 23, -4, 31, -8, 30, -2, 30, 0, 26, -6, 22, -6, 20, -12, 15, -19, 10, -10, 13, -14, 6, -43, -13, -43, -16, -9, -12, -10, -29, -42, -40, -37, -28, -5, -21, 1, -24, -8, -20, 4, -18, 26, -24, 44, -26, 66, -30, 86, -37, 88, -41, 72, -46, 50, -31, 28, 23, 14, 64, 16, 51, 26, 32, 34, 39, 42, 48, 35, 58, 0, 72, -36, 69, -59, 58, -98, 54, -124, 36, -103, 12, -110, 5, -173, -19, -146, -59, -4, -42, 51, 1, -23, -6, -30, -6, 45, 46, 47, 70, 6, 55, 19, 60, 38, 62, 42, 47, 61, 46, 40, 42, -19, 22, -34, 6, -35, -50, -61, -141, -37, -171, 17, -163, 26, -180, 46, -154, 80, -63, 48, -4, 18, 20, 50, 47, 58, 53, 44, 61, 57, 85, 37, 80, 0, 86, -8, 106, -95, 49, -213, -8, -131, 47, 49, 63, 40, -39, -69, -74, -37, -20, 63, -12, 58, -14, -12, 25, -31, 41, 11, 45, 76, 47, 167, 5, 261, -37, 277, -83, 183, -172, 35, -122, -79, 138, -70, 266, 69, 124, 228, 0, 391, -29, 594, -84, 702, -78, 627, -8, 551, -13, 509, 13, 372, 120, 352, 125, 622, 127, 691, 223, 362, 126, 386, -33, 915, 198, 958, 457, 456, 298, 500, 233, 1027, 469, 1096, 426, 918, 160, 1067, 141, 1220, 189, 1245, 164, 1375, 297, 1378, 503, 1299, 702, 1550, 929, 1799, 855, 1752, 547, 1830, 602, 1928, 832, 1736, 796, 1735, 933, 1961, 1385, 1935, 1562, 2105, 1485, 2716, 1449, 2948, 1305, 2768, 1205, 2716, 1346, 2531, 1450, 2470, 1653, 3117, 2111, 3370, 2176, 2696, 1947, 2925, 2305, 3846, 2658, 2425, 2184, -877, 1981, -2261, 2623, -1645, 2908, -1876, 2732, -2704, 2953, -2484, 3116, -2120, 2954, -2442, 3216, -2466, 3499, -2192, 3234, -2392, 3361, -2497, 3869, -2078, 3772, -1858, 3915, -2066, 4438, -2285, 2934, -2294, -280, -2066, -1762, -1992, -1412, -2298, -1535, -2399, -1789, -2223, -1419, -2244, -1334, -2092, -1476, -1777, -1396, -2014, -1571, -2199, -1574, -1843, -1167, -1910, -1446, -2007, -1818];\n+\n+fn main() {\n+    for i in 0..5 {\n+        mse(PCM.len(), PCM, EXPECTED);\n+    }\n+}\n+\n+fn read_i16(buffer: &[u8], index: usize) -> i16 {\n+    const SIZE: usize = std::mem::size_of::<i16>();\n+    let mut bytes: [u8; SIZE] = [0u8; SIZE];\n+    bytes.copy_from_slice(&buffer[(index * SIZE)..(index * SIZE + SIZE)]);\n+    unsafe { std::mem::transmute(bytes) }\n+}\n+\n+fn mse(samples: usize, frame_buf: &[i16], buf_ref: &[u8]) -> f64 {\n+    let mut mse = 0.0;\n+    let max_samples = std::cmp::min(buf_ref.len() / 2, samples as usize);\n+    for i in 0..max_samples {\n+        let ref_res = read_i16(buf_ref, i);\n+        let info_res = frame_buf[i as usize];\n+        let diff = (ref_res - info_res).abs();\n+        mse += f64::from(diff.pow(2));\n+    }\n+    mse / max_samples as f64\n+}\n+"}, {"sha": "29f0abff5d73de9dd9d456c7c09727249fc12bcc", "filename": "bench-cargo-miri/serde1/Cargo.toml", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/97f4cff8e904c268569d37922a27835209deff5d/bench-cargo-miri%2Fserde1%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/97f4cff8e904c268569d37922a27835209deff5d/bench-cargo-miri%2Fserde1%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/bench-cargo-miri%2Fserde1%2FCargo.toml?ref=97f4cff8e904c268569d37922a27835209deff5d", "patch": "@@ -0,0 +1,9 @@\n+[package]\n+name = \"cargo-miri-test\"\n+version = \"0.1.0\"\n+authors = [\"Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de>\"]\n+edition = \"2018\"\n+\n+[dependencies]\n+serde = { version = \"*\", features = [\"derive\"] }\n+serde_json = \"*\""}, {"sha": "2712156d61b4aa749531616b6f698fc0febe831a", "filename": "bench-cargo-miri/serde1/src/main.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/97f4cff8e904c268569d37922a27835209deff5d/bench-cargo-miri%2Fserde1%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f4cff8e904c268569d37922a27835209deff5d/bench-cargo-miri%2Fserde1%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/bench-cargo-miri%2Fserde1%2Fsrc%2Fmain.rs?ref=97f4cff8e904c268569d37922a27835209deff5d", "patch": "@@ -0,0 +1,13 @@\n+static JSON: &str = r#\"{\"buffer\":[-29,-42,-40,-37,-28,-5,-21,1,-24,-8,-20,4,-18,26,-24,44,-26,66,-30,86,-37,88,-41,72,-46,50,-31,28,23,14,64,16,51,26,32,34,39,42,48,35,58,0,72,-36,69,-59,58,-98,54,-124,36,-103,12,-110,5,-173,-19,-146,-59,-4,-42,51,1,-23,-6,-30,-6,45,46,47,70,6,55,19,60,38,62,42,47,61,46,40,42,-19,22,-34,6,-35,-50,-61,-141,-37,-171,17,-163,26,-180,46,-154,80,-63,48,-4,18,20,50,47,58,53,44,61,57,85,37,80,0,86,-8,106,-95,49,-213,-8,-131,47,49,63,40,-39,-69,-74,-37,-20,63,-12,58,-14,-12,25,-31,41,11,45,76,47,167,5,261,-37,277,-83,183,-172,35,-122,-79,138,-70,266,69,124,228,0,391,-29,594,-84,702,-78,627,-8,551,-13,509,13,372,120,352,125,622,127,691,223,362,126,386,-33,915,198,958,457,456,298,500,233,1027,469,1096,426,918,160,1067,141,1220,189,1245,164,1375,297,1378,503,1299,702,1550,929,1799,855,1752,547,1830,602,1928,832,1736,796,1735,933,1961,1385,1935,1562,2105,1485,2716,1449,2948,1305,2768,1205,2716,1346,2531,1450,2470,1653,3117,2111,3370,2176,2696,1947,2925,2305,3846,2658,2425,2184,-877,1981,-2261,2623,-1645,2908,-1876,2732,-2704,2953,-2484,3116,-2120,2954,-2442,3216,-2466,3499,-2192,3234,-2392,3361,-2497,3869,-2078,3772,-1858,3915,-2066,4438,-2285,2934,-2294,-280,-2066,-1762,-1992,-1412,-2298,-1535,-2399,-1789,-2223,-1419,-2244,-1334,-2092,-1476,-1777,-1396,-2014,-1571,-2199,-1574,-1843,-1167,-1910,-1446,-2007,-1818,-1506,-1331,-2526,-2048,-5535,-4573,-7148,-5828,-6422,-5327,-5840,-5488,-5992,-6144,-6014,-6164,-6109,-6234,-6271,-6388,-6288,-6156,-6517,-6249,-6794,-6602,-6822,-6418,-6788,-6245,-6490,-6560,-6394,-6794,-7920,-6937,-10397,-7140,-11428,-6972,-11019,-6610,-11141,-6665,-11913,-7046,-11979,-7235,-11599,-7015,-11854,-6912,-12161,-7441,-12136,-7761,-12861,-7292,-13390,-7254,-12345,-7809,-12490,-7463,-13983,-6969,-10489,-8465,-2382,-11054,1272,-12247,-270,-12060,-323,-12113,502,-12486,-697,-12251,-1086,-12141,-181,-13116,-670,-13509,-1173,-12592,-443,-12811,-449,-13698,-934,-12850,-747,-13083,-873,-15036,-1161,-11478,-1047,-2669,-1407,1006,-1658,-1146,-1195,-1297,-1421,-73,-1946,-977,-1590,-1499,-1577,-1010,-1862,-1256,-1389,-962,-1692,-509,-2613,-1317,-2087,-1359,-1997,-1034,-2891,-2024,-119,-84,5651,5723,8074,8306,7156,6870,6985,7106,7312,8403,7114,8096,7173,7848,7082,7827,6761,7189,6985,7368,7076,7835,6992,7297,7453,7260,7016,7755,6025,7429,8533,7352,14150,7628,17142,7077,16399,6947,15939,7475,16564,7069,16463,6882,16400,7602,17031,7233,16543,6517,15395,7018,15985,7104,16689,6869,15655,7622,16155,7198,17884,6022,14056,8856,5665,14484,1815,16782,3034,15786,3107,15664,2312,16517,2965,16443,3036,16120,2287,16584,2479,16720,2693,16073,2535,16159,2958,16609,3067,16086,2716,16579,3035,17752,3092,13704,2499,5265,2620,1452,2808,3024,2444,3275,2839,2267,3340,2857,2968,3232,3066,2867,3152,3072,2248,2961,2413,2807,3238,3237,2368,2699,2262,2392,3537,3339,827,823,-5020,-5359,-7095,-7857,-5973,-6274,-6208,-6279,-6934,-7181,-6893,-6647,-7146,-6687,-7026,-7328,-6451,-6924,-6763,-6535,-7109,-6639,-6926,-6559,-7188,-6799,-6727,-6955,-5786,-6554,-8543,-6796,-14465,-7190,-17356,-6641,-16372,-6529,-15941,-6898,-16526,-6434,-16219,-6520,-16222,-7449,-17077,-7097,-16665,-6476,-15675,-7026,-16498,-6848,-17147,-6271,-15894,-7069,-16266,-7032,-17817,-5991,-13796,-8594,-5421,-14349,-1649,-17288,-2847,-16525,-2974,-15945,-2324,-16482,-3022,-16593,-3097,-16451,-2420,-16780,-2649,-16641,-2836,-15900,-2660,-16214,-3050,-16827,-3111,-15993,-2741,-16151,-2994,-17537,-2933,-13812,-2314,-5216,-2475,-1125,-2648,-2801,-2290,-3285,-2796,-2243,-3415,-2642,-3109,-3000,-3271,-2839,-3408,-3161,-2497,-2876,-2603,-2570,-3351,-3173,-2416,-2832,-2235,-2408,-3405,-3186,-613,-768,5271,5201,7376,7644,6241,6176,6366,6275,6964,7124,6831,6508,6998,6566,6836,7230,6277,6777,6589,6376,6934,6536,6819,6494,7160,6749,6736,6900,5822,6476,8593,6747,14520,7204,17448,6637,16490,6483,16033,6906,16600,6511,16304,6568,16279,7438,17079,7072,16624,6463,15577,7028,16343,6877,16990,6331,15760,7121,16140,7023,17719,5944,13748,8575,5401,14336,1645,17210,2880,16419,3036,15896,2382,16483,3074,16584,3143,16425,2443,16782,2650,16695,2825,15978,2632,16272,3015,16880,3084,16096,2709,16289,2965,17641,2932,13887,2323,5330,2474,1286,2656,2954,2309,3410,2803,2373,3414,2795,3106,3151,3263,2952,3403,3241,2483,2969,2568,2681,3316,3245,2383,2837,2199,2390,3396,3165,641,706,-5230,-5323,-7307,-7790,-6136,-6317,-6268,-6419,-6884,-7278,-6766,-6666,-6976,-6731,-6853,-7406,-6308,-6958,-6636,-6553,-6978,-6703,-6829,-6647,-7156,-6883,-6737,-7017,-5814,-6581,-8575,-6833,-14490,-7270,-17411,-6699,-16466,-6539,-16016,-6931,-16571,-6504,-16257,-6551,-16202,-7408,-16983,-7021,-16545,-6410,-15512,-6976,-16305,-6803,-17017,-6243,-15820,-7037,-16197,-6923,-17802,-5820,-13840,-8455,-5475,-14227,-1724,-17099,-2923,-16314,-3008,-15801,-2362,-16392,-3088,-16506,-3163,-16356,-2503,-16700,-2717,-16605,-2855,-15904,-2710,-16226,-3108,-16870,-3089,-16101,-2747,-16257,-3087,-17584,-2975,-13868,-2324,-5343,-2548,-1275,-2673,-2917,-2213,-3363,-2694,-2311,-3251,-2744,-2867,-3129,-3034,-2939,-3190,-3234,-2346,-2964,-2639,-2658,-3558,-3241,-2670,-2892,-2453,-2437,-3564,-3175,-771,-779,5105,5171,7308,7655,6265,6204,6397,6288,7024,7172,6903,6586,7002,6627,6777,7308,6190,6889,6537,6465,7011,6613,6985,6631,7393,6934,7073,7072,6112,6615,8751,6859,14672,7282,17448,6652,16146,6448,15565,6899,16151,6547,15860,6591,16048,7446,17065,7064,16661,6368,15774,6857,16524,6677,16825,6071,15577,6900,16119,7040,17490,6118,13495,8696,5432,14446,1678,17366,3036,16488,3624,15834,3012,16382,3575,16465,3685,16301,2815,16708,2982,16679,3356,15952,2934,16049,3290,16352,3964,15605,3612,16222,3647,17764,4272,13865,3977,5384,3592,1580,3794,3243,3627,3670,3622,2758,4007,3130,3835,3294,3964,3065,4468,3408,3933,3234,3789,3118,4634,3643,4211,3174,4155,3176,5512,4400,2792,1730,-3702,-4499,-5940,-6691,-4265,-5094,-4381,-5215,-4918,-5746,-4217,-4871,-4402,-4981,-4479,-5525,-3732,-4968,-4118,-4924,-4300,-5349,-3422,-5021,-3876,-4886,-4087,-4860,-2790,-4254,-5025,-4196,-10898,-4415,-13419,-4007,-12198,-4121,-11995,-4413,-12471,-3808,-11937,-3920,-11792,-4583,-12284,-3776,-12085,-3107,-11421,-3583,-11226,-3081,-11157,-2768,-10580,-3914,-10424,-3197,-11040,-1715,-9822,-5144,-6189,-11154,-4236,-13029,-5134,-11598,-5507,-10949,-4921,-11142,-4999,-11180,-4883,-11184,-4366,-11090,-4548,-10887,-4818,-10708,-4866,-10534,-5253,-10272,-5179,-9894,-4633,-10029,-4773,-10382,-4977,-8674,-4668,-5292,-4651,-3928,-4629,-4465,-4312,-3994,-4459,-3528,-4570,-4400,-4272,-4601,-4482,-4035,-4627,-4334,-4080,-4498,-4045,-3835,-4204,-3526,-3695,-3646,-4045,-4101,-4856,-4628,-3338,-3235,-673,-508,28,147,-453,-639,11,0,8,-2,7,0,7,-3,11,-8,15,-9,17,-6,17,-5,13,-3,7,0,3,0,-2,0,-4,0,-4,-2,-6,0,-14,-2,-17,-4,-8,0,-7,5,-17,7,-18,10,-7,18,-2,25,-3,27,0,31,4,34,4,34,8,36,8,37,2,36,4,34,8,28,3,15,0,11,0,12,-5,8,-4,10,0,23,-4,31,-8,30,-2,30,0,26,-6,22,-6,20,-12,15,-19,10,-10,13,-14,6,-43,-13,-43,-16,-9,-12,-10,-29,-42,-40,-37,-28,-5,-21,1,-24,-8,-20,4,-18,26,-24,44,-26,66,-30,86,-37,88,-41,72,-46,50,-31,28,23,14,64,16,51,26,32,34,39,42,48,35,58,0,72,-36,69,-59,58,-98,54,-124,36,-103,12,-110,5,-173,-19,-146,-59,-4,-42,51,1,-23,-6,-30,-6,45,46,47,70,6,55,19,60,38,62,42,47,61,46,40,42,-19,22,-34,6,-35,-50,-61,-141,-37,-171,17,-163,26,-180,46,-154,80,-63,48,-4,18,20,50,47,58,53,44,61,57,85,37,80,0,86,-8,106,-95,49,-213,-8,-131,47,49,63,40,-39,-69,-74,-37,-20,63,-12,58,-14,-12,25,-31,41,11,45,76,47,167,5,261,-37,277,-83,183,-172,35,-122,-79,138,-70,266,69,124,228,0,391,-29,594,-84,702,-78,627,-8,551,-13,509,13,372,120,352,125,622,127,691,223,362,126,386,-33,915,198,958,457,456,298,500,233,1027,469,1096,426,918,160,1067,141,1220,189,1245,164,1375,297,1378,503,1299,702,1550,929,1799,855,1752,547,1830,602,1928,832,1736,796,1735,933,1961,1385,1935,1562,2105,1485,2716,1449,2948,1305,2768,1205,2716,1346,2531,1450,2470,1653,3117,2111,3370,2176,2696,1947,2925,2305,3846,2658,2425,2184,-877,1981,-2261,2623,-1645,2908,-1876,2732,-2704,2953,-2484,3116,-2120,2954,-2442,3216,-2466,3499,-2192,3234,-2392,3361,-2497,3869,-2078,3772,-1858,3915,-2066,4438,-2285,2934,-2294,-280,-2066,-1762,-1992,-1412,-2298,-1535,-2399,-1789,-2223,-1419,-2244,-1334,-2092,-1476,-1777,-1396,-2014,-1571,-2199,-1574,-1843,-1167,-1910,-1446,-2007,-1818,-1506,-1331,-2526,-2048,-5535,-4573,-7148,-5828,-6422,-5327,-5840,-5488,-5992,-6144,-6014,-6164,-6109,-6234,-6271,-6388,-6288,-6156,-6517,-6249,-6794,-6602,-6822,-6418,-6788,-6245,-6490,-6560,-6394,-6794,-7920,-6937,-10397,-7140,-11428,-6972,-11019,-6610,-11141,-6665,-11913,-7046,-11979,-7235,-11599,-7015,-11854,-6912,-12161,-7441,-12136,-7761,-12861,-7292,-13390,-7254,-12345,-7809,-12490,-7463,-13983,-6969,-10489,-8465,-2382,-11054,1272,-12247,-270,-12060,-323,-12113,502,-12486,-697,-12251,-1086,-12141,-181,-13116,-670,-13509,-1173,-12592,-443,-12811,-449,-13698,-934,-12850,-747,-13083,-873,-15036,-1161,-11478,-1047,-2669,-1407,1006,-1658,-1146,-1195,-1297,-1421,-73,-1946,-977,-1590,-1499,-1577,-1010,-1862,-1256,-1389,-962,-1692,-509,-2613,-1317,-2087,-1359,-1997,-1034,-2891,-2024,-119,-84,5651,5723,8074,8306,7156,6870,6985,7106,7312,8403,7114,8096,7173,7848,7082,7827,6761,7189,6985,7368]}\"#;\n+\n+use serde::Deserialize;\n+\n+#[derive(Deserialize)]\n+struct DeriveStruct {\n+    buffer: Vec<i16>,\n+}\n+\n+fn main() {\n+    let info: DeriveStruct = serde_json::from_str(JSON).unwrap();\n+    println!(\"{}\", info.buffer.len());\n+}"}, {"sha": "a8fd432282a102692dcc0e97e4d3faad193bb511", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97f4cff8e904c268569d37922a27835209deff5d/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f4cff8e904c268569d37922a27835209deff5d/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=97f4cff8e904c268569d37922a27835209deff5d", "patch": "@@ -1,4 +1,4 @@\n-#![feature(rustc_private)]\n+#![feature(rustc_private, range_contains)]\n \n #![allow(clippy::cast_lossless)]\n "}, {"sha": "80fc98a86965d1814a698f024d0a0e0d818e2ac9", "filename": "src/range_map.rs", "status": "modified", "additions": 167, "deletions": 129, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/97f4cff8e904c268569d37922a27835209deff5d/src%2Frange_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f4cff8e904c268569d37922a27835209deff5d/src%2Frange_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frange_map.rs?ref=97f4cff8e904c268569d37922a27835209deff5d", "patch": "@@ -6,174 +6,197 @@\n //! necessary (e.g. when [0,5) is first associated with X, and then [1,2) is mutated).\n //! Users must not depend on whether a range is coalesced or not, even though this is observable\n //! via the iteration APIs.\n-use std::collections::BTreeMap;\n+\n use std::ops;\n+use std::num::NonZeroU64;\n \n use rustc::ty::layout::Size;\n \n-#[derive(Clone, Debug, PartialEq, Eq)]\n-pub struct RangeMap<T> {\n-    map: BTreeMap<Range, T>,\n+#[derive(Clone, Debug)]\n+struct Elem<T> {\n+    range: ops::Range<u64>, // the range covered by this element, never empty\n+    data: T,\n }\n-\n-// The derived `Ord` impl sorts first by the first field, then, if the fields are the same,\n-// by the second field.\n-// This is exactly what we need for our purposes, since a range query on a BTReeSet/BTreeMap will give us all\n-// `MemoryRange`s whose `start` is <= than the one we're looking for, but not > the end of the range we're checking.\n-// At the same time the `end` is irrelevant for the sorting and range searching, but used for the check.\n-// This kind of search breaks, if `end < start`, so don't do that!\n-#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Debug)]\n-struct Range {\n-    start: u64,\n-    end: u64, // Invariant: end > start\n-}\n-\n-impl Range {\n-    /// Compute a range of ranges that contains all ranges overlaping with [offset, offset+len)\n-    fn range(offset: u64, len: u64) -> ops::Range<Range> {\n-        if len == 0 {\n-            // We can produce an empty range, nothing overlaps with this.\n-            let r = Range { start: 0, end: 1 };\n-            return r..r;\n-        }\n-        // We select all elements that are within\n-        // the range given by the offset into the allocation and the length.\n-        // This is sound if all ranges that intersect with the argument range, are in the\n-        // resulting range of ranges.\n-        let left = Range {\n-            // lowest range to include `offset`\n-            start: 0,\n-            end: offset + 1,\n-        };\n-        let right = Range {\n-            // lowest (valid) range not to include `offset+len`\n-            start: offset + len,\n-            end: offset + len + 1,\n-        };\n-        left..right\n-    }\n-\n-    /// Tests if any element of [offset, offset+len) is contained in this range.\n-    #[inline(always)]\n-    fn overlaps(&self, offset: u64, len: u64) -> bool {\n-        if len == 0 {\n-            // `offset` totally does not matter, we cannot overlap with an empty interval\n-            false\n-        } else {\n-            offset < self.end && offset.checked_add(len).unwrap() >= self.start\n-        }\n-    }\n+#[derive(Clone, Debug)]\n+pub struct RangeMap<T> {\n+    v: Vec<Elem<T>>,\n }\n \n impl<T> RangeMap<T> {\n     /// Create a new RangeMap for the given size, and with the given initial value used for\n     /// the entire range.\n     #[inline(always)]\n     pub fn new(size: Size, init: T) -> RangeMap<T> {\n-        let mut map = RangeMap { map: BTreeMap::new() };\n-        if size.bytes() > 0 {\n-            map.map.insert(Range { start: 0, end: size.bytes() }, init);\n+        let size = size.bytes();\n+        let mut map = RangeMap { v: Vec::new() };\n+        if size > 0 {\n+            map.v.push(Elem {\n+                range: 0..size,\n+                data: init\n+            });\n         }\n         map\n     }\n \n-    fn iter_with_range<'a>(\n-        &'a self,\n-        offset: u64,\n-        len: u64,\n-    ) -> impl Iterator<Item = (&'a Range, &'a T)> + 'a {\n-        self.map.range(Range::range(offset, len)).filter_map(\n-            move |(range, data)| {\n-                debug_assert!(len > 0);\n-                if range.overlaps(offset, len) {\n-                    Some((range, data))\n-                } else {\n-                    None\n-                }\n-            },\n-        )\n+    /// Find the index containing the given offset.\n+    fn find_offset(&self, offset: u64) -> usize {\n+        // We do a binary search\n+        let mut left = 0usize; // inclusive\n+        let mut right = self.v.len(); // exclusive\n+        loop {\n+            debug_assert!(left < right, \"find_offset: offset {} is out-of-bounds\", offset);\n+            let candidate = left.checked_add(right).unwrap() / 2;\n+            let elem = &self.v[candidate];\n+            if offset < elem.range.start {\n+                // we are too far right (offset is further left)\n+                debug_assert!(candidate < right); // we are making progress\n+                right = candidate;\n+            } else if offset >= elem.range.end {\n+                // we are too far left (offset is further right)\n+                debug_assert!(candidate >= left); // we are making progress\n+                left = candidate+1;\n+            } else {\n+                // This is it!\n+                return candidate;\n+            }\n+        }\n     }\n \n     /// Provide read-only iteration over everything in the given range.  This does\n     /// *not* split items if they overlap with the edges.  Do not use this to mutate\n     /// through interior mutability.\n     pub fn iter<'a>(&'a self, offset: Size, len: Size) -> impl Iterator<Item = &'a T> + 'a {\n-        self.iter_with_range(offset.bytes(), len.bytes()).map(|(_, data)| data)\n+        let offset = offset.bytes();\n+        let len = len.bytes();\n+        // Compute a slice starting with the elements we care about\n+        let slice: &[Elem<T>] = if len == 0 {\n+                // We just need any empty iterator.  We don't even want to\n+                // yield the element that surrounds this position.\n+                &[]\n+            } else {\n+                let first_idx = self.find_offset(offset);\n+                &self.v[first_idx..]\n+            };\n+        let end = offset + len; // the first offset that is not included any more\n+        slice.iter()\n+            .take_while(move |elem| elem.range.start < end)\n+            .map(|elem| &elem.data)\n     }\n \n     pub fn iter_mut_all<'a>(&'a mut self) -> impl Iterator<Item = &'a mut T> + 'a {\n-        self.map.values_mut()\n+        self.v.iter_mut().map(|elem| &mut elem.data)\n     }\n \n-    fn split_entry_at(&mut self, offset: u64)\n+    // Split the element situated at the given `index`, such that the 2nd one starts at offset `split_offset`.\n+    // Do nothing if the element already starts there.\n+    // Return whether a split was necessary.\n+    fn split_index(&mut self, index: usize, split_offset: u64) -> bool\n     where\n         T: Clone,\n     {\n-        let range = match self.iter_with_range(offset, 1).next() {\n-            Some((&range, _)) => range,\n-            None => return,\n-        };\n-        assert!(\n-            range.start <= offset && range.end > offset,\n-            \"We got a range that doesn't even contain what we asked for.\"\n-        );\n-        // There is an entry overlapping this position, see if we have to split it\n-        if range.start < offset {\n-            let data = self.map.remove(&range).unwrap();\n-            let old = self.map.insert(\n-                Range {\n-                    start: range.start,\n-                    end: offset,\n-                },\n-                data.clone(),\n-            );\n-            assert!(old.is_none());\n-            let old = self.map.insert(\n-                Range {\n-                    start: offset,\n-                    end: range.end,\n-                },\n-                data,\n-            );\n-            assert!(old.is_none());\n+        let elem = &mut self.v[index];\n+        if split_offset == elem.range.start || split_offset == elem.range.end {\n+            // Nothing to do\n+            return false;\n         }\n+        debug_assert!(elem.range.contains(&split_offset),\n+            \"The split_offset is not in the element to be split\");\n+\n+        // Now we really have to split.  Reduce length of first element.\n+        let second_range = split_offset..elem.range.end;\n+        elem.range.end = split_offset;\n+        // Copy the data, and insert 2nd element\n+        let second = Elem {\n+            range: second_range,\n+            data: elem.data.clone(),\n+        };\n+        self.v.insert(index+1, second);\n+        return true;\n     }\n \n     /// Provide mutable iteration over everything in the given range.  As a side-effect,\n     /// this will split entries in the map that are only partially hit by the given range,\n     /// to make sure that when they are mutated, the effect is constrained to the given range.\n+    /// Moreover, this will opportunistically merge neighbouring equal blocks.\n     pub fn iter_mut<'a>(\n         &'a mut self,\n         offset: Size,\n         len: Size,\n     ) -> impl Iterator<Item = &'a mut T> + 'a\n     where\n-        T: Clone,\n+        T: Clone + PartialEq,\n     {\n         let offset = offset.bytes();\n         let len = len.bytes();\n-\n-        if len > 0 {\n-            // Preparation: Split first and last entry as needed.\n-            self.split_entry_at(offset);\n-            self.split_entry_at(offset + len);\n-        }\n-        // Now we can provide a mutable iterator\n-        self.map.range_mut(Range::range(offset, len)).filter_map(\n-            move |(&range, data)| {\n-                debug_assert!(len > 0);\n-                if range.overlaps(offset, len) {\n-                    assert!(\n-                        offset <= range.start && offset + len >= range.end,\n-                        \"The splitting went wrong\"\n-                    );\n-                    Some(data)\n-                } else {\n-                    // Skip this one\n-                    None\n+        // Compute a slice containing exactly the elements we care about\n+        let slice: &mut [Elem<T>] = if len == 0 {\n+                // We just need any empty iterator.  We don't even want to\n+                // yield the element that surrounds this position, nor do\n+                // any splitting.\n+                &mut []\n+            } else {\n+                // Make sure we got a clear beginning\n+                let mut first_idx = self.find_offset(offset);\n+                if self.split_index(first_idx, offset) {\n+                    // The newly created 2nd element is ours\n+                    first_idx += 1;\n+                }\n+                let first_idx = first_idx; // no more mutation\n+                // Find our end.  Linear scan, but that's okay because the iteration\n+                // is doing the same linear scan anyway -- no increase in complexity.\n+                // We combine this scan with a scan for duplicates that we can merge, to reduce\n+                // the number of elements.\n+                // We stop searching after the first \"block\" of size 1, to avoid spending excessive\n+                // amounts of time on the merging.\n+                let mut equal_since_idx = first_idx;\n+                // Once we see too many non-mergeable blocks, we stop.\n+                // The initial value is chosen via... magic.  Benchmarking and magic.\n+                let mut successful_merge_count = 3usize;\n+                let mut end_idx = first_idx; // when the loop is done, this is the first excluded element.\n+                loop {\n+                    // Compute if `end` is the last element we need to look at.\n+                    let done = (self.v[end_idx].range.end >= offset+len);\n+                    // We definitely need to include `end`, so move the index.\n+                    end_idx += 1;\n+                    debug_assert!(done || end_idx < self.v.len(), \"iter_mut: end-offset {} is out-of-bounds\", offset+len);\n+                    // see if we want to merge everything in `equal_since..end` (exclusive at the end!)\n+                    if successful_merge_count > 0 {\n+                        if done || self.v[end_idx].data != self.v[equal_since_idx].data {\n+                            // Everything in `equal_since..end` was equal.  Make them just one element covering\n+                            // the entire range.\n+                            let removed_elems = end_idx - equal_since_idx - 1; // number of elements that we would remove\n+                            if removed_elems > 0 {\n+                                // Adjust the range of the first element to cover all of them.\n+                                let equal_until = self.v[end_idx - 1].range.end; // end of range of last of the equal elements\n+                                self.v[equal_since_idx].range.end = equal_until;\n+                                // Delete the rest of them.\n+                                self.v.splice(equal_since_idx+1..end_idx, std::iter::empty());\n+                                // Adjust `end_idx` because we made the list shorter.\n+                                end_idx -= removed_elems;\n+                                // adjust the count for the cutoff\n+                                successful_merge_count += removed_elems;\n+                            } else {\n+                                // adjust the count for the cutoff\n+                                successful_merge_count -= 1;\n+                            }\n+                            // Go on scanning for the next block starting here.\n+                            equal_since_idx = end_idx;\n+                        }\n+                    }\n+                    // Leave loop if this is the last element.\n+                    if done {\n+                        break;\n+                    }\n                 }\n-            },\n-        )\n+                let end_idx = end_idx-1; // Move to last included instead of first excluded index.\n+                // We need to split the end as well.  Even if this performs a\n+                // split, we don't have to adjust our index as we only care about\n+                // the first part of the split.\n+                self.split_index(end_idx, offset+len);\n+                // Now we yield the slice. `end` is inclusive.\n+                &mut self.v[first_idx..=end_idx]\n+            };\n+        slice.iter_mut().map(|elem| &mut elem.data)\n     }\n }\n \n@@ -203,6 +226,7 @@ mod tests {\n         }\n         // Check\n         assert_eq!(to_vec(&map, 10, 1), vec![42]);\n+        assert_eq!(map.v.len(), 3);\n \n         // Insert with size 0\n         for x in map.iter_mut(Size::from_bytes(10), Size::from_bytes(0)) {\n@@ -212,6 +236,7 @@ mod tests {\n             *x = 19;\n         }\n         assert_eq!(to_vec(&map, 10, 2), vec![42, -1]);\n+        assert_eq!(map.v.len(), 3);\n     }\n \n     #[test]\n@@ -223,6 +248,7 @@ mod tests {\n         for x in map.iter_mut(Size::from_bytes(15), Size::from_bytes(1)) {\n             *x = 43;\n         }\n+        assert_eq!(map.v.len(), 5);\n         assert_eq!(\n             to_vec(&map, 10, 10),\n             vec![-1, 42, -1, -1, -1, 43, -1, -1, -1, -1]\n@@ -233,20 +259,32 @@ mod tests {\n                 *x = 23;\n             }\n         }\n-\n+        assert_eq!(map.v.len(), 6);\n         assert_eq!(\n             to_vec(&map, 10, 10),\n             vec![23, 42, 23, 23, 23, 43, 23, 23, 23, 23]\n         );\n         assert_eq!(to_vec(&map, 13, 5), vec![23, 23, 43, 23, 23]);\n \n-        // Now request a range that goes beyond the initial size\n-        for x in map.iter_mut(Size::from_bytes(15), Size::from_bytes(10)) {\n+\n+        for x in map.iter_mut(Size::from_bytes(15), Size::from_bytes(5)) {\n             *x = 19;\n         }\n-        assert_eq!(map.iter(Size::from_bytes(19), Size::from_bytes(1))\n-            .map(|&t| t).collect::<Vec<_>>(), vec![19]);\n-        assert_eq!(map.iter(Size::from_bytes(20), Size::from_bytes(1))\n-            .map(|&t| t).collect::<Vec<_>>(), vec![]);\n+        assert_eq!(map.v.len(), 6);\n+        assert_eq!(\n+            to_vec(&map, 10, 10),\n+            vec![23, 42, 23, 23, 23, 19, 19, 19, 19, 19]\n+        );\n+        // Should be seeing two blocks with 19\n+        assert_eq!(map.iter(Size::from_bytes(15), Size::from_bytes(2))\n+            .map(|&t| t).collect::<Vec<_>>(), vec![19, 19]);\n+\n+        // a NOP iter_mut should trigger merging\n+        for x in map.iter_mut(Size::from_bytes(15), Size::from_bytes(5)) { }\n+        assert_eq!(map.v.len(), 5);\n+        assert_eq!(\n+            to_vec(&map, 10, 10),\n+            vec![23, 42, 23, 23, 23, 19, 19, 19, 19, 19]\n+        );\n     }\n }"}, {"sha": "1fc705c03bb5e30c06a5ea0537b0b6aa150f4e07", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97f4cff8e904c268569d37922a27835209deff5d/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97f4cff8e904c268569d37922a27835209deff5d/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=97f4cff8e904c268569d37922a27835209deff5d", "patch": "@@ -67,7 +67,7 @@ pub enum BorStackItem {\n }\n \n /// Extra per-location state\n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub struct Stack {\n     borrows: Vec<BorStackItem>, // used as a stack; never empty\n     frozen_since: Option<Timestamp>, // virtual frozen \"item\" on top of the stack"}]}