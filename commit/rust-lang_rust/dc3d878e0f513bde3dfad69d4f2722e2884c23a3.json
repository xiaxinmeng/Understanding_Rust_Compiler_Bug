{"sha": "dc3d878e0f513bde3dfad69d4f2722e2884c23a3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjM2Q4NzhlMGY1MTNiZGUzZGZhZDY5ZDRmMjcyMmUyODg0YzIzYTM=", "commit": {"author": {"name": "Joseph Dunne", "email": "jd@lambda.tech", "date": "2016-06-11T01:00:07Z"}, "committer": {"name": "Joseph Dunne", "email": "jd@lambda.tech", "date": "2016-06-13T20:46:43Z"}, "message": "Add support for macro expansion inside trait items", "tree": {"sha": "2d015d97944935b40d40b919debbb95b5176efc5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d015d97944935b40d40b919debbb95b5176efc5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc3d878e0f513bde3dfad69d4f2722e2884c23a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc3d878e0f513bde3dfad69d4f2722e2884c23a3", "html_url": "https://github.com/rust-lang/rust/commit/dc3d878e0f513bde3dfad69d4f2722e2884c23a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc3d878e0f513bde3dfad69d4f2722e2884c23a3/comments", "author": {"login": "josephDunne", "id": 1827457, "node_id": "MDQ6VXNlcjE4Mjc0NTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1827457?v=4", "gravatar_id": "", "url": "https://api.github.com/users/josephDunne", "html_url": "https://github.com/josephDunne", "followers_url": "https://api.github.com/users/josephDunne/followers", "following_url": "https://api.github.com/users/josephDunne/following{/other_user}", "gists_url": "https://api.github.com/users/josephDunne/gists{/gist_id}", "starred_url": "https://api.github.com/users/josephDunne/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/josephDunne/subscriptions", "organizations_url": "https://api.github.com/users/josephDunne/orgs", "repos_url": "https://api.github.com/users/josephDunne/repos", "events_url": "https://api.github.com/users/josephDunne/events{/privacy}", "received_events_url": "https://api.github.com/users/josephDunne/received_events", "type": "User", "site_admin": false}, "committer": {"login": "josephDunne", "id": 1827457, "node_id": "MDQ6VXNlcjE4Mjc0NTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1827457?v=4", "gravatar_id": "", "url": "https://api.github.com/users/josephDunne", "html_url": "https://github.com/josephDunne", "followers_url": "https://api.github.com/users/josephDunne/followers", "following_url": "https://api.github.com/users/josephDunne/following{/other_user}", "gists_url": "https://api.github.com/users/josephDunne/gists{/gist_id}", "starred_url": "https://api.github.com/users/josephDunne/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/josephDunne/subscriptions", "organizations_url": "https://api.github.com/users/josephDunne/orgs", "repos_url": "https://api.github.com/users/josephDunne/repos", "events_url": "https://api.github.com/users/josephDunne/events{/privacy}", "received_events_url": "https://api.github.com/users/josephDunne/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0740a93cc290a5419807d2e8c6c442354baf46b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/0740a93cc290a5419807d2e8c6c442354baf46b0", "html_url": "https://github.com/rust-lang/rust/commit/0740a93cc290a5419807d2e8c6c442354baf46b0"}], "stats": {"total": 325, "additions": 238, "deletions": 87}, "files": [{"sha": "29293794bb8c171f555528321993d87502178aa5", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dc3d878e0f513bde3dfad69d4f2722e2884c23a3/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc3d878e0f513bde3dfad69d4f2722e2884c23a3/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=dc3d878e0f513bde3dfad69d4f2722e2884c23a3", "patch": "@@ -700,6 +700,7 @@ impl<'a> LoweringContext<'a> {\n                         hir::TypeTraitItem(this.lower_bounds(bounds),\n                                            default.as_ref().map(|x| this.lower_ty(x)))\n                     }\n+                    TraitItemKind::Macro(..) => panic!(\"Shouldn't exist any more\"),\n                 },\n                 span: i.span,\n             }"}, {"sha": "c385db534a8c5468628251f427c5653f39aaa815", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dc3d878e0f513bde3dfad69d4f2722e2884c23a3/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc3d878e0f513bde3dfad69d4f2722e2884c23a3/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=dc3d878e0f513bde3dfad69d4f2722e2884c23a3", "patch": "@@ -204,6 +204,7 @@ impl<'ast> visit::Visitor<'ast> for DefCollector<'ast> {\n             TraitItemKind::Method(..) | TraitItemKind::Const(..) =>\n                 DefPathData::ValueNs(ti.ident.name),\n             TraitItemKind::Type(..) => DefPathData::TypeNs(ti.ident.name),\n+            TraitItemKind::Macro(..) => DefPathData::MacroDef(ti.ident.name),\n         };\n \n         let def = self.create_def(ti.id, def_data);"}, {"sha": "71f894813060eb15d021fe1c4885f95ee8c8d7bf", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dc3d878e0f513bde3dfad69d4f2722e2884c23a3/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc3d878e0f513bde3dfad69d4f2722e2884c23a3/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=dc3d878e0f513bde3dfad69d4f2722e2884c23a3", "patch": "@@ -313,6 +313,7 @@ impl<'b> Resolver<'b> {\n                             (Def::Method(item_def_id), ValueNS)\n                         }\n                         TraitItemKind::Type(..) => (Def::AssociatedTy(def_id, item_def_id), TypeNS),\n+                        TraitItemKind::Macro(_) => panic!(\"unexpanded macro in resolve!\"),\n                     };\n \n                     self.define(module_parent, item.ident.name, ns, (def, item.span, vis));"}, {"sha": "6a82eaa890d035625d1bceea57ce47c329d9b8d6", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dc3d878e0f513bde3dfad69d4f2722e2884c23a3/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc3d878e0f513bde3dfad69d4f2722e2884c23a3/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=dc3d878e0f513bde3dfad69d4f2722e2884c23a3", "patch": "@@ -1692,6 +1692,7 @@ impl<'a> Resolver<'a> {\n                                         visit::walk_trait_item(this, trait_item)\n                                     });\n                                 }\n+                                TraitItemKind::Macro(_) => panic!(\"unexpanded macro in resolve!\"),\n                             };\n                         }\n                     });"}, {"sha": "aae88bc4e357436262edcc2d92511e9ca7315c38", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dc3d878e0f513bde3dfad69d4f2722e2884c23a3/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc3d878e0f513bde3dfad69d4f2722e2884c23a3/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=dc3d878e0f513bde3dfad69d4f2722e2884c23a3", "patch": "@@ -1204,7 +1204,8 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                                     trait_item.span);\n             }\n             ast::TraitItemKind::Const(_, None) |\n-            ast::TraitItemKind::Type(..) => {}\n+            ast::TraitItemKind::Type(..) |\n+            ast::TraitItemKind::Macro(_) => {}\n         }\n     }\n "}, {"sha": "6853ba688d5f59cd9dad321ae5d56dcef064e2b5", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dc3d878e0f513bde3dfad69d4f2722e2884c23a3/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc3d878e0f513bde3dfad69d4f2722e2884c23a3/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=dc3d878e0f513bde3dfad69d4f2722e2884c23a3", "patch": "@@ -1390,6 +1390,7 @@ pub enum TraitItemKind {\n     Const(P<Ty>, Option<P<Expr>>),\n     Method(MethodSig, Option<P<Block>>),\n     Type(TyParamBounds, Option<P<Ty>>),\n+    Macro(Mac),\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]"}, {"sha": "dd07fdcf33569399bdde60f99c37ac4dd221253c", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dc3d878e0f513bde3dfad69d4f2722e2884c23a3/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc3d878e0f513bde3dfad69d4f2722e2884c23a3/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=dc3d878e0f513bde3dfad69d4f2722e2884c23a3", "patch": "@@ -227,6 +227,11 @@ pub trait MacResult {\n         None\n     }\n \n+    /// Create zero or more trait items.\n+    fn make_trait_items(self: Box<Self>) -> Option<SmallVector<ast::TraitItem>> {\n+        None\n+    }\n+\n     /// Create a pattern.\n     fn make_pat(self: Box<Self>) -> Option<P<ast::Pat>> {\n         None\n@@ -274,6 +279,7 @@ make_MacEager! {\n     pat: P<ast::Pat>,\n     items: SmallVector<P<ast::Item>>,\n     impl_items: SmallVector<ast::ImplItem>,\n+    trait_items: SmallVector<ast::TraitItem>,\n     stmts: SmallVector<ast::Stmt>,\n     ty: P<ast::Ty>,\n }\n@@ -291,6 +297,10 @@ impl MacResult for MacEager {\n         self.impl_items\n     }\n \n+    fn make_trait_items(self: Box<Self>) -> Option<SmallVector<ast::TraitItem>> {\n+        self.trait_items\n+    }\n+\n     fn make_stmts(self: Box<Self>) -> Option<SmallVector<ast::Stmt>> {\n         match self.stmts.as_ref().map_or(0, |s| s.len()) {\n             0 => make_stmts_default!(self),\n@@ -399,6 +409,14 @@ impl MacResult for DummyResult {\n         }\n     }\n \n+    fn make_trait_items(self: Box<DummyResult>) -> Option<SmallVector<ast::TraitItem>> {\n+        if self.expr_only {\n+            None\n+        } else {\n+            Some(SmallVector::zero())\n+        }\n+    }\n+\n     fn make_stmts(self: Box<DummyResult>) -> Option<SmallVector<ast::Stmt>> {\n         Some(SmallVector::one(\n             codemap::respan(self.span,"}, {"sha": "ba389d5800628fc605a47f59c5fc1edd99e50264", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 31, "deletions": 19, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/dc3d878e0f513bde3dfad69d4f2722e2884c23a3/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc3d878e0f513bde3dfad69d4f2722e2884c23a3/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=dc3d878e0f513bde3dfad69d4f2722e2884c23a3", "patch": "@@ -70,6 +70,8 @@ impl_macro_generable! {\n     P<ast::Ty>:   \"type\",       .make_ty,   .fold_ty,   |span| DummyResult::raw_ty(span);\n     SmallVector<ast::ImplItem>:\n         \"impl item\", .make_impl_items, lift .fold_impl_item, |_span| SmallVector::zero();\n+    SmallVector<ast::TraitItem>:\n+        \"trait item\", .make_trait_items, lift .fold_trait_item, |_span| SmallVector::zero();\n     SmallVector<P<ast::Item>>:\n         \"item\",      .make_items,      lift .fold_item,      |_span| SmallVector::zero();\n     SmallVector<ast::Stmt>:\n@@ -760,25 +762,10 @@ fn expand_annotatable(a: Annotatable,\n             _ => noop_fold_item(it, fld),\n         }.into_iter().map(|i| Annotatable::Item(i)).collect(),\n \n-        Annotatable::TraitItem(it) => match it.node {\n-            ast::TraitItemKind::Method(_, Some(_)) => {\n-                let ti = it.unwrap();\n-                SmallVector::one(ast::TraitItem {\n-                    id: ti.id,\n-                    ident: ti.ident,\n-                    attrs: ti.attrs,\n-                    node: match ti.node  {\n-                        ast::TraitItemKind::Method(sig, Some(body)) => {\n-                            let (sig, body) = expand_and_rename_method(sig, body, fld);\n-                            ast::TraitItemKind::Method(sig, Some(body))\n-                        }\n-                        _ => unreachable!()\n-                    },\n-                    span: ti.span,\n-                })\n-            }\n-            _ => fold::noop_fold_trait_item(it.unwrap(), fld)\n-        }.into_iter().map(|ti| Annotatable::TraitItem(P(ti))).collect(),\n+        Annotatable::TraitItem(it) => {\n+            expand_trait_item(it.unwrap(), fld).into_iter().\n+                map(|it| Annotatable::TraitItem(P(it))).collect()\n+        }\n \n         Annotatable::ImplItem(ii) => {\n             expand_impl_item(ii.unwrap(), fld).into_iter().\n@@ -934,6 +921,31 @@ fn expand_impl_item(ii: ast::ImplItem, fld: &mut MacroExpander)\n     }\n }\n \n+fn expand_trait_item(ti: ast::TraitItem, fld: &mut MacroExpander)\n+                     -> SmallVector<ast::TraitItem> {\n+    match ti.node {\n+        ast::TraitItemKind::Method(_, Some(_)) => {\n+            SmallVector::one(ast::TraitItem {\n+                id: ti.id,\n+                ident: ti.ident,\n+                attrs: ti.attrs,\n+                node: match ti.node  {\n+                    ast::TraitItemKind::Method(sig, Some(body)) => {\n+                        let (sig, body) = expand_and_rename_method(sig, body, fld);\n+                        ast::TraitItemKind::Method(sig, Some(body))\n+                    }\n+                    _ => unreachable!()\n+                },\n+                span: ti.span,\n+            })\n+        }\n+        ast::TraitItemKind::Macro(mac) => {\n+            expand_mac_invoc(mac, None, ti.attrs, ti.span, fld)\n+        }\n+        _ => fold::noop_fold_trait_item(ti, fld)\n+    }\n+}\n+\n /// Given a fn_decl and a block and a MacroExpander, expand the fn_decl, then use the\n /// PatIdents in its arguments to perform renaming in the FnDecl and\n /// the block, returning both the new FnDecl and the new Block."}, {"sha": "fe98394c3e4519c90f443a996bad7799aa26d4b0", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/dc3d878e0f513bde3dfad69d4f2722e2884c23a3/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc3d878e0f513bde3dfad69d4f2722e2884c23a3/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=dc3d878e0f513bde3dfad69d4f2722e2884c23a3", "patch": "@@ -100,6 +100,21 @@ impl<'a> MacResult for ParserAnyMacro<'a> {\n         Some(ret)\n     }\n \n+    fn make_trait_items(self: Box<ParserAnyMacro<'a>>)\n+                       -> Option<SmallVector<ast::TraitItem>> {\n+        let mut ret = SmallVector::zero();\n+        loop {\n+            let mut parser = self.parser.borrow_mut();\n+            match parser.token {\n+                token::Eof => break,\n+                _ => ret.push(panictry!(parser.parse_trait_item()))\n+            }\n+        }\n+        self.ensure_complete_parse(false, \"item\");\n+        Some(ret)\n+    }\n+\n+\n     fn make_stmts(self: Box<ParserAnyMacro<'a>>)\n                  -> Option<SmallVector<ast::Stmt>> {\n         let mut ret = SmallVector::zero();"}, {"sha": "c44d5f368fe86c9a0651e1613de07465b0126ea1", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dc3d878e0f513bde3dfad69d4f2722e2884c23a3/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc3d878e0f513bde3dfad69d4f2722e2884c23a3/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=dc3d878e0f513bde3dfad69d4f2722e2884c23a3", "patch": "@@ -945,6 +945,9 @@ pub fn noop_fold_trait_item<T: Folder>(i: TraitItem, folder: &mut T)\n                 TraitItemKind::Type(folder.fold_bounds(bounds),\n                               default.map(|x| folder.fold_ty(x)))\n             }\n+            ast::TraitItemKind::Macro(mac) => {\n+                TraitItemKind::Macro(folder.fold_mac(mac))\n+            }\n         },\n         span: folder.new_span(i.span)\n     })"}, {"sha": "e0fad8f32b92a8478d4743d186e3bb6088ad1441", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 91, "deletions": 67, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/dc3d878e0f513bde3dfad69d4f2722e2884c23a3/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc3d878e0f513bde3dfad69d4f2722e2884c23a3/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=dc3d878e0f513bde3dfad69d4f2722e2884c23a3", "patch": "@@ -1232,73 +1232,88 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse the items in a trait declaration\n-    pub fn parse_trait_items(&mut self) -> PResult<'a,  Vec<TraitItem>> {\n-        self.parse_unspanned_seq(\n-            &token::OpenDelim(token::Brace),\n-            &token::CloseDelim(token::Brace),\n-            SeqSep::none(),\n-            |p| -> PResult<'a, TraitItem> {\n-            maybe_whole!(no_clone_from_p p, NtTraitItem);\n-            let mut attrs = p.parse_outer_attributes()?;\n-            let lo = p.span.lo;\n-\n-            let (name, node) = if p.eat_keyword(keywords::Type) {\n-                let TyParam {ident, bounds, default, ..} = p.parse_ty_param()?;\n-                p.expect(&token::Semi)?;\n-                (ident, TraitItemKind::Type(bounds, default))\n-            } else if p.is_const_item() {\n-                p.expect_keyword(keywords::Const)?;\n-                let ident = p.parse_ident()?;\n-                p.expect(&token::Colon)?;\n-                let ty = p.parse_ty_sum()?;\n-                let default = if p.check(&token::Eq) {\n-                    p.bump();\n-                    let expr = p.parse_expr()?;\n-                    p.commit_expr_expecting(&expr, token::Semi)?;\n-                    Some(expr)\n-                } else {\n-                    p.expect(&token::Semi)?;\n-                    None\n-                };\n-                (ident, TraitItemKind::Const(ty, default))\n+    pub fn parse_trait_item(&mut self) -> PResult<'a, TraitItem> {\n+        maybe_whole!(no_clone_from_p self, NtTraitItem);\n+        let mut attrs = self.parse_outer_attributes()?;\n+        let lo = self.span.lo;\n+\n+        let (name, node) = if self.eat_keyword(keywords::Type) {\n+            let TyParam {ident, bounds, default, ..} = self.parse_ty_param()?;\n+            self.expect(&token::Semi)?;\n+            (ident, TraitItemKind::Type(bounds, default))\n+        } else if self.is_const_item() {\n+                self.expect_keyword(keywords::Const)?;\n+            let ident = self.parse_ident()?;\n+            self.expect(&token::Colon)?;\n+            let ty = self.parse_ty_sum()?;\n+            let default = if self.check(&token::Eq) {\n+                self.bump();\n+                let expr = self.parse_expr()?;\n+                self.commit_expr_expecting(&expr, token::Semi)?;\n+                Some(expr)\n+            } else {\n+                self.expect(&token::Semi)?;\n+                None\n+            };\n+            (ident, TraitItemKind::Const(ty, default))\n+        } else if !self.token.is_any_keyword()\n+            && self.look_ahead(1, |t| *t == token::Not)\n+            && (self.look_ahead(2, |t| *t == token::OpenDelim(token::Paren))\n+                || self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace))) {\n+                // trait item macro.\n+                // code copied from parse_macro_use_or_failure... abstraction!\n+                let lo = self.span.lo;\n+                let pth = self.parse_ident_into_path()?;\n+                self.expect(&token::Not)?;\n+\n+                // eat a matched-delimiter token tree:\n+                let delim = self.expect_open_delim()?;\n+                let tts = self.parse_seq_to_end(&token::CloseDelim(delim),\n+                                             SeqSep::none(),\n+                                             |pp| pp.parse_token_tree())?;\n+                let m_ = Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT };\n+                let m: ast::Mac = codemap::Spanned { node: m_,\n+                                                     span: mk_sp(lo,\n+                                                                 self.last_span.hi) };\n+                if delim != token::Brace {\n+                    self.expect(&token::Semi)?\n+                }\n+                (keywords::Invalid.ident(), ast::TraitItemKind::Macro(m))\n             } else {\n-                let (constness, unsafety, abi) = match p.parse_fn_front_matter() {\n+                let (constness, unsafety, abi) = match self.parse_fn_front_matter() {\n                     Ok(cua) => cua,\n                     Err(e) => {\n                         loop {\n-                            match p.token {\n+                            match self.token {\n                                 token::Eof => break,\n-\n                                 token::CloseDelim(token::Brace) |\n                                 token::Semi => {\n-                                    p.bump();\n+                                    self.bump();\n                                     break;\n                                 }\n-\n                                 token::OpenDelim(token::Brace) => {\n-                                    p.parse_token_tree()?;\n+                                    self.parse_token_tree()?;\n                                     break;\n                                 }\n-\n-                                _ => p.bump()\n+                                _ => self.bump()\n                             }\n                         }\n \n                         return Err(e);\n                     }\n                 };\n \n-                let ident = p.parse_ident()?;\n-                let mut generics = p.parse_generics()?;\n+                let ident = self.parse_ident()?;\n+                let mut generics = self.parse_generics()?;\n \n-                let d = p.parse_fn_decl_with_self(|p: &mut Parser<'a>|{\n+                let d = self.parse_fn_decl_with_self(|p: &mut Parser<'a>|{\n                     // This is somewhat dubious; We don't want to allow\n                     // argument names to be left off if there is a\n                     // definition...\n                     p.parse_arg_general(false)\n                 })?;\n \n-                generics.where_clause = p.parse_where_clause()?;\n+                generics.where_clause = self.parse_where_clause()?;\n                 let sig = ast::MethodSig {\n                     unsafety: unsafety,\n                     constness: constness,\n@@ -1307,37 +1322,47 @@ impl<'a> Parser<'a> {\n                     abi: abi,\n                 };\n \n-                let body = match p.token {\n-                  token::Semi => {\n-                    p.bump();\n-                    debug!(\"parse_trait_methods(): parsing required method\");\n-                    None\n-                  }\n-                  token::OpenDelim(token::Brace) => {\n-                    debug!(\"parse_trait_methods(): parsing provided method\");\n-                    let (inner_attrs, body) =\n-                        p.parse_inner_attrs_and_block()?;\n-                    attrs.extend(inner_attrs.iter().cloned());\n-                    Some(body)\n-                  }\n+                let body = match self.token {\n+                    token::Semi => {\n+                        self.bump();\n+                        debug!(\"parse_trait_methods(): parsing required method\");\n+                        None\n+                    }\n+                    token::OpenDelim(token::Brace) => {\n+                        debug!(\"parse_trait_methods(): parsing provided method\");\n+                        let (inner_attrs, body) =\n+                            self.parse_inner_attrs_and_block()?;\n+                        attrs.extend(inner_attrs.iter().cloned());\n+                        Some(body)\n+                    }\n \n-                  _ => {\n-                      let token_str = p.this_token_to_string();\n-                      return Err(p.fatal(&format!(\"expected `;` or `{{`, found `{}`\",\n-                                       token_str)[..]))\n-                  }\n+                    _ => {\n+                        let token_str = self.this_token_to_string();\n+                        return Err(self.fatal(&format!(\"expected `;` or `{{`, found `{}`\",\n+                                                    token_str)[..]))\n+                    }\n                 };\n                 (ident, ast::TraitItemKind::Method(sig, body))\n             };\n+        Ok(TraitItem {\n+            id: ast::DUMMY_NODE_ID,\n+            ident: name,\n+            attrs: attrs,\n+            node: node,\n+            span: mk_sp(lo, self.last_span.hi),\n+        })\n+    }\n \n-            Ok(TraitItem {\n-                id: ast::DUMMY_NODE_ID,\n-                ident: name,\n-                attrs: attrs,\n-                node: node,\n-                span: mk_sp(lo, p.last_span.hi),\n+\n+    /// Parse the items in a trait declaration\n+    pub fn parse_trait_items(&mut self) -> PResult<'a,  Vec<TraitItem>> {\n+        self.parse_unspanned_seq(\n+            &token::OpenDelim(token::Brace),\n+            &token::CloseDelim(token::Brace),\n+            SeqSep::none(),\n+            |p| -> PResult<'a, TraitItem> {\n+                p.parse_trait_item()\n             })\n-        })\n     }\n \n     /// Parse a possibly mutable type\n@@ -4940,7 +4965,6 @@ impl<'a> Parser<'a> {\n \n     /// Parse trait Foo { ... }\n     fn parse_item_trait(&mut self, unsafety: Unsafety) -> PResult<'a, ItemInfo> {\n-\n         let ident = self.parse_ident()?;\n         let mut tps = self.parse_generics()?;\n "}, {"sha": "7e9cc3763bf66e3faa5aa3b30633539d35b98165", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dc3d878e0f513bde3dfad69d4f2722e2884c23a3/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc3d878e0f513bde3dfad69d4f2722e2884c23a3/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=dc3d878e0f513bde3dfad69d4f2722e2884c23a3", "patch": "@@ -1549,6 +1549,17 @@ impl<'a> State<'a> {\n                 self.print_associated_type(ti.ident, Some(bounds),\n                                            default.as_ref().map(|ty| &**ty))?;\n             }\n+            ast::TraitItemKind::Macro(codemap::Spanned { ref node, .. }) => {\n+                // code copied from ItemKind::Mac:\n+                self.print_path(&node.path, false, 0)?;\n+                word(&mut self.s, \"! \")?;\n+                self.cbox(INDENT_UNIT)?;\n+                self.popen()?;\n+                self.print_tts(&node.tts[..])?;\n+                self.pclose()?;\n+                word(&mut self.s, \";\")?;\n+                self.end()?\n+            }\n         }\n         self.ann.post(self, NodeSubItem(ti.id))\n     }"}, {"sha": "45c3a6904bd3ae1d921818a7a3d9c9c62cc67679", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dc3d878e0f513bde3dfad69d4f2722e2884c23a3/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc3d878e0f513bde3dfad69d4f2722e2884c23a3/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=dc3d878e0f513bde3dfad69d4f2722e2884c23a3", "patch": "@@ -565,6 +565,9 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n             walk_list!(visitor, visit_ty_param_bound, bounds);\n             walk_list!(visitor, visit_ty, default);\n         }\n+        TraitItemKind::Macro(ref mac) => {\n+            visitor.visit_mac(mac);\n+        }\n     }\n }\n "}, {"sha": "fd356f4a81792cf277915e0b340e13f6bb0513af", "filename": "src/test/parse-fail/trait-non-item-macros.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dc3d878e0f513bde3dfad69d4f2722e2884c23a3/src%2Ftest%2Fparse-fail%2Ftrait-non-item-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc3d878e0f513bde3dfad69d4f2722e2884c23a3/src%2Ftest%2Fparse-fail%2Ftrait-non-item-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Ftrait-non-item-macros.rs?ref=dc3d878e0f513bde3dfad69d4f2722e2884c23a3", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! bah {\n+    ($a:expr) => ($a)\n+    //~^ ERROR expected one of `const`, `extern`, `fn`, `type`, or `unsafe`, found `2`\n+}\n+\n+trait bar {\n+    bah!(2);\n+}\n+\n+fn main() {}"}, {"sha": "7c13576120b4406662b7102fbe5322ef98af4359", "filename": "src/test/run-pass/trait-item-inside-macro.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/dc3d878e0f513bde3dfad69d4f2722e2884c23a3/src%2Ftest%2Frun-pass%2Ftrait-item-inside-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc3d878e0f513bde3dfad69d4f2722e2884c23a3/src%2Ftest%2Frun-pass%2Ftrait-item-inside-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-item-inside-macro.rs?ref=dc3d878e0f513bde3dfad69d4f2722e2884c23a3", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Issue #34183\n+\n+macro_rules! foo {\n+    () => {\n+        fn foo() { }\n+    }\n+}\n+\n+macro_rules! bar {\n+    () => {\n+        fn bar();\n+    }\n+}\n+\n+trait Bleh {\n+    foo!();\n+    bar!();\n+}\n+\n+struct Test;\n+\n+impl Bleh for Test {\n+    fn bar() {}\n+}\n+\n+fn main() {\n+    Test::bar();\n+    Test::foo();\n+}"}]}