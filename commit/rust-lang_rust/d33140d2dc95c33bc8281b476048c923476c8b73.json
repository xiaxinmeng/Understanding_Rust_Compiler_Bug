{"sha": "d33140d2dc95c33bc8281b476048c923476c8b73", "node_id": "C_kwDOAAsO6NoAKGQzMzE0MGQyZGM5NWMzM2JjODI4MWI0NzYwNDhjOTIzNDc2YzhiNzM", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2022-04-29T16:48:58Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2022-05-03T09:26:58Z"}, "message": "Make rustc_parse_format compile on stable\n\nThis allows it to be used by lightweight formatting systems and may\nallow it to be used by rust-analyzer.", "tree": {"sha": "0c34de2c8a888f4babf83db1d022c1666c0c1684", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c34de2c8a888f4babf83db1d022c1666c0c1684"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d33140d2dc95c33bc8281b476048c923476c8b73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d33140d2dc95c33bc8281b476048c923476c8b73", "html_url": "https://github.com/rust-lang/rust/commit/d33140d2dc95c33bc8281b476048c923476c8b73", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d33140d2dc95c33bc8281b476048c923476c8b73/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "683c582c1e88c573c454b7fa6f00bc6647421864", "url": "https://api.github.com/repos/rust-lang/rust/commits/683c582c1e88c573c454b7fa6f00bc6647421864", "html_url": "https://github.com/rust-lang/rust/commit/683c582c1e88c573c454b7fa6f00bc6647421864"}], "stats": {"total": 422, "additions": 231, "deletions": 191}, "files": [{"sha": "94832a24409874eb63af9e5e6f9802d8678c0a46", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d33140d2dc95c33bc8281b476048c923476c8b73/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/d33140d2dc95c33bc8281b476048c923476c8b73/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=d33140d2dc95c33bc8281b476048c923476c8b73", "patch": "@@ -4171,7 +4171,6 @@ name = \"rustc_parse_format\"\n version = \"0.0.0\"\n dependencies = [\n  \"rustc_lexer\",\n- \"rustc_span\",\n ]\n \n [[package]]"}, {"sha": "c95d7147176bd111d6d3ae7a9b5fb0715a8de9b8", "filename": "compiler/rustc_builtin_macros/src/asm.rs", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/d33140d2dc95c33bc8281b476048c923476c8b73/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d33140d2dc95c33bc8281b476048c923476c8b73/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs?ref=d33140d2dc95c33bc8281b476048c923476c8b73", "patch": "@@ -626,15 +626,15 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, args: AsmArgs) -> Option<ast::Inl\n \n         if !parser.errors.is_empty() {\n             let err = parser.errors.remove(0);\n-            let err_sp = template_span.from_inner(err.span);\n+            let err_sp = template_span.from_inner(InnerSpan::new(err.span.start, err.span.end));\n             let msg = &format!(\"invalid asm template string: {}\", err.description);\n             let mut e = ecx.struct_span_err(err_sp, msg);\n             e.span_label(err_sp, err.label + \" in asm template string\");\n             if let Some(note) = err.note {\n                 e.note(&note);\n             }\n             if let Some((label, span)) = err.secondary_label {\n-                let err_sp = template_span.from_inner(span);\n+                let err_sp = template_span.from_inner(InnerSpan::new(span.start, span.end));\n                 e.span_label(err_sp, label);\n             }\n             e.emit();\n@@ -643,7 +643,10 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, args: AsmArgs) -> Option<ast::Inl\n \n         curarg = parser.curarg;\n \n-        let mut arg_spans = parser.arg_places.iter().map(|span| template_span.from_inner(*span));\n+        let mut arg_spans = parser\n+            .arg_places\n+            .iter()\n+            .map(|span| template_span.from_inner(InnerSpan::new(span.start, span.end)));\n         for piece in unverified_pieces {\n             match piece {\n                 parse::Piece::String(s) => {\n@@ -699,14 +702,21 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, args: AsmArgs) -> Option<ast::Inl\n                                 Some(idx)\n                             }\n                         }\n-                        parse::ArgumentNamed(name, span) => match args.named_args.get(&name) {\n-                            Some(&idx) => Some(idx),\n-                            None => {\n-                                let msg = format!(\"there is no argument named `{}`\", name);\n-                                ecx.struct_span_err(template_span.from_inner(span), &msg).emit();\n-                                None\n+                        parse::ArgumentNamed(name, span) => {\n+                            match args.named_args.get(&Symbol::intern(name)) {\n+                                Some(&idx) => Some(idx),\n+                                None => {\n+                                    let msg = format!(\"there is no argument named `{}`\", name);\n+                                    ecx.struct_span_err(\n+                                        template_span\n+                                            .from_inner(InnerSpan::new(span.start, span.end)),\n+                                        &msg,\n+                                    )\n+                                    .emit();\n+                                    None\n+                                }\n                             }\n-                        },\n+                        }\n                     };\n \n                     let mut chars = arg.format.ty.chars();\n@@ -715,7 +725,7 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, args: AsmArgs) -> Option<ast::Inl\n                         let span = arg\n                             .format\n                             .ty_span\n-                            .map(|sp| template_sp.from_inner(sp))\n+                            .map(|sp| template_sp.from_inner(InnerSpan::new(sp.start, sp.end)))\n                             .unwrap_or(template_sp);\n                         ecx.struct_span_err(\n                             span,\n@@ -741,7 +751,12 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, args: AsmArgs) -> Option<ast::Inl\n             let template_num_lines = 1 + template_str.matches('\\n').count();\n             line_spans.extend(std::iter::repeat(template_sp).take(template_num_lines));\n         } else {\n-            line_spans.extend(parser.line_spans.iter().map(|span| template_span.from_inner(*span)));\n+            line_spans.extend(\n+                parser\n+                    .line_spans\n+                    .iter()\n+                    .map(|span| template_span.from_inner(InnerSpan::new(span.start, span.end))),\n+            );\n         };\n     }\n "}, {"sha": "60b96399b5e7ec7a159c1b8d7bd84d3036950f04", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d33140d2dc95c33bc8281b476048c923476c8b73/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d33140d2dc95c33bc8281b476048c923476c8b73/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=d33140d2dc95c33bc8281b476048c923476c8b73", "patch": "@@ -242,7 +242,7 @@ impl<'a, 'b> Context<'a, 'b> {\n     fn resolve_name_inplace(&self, p: &mut parse::Piece<'_>) {\n         // NOTE: the `unwrap_or` branch is needed in case of invalid format\n         // arguments, e.g., `format_args!(\"{foo}\")`.\n-        let lookup = |s: Symbol| *self.names.get(&s).unwrap_or(&0);\n+        let lookup = |s: &str| *self.names.get(&Symbol::intern(s)).unwrap_or(&0);\n \n         match *p {\n             parse::String(_) => {}\n@@ -276,7 +276,9 @@ impl<'a, 'b> Context<'a, 'b> {\n                 // it's written second, so it should come after width/precision.\n                 let pos = match arg.position {\n                     parse::ArgumentIs(i) | parse::ArgumentImplicitlyIs(i) => Exact(i),\n-                    parse::ArgumentNamed(s, span) => Named(s, span),\n+                    parse::ArgumentNamed(s, span) => {\n+                        Named(Symbol::intern(s), InnerSpan::new(span.start, span.end))\n+                    }\n                 };\n \n                 let ty = Placeholder(match arg.format.ty {\n@@ -291,7 +293,10 @@ impl<'a, 'b> Context<'a, 'b> {\n                     \"X\" => \"UpperHex\",\n                     _ => {\n                         let fmtsp = self.fmtsp;\n-                        let sp = arg.format.ty_span.map(|sp| fmtsp.from_inner(sp));\n+                        let sp = arg\n+                            .format\n+                            .ty_span\n+                            .map(|sp| fmtsp.from_inner(InnerSpan::new(sp.start, sp.end)));\n                         let mut err = self.ecx.struct_span_err(\n                             sp.unwrap_or(fmtsp),\n                             &format!(\"unknown format trait `{}`\", arg.format.ty),\n@@ -340,14 +345,17 @@ impl<'a, 'b> Context<'a, 'b> {\n         }\n     }\n \n-    fn verify_count(&mut self, c: parse::Count) {\n+    fn verify_count(&mut self, c: parse::Count<'_>) {\n         match c {\n             parse::CountImplied | parse::CountIs(..) => {}\n             parse::CountIsParam(i) => {\n                 self.verify_arg_type(Exact(i), Count);\n             }\n             parse::CountIsName(s, span) => {\n-                self.verify_arg_type(Named(s, span), Count);\n+                self.verify_arg_type(\n+                    Named(Symbol::intern(s), InnerSpan::new(span.start, span.end)),\n+                    Count,\n+                );\n             }\n         }\n     }\n@@ -425,7 +433,7 @@ impl<'a, 'b> Context<'a, 'b> {\n \n         for fmt in &self.arg_with_formatting {\n             if let Some(span) = fmt.precision_span {\n-                let span = self.fmtsp.from_inner(span);\n+                let span = self.fmtsp.from_inner(InnerSpan::new(span.start, span.end));\n                 match fmt.precision {\n                     parse::CountIsParam(pos) if pos > self.num_args() => {\n                         e.span_label(\n@@ -471,7 +479,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 }\n             }\n             if let Some(span) = fmt.width_span {\n-                let span = self.fmtsp.from_inner(span);\n+                let span = self.fmtsp.from_inner(InnerSpan::new(span.start, span.end));\n                 match fmt.width {\n                     parse::CountIsParam(pos) if pos > self.num_args() => {\n                         e.span_label(\n@@ -610,7 +618,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         ecx.std_path(&[sym::fmt, sym::rt, sym::v1, s])\n     }\n \n-    fn build_count(&self, c: parse::Count) -> P<ast::Expr> {\n+    fn build_count(&self, c: parse::Count<'_>) -> P<ast::Expr> {\n         let sp = self.macsp;\n         let count = |c, arg| {\n             let mut path = Context::rtpath(self.ecx, sym::Count);\n@@ -1033,7 +1041,7 @@ pub fn expand_preparsed_format_args(\n     if !parser.errors.is_empty() {\n         let err = parser.errors.remove(0);\n         let sp = if efmt_kind_is_lit {\n-            fmt_span.from_inner(err.span)\n+            fmt_span.from_inner(InnerSpan::new(err.span.start, err.span.end))\n         } else {\n             // The format string could be another macro invocation, e.g.:\n             //     format!(concat!(\"abc\", \"{}\"), 4);\n@@ -1052,14 +1060,18 @@ pub fn expand_preparsed_format_args(\n         }\n         if let Some((label, span)) = err.secondary_label {\n             if efmt_kind_is_lit {\n-                e.span_label(fmt_span.from_inner(span), label);\n+                e.span_label(fmt_span.from_inner(InnerSpan::new(span.start, span.end)), label);\n             }\n         }\n         e.emit();\n         return DummyResult::raw_expr(sp, true);\n     }\n \n-    let arg_spans = parser.arg_places.iter().map(|span| fmt_span.from_inner(*span)).collect();\n+    let arg_spans = parser\n+        .arg_places\n+        .iter()\n+        .map(|span| fmt_span.from_inner(InnerSpan::new(span.start, span.end)))\n+        .collect();\n \n     let named_pos: FxHashSet<usize> = names.values().cloned().collect();\n "}, {"sha": "4e7aeca9ce1d5c881baa52d404d08b349c4d4c01", "filename": "compiler/rustc_lint/src/non_fmt_panic.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d33140d2dc95c33bc8281b476048c923476c8b73/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d33140d2dc95c33bc8281b476048c923476c8b73/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs?ref=d33140d2dc95c33bc8281b476048c923476c8b73", "patch": "@@ -254,7 +254,10 @@ fn check_panic_str<'tcx>(\n     if n_arguments > 0 && fmt_parser.errors.is_empty() {\n         let arg_spans: Vec<_> = match &fmt_parser.arg_places[..] {\n             [] => vec![fmt_span],\n-            v => v.iter().map(|span| fmt_span.from_inner(*span)).collect(),\n+            v => v\n+                .iter()\n+                .map(|span| fmt_span.from_inner(InnerSpan::new(span.start, span.end)))\n+                .collect(),\n         };\n         cx.struct_span_lint(NON_FMT_PANICS, arg_spans, |lint| {\n             let mut l = lint.build(match n_arguments {"}, {"sha": "fcc68b3a219cc93bea57983cbe980b31a8b220c8", "filename": "compiler/rustc_parse_format/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d33140d2dc95c33bc8281b476048c923476c8b73/compiler%2Frustc_parse_format%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d33140d2dc95c33bc8281b476048c923476c8b73/compiler%2Frustc_parse_format%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse_format%2FCargo.toml?ref=d33140d2dc95c33bc8281b476048c923476c8b73", "patch": "@@ -4,5 +4,4 @@ version = \"0.0.0\"\n edition = \"2021\"\n \n [dependencies]\n-rustc_span = { path = \"../rustc_span\" }\n rustc_lexer = { path = \"../rustc_lexer\" }"}, {"sha": "f6fa19030acb9ff08bd76bb03f26739d4537cc7e", "filename": "compiler/rustc_parse_format/src/lib.rs", "status": "modified", "additions": 28, "deletions": 16, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d33140d2dc95c33bc8281b476048c923476c8b73/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d33140d2dc95c33bc8281b476048c923476c8b73/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs?ref=d33140d2dc95c33bc8281b476048c923476c8b73", "patch": "@@ -9,8 +9,8 @@\n     html_playground_url = \"https://play.rust-lang.org/\",\n     test(attr(deny(warnings)))\n )]\n-#![feature(nll)]\n-#![feature(bool_to_option)]\n+// We want to be able to build this crate with a stable compiler, so no\n+// `#![feature]` attributes should be added.\n \n pub use Alignment::*;\n pub use Count::*;\n@@ -22,7 +22,19 @@ use std::iter;\n use std::str;\n use std::string;\n \n-use rustc_span::{InnerSpan, Symbol};\n+// Note: copied from rustc_span\n+/// Range inside of a `Span` used for diagnostics when we only have access to relative positions.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub struct InnerSpan {\n+    pub start: usize,\n+    pub end: usize,\n+}\n+\n+impl InnerSpan {\n+    pub fn new(start: usize, end: usize) -> InnerSpan {\n+        InnerSpan { start, end }\n+    }\n+}\n \n /// The type of format string that we are parsing.\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n@@ -57,7 +69,7 @@ pub enum Piece<'a> {\n #[derive(Copy, Clone, Debug, PartialEq)]\n pub struct Argument<'a> {\n     /// Where to find this argument\n-    pub position: Position,\n+    pub position: Position<'a>,\n     /// How to format the argument\n     pub format: FormatSpec<'a>,\n }\n@@ -72,11 +84,11 @@ pub struct FormatSpec<'a> {\n     /// Packed version of various flags provided.\n     pub flags: u32,\n     /// The integer precision to use.\n-    pub precision: Count,\n+    pub precision: Count<'a>,\n     /// The span of the precision formatting flag (for diagnostics).\n     pub precision_span: Option<InnerSpan>,\n     /// The string width requested for the resulting format.\n-    pub width: Count,\n+    pub width: Count<'a>,\n     /// The span of the width formatting flag (for diagnostics).\n     pub width_span: Option<InnerSpan>,\n     /// The descriptor string representing the name of the format desired for\n@@ -89,16 +101,16 @@ pub struct FormatSpec<'a> {\n \n /// Enum describing where an argument for a format can be located.\n #[derive(Copy, Clone, Debug, PartialEq)]\n-pub enum Position {\n+pub enum Position<'a> {\n     /// The argument is implied to be located at an index\n     ArgumentImplicitlyIs(usize),\n     /// The argument is located at a specific index given in the format\n     ArgumentIs(usize),\n     /// The argument has a name.\n-    ArgumentNamed(Symbol, InnerSpan),\n+    ArgumentNamed(&'a str, InnerSpan),\n }\n \n-impl Position {\n+impl Position<'_> {\n     pub fn index(&self) -> Option<usize> {\n         match self {\n             ArgumentIs(i) | ArgumentImplicitlyIs(i) => Some(*i),\n@@ -143,11 +155,11 @@ pub enum Flag {\n /// A count is used for the precision and width parameters of an integer, and\n /// can reference either an argument or a literal integer.\n #[derive(Copy, Clone, Debug, PartialEq)]\n-pub enum Count {\n+pub enum Count<'a> {\n     /// The count is specified explicitly.\n     CountIs(usize),\n     /// The count is specified by the argument with the given name.\n-    CountIsName(Symbol, InnerSpan),\n+    CountIsName(&'a str, InnerSpan),\n     /// The count is specified by the argument at the given index.\n     CountIsParam(usize),\n     /// The count is implied and cannot be explicitly specified.\n@@ -489,7 +501,7 @@ impl<'a> Parser<'a> {\n     /// integer index of an argument, a named argument, or a blank string.\n     /// Returns `Some(parsed_position)` if the position is not implicitly\n     /// consuming a macro argument, `None` if it's the case.\n-    fn position(&mut self) -> Option<Position> {\n+    fn position(&mut self) -> Option<Position<'a>> {\n         if let Some(i) = self.integer() {\n             Some(ArgumentIs(i))\n         } else {\n@@ -498,7 +510,7 @@ impl<'a> Parser<'a> {\n                     let word = self.word();\n                     let end = start + word.len();\n                     let span = self.to_span_index(start).to(self.to_span_index(end));\n-                    Some(ArgumentNamed(Symbol::intern(word), span))\n+                    Some(ArgumentNamed(word, span))\n                 }\n \n                 // This is an `ArgumentNext`.\n@@ -651,7 +663,7 @@ impl<'a> Parser<'a> {\n     /// Parses a `Count` parameter at the current position. This does not check\n     /// for 'CountIsNextParam' because that is only used in precision, not\n     /// width.\n-    fn count(&mut self, start: usize) -> (Count, Option<InnerSpan>) {\n+    fn count(&mut self, start: usize) -> (Count<'a>, Option<InnerSpan>) {\n         if let Some(i) = self.integer() {\n             if let Some(end) = self.consume_pos('$') {\n                 let span = self.to_span_index(start).to(self.to_span_index(end + 1));\n@@ -667,7 +679,7 @@ impl<'a> Parser<'a> {\n                 (CountImplied, None)\n             } else if let Some(end) = self.consume_pos('$') {\n                 let span = self.to_span_index(start + 1).to(self.to_span_index(end));\n-                (CountIsName(Symbol::intern(word), span), None)\n+                (CountIsName(word, span), None)\n             } else {\n                 self.cur = tmp;\n                 (CountImplied, None)\n@@ -723,7 +735,7 @@ impl<'a> Parser<'a> {\n                 break;\n             }\n         }\n-        found.then_some(cur)\n+        if found { Some(cur) } else { None }\n     }\n }\n "}, {"sha": "c9667922ee7c3649b7a00d7cb202ebe915004b0d", "filename": "compiler/rustc_parse_format/src/tests.rs", "status": "modified", "additions": 85, "deletions": 87, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/d33140d2dc95c33bc8281b476048c923476c8b73/compiler%2Frustc_parse_format%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d33140d2dc95c33bc8281b476048c923476c8b73/compiler%2Frustc_parse_format%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse_format%2Fsrc%2Ftests.rs?ref=d33140d2dc95c33bc8281b476048c923476c8b73", "patch": "@@ -144,93 +144,91 @@ fn format_align_fill() {\n }\n #[test]\n fn format_counts() {\n-    rustc_span::create_default_session_globals_then(|| {\n-        same(\n-            \"{:10x}\",\n-            &[NextArgument(Argument {\n-                position: ArgumentImplicitlyIs(0),\n-                format: FormatSpec {\n-                    fill: None,\n-                    align: AlignUnknown,\n-                    flags: 0,\n-                    precision: CountImplied,\n-                    width: CountIs(10),\n-                    precision_span: None,\n-                    width_span: None,\n-                    ty: \"x\",\n-                    ty_span: None,\n-                },\n-            })],\n-        );\n-        same(\n-            \"{:10$.10x}\",\n-            &[NextArgument(Argument {\n-                position: ArgumentImplicitlyIs(0),\n-                format: FormatSpec {\n-                    fill: None,\n-                    align: AlignUnknown,\n-                    flags: 0,\n-                    precision: CountIs(10),\n-                    width: CountIsParam(10),\n-                    precision_span: None,\n-                    width_span: Some(InnerSpan::new(3, 6)),\n-                    ty: \"x\",\n-                    ty_span: None,\n-                },\n-            })],\n-        );\n-        same(\n-            \"{:.*x}\",\n-            &[NextArgument(Argument {\n-                position: ArgumentImplicitlyIs(1),\n-                format: FormatSpec {\n-                    fill: None,\n-                    align: AlignUnknown,\n-                    flags: 0,\n-                    precision: CountIsParam(0),\n-                    width: CountImplied,\n-                    precision_span: Some(InnerSpan::new(3, 5)),\n-                    width_span: None,\n-                    ty: \"x\",\n-                    ty_span: None,\n-                },\n-            })],\n-        );\n-        same(\n-            \"{:.10$x}\",\n-            &[NextArgument(Argument {\n-                position: ArgumentImplicitlyIs(0),\n-                format: FormatSpec {\n-                    fill: None,\n-                    align: AlignUnknown,\n-                    flags: 0,\n-                    precision: CountIsParam(10),\n-                    width: CountImplied,\n-                    precision_span: Some(InnerSpan::new(3, 7)),\n-                    width_span: None,\n-                    ty: \"x\",\n-                    ty_span: None,\n-                },\n-            })],\n-        );\n-        same(\n-            \"{:a$.b$?}\",\n-            &[NextArgument(Argument {\n-                position: ArgumentImplicitlyIs(0),\n-                format: FormatSpec {\n-                    fill: None,\n-                    align: AlignUnknown,\n-                    flags: 0,\n-                    precision: CountIsName(Symbol::intern(\"b\"), InnerSpan::new(6, 7)),\n-                    width: CountIsName(Symbol::intern(\"a\"), InnerSpan::new(4, 4)),\n-                    precision_span: None,\n-                    width_span: None,\n-                    ty: \"?\",\n-                    ty_span: None,\n-                },\n-            })],\n-        );\n-    });\n+    same(\n+        \"{:10x}\",\n+        &[NextArgument(Argument {\n+            position: ArgumentImplicitlyIs(0),\n+            format: FormatSpec {\n+                fill: None,\n+                align: AlignUnknown,\n+                flags: 0,\n+                precision: CountImplied,\n+                width: CountIs(10),\n+                precision_span: None,\n+                width_span: None,\n+                ty: \"x\",\n+                ty_span: None,\n+            },\n+        })],\n+    );\n+    same(\n+        \"{:10$.10x}\",\n+        &[NextArgument(Argument {\n+            position: ArgumentImplicitlyIs(0),\n+            format: FormatSpec {\n+                fill: None,\n+                align: AlignUnknown,\n+                flags: 0,\n+                precision: CountIs(10),\n+                width: CountIsParam(10),\n+                precision_span: None,\n+                width_span: Some(InnerSpan::new(3, 6)),\n+                ty: \"x\",\n+                ty_span: None,\n+            },\n+        })],\n+    );\n+    same(\n+        \"{:.*x}\",\n+        &[NextArgument(Argument {\n+            position: ArgumentImplicitlyIs(1),\n+            format: FormatSpec {\n+                fill: None,\n+                align: AlignUnknown,\n+                flags: 0,\n+                precision: CountIsParam(0),\n+                width: CountImplied,\n+                precision_span: Some(InnerSpan::new(3, 5)),\n+                width_span: None,\n+                ty: \"x\",\n+                ty_span: None,\n+            },\n+        })],\n+    );\n+    same(\n+        \"{:.10$x}\",\n+        &[NextArgument(Argument {\n+            position: ArgumentImplicitlyIs(0),\n+            format: FormatSpec {\n+                fill: None,\n+                align: AlignUnknown,\n+                flags: 0,\n+                precision: CountIsParam(10),\n+                width: CountImplied,\n+                precision_span: Some(InnerSpan::new(3, 7)),\n+                width_span: None,\n+                ty: \"x\",\n+                ty_span: None,\n+            },\n+        })],\n+    );\n+    same(\n+        \"{:a$.b$?}\",\n+        &[NextArgument(Argument {\n+            position: ArgumentImplicitlyIs(0),\n+            format: FormatSpec {\n+                fill: None,\n+                align: AlignUnknown,\n+                flags: 0,\n+                precision: CountIsName(\"b\", InnerSpan::new(6, 7)),\n+                width: CountIsName(\"a\", InnerSpan::new(4, 4)),\n+                precision_span: None,\n+                width_span: None,\n+                ty: \"?\",\n+                ty_span: None,\n+            },\n+        })],\n+    );\n }\n #[test]\n fn format_flags() {"}, {"sha": "c266eec25aa6b9a68eb914b43978f417b65cb308", "filename": "compiler/rustc_trait_selection/src/traits/on_unimplemented.rs", "status": "modified", "additions": 61, "deletions": 60, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/d33140d2dc95c33bc8281b476048c923476c8b73/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d33140d2dc95c33bc8281b476048c923476c8b73/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs?ref=d33140d2dc95c33bc8281b476048c923476c8b73", "patch": "@@ -304,42 +304,40 @@ impl<'tcx> OnUnimplementedFormatString {\n             match token {\n                 Piece::String(_) => (), // Normal string, no need to check it\n                 Piece::NextArgument(a) => match a.position {\n-                    // `{Self}` is allowed\n-                    Position::ArgumentNamed(s, _) if s == kw::SelfUpper => (),\n-                    // `{ThisTraitsName}` is allowed\n-                    Position::ArgumentNamed(s, _) if s == trait_name => (),\n-                    // `{from_method}` is allowed\n-                    Position::ArgumentNamed(s, _) if s == sym::from_method => (),\n-                    // `{from_desugaring}` is allowed\n-                    Position::ArgumentNamed(s, _) if s == sym::from_desugaring => (),\n-                    // `{ItemContext}` is allowed\n-                    Position::ArgumentNamed(s, _) if s == sym::ItemContext => (),\n-                    // `{integral}` and `{integer}` and `{float}` are allowed\n-                    Position::ArgumentNamed(s, _)\n-                        if s == sym::integral || s == sym::integer_ || s == sym::float =>\n-                    {\n-                        ()\n-                    }\n-                    // So is `{A}` if A is a type parameter\n                     Position::ArgumentNamed(s, _) => {\n-                        match generics.params.iter().find(|param| param.name == s) {\n-                            Some(_) => (),\n-                            None => {\n-                                let reported = struct_span_err!(\n-                                    tcx.sess,\n-                                    span,\n-                                    E0230,\n-                                    \"there is no parameter `{}` on {}\",\n-                                    s,\n-                                    if trait_def_id == item_def_id {\n-                                        format!(\"trait `{}`\", trait_name)\n-                                    } else {\n-                                        \"impl\".to_string()\n-                                    }\n-                                )\n-                                .emit();\n-                                result = Err(reported);\n-                            }\n+                        match Symbol::intern(s) {\n+                            // `{Self}` is allowed\n+                            kw::SelfUpper => (),\n+                            // `{ThisTraitsName}` is allowed\n+                            s if s == trait_name => (),\n+                            // `{from_method}` is allowed\n+                            sym::from_method => (),\n+                            // `{from_desugaring}` is allowed\n+                            sym::from_desugaring => (),\n+                            // `{ItemContext}` is allowed\n+                            sym::ItemContext => (),\n+                            // `{integral}` and `{integer}` and `{float}` are allowed\n+                            sym::integral | sym::integer_ | sym::float => (),\n+                            // So is `{A}` if A is a type parameter\n+                            s => match generics.params.iter().find(|param| param.name == s) {\n+                                Some(_) => (),\n+                                None => {\n+                                    let reported = struct_span_err!(\n+                                        tcx.sess,\n+                                        span,\n+                                        E0230,\n+                                        \"there is no parameter `{}` on {}\",\n+                                        s,\n+                                        if trait_def_id == item_def_id {\n+                                            format!(\"trait `{}`\", trait_name)\n+                                        } else {\n+                                            \"impl\".to_string()\n+                                        }\n+                                    )\n+                                    .emit();\n+                                    result = Err(reported);\n+                                }\n+                            },\n                         }\n                     }\n                     // `{:1}` and `{}` are not to be used\n@@ -392,34 +390,37 @@ impl<'tcx> OnUnimplementedFormatString {\n             .map(|p| match p {\n                 Piece::String(s) => s,\n                 Piece::NextArgument(a) => match a.position {\n-                    Position::ArgumentNamed(s, _) => match generic_map.get(&s) {\n-                        Some(val) => val,\n-                        None if s == name => &trait_str,\n-                        None => {\n-                            if let Some(val) = options.get(&s) {\n-                                val\n-                            } else if s == sym::from_desugaring || s == sym::from_method {\n-                                // don't break messages using these two arguments incorrectly\n-                                &empty_string\n-                            } else if s == sym::ItemContext {\n-                                &item_context\n-                            } else if s == sym::integral {\n-                                \"{integral}\"\n-                            } else if s == sym::integer_ {\n-                                \"{integer}\"\n-                            } else if s == sym::float {\n-                                \"{float}\"\n-                            } else {\n-                                bug!(\n-                                    \"broken on_unimplemented {:?} for {:?}: \\\n+                    Position::ArgumentNamed(s, _) => {\n+                        let s = Symbol::intern(s);\n+                        match generic_map.get(&s) {\n+                            Some(val) => val,\n+                            None if s == name => &trait_str,\n+                            None => {\n+                                if let Some(val) = options.get(&s) {\n+                                    val\n+                                } else if s == sym::from_desugaring || s == sym::from_method {\n+                                    // don't break messages using these two arguments incorrectly\n+                                    &empty_string\n+                                } else if s == sym::ItemContext {\n+                                    &item_context\n+                                } else if s == sym::integral {\n+                                    \"{integral}\"\n+                                } else if s == sym::integer_ {\n+                                    \"{integer}\"\n+                                } else if s == sym::float {\n+                                    \"{float}\"\n+                                } else {\n+                                    bug!(\n+                                        \"broken on_unimplemented {:?} for {:?}: \\\n                                       no argument matching {:?}\",\n-                                    self.0,\n-                                    trait_ref,\n-                                    s\n-                                )\n+                                        self.0,\n+                                        trait_ref,\n+                                        s\n+                                    )\n+                                }\n                             }\n                         }\n-                    },\n+                    }\n                     _ => bug!(\"broken on_unimplemented {:?} - bad format arg\", self.0),\n                 },\n             })"}, {"sha": "54b93a20a057d9b0fc8171f93afe5b2a7934e404", "filename": "src/tools/clippy/clippy_lints/src/write.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d33140d2dc95c33bc8281b476048c923476c8b73/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d33140d2dc95c33bc8281b476048c923476c8b73/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs?ref=d33140d2dc95c33bc8281b476048c923476c8b73", "patch": "@@ -13,7 +13,7 @@ use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n use rustc_parse::parser;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::symbol::{kw, Symbol};\n-use rustc_span::{sym, BytePos, Span, DUMMY_SP};\n+use rustc_span::{sym, BytePos, InnerSpan, Span, DUMMY_SP};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -454,6 +454,7 @@ impl SimpleFormatArgs {\n                 }\n             },\n             ArgumentNamed(n, _) => {\n+                let n = Symbol::intern(n);\n                 if let Some(x) = self.named.iter_mut().find(|x| x.0 == n) {\n                     match x.1.as_slice() {\n                         // A non-empty format string has been seen already.\n@@ -495,7 +496,7 @@ impl Write {\n             let span = parser\n                 .arg_places\n                 .last()\n-                .map_or(DUMMY_SP, |&x| str_lit.span.from_inner(x));\n+                .map_or(DUMMY_SP, |&x| str_lit.span.from_inner(InnerSpan::new(x.start, x.end)));\n \n             if !self.in_debug_impl && arg.format.ty == \"?\" {\n                 // FIXME: modify rustc's fmt string parser to give us the current span"}]}