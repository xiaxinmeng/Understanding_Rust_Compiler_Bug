{"sha": "83d6be6cecb19659e289eba63f12ac33dceb3b56", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzZDZiZTZjZWNiMTk2NTllMjg5ZWJhNjNmMTJhYzMzZGNlYjNiNTY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-02-23T12:43:45Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-02-23T13:55:18Z"}, "message": "keep-text", "tree": {"sha": "e66750729579dfeba7c2257a65fd29b343b4e403", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e66750729579dfeba7c2257a65fd29b343b4e403"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83d6be6cecb19659e289eba63f12ac33dceb3b56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83d6be6cecb19659e289eba63f12ac33dceb3b56", "html_url": "https://github.com/rust-lang/rust/commit/83d6be6cecb19659e289eba63f12ac33dceb3b56", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83d6be6cecb19659e289eba63f12ac33dceb3b56/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71b8a874e7931e2213e3864e1eae90ceb2551fc2", "url": "https://api.github.com/repos/rust-lang/rust/commits/71b8a874e7931e2213e3864e1eae90ceb2551fc2", "html_url": "https://github.com/rust-lang/rust/commit/71b8a874e7931e2213e3864e1eae90ceb2551fc2"}], "stats": {"total": 27, "additions": 17, "deletions": 10}, "files": [{"sha": "24a043175960c4b3202aa78ca735bcab50e2fe0c", "filename": "crates/ra_mbe/src/syntax_bridge.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/83d6be6cecb19659e289eba63f12ac33dceb3b56/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83d6be6cecb19659e289eba63f12ac33dceb3b56/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs?ref=83d6be6cecb19659e289eba63f12ac33dceb3b56", "patch": "@@ -98,7 +98,7 @@ struct TtTokenSource {\n struct Tok {\n     kind: SyntaxKind,\n     is_joint_to_next: bool,\n-    text: Option<SmolStr>,\n+    text: SmolStr,\n }\n \n impl TtTokenSource {\n@@ -123,27 +123,34 @@ impl TtTokenSource {\n             tt::Leaf::Literal(l) => Tok {\n                 kind: SyntaxKind::INT_NUMBER, // FIXME\n                 is_joint_to_next: false,\n-                text: Some(l.text.clone()),\n+                text: l.text.clone(),\n             },\n             tt::Leaf::Punct(p) => Tok {\n                 kind: SyntaxKind::from_char(p.char).unwrap(),\n                 is_joint_to_next: p.spacing == tt::Spacing::Joint,\n-                text: None,\n+                text: {\n+                    let mut buf = [0u8; 4];\n+                    let s: &str = p.char.encode_utf8(&mut buf);\n+                    SmolStr::new(s)\n+                },\n             },\n             tt::Leaf::Ident(ident) => {\n-                Tok { kind: IDENT, is_joint_to_next: false, text: Some(ident.text.clone()) }\n+                Tok { kind: IDENT, is_joint_to_next: false, text: ident.text.clone() }\n             }\n         };\n         self.tokens.push(tok)\n     }\n     fn push_delim(&mut self, d: tt::Delimiter, closing: bool) {\n-        let kinds = match d {\n-            tt::Delimiter::Parenthesis => [L_PAREN, R_PAREN],\n-            tt::Delimiter::Brace => [L_CURLY, R_CURLY],\n-            tt::Delimiter::Bracket => [L_BRACK, R_BRACK],\n+        let (kinds, texts) = match d {\n+            tt::Delimiter::Parenthesis => ([L_PAREN, R_PAREN], \"()\"),\n+            tt::Delimiter::Brace => ([L_CURLY, R_CURLY], \"{}\"),\n+            tt::Delimiter::Bracket => ([L_BRACK, R_BRACK], \"[]\"),\n             tt::Delimiter::None => return,\n         };\n-        let tok = Tok { kind: kinds[closing as usize], is_joint_to_next: false, text: None };\n+        let idx = closing as usize;\n+        let kind = kinds[idx];\n+        let text = &texts[idx..texts.len() - (1 - idx)];\n+        let tok = Tok { kind, is_joint_to_next: false, text: SmolStr::new(text) };\n         self.tokens.push(tok)\n     }\n }\n@@ -156,6 +163,6 @@ impl TokenSource for TtTokenSource {\n         self.tokens[pos].is_joint_to_next\n     }\n     fn is_keyword(&self, pos: usize, kw: &str) -> bool {\n-        self.tokens[pos].text.as_ref().map(|it| it.as_str()) == Some(kw)\n+        self.tokens[pos].text == *kw\n     }\n }"}]}