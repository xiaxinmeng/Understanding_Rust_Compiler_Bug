{"sha": "c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0YTAzMjgzY2QxN2M4NmM5YmNkYzNmZGM3NmQ5MjRhYjVlYWZmMmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-12T23:07:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-12T23:07:07Z"}, "message": "Auto merge of #45298 - toidiu:ak-44493-infer-predicate, r=nikomatsakis\n\nAk 44493 infer predicate\n\n **WIP**  Implements #44493\n\nThings to do:\n\n- [x] add feature gate and appropriate tests (see [forge](https://forge.rust-lang.org/feature-guide.html) for some details)\n- [x] add a unit testing system similar to `#[rustc_variance]`\n  - [x] to see how, maybe `rg rustc_variance` and take some notes\n- [ ] add more tests:\n- [x] we need to decide how to handle `struct Foo<'a, T> { x: &'a T::Item }`\n- [x] handle explicit predicates on types\n- [ ] handle explicit predicates on `dyn Trait` (this could be put off to a follow-up PR)\n- [ ] handle explicit predicates on projections (this could be put off to a follow-up PR)", "tree": {"sha": "23c1bb1f332df4d34679d76fedacd15541c5556d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23c1bb1f332df4d34679d76fedacd15541c5556d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "html_url": "https://github.com/rust-lang/rust/commit/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c537493d01694cc6e0a614dff12c475055aa2b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c537493d01694cc6e0a614dff12c475055aa2b4", "html_url": "https://github.com/rust-lang/rust/commit/6c537493d01694cc6e0a614dff12c475055aa2b4"}, {"sha": "6a229cbfac2c6ae8e1db4f8ae6320cac731a2c2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a229cbfac2c6ae8e1db4f8ae6320cac731a2c2a", "html_url": "https://github.com/rust-lang/rust/commit/6a229cbfac2c6ae8e1db4f8ae6320cac731a2c2a"}], "stats": {"total": 1436, "additions": 1415, "deletions": 21}, "files": [{"sha": "efbbf22ffe57bbe85e36595fee797dd20509218e", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -83,6 +83,7 @@ __pycache__/\n /src/libstd_unicode/UnicodeData.txt\n /stage[0-9]+/\n /target\n+target/\n /test/\n /tmp/\n TAGS"}, {"sha": "1b90707323850dccd75e9411dd6124a304b84771", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -500,6 +500,7 @@ define_dep_nodes!( <'tcx>\n     [] GenericsOfItem(DefId),\n     [] PredicatesOfItem(DefId),\n     [] InferredOutlivesOf(DefId),\n+    [] InferredOutlivesCrate(CrateNum),\n     [] SuperPredicatesOfItem(DefId),\n     [] TraitDefOfItem(DefId),\n     [] AdtDefOfItem(DefId),"}, {"sha": "41cfac2674be66b4dc358a30515923f777923758", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -1100,6 +1100,20 @@ impl<'a> HashStable<StableHashingContext<'a>> for ty::CrateVariancesMap {\n     }\n }\n \n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for ty::CratePredicatesMap<'gcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let ty::CratePredicatesMap {\n+            ref predicates,\n+            // This is just an irrelevant helper value.\n+            empty_predicate: _,\n+        } = *self;\n+\n+        predicates.hash_stable(hcx, hasher);\n+    }\n+}\n+\n impl_stable_hash_for!(struct ty::AssociatedItem {\n     def_id,\n     name,"}, {"sha": "664c84f5986608ac2e48b2952da6e788ce9ee4bc", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -155,6 +155,12 @@ impl<'tcx> QueryDescription<'tcx> for queries::crate_variances<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription<'tcx> for queries::inferred_outlives_crate<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"computing the inferred outlives predicates for items in this crate\")\n+    }\n+}\n+\n impl<'tcx> QueryDescription<'tcx> for queries::mir_shims<'tcx> {\n     fn describe(tcx: TyCtxt, def: ty::InstanceDef<'tcx>) -> String {\n         format!(\"generating MIR shim for `{}`\","}, {"sha": "4a9a2c4f4adf1713f9f6d8d1cf034cd57e6e9146", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -102,6 +102,7 @@ define_maps! { <'tcx>\n     /// associated generics and predicates.\n     [] fn generics_of: GenericsOfItem(DefId) -> &'tcx ty::Generics,\n     [] fn predicates_of: PredicatesOfItem(DefId) -> ty::GenericPredicates<'tcx>,\n+    [] fn explicit_predicates_of: PredicatesOfItem(DefId) -> ty::GenericPredicates<'tcx>,\n \n     /// Maps from the def-id of a trait to the list of\n     /// super-predicates. This is a subset of the full list of\n@@ -139,7 +140,11 @@ define_maps! { <'tcx>\n     [] fn variances_of: ItemVariances(DefId) -> Lrc<Vec<ty::Variance>>,\n \n     /// Maps from def-id of a type to its (inferred) outlives.\n-    [] fn inferred_outlives_of: InferredOutlivesOf(DefId) -> Vec<ty::Predicate<'tcx>>,\n+    [] fn inferred_outlives_of: InferredOutlivesOf(DefId) -> Lrc<Vec<ty::Predicate<'tcx>>>,\n+\n+    /// Maps from def-id of a type to its (inferred) outlives.\n+    [] fn inferred_outlives_crate: InferredOutlivesCrate(CrateNum)\n+        -> Lrc<ty::CratePredicatesMap<'tcx>>,\n \n     /// Maps from an impl/trait def-id to a list of the def-ids of its items\n     [] fn associated_item_def_ids: AssociatedItemDefIds(DefId) -> Lrc<Vec<DefId>>,"}, {"sha": "efe7a56d8009709f8fdd460f5cdeb08fe49e0afd", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -1007,6 +1007,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::GenericsOfItem => { force!(generics_of, def_id!()); }\n         DepKind::PredicatesOfItem => { force!(predicates_of, def_id!()); }\n         DepKind::InferredOutlivesOf => { force!(inferred_outlives_of, def_id!()); }\n+        DepKind::InferredOutlivesCrate => { force!(inferred_outlives_crate, LOCAL_CRATE); }\n         DepKind::SuperPredicatesOfItem => { force!(super_predicates_of, def_id!()); }\n         DepKind::TraitDefOfItem => { force!(trait_def, def_id!()); }\n         DepKind::AdtDefOfItem => { force!(adt_def, def_id!()); }"}, {"sha": "fccba1e6aa76f470e70f777435c37734d7e9e902", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -956,6 +956,22 @@ pub enum Predicate<'tcx> {\n     ConstEvaluatable(DefId, &'tcx Substs<'tcx>),\n }\n \n+/// The crate outlives map is computed during typeck and contains the\n+/// outlives of every item in the local crate. You should not use it\n+/// directly, because to do so will make your pass dependent on the\n+/// HIR of every item in the local crate. Instead, use\n+/// `tcx.inferred_outlives_of()` to get the outlives for a *particular*\n+/// item.\n+pub struct CratePredicatesMap<'tcx> {\n+    /// For each struct with outlive bounds, maps to a vector of the\n+    /// predicate of its outlive bounds. If an item has no outlives\n+    /// bounds, it will have no entry.\n+    pub predicates: FxHashMap<DefId, Lrc<Vec<ty::Predicate<'tcx>>>>,\n+\n+    /// An empty vector, useful for cloning.\n+    pub empty_predicate: Lrc<Vec<ty::Predicate<'tcx>>>,\n+}\n+\n impl<'tcx> AsRef<Predicate<'tcx>> for Predicate<'tcx> {\n     fn as_ref(&self) -> &Predicate<'tcx> {\n         self"}, {"sha": "e2e6a2d7aac9235a1f676060a01a07d955e302ec", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -64,6 +64,7 @@ pub fn provide(providers: &mut Providers) {\n         type_of,\n         generics_of,\n         predicates_of,\n+        explicit_predicates_of,\n         super_predicates_of,\n         type_param_predicates,\n         trait_def,\n@@ -1296,13 +1297,17 @@ fn predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            def_id: DefId)\n                            -> ty::GenericPredicates<'tcx> {\n     let explicit = explicit_predicates_of(tcx, def_id);\n+    let predicates = if tcx.sess.features_untracked().infer_outlives_requirements {\n+        [&explicit.predicates[..], &tcx.inferred_outlives_of(def_id)[..]].concat()\n+    } else { explicit.predicates };\n+\n     ty::GenericPredicates {\n         parent: explicit.parent,\n-        predicates: [&explicit.predicates[..], &tcx.inferred_outlives_of(def_id)[..]].concat()\n+        predicates: predicates,\n     }\n }\n \n-fn explicit_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn explicit_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            def_id: DefId)\n                            -> ty::GenericPredicates<'tcx> {\n     use rustc::hir::map::*;"}, {"sha": "063d83780d8b908dc0ecdbbcc0396d74fe247727", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -4840,11 +4840,11 @@ register_diagnostics! {\n     E0588, // packed type cannot transitively contain a `[repr(align)]` type\n     E0592, // duplicate definitions with name `{}`\n //  E0613, // Removed (merged with E0609)\n-    E0640, // infer outlives\n     E0627, // yield statement outside of generator literal\n     E0632, // cannot provide explicit type parameters when `impl Trait` is used in\n            // argument position.\n     E0634, // type has conflicting packed representaton hints\n+    E0640, // infer outlives requirements\n     E0641, // cannot cast to/from a pointer with an unknown kind\n     E0645, // trait aliases not finished\n     E0907, // type inside generator must be known in this context"}, {"sha": "a4477e80b988a51003948e8cbdc26e796ab12623", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -82,6 +82,7 @@ This API is completely unstable and subject to change.\n #![feature(slice_patterns)]\n #![feature(slice_sort_by_cached_key)]\n #![feature(dyn_trait)]\n+#![feature(underscore_lifetimes)]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;"}, {"sha": "9a8fd46b0efff2ec27b7abd83d75143a26e4c865", "filename": "src/librustc_typeck/outlives/explicit.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -0,0 +1,82 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use hir::map as hir_map;\n+use rustc::hir;\n+use rustc::hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n+use rustc::ty::maps::Providers;\n+use rustc::ty::{self, CratePredicatesMap, TyCtxt};\n+use rustc_data_structures::sync::Lrc;\n+use util::nodemap::FxHashMap;\n+\n+pub fn explicit_predicates<'tcx>(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    crate_num: CrateNum,\n+) -> FxHashMap<DefId, Lrc<Vec<ty::Predicate<'tcx>>>> {\n+    assert_eq!(crate_num, LOCAL_CRATE);\n+    let mut predicates: FxHashMap<DefId, Lrc<Vec<ty::Predicate<'tcx>>>> = FxHashMap();\n+\n+    // iterate over the entire crate\n+    tcx.hir.krate().visit_all_item_likes(&mut ExplicitVisitor {\n+        tcx: tcx,\n+        explicit_predicates: &mut predicates,\n+        crate_num: crate_num,\n+    });\n+\n+    predicates\n+}\n+\n+pub struct ExplicitVisitor<'cx, 'tcx: 'cx> {\n+    tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n+    explicit_predicates: &'cx mut FxHashMap<DefId, Lrc<Vec<ty::Predicate<'tcx>>>>,\n+    crate_num: CrateNum,\n+}\n+\n+impl<'cx, 'tcx> ItemLikeVisitor<'tcx> for ExplicitVisitor<'cx, 'tcx> {\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+        let def_id = DefId {\n+            krate: self.crate_num,\n+            index: item.hir_id.owner,\n+        };\n+\n+        let local_explicit_predicate = self.tcx.explicit_predicates_of(def_id);\n+\n+        let filtered_predicates = local_explicit_predicate\n+            .predicates\n+            .into_iter()\n+            .filter(|pred| match pred {\n+                ty::Predicate::TypeOutlives(..) | ty::Predicate::RegionOutlives(..) => true,\n+\n+                ty::Predicate::Trait(..)\n+                | ty::Predicate::Projection(..)\n+                | ty::Predicate::WellFormed(..)\n+                | ty::Predicate::ObjectSafe(..)\n+                | ty::Predicate::ClosureKind(..)\n+                | ty::Predicate::Subtype(..)\n+                | ty::Predicate::ConstEvaluatable(..) => false,\n+            })\n+            .collect();\n+\n+        match item.node {\n+            hir::ItemStruct(..) | hir::ItemEnum(..) => {\n+                self.tcx.adt_def(def_id);\n+            }\n+            _ => {}\n+        }\n+\n+        self.explicit_predicates\n+            .insert(def_id, Lrc::new(filtered_predicates));\n+    }\n+\n+    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {}\n+\n+    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {}\n+}"}, {"sha": "b2259c63683c6b98d14a3c3061ca4149b9d6235b", "filename": "src/librustc_typeck/outlives/implicit_empty.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_empty.rs?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use hir::map as hir_map;\n+use rustc::hir;\n+use rustc::hir::def_id::{self, CrateNum, DefId, LOCAL_CRATE};\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n+use rustc::ty::maps::Providers;\n+use rustc::ty::{self, CratePredicatesMap, TyCtxt};\n+use rustc_data_structures::sync::Lrc;\n+use util::nodemap::FxHashMap;\n+\n+// Create the sets of inferred predicates for each type. These sets\n+// are initially empty but will grow during the inference step.\n+pub fn empty_predicate_map<'tcx>(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+) -> FxHashMap<DefId, Lrc<Vec<ty::Predicate<'tcx>>>> {\n+    let mut predicates = FxHashMap();\n+\n+    // iterate over the entire crate\n+    tcx.hir\n+        .krate()\n+        .visit_all_item_likes(&mut EmptyImplicitVisitor {\n+            tcx,\n+            predicates: &mut predicates,\n+        });\n+\n+    predicates\n+}\n+\n+pub struct EmptyImplicitVisitor<'cx, 'tcx: 'cx> {\n+    tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n+    predicates: &'cx mut FxHashMap<DefId, Lrc<Vec<ty::Predicate<'tcx>>>>,\n+}\n+\n+impl<'a, 'p, 'v> ItemLikeVisitor<'v> for EmptyImplicitVisitor<'a, 'p> {\n+    fn visit_item(&mut self, item: &hir::Item) {\n+        self.predicates\n+            .insert(self.tcx.hir.local_def_id(item.id), Lrc::new(Vec::new()));\n+    }\n+\n+    fn visit_trait_item(&mut self, trait_item: &hir::TraitItem) {}\n+\n+    fn visit_impl_item(&mut self, impl_item: &hir::ImplItem) {}\n+}"}, {"sha": "ac53a6d4a3f5f6f3014c6dd40f32821fce0acda5", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "added", "additions": 442, "deletions": 0, "changes": 442, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -0,0 +1,442 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused)]\n+\n+use rustc::hir;\n+use rustc::hir::def::{CtorKind, Def};\n+use rustc::hir::def_id::{self, CrateNum, DefId, LOCAL_CRATE};\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n+use rustc::hir::map as hir_map;\n+use rustc::ty::Slice;\n+use rustc::ty::maps::Providers;\n+use rustc::ty::outlives::Component;\n+use rustc::ty::subst::{Kind, Subst, UnpackedKind};\n+use rustc::ty::{self, AdtKind, CratePredicatesMap, Region, RegionKind, ReprOptions,\n+                ToPolyTraitRef, ToPredicate, Ty, TyCtxt};\n+use rustc::util::nodemap::{FxHashMap, FxHashSet};\n+use rustc_data_structures::sync::Lrc;\n+use syntax::{abi, ast};\n+use syntax_pos::{Span, DUMMY_SP};\n+\n+/// Infer predicates for the items in the crate.\n+///\n+/// global_inferred_outlives: this is initially the empty map that\n+///     was generated by walking the items in the crate. This will\n+///     now be filled with inferred predicates.\n+pub fn infer_predicates<'tcx>(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    explicit_map: &FxHashMap<DefId, Lrc<Vec<ty::Predicate<'tcx>>>>,\n+) -> FxHashMap<DefId, RequiredPredicates<'tcx>> {\n+    debug!(\"infer_predicates\");\n+\n+    let mut predicates_added = true;\n+\n+    let mut global_inferred_outlives = FxHashMap::default();\n+\n+    // If new predicates were added then we need to re-calculate\n+    // all crates since there could be new implied predicates.\n+    while predicates_added {\n+        predicates_added = false;\n+\n+        let mut visitor = InferVisitor {\n+            tcx: tcx,\n+            global_inferred_outlives: &mut global_inferred_outlives,\n+            predicates_added: &mut predicates_added,\n+            explicit_map: explicit_map,\n+        };\n+\n+        // Visit all the crates and infer predicates\n+        tcx.hir.krate().visit_all_item_likes(&mut visitor);\n+    }\n+\n+    global_inferred_outlives\n+}\n+\n+pub struct InferVisitor<'cx, 'tcx: 'cx> {\n+    tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n+    global_inferred_outlives: &'cx mut FxHashMap<DefId, RequiredPredicates<'tcx>>,\n+    predicates_added: &'cx mut bool,\n+    explicit_map: &'cx FxHashMap<DefId, Lrc<Vec<ty::Predicate<'tcx>>>>,\n+}\n+\n+/// Tracks the `T: 'a` or `'a: 'a` predicates that we have inferred\n+/// must be added to the struct header.\n+type RequiredPredicates<'tcx> = FxHashSet<ty::OutlivesPredicate<Kind<'tcx>, ty::Region<'tcx>>>;\n+\n+impl<'cx, 'tcx> ItemLikeVisitor<'tcx> for InferVisitor<'cx, 'tcx> {\n+    fn visit_item(&mut self, item: &hir::Item) {\n+        let item_did = self.tcx.hir.local_def_id(item.id);\n+\n+        debug!(\"InferVisitor::visit_item(item={:?})\", item_did);\n+\n+        let node_id = self.tcx\n+            .hir\n+            .as_local_node_id(item_did)\n+            .expect(\"expected local def-id\");\n+        let item = match self.tcx.hir.get(node_id) {\n+            hir::map::NodeItem(item) => item,\n+            _ => bug!(),\n+        };\n+\n+        let mut item_required_predicates = RequiredPredicates::default();\n+        match item.node {\n+            hir::ItemUnion(..) | hir::ItemEnum(..) | hir::ItemStruct(..) => {\n+                let adt_def = self.tcx.adt_def(item_did);\n+\n+                // Iterate over all fields in item_did\n+                for field_def in adt_def.all_fields() {\n+                    // Calculating the predicate requirements necessary\n+                    // for item_did.\n+                    //\n+                    // For field of type &'a T (reference) or TyAdt\n+                    // (struct/enum/union) there will be outlive\n+                    // requirements for adt_def.\n+                    let field_ty = self.tcx.type_of(field_def.did);\n+                    insert_required_predicates_to_be_wf(\n+                        self.tcx,\n+                        field_ty,\n+                        self.global_inferred_outlives,\n+                        &mut item_required_predicates,\n+                        self.explicit_map,\n+                    );\n+                }\n+            }\n+\n+            _ => {}\n+        };\n+\n+        // If new predicates were added (`local_predicate_map` has more\n+        // predicates than the `global_inferred_outlives`), the new predicates\n+        // might result in implied predicates for their parent types.\n+        // Therefore mark `predicates_added` as true and which will ensure\n+        // we walk the crates again and re-calculate predicates for all\n+        // items.\n+        let item_predicates_len: usize = self.global_inferred_outlives\n+            .get(&item_did)\n+            .map(|p| p.len())\n+            .unwrap_or(0);\n+        if item_required_predicates.len() > item_predicates_len {\n+            *self.predicates_added = true;\n+            self.global_inferred_outlives\n+                .insert(item_did, item_required_predicates);\n+        }\n+    }\n+\n+    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {}\n+\n+    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {}\n+}\n+\n+fn insert_required_predicates_to_be_wf<'tcx>(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    field_ty: Ty<'tcx>,\n+    global_inferred_outlives: &FxHashMap<DefId, RequiredPredicates<'tcx>>,\n+    required_predicates: &mut RequiredPredicates<'tcx>,\n+    explicit_map: &FxHashMap<DefId, Lrc<Vec<ty::Predicate<'tcx>>>>,\n+) {\n+    for ty in field_ty.walk() {\n+        match ty.sty {\n+            // The field is of type &'a T which means that we will have\n+            // a predicate requirement of T: 'a (T outlives 'a).\n+            //\n+            // We also want to calculate potential predicates for the T\n+            ty::TyRef(region, mt) => {\n+                insert_outlives_predicate(tcx, mt.ty.into(), region, required_predicates);\n+            }\n+\n+            // For each TyAdt (struct/enum/union) type `Foo<'a, T>`, we\n+            // can load the current set of inferred and explicit\n+            // predicates from `global_inferred_outlives` and filter the\n+            // ones that are TypeOutlives.\n+            //\n+            ty::TyAdt(def, substs) => {\n+                // First check the inferred predicates\n+                //\n+                // Example 1:\n+                //\n+                //     struct Foo<'a, T> {\n+                //         field1: Bar<'a, T>\n+                //     }\n+                //\n+                //     struct Bar<'b, U> {\n+                //         field2: &'b U\n+                //     }\n+                //\n+                // Here, when processing the type of `field1`, we would\n+                // request the set of implicit predicates computed for `Bar`\n+                // thus far. This will initially come back empty, but in next\n+                // round we will get `U: 'b`. We then apply the substitution\n+                // `['b => 'a, U => T]` and thus get the requirement that `T:\n+                // 'a` holds for `Foo`.\n+                if let Some(unsubstituted_predicates) = global_inferred_outlives.get(&def.did) {\n+                    for unsubstituted_predicate in unsubstituted_predicates {\n+                        // `unsubstituted_predicate` is `U: 'b` in the\n+                        // example above.  So apply the substitution to\n+                        // get `T: 'a` (or `predicate`):\n+                        let predicate = unsubstituted_predicate.subst(tcx, substs);\n+                        insert_outlives_predicate(\n+                            tcx,\n+                            predicate.0,\n+                            predicate.1,\n+                            required_predicates,\n+                        );\n+                    }\n+                }\n+\n+                // Check if the type has any explicit predicates that need\n+                // to be added to `required_predicates`\n+                // let _: () = substs.region_at(0);\n+                check_explicit_predicates(tcx, &def.did, substs, required_predicates, explicit_map);\n+            }\n+\n+            ty::TyDynamic(obj, region) => {\n+                // FIXME This corresponds to `dyn Trait<..>`. In this\n+                // case, we should use the explicit predicates as\n+                // well.\n+                if let Some(p) = obj.principal() {\n+                    check_explicit_predicates(\n+                        tcx,\n+                        &p.skip_binder().def_id,\n+                        &[region.into()],\n+                        required_predicates,\n+                        explicit_map,\n+                    );\n+                }\n+            }\n+\n+            ty::TyProjection(obj) => {\n+                // FIXME This corresponds to `<T as Foo<'a>>::Bar`. In this case, we should use the\n+                // explicit predicates as well.\n+                check_explicit_predicates(\n+                    tcx,\n+                    &obj.item_def_id,\n+                    obj.substs,\n+                    required_predicates,\n+                    explicit_map,\n+                );\n+            }\n+\n+            _ => {}\n+        }\n+    }\n+}\n+\n+/// We also have to check the explicit predicates\n+/// declared on the type.\n+///\n+///     struct Foo<'a, T> {\n+///         field1: Bar<T>\n+///     }\n+///\n+///     struct Bar<U> where U: 'static, U: Foo {\n+///         ...\n+///     }\n+///\n+/// Here, we should fetch the explicit predicates, which\n+/// will give us `U: 'static` and `U: Foo`. The latter we\n+/// can ignore, but we will want to process `U: 'static`,\n+/// applying the substitution as above.\n+fn check_explicit_predicates<'tcx>(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    def_id: &DefId,\n+    substs: &[Kind<'tcx>],\n+    required_predicates: &mut RequiredPredicates<'tcx>,\n+    explicit_map: &FxHashMap<DefId, Lrc<Vec<ty::Predicate<'tcx>>>>,\n+) {\n+    if let Some(general_predicates) = explicit_map.get(def_id) {\n+        for general_predicate in general_predicates.iter() {\n+            match general_predicate {\n+                // `poly` is `PolyTypeOutlivesPredicate<OutlivesPredicate<Ty>>`\n+                // where OutlivesPredicate<type1, region1> is the predicate\n+                // we want to add.\n+                ty::Predicate::TypeOutlives(poly) => {\n+                    let predicate = poly.0.subst(tcx, substs);\n+                    insert_outlives_predicate(\n+                        tcx,\n+                        predicate.0.into(),\n+                        predicate.1,\n+                        required_predicates,\n+                    );\n+                }\n+\n+                // `poly` is `PolyRegionOutlivesPredicate<OutlivesPredicate<Ty>>`\n+                // where OutlivesPredicate<region1, region2> is the predicate\n+                // we want to add.\n+                ty::Predicate::RegionOutlives(poly) => {\n+                    let predicate = poly.0.subst(tcx, substs);\n+                    insert_outlives_predicate(\n+                        tcx,\n+                        predicate.0.into(),\n+                        predicate.1,\n+                        required_predicates,\n+                    );\n+                }\n+\n+                ty::Predicate::Trait(..)\n+                | ty::Predicate::Projection(..)\n+                | ty::Predicate::WellFormed(..)\n+                | ty::Predicate::ObjectSafe(..)\n+                | ty::Predicate::ClosureKind(..)\n+                | ty::Predicate::Subtype(..)\n+                | ty::Predicate::ConstEvaluatable(..) => (),\n+            }\n+        }\n+    }\n+}\n+\n+/// Given a requirement `T: 'a` or `'b: 'a`, deduce the\n+/// outlives_component and add it to `required_predicates`\n+fn insert_outlives_predicate<'tcx>(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    kind: Kind<'tcx>,\n+    outlived_region: Region<'tcx>,\n+    required_predicates: &mut RequiredPredicates<'tcx>,\n+) {\n+    // If the `'a` region is bound within the field type itself, we\n+    // don't want to propagate this constraint to the header.\n+    if !is_free_region(outlived_region) {\n+        return;\n+    }\n+\n+    match kind.unpack() {\n+        UnpackedKind::Type(ty) => {\n+            // `T: 'outlived_region` for some type `T`\n+            // But T could be a lot of things:\n+            // e.g., if `T = &'b u32`, then `'b: 'outlived_region` is\n+            // what we want to add.\n+            //\n+            // Or if within `struct Foo<U>` you had `T = Vec<U>`, then\n+            // we would want to add `U: 'outlived_region`\n+            for component in tcx.outlives_components(ty) {\n+                match component {\n+                    Component::Region(r) => {\n+                        // This would arise from something like:\n+                        //\n+                        // ```\n+                        // struct Foo<'a, 'b> {\n+                        //    x:  &'a &'b u32\n+                        // }\n+                        // ```\n+                        //\n+                        // Here `outlived_region = 'a` and `kind = &'b\n+                        // u32`.  Decomposing `&'b u32` into\n+                        // components would yield `'b`, and we add the\n+                        // where clause that `'b: 'a`.\n+                        insert_outlives_predicate(\n+                            tcx,\n+                            r.into(),\n+                            outlived_region,\n+                            required_predicates,\n+                        );\n+                    }\n+\n+                    Component::Param(param_ty) => {\n+                        // param_ty: ty::ParamTy\n+                        // This would arise from something like:\n+                        //\n+                        // ```\n+                        // struct Foo<'a, U> {\n+                        //    x:  &'a Vec<U>\n+                        // }\n+                        // ```\n+                        //\n+                        // Here `outlived_region = 'a` and `kind =\n+                        // Vec<U>`.  Decomposing `Vec<U>` into\n+                        // components would yield `U`, and we add the\n+                        // where clause that `U: 'a`.\n+                        let ty: Ty<'tcx> = tcx.mk_param(param_ty.idx, param_ty.name);\n+                        required_predicates\n+                            .insert(ty::OutlivesPredicate(ty.into(), outlived_region));\n+                    }\n+\n+                    Component::Projection(proj_ty) => {\n+                        // This would arise from something like:\n+                        //\n+                        // ```\n+                        // struct Foo<'a, T: Iterator> {\n+                        //    x:  &'a <T as Iterator>::Item\n+                        // }\n+                        // ```\n+                        //\n+                        // Here we want to add an explicit `where <T as Iterator>::Item: 'a`.\n+                        let ty: Ty<'tcx> = tcx.mk_projection(proj_ty.item_def_id, proj_ty.substs);\n+                        required_predicates\n+                            .insert(ty::OutlivesPredicate(ty.into(), outlived_region));\n+                    }\n+\n+                    Component::EscapingProjection(_) => {\n+                        // As above, but the projection involves\n+                        // late-bound regions.  Therefore, the WF\n+                        // requirement is not checked in type definition\n+                        // but at fn call site, so ignore it.\n+                        //\n+                        // ```\n+                        // struct Foo<'a, T: Iterator> {\n+                        //    x: for<'b> fn(<&'b T as Iterator>::Item)\n+                        //              //  ^^^^^^^^^^^^^^^^^^^^^^^^^\n+                        // }\n+                        // ```\n+                        //\n+                        // Since `'b` is not in scope on `Foo`, can't\n+                        // do anything here, ignore it.\n+                    }\n+\n+                    Component::UnresolvedInferenceVariable(_) => bug!(\"not using infcx\"),\n+                }\n+            }\n+        }\n+\n+        UnpackedKind::Lifetime(r) => {\n+            if !is_free_region(r) {\n+                return;\n+            }\n+            required_predicates.insert(ty::OutlivesPredicate(kind, outlived_region));\n+        }\n+    }\n+}\n+\n+fn is_free_region(region: Region<'_>) -> bool {\n+    // First, screen for regions that might appear in a type header.\n+    match region {\n+        // *These* correspond to `T: 'a` relationships where `'a` is\n+        // either declared on the type or `'static`:\n+        //\n+        //     struct Foo<'a, T> {\n+        //         field: &'a T, // this would generate a ReEarlyBound referencing `'a`\n+        //         field2: &'static T, // this would generate a ReStatic\n+        //     }\n+        //\n+        // We care about these, so fall through.\n+        RegionKind::ReStatic | RegionKind::ReEarlyBound(_) => true,\n+\n+        // Late-bound regions can appear in `fn` types:\n+        //\n+        //     struct Foo<T> {\n+        //         field: for<'b> fn(&'b T) // e.g., 'b here\n+        //     }\n+        //\n+        // The type above might generate a `T: 'b` bound, but we can\n+        // ignore it.  We can't put it on the struct header anyway.\n+        RegionKind::ReLateBound(..) => false,\n+\n+        // These regions don't appear in types from type declarations:\n+        RegionKind::ReEmpty\n+        | RegionKind::ReErased\n+        | RegionKind::ReClosureBound(..)\n+        | RegionKind::ReCanonical(..)\n+        | RegionKind::ReScope(..)\n+        | RegionKind::ReVar(..)\n+        | RegionKind::ReSkolemized(..)\n+        | RegionKind::ReFree(..) => {\n+            bug!(\"unexpected region in outlives inference: {:?}\", region);\n+        }\n+    }\n+}"}, {"sha": "bad0c68a6fe8e78d5d07444b2e4d53ad7d293821", "filename": "src/librustc_typeck/outlives/mod.rs", "status": "modified", "additions": 89, "deletions": 7, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -7,23 +7,105 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-\n-use rustc::hir::def_id::DefId;\n-use rustc::ty::{self, TyCtxt};\n+#![allow(unused)]\n+#[allow(dead_code)]\n+use hir::map as hir_map;\n+use rustc::dep_graph::DepKind;\n+use rustc::hir;\n+use rustc::hir::Ty_::*;\n+use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::ty::maps::Providers;\n+use rustc::ty::subst::UnpackedKind;\n+use rustc::ty::{self, CratePredicatesMap, TyCtxt};\n+use rustc_data_structures::sync::Lrc;\n+use util::nodemap::FxHashMap;\n \n+mod explicit;\n+mod implicit_empty;\n+mod implicit_infer;\n /// Code to write unit test for outlives.\n pub mod test;\n \n pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n         inferred_outlives_of,\n+        inferred_outlives_crate,\n         ..*providers\n     };\n }\n \n-//todo\n-fn inferred_outlives_of<'a, 'tcx>(_tcx: TyCtxt<'a, 'tcx, 'tcx>, _def_id: DefId)\n-                                  -> Vec<ty::Predicate<'tcx>> {\n-    Vec::new()\n+fn inferred_outlives_of<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    item_def_id: DefId,\n+) -> Lrc<Vec<ty::Predicate<'tcx>>> {\n+    let id = tcx.hir\n+        .as_local_node_id(item_def_id)\n+        .expect(\"expected local def-id\");\n+\n+    match tcx.hir.get(id) {\n+        hir_map::NodeItem(item) => match item.node {\n+            hir::ItemStruct(..) | hir::ItemEnum(..) | hir::ItemUnion(..) => {\n+                let crate_map = tcx.inferred_outlives_crate(LOCAL_CRATE);\n+                let dep_node = item_def_id.to_dep_node(tcx, DepKind::InferredOutlivesOf);\n+                tcx.dep_graph.read(dep_node);\n+\n+                crate_map\n+                    .predicates\n+                    .get(&item_def_id)\n+                    .unwrap_or(&crate_map.empty_predicate)\n+                    .clone()\n+            }\n+\n+            _ => Lrc::new(Vec::new()),\n+        },\n+\n+        _ => Lrc::new(Vec::new()),\n+    }\n+}\n+\n+fn inferred_outlives_crate<'tcx>(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    crate_num: CrateNum,\n+) -> Lrc<CratePredicatesMap<'tcx>> {\n+    // Compute a map from each struct/enum/union S to the **explicit**\n+    // outlives predicates (`T: 'a`, `'a: 'b`) that the user wrote.\n+    // Typically there won't be many of these, except in older code where\n+    // they were mandatory. Nonetheless, we have to ensure that every such\n+    // predicate is satisfied, so they form a kind of base set of requirements\n+    // for the type.\n+\n+    // Compute the inferred predicates\n+    let exp = explicit::explicit_predicates(tcx, crate_num);\n+    let mut global_inferred_outlives = implicit_infer::infer_predicates(tcx, &exp);\n+\n+    // Convert the inferred predicates into the \"collected\" form the\n+    // global data structure expects.\n+    //\n+    // FIXME -- consider correcting impedance mismatch in some way,\n+    // probably by updating the global data structure.\n+    let mut predicates = global_inferred_outlives\n+        .iter()\n+        .map(|(&def_id, set)| {\n+            let vec: Vec<ty::Predicate<'tcx>> = set.iter()\n+                .map(\n+                    |ty::OutlivesPredicate(kind1, region2)| match kind1.unpack() {\n+                        UnpackedKind::Type(ty1) => ty::Predicate::TypeOutlives(ty::Binder(\n+                            ty::OutlivesPredicate(ty1, region2),\n+                        )),\n+                        UnpackedKind::Lifetime(region1) => ty::Predicate::RegionOutlives(\n+                            ty::Binder(ty::OutlivesPredicate(region1, region2)),\n+                        ),\n+                    },\n+                )\n+                .collect();\n+            (def_id, Lrc::new(vec))\n+        })\n+        .collect();\n+\n+    let empty_predicate = Lrc::new(Vec::new());\n+\n+    Lrc::new(ty::CratePredicatesMap {\n+        predicates,\n+        empty_predicate,\n+    })\n }"}, {"sha": "c3c2ae667ddd950afde58bcfee64f07a7828ca0c", "filename": "src/librustc_typeck/outlives/test.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Flibrustc_typeck%2Foutlives%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Flibrustc_typeck%2Foutlives%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Ftest.rs?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -13,11 +13,13 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::ty::TyCtxt;\n \n pub fn test_inferred_outlives<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    tcx.hir.krate().visit_all_item_likes(&mut OutlivesTest { tcx });\n+    tcx.hir\n+        .krate()\n+        .visit_all_item_likes(&mut OutlivesTest { tcx });\n }\n \n struct OutlivesTest<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n impl<'a, 'tcx> ItemLikeVisitor<'tcx> for OutlivesTest<'a, 'tcx> {\n@@ -28,14 +30,16 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for OutlivesTest<'a, 'tcx> {\n         // attribute and report an error with various results if found.\n         if self.tcx.has_attr(item_def_id, \"rustc_outlives\") {\n             let inferred_outlives_of = self.tcx.inferred_outlives_of(item_def_id);\n-            span_err!(self.tcx.sess,\n-                      item.span,\n-                      E0640,\n-                      \"{:?}\",\n-                      inferred_outlives_of);\n+            span_err!(\n+                self.tcx.sess,\n+                item.span,\n+                E0640,\n+                \"{:?}\",\n+                inferred_outlives_of\n+            );\n         }\n     }\n \n-    fn visit_trait_item(&mut self, _: &'tcx hir::TraitItem) { }\n-    fn visit_impl_item(&mut self, _: &'tcx hir::ImplItem) { }\n+    fn visit_trait_item(&mut self, _: &'tcx hir::TraitItem) {}\n+    fn visit_impl_item(&mut self, _: &'tcx hir::ImplItem) {}\n }"}, {"sha": "73ebfc20876d0679814369d4abe88883207d2570", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -426,6 +426,9 @@ declare_features! (\n     // Use `?` as the Kleene \"at most one\" operator\n     (active, macro_at_most_once_rep, \"1.25.0\", Some(48075), None),\n \n+    // Infer outlives requirements; RFC 2093\n+    (active, infer_outlives_requirements, \"1.26.0\", Some(44493), None),\n+\n     // Multiple patterns with `|` in `if let` and `while let`\n     (active, if_while_or_patterns, \"1.26.0\", Some(48215), None),\n \n@@ -1023,6 +1026,12 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n                                  \"never will be stable\",\n                                  cfg_fn!(rustc_attrs))),\n \n+    // RFC #2093\n+    (\"infer_outlives_requirements\", Normal, Gated(Stability::Unstable,\n+                                   \"infer_outlives_requirements\",\n+                                   \"infer outlives requirements is an experimental feature\",\n+                                   cfg_fn!(infer_outlives_requirements))),\n+\n     (\"wasm_custom_section\", Whitelisted, Gated(Stability::Unstable,\n                                  \"wasm_custom_section\",\n                                  \"attribute is currently unstable\","}, {"sha": "5c392223f88b7dccc1a96e105fcd63dc4ac6c8da", "filename": "src/test/compile-fail/outlives-associated-types.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fcompile-fail%2Foutlives-associated-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fcompile-fail%2Foutlives-associated-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foutlives-associated-types.rs?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-tidy-linelength\n+\n // Test that the outlives computation runs for now...\n \n #![feature(rustc_attrs)]\n@@ -16,7 +18,7 @@\n // https://github.com/rust-lang/rfcs/blob/master/text/2093-infer-outlives.md#example-1-a-reference\n \n #[rustc_outlives]\n-struct Direct<'a, T> { //~ ERROR 19:1: 21:2: [] [E0640]\n+struct Direct<'a, T> { //~ ERROR 21:1: 23:2: [Binder(OutlivesPredicate(T, ReEarlyBound(0, 'a)))] [E0640]\n     field: &'a T\n }\n "}, {"sha": "01ccc50a130f2a56b976bf16a6f1f8c8a9d58e45", "filename": "src/test/ui/feature-gate-infer_outlives_requirements.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Ffeature-gate-infer_outlives_requirements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Ffeature-gate-infer_outlives_requirements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-infer_outlives_requirements.rs?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Needs an explicit where clause stating outlives condition. (RFC 2093)\n+\n+// Type T needs to outlive lifetime 'a.\n+struct Foo<'a, T> {\n+    bar: &'a [T] //~ ERROR the parameter type `T` may not live long enough [E0309]\n+}\n+\n+fn main() { }"}, {"sha": "560e494b5828dec66e2a5705001b090911c8146e", "filename": "src/test/ui/feature-gate-infer_outlives_requirements.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Ffeature-gate-infer_outlives_requirements.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Ffeature-gate-infer_outlives_requirements.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-infer_outlives_requirements.stderr?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -0,0 +1,17 @@\n+error[E0309]: the parameter type `T` may not live long enough\n+  --> $DIR/feature-gate-infer_outlives_requirements.rs:15:5\n+   |\n+LL | struct Foo<'a, T> {\n+   |                - help: consider adding an explicit lifetime bound `T: 'a`...\n+LL |     bar: &'a [T] //~ ERROR the parameter type `T` may not live long enough [E0309]\n+   |     ^^^^^^^^^^^^\n+   |\n+note: ...so that the reference type `&'a [T]` does not outlive the data it points at\n+  --> $DIR/feature-gate-infer_outlives_requirements.rs:15:5\n+   |\n+LL |     bar: &'a [T] //~ ERROR the parameter type `T` may not live long enough [E0309]\n+   |     ^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0309`."}, {"sha": "8c7275bb1a7e4d3c48e129bd39750153ff2adedd", "filename": "src/test/ui/rfc-2093-infer-outlives/enum-pass.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fenum-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fenum-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fenum-pass.rs?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// must-compile-successfully\n+\n+#![feature(infer_outlives_requirements)]\n+\n+// Type T needs to outlive lifetime 'a.\n+enum Foo<'a, T> {\n+\n+    One(Bar<'a, T>)\n+}\n+\n+// Type U needs to outlive lifetime 'b\n+struct Bar<'b, U> {\n+    field2: &'b U\n+}\n+\n+\n+\n+// Type K needs to outlive lifetime 'c.\n+enum Ying<'c, K> {\n+    One(&'c Yang<K>)\n+}\n+\n+struct Yang<V> {\n+    field2: V\n+}\n+\n+fn main() {}\n+"}, {"sha": "7d0427adb9f3e016b97aacdea78524ff14aff984", "filename": "src/test/ui/rfc-2093-infer-outlives/enum.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fenum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fenum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fenum.rs?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+\n+// Needs an explicit where clause stating outlives condition. (RFC 2093)\n+\n+// Type T needs to outlive lifetime 'a.\n+enum Foo<'a, T> {\n+\n+    One(Bar<'a, T>)\n+}\n+\n+// Type U needs to outlive lifetime 'b\n+struct Bar<'b, U> {\n+    field2: &'b U //~ ERROR 23:5: 23:18: the parameter type `U` may not live long enough [E0309]\n+}\n+\n+\n+\n+// Type K needs to outlive lifetime 'c.\n+enum Ying<'c, K> {\n+    One(&'c Yang<K>) //~ ERROR 30:9: 30:21: the parameter type `K` may not live long enough [E0309]\n+}\n+\n+struct Yang<V> {\n+    field2: V\n+}\n+\n+fn main() {}"}, {"sha": "e6eaf9b47545037b024c681de9bda55a3fe2753e", "filename": "src/test/ui/rfc-2093-infer-outlives/enum.stderr", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fenum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fenum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fenum.stderr?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -0,0 +1,31 @@\n+error[E0309]: the parameter type `U` may not live long enough\n+  --> $DIR/enum.rs:23:5\n+   |\n+LL | struct Bar<'b, U> {\n+   |                - help: consider adding an explicit lifetime bound `U: 'b`...\n+LL |     field2: &'b U //~ ERROR 23:5: 23:18: the parameter type `U` may not live long enough [E0309]\n+   |     ^^^^^^^^^^^^^\n+   |\n+note: ...so that the reference type `&'b U` does not outlive the data it points at\n+  --> $DIR/enum.rs:23:5\n+   |\n+LL |     field2: &'b U //~ ERROR 23:5: 23:18: the parameter type `U` may not live long enough [E0309]\n+   |     ^^^^^^^^^^^^^\n+\n+error[E0309]: the parameter type `K` may not live long enough\n+  --> $DIR/enum.rs:30:9\n+   |\n+LL | enum Ying<'c, K> {\n+   |               - help: consider adding an explicit lifetime bound `K: 'c`...\n+LL |     One(&'c Yang<K>) //~ ERROR 30:9: 30:21: the parameter type `K` may not live long enough [E0309]\n+   |         ^^^^^^^^^^^^\n+   |\n+note: ...so that the reference type `&'c Yang<K>` does not outlive the data it points at\n+  --> $DIR/enum.rs:30:9\n+   |\n+LL |     One(&'c Yang<K>) //~ ERROR 30:9: 30:21: the parameter type `K` may not live long enough [E0309]\n+   |         ^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0309`."}, {"sha": "da578386adb14884756d466da7ebad97f5f6ce6e", "filename": "src/test/ui/rfc-2093-infer-outlives/explicit-impl-lifetime-pass.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-impl-lifetime-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-impl-lifetime-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-impl-lifetime-pass.rs?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-test\n+// must-compile-successfully\n+\n+#![feature(infer_outlives_requirements)]\n+// Outlives requirementes are inferred (RFC 2093)\n+\n+trait MakeRef<'a>: 'a {\n+    type Type;\n+}\n+impl<'a, T> MakeRef<'a> for Vec<T>\n+where T: 'a,\n+{\n+    type Type = &'a T;\n+}\n+// explicit-impl: T: 'a\n+struct Foo<'a, T> {\n+    foo: <Vec<T> as MakeRef<'a>>::Type,\n+}\n+\n+fn main() {}"}, {"sha": "fd74fe30bb6b081e810c491d25d92afe93d4ecb2", "filename": "src/test/ui/rfc-2093-infer-outlives/explicit-impl-pass.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-impl-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-impl-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-impl-pass.rs?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-test\n+// must-compile-successfully\n+\n+#![feature(infer_outlives_requirements)]\n+// Outlives requirementes are inferred (RFC 2093)\n+\n+trait MakeRef<'a> {\n+    type Type;\n+}\n+impl<'a, T> MakeRef<'a> for Vec<T>\n+where T: 'a,\n+{\n+    type Type = &'a T;\n+}\n+// explicit-impl: T: 'a\n+struct Foo<'a, T> {\n+    foo: <Vec<T> as MakeRef<'a>>::Type,\n+}\n+\n+fn main() {}"}, {"sha": "3a10087551c4e8c2295957f5a10fc6c390204ef3", "filename": "src/test/ui/rfc-2093-infer-outlives/explicit-impl.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-impl.rs?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+\n+// Needs an explicit where clause stating outlives condition. (RFC 2093)\n+\n+trait MakeRef<'a> {\n+    type Type;\n+}\n+\n+impl<'a, T> MakeRef<'a> for Vec<T>\n+  where T: 'a\n+{\n+    type Type = &'a T;\n+}\n+\n+// Type T needs to outlive lifetime 'a, as stated in impl.\n+struct Foo<'a, T> {\n+    foo: <Vec<T> as MakeRef<'a>>::Type //~ Error the parameter type `T` may not live long enough [E0309]\n+}\n+\n+fn main() { }"}, {"sha": "498d66ef9a542be9a580f6f0b01d919d5e935bba", "filename": "src/test/ui/rfc-2093-infer-outlives/explicit-impl.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-impl.stderr?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -0,0 +1,17 @@\n+error[E0309]: the parameter type `T` may not live long enough\n+  --> $DIR/explicit-impl.rs:27:5\n+   |\n+LL | struct Foo<'a, T> {\n+   |                - help: consider adding an explicit lifetime bound `T: 'a`...\n+LL |     foo: <Vec<T> as MakeRef<'a>>::Type //~ Error the parameter type `T` may not live long enough [E0309]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: ...so that the type `T` will meet its required lifetime bounds\n+  --> $DIR/explicit-impl.rs:27:5\n+   |\n+LL |     foo: <Vec<T> as MakeRef<'a>>::Type //~ Error the parameter type `T` may not live long enough [E0309]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0309`."}, {"sha": "e51b5a16b4501abe0a6ff039600420a8237a6edf", "filename": "src/test/ui/rfc-2093-infer-outlives/explicit-where-pass.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-where-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-where-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-where-pass.rs?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// must-compile-successfully\n+\n+#![feature(infer_outlives_requirements)]\n+// Outlives requirementes are inferred (RFC 2093)\n+\n+// explicit-where: infer U: 'b\n+struct ExFoo<'b, U> {\n+    bar: ExBar<'b, U>\n+}\n+struct ExBar<'a, T> where T: 'a {\n+    x: &'a (),\n+    y: T,\n+}\n+\n+\n+fn main() {}\n+"}, {"sha": "81734bf514ef3e214bba2e3ce2d3e9f69b149a91", "filename": "src/test/ui/rfc-2093-infer-outlives/explicit-where.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-where.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-where.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-where.rs?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Needs an explicit where clause stating outlives condition. (RFC 2093)\n+\n+// Type U needs to outlive lifetime 'b.\n+struct Foo<'b, U> {\n+    bar: Bar<'b, U> //~ Error the parameter type `U` may not live long enough [E0309]\n+}\n+\n+struct Bar<'a, T> where T: 'a {\n+    x: &'a (),\n+    y: T,\n+}\n+\n+fn main() { }"}, {"sha": "436754c7dc1cd1235ac9afc63b5f4d2c24cc38e2", "filename": "src/test/ui/rfc-2093-infer-outlives/explicit-where.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-where.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-where.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-where.stderr?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -0,0 +1,17 @@\n+error[E0309]: the parameter type `U` may not live long enough\n+  --> $DIR/explicit-where.rs:15:5\n+   |\n+LL | struct Foo<'b, U> {\n+   |                - help: consider adding an explicit lifetime bound `U: 'b`...\n+LL |     bar: Bar<'b, U> //~ Error the parameter type `U` may not live long enough [E0309]\n+   |     ^^^^^^^^^^^^^^^\n+   |\n+note: ...so that the type `U` will meet its required lifetime bounds\n+  --> $DIR/explicit-where.rs:15:5\n+   |\n+LL |     bar: Bar<'b, U> //~ Error the parameter type `U` may not live long enough [E0309]\n+   |     ^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0309`."}, {"sha": "be686a8004825c3f15ccbbcf51a266be1410b7fe", "filename": "src/test/ui/rfc-2093-infer-outlives/multiple-regions-pass.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fmultiple-regions-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fmultiple-regions-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fmultiple-regions-pass.rs?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// must-compile-successfully\n+\n+#![feature(infer_outlives_requirements)]\n+// Outlives requirementes are inferred (RFC 2093)\n+\n+// multiple-regions: infer 'b: 'a\n+struct MultiFoo<'a, 'b, T> {\n+    x: &'a &'b T\n+}\n+\n+fn main() {}\n+"}, {"sha": "7ea1ce2d3dc1baa5871b0a3dc6449b9493c3b9a3", "filename": "src/test/ui/rfc-2093-infer-outlives/multiple-regions.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fmultiple-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fmultiple-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fmultiple-regions.rs?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Needs an explicit where clause stating outlives condition. (RFC 2093)\n+\n+// Lifetime 'b needs to outlive lifetime 'a\n+struct Foo<'a,'b,T> {\n+    x: &'a &'b T //~ ERROR reference has a longer lifetime than the data it references [E0491]\n+}\n+\n+fn main() {}\n+"}, {"sha": "3722abd5ad6484b0f3049bc7ad763d13ceb9d787", "filename": "src/test/ui/rfc-2093-infer-outlives/multiple-regions.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fmultiple-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fmultiple-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fmultiple-regions.stderr?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -0,0 +1,20 @@\n+error[E0491]: in type `&'a &'b T`, reference has a longer lifetime than the data it references\n+  --> $DIR/multiple-regions.rs:15:5\n+   |\n+LL |     x: &'a &'b T //~ ERROR reference has a longer lifetime than the data it references [E0491]\n+   |     ^^^^^^^^^^^^\n+   |\n+note: the pointer is valid for the lifetime 'a as defined on the struct at 14:1\n+  --> $DIR/multiple-regions.rs:14:1\n+   |\n+LL | struct Foo<'a,'b,T> {\n+   | ^^^^^^^^^^^^^^^^^^^\n+note: but the referenced data is only valid for the lifetime 'b as defined on the struct at 14:1\n+  --> $DIR/multiple-regions.rs:14:1\n+   |\n+LL | struct Foo<'a,'b,T> {\n+   | ^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0491`."}, {"sha": "02581457fcc52b187065a4aaa6f02ec785c82d67", "filename": "src/test/ui/rfc-2093-infer-outlives/nested-structs-pass.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-structs-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-structs-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-structs-pass.rs?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// must-compile-successfully\n+\n+#![feature(infer_outlives_requirements)]\n+// Outlives requirementes are inferred (RFC 2093)\n+\n+// nested-structs: infer U: 'b and therefore T: 'a\n+struct NestFoo<'a, T> {\n+    field1: NestBar<'a, T>\n+}\n+struct NestBar<'b, U> {\n+    field2: &'b U\n+}\n+\n+fn main() {}\n+"}, {"sha": "7c444dbd3b011e1a72609499c73ef1a5730a0a73", "filename": "src/test/ui/rfc-2093-infer-outlives/nested-structs.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-structs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-structs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-structs.rs?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Needs an explicit where clause stating outlives condition. (RFC 2093)\n+\n+\n+// Type T needs to outlive lifetime 'a. This is not reported due to\n+// a compilation error in Bar.\n+struct Foo<'a, T> {\n+    field1: Bar<'a, T>\n+}\n+\n+// Type U needs to outlive lifetime 'b\n+struct Bar<'b, U> {\n+    field2: &'b U //~ ERROR the parameter type `U` may not live long enough [E0309]\n+}\n+\n+fn main() {}\n+"}, {"sha": "94d6cbdb5fe84261828df1496a15d4c4af6c1beb", "filename": "src/test/ui/rfc-2093-infer-outlives/nested-structs.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-structs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-structs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-structs.stderr?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -0,0 +1,17 @@\n+error[E0309]: the parameter type `U` may not live long enough\n+  --> $DIR/nested-structs.rs:22:5\n+   |\n+LL | struct Bar<'b, U> {\n+   |                - help: consider adding an explicit lifetime bound `U: 'b`...\n+LL |     field2: &'b U //~ ERROR the parameter type `U` may not live long enough [E0309]\n+   |     ^^^^^^^^^^^^^\n+   |\n+note: ...so that the reference type `&'b U` does not outlive the data it points at\n+  --> $DIR/nested-structs.rs:22:5\n+   |\n+LL |     field2: &'b U //~ ERROR the parameter type `U` may not live long enough [E0309]\n+   |     ^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0309`."}, {"sha": "1234e27b866bc248de8d60fa423fdfb29a6c6dc0", "filename": "src/test/ui/rfc-2093-infer-outlives/projections-pass.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fprojections-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fprojections-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fprojections-pass.rs?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// must-compile-successfully\n+\n+#![feature(infer_outlives_requirements)]\n+// Outlives requirementes are inferred (RFC 2093)\n+\n+// projections: infer <Iterator>::Item: 'a\n+struct ProjFoo<'a, T: Iterator> {\n+    bar: &'a T::Item\n+}\n+\n+\n+fn main() {}\n+"}, {"sha": "f6a557c174c19115da92b32465c6e1037e003561", "filename": "src/test/ui/rfc-2093-infer-outlives/projections.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fprojections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fprojections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fprojections.rs?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+\n+// Needs an explicit where clause stating outlives condition. RFC 2093\n+\n+// Associated type <Iterator>::Item  needs to outlives lifetime 'a.\n+struct Foo<'a, T: Iterator> {\n+    bar: &'a T::Item //~ Error the associated type `<T as std::iter::Iterator>::Item` may not live long enough [E0309]\n+}\n+\n+fn main() { }"}, {"sha": "9969cf48ecd3b735aa9ca00f2cdcf20078fbf7cf", "filename": "src/test/ui/rfc-2093-infer-outlives/projections.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fprojections.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fprojections.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fprojections.stderr?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -0,0 +1,16 @@\n+error[E0309]: the associated type `<T as std::iter::Iterator>::Item` may not live long enough\n+  --> $DIR/projections.rs:17:5\n+   |\n+LL |     bar: &'a T::Item //~ Error the associated type `<T as std::iter::Iterator>::Item` may not live long enough [E0309]\n+   |     ^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `<T as std::iter::Iterator>::Item: 'a`...\n+note: ...so that the reference type `&'a <T as std::iter::Iterator>::Item` does not outlive the data it points at\n+  --> $DIR/projections.rs:17:5\n+   |\n+LL |     bar: &'a T::Item //~ Error the associated type `<T as std::iter::Iterator>::Item` may not live long enough [E0309]\n+   |     ^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0309`."}, {"sha": "f357685e1399f4faa2fea4fd0ff56d2f40d100ac", "filename": "src/test/ui/rfc-2093-infer-outlives/reference-pass.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Freference-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Freference-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Freference-pass.rs?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// must-compile-successfully\n+\n+#![feature(infer_outlives_requirements)]\n+// Outlives requirementes are inferred (RFC 2093)\n+\n+// reference: infer T: 'a\n+struct RefFoo<'a, T> {\n+    bar: &'a [T]\n+}\n+\n+\n+fn main() {}\n+"}, {"sha": "01ccc50a130f2a56b976bf16a6f1f8c8a9d58e45", "filename": "src/test/ui/rfc-2093-infer-outlives/reference.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Freference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Freference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Freference.rs?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Needs an explicit where clause stating outlives condition. (RFC 2093)\n+\n+// Type T needs to outlive lifetime 'a.\n+struct Foo<'a, T> {\n+    bar: &'a [T] //~ ERROR the parameter type `T` may not live long enough [E0309]\n+}\n+\n+fn main() { }"}, {"sha": "7236bd535c9f2922639241279d96fd6b0c68ff83", "filename": "src/test/ui/rfc-2093-infer-outlives/reference.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Freference.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Freference.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Freference.stderr?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -0,0 +1,17 @@\n+error[E0309]: the parameter type `T` may not live long enough\n+  --> $DIR/reference.rs:15:5\n+   |\n+LL | struct Foo<'a, T> {\n+   |                - help: consider adding an explicit lifetime bound `T: 'a`...\n+LL |     bar: &'a [T] //~ ERROR the parameter type `T` may not live long enough [E0309]\n+   |     ^^^^^^^^^^^^\n+   |\n+note: ...so that the reference type `&'a [T]` does not outlive the data it points at\n+  --> $DIR/reference.rs:15:5\n+   |\n+LL |     bar: &'a [T] //~ ERROR the parameter type `T` may not live long enough [E0309]\n+   |     ^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0309`."}, {"sha": "b4a61346b011b1873e8b96820d003b4d9814c488", "filename": "src/test/ui/rfc-2093-infer-outlives/union-pass.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Funion-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Funion-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Funion-pass.rs?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// must-compile-successfully\n+\n+#![feature(infer_outlives_requirements)]\n+#![feature(untagged_unions)]\n+#![allow(unions_with_drop_fields)]\n+\n+// Type T needs to outlive lifetime 'a. This is not reported due to\n+// a compilation error in Bar.\n+union Foo<'a, T> {\n+    field1: Bar<'a, T>\n+}\n+\n+// Type U needs to outlive lifetime 'b\n+union Bar<'b, U> {\n+    field2: &'b U\n+}\n+\n+\n+// Type K needs to outlive lifetime 'c.\n+union Ying<'c, K> {\n+    field1: &'c Yang<K>\n+}\n+\n+union Yang<V> {\n+    field2: V\n+}\n+\n+fn main() {}\n+"}, {"sha": "36b1dccb13ebb7907daa8e2f08c422fe8975aa18", "filename": "src/test/ui/rfc-2093-infer-outlives/union.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Funion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Funion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Funion.rs?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+\n+// Needs an explicit where clause stating outlives condition. (RFC 2093)\n+\n+#![feature(untagged_unions)]\n+\n+// Type T needs to outlive lifetime 'a. This is not reported due to\n+// a compilation error in Bar.\n+union Foo<'a, T> {\n+    field1: Bar<'a, T>\n+}\n+\n+// Type U needs to outlive lifetime 'b\n+union Bar<'b, U> {\n+    field2: &'b U //~ ERROR 25:5: 25:18: the parameter type `U` may not live long enough [E0309]\n+}\n+\n+\n+// Type K needs to outlive lifetime 'c.\n+union Ying<'c, K> {\n+    field1: &'c Yang<K> //~ ERROR 31:5: 31:24: the parameter type `K` may not live long enough [E0309]\n+}\n+\n+union Yang<V> {\n+    field2: V\n+}\n+\n+\n+fn main() {}\n+"}, {"sha": "cd13c423293329c9730d8b785e53a8e86881d51b", "filename": "src/test/ui/rfc-2093-infer-outlives/union.stderr", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Funion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Funion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Funion.stderr?ref=c4a03283cd17c86c9bcdc3fdc76d924ab5eaff2a", "patch": "@@ -0,0 +1,31 @@\n+error[E0309]: the parameter type `U` may not live long enough\n+  --> $DIR/union.rs:25:5\n+   |\n+LL | union Bar<'b, U> {\n+   |               - help: consider adding an explicit lifetime bound `U: 'b`...\n+LL |     field2: &'b U //~ ERROR 25:5: 25:18: the parameter type `U` may not live long enough [E0309]\n+   |     ^^^^^^^^^^^^^\n+   |\n+note: ...so that the reference type `&'b U` does not outlive the data it points at\n+  --> $DIR/union.rs:25:5\n+   |\n+LL |     field2: &'b U //~ ERROR 25:5: 25:18: the parameter type `U` may not live long enough [E0309]\n+   |     ^^^^^^^^^^^^^\n+\n+error[E0309]: the parameter type `K` may not live long enough\n+  --> $DIR/union.rs:31:5\n+   |\n+LL | union Ying<'c, K> {\n+   |                - help: consider adding an explicit lifetime bound `K: 'c`...\n+LL |     field1: &'c Yang<K> //~ ERROR 31:5: 31:24: the parameter type `K` may not live long enough [E0309]\n+   |     ^^^^^^^^^^^^^^^^^^^\n+   |\n+note: ...so that the reference type `&'c Yang<K>` does not outlive the data it points at\n+  --> $DIR/union.rs:31:5\n+   |\n+LL |     field1: &'c Yang<K> //~ ERROR 31:5: 31:24: the parameter type `K` may not live long enough [E0309]\n+   |     ^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0309`."}]}