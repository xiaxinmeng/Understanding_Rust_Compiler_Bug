{"sha": "4c39962d325c09849e9cbb1828f85028f29fcea3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjMzk5NjJkMzI1YzA5ODQ5ZTljYmIxODI4Zjg1MDI4ZjI5ZmNlYTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-22T00:01:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-22T00:01:34Z"}, "message": "auto merge of #15005 : dotdash/rust/i1_bool, r=alexcrichton\n\nWe currently compiled bools to i8 values, because there was a bug in\r\nLLVM that sometimes caused miscompilations when using i1 in, for\r\nexample, structs.\r\n\r\nUsing i8 means a lot of unnecessary zero-extend and truncate operations\r\nthough, since we have to convert the value from and to i1 when using for\r\nexample icmp or br instructions. Besides the unnecessary overhead caused\r\nby this, it also sometimes made LLVM miss some optimizations.\r\n\r\nFirst, we have to fix some bugs concerning the handling of\r\nattributes in foreign function declarations and calls. These\r\nare required because the i1 type needs the ZExt attribute when\r\nused as a function parameter or return type.\r\n\r\nThen we have to update LLVM to get a bugfix without which LLVM\r\nsometimes generates broken code when using i1.\r\n\r\nAnd then, finally, we can switch bools over to i1.", "tree": {"sha": "00465a2053409f3dee73d6daaf16e586cdd5fd46", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00465a2053409f3dee73d6daaf16e586cdd5fd46"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c39962d325c09849e9cbb1828f85028f29fcea3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c39962d325c09849e9cbb1828f85028f29fcea3", "html_url": "https://github.com/rust-lang/rust/commit/4c39962d325c09849e9cbb1828f85028f29fcea3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c39962d325c09849e9cbb1828f85028f29fcea3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db9af1d505809c965e719bf4ad775ff984ee3da6", "url": "https://api.github.com/repos/rust-lang/rust/commits/db9af1d505809c965e719bf4ad775ff984ee3da6", "html_url": "https://github.com/rust-lang/rust/commit/db9af1d505809c965e719bf4ad775ff984ee3da6"}, {"sha": "d747de5a927e405c7d12ae04d213bdc05add2032", "url": "https://api.github.com/repos/rust-lang/rust/commits/d747de5a927e405c7d12ae04d213bdc05add2032", "html_url": "https://github.com/rust-lang/rust/commit/d747de5a927e405c7d12ae04d213bdc05add2032"}], "stats": {"total": 254, "additions": 155, "deletions": 99}, "files": [{"sha": "5fae1635bee8e491dc458670c6856a41a0aa6213", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4c39962d325c09849e9cbb1828f85028f29fcea3/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c39962d325c09849e9cbb1828f85028f29fcea3/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=4c39962d325c09849e9cbb1828f85028f29fcea3", "patch": "@@ -1200,8 +1200,6 @@ fn pick_col(m: &[Match]) -> uint {\n pub enum branch_kind { no_branch, single, switch, compare, compare_vec_len, }\n \n // Compiles a comparison between two things.\n-//\n-// NB: This must produce an i1, not a Rust bool (i8).\n fn compare_values<'a>(\n                   cx: &'a Block<'a>,\n                   lhs: ValueRef,\n@@ -1218,11 +1216,7 @@ fn compare_values<'a>(\n                            format!(\"comparison of `{}`\",\n                                    cx.ty_to_str(rhs_t)).as_slice(),\n                            StrEqFnLangItem);\n-        let result = callee::trans_lang_call(cx, did, [lhs, rhs], None);\n-        Result {\n-            bcx: result.bcx,\n-            val: bool_to_i1(result.bcx, result.val)\n-        }\n+        callee::trans_lang_call(cx, did, [lhs, rhs], None)\n     }\n \n     let _icx = push_ctxt(\"compare_values\");\n@@ -1243,11 +1237,7 @@ fn compare_values<'a>(\n                                    format!(\"comparison of `{}`\",\n                                            cx.ty_to_str(rhs_t)).as_slice(),\n                                    UniqStrEqFnLangItem);\n-                let result = callee::trans_lang_call(cx, did, [scratch_lhs, scratch_rhs], None);\n-                Result {\n-                    bcx: result.bcx,\n-                    val: bool_to_i1(result.bcx, result.val)\n-                }\n+                callee::trans_lang_call(cx, did, [scratch_lhs, scratch_rhs], None)\n             }\n             _ => cx.sess().bug(\"only strings supported in compare_values\"),\n         },"}, {"sha": "da49c7764ce535604d2fc38093007a2419ea5a51", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4c39962d325c09849e9cbb1828f85028f29fcea3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c39962d325c09849e9cbb1828f85028f29fcea3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=4c39962d325c09849e9cbb1828f85028f29fcea3", "patch": "@@ -501,7 +501,6 @@ pub fn maybe_name_value(cx: &CrateContext, v: ValueRef, s: &str) {\n // Used only for creating scalar comparison glue.\n pub enum scalar_type { nil_type, signed_int, unsigned_int, floating_point, }\n \n-// NB: This produces an i1, not a Rust bool (i8).\n pub fn compare_scalar_types<'a>(\n                             cx: &'a Block<'a>,\n                             lhs: ValueRef,\n@@ -1815,6 +1814,13 @@ pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t) -> Vec<(uint, u6\n             }\n             _ => {}\n         }\n+\n+        match ty::get(ret_ty).sty {\n+            ty::ty_bool => {\n+                attrs.push((lib::llvm::ReturnIndex as uint, lib::llvm::ZExtAttribute as u64));\n+            }\n+            _ => {}\n+        }\n     }\n \n     for (idx, &t) in fn_sig.inputs.iter().enumerate().map(|(i, v)| (i + first_arg_offset, v)) {\n@@ -1828,6 +1834,9 @@ pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t) -> Vec<(uint, u6\n                 attrs.push((idx, lib::llvm::NoCaptureAttribute as u64));\n                 attrs.push((idx, lib::llvm::NonNullAttribute as u64));\n             }\n+            ty::ty_bool => {\n+                attrs.push((idx, lib::llvm::ZExtAttribute as u64));\n+            }\n             // `~` pointer parameters never alias because ownership is transferred\n             ty::ty_uniq(_) => {\n                 attrs.push((idx, lib::llvm::NoAliasAttribute as u64));"}, {"sha": "01bef64ebba642bf1fa0347de358191b179049eb", "filename": "src/librustc/middle/trans/cabi_arm.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4c39962d325c09849e9cbb1828f85028f29fcea3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c39962d325c09849e9cbb1828f85028f29fcea3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs?ref=4c39962d325c09849e9cbb1828f85028f29fcea3", "patch": "@@ -11,7 +11,7 @@\n #![allow(non_uppercase_pattern_statics)]\n \n use lib::llvm::{llvm, Integer, Pointer, Float, Double, Struct, Array};\n-use lib::llvm::StructRetAttribute;\n+use lib::llvm::{StructRetAttribute, ZExtAttribute};\n use middle::trans::cabi::{FnType, ArgType};\n use middle::trans::context::CrateContext;\n use middle::trans::type_::Type;\n@@ -85,7 +85,8 @@ fn ty_size(ty: Type) -> uint {\n \n fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n     if is_reg_ty(ty) {\n-        return ArgType::direct(ty, None, None, None);\n+        let attr = if ty == Type::bool(ccx) { Some(ZExtAttribute) } else { None };\n+        return ArgType::direct(ty, None, None, attr);\n     }\n     let size = ty_size(ty);\n     if size <= 4 {\n@@ -103,7 +104,8 @@ fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n \n fn classify_arg_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n     if is_reg_ty(ty) {\n-        return ArgType::direct(ty, None, None, None);\n+        let attr = if ty == Type::bool(ccx) { Some(ZExtAttribute) } else { None };\n+        return ArgType::direct(ty, None, None, attr);\n     }\n     let align = ty_align(ty);\n     let size = ty_size(ty);"}, {"sha": "60db609e59ed184cc9b7eac69e711be04643296f", "filename": "src/librustc/middle/trans/cabi_mips.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4c39962d325c09849e9cbb1828f85028f29fcea3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c39962d325c09849e9cbb1828f85028f29fcea3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs?ref=4c39962d325c09849e9cbb1828f85028f29fcea3", "patch": "@@ -13,7 +13,7 @@\n use libc::c_uint;\n use std::cmp;\n use lib::llvm::{llvm, Integer, Pointer, Float, Double, Struct, Array};\n-use lib::llvm::StructRetAttribute;\n+use lib::llvm::{StructRetAttribute, ZExtAttribute};\n use middle::trans::context::CrateContext;\n use middle::trans::cabi::*;\n use middle::trans::type_::Type;\n@@ -83,9 +83,10 @@ fn ty_size(ty: Type) -> uint {\n     }\n }\n \n-fn classify_ret_ty(ty: Type) -> ArgType {\n+fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n     if is_reg_ty(ty) {\n-        ArgType::direct(ty, None, None, None)\n+        let attr = if ty == Type::bool(ccx) { Some(ZExtAttribute) } else { None };\n+        ArgType::direct(ty, None, None, attr)\n     } else {\n         ArgType::indirect(ty, Some(StructRetAttribute))\n     }\n@@ -101,7 +102,8 @@ fn classify_arg_ty(ccx: &CrateContext, ty: Type, offset: &mut uint) -> ArgType {\n     *offset += align_up_to(size, align * 8) / 8;\n \n     if is_reg_ty(ty) {\n-        ArgType::direct(ty, None, None, None)\n+        let attr = if ty == Type::bool(ccx) { Some(ZExtAttribute) } else { None };\n+        ArgType::direct(ty, None, None, attr)\n     } else {\n         ArgType::direct(\n             ty,\n@@ -160,7 +162,7 @@ pub fn compute_abi_info(ccx: &CrateContext,\n                         rty: Type,\n                         ret_def: bool) -> FnType {\n     let ret_ty = if ret_def {\n-        classify_ret_ty(rty)\n+        classify_ret_ty(ccx, rty)\n     } else {\n         ArgType::direct(Type::void(ccx), None, None, None)\n     };"}, {"sha": "5fffdf08646b9824b9f8b1846fbe9041002bdcd2", "filename": "src/librustc/middle/trans/cabi_x86.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4c39962d325c09849e9cbb1828f85028f29fcea3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c39962d325c09849e9cbb1828f85028f29fcea3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs?ref=4c39962d325c09849e9cbb1828f85028f29fcea3", "patch": "@@ -59,7 +59,8 @@ pub fn compute_abi_info(ccx: &CrateContext,\n             }\n         }\n     } else {\n-        ret_ty = ArgType::direct(rty, None, None, None);\n+        let attr = if rty == Type::bool(ccx) { Some(ZExtAttribute) } else { None };\n+        ret_ty = ArgType::direct(rty, None, None, attr);\n     }\n \n     for &t in atys.iter() {\n@@ -72,7 +73,10 @@ pub fn compute_abi_info(ccx: &CrateContext,\n                     ArgType::indirect(t, Some(ByValAttribute))\n                 }\n             }\n-            _ => ArgType::direct(t, None, None, None),\n+            _ => {\n+                let attr = if t == Type::bool(ccx) { Some(ZExtAttribute) } else { None };\n+                ArgType::direct(t, None, None, attr)\n+            }\n         };\n         arg_tys.push(ty);\n     }"}, {"sha": "b2cd9d256dd43c4ea9845a3a74cf84d658433166", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4c39962d325c09849e9cbb1828f85028f29fcea3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c39962d325c09849e9cbb1828f85028f29fcea3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=4c39962d325c09849e9cbb1828f85028f29fcea3", "patch": "@@ -15,7 +15,7 @@\n \n use lib::llvm::{llvm, Integer, Pointer, Float, Double};\n use lib::llvm::{Struct, Array, Attribute};\n-use lib::llvm::{StructRetAttribute, ByValAttribute};\n+use lib::llvm::{StructRetAttribute, ByValAttribute, ZExtAttribute};\n use middle::trans::cabi::*;\n use middle::trans::context::CrateContext;\n use middle::trans::type_::Type;\n@@ -337,20 +337,21 @@ pub fn compute_abi_info(ccx: &CrateContext,\n     fn x86_64_ty(ccx: &CrateContext,\n                  ty: Type,\n                  is_mem_cls: |cls: &[RegClass]| -> bool,\n-                 attr: Attribute)\n+                 ind_attr: Attribute)\n                  -> ArgType {\n         if !ty.is_reg_ty() {\n             let cls = classify_ty(ty);\n             if is_mem_cls(cls.as_slice()) {\n-                ArgType::indirect(ty, Some(attr))\n+                ArgType::indirect(ty, Some(ind_attr))\n             } else {\n                 ArgType::direct(ty,\n                                 Some(llreg_ty(ccx, cls.as_slice())),\n                                 None,\n                                 None)\n             }\n         } else {\n-            ArgType::direct(ty, None, None, None)\n+            let attr = if ty == Type::bool(ccx) { Some(ZExtAttribute) } else { None };\n+            ArgType::direct(ty, None, None, attr)\n         }\n     }\n "}, {"sha": "a1923022e7b176dad7326b7000356453f8e6b033", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4c39962d325c09849e9cbb1828f85028f29fcea3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c39962d325c09849e9cbb1828f85028f29fcea3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=4c39962d325c09849e9cbb1828f85028f29fcea3", "patch": "@@ -818,11 +818,6 @@ pub fn find_vtable(tcx: &ty::ctxt,\n     param_bounds.get(n_bound).clone()\n }\n \n-// Casts a Rust bool value to an i1.\n-pub fn bool_to_i1(bcx: &Block, llval: ValueRef) -> ValueRef {\n-    build::ICmp(bcx, lib::llvm::IntNE, llval, C_bool(bcx.ccx(), false))\n-}\n-\n pub fn langcall(bcx: &Block,\n                 span: Option<Span>,\n                 msg: &str,"}, {"sha": "527ce5dfaae4591d62285d229780ae8137279736", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4c39962d325c09849e9cbb1828f85028f29fcea3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c39962d325c09849e9cbb1828f85028f29fcea3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=4c39962d325c09849e9cbb1828f85028f29fcea3", "patch": "@@ -399,18 +399,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                 let (dv, _dt) = const_deref(cx, te, ty, true);\n                 dv\n               }\n-              ast::UnNot    => {\n-                match ty::get(ty).sty {\n-                    ty::ty_bool => {\n-                        // Somewhat questionable, but I believe this is\n-                        // correct.\n-                        let te = llvm::LLVMConstTrunc(te, Type::i1(cx).to_ref());\n-                        let te = llvm::LLVMConstNot(te);\n-                        llvm::LLVMConstZExt(te, Type::bool(cx).to_ref())\n-                    }\n-                    _ => llvm::LLVMConstNot(te),\n-                }\n-              }\n+              ast::UnNot    => llvm::LLVMConstNot(te),\n               ast::UnNeg    => {\n                 if is_float { llvm::LLVMConstFNeg(te) }\n                 else        { llvm::LLVMConstNeg(te) }"}, {"sha": "440aa36b28cbd2e9e8cb864b0bc9aa044fa27150", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4c39962d325c09849e9cbb1828f85028f29fcea3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c39962d325c09849e9cbb1828f85028f29fcea3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=4c39962d325c09849e9cbb1828f85028f29fcea3", "patch": "@@ -525,8 +525,6 @@ fn load<'a>(bcx: &'a Block<'a>, llptr: ValueRef, ty: ty::t) -> ValueRef {\n \n     if type_is_zero_size(bcx.ccx(), ty) {\n         C_undef(type_of::type_of(bcx.ccx(), ty))\n-    } else if ty::type_is_bool(ty) {\n-        LoadRangeAssert(bcx, llptr, 0, 2, lib::llvm::False)\n     } else if ty::type_is_char(ty) {\n         // a char is a unicode codepoint, and so takes values from 0\n         // to 0x10FFFF inclusive only.\n@@ -652,8 +650,7 @@ impl<K:KindOps> Datum<K> {\n \n     pub fn to_llbool<'a>(self, bcx: &'a Block<'a>) -> ValueRef {\n         assert!(ty::type_is_bool(self.ty) || ty::type_is_bot(self.ty))\n-        let cond_val = self.to_llscalarish(bcx);\n-        bool_to_i1(bcx, cond_val)\n+        self.to_llscalarish(bcx)\n     }\n }\n "}, {"sha": "9af5c7aa792358e4021ee7ec2c6c8ffbd6260ce2", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4c39962d325c09849e9cbb1828f85028f29fcea3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c39962d325c09849e9cbb1828f85028f29fcea3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=4c39962d325c09849e9cbb1828f85028f29fcea3", "patch": "@@ -1147,11 +1147,7 @@ fn trans_unary<'a>(bcx: &'a Block<'a>,\n             let datum = unpack_datum!(bcx, trans(bcx, sub_expr));\n             let llresult = if ty::type_is_bool(un_ty) {\n                 let val = datum.to_llscalarish(bcx);\n-                let llcond = ICmp(bcx,\n-                                  lib::llvm::IntEQ,\n-                                  val,\n-                                  C_bool(ccx, false));\n-                Select(bcx, llcond, C_bool(ccx, true), C_bool(ccx, false))\n+                Xor(bcx, val, C_bool(ccx, true))\n             } else {\n                 // Note: `Not` is bitwise, not suitable for logical not.\n                 Not(bcx, datum.to_llscalarish(bcx))\n@@ -1325,9 +1321,7 @@ fn trans_eager_binop<'a>(\n         if ty::type_is_bot(rhs_t) {\n             C_bool(bcx.ccx(), false)\n         } else if ty::type_is_scalar(rhs_t) {\n-            let cmpr = base::compare_scalar_types(bcx, lhs, rhs, rhs_t, op);\n-            bcx = cmpr.bcx;\n-            ZExt(bcx, cmpr.val, Type::i8(bcx.ccx()))\n+            unpack_result!(bcx, base::compare_scalar_types(bcx, lhs, rhs, rhs_t, op))\n         } else if is_simd {\n             base::compare_simd_types(bcx, lhs, rhs, intype, ty::simd_size(tcx, lhs_t), op)\n         } else {\n@@ -1369,10 +1363,9 @@ fn trans_lazy_binop<'a>(\n     let join = fcx.new_id_block(\"join\", binop_expr.id);\n     let before_rhs = fcx.new_id_block(\"before_rhs\", b.id);\n \n-    let lhs_i1 = bool_to_i1(past_lhs, lhs);\n     match op {\n-      lazy_and => CondBr(past_lhs, lhs_i1, before_rhs.llbb, join.llbb),\n-      lazy_or => CondBr(past_lhs, lhs_i1, join.llbb, before_rhs.llbb)\n+      lazy_and => CondBr(past_lhs, lhs, before_rhs.llbb, join.llbb),\n+      lazy_or => CondBr(past_lhs, lhs, join.llbb, before_rhs.llbb)\n     }\n \n     let DatumBlock {bcx: past_rhs, datum: rhs} = trans(before_rhs, b);"}, {"sha": "fcd6c7e293ea26994f3fb183a9b54dcbd65d1612", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 39, "deletions": 24, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/4c39962d325c09849e9cbb1828f85028f29fcea3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c39962d325c09849e9cbb1828f85028f29fcea3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=4c39962d325c09849e9cbb1828f85028f29fcea3", "patch": "@@ -11,7 +11,7 @@\n \n use back::{link};\n use lib::llvm::llvm;\n-use lib::llvm::{ValueRef, CallConv, StructRetAttribute, Linkage};\n+use lib::llvm::{ValueRef, CallConv, Linkage};\n use lib;\n use middle::weak_lang_items;\n use middle::trans::base::push_ctxt;\n@@ -373,18 +373,41 @@ pub fn trans_native_call<'a>(\n     };\n \n     // A function pointer is called without the declaration available, so we have to apply\n-    // any attributes with ABI implications directly to the call instruction. Right now, the\n-    // only attribute we need to worry about is `sret`.\n+    // any attributes with ABI implications directly to the call instruction.\n     let mut attrs = Vec::new();\n-    if fn_type.ret_ty.is_indirect() {\n-        attrs.push((1, lib::llvm::StructRetAttribute as u64));\n \n+    // Add attributes that are always applicable, independent of the concrete foreign ABI\n+    if fn_type.ret_ty.is_indirect() {\n         // The outptr can be noalias and nocapture because it's entirely\n         // invisible to the program. We can also mark it as nonnull\n         attrs.push((1, lib::llvm::NoAliasAttribute as u64));\n         attrs.push((1, lib::llvm::NoCaptureAttribute as u64));\n         attrs.push((1, lib::llvm::NonNullAttribute as u64));\n     };\n+\n+    // Add attributes that depend on the concrete foreign ABI\n+    let mut arg_idx = if fn_type.ret_ty.is_indirect() { 1 } else { 0 };\n+    match fn_type.ret_ty.attr {\n+        Some(attr) => attrs.push((arg_idx, attr as u64)),\n+        _ => ()\n+    }\n+\n+    arg_idx += 1;\n+    for arg_ty in fn_type.arg_tys.iter() {\n+        if arg_ty.is_ignore() {\n+            continue;\n+        }\n+        // skip padding\n+        if arg_ty.pad.is_some() { arg_idx += 1; }\n+\n+        match arg_ty.attr {\n+            Some(attr) => attrs.push((arg_idx, attr as u64)),\n+            _ => {}\n+        }\n+\n+        arg_idx += 1;\n+    }\n+\n     let llforeign_retval = CallWithConv(bcx,\n                                         llfn,\n                                         llargs_foreign.as_slice(),\n@@ -934,22 +957,17 @@ pub fn lltype_for_foreign_fn(ccx: &CrateContext, ty: ty::t) -> Type {\n \n fn add_argument_attributes(tys: &ForeignTypes,\n                            llfn: ValueRef) {\n-    let mut i = 0;\n-\n-    if tys.fn_ty.ret_ty.is_indirect() {\n-        match tys.fn_ty.ret_ty.attr {\n-            Some(attr) => {\n-                let llarg = get_param(llfn, i);\n-                unsafe {\n-                    llvm::LLVMAddAttribute(llarg, attr as c_uint);\n-                }\n-            }\n-            None => {}\n-        }\n+    let mut i = if tys.fn_ty.ret_ty.is_indirect() { 1 } else { 0 };\n \n-        i += 1;\n+    match tys.fn_ty.ret_ty.attr {\n+        Some(attr) => unsafe {\n+            llvm::LLVMAddFunctionAttribute(llfn, i as c_uint, attr as u64);\n+        },\n+        None => {}\n     }\n \n+    i += 1;\n+\n     for &arg_ty in tys.fn_ty.arg_tys.iter() {\n         if arg_ty.is_ignore() {\n             continue;\n@@ -958,12 +976,9 @@ fn add_argument_attributes(tys: &ForeignTypes,\n         if arg_ty.pad.is_some() { i += 1; }\n \n         match arg_ty.attr {\n-            Some(attr) => {\n-                let llarg = get_param(llfn, i);\n-                unsafe {\n-                    llvm::LLVMAddAttribute(llarg, attr as c_uint);\n-                }\n-            }\n+            Some(attr) => unsafe {\n+                llvm::LLVMAddFunctionAttribute(llfn, i as c_uint, attr as u64);\n+            },\n             None => ()\n         }\n "}, {"sha": "bc0c88ceee95fc5866159c067f70773851ad51f5", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4c39962d325c09849e9cbb1828f85028f29fcea3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c39962d325c09849e9cbb1828f85028f29fcea3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=4c39962d325c09849e9cbb1828f85028f29fcea3", "patch": "@@ -96,19 +96,13 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n         let b = get_param(bcx.fcx.llfn, first_real_arg + 1);\n         let llfn = bcx.ccx().get_intrinsic(&name);\n \n-        // convert `i1` to a `bool`, and write to the out parameter\n         let val = Call(bcx, llfn, [a, b], []);\n-        let result = ExtractValue(bcx, val, 0);\n-        let overflow = ZExt(bcx, ExtractValue(bcx, val, 1), Type::bool(bcx.ccx()));\n-        let ret = C_undef(type_of::type_of(bcx.ccx(), t));\n-        let ret = InsertValue(bcx, ret, result, 0);\n-        let ret = InsertValue(bcx, ret, overflow, 1);\n \n         if type_is_immediate(bcx.ccx(), t) {\n-            Ret(bcx, ret);\n+            Ret(bcx, val);\n         } else {\n             let retptr = get_param(bcx.fcx.llfn, bcx.fcx.out_arg_pos());\n-            Store(bcx, ret, retptr);\n+            Store(bcx, val, retptr);\n             RetVoid(bcx);\n         }\n     }\n@@ -235,11 +229,15 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n                     lib::llvm::SequentiallyConsistent =>\n                         lib::llvm::SequentiallyConsistent,\n                 };\n-                let old = AtomicCmpXchg(bcx, get_param(decl, first_real_arg),\n+                let res = AtomicCmpXchg(bcx, get_param(decl, first_real_arg),\n                                         get_param(decl, first_real_arg + 1u),\n                                         get_param(decl, first_real_arg + 2u),\n                                         order, strongest_failure_ordering);\n-                Ret(bcx, old);\n+                if unsafe { lib::llvm::llvm::LLVMVersionMinor() >= 5 } {\n+                    Ret(bcx, ExtractValue(bcx, res, 0));\n+                } else {\n+                    Ret(bcx, res);\n+                }\n             }\n             \"load\" => {\n                 let old = AtomicLoad(bcx, get_param(decl, first_real_arg),"}, {"sha": "59903324e10eaaf2c5c6b2061eb59df0ff6e659d", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4c39962d325c09849e9cbb1828f85028f29fcea3/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c39962d325c09849e9cbb1828f85028f29fcea3/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=4c39962d325c09849e9cbb1828f85028f29fcea3", "patch": "@@ -107,7 +107,6 @@ impl<'a, 'b> Reflector<'a, 'b> {\n                                                          mth_idx,\n                                                          v),\n             ArgVals(args), None));\n-        let result = bool_to_i1(bcx, result);\n         let next_bcx = fcx.new_temp_block(\"next\");\n         CondBr(bcx, result, next_bcx.llbb, self.final_bcx.llbb);\n         self.bcx = next_bcx"}, {"sha": "75f884aac34cf28f58e46ac0eaa0d45ca18a26db", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c39962d325c09849e9cbb1828f85028f29fcea3/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c39962d325c09849e9cbb1828f85028f29fcea3/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=4c39962d325c09849e9cbb1828f85028f29fcea3", "patch": "@@ -93,7 +93,7 @@ impl Type {\n     }\n \n     pub fn bool(ccx: &CrateContext) -> Type {\n-        Type::i8(ccx)\n+        Type::i1(ccx)\n     }\n \n     pub fn char(ccx: &CrateContext) -> Type {"}, {"sha": "1bba09755d95892bc826c558630e93803b0a4ee6", "filename": "src/llvm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm?ref=4c39962d325c09849e9cbb1828f85028f29fcea3", "patch": "@@ -1 +1 @@\n-Subproject commit 0a894645cf120539876e9eb4eb0d7b572dfa9d14\n+Subproject commit 1bba09755d95892bc826c558630e93803b0a4ee6"}, {"sha": "c755cf67caa9f6b52dad2e8007673b6fc1bd8f94", "filename": "src/rt/rust_test_helpers.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4c39962d325c09849e9cbb1828f85028f29fcea3/src%2Frt%2Frust_test_helpers.c", "raw_url": "https://github.com/rust-lang/rust/raw/4c39962d325c09849e9cbb1828f85028f29fcea3/src%2Frt%2Frust_test_helpers.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_test_helpers.c?ref=4c39962d325c09849e9cbb1828f85028f29fcea3", "patch": "@@ -199,3 +199,21 @@ void\n rust_dbg_static_mut_check_four() {\n     assert(rust_dbg_static_mut == 4);\n }\n+\n+struct S {\n+    uint64_t x;\n+    uint64_t y;\n+    uint64_t z;\n+};\n+\n+uint64_t get_x(struct S s) {\n+    return s.x;\n+}\n+\n+uint64_t get_y(struct S s) {\n+    return s.y;\n+}\n+\n+uint64_t get_z(struct S s) {\n+    return s.z;\n+}"}, {"sha": "a1a88d1b14d45d8a9d97cce938dc4ceff0497de1", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4c39962d325c09849e9cbb1828f85028f29fcea3/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4c39962d325c09849e9cbb1828f85028f29fcea3/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=4c39962d325c09849e9cbb1828f85028f29fcea3", "patch": "@@ -659,7 +659,7 @@ LLVMRustLinkInExternalBitcode(LLVMModuleRef dst, char *bc, size_t len) {\n extern \"C\" void*\n LLVMRustOpenArchive(char *path) {\n     std::unique_ptr<MemoryBuffer> buf;\n-    error_code err = MemoryBuffer::getFile(path, buf);\n+    std::error_code err = MemoryBuffer::getFile(path, buf);\n     if (err) {\n         LLVMRustSetLastError(err.message().c_str());\n         return NULL;\n@@ -694,14 +694,18 @@ LLVMRustArchiveReadSection(Archive *ar, char *name, size_t *size) {\n #if LLVM_VERSION_MINOR >= 5\n     Archive::child_iterator child = ar->child_begin(),\n                               end = ar->child_end();\n+    for (; child != end; ++child) {\n+        ErrorOr<StringRef> name_or_err = child->getName();\n+        if (name_or_err.getError()) continue;\n+        StringRef sect_name = name_or_err.get();\n #else\n     Archive::child_iterator child = ar->begin_children(),\n                               end = ar->end_children();\n-#endif\n     for (; child != end; ++child) {\n         StringRef sect_name;\n         error_code err = child->getName(sect_name);\n         if (err) continue;\n+#endif\n         if (sect_name.trim(\" \") == name) {\n             StringRef buf = child->getBuffer();\n             *size = buf.size();\n@@ -757,7 +761,11 @@ inline section_iterator *unwrap(LLVMSectionIteratorRef SI) {\n extern \"C\" int\n LLVMRustGetSectionName(LLVMSectionIteratorRef SI, const char **ptr) {\n     StringRef ret;\n+#if LLVM_VERSION_MINOR >= 5\n+    if (std::error_code ec = (*unwrap(SI))->getName(ret))\n+#else\n     if (error_code ec = (*unwrap(SI))->getName(ret))\n+#endif\n       report_fatal_error(ec.message());\n     *ptr = ret.data();\n     return ret.size();"}, {"sha": "1bd3434b46eca59bdeae275dcb79edef06acdf67", "filename": "src/rustllvm/llvm-auto-clean-trigger", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c39962d325c09849e9cbb1828f85028f29fcea3/src%2Frustllvm%2Fllvm-auto-clean-trigger", "raw_url": "https://github.com/rust-lang/rust/raw/4c39962d325c09849e9cbb1828f85028f29fcea3/src%2Frustllvm%2Fllvm-auto-clean-trigger", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Fllvm-auto-clean-trigger?ref=4c39962d325c09849e9cbb1828f85028f29fcea3", "patch": "@@ -1,4 +1,4 @@\n # If this file is modified, then llvm will be forcibly cleaned and then rebuilt.\n # The actual contents of this file do not matter, but to trigger a change on the\n # build bots then the contents should be changed so git updates the mtime.\n-2014-05-20\n+2014-06-20.2"}, {"sha": "6a26ec44312d7abe2bbc140cb60039a6f8aba79f", "filename": "src/test/run-pass/foreign-fn-with-byval.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4c39962d325c09849e9cbb1828f85028f29fcea3/src%2Ftest%2Frun-pass%2Fforeign-fn-with-byval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c39962d325c09849e9cbb1828f85028f29fcea3/src%2Ftest%2Frun-pass%2Fforeign-fn-with-byval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-fn-with-byval.rs?ref=4c39962d325c09849e9cbb1828f85028f29fcea3", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub struct S {\n+    x: u64,\n+    y: u64,\n+    z: u64,\n+}\n+\n+#[link(name = \"rust_test_helpers\")]\n+extern {\n+    pub fn get_x(x: S) -> u64;\n+    pub fn get_y(x: S) -> u64;\n+    pub fn get_z(x: S) -> u64;\n+}\n+\n+#[inline(never)]\n+fn indirect_call(func: unsafe extern fn(s: S) -> u64, s: S) -> u64 {\n+    unsafe {\n+        func(s)\n+    }\n+}\n+\n+fn main() {\n+    let s = S { x: 1, y: 2, z: 3 };\n+    assert_eq!(s.x, indirect_call(get_x, s));\n+    assert_eq!(s.y, indirect_call(get_y, s));\n+    assert_eq!(s.z, indirect_call(get_z, s));\n+}"}]}