{"sha": "d5c227998bdc854938bdbf7dea96a58d2f7395a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1YzIyNzk5OGJkYzg1NDkzOGJkYmY3ZGVhOTZhNThkMmY3Mzk1YTI=", "commit": {"author": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2021-01-03T21:09:26Z"}, "committer": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2021-02-15T23:22:24Z"}, "message": "Add proptest float tests", "tree": {"sha": "298f5ccf5e7c645e35748a02288d9150de7af678", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/298f5ccf5e7c645e35748a02288d9150de7af678"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5c227998bdc854938bdbf7dea96a58d2f7395a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5c227998bdc854938bdbf7dea96a58d2f7395a2", "html_url": "https://github.com/rust-lang/rust/commit/d5c227998bdc854938bdbf7dea96a58d2f7395a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5c227998bdc854938bdbf7dea96a58d2f7395a2/comments", "author": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3c58daa9617bcb92798b672d56e556bb0f37faf", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3c58daa9617bcb92798b672d56e556bb0f37faf", "html_url": "https://github.com/rust-lang/rust/commit/d3c58daa9617bcb92798b672d56e556bb0f37faf"}], "stats": {"total": 1007, "additions": 572, "deletions": 435}, "files": [{"sha": "3f1abd73519bdd1bb02bf43787019bdb8b6c427c", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d5c227998bdc854938bdbf7dea96a58d2f7395a2/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d5c227998bdc854938bdbf7dea96a58d2f7395a2/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=d5c227998bdc854938bdbf7dea96a58d2f7395a2", "patch": "@@ -2,4 +2,5 @@\n \n members = [\n     \"crates/core_simd\",\n+    \"crates/test_helpers\",\n ]"}, {"sha": "d76bd547cde68ac22ef4ea73a7021f5e0ae29e55", "filename": "crates/core_simd/Cargo.toml", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d5c227998bdc854938bdbf7dea96a58d2f7395a2/crates%2Fcore_simd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d5c227998bdc854938bdbf7dea96a58d2f7395a2/crates%2Fcore_simd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2FCargo.toml?ref=d5c227998bdc854938bdbf7dea96a58d2f7395a2", "patch": "@@ -14,3 +14,11 @@ version = \"0.2\"\n \n [dev-dependencies.wasm-bindgen-test]\n version = \"0.3\"\n+\n+[dev-dependencies.proptest]\n+version = \"0.10\"\n+default-features = false\n+features = [\"alloc\"]\n+\n+[dev-dependencies.test_helpers]\n+path = \"../test_helpers\""}, {"sha": "3e428379b74d2f1267e8254f5be5461c167b6bea", "filename": "crates/core_simd/src/macros.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d5c227998bdc854938bdbf7dea96a58d2f7395a2/crates%2Fcore_simd%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5c227998bdc854938bdbf7dea96a58d2f7395a2/crates%2Fcore_simd%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmacros.rs?ref=d5c227998bdc854938bdbf7dea96a58d2f7395a2", "patch": "@@ -141,6 +141,12 @@ macro_rules! impl_vector {\n             }\n         }\n \n+        impl <const LANES: usize> From<$name<LANES>> for [$type; LANES] {\n+            fn from(vector: $name<LANES>) -> Self {\n+                vector.0\n+            }\n+        }\n+\n         // splat\n         impl<const LANES: usize> From<$type> for $name<LANES> where Self: crate::LanesAtMost64 {\n             #[inline]"}, {"sha": "939c18559d2a6f77c004b0bdaa79111e16b70b77", "filename": "crates/core_simd/tests/float.rs", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/d5c227998bdc854938bdbf7dea96a58d2f7395a2/crates%2Fcore_simd%2Ftests%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5c227998bdc854938bdbf7dea96a58d2f7395a2/crates%2Fcore_simd%2Ftests%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Ffloat.rs?ref=d5c227998bdc854938bdbf7dea96a58d2f7395a2", "patch": "@@ -0,0 +1,132 @@\n+#[cfg(target_arch = \"wasm32\")]\n+wasm_bindgen_test_configure!(run_in_browser);\n+\n+macro_rules! impl_op_test {\n+    { unary, $vector:ty, $scalar:ty, $trait:ident :: $fn:ident } => {\n+        test_helpers::test_lanes! {\n+            fn $fn<const LANES: usize>() {\n+                test_helpers::test_unary_elementwise(\n+                    <$vector as core::ops::$trait>::$fn,\n+                    <$scalar as core::ops::$trait>::$fn,\n+                );\n+            }\n+        }\n+    };\n+    { binary, $vector:ty, $scalar:ty, $trait:ident :: $fn:ident, $trait_assign:ident :: $fn_assign:ident } => {\n+        mod $fn {\n+            use super::*;\n+\n+            test_helpers::test_lanes! {\n+                fn normal<const LANES: usize>() {\n+                    test_helpers::test_binary_elementwise(\n+                        <$vector as core::ops::$trait>::$fn,\n+                        <$scalar as core::ops::$trait>::$fn,\n+                    );\n+                }\n+\n+                fn scalar_rhs<const LANES: usize>() {\n+                    test_helpers::test_binary_scalar_rhs_elementwise(\n+                        <$vector as core::ops::$trait<$scalar>>::$fn,\n+                        <$scalar as core::ops::$trait>::$fn,\n+                    );\n+                }\n+\n+                fn scalar_lhs<const LANES: usize>() {\n+                    test_helpers::test_binary_scalar_lhs_elementwise(\n+                        <$scalar as core::ops::$trait<$vector>>::$fn,\n+                        <$scalar as core::ops::$trait>::$fn,\n+                    );\n+                }\n+\n+                fn assign<const LANES: usize>() {\n+                    test_helpers::test_binary_elementwise(\n+                        |mut a, b| { <$vector as core::ops::$trait_assign>::$fn_assign(&mut a, b); a },\n+                        |mut a, b| { <$scalar as core::ops::$trait_assign>::$fn_assign(&mut a, b); a },\n+                    )\n+                }\n+\n+                fn assign_scalar_rhs<const LANES: usize>() {\n+                    test_helpers::test_binary_scalar_rhs_elementwise(\n+                        |mut a, b| { <$vector as core::ops::$trait_assign<$scalar>>::$fn_assign(&mut a, b); a },\n+                        |mut a, b| { <$scalar as core::ops::$trait_assign>::$fn_assign(&mut a, b); a },\n+                    )\n+                }\n+            }\n+        }\n+    };\n+}\n+\n+macro_rules! impl_tests {\n+    { $vector:ident, $scalar:tt, $int_scalar:tt } => {\n+        mod $scalar {\n+            type Vector<const LANES: usize> = core_simd::$vector<LANES>;\n+            type Scalar = $scalar;\n+            type IntScalar = $int_scalar;\n+            \n+            impl_op_test! { unary, Vector<LANES>, Scalar, Neg::neg }\n+            impl_op_test! { binary, Vector<LANES>, Scalar, Add::add, AddAssign::add_assign }\n+            impl_op_test! { binary, Vector<LANES>, Scalar, Sub::sub, SubAssign::sub_assign }\n+            impl_op_test! { binary, Vector<LANES>, Scalar, Mul::mul, SubAssign::sub_assign }\n+            impl_op_test! { binary, Vector<LANES>, Scalar, Div::div, DivAssign::div_assign }\n+            impl_op_test! { binary, Vector<LANES>, Scalar, Rem::rem, RemAssign::rem_assign }\n+\n+            test_helpers::test_lanes! {\n+                fn abs<const LANES: usize>() {\n+                    test_helpers::test_unary_elementwise(\n+                        Vector::<LANES>::abs,\n+                        Scalar::abs,\n+                    )\n+                }\n+\n+                fn ceil<const LANES: usize>() {\n+                    test_helpers::test_unary_elementwise(\n+                        Vector::<LANES>::ceil,\n+                        Scalar::ceil,\n+                    )\n+                }\n+\n+                fn floor<const LANES: usize>() {\n+                    test_helpers::test_unary_elementwise(\n+                        Vector::<LANES>::floor,\n+                        Scalar::floor,\n+                    )\n+                }\n+\n+                fn round_from_int<const LANES: usize>() {\n+                    test_helpers::test_unary_elementwise(\n+                        Vector::<LANES>::round_from_int,\n+                        |x| x as Scalar,\n+                    )\n+                }\n+\n+                fn to_int_unchecked<const LANES: usize>() {\n+                    // The maximum integer that can be represented by the equivalently sized float has\n+                    // all of the mantissa digits set to 1, pushed up to the MSB.\n+                    const ALL_MANTISSA_BITS: IntScalar = ((1 << <Scalar>::MANTISSA_DIGITS) - 1);\n+                    const MAX_REPRESENTABLE_VALUE: Scalar =\n+                        (ALL_MANTISSA_BITS << (core::mem::size_of::<Scalar>() * 8 - <Scalar>::MANTISSA_DIGITS as usize - 1)) as Scalar;\n+\n+                    let mut runner = proptest::test_runner::TestRunner::default();\n+                    runner.run(\n+                        &test_helpers::array::UniformArrayStrategy::new(-MAX_REPRESENTABLE_VALUE..MAX_REPRESENTABLE_VALUE),\n+                        |x| {\n+                            let result_1 = unsafe { Vector::from_array(x).to_int_unchecked().to_array() };\n+                            let result_2 = {\n+                                let mut result = [0; LANES];\n+                                for (i, o) in x.iter().zip(result.iter_mut()) {\n+                                    *o = unsafe { i.to_int_unchecked() };\n+                                }\n+                                result\n+                            };\n+                            test_helpers::prop_assert_biteq!(result_1, result_2);\n+                            Ok(())\n+                        },\n+                    ).unwrap();\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl_tests! { SimdF32, f32, i32 }\n+impl_tests! { SimdF64, f64, i64 }"}, {"sha": "1472822fe1fe559f935b5b1381c6ff0999d6ad2b", "filename": "crates/core_simd/tests/ops_impl/f32.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ff32.rs?ref=d3c58daa9617bcb92798b672d56e556bb0f37faf", "patch": "@@ -1,6 +0,0 @@\n-use super::helpers;\n-\n-float_tests! { f32x2, f32, i32x2, i32 }\n-float_tests! { f32x4, f32, i32x4, i32 }\n-float_tests! { f32x8, f32, i32x8, i32 }\n-float_tests! { f32x16, f32, i32x16, i32 }"}, {"sha": "8f573baa1ad222a20fe7a35ff7c13a6135750112", "filename": "crates/core_simd/tests/ops_impl/f64.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ff64.rs?ref=d3c58daa9617bcb92798b672d56e556bb0f37faf", "patch": "@@ -1,5 +0,0 @@\n-use super::helpers;\n-\n-float_tests! { f64x2, f64, i64x2, i64 }\n-float_tests! { f64x4, f64, i64x4, i64 }\n-float_tests! { f64x8, f64, i64x8, i64 }"}, {"sha": "fe347a5362daf85053e4f2d563390b9a92d15a94", "filename": "crates/core_simd/tests/ops_impl/float_macros.rs", "status": "removed", "additions": 0, "deletions": 418, "changes": 418, "blob_url": "https://github.com/rust-lang/rust/blob/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ffloat_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c58daa9617bcb92798b672d56e556bb0f37faf/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ffloat_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ffloat_macros.rs?ref=d3c58daa9617bcb92798b672d56e556bb0f37faf", "patch": "@@ -1,418 +0,0 @@\n-macro_rules! float_tests {\n-    { $vector:ident, $scalar:ident, $int_vector:ident, $int_scalar:ident } => {\n-        #[cfg(test)]\n-        mod $vector {\n-            use super::*;\n-            use helpers::lanewise::*;\n-\n-            #[cfg(target_arch = \"wasm32\")]\n-            use wasm_bindgen_test::*;\n-\n-            #[cfg(target_arch = \"wasm32\")]\n-            wasm_bindgen_test_configure!(run_in_browser);\n-\n-            // TODO impl this as an associated fn on vectors\n-            fn from_slice(slice: &[$scalar]) -> core_simd::$vector {\n-                let mut value = core_simd::$vector::default();\n-                let value_slice: &mut [_] = value.as_mut();\n-                value_slice.copy_from_slice(&slice[0..value_slice.len()]);\n-                value\n-            }\n-\n-            fn slice_chunks(slice: &[$scalar]) -> impl Iterator<Item = core_simd::$vector> + '_ {\n-                let lanes = core::mem::size_of::<core_simd::$vector>() / core::mem::size_of::<$scalar>();\n-                slice.chunks_exact(lanes).map(from_slice)\n-            }\n-\n-            fn from_slice_int(slice: &[$int_scalar]) -> core_simd::$int_vector {\n-                let mut value = core_simd::$int_vector::default();\n-                let value_slice: &mut [_] = value.as_mut();\n-                value_slice.copy_from_slice(&slice[0..value_slice.len()]);\n-                value\n-            }\n-\n-            fn slice_chunks_int(slice: &[$int_scalar]) -> impl Iterator<Item = core_simd::$int_vector> + '_ {\n-                let lanes = core::mem::size_of::<core_simd::$int_vector>() / core::mem::size_of::<$int_scalar>();\n-                slice.chunks_exact(lanes).map(from_slice_int)\n-            }\n-\n-            const A: [$scalar; 16] = [0.,   1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10., 11., 12., 13., 14., 15.];\n-            const B: [$scalar; 16] = [16., 17., 18., 19., 20., 21., 22., 23., 24., 25., 26., 27., 28., 29., 30., 31.];\n-            const C: [$scalar; 16] = [\n-                -0.0,\n-                0.0,\n-                -1.0,\n-                1.0,\n-                <$scalar>::MIN,\n-                <$scalar>::MAX,\n-                <$scalar>::INFINITY,\n-                <$scalar>::NEG_INFINITY,\n-                <$scalar>::MIN_POSITIVE,\n-                -<$scalar>::MIN_POSITIVE,\n-                <$scalar>::EPSILON,\n-                -<$scalar>::EPSILON,\n-                <$scalar>::NAN,\n-                -<$scalar>::NAN,\n-                // TODO: Would be nice to check sNaN...\n-                100.0 / 3.0,\n-                -100.0 / 3.0,\n-            ];\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn add() {\n-                let a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::Add::add);\n-                assert_biteq!(a + b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn add_assign() {\n-                let mut a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::Add::add);\n-                a += b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn add_scalar_rhs() {\n-                let a = from_slice(&A);\n-                let b = 5.;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Add::add);\n-                assert_biteq!(a + b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn add_scalar_lhs() {\n-                let a = 5.;\n-                let b = from_slice(&B);\n-                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::Add::add);\n-                assert_biteq!(a + b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn add_assign_scalar() {\n-                let mut a = from_slice(&A);\n-                let b = 5.;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Add::add);\n-                a += b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn sub() {\n-                let a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::Sub::sub);\n-                assert_biteq!(a - b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn sub_assign() {\n-                let mut a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::Sub::sub);\n-                a -= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn sub_scalar_rhs() {\n-                let a = from_slice(&A);\n-                let b = 5.;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Sub::sub);\n-                assert_biteq!(a - b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn sub_scalar_lhs() {\n-                let a = 5.;\n-                let b = from_slice(&B);\n-                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::Sub::sub);\n-                assert_biteq!(a - b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn sub_assign_scalar() {\n-                let mut a = from_slice(&A);\n-                let b = 5.;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Sub::sub);\n-                a -= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn mul() {\n-                let a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::Mul::mul);\n-                assert_biteq!(a * b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn mul_assign() {\n-                let mut a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::Mul::mul);\n-                a *= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn mul_scalar_rhs() {\n-                let a = from_slice(&A);\n-                let b = 5.;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Mul::mul);\n-                assert_biteq!(a * b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn mul_scalar_lhs() {\n-                let a = 5.;\n-                let b = from_slice(&B);\n-                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::Mul::mul);\n-                assert_biteq!(a * b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn mul_assign_scalar() {\n-                let mut a = from_slice(&A);\n-                let b = 5.;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Mul::mul);\n-                a *= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn div() {\n-                let a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::Div::div);\n-                assert_biteq!(a / b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn div_assign() {\n-                let mut a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::Div::div);\n-                a /= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn div_scalar_rhs() {\n-                let a = from_slice(&A);\n-                let b = 5.;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Div::div);\n-                assert_biteq!(a / b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn div_scalar_lhs() {\n-                let a = 5.;\n-                let b = from_slice(&B);\n-                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::Div::div);\n-                assert_biteq!(a / b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn div_assign_scalar() {\n-                let mut a = from_slice(&A);\n-                let b = 5.;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Div::div);\n-                a /= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn rem() {\n-                let a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::Rem::rem);\n-                assert_biteq!(a % b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn rem_assign() {\n-                let mut a = from_slice(&A);\n-                let b = from_slice(&B);\n-                let expected = apply_binary_lanewise(a, b, core::ops::Rem::rem);\n-                a %= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn rem_scalar_rhs() {\n-                let a = from_slice(&A);\n-                let b = 5.;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Rem::rem);\n-                assert_biteq!(a % b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn rem_scalar_lhs() {\n-                let a = 5.;\n-                let b = from_slice(&B);\n-                let expected = apply_binary_scalar_lhs_lanewise(a, b, core::ops::Rem::rem);\n-                assert_biteq!(a % b, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn rem_assign_scalar() {\n-                let mut a = from_slice(&A);\n-                let b = 5.;\n-                let expected = apply_binary_scalar_rhs_lanewise(a, b, core::ops::Rem::rem);\n-                a %= b;\n-                assert_biteq!(a, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn neg() {\n-                let v = from_slice(&A);\n-                let expected = apply_unary_lanewise(v, core::ops::Neg::neg);\n-                assert_biteq!(-v, expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn neg_odd_floats() {\n-                for v in slice_chunks(&C) {\n-                    let expected = apply_unary_lanewise(v, core::ops::Neg::neg);\n-                    assert_biteq!(-v, expected);\n-                }\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn abs_negative() {\n-                let v = -from_slice(&A);\n-                let expected = apply_unary_lanewise(v, <$scalar>::abs);\n-                assert_biteq!(v.abs(), expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn abs_positive() {\n-                let v = from_slice(&B);\n-                let expected = apply_unary_lanewise(v, <$scalar>::abs);\n-                assert_biteq!(v.abs(), expected);\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn abs_odd_floats() {\n-                for v in slice_chunks(&C) {\n-                    let expected = apply_unary_lanewise(v, <$scalar>::abs);\n-                    assert_biteq!(v.abs(), expected);\n-                }\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn ceil_odd_floats() {\n-                for v in slice_chunks(&C) {\n-                    let expected = apply_unary_lanewise(v, <$scalar>::ceil);\n-                    assert_biteq!(v.ceil(), expected);\n-                }\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn floor_odd_floats() {\n-                for v in slice_chunks(&C) {\n-                    let expected = apply_unary_lanewise(v, <$scalar>::floor);\n-                    assert_biteq!(v.floor(), expected);\n-                }\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn to_int_unchecked() {\n-                // The maximum integer that can be represented by the equivalently sized float has\n-                // all of the mantissa digits set to 1, pushed up to the MSB.\n-                const ALL_MANTISSA_BITS: $int_scalar = ((1 << <$scalar>::MANTISSA_DIGITS) - 1);\n-                const MAX_REPRESENTABLE_VALUE: $int_scalar =\n-                    ALL_MANTISSA_BITS << (core::mem::size_of::<$scalar>() * 8 - <$scalar>::MANTISSA_DIGITS as usize - 1);\n-                const VALUES: [$scalar; 16] = [\n-                    -0.0,\n-                    0.0,\n-                    -1.0,\n-                    1.0,\n-                    ALL_MANTISSA_BITS as $scalar,\n-                    -ALL_MANTISSA_BITS as $scalar,\n-                    MAX_REPRESENTABLE_VALUE as $scalar,\n-                    -MAX_REPRESENTABLE_VALUE as $scalar,\n-                    (MAX_REPRESENTABLE_VALUE / 2) as $scalar,\n-                    (-MAX_REPRESENTABLE_VALUE / 2) as $scalar,\n-                    <$scalar>::MIN_POSITIVE,\n-                    -<$scalar>::MIN_POSITIVE,\n-                    <$scalar>::EPSILON,\n-                    -<$scalar>::EPSILON,\n-                    100.0 / 3.0,\n-                    -100.0 / 3.0,\n-                ];\n-\n-                for v in slice_chunks(&VALUES) {\n-                    let expected = apply_unary_lanewise(v, |x| unsafe { x.to_int_unchecked() });\n-                    assert_biteq!(unsafe { v.to_int_unchecked() }, expected);\n-                }\n-            }\n-\n-            #[test]\n-            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-            fn round_from_int() {\n-                const VALUES: [$int_scalar; 16] = [\n-                    0,\n-                    0,\n-                    1,\n-                    -1,\n-                    100,\n-                    -100,\n-                    200,\n-                    -200,\n-                    413,\n-                    -413,\n-                    1017,\n-                    -1017,\n-                    1234567,\n-                    -1234567,\n-                    <$int_scalar>::MAX,\n-                    <$int_scalar>::MIN,\n-                ];\n-\n-                for v in slice_chunks_int(&VALUES) {\n-                    let expected = apply_unary_lanewise(v, |x| x as $scalar);\n-                    assert_biteq!(core_simd::$vector::round_from_int(v), expected);\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "5819eb6beafad984dae1618d440b8439d63c374b", "filename": "crates/core_simd/tests/ops_impl/mod.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d5c227998bdc854938bdbf7dea96a58d2f7395a2/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5c227998bdc854938bdbf7dea96a58d2f7395a2/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmod.rs?ref=d5c227998bdc854938bdbf7dea96a58d2f7395a2", "patch": "@@ -2,12 +2,6 @@\n #[path = \"../helpers/mod.rs\"]\n mod helpers;\n \n-#[macro_use]\n-mod float_macros;\n-\n-mod r#f32;\n-mod r#f64;\n-\n #[macro_use]\n mod int_macros;\n "}, {"sha": "0a8c3344334c44bab698f90216cdb903310d61fa", "filename": "crates/test_helpers/Cargo.toml", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d5c227998bdc854938bdbf7dea96a58d2f7395a2/crates%2Ftest_helpers%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d5c227998bdc854938bdbf7dea96a58d2f7395a2/crates%2Ftest_helpers%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_helpers%2FCargo.toml?ref=d5c227998bdc854938bdbf7dea96a58d2f7395a2", "patch": "@@ -0,0 +1,9 @@\n+[package]\n+name = \"test_helpers\"\n+version = \"0.1.0\"\n+authors = [\"Caleb Zulawski <caleb.zulawski@gmail.com>\"]\n+edition = \"2018\"\n+publish = false\n+\n+[dependencies]\n+proptest = \"0.10\""}, {"sha": "d9cae96ca2fffc586708bfa85cafa46701f55df3", "filename": "crates/test_helpers/src/array.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/d5c227998bdc854938bdbf7dea96a58d2f7395a2/crates%2Ftest_helpers%2Fsrc%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5c227998bdc854938bdbf7dea96a58d2f7395a2/crates%2Ftest_helpers%2Fsrc%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_helpers%2Fsrc%2Farray.rs?ref=d5c227998bdc854938bdbf7dea96a58d2f7395a2", "patch": "@@ -0,0 +1,98 @@\n+// Adapted from proptest's array code\n+// Copyright 2017 Jason Lingle\n+\n+use proptest::{\n+    strategy::{NewTree, Strategy, ValueTree},\n+    test_runner::TestRunner,\n+};\n+use core::{\n+    marker::PhantomData,\n+    mem::MaybeUninit,\n+};\n+\n+#[must_use = \"strategies do nothing unless used\"]\n+#[derive(Clone, Copy, Debug)]\n+pub struct UniformArrayStrategy<S, T> {\n+    strategy: S,\n+    _marker: PhantomData<T>,\n+}\n+\n+impl<S, T> UniformArrayStrategy<S, T> {\n+    pub fn new(strategy: S) -> Self {\n+        Self {\n+            strategy,\n+            _marker: PhantomData,\n+        }\n+    }\n+}\n+\n+pub struct ArrayValueTree<T> {\n+    tree: T,\n+    shrinker: usize,\n+    last_shrinker: Option<usize>,\n+}\n+\n+impl<T, S, const LANES: usize> Strategy for UniformArrayStrategy<S, [T; LANES]>\n+where\n+    T: core::fmt::Debug,\n+    S: Strategy<Value = T>,\n+{\n+    type Tree = ArrayValueTree<[S::Tree; LANES]>;\n+    type Value = [T; LANES];\n+\n+    fn new_tree(&self, runner: &mut TestRunner) -> NewTree<Self> {\n+        let tree: [S::Tree; LANES] = unsafe {\n+            let mut tree: [MaybeUninit<S::Tree>; LANES] = MaybeUninit::uninit().assume_init();\n+            for t in tree.iter_mut() {\n+                *t = MaybeUninit::new(self.strategy.new_tree(runner)?)\n+            }\n+            core::mem::transmute_copy(&tree)\n+        };\n+        Ok(ArrayValueTree {\n+            tree,\n+            shrinker: 0,\n+            last_shrinker: None,\n+        })\n+    }\n+}\n+\n+impl<T: ValueTree, const LANES: usize> ValueTree for ArrayValueTree<[T; LANES]> {\n+    type Value = [T::Value; LANES];\n+\n+    fn current(&self) -> Self::Value {\n+        unsafe {\n+            let mut value: [MaybeUninit<T::Value>; LANES] = MaybeUninit::uninit().assume_init();\n+            for (tree_elem, value_elem) in self.tree.iter().zip(value.iter_mut()) {\n+                *value_elem = MaybeUninit::new(tree_elem.current());\n+            }\n+            core::mem::transmute_copy(&value)\n+        }\n+    }\n+\n+    fn simplify(&mut self) -> bool {\n+        while self.shrinker < LANES {\n+            if self.tree[self.shrinker].simplify() {\n+                self.last_shrinker = Some(self.shrinker);\n+                return true;\n+            } else {\n+                self.shrinker += 1;\n+            }\n+        }\n+\n+        false\n+    }\n+\n+    fn complicate(&mut self) -> bool {\n+        if let Some(shrinker) = self.last_shrinker {\n+            self.shrinker = shrinker;\n+            if self.tree[shrinker].complicate() {\n+                true\n+            } else {\n+                self.last_shrinker = None;\n+                false\n+            }\n+        } else {\n+            false\n+        }\n+    }\n+}"}, {"sha": "23aa7d4d908e5324cf9083fd94b1ad314e2695a9", "filename": "crates/test_helpers/src/biteq.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/d5c227998bdc854938bdbf7dea96a58d2f7395a2/crates%2Ftest_helpers%2Fsrc%2Fbiteq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5c227998bdc854938bdbf7dea96a58d2f7395a2/crates%2Ftest_helpers%2Fsrc%2Fbiteq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_helpers%2Fsrc%2Fbiteq.rs?ref=d5c227998bdc854938bdbf7dea96a58d2f7395a2", "patch": "@@ -0,0 +1,94 @@\n+pub trait BitEq {\n+    fn biteq(&self, other: &Self) -> bool;\n+    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result;\n+}\n+\n+macro_rules! impl_integer_biteq {\n+    { $($type:ty),* } => {\n+        $(\n+        impl BitEq for $type {\n+            fn biteq(&self, other: &Self) -> bool {\n+                self == other\n+            }\n+\n+            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                write!(f, \"{:?} ({:x})\", self, self)\n+            }\n+        }\n+        )*\n+    };\n+}\n+\n+impl_integer_biteq! { u8, u16, u32, u64, u128, usize, i8, i16, i32, i64, i128, isize }\n+\n+macro_rules! impl_float_biteq {\n+    { $($type:ty),* } => {\n+        $(\n+        impl BitEq for $type {\n+            fn biteq(&self, other: &Self) -> bool {\n+                if self.is_nan() && other.is_nan() {\n+                    true // exact nan bits don't matter\n+                } else {\n+                    self.to_bits() == other.to_bits()\n+                }\n+            }\n+\n+            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                write!(f, \"{:?} ({:x})\", self, self.to_bits())\n+            }\n+        }\n+        )*\n+    };\n+}\n+\n+impl_float_biteq! { f32, f64 }\n+\n+impl<T: BitEq, const N: usize> BitEq for [T; N] {\n+    fn biteq(&self, other: &Self) -> bool {\n+        self.iter()\n+            .zip(other.iter())\n+            .fold(true, |value, (left, right)| value && left.biteq(right))\n+    }\n+\n+    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+        #[repr(transparent)]\n+        struct Wrapper<'a, T: BitEq>(&'a T);\n+\n+        impl<T: BitEq> core::fmt::Debug for Wrapper<'_, T> {\n+            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                self.0.fmt(f)\n+            }\n+        }\n+\n+        f.debug_list()\n+            .entries(self.iter().map(|x| Wrapper(x)))\n+            .finish()\n+    }\n+}\n+\n+#[doc(hidden)]\n+pub struct BitEqWrapper<'a, T>(pub &'a T);\n+\n+impl<T: BitEq> PartialEq for BitEqWrapper<'_, T> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.0.biteq(other.0)\n+    }\n+}\n+\n+impl<T: BitEq> core::fmt::Debug for BitEqWrapper<'_, T> {\n+    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n+#[macro_export]\n+macro_rules! prop_assert_biteq {\n+    { $a:expr, $b:expr } => {\n+        {\n+            use $crate::biteq::BitEqWrapper;\n+            let a = $a;\n+            let b = $b;\n+            proptest::prop_assert_eq!(BitEqWrapper(&a), BitEqWrapper(&b));\n+        }\n+    }\n+}"}, {"sha": "2aaa4641fdfd8bc0d0eb9ce78965c67876fa2690", "filename": "crates/test_helpers/src/lib.rs", "status": "added", "additions": 224, "deletions": 0, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/d5c227998bdc854938bdbf7dea96a58d2f7395a2/crates%2Ftest_helpers%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5c227998bdc854938bdbf7dea96a58d2f7395a2/crates%2Ftest_helpers%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_helpers%2Fsrc%2Flib.rs?ref=d5c227998bdc854938bdbf7dea96a58d2f7395a2", "patch": "@@ -0,0 +1,224 @@\n+pub mod array;\n+\n+#[macro_use]\n+pub mod biteq;\n+\n+pub trait DefaultStrategy {\n+    type Strategy: proptest::strategy::Strategy<Value = Self>;\n+    fn default_strategy() -> Self::Strategy;\n+}\n+\n+macro_rules! impl_num {\n+    { $type:tt } => {\n+        impl DefaultStrategy for $type {\n+            type Strategy = proptest::num::$type::Any;\n+            fn default_strategy() -> Self::Strategy {\n+                proptest::num::$type::ANY\n+            }\n+        }\n+    }\n+}\n+\n+impl_num! { i8 }\n+impl_num! { i16 }\n+impl_num! { i32 }\n+impl_num! { i64 }\n+impl_num! { i128 }\n+impl_num! { isize }\n+impl_num! { u8 }\n+impl_num! { u16 }\n+impl_num! { u32 }\n+impl_num! { u64 }\n+impl_num! { u128 }\n+impl_num! { usize }\n+impl_num! { f32 }\n+impl_num! { f64 }\n+\n+impl<T: core::fmt::Debug + DefaultStrategy, const LANES: usize> DefaultStrategy for [T; LANES] {\n+    type Strategy = crate::array::UniformArrayStrategy<T::Strategy, Self>;\n+    fn default_strategy() -> Self::Strategy {\n+        Self::Strategy::new(T::default_strategy())\n+    }\n+}\n+\n+pub fn test_1<A: core::fmt::Debug + DefaultStrategy>(\n+    f: impl Fn(A) -> proptest::test_runner::TestCaseResult,\n+) {\n+    let mut runner = proptest::test_runner::TestRunner::default();\n+    runner.run(&A::default_strategy(), f).unwrap();\n+}\n+\n+pub fn test_2<A: core::fmt::Debug + DefaultStrategy, B: core::fmt::Debug + DefaultStrategy>(\n+    f: impl Fn(A, B) -> proptest::test_runner::TestCaseResult,\n+) {\n+    let mut runner = proptest::test_runner::TestRunner::default();\n+    runner\n+        .run(&(A::default_strategy(), B::default_strategy()), |(a, b)| {\n+            f(a, b)\n+        })\n+        .unwrap();\n+}\n+\n+pub fn test_unary_elementwise<Scalar, ScalarResult, Vector, VectorResult, const LANES: usize>(\n+    fv: impl Fn(Vector) -> VectorResult,\n+    fs: impl Fn(Scalar) -> ScalarResult,\n+) where\n+    Scalar: Copy + Default + core::fmt::Debug + DefaultStrategy,\n+    ScalarResult: Copy + Default + biteq::BitEq + core::fmt::Debug + DefaultStrategy,\n+    Vector: Into<[Scalar; LANES]> + From<[Scalar; LANES]> + Copy,\n+    VectorResult: Into<[ScalarResult; LANES]> + From<[ScalarResult; LANES]> + Copy,\n+{\n+    test_1(|x: [Scalar; LANES]| {\n+        let result_1: [ScalarResult; LANES] = fv(x.into()).into();\n+        let result_2: [ScalarResult; LANES] = {\n+            let mut result = [ScalarResult::default(); LANES];\n+            for (i, o) in x.iter().zip(result.iter_mut()) {\n+                *o = fs(*i);\n+            }\n+            result\n+        };\n+        crate::prop_assert_biteq!(result_1, result_2);\n+        Ok(())\n+    });\n+}\n+\n+pub fn test_binary_elementwise<\n+    Scalar1,\n+    Scalar2,\n+    ScalarResult,\n+    Vector1,\n+    Vector2,\n+    VectorResult,\n+    const LANES: usize,\n+>(\n+    fv: impl Fn(Vector1, Vector2) -> VectorResult,\n+    fs: impl Fn(Scalar1, Scalar2) -> ScalarResult,\n+) where\n+    Scalar1: Copy + Default + core::fmt::Debug + DefaultStrategy,\n+    Scalar2: Copy + Default + core::fmt::Debug + DefaultStrategy,\n+    ScalarResult: Copy + Default + biteq::BitEq + core::fmt::Debug + DefaultStrategy,\n+    Vector1: Into<[Scalar1; LANES]> + From<[Scalar1; LANES]> + Copy,\n+    Vector2: Into<[Scalar2; LANES]> + From<[Scalar2; LANES]> + Copy,\n+    VectorResult: Into<[ScalarResult; LANES]> + From<[ScalarResult; LANES]> + Copy,\n+{\n+    test_2(|x: [Scalar1; LANES], y: [Scalar2; LANES]| {\n+        let result_1: [ScalarResult; LANES] = fv(x.into(), y.into()).into();\n+        let result_2: [ScalarResult; LANES] = {\n+            let mut result = [ScalarResult::default(); LANES];\n+            for ((i1, i2), o) in x.iter().zip(y.iter()).zip(result.iter_mut()) {\n+                *o = fs(*i1, *i2);\n+            }\n+            result\n+        };\n+        crate::prop_assert_biteq!(result_1, result_2);\n+        Ok(())\n+    });\n+}\n+\n+pub fn test_binary_scalar_rhs_elementwise<\n+    Scalar1,\n+    Scalar2,\n+    ScalarResult,\n+    Vector,\n+    VectorResult,\n+    const LANES: usize,\n+>(\n+    fv: impl Fn(Vector, Scalar2) -> VectorResult,\n+    fs: impl Fn(Scalar1, Scalar2) -> ScalarResult,\n+) where\n+    Scalar1: Copy + Default + core::fmt::Debug + DefaultStrategy,\n+    Scalar2: Copy + Default + core::fmt::Debug + DefaultStrategy,\n+    ScalarResult: Copy + Default + biteq::BitEq + core::fmt::Debug + DefaultStrategy,\n+    Vector: Into<[Scalar1; LANES]> + From<[Scalar1; LANES]> + Copy,\n+    VectorResult: Into<[ScalarResult; LANES]> + From<[ScalarResult; LANES]> + Copy,\n+{\n+    test_2(|x: [Scalar1; LANES], y: Scalar2| {\n+        let result_1: [ScalarResult; LANES] = fv(x.into(), y).into();\n+        let result_2: [ScalarResult; LANES] = {\n+            let mut result = [ScalarResult::default(); LANES];\n+            for (i, o) in x.iter().zip(result.iter_mut()) {\n+                *o = fs(*i, y);\n+            }\n+            result\n+        };\n+        crate::prop_assert_biteq!(result_1, result_2);\n+        Ok(())\n+    });\n+}\n+\n+pub fn test_binary_scalar_lhs_elementwise<\n+    Scalar1,\n+    Scalar2,\n+    ScalarResult,\n+    Vector,\n+    VectorResult,\n+    const LANES: usize,\n+>(\n+    fv: impl Fn(Scalar1, Vector) -> VectorResult,\n+    fs: impl Fn(Scalar1, Scalar2) -> ScalarResult,\n+) where\n+    Scalar1: Copy + Default + core::fmt::Debug + DefaultStrategy,\n+    Scalar2: Copy + Default + core::fmt::Debug + DefaultStrategy,\n+    ScalarResult: Copy + Default + biteq::BitEq + core::fmt::Debug + DefaultStrategy,\n+    Vector: Into<[Scalar2; LANES]> + From<[Scalar2; LANES]> + Copy,\n+    VectorResult: Into<[ScalarResult; LANES]> + From<[ScalarResult; LANES]> + Copy,\n+{\n+    test_2(|x: Scalar1, y: [Scalar2; LANES]| {\n+        let result_1: [ScalarResult; LANES] = fv(x, y.into()).into();\n+        let result_2: [ScalarResult; LANES] = {\n+            let mut result = [ScalarResult::default(); LANES];\n+            for (i, o) in y.iter().zip(result.iter_mut()) {\n+                *o = fs(x, *i);\n+            }\n+            result\n+        };\n+        crate::prop_assert_biteq!(result_1, result_2);\n+        Ok(())\n+    });\n+}\n+\n+#[macro_export]\n+#[doc(hidden)]\n+macro_rules! test_lanes_impl {\n+    {\n+        fn $test:ident<const $lanes:ident: usize>() $body:tt\n+\n+        $($name:ident => $lanes_lit:literal,)*\n+    } => {\n+        mod $test {\n+            use super::*;\n+            $(\n+                #[test]\n+                #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+                fn $name() {\n+                    const $lanes: usize = $lanes_lit;\n+                    $body\n+                }\n+            )*\n+        }\n+    }\n+}\n+\n+#[macro_export]\n+macro_rules! test_lanes {\n+    {\n+        $(fn $test:ident<const $lanes:ident: usize>() $body:tt)*\n+    } => {\n+        $(\n+        $crate::test_lanes_impl! {\n+            fn $test<const $lanes: usize>() $body\n+\n+            lanes_2 => 2,\n+            lanes_3 => 3,\n+            lanes_4 => 4,\n+            lanes_7 => 7,\n+            lanes_8 => 8,\n+            lanes_16 => 16,\n+            lanes_32 => 32,\n+            lanes_64 => 64,\n+            lanes_128 => 128,\n+            lanes_256 => 256,\n+        }\n+        )*\n+    }\n+}"}]}