{"sha": "7d675eda80c5f1eb4a9fe7d374023d71721bf2f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkNjc1ZWRhODBjNWYxZWI0YTlmZTdkMzc0MDIzZDcxNzIxYmYyZjE=", "commit": {"author": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-05-10T17:40:35Z"}, "committer": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-05-31T19:08:43Z"}, "message": "Don't panic on a pattern of unresolved ADT variant.", "tree": {"sha": "c6a3e1bf3709c63d4451a52d0c110340b0665234", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c6a3e1bf3709c63d4451a52d0c110340b0665234"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d675eda80c5f1eb4a9fe7d374023d71721bf2f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d675eda80c5f1eb4a9fe7d374023d71721bf2f1", "html_url": "https://github.com/rust-lang/rust/commit/7d675eda80c5f1eb4a9fe7d374023d71721bf2f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d675eda80c5f1eb4a9fe7d374023d71721bf2f1/comments", "author": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "466345ca81c9f8a17347671ca27856eb963858f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/466345ca81c9f8a17347671ca27856eb963858f4", "html_url": "https://github.com/rust-lang/rust/commit/466345ca81c9f8a17347671ca27856eb963858f4"}], "stats": {"total": 64, "additions": 14, "deletions": 50}, "files": [{"sha": "52e9a5b1b3f77dffcf138f46468d261ed260d94c", "filename": "crates/hir_ty/src/diagnostics/match_check.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7d675eda80c5f1eb4a9fe7d374023d71721bf2f1/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d675eda80c5f1eb4a9fe7d374023d71721bf2f1/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs?ref=7d675eda80c5f1eb4a9fe7d374023d71721bf2f1", "patch": "@@ -1357,6 +1357,7 @@ fn enum_(never: Never) {\n }\n fn enum_ref(never: &Never) {\n     match never {}\n+        //^^^^^ Missing match arm\n }\n fn bang(never: !) {\n     match never {}"}, {"sha": "4f88dfe60b02859d155eff57837962a58cdeb38f", "filename": "crates/hir_ty/src/diagnostics/pattern.rs", "status": "modified", "additions": 13, "deletions": 50, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/7d675eda80c5f1eb4a9fe7d374023d71721bf2f1/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d675eda80c5f1eb4a9fe7d374023d71721bf2f1/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern.rs?ref=7d675eda80c5f1eb4a9fe7d374023d71721bf2f1", "patch": "@@ -21,6 +21,7 @@ pub(crate) type PatId = Idx<Pat>;\n #[derive(Clone, Debug)]\n pub(crate) enum PatternError {\n     Unimplemented,\n+    UnresolvedVariant,\n }\n \n #[derive(Clone, Debug, PartialEq)]\n@@ -103,6 +104,7 @@ impl<'a> PatCtxt<'a> {\n \n     fn lower_pattern_unadjusted(&mut self, pat: hir_def::expr::PatId) -> Pat {\n         let ty = &self.infer[pat];\n+        let variant = self.infer.variant_resolution_for_pat(pat);\n \n         let kind = match self.body[pat] {\n             hir_def::expr::Pat::Wild => PatKind::Wild,\n@@ -126,21 +128,14 @@ impl<'a> PatCtxt<'a> {\n                 PatKind::Binding { subpattern: self.lower_opt_pattern(subpat) }\n             }\n \n-            hir_def::expr::Pat::TupleStruct { ref args, ellipsis, .. } => {\n-                let variant_data = match self.infer.variant_resolution_for_pat(pat) {\n-                    Some(variant_id) => variant_id.variant_data(self.db.upcast()),\n-                    None => panic!(\"tuple struct pattern not applied to an ADT {:?}\", ty),\n-                };\n-                let subpatterns =\n-                    self.lower_tuple_subpats(args, variant_data.fields().len(), ellipsis);\n+            hir_def::expr::Pat::TupleStruct { ref args, ellipsis, .. } if variant.is_some() => {\n+                let expected_len = variant.unwrap().variant_data(self.db.upcast()).fields().len();\n+                let subpatterns = self.lower_tuple_subpats(args, expected_len, ellipsis);\n                 self.lower_variant_or_leaf(pat, ty, subpatterns)\n             }\n \n-            hir_def::expr::Pat::Record { ref args, .. } => {\n-                let variant_data = match self.infer.variant_resolution_for_pat(pat) {\n-                    Some(variant_id) => variant_id.variant_data(self.db.upcast()),\n-                    None => panic!(\"record pattern not applied to an ADT {:?}\", ty),\n-                };\n+            hir_def::expr::Pat::Record { ref args, .. } if variant.is_some() => {\n+                let variant_data = variant.unwrap().variant_data(self.db.upcast());\n                 let subpatterns = args\n                     .iter()\n                     .map(|field| FieldPat {\n@@ -151,6 +146,10 @@ impl<'a> PatCtxt<'a> {\n                     .collect();\n                 self.lower_variant_or_leaf(pat, ty, subpatterns)\n             }\n+            hir_def::expr::Pat::TupleStruct { .. } | hir_def::expr::Pat::Record { .. } => {\n+                self.errors.push(PatternError::UnresolvedVariant);\n+                PatKind::Wild\n+            }\n \n             hir_def::expr::Pat::Or(ref pats) => PatKind::Or { pats: self.lower_patterns(pats) },\n \n@@ -208,7 +207,7 @@ impl<'a> PatCtxt<'a> {\n                 }\n             }\n             None => {\n-                self.errors.push(PatternError::Unimplemented);\n+                self.errors.push(PatternError::UnresolvedVariant);\n                 PatKind::Wild\n             }\n         };\n@@ -223,7 +222,7 @@ impl<'a> PatCtxt<'a> {\n         match self.infer.variant_resolution_for_pat(pat) {\n             Some(_) => pat_from_kind(self.lower_variant_or_leaf(pat, ty, Vec::new())),\n             None => {\n-                self.errors.push(PatternError::Unimplemented);\n+                self.errors.push(PatternError::UnresolvedVariant);\n                 pat_from_kind(PatKind::Wild)\n             }\n         }\n@@ -510,40 +509,4 @@ fn main() {\n \"#,\n         );\n     }\n-\n-    /// These failing tests are narrowed down from \"hir_ty::diagnostics::match_check::tests\"\n-    // TODO fix\n-    mod failing {\n-        use super::*;\n-\n-        #[test]\n-        fn never() {\n-            check_diagnostics(\n-                r#\"\n-enum Never {}\n-\n-fn enum_ref(never: &Never) {\n-    match never {}\n-}\n-\"#,\n-            );\n-        }\n-\n-        #[test]\n-        fn unknown_type() {\n-            check_diagnostics(\n-                r#\"\n-enum Option<T> { Some(T), None }\n-\n-fn main() {\n-    // `Never` is deliberately not defined so that it's an uninferred type.\n-    match Option::<Never>::None {\n-        None => {}\n-        Some(never) => {}\n-    }\n-}\n-\"#,\n-            );\n-        }\n-    }\n }"}]}