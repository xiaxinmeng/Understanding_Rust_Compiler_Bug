{"sha": "85cc3cfec99a7d232384efae010bfbc8224f1351", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1Y2MzY2ZlYzk5YTdkMjMyMzg0ZWZhZTAxMGJmYmM4MjI0ZjEzNTE=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-01-03T10:47:57Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-01-03T10:47:57Z"}, "message": "Revert \"Proper handling $crate and local_inner_macros\"", "tree": {"sha": "f02b994b580aacd64a3b8172a17fa464a52b4713", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f02b994b580aacd64a3b8172a17fa464a52b4713"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85cc3cfec99a7d232384efae010bfbc8224f1351", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJf8aDdCRBK7hj4Ov3rIwAAdHIIAFp4xCuQGt+yHnzDVnkxVEbA\njqGYZqfEgnpd4oD5fsYVXtjQzCSkDP62X+fd8iRcHbYZSspb72SpIux6s3B5RPz5\nJz8hYpOUelN476bR84fejpAMHQ0XoFDg19jQ4aMAsgJ33Jadnmyqe4XYX8ApurIN\nSloYygfYlNMlOXc/mOUSXUZvDSfN5fYLSAfPw8Aajk7YZFtUabHIbKKKAjgq9A2z\n0ruReoXsHGB/9XhE04EmmcYEtmEdk1w5V7vNjFwBESuIzC+TOQZTtW2JWszoODdn\nWRA4yesat4em4pcGFpqrhNnJZSRbCE2ceDy2pZTrRpZAiig2l+5TwtttinT0v0A=\n=gdi6\n-----END PGP SIGNATURE-----\n", "payload": "tree f02b994b580aacd64a3b8172a17fa464a52b4713\nparent 354c1daedc91abd15ca0ce6ada417053ce45ecfa\nauthor Jonas Schievink <jonasschievink@gmail.com> 1609670877 +0100\ncommitter GitHub <noreply@github.com> 1609670877 +0100\n\nRevert \"Proper handling $crate and local_inner_macros\"\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85cc3cfec99a7d232384efae010bfbc8224f1351", "html_url": "https://github.com/rust-lang/rust/commit/85cc3cfec99a7d232384efae010bfbc8224f1351", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85cc3cfec99a7d232384efae010bfbc8224f1351/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "354c1daedc91abd15ca0ce6ada417053ce45ecfa", "url": "https://api.github.com/repos/rust-lang/rust/commits/354c1daedc91abd15ca0ce6ada417053ce45ecfa", "html_url": "https://github.com/rust-lang/rust/commit/354c1daedc91abd15ca0ce6ada417053ce45ecfa"}], "stats": {"total": 228, "additions": 52, "deletions": 176}, "files": [{"sha": "8a01e6eead0fa41c9997df1e04398222ceab1736", "filename": "crates/hir_def/src/path/lower.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85cc3cfec99a7d232384efae010bfbc8224f1351/crates%2Fhir_def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85cc3cfec99a7d232384efae010bfbc8224f1351/crates%2Fhir_def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fpath%2Flower.rs?ref=85cc3cfec99a7d232384efae010bfbc8224f1351", "patch": "@@ -123,7 +123,7 @@ pub(super) fn lower_path(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path>\n     // We follow what it did anyway :)\n     if segments.len() == 1 && kind == PathKind::Plain {\n         if let Some(_macro_call) = path.syntax().parent().and_then(ast::MacroCall::cast) {\n-            if let Some(crate_id) = hygiene.local_inner_macros(path) {\n+            if let Some(crate_id) = hygiene.local_inner_macros() {\n                 kind = PathKind::DollarCrate(crate_id);\n             }\n         }"}, {"sha": "7ab0a5e52eb071751df865f6d9cb4d9448cd8460", "filename": "crates/hir_expand/src/hygiene.rs", "status": "modified", "additions": 25, "deletions": 126, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/85cc3cfec99a7d232384efae010bfbc8224f1351/crates%2Fhir_expand%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85cc3cfec99a7d232384efae010bfbc8224f1351/crates%2Fhir_expand%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fhygiene.rs?ref=85cc3cfec99a7d232384efae010bfbc8224f1351", "patch": "@@ -2,94 +2,30 @@\n //!\n //! Specifically, `ast` + `Hygiene` allows you to create a `Name`. Note that, at\n //! this moment, this is horribly incomplete and handles only `$crate`.\n-use std::sync::Arc;\n-\n-use arena::{Arena, Idx};\n use base_db::CrateId;\n use either::Either;\n-use mbe::Origin;\n-use syntax::{ast, AstNode};\n+use syntax::ast;\n \n use crate::{\n     db::AstDatabase,\n     name::{AsName, Name},\n-    ExpansionInfo, HirFileId, HirFileIdRepr, MacroCallId, MacroDefKind,\n+    HirFileId, HirFileIdRepr, MacroCallId, MacroDefKind,\n };\n \n #[derive(Clone, Debug)]\n pub struct Hygiene {\n-    frames: Option<Arc<HygieneFrames>>,\n-}\n-\n-impl Hygiene {\n-    pub fn new(db: &dyn AstDatabase, file_id: HirFileId) -> Hygiene {\n-        Hygiene { frames: Some(Arc::new(HygieneFrames::new(db, file_id.clone()))) }\n-    }\n-\n-    pub fn new_unhygienic() -> Hygiene {\n-        Hygiene { frames: None }\n-    }\n-\n-    // FIXME: this should just return name\n-    pub fn name_ref_to_name(&self, name_ref: ast::NameRef) -> Either<Name, CrateId> {\n-        if let Some(frames) = &self.frames {\n-            if name_ref.text() == \"$crate\" {\n-                if let Some(krate) = frames.root_crate(&name_ref) {\n-                    return Either::Right(krate);\n-                }\n-            }\n-        }\n-\n-        Either::Left(name_ref.as_name())\n-    }\n-\n-    pub fn local_inner_macros(&self, path: ast::Path) -> Option<CrateId> {\n-        let frames = self.frames.as_ref()?;\n-\n-        let mut token = path.syntax().first_token()?;\n-        let mut current = frames.first();\n-\n-        while let Some((frame, data)) =\n-            current.and_then(|it| Some((it, it.expansion.as_ref()?.map_token_up(&token)?)))\n-        {\n-            let (mapped, origin) = data;\n-            if origin == Origin::Def {\n-                return if frame.local_inner { frame.krate } else { None };\n-            }\n-            current = Some(&frames.0[frame.call_site?]);\n-            token = mapped.value;\n-        }\n-        None\n-    }\n-}\n-\n-#[derive(Default, Debug)]\n-struct HygieneFrames(Arena<HygieneFrame>);\n-\n-#[derive(Clone, Debug)]\n-struct HygieneFrame {\n-    expansion: Option<ExpansionInfo>,\n+    // This is what `$crate` expands to\n+    def_crate: Option<CrateId>,\n \n     // Indicate this is a local inner macro\n     local_inner: bool,\n-    krate: Option<CrateId>,\n-\n-    call_site: Option<Idx<HygieneFrame>>,\n-    def_site: Option<Idx<HygieneFrame>>,\n }\n \n-impl HygieneFrames {\n-    fn new(db: &dyn AstDatabase, file_id: HirFileId) -> Self {\n-        let mut frames = HygieneFrames::default();\n-        frames.add(db, file_id);\n-        frames\n-    }\n-\n-    fn add(&mut self, db: &dyn AstDatabase, file_id: HirFileId) -> Option<Idx<HygieneFrame>> {\n-        let (krate, local_inner) = match file_id.0 {\n+impl Hygiene {\n+    pub fn new(db: &dyn AstDatabase, file_id: HirFileId) -> Hygiene {\n+        let (def_crate, local_inner) = match file_id.0 {\n             HirFileIdRepr::FileId(_) => (None, false),\n             HirFileIdRepr::MacroFile(macro_file) => match macro_file.macro_call_id {\n-                MacroCallId::EagerMacro(_id) => (None, false),\n                 MacroCallId::LazyMacro(id) => {\n                     let loc = db.lookup_intern_macro(id);\n                     match loc.def.kind {\n@@ -100,68 +36,31 @@ impl HygieneFrames {\n                         MacroDefKind::ProcMacro(_) => (None, false),\n                     }\n                 }\n+                MacroCallId::EagerMacro(_id) => (None, false),\n             },\n         };\n-\n-        let expansion = file_id.expansion_info(db);\n-        let expansion = match expansion {\n-            None => {\n-                return Some(self.0.alloc(HygieneFrame {\n-                    expansion: None,\n-                    local_inner,\n-                    krate,\n-                    call_site: None,\n-                    def_site: None,\n-                }));\n-            }\n-            Some(it) => it,\n-        };\n-\n-        let def_site = expansion.def.clone();\n-        let call_site = expansion.arg.file_id;\n-        let idx = self.0.alloc(HygieneFrame {\n-            expansion: Some(expansion),\n-            local_inner,\n-            krate,\n-            call_site: None,\n-            def_site: None,\n-        });\n-\n-        self.0[idx].call_site = self.add(db, call_site);\n-        self.0[idx].def_site = def_site.and_then(|it| self.add(db, it.file_id));\n-\n-        Some(idx)\n+        Hygiene { def_crate, local_inner }\n     }\n \n-    fn first(&self) -> Option<&HygieneFrame> {\n-        self.0.iter().next().map(|it| it.1)\n+    pub fn new_unhygienic() -> Hygiene {\n+        Hygiene { def_crate: None, local_inner: false }\n     }\n \n-    fn root_crate(&self, name_ref: &ast::NameRef) -> Option<CrateId> {\n-        let mut token = name_ref.syntax().first_token()?;\n-        let first = self.first()?;\n-        let mut result = first.krate;\n-        let mut current = Some(first);\n-\n-        while let Some((frame, (mapped, origin))) =\n-            current.and_then(|it| Some((it, it.expansion.as_ref()?.map_token_up(&token)?)))\n-        {\n-            result = frame.krate;\n-\n-            let site = match origin {\n-                Origin::Def => frame.def_site,\n-                Origin::Call => frame.call_site,\n-            };\n-\n-            let site = match site {\n-                None => break,\n-                Some(it) => it,\n-            };\n-\n-            current = Some(&self.0[site]);\n-            token = mapped.value;\n+    // FIXME: this should just return name\n+    pub fn name_ref_to_name(&self, name_ref: ast::NameRef) -> Either<Name, CrateId> {\n+        if let Some(def_crate) = self.def_crate {\n+            if name_ref.text() == \"$crate\" {\n+                return Either::Right(def_crate);\n+            }\n         }\n+        Either::Left(name_ref.as_name())\n+    }\n \n-        result\n+    pub fn local_inner_macros(&self) -> Option<CrateId> {\n+        if self.local_inner {\n+            self.def_crate\n+        } else {\n+            None\n+        }\n     }\n }"}, {"sha": "3fa1b1d776f8302c45a1e4de7bd9d8cce114ff52", "filename": "crates/hir_expand/src/lib.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/85cc3cfec99a7d232384efae010bfbc8224f1351/crates%2Fhir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85cc3cfec99a7d232384efae010bfbc8224f1351/crates%2Fhir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Flib.rs?ref=85cc3cfec99a7d232384efae010bfbc8224f1351", "patch": "@@ -340,8 +340,11 @@ impl ExpansionInfo {\n         Some(self.expanded.with_value(token))\n     }\n \n-    pub fn map_token_up(&self, token: &SyntaxToken) -> Option<(InFile<SyntaxToken>, Origin)> {\n-        let token_id = self.exp_map.token_by_range(token.text_range())?;\n+    pub fn map_token_up(\n+        &self,\n+        token: InFile<&SyntaxToken>,\n+    ) -> Option<(InFile<SyntaxToken>, Origin)> {\n+        let token_id = self.exp_map.token_by_range(token.value.text_range())?;\n \n         let (token_id, origin) = self.macro_def.0.map_id_up(token_id);\n         let (token_map, tt) = match origin {\n@@ -356,7 +359,7 @@ impl ExpansionInfo {\n             ),\n         };\n \n-        let range = token_map.range_by_token(token_id)?.by_kind(token.kind())?;\n+        let range = token_map.range_by_token(token_id)?.by_kind(token.value.kind())?;\n         let token = algo::find_covering_element(&tt.value, range + tt.value.text_range().start())\n             .into_token()?;\n         Some((tt.with_value(token), origin))\n@@ -492,7 +495,7 @@ fn ascend_call_token(\n     expansion: &ExpansionInfo,\n     token: InFile<SyntaxToken>,\n ) -> Option<InFile<SyntaxToken>> {\n-    let (mapped, origin) = expansion.map_token_up(&token.value)?;\n+    let (mapped, origin) = expansion.map_token_up(token.as_ref())?;\n     if origin != Origin::Call {\n         return None;\n     }"}, {"sha": "1953da7beb453ec5e15c82bdd8675884d063e4e0", "filename": "crates/hir_ty/src/tests/macros.rs", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/85cc3cfec99a7d232384efae010bfbc8224f1351/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85cc3cfec99a7d232384efae010bfbc8224f1351/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs?ref=85cc3cfec99a7d232384efae010bfbc8224f1351", "patch": "@@ -370,37 +370,6 @@ expand!();\n     );\n }\n \n-#[test]\n-fn infer_macro_with_dollar_crate_in_def_site() {\n-    check_types(\n-        r#\"\n-//- /main.rs crate:main deps:foo\n-use foo::expand;\n-\n-macro_rules! list {\n-    ($($tt:tt)*) => { $($tt)* }\n-}\n-\n-fn test() {\n-    let r = expand!();\n-    r;\n-  //^ u128\n-}\n-\n-//- /lib.rs crate:foo\n-#[macro_export]\n-macro_rules! expand {\n-    () => { list!($crate::m!()) };\n-}\n-\n-#[macro_export]\n-macro_rules! m {\n-    () => { 0u128 };\n-}\n-\"#,\n-    );\n-}\n-\n #[test]\n fn infer_type_value_non_legacy_macro_use_as() {\n     check_infer("}, {"sha": "ab5f87c487ce6b910fdff0eb7ac6012340a7803f", "filename": "crates/mbe/src/mbe_expander/matcher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85cc3cfec99a7d232384efae010bfbc8224f1351/crates%2Fmbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85cc3cfec99a7d232384efae010bfbc8224f1351/crates%2Fmbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs?ref=85cc3cfec99a7d232384efae010bfbc8224f1351", "patch": "@@ -150,7 +150,7 @@ fn match_subtree(\n                     res.add_err(err!(\"leftover tokens\"));\n                 }\n             }\n-            Op::Var { name, kind, .. } => {\n+            Op::Var { name, kind } => {\n                 let kind = match kind {\n                     Some(k) => k,\n                     None => {"}, {"sha": "7205312371d16686392dac48c7921e0d75b52258", "filename": "crates/mbe/src/mbe_expander/transcriber.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/85cc3cfec99a7d232384efae010bfbc8224f1351/crates%2Fmbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85cc3cfec99a7d232384efae010bfbc8224f1351/crates%2Fmbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs?ref=85cc3cfec99a7d232384efae010bfbc8224f1351", "patch": "@@ -100,8 +100,8 @@ fn expand_subtree(\n                 err = err.or(e);\n                 arena.push(tt.into());\n             }\n-            Op::Var { name, id, .. } => {\n-                let ExpandResult { value: fragment, err: e } = expand_var(ctx, &name, *id);\n+            Op::Var { name, .. } => {\n+                let ExpandResult { value: fragment, err: e } = expand_var(ctx, &name);\n                 err = err.or(e);\n                 push_fragment(arena, fragment);\n             }\n@@ -118,10 +118,12 @@ fn expand_subtree(\n     ExpandResult { value: tt::Subtree { delimiter: template.delimiter, token_trees: tts }, err }\n }\n \n-fn expand_var(ctx: &mut ExpandCtx, v: &SmolStr, id: tt::TokenId) -> ExpandResult<Fragment> {\n+fn expand_var(ctx: &mut ExpandCtx, v: &SmolStr) -> ExpandResult<Fragment> {\n     if v == \"crate\" {\n         // We simply produce identifier `$crate` here. And it will be resolved when lowering ast to Path.\n-        let tt = tt::Leaf::from(tt::Ident { text: \"$crate\".into(), id }).into();\n+        let tt =\n+            tt::Leaf::from(tt::Ident { text: \"$crate\".into(), id: tt::TokenId::unspecified() })\n+                .into();\n         ExpandResult::ok(Fragment::Tokens(tt))\n     } else if !ctx.bindings.contains(v) {\n         // Note that it is possible to have a `$var` inside a macro which is not bound.\n@@ -140,8 +142,14 @@ fn expand_var(ctx: &mut ExpandCtx, v: &SmolStr, id: tt::TokenId) -> ExpandResult\n         let tt = tt::Subtree {\n             delimiter: None,\n             token_trees: vec![\n-                tt::Leaf::from(tt::Punct { char: '$', spacing: tt::Spacing::Alone, id }).into(),\n-                tt::Leaf::from(tt::Ident { text: v.clone(), id }).into(),\n+                tt::Leaf::from(tt::Punct {\n+                    char: '$',\n+                    spacing: tt::Spacing::Alone,\n+                    id: tt::TokenId::unspecified(),\n+                })\n+                .into(),\n+                tt::Leaf::from(tt::Ident { text: v.clone(), id: tt::TokenId::unspecified() })\n+                    .into(),\n             ],\n         }\n         .into();"}, {"sha": "2f3ebc831397675f95741762ac11eaa3280acb50", "filename": "crates/mbe/src/parser.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/85cc3cfec99a7d232384efae010bfbc8224f1351/crates%2Fmbe%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85cc3cfec99a7d232384efae010bfbc8224f1351/crates%2Fmbe%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fparser.rs?ref=85cc3cfec99a7d232384efae010bfbc8224f1351", "patch": "@@ -8,7 +8,7 @@ use crate::{tt_iter::TtIter, ExpandError, MetaTemplate};\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) enum Op {\n-    Var { name: SmolStr, kind: Option<SmolStr>, id: tt::TokenId },\n+    Var { name: SmolStr, kind: Option<SmolStr> },\n     Repeat { subtree: MetaTemplate, kind: RepeatKind, separator: Option<Separator> },\n     Leaf(tt::Leaf),\n     Subtree(MetaTemplate),\n@@ -106,21 +106,18 @@ fn next_op<'a>(first: &tt::TokenTree, src: &mut TtIter<'a>, mode: Mode) -> Resul\n                         }\n                         let name = UNDERSCORE.clone();\n                         let kind = eat_fragment_kind(src, mode)?;\n-                        let id = punct.id;\n-                        Op::Var { name, kind, id }\n+                        Op::Var { name, kind }\n                     }\n                     tt::Leaf::Ident(ident) => {\n                         let name = ident.text.clone();\n                         let kind = eat_fragment_kind(src, mode)?;\n-                        let id = ident.id;\n-                        Op::Var { name, kind, id }\n+                        Op::Var { name, kind }\n                     }\n                     tt::Leaf::Literal(lit) => {\n                         if is_boolean_literal(&lit) {\n                             let name = lit.text.clone();\n                             let kind = eat_fragment_kind(src, mode)?;\n-                            let id = lit.id;\n-                            Op::Var { name, kind, id }\n+                            Op::Var { name, kind }\n                         } else {\n                             bail!(\"bad var 2\");\n                         }"}]}