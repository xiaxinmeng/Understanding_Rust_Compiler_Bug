{"sha": "602f9aab89791ac2e63d0a41731ddf0a9b727f29", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwMmY5YWFiODk3OTFhYzJlNjNkMGE0MTczMWRkZjBhOWI3MjdmMjk=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-08-01T11:10:12Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-08-01T18:23:13Z"}, "message": "More benchmarks of BTreeMap mutation", "tree": {"sha": "f8930164374c493011600946952709397477e39a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8930164374c493011600946952709397477e39a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/602f9aab89791ac2e63d0a41731ddf0a9b727f29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/602f9aab89791ac2e63d0a41731ddf0a9b727f29", "html_url": "https://github.com/rust-lang/rust/commit/602f9aab89791ac2e63d0a41731ddf0a9b727f29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/602f9aab89791ac2e63d0a41731ddf0a9b727f29/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e614f66800c2b289f6c969dbabd2902e253a5e69", "url": "https://api.github.com/repos/rust-lang/rust/commits/e614f66800c2b289f6c969dbabd2902e253a5e69", "html_url": "https://github.com/rust-lang/rust/commit/e614f66800c2b289f6c969dbabd2902e253a5e69"}], "stats": {"total": 354, "additions": 332, "deletions": 22}, "files": [{"sha": "7c2e5694a62fc4249859748c47d16499752ad066", "filename": "library/alloc/benches/btree/map.rs", "status": "modified", "additions": 302, "deletions": 0, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/602f9aab89791ac2e63d0a41731ddf0a9b727f29/library%2Falloc%2Fbenches%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/602f9aab89791ac2e63d0a41731ddf0a9b727f29/library%2Falloc%2Fbenches%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Fbtree%2Fmap.rs?ref=602f9aab89791ac2e63d0a41731ddf0a9b727f29", "patch": "@@ -282,3 +282,305 @@ pub fn iter_10k(b: &mut Bencher) {\n pub fn iter_1m(b: &mut Bencher) {\n     bench_iter(b, 1_000, 1_000_000);\n }\n+\n+const FAT: usize = 256;\n+\n+// The returned map has small keys and values.\n+// Benchmarks on it have a counterpart in set.rs with the same keys and no values at all.\n+fn slim_map(n: usize) -> BTreeMap<usize, usize> {\n+    (0..n).map(|i| (i, i)).collect::<BTreeMap<_, _>>()\n+}\n+\n+// The returned map has small keys and large values.\n+fn fat_val_map(n: usize) -> BTreeMap<usize, [usize; FAT]> {\n+    (0..n).map(|i| (i, [i; FAT])).collect::<BTreeMap<_, _>>()\n+}\n+\n+// The returned map has large keys and values.\n+fn fat_map(n: usize) -> BTreeMap<[usize; FAT], [usize; FAT]> {\n+    (0..n).map(|i| ([i; FAT], [i; FAT])).collect::<BTreeMap<_, _>>()\n+}\n+\n+#[bench]\n+pub fn clone_slim_100(b: &mut Bencher) {\n+    let src = slim_map(100);\n+    b.iter(|| src.clone())\n+}\n+\n+#[bench]\n+pub fn clone_slim_100_and_clear(b: &mut Bencher) {\n+    let src = slim_map(100);\n+    b.iter(|| src.clone().clear())\n+}\n+\n+#[bench]\n+pub fn clone_slim_100_and_drain_all(b: &mut Bencher) {\n+    let src = slim_map(100);\n+    b.iter(|| src.clone().drain_filter(|_, _| true).count())\n+}\n+\n+#[bench]\n+pub fn clone_slim_100_and_drain_half(b: &mut Bencher) {\n+    let src = slim_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        assert_eq!(map.drain_filter(|i, _| i % 2 == 0).count(), 100 / 2);\n+        assert_eq!(map.len(), 100 / 2);\n+    })\n+}\n+\n+#[bench]\n+pub fn clone_slim_100_and_into_iter(b: &mut Bencher) {\n+    let src = slim_map(100);\n+    b.iter(|| src.clone().into_iter().count())\n+}\n+\n+#[bench]\n+pub fn clone_slim_100_and_pop_all(b: &mut Bencher) {\n+    let src = slim_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        while map.pop_first().is_some() {}\n+        map\n+    });\n+}\n+\n+#[bench]\n+pub fn clone_slim_100_and_remove_all(b: &mut Bencher) {\n+    let src = slim_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        while let Some(elt) = map.iter().map(|(&i, _)| i).next() {\n+            let v = map.remove(&elt);\n+            debug_assert!(v.is_some());\n+        }\n+        map\n+    });\n+}\n+\n+#[bench]\n+pub fn clone_slim_100_and_remove_half(b: &mut Bencher) {\n+    let src = slim_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        for i in (0..100).step_by(2) {\n+            let v = map.remove(&i);\n+            debug_assert!(v.is_some());\n+        }\n+        assert_eq!(map.len(), 100 / 2);\n+        map\n+    })\n+}\n+\n+#[bench]\n+pub fn clone_slim_10k(b: &mut Bencher) {\n+    let src = slim_map(10_000);\n+    b.iter(|| src.clone())\n+}\n+\n+#[bench]\n+pub fn clone_slim_10k_and_clear(b: &mut Bencher) {\n+    let src = slim_map(10_000);\n+    b.iter(|| src.clone().clear())\n+}\n+\n+#[bench]\n+pub fn clone_slim_10k_and_drain_all(b: &mut Bencher) {\n+    let src = slim_map(10_000);\n+    b.iter(|| src.clone().drain_filter(|_, _| true).count())\n+}\n+\n+#[bench]\n+pub fn clone_slim_10k_and_drain_half(b: &mut Bencher) {\n+    let src = slim_map(10_000);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        assert_eq!(map.drain_filter(|i, _| i % 2 == 0).count(), 10_000 / 2);\n+        assert_eq!(map.len(), 10_000 / 2);\n+    })\n+}\n+\n+#[bench]\n+pub fn clone_slim_10k_and_into_iter(b: &mut Bencher) {\n+    let src = slim_map(10_000);\n+    b.iter(|| src.clone().into_iter().count())\n+}\n+\n+#[bench]\n+pub fn clone_slim_10k_and_pop_all(b: &mut Bencher) {\n+    let src = slim_map(10_000);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        while map.pop_first().is_some() {}\n+        map\n+    });\n+}\n+\n+#[bench]\n+pub fn clone_slim_10k_and_remove_all(b: &mut Bencher) {\n+    let src = slim_map(10_000);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        while let Some(elt) = map.iter().map(|(&i, _)| i).next() {\n+            let v = map.remove(&elt);\n+            debug_assert!(v.is_some());\n+        }\n+        map\n+    });\n+}\n+\n+#[bench]\n+pub fn clone_slim_10k_and_remove_half(b: &mut Bencher) {\n+    let src = slim_map(10_000);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        for i in (0..10_000).step_by(2) {\n+            let v = map.remove(&i);\n+            debug_assert!(v.is_some());\n+        }\n+        assert_eq!(map.len(), 10_000 / 2);\n+        map\n+    })\n+}\n+\n+#[bench]\n+pub fn clone_fat_val_100(b: &mut Bencher) {\n+    let src = fat_val_map(100);\n+    b.iter(|| src.clone())\n+}\n+\n+#[bench]\n+pub fn clone_fat_val_100_and_clear(b: &mut Bencher) {\n+    let src = fat_val_map(100);\n+    b.iter(|| src.clone().clear())\n+}\n+\n+#[bench]\n+pub fn clone_fat_val_100_and_drain_all(b: &mut Bencher) {\n+    let src = fat_val_map(100);\n+    b.iter(|| src.clone().drain_filter(|_, _| true).count())\n+}\n+\n+#[bench]\n+pub fn clone_fat_val_100_and_drain_half(b: &mut Bencher) {\n+    let src = fat_val_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        assert_eq!(map.drain_filter(|i, _| i % 2 == 0).count(), 100 / 2);\n+        assert_eq!(map.len(), 100 / 2);\n+    })\n+}\n+\n+#[bench]\n+pub fn clone_fat_val_100_and_into_iter(b: &mut Bencher) {\n+    let src = fat_val_map(100);\n+    b.iter(|| src.clone().into_iter().count())\n+}\n+\n+#[bench]\n+pub fn clone_fat_val_100_and_pop_all(b: &mut Bencher) {\n+    let src = fat_val_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        while map.pop_first().is_some() {}\n+        map\n+    });\n+}\n+\n+#[bench]\n+pub fn clone_fat_val_100_and_remove_all(b: &mut Bencher) {\n+    let src = fat_val_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        while let Some(elt) = map.iter().map(|(&i, _)| i).next() {\n+            let v = map.remove(&elt);\n+            debug_assert!(v.is_some());\n+        }\n+        map\n+    });\n+}\n+\n+#[bench]\n+pub fn clone_fat_val_100_and_remove_half(b: &mut Bencher) {\n+    let src = fat_val_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        for i in (0..100).step_by(2) {\n+            let v = map.remove(&i);\n+            debug_assert!(v.is_some());\n+        }\n+        assert_eq!(map.len(), 100 / 2);\n+        map\n+    })\n+}\n+\n+#[bench]\n+pub fn clone_fat_100(b: &mut Bencher) {\n+    let src = fat_map(100);\n+    b.iter(|| src.clone())\n+}\n+\n+#[bench]\n+pub fn clone_fat_100_and_clear(b: &mut Bencher) {\n+    let src = fat_map(100);\n+    b.iter(|| src.clone().clear())\n+}\n+\n+#[bench]\n+pub fn clone_fat_100_and_drain_all(b: &mut Bencher) {\n+    let src = fat_map(100);\n+    b.iter(|| src.clone().drain_filter(|_, _| true).count())\n+}\n+\n+#[bench]\n+pub fn clone_fat_100_and_drain_half(b: &mut Bencher) {\n+    let src = fat_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        assert_eq!(map.drain_filter(|i, _| i[0] % 2 == 0).count(), 100 / 2);\n+        assert_eq!(map.len(), 100 / 2);\n+    })\n+}\n+\n+#[bench]\n+pub fn clone_fat_100_and_into_iter(b: &mut Bencher) {\n+    let src = fat_map(100);\n+    b.iter(|| src.clone().into_iter().count())\n+}\n+\n+#[bench]\n+pub fn clone_fat_100_and_pop_all(b: &mut Bencher) {\n+    let src = fat_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        while map.pop_first().is_some() {}\n+        map\n+    });\n+}\n+\n+#[bench]\n+pub fn clone_fat_100_and_remove_all(b: &mut Bencher) {\n+    let src = fat_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        while let Some(elt) = map.iter().map(|(&i, _)| i).next() {\n+            let v = map.remove(&elt);\n+            debug_assert!(v.is_some());\n+        }\n+        map\n+    });\n+}\n+\n+#[bench]\n+pub fn clone_fat_100_and_remove_half(b: &mut Bencher) {\n+    let src = fat_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        for i in (0..100).step_by(2) {\n+            let v = map.remove(&[i; FAT]);\n+            debug_assert!(v.is_some());\n+        }\n+        assert_eq!(map.len(), 100 / 2);\n+        map\n+    })\n+}"}, {"sha": "07bf5093727c04b4589f7260416a1e275f0ce717", "filename": "library/alloc/benches/btree/set.rs", "status": "modified", "additions": 30, "deletions": 22, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/602f9aab89791ac2e63d0a41731ddf0a9b727f29/library%2Falloc%2Fbenches%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/602f9aab89791ac2e63d0a41731ddf0a9b727f29/library%2Falloc%2Fbenches%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Fbtree%2Fset.rs?ref=602f9aab89791ac2e63d0a41731ddf0a9b727f29", "patch": "@@ -50,27 +50,31 @@ macro_rules! set_bench {\n     };\n }\n \n+fn slim_set(n: usize) -> BTreeSet<usize> {\n+    (0..n).collect::<BTreeSet<_>>()\n+}\n+\n #[bench]\n pub fn clone_100(b: &mut Bencher) {\n-    let src = pos(100);\n+    let src = slim_set(100);\n     b.iter(|| src.clone())\n }\n \n #[bench]\n pub fn clone_100_and_clear(b: &mut Bencher) {\n-    let src = pos(100);\n+    let src = slim_set(100);\n     b.iter(|| src.clone().clear())\n }\n \n #[bench]\n pub fn clone_100_and_drain_all(b: &mut Bencher) {\n-    let src = pos(100);\n+    let src = slim_set(100);\n     b.iter(|| src.clone().drain_filter(|_| true).count())\n }\n \n #[bench]\n pub fn clone_100_and_drain_half(b: &mut Bencher) {\n-    let src = pos(100);\n+    let src = slim_set(100);\n     b.iter(|| {\n         let mut set = src.clone();\n         assert_eq!(set.drain_filter(|i| i % 2 == 0).count(), 100 / 2);\n@@ -80,13 +84,13 @@ pub fn clone_100_and_drain_half(b: &mut Bencher) {\n \n #[bench]\n pub fn clone_100_and_into_iter(b: &mut Bencher) {\n-    let src = pos(100);\n+    let src = slim_set(100);\n     b.iter(|| src.clone().into_iter().count())\n }\n \n #[bench]\n pub fn clone_100_and_pop_all(b: &mut Bencher) {\n-    let src = pos(100);\n+    let src = slim_set(100);\n     b.iter(|| {\n         let mut set = src.clone();\n         while set.pop_first().is_some() {}\n@@ -96,23 +100,25 @@ pub fn clone_100_and_pop_all(b: &mut Bencher) {\n \n #[bench]\n pub fn clone_100_and_remove_all(b: &mut Bencher) {\n-    let src = pos(100);\n+    let src = slim_set(100);\n     b.iter(|| {\n         let mut set = src.clone();\n         while let Some(elt) = set.iter().copied().next() {\n-            set.remove(&elt);\n+            let ok = set.remove(&elt);\n+            debug_assert!(ok);\n         }\n         set\n     });\n }\n \n #[bench]\n pub fn clone_100_and_remove_half(b: &mut Bencher) {\n-    let src = pos(100);\n+    let src = slim_set(100);\n     b.iter(|| {\n         let mut set = src.clone();\n-        for i in (2..=100 as i32).step_by(2) {\n-            set.remove(&i);\n+        for i in (0..100).step_by(2) {\n+            let ok = set.remove(&i);\n+            debug_assert!(ok);\n         }\n         assert_eq!(set.len(), 100 / 2);\n         set\n@@ -121,25 +127,25 @@ pub fn clone_100_and_remove_half(b: &mut Bencher) {\n \n #[bench]\n pub fn clone_10k(b: &mut Bencher) {\n-    let src = pos(10_000);\n+    let src = slim_set(10_000);\n     b.iter(|| src.clone())\n }\n \n #[bench]\n pub fn clone_10k_and_clear(b: &mut Bencher) {\n-    let src = pos(10_000);\n+    let src = slim_set(10_000);\n     b.iter(|| src.clone().clear())\n }\n \n #[bench]\n pub fn clone_10k_and_drain_all(b: &mut Bencher) {\n-    let src = pos(10_000);\n+    let src = slim_set(10_000);\n     b.iter(|| src.clone().drain_filter(|_| true).count())\n }\n \n #[bench]\n pub fn clone_10k_and_drain_half(b: &mut Bencher) {\n-    let src = pos(10_000);\n+    let src = slim_set(10_000);\n     b.iter(|| {\n         let mut set = src.clone();\n         assert_eq!(set.drain_filter(|i| i % 2 == 0).count(), 10_000 / 2);\n@@ -149,13 +155,13 @@ pub fn clone_10k_and_drain_half(b: &mut Bencher) {\n \n #[bench]\n pub fn clone_10k_and_into_iter(b: &mut Bencher) {\n-    let src = pos(10_000);\n+    let src = slim_set(10_000);\n     b.iter(|| src.clone().into_iter().count())\n }\n \n #[bench]\n pub fn clone_10k_and_pop_all(b: &mut Bencher) {\n-    let src = pos(10_000);\n+    let src = slim_set(10_000);\n     b.iter(|| {\n         let mut set = src.clone();\n         while set.pop_first().is_some() {}\n@@ -165,23 +171,25 @@ pub fn clone_10k_and_pop_all(b: &mut Bencher) {\n \n #[bench]\n pub fn clone_10k_and_remove_all(b: &mut Bencher) {\n-    let src = pos(10_000);\n+    let src = slim_set(10_000);\n     b.iter(|| {\n         let mut set = src.clone();\n         while let Some(elt) = set.iter().copied().next() {\n-            set.remove(&elt);\n+            let ok = set.remove(&elt);\n+            debug_assert!(ok);\n         }\n         set\n     });\n }\n \n #[bench]\n pub fn clone_10k_and_remove_half(b: &mut Bencher) {\n-    let src = pos(10_000);\n+    let src = slim_set(10_000);\n     b.iter(|| {\n         let mut set = src.clone();\n-        for i in (2..=10_000 as i32).step_by(2) {\n-            set.remove(&i);\n+        for i in (0..10_000).step_by(2) {\n+            let ok = set.remove(&i);\n+            debug_assert!(ok);\n         }\n         assert_eq!(set.len(), 10_000 / 2);\n         set"}]}