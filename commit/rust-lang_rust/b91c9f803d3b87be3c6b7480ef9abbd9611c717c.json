{"sha": "b91c9f803d3b87be3c6b7480ef9abbd9611c717c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5MWM5ZjgwM2QzYjg3YmUzYzZiNzQ4MGVmOWFiYmQ5NjExYzcxN2M=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-04-05T19:06:42Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-04-05T22:18:26Z"}, "message": "simplify typing rule for vector addition: use mutability of LHS", "tree": {"sha": "ccc08d1df5318c4a261f5ed3aed6aae2cb91838a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ccc08d1df5318c4a261f5ed3aed6aae2cb91838a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b91c9f803d3b87be3c6b7480ef9abbd9611c717c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b91c9f803d3b87be3c6b7480ef9abbd9611c717c", "html_url": "https://github.com/rust-lang/rust/commit/b91c9f803d3b87be3c6b7480ef9abbd9611c717c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b91c9f803d3b87be3c6b7480ef9abbd9611c717c/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79cbdba03760347393778607be2127763829a570", "url": "https://api.github.com/repos/rust-lang/rust/commits/79cbdba03760347393778607be2127763829a570", "html_url": "https://github.com/rust-lang/rust/commit/79cbdba03760347393778607be2127763829a570"}], "stats": {"total": 531, "additions": 516, "deletions": 15}, "files": [{"sha": "5efa594ba21240937072d734dbf459fb6aa8a957", "filename": "src/libcore/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b91c9f803d3b87be3c6b7480ef9abbd9611c717c/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b91c9f803d3b87be3c6b7480ef9abbd9611c717c/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=b91c9f803d3b87be3c6b7480ef9abbd9611c717c", "patch": "@@ -849,7 +849,7 @@ mod tests {\n       };\n       assert (ostream as uint != 0u);\n       let s = \"hello\";\n-      let mut buf = str::bytes(s) + [0 as u8];\n+      let mut buf = vec::to_mut(str::bytes(s) + [0 as u8]);\n       vec::as_mut_buf(buf) {|b|\n          assert (libc::fwrite(b as *c_void, 1u, str::len(s) + 1u, ostream) ==\n                  buf.len())};"}, {"sha": "419455e2399311574c5ca06296c5b15c577b1d73", "filename": "src/libcore/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b91c9f803d3b87be3c6b7480ef9abbd9611c717c/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b91c9f803d3b87be3c6b7480ef9abbd9611c717c/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=b91c9f803d3b87be3c6b7480ef9abbd9611c717c", "patch": "@@ -1658,7 +1658,7 @@ mod unsafe {\n    Does not verify that the vector contains valid UTF-8.\n    \"]\n    unsafe fn from_bytes(v: [const u8]) -> str unsafe {\n-       let mut vcopy: [u8] = v + [0u8];\n+       let vcopy = v + [0u8];\n        let scopy: str = ::unsafe::reinterpret_cast(vcopy);\n        ::unsafe::forget(vcopy);\n        ret scopy;"}, {"sha": "802671e2c81cf84aaa3fbbfef0ad5a9f64483d28", "filename": "src/rustc/middle/pairwise.rs", "status": "added", "additions": 407, "deletions": 0, "changes": 407, "blob_url": "https://github.com/rust-lang/rust/blob/b91c9f803d3b87be3c6b7480ef9abbd9611c717c/src%2Frustc%2Fmiddle%2Fpairwise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b91c9f803d3b87be3c6b7480ef9abbd9611c717c/src%2Frustc%2Fmiddle%2Fpairwise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fpairwise.rs?ref=b91c9f803d3b87be3c6b7480ef9abbd9611c717c", "patch": "@@ -0,0 +1,407 @@\n+iface lattice<T> {\n+    fn lub(T, T) -> cres<T>;\n+    fn glb(T, T) -> cres<T>;\n+}\n+\n+iface lattice_op<T> {\n+    fn bnd<V:copy>(b: bounds<V>) -> option<V>;\n+    fn with_bnd<V:copy>(b: bounds<V>, v: V) -> bounds<V>;\n+}\n+\n+iface pairwise {\n+    fn infcx() -> infer_ctxt;\n+    fn tag() -> str;\n+\n+    fn c_tys(t1: ty::t, t2: ty::t) -> cres<ty::t>;\n+    fn c_flds(a: ty::field, b: ty::field) -> cres<ty::field>;\n+    fn c_bot(b: ty::t) -> cres<ty::t>;\n+    fn c_mts(a: ty::mt, b: ty::mt) -> cres<ty::mt>;\n+    fn c_contratys(t1: ty::t, t2: ty::t) -> cres<ty::t>;\n+    fn c_protos(p1: ast::proto, p2: ast::proto) -> cres<ast::proto>;\n+    fn c_ret_styles(r1: ret_style, r2: ret_style) -> cres<ret_style>;\n+\n+    // Combining regions (along with some specific cases that are\n+    // different for LUB/GLB):\n+    fn c_regions(\n+        a: ty::region, b: ty::region) -> cres<ty::region>;\n+    fn c_regions_scope_scope(\n+        a: ty::region, a_id: ast::node_id,\n+        b: ty::region, b_id: ast::node_id) -> cres<ty::region>;\n+    fn c_regions_free_scope(\n+        a: ty::region, a_id: ast::node_id, a_br: ty::bound_region,\n+        b: ty::region, b_id: ast::node_id) -> cres<ty::region>;\n+}\n+\n+fn c_vars<V:copy vid, PW:pairwise, T:copy to_str st>(\n+    self: PW, vb: vals_and_bindings<V, T>,\n+    a_t: T, a_vid: V, b_vid: V,\n+    c_ts: fn(T, T) -> cres<T>) -> cres<T> {\n+\n+    // The comments in this function are written for LUB and types,\n+    // but they apply equally well to GLB and regions if you inverse\n+    // upper/lower/sub/super/etc.\n+\n+    // Need to find a type that is a supertype of both a and b:\n+    let {root: a_vid, bounds: a_bounds} = self.infcx().get(vb, a_vid);\n+    let {root: b_vid, bounds: b_bounds} = self.infcx().get(vb, b_vid);\n+\n+    #debug[\"%s.c_vars(%s=%s <: %s=%s)\",\n+           self.tag(),\n+           a_vid.to_str(), a_bounds.to_str(self.infcx()),\n+           b_vid.to_str(), b_bounds.to_str(self.infcx())];\n+\n+    if a_vid == b_vid {\n+        ret ok(a_t);\n+    }\n+\n+    // If both A and B have an UB type, then we can just compute the\n+    // LUB of those types:\n+    let a_bnd = self.bnd(a_bounds), b_bnd = self.bnd(b_bounds);\n+    alt (a_bnd, b_bnd) {\n+      (some(a_ty), some(b_ty)) {\n+        alt self.infcx().try {|| c_ts(a_ty, b_ty) } {\n+            ok(t) { ret ok(t); }\n+            err(_) { /*fallthrough */ }\n+        }\n+      }\n+      _ {/*fallthrough*/}\n+    }\n+\n+    // Otherwise, we need to merge A and B into one variable.  We can\n+    // then use either variable as an upper bound:\n+    self.infcx().vars(vb, a_vid, b_vid).then {||\n+        ok(a_t)\n+    }\n+}\n+\n+fn c_var_t<V:copy vid, PW:pairwise, T:copy to_str st>(\n+    self: PW, vb: vals_and_bindings<V, T>,\n+    a_vid: V, b: T,\n+    c_ts: fn(T, T) -> cres<T>) -> cres<T> {\n+\n+    let {root: a_id, bounds: a_bounds} = self.infcx().get(vb, a_vid);\n+\n+    // The comments in this function are written for LUB, but they\n+    // apply equally well to GLB if you inverse upper/lower/sub/super/etc.\n+\n+    #debug[\"%s.c_var_ty(%s=%s <: %s)\",\n+           self.tag(),\n+           a_id.to_str(), a_bounds.to_str(self.infcx()),\n+           b.to_str(self.infcx())];\n+\n+    alt self.bnd(a_bounds) {\n+      some(a_bnd) {\n+        // If a has an upper bound, return it.\n+        ret c_ts(a_bnd, b);\n+      }\n+      none {\n+        // If a does not have an upper bound, make b the upper bound of a\n+        // and then return b.\n+        let a_bounds = self.with_bnd(a_bounds, b);\n+        self.infcx().bnds(a_bounds.lb, a_bounds.ub).then {||\n+            self.infcx().set(vb, a_id, bounded(a_bounds));\n+            ok(b)\n+        }\n+      }\n+    }\n+}\n+\n+fn c_tuptys<PW:pairwise>(self: PW, as: [ty::t], bs: [ty::t])\n+    -> cres<[ty::t]> {\n+\n+    if check vec::same_length(as, bs) {\n+        map2(as, bs) {|a, b| self.c_tys(a, b) }\n+    } else {\n+        err(ty::terr_tuple_size(as.len(), bs.len()))\n+    }\n+}\n+\n+fn c_tps<PW:pairwise>(self: PW, _did: ast::def_id, as: [ty::t], bs: [ty::t])\n+    -> cres<[ty::t]> {\n+    // FIXME #1973 lookup the declared variance of the type parameters\n+    // based on did\n+    if check vec::same_length(as, bs) {\n+        map2(as, bs) {|a,b| self.c_tys(a, b) }\n+    } else {\n+        err(ty::terr_ty_param_size(as.len(), bs.len()))\n+    }\n+}\n+\n+fn c_fieldvecs<PW:pairwise>(\n+    self: PW, as: [ty::field], bs: [ty::field])\n+    -> cres<[ty::field]> {\n+\n+    if check vec::same_length(as, bs) {\n+        map2(as, bs) {|a,b| self.c_flds(a, b) }\n+    } else {\n+        err(ty::terr_record_size(as.len(), bs.len()))\n+    }\n+}\n+\n+fn c_flds<PW:pairwise>(\n+    self: PW, a: ty::field, b: ty::field) -> cres<ty::field> {\n+\n+    if a.ident == b.ident {\n+        self.c_mts(a.mt, b.mt).chain {|mt|\n+            ok({ident: a.ident, mt: mt})\n+        }\n+    } else {\n+        err(ty::terr_record_fields(a.ident, b.ident))\n+    }\n+}\n+\n+fn c_modes<PW:pairwise>(\n+    self: PW, a: ast::mode, b: ast::mode)\n+    -> cres<ast::mode> {\n+\n+    let tcx = self.infcx().tcx;\n+    ty::unify_mode(tcx, a, b)\n+}\n+\n+fn c_args<PW:pairwise>(\n+    self: PW, a: ty::arg, b: ty::arg)\n+    -> cres<ty::arg> {\n+\n+    self.c_modes(a.mode, b.mode).chain {|m|\n+        // Note: contravariant\n+        self.c_contratys(b.ty, a.ty).chain {|t|\n+            ok({mode: m, ty: t})\n+        }\n+    }\n+}\n+\n+fn c_argvecs<PW:pairwise>(\n+    self: PW, a_args: [ty::arg], b_args: [ty::arg]) -> cres<[ty::arg]> {\n+\n+    if check vec::same_length(a_args, b_args) {\n+        map2(a_args, b_args) {|a, b| self.c_args(a, b) }\n+    } else {\n+        err(ty::terr_arg_count)\n+    }\n+}\n+\n+fn c_fns<PW:pairwise>(\n+    self: PW, a_f: ty::fn_ty, b_f: ty::fn_ty) -> cres<ty::fn_ty> {\n+\n+    self.c_protos(a_f.proto, b_f.proto).chain {|p|\n+        self.c_ret_styles(a_f.ret_style, b_f.ret_style).chain {|rs|\n+            self.c_argvecs(a_f.inputs, b_f.inputs).chain {|inputs|\n+                self.c_tys(a_f.output, b_f.output).chain {|output|\n+                    //FIXME self.infcx().constrvecs(a_f.constraints,\n+                    //FIXME                         b_f.constraints).then {||\n+                        ok({proto: p,\n+                            inputs: inputs,\n+                            output: output,\n+                            ret_style: rs,\n+                            constraints: a_f.constraints})\n+                    //FIXME }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn c_tys<PW:pairwise>(\n+    self: PW, a: ty::t, b: ty::t) -> cres<ty::t> {\n+\n+    let tcx = self.infcx().tcx;\n+\n+    #debug(\"%s.c_tys(%s, %s)\",\n+           self.tag(),\n+           ty_to_str(tcx, a),\n+           ty_to_str(tcx, b));\n+\n+    // Fast path.\n+    if a == b { ret ok(a); }\n+\n+    alt (ty::get(a).struct, ty::get(b).struct) {\n+      (ty::ty_bot, _) { self.c_bot(b) }\n+      (_, ty::ty_bot) { self.c_bot(b) }\n+\n+      (ty::ty_var(a_id), ty::ty_var(b_id)) {\n+        self.c_vars(self.infcx().vb,\n+               a, a_id, b_id,\n+               {|x, y| self.c_tys(x, y) })\n+      }\n+\n+      // Note that the LUB/GLB operations are commutative:\n+      (ty::ty_var(v_id), _) {\n+        self.c_var_t(self.infcx().vb,\n+                v_id, b,\n+                {|x, y| self.c_tys(x, y) })\n+      }\n+      (_, ty::ty_var(v_id)) {\n+        self.c_var_t(self.infcx().vb,\n+                v_id, a,\n+                {|x, y| self.c_tys(x, y) })\n+      }\n+\n+      (ty::ty_nil, _) |\n+      (ty::ty_bool, _) |\n+      (ty::ty_int(_), _) |\n+      (ty::ty_uint(_), _) |\n+      (ty::ty_float(_), _) |\n+      (ty::ty_str, _) {\n+        let cfg = tcx.sess.targ_cfg;\n+        if ty::mach_sty(cfg, a) == ty::mach_sty(cfg, b) {\n+            ok(a)\n+        } else {\n+            err(ty::terr_mismatch)\n+        }\n+      }\n+\n+      (ty::ty_param(a_n, _), ty::ty_param(b_n, _)) if a_n == b_n {\n+        ok(a)\n+      }\n+\n+      (ty::ty_enum(a_id, a_tps), ty::ty_enum(b_id, b_tps))\n+      if a_id == b_id {\n+        self.c_tps(a_id, a_tps, b_tps).chain {|tps|\n+            ok(ty::mk_enum(tcx, a_id, tps))\n+        }\n+      }\n+\n+      (ty::ty_iface(a_id, a_tps), ty::ty_iface(b_id, b_tps))\n+      if a_id == b_id {\n+        self.c_tps(a_id, a_tps, b_tps).chain {|tps|\n+            ok(ty::mk_iface(tcx, a_id, tps))\n+        }\n+      }\n+\n+      (ty::ty_class(a_id, a_tps), ty::ty_class(b_id, b_tps))\n+      if a_id == b_id {\n+        // FIXME variance\n+        self.c_tps(a_id, a_tps, b_tps).chain {|tps|\n+            ok(ty::mk_class(tcx, a_id, tps))\n+        }\n+      }\n+\n+      (ty::ty_box(a_mt), ty::ty_box(b_mt)) {\n+        self.c_mts(a_mt, b_mt).chain {|mt|\n+            ok(ty::mk_box(tcx, mt))\n+        }\n+      }\n+\n+      (ty::ty_uniq(a_mt), ty::ty_uniq(b_mt)) {\n+        self.c_mts(a_mt, b_mt).chain {|mt|\n+            ok(ty::mk_uniq(tcx, mt))\n+        }\n+      }\n+\n+      (ty::ty_vec(a_mt), ty::ty_vec(b_mt)) {\n+        self.c_mts(a_mt, b_mt).chain {|mt|\n+            ok(ty::mk_vec(tcx, mt))\n+        }\n+      }\n+\n+      (ty::ty_ptr(a_mt), ty::ty_ptr(b_mt)) {\n+        self.c_mts(a_mt, b_mt).chain {|mt|\n+            ok(ty::mk_ptr(tcx, mt))\n+        }\n+      }\n+\n+      (ty::ty_rptr(a_r, a_mt), ty::ty_rptr(b_r, b_mt)) {\n+        self.c_regions(a_r, b_r).chain {|r|\n+            self.c_mts(a_mt, b_mt).chain {|mt|\n+                ok(ty::mk_rptr(tcx, r, mt))\n+            }\n+        }\n+      }\n+\n+      (ty::ty_res(a_id, a_t, a_tps), ty::ty_res(b_id, b_t, b_tps))\n+      if a_id == b_id {\n+        self.c_tys(a_t, b_t).chain {|t|\n+            self.c_tps(a_id, a_tps, b_tps).chain {|tps|\n+                ok(ty::mk_res(tcx, a_id, t, tps))\n+            }\n+        }\n+      }\n+\n+      (ty::ty_rec(a_fields), ty::ty_rec(b_fields)) {\n+        self.c_fieldvecs(a_fields, b_fields).chain {|fs|\n+            ok(ty::mk_rec(tcx, fs))\n+        }\n+      }\n+\n+      (ty::ty_tup(a_tys), ty::ty_tup(b_tys)) {\n+        self.c_tuptys(a_tys, b_tys).chain {|ts|\n+            ok(ty::mk_tup(tcx, ts))\n+        }\n+      }\n+\n+      (ty::ty_fn(a_fty), ty::ty_fn(b_fty)) {\n+        self.c_fns(a_fty, b_fty).chain {|fty|\n+            ok(ty::mk_fn(tcx, fty))\n+        }\n+      }\n+\n+      (ty::ty_constr(a_t, a_constrs), ty::ty_constr(b_t, b_constrs)) {\n+        self.c_tys(a_t, b_t).chain {|t|\n+            self.infcx().constrvecs(a_constrs, b_constrs).then {||\n+                ok(ty::mk_constr(tcx, t, a_constrs))\n+            }\n+        }\n+      }\n+\n+      _ { err(ty::terr_mismatch) }\n+    }\n+}\n+\n+fn c_regions<PW:pairwise>(\n+    self: PW, a: ty::region, b: ty::region) -> cres<ty::region> {\n+\n+    #debug[\"%s.c_regions(%?, %?)\",\n+           self.tag(),\n+           a.to_str(self.infcx()),\n+           b.to_str(self.infcx())];\n+\n+    alt (a, b) {\n+      (ty::re_var(a_id), ty::re_var(b_id)) {\n+        self.c_vars(self.infcx().rb,\n+               a, a_id, b_id,\n+               {|x, y| self.c_regions(x, y) })\n+      }\n+\n+      (ty::re_var(v_id), r) |\n+      (r, ty::re_var(v_id)) {\n+        self.c_var_t(self.infcx().rb,\n+                v_id, r,\n+                {|x, y| self.c_regions(x, y) })\n+      }\n+\n+      (f @ ty::re_free(f_id, f_br), s @ ty::re_scope(s_id)) |\n+      (s @ ty::re_scope(s_id), f @ ty::re_free(f_id, f_br)) {\n+        self.c_regions_free_scope(f, f_id, f_br, s, s_id)\n+      }\n+\n+      (ty::re_scope(a_id), ty::re_scope(b_id)) {\n+        self.c_regions_scope_scope(a, a_id, b, b_id)\n+      }\n+\n+      // For these types, we cannot define any additional relationship:\n+      (ty::re_free(_, _), ty::re_free(_, _)) |\n+      (ty::re_bound(_), ty::re_bound(_)) |\n+      (ty::re_bound(_), ty::re_free(_, _)) |\n+      (ty::re_bound(_), ty::re_scope(_)) |\n+      (ty::re_free(_, _), ty::re_bound(_)) |\n+      (ty::re_scope(_), ty::re_bound(_)) {\n+        if a == b {\n+            #debug[\"... yes, %s == %s.\",\n+                   a.to_str(self.infcx()),\n+                   b.to_str(self.infcx())];\n+            ok(a)\n+        } else {\n+            #debug[\"... no, %s != %s.\",\n+                   a.to_str(self.infcx()),\n+                   b.to_str(self.infcx())];\n+            err(ty::terr_regions_differ(false, b, a))\n+        }\n+      }\n+\n+      (ty::re_default, _) |\n+      (_, ty::re_default) {\n+        // actually a compiler bug, I think.\n+        err(ty::terr_regions_differ(false, b, a))\n+      }\n+    }\n+}"}, {"sha": "8fcdcbbc86d6e1ccc3fe18813f0750807e4ae1b3", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b91c9f803d3b87be3c6b7480ef9abbd9611c717c/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b91c9f803d3b87be3c6b7480ef9abbd9611c717c/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=b91c9f803d3b87be3c6b7480ef9abbd9611c717c", "patch": "@@ -2676,21 +2676,18 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         let lhs_t = structurally_resolved_type(fcx, lhs.span, lhs_t);\n         ret alt (op, ty::get(lhs_t).struct) {\n           (ast::add, ty::ty_vec(lhs_mt)) {\n-            // For adding vectors with type L=[M TL] and R=[M TR], the result\n-            // is somewhat subtle.  Let L_c=[const TL] and R_c=[const TR] be\n-            // const versions of the vectors in L and R.  Next, let T be a\n-            // fresh type variable where TL <: T and TR <: T.  Then the result\n-            // type is a fresh type variable T1 where T1 <: [const T].  This\n-            // allows the result to be either a mut or immutable vector,\n-            // depending on external demands.\n-            let const_vec_t =\n-                ty::mk_vec(tcx, {ty: next_ty_var(fcx),\n-                                 mutbl: ast::m_const});\n+            // For adding vectors with type L=[ML TL] and R=[MR TR], the the\n+            // result [ML T] where TL <: T and TR <: T.  In other words, the\n+            // result type is (generally) the LUB of (TL, TR) and takes the\n+            // mutability from the LHS.\n+            let t_var = next_ty_var(fcx);\n+            let const_vec_t = ty::mk_vec(tcx, {ty: t_var,\n+                                               mutbl: ast::m_const});\n             demand::simple(fcx, lhs.span, const_vec_t, lhs_t);\n             let rhs_bot = check_expr_with(fcx, rhs, const_vec_t);\n-            let result_var = next_ty_var(fcx);\n-            demand::simple(fcx, lhs.span, const_vec_t, result_var);\n-            fcx.write_ty(expr.id, result_var);\n+            let result_vec_t = ty::mk_vec(tcx, {ty: t_var,\n+                                                mutbl: lhs_mt.mutbl});\n+            fcx.write_ty(expr.id, result_vec_t);\n             lhs_bot | rhs_bot\n           }\n "}, {"sha": "2d96f0c6810868f818edd75634b63aaa568de885", "filename": "src/test/compile-fail/vec-add.rs", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/b91c9f803d3b87be3c6b7480ef9abbd9611c717c/src%2Ftest%2Fcompile-fail%2Fvec-add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b91c9f803d3b87be3c6b7480ef9abbd9611c717c/src%2Ftest%2Fcompile-fail%2Fvec-add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-add.rs?ref=b91c9f803d3b87be3c6b7480ef9abbd9611c717c", "patch": "@@ -0,0 +1,89 @@\n+fn add(i: [int], m: [mut int], c: [const int]) {\n+\n+    // Check that:\n+    //  (1) vectors of any two mutabilities can be added\n+    //  (2) result has mutability of lhs\n+\n+   add(i + [3],\n+       m + [3],\n+       c + [3]);\n+\n+   add(i + [mut 3],\n+       m + [mut 3],\n+       c + [mut 3]);\n+\n+   add(i + i,\n+       m + i,\n+       c + i);\n+\n+   add(i + m,\n+       m + m,\n+       c + m);\n+\n+   add(i + c,\n+       m + c,\n+       c + c);\n+\n+   add(m + [3], //! ERROR mismatched types\n+       m + [3],\n+       m + [3]);\n+\n+   add(i + [3],\n+       i + [3], //! ERROR mismatched types\n+       i + [3]);\n+\n+   add(c + [3], //! ERROR mismatched types\n+       c + [3], //! ERROR mismatched types\n+       c + [3]);\n+\n+   add(m + [mut 3], //! ERROR mismatched types\n+       m + [mut 3],\n+       m + [mut 3]);\n+\n+   add(i + [mut 3],\n+       i + [mut 3], //! ERROR mismatched types\n+       i + [mut 3]);\n+\n+   add(c + [mut 3], //! ERROR mismatched types\n+       c + [mut 3], //! ERROR mismatched types\n+       c + [mut 3]);\n+\n+   add(m + i, //! ERROR mismatched types\n+       m + i,\n+       m + i);\n+\n+   add(i + i,\n+       i + i, //! ERROR mismatched types\n+       i + i);\n+\n+   add(c + i, //! ERROR mismatched types\n+       c + i, //! ERROR mismatched types\n+       c + i);\n+\n+   add(m + m, //! ERROR mismatched types\n+       m + m,\n+       m + m);\n+\n+   add(i + m,\n+       i + m, //! ERROR mismatched types\n+       i + m);\n+\n+   add(c + m, //! ERROR mismatched types\n+       c + m, //! ERROR mismatched types\n+       c + m);\n+\n+   add(m + c, //! ERROR mismatched types\n+       m + c,\n+       m + c);\n+\n+   add(i + c,\n+       i + c, //! ERROR mismatched types\n+       i + c);\n+\n+   add(c + c, //! ERROR mismatched types\n+       c + c, //! ERROR mismatched types\n+       c + c);\n+}\n+\n+fn main() {\n+}"}, {"sha": "cb6b63059f4a2761974012dc095911144eef604c", "filename": "src/test/run-pass/option-ext.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b91c9f803d3b87be3c6b7480ef9abbd9611c717c/src%2Ftest%2Frun-pass%2Foption-ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b91c9f803d3b87be3c6b7480ef9abbd9611c717c/src%2Ftest%2Frun-pass%2Foption-ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foption-ext.rs?ref=b91c9f803d3b87be3c6b7480ef9abbd9611c717c", "patch": "@@ -0,0 +1,8 @@\n+fn main(args: [str]) {\n+    let thing = \"{{ f }}\";\n+    let f = str::find_str(thing, \"{{\");\n+\n+    if f.is_none() {\n+        io::println(\"None!\");\n+    }\n+}\n\\ No newline at end of file"}]}