{"sha": "dd64bd83b72a669a20d1b7d938f1ff76aceb0cef", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkNjRiZDgzYjcyYTY2OWEyMGQxYjdkOTM4ZjFmZjc2YWNlYjBjZWY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-22T07:45:41Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-23T16:45:19Z"}, "message": "std: Move NativeMutex from &mut self to &self\n\nThe proper usage of shared types is now sharing through `&self` rather than\n`&mut self` because the mutable version will provide stronger guarantees (no\naliasing on *any* thread).", "tree": {"sha": "c1988740d6ae11cebfba3a3a946c4311425db55a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1988740d6ae11cebfba3a3a946c4311425db55a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd64bd83b72a669a20d1b7d938f1ff76aceb0cef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd64bd83b72a669a20d1b7d938f1ff76aceb0cef", "html_url": "https://github.com/rust-lang/rust/commit/dd64bd83b72a669a20d1b7d938f1ff76aceb0cef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd64bd83b72a669a20d1b7d938f1ff76aceb0cef/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da118e88d5f5814e5a7fad4dbeb8cc125054c5da", "url": "https://api.github.com/repos/rust-lang/rust/commits/da118e88d5f5814e5a7fad4dbeb8cc125054c5da", "html_url": "https://github.com/rust-lang/rust/commit/da118e88d5f5814e5a7fad4dbeb8cc125054c5da"}], "stats": {"total": 121, "additions": 65, "deletions": 56}, "files": [{"sha": "01e620df2d675dda9e3bfc43b6c2bd4679816e62", "filename": "src/libgreen/simple.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dd64bd83b72a669a20d1b7d938f1ff76aceb0cef/src%2Flibgreen%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd64bd83b72a669a20d1b7d938f1ff76aceb0cef/src%2Flibgreen%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsimple.rs?ref=dd64bd83b72a669a20d1b7d938f1ff76aceb0cef", "patch": "@@ -40,7 +40,7 @@ impl Runtime for SimpleTask {\n         // See libnative/task.rs for what's going on here with the `awoken`\n         // field and the while loop around wait()\n         unsafe {\n-            let mut guard = (*me).lock.lock();\n+            let guard = (*me).lock.lock();\n             (*me).awoken = false;\n             match f(task) {\n                 Ok(()) => {\n@@ -60,7 +60,7 @@ impl Runtime for SimpleTask {\n         to_wake.put_runtime(self as ~Runtime);\n         unsafe {\n             cast::forget(to_wake);\n-            let mut guard = (*me).lock.lock();\n+            let guard = (*me).lock.lock();\n             (*me).awoken = true;\n             guard.signal();\n         }"}, {"sha": "e5f70c4e4b31c81698bf18c72cb32305c7d24772", "filename": "src/libnative/io/timer_helper.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd64bd83b72a669a20d1b7d938f1ff76aceb0cef/src%2Flibnative%2Fio%2Ftimer_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd64bd83b72a669a20d1b7d938f1ff76aceb0cef/src%2Flibnative%2Fio%2Ftimer_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_helper.rs?ref=dd64bd83b72a669a20d1b7d938f1ff76aceb0cef", "patch": "@@ -75,7 +75,7 @@ pub fn send(req: Req) {\n fn shutdown() {\n     // Request a shutdown, and then wait for the task to exit\n     unsafe {\n-        let mut guard = TIMER_HELPER_EXIT.lock();\n+        let guard = TIMER_HELPER_EXIT.lock();\n         send(Shutdown);\n         guard.wait();\n         drop(guard);"}, {"sha": "659e417b8ad4bfdf3f4a0d0bbb4a2c322a9595a0", "filename": "src/libnative/task.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dd64bd83b72a669a20d1b7d938f1ff76aceb0cef/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd64bd83b72a669a20d1b7d938f1ff76aceb0cef/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=dd64bd83b72a669a20d1b7d938f1ff76aceb0cef", "patch": "@@ -190,7 +190,7 @@ impl rt::Runtime for Ops {\n             let task = BlockedTask::block(cur_task);\n \n             if times == 1 {\n-                let mut guard = (*me).lock.lock();\n+                let guard = (*me).lock.lock();\n                 (*me).awoken = false;\n                 match f(task) {\n                     Ok(()) => {\n@@ -202,7 +202,7 @@ impl rt::Runtime for Ops {\n                 }\n             } else {\n                 let mut iter = task.make_selectable(times);\n-                let mut guard = (*me).lock.lock();\n+                let guard = (*me).lock.lock();\n                 (*me).awoken = false;\n                 let success = iter.all(|task| {\n                     match f(task) {\n@@ -232,7 +232,7 @@ impl rt::Runtime for Ops {\n             let me = &mut *self as *mut Ops;\n             to_wake.put_runtime(self as ~rt::Runtime);\n             cast::forget(to_wake);\n-            let mut guard = (*me).lock.lock();\n+            let guard = (*me).lock.lock();\n             (*me).awoken = true;\n             guard.signal();\n         }"}, {"sha": "e8ba9d6e62809badaabe510e61a4d3024ee48dbb", "filename": "src/libstd/comm/shared.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd64bd83b72a669a20d1b7d938f1ff76aceb0cef/src%2Flibstd%2Fcomm%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd64bd83b72a669a20d1b7d938f1ff76aceb0cef/src%2Flibstd%2Fcomm%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fshared.rs?ref=dd64bd83b72a669a20d1b7d938f1ff76aceb0cef", "patch": "@@ -68,7 +68,7 @@ pub enum Failure {\n impl<T: Send> Packet<T> {\n     // Creation of a packet *must* be followed by a call to inherit_blocker\n     pub fn new() -> Packet<T> {\n-        let mut p = Packet {\n+        let p = Packet {\n             queue: mpsc::Queue::new(),\n             cnt: atomics::AtomicInt::new(0),\n             steals: 0,"}, {"sha": "932cd7af033d709b45c459c78ee36b4b42c774f1", "filename": "src/libstd/rt/bookkeeping.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dd64bd83b72a669a20d1b7d938f1ff76aceb0cef/src%2Flibstd%2Frt%2Fbookkeeping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd64bd83b72a669a20d1b7d938f1ff76aceb0cef/src%2Flibstd%2Frt%2Fbookkeeping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbookkeeping.rs?ref=dd64bd83b72a669a20d1b7d938f1ff76aceb0cef", "patch": "@@ -34,7 +34,7 @@ pub fn increment() {\n pub fn decrement() {\n     unsafe {\n         if TASK_COUNT.fetch_sub(1, atomics::SeqCst) == 1 {\n-            let mut guard = TASK_LOCK.lock();\n+            let guard = TASK_LOCK.lock();\n             guard.signal();\n         }\n     }\n@@ -44,7 +44,7 @@ pub fn decrement() {\n /// the entry points of native programs\n pub fn wait_for_other_tasks() {\n     unsafe {\n-        let mut guard = TASK_LOCK.lock();\n+        let guard = TASK_LOCK.lock();\n         while TASK_COUNT.load(atomics::SeqCst) > 0 {\n             guard.wait();\n         }"}, {"sha": "9802271e28f269cdba8e3ecaf1fd54d6ceff29e0", "filename": "src/libstd/unstable/mutex.rs", "status": "modified", "additions": 54, "deletions": 45, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/dd64bd83b72a669a20d1b7d938f1ff76aceb0cef/src%2Flibstd%2Funstable%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd64bd83b72a669a20d1b7d938f1ff76aceb0cef/src%2Flibstd%2Funstable%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmutex.rs?ref=dd64bd83b72a669a20d1b7d938f1ff76aceb0cef", "patch": "@@ -86,7 +86,7 @@ pub struct NativeMutex {\n /// then.\n #[must_use]\n pub struct LockGuard<'a> {\n-    priv lock: &'a mut StaticNativeMutex\n+    priv lock: &'a StaticNativeMutex\n }\n \n pub static NATIVE_MUTEX_INIT: StaticNativeMutex = StaticNativeMutex {\n@@ -106,6 +106,7 @@ impl StaticNativeMutex {\n     /// already hold the lock.\n     ///\n     /// # Example\n+    ///\n     /// ```rust\n     /// use std::unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n     /// static mut LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n@@ -114,15 +115,15 @@ impl StaticNativeMutex {\n     ///     // critical section...\n     /// } // automatically unlocked in `_guard`'s destructor\n     /// ```\n-    pub unsafe fn lock<'a>(&'a mut self) -> LockGuard<'a> {\n+    pub unsafe fn lock<'a>(&'a self) -> LockGuard<'a> {\n         self.inner.lock();\n \n         LockGuard { lock: self }\n     }\n \n     /// Attempts to acquire the lock. The value returned is `Some` if\n     /// the attempt succeeded.\n-    pub unsafe fn trylock<'a>(&'a mut self) -> Option<LockGuard<'a>> {\n+    pub unsafe fn trylock<'a>(&'a self) -> Option<LockGuard<'a>> {\n         if self.inner.trylock() {\n             Some(LockGuard { lock: self })\n         } else {\n@@ -134,36 +135,36 @@ impl StaticNativeMutex {\n     ///\n     /// These needs to be paired with a call to `.unlock_noguard`. Prefer using\n     /// `.lock`.\n-    pub unsafe fn lock_noguard(&mut self) { self.inner.lock() }\n+    pub unsafe fn lock_noguard(&self) { self.inner.lock() }\n \n     /// Attempts to acquire the lock without creating a\n     /// `LockGuard`. The value returned is whether the lock was\n     /// acquired or not.\n     ///\n     /// If `true` is returned, this needs to be paired with a call to\n     /// `.unlock_noguard`. Prefer using `.trylock`.\n-    pub unsafe fn trylock_noguard(&mut self) -> bool {\n+    pub unsafe fn trylock_noguard(&self) -> bool {\n         self.inner.trylock()\n     }\n \n     /// Unlocks the lock. This assumes that the current thread already holds the\n     /// lock.\n-    pub unsafe fn unlock_noguard(&mut self) { self.inner.unlock() }\n+    pub unsafe fn unlock_noguard(&self) { self.inner.unlock() }\n \n     /// Block on the internal condition variable.\n     ///\n     /// This function assumes that the lock is already held. Prefer\n     /// using `LockGuard.wait` since that guarantees that the lock is\n     /// held.\n-    pub unsafe fn wait_noguard(&mut self) { self.inner.wait() }\n+    pub unsafe fn wait_noguard(&self) { self.inner.wait() }\n \n     /// Signals a thread in `wait` to wake up\n-    pub unsafe fn signal_noguard(&mut self) { self.inner.signal() }\n+    pub unsafe fn signal_noguard(&self) { self.inner.signal() }\n \n     /// This function is especially unsafe because there are no guarantees made\n     /// that no other thread is currently holding the lock or waiting on the\n     /// condition variable contained inside.\n-    pub unsafe fn destroy(&mut self) { self.inner.destroy() }\n+    pub unsafe fn destroy(&self) { self.inner.destroy() }\n }\n \n impl NativeMutex {\n@@ -190,45 +191,45 @@ impl NativeMutex {\n     ///     } // automatically unlocked in `_guard`'s destructor\n     /// }\n     /// ```\n-    pub unsafe fn lock<'a>(&'a mut self) -> LockGuard<'a> {\n+    pub unsafe fn lock<'a>(&'a self) -> LockGuard<'a> {\n         self.inner.lock()\n     }\n \n     /// Attempts to acquire the lock. The value returned is `Some` if\n     /// the attempt succeeded.\n-    pub unsafe fn trylock<'a>(&'a mut self) -> Option<LockGuard<'a>> {\n+    pub unsafe fn trylock<'a>(&'a self) -> Option<LockGuard<'a>> {\n         self.inner.trylock()\n     }\n \n     /// Acquire the lock without creating a `LockGuard`.\n     ///\n     /// These needs to be paired with a call to `.unlock_noguard`. Prefer using\n     /// `.lock`.\n-    pub unsafe fn lock_noguard(&mut self) { self.inner.lock_noguard() }\n+    pub unsafe fn lock_noguard(&self) { self.inner.lock_noguard() }\n \n     /// Attempts to acquire the lock without creating a\n     /// `LockGuard`. The value returned is whether the lock was\n     /// acquired or not.\n     ///\n     /// If `true` is returned, this needs to be paired with a call to\n     /// `.unlock_noguard`. Prefer using `.trylock`.\n-    pub unsafe fn trylock_noguard(&mut self) -> bool {\n+    pub unsafe fn trylock_noguard(&self) -> bool {\n         self.inner.trylock_noguard()\n     }\n \n     /// Unlocks the lock. This assumes that the current thread already holds the\n     /// lock.\n-    pub unsafe fn unlock_noguard(&mut self) { self.inner.unlock_noguard() }\n+    pub unsafe fn unlock_noguard(&self) { self.inner.unlock_noguard() }\n \n     /// Block on the internal condition variable.\n     ///\n     /// This function assumes that the lock is already held. Prefer\n     /// using `LockGuard.wait` since that guarantees that the lock is\n     /// held.\n-    pub unsafe fn wait_noguard(&mut self) { self.inner.wait_noguard() }\n+    pub unsafe fn wait_noguard(&self) { self.inner.wait_noguard() }\n \n     /// Signals a thread in `wait` to wake up\n-    pub unsafe fn signal_noguard(&mut self) { self.inner.signal_noguard() }\n+    pub unsafe fn signal_noguard(&self) { self.inner.signal_noguard() }\n }\n \n impl Drop for NativeMutex {\n@@ -239,12 +240,12 @@ impl Drop for NativeMutex {\n \n impl<'a> LockGuard<'a> {\n     /// Block on the internal condition variable.\n-    pub unsafe fn wait(&mut self) {\n+    pub unsafe fn wait(&self) {\n         self.lock.wait_noguard()\n     }\n \n     /// Signals a thread in `wait` to wake up.\n-    pub unsafe fn signal(&mut self) {\n+    pub unsafe fn signal(&self) {\n         self.lock.signal_noguard()\n     }\n }\n@@ -262,6 +263,8 @@ mod imp {\n     use self::os::{PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER,\n                    pthread_mutex_t, pthread_cond_t};\n     use mem;\n+    use ty::Unsafe;\n+    use kinds::marker;\n \n     type pthread_mutexattr_t = libc::c_void;\n     type pthread_condattr_t = libc::c_void;\n@@ -369,40 +372,46 @@ mod imp {\n     }\n \n     pub struct Mutex {\n-        priv lock: pthread_mutex_t,\n-        priv cond: pthread_cond_t,\n+        priv lock: Unsafe<pthread_mutex_t>,\n+        priv cond: Unsafe<pthread_cond_t>,\n     }\n \n     pub static MUTEX_INIT: Mutex = Mutex {\n-        lock: PTHREAD_MUTEX_INITIALIZER,\n-        cond: PTHREAD_COND_INITIALIZER,\n+        lock: Unsafe {\n+            value: PTHREAD_MUTEX_INITIALIZER,\n+            marker1: marker::InvariantType,\n+        },\n+        cond: Unsafe {\n+            value: PTHREAD_COND_INITIALIZER,\n+            marker1: marker::InvariantType,\n+        },\n     };\n \n     impl Mutex {\n         pub unsafe fn new() -> Mutex {\n-            let mut m = Mutex {\n-                lock: mem::init(),\n-                cond: mem::init(),\n+            let m = Mutex {\n+                lock: Unsafe::new(mem::init()),\n+                cond: Unsafe::new(mem::init()),\n             };\n \n-            pthread_mutex_init(&mut m.lock, 0 as *libc::c_void);\n-            pthread_cond_init(&mut m.cond, 0 as *libc::c_void);\n+            pthread_mutex_init(m.lock.get(), 0 as *libc::c_void);\n+            pthread_cond_init(m.cond.get(), 0 as *libc::c_void);\n \n             return m;\n         }\n \n-        pub unsafe fn lock(&mut self) { pthread_mutex_lock(&mut self.lock); }\n-        pub unsafe fn unlock(&mut self) { pthread_mutex_unlock(&mut self.lock); }\n-        pub unsafe fn signal(&mut self) { pthread_cond_signal(&mut self.cond); }\n-        pub unsafe fn wait(&mut self) {\n-            pthread_cond_wait(&mut self.cond, &mut self.lock);\n+        pub unsafe fn lock(&self) { pthread_mutex_lock(self.lock.get()); }\n+        pub unsafe fn unlock(&self) { pthread_mutex_unlock(self.lock.get()); }\n+        pub unsafe fn signal(&self) { pthread_cond_signal(self.cond.get()); }\n+        pub unsafe fn wait(&self) {\n+            pthread_cond_wait(self.cond.get(), self.lock.get());\n         }\n-        pub unsafe fn trylock(&mut self) -> bool {\n-            pthread_mutex_trylock(&mut self.lock) == 0\n+        pub unsafe fn trylock(&self) -> bool {\n+            pthread_mutex_trylock(self.lock.get()) == 0\n         }\n-        pub unsafe fn destroy(&mut self) {\n-            pthread_mutex_destroy(&mut self.lock);\n-            pthread_cond_destroy(&mut self.cond);\n+        pub unsafe fn destroy(&self) {\n+            pthread_mutex_destroy(self.lock.get());\n+            pthread_cond_destroy(self.cond.get());\n         }\n     }\n \n@@ -454,37 +463,37 @@ mod imp {\n                 cond: atomics::AtomicUint::new(init_cond()),\n             }\n         }\n-        pub unsafe fn lock(&mut self) {\n+        pub unsafe fn lock(&self) {\n             EnterCriticalSection(self.getlock() as LPCRITICAL_SECTION)\n         }\n-        pub unsafe fn trylock(&mut self) -> bool {\n+        pub unsafe fn trylock(&self) -> bool {\n             TryEnterCriticalSection(self.getlock() as LPCRITICAL_SECTION) != 0\n         }\n-        pub unsafe fn unlock(&mut self) {\n+        pub unsafe fn unlock(&self) {\n             LeaveCriticalSection(self.getlock() as LPCRITICAL_SECTION)\n         }\n \n-        pub unsafe fn wait(&mut self) {\n+        pub unsafe fn wait(&self) {\n             self.unlock();\n             WaitForSingleObject(self.getcond() as HANDLE, libc::INFINITE);\n             self.lock();\n         }\n \n-        pub unsafe fn signal(&mut self) {\n+        pub unsafe fn signal(&self) {\n             assert!(SetEvent(self.getcond() as HANDLE) != 0);\n         }\n \n         /// This function is especially unsafe because there are no guarantees made\n         /// that no other thread is currently holding the lock or waiting on the\n         /// condition variable contained inside.\n-        pub unsafe fn destroy(&mut self) {\n+        pub unsafe fn destroy(&self) {\n             let lock = self.lock.swap(0, atomics::SeqCst);\n             let cond = self.cond.swap(0, atomics::SeqCst);\n             if lock != 0 { free_lock(lock) }\n             if cond != 0 { free_cond(cond) }\n         }\n \n-        unsafe fn getlock(&mut self) -> *mut c_void {\n+        unsafe fn getlock(&self) -> *mut c_void {\n             match self.lock.load(atomics::SeqCst) {\n                 0 => {}\n                 n => return n as *mut c_void\n@@ -498,7 +507,7 @@ mod imp {\n             return self.lock.load(atomics::SeqCst) as *mut c_void;\n         }\n \n-        unsafe fn getcond(&mut self) -> *mut c_void {\n+        unsafe fn getcond(&self) -> *mut c_void {\n             match self.cond.load(atomics::SeqCst) {\n                 0 => {}\n                 n => return n as *mut c_void"}, {"sha": "367967b8e675879f10b7bdf03ab95d942a49e528", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dd64bd83b72a669a20d1b7d938f1ff76aceb0cef/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd64bd83b72a669a20d1b7d938f1ff76aceb0cef/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=dd64bd83b72a669a20d1b7d938f1ff76aceb0cef", "patch": "@@ -79,7 +79,7 @@ impl<T:Send> Exclusive<T> {\n     #[inline]\n     pub unsafe fn hold_and_signal(&self, f: |x: &mut T|) {\n         let rec = self.x.get();\n-        let mut guard = (*rec).lock.lock();\n+        let guard = (*rec).lock.lock();\n         if (*rec).failed {\n             fail!(\"Poisoned Exclusive::new - another task failed inside!\");\n         }\n@@ -92,7 +92,7 @@ impl<T:Send> Exclusive<T> {\n     #[inline]\n     pub unsafe fn hold_and_wait(&self, f: |x: &T| -> bool) {\n         let rec = self.x.get();\n-        let mut l = (*rec).lock.lock();\n+        let l = (*rec).lock.lock();\n         if (*rec).failed {\n             fail!(\"Poisoned Exclusive::new - another task failed inside!\");\n         }"}]}