{"sha": "5841564bf9a9db012fc17d53da514ddf223dfaf5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4NDE1NjRiZjlhOWRiMDEyZmMxN2Q1M2RhNTE0ZGRmMjIzZGZhZjU=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-04-10T23:31:51Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-04-10T23:32:09Z"}, "message": "syntax: add support for #[deriving(Encodable)]", "tree": {"sha": "127b69df615c50952817ac167dbe9c36868e83a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/127b69df615c50952817ac167dbe9c36868e83a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5841564bf9a9db012fc17d53da514ddf223dfaf5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5841564bf9a9db012fc17d53da514ddf223dfaf5", "html_url": "https://github.com/rust-lang/rust/commit/5841564bf9a9db012fc17d53da514ddf223dfaf5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5841564bf9a9db012fc17d53da514ddf223dfaf5/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f50a8e283398a8857425e80053db8db845980fa8", "url": "https://api.github.com/repos/rust-lang/rust/commits/f50a8e283398a8857425e80053db8db845980fa8", "html_url": "https://github.com/rust-lang/rust/commit/f50a8e283398a8857425e80053db8db845980fa8"}], "stats": {"total": 463, "additions": 455, "deletions": 8}, "files": [{"sha": "530bb8f15417aea85a08b31c7ca5782b5a203262", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 64, "deletions": 8, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/5841564bf9a9db012fc17d53da514ddf223dfaf5/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5841564bf9a9db012fc17d53da514ddf223dfaf5/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=5841564bf9a9db012fc17d53da514ddf223dfaf5", "patch": "@@ -64,12 +64,7 @@ pub fn mk_unary(cx: @ext_ctxt, sp: span, op: ast::unop, e: @ast::expr)\n     mk_expr(cx, sp, ast::expr_unary(op, e))\n }\n pub fn mk_raw_path(sp: span, +idents: ~[ast::ident]) -> @ast::Path {\n-    let p = @ast::Path { span: sp,\n-                         global: false,\n-                         idents: idents,\n-                         rp: None,\n-                         types: ~[] };\n-    return p;\n+    mk_raw_path_(sp, idents, ~[])\n }\n pub fn mk_raw_path_(sp: span,\n                     +idents: ~[ast::ident],\n@@ -82,11 +77,16 @@ pub fn mk_raw_path_(sp: span,\n                  types: types }\n }\n pub fn mk_raw_path_global(sp: span, +idents: ~[ast::ident]) -> @ast::Path {\n+    mk_raw_path_global_(sp, idents, ~[])\n+}\n+pub fn mk_raw_path_global_(sp: span,\n+                           +idents: ~[ast::ident],\n+                           +types: ~[@ast::Ty]) -> @ast::Path {\n     @ast::Path { span: sp,\n                  global: true,\n                  idents: idents,\n                  rp: None,\n-                 types: ~[] }\n+                 types: types }\n }\n pub fn mk_path(cx: @ext_ctxt, sp: span, +idents: ~[ast::ident])\n             -> @ast::expr {\n@@ -271,6 +271,29 @@ pub fn mk_simple_block(cx: @ext_ctxt,\n         span: span,\n     }\n }\n+pub fn mk_lambda_(cx: @ext_ctxt,\n+                 span: span,\n+                 fn_decl: ast::fn_decl,\n+                 blk: ast::blk)\n+              -> @ast::expr {\n+    mk_expr(cx, span, ast::expr_fn_block(fn_decl, blk))\n+}\n+pub fn mk_lambda(cx: @ext_ctxt,\n+                       span: span,\n+                       fn_decl: ast::fn_decl,\n+                       expr: @ast::expr)\n+                    -> @ast::expr {\n+    let blk = mk_simple_block(cx, span, expr);\n+    mk_lambda_(cx, span, fn_decl, blk)\n+}\n+pub fn mk_lambda_stmts(cx: @ext_ctxt,\n+                       span: span,\n+                       fn_decl: ast::fn_decl,\n+                       stmts: ~[@ast::stmt])\n+                    -> @ast::expr {\n+    let blk = mk_block(cx, span, ~[], stmts, None);\n+    mk_lambda(cx, span, fn_decl, blk)\n+}\n pub fn mk_copy(cx: @ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_copy(e))\n }\n@@ -337,12 +360,35 @@ pub fn mk_ty_path_global(cx: @ext_ctxt,\n     let ty = @ast::Ty { id: cx.next_id(), node: ty, span: span };\n     ty\n }\n+pub fn mk_ty_rptr(cx: @ext_ctxt,\n+                  span: span,\n+                  ty: @ast::Ty,\n+                  mutbl: ast::mutability)\n+               -> @ast::Ty {\n+    @ast::Ty {\n+        id: cx.next_id(),\n+        span: span,\n+        node: ast::ty_rptr(\n+            None,\n+            ast::mt { ty: ty, mutbl: mutbl }\n+        ),\n+    }\n+}\n+pub fn mk_ty_infer(cx: @ext_ctxt, span: span) -> @ast::Ty {\n+    @ast::Ty {\n+        id: cx.next_id(),\n+        node: ast::ty_infer,\n+        span: span,\n+    }\n+}\n pub fn mk_trait_ref_global(cx: @ext_ctxt,\n                            span: span,\n                            +idents: ~[ ast::ident ])\n     -> @ast::trait_ref\n {\n-    let path = build::mk_raw_path_global(span, idents);\n+    mk_trait_ref_(cx, build::mk_raw_path_global(span, idents))\n+}\n+pub fn mk_trait_ref_(cx: @ext_ctxt, path: @ast::Path) -> @ast::trait_ref {\n     @ast::trait_ref {\n         path: path,\n         ref_id: cx.next_id()\n@@ -371,6 +417,16 @@ pub fn mk_arg(cx: @ext_ctxt,\n pub fn mk_fn_decl(+inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl {\n     ast::fn_decl { inputs: inputs, output: output, cf: ast::return_val }\n }\n+pub fn mk_trait_ty_param_bound_global(cx: @ext_ctxt,\n+                                      span: span,\n+                                      +idents: ~[ast::ident])\n+                                   -> ast::TyParamBound {\n+    ast::TraitTyParamBound(mk_trait_ref_global(cx, span, idents))\n+}\n+pub fn mk_trait_ty_param_bound_(cx: @ext_ctxt,\n+                                path: @ast::Path) -> ast::TyParamBound {\n+    ast::TraitTyParamBound(mk_trait_ref_(cx, path))\n+}\n pub fn mk_ty_param(cx: @ext_ctxt,\n                    ident: ast::ident,\n                    bounds: @OptVec<ast::TyParamBound>)"}, {"sha": "81bfb03724f30a251c6e5e1983a30d5f63ab48fc", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "added", "additions": 388, "deletions": 0, "changes": 388, "blob_url": "https://github.com/rust-lang/rust/blob/5841564bf9a9db012fc17d53da514ddf223dfaf5/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5841564bf9a9db012fc17d53da514ddf223dfaf5/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=5841564bf9a9db012fc17d53da514ddf223dfaf5", "patch": "@@ -0,0 +1,388 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::prelude::*;\n+\n+use ast;\n+use ast::*;\n+use ext::base::ext_ctxt;\n+use ext::build;\n+use ext::deriving::*;\n+use codemap::{span, spanned};\n+use ast_util;\n+use opt_vec;\n+\n+use core::uint;\n+\n+pub fn expand_deriving_encodable(\n+    cx: @ext_ctxt,\n+    span: span,\n+    _mitem: @meta_item,\n+    in_items: ~[@item]\n+) -> ~[@item] {\n+    expand_deriving(\n+        cx,\n+        span,\n+        in_items,\n+        expand_deriving_encodable_struct_def,\n+        expand_deriving_encodable_enum_def\n+    )\n+}\n+\n+fn create_derived_encodable_impl(\n+    cx: @ext_ctxt,\n+    span: span,\n+    type_ident: ident,\n+    generics: &Generics,\n+    method: @method\n+) -> @item {\n+    let encoder_ty_param = build::mk_ty_param(\n+        cx,\n+        cx.ident_of(~\"__E\"),\n+        @opt_vec::with(\n+            build::mk_trait_ty_param_bound_global(\n+                cx,\n+                span,\n+                ~[\n+                    cx.ident_of(~\"std\"),\n+                    cx.ident_of(~\"serialize\"),\n+                    cx.ident_of(~\"Encoder\"),\n+                ]\n+            )\n+        )\n+    );\n+\n+    // All the type parameters need to bound to the trait.\n+    let generic_ty_params = opt_vec::with(encoder_ty_param);\n+\n+    let methods = [method];\n+    let trait_path = build::mk_raw_path_global_(\n+        span,\n+        ~[\n+            cx.ident_of(~\"std\"),\n+            cx.ident_of(~\"serialize\"),\n+            cx.ident_of(~\"Encodable\")\n+        ],\n+        ~[\n+            build::mk_simple_ty_path(cx, span, cx.ident_of(~\"__E\"))\n+        ]\n+    );\n+    create_derived_impl(\n+        cx,\n+        span,\n+        type_ident,\n+        generics,\n+        methods,\n+        trait_path,\n+        generic_ty_params\n+    )\n+}\n+\n+// Creates a method from the given set of statements conforming to the\n+// signature of the `encodable` method.\n+fn create_encode_method(\n+    cx: @ext_ctxt,\n+    span: span,\n+    +statements: ~[@stmt]\n+) -> @method {\n+    // Create the `e` parameter.\n+    let e_arg_type = build::mk_ty_rptr(\n+        cx,\n+        span,\n+        build::mk_simple_ty_path(cx, span, cx.ident_of(~\"__E\")),\n+        ast::m_imm\n+    );\n+    let e_ident = cx.ident_of(~\"__e\");\n+    let e_arg = build::mk_arg(cx, span, e_ident, e_arg_type);\n+\n+    // Create the type of the return value.\n+    let output_type = @ast::Ty { id: cx.next_id(), node: ty_nil, span: span };\n+\n+    // Create the function declaration.\n+    let inputs = ~[e_arg];\n+    let fn_decl = build::mk_fn_decl(inputs, output_type);\n+\n+    // Create the body block.\n+    let body_block = build::mk_block_(cx, span, statements);\n+\n+    // Create the method.\n+    let self_ty = spanned { node: sty_region(None, m_imm), span: span };\n+    let method_ident = cx.ident_of(~\"encode\");\n+    @ast::method {\n+        ident: method_ident,\n+        attrs: ~[],\n+        generics: ast_util::empty_generics(),\n+        self_ty: self_ty,\n+        purity: impure_fn,\n+        decl: fn_decl,\n+        body: body_block,\n+        id: cx.next_id(),\n+        span: span,\n+        self_id: cx.next_id(),\n+        vis: public\n+    }\n+}\n+\n+fn call_substructure_encode_method(\n+    cx: @ext_ctxt,\n+    span: span,\n+    self_field: @expr\n+) -> @ast::expr {\n+    // Gather up the parameters we want to chain along.\n+    let e_ident = cx.ident_of(~\"__e\");\n+    let e_expr = build::mk_path(cx, span, ~[e_ident]);\n+\n+    // Call the substructure method.\n+    let encode_ident = cx.ident_of(~\"encode\");\n+    build::mk_method_call(\n+        cx,\n+        span,\n+        self_field,\n+        encode_ident,\n+        ~[e_expr]\n+    )\n+}\n+\n+fn expand_deriving_encodable_struct_def(\n+    cx: @ext_ctxt,\n+    span: span,\n+    struct_def: &struct_def,\n+    type_ident: ident,\n+    generics: &Generics\n+) -> @item {\n+    // Create the method.\n+    let method = expand_deriving_encodable_struct_method(\n+        cx,\n+        span,\n+        type_ident,\n+        struct_def\n+    );\n+\n+    // Create the implementation.\n+    create_derived_encodable_impl(\n+        cx,\n+        span,\n+        type_ident,\n+        generics,\n+        method\n+    )\n+}\n+\n+fn expand_deriving_encodable_enum_def(\n+    cx: @ext_ctxt,\n+    span: span,\n+    enum_definition: &enum_def,\n+    type_ident: ident,\n+    generics: &Generics\n+) -> @item {\n+    // Create the method.\n+    let method = expand_deriving_encodable_enum_method(\n+        cx,\n+        span,\n+        type_ident,\n+        enum_definition\n+    );\n+\n+    // Create the implementation.\n+    create_derived_encodable_impl(\n+        cx,\n+        span,\n+        type_ident,\n+        generics,\n+        method\n+    )\n+}\n+\n+fn expand_deriving_encodable_struct_method(\n+    cx: @ext_ctxt,\n+    span: span,\n+    type_ident: ident,\n+    struct_def: &struct_def\n+) -> @method {\n+    let self_ident = cx.ident_of(~\"self\");\n+\n+    // Create the body of the method.\n+    let mut idx = 0;\n+    let mut statements = ~[];\n+    for struct_def.fields.each |struct_field| {\n+        match struct_field.node.kind {\n+            named_field(ident, _, _) => {\n+                // Create the accessor for this field.\n+                let self_field = build::mk_access(\n+                    cx,\n+                    span,\n+                    ~[self_ident],\n+                    ident\n+                );\n+\n+                // Call the substructure method.\n+                let encode_expr = call_substructure_encode_method(\n+                    cx,\n+                    span,\n+                    self_field\n+                );\n+\n+                let blk_expr = build::mk_lambda(\n+                    cx,\n+                    span,\n+                    build::mk_fn_decl(~[], build::mk_ty_infer(cx, span)),\n+                    encode_expr\n+                );\n+\n+                let call_expr = build::mk_method_call(\n+                    cx,\n+                    span,\n+                    build::mk_path(cx, span, ~[cx.ident_of(~\"__e\")]),\n+                    cx.ident_of(~\"emit_struct_field\"),\n+                    ~[\n+                        build::mk_base_str(cx, span, cx.str_of(ident)),\n+                        build::mk_uint(cx, span, idx),\n+                        blk_expr\n+                    ]\n+                );\n+\n+                statements.push(build::mk_stmt(cx, span, call_expr));\n+            }\n+            unnamed_field => {\n+                cx.span_unimpl(\n+                    span,\n+                    ~\"unnamed fields with `deriving(Encodable)`\"\n+                );\n+            }\n+        }\n+        idx += 1;\n+    }\n+\n+    let emit_struct_stmt = build::mk_method_call(\n+        cx,\n+        span,\n+        build::mk_path(\n+            cx,\n+            span,\n+            ~[cx.ident_of(~\"__e\")]\n+        ),\n+        cx.ident_of(~\"emit_struct\"),\n+        ~[\n+            build::mk_base_str(cx, span, cx.str_of(type_ident)),\n+            build::mk_uint(cx, span, statements.len()),\n+            build::mk_lambda_stmts(\n+                cx,\n+                span,\n+                build::mk_fn_decl(~[], build::mk_ty_infer(cx, span)),\n+                statements\n+            ),\n+        ]\n+    );\n+\n+    let statements = ~[build::mk_stmt(cx, span, emit_struct_stmt)];\n+\n+    // Create the method itself.\n+    return create_encode_method(cx, span, statements);\n+}\n+\n+fn expand_deriving_encodable_enum_method(\n+    cx: @ext_ctxt,\n+    span: span,\n+    type_ident: ast::ident,\n+    enum_definition: &enum_def\n+) -> @method {\n+    // Create the arms of the match in the method body.\n+    let arms = do enum_definition.variants.mapi |i, variant| {\n+        // Create the matching pattern.\n+        let pat = create_enum_variant_pattern(cx, span, variant, ~\"__self\");\n+\n+        // Feed the discriminant to the encode function.\n+        let mut stmts = ~[];\n+\n+        // Feed each argument in this variant to the encode function\n+        // as well.\n+        let variant_arg_len = variant_arg_count(cx, span, variant);\n+        for uint::range(0, variant_arg_len) |j| {\n+            // Create the expression for this field.\n+            let field_ident = cx.ident_of(~\"__self\" + j.to_str());\n+            let field = build::mk_path(cx, span, ~[ field_ident ]);\n+\n+            // Call the substructure method.\n+            let expr = call_substructure_encode_method(cx, span, field);\n+\n+            let blk_expr = build::mk_lambda(\n+                cx,\n+                span,\n+                build::mk_fn_decl(~[], build::mk_ty_infer(cx, span)),\n+                expr\n+            );\n+\n+            let call_expr = build::mk_method_call(\n+                cx,\n+                span,\n+                build::mk_path(cx, span, ~[cx.ident_of(~\"__e\")]),\n+                cx.ident_of(~\"emit_enum_variant_arg\"),\n+                ~[\n+                    build::mk_uint(cx, span, j),\n+                    blk_expr,\n+                ]\n+            );\n+\n+            stmts.push(build::mk_stmt(cx, span, call_expr));\n+        }\n+\n+        // Create the pattern body.\n+        let call_expr = build::mk_method_call(\n+            cx,\n+            span,\n+            build::mk_path(cx, span, ~[cx.ident_of(~\"__e\")]),\n+            cx.ident_of(~\"emit_enum_variant\"),\n+            ~[\n+                build::mk_base_str(cx, span, cx.str_of(variant.node.name)),\n+                build::mk_uint(cx, span, i),\n+                build::mk_uint(cx, span, variant_arg_len),\n+                build::mk_lambda_stmts(\n+                    cx,\n+                    span,\n+                    build::mk_fn_decl(~[], build::mk_ty_infer(cx, span)),\n+                    stmts\n+                )\n+            ]\n+        );\n+\n+        let match_body_block = build::mk_simple_block(cx, span, call_expr);\n+\n+        // Create the arm.\n+        ast::arm {\n+            pats: ~[pat],\n+            guard: None,\n+            body: match_body_block,\n+        }\n+    };\n+\n+    // Create the method body.\n+    let lambda_expr = build::mk_lambda(\n+        cx,\n+        span,\n+        build::mk_fn_decl(~[], build::mk_ty_infer(cx, span)),\n+        expand_enum_or_struct_match(cx, span, arms)\n+    );\n+\n+    let call_expr = build::mk_method_call(\n+        cx,\n+        span,\n+        build::mk_path(cx, span, ~[cx.ident_of(~\"__e\")]),\n+        cx.ident_of(~\"emit_enum\"),\n+        ~[\n+            build::mk_base_str(cx, span, cx.str_of(type_ident)),\n+            lambda_expr,\n+        ]\n+    );\n+\n+    let stmt = build::mk_stmt(cx, span, call_expr);\n+\n+    // Create the method.\n+    create_encode_method(cx, span, ~[stmt])\n+}"}, {"sha": "5242d54208758fbaa78307bc995d98bf806cd4a5", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5841564bf9a9db012fc17d53da514ddf223dfaf5/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5841564bf9a9db012fc17d53da514ddf223dfaf5/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=5841564bf9a9db012fc17d53da514ddf223dfaf5", "patch": "@@ -33,6 +33,7 @@ use core::uint;\n pub mod clone;\n pub mod eq;\n pub mod iter_bytes;\n+pub mod encodable;\n \n type ExpandDerivingStructDefFn<'self> = &'self fn(@ext_ctxt,\n                                                   span,\n@@ -76,6 +77,8 @@ pub fn expand_meta_deriving(cx: @ext_ctxt,\n                                 titem, in_items),\n                             ~\"IterBytes\" => iter_bytes::expand_deriving_iter_bytes(cx,\n                                 titem.span, titem, in_items),\n+                            ~\"Encodable\" => encodable::expand_deriving_encodable(cx,\n+                                titem.span, titem, in_items),\n                             tname => {\n                                 cx.span_err(titem.span, fmt!(\"unknown \\\n                                     `deriving` trait: `%s`\", tname));"}]}