{"sha": "843c5e6308920018defe62fd1951c8a5b45553b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0M2M1ZTYzMDg5MjAwMThkZWZlNjJmZDE5NTFjOGE1YjQ1NTUzYjE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-26T20:55:23Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-27T20:03:57Z"}, "message": "std: Small cleanup and test improvement\n\nThis weeds out a bunch of warnings building stdtest on windows, and it also adds\na check! macro to the io::fs tests to help diagnose errors that are cropping up\non windows platforms as well.\n\ncc #12516", "tree": {"sha": "91b45e5bbb711bcfbfbbded88cdd606bf94f2520", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91b45e5bbb711bcfbfbbded88cdd606bf94f2520"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/843c5e6308920018defe62fd1951c8a5b45553b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/843c5e6308920018defe62fd1951c8a5b45553b1", "html_url": "https://github.com/rust-lang/rust/commit/843c5e6308920018defe62fd1951c8a5b45553b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/843c5e6308920018defe62fd1951c8a5b45553b1/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68a92c5ed58e676d6aa224681080f921b9e069a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/68a92c5ed58e676d6aa224681080f921b9e069a5", "html_url": "https://github.com/rust-lang/rust/commit/68a92c5ed58e676d6aa224681080f921b9e069a5"}], "stats": {"total": 340, "additions": 182, "deletions": 158}, "files": [{"sha": "d72abb272c28d9b687a8d1ff671d37c0c85075bb", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 155, "deletions": 132, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/843c5e6308920018defe62fd1951c8a5b45553b1/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843c5e6308920018defe62fd1951c8a5b45553b1/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=843c5e6308920018defe62fd1951c8a5b45553b1", "patch": "@@ -663,6 +663,13 @@ mod test {\n     use io;\n     use ops::Drop;\n \n+    macro_rules! check( ($e:expr) => (\n+        match $e {\n+            Ok(t) => t,\n+            Err(e) => fail!(\"{} failed with: {}\", stringify!($e), e),\n+        }\n+    ) )\n+\n     struct TempDir(Path);\n \n     impl TempDir {\n@@ -682,15 +689,15 @@ mod test {\n             // Gee, seeing how we're testing the fs module I sure hope that we\n             // at least implement this correctly!\n             let TempDir(ref p) = *self;\n-            io::fs::rmdir_recursive(p).unwrap();\n+            check!(io::fs::rmdir_recursive(p));\n         }\n     }\n \n     pub fn tmpdir() -> TempDir {\n         use os;\n         use rand;\n         let ret = os::tmpdir().join(format!(\"rust-{}\", rand::random::<u32>()));\n-        io::fs::mkdir(&ret, io::UserRWX).unwrap();\n+        check!(io::fs::mkdir(&ret, io::UserRWX));\n         TempDir(ret)\n     }\n \n@@ -700,18 +707,18 @@ mod test {\n         let filename = &tmpdir.join(\"file_rt_io_file_test.txt\");\n         {\n             let mut write_stream = File::open_mode(filename, Open, ReadWrite);\n-            write_stream.write(message.as_bytes()).unwrap();\n+            check!(write_stream.write(message.as_bytes()));\n         }\n         {\n             let mut read_stream = File::open_mode(filename, Open, Read);\n             let mut read_buf = [0, .. 1028];\n-            let read_str = match read_stream.read(read_buf).unwrap() {\n+            let read_str = match check!(read_stream.read(read_buf)) {\n                 -1|0 => fail!(\"shouldn't happen\"),\n-                n => str::from_utf8_owned(read_buf.slice_to(n).to_owned()).unwrap()\n+                n => str::from_utf8(read_buf.slice_to(n).to_owned()).unwrap().to_owned()\n             };\n             assert_eq!(read_str, message.to_owned());\n         }\n-        unlink(filename).unwrap();\n+        check!(unlink(filename));\n     })\n \n     iotest!(fn invalid_path_raises() {\n@@ -734,20 +741,20 @@ mod test {\n         let filename = &tmpdir.join(\"file_rt_io_file_test_positional.txt\");\n         {\n             let mut rw_stream = File::open_mode(filename, Open, ReadWrite);\n-            rw_stream.write(message.as_bytes()).unwrap();\n+            check!(rw_stream.write(message.as_bytes()));\n         }\n         {\n             let mut read_stream = File::open_mode(filename, Open, Read);\n             {\n                 let read_buf = read_mem.mut_slice(0, 4);\n-                read_stream.read(read_buf).unwrap();\n+                check!(read_stream.read(read_buf));\n             }\n             {\n                 let read_buf = read_mem.mut_slice(4, 8);\n-                read_stream.read(read_buf).unwrap();\n+                check!(read_stream.read(read_buf));\n             }\n         }\n-        unlink(filename).unwrap();\n+        check!(unlink(filename));\n         let read_str = str::from_utf8(read_mem).unwrap();\n         assert_eq!(read_str, message);\n     })\n@@ -762,16 +769,16 @@ mod test {\n         let filename = &tmpdir.join(\"file_rt_io_file_test_seeking.txt\");\n         {\n             let mut rw_stream = File::open_mode(filename, Open, ReadWrite);\n-            rw_stream.write(message.as_bytes()).unwrap();\n+            check!(rw_stream.write(message.as_bytes()));\n         }\n         {\n             let mut read_stream = File::open_mode(filename, Open, Read);\n-            read_stream.seek(set_cursor as i64, SeekSet).unwrap();\n-            tell_pos_pre_read = read_stream.tell().unwrap();\n-            read_stream.read(read_mem).unwrap();\n-            tell_pos_post_read = read_stream.tell().unwrap();\n+            check!(read_stream.seek(set_cursor as i64, SeekSet));\n+            tell_pos_pre_read = check!(read_stream.tell());\n+            check!(read_stream.read(read_mem));\n+            tell_pos_post_read = check!(read_stream.tell());\n         }\n-        unlink(filename).unwrap();\n+        check!(unlink(filename));\n         let read_str = str::from_utf8(read_mem).unwrap();\n         assert_eq!(read_str, message.slice(4, 8));\n         assert_eq!(tell_pos_pre_read, set_cursor);\n@@ -788,15 +795,15 @@ mod test {\n         let filename = &tmpdir.join(\"file_rt_io_file_test_seek_and_write.txt\");\n         {\n             let mut rw_stream = File::open_mode(filename, Open, ReadWrite);\n-            rw_stream.write(initial_msg.as_bytes()).unwrap();\n-            rw_stream.seek(seek_idx as i64, SeekSet).unwrap();\n-            rw_stream.write(overwrite_msg.as_bytes()).unwrap();\n+            check!(rw_stream.write(initial_msg.as_bytes()));\n+            check!(rw_stream.seek(seek_idx as i64, SeekSet));\n+            check!(rw_stream.write(overwrite_msg.as_bytes()));\n         }\n         {\n             let mut read_stream = File::open_mode(filename, Open, Read);\n-            read_stream.read(read_mem).unwrap();\n+            check!(read_stream.read(read_mem));\n         }\n-        unlink(filename).unwrap();\n+        check!(unlink(filename));\n         let read_str = str::from_utf8(read_mem).unwrap();\n         assert!(read_str == final_msg.to_owned());\n     })\n@@ -812,24 +819,24 @@ mod test {\n         let filename = &tmpdir.join(\"file_rt_io_file_test_seek_shakedown.txt\");\n         {\n             let mut rw_stream = File::open_mode(filename, Open, ReadWrite);\n-            rw_stream.write(initial_msg.as_bytes()).unwrap();\n+            check!(rw_stream.write(initial_msg.as_bytes()));\n         }\n         {\n             let mut read_stream = File::open_mode(filename, Open, Read);\n \n-            read_stream.seek(-4, SeekEnd).unwrap();\n-            read_stream.read(read_mem).unwrap();\n+            check!(read_stream.seek(-4, SeekEnd));\n+            check!(read_stream.read(read_mem));\n             assert_eq!(str::from_utf8(read_mem).unwrap(), chunk_three);\n \n-            read_stream.seek(-9, SeekCur).unwrap();\n-            read_stream.read(read_mem).unwrap();\n+            check!(read_stream.seek(-9, SeekCur));\n+            check!(read_stream.read(read_mem));\n             assert_eq!(str::from_utf8(read_mem).unwrap(), chunk_two);\n \n-            read_stream.seek(0, SeekSet).unwrap();\n-            read_stream.read(read_mem).unwrap();\n+            check!(read_stream.seek(0, SeekSet));\n+            check!(read_stream.read(read_mem));\n             assert_eq!(str::from_utf8(read_mem).unwrap(), chunk_one);\n         }\n-        unlink(filename).unwrap();\n+        check!(unlink(filename));\n     })\n \n     iotest!(fn file_test_stat_is_correct_on_is_file() {\n@@ -840,81 +847,81 @@ mod test {\n             let msg = \"hw\";\n             fs.write(msg.as_bytes()).unwrap();\n         }\n-        let stat_res = stat(filename).unwrap();\n+        let stat_res = check!(stat(filename));\n         assert_eq!(stat_res.kind, io::TypeFile);\n-        unlink(filename).unwrap();\n+        check!(unlink(filename));\n     })\n \n     iotest!(fn file_test_stat_is_correct_on_is_dir() {\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_stat_correct_on_is_dir\");\n-        mkdir(filename, io::UserRWX).unwrap();\n-        let stat_res = filename.stat().unwrap();\n+        check!(mkdir(filename, io::UserRWX));\n+        let stat_res = check!(filename.stat());\n         assert!(stat_res.kind == io::TypeDirectory);\n-        rmdir(filename).unwrap();\n+        check!(rmdir(filename));\n     })\n \n     iotest!(fn file_test_fileinfo_false_when_checking_is_file_on_a_directory() {\n         let tmpdir = tmpdir();\n         let dir = &tmpdir.join(\"fileinfo_false_on_dir\");\n-        mkdir(dir, io::UserRWX).unwrap();\n+        check!(mkdir(dir, io::UserRWX));\n         assert!(dir.is_file() == false);\n-        rmdir(dir).unwrap();\n+        check!(rmdir(dir));\n     })\n \n     iotest!(fn file_test_fileinfo_check_exists_before_and_after_file_creation() {\n         let tmpdir = tmpdir();\n         let file = &tmpdir.join(\"fileinfo_check_exists_b_and_a.txt\");\n-        File::create(file).write(bytes!(\"foo\")).unwrap();\n+        check!(File::create(file).write(bytes!(\"foo\")));\n         assert!(file.exists());\n-        unlink(file).unwrap();\n+        check!(unlink(file));\n         assert!(!file.exists());\n     })\n \n     iotest!(fn file_test_directoryinfo_check_exists_before_and_after_mkdir() {\n         let tmpdir = tmpdir();\n         let dir = &tmpdir.join(\"before_and_after_dir\");\n         assert!(!dir.exists());\n-        mkdir(dir, io::UserRWX).unwrap();\n+        check!(mkdir(dir, io::UserRWX));\n         assert!(dir.exists());\n         assert!(dir.is_dir());\n-        rmdir(dir).unwrap();\n+        check!(rmdir(dir));\n         assert!(!dir.exists());\n     })\n \n     iotest!(fn file_test_directoryinfo_readdir() {\n         use std::str;\n         let tmpdir = tmpdir();\n         let dir = &tmpdir.join(\"di_readdir\");\n-        mkdir(dir, io::UserRWX).unwrap();\n+        check!(mkdir(dir, io::UserRWX));\n         let prefix = \"foo\";\n         for n in range(0,3) {\n             let f = dir.join(format!(\"{}.txt\", n));\n-            let mut w = File::create(&f).unwrap();\n+            let mut w = check!(File::create(&f));\n             let msg_str = (prefix + n.to_str().to_owned()).to_owned();\n             let msg = msg_str.as_bytes();\n-            w.write(msg).unwrap();\n+            check!(w.write(msg));\n         }\n-        let files = readdir(dir).unwrap();\n+        let files = check!(readdir(dir));\n         let mut mem = [0u8, .. 4];\n         for f in files.iter() {\n             {\n                 let n = f.filestem_str();\n-                File::open(f).read(mem).unwrap();\n+                check!(File::open(f).read(mem));\n                 let read_str = str::from_utf8(mem).unwrap();\n                 let expected = match n {\n                     None|Some(\"\") => fail!(\"really shouldn't happen..\"),\n                     Some(n) => prefix+n\n                 };\n                 assert_eq!(expected.as_slice(), read_str);\n             }\n-            unlink(f).unwrap();\n+            check!(unlink(f));\n         }\n-        rmdir(dir).unwrap();\n+        check!(rmdir(dir));\n     })\n \n     iotest!(fn recursive_mkdir_slash() {\n-        mkdir_recursive(&Path::new(\"/\"), io::UserRWX).unwrap();\n+        check!(mkdir_recursive(&Path::new(\"/\"), io::UserRWX));\n     })\n \n     iotest!(fn unicode_path_is_dir() {\n@@ -925,12 +932,12 @@ mod test {\n \n         let mut dirpath = tmpdir.path().clone();\n         dirpath.push(format!(\"test-\uac00\u4e00\u30fc\u4f60\u597d\"));\n-        mkdir(&dirpath, io::UserRWX).unwrap();\n+        check!(mkdir(&dirpath, io::UserRWX));\n         assert!(dirpath.is_dir());\n \n         let mut filepath = dirpath;\n         filepath.push(\"unicode-file-\\uac00\\u4e00\\u30fc\\u4f60\\u597d.rs\");\n-        File::create(&filepath).unwrap(); // ignore return; touch only\n+        check!(File::create(&filepath)); // ignore return; touch only\n         assert!(!filepath.is_dir());\n         assert!(filepath.exists());\n     })\n@@ -942,7 +949,7 @@ mod test {\n         let tmpdir = tmpdir();\n         let unicode = tmpdir.path();\n         let unicode = unicode.join(format!(\"test-\uac01\u4e01\u30fc\u518d\u89c1\"));\n-        mkdir(&unicode, io::UserRWX).unwrap();\n+        check!(mkdir(&unicode, io::UserRWX));\n         assert!(unicode.exists());\n         assert!(!Path::new(\"test/unicode-bogus-path-\uac01\u4e01\u30fc\u518d\u89c1\").exists());\n     })\n@@ -964,19 +971,19 @@ mod test {\n         let input = tmpdir.join(\"in.txt\");\n         let out = tmpdir.join(\"out.txt\");\n \n-        File::create(&input).write(bytes!(\"hello\")).unwrap();\n-        copy(&input, &out).unwrap();\n-        let contents = File::open(&out).read_to_end().unwrap();\n+        check!(File::create(&input).write(bytes!(\"hello\")));\n+        check!(copy(&input, &out));\n+        let contents = check!(File::open(&out).read_to_end());\n         assert_eq!(contents.as_slice(), bytes!(\"hello\"));\n \n-        assert_eq!(input.stat().unwrap().perm, out.stat().unwrap().perm);\n+        assert_eq!(check!(input.stat()).perm, check!(out.stat()).perm);\n     })\n \n     iotest!(fn copy_file_dst_dir() {\n         let tmpdir = tmpdir();\n         let out = tmpdir.join(\"out\");\n \n-        File::create(&out).unwrap();\n+        check!(File::create(&out));\n         match copy(&out, tmpdir.path()) {\n             Ok(..) => fail!(), Err(..) => {}\n         }\n@@ -987,11 +994,11 @@ mod test {\n         let input = tmpdir.join(\"in\");\n         let output = tmpdir.join(\"out\");\n \n-        File::create(&input).write(\"foo\".as_bytes()).unwrap();\n-        File::create(&output).write(\"bar\".as_bytes()).unwrap();\n-        copy(&input, &output).unwrap();\n+        check!(File::create(&input).write(\"foo\".as_bytes()));\n+        check!(File::create(&output).write(\"bar\".as_bytes()));\n+        check!(copy(&input, &output));\n \n-        assert_eq!(File::open(&output).read_to_end().unwrap(),\n+        assert_eq!(check!(File::open(&output).read_to_end()),\n                    (bytes!(\"foo\")).to_owned());\n     })\n \n@@ -1010,13 +1017,13 @@ mod test {\n         let input = tmpdir.join(\"in.txt\");\n         let out = tmpdir.join(\"out.txt\");\n \n-        File::create(&input).unwrap();\n-        chmod(&input, io::UserRead).unwrap();\n-        copy(&input, &out).unwrap();\n-        assert!(out.stat().unwrap().perm & io::UserWrite == 0);\n+        check!(File::create(&input));\n+        check!(chmod(&input, io::UserRead));\n+        check!(copy(&input, &out));\n+        assert!(check!(out.stat()).perm & io::UserWrite == 0);\n \n-        chmod(&input, io::UserFile).unwrap();\n-        chmod(&out, io::UserFile).unwrap();\n+        check!(chmod(&input, io::UserFile));\n+        check!(chmod(&out, io::UserFile));\n     })\n \n     #[cfg(not(windows))] // FIXME(#10264) operation not permitted?\n@@ -1025,22 +1032,22 @@ mod test {\n         let input = tmpdir.join(\"in.txt\");\n         let out = tmpdir.join(\"out.txt\");\n \n-        File::create(&input).write(\"foobar\".as_bytes()).unwrap();\n-        symlink(&input, &out).unwrap();\n+        check!(File::create(&input).write(\"foobar\".as_bytes()));\n+        check!(symlink(&input, &out));\n         if cfg!(not(windows)) {\n-            assert_eq!(lstat(&out).unwrap().kind, io::TypeSymlink);\n+            assert_eq!(check!(lstat(&out)).kind, io::TypeSymlink);\n         }\n-        assert_eq!(stat(&out).unwrap().size, stat(&input).unwrap().size);\n-        assert_eq!(File::open(&out).read_to_end().unwrap(),\n+        assert_eq!(check!(stat(&out)).size, check!(stat(&input)).size);\n+        assert_eq!(check!(File::open(&out).read_to_end()),\n                    (bytes!(\"foobar\")).to_owned());\n     })\n \n     #[cfg(not(windows))] // apparently windows doesn't like symlinks\n     iotest!(fn symlink_noexist() {\n         let tmpdir = tmpdir();\n         // symlinks can point to things that don't exist\n-        symlink(&tmpdir.join(\"foo\"), &tmpdir.join(\"bar\")).unwrap();\n-        assert!(readlink(&tmpdir.join(\"bar\")).unwrap() == tmpdir.join(\"foo\"));\n+        check!(symlink(&tmpdir.join(\"foo\"), &tmpdir.join(\"bar\")));\n+        assert!(check!(readlink(&tmpdir.join(\"bar\"))) == tmpdir.join(\"foo\"));\n     })\n \n     iotest!(fn readlink_not_symlink() {\n@@ -1056,14 +1063,14 @@ mod test {\n         let input = tmpdir.join(\"in.txt\");\n         let out = tmpdir.join(\"out.txt\");\n \n-        File::create(&input).write(\"foobar\".as_bytes()).unwrap();\n-        link(&input, &out).unwrap();\n+        check!(File::create(&input).write(\"foobar\".as_bytes()));\n+        check!(link(&input, &out));\n         if cfg!(not(windows)) {\n-            assert_eq!(lstat(&out).unwrap().kind, io::TypeFile);\n-            assert_eq!(stat(&out).unwrap().unstable.nlink, 2);\n+            assert_eq!(check!(lstat(&out)).kind, io::TypeFile);\n+            assert_eq!(check!(stat(&out)).unstable.nlink, 2);\n         }\n-        assert_eq!(stat(&out).unwrap().size, stat(&input).unwrap().size);\n-        assert_eq!(File::open(&out).read_to_end().unwrap(),\n+        assert_eq!(check!(stat(&out)).size, check!(stat(&input)).size);\n+        assert_eq!(check!(File::open(&out).read_to_end()),\n                    (bytes!(\"foobar\")).to_owned());\n \n         // can't link to yourself\n@@ -1082,109 +1089,112 @@ mod test {\n         let tmpdir = tmpdir();\n         let file = tmpdir.join(\"in.txt\");\n \n-        File::create(&file).unwrap();\n-        assert!(stat(&file).unwrap().perm & io::UserWrite == io::UserWrite);\n-        chmod(&file, io::UserRead).unwrap();\n-        assert!(stat(&file).unwrap().perm & io::UserWrite == 0);\n+        check!(File::create(&file));\n+        assert!(check!(stat(&file)).perm & io::UserWrite == io::UserWrite);\n+        check!(chmod(&file, io::UserRead));\n+        assert!(check!(stat(&file)).perm & io::UserWrite == 0);\n \n         match chmod(&tmpdir.join(\"foo\"), io::UserRWX) {\n             Ok(..) => fail!(\"wanted a failure\"),\n             Err(..) => {}\n         }\n \n-        chmod(&file, io::UserFile).unwrap();\n+        check!(chmod(&file, io::UserFile));\n     })\n \n     iotest!(fn sync_doesnt_kill_anything() {\n         let tmpdir = tmpdir();\n         let path = tmpdir.join(\"in.txt\");\n \n-        let mut file = File::open_mode(&path, io::Open, io::ReadWrite).unwrap();\n-        file.fsync().unwrap();\n-        file.datasync().unwrap();\n-        file.write(bytes!(\"foo\")).unwrap();\n-        file.fsync().unwrap();\n-        file.datasync().unwrap();\n+        let mut file = check!(File::open_mode(&path, io::Open, io::ReadWrite));\n+        check!(file.fsync());\n+        check!(file.datasync());\n+        check!(file.write(bytes!(\"foo\")));\n+        check!(file.fsync());\n+        check!(file.datasync());\n         drop(file);\n-    } #[ignore(cfg(windows))])\n+    })\n \n     iotest!(fn truncate_works() {\n         let tmpdir = tmpdir();\n         let path = tmpdir.join(\"in.txt\");\n \n-        let mut file = File::open_mode(&path, io::Open, io::ReadWrite).unwrap();\n-        file.write(bytes!(\"foo\")).unwrap();\n-        file.fsync().unwrap();\n+        let mut file = check!(File::open_mode(&path, io::Open, io::ReadWrite));\n+        check!(file.write(bytes!(\"foo\")));\n+        check!(file.fsync());\n \n         // Do some simple things with truncation\n-        assert_eq!(stat(&path).unwrap().size, 3);\n-        file.truncate(10).unwrap();\n-        assert_eq!(stat(&path).unwrap().size, 10);\n-        file.write(bytes!(\"bar\")).unwrap();\n-        file.fsync().unwrap();\n-        assert_eq!(stat(&path).unwrap().size, 10);\n-        assert_eq!(File::open(&path).read_to_end().unwrap(),\n+        assert_eq!(check!(stat(&path)).size, 3);\n+        check!(file.truncate(10));\n+        assert_eq!(check!(stat(&path)).size, 10);\n+        check!(file.write(bytes!(\"bar\")));\n+        check!(file.fsync());\n+        assert_eq!(check!(stat(&path)).size, 10);\n+        assert_eq!(check!(File::open(&path).read_to_end()),\n                    (bytes!(\"foobar\", 0, 0, 0, 0)).to_owned());\n \n         // Truncate to a smaller length, don't seek, and then write something.\n         // Ensure that the intermediate zeroes are all filled in (we're seeked\n         // past the end of the file).\n-        file.truncate(2).unwrap();\n-        assert_eq!(stat(&path).unwrap().size, 2);\n-        file.write(bytes!(\"wut\")).unwrap();\n-        file.fsync().unwrap();\n-        assert_eq!(stat(&path).unwrap().size, 9);\n-        assert_eq!(File::open(&path).read_to_end().unwrap(),\n+        check!(file.truncate(2));\n+        assert_eq!(check!(stat(&path)).size, 2);\n+        check!(file.write(bytes!(\"wut\")));\n+        check!(file.fsync());\n+        assert_eq!(check!(stat(&path)).size, 9);\n+        assert_eq!(check!(File::open(&path).read_to_end()),\n                    (bytes!(\"fo\", 0, 0, 0, 0, \"wut\")).to_owned());\n         drop(file);\n-    } #[ignore(cfg(windows))]) // FIXME(#11638)\n+    })\n \n     iotest!(fn open_flavors() {\n         let tmpdir = tmpdir();\n \n         match File::open_mode(&tmpdir.join(\"a\"), io::Open, io::Read) {\n             Ok(..) => fail!(), Err(..) => {}\n         }\n-        File::open_mode(&tmpdir.join(\"b\"), io::Open, io::Write).unwrap();\n-        File::open_mode(&tmpdir.join(\"c\"), io::Open, io::ReadWrite).unwrap();\n-        File::open_mode(&tmpdir.join(\"d\"), io::Append, io::Write).unwrap();\n-        File::open_mode(&tmpdir.join(\"e\"), io::Append, io::ReadWrite).unwrap();\n-        File::open_mode(&tmpdir.join(\"f\"), io::Truncate, io::Write).unwrap();\n-        File::open_mode(&tmpdir.join(\"g\"), io::Truncate, io::ReadWrite).unwrap();\n-\n-        File::create(&tmpdir.join(\"h\")).write(\"foo\".as_bytes()).unwrap();\n-        File::open_mode(&tmpdir.join(\"h\"), io::Open, io::Read).unwrap();\n+        check!(File::open_mode(&tmpdir.join(\"b\"), io::Open, io::Write));\n+        check!(File::open_mode(&tmpdir.join(\"c\"), io::Open, io::ReadWrite));\n+        check!(File::open_mode(&tmpdir.join(\"d\"), io::Append, io::Write));\n+        check!(File::open_mode(&tmpdir.join(\"e\"), io::Append, io::ReadWrite));\n+        check!(File::open_mode(&tmpdir.join(\"f\"), io::Truncate, io::Write));\n+        check!(File::open_mode(&tmpdir.join(\"g\"), io::Truncate, io::ReadWrite));\n+\n+        check!(File::create(&tmpdir.join(\"h\")).write(\"foo\".as_bytes()));\n+        check!(File::open_mode(&tmpdir.join(\"h\"), io::Open, io::Read));\n         {\n-            let mut f = File::open_mode(&tmpdir.join(\"h\"), io::Open,\n-                                        io::Read).unwrap();\n+            let mut f = check!(File::open_mode(&tmpdir.join(\"h\"), io::Open,\n+                                               io::Read));\n             match f.write(\"wut\".as_bytes()) {\n                 Ok(..) => fail!(), Err(..) => {}\n             }\n         }\n-        assert_eq!(stat(&tmpdir.join(\"h\")).unwrap().size, 3);\n+        assert!(check!(stat(&tmpdir.join(\"h\"))).size == 3,\n+                \"write/stat failed\");\n         {\n-            let mut f = File::open_mode(&tmpdir.join(\"h\"), io::Append,\n-                                        io::Write).unwrap();\n-            f.write(\"bar\".as_bytes()).unwrap();\n+            let mut f = check!(File::open_mode(&tmpdir.join(\"h\"), io::Append,\n+                                               io::Write));\n+            check!(f.write(\"bar\".as_bytes()));\n         }\n-        assert_eq!(stat(&tmpdir.join(\"h\")).unwrap().size, 6);\n+        assert!(check!(stat(&tmpdir.join(\"h\"))).size == 6,\n+                \"append didn't append\");\n         {\n-            let mut f = File::open_mode(&tmpdir.join(\"h\"), io::Truncate,\n-                                        io::Write).unwrap();\n-            f.write(\"bar\".as_bytes()).unwrap();\n+            let mut f = check!(File::open_mode(&tmpdir.join(\"h\"), io::Truncate,\n+                                               io::Write));\n+            check!(f.write(\"bar\".as_bytes()));\n         }\n-        assert_eq!(stat(&tmpdir.join(\"h\")).unwrap().size, 3);\n+        assert!(check!(stat(&tmpdir.join(\"h\"))).size == 3,\n+                \"truncate didn't truncate\");\n     })\n \n     #[test]\n     fn utime() {\n         let tmpdir = tmpdir();\n         let path = tmpdir.join(\"a\");\n-        File::create(&path).unwrap();\n+        check!(File::create(&path));\n \n-        change_file_times(&path, 1000, 2000).unwrap();\n-        assert_eq!(path.stat().unwrap().accessed, 1000);\n-        assert_eq!(path.stat().unwrap().modified, 2000);\n+        check!(change_file_times(&path, 1000, 2000));\n+        assert_eq!(check!(path.stat()).accessed, 1000);\n+        assert_eq!(check!(path.stat()).modified, 2000);\n     }\n \n     #[test]\n@@ -1196,4 +1206,17 @@ mod test {\n             Err(..) => {}\n         }\n     }\n+\n+    iotest!(fn binary_file() {\n+        use rand::{rng, Rng};\n+\n+        let mut bytes = [0, ..1024];\n+        rng().fill_bytes(bytes);\n+\n+        let tmpdir = tmpdir();\n+\n+        check!(File::create(&tmpdir.join(\"test\")).write(bytes));\n+        let actual = check!(File::open(&tmpdir.join(\"test\")).read_to_end());\n+        assert!(actual.as_slice == bytes);\n+    })\n }"}, {"sha": "4545fea061b8f31a67e765a3440c0afda746ba2d", "filename": "src/libstd/io/net/unix.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/843c5e6308920018defe62fd1951c8a5b45553b1/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843c5e6308920018defe62fd1951c8a5b45553b1/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=843c5e6308920018defe62fd1951c8a5b45553b1", "patch": "@@ -137,16 +137,20 @@ mod tests {\n     pub fn smalltest(server: proc(UnixStream), client: proc(UnixStream)) {\n         let path1 = next_test_unix();\n         let path2 = path1.clone();\n-        let (port, chan) = Chan::new();\n+\n+        let mut acceptor = UnixListener::bind(&path1).listen();\n \n         spawn(proc() {\n-            port.recv();\n-            client(UnixStream::connect(&path2).unwrap());\n+            match UnixStream::connect(&path2) {\n+                Ok(c) => client(c),\n+                Err(e) => fail!(\"failed connect: {}\", e),\n+            }\n         });\n \n-        let mut acceptor = UnixListener::bind(&path1).listen();\n-        chan.send(());\n-        server(acceptor.accept().unwrap());\n+        match acceptor.accept() {\n+            Ok(c) => server(c),\n+            Err(e) => fail!(\"failed accept: {}\", e),\n+        }\n     }\n \n     iotest!(fn bind_error() {"}, {"sha": "43419c751fcced9e4101069e96f435c0cb6897bc", "filename": "src/libstd/io/signal.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/843c5e6308920018defe62fd1951c8a5b45553b1/src%2Flibstd%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843c5e6308920018defe62fd1951c8a5b45553b1/src%2Flibstd%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fsignal.rs?ref=843c5e6308920018defe62fd1951c8a5b45553b1", "patch": "@@ -146,22 +146,20 @@ impl Listener {\n     }\n }\n \n-#[cfg(test)]\n-mod test {\n+#[cfg(test, unix)]\n+mod test_unix {\n     use libc;\n     use comm::Empty;\n     use io::timer;\n     use super::{Listener, Interrupt};\n \n-    // kill is only available on Unixes\n-    #[cfg(unix)]\n     fn sigint() {\n         unsafe {\n             libc::funcs::posix88::signal::kill(libc::getpid(), libc::SIGINT);\n         }\n     }\n \n-    #[test] #[cfg(unix, not(target_os=\"android\"))] // FIXME(#10378)\n+    #[test] #[cfg(not(target_os=\"android\"))] // FIXME(#10378)\n     fn test_io_signal_smoketest() {\n         let mut signal = Listener::new();\n         signal.register(Interrupt).unwrap();\n@@ -173,7 +171,7 @@ mod test {\n         }\n     }\n \n-    #[test] #[cfg(unix, not(target_os=\"android\"))] // FIXME(#10378)\n+    #[test] #[cfg(not(target_os=\"android\"))] // FIXME(#10378)\n     fn test_io_signal_two_signal_one_signum() {\n         let mut s1 = Listener::new();\n         let mut s2 = Listener::new();\n@@ -191,7 +189,7 @@ mod test {\n         }\n     }\n \n-    #[test] #[cfg(unix, not(target_os=\"android\"))] // FIXME(#10378)\n+    #[test] #[cfg(not(target_os=\"android\"))] // FIXME(#10378)\n     fn test_io_signal_unregister() {\n         let mut s1 = Listener::new();\n         let mut s2 = Listener::new();\n@@ -202,15 +200,16 @@ mod test {\n         timer::sleep(10);\n         assert_eq!(s2.port.try_recv(), Empty);\n     }\n+}\n+\n+#[cfg(test, windows)]\n+mod test_windows {\n+    use super::{User1, Listener};\n+    use result::{Ok, Err};\n \n-    #[cfg(windows)]\n     #[test]\n     fn test_io_signal_invalid_signum() {\n-        use io;\n-        use super::User1;\n-        use result::{Ok, Err};\n         let mut s = Listener::new();\n-        let mut called = false;\n         match s.register(User1) {\n             Ok(..) => {\n                 fail!(\"Unexpected successful registry of signum {:?}\", User1);"}, {"sha": "a8f7782fa4623a2371ac47c54501c33d946d43f6", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/843c5e6308920018defe62fd1951c8a5b45553b1/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843c5e6308920018defe62fd1951c8a5b45553b1/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=843c5e6308920018defe62fd1951c8a5b45553b1", "patch": "@@ -698,8 +698,8 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $join:expr) => (\n                 {\n-                    let path = ($path);\n-                    let join = ($join);\n+                    let path = $path;\n+                    let join = $join;\n                     let mut p1 = Path::new(path);\n                     let p2 = p1.clone();\n                     p1.push(join);"}, {"sha": "10834aec64c94ea9bc836ea70bb3e1ad3a603c35", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/843c5e6308920018defe62fd1951c8a5b45553b1/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843c5e6308920018defe62fd1951c8a5b45553b1/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=843c5e6308920018defe62fd1951c8a5b45553b1", "patch": "@@ -1433,8 +1433,8 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $join:expr) => (\n                 {\n-                    let path = ($path);\n-                    let join = ($join);\n+                    let path = $path;\n+                    let join = $join;\n                     let mut p1 = Path::new(path);\n                     let p2 = p1.clone();\n                     p1.push(join);"}, {"sha": "57dbc045a65fedaa3f5df4523fe3694a6323a74e", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/843c5e6308920018defe62fd1951c8a5b45553b1/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843c5e6308920018defe62fd1951c8a5b45553b1/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=843c5e6308920018defe62fd1951c8a5b45553b1", "patch": "@@ -82,9 +82,7 @@ impl DynamicLibrary {\n #[cfg(test)]\n mod test {\n     use super::*;\n-    use option::*;\n-    use result::*;\n-    use path::*;\n+    use prelude::*;\n     use libc;\n \n     #[test]"}, {"sha": "ce719c6d0b8db4ce2ad57b7872c92509bf435dc5", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/843c5e6308920018defe62fd1951c8a5b45553b1/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843c5e6308920018defe62fd1951c8a5b45553b1/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=843c5e6308920018defe62fd1951c8a5b45553b1", "patch": "@@ -3529,7 +3529,7 @@ mod tests {\n         let mut v: [uint, .. 0] = [];\n         v.sort();\n \n-        let mut v = [0xDEADBEEF];\n+        let mut v = [0xDEADBEEFu];\n         v.sort();\n         assert_eq!(v, [0xDEADBEEF]);\n     }"}]}