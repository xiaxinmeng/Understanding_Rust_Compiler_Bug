{"sha": "ba928ba04116b70d81738a4f49c1b9b23aab7c88", "node_id": "C_kwDOAAsO6NoAKGJhOTI4YmEwNDExNmI3MGQ4MTczOGE0ZjQ5YzFiOWIyM2FhYjdjODg", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-01-26T05:15:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-26T05:15:24Z"}, "message": "Rollup merge of #106960 - estebank:parse-anon-enums, r=cjgillot\n\nTeach parser to understand fake anonymous enum syntax\n\nParse `Ty | OtherTy` in function argument and return types.\nParse type ascription in top level patterns.\n\nMinimally address #100741.", "tree": {"sha": "b5e815cec92b34722d5346a59e8a8db4776614e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5e815cec92b34722d5346a59e8a8db4776614e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba928ba04116b70d81738a4f49c1b9b23aab7c88", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj0gxsCRBK7hj4Ov3rIwAAlqAIADSjtu4V6zN+ajDY699lu9Y2\nXf9t2hffSKc+QFGYOVyWIQR3fD77PmetQEfSMue75axqD5A2rbLEKYKMjVZw70W8\nlYiOgld3VzCfSH/bpVerLQzKT3RP+0L/HZQj1BuvRWQuuSXqPvpj4keryN0jFl6L\nCoDfet0vwff0/jtcQlajEtwXaWMKTMq6M+bVtGg8me9YfxRyjb4Lkt6jAsQ+eSCx\nHWEiSAiuvGeT0ajIGHncbzSb8Knkb3sa1v7vAz7HizKjYWEEgMuzu6gXyhDeq8eC\nLIRSM3bOZxC3PWmfiKc0duHMD7CwGl5s9JCkITzsax6gRWPqZKfWUnrhRlyo6FE=\n=8Vrm\n-----END PGP SIGNATURE-----\n", "payload": "tree b5e815cec92b34722d5346a59e8a8db4776614e4\nparent 8ae5116faeedcb325c0cc49d9c0f36ceaeba5616\nparent 020cca8d36cb678e3ddc2ead41364be314d19e93\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1674710124 +0100\ncommitter GitHub <noreply@github.com> 1674710124 +0100\n\nRollup merge of #106960 - estebank:parse-anon-enums, r=cjgillot\n\nTeach parser to understand fake anonymous enum syntax\n\nParse `Ty | OtherTy` in function argument and return types.\nParse type ascription in top level patterns.\n\nMinimally address #100741.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba928ba04116b70d81738a4f49c1b9b23aab7c88", "html_url": "https://github.com/rust-lang/rust/commit/ba928ba04116b70d81738a4f49c1b9b23aab7c88", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba928ba04116b70d81738a4f49c1b9b23aab7c88/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ae5116faeedcb325c0cc49d9c0f36ceaeba5616", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ae5116faeedcb325c0cc49d9c0f36ceaeba5616", "html_url": "https://github.com/rust-lang/rust/commit/8ae5116faeedcb325c0cc49d9c0f36ceaeba5616"}, {"sha": "020cca8d36cb678e3ddc2ead41364be314d19e93", "url": "https://api.github.com/repos/rust-lang/rust/commits/020cca8d36cb678e3ddc2ead41364be314d19e93", "html_url": "https://github.com/rust-lang/rust/commit/020cca8d36cb678e3ddc2ead41364be314d19e93"}], "stats": {"total": 313, "additions": 266, "deletions": 47}, "files": [{"sha": "feb5187536ffa5cbf97869f9334f6fcc69b0068d", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ba928ba04116b70d81738a4f49c1b9b23aab7c88/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba928ba04116b70d81738a4f49c1b9b23aab7c88/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=ba928ba04116b70d81738a4f49c1b9b23aab7c88", "patch": "@@ -400,8 +400,8 @@ pub fn walk_ty<'a, V: Visitor<'a>>(visitor: &mut V, typ: &'a Ty) {\n             walk_list!(visitor, visit_lifetime, opt_lifetime, LifetimeCtxt::Ref);\n             visitor.visit_ty(&mutable_type.ty)\n         }\n-        TyKind::Tup(tuple_element_types) => {\n-            walk_list!(visitor, visit_ty, tuple_element_types);\n+        TyKind::Tup(tys) => {\n+            walk_list!(visitor, visit_ty, tys);\n         }\n         TyKind::BareFn(function_declaration) => {\n             walk_list!(visitor, visit_generic_param, &function_declaration.generic_params);"}, {"sha": "eda7046c748e5f52121854349a3fa6f903e502d2", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 39, "deletions": 13, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/ba928ba04116b70d81738a4f49c1b9b23aab7c88/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba928ba04116b70d81738a4f49c1b9b23aab7c88/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=ba928ba04116b70d81738a4f49c1b9b23aab7c88", "patch": "@@ -2372,7 +2372,7 @@ impl<'a> Parser<'a> {\n \n     /// Some special error handling for the \"top-level\" patterns in a match arm,\n     /// `for` loop, `let`, &c. (in contrast to subpatterns within such).\n-    pub(crate) fn maybe_recover_colon_colon_in_pat_typo(\n+    pub(crate) fn maybe_recover_colon_colon_in_pat_typo_or_anon_enum(\n         &mut self,\n         mut first_pat: P<Pat>,\n         expected: Expected,\n@@ -2383,26 +2383,41 @@ impl<'a> Parser<'a> {\n         if !matches!(first_pat.kind, PatKind::Ident(_, _, None) | PatKind::Path(..))\n             || !self.look_ahead(1, |token| token.is_ident() && !token.is_reserved_ident())\n         {\n+            let mut snapshot_type = self.create_snapshot_for_diagnostic();\n+            snapshot_type.bump(); // `:`\n+            match snapshot_type.parse_ty() {\n+                Err(inner_err) => {\n+                    inner_err.cancel();\n+                }\n+                Ok(ty) => {\n+                    let Err(mut err) = self.expected_one_of_not_found(&[], &[]) else {\n+                        return first_pat;\n+                    };\n+                    err.span_label(ty.span, \"specifying the type of a pattern isn't supported\");\n+                    self.restore_snapshot(snapshot_type);\n+                    let span = first_pat.span.to(ty.span);\n+                    first_pat = self.mk_pat(span, PatKind::Wild);\n+                    err.emit();\n+                }\n+            }\n             return first_pat;\n         }\n         // The pattern looks like it might be a path with a `::` -> `:` typo:\n         // `match foo { bar:baz => {} }`\n-        let span = self.token.span;\n+        let colon_span = self.token.span;\n         // We only emit \"unexpected `:`\" error here if we can successfully parse the\n         // whole pattern correctly in that case.\n-        let snapshot = self.create_snapshot_for_diagnostic();\n+        let mut snapshot_pat = self.create_snapshot_for_diagnostic();\n+        let mut snapshot_type = self.create_snapshot_for_diagnostic();\n \n         // Create error for \"unexpected `:`\".\n         match self.expected_one_of_not_found(&[], &[]) {\n             Err(mut err) => {\n-                self.bump(); // Skip the `:`.\n-                match self.parse_pat_no_top_alt(expected) {\n+                snapshot_pat.bump(); // Skip the `:`.\n+                snapshot_type.bump(); // Skip the `:`.\n+                match snapshot_pat.parse_pat_no_top_alt(expected) {\n                     Err(inner_err) => {\n-                        // Carry on as if we had not done anything, callers will emit a\n-                        // reasonable error.\n                         inner_err.cancel();\n-                        err.cancel();\n-                        self.restore_snapshot(snapshot);\n                     }\n                     Ok(mut pat) => {\n                         // We've parsed the rest of the pattern.\n@@ -2466,22 +2481,33 @@ impl<'a> Parser<'a> {\n                             _ => {}\n                         }\n                         if show_sugg {\n-                            err.span_suggestion(\n-                                span,\n+                            err.span_suggestion_verbose(\n+                                colon_span.until(self.look_ahead(1, |t| t.span)),\n                                 \"maybe write a path separator here\",\n                                 \"::\",\n                                 Applicability::MaybeIncorrect,\n                             );\n                         } else {\n                             first_pat = self.mk_pat(new_span, PatKind::Wild);\n                         }\n-                        err.emit();\n+                        self.restore_snapshot(snapshot_pat);\n                     }\n                 }\n+                match snapshot_type.parse_ty() {\n+                    Err(inner_err) => {\n+                        inner_err.cancel();\n+                    }\n+                    Ok(ty) => {\n+                        err.span_label(ty.span, \"specifying the type of a pattern isn't supported\");\n+                        self.restore_snapshot(snapshot_type);\n+                        let new_span = first_pat.span.to(ty.span);\n+                        first_pat = self.mk_pat(new_span, PatKind::Wild);\n+                    }\n+                }\n+                err.emit();\n             }\n             _ => {\n                 // Carry on as if we had not done anything. This should be unreachable.\n-                self.restore_snapshot(snapshot);\n             }\n         };\n         first_pat"}, {"sha": "e5411538eea220ce5ff179026be98d677b08dc67", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ba928ba04116b70d81738a4f49c1b9b23aab7c88/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba928ba04116b70d81738a4f49c1b9b23aab7c88/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=ba928ba04116b70d81738a4f49c1b9b23aab7c88", "patch": "@@ -116,7 +116,8 @@ impl<'a> Parser<'a> {\n \n             // Check if the user wrote `foo:bar` instead of `foo::bar`.\n             if ra == RecoverColon::Yes {\n-                first_pat = self.maybe_recover_colon_colon_in_pat_typo(first_pat, expected);\n+                first_pat =\n+                    self.maybe_recover_colon_colon_in_pat_typo_or_anon_enum(first_pat, expected);\n             }\n \n             if let Some(leading_vert_span) = leading_vert_span {"}, {"sha": "25de0a9e75014ae019b680aedaf410e4563bcc5d", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 63, "deletions": 4, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/ba928ba04116b70d81738a4f49c1b9b23aab7c88/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba928ba04116b70d81738a4f49c1b9b23aab7c88/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=ba928ba04116b70d81738a4f49c1b9b23aab7c88", "patch": "@@ -11,6 +11,7 @@ use rustc_ast::{\n     self as ast, BareFnTy, FnRetTy, GenericBound, GenericBounds, GenericParam, Generics, Lifetime,\n     MacCall, MutTy, Mutability, PolyTraitRef, TraitBoundModifier, TraitObjectSyntax, Ty, TyKind,\n };\n+use rustc_ast_pretty::pprust;\n use rustc_errors::{pluralize, struct_span_err, Applicability, PResult};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{kw, sym, Ident};\n@@ -43,17 +44,24 @@ pub(super) enum AllowPlus {\n     No,\n }\n \n-#[derive(PartialEq)]\n+#[derive(PartialEq, Clone, Copy)]\n pub(super) enum RecoverQPath {\n     Yes,\n     No,\n }\n \n+#[derive(PartialEq, Clone, Copy)]\n pub(super) enum RecoverQuestionMark {\n     Yes,\n     No,\n }\n \n+#[derive(PartialEq, Clone, Copy)]\n+pub(super) enum RecoverAnonEnum {\n+    Yes,\n+    No,\n+}\n+\n /// Signals whether parsing a type should recover `->`.\n ///\n /// More specifically, when parsing a function like:\n@@ -86,7 +94,7 @@ impl RecoverReturnSign {\n }\n \n // Is `...` (`CVarArgs`) legal at this level of type parsing?\n-#[derive(PartialEq)]\n+#[derive(PartialEq, Clone, Copy)]\n enum AllowCVariadic {\n     Yes,\n     No,\n@@ -111,6 +119,7 @@ impl<'a> Parser<'a> {\n             RecoverReturnSign::Yes,\n             None,\n             RecoverQuestionMark::Yes,\n+            RecoverAnonEnum::No,\n         )\n     }\n \n@@ -125,6 +134,7 @@ impl<'a> Parser<'a> {\n             RecoverReturnSign::Yes,\n             Some(ty_params),\n             RecoverQuestionMark::Yes,\n+            RecoverAnonEnum::No,\n         )\n     }\n \n@@ -139,6 +149,7 @@ impl<'a> Parser<'a> {\n             RecoverReturnSign::Yes,\n             None,\n             RecoverQuestionMark::Yes,\n+            RecoverAnonEnum::Yes,\n         )\n     }\n \n@@ -156,6 +167,7 @@ impl<'a> Parser<'a> {\n             RecoverReturnSign::Yes,\n             None,\n             RecoverQuestionMark::Yes,\n+            RecoverAnonEnum::No,\n         )\n     }\n \n@@ -169,6 +181,7 @@ impl<'a> Parser<'a> {\n             RecoverReturnSign::Yes,\n             None,\n             RecoverQuestionMark::No,\n+            RecoverAnonEnum::No,\n         )\n     }\n \n@@ -180,6 +193,7 @@ impl<'a> Parser<'a> {\n             RecoverReturnSign::Yes,\n             None,\n             RecoverQuestionMark::No,\n+            RecoverAnonEnum::No,\n         )\n     }\n \n@@ -192,6 +206,7 @@ impl<'a> Parser<'a> {\n             RecoverReturnSign::OnlyFatArrow,\n             None,\n             RecoverQuestionMark::Yes,\n+            RecoverAnonEnum::No,\n         )\n     }\n \n@@ -211,6 +226,7 @@ impl<'a> Parser<'a> {\n                 recover_return_sign,\n                 None,\n                 RecoverQuestionMark::Yes,\n+                RecoverAnonEnum::Yes,\n             )?;\n             FnRetTy::Ty(ty)\n         } else if recover_return_sign.can_recover(&self.token.kind) {\n@@ -232,6 +248,7 @@ impl<'a> Parser<'a> {\n                 recover_return_sign,\n                 None,\n                 RecoverQuestionMark::Yes,\n+                RecoverAnonEnum::Yes,\n             )?;\n             FnRetTy::Ty(ty)\n         } else {\n@@ -247,6 +264,7 @@ impl<'a> Parser<'a> {\n         recover_return_sign: RecoverReturnSign,\n         ty_generics: Option<&Generics>,\n         recover_question_mark: RecoverQuestionMark,\n+        recover_anon_enum: RecoverAnonEnum,\n     ) -> PResult<'a, P<Ty>> {\n         let allow_qpath_recovery = recover_qpath == RecoverQPath::Yes;\n         maybe_recover_from_interpolated_ty_qpath!(self, allow_qpath_recovery);\n@@ -325,14 +343,55 @@ impl<'a> Parser<'a> {\n         let mut ty = self.mk_ty(span, kind);\n \n         // Try to recover from use of `+` with incorrect priority.\n-        if matches!(allow_plus, AllowPlus::Yes) {\n+        if allow_plus == AllowPlus::Yes {\n             self.maybe_recover_from_bad_type_plus(&ty)?;\n         } else {\n             self.maybe_report_ambiguous_plus(impl_dyn_multi, &ty);\n         }\n-        if let RecoverQuestionMark::Yes = recover_question_mark {\n+        if RecoverQuestionMark::Yes == recover_question_mark {\n             ty = self.maybe_recover_from_question_mark(ty);\n         }\n+        if recover_anon_enum == RecoverAnonEnum::Yes\n+            && self.check_noexpect(&token::BinOp(token::Or))\n+            && self.look_ahead(1, |t| t.can_begin_type())\n+        {\n+            let mut pipes = vec![self.token.span];\n+            let mut types = vec![ty];\n+            loop {\n+                if !self.eat(&token::BinOp(token::Or)) {\n+                    break;\n+                }\n+                pipes.push(self.prev_token.span);\n+                types.push(self.parse_ty_common(\n+                    allow_plus,\n+                    allow_c_variadic,\n+                    recover_qpath,\n+                    recover_return_sign,\n+                    ty_generics,\n+                    recover_question_mark,\n+                    RecoverAnonEnum::No,\n+                )?);\n+            }\n+            let mut err = self.struct_span_err(pipes, \"anonymous enums are not supported\");\n+            for ty in &types {\n+                err.span_label(ty.span, \"\");\n+            }\n+            err.help(&format!(\n+                \"create a named `enum` and use it here instead:\\nenum Name {{\\n{}\\n}}\",\n+                types\n+                    .iter()\n+                    .enumerate()\n+                    .map(|(i, t)| format!(\n+                        \"    Variant{}({}),\",\n+                        i + 1, // Lets not confuse people with zero-indexing :)\n+                        pprust::to_string(|s| s.print_type(&t)),\n+                    ))\n+                    .collect::<Vec<_>>()\n+                    .join(\"\\n\"),\n+            ));\n+            err.emit();\n+            return Ok(self.mk_ty(lo.to(self.prev_token.span), TyKind::Err));\n+        }\n         if allow_qpath_recovery { self.maybe_recover_from_bad_qpath(ty) } else { Ok(ty) }\n     }\n "}, {"sha": "56b8a3d43bedf674eb4a879fea8252e8f2f9273e", "filename": "tests/ui/parser/anon-enums.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ba928ba04116b70d81738a4f49c1b9b23aab7c88/tests%2Fui%2Fparser%2Fanon-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba928ba04116b70d81738a4f49c1b9b23aab7c88/tests%2Fui%2Fparser%2Fanon-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fanon-enums.rs?ref=ba928ba04116b70d81738a4f49c1b9b23aab7c88", "patch": "@@ -0,0 +1,17 @@\n+fn foo(x: bool | i32) -> i32 | f64 {\n+//~^ ERROR anonymous enums are not supported\n+//~| ERROR anonymous enums are not supported\n+    match x {\n+        x: i32 => x, //~ ERROR expected\n+        true => 42.,\n+        false => 0.333,\n+    }\n+}\n+\n+fn main() {\n+    match foo(true) {\n+        42: i32 => (), //~ ERROR expected\n+        _: f64 => (), //~ ERROR expected\n+        x: i32 => (), //~ ERROR expected\n+    }\n+}"}, {"sha": "841582256609121d41403607a0fe2d2a1b43c65c", "filename": "tests/ui/parser/anon-enums.stderr", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/ba928ba04116b70d81738a4f49c1b9b23aab7c88/tests%2Fui%2Fparser%2Fanon-enums.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ba928ba04116b70d81738a4f49c1b9b23aab7c88/tests%2Fui%2Fparser%2Fanon-enums.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fanon-enums.stderr?ref=ba928ba04116b70d81738a4f49c1b9b23aab7c88", "patch": "@@ -0,0 +1,68 @@\n+error: anonymous enums are not supported\n+  --> $DIR/anon-enums.rs:1:16\n+   |\n+LL | fn foo(x: bool | i32) -> i32 | f64 {\n+   |           ---- ^ ---\n+   |\n+   = help: create a named `enum` and use it here instead:\n+           enum Name {\n+               Variant1(bool),\n+               Variant2(i32),\n+           }\n+\n+error: anonymous enums are not supported\n+  --> $DIR/anon-enums.rs:1:30\n+   |\n+LL | fn foo(x: bool | i32) -> i32 | f64 {\n+   |                          --- ^ ---\n+   |\n+   = help: create a named `enum` and use it here instead:\n+           enum Name {\n+               Variant1(i32),\n+               Variant2(f64),\n+           }\n+\n+error: expected one of `@` or `|`, found `:`\n+  --> $DIR/anon-enums.rs:5:10\n+   |\n+LL |         x: i32 => x,\n+   |          ^ --- specifying the type of a pattern isn't supported\n+   |          |\n+   |          expected one of `@` or `|`\n+   |\n+help: maybe write a path separator here\n+   |\n+LL |         x::i32 => x,\n+   |          ~~\n+\n+error: expected one of `...`, `..=`, `..`, or `|`, found `:`\n+  --> $DIR/anon-enums.rs:13:11\n+   |\n+LL |         42: i32 => (),\n+   |           ^ --- specifying the type of a pattern isn't supported\n+   |           |\n+   |           expected one of `...`, `..=`, `..`, or `|`\n+\n+error: expected `|`, found `:`\n+  --> $DIR/anon-enums.rs:14:10\n+   |\n+LL |         _: f64 => (),\n+   |          ^ --- specifying the type of a pattern isn't supported\n+   |          |\n+   |          expected `|`\n+\n+error: expected one of `@` or `|`, found `:`\n+  --> $DIR/anon-enums.rs:15:10\n+   |\n+LL |         x: i32 => (),\n+   |          ^ --- specifying the type of a pattern isn't supported\n+   |          |\n+   |          expected one of `@` or `|`\n+   |\n+help: maybe write a path separator here\n+   |\n+LL |         x::i32 => (),\n+   |          ~~\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "38fe8dee2382915c6b3d0f02bb8867046a2bced5", "filename": "tests/ui/parser/fake-anon-enums-in-macros.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ba928ba04116b70d81738a4f49c1b9b23aab7c88/tests%2Fui%2Fparser%2Ffake-anon-enums-in-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba928ba04116b70d81738a4f49c1b9b23aab7c88/tests%2Fui%2Fparser%2Ffake-anon-enums-in-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Ffake-anon-enums-in-macros.rs?ref=ba928ba04116b70d81738a4f49c1b9b23aab7c88", "patch": "@@ -0,0 +1,20 @@\n+// build-pass\n+macro_rules! check_ty {\n+    ($Z:ty) => { compile_error!(\"triggered\"); };\n+    ($X:ty | $Y:ty) => { $X };\n+}\n+\n+macro_rules! check {\n+    ($Z:ty) => { compile_error!(\"triggered\"); };\n+    ($X:ty | $Y:ty) => { };\n+}\n+\n+check! { i32 | u8 }\n+\n+fn foo(x: check_ty! { i32 | u8 }) -> check_ty! { i32 | u8 } {\n+    x\n+}\n+fn main() {\n+    let x: check_ty! { i32 | u8 } = 42;\n+    let _: check_ty! { i32 | u8 } = foo(x);\n+}"}, {"sha": "e1ea38f2795df698983f335bbf6b77f13d29dad1", "filename": "tests/ui/parser/issues/issue-87086-colon-path-sep.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ba928ba04116b70d81738a4f49c1b9b23aab7c88/tests%2Fui%2Fparser%2Fissues%2Fissue-87086-colon-path-sep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba928ba04116b70d81738a4f49c1b9b23aab7c88/tests%2Fui%2Fparser%2Fissues%2Fissue-87086-colon-path-sep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fissues%2Fissue-87086-colon-path-sep.rs?ref=ba928ba04116b70d81738a4f49c1b9b23aab7c88", "patch": "@@ -68,7 +68,6 @@ fn main() {\n         Foo:Bar::Baz => {}\n         //~^ ERROR: expected one of\n         //~| HELP: maybe write a path separator here\n-        //~| ERROR: failed to resolve: `Bar` is a variant, not a module\n     }\n     match myfoo {\n         Foo::Bar => {}"}, {"sha": "63b072ac4cdc68c6c4f9ec8734f49945c45de38e", "filename": "tests/ui/parser/issues/issue-87086-colon-path-sep.stderr", "status": "modified", "additions": 55, "deletions": 26, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/ba928ba04116b70d81738a4f49c1b9b23aab7c88/tests%2Fui%2Fparser%2Fissues%2Fissue-87086-colon-path-sep.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ba928ba04116b70d81738a4f49c1b9b23aab7c88/tests%2Fui%2Fparser%2Fissues%2Fissue-87086-colon-path-sep.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fissues%2Fissue-87086-colon-path-sep.stderr?ref=ba928ba04116b70d81738a4f49c1b9b23aab7c88", "patch": "@@ -2,89 +2,118 @@ error: expected one of `@` or `|`, found `:`\n   --> $DIR/issue-87086-colon-path-sep.rs:17:12\n    |\n LL |         Foo:Bar => {}\n-   |            ^\n+   |            ^--- specifying the type of a pattern isn't supported\n    |            |\n    |            expected one of `@` or `|`\n-   |            help: maybe write a path separator here: `::`\n+   |\n+help: maybe write a path separator here\n+   |\n+LL |         Foo::Bar => {}\n+   |            ~~\n \n error: expected one of `!`, `(`, `...`, `..=`, `..`, `::`, `{`, or `|`, found `:`\n   --> $DIR/issue-87086-colon-path-sep.rs:23:17\n    |\n LL |         qux::Foo:Bar => {}\n-   |                 ^\n+   |                 ^--- specifying the type of a pattern isn't supported\n    |                 |\n    |                 expected one of 8 possible tokens\n-   |                 help: maybe write a path separator here: `::`\n+   |\n+help: maybe write a path separator here\n+   |\n+LL |         qux::Foo::Bar => {}\n+   |                 ~~\n \n error: expected one of `@` or `|`, found `:`\n   --> $DIR/issue-87086-colon-path-sep.rs:29:12\n    |\n LL |         qux:Foo::Baz => {}\n-   |            ^\n+   |            ^-------- specifying the type of a pattern isn't supported\n    |            |\n    |            expected one of `@` or `|`\n-   |            help: maybe write a path separator here: `::`\n+   |\n+help: maybe write a path separator here\n+   |\n+LL |         qux::Foo::Baz => {}\n+   |            ~~\n \n error: expected one of `@` or `|`, found `:`\n   --> $DIR/issue-87086-colon-path-sep.rs:35:12\n    |\n LL |         qux: Foo::Baz if true => {}\n-   |            ^\n+   |            ^ -------- specifying the type of a pattern isn't supported\n    |            |\n    |            expected one of `@` or `|`\n-   |            help: maybe write a path separator here: `::`\n+   |\n+help: maybe write a path separator here\n+   |\n+LL |         qux::Foo::Baz if true => {}\n+   |            ~~\n \n error: expected one of `@` or `|`, found `:`\n   --> $DIR/issue-87086-colon-path-sep.rs:40:15\n    |\n LL |     if let Foo:Bar = f() {\n-   |               ^\n+   |               ^--- specifying the type of a pattern isn't supported\n    |               |\n    |               expected one of `@` or `|`\n-   |               help: maybe write a path separator here: `::`\n+   |\n+help: maybe write a path separator here\n+   |\n+LL |     if let Foo::Bar = f() {\n+   |               ~~\n \n error: expected one of `@` or `|`, found `:`\n   --> $DIR/issue-87086-colon-path-sep.rs:48:16\n    |\n LL |         ref qux: Foo::Baz => {}\n-   |                ^\n+   |                ^ -------- specifying the type of a pattern isn't supported\n    |                |\n    |                expected one of `@` or `|`\n-   |                help: maybe write a path separator here: `::`\n+   |\n+help: maybe write a path separator here\n+   |\n+LL |         ref qux::Foo::Baz => {}\n+   |                ~~\n \n error: expected one of `@` or `|`, found `:`\n   --> $DIR/issue-87086-colon-path-sep.rs:57:16\n    |\n LL |         mut qux: Foo::Baz => {}\n-   |                ^\n+   |                ^ -------- specifying the type of a pattern isn't supported\n    |                |\n    |                expected one of `@` or `|`\n-   |                help: maybe write a path separator here: `::`\n+   |\n+help: maybe write a path separator here\n+   |\n+LL |         mut qux::Foo::Baz => {}\n+   |                ~~\n \n error: expected one of `@` or `|`, found `:`\n   --> $DIR/issue-87086-colon-path-sep.rs:68:12\n    |\n LL |         Foo:Bar::Baz => {}\n-   |            ^\n+   |            ^-------- specifying the type of a pattern isn't supported\n    |            |\n    |            expected one of `@` or `|`\n-   |            help: maybe write a path separator here: `::`\n+   |\n+help: maybe write a path separator here\n+   |\n+LL |         Foo::Bar::Baz => {}\n+   |            ~~\n \n error: expected one of `@` or `|`, found `:`\n-  --> $DIR/issue-87086-colon-path-sep.rs:75:12\n+  --> $DIR/issue-87086-colon-path-sep.rs:74:12\n    |\n LL |         Foo:Bar => {}\n-   |            ^\n+   |            ^--- specifying the type of a pattern isn't supported\n    |            |\n    |            expected one of `@` or `|`\n-   |            help: maybe write a path separator here: `::`\n-\n-error[E0433]: failed to resolve: `Bar` is a variant, not a module\n-  --> $DIR/issue-87086-colon-path-sep.rs:68:13\n    |\n-LL |         Foo:Bar::Baz => {}\n-   |             ^^^ `Bar` is a variant, not a module\n+help: maybe write a path separator here\n+   |\n+LL |         Foo::Bar => {}\n+   |            ~~\n \n-error: aborting due to 10 previous errors\n+error: aborting due to 9 previous errors\n \n-For more information about this error, try `rustc --explain E0433`."}]}