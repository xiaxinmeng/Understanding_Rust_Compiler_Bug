{"sha": "b5b4a1f23dd4d544eec0699bda9df39235617711", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1YjRhMWYyM2RkNGQ1NDRlZWMwNjk5YmRhOWRmMzkyMzU2MTc3MTE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-04-30T09:07:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-30T09:07:24Z"}, "message": "Merge #8692\n\n8692: Fix panic caused by new Try trait definition r=flodiebold a=flodiebold\n\nThe new Try trait definition caused a query cycle for us. This adds recovery for that cycle, but also fixes the cause, which is that we went through the supertraits when resolving `<T as Trait>::Assoc`, which isn't actually necessary. I also rewrote `all_super_trait_refs` to an iterator before I realized what the actual problem was, so I kept that.\r\n\r\nFixes #8686.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "155a638a9cb73ddce1df6ce0c7b43fe4d4b12c69", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/155a638a9cb73ddce1df6ce0c7b43fe4d4b12c69"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5b4a1f23dd4d544eec0699bda9df39235617711", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgi8jMCRBK7hj4Ov3rIwAAO6AIABw/T4QDigyGjKjL5nCdi0Fs\nZXM7SmSJAOqzhTXwWnYdQBamXYrZVAxpq1kAMqNSavN9N49a9v7L8gyCOh9i/Buo\nqHPyqFbXClBhqmnE4IW8KRVpss5BsOwlZUW9olkCotvApt3wohHjEUYYiFVIVBlo\nqcYRDR3u/778TXRZlOLH/t3jqemEna9KhisZK2YCP1jdp11DN4Bvemd4oPrDU1jJ\nr8u5ci48GON7dv9/ossAA3BZobIXH2Z6aMLLZLd/dLt0xyZ4SuM32nsOTNr3ThIc\nrhB/bN2GPDF46vbnASxhFP4ES8rq28d0dvodLpvykP6CLwz+KoVXMXFSYuYSHPs=\n=WS7z\n-----END PGP SIGNATURE-----\n", "payload": "tree 155a638a9cb73ddce1df6ce0c7b43fe4d4b12c69\nparent 6ea91a419f89e2486938d139daf8eb8620444944\nparent c2aefd5b95adb9e07919a11cdfcca45de79b5324\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1619773644 +0000\ncommitter GitHub <noreply@github.com> 1619773644 +0000\n\nMerge #8692\n\n8692: Fix panic caused by new Try trait definition r=flodiebold a=flodiebold\n\nThe new Try trait definition caused a query cycle for us. This adds recovery for that cycle, but also fixes the cause, which is that we went through the supertraits when resolving `<T as Trait>::Assoc`, which isn't actually necessary. I also rewrote `all_super_trait_refs` to an iterator before I realized what the actual problem was, so I kept that.\r\n\r\nFixes #8686.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5b4a1f23dd4d544eec0699bda9df39235617711", "html_url": "https://github.com/rust-lang/rust/commit/b5b4a1f23dd4d544eec0699bda9df39235617711", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5b4a1f23dd4d544eec0699bda9df39235617711/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ea91a419f89e2486938d139daf8eb8620444944", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ea91a419f89e2486938d139daf8eb8620444944", "html_url": "https://github.com/rust-lang/rust/commit/6ea91a419f89e2486938d139daf8eb8620444944"}, {"sha": "c2aefd5b95adb9e07919a11cdfcca45de79b5324", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2aefd5b95adb9e07919a11cdfcca45de79b5324", "html_url": "https://github.com/rust-lang/rust/commit/c2aefd5b95adb9e07919a11cdfcca45de79b5324"}], "stats": {"total": 125, "additions": 100, "deletions": 25}, "files": [{"sha": "9da0a02e3341d5af0ee29cd9aa6401a78156a59a", "filename": "crates/hir_ty/src/db.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b5b4a1f23dd4d544eec0699bda9df39235617711/crates%2Fhir_ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b4a1f23dd4d544eec0699bda9df39235617711/crates%2Fhir_ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdb.rs?ref=b5b4a1f23dd4d544eec0699bda9df39235617711", "patch": "@@ -70,6 +70,7 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     fn trait_environment(&self, def: GenericDefId) -> Arc<crate::TraitEnvironment>;\n \n     #[salsa::invoke(crate::lower::generic_defaults_query)]\n+    #[salsa::cycle(crate::lower::generic_defaults_recover)]\n     fn generic_defaults(&self, def: GenericDefId) -> Arc<[Binders<Ty>]>;\n \n     #[salsa::invoke(InherentImpls::inherent_impls_in_crate_query)]"}, {"sha": "c99dd8d0a46d5b1c56a283d6a46aaebdfabbee3d", "filename": "crates/hir_ty/src/lower.rs", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b5b4a1f23dd4d544eec0699bda9df39235617711/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b4a1f23dd4d544eec0699bda9df39235617711/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=b5b4a1f23dd4d544eec0699bda9df39235617711", "patch": "@@ -414,17 +414,16 @@ impl<'a> TyLoweringContext<'a> {\n                     self.lower_trait_ref_from_resolved_path(trait_, resolved_segment, self_ty);\n                 let ty = if remaining_segments.len() == 1 {\n                     let segment = remaining_segments.first().unwrap();\n-                    let found = associated_type_by_name_including_super_traits(\n-                        self.db,\n-                        trait_ref,\n-                        &segment.name,\n-                    );\n+                    let found = self\n+                        .db\n+                        .trait_data(trait_ref.hir_trait_id())\n+                        .associated_type_by_name(&segment.name);\n                     match found {\n-                        Some((super_trait_ref, associated_ty)) => {\n+                        Some(associated_ty) => {\n                             // FIXME handle type parameters on the segment\n                             TyKind::Alias(AliasTy::Projection(ProjectionTy {\n                                 associated_ty_id: to_assoc_type_id(associated_ty),\n-                                substitution: super_trait_ref.substitution,\n+                                substitution: trait_ref.substitution,\n                             }))\n                             .intern(&Interner)\n                         }\n@@ -1089,6 +1088,27 @@ pub(crate) fn generic_defaults_query(\n     defaults\n }\n \n+pub(crate) fn generic_defaults_recover(\n+    db: &dyn HirDatabase,\n+    _cycle: &[String],\n+    def: &GenericDefId,\n+) -> Arc<[Binders<Ty>]> {\n+    let generic_params = generics(db.upcast(), *def);\n+\n+    // we still need one default per parameter\n+    let defaults = generic_params\n+        .iter()\n+        .enumerate()\n+        .map(|(idx, _)| {\n+            let ty = TyKind::Error.intern(&Interner);\n+\n+            crate::make_only_type_binders(idx, ty)\n+        })\n+        .collect();\n+\n+    defaults\n+}\n+\n fn fn_sig_for_fn(db: &dyn HirDatabase, def: FunctionId) -> PolyFnSig {\n     let data = db.function_data(def);\n     let resolver = def.resolver(db.upcast());"}, {"sha": "d14f5c9bb11af73c43f047055870c29c734e6ae8", "filename": "crates/hir_ty/src/tests/regression.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b5b4a1f23dd4d544eec0699bda9df39235617711/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b4a1f23dd4d544eec0699bda9df39235617711/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs?ref=b5b4a1f23dd4d544eec0699bda9df39235617711", "patch": "@@ -1012,3 +1012,41 @@ fn lifetime_from_chalk_during_deref() {\n         \"#,\n     )\n }\n+\n+#[test]\n+fn issue_8686() {\n+    check_infer(\n+        r#\"\n+pub trait Try: FromResidual {\n+    type Output;\n+    type Residual;\n+}\n+pub trait FromResidual<R = <Self as Try>::Residual> {\n+     fn from_residual(residual: R) -> Self;\n+}\n+\n+struct ControlFlow<B, C>;\n+impl<B, C> Try for ControlFlow<B, C> {\n+    type Output = C;\n+    type Residual = ControlFlow<B, !>;\n+}\n+impl<B, C> FromResidual for ControlFlow<B, C> {\n+    fn from_residual(r: ControlFlow<B, !>) -> Self { ControlFlow }\n+}\n+\n+fn test() {\n+    ControlFlow::from_residual(ControlFlow::<u32, !>);\n+}\n+        \"#,\n+        expect![[r#\"\n+            144..152 'residual': R\n+            365..366 'r': ControlFlow<B, !>\n+            395..410 '{ ControlFlow }': ControlFlow<B, C>\n+            397..408 'ControlFlow': ControlFlow<B, C>\n+            424..482 '{     ...!>); }': ()\n+            430..456 'Contro...sidual': fn from_residual<ControlFlow<u32, {unknown}>, ControlFlow<u32, !>>(ControlFlow<u32, !>) -> ControlFlow<u32, {unknown}>\n+            430..479 'Contro...2, !>)': ControlFlow<u32, {unknown}>\n+            457..478 'Contro...32, !>': ControlFlow<u32, !>\n+        \"#]],\n+    );\n+}"}, {"sha": "2f490fb92026656ec512f8720a35ec846be6172c", "filename": "crates/hir_ty/src/utils.rs", "status": "modified", "additions": 34, "deletions": 18, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/b5b4a1f23dd4d544eec0699bda9df39235617711/crates%2Fhir_ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b4a1f23dd4d544eec0699bda9df39235617711/crates%2Fhir_ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Futils.rs?ref=b5b4a1f23dd4d544eec0699bda9df39235617711", "patch": "@@ -1,6 +1,8 @@\n //! Helper functions for working with def, which don't need to be a separate\n //! query, but can't be computed directly from `*Data` (ie, which need a `db`).\n \n+use std::iter;\n+\n use chalk_ir::{fold::Shift, BoundVar, DebruijnIndex};\n use hir_def::{\n     db::DefDatabase,\n@@ -14,8 +16,12 @@ use hir_def::{\n     AssocContainerId, GenericDefId, Lookup, TraitId, TypeAliasId, TypeParamId,\n };\n use hir_expand::name::{name, Name};\n+use rustc_hash::FxHashSet;\n \n-use crate::{db::HirDatabase, Interner, Substitution, TraitRef, TraitRefExt, TyKind, WhereClause};\n+use crate::{\n+    db::HirDatabase, ChalkTraitId, Interner, Substitution, TraitRef, TraitRefExt, TyKind,\n+    WhereClause,\n+};\n \n fn direct_super_traits(db: &dyn DefDatabase, trait_: TraitId) -> Vec<TraitId> {\n     let resolver = trait_.resolver(db);\n@@ -102,33 +108,43 @@ pub fn all_super_traits(db: &dyn DefDatabase, trait_: TraitId) -> Vec<TraitId> {\n /// `all_super_traits` is that we keep track of type parameters; for example if\n /// we have `Self: Trait<u32, i32>` and `Trait<T, U>: OtherTrait<U>` we'll get\n /// `Self: OtherTrait<i32>`.\n-pub(super) fn all_super_trait_refs(db: &dyn HirDatabase, trait_ref: TraitRef) -> Vec<TraitRef> {\n-    // FIXME: replace by Chalk's `super_traits`, maybe make this a query\n+pub(super) fn all_super_trait_refs(db: &dyn HirDatabase, trait_ref: TraitRef) -> SuperTraits {\n+    SuperTraits { db, seen: iter::once(trait_ref.trait_id).collect(), stack: vec![trait_ref] }\n+}\n \n-    // we need to take care a bit here to avoid infinite loops in case of cycles\n-    // (i.e. if we have `trait A: B; trait B: A;`)\n-    let mut result = vec![trait_ref];\n-    let mut i = 0;\n-    while i < result.len() {\n-        let t = &result[i];\n-        // yeah this is quadratic, but trait hierarchies should be flat\n-        // enough that this doesn't matter\n-        for tt in direct_super_trait_refs(db, t) {\n-            if !result.iter().any(|tr| tr.trait_id == tt.trait_id) {\n-                result.push(tt);\n-            }\n+pub(super) struct SuperTraits<'a> {\n+    db: &'a dyn HirDatabase,\n+    stack: Vec<TraitRef>,\n+    seen: FxHashSet<ChalkTraitId>,\n+}\n+\n+impl<'a> SuperTraits<'a> {\n+    fn elaborate(&mut self, trait_ref: &TraitRef) {\n+        let mut trait_refs = direct_super_trait_refs(self.db, trait_ref);\n+        trait_refs.retain(|tr| !self.seen.contains(&tr.trait_id));\n+        self.stack.extend(trait_refs);\n+    }\n+}\n+\n+impl<'a> Iterator for SuperTraits<'a> {\n+    type Item = TraitRef;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if let Some(next) = self.stack.pop() {\n+            self.elaborate(&next);\n+            Some(next)\n+        } else {\n+            None\n         }\n-        i += 1;\n     }\n-    result\n }\n \n pub(super) fn associated_type_by_name_including_super_traits(\n     db: &dyn HirDatabase,\n     trait_ref: TraitRef,\n     name: &Name,\n ) -> Option<(TraitRef, TypeAliasId)> {\n-    all_super_trait_refs(db, trait_ref).into_iter().find_map(|t| {\n+    all_super_trait_refs(db, trait_ref).find_map(|t| {\n         let assoc_type = db.trait_data(t.hir_trait_id()).associated_type_by_name(name)?;\n         Some((t, assoc_type))\n     })"}]}