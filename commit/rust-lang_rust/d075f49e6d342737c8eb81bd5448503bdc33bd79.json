{"sha": "d075f49e6d342737c8eb81bd5448503bdc33bd79", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwNzVmNDllNmQzNDI3MzdjOGViODFiZDU0NDg1MDNiZGMzM2JkNzk=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-04-13T15:20:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-13T15:20:17Z"}, "message": "Merge #3960\n\n3960: ellipsis in tuple patterns r=JoshMcguigan a=JoshMcguigan\n\nThis PR lowers ellipsis in tuple patterns. It fixes a bug in the way ellipsis were previously lowered (by replacing the ellipsis with a single `Pat::Wild` no matter how many items the `..` was taking the place of).\r\n\r\nIt also uses this new information to properly handle `..` in tuple struct patterns when perform match statement exhaustiveness checks.\r\n\r\nWhile this PR provides the building blocks for match statement exhaustiveness checks for tuples, there are some additional challenges there, so that is still unimplemented (unlike tuple structs).\n\nCo-authored-by: Josh Mcguigan <joshmcg88@gmail.com>", "tree": {"sha": "2616cbd7be4a0b8f29a6a6d8f977f8817cc24ce9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2616cbd7be4a0b8f29a6a6d8f977f8817cc24ce9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d075f49e6d342737c8eb81bd5448503bdc33bd79", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJelIMxCRBK7hj4Ov3rIwAAdHIIABE1Fa3eoTEEBhw7QbIweMLQ\nUrJdOsSh+SmUz9q2COOthw9qg1uULFJq7azaW3AC4I4Do2ZMWps8eypRkzSmkll8\n0PFHA+D5NIsSezIXk7oHo0qgjurjQq4tJuqO6EAoU9W43d/tsCFxZDa8uKCTtpRG\nZvWE9yzhz+CZTtvtUXp5TzExJECMi21+4wckybrihGyba6cyUOnccIYd1gJqNsX1\nhHXOClDVTXztteRnb8CLWFKZjDDE61uaqtNAnjURay/po813wMDnv36vpzTrwa0a\nyXZ9iqEwoaIByKyS0JUAsd/Hn+O8rpDfoX+GxNReCAzl472l0BZ8/8w4CnYkwKE=\n=EWA0\n-----END PGP SIGNATURE-----\n", "payload": "tree 2616cbd7be4a0b8f29a6a6d8f977f8817cc24ce9\nparent c388130f5ffbcbe7d3131213a24d12d02f769b87\nparent ee822d19b7662a9055bc6693c4c40d8dcf752ea1\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1586791217 +0000\ncommitter GitHub <noreply@github.com> 1586791217 +0000\n\nMerge #3960\n\n3960: ellipsis in tuple patterns r=JoshMcguigan a=JoshMcguigan\n\nThis PR lowers ellipsis in tuple patterns. It fixes a bug in the way ellipsis were previously lowered (by replacing the ellipsis with a single `Pat::Wild` no matter how many items the `..` was taking the place of).\r\n\r\nIt also uses this new information to properly handle `..` in tuple struct patterns when perform match statement exhaustiveness checks.\r\n\r\nWhile this PR provides the building blocks for match statement exhaustiveness checks for tuples, there are some additional challenges there, so that is still unimplemented (unlike tuple structs).\n\nCo-authored-by: Josh Mcguigan <joshmcg88@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d075f49e6d342737c8eb81bd5448503bdc33bd79", "html_url": "https://github.com/rust-lang/rust/commit/d075f49e6d342737c8eb81bd5448503bdc33bd79", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d075f49e6d342737c8eb81bd5448503bdc33bd79/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c388130f5ffbcbe7d3131213a24d12d02f769b87", "url": "https://api.github.com/repos/rust-lang/rust/commits/c388130f5ffbcbe7d3131213a24d12d02f769b87", "html_url": "https://github.com/rust-lang/rust/commit/c388130f5ffbcbe7d3131213a24d12d02f769b87"}, {"sha": "ee822d19b7662a9055bc6693c4c40d8dcf752ea1", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee822d19b7662a9055bc6693c4c40d8dcf752ea1", "html_url": "https://github.com/rust-lang/rust/commit/ee822d19b7662a9055bc6693c4c40d8dcf752ea1"}], "stats": {"total": 199, "additions": 141, "deletions": 58}, "files": [{"sha": "79abe55ce6065227463376240b8f5673941d8092", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d075f49e6d342737c8eb81bd5448503bdc33bd79/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d075f49e6d342737c8eb81bd5448503bdc33bd79/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=d075f49e6d342737c8eb81bd5448503bdc33bd79", "patch": "@@ -33,6 +33,7 @@ use crate::{\n };\n \n use super::{ExprSource, PatSource};\n+use ast::AstChildren;\n \n pub(super) fn lower(\n     db: &dyn DefDatabase,\n@@ -598,8 +599,8 @@ impl ExprCollector<'_> {\n             }\n             ast::Pat::TupleStructPat(p) => {\n                 let path = p.path().and_then(|path| self.expander.parse_path(path));\n-                let args = p.args().map(|p| self.collect_pat(p)).collect();\n-                Pat::TupleStruct { path, args }\n+                let (args, ellipsis) = self.collect_tuple_pat(p.args());\n+                Pat::TupleStruct { path, args, ellipsis }\n             }\n             ast::Pat::RefPat(p) => {\n                 let pat = self.collect_pat_opt(p.pat());\n@@ -616,10 +617,10 @@ impl ExprCollector<'_> {\n             }\n             ast::Pat::ParenPat(p) => return self.collect_pat_opt(p.pat()),\n             ast::Pat::TuplePat(p) => {\n-                let args = p.args().map(|p| self.collect_pat(p)).collect();\n-                Pat::Tuple(args)\n+                let (args, ellipsis) = self.collect_tuple_pat(p.args());\n+                Pat::Tuple { args, ellipsis }\n             }\n-            ast::Pat::PlaceholderPat(_) | ast::Pat::DotDotPat(_) => Pat::Wild,\n+            ast::Pat::PlaceholderPat(_) => Pat::Wild,\n             ast::Pat::RecordPat(p) => {\n                 let path = p.path().and_then(|path| self.expander.parse_path(path));\n                 let record_field_pat_list =\n@@ -665,6 +666,9 @@ impl ExprCollector<'_> {\n                     Pat::Missing\n                 }\n             }\n+            ast::Pat::DotDotPat(_) => unreachable!(\n+                \"`DotDotPat` requires special handling and should not be mapped to a Pat.\"\n+            ),\n             // FIXME: implement\n             ast::Pat::BoxPat(_) | ast::Pat::RangePat(_) | ast::Pat::MacroPat(_) => Pat::Missing,\n         };\n@@ -679,6 +683,19 @@ impl ExprCollector<'_> {\n             self.missing_pat()\n         }\n     }\n+\n+    fn collect_tuple_pat(&mut self, args: AstChildren<ast::Pat>) -> (Vec<PatId>, Option<usize>) {\n+        // Find the location of the `..`, if there is one. Note that we do not\n+        // consider the possiblity of there being multiple `..` here.\n+        let ellipsis = args.clone().position(|p| matches!(p, ast::Pat::DotDotPat(_)));\n+        // We want to skip the `..` pattern here, since we account for it above.\n+        let args = args\n+            .filter(|p| !matches!(p, ast::Pat::DotDotPat(_)))\n+            .map(|p| self.collect_pat(p))\n+            .collect();\n+\n+        (args, ellipsis)\n+    }\n }\n \n impl From<ast::BinOp> for BinaryOp {"}, {"sha": "a0cdad529b3fb8404e4216df17ab6cb353a912cd", "filename": "crates/ra_hir_def/src/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d075f49e6d342737c8eb81bd5448503bdc33bd79/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d075f49e6d342737c8eb81bd5448503bdc33bd79/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs?ref=d075f49e6d342737c8eb81bd5448503bdc33bd79", "patch": "@@ -374,15 +374,15 @@ pub struct RecordFieldPat {\n pub enum Pat {\n     Missing,\n     Wild,\n-    Tuple(Vec<PatId>),\n+    Tuple { args: Vec<PatId>, ellipsis: Option<usize> },\n     Or(Vec<PatId>),\n     Record { path: Option<Path>, args: Vec<RecordFieldPat>, ellipsis: bool },\n     Range { start: ExprId, end: ExprId },\n     Slice { prefix: Vec<PatId>, slice: Option<PatId>, suffix: Vec<PatId> },\n     Path(Path),\n     Lit(ExprId),\n     Bind { mode: BindingAnnotation, name: Name, subpat: Option<PatId> },\n-    TupleStruct { path: Option<Path>, args: Vec<PatId> },\n+    TupleStruct { path: Option<Path>, args: Vec<PatId>, ellipsis: Option<usize> },\n     Ref { pat: PatId, mutability: Mutability },\n }\n \n@@ -393,7 +393,7 @@ impl Pat {\n             Pat::Bind { subpat, .. } => {\n                 subpat.iter().copied().for_each(f);\n             }\n-            Pat::Or(args) | Pat::Tuple(args) | Pat::TupleStruct { args, .. } => {\n+            Pat::Or(args) | Pat::Tuple { args, .. } | Pat::TupleStruct { args, .. } => {\n                 args.iter().copied().for_each(f);\n             }\n             Pat::Ref { pat, .. } => f(*pat),"}, {"sha": "a64be9848ef1cebebdf1cd695e888812d4467f7d", "filename": "crates/ra_hir_ty/src/_match.rs", "status": "modified", "additions": 113, "deletions": 47, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/d075f49e6d342737c8eb81bd5448503bdc33bd79/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d075f49e6d342737c8eb81bd5448503bdc33bd79/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2F_match.rs?ref=d075f49e6d342737c8eb81bd5448503bdc33bd79", "patch": "@@ -289,7 +289,7 @@ impl PatStack {\n         Self::from_slice(&self.0[1..])\n     }\n \n-    fn replace_head_with(&self, pat_ids: &[PatId]) -> PatStack {\n+    fn replace_head_with<T: Into<PatIdOrWild> + Copy>(&self, pat_ids: &[T]) -> PatStack {\n         let mut patterns: PatStackInner = smallvec![];\n         for pat in pat_ids {\n             patterns.push((*pat).into());\n@@ -320,12 +320,14 @@ impl PatStack {\n         constructor: &Constructor,\n     ) -> MatchCheckResult<Option<PatStack>> {\n         let result = match (self.head().as_pat(cx), constructor) {\n-            (Pat::Tuple(ref pat_ids), Constructor::Tuple { arity }) => {\n-                debug_assert_eq!(\n-                    pat_ids.len(),\n-                    *arity,\n-                    \"we type check before calling this code, so we should never hit this case\",\n-                );\n+            (Pat::Tuple { args: ref pat_ids, ellipsis }, Constructor::Tuple { arity: _ }) => {\n+                if ellipsis.is_some() {\n+                    // If there are ellipsis here, we should add the correct number of\n+                    // Pat::Wild patterns to `pat_ids`. We should be able to use the\n+                    // constructors arity for this, but at the time of writing we aren't\n+                    // correctly calculating this arity when ellipsis are present.\n+                    return Err(MatchCheckErr::NotImplemented);\n+                }\n \n                 Some(self.replace_head_with(pat_ids))\n             }\n@@ -351,19 +353,47 @@ impl PatStack {\n                     Some(self.to_tail())\n                 }\n             }\n-            (Pat::TupleStruct { args: ref pat_ids, .. }, Constructor::Enum(enum_constructor)) => {\n+            (\n+                Pat::TupleStruct { args: ref pat_ids, ellipsis, .. },\n+                Constructor::Enum(enum_constructor),\n+            ) => {\n                 let pat_id = self.head().as_id().expect(\"we know this isn't a wild\");\n                 if !enum_variant_matches(cx, pat_id, *enum_constructor) {\n                     None\n                 } else {\n-                    // If the enum variant matches, then we need to confirm\n-                    // that the number of patterns aligns with the expected\n-                    // number of patterns for that enum variant.\n-                    if pat_ids.len() != constructor.arity(cx)? {\n-                        return Err(MatchCheckErr::MalformedMatchArm);\n+                    let constructor_arity = constructor.arity(cx)?;\n+                    if let Some(ellipsis_position) = ellipsis {\n+                        // If there are ellipsis in the pattern, the ellipsis must take the place\n+                        // of at least one sub-pattern, so `pat_ids` should be smaller than the\n+                        // constructor arity.\n+                        if pat_ids.len() < constructor_arity {\n+                            let mut new_patterns: Vec<PatIdOrWild> = vec![];\n+\n+                            for pat_id in &pat_ids[0..ellipsis_position] {\n+                                new_patterns.push((*pat_id).into());\n+                            }\n+\n+                            for _ in 0..(constructor_arity - pat_ids.len()) {\n+                                new_patterns.push(PatIdOrWild::Wild);\n+                            }\n+\n+                            for pat_id in &pat_ids[ellipsis_position..pat_ids.len()] {\n+                                new_patterns.push((*pat_id).into());\n+                            }\n+\n+                            Some(self.replace_head_with(&new_patterns))\n+                        } else {\n+                            return Err(MatchCheckErr::MalformedMatchArm);\n+                        }\n+                    } else {\n+                        // If there is no ellipsis in the tuple pattern, the number\n+                        // of patterns must equal the constructor arity.\n+                        if pat_ids.len() == constructor_arity {\n+                            Some(self.replace_head_with(pat_ids))\n+                        } else {\n+                            return Err(MatchCheckErr::MalformedMatchArm);\n+                        }\n                     }\n-\n-                    Some(self.replace_head_with(pat_ids))\n                 }\n             }\n             (Pat::Or(_), _) => return Err(MatchCheckErr::NotImplemented),\n@@ -644,7 +674,11 @@ impl Constructor {\n fn pat_constructor(cx: &MatchCheckCtx, pat: PatIdOrWild) -> MatchCheckResult<Option<Constructor>> {\n     let res = match pat.as_pat(cx) {\n         Pat::Wild => None,\n-        Pat::Tuple(pats) => Some(Constructor::Tuple { arity: pats.len() }),\n+        // FIXME somehow create the Tuple constructor with the proper arity. If there are\n+        // ellipsis, the arity is not equal to the number of patterns.\n+        Pat::Tuple { args: pats, ellipsis } if ellipsis.is_none() => {\n+            Some(Constructor::Tuple { arity: pats.len() })\n+        }\n         Pat::Lit(lit_expr) => match cx.body.exprs[lit_expr] {\n             Expr::Literal(Literal::Bool(val)) => Some(Constructor::Bool(val)),\n             _ => return Err(MatchCheckErr::NotImplemented),\n@@ -1506,6 +1540,67 @@ mod tests {\n         check_no_diagnostic(content);\n     }\n \n+    #[test]\n+    fn enum_tuple_partial_ellipsis_2_no_diagnostic() {\n+        let content = r\"\n+            enum Either {\n+                A(bool, bool, bool, bool),\n+                B,\n+            }\n+            fn test_fn() {\n+                match Either::B {\n+                    Either::A(true, .., true) => {},\n+                    Either::A(true, .., false) => {},\n+                    Either::A(.., true) => {},\n+                    Either::A(.., false) => {},\n+                    Either::B => {},\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_tuple_partial_ellipsis_missing_arm() {\n+        let content = r\"\n+            enum Either {\n+                A(bool, bool, bool, bool),\n+                B,\n+            }\n+            fn test_fn() {\n+                match Either::B {\n+                    Either::A(true, .., true) => {},\n+                    Either::A(true, .., false) => {},\n+                    Either::A(false, .., false) => {},\n+                    Either::B => {},\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_tuple_partial_ellipsis_2_missing_arm() {\n+        let content = r\"\n+            enum Either {\n+                A(bool, bool, bool, bool),\n+                B,\n+            }\n+            fn test_fn() {\n+                match Either::B {\n+                    Either::A(true, .., true) => {},\n+                    Either::A(true, .., false) => {},\n+                    Either::A(.., true) => {},\n+                    Either::B => {},\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic(content);\n+    }\n+\n     #[test]\n     fn enum_tuple_ellipsis_no_diagnostic() {\n         let content = r\"\n@@ -1645,11 +1740,7 @@ mod false_negatives {\n         \";\n \n         // This is a false negative.\n-        // The `..` pattern is currently lowered to a single `Pat::Wild`\n-        // no matter how many fields the `..` pattern is covering. This\n-        // causes the match arm in this test not to type check against\n-        // the match expression, which causes this diagnostic not to\n-        // fire.\n+        // We don't currently handle tuple patterns with ellipsis.\n         check_no_diagnostic(content);\n     }\n \n@@ -1664,32 +1755,7 @@ mod false_negatives {\n         \";\n \n         // This is a false negative.\n-        // See comments on `tuple_of_bools_with_ellipsis_at_end_missing_arm`.\n-        check_no_diagnostic(content);\n-    }\n-\n-    #[test]\n-    fn enum_tuple_partial_ellipsis_missing_arm() {\n-        let content = r\"\n-            enum Either {\n-                A(bool, bool, bool, bool),\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::B {\n-                    Either::A(true, .., true) => {},\n-                    Either::A(true, .., false) => {},\n-                    Either::A(false, .., false) => {},\n-                    Either::B => {},\n-                }\n-            }\n-        \";\n-\n-        // This is a false negative.\n-        // The `..` pattern is currently lowered to a single `Pat::Wild`\n-        // no matter how many fields the `..` pattern is covering. This\n-        // causes us to return a `MatchCheckErr::MalformedMatchArm` in\n-        // `Pat::specialize_constructor`.\n+        // We don't currently handle tuple patterns with ellipsis.\n         check_no_diagnostic(content);\n     }\n }"}, {"sha": "8ec4d4ace084e7c805061bc6ae21235b1b5f1c67", "filename": "crates/ra_hir_ty/src/infer/pat.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d075f49e6d342737c8eb81bd5448503bdc33bd79/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d075f49e6d342737c8eb81bd5448503bdc33bd79/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs?ref=d075f49e6d342737c8eb81bd5448503bdc33bd79", "patch": "@@ -85,7 +85,7 @@ impl<'a> InferenceContext<'a> {\n         let body = Arc::clone(&self.body); // avoid borrow checker problem\n \n         let is_non_ref_pat = match &body[pat] {\n-            Pat::Tuple(..)\n+            Pat::Tuple { .. }\n             | Pat::Or(..)\n             | Pat::TupleStruct { .. }\n             | Pat::Record { .. }\n@@ -116,7 +116,7 @@ impl<'a> InferenceContext<'a> {\n         let expected = expected;\n \n         let ty = match &body[pat] {\n-            Pat::Tuple(ref args) => {\n+            Pat::Tuple { ref args, .. } => {\n                 let expectations = match expected.as_tuple() {\n                     Some(parameters) => &*parameters.0,\n                     _ => &[],\n@@ -155,7 +155,7 @@ impl<'a> InferenceContext<'a> {\n                 let subty = self.infer_pat(*pat, expectation, default_bm);\n                 Ty::apply_one(TypeCtor::Ref(*mutability), subty)\n             }\n-            Pat::TupleStruct { path: p, args: subpats } => {\n+            Pat::TupleStruct { path: p, args: subpats, .. } => {\n                 self.infer_tuple_struct_pat(p.as_ref(), subpats, expected, default_bm, pat)\n             }\n             Pat::Record { path: p, args: fields, ellipsis: _ } => {"}]}