{"sha": "5d403c0b859259499886d3ee3d4b4b4dfaab6ae2", "node_id": "C_kwDOAAsO6NoAKDVkNDAzYzBiODU5MjU5NDk5ODg2ZDNlZTNkNGI0YjRkZmFhYjZhZTI", "commit": {"author": {"name": "J-ZhengLi", "email": "lizheng135@huawei.com", "date": "2022-04-16T08:57:06Z"}, "committer": {"name": "Philipp Krones", "email": "hello@philkrones.com", "date": "2022-08-21T08:24:27Z"}, "message": "allow check for `match` in lint [`option_if_let_else`]\nand add test case for `Result`", "tree": {"sha": "abc2f1df49d17ffaabb7e776e164b2438b720a38", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/abc2f1df49d17ffaabb7e776e164b2438b720a38"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d403c0b859259499886d3ee3d4b4b4dfaab6ae2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEij1UXJ/PQTcb99vTHKDfKvWdaKUFAmMB67sACgkQHKDfKvWd\naKWEEw//Vo2GG3vT+Xfgh5fHvttYIr/GN6yF7hIkdtwtslvaqcJhTiBo+IQheHHP\nUCEnm2sXNYT2EN3g8JTLXuTU0jvIMVDnpzdSZLGhxPIRQFr+4ipLyuwYyPetw0RV\nvg9epv8/VqBInh30X8BxcmD/x6jCNV0goahvVkGBlN19wJx06yKyHkOlosuccp6P\nyRuEipqMHspnasw2KaVLspHZRy8qvCTZUbpdYfnAdosN8wDZ79hYrwM3aKB8fdcM\nzQ8RXabOxHyzuTu/YmdTTMseSfcXi7OI8Bd5fpD1yroZztWVg4AUaEUjp/HQqtBJ\nCzSux7Vs+H553Hn1jm311p+2ILTIMALGOQTSY+ShiImf/F/K+GWnEBlqZT1JbrrW\nZgjWdO+hbzLCpUXv3sGS9IcjD0B1GlSAUqOMWdJMnLSqIJnLoPKMB1yuLvn7nO5V\no/XWFW0a8EOdI59sh6Y1KcyPJEYXjJ2WY1HqeO/bdpg1GV6J7t6QZbj5mqoru3Nw\n+WIs7QU8bDdo9hnbLbaEhAEx43Sx/9k5bRXR1yj/CohBR5KkGaokxnIWRB6gtebx\n5Sb9wOwpAjZ9EHGZTcDFvWxpNu3Ezn+0jPmru5jTPwQI5VnjiuP7my91/4TRq4ZA\nyLTjsGxSn6MyS1ILDTijeheCFBhUjKKWu2HF3deOP5T/S6pgue0=\n=3jlg\n-----END PGP SIGNATURE-----", "payload": "tree abc2f1df49d17ffaabb7e776e164b2438b720a38\nparent 41309df8efe99848a79782ae98ad73638668381c\nauthor J-ZhengLi <lizheng135@huawei.com> 1650099426 +0800\ncommitter Philipp Krones <hello@philkrones.com> 1661070267 +0200\n\nallow check for `match` in lint [`option_if_let_else`]\nand add test case for `Result`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d403c0b859259499886d3ee3d4b4b4dfaab6ae2", "html_url": "https://github.com/rust-lang/rust/commit/5d403c0b859259499886d3ee3d4b4b4dfaab6ae2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d403c0b859259499886d3ee3d4b4b4dfaab6ae2/comments", "author": {"login": "J-ZhengLi", "id": 32276130, "node_id": "MDQ6VXNlcjMyMjc2MTMw", "avatar_url": "https://avatars.githubusercontent.com/u/32276130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/J-ZhengLi", "html_url": "https://github.com/J-ZhengLi", "followers_url": "https://api.github.com/users/J-ZhengLi/followers", "following_url": "https://api.github.com/users/J-ZhengLi/following{/other_user}", "gists_url": "https://api.github.com/users/J-ZhengLi/gists{/gist_id}", "starred_url": "https://api.github.com/users/J-ZhengLi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/J-ZhengLi/subscriptions", "organizations_url": "https://api.github.com/users/J-ZhengLi/orgs", "repos_url": "https://api.github.com/users/J-ZhengLi/repos", "events_url": "https://api.github.com/users/J-ZhengLi/events{/privacy}", "received_events_url": "https://api.github.com/users/J-ZhengLi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41309df8efe99848a79782ae98ad73638668381c", "url": "https://api.github.com/repos/rust-lang/rust/commits/41309df8efe99848a79782ae98ad73638668381c", "html_url": "https://github.com/rust-lang/rust/commit/41309df8efe99848a79782ae98ad73638668381c"}], "stats": {"total": 228, "additions": 183, "deletions": 45}, "files": [{"sha": "b99966c5a5df3b3e8445b376016ec1f1fd610292", "filename": "clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 126, "deletions": 44, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/5d403c0b859259499886d3ee3d4b4b4dfaab6ae2/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d403c0b859259499886d3ee3d4b4b4dfaab6ae2/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=5d403c0b859259499886d3ee3d4b4b4dfaab6ae2", "patch": "@@ -7,15 +7,18 @@ use clippy_utils::{\n };\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::LangItem::OptionSome;\n-use rustc_hir::{def::Res, BindingAnnotation, Expr, ExprKind, Mutability, PatKind, Path, QPath, UnOp};\n+use rustc_hir::LangItem::{OptionNone, OptionSome};\n+use rustc_hir::{\n+    def::Res, Arm, BindingAnnotation, Expr, ExprKind, MatchSource, Mutability, Pat, PatKind, Path, QPath, UnOp,\n+};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// Lints usage of `if let Some(v) = ... { y } else { x }` which is more\n+    /// Lints usage of `if let Some(v) = ... { y } else { x }` and\n+    /// `match .. { Some(v) => y, None/_ => x }` which are more\n     /// idiomatically done with `Option::map_or` (if the else bit is a pure\n     /// expression) or `Option::map_or_else` (if the else bit is an impure\n     /// expression).\n@@ -39,6 +42,10 @@ declare_clippy_lint! {\n     /// } else {\n     ///     5\n     /// };\n+    /// let _ = match optional {\n+    ///     Some(val) => val + 1,\n+    ///     None => 5\n+    /// };\n     /// let _ = if let Some(foo) = optional {\n     ///     foo\n     /// } else {\n@@ -53,6 +60,7 @@ declare_clippy_lint! {\n     /// # let optional: Option<u32> = Some(0);\n     /// # fn do_complicated_function() -> u32 { 5 };\n     /// let _ = optional.map_or(5, |foo| foo);\n+    /// let _ = optional.map_or(5, |val| val + 1);\n     /// let _ = optional.map_or_else(||{\n     ///     let y = do_complicated_function();\n     ///     y*y\n@@ -76,9 +84,21 @@ fn is_result_ok(cx: &LateContext<'_>, expr: &'_ Expr<'_>) -> bool {\n     }\n }\n \n-/// A struct containing information about occurrences of the\n-/// `if let Some(..) = .. else` construct that this lint detects.\n-struct OptionIfLetElseOccurrence {\n+/// A struct containing information about occurrences of construct that this lint detects\n+///\n+/// Such as:\n+///\n+/// ```ignore\n+/// if let Some(..) = {..} else {..}\n+/// ```\n+/// or\n+/// ```ignore\n+/// match x {\n+///     Some(..) => {..},\n+///     None/_ => {..}\n+/// }\n+/// ```\n+struct OptionOccurence {\n     option: String,\n     method_sugg: String,\n     some_expr: String,\n@@ -99,43 +119,39 @@ fn format_option_in_sugg(cx: &LateContext<'_>, cond_expr: &Expr<'_>, as_ref: boo\n     )\n }\n \n-/// If this expression is the option if let/else construct we're detecting, then\n-/// this function returns an `OptionIfLetElseOccurrence` struct with details if\n-/// this construct is found, or None if this construct is not found.\n-fn detect_option_if_let_else<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) -> Option<OptionIfLetElseOccurrence> {\n+fn try_get_option_occurence<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &Pat<'tcx>,\n+    expr: &Expr<'_>,\n+    if_then: &'tcx Expr<'_>,\n+    if_else: &'tcx Expr<'_>,\n+) -> Option<OptionOccurence> {\n+    let cond_expr = match expr.kind {\n+        ExprKind::Unary(UnOp::Deref, inner_expr) | ExprKind::AddrOf(_, _, inner_expr) => inner_expr,\n+        _ => expr,\n+    };\n     if_chain! {\n-        if !expr.span.from_expansion(); // Don't lint macros, because it behaves weirdly\n-        if !in_constant(cx, expr.hir_id);\n-        if let Some(higher::IfLet { let_pat, let_expr, if_then, if_else: Some(if_else) })\n-            = higher::IfLet::hir(cx, expr);\n-        if !is_else_clause(cx.tcx, expr);\n-        if !is_result_ok(cx, let_expr); // Don't lint on Result::ok because a different lint does it already\n-        if let PatKind::TupleStruct(struct_qpath, [inner_pat], _) = &let_pat.kind;\n-        if is_lang_ctor(cx, struct_qpath, OptionSome);\n-        if let PatKind::Binding(bind_annotation, _, id, None) = &inner_pat.kind;\n+        if !is_result_ok(cx, cond_expr); // Don't lint on Result::ok because a different lint does it already\n+        let inner_pat = try_get_inner_pat(cx, pat)?;\n+        if let PatKind::Binding(bind_annotation, _, id, None) = inner_pat.kind;\n         if let Some(some_captures) = can_move_expr_to_closure(cx, if_then);\n         if let Some(none_captures) = can_move_expr_to_closure(cx, if_else);\n         if some_captures\n             .iter()\n             .filter_map(|(id, &c)| none_captures.get(id).map(|&c2| (c, c2)))\n             .all(|(x, y)| x.is_imm_ref() && y.is_imm_ref());\n-\n         then {\n-            let capture_mut = if bind_annotation == &BindingAnnotation::Mutable { \"mut \" } else { \"\" };\n+            let capture_mut = if bind_annotation == BindingAnnotation::Mutable { \"mut \" } else { \"\" };\n             let some_body = peel_blocks(if_then);\n             let none_body = peel_blocks(if_else);\n             let method_sugg = if eager_or_lazy::switch_to_eager_eval(cx, none_body) { \"map_or\" } else { \"map_or_else\" };\n             let capture_name = id.name.to_ident_string();\n-            let (as_ref, as_mut) = match &let_expr.kind {\n+            let (as_ref, as_mut) = match &expr.kind {\n                 ExprKind::AddrOf(_, Mutability::Not, _) => (true, false),\n                 ExprKind::AddrOf(_, Mutability::Mut, _) => (false, true),\n-                _ => (bind_annotation == &BindingAnnotation::Ref, bind_annotation == &BindingAnnotation::RefMut),\n-            };\n-            let cond_expr = match let_expr.kind {\n-                // Pointer dereferencing happens automatically, so we can omit it in the suggestion\n-                ExprKind::Unary(UnOp::Deref, expr) | ExprKind::AddrOf(_, _, expr) => expr,\n-                _ => let_expr,\n+                _ => (bind_annotation == BindingAnnotation::Ref, bind_annotation == BindingAnnotation::RefMut),\n             };\n+\n             // Check if captures the closure will need conflict with borrows made in the scrutinee.\n             // TODO: check all the references made in the scrutinee expression. This will require interacting\n             // with the borrow checker. Currently only `<local>[.<field>]*` is checked for.\n@@ -154,33 +170,99 @@ fn detect_option_if_let_else<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) ->\n                     }\n                 }\n             }\n-            Some(OptionIfLetElseOccurrence {\n+\n+            return Some(OptionOccurence {\n                 option: format_option_in_sugg(cx, cond_expr, as_ref, as_mut),\n                 method_sugg: method_sugg.to_string(),\n                 some_expr: format!(\"|{}{}| {}\", capture_mut, capture_name, Sugg::hir_with_macro_callsite(cx, some_body, \"..\")),\n                 none_expr: format!(\"{}{}\", if method_sugg == \"map_or\" { \"\" } else { \"|| \" }, Sugg::hir_with_macro_callsite(cx, none_body, \"..\")),\n-            })\n+            });\n+        }\n+    }\n+\n+    None\n+}\n+\n+fn try_get_inner_pat<'tcx>(cx: &LateContext<'tcx>, pat: &Pat<'tcx>) -> Option<&'tcx Pat<'tcx>> {\n+    if let PatKind::TupleStruct(ref qpath, [inner_pat], ..) = pat.kind {\n+        if is_lang_ctor(cx, qpath, OptionSome) {\n+            return Some(inner_pat);\n+        }\n+    }\n+    None\n+}\n+\n+/// If this expression is the option if let/else construct we're detecting, then\n+/// this function returns an `OptionOccurence` struct with details if\n+/// this construct is found, or None if this construct is not found.\n+fn detect_option_if_let_else<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) -> Option<OptionOccurence> {\n+    if let Some(higher::IfLet {\n+        let_pat,\n+        let_expr,\n+        if_then,\n+        if_else: Some(if_else),\n+    }) = higher::IfLet::hir(cx, expr)\n+    {\n+        if !is_else_clause(cx.tcx, expr) {\n+            return try_get_option_occurence(cx, let_pat, let_expr, if_then, if_else);\n+        }\n+    }\n+    None\n+}\n+\n+fn detect_option_match<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) -> Option<OptionOccurence> {\n+    if let ExprKind::Match(ex, arms, MatchSource::Normal) = expr.kind {\n+        if let Some((let_pat, if_then, if_else)) = try_convert_match(cx, arms) {\n+            return try_get_option_occurence(cx, let_pat, ex, if_then, if_else);\n+        }\n+    }\n+    None\n+}\n+\n+fn try_convert_match<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    arms: &[Arm<'tcx>],\n+) -> Option<(&'tcx Pat<'tcx>, &'tcx Expr<'tcx>, &'tcx Expr<'tcx>)> {\n+    if arms.len() == 2 {\n+        return if is_none_arm(cx, &arms[1]) {\n+            Some((arms[0].pat, arms[0].body, arms[1].body))\n+        } else if is_none_arm(cx, &arms[0]) {\n+            Some((arms[1].pat, arms[1].body, arms[0].body))\n         } else {\n             None\n-        }\n+        };\n+    }\n+    None\n+}\n+\n+fn is_none_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n+    match arm.pat.kind {\n+        PatKind::Path(ref qpath) => is_lang_ctor(cx, qpath, OptionNone),\n+        PatKind::Wild => true,\n+        _ => false,\n     }\n }\n \n impl<'tcx> LateLintPass<'tcx> for OptionIfLetElse {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &Expr<'tcx>) {\n-        if let Some(detection) = detect_option_if_let_else(cx, expr) {\n-            span_lint_and_sugg(\n-                cx,\n-                OPTION_IF_LET_ELSE,\n-                expr.span,\n-                format!(\"use Option::{} instead of an if let/else\", detection.method_sugg).as_str(),\n-                \"try\",\n-                format!(\n-                    \"{}.{}({}, {})\",\n-                    detection.option, detection.method_sugg, detection.none_expr, detection.some_expr,\n-                ),\n-                Applicability::MaybeIncorrect,\n-            );\n+        // Don't lint macros, because it behaves weirdly\n+        // and don't lint constant as well\n+        if !expr.span.from_expansion() && !in_constant(cx, expr.hir_id) {\n+            let detection = detect_option_if_let_else(cx, expr).or_else(|| detect_option_match(cx, expr));\n+            if let Some(det) = detection {\n+                span_lint_and_sugg(\n+                    cx,\n+                    OPTION_IF_LET_ELSE,\n+                    expr.span,\n+                    format!(\"use Option::{} instead of an if let/else\", det.method_sugg).as_str(),\n+                    \"try\",\n+                    format!(\n+                        \"{}.{}({}, {})\",\n+                        det.option, det.method_sugg, det.none_expr, det.some_expr\n+                    ),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n         }\n     }\n }"}, {"sha": "79610a0ea349343d2eb8f3791579a5a281f5ebbd", "filename": "tests/ui/option_if_let_else.fixed", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5d403c0b859259499886d3ee3d4b4b4dfaab6ae2/tests%2Fui%2Foption_if_let_else.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5d403c0b859259499886d3ee3d4b4b4dfaab6ae2/tests%2Fui%2Foption_if_let_else.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_if_let_else.fixed?ref=5d403c0b859259499886d3ee3d4b4b4dfaab6ae2", "patch": "@@ -179,4 +179,19 @@ fn main() {\n \n     let _ = pattern_to_vec(\"hello world\");\n     let _ = complex_subpat();\n+\n+    // issue #8492\n+    let _ = s.map_or(1, |string| string.len());\n+    let _ = Some(10).map_or(5, |a| a + 1);\n+\n+    let res: Result<i32, i32> = Ok(5);\n+    let _ = match res {\n+        Ok(a) => a + 1,\n+        _ => 1,\n+    };\n+    let _ = match res {\n+        Err(_) => 1,\n+        Ok(a) => a + 1,\n+    };\n+    let _ = if let Ok(a) = res { a + 1 } else { 5 };\n }"}, {"sha": "9eeaea12d3bc91e615cb2fac5f3d3b10c0ffd0c9", "filename": "tests/ui/option_if_let_else.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5d403c0b859259499886d3ee3d4b4b4dfaab6ae2/tests%2Fui%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d403c0b859259499886d3ee3d4b4b4dfaab6ae2/tests%2Fui%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_if_let_else.rs?ref=5d403c0b859259499886d3ee3d4b4b4dfaab6ae2", "patch": "@@ -208,4 +208,25 @@ fn main() {\n \n     let _ = pattern_to_vec(\"hello world\");\n     let _ = complex_subpat();\n+\n+    // issue #8492\n+    let _ = match s {\n+        Some(string) => string.len(),\n+        None => 1,\n+    };\n+    let _ = match Some(10) {\n+        Some(a) => a + 1,\n+        None => 5,\n+    };\n+\n+    let res: Result<i32, i32> = Ok(5);\n+    let _ = match res {\n+        Ok(a) => a + 1,\n+        _ => 1,\n+    };\n+    let _ = match res {\n+        Err(_) => 1,\n+        Ok(a) => a + 1,\n+    };\n+    let _ = if let Ok(a) = res { a + 1 } else { 5 };\n }"}, {"sha": "4086b45b7c0c5df9c6d4e7e59d61a6c85b738045", "filename": "tests/ui/option_if_let_else.stderr", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5d403c0b859259499886d3ee3d4b4b4dfaab6ae2/tests%2Fui%2Foption_if_let_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5d403c0b859259499886d3ee3d4b4b4dfaab6ae2/tests%2Fui%2Foption_if_let_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_if_let_else.stderr?ref=5d403c0b859259499886d3ee3d4b4b4dfaab6ae2", "patch": "@@ -206,5 +206,25 @@ LL +         s.len() + x\n LL ~     });\n    |\n \n-error: aborting due to 15 previous errors\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:212:13\n+   |\n+LL |       let _ = match s {\n+   |  _____________^\n+LL | |         Some(string) => string.len(),\n+LL | |         None => 1,\n+LL | |     };\n+   | |_____^ help: try: `s.map_or(1, |string| string.len())`\n+\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:216:13\n+   |\n+LL |       let _ = match Some(10) {\n+   |  _____________^\n+LL | |         Some(a) => a + 1,\n+LL | |         None => 5,\n+LL | |     };\n+   | |_____^ help: try: `Some(10).map_or(5, |a| a + 1)`\n+\n+error: aborting due to 17 previous errors\n "}]}