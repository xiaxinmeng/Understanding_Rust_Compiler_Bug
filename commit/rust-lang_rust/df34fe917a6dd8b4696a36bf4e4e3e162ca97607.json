{"sha": "df34fe917a6dd8b4696a36bf4e4e3e162ca97607", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmMzRmZTkxN2E2ZGQ4YjQ2OTZhMzZiZjRlNGUzZTE2MmNhOTc2MDc=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-01T00:20:36Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-01T00:20:36Z"}, "message": "doc: Trim down the tutorial a little more", "tree": {"sha": "535a92ecad2b188c70f3cd9f0e80e871a5e224b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/535a92ecad2b188c70f3cd9f0e80e871a5e224b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df34fe917a6dd8b4696a36bf4e4e3e162ca97607", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df34fe917a6dd8b4696a36bf4e4e3e162ca97607", "html_url": "https://github.com/rust-lang/rust/commit/df34fe917a6dd8b4696a36bf4e4e3e162ca97607", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df34fe917a6dd8b4696a36bf4e4e3e162ca97607/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9eaaceb9f020faca7e2880fdc94946056c0ce4cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/9eaaceb9f020faca7e2880fdc94946056c0ce4cf", "html_url": "https://github.com/rust-lang/rust/commit/9eaaceb9f020faca7e2880fdc94946056c0ce4cf"}], "stats": {"total": 127, "additions": 55, "deletions": 72}, "files": [{"sha": "a0b2dc71f29c9040ae959845fead2f35f6c132de", "filename": "doc/tutorial.md", "status": "modified", "additions": 55, "deletions": 72, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/df34fe917a6dd8b4696a36bf4e4e3e162ca97607/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/df34fe917a6dd8b4696a36bf4e4e3e162ca97607/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=df34fe917a6dd8b4696a36bf4e4e3e162ca97607", "patch": "@@ -303,14 +303,6 @@ The double-colon (`::`) is used as a module separator, so\n `io::println` means 'the thing named `println` in the module\n named `io`.\n \n-Rust will normally emit warnings about unused variables. These can be\n-suppressed by using a variable name that starts with an underscore.\n-\n-~~~~\n-fn this_warns(x: int) {}\n-fn this_doesnt(_x: int) {}\n-~~~~\n-\n ## Variable declaration\n \n The `let` keyword, as we've seen, introduces a local variable. Local\n@@ -319,11 +311,11 @@ a local variable that can be reassigned.  Global constants can be\n defined with `const`:\n \n ~~~~\n-const repeat: int = 5;\n+const REPEAT: int = 5;\n fn main() {\n     let hi = \"Hi!\";\n     let mut count = 0;\n-    while count < repeat {\n+    while count < REPEAT {\n         io::println(hi);\n         count += 1;\n     }\n@@ -340,28 +332,6 @@ let my_favorite_value: int = my_favorite_value as int;\n \n ## Types\n \n-The `-> bool` in the `is_four` example is the way a function's return\n-type is written. For functions that do not return a meaningful value\n-(these conceptually return nil in Rust), you can optionally say `->\n-()` (`()` is how nil is written), but usually the return annotation is\n-simply left off, as in the `fn main() { ... }` examples we've seen\n-earlier.\n-\n-Every argument to a function must have its type declared (for example,\n-`x: int`). Inside the function, type inference will be able to\n-automatically deduce the type of most locals (generic functions, which\n-we'll come back to later, will occasionally need additional\n-annotation). Locals can be written either with or without a type\n-annotation:\n-\n-~~~~\n-// The type of this vector will be inferred based on its use.\n-let x = [];\n-# vec::map(x, fn&(&&_y:int) -> int { _y });\n-// Explicitly say this is a vector of zero integers.\n-let y: [int * 0] = [];\n-~~~~\n-\n The basic types are written like this:\n \n `()`\n@@ -407,16 +377,16 @@ more detail later on (the `T`s here stand for any other type):\n `@T`, `~T`, `&T`\n   : Pointer types.\n \n-The size of some types can vary when your program runs. Because of this, you\n-don't manipulate them only by pointer, never directly. For instance, you \n-can't refer to a string (`str`); instead you refer to a pointer to a string\n-(`@str`, `~str`, or `&str`). These *dynamically-sized* types const of:\n+Some types can only be manipulated by pointer, never directly. For instance,\n+you cannot refer to a string (`str`); instead you refer to a pointer to a\n+string (`@str`, `~str`, or `&str`). These *dynamically-sized* types consist\n+of:\n \n `fn(arg1: T1, arg2: T2) -> T3`\n   : Function types.\n \n `str`\n-  : String type. A string contains a UTF-8 encoded sequence of characters.\n+  : String type (in UTF-8).\n \n `[T]`\n   : Vector with unknown size (also called a slice).\n@@ -437,6 +407,28 @@ error. Read about [single-variant enums](#single_variant_enum)\n further on if you need to create a type name that's not just a\n synonym.\n \n+## Using types\n+\n+The `-> bool` in the `is_four` example is the way a function's return\n+type is written. For functions that do not return a meaningful value,\n+you can optionally say `-> ()`, but usually the return annotation is simply\n+left off, as in the `fn main() { ... }` examples we've seen earlier.\n+\n+Every argument to a function must have its type declared (for example,\n+`x: int`). Inside the function, type inference will be able to\n+automatically deduce the type of most locals (generic functions, which\n+we'll come back to later, will occasionally need additional\n+annotation). Locals can be written either with or without a type\n+annotation:\n+\n+~~~~\n+// The type of this vector will be inferred based on its use.\n+let x = [];\n+# vec::map(x, fn&(&&_y:int) -> int { _y });\n+// Explicitly say this is a vector of zero integers.\n+let y: [int * 0] = [];\n+~~~~\n+\n ## Numeric literals\n \n Integers can be written in decimal (`144`), hexadecimal (`0x90`), and\n@@ -478,20 +470,20 @@ between double quotes (`\"hello\"`). Rust strings may contain newlines.\n \n ## Operators\n \n-Rust's set of operators contains very few surprises. Binary arithmetic\n-is done with `*`, `/`, `%`, `+`, and `-` (multiply, divide, remainder,\n-plus, minus). `-` is also a unary prefix operator that does negation. As in C,\n-the bit operators `>>`, `<<`, `&`, `|`, and `^` are supported.\n+Rust's set of operators contains very few surprises. Arithmetic is done with\n+`*`, `/`, `%`, `+`, and `-` (multiply, divide, remainder, plus, minus). `-` is\n+also a unary prefix operator that does negation. As in C, the bit operators\n+`>>`, `<<`, `&`, `|`, and `^` are also supported.\n \n-Note that, if applied an integer value, `!` inverts all the bits.\n+Note that, if applied to an integer value, `!` flips all the bits (like `~` in\n+C).\n \n The comparison operators are the traditional `==`, `!=`, `<`, `>`,\n `<=`, and `>=`. Short-circuiting (lazy) boolean operators are written\n `&&` (and) and `||` (or).\n \n-For type casting, Rust uses the binary `as` operator, which has high\n-precedence, just lower than multiplication and division.  It takes an\n-expression on the left side, and a type on the right side, and will,\n+For type casting, Rust uses the binary `as` operator.  It takes an\n+expression on the left side and a type on the right side and will,\n if a meaningful conversion exists, convert the result of the\n expression to the given type.\n \n@@ -508,11 +500,12 @@ more likely to be what you expect (unless you are a C veteran).\n \n ## Syntax extensions\n \n-*Syntax extensions* are special syntax that is not built into the language,\n-but are instead provided by the libraries. To make it clear when a syntax\n-extension is being used, their names all end with `!`. The standard library\n-defines a few syntax extensions. The most useful one is `fmt!`, a\n-`sprintf`-style text formatter that is expanded at compile time.\n+*Syntax extensions* are special forms that are not built into the language,\n+but are instead provided by the libraries. To make it clear to the reader when\n+a syntax extension is being used, the names of all syntax extensions end with\n+`!`. The standard library defines a few syntax extensions, the most useful of\n+which is `fmt!`, a `sprintf`-style text formatter that is expanded at compile\n+time.\n \n ~~~~\n io::println(fmt!(\"%s is %d\", ~\"the answer\", 42));\n@@ -524,7 +517,8 @@ don't match the types of the arguments.\n \n [pf]: http://en.cppreference.com/w/cpp/io/c/fprintf\n \n-You can define your own syntax extensions via macros.\n+You can define your own syntax extensions with the macro system, which is out\n+of scope of this tutorial.\n \n # Control structures\n \n@@ -581,8 +575,8 @@ construct when it is finished.\n The part to the left of the arrow `=>` is called the *pattern*. Literals are\n valid patterns and will match only their own value. The pipe operator\n (`|`) can be used to assign multiple patterns to a single arm. Ranges\n-of numeric literal patterns can be expressed with `..`. The underscore\n-(`_`) is a wildcard pattern that matches everything.\n+of numeric literal patterns can be expressed with two dots, as in `M..N`. The\n+underscore (`_`) is a wildcard pattern that matches everything.\n \n The patterns in an match arm are followed by a fat arrow, `=>`, then an\n expression to evaluate. Each case is separated by commas. It's often\n@@ -601,10 +595,9 @@ match my_number {\n }\n ~~~\n \n-If the arm with the wildcard pattern was left off in the above\n-example, the typechecker would reject it at compile time. `match`\n-constructs must be exhaustive: they must have an arm covering every\n-possible case.\n+`match` constructs must be *exhaustive*: they must have an arm covering every\n+possible case. For example, if the arm with the wildcard pattern was left off\n+in the above example, the typechecker would reject it.\n \n A powerful application of pattern matching is *destructuring*, where\n you use the matching to get at the contents of data types. Remember\n@@ -632,11 +625,11 @@ an expression of type `bool` that determines, after the pattern is\n found to match, whether the arm is taken or not. The variables bound\n by the pattern are available in this guard expression.\n \n-## Destructuring let\n+## Let\n \n-To a limited extent, it is possible to use destructuring patterns when\n-declaring a variable with `let`. For example, you can say this to\n-extract the fields from a tuple:\n+You've already seen simple `let` bindings. `let` is also a little fancier: it\n+is possible to use destructuring patterns in it. For example, you can say this\n+to extract the fields from a tuple:\n \n ~~~~\n # fn get_tuple_of_two_ints() -> (int, int) { (1, 1) }\n@@ -646,7 +639,7 @@ let (a, b) = get_tuple_of_two_ints();\n This will introduce two new variables, `a` and `b`, bound to the\n content of the tuple.\n \n-You may only use irrefutable patterns\u2014patterns that can never fail to\n+You may only use *irrefutable* patterns\u2014patterns that can never fail to\n match\u2014in let bindings. Other types of patterns, such as literals, are\n not allowed.\n \n@@ -736,16 +729,6 @@ fn do_nothing_the_hard_way() -> () { return (); }\n fn do_nothing_the_easy_way() { }\n ~~~~\n \n-Some functions (such as the C function `exit`) never return normally.\n-In Rust, these are annotated with the pseudo-return type '`!`':\n-\n-~~~~\n-fn dead_end() -> ! { fail }\n-~~~~\n-\n-Using `!` in your code instead of making up a return type helps the compiler\n-avoid spurious error messages.\n-\n # Basic datatypes\n \n The core datatypes of Rust are structs, enums (tagged unions, algebraic data"}]}