{"sha": "257b351ad17564d6691342d6db22c46392bfad8b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1N2IzNTFhZDE3NTY0ZDY2OTEzNDJkNmRiMjJjNDYzOTJiZmFkOGI=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-07-15T08:56:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-15T08:56:42Z"}, "message": "Rollup merge of #34733 - izgzhen:alloc-arc-doc-improve, r=steveklabnik\n\nImprove arc doc, fixing #32905\n\nAs issue #32905 detailed, I moved part of the module doc to the struct doc, and fixed some small places in the `alloc::arc`.", "tree": {"sha": "73a9c0cee10255cbd5ed31e6875153fc2cbda7a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/73a9c0cee10255cbd5ed31e6875153fc2cbda7a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/257b351ad17564d6691342d6db22c46392bfad8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/257b351ad17564d6691342d6db22c46392bfad8b", "html_url": "https://github.com/rust-lang/rust/commit/257b351ad17564d6691342d6db22c46392bfad8b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/257b351ad17564d6691342d6db22c46392bfad8b/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f07b6ca4b064ea8e6d172fc7d6a87f065c20327", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f07b6ca4b064ea8e6d172fc7d6a87f065c20327", "html_url": "https://github.com/rust-lang/rust/commit/6f07b6ca4b064ea8e6d172fc7d6a87f065c20327"}, {"sha": "a6ff05cd8387efbb0286e9e35d11111c3b6380fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6ff05cd8387efbb0286e9e35d11111c3b6380fe", "html_url": "https://github.com/rust-lang/rust/commit/a6ff05cd8387efbb0286e9e35d11111c3b6380fe"}], "stats": {"total": 89, "additions": 46, "deletions": 43}, "files": [{"sha": "e762e4d8ce9a26a2d3690a40839d6e47ae280bd5", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 46, "deletions": 43, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/257b351ad17564d6691342d6db22c46392bfad8b/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/257b351ad17564d6691342d6db22c46392bfad8b/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=257b351ad17564d6691342d6db22c46392bfad8b", "patch": "@@ -12,23 +12,11 @@\n \n //! Threadsafe reference-counted boxes (the `Arc<T>` type).\n //!\n-//! The `Arc<T>` type provides shared ownership of an immutable value.\n-//! Destruction is deterministic, and will occur as soon as the last owner is\n-//! gone. It is marked as `Send` because it uses atomic reference counting.\n-//!\n-//! If you do not need thread-safety, and just need shared ownership, consider\n-//! the [`Rc<T>` type](../rc/struct.Rc.html). It is the same as `Arc<T>`, but\n-//! does not use atomics, making it both thread-unsafe as well as significantly\n-//! faster when updating the reference count.\n-//!\n-//! The `downgrade` method can be used to create a non-owning `Weak<T>` pointer\n-//! to the box. A `Weak<T>` pointer can be upgraded to an `Arc<T>` pointer, but\n-//! will return `None` if the value has already been dropped.\n-//!\n-//! For example, a tree with parent pointers can be represented by putting the\n-//! nodes behind strong `Arc<T>` pointers, and then storing the parent pointers\n-//! as `Weak<T>` pointers.\n+//! The `Arc<T>` type provides shared ownership of an immutable value through\n+//! atomic reference counting.\n //!\n+//! `Weak<T>` is a weak reference to the `Arc<T>` box, and it is created by\n+//! the `downgrade` method.\n //! # Examples\n //!\n //! Sharing some immutable data between threads:\n@@ -47,27 +35,6 @@\n //!     });\n //! }\n //! ```\n-//!\n-//! Sharing mutable data safely between threads with a `Mutex`:\n-//!\n-//! ```no_run\n-//! use std::sync::{Arc, Mutex};\n-//! use std::thread;\n-//!\n-//! let five = Arc::new(Mutex::new(5));\n-//!\n-//! for _ in 0..10 {\n-//!     let five = five.clone();\n-//!\n-//!     thread::spawn(move || {\n-//!         let mut number = five.lock().unwrap();\n-//!\n-//!         *number += 1;\n-//!\n-//!         println!(\"{}\", *number); // prints 6\n-//!     });\n-//! }\n-//! ```\n \n use boxed::Box;\n \n@@ -92,15 +59,19 @@ use heap::deallocate;\n const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n \n /// An atomically reference counted wrapper for shared state.\n+/// Destruction is deterministic, and will occur as soon as the last owner is\n+/// gone. It is marked as `Send` because it uses atomic reference counting.\n ///\n-/// # Examples\n+/// If you do not need thread-safety, and just need shared ownership, consider\n+/// the [`Rc<T>` type](../rc/struct.Rc.html). It is the same as `Arc<T>`, but\n+/// does not use atomics, making it both thread-unsafe as well as significantly\n+/// faster when updating the reference count.\n ///\n-/// In this example, a large vector is shared between several threads.\n-/// With simple pipes, without `Arc`, a copy would have to be made for each\n-/// thread.\n+/// # Examples\n ///\n-/// When you clone an `Arc<T>`, it will create another pointer to the data and\n-/// increase the reference counter.\n+/// In this example, a large vector of data will be shared by several threads. First we\n+/// wrap it with a `Arc::new` and then clone the `Arc<T>` reference for every thread (which will\n+/// increase the reference count atomically).\n ///\n /// ```\n /// use std::sync::Arc;\n@@ -111,6 +82,7 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n ///     let shared_numbers = Arc::new(numbers);\n ///\n ///     for _ in 0..10 {\n+///         // prepare a copy of reference here and it will be moved to the thread\n ///         let child_numbers = shared_numbers.clone();\n ///\n ///         thread::spawn(move || {\n@@ -121,6 +93,29 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n ///     }\n /// }\n /// ```\n+/// You can also share mutable data between threads safely\n+/// by putting it inside `Mutex` and then share `Mutex` immutably\n+/// with `Arc<T>` as shown below.\n+///\n+/// ```\n+/// use std::sync::{Arc, Mutex};\n+/// use std::thread;\n+///\n+/// let five = Arc::new(Mutex::new(5));\n+///\n+/// for _ in 0..10 {\n+///     let five = five.clone();\n+///\n+///     thread::spawn(move || {\n+///         let mut number = five.lock().unwrap();\n+///\n+///         *number += 1;\n+///\n+///         println!(\"{}\", *number); // prints 6\n+///     });\n+/// }\n+/// ```\n+\n #[unsafe_no_drop_flag]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Arc<T: ?Sized> {\n@@ -139,6 +134,14 @@ impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Arc<U>> for Arc<T> {}\n ///\n /// Weak pointers will not keep the data inside of the `Arc` alive, and can be\n /// used to break cycles between `Arc` pointers.\n+///\n+/// A `Weak<T>` pointer can be upgraded to an `Arc<T>` pointer, but\n+/// will return `None` if the value has already been dropped.\n+///\n+/// For example, a tree with parent pointers can be represented by putting the\n+/// nodes behind strong `Arc<T>` pointers, and then storing the parent pointers\n+/// as `Weak<T>` pointers.\n+\n #[unsafe_no_drop_flag]\n #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n pub struct Weak<T: ?Sized> {"}]}