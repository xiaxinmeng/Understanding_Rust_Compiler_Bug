{"sha": "7300bd6a38376ead250f766a470594943fd9bb80", "node_id": "C_kwDOAAsO6NoAKDczMDBiZDZhMzgzNzZlYWQyNTBmNzY2YTQ3MDU5NDk0M2ZkOWJiODA", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-04-05T06:31:30Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-04-05T07:23:30Z"}, "message": "Move the missing fragment identifier checking.\n\nIn #95555 this was moved out of `parse_tt_inner` and `nameize` into\n`compute_locs`. But the next commit will be moving `compute_locs`\noutwards to a place that isn't suitable for the missing fragment\nidentifier checking. So this reinstates the old checking.", "tree": {"sha": "b0f4f494d4b74c96b7e1e1c56ec859d9babbcb8d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0f4f494d4b74c96b7e1e1c56ec859d9babbcb8d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7300bd6a38376ead250f766a470594943fd9bb80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7300bd6a38376ead250f766a470594943fd9bb80", "html_url": "https://github.com/rust-lang/rust/commit/7300bd6a38376ead250f766a470594943fd9bb80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7300bd6a38376ead250f766a470594943fd9bb80/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "896d8f5905f2d63393a048dff5aeb0c23b793e7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/896d8f5905f2d63393a048dff5aeb0c23b793e7e", "html_url": "https://github.com/rust-lang/rust/commit/896d8f5905f2d63393a048dff5aeb0c23b793e7e"}], "stats": {"total": 105, "additions": 58, "deletions": 47}, "files": [{"sha": "76a92d1f8a0c3355d5f1051d951fc5a829e8cac3", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 58, "deletions": 47, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/7300bd6a38376ead250f766a470594943fd9bb80/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7300bd6a38376ead250f766a470594943fd9bb80/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=7300bd6a38376ead250f766a470594943fd9bb80", "patch": "@@ -131,7 +131,7 @@ enum MatcherLoc {\n     MetaVarDecl {\n         span: Span,\n         bind: Ident,\n-        kind: NonterminalKind,\n+        kind: Option<NonterminalKind>,\n         next_metavar: usize,\n         seq_depth: usize,\n     },\n@@ -337,26 +337,22 @@ impl TtParser {\n     /// recursive. This conversion is fairly cheap and the representation is sufficiently better\n     /// for matching than `&[TokenTree]` that it's a clear performance win even with the overhead.\n     /// But it might be possible to move the conversion outwards so it only occurs once per macro.\n-    fn compute_locs(\n-        &mut self,\n-        sess: &ParseSess,\n-        matcher: &[TokenTree],\n-    ) -> Result<usize, (Span, String)> {\n+    fn compute_locs(&mut self, sess: &ParseSess, matcher: &[TokenTree]) -> usize {\n         fn inner(\n             sess: &ParseSess,\n             tts: &[TokenTree],\n             locs: &mut Vec<MatcherLoc>,\n             next_metavar: &mut usize,\n             seq_depth: usize,\n-        ) -> Result<(), (Span, String)> {\n+        ) {\n             for tt in tts {\n                 match tt {\n                     TokenTree::Token(token) => {\n                         locs.push(MatcherLoc::Token { token: token.clone() });\n                     }\n                     TokenTree::Delimited(_, delimited) => {\n                         locs.push(MatcherLoc::Delimited);\n-                        inner(sess, &delimited.all_tts, locs, next_metavar, seq_depth)?;\n+                        inner(sess, &delimited.all_tts, locs, next_metavar, seq_depth);\n                     }\n                     TokenTree::Sequence(_, seq) => {\n                         // We can't determine `idx_first_after` and construct the final\n@@ -370,7 +366,7 @@ impl TtParser {\n                         let op = seq.kleene.op;\n                         let idx_first = locs.len();\n                         let idx_seq = idx_first - 1;\n-                        inner(sess, &seq.tts, locs, next_metavar, seq_depth + 1)?;\n+                        inner(sess, &seq.tts, locs, next_metavar, seq_depth + 1);\n \n                         if let Some(separator) = &seq.separator {\n                             locs.push(MatcherLoc::SequenceSep { separator: separator.clone() });\n@@ -389,40 +385,29 @@ impl TtParser {\n                         };\n                     }\n                     &TokenTree::MetaVarDecl(span, bind, kind) => {\n-                        if let Some(kind) = kind {\n-                            locs.push(MatcherLoc::MetaVarDecl {\n-                                span,\n-                                bind,\n-                                kind,\n-                                next_metavar: *next_metavar,\n-                                seq_depth,\n-                            });\n-                            *next_metavar += 1;\n-                        } else if sess\n-                            .missing_fragment_specifiers\n-                            .borrow_mut()\n-                            .remove(&span)\n-                            .is_some()\n-                        {\n-                            // E.g. `$e` instead of `$e:expr`.\n-                            return Err((span, \"missing fragment specifier\".to_string()));\n-                        }\n+                        locs.push(MatcherLoc::MetaVarDecl {\n+                            span,\n+                            bind,\n+                            kind,\n+                            next_metavar: *next_metavar,\n+                            seq_depth,\n+                        });\n+                        *next_metavar += 1;\n                     }\n                     TokenTree::MetaVar(..) | TokenTree::MetaVarExpr(..) => unreachable!(),\n                 }\n             }\n-            Ok(())\n         }\n \n         self.locs.clear();\n         let mut next_metavar = 0;\n-        inner(sess, matcher, &mut self.locs, &mut next_metavar, /* seq_depth */ 0)?;\n+        inner(sess, matcher, &mut self.locs, &mut next_metavar, /* seq_depth */ 0);\n \n         // A final entry is needed for eof.\n         self.locs.push(MatcherLoc::Eof);\n \n         // This is the number of metavar decls.\n-        Ok(next_metavar)\n+        next_metavar\n     }\n \n     /// Process the matcher positions of `cur_mps` until it is empty. In the process, this will\n@@ -434,6 +419,7 @@ impl TtParser {\n     /// track of through the mps generated.\n     fn parse_tt_inner(\n         &mut self,\n+        sess: &ParseSess,\n         num_metavar_decls: usize,\n         token: &Token,\n     ) -> Option<NamedParseResult> {\n@@ -532,12 +518,20 @@ impl TtParser {\n                     mp.idx = idx_first;\n                     self.cur_mps.push(mp);\n                 }\n-                MatcherLoc::MetaVarDecl { kind, .. } => {\n+                &MatcherLoc::MetaVarDecl { span, kind, .. } => {\n                     // Built-in nonterminals never start with these tokens, so we can eliminate\n                     // them from consideration. We use the span of the metavariable declaration\n                     // to determine any edition-specific matching behavior for non-terminals.\n-                    if Parser::nonterminal_may_begin_with(*kind, token) {\n-                        self.bb_mps.push(mp);\n+                    if let Some(kind) = kind {\n+                        if Parser::nonterminal_may_begin_with(kind, token) {\n+                            self.bb_mps.push(mp);\n+                        }\n+                    } else {\n+                        // Both this check and the one in `nameize` are necessary, surprisingly.\n+                        if sess.missing_fragment_specifiers.borrow_mut().remove(&span).is_some() {\n+                            // E.g. `$e` instead of `$e:expr`.\n+                            return Some(Error(span, \"missing fragment specifier\".to_string()));\n+                        }\n                     }\n                 }\n                 MatcherLoc::Eof => {\n@@ -564,7 +558,7 @@ impl TtParser {\n                     // Need to take ownership of the matches from within the `Lrc`.\n                     Lrc::make_mut(&mut eof_mp.matches);\n                     let matches = Lrc::try_unwrap(eof_mp.matches).unwrap().into_iter();\n-                    self.nameize(matches)\n+                    self.nameize(sess, matches)\n                 }\n                 EofMatcherPositions::Multiple => {\n                     Error(token.span, \"ambiguity: multiple successful parses\".to_string())\n@@ -588,10 +582,7 @@ impl TtParser {\n         parser: &mut Cow<'_, Parser<'_>>,\n         matcher: &[TokenTree],\n     ) -> NamedParseResult {\n-        let num_metavar_decls = match self.compute_locs(parser.sess, matcher) {\n-            Ok(num_metavar_decls) => num_metavar_decls,\n-            Err((span, msg)) => return Error(span, msg),\n-        };\n+        let num_metavar_decls = self.compute_locs(parser.sess, matcher);\n \n         // A queue of possible matcher positions. We initialize it with the matcher position in\n         // which the \"dot\" is before the first token of the first token tree in `matcher`.\n@@ -607,7 +598,7 @@ impl TtParser {\n \n             // Process `cur_mps` until either we have finished the input or we need to get some\n             // parsing from the black-box parser done.\n-            if let Some(res) = self.parse_tt_inner(num_metavar_decls, &parser.token) {\n+            if let Some(res) = self.parse_tt_inner(&parser.sess, num_metavar_decls, &parser.token) {\n                 return res;\n             }\n \n@@ -637,7 +628,11 @@ impl TtParser {\n                     let mut mp = self.bb_mps.pop().unwrap();\n                     let loc = &self.locs[mp.idx];\n                     if let &MatcherLoc::MetaVarDecl {\n-                        span, kind, next_metavar, seq_depth, ..\n+                        span,\n+                        kind: Some(kind),\n+                        next_metavar,\n+                        seq_depth,\n+                        ..\n                     } = loc\n                     {\n                         // We use the span of the metavariable declaration to determine any\n@@ -682,7 +677,9 @@ impl TtParser {\n             .bb_mps\n             .iter()\n             .map(|mp| match &self.locs[mp.idx] {\n-                MatcherLoc::MetaVarDecl { bind, kind, .. } => format!(\"{} ('{}')\", kind, bind),\n+                MatcherLoc::MetaVarDecl { bind, kind: Some(kind), .. } => {\n+                    format!(\"{} ('{}')\", kind, bind)\n+                }\n                 _ => unreachable!(),\n             })\n             .collect::<Vec<String>>()\n@@ -702,16 +699,30 @@ impl TtParser {\n         )\n     }\n \n-    fn nameize<I: Iterator<Item = NamedMatch>>(&self, mut res: I) -> NamedParseResult {\n+    fn nameize<I: Iterator<Item = NamedMatch>>(\n+        &self,\n+        sess: &ParseSess,\n+        mut res: I,\n+    ) -> NamedParseResult {\n         // Make that each metavar has _exactly one_ binding. If so, insert the binding into the\n         // `NamedParseResult`. Otherwise, it's an error.\n         let mut ret_val = FxHashMap::default();\n         for loc in self.locs.iter() {\n-            if let &MatcherLoc::MetaVarDecl { span, bind, .. } = loc {\n-                match ret_val.entry(MacroRulesNormalizedIdent::new(bind)) {\n-                    Vacant(spot) => spot.insert(res.next().unwrap()),\n-                    Occupied(..) => return Error(span, format!(\"duplicated bind name: {}\", bind)),\n-                };\n+            if let &MatcherLoc::MetaVarDecl { span, bind, kind, .. } = loc {\n+                if kind.is_some() {\n+                    match ret_val.entry(MacroRulesNormalizedIdent::new(bind)) {\n+                        Vacant(spot) => spot.insert(res.next().unwrap()),\n+                        Occupied(..) => {\n+                            return Error(span, format!(\"duplicated bind name: {}\", bind));\n+                        }\n+                    };\n+                } else {\n+                    // Both this check and the one in `parse_tt_inner` are necessary, surprisingly.\n+                    if sess.missing_fragment_specifiers.borrow_mut().remove(&span).is_some() {\n+                        // E.g. `$e` instead of `$e:expr`.\n+                        return Error(span, \"missing fragment specifier\".to_string());\n+                    }\n+                }\n             }\n         }\n         Success(ret_val)"}]}