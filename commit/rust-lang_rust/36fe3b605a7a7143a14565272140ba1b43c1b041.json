{"sha": "36fe3b605a7a7143a14565272140ba1b43c1b041", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2ZmUzYjYwNWE3YTcxNDNhMTQ1NjUyNzIxNDBiYTFiNDNjMWIwNDE=", "commit": {"author": {"name": "Alex Gaynor", "email": "alex.gaynor@gmail.com", "date": "2018-10-25T19:44:32Z"}, "committer": {"name": "Alex Gaynor", "email": "alex.gaynor@gmail.com", "date": "2018-11-01T12:51:24Z"}, "message": "Fixes #46775 -- don't mutate the process's environment in Command::exec\n\nInstead, pass the environment to execvpe, so the kernel can apply it directly to the new process. This avoids a use-after-free in the case where exec'ing the new process fails for any reason, as well as a race condition if there are other threads alive during the exec.", "tree": {"sha": "b6e50e01308ebee18923dbf6d22d3f81338549c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6e50e01308ebee18923dbf6d22d3f81338549c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/36fe3b605a7a7143a14565272140ba1b43c1b041", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/36fe3b605a7a7143a14565272140ba1b43c1b041", "html_url": "https://github.com/rust-lang/rust/commit/36fe3b605a7a7143a14565272140ba1b43c1b041", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/36fe3b605a7a7143a14565272140ba1b43c1b041/comments", "author": {"login": "alex", "id": 772, "node_id": "MDQ6VXNlcjc3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alex", "html_url": "https://github.com/alex", "followers_url": "https://api.github.com/users/alex/followers", "following_url": "https://api.github.com/users/alex/following{/other_user}", "gists_url": "https://api.github.com/users/alex/gists{/gist_id}", "starred_url": "https://api.github.com/users/alex/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alex/subscriptions", "organizations_url": "https://api.github.com/users/alex/orgs", "repos_url": "https://api.github.com/users/alex/repos", "events_url": "https://api.github.com/users/alex/events{/privacy}", "received_events_url": "https://api.github.com/users/alex/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alex", "id": 772, "node_id": "MDQ6VXNlcjc3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alex", "html_url": "https://github.com/alex", "followers_url": "https://api.github.com/users/alex/followers", "following_url": "https://api.github.com/users/alex/following{/other_user}", "gists_url": "https://api.github.com/users/alex/gists{/gist_id}", "starred_url": "https://api.github.com/users/alex/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alex/subscriptions", "organizations_url": "https://api.github.com/users/alex/orgs", "repos_url": "https://api.github.com/users/alex/repos", "events_url": "https://api.github.com/users/alex/events{/privacy}", "received_events_url": "https://api.github.com/users/alex/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "365b9001e588cf3d91561894b0e44389e31ae000", "url": "https://api.github.com/repos/rust-lang/rust/commits/365b9001e588cf3d91561894b0e44389e31ae000", "html_url": "https://github.com/rust-lang/rust/commit/365b9001e588cf3d91561894b0e44389e31ae000"}], "stats": {"total": 119, "additions": 111, "deletions": 8}, "files": [{"sha": "3d5920dfb69ac8aa59f2125e36c1028ea247a89d", "filename": "src/libstd/sys/unix/process/process_common.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/36fe3b605a7a7143a14565272140ba1b43c1b041/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36fe3b605a7a7143a14565272140ba1b43c1b041/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs?ref=36fe3b605a7a7143a14565272140ba1b43c1b041", "patch": "@@ -141,6 +141,10 @@ impl Command {\n     pub fn get_argv(&self) -> &Vec<*const c_char> {\n         &self.argv.0\n     }\n+    #[cfg(not(target_os = \"fuchsia\"))]\n+    pub fn get_program(&self) -> &CString {\n+        return &self.program;\n+    }\n \n     #[allow(dead_code)]\n     pub fn get_cwd(&self) -> &Option<CString> {\n@@ -244,6 +248,10 @@ impl CStringArray {\n     pub fn as_ptr(&self) -> *const *const c_char {\n         self.ptrs.as_ptr()\n     }\n+    #[cfg(not(target_os = \"fuchsia\"))]\n+    pub fn get_items(&self) -> &[CString] {\n+        return &self.items;\n+    }\n }\n \n fn construct_envp(env: BTreeMap<DefaultEnvKey, OsString>, saw_nul: &mut bool) -> CStringArray {"}, {"sha": "f41bd2c20720a65511c13c4028d53965cd4d0efc", "filename": "src/libstd/sys/unix/process/process_unix.rs", "status": "modified", "additions": 91, "deletions": 8, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/36fe3b605a7a7143a14565272140ba1b43c1b041/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36fe3b605a7a7143a14565272140ba1b43c1b041/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=36fe3b605a7a7143a14565272140ba1b43c1b041", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use env;\n+use ffi::CString;\n use io::{self, Error, ErrorKind};\n use libc::{self, c_int, gid_t, pid_t, uid_t};\n use ptr;\n@@ -39,13 +41,15 @@ impl Command {\n             return Ok((ret, ours))\n         }\n \n+        let possible_paths = self.compute_possible_paths(envp.as_ref());\n+\n         let (input, output) = sys::pipe::anon_pipe()?;\n \n         let pid = unsafe {\n             match cvt(libc::fork())? {\n                 0 => {\n                     drop(input);\n-                    let err = self.do_exec(theirs, envp.as_ref());\n+                    let err = self.do_exec(theirs, envp.as_ref(), possible_paths);\n                     let errno = err.raw_os_error().unwrap_or(libc::EINVAL) as u32;\n                     let bytes = [\n                         (errno >> 24) as u8,\n@@ -113,12 +117,48 @@ impl Command {\n                                   \"nul byte found in provided data\")\n         }\n \n+        let possible_paths = self.compute_possible_paths(envp.as_ref());\n         match self.setup_io(default, true) {\n-            Ok((_, theirs)) => unsafe { self.do_exec(theirs, envp.as_ref()) },\n+            Ok((_, theirs)) => unsafe { self.do_exec(theirs, envp.as_ref(), possible_paths) },\n             Err(e) => e,\n         }\n     }\n \n+    fn compute_possible_paths(&self, maybe_envp: Option<&CStringArray>) -> Option<Vec<CString>> {\n+        let program = self.get_program().as_bytes();\n+        if program.contains(&b'/') {\n+            return None;\n+        }\n+        // Outside the match so we can borrow it for the lifetime of the function.\n+        let parent_path = env::var(\"PATH\").ok();\n+        let paths = match maybe_envp {\n+            Some(envp) => {\n+                match envp.get_items().iter().find(|var| var.as_bytes().starts_with(b\"PATH=\")) {\n+                    Some(p) => &p.as_bytes()[5..],\n+                    None => return None,\n+                }\n+            },\n+            // maybe_envp is None if the process isn't changing the parent's env at all.\n+            None => {\n+                match parent_path.as_ref() {\n+                    Some(p) => p.as_bytes(),\n+                    None => return None,\n+                }\n+            },\n+        };\n+\n+        let mut possible_paths = vec![];\n+        for path in paths.split(|p| *p == b':') {\n+            let mut binary_path = Vec::with_capacity(program.len() + path.len() + 1);\n+            binary_path.extend_from_slice(path);\n+            binary_path.push(b'/');\n+            binary_path.extend_from_slice(program);\n+            let c_binary_path = CString::new(binary_path).unwrap();\n+            possible_paths.push(c_binary_path);\n+        }\n+        return Some(possible_paths);\n+    }\n+\n     // And at this point we've reached a special time in the life of the\n     // child. The child must now be considered hamstrung and unable to\n     // do anything other than syscalls really. Consider the following\n@@ -152,7 +192,8 @@ impl Command {\n     unsafe fn do_exec(\n         &mut self,\n         stdio: ChildPipes,\n-        maybe_envp: Option<&CStringArray>\n+        maybe_envp: Option<&CStringArray>,\n+        maybe_possible_paths: Option<Vec<CString>>,\n     ) -> io::Error {\n         use sys::{self, cvt_r};\n \n@@ -193,9 +234,6 @@ impl Command {\n         if let Some(ref cwd) = *self.get_cwd() {\n             t!(cvt(libc::chdir(cwd.as_ptr())));\n         }\n-        if let Some(envp) = maybe_envp {\n-            *sys::os::environ() = envp.as_ptr();\n-        }\n \n         // emscripten has no signal support.\n         #[cfg(not(any(target_os = \"emscripten\")))]\n@@ -231,8 +269,53 @@ impl Command {\n             t!(callback());\n         }\n \n-        libc::execvp(self.get_argv()[0], self.get_argv().as_ptr());\n-        io::Error::last_os_error()\n+        // If the program isn't an absolute path, and our environment contains a PATH var, then we\n+        // implement the PATH traversal ourselves so that it honors the child's PATH instead of the\n+        // parent's. This mirrors the logic that exists in glibc's execvpe, except using the\n+        // child's env to fetch PATH.\n+        match maybe_possible_paths {\n+            Some(possible_paths) => {\n+                let mut pending_error = None;\n+                for path in possible_paths {\n+                    libc::execve(\n+                        path.as_ptr(),\n+                        self.get_argv().as_ptr(),\n+                        maybe_envp.map(|envp| envp.as_ptr()).unwrap_or_else(|| *sys::os::environ())\n+                    );\n+                    let err = io::Error::last_os_error();\n+                    match err.kind() {\n+                        io::ErrorKind::PermissionDenied => {\n+                            // If we saw a PermissionDenied, and none of the other entries in\n+                            // $PATH are successful, then we'll return the first EACCESS we see.\n+                            if pending_error.is_none() {\n+                                pending_error = Some(err);\n+                            }\n+                        },\n+                        // Errors which indicate we failed to find a file are ignored and we try\n+                        // the next entry in the path.\n+                        io::ErrorKind::NotFound | io::ErrorKind::TimedOut => {\n+                            continue\n+                        },\n+                        // Any other error means we found a file and couldn't execute it.\n+                        _ => {\n+                            return err;\n+                        }\n+                    }\n+                }\n+                if let Some(err) = pending_error {\n+                    return err;\n+                }\n+                return io::Error::from_raw_os_error(libc::ENOENT);\n+            },\n+            _ => {\n+                libc::execve(\n+                    self.get_argv()[0],\n+                    self.get_argv().as_ptr(),\n+                    maybe_envp.map(|envp| envp.as_ptr()).unwrap_or_else(|| *sys::os::environ())\n+                );\n+                return io::Error::last_os_error()\n+            }\n+        }\n     }\n \n     #[cfg(not(any(target_os = \"macos\", target_os = \"freebsd\","}, {"sha": "96f9da67790fc7814339eaca87641640e6062481", "filename": "src/test/run-pass/command-exec.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/36fe3b605a7a7143a14565272140ba1b43c1b041/src%2Ftest%2Frun-pass%2Fcommand-exec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36fe3b605a7a7143a14565272140ba1b43c1b041/src%2Ftest%2Frun-pass%2Fcommand-exec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcommand-exec.rs?ref=36fe3b605a7a7143a14565272140ba1b43c1b041", "patch": "@@ -48,6 +48,13 @@ fn main() {\n                 println!(\"passed\");\n             }\n \n+            \"exec-test5\" => {\n+                env::set_var(\"VARIABLE\", \"ABC\");\n+                Command::new(\"definitely-not-a-real-binary\").env(\"VARIABLE\", \"XYZ\").exec();\n+                assert_eq!(env::var(\"VARIABLE\").unwrap(), \"ABC\");\n+                println!(\"passed\");\n+            }\n+\n             _ => panic!(\"unknown argument: {}\", arg),\n         }\n         return\n@@ -72,4 +79,9 @@ fn main() {\n     assert!(output.status.success());\n     assert!(output.stderr.is_empty());\n     assert_eq!(output.stdout, b\"passed\\n\");\n+\n+    let output = Command::new(&me).arg(\"exec-test5\").output().unwrap();\n+    assert!(output.status.success());\n+    assert!(output.stderr.is_empty());\n+    assert_eq!(output.stdout, b\"passed\\n\");\n }"}]}