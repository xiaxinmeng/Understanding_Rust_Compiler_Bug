{"sha": "90797ef008a2004e70ff0106c756f24ea63ab236", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwNzk3ZWYwMDhhMjAwNGU3MGZmMDEwNmM3NTZmMjRlYTYzYWIyMzY=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2021-03-17T23:28:04Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-17T23:28:04Z"}, "message": "Rollup merge of #82191 - Soveu:dedup, r=nagisa\n\nVec::dedup_by optimization\n\nNow `Vec::dedup_by` drops items in-place as it goes through them.\nFrom my benchmarks, it is around 10% faster when T is small, with no major regression when otherwise.\n\nI used `ptr::copy` instead of conditional `ptr::copy_nonoverlapping`, because the latter had some weird performance issues on my ryzen laptop (it was 50% slower on it than on intel/sandybridge laptop)\nIt would be good if someone was able to reproduce these results.", "tree": {"sha": "e8cb8a5d1ee1b6ef5fc05df529e620062ebf1598", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8cb8a5d1ee1b6ef5fc05df529e620062ebf1598"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90797ef008a2004e70ff0106c756f24ea63ab236", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgUpCFCRBK7hj4Ov3rIwAAdHIIAB1F8ogzqCUJq5PgeLsPdFsR\nOlF152TfTnf7Nmxw5NLnEA8HCV7iPaYQjFyWKNDuQeOZK0w+xUNkEnd+fCwZH6X5\naM9bpW5mL8hzSYVDBH58CZi1DB520ze1tNv/kPeIrJX/kxzbAvKlxHbJD3JWZBXr\nFEzI1bRzrXjx4QQQpkgKmyowT2OADT5lTYCQFEXHTnxQHeEjkbQfZZzVzPq5jhdH\nJpTkVPdMoFSxeLAiVuMZnzSWwvcOWp8vMl1r45wlJdBcR7Bb3Hw4dsaYS3Eq3p1Y\n80gMryVAxxfedlqSN6u2XDTkpqEW0YU1O7V6VHQlBSUMHKvVOW8FLijLY3DEMgo=\n=aPeU\n-----END PGP SIGNATURE-----\n", "payload": "tree e8cb8a5d1ee1b6ef5fc05df529e620062ebf1598\nparent 36f1f04f18b89ba4a999bcfd6584663fd6fc1c5d\nparent b0092bc995fa3e6633c3aaa1d0a56006ab7ad1e3\nauthor Dylan DPC <dylan.dpc@gmail.com> 1616023684 +0100\ncommitter GitHub <noreply@github.com> 1616023684 +0100\n\nRollup merge of #82191 - Soveu:dedup, r=nagisa\n\nVec::dedup_by optimization\n\nNow `Vec::dedup_by` drops items in-place as it goes through them.\nFrom my benchmarks, it is around 10% faster when T is small, with no major regression when otherwise.\n\nI used `ptr::copy` instead of conditional `ptr::copy_nonoverlapping`, because the latter had some weird performance issues on my ryzen laptop (it was 50% slower on it than on intel/sandybridge laptop)\nIt would be good if someone was able to reproduce these results.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90797ef008a2004e70ff0106c756f24ea63ab236", "html_url": "https://github.com/rust-lang/rust/commit/90797ef008a2004e70ff0106c756f24ea63ab236", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90797ef008a2004e70ff0106c756f24ea63ab236/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36f1f04f18b89ba4a999bcfd6584663fd6fc1c5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/36f1f04f18b89ba4a999bcfd6584663fd6fc1c5d", "html_url": "https://github.com/rust-lang/rust/commit/36f1f04f18b89ba4a999bcfd6584663fd6fc1c5d"}, {"sha": "b0092bc995fa3e6633c3aaa1d0a56006ab7ad1e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0092bc995fa3e6633c3aaa1d0a56006ab7ad1e3", "html_url": "https://github.com/rust-lang/rust/commit/b0092bc995fa3e6633c3aaa1d0a56006ab7ad1e3"}], "stats": {"total": 312, "additions": 306, "deletions": 6}, "files": [{"sha": "38a8f65f1695a0d4a4e12c85f6ee2ec7cb7e763d", "filename": "library/alloc/benches/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/90797ef008a2004e70ff0106c756f24ea63ab236/library%2Falloc%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90797ef008a2004e70ff0106c756f24ea63ab236/library%2Falloc%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Flib.rs?ref=90797ef008a2004e70ff0106c756f24ea63ab236", "patch": "@@ -4,6 +4,7 @@\n #![feature(btree_drain_filter)]\n #![feature(map_first_last)]\n #![feature(repr_simd)]\n+#![feature(slice_partition_dedup)]\n #![feature(test)]\n \n extern crate test;"}, {"sha": "73eb353f6e7d468be55a2bb86f695ddb53483dae", "filename": "library/alloc/benches/vec.rs", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/90797ef008a2004e70ff0106c756f24ea63ab236/library%2Falloc%2Fbenches%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90797ef008a2004e70ff0106c756f24ea63ab236/library%2Falloc%2Fbenches%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Fvec.rs?ref=90797ef008a2004e70ff0106c756f24ea63ab236", "patch": "@@ -671,3 +671,92 @@ fn bench_map_fast(b: &mut Bencher) {\n     let data = black_box([(0, 0); LEN]);\n     b.iter(|| map_fast(&data));\n }\n+\n+fn random_sorted_fill(mut seed: u32, buf: &mut [u32]) {\n+    let mask = if buf.len() < 8192 {\n+        0xFF\n+    } else if buf.len() < 200_000 {\n+        0xFFFF\n+    } else {\n+        0xFFFF_FFFF\n+    };\n+\n+    for item in buf.iter_mut() {\n+        seed ^= seed << 13;\n+        seed ^= seed >> 17;\n+        seed ^= seed << 5;\n+\n+        *item = seed & mask;\n+    }\n+\n+    buf.sort();\n+}\n+\n+fn bench_vec_dedup_old(b: &mut Bencher, sz: usize) {\n+    let mut template = vec![0u32; sz];\n+    b.bytes = std::mem::size_of_val(template.as_slice()) as u64;\n+    random_sorted_fill(0x43, &mut template);\n+\n+    let mut vec = template.clone();\n+    b.iter(|| {\n+        let len = {\n+            let (dedup, _) = vec.partition_dedup();\n+            dedup.len()\n+        };\n+        vec.truncate(len);\n+\n+        black_box(vec.first());\n+        vec.clear();\n+        vec.extend_from_slice(&template);\n+    });\n+}\n+\n+fn bench_vec_dedup_new(b: &mut Bencher, sz: usize) {\n+    let mut template = vec![0u32; sz];\n+    b.bytes = std::mem::size_of_val(template.as_slice()) as u64;\n+    random_sorted_fill(0x43, &mut template);\n+\n+    let mut vec = template.clone();\n+    b.iter(|| {\n+        vec.dedup();\n+        black_box(vec.first());\n+        vec.clear();\n+        vec.extend_from_slice(&template);\n+    });\n+}\n+\n+#[bench]\n+fn bench_dedup_old_100(b: &mut Bencher) {\n+    bench_vec_dedup_old(b, 100);\n+}\n+#[bench]\n+fn bench_dedup_new_100(b: &mut Bencher) {\n+    bench_vec_dedup_new(b, 100);\n+}\n+\n+#[bench]\n+fn bench_dedup_old_1000(b: &mut Bencher) {\n+    bench_vec_dedup_old(b, 1000);\n+}\n+#[bench]\n+fn bench_dedup_new_1000(b: &mut Bencher) {\n+    bench_vec_dedup_new(b, 1000);\n+}\n+\n+#[bench]\n+fn bench_dedup_old_10000(b: &mut Bencher) {\n+    bench_vec_dedup_old(b, 10000);\n+}\n+#[bench]\n+fn bench_dedup_new_10000(b: &mut Bencher) {\n+    bench_vec_dedup_new(b, 10000);\n+}\n+\n+#[bench]\n+fn bench_dedup_old_100000(b: &mut Bencher) {\n+    bench_vec_dedup_old(b, 100000);\n+}\n+#[bench]\n+fn bench_dedup_new_100000(b: &mut Bencher) {\n+    bench_vec_dedup_new(b, 100000);\n+}"}, {"sha": "135279874bb3b7b3d7a1e0be730f3c40f82bab6c", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 89, "deletions": 6, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/90797ef008a2004e70ff0106c756f24ea63ab236/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90797ef008a2004e70ff0106c756f24ea63ab236/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=90797ef008a2004e70ff0106c756f24ea63ab236", "patch": "@@ -1512,15 +1512,98 @@ impl<T, A: Allocator> Vec<T, A> {\n     /// assert_eq!(vec, [\"foo\", \"bar\", \"baz\", \"bar\"]);\n     /// ```\n     #[stable(feature = \"dedup_by\", since = \"1.16.0\")]\n-    pub fn dedup_by<F>(&mut self, same_bucket: F)\n+    pub fn dedup_by<F>(&mut self, mut same_bucket: F)\n     where\n         F: FnMut(&mut T, &mut T) -> bool,\n     {\n-        let len = {\n-            let (dedup, _) = self.as_mut_slice().partition_dedup_by(same_bucket);\n-            dedup.len()\n-        };\n-        self.truncate(len);\n+        let len = self.len();\n+        if len <= 1 {\n+            return;\n+        }\n+\n+        /* INVARIANT: vec.len() > read >= write > write-1 >= 0 */\n+        struct FillGapOnDrop<'a, T, A: core::alloc::Allocator> {\n+            /* Offset of the element we want to check if it is duplicate */\n+            read: usize,\n+\n+            /* Offset of the place where we want to place the non-duplicate\n+             * when we find it. */\n+            write: usize,\n+\n+            /* The Vec that would need correction if `same_bucket` panicked */\n+            vec: &'a mut Vec<T, A>,\n+        }\n+\n+        impl<'a, T, A: core::alloc::Allocator> Drop for FillGapOnDrop<'a, T, A> {\n+            fn drop(&mut self) {\n+                /* This code gets executed when `same_bucket` panics */\n+\n+                /* SAFETY: invariant guarantees that `read - write`\n+                 * and `len - read` never overflow and that the copy is always\n+                 * in-bounds. */\n+                unsafe {\n+                    let ptr = self.vec.as_mut_ptr();\n+                    let len = self.vec.len();\n+\n+                    /* How many items were left when `same_bucket` paniced.\n+                     * Basically vec[read..].len() */\n+                    let items_left = len.wrapping_sub(self.read);\n+\n+                    /* Pointer to first item in vec[write..write+items_left] slice */\n+                    let dropped_ptr = ptr.add(self.write);\n+                    /* Pointer to first item in vec[read..] slice */\n+                    let valid_ptr = ptr.add(self.read);\n+\n+                    /* Copy `vec[read..]` to `vec[write..write+items_left]`.\n+                     * The slices can overlap, so `copy_nonoverlapping` cannot be used */\n+                    ptr::copy(valid_ptr, dropped_ptr, items_left);\n+\n+                    /* How many items have been already dropped\n+                     * Basically vec[read..write].len() */\n+                    let dropped = self.read.wrapping_sub(self.write);\n+\n+                    self.vec.set_len(len - dropped);\n+                }\n+            }\n+        }\n+\n+        let mut gap = FillGapOnDrop { read: 1, write: 1, vec: self };\n+        let ptr = gap.vec.as_mut_ptr();\n+\n+        /* Drop items while going through Vec, it should be more efficient than\n+         * doing slice partition_dedup + truncate */\n+\n+        /* SAFETY: Because of the invariant, read_ptr, prev_ptr and write_ptr\n+         * are always in-bounds and read_ptr never aliases prev_ptr */\n+        unsafe {\n+            while gap.read < len {\n+                let read_ptr = ptr.add(gap.read);\n+                let prev_ptr = ptr.add(gap.write.wrapping_sub(1));\n+\n+                if same_bucket(&mut *read_ptr, &mut *prev_ptr) {\n+                    /* We have found duplicate, drop it in-place */\n+                    ptr::drop_in_place(read_ptr);\n+                } else {\n+                    let write_ptr = ptr.add(gap.write);\n+\n+                    /* Because `read_ptr` can be equal to `write_ptr`, we either\n+                     * have to use `copy` or conditional `copy_nonoverlapping`.\n+                     * Looks like the first option is faster. */\n+                    ptr::copy(read_ptr, write_ptr, 1);\n+\n+                    /* We have filled that place, so go further */\n+                    gap.write += 1;\n+                }\n+\n+                gap.read += 1;\n+            }\n+\n+            /* Technically we could let `gap` clean up with its Drop, but\n+             * when `same_bucket` is guaranteed to not panic, this bloats a little\n+             * the codegen, so we just do it manually */\n+            gap.vec.set_len(gap.write);\n+            mem::forget(gap);\n+        }\n     }\n \n     /// Appends an element to the back of a collection."}, {"sha": "11673ed8262bd6c36c20d2100f80a99f639545bd", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/90797ef008a2004e70ff0106c756f24ea63ab236/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90797ef008a2004e70ff0106c756f24ea63ab236/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=90797ef008a2004e70ff0106c756f24ea63ab236", "patch": "@@ -19,6 +19,7 @@\n #![feature(int_bits_const)]\n #![feature(vecdeque_binary_search)]\n #![feature(slice_group_by)]\n+#![feature(slice_partition_dedup)]\n #![feature(vec_extend_from_within)]\n #![feature(vec_spare_capacity)]\n "}, {"sha": "c142536cd2dfbfc9664ecb3d795565dd2a227d6f", "filename": "library/alloc/tests/vec.rs", "status": "modified", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/90797ef008a2004e70ff0106c756f24ea63ab236/library%2Falloc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90797ef008a2004e70ff0106c756f24ea63ab236/library%2Falloc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec.rs?ref=90797ef008a2004e70ff0106c756f24ea63ab236", "patch": "@@ -2102,6 +2102,132 @@ fn test_extend_from_within() {\n     assert_eq!(v, [\"a\", \"b\", \"c\", \"b\", \"c\", \"a\", \"b\"]);\n }\n \n+#[test]\n+fn test_vec_dedup_by() {\n+    let mut vec: Vec<i32> = vec![1, -1, 2, 3, 1, -5, 5, -2, 2];\n+\n+    vec.dedup_by(|a, b| a.abs() == b.abs());\n+\n+    assert_eq!(vec, [1, 2, 3, 1, -5, -2]);\n+}\n+\n+#[test]\n+fn test_vec_dedup_empty() {\n+    let mut vec: Vec<i32> = Vec::new();\n+\n+    vec.dedup();\n+\n+    assert_eq!(vec, []);\n+}\n+\n+#[test]\n+fn test_vec_dedup_one() {\n+    let mut vec = vec![12i32];\n+\n+    vec.dedup();\n+\n+    assert_eq!(vec, [12]);\n+}\n+\n+#[test]\n+fn test_vec_dedup_multiple_ident() {\n+    let mut vec = vec![12, 12, 12, 12, 12, 11, 11, 11, 11, 11, 11];\n+\n+    vec.dedup();\n+\n+    assert_eq!(vec, [12, 11]);\n+}\n+\n+#[test]\n+fn test_vec_dedup_partialeq() {\n+    #[derive(Debug)]\n+    struct Foo(i32, i32);\n+\n+    impl PartialEq for Foo {\n+        fn eq(&self, other: &Foo) -> bool {\n+            self.0 == other.0\n+        }\n+    }\n+\n+    let mut vec = vec![Foo(0, 1), Foo(0, 5), Foo(1, 7), Foo(1, 9)];\n+\n+    vec.dedup();\n+    assert_eq!(vec, [Foo(0, 1), Foo(1, 7)]);\n+}\n+\n+#[test]\n+fn test_vec_dedup() {\n+    let mut vec: Vec<bool> = Vec::with_capacity(8);\n+    let mut template = vec.clone();\n+\n+    for x in 0u8..255u8 {\n+        vec.clear();\n+        template.clear();\n+\n+        let iter = (0..8).map(move |bit| (x >> bit) & 1 == 1);\n+        vec.extend(iter);\n+        template.extend_from_slice(&vec);\n+\n+        let (dedup, _) = template.partition_dedup();\n+        vec.dedup();\n+\n+        assert_eq!(vec, dedup);\n+    }\n+}\n+\n+#[test]\n+fn test_vec_dedup_panicking() {\n+    #[derive(Debug)]\n+    struct Panic {\n+        drop_counter: &'static AtomicU32,\n+        value: bool,\n+        index: usize,\n+    }\n+\n+    impl PartialEq for Panic {\n+        fn eq(&self, other: &Self) -> bool {\n+            self.value == other.value\n+        }\n+    }\n+\n+    impl Drop for Panic {\n+        fn drop(&mut self) {\n+            let x = self.drop_counter.fetch_add(1, Ordering::SeqCst);\n+            assert!(x != 4);\n+        }\n+    }\n+\n+    static DROP_COUNTER: AtomicU32 = AtomicU32::new(0);\n+    let expected = [\n+        Panic { drop_counter: &DROP_COUNTER, value: false, index: 0 },\n+        Panic { drop_counter: &DROP_COUNTER, value: false, index: 5 },\n+        Panic { drop_counter: &DROP_COUNTER, value: true, index: 6 },\n+        Panic { drop_counter: &DROP_COUNTER, value: true, index: 7 },\n+    ];\n+    let mut vec = vec![\n+        Panic { drop_counter: &DROP_COUNTER, value: false, index: 0 },\n+        // these elements get deduplicated\n+        Panic { drop_counter: &DROP_COUNTER, value: false, index: 1 },\n+        Panic { drop_counter: &DROP_COUNTER, value: false, index: 2 },\n+        Panic { drop_counter: &DROP_COUNTER, value: false, index: 3 },\n+        Panic { drop_counter: &DROP_COUNTER, value: false, index: 4 },\n+        // here it panics\n+        Panic { drop_counter: &DROP_COUNTER, value: false, index: 5 },\n+        Panic { drop_counter: &DROP_COUNTER, value: true, index: 6 },\n+        Panic { drop_counter: &DROP_COUNTER, value: true, index: 7 },\n+    ];\n+\n+    let _ = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {\n+        vec.dedup();\n+    }));\n+\n+    let ok = vec.iter().zip(expected.iter()).all(|(x, y)| x.index == y.index);\n+\n+    if !ok {\n+        panic!(\"expected: {:?}\\ngot: {:?}\\n\", expected, vec);\n+    }\n+}\n+\n // Regression test for issue #82533\n #[test]\n fn test_extend_from_within_panicing_clone() {"}]}