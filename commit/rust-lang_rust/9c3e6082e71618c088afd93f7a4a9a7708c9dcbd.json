{"sha": "9c3e6082e71618c088afd93f7a4a9a7708c9dcbd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljM2U2MDgyZTcxNjE4YzA4OGFmZDkzZjdhNGE5YTc3MDhjOWRjYmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-03T03:25:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-03T03:25:21Z"}, "message": "auto merge of #20154 : P1start/rust/qualified-assoc-type-generics, r=nikomatsakis\n\nThis modifies `Parser::eat_lt` to always split up `<<`s, instead of doing so only when a lifetime name followed or the `force` parameter (now removed) was `true`. This is because `Foo<<TYPE` is now a valid start to a type, whereas previously only `Foo<<LIFETIME` was valid.\r\n\r\nThis is a [breaking-change]. Change code that looks like this:\r\n\r\n```rust\r\nlet x = foo as bar << 13;\r\n```\r\n\r\nto use parentheses, like this:\r\n\r\n```rust\r\nlet x = (foo as bar) << 13;\r\n```\r\n\r\nCloses #17362.", "tree": {"sha": "7f0a4f049f87f845a99751add69cda3409a91c20", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f0a4f049f87f845a99751add69cda3409a91c20"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c3e6082e71618c088afd93f7a4a9a7708c9dcbd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c3e6082e71618c088afd93f7a4a9a7708c9dcbd", "html_url": "https://github.com/rust-lang/rust/commit/9c3e6082e71618c088afd93f7a4a9a7708c9dcbd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c3e6082e71618c088afd93f7a4a9a7708c9dcbd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6b109723aa78154ffcfa4db80f3f36b76a9c0a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6b109723aa78154ffcfa4db80f3f36b76a9c0a7", "html_url": "https://github.com/rust-lang/rust/commit/a6b109723aa78154ffcfa4db80f3f36b76a9c0a7"}, {"sha": "d9769ec3834b62318da892925dc24c8883bb1635", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9769ec3834b62318da892925dc24c8883bb1635", "html_url": "https://github.com/rust-lang/rust/commit/d9769ec3834b62318da892925dc24c8883bb1635"}], "stats": {"total": 112, "additions": 53, "deletions": 59}, "files": [{"sha": "a5b8c5f3e5718bed0bde281460e8957db8ce9813", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9c3e6082e71618c088afd93f7a4a9a7708c9dcbd/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c3e6082e71618c088afd93f7a4a9a7708c9dcbd/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=9c3e6082e71618c088afd93f7a4a9a7708c9dcbd", "patch": "@@ -319,17 +319,17 @@ impl Bitv {\n \n         for i in range(0, complete_words) {\n             bitv.storage.push(\n-                (reverse_bits(bytes[i * 4 + 0]) as u32 << 0) |\n-                (reverse_bits(bytes[i * 4 + 1]) as u32 << 8) |\n-                (reverse_bits(bytes[i * 4 + 2]) as u32 << 16) |\n-                (reverse_bits(bytes[i * 4 + 3]) as u32 << 24)\n+                ((reverse_bits(bytes[i * 4 + 0]) as u32) << 0) |\n+                ((reverse_bits(bytes[i * 4 + 1]) as u32) << 8) |\n+                ((reverse_bits(bytes[i * 4 + 2]) as u32) << 16) |\n+                ((reverse_bits(bytes[i * 4 + 3]) as u32) << 24)\n             );\n         }\n \n         if extra_bytes > 0 {\n             let mut last_word = 0u32;\n             for (i, &byte) in bytes[complete_words*4..].iter().enumerate() {\n-                last_word |= reverse_bits(byte) as u32 << (i * 8);\n+                last_word |= (reverse_bits(byte) as u32) << (i * 8);\n             }\n             bitv.storage.push(last_word);\n         }\n@@ -650,7 +650,7 @@ impl Bitv {\n             if offset >= bitv.nbits {\n                 0\n             } else {\n-                bitv[offset] as u8 << (7 - bit)\n+                (bitv[offset] as u8) << (7 - bit)\n             }\n         }\n "}, {"sha": "70feb3e80cc0e60a7884e3f76d063ed7657a08cf", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9c3e6082e71618c088afd93f7a4a9a7708c9dcbd/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c3e6082e71618c088afd93f7a4a9a7708c9dcbd/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=9c3e6082e71618c088afd93f7a4a9a7708c9dcbd", "patch": "@@ -50,19 +50,19 @@ pub struct SipState {\n macro_rules! u8to64_le {\n     ($buf:expr, $i:expr) =>\n     ($buf[0+$i] as u64 |\n-     $buf[1+$i] as u64 << 8 |\n-     $buf[2+$i] as u64 << 16 |\n-     $buf[3+$i] as u64 << 24 |\n-     $buf[4+$i] as u64 << 32 |\n-     $buf[5+$i] as u64 << 40 |\n-     $buf[6+$i] as u64 << 48 |\n-     $buf[7+$i] as u64 << 56);\n+     ($buf[1+$i] as u64) << 8 |\n+     ($buf[2+$i] as u64) << 16 |\n+     ($buf[3+$i] as u64) << 24 |\n+     ($buf[4+$i] as u64) << 32 |\n+     ($buf[5+$i] as u64) << 40 |\n+     ($buf[6+$i] as u64) << 48 |\n+     ($buf[7+$i] as u64) << 56);\n     ($buf:expr, $i:expr, $len:expr) =>\n     ({\n         let mut t = 0;\n         let mut out = 0u64;\n         while t < $len {\n-            out |= $buf[t+$i] as u64 << t*8;\n+            out |= ($buf[t+$i] as u64) << t*8;\n             t += 1;\n         }\n         out"}, {"sha": "e96bf80feef6b937160ce504bf282d18f8ad76e9", "filename": "src/librand/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c3e6082e71618c088afd93f7a4a9a7708c9dcbd/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c3e6082e71618c088afd93f7a4a9a7708c9dcbd/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=9c3e6082e71618c088afd93f7a4a9a7708c9dcbd", "patch": "@@ -74,7 +74,7 @@ pub trait Rng : Sized {\n     /// these two methods. Similarly to `next_u32`, this rarely needs\n     /// to be called directly, prefer `r.gen()` to `r.next_u64()`.\n     fn next_u64(&mut self) -> u64 {\n-        (self.next_u32() as u64 << 32) | (self.next_u32() as u64)\n+        ((self.next_u32() as u64) << 32) | (self.next_u32() as u64)\n     }\n \n     /// Return the next random f32 selected from the half-open"}, {"sha": "eeb858a18870bdfb920faaa9bd0549ce04445a91", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c3e6082e71618c088afd93f7a4a9a7708c9dcbd/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c3e6082e71618c088afd93f7a4a9a7708c9dcbd/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=9c3e6082e71618c088afd93f7a4a9a7708c9dcbd", "patch": "@@ -267,8 +267,8 @@ impl<'a> Parser<'a> {\n                     });\n                     match ipv4 {\n                         Some(Ipv4Addr(a, b, c, d)) => {\n-                            groups[i + 0] = (a as u16 << 8) | (b as u16);\n-                            groups[i + 1] = (c as u16 << 8) | (d as u16);\n+                            groups[i + 0] = ((a as u16) << 8) | (b as u16);\n+                            groups[i + 1] = ((c as u16) << 8) | (d as u16);\n                             return (i + 2, true);\n                         }\n                         _ => {}"}, {"sha": "94a2c9b78faef4323f70217ef9ee219db5f01483", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c3e6082e71618c088afd93f7a4a9a7708c9dcbd/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c3e6082e71618c088afd93f7a4a9a7708c9dcbd/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=9c3e6082e71618c088afd93f7a4a9a7708c9dcbd", "patch": "@@ -56,10 +56,10 @@ pub enum InAddr {\n pub fn ip_to_inaddr(ip: IpAddr) -> InAddr {\n     match ip {\n         Ipv4Addr(a, b, c, d) => {\n-            let ip = (a as u32 << 24) |\n-                     (b as u32 << 16) |\n-                     (c as u32 <<  8) |\n-                     (d as u32 <<  0);\n+            let ip = ((a as u32) << 24) |\n+                     ((b as u32) << 16) |\n+                     ((c as u32) <<  8) |\n+                     ((d as u32) <<  0);\n             In4Addr(libc::in_addr {\n                 s_addr: Int::from_be(ip)\n             })"}, {"sha": "e2f86f8fd39018609562c70101dfc302fb26b4d4", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 10, "deletions": 34, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9c3e6082e71618c088afd93f7a4a9a7708c9dcbd/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c3e6082e71618c088afd93f7a4a9a7708c9dcbd/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9c3e6082e71618c088afd93f7a4a9a7708c9dcbd", "patch": "@@ -681,45 +681,22 @@ impl<'a> Parser<'a> {\n     /// `<` and continue. If a `<` is not seen, return false.\n     ///\n     /// This is meant to be used when parsing generics on a path to get the\n-    /// starting token. The `force` parameter is used to forcefully break up a\n-    /// `<<` token. If `force` is false, then `<<` is only broken when a lifetime\n-    /// shows up next. For example, consider the expression:\n-    ///\n-    ///      foo as bar << test\n-    ///\n-    /// The parser needs to know if `bar <<` is the start of a generic path or if\n-    /// it's a left-shift token. If `test` were a lifetime, then it's impossible\n-    /// for the token to be a left-shift, but if it's not a lifetime, then it's\n-    /// considered a left-shift.\n-    ///\n-    /// The reason for this is that the only current ambiguity with `<<` is when\n-    /// parsing closure types:\n-    ///\n-    ///      foo::<<'a> ||>();\n-    ///      impl Foo<<'a> ||>() { ... }\n-    fn eat_lt(&mut self, force: bool) -> bool {\n+    /// starting token.\n+    fn eat_lt(&mut self) -> bool {\n         match self.token {\n             token::Lt => { self.bump(); true }\n             token::BinOp(token::Shl) => {\n-                let next_lifetime = self.look_ahead(1, |t| match *t {\n-                    token::Lifetime(..) => true,\n-                    _ => false,\n-                });\n-                if force || next_lifetime {\n-                    let span = self.span;\n-                    let lo = span.lo + BytePos(1);\n-                    self.replace_token(token::Lt, lo, span.hi);\n-                    true\n-                } else {\n-                    false\n-                }\n+                let span = self.span;\n+                let lo = span.lo + BytePos(1);\n+                self.replace_token(token::Lt, lo, span.hi);\n+                true\n             }\n             _ => false,\n         }\n     }\n \n     fn expect_lt(&mut self) {\n-        if !self.eat_lt(true) {\n+        if !self.eat_lt() {\n             let found_token = self.this_token_to_string();\n             let token_str = Parser::token_to_string(&token::Lt);\n             self.fatal(format!(\"expected `{}`, found `{}`\",\n@@ -1594,9 +1571,8 @@ impl<'a> Parser<'a> {\n             TyTypeof(e)\n         } else if self.eat_keyword(keywords::Proc) {\n             self.parse_proc_type(Vec::new())\n-        } else if self.check(&token::Lt) {\n+        } else if self.eat_lt() {\n             // QUALIFIED PATH `<TYPE as TRAIT_REF>::item`\n-            self.bump();\n             let self_type = self.parse_ty_sum();\n             self.expect_keyword(keywords::As);\n             let trait_ref = self.parse_trait_ref();\n@@ -1877,7 +1853,7 @@ impl<'a> Parser<'a> {\n             let identifier = self.parse_ident();\n \n             // Parse types, optionally.\n-            let parameters = if self.eat_lt(false) {\n+            let parameters = if self.eat_lt() {\n                 let (lifetimes, types, bindings) = self.parse_generic_values_after_lt();\n \n                 ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n@@ -1938,7 +1914,7 @@ impl<'a> Parser<'a> {\n             }\n \n             // Check for a type segment.\n-            if self.eat_lt(false) {\n+            if self.eat_lt() {\n                 // Consumed `a::b::<`, go look for types\n                 let (lifetimes, types, bindings) = self.parse_generic_values_after_lt();\n                 segments.push(ast::PathSegment {"}, {"sha": "b2aca684314323f4689c3ee3589e8ffb12f9f294", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c3e6082e71618c088afd93f7a4a9a7708c9dcbd/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c3e6082e71618c088afd93f7a4a9a7708c9dcbd/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=9c3e6082e71618c088afd93f7a4a9a7708c9dcbd", "patch": "@@ -149,8 +149,8 @@ pub fn get_time() -> Timespec {\n         // A FILETIME contains a 64-bit value representing the number of\n         // hectonanosecond (100-nanosecond) intervals since 1601-01-01T00:00:00Z.\n         // http://support.microsoft.com/kb/167296/en-us\n-        let ns_since_1601 = ((time.dwHighDateTime as u64 << 32) |\n-                             (time.dwLowDateTime  as u64 <<  0)) / 10;\n+        let ns_since_1601 = (((time.dwHighDateTime as u64) << 32) |\n+                             ((time.dwLowDateTime  as u64) <<  0)) / 10;\n         let ns_since_1970 = ns_since_1601 - NANOSECONDS_FROM_1601_TO_1970;\n \n         ((ns_since_1970 / 1000000) as i64,"}, {"sha": "e17bf025cba7cd7e0b5f258fedef0b65f6ae74a9", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c3e6082e71618c088afd93f7a4a9a7708c9dcbd/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c3e6082e71618c088afd93f7a4a9a7708c9dcbd/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=9c3e6082e71618c088afd93f7a4a9a7708c9dcbd", "patch": "@@ -458,7 +458,7 @@ impl<'a> Iterator<Utf16Item> for Utf16Items<'a> {\n             }\n \n             // all ok, so lets decode it.\n-            let c = ((u - 0xD800) as u32 << 10 | (u2 - 0xDC00) as u32) + 0x1_0000;\n+            let c = (((u - 0xD800) as u32) << 10 | (u2 - 0xDC00) as u32) + 0x1_0000;\n             Some(Utf16Item::ScalarValue(unsafe {mem::transmute(c)}))\n         }\n     }"}, {"sha": "a1386843303651967449e749de5e0e3dae0c595e", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c3e6082e71618c088afd93f7a4a9a7708c9dcbd/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c3e6082e71618c088afd93f7a4a9a7708c9dcbd/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=9c3e6082e71618c088afd93f7a4a9a7708c9dcbd", "patch": "@@ -63,7 +63,7 @@ impl Tables {\n         }\n         let mut table16 = [0;1 << 16];\n         for (i, v) in table16.iter_mut().enumerate() {\n-            *v = table8[i & 255] as u16 << 8 |\n+            *v = (table8[i & 255] as u16) << 8 |\n                  table8[i >> 8]  as u16;\n         }\n         Tables { table8: table8, table16: table16 }"}, {"sha": "8a68711a769fc2e5a5ab1b3e2a13a1b65c669946", "filename": "src/test/run-pass/parse-assoc-type-lt.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9c3e6082e71618c088afd93f7a4a9a7708c9dcbd/src%2Ftest%2Frun-pass%2Fparse-assoc-type-lt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c3e6082e71618c088afd93f7a4a9a7708c9dcbd/src%2Ftest%2Frun-pass%2Fparse-assoc-type-lt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fparse-assoc-type-lt.rs?ref=9c3e6082e71618c088afd93f7a4a9a7708c9dcbd", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_types)]\n+\n+trait Foo {\n+    type T;\n+    fn foo() -> Box<<Self as Foo>::T>;\n+}\n+\n+fn main() {}"}]}