{"sha": "777e810a394bdf8becc308704f7df5ade9321f79", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3N2U4MTBhMzk0YmRmOGJlY2MzMDg3MDRmN2RmNWFkZTkzMjFmNzk=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-03-28T21:32:55Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-03-28T21:32:55Z"}, "message": "Add `for _ in vec![\u2026]` to the `USELESS_VEC` lint", "tree": {"sha": "7a0420c1622e684a533234afc14af6d4346a37a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a0420c1622e684a533234afc14af6d4346a37a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/777e810a394bdf8becc308704f7df5ade9321f79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/777e810a394bdf8becc308704f7df5ade9321f79", "html_url": "https://github.com/rust-lang/rust/commit/777e810a394bdf8becc308704f7df5ade9321f79", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/777e810a394bdf8becc308704f7df5ade9321f79/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11eae72e6fd44935587badad39bfb46ca23b24ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/11eae72e6fd44935587badad39bfb46ca23b24ba", "html_url": "https://github.com/rust-lang/rust/commit/11eae72e6fd44935587badad39bfb46ca23b24ba"}], "stats": {"total": 113, "additions": 65, "deletions": 48}, "files": [{"sha": "10a8a76d7ae99159e9bf62dcb15b68854afe6ecb", "filename": "src/loops.rs", "status": "modified", "additions": 1, "deletions": 25, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/777e810a394bdf8becc308704f7df5ade9321f79/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777e810a394bdf8becc308704f7df5ade9321f79/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=777e810a394bdf8becc308704f7df5ade9321f79", "patch": "@@ -14,7 +14,7 @@ use syntax::ast;\n \n use utils::{snippet, span_lint, get_parent_expr, match_trait_method, match_type, in_external_macro,\n             span_help_and_lint, is_integer_literal, get_enclosing_block, span_lint_and_then,\n-            unsugar_range, walk_ptrs_ty};\n+            unsugar_range, walk_ptrs_ty, recover_for_loop};\n use utils::{BTREEMAP_PATH, HASHMAP_PATH, LL_PATH, OPTION_PATH, RESULT_PATH, VEC_PATH};\n use utils::UnsugaredRange;\n \n@@ -641,30 +641,6 @@ impl<'a> Visitor<'a> for UsedVisitor {\n     }\n }\n \n-/// Recover the essential nodes of a desugared for loop:\n-/// `for pat in arg { body }` becomes `(pat, arg, body)`.\n-fn recover_for_loop(expr: &Expr) -> Option<(&Pat, &Expr, &Expr)> {\n-    if_let_chain! {\n-        [\n-            let ExprMatch(ref iterexpr, ref arms, _) = expr.node,\n-            let ExprCall(_, ref iterargs) = iterexpr.node,\n-            iterargs.len() == 1 && arms.len() == 1 && arms[0].guard.is_none(),\n-            let ExprLoop(ref block, _) = arms[0].body.node,\n-            block.stmts.is_empty(),\n-            let Some(ref loopexpr) = block.expr,\n-            let ExprMatch(_, ref innerarms, MatchSource::ForLoopDesugar) = loopexpr.node,\n-            innerarms.len() == 2 && innerarms[0].pats.len() == 1,\n-            let PatKind::TupleStruct(_, Some(ref somepats)) = innerarms[0].pats[0].node,\n-            somepats.len() == 1\n-        ], {\n-            return Some((&somepats[0],\n-                         &iterargs[0],\n-                         &innerarms[0].body));\n-        }\n-    }\n-    None\n-}\n-\n struct VarVisitor<'v, 't: 'v> {\n     cx: &'v LateContext<'v, 't>, // context reference\n     var: Name, // var name to look for as index"}, {"sha": "300cb8df042dd29e0968aee69153317f95133d85", "filename": "src/utils/mod.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/777e810a394bdf8becc308704f7df5ade9321f79/src%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777e810a394bdf8becc308704f7df5ade9321f79/src%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fmod.rs?ref=777e810a394bdf8becc308704f7df5ade9321f79", "patch": "@@ -800,3 +800,27 @@ pub fn same_tys<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, a: ty::Ty<'tcx>, b: ty::Ty\n     let new_b = b.subst(infcx.tcx, &infcx.parameter_environment.free_substs);\n     infcx.can_equate(&new_a, &new_b).is_ok()\n }\n+\n+/// Recover the essential nodes of a desugared for loop:\n+/// `for pat in arg { body }` becomes `(pat, arg, body)`.\n+pub fn recover_for_loop(expr: &Expr) -> Option<(&Pat, &Expr, &Expr)> {\n+    if_let_chain! {\n+        [\n+            let ExprMatch(ref iterexpr, ref arms, _) = expr.node,\n+            let ExprCall(_, ref iterargs) = iterexpr.node,\n+            iterargs.len() == 1 && arms.len() == 1 && arms[0].guard.is_none(),\n+            let ExprLoop(ref block, _) = arms[0].body.node,\n+            block.stmts.is_empty(),\n+            let Some(ref loopexpr) = block.expr,\n+            let ExprMatch(_, ref innerarms, MatchSource::ForLoopDesugar) = loopexpr.node,\n+            innerarms.len() == 2 && innerarms[0].pats.len() == 1,\n+            let PatKind::TupleStruct(_, Some(ref somepats)) = innerarms[0].pats[0].node,\n+            somepats.len() == 1\n+        ], {\n+            return Some((&somepats[0],\n+                         &iterargs[0],\n+                         &innerarms[0].body));\n+        }\n+    }\n+    None\n+}"}, {"sha": "412ebf396dd3316a7fbe635b0b1b420ee6cdcdfc", "filename": "src/vec.rs", "status": "modified", "additions": 33, "deletions": 23, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/777e810a394bdf8becc308704f7df5ade9321f79/src%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777e810a394bdf8becc308704f7df5ade9321f79/src%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvec.rs?ref=777e810a394bdf8becc308704f7df5ade9321f79", "patch": "@@ -4,7 +4,7 @@ use rustc_front::hir::*;\n use syntax::codemap::Span;\n use syntax::ptr::P;\n use utils::VEC_FROM_ELEM_PATH;\n-use utils::{is_expn_of, match_path, snippet, span_lint_and_then};\n+use utils::{is_expn_of, match_path, recover_for_loop, snippet, span_lint_and_then};\n \n /// **What it does:** This lint warns about using `&vec![..]` when using `&[..]` would be possible.\n ///\n@@ -38,32 +38,42 @@ impl LateLintPass for UselessVec {\n             let TypeVariants::TyRef(_, ref ty) = cx.tcx.expr_ty_adjusted(expr).sty,\n             let TypeVariants::TySlice(..) = ty.ty.sty,\n             let ExprAddrOf(_, ref addressee) = expr.node,\n-            let Some(vec_args) = unexpand_vec(cx, addressee)\n         ], {\n-            let snippet = match vec_args {\n-                VecArgs::Repeat(elem, len) => {\n-                    format!(\"&[{}; {}]\", snippet(cx, elem.span, \"elem\"), snippet(cx, len.span, \"len\")).into()\n-                }\n-                VecArgs::Vec(args) => {\n-                    if let Some(last) = args.iter().last() {\n-                        let span = Span {\n-                            lo: args[0].span.lo,\n-                            hi: last.span.hi,\n-                            expn_id: args[0].span.expn_id,\n-                        };\n+            check_vec_macro(cx, expr, addressee);\n+        }}\n+\n+        // search for `for _ in vec![\u2026]`\n+        if let Some((_, arg, _)) = recover_for_loop(expr) {\n+            check_vec_macro(cx, arg, arg);\n+        }\n+    }\n+}\n+\n+fn check_vec_macro(cx: &LateContext, expr: &Expr, vec: &Expr) {\n+    if let Some(vec_args) = unexpand_vec(cx, vec) {\n+        let snippet = match vec_args {\n+            VecArgs::Repeat(elem, len) => {\n+                format!(\"&[{}; {}]\", snippet(cx, elem.span, \"elem\"), snippet(cx, len.span, \"len\")).into()\n+            }\n+            VecArgs::Vec(args) => {\n+                if let Some(last) = args.iter().last() {\n+                    let span = Span {\n+                        lo: args[0].span.lo,\n+                        hi: last.span.hi,\n+                        expn_id: args[0].span.expn_id,\n+                    };\n \n-                        format!(\"&[{}]\", snippet(cx, span, \"..\")).into()\n-                    }\n-                    else {\n-                        \"&[]\".into()\n-                    }\n+                    format!(\"&[{}]\", snippet(cx, span, \"..\")).into()\n+                }\n+                else {\n+                    \"&[]\".into()\n                 }\n-            };\n+            }\n+        };\n \n-            span_lint_and_then(cx, USELESS_VEC, expr.span, \"useless use of `vec!`\", |db| {\n-                db.span_suggestion(expr.span, \"you can use a slice directly\", snippet);\n-            });\n-        }}\n+        span_lint_and_then(cx, USELESS_VEC, expr.span, \"useless use of `vec!`\", |db| {\n+            db.span_suggestion(expr.span, \"you can use a slice directly\", snippet);\n+        });\n     }\n }\n "}, {"sha": "eda75a2fe8a4f6bfc2edcb86a016f210269d5c9c", "filename": "tests/compile-fail/vec.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/777e810a394bdf8becc308704f7df5ade9321f79/tests%2Fcompile-fail%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777e810a394bdf8becc308704f7df5ade9321f79/tests%2Fcompile-fail%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvec.rs?ref=777e810a394bdf8becc308704f7df5ade9321f79", "patch": "@@ -41,4 +41,11 @@ fn main() {\n     on_vec(&vec![]);\n     on_vec(&vec![1, 2]);\n     on_vec(&vec![1; 2]);\n+\n+    for a in vec![1, 2, 3] {\n+        //~^ ERROR useless use of `vec!`\n+        //~| HELP you can use\n+        //~| SUGGESTION for a in &[1, 2, 3] {\n+        println!(\"{}\", a);\n+    }\n }"}]}