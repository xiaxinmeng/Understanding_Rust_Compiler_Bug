{"sha": "3d2fc456a91e898f735f97f1a9ea79432da4e1a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkMmZjNDU2YTkxZTg5OGY3MzVmOTdmMWE5ZWE3OTQzMmRhNGUxYTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-09T06:25:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-09T06:25:13Z"}, "message": "Auto merge of #53988 - eddyb:issue-53770, r=petrochenkov\n\nrustc_resolve: only prepend CrateRoot to a non-keyword segment.\n\nFixes #53770 by treating `use` paths as absolute in a finer-grained manner, specifically:\n```rust\nuse {a, crate::b, self::c, super::d};\n```\nUsed to be interpreted as if it were (when `uniform_paths` is not enabled):\n```rust\nuse ::{a, crate::b, self::c, super::d};\n```\nWith this PR, the `CrateRoot` pseudo-keyword indicating an absolute path is only inserted when the first path segment is found (if it's not a keyword), i.e. the example behaves like:\n```rust\nuse {::a, crate::b, self::c, super::d};\n```\nThis should (finally) make `use {path};` fully equivalent to `use path;`.\n\nr? @petrochenkov cc @cramertj @joshtriplett @nikomatsakis", "tree": {"sha": "b7620e25ede29068f275795f65610a116f215a70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7620e25ede29068f275795f65610a116f215a70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d2fc456a91e898f735f97f1a9ea79432da4e1a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d2fc456a91e898f735f97f1a9ea79432da4e1a5", "html_url": "https://github.com/rust-lang/rust/commit/3d2fc456a91e898f735f97f1a9ea79432da4e1a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d2fc456a91e898f735f97f1a9ea79432da4e1a5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dac76020a5a33fa723d578043e422455e598620b", "url": "https://api.github.com/repos/rust-lang/rust/commits/dac76020a5a33fa723d578043e422455e598620b", "html_url": "https://github.com/rust-lang/rust/commit/dac76020a5a33fa723d578043e422455e598620b"}, {"sha": "e0e7cf303ba2fd63763e6d99a9d67dced1fac8ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0e7cf303ba2fd63763e6d99a9d67dced1fac8ab", "html_url": "https://github.com/rust-lang/rust/commit/e0e7cf303ba2fd63763e6d99a9d67dced1fac8ab"}], "stats": {"total": 92, "additions": 49, "deletions": 43}, "files": [{"sha": "92a9057d96ebccd37b1a8fdb663fe5c9977273bf", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 37, "deletions": 41, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/3d2fc456a91e898f735f97f1a9ea79432da4e1a5/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d2fc456a91e898f735f97f1a9ea79432da4e1a5/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=3d2fc456a91e898f735f97f1a9ea79432da4e1a5", "patch": "@@ -120,26 +120,48 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         use_tree: &ast::UseTree,\n         id: NodeId,\n         vis: ty::Visibility,\n-        prefix: &ast::Path,\n+        parent_prefix: &[Ident],\n         mut uniform_paths_canary_emitted: bool,\n         nested: bool,\n         item: &Item,\n         expansion: Mark,\n     ) {\n-        debug!(\"build_reduced_graph_for_use_tree(prefix={:?}, \\\n+        debug!(\"build_reduced_graph_for_use_tree(parent_prefix={:?}, \\\n                 uniform_paths_canary_emitted={}, \\\n                 use_tree={:?}, nested={})\",\n-               prefix, uniform_paths_canary_emitted, use_tree, nested);\n+               parent_prefix, uniform_paths_canary_emitted, use_tree, nested);\n \n         let is_prelude = attr::contains_name(&item.attrs, \"prelude_import\");\n-        let path = &use_tree.prefix;\n+        let uniform_paths =\n+            self.session.rust_2018() &&\n+            self.session.features_untracked().uniform_paths;\n+\n+        let prefix_iter = || parent_prefix.iter().cloned()\n+            .chain(use_tree.prefix.segments.iter().map(|seg| seg.ident));\n+        let prefix_start = prefix_iter().nth(0);\n+        let starts_with_non_keyword = prefix_start.map_or(false, |ident| {\n+            !ident.is_path_segment_keyword()\n+        });\n+\n+        // Imports are resolved as global by default, prepend `CrateRoot`,\n+        // unless `#![feature(uniform_paths)]` is enabled.\n+        let inject_crate_root =\n+            !uniform_paths &&\n+            match use_tree.kind {\n+                // HACK(eddyb) special-case `use *` to mean `use ::*`.\n+                ast::UseTreeKind::Glob if prefix_start.is_none() => true,\n+                _ => starts_with_non_keyword,\n+            };\n+        let root = if inject_crate_root {\n+            let span = use_tree.prefix.span.shrink_to_lo();\n+            Some(Ident::new(keywords::CrateRoot.name(), span))\n+        } else {\n+            None\n+        };\n \n-        let mut module_path: Vec<_> = prefix.segments.iter()\n-            .chain(path.segments.iter())\n-            .map(|seg| seg.ident)\n-            .collect();\n+        let prefix: Vec<_> = root.into_iter().chain(prefix_iter()).collect();\n \n-        debug!(\"build_reduced_graph_for_use_tree: module_path={:?}\", module_path);\n+        debug!(\"build_reduced_graph_for_use_tree: prefix={:?}\", prefix);\n \n         // `#[feature(uniform_paths)]` allows an unqualified import path,\n         // e.g. `use x::...;` to resolve not just globally (`use ::x::...;`)\n@@ -172,15 +194,10 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         // ergonomically unacceptable.\n         let emit_uniform_paths_canary =\n             !uniform_paths_canary_emitted &&\n-            module_path.get(0).map_or(false, |ident| {\n-                !ident.is_path_segment_keyword()\n-            });\n+            uniform_paths &&\n+            starts_with_non_keyword;\n         if emit_uniform_paths_canary {\n-            // Relative paths should only get here if the feature-gate is on.\n-            assert!(self.session.rust_2018() &&\n-                    self.session.features_untracked().uniform_paths);\n-\n-            let source = module_path[0];\n+            let source = prefix_start.unwrap();\n \n             // HACK(eddyb) For `use x::{self, ...};`, use the ID of the\n             // `self` nested import for the canary. This allows the\n@@ -256,6 +273,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         match use_tree.kind {\n             ast::UseTreeKind::Simple(rename, ..) => {\n                 let mut ident = use_tree.ident();\n+                let mut module_path = prefix;\n                 let mut source = module_path.pop().unwrap();\n                 let mut type_ns_only = false;\n \n@@ -354,7 +372,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     max_vis: Cell::new(ty::Visibility::Invisible),\n                 };\n                 self.add_import_directive(\n-                    module_path,\n+                    prefix,\n                     subclass,\n                     use_tree.span,\n                     id,\n@@ -366,13 +384,6 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 );\n             }\n             ast::UseTreeKind::Nested(ref items) => {\n-                let prefix = ast::Path {\n-                    segments: module_path.into_iter()\n-                        .map(|ident| ast::PathSegment::from_ident(ident))\n-                        .collect(),\n-                    span: path.span,\n-                };\n-\n                 // Ensure there is at most one `self` in the list\n                 let self_spans = items.iter().filter_map(|&(ref use_tree, _)| {\n                     if let ast::UseTreeKind::Simple(..) = use_tree.kind {\n@@ -422,28 +433,13 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n         match item.node {\n             ItemKind::Use(ref use_tree) => {\n-                let uniform_paths =\n-                    self.session.rust_2018() &&\n-                    self.session.features_untracked().uniform_paths;\n-                // Imports are resolved as global by default, add starting root segment.\n-                let root = if !uniform_paths {\n-                    use_tree.prefix.make_root()\n-                } else {\n-                    // Except when `#![feature(uniform_paths)]` is on.\n-                    None\n-                };\n-                let prefix = ast::Path {\n-                    segments: root.into_iter().collect(),\n-                    span: use_tree.span,\n-                };\n-\n                 self.build_reduced_graph_for_use_tree(\n                     use_tree,\n                     item.id,\n                     use_tree,\n                     item.id,\n                     vis,\n-                    &prefix,\n+                    &[],\n                     false, // uniform_paths_canary_emitted\n                     false,\n                     item,"}, {"sha": "71904acae724d8c5b7d5984dfbf2b26afde3417d", "filename": "src/test/ui/run-pass/rfcs/rfc-2126-crate-paths/crate-path-absolute.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3d2fc456a91e898f735f97f1a9ea79432da4e1a5/src%2Ftest%2Fui%2Frun-pass%2Frfcs%2Frfc-2126-crate-paths%2Fcrate-path-absolute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d2fc456a91e898f735f97f1a9ea79432da4e1a5/src%2Ftest%2Fui%2Frun-pass%2Frfcs%2Frfc-2126-crate-paths%2Fcrate-path-absolute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frun-pass%2Frfcs%2Frfc-2126-crate-paths%2Fcrate-path-absolute.rs?ref=3d2fc456a91e898f735f97f1a9ea79432da4e1a5", "patch": "@@ -23,8 +23,7 @@ mod m {\n     pub(in crate::m) struct S;\n }\n \n-mod n\n-{\n+mod n {\n     use crate::m::f;\n     use crate as root;\n     pub fn check() {\n@@ -34,9 +33,20 @@ mod n\n     }\n }\n \n+mod p {\n+    use {super::f, crate::m::g, self::root::m::h};\n+    use crate as root;\n+    pub fn check() {\n+        assert_eq!(f(), 1);\n+        assert_eq!(g(), 2);\n+        assert_eq!(h(), 3);\n+    }\n+}\n+\n fn main() {\n     assert_eq!(f(), 1);\n     assert_eq!(crate::m::g(), 2);\n     assert_eq!(root::m::h(), 3);\n     n::check();\n+    p::check();\n }"}]}