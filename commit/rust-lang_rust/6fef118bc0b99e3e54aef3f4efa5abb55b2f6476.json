{"sha": "6fef118bc0b99e3e54aef3f4efa5abb55b2f6476", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmZWYxMThiYzBiOTllM2U1NGFlZjNmNGVmYTVhYmI1NWIyZjY0NzY=", "commit": {"author": {"name": "Oliver 'ker' Schneider", "email": "rust19446194516@oli-obk.de", "date": "2016-01-16T15:03:09Z"}, "committer": {"name": "Oliver 'ker' Schneider", "email": "rust19446194516@oli-obk.de", "date": "2016-01-16T15:03:09Z"}, "message": "use a newtype for the variant discriminant instead of u64", "tree": {"sha": "2296e5a266a2287d8f1ca57a2b5fe490cd45e08b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2296e5a266a2287d8f1ca57a2b5fe490cd45e08b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6fef118bc0b99e3e54aef3f4efa5abb55b2f6476", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6fef118bc0b99e3e54aef3f4efa5abb55b2f6476", "html_url": "https://github.com/rust-lang/rust/commit/6fef118bc0b99e3e54aef3f4efa5abb55b2f6476", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6fef118bc0b99e3e54aef3f4efa5abb55b2f6476/comments", "author": null, "committer": null, "parents": [{"sha": "8e12365570c4a9e781298058d6394705ac648a3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e12365570c4a9e781298058d6394705ac648a3b", "html_url": "https://github.com/rust-lang/rust/commit/8e12365570c4a9e781298058d6394705ac648a3b"}], "stats": {"total": 274, "additions": 173, "deletions": 101}, "files": [{"sha": "6c1a31738afb960d679513a13b14087c20a46671", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6fef118bc0b99e3e54aef3f4efa5abb55b2f6476/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fef118bc0b99e3e54aef3f4efa5abb55b2f6476/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=6fef118bc0b99e3e54aef3f4efa5abb55b2f6476", "patch": "@@ -215,6 +215,7 @@ use trans::expr::{self, Dest};\n use trans::monomorphize;\n use trans::tvec;\n use trans::type_of;\n+use trans::Disr;\n use middle::ty::{self, Ty};\n use session::config::NoDebugInfo;\n use util::common::indenter;\n@@ -249,7 +250,7 @@ impl<'a> ConstantExpr<'a> {\n enum Opt<'a, 'tcx> {\n     ConstantValue(ConstantExpr<'a>, DebugLoc),\n     ConstantRange(ConstantExpr<'a>, ConstantExpr<'a>, DebugLoc),\n-    Variant(ty::Disr, Rc<adt::Repr<'tcx>>, DefId, DebugLoc),\n+    Variant(Disr, Rc<adt::Repr<'tcx>>, DefId, DebugLoc),\n     SliceLengthEqual(usize, DebugLoc),\n     SliceLengthGreaterOrEqual(/* prefix length */ usize,\n                               /* suffix length */ usize,\n@@ -670,7 +671,7 @@ fn get_branches<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 match opt_def {\n                     Some(def::DefVariant(enum_id, var_id, _)) => {\n                         let variant = tcx.lookup_adt_def(enum_id).variant_with_id(var_id);\n-                        Variant(variant.disr_val,\n+                        Variant(Disr::from(variant.disr_val),\n                                 adt::represent_node(bcx, cur.id),\n                                 var_id,\n                                 debug_loc)\n@@ -704,7 +705,7 @@ struct ExtractedBlock<'blk, 'tcx: 'blk> {\n \n fn extract_variant_args<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     repr: &adt::Repr<'tcx>,\n-                                    disr_val: ty::Disr,\n+                                    disr_val: Disr,\n                                     val: MatchInput)\n                                     -> ExtractedBlock<'blk, 'tcx> {\n     let _icx = push_ctxt(\"match::extract_variant_args\");\n@@ -1189,7 +1190,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     };\n     let adt_vals = if any_irrefutable_adt_pat(bcx.tcx(), m, col) {\n         let repr = adt::represent_type(bcx.ccx(), left_ty);\n-        let arg_count = adt::num_args(&*repr, 0);\n+        let arg_count = adt::num_args(&*repr, Disr(0));\n         let (arg_count, struct_val) = if type_is_sized(bcx.tcx(), left_ty) {\n             (arg_count, val.val)\n         } else {\n@@ -1201,7 +1202,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         };\n         let mut field_vals: Vec<ValueRef> = (0..arg_count).map(|ix|\n             // By definition, these are all sized\n-            adt::trans_field_ptr(bcx, &*repr, adt::MaybeSizedValue::sized(struct_val), 0, ix)\n+            adt::trans_field_ptr(bcx, &*repr, adt::MaybeSizedValue::sized(struct_val), Disr(0), ix)\n         ).collect();\n \n         match left_ty.sty {\n@@ -1217,7 +1218,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 let meta = Load(bcx, expr::get_meta(bcx, val.val));\n                 let struct_val = adt::MaybeSizedValue::unsized_(struct_val, meta);\n \n-                let data = adt::trans_field_ptr(bcx, &*repr, struct_val, 0, arg_count);\n+                let data = adt::trans_field_ptr(bcx, &*repr, struct_val, Disr(0), arg_count);\n                 Store(bcx, data, expr::get_dataptr(bcx, scratch));\n                 Store(bcx, meta, expr::get_meta(bcx, scratch));\n                 field_vals.push(scratch);\n@@ -1855,7 +1856,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     let vinfo = ccx.tcx().lookup_adt_def(enum_id).variant_with_id(var_id);\n                     let args = extract_variant_args(bcx,\n                                                     &*repr,\n-                                                    vinfo.disr_val,\n+                                                    Disr::from(vinfo.disr_val),\n                                                     val);\n                     if let Some(ref sub_pat) = *sub_pats {\n                         for (i, &argval) in args.vals.iter().enumerate() {\n@@ -1878,7 +1879,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                             let val = adt::MaybeSizedValue::sized(val.val);\n                             for (i, elem) in elems.iter().enumerate() {\n                                 let fldptr = adt::trans_field_ptr(bcx, &*repr,\n-                                                                  val, 0, i);\n+                                                                  val, Disr(0), i);\n                                 bcx = bind_irrefutable_pat(\n                                     bcx,\n                                     &**elem,\n@@ -1937,7 +1938,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let repr = adt::represent_node(bcx, pat.id);\n             let val = adt::MaybeSizedValue::sized(val.val);\n             for (i, elem) in elems.iter().enumerate() {\n-                let fldptr = adt::trans_field_ptr(bcx, &*repr, val, 0, i);\n+                let fldptr = adt::trans_field_ptr(bcx, &*repr, val, Disr(0), i);\n                 bcx = bind_irrefutable_pat(\n                     bcx,\n                     &**elem,"}, {"sha": "59487c0362c89f10d4bdfdb5db6b473b82272d3d", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 47, "deletions": 41, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/6fef118bc0b99e3e54aef3f4efa5abb55b2f6476/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fef118bc0b99e3e54aef3f4efa5abb55b2f6476/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=6fef118bc0b99e3e54aef3f4efa5abb55b2f6476", "patch": "@@ -42,6 +42,7 @@\n //!   taken to it, implementing them for Rust seems difficult.\n \n pub use self::Repr::*;\n+use super::Disr;\n \n use std;\n use std::rc::Rc;\n@@ -50,7 +51,6 @@ use llvm::{ValueRef, True, IntEQ, IntNE};\n use back::abi::FAT_PTR_ADDR;\n use middle::subst;\n use middle::ty::{self, Ty};\n-use middle::ty::Disr;\n use syntax::ast;\n use syntax::attr;\n use syntax::attr::IntType;\n@@ -308,20 +308,20 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             if !dtor && cases.iter().all(|c| c.tys.is_empty()) {\n                 // All bodies empty -> intlike\n-                let discrs: Vec<u64> = cases.iter().map(|c| c.discr).collect();\n+                let discrs: Vec<_> = cases.iter().map(|c| Disr::from(c.discr)).collect();\n                 let bounds = IntBounds {\n-                    ulo: *discrs.iter().min().unwrap(),\n-                    uhi: *discrs.iter().max().unwrap(),\n-                    slo: discrs.iter().map(|n| *n as i64).min().unwrap(),\n-                    shi: discrs.iter().map(|n| *n as i64).max().unwrap()\n+                    ulo: discrs.iter().min().unwrap().0,\n+                    uhi: discrs.iter().max().unwrap().0,\n+                    slo: discrs.iter().map(|n| n.0 as i64).min().unwrap(),\n+                    shi: discrs.iter().map(|n| n.0 as i64).max().unwrap()\n                 };\n                 return mk_cenum(cx, hint, &bounds);\n             }\n \n             // Since there's at least one\n             // non-empty body, explicit discriminants should have\n             // been rejected by a checker before this point.\n-            if !cases.iter().enumerate().all(|(i,c)| c.discr == (i as Disr)) {\n+            if !cases.iter().enumerate().all(|(i,c)| c.discr == Disr::from(i)) {\n                 cx.sess().bug(&format!(\"non-C-like enum {} with specified \\\n                                         discriminants\",\n                                        cx.tcx().item_path_str(def.did)));\n@@ -347,7 +347,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                         match cases[discr].find_ptr(cx) {\n                             Some(ref df) if df.len() == 1 && st.fields.len() == 1 => {\n                                 return RawNullablePointer {\n-                                    nndiscr: discr as Disr,\n+                                    nndiscr: Disr::from(discr),\n                                     nnty: st.fields[0],\n                                     nullfields: cases[1 - discr].tys.clone()\n                                 };\n@@ -356,7 +356,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                 discrfield.push(0);\n                                 discrfield.reverse();\n                                 return StructWrappedNullablePointer {\n-                                    nndiscr: discr as Disr,\n+                                    nndiscr: Disr::from(discr),\n                                     nonnull: st,\n                                     discrfield: discrfield,\n                                     nullfields: cases[1 - discr].tys.clone()\n@@ -564,7 +564,7 @@ fn get_cases<'tcx>(tcx: &ty::ctxt<'tcx>,\n         let field_tys = vi.fields.iter().map(|field| {\n             monomorphize::field_ty(tcx, substs, field)\n         }).collect();\n-        Case { discr: vi.disr_val, tys: field_tys }\n+        Case { discr: Disr::from(vi.disr_val), tys: field_tys }\n     }).collect()\n }\n \n@@ -605,8 +605,8 @@ fn mk_cenum<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                       -> Repr<'tcx> {\n     let it = range_to_inttype(cx, hint, bounds);\n     match it {\n-        attr::SignedInt(_) => CEnum(it, bounds.slo as Disr, bounds.shi as Disr),\n-        attr::UnsignedInt(_) => CEnum(it, bounds.ulo, bounds.uhi)\n+        attr::SignedInt(_) => CEnum(it, Disr(bounds.slo as u64), Disr(bounds.shi as u64)),\n+        attr::UnsignedInt(_) => CEnum(it, Disr(bounds.ulo), Disr(bounds.uhi))\n     }\n }\n \n@@ -923,11 +923,11 @@ pub fn trans_get_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n         CEnum(ity, min, max) => load_discr(bcx, ity, scrutinee, min, max),\n         General(ity, ref cases, _) => {\n             let ptr = StructGEP(bcx, scrutinee, 0);\n-            load_discr(bcx, ity, ptr, 0, (cases.len() - 1) as Disr)\n+            load_discr(bcx, ity, ptr, Disr(0), Disr(cases.len() as u64 - 1))\n         }\n         Univariant(..) => C_u8(bcx.ccx(), 0),\n         RawNullablePointer { nndiscr, nnty, .. } =>  {\n-            let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n+            let cmp = if nndiscr == Disr(0) { IntEQ } else { IntNE };\n             let llptrty = type_of::sizing_type_of(bcx.ccx(), nnty);\n             ICmp(bcx, cmp, Load(bcx, scrutinee), C_null(llptrty), DebugLoc::None)\n         }\n@@ -945,7 +945,7 @@ fn struct_wrapped_nullable_bitdiscr(bcx: Block, nndiscr: Disr, discrfield: &Disc\n                                     scrutinee: ValueRef) -> ValueRef {\n     let llptrptr = GEPi(bcx, scrutinee, &discrfield[..]);\n     let llptr = Load(bcx, llptrptr);\n-    let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n+    let cmp = if nndiscr == Disr(0) { IntEQ } else { IntNE };\n     ICmp(bcx, cmp, llptr, C_null(val_ty(llptr)), DebugLoc::None)\n }\n \n@@ -957,10 +957,10 @@ fn load_discr(bcx: Block, ity: IntType, ptr: ValueRef, min: Disr, max: Disr)\n     let bits = machine::llbitsize_of_real(bcx.ccx(), llty);\n     assert!(bits <= 64);\n     let  bits = bits as usize;\n-    let mask = (!0u64 >> (64 - bits)) as Disr;\n+    let mask = Disr(!0u64 >> (64 - bits));\n     // For a (max) discr of -1, max will be `-1 as usize`, which overflows.\n     // However, that is fine here (it would still represent the full range),\n-    if (max.wrapping_add(1)) & mask == min & mask {\n+    if max.wrapping_add(Disr(1)) & mask == min & mask {\n         // i.e., if the range is everything.  The lo==hi case would be\n         // rejected by the LLVM verifier (it would mean either an\n         // empty set, which is impossible, or the entire range of the\n@@ -969,7 +969,7 @@ fn load_discr(bcx: Block, ity: IntType, ptr: ValueRef, min: Disr, max: Disr)\n     } else {\n         // llvm::ConstantRange can deal with ranges that wrap around,\n         // so an overflow on (max + 1) is fine.\n-        LoadRangeAssert(bcx, ptr, min, (max.wrapping_add(1)), /* signed: */ True)\n+        LoadRangeAssert(bcx, ptr, min, max.wrapping_add(Disr(1)), /* signed: */ True)\n     }\n }\n \n@@ -981,18 +981,18 @@ pub fn trans_case<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr, discr: Disr)\n                               -> ValueRef {\n     match *r {\n         CEnum(ity, _, _) => {\n-            C_integral(ll_inttype(bcx.ccx(), ity), discr as u64, true)\n+            C_integral(ll_inttype(bcx.ccx(), ity), discr.0, true)\n         }\n         General(ity, _, _) => {\n-            C_integral(ll_inttype(bcx.ccx(), ity), discr as u64, true)\n+            C_integral(ll_inttype(bcx.ccx(), ity), discr.0, true)\n         }\n         Univariant(..) => {\n             bcx.ccx().sess().bug(\"no cases for univariants or structs\")\n         }\n         RawNullablePointer { .. } |\n         StructWrappedNullablePointer { .. } => {\n-            assert!(discr == 0 || discr == 1);\n-            C_bool(bcx.ccx(), discr != 0)\n+            assert!(discr == Disr(0) || discr == Disr(1));\n+            C_bool(bcx.ccx(), discr != Disr(0))\n         }\n     }\n }\n@@ -1004,20 +1004,20 @@ pub fn trans_set_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n     match *r {\n         CEnum(ity, min, max) => {\n             assert_discr_in_range(ity, min, max, discr);\n-            Store(bcx, C_integral(ll_inttype(bcx.ccx(), ity), discr as u64, true),\n+            Store(bcx, C_integral(ll_inttype(bcx.ccx(), ity), discr.0, true),\n                   val);\n         }\n         General(ity, ref cases, dtor) => {\n             if dtor_active(dtor) {\n                 let ptr = trans_field_ptr(bcx, r, MaybeSizedValue::sized(val), discr,\n-                                          cases[discr as usize].fields.len() - 2);\n+                                          cases[discr.0 as usize].fields.len() - 2);\n                 Store(bcx, C_u8(bcx.ccx(), DTOR_NEEDED), ptr);\n             }\n-            Store(bcx, C_integral(ll_inttype(bcx.ccx(), ity), discr as u64, true),\n+            Store(bcx, C_integral(ll_inttype(bcx.ccx(), ity), discr.0, true),\n                   StructGEP(bcx, val, 0));\n         }\n         Univariant(ref st, dtor) => {\n-            assert_eq!(discr, 0);\n+            assert_eq!(discr, Disr(0));\n             if dtor_active(dtor) {\n                 Store(bcx, C_u8(bcx.ccx(), DTOR_NEEDED),\n                       StructGEP(bcx, val, st.fields.len() - 1));\n@@ -1041,8 +1041,14 @@ pub fn trans_set_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n \n fn assert_discr_in_range(ity: IntType, min: Disr, max: Disr, discr: Disr) {\n     match ity {\n-        attr::UnsignedInt(_) => assert!(min <= discr && discr <= max),\n-        attr::SignedInt(_) => assert!(min as i64 <= discr as i64 && discr as i64 <= max as i64)\n+        attr::UnsignedInt(_) => {\n+            assert!(min <= discr);\n+            assert!(discr <= max)\n+        },\n+        attr::SignedInt(_) => {\n+            assert!(min.0 as i64 <= discr.0 as i64);\n+            assert!(discr.0 as i64 <= max.0 as i64);\n+        },\n     }\n }\n \n@@ -1052,11 +1058,11 @@ pub fn num_args(r: &Repr, discr: Disr) -> usize {\n     match *r {\n         CEnum(..) => 0,\n         Univariant(ref st, dtor) => {\n-            assert_eq!(discr, 0);\n+            assert_eq!(discr, Disr(0));\n             st.fields.len() - (if dtor_active(dtor) { 1 } else { 0 })\n         }\n         General(_, ref cases, dtor) => {\n-            cases[discr as usize].fields.len() - 1 - (if dtor_active(dtor) { 1 } else { 0 })\n+            cases[discr.0 as usize].fields.len() - 1 - (if dtor_active(dtor) { 1 } else { 0 })\n         }\n         RawNullablePointer { nndiscr, ref nullfields, .. } => {\n             if discr == nndiscr { 1 } else { nullfields.len() }\n@@ -1079,11 +1085,11 @@ pub fn trans_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n             bcx.ccx().sess().bug(\"element access in C-like enum\")\n         }\n         Univariant(ref st, _dtor) => {\n-            assert_eq!(discr, 0);\n+            assert_eq!(discr, Disr(0));\n             struct_field_ptr(bcx, st, val, ix, false)\n         }\n         General(_, ref cases, _) => {\n-            struct_field_ptr(bcx, &cases[discr as usize], val, ix + 1, true)\n+            struct_field_ptr(bcx, &cases[discr.0 as usize], val, ix + 1, true)\n         }\n         RawNullablePointer { nndiscr, ref nullfields, .. } |\n         StructWrappedNullablePointer { nndiscr, ref nullfields, .. } if discr != nndiscr => {\n@@ -1326,20 +1332,20 @@ pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>, discr\n         CEnum(ity, min, max) => {\n             assert_eq!(vals.len(), 0);\n             assert_discr_in_range(ity, min, max, discr);\n-            C_integral(ll_inttype(ccx, ity), discr as u64, true)\n+            C_integral(ll_inttype(ccx, ity), discr.0, true)\n         }\n         General(ity, ref cases, _) => {\n-            let case = &cases[discr as usize];\n+            let case = &cases[discr.0 as usize];\n             let (max_sz, _) = union_size_and_align(&cases[..]);\n-            let lldiscr = C_integral(ll_inttype(ccx, ity), discr as u64, true);\n+            let lldiscr = C_integral(ll_inttype(ccx, ity), discr.0 as u64, true);\n             let mut f = vec![lldiscr];\n             f.extend_from_slice(vals);\n             let mut contents = build_const_struct(ccx, case, &f[..]);\n             contents.extend_from_slice(&[padding(ccx, max_sz - case.size)]);\n             C_struct(ccx, &contents[..], false)\n         }\n         Univariant(ref st, _dro) => {\n-            assert!(discr == 0);\n+            assert_eq!(discr, Disr(0));\n             let contents = build_const_struct(ccx, st, vals);\n             C_struct(ccx, &contents[..], st.packed)\n         }\n@@ -1444,17 +1450,17 @@ pub fn const_get_discrim(ccx: &CrateContext, r: &Repr, val: ValueRef) -> Disr {\n     match *r {\n         CEnum(ity, _, _) => {\n             match ity {\n-                attr::SignedInt(..) => const_to_int(val) as Disr,\n-                attr::UnsignedInt(..) => const_to_uint(val) as Disr\n+                attr::SignedInt(..) => Disr(const_to_int(val) as u64),\n+                attr::UnsignedInt(..) => Disr(const_to_uint(val)),\n             }\n         }\n         General(ity, _, _) => {\n             match ity {\n-                attr::SignedInt(..) => const_to_int(const_get_elt(ccx, val, &[0])) as Disr,\n-                attr::UnsignedInt(..) => const_to_uint(const_get_elt(ccx, val, &[0])) as Disr\n+                attr::SignedInt(..) => Disr(const_to_int(const_get_elt(ccx, val, &[0])) as u64),\n+                attr::UnsignedInt(..) => Disr(const_to_uint(const_get_elt(ccx, val, &[0])))\n             }\n         }\n-        Univariant(..) => 0,\n+        Univariant(..) => Disr(0),\n         RawNullablePointer { .. } | StructWrappedNullablePointer { .. } => {\n             ccx.sess().bug(\"const discrim access of non c-like enum\")\n         }"}, {"sha": "3909cb2df23647a70a44faabae1e4a05c590013f", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6fef118bc0b99e3e54aef3f4efa5abb55b2f6476/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fef118bc0b99e3e54aef3f4efa5abb55b2f6476/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=6fef118bc0b99e3e54aef3f4efa5abb55b2f6476", "patch": "@@ -85,6 +85,7 @@ use trans::type_::Type;\n use trans::type_of;\n use trans::type_of::*;\n use trans::value::Value;\n+use trans::Disr;\n use util::common::indenter;\n use util::sha2::Sha256;\n use util::nodemap::{NodeMap, NodeSet};\n@@ -489,7 +490,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n         for (i, field) in variant.fields.iter().enumerate() {\n             let arg = monomorphize::field_ty(tcx, substs, field);\n             cx = f(cx,\n-                   adt::trans_field_ptr(cx, repr, av, variant.disr_val, i),\n+                   adt::trans_field_ptr(cx, repr, av, Disr::from(variant.disr_val), i),\n                    arg);\n         }\n         return cx;\n@@ -509,7 +510,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n             let repr = adt::represent_type(cx.ccx(), t);\n             let VariantInfo { fields, discr } = VariantInfo::from_ty(cx.tcx(), t, None);\n             for (i, &Field(_, field_ty)) in fields.iter().enumerate() {\n-                let llfld_a = adt::trans_field_ptr(cx, &*repr, value, discr, i);\n+                let llfld_a = adt::trans_field_ptr(cx, &*repr, value, Disr::from(discr), i);\n \n                 let val = if common::type_is_sized(cx.tcx(), field_ty) {\n                     llfld_a\n@@ -525,7 +526,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n         ty::TyClosure(_, ref substs) => {\n             let repr = adt::represent_type(cx.ccx(), t);\n             for (i, upvar_ty) in substs.upvar_tys.iter().enumerate() {\n-                let llupvar = adt::trans_field_ptr(cx, &*repr, value, 0, i);\n+                let llupvar = adt::trans_field_ptr(cx, &*repr, value, Disr(0), i);\n                 cx = f(cx, llupvar, upvar_ty);\n             }\n         }\n@@ -541,7 +542,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n         ty::TyTuple(ref args) => {\n             let repr = adt::represent_type(cx.ccx(), t);\n             for (i, arg) in args.iter().enumerate() {\n-                let llfld_a = adt::trans_field_ptr(cx, &*repr, value, 0, i);\n+                let llfld_a = adt::trans_field_ptr(cx, &*repr, value, Disr(0), i);\n                 cx = f(cx, llfld_a, *arg);\n             }\n         }\n@@ -588,7 +589,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n                         let variant_cx = fcx.new_temp_block(&format!(\"enum-iter-variant-{}\",\n                                                                      &variant.disr_val\n                                                                              .to_string()));\n-                        let case_val = adt::trans_case(cx, &*repr, variant.disr_val);\n+                        let case_val = adt::trans_case(cx, &*repr, Disr::from(variant.disr_val));\n                         AddCase(llswitch, case_val, variant_cx.llbb);\n                         let variant_cx = iter_variant(variant_cx,\n                                                       &*repr,\n@@ -720,8 +721,8 @@ pub fn coerce_unsized_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     continue;\n                 }\n \n-                let src_f = adt::trans_field_ptr(bcx, &src_repr, src, 0, i);\n-                let dst_f = adt::trans_field_ptr(bcx, &dst_repr, dst, 0, i);\n+                let src_f = adt::trans_field_ptr(bcx, &src_repr, src, Disr(0), i);\n+                let dst_f = adt::trans_field_ptr(bcx, &dst_repr, dst, Disr(0), i);\n                 if src_fty == dst_fty {\n                     memcpy_ty(bcx, dst_f, src_f, src_fty);\n                 } else {\n@@ -1022,11 +1023,11 @@ pub fn load_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>, ptr: ValueRef, t: Ty<'tcx>) ->\n     }\n \n     let val = if t.is_bool() {\n-        LoadRangeAssert(cx, ptr, 0, 2, llvm::False)\n+        LoadRangeAssert(cx, ptr, Disr(0), Disr(2), llvm::False)\n     } else if t.is_char() {\n         // a char is a Unicode codepoint, and so takes values from 0\n         // to 0x10FFFF inclusive only.\n-        LoadRangeAssert(cx, ptr, 0, 0x10FFFF + 1, llvm::False)\n+        LoadRangeAssert(cx, ptr, Disr(0), Disr(0x10FFFF + 1), llvm::False)\n     } else if (t.is_region_ptr() || t.is_unique()) && !common::type_is_fat_ptr(cx.tcx(), t) {\n         LoadNonNull(cx, ptr)\n     } else {\n@@ -2111,7 +2112,7 @@ pub fn trans_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n pub fn trans_enum_variant<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                     ctor_id: ast::NodeId,\n-                                    disr: ty::Disr,\n+                                    disr: Disr,\n                                     param_substs: &'tcx Substs<'tcx>,\n                                     llfndecl: ValueRef) {\n     let _icx = push_ctxt(\"trans_enum_variant\");\n@@ -2121,7 +2122,7 @@ pub fn trans_enum_variant<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                                  ctor_ty: Ty<'tcx>,\n-                                                 disr: ty::Disr,\n+                                                 disr: Disr,\n                                                  args: callee::CallArgs,\n                                                  dest: expr::Dest,\n                                                  debug_loc: DebugLoc)\n@@ -2197,12 +2198,12 @@ pub fn trans_tuple_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                     llfndecl: ValueRef) {\n     let _icx = push_ctxt(\"trans_tuple_struct\");\n \n-    trans_enum_variant_or_tuple_like_struct(ccx, ctor_id, 0, param_substs, llfndecl);\n+    trans_enum_variant_or_tuple_like_struct(ccx, ctor_id, Disr(0), param_substs, llfndecl);\n }\n \n fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                      ctor_id: ast::NodeId,\n-                                                     disr: ty::Disr,\n+                                                     disr: Disr,\n                                                      param_substs: &'tcx Substs<'tcx>,\n                                                      llfndecl: ValueRef) {\n     let ctor_ty = ccx.tcx().node_id_to_type(ctor_id);\n@@ -2233,7 +2234,7 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n         let repr = adt::represent_type(ccx, result_ty.unwrap());\n         let mut llarg_idx = fcx.arg_offset() as c_uint;\n         for (i, arg_ty) in arg_tys.into_iter().enumerate() {\n-            let lldestptr = adt::trans_field_ptr(bcx, &*repr, dest_val, disr, i);\n+            let lldestptr = adt::trans_field_ptr(bcx, &*repr, dest_val, Disr::from(disr), i);\n             if common::type_is_fat_ptr(bcx.tcx(), arg_ty) {\n                 Store(bcx,\n                       get_param(fcx.llfn, llarg_idx),"}, {"sha": "89e58557179529f0a1d456c61d3a8f69f8728101", "filename": "src/librustc_trans/trans/build.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6fef118bc0b99e3e54aef3f4efa5abb55b2f6476/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fef118bc0b99e3e54aef3f4efa5abb55b2f6476/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs?ref=6fef118bc0b99e3e54aef3f4efa5abb55b2f6476", "patch": "@@ -21,6 +21,7 @@ use syntax::codemap::Span;\n use trans::builder::Builder;\n use trans::type_::Type;\n use trans::debuginfo::DebugLoc;\n+use trans::Disr;\n \n use libc::{c_uint, c_char};\n \n@@ -577,8 +578,8 @@ pub fn AtomicLoad(cx: Block, pointer_val: ValueRef, order: AtomicOrdering) -> Va\n }\n \n \n-pub fn LoadRangeAssert(cx: Block, pointer_val: ValueRef, lo: u64,\n-                       hi: u64, signed: llvm::Bool) -> ValueRef {\n+pub fn LoadRangeAssert(cx: Block, pointer_val: ValueRef, lo: Disr,\n+                       hi: Disr, signed: llvm::Bool) -> ValueRef {\n     if cx.unreachable.get() {\n         let ccx = cx.fcx.ccx;\n         let ty = val_ty(pointer_val);\n@@ -591,7 +592,7 @@ pub fn LoadRangeAssert(cx: Block, pointer_val: ValueRef, lo: u64,\n             llvm::LLVMGetUndef(eltty.to_ref())\n         }\n     } else {\n-        B(cx).load_range_assert(pointer_val, lo, hi, signed)\n+        B(cx).load_range_assert(pointer_val, lo.0, hi.0, signed)\n     }\n }\n "}, {"sha": "c7ec1c0955146ca82182a4593023bba29d16fd51", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6fef118bc0b99e3e54aef3f4efa5abb55b2f6476/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fef118bc0b99e3e54aef3f4efa5abb55b2f6476/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=6fef118bc0b99e3e54aef3f4efa5abb55b2f6476", "patch": "@@ -50,6 +50,7 @@ use trans::meth;\n use trans::monomorphize;\n use trans::type_::Type;\n use trans::type_of;\n+use trans::Disr;\n use middle::ty::{self, Ty, TypeFoldable};\n use middle::ty::MethodCall;\n use rustc_front::hir;\n@@ -68,7 +69,7 @@ pub struct MethodData {\n pub enum CalleeData<'tcx> {\n     // Constructor for enum variant/tuple-like-struct\n     // i.e. Some, Ok\n-    NamedTupleConstructor(ty::Disr),\n+    NamedTupleConstructor(Disr),\n \n     // Represents a (possibly monomorphized) top-level fn item or method\n     // item. Note that this is just the fn-ptr and is not a Rust closure\n@@ -151,7 +152,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &hir::Expr)\n             } => {\n                 Callee {\n                     bcx: bcx,\n-                    data: NamedTupleConstructor(0),\n+                    data: NamedTupleConstructor(Disr(0)),\n                     ty: expr_ty\n                 }\n             }\n@@ -195,14 +196,14 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &hir::Expr)\n \n                 Callee {\n                     bcx: bcx,\n-                    data: NamedTupleConstructor(vinfo.disr_val),\n+                    data: NamedTupleConstructor(Disr::from(vinfo.disr_val)),\n                     ty: expr_ty\n                 }\n             }\n             def::DefStruct(_) => {\n                 Callee {\n                     bcx: bcx,\n-                    data: NamedTupleConstructor(0),\n+                    data: NamedTupleConstructor(Disr(0)),\n                     ty: expr_ty\n                 }\n             }\n@@ -863,7 +864,7 @@ fn trans_args_under_call_abi<'blk, 'tcx>(\n                     bcx,\n                     field_type,\n                     |srcval| {\n-                        adt::trans_field_ptr(bcx, repr_ptr, srcval, 0, i)\n+                        adt::trans_field_ptr(bcx, repr_ptr, srcval, Disr(0), i)\n                     }).to_expr_datum();\n                 bcx = trans_arg_datum(bcx,\n                                       field_type,"}, {"sha": "5bdfc099f0880eedc40bf0252fcea8d7770899e4", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6fef118bc0b99e3e54aef3f4efa5abb55b2f6476/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fef118bc0b99e3e54aef3f4efa5abb55b2f6476/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=6fef118bc0b99e3e54aef3f4efa5abb55b2f6476", "patch": "@@ -26,6 +26,7 @@ use trans::declare;\n use trans::expr;\n use trans::monomorphize::{MonoId};\n use trans::type_of::*;\n+use trans::Disr;\n use middle::ty;\n use session::config::FullDebugInfo;\n \n@@ -242,7 +243,7 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n     for (i, freevar) in freevars.iter().enumerate() {\n         let datum = expr::trans_local_var(bcx, freevar.def);\n         let upvar_slot_dest = adt::trans_field_ptr(\n-            bcx, &*repr, adt::MaybeSizedValue::sized(dest_addr), 0, i);\n+            bcx, &*repr, adt::MaybeSizedValue::sized(dest_addr), Disr(0), i);\n         let upvar_id = ty::UpvarId { var_id: freevar.def.var_id(),\n                                      closure_expr_id: id };\n         match tcx.upvar_capture(upvar_id).unwrap() {\n@@ -254,7 +255,7 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n             }\n         }\n     }\n-    adt::trans_set_discr(bcx, &*repr, dest_addr, 0);\n+    adt::trans_set_discr(bcx, &*repr, dest_addr, Disr(0));\n \n     Some(bcx)\n }"}, {"sha": "1342accd388604f4c5e81ef196a76caccd26c815", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6fef118bc0b99e3e54aef3f4efa5abb55b2f6476/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fef118bc0b99e3e54aef3f4efa5abb55b2f6476/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=6fef118bc0b99e3e54aef3f4efa5abb55b2f6476", "patch": "@@ -161,6 +161,8 @@ pub fn gensym_name(name: &str) -> ast::Name {\n *\n */\n \n+use trans::Disr;\n+\n #[derive(Copy, Clone)]\n pub struct NodeIdAndSpan {\n     pub id: ast::NodeId,\n@@ -177,7 +179,7 @@ pub struct Field<'tcx>(pub ast::Name, pub Ty<'tcx>);\n \n /// The concrete version of ty::VariantDef\n pub struct VariantInfo<'tcx> {\n-    pub discr: ty::Disr,\n+    pub discr: Disr,\n     pub fields: Vec<Field<'tcx>>\n }\n \n@@ -195,7 +197,7 @@ impl<'tcx> VariantInfo<'tcx> {\n                 };\n \n                 VariantInfo {\n-                    discr: variant.disr_val,\n+                    discr: Disr::from(variant.disr_val),\n                     fields: variant.fields.iter().map(|f| {\n                         Field(f.name, monomorphize::field_ty(tcx, substs, f))\n                     }).collect()\n@@ -204,7 +206,7 @@ impl<'tcx> VariantInfo<'tcx> {\n \n             ty::TyTuple(ref v) => {\n                 VariantInfo {\n-                    discr: 0,\n+                    discr: Disr(0),\n                     fields: v.iter().enumerate().map(|(i, &t)| {\n                         Field(token::intern(&i.to_string()), t)\n                     }).collect()"}, {"sha": "0fc879707331df7b2bc62e8f1d4495881970e9c3", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6fef118bc0b99e3e54aef3f4efa5abb55b2f6476/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fef118bc0b99e3e54aef3f4efa5abb55b2f6476/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=6fef118bc0b99e3e54aef3f4efa5abb55b2f6476", "patch": "@@ -37,6 +37,7 @@ use trans::declare;\n use trans::monomorphize;\n use trans::type_::Type;\n use trans::type_of;\n+use trans::Disr;\n use middle::subst::Substs;\n use middle::ty::adjustment::{AdjustDerefRef, AdjustReifyFnPointer};\n use middle::ty::adjustment::AdjustUnsafeFnPointer;\n@@ -740,7 +741,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 (CastTy::Int(IntTy::CEnum), CastTy::Int(_)) => {\n                     let repr = adt::represent_type(cx, t_expr);\n                     let discr = adt::const_get_discrim(cx, &*repr, v);\n-                    let iv = C_integral(cx.int_type(), discr, false);\n+                    let iv = C_integral(cx.int_type(), discr.0, false);\n                     let s = adt::is_discr_signed(&*repr) as Bool;\n                     llvm::LLVMConstIntCast(iv, llty.to_ref(), s)\n                 },\n@@ -807,7 +808,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         hir::ExprTup(ref es) => {\n             let repr = adt::represent_type(cx, ety);\n             let vals = try!(map_list(&es[..]));\n-            adt::trans_const(cx, &*repr, 0, &vals[..])\n+            adt::trans_const(cx, &*repr, Disr(0), &vals[..])\n         },\n         hir::ExprStruct(_, ref fs, ref base_opt) => {\n             let repr = adt::represent_type(cx, ety);\n@@ -898,7 +899,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     match vinfo.kind() {\n                         ty::VariantKind::Unit => {\n                             let repr = adt::represent_type(cx, ety);\n-                            adt::trans_const(cx, &*repr, vinfo.disr_val, &[])\n+                            adt::trans_const(cx, &*repr, Disr::from(vinfo.disr_val), &[])\n                         }\n                         ty::VariantKind::Tuple => {\n                             expr::trans_def_fn_unadjusted(cx, e, def, param_substs).val\n@@ -952,15 +953,15 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                         C_vector(&arg_vals[..])\n                     } else {\n                         let repr = adt::represent_type(cx, ety);\n-                        adt::trans_const(cx, &*repr, 0, &arg_vals[..])\n+                        adt::trans_const(cx, &*repr, Disr(0), &arg_vals[..])\n                     }\n                 }\n                 def::DefVariant(enum_did, variant_did, _) => {\n                     let repr = adt::represent_type(cx, ety);\n                     let vinfo = cx.tcx().lookup_adt_def(enum_did).variant_with_id(variant_did);\n                     adt::trans_const(cx,\n                                      &*repr,\n-                                     vinfo.disr_val,\n+                                     Disr::from(vinfo.disr_val),\n                                      &arg_vals[..])\n                 }\n                 _ => cx.sess().span_bug(e.span, \"expected a struct, variant, or const fn def\"),"}, {"sha": "d967c728d16986099ba6616cd70ac9d4a2fea45f", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6fef118bc0b99e3e54aef3f4efa5abb55b2f6476/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fef118bc0b99e3e54aef3f4efa5abb55b2f6476/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=6fef118bc0b99e3e54aef3f4efa5abb55b2f6476", "patch": "@@ -1341,7 +1341,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 // DWARF representation of enums uniform.\n \n                 // First create a description of the artificial wrapper struct:\n-                let non_null_variant = &adt.variants[non_null_variant_index as usize];\n+                let non_null_variant = &adt.variants[non_null_variant_index.0 as usize];\n                 let non_null_variant_name = non_null_variant.name.as_str();\n \n                 // The llvm type and metadata of the pointer\n@@ -1389,7 +1389,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n \n                 // Encode the information about the null variant in the union\n                 // member's name.\n-                let null_variant_index = (1 - non_null_variant_index) as usize;\n+                let null_variant_index = (1 - non_null_variant_index.0) as usize;\n                 let null_variant_name = adt.variants[null_variant_index].name;\n                 let union_member_name = format!(\"RUST$ENCODED$ENUM${}${}\",\n                                                 0,\n@@ -1415,7 +1415,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                     describe_enum_variant(cx,\n                                           self.enum_type,\n                                           struct_def,\n-                                          &adt.variants[nndiscr as usize],\n+                                          &adt.variants[nndiscr.0 as usize],\n                                           OptimizedDiscriminant,\n                                           self.containing_scope,\n                                           self.span);\n@@ -1430,7 +1430,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n \n                 // Encode the information about the null variant in the union\n                 // member's name.\n-                let null_variant_index = (1 - nndiscr) as usize;\n+                let null_variant_index = (1 - nndiscr.0) as usize;\n                 let null_variant_name = adt.variants[null_variant_index].name;\n                 let discrfield = discrfield.iter()\n                                            .skip(1)"}, {"sha": "7cb10a8bc44c44555e223950edbdefe044308ee2", "filename": "src/librustc_trans/trans/disr.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/6fef118bc0b99e3e54aef3f4efa5abb55b2f6476/src%2Flibrustc_trans%2Ftrans%2Fdisr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fef118bc0b99e3e54aef3f4efa5abb55b2f6476/src%2Flibrustc_trans%2Ftrans%2Fdisr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdisr.rs?ref=6fef118bc0b99e3e54aef3f4efa5abb55b2f6476", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[derive(Debug, Eq, PartialEq, Copy, Clone)]\n+pub struct Disr(pub u64);\n+\n+impl Disr {\n+    pub fn wrapping_add(self, other: Self) -> Self {\n+        Disr(self.0.wrapping_add(other.0))\n+    }\n+}\n+\n+impl ::std::ops::BitAnd for Disr {\n+    type Output = Disr;\n+    fn bitand(self, other: Self) -> Self {\n+        Disr(self.0 & other.0)\n+    }\n+}\n+\n+impl From<::middle::ty::Disr> for Disr {\n+    fn from(i: ::middle::ty::Disr) -> Disr {\n+        Disr(i)\n+    }\n+}\n+\n+impl From<usize> for Disr {\n+    fn from(i: usize) -> Disr {\n+        Disr(i as u64)\n+    }\n+}\n+\n+impl PartialOrd for Disr {\n+    fn partial_cmp(&self, other: &Disr) -> Option<::std::cmp::Ordering> {\n+        self.0.partial_cmp(&other.0)\n+    }\n+}\n+\n+impl Ord for Disr {\n+    fn cmp(&self, other: &Disr) -> ::std::cmp::Ordering {\n+        self.0.cmp(&other.0)\n+    }\n+}"}, {"sha": "ab2f4462757d57529e43c414c5781e923edc6301", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6fef118bc0b99e3e54aef3f4efa5abb55b2f6476/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fef118bc0b99e3e54aef3f4efa5abb55b2f6476/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=6fef118bc0b99e3e54aef3f4efa5abb55b2f6476", "patch": "@@ -71,6 +71,7 @@ use trans::machine;\n use trans::meth;\n use trans::tvec;\n use trans::type_of;\n+use trans::Disr;\n use middle::ty::adjustment::{AdjustDerefRef, AdjustReifyFnPointer};\n use middle::ty::adjustment::{AdjustUnsafeFnPointer, CustomCoerceUnsized};\n use middle::ty::{self, Ty};\n@@ -549,8 +550,8 @@ fn coerce_unsized<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n             let iter = src_fields.iter().zip(target_fields).enumerate();\n             for (i, (src_ty, target_ty)) in iter {\n-                let ll_source = adt::trans_field_ptr(bcx, &repr_source, source_val, 0, i);\n-                let ll_target = adt::trans_field_ptr(bcx, &repr_target, target_val, 0, i);\n+                let ll_source = adt::trans_field_ptr(bcx, &repr_source, source_val, Disr(0), i);\n+                let ll_target = adt::trans_field_ptr(bcx, &repr_target, target_val, Disr(0), i);\n \n                 // If this is the field we need to coerce, recurse on it.\n                 if i == coerce_index {\n@@ -1154,7 +1155,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 args.iter().enumerate().map(|(i, arg)| (i, &**arg)).collect();\n             trans_adt(bcx,\n                       expr_ty(bcx, expr),\n-                      0,\n+                      Disr(0),\n                       &numbered_fields[..],\n                       None,\n                       dest,\n@@ -1295,7 +1296,7 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 // Nullary variant.\n                 let ty = expr_ty(bcx, ref_expr);\n                 let repr = adt::represent_type(bcx.ccx(), ty);\n-                adt::trans_set_discr(bcx, &*repr, lldest, variant.disr_val);\n+                adt::trans_set_discr(bcx, &*repr, lldest, Disr::from(variant.disr_val));\n                 return bcx;\n             }\n         }\n@@ -1304,7 +1305,7 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             match ty.sty {\n                 ty::TyStruct(def, _) if def.has_dtor() => {\n                     let repr = adt::represent_type(bcx.ccx(), ty);\n-                    adt::trans_set_discr(bcx, &*repr, lldest, 0);\n+                    adt::trans_set_discr(bcx, &*repr, lldest, Disr(0));\n                 }\n                 _ => {}\n             }\n@@ -1466,7 +1467,7 @@ pub struct StructBaseInfo<'a, 'tcx> {\n /// which remaining fields are copied; see comments on `StructBaseInfo`.\n pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                  ty: Ty<'tcx>,\n-                                 discr: ty::Disr,\n+                                 discr: Disr,\n                                  fields: &[(usize, &hir::Expr)],\n                                  optbase: Option<StructBaseInfo<'a, 'tcx>>,\n                                  dest: Dest,\n@@ -1534,7 +1535,7 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         debug_location.apply(bcx.fcx);\n \n         // Second, trans the base to the dest.\n-        assert_eq!(discr, 0);\n+        assert_eq!(discr, Disr(0));\n \n         let addr = adt::MaybeSizedValue::sized(addr);\n         match expr_kind(bcx.tcx(), &*base.expr) {"}, {"sha": "41c39a359871b791fda1820a3c47474e88d77faa", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6fef118bc0b99e3e54aef3f4efa5abb55b2f6476/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fef118bc0b99e3e54aef3f4efa5abb55b2f6476/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=6fef118bc0b99e3e54aef3f4efa5abb55b2f6476", "patch": "@@ -27,6 +27,7 @@ use trans::monomorphize;\n use trans::type_::Type;\n use trans::type_of::*;\n use trans::type_of;\n+use trans::Disr;\n use middle::infer;\n use middle::ty::{self, Ty};\n use middle::subst::Substs;\n@@ -332,7 +333,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             llarg_rust\n         } else {\n             if passed_arg_tys[i].is_bool() {\n-                let val = LoadRangeAssert(bcx, llarg_rust, 0, 2, llvm::False);\n+                let val = LoadRangeAssert(bcx, llarg_rust, Disr(0), Disr(2), llvm::False);\n                 Trunc(bcx, val, Type::i1(bcx.ccx()))\n             } else {\n                 Load(bcx, llarg_rust)"}, {"sha": "0c9b076cb650a4c8873313696ed1090e4603038d", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6fef118bc0b99e3e54aef3f4efa5abb55b2f6476/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fef118bc0b99e3e54aef3f4efa5abb55b2f6476/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=6fef118bc0b99e3e54aef3f4efa5abb55b2f6476", "patch": "@@ -36,6 +36,7 @@ use trans::type_of;\n use trans::machine;\n use trans::type_::Type;\n use middle::ty::{self, Ty, TypeFoldable};\n+use trans::Disr;\n use middle::subst::Substs;\n use rustc::dep_graph::DepNode;\n use rustc_front::hir;\n@@ -848,7 +849,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                         let arg = adt::MaybeSizedValue::sized(llarg);\n                         (0..contents.len())\n                             .map(|i| {\n-                                Load(bcx, adt::trans_field_ptr(bcx, repr_ptr, arg, 0, i))\n+                                Load(bcx, adt::trans_field_ptr(bcx, repr_ptr, arg, Disr(0), i))\n                             })\n                             .collect()\n                     }"}, {"sha": "5446bbda4c26dbe64534d507e731ce450ea29900", "filename": "src/librustc_trans/trans/mir/block.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6fef118bc0b99e3e54aef3f4efa5abb55b2f6476/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fef118bc0b99e3e54aef3f4efa5abb55b2f6476/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs?ref=6fef118bc0b99e3e54aef3f4efa5abb55b2f6476", "patch": "@@ -18,6 +18,7 @@ use trans::common::{self, Block};\n use trans::debuginfo::DebugLoc;\n use trans::type_of;\n use trans::type_::Type;\n+use trans::Disr;\n \n use super::MirContext;\n use super::operand::OperandValue::{FatPtr, Immediate, Ref};\n@@ -60,7 +61,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let switch = build::Switch(bcx, discr, unreachable_blk.llbb, targets.len());\n                 assert_eq!(adt_def.variants.len(), targets.len());\n                 for (adt_variant, target) in adt_def.variants.iter().zip(targets) {\n-                    let llval = adt::trans_case(bcx, &*repr, adt_variant.disr_val);\n+                    let llval = adt::trans_case(bcx, &*repr, Disr::from(adt_variant.disr_val));\n                     let llbb = self.llblock(*target);\n \n                     build::AddCase(switch, llval, llbb)"}, {"sha": "a6ba069742d9132f37c830655b58015b3b7f8a15", "filename": "src/librustc_trans/trans/mir/lvalue.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6fef118bc0b99e3e54aef3f4efa5abb55b2f6476/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fef118bc0b99e3e54aef3f4efa5abb55b2f6476/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs?ref=6fef118bc0b99e3e54aef3f4efa5abb55b2f6476", "patch": "@@ -20,6 +20,7 @@ use trans::debuginfo::DebugLoc;\n use trans::machine;\n use trans::type_of;\n use llvm;\n+use trans::Disr;\n \n use std::ptr;\n \n@@ -137,7 +138,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         } else {\n                             adt::MaybeSizedValue::unsized_(tr_base.llval, tr_base.llextra)\n                         };\n-                        (adt::trans_field_ptr(bcx, &base_repr, base, discr, field.index()),\n+                        (adt::trans_field_ptr(bcx, &base_repr, base, Disr(discr), field.index()),\n                          if is_sized {\n                              ptr::null_mut()\n                          } else {"}, {"sha": "f53653d7cad6aaf9cd3977231aa84f5d158d026a", "filename": "src/librustc_trans/trans/mir/rvalue.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6fef118bc0b99e3e54aef3f4efa5abb55b2f6476/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fef118bc0b99e3e54aef3f4efa5abb55b2f6476/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs?ref=6fef118bc0b99e3e54aef3f4efa5abb55b2f6476", "patch": "@@ -25,6 +25,7 @@ use trans::machine;\n use trans::type_::Type;\n use trans::type_of;\n use trans::tvec;\n+use trans::Disr;\n \n use super::MirContext;\n use super::operand::{OperandRef, OperandValue};\n@@ -100,8 +101,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 match *kind {\n                     mir::AggregateKind::Adt(adt_def, index, _) => {\n                         let repr = adt::represent_type(bcx.ccx(), dest.ty.to_ty(bcx.tcx()));\n-                        let disr = adt_def.variants[index].disr_val;\n-                        adt::trans_set_discr(bcx, &*repr, dest.llval, disr);\n+                        let disr = Disr::from(adt_def.variants[index].disr_val);\n+                        adt::trans_set_discr(bcx, &*repr, dest.llval, Disr::from(disr));\n                         for (i, operand) in operands.iter().enumerate() {\n                             let op = self.trans_operand(bcx, operand);\n                             // Do not generate stores and GEPis for zero-sized fields."}, {"sha": "d87c17cbf88d477ceb78ee389798b075a0056c4a", "filename": "src/librustc_trans/trans/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6fef118bc0b99e3e54aef3f4efa5abb55b2f6476/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fef118bc0b99e3e54aef3f4efa5abb55b2f6476/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmod.rs?ref=6fef118bc0b99e3e54aef3f4efa5abb55b2f6476", "patch": "@@ -14,6 +14,7 @@ use middle::cstore::LinkMeta;\n pub use self::base::trans_crate;\n pub use self::context::CrateContext;\n pub use self::common::gensym_name;\n+pub use self::disr::Disr;\n \n #[macro_use]\n mod macros;\n@@ -45,6 +46,7 @@ mod controlflow;\n mod datum;\n mod debuginfo;\n mod declare;\n+mod disr;\n mod expr;\n mod foreign;\n mod glue;"}, {"sha": "62e69cbb85e6fcf87a949bd9ec70c7052d67c1cc", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6fef118bc0b99e3e54aef3f4efa5abb55b2f6476/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fef118bc0b99e3e54aef3f4efa5abb55b2f6476/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=6fef118bc0b99e3e54aef3f4efa5abb55b2f6476", "patch": "@@ -24,6 +24,7 @@ use trans::common::*;\n use trans::declare;\n use trans::foreign;\n use middle::ty::{self, Ty};\n+use trans::Disr;\n use rustc::front::map as hir_map;\n \n use rustc_front::hir;\n@@ -207,7 +208,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             assert_eq!(v.node.name, variant.name);\n             let d = mk_lldecl(abi::Rust);\n             attributes::inline(d, attributes::InlineAttr::Hint);\n-            trans_enum_variant(ccx, fn_node_id, variant.disr_val, psubsts, d);\n+            trans_enum_variant(ccx, fn_node_id, Disr::from(variant.disr_val), psubsts, d);\n             d\n         }\n         hir_map::NodeImplItem(impl_item) => {"}, {"sha": "d501641b5389969bcdf5bce929f895d0890a1f2a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6fef118bc0b99e3e54aef3f4efa5abb55b2f6476/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fef118bc0b99e3e54aef3f4efa5abb55b2f6476/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6fef118bc0b99e3e54aef3f4efa5abb55b2f6476", "patch": "@@ -4178,7 +4178,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                     sp: Span,\n                                     vs: &'tcx [hir::Variant],\n                                     id: ast::NodeId) {\n-\n+    // disr_in_range should be removed once we have forced type hints for consts\n     fn disr_in_range(ccx: &CrateCtxt,\n                      ty: attr::IntType,\n                      disr: ty::Disr) -> bool {"}]}