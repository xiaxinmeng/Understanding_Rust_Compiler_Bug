{"sha": "f0c345841ce14f6ce618d1ed09c1d728bd253c87", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwYzM0NTg0MWNlMTRmNmNlNjE4ZDFlZDA5YzFkNzI4YmQyNTNjODc=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-05-30T22:18:45Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-05-31T00:39:53Z"}, "message": "Added a factory version of par::mapi, which avoids the need for share_arc, and copies arcs between tasks better.", "tree": {"sha": "1e9a010ed985a507d6045aed75e1d40edfb5e009", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e9a010ed985a507d6045aed75e1d40edfb5e009"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0c345841ce14f6ce618d1ed09c1d728bd253c87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0c345841ce14f6ce618d1ed09c1d728bd253c87", "html_url": "https://github.com/rust-lang/rust/commit/f0c345841ce14f6ce618d1ed09c1d728bd253c87", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0c345841ce14f6ce618d1ed09c1d728bd253c87/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f05040f17af1f4fcd6cda2b9cfe3ee43dc9c18e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/f05040f17af1f4fcd6cda2b9cfe3ee43dc9c18e4", "html_url": "https://github.com/rust-lang/rust/commit/f05040f17af1f4fcd6cda2b9cfe3ee43dc9c18e4"}], "stats": {"total": 111, "additions": 69, "deletions": 42}, "files": [{"sha": "5263237d6845f7c2663f40adb100000aa35eadcf", "filename": "src/libstd/par.rs", "status": "modified", "additions": 40, "deletions": 15, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/f0c345841ce14f6ce618d1ed09c1d728bd253c87/src%2Flibstd%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0c345841ce14f6ce618d1ed09c1d728bd253c87/src%2Flibstd%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpar.rs?ref=f0c345841ce14f6ce618d1ed09c1d728bd253c87", "patch": "@@ -4,7 +4,7 @@ import comm::send;\n import comm::recv;\n import future::future;\n \n-export map, mapi, alli, any;\n+export map, mapi, alli, any, mapi_factory;\n \n #[doc=\"The maximum number of tasks this module will spawn for a single\n operationg.\"]\n@@ -18,15 +18,16 @@ return the intermediate results.\n \n This is used to build most of the other parallel vector functions,\n like map or alli.\"]\n-fn map_slices<A: copy send, B: copy send>(xs: [A],\n-                                          f: fn~(uint, [const A]/&) -> B)\n+fn map_slices<A: copy send, B: copy send>(\n+    xs: [A],\n+    f: fn() -> fn~(uint, [const A]/&) -> B)\n     -> [B] {\n \n     let len = xs.len();\n     if len < min_granularity {\n         log(info, \"small slice\");\n         // This is a small vector, fall back on the normal map.\n-        [f(0u, xs)]\n+        [f()(0u, xs)]\n     }\n     else {\n         let num_tasks = uint::min(max_tasks, len / min_granularity);\n@@ -40,7 +41,7 @@ fn map_slices<A: copy send, B: copy send>(xs: [A],\n             let end = uint::min(len, base + items_per_task);\n             // FIXME: why is the ::<A, ()> annotation required here?\n             vec::unpack_slice::<A, ()>(xs) {|p, _len|\n-                let f = ptr::addr_of(f);\n+                let f = f();\n                 futures += [future::spawn() {|copy base|\n                     unsafe {\n                         let len = end - base;\n@@ -52,7 +53,7 @@ fn map_slices<A: copy send, B: copy send>(xs: [A],\n                         log(info, #fmt(\"slice: %?\",\n                                        (base, vec::len(slice), end - base)));\n                         assert(vec::len(slice) == end - base);\n-                        (*f)(base, slice)\n+                        f(base, slice)\n                     }\n                 }];\n             };\n@@ -73,16 +74,40 @@ fn map_slices<A: copy send, B: copy send>(xs: [A],\n \n #[doc=\"A parallel version of map.\"]\n fn map<A: copy send, B: copy send>(xs: [A], f: fn~(A) -> B) -> [B] {\n-    vec::concat(map_slices(xs) {|_base, slice|\n-        vec::map(slice, f)\n+    vec::concat(map_slices(xs) {||\n+        fn~(_base: uint, slice : [const A]/&) -> [B] {\n+            vec::map(slice, f)\n+        }\n     })\n }\n \n #[doc=\"A parallel version of mapi.\"]\n fn mapi<A: copy send, B: copy send>(xs: [A], f: fn~(uint, A) -> B) -> [B] {\n-    let slices = map_slices(xs) {|base, slice|\n-        vec::mapi(slice) {|i, x|\n-            f(i + base, x)\n+    let slices = map_slices(xs) {||\n+        fn~(base: uint, slice : [const A]/&) -> [B] {\n+            vec::mapi(slice) {|i, x|\n+                f(i + base, x)\n+            }\n+        }\n+    };\n+    let r = vec::concat(slices);\n+    log(info, (r.len(), xs.len()));\n+    assert(r.len() == xs.len());\n+    r\n+}\n+\n+#[doc=\"A parallel version of mapi.\n+\n+In this case, f is a function that creates functions to run over the\n+inner elements. This is to skirt the need for copy constructors.\"]\n+fn mapi_factory<A: copy send, B: copy send>(\n+    xs: [A], f: fn() -> fn~(uint, A) -> B) -> [B] {\n+    let slices = map_slices(xs) {||\n+        let f = f();\n+        fn~(base: uint, slice : [const A]/&) -> [B] {\n+            vec::mapi(slice) {|i, x|\n+                f(i + base, x)\n+            }\n         }\n     };\n     let r = vec::concat(slices);\n@@ -93,16 +118,16 @@ fn mapi<A: copy send, B: copy send>(xs: [A], f: fn~(uint, A) -> B) -> [B] {\n \n #[doc=\"Returns true if the function holds for all elements in the vector.\"]\n fn alli<A: copy send>(xs: [A], f: fn~(uint, A) -> bool) -> bool {\n-    vec::all(map_slices(xs) {|base, slice|\n+    vec::all(map_slices(xs) {|| fn~(base: uint, slice : [const A]/&) -> bool {\n         vec::alli(slice) {|i, x|\n             f(i + base, x)\n         }\n-    }) {|x| x }\n+    }}) {|x| x }\n }\n \n #[doc=\"Returns true if the function holds for any elements in the vector.\"]\n fn any<A: copy send>(xs: [A], f: fn~(A) -> bool) -> bool {\n-    vec::any(map_slices(xs) {|_base, slice|\n+    vec::any(map_slices(xs) {|| fn~(_base : uint, slice: [const A]/&) -> bool {\n         vec::any(slice, f)\n-    }) {|x| x }\n+    }}) {|x| x }\n }"}, {"sha": "577d6bec1558ef6f5611e8d69e6f3d27908c7161", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 29, "deletions": 27, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f0c345841ce14f6ce618d1ed09c1d728bd253c87/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0c345841ce14f6ce618d1ed09c1d728bd253c87/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=f0c345841ce14f6ce618d1ed09c1d728bd253c87", "patch": "@@ -227,7 +227,7 @@ fn pbfs(graph: graph, key: node_id) -> bfs_result {\n         }\n     }\n \n-    let (_res, graph) = arc::shared_arc(copy graph);\n+    let graph = arc::arc(copy graph);\n \n     let mut i = 0u;\n     while par::any(colors, is_gray) {\n@@ -236,33 +236,35 @@ fn pbfs(graph: graph, key: node_id) -> bfs_result {\n         i += 1u;\n         let old_len = colors.len();\n \n-        let (_res, color) = arc::shared_arc(copy colors);\n-\n-        colors = par::mapi(colors) {|i, c|\n-            let c : color = c;\n-            let colors = &arc::get_arc(color);\n-            let colors = arc::get(colors);\n-            let graph = &arc::get_arc(graph);\n-            let graph = arc::get(graph);\n-            alt c {\n-              white {\n-                let i = i as node_id;\n-                \n-                let neighbors = (*graph)[i];\n-                \n-                let mut color = white;\n-                \n-                neighbors.each() {|k|\n-                    if is_gray((*colors)[k]) {\n-                        color = gray(k);\n-                        false\n-                    }\n-                    else { true }\n+        let color = arc::arc(colors);\n+\n+        colors = par::mapi_factory(*arc::get(&color)) {||\n+            let colors = arc::clone(&color);\n+            let graph = arc::clone(&graph);\n+            fn~(i: uint, c: color) -> color {\n+                let c : color = c;\n+                let colors = arc::get(&colors);\n+                let graph = arc::get(&graph);\n+                alt c {\n+                  white {\n+                    let i = i as node_id;\n+                    \n+                    let neighbors = (*graph)[i];\n+                    \n+                    let mut color = white;\n+                    \n+                    neighbors.each() {|k|\n+                        if is_gray((*colors)[k]) {\n+                            color = gray(k);\n+                            false\n+                        }\n+                        else { true }\n                     };\n-                color\n-              }\n-              gray(parent) { black(parent) }\n-              black(parent) { black(parent) }\n+                    color\n+                  }\n+                  gray(parent) { black(parent) }\n+                  black(parent) { black(parent) }\n+                }\n             }\n         };\n         assert(colors.len() == old_len);"}]}