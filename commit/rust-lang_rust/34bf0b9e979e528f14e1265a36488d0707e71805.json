{"sha": "34bf0b9e979e528f14e1265a36488d0707e71805", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0YmYwYjllOTc5ZTUyOGYxNGUxMjY1YTM2NDg4ZDA3MDdlNzE4MDU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-09-13T00:06:36Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-09-13T01:15:22Z"}, "message": "trans: overhaul match bindings.  No more phi, one code path for guards.\n\nFixes #3256.\nFixes #3291.", "tree": {"sha": "7010d86826d2f9f0986659ea59346078515e9124", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7010d86826d2f9f0986659ea59346078515e9124"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34bf0b9e979e528f14e1265a36488d0707e71805", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34bf0b9e979e528f14e1265a36488d0707e71805", "html_url": "https://github.com/rust-lang/rust/commit/34bf0b9e979e528f14e1265a36488d0707e71805", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34bf0b9e979e528f14e1265a36488d0707e71805/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e", "html_url": "https://github.com/rust-lang/rust/commit/ff54ac8e598bfc71e827c0b60e392c5f0fbd4d7e"}], "stats": {"total": 1125, "additions": 724, "deletions": 401}, "files": [{"sha": "70e717aa6d9ea5881ca76c714b30fe7dc806f99c", "filename": "src/rustc/driver/session.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/34bf0b9e979e528f14e1265a36488d0707e71805/src%2Frustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34bf0b9e979e528f14e1265a36488d0707e71805/src%2Frustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fsession.rs?ref=34bf0b9e979e528f14e1265a36488d0707e71805", "patch": "@@ -38,7 +38,7 @@ type config =\n      uint_type: uint_ty,\n      float_type: float_ty};\n \n-const ppregions: uint = 1 << 0;\n+const verbose: uint = 1 << 0;\n const time_passes: uint = 1 << 1;\n const count_llvm_insns: uint = 1 << 2;\n const time_llvm_passes: uint = 1 << 3;\n@@ -60,8 +60,7 @@ const meta_stats: uint = 1 << 16;\n const no_opt: uint = 1 << 17;\n \n fn debugging_opts_map() -> ~[(~str, ~str, uint)] {\n-    ~[(~\"ppregions\", ~\"prettyprint regions with \\\n-                    internal repr details\", ppregions),\n+    ~[(~\"verbose\", ~\"in general, enable more debug printouts\", verbose),\n      (~\"time-passes\", ~\"measure time of each rustc pass\", time_passes),\n      (~\"count-llvm-insns\", ~\"count where LLVM \\\n                            instrs originate\", count_llvm_insns),\n@@ -219,7 +218,7 @@ impl session {\n     fn impossible_case(sp: span, msg: &str) -> ! {\n         self.span_bug(sp, #fmt(\"Impossible case reached: %s\", msg));\n     }\n-    fn ppregions() -> bool { self.debugging_opt(ppregions) }\n+    fn verbose() -> bool { self.debugging_opt(verbose) }\n     fn time_passes() -> bool { self.debugging_opt(time_passes) }\n     fn count_llvm_insns() -> bool { self.debugging_opt(count_llvm_insns) }\n     fn count_type_sizes() -> bool { self.debugging_opt(count_type_sizes) }"}, {"sha": "043f14113ba18839bc9ee90579ff51a1f1889c6a", "filename": "src/rustc/middle/pat_util.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/34bf0b9e979e528f14e1265a36488d0707e71805/src%2Frustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34bf0b9e979e528f14e1265a36488d0707e71805/src%2Frustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fpat_util.rs?ref=34bf0b9e979e528f14e1265a36488d0707e71805", "patch": "@@ -6,14 +6,14 @@ use syntax::fold::*;\n use syntax::codemap::span;\n use std::map::HashMap;\n \n-export pat_binding_ids, pat_bindings, pat_id_map;\n-export pat_is_variant;\n+export pat_binding_ids, pat_bindings, pat_id_map, PatIdMap;\n+export pat_is_variant, pat_is_binding_or_wild;\n \n-type pat_id_map = std::map::HashMap<ident, node_id>;\n+type PatIdMap = std::map::HashMap<ident, node_id>;\n \n // This is used because same-named variables in alternative patterns need to\n // use the node_id of their namesake in the first pattern.\n-fn pat_id_map(dm: resolve::DefMap, pat: @pat) -> pat_id_map {\n+fn pat_id_map(dm: resolve::DefMap, pat: @pat) -> PatIdMap {\n     let map = std::map::uint_hash();\n     do pat_bindings(dm, pat) |_bm, p_id, _s, n| {\n       map.insert(path_to_ident(n), p_id);\n@@ -32,6 +32,14 @@ fn pat_is_variant(dm: resolve::DefMap, pat: @pat) -> bool {\n     }\n }\n \n+fn pat_is_binding_or_wild(dm: resolve::DefMap, pat: @pat) -> bool {\n+    match pat.node {\n+        pat_ident(*) => !pat_is_variant(dm, pat),\n+        pat_wild => true,\n+        _ => false\n+    }\n+}\n+\n fn pat_bindings(dm: resolve::DefMap, pat: @pat,\n                 it: fn(binding_mode, node_id, span, @path)) {\n     do walk_pat(pat) |p| {"}, {"sha": "561adce315038261774bc824abe0b357feaa3508", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 680, "deletions": 387, "changes": 1067, "blob_url": "https://github.com/rust-lang/rust/blob/34bf0b9e979e528f14e1265a36488d0707e71805/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34bf0b9e979e528f14e1265a36488d0707e71805/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=34bf0b9e979e528f14e1265a36488d0707e71805", "patch": "@@ -1,3 +1,104 @@\n+/*!\n+ *\n+ * # Compilation of match statements\n+ *\n+ * I will endeavor to explain the code as best I can.  I have only a loose\n+ * understanding of some parts of it.\n+ *\n+ * ## Matching\n+ *\n+ * The basic state of the code is maintained in an array `m` of `@Match`\n+ * objects.  Each `@Match` describes some list of patterns, all of which must\n+ * match against the current list of values.  If those patterns match, then\n+ * the arm listed in the match is the correct arm.  A given arm may have\n+ * multiple corresponding match entries, one for each alternative that\n+ * remains.  As we proceed these sets of matches are adjusted.  Anyway this\n+ * part I am pretty vague on.  Perhaps I or someone else can add more\n+ * documentation when they understand it. :)\n+ *\n+ * ## Bindings\n+ *\n+ * We store information about the bound variables for each arm as part of the\n+ * per-arm `ArmData` struct.  There is a mapping from identifiers to\n+ * `BindingInfo` structs.  These structs contain the mode/id/type of the\n+ * binding, but they also contain up to two LLVM values, called `llmatch` and\n+ * `llbinding` respectively (the `llbinding`, as will be described shortly, is\n+ * optional and only present for by-value bindings---therefore it is bundled\n+ * up as part of the `TransBindingMode` type).  Both point at allocas.\n+ *\n+ * The `llmatch` binding always stores a pointer into the value being matched\n+ * which points at the data for the binding.  If the value being matched has\n+ * type `T`, then, `llmatch` will point at an alloca of type `T*` (and hence\n+ * `llmatch` has type `T**`).  So, if you have a pattern like:\n+ *\n+ *    let a: A = ...;\n+ *    let b: B = ...;\n+ *    match (a, b) { (ref c, copy d) => { ... } }\n+ *\n+ * For `c` and `d`, we would generate allocas of type `C*` and `D*`\n+ * respectively.  These are called the `llmatch`.  As we match, when we come\n+ * up against an identifier, we store the current pointer into the\n+ * corresponding alloca.\n+ *\n+ * In addition, for each by-value binding (copy or move), we will create a\n+ * second alloca (`llbinding`) that will hold the final value.  In this\n+ * example, that means that `d` would have this second alloca of type `D` (and\n+ * hence `llbinding` has type `D*`).\n+ *\n+ * Once a pattern is completely matched, and assuming that there is no guard\n+ * pattern, we will branch to a block that leads to the body itself.  For any\n+ * by-value bindings, this block will first load the ptr from `llmatch` (the\n+ * one of type `D*`) and copy/move the value into `llbinding` (the one of type\n+ * `D`).  The second alloca then becomes the value of the local variable.  For\n+ * by ref bindings, the value of the local variable is simply the first\n+ * alloca.\n+ *\n+ * So, for the example above, we would generate a setup kind of like this:\n+ *\n+ *        +-------+\n+ *        | Entry |\n+ *        +-------+\n+ *            |\n+ *        +-------------------------------------------+\n+ *        | llmatch_c = (addr of first half of tuple) |\n+ *        | llmatch_d = (addr of first half of tuple) |\n+ *        +-------------------------------------------+\n+ *            |\n+ *        +--------------------------------------+\n+ *        | *llbinding_d = **llmatch_dlbinding_d |\n+ *        +--------------------------------------+\n+ *\n+ * If there is a guard, the situation is slightly different, because we must\n+ * execute the guard code.  Moreover, we need to do so once for each of the\n+ * alternatives that lead to the arm, because if the guard fails, they may\n+ * have different points from which to continue the search. Therefore, in that\n+ * case, we generate code that looks more like:\n+ *\n+ *        +-------+\n+ *        | Entry |\n+ *        +-------+\n+ *            |\n+ *        +-------------------------------------------+\n+ *        | llmatch_c = (addr of first half of tuple) |\n+ *        | llmatch_d = (addr of first half of tuple) |\n+ *        +-------------------------------------------+\n+ *            |\n+ *        +-------------------------------------------------+\n+ *        | *llbinding_d = **llmatch_dlbinding_d            |\n+ *        | check condition                                 |\n+ *        | if false { free *llbinding_d, goto next case }  |\n+ *        | if true { goto body }                           |\n+ *        +-------------------------------------------------+\n+ *\n+ * The handling for the cleanups is a bit... sensitive.  Basically, the body\n+ * is the one that invokes `add_clean()` for each binding.  During the guard\n+ * evaluation, we add temporary cleanups and revoke them after the guard is\n+ * evaluated (it could fail, after all).  Presuming the guard fails, we drop\n+ * the various values we copied explicitly.  Note that guards and moves are\n+ * just plain incompatible.\n+ *\n+ */\n+\n use driver::session::session;\n use lib::llvm::llvm;\n use lib::llvm::{ValueRef, BasicBlockRef};\n@@ -17,6 +118,7 @@ use dvec::DVec;\n use datum::*;\n use common::*;\n use expr::Dest;\n+use util::common::indenter;\n \n fn macros() { include!(\"macros.rs\"); } // FIXME(#3114): Macro import/export.\n \n@@ -71,35 +173,54 @@ fn variant_opt(tcx: ty::ctxt, pat_id: ast::node_id) -> opt {\n     core::unreachable();\n }\n \n-struct binding {\n-    val: ValueRef,\n-    mode: ast::binding_mode,\n-    ty: ty::t\n+enum TransBindingMode {\n+    TrByValue(/*ismove:*/ bool, /*llbinding:*/ ValueRef),\n+    TrByRef,\n+    TrByImplicitRef\n }\n \n-type bind_map = ~[{\n-    ident: ast::ident,\n-    binding: binding\n-}];\n+/**\n+ * Information about a pattern binding:\n+ * - `llmatch` is a pointer to a stack slot.  The stack slot contains a\n+ *   pointer into the value being matched.  Hence, llmatch has type `T**`\n+ *   where `T` is the value being matched.\n+ * - `trmode` is the trans binding mode\n+ * - `id` is the node id of the binding\n+ * - `ty` is the Rust type of the binding */\n+struct BindingInfo {\n+    llmatch: ValueRef,\n+    trmode: TransBindingMode,\n+    id: ast::node_id,\n+    ty: ty::t,\n+}\n \n-fn assoc(key: ast::ident, list: bind_map) -> Option<binding> {\n-    for vec::each(list) |elt| {\n-        if elt.ident == key {\n-            return Some(elt.binding);\n-        }\n+type BindingsMap = HashMap<ident, BindingInfo>;\n+\n+struct ArmData {\n+    bodycx: block,\n+    arm: &ast::arm,\n+    bindings_map: BindingsMap\n+}\n+\n+struct Match {\n+    pats: ~[@ast::pat],\n+    data: @ArmData\n+}\n+\n+fn match_to_str(bcx: block, m: &Match) -> ~str {\n+    if bcx.sess().verbose() {\n+        // for many programs, this just take too long to serialize\n+        fmt!(\"%?\", m.pats.map(|p| pat_to_str(p, bcx.sess().intr())))\n+    } else {\n+        fmt!(\"%u pats\", m.pats.len())\n     }\n-    return None;\n }\n \n-type match_branch =\n-    @{pats: ~[@ast::pat],\n-      bound: bind_map,\n-      data: @{bodycx: block,\n-              guard: Option<@ast::expr>,\n-              id_map: pat_id_map}};\n-type match_ = ~[match_branch];\n+fn matches_to_str(bcx: block, m: &[@Match]) -> ~str {\n+    fmt!(\"%?\", m.map(|n| match_to_str(bcx, n)))\n+}\n \n-fn has_nested_bindings(m: match_, col: uint) -> bool {\n+fn has_nested_bindings(m: &[@Match], col: uint) -> bool {\n     for vec::each(m) |br| {\n         match br.pats[col].node {\n           ast::pat_ident(_, _, Some(_)) => return true,\n@@ -109,70 +230,102 @@ fn has_nested_bindings(m: match_, col: uint) -> bool {\n     return false;\n }\n \n-fn expand_nested_bindings(bcx: block, m: match_, col: uint, val: ValueRef)\n-                       -> match_ {\n+fn expand_nested_bindings(bcx: block, m: &[@Match/&r],\n+                          col: uint, val: ValueRef)\n+    -> ~[@Match/&r]\n+{\n+    debug!(\"expand_nested_bindings(bcx=%s, m=%s, col=%u, val=%?)\",\n+           bcx.to_str(),\n+           matches_to_str(bcx, m),\n+           col,\n+           bcx.val_str(val));\n+    let _indenter = indenter();\n+\n+    do m.map |br| {\n+        match br.pats[col].node {\n+            ast::pat_ident(_, path, Some(inner)) => {\n+                let pats = vec::append(\n+                    vec::slice(br.pats, 0u, col),\n+                    vec::append(~[inner],\n+                                vec::view(br.pats, col + 1u, br.pats.len())));\n \n-    let mut result = ~[];\n-    for vec::each(m) |br| {\n-      match br.pats[col].node {\n-          ast::pat_ident(mode, name, Some(inner)) => {\n-            let pats = vec::append(\n-                vec::slice(br.pats, 0u, col),\n-                vec::append(~[inner],\n-                            vec::view(br.pats, col + 1u, br.pats.len())));\n-            vec::push(result,\n-                      @{pats: pats,\n-                        bound: vec::append(\n-                            br.bound, ~[{ident: path_to_ident(name),\n-                                         binding: binding {\n-                                            val: val,\n-                                            mode: mode,\n-                                            ty: node_id_type(bcx,\n-                                                             br.pats[col].id)\n-                                         }}]),\n-                        ..*br});\n-          }\n-          _ => vec::push(result, br)\n-        }\n-    }\n-    result\n+                let binding_info =\n+                    br.data.bindings_map.get(path_to_ident(path));\n+\n+                Store(bcx, val, binding_info.llmatch);\n+                @Match {pats: pats, data: br.data}\n+            }\n+            _ => {\n+                br\n+            }\n+        }\n+    }\n }\n \n type enter_pat = fn(@ast::pat) -> Option<~[@ast::pat]>;\n \n-fn enter_match(bcx: block, dm: DefMap, m: match_, col: uint, val: ValueRef,\n-               e: enter_pat) -> match_ {\n+fn assert_is_binding_or_wild(bcx: block, p: @ast::pat) {\n+    if !pat_is_binding_or_wild(bcx.tcx().def_map, p) {\n+        bcx.sess().span_bug(\n+            p.span,\n+            fmt!(\"Expected an identifier pattern but found p: %s\",\n+                 pat_to_str(p, bcx.sess().intr())));\n+    }\n+}\n+\n+fn enter_match(bcx: block, dm: DefMap, m: &[@Match/&r],\n+               col: uint, val: ValueRef, e: enter_pat)\n+    -> ~[@Match/&r]\n+{\n+    debug!(\"enter_match(bcx=%s, m=%s, col=%u, val=%?)\",\n+           bcx.to_str(),\n+           matches_to_str(bcx, m),\n+           col,\n+           bcx.val_str(val));\n+    let _indenter = indenter();\n+\n     let mut result = ~[];\n     for vec::each(m) |br| {\n         match e(br.pats[col]) {\n-          Some(sub) => {\n-            let pats = vec::append(\n-                vec::append(sub, vec::view(br.pats, 0u, col)),\n-                vec::view(br.pats, col + 1u, br.pats.len()));\n-            let self = br.pats[col];\n-            let bound = match self.node {\n-              ast::pat_ident(mode, name, None)\n-                  if !pat_is_variant(dm, self) => {\n-                vec::append(br.bound,\n-                            ~[{ident: path_to_ident(name),\n-                               binding: binding {\n-                                   val: val,\n-                                   mode: mode,\n-                                   ty: node_id_type(bcx, br.pats[col].id)\n-                               }}])\n-              }\n-              _ => br.bound\n-            };\n-            vec::push(result, @{pats: pats, bound: bound, ..*br});\n-          }\n-          None => ()\n+            Some(sub) => {\n+                let pats =\n+                    vec::append(\n+                        vec::append(sub, vec::view(br.pats, 0u, col)),\n+                        vec::view(br.pats, col + 1u, br.pats.len()));\n+\n+                let self = br.pats[col];\n+                match self.node {\n+                    ast::pat_ident(_, path, None) => {\n+                        if !pat_is_variant(dm, self) {\n+                            let binding_info =\n+                                br.data.bindings_map.get(path_to_ident(path));\n+                            Store(bcx, val, binding_info.llmatch);\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+\n+                vec::push(result, @Match {pats: pats, data: br.data});\n+            }\n+            None => ()\n         }\n     }\n+\n+    debug!(\"result=%s\", matches_to_str(bcx, result));\n+\n     return result;\n }\n \n-fn enter_default(bcx: block, dm: DefMap, m: match_, col: uint, val: ValueRef)\n-              -> match_ {\n+fn enter_default(bcx: block, dm: DefMap, m: &[@Match/&r],\n+                 col: uint, val: ValueRef)\n+    -> ~[@Match/&r]\n+{\n+    debug!(\"enter_default(bcx=%s, m=%s, col=%u, val=%?)\",\n+           bcx.to_str(),\n+           matches_to_str(bcx, m),\n+           col,\n+           bcx.val_str(val));\n+    let _indenter = indenter();\n \n     do enter_match(bcx, dm, m, col, val) |p| {\n         match p.node {\n@@ -184,88 +337,158 @@ fn enter_default(bcx: block, dm: DefMap, m: match_, col: uint, val: ValueRef)\n     }\n }\n \n-fn enter_opt(bcx: block, m: match_, opt: opt, col: uint,\n-             variant_size: uint, val: ValueRef) -> match_ {\n+fn enter_opt(bcx: block, m: &[@Match/&r], opt: opt, col: uint,\n+             variant_size: uint, val: ValueRef)\n+    -> ~[@Match/&r]\n+{\n+    debug!(\"enter_opt(bcx=%s, m=%s, col=%u, val=%?)\",\n+           bcx.to_str(),\n+           matches_to_str(bcx, m),\n+           col,\n+           bcx.val_str(val));\n+    let _indenter = indenter();\n+\n     let tcx = bcx.tcx();\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(bcx, tcx.def_map, m, col, val) |p| {\n         match p.node {\n-          ast::pat_enum(_, subpats) => {\n-            if opt_eq(tcx, variant_opt(tcx, p.id), opt) {\n-              Some(option::get_default(subpats,\n-                     vec::from_elem(variant_size, dummy))) }\n-            else { None }\n-          }\n-          ast::pat_ident(_, _, None) if pat_is_variant(tcx.def_map, p) => {\n-            if opt_eq(tcx, variant_opt(tcx, p.id), opt) { Some(~[]) }\n-            else { None }\n-          }\n-          ast::pat_lit(l) => {\n-            if opt_eq(tcx, lit(l), opt) { Some(~[]) } else { None }\n-          }\n-          ast::pat_range(l1, l2) => {\n-            if opt_eq(tcx, range(l1, l2), opt) { Some(~[]) } else { None }\n-          }\n-          _ => Some(vec::from_elem(variant_size, dummy))\n-        }\n-    }\n-}\n-\n-fn enter_rec_or_struct(bcx: block, dm: DefMap, m: match_, col: uint,\n-                       fields: ~[ast::ident], val: ValueRef) -> match_ {\n+            ast::pat_enum(_, subpats) => {\n+                if opt_eq(tcx, variant_opt(tcx, p.id), opt) {\n+                    Some(option::get_default(subpats,\n+                                             vec::from_elem(variant_size,\n+                                                            dummy)))\n+                } else {\n+                    None\n+                }\n+            }\n+            ast::pat_ident(_, _, None) if pat_is_variant(tcx.def_map, p) => {\n+                if opt_eq(tcx, variant_opt(tcx, p.id), opt) {\n+                    Some(~[])\n+                } else {\n+                    None\n+                }\n+            }\n+            ast::pat_lit(l) => {\n+                if opt_eq(tcx, lit(l), opt) { Some(~[]) } else { None }\n+            }\n+            ast::pat_range(l1, l2) => {\n+                if opt_eq(tcx, range(l1, l2), opt) { Some(~[]) } else { None }\n+            }\n+            _ => {\n+                assert_is_binding_or_wild(bcx, p);\n+                Some(vec::from_elem(variant_size, dummy))\n+            }\n+        }\n+    }\n+}\n+\n+fn enter_rec_or_struct(bcx: block, dm: DefMap, m: &[@Match/&r], col: uint,\n+                       fields: ~[ast::ident], val: ValueRef) -> ~[@Match/&r] {\n+    debug!(\"enter_rec_or_struct(bcx=%s, m=%s, col=%u, val=%?)\",\n+           bcx.to_str(),\n+           matches_to_str(bcx, m),\n+           col,\n+           bcx.val_str(val));\n+    let _indenter = indenter();\n+\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(bcx, dm, m, col, val) |p| {\n         match p.node {\n-          ast::pat_rec(fpats, _) | ast::pat_struct(_, fpats, _) => {\n-            let mut pats = ~[];\n-            for vec::each(fields) |fname| {\n-                match fpats.find(|p| p.ident == fname) {\n-                    None => vec::push(pats, dummy),\n-                    Some(pat) => vec::push(pats, pat.pat)\n+            ast::pat_rec(fpats, _) | ast::pat_struct(_, fpats, _) => {\n+                let mut pats = ~[];\n+                for vec::each(fields) |fname| {\n+                    match fpats.find(|p| p.ident == fname) {\n+                        None => vec::push(pats, dummy),\n+                        Some(pat) => vec::push(pats, pat.pat)\n+                    }\n                 }\n+                Some(pats)\n+            }\n+            _ => {\n+                assert_is_binding_or_wild(bcx, p);\n+                Some(vec::from_elem(fields.len(), dummy))\n             }\n-            Some(pats)\n-          }\n-          _ => Some(vec::from_elem(fields.len(), dummy))\n         }\n     }\n }\n \n-fn enter_tup(bcx: block, dm: DefMap, m: match_, col: uint, val: ValueRef,\n-             n_elts: uint) -> match_ {\n+fn enter_tup(bcx: block, dm: DefMap, m: &[@Match/&r],\n+             col: uint, val: ValueRef, n_elts: uint)\n+    -> ~[@Match/&r]\n+{\n+    debug!(\"enter_tup(bcx=%s, m=%s, col=%u, val=%?)\",\n+           bcx.to_str(),\n+           matches_to_str(bcx, m),\n+           col,\n+           bcx.val_str(val));\n+    let _indenter = indenter();\n+\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(bcx, dm, m, col, val) |p| {\n         match p.node {\n-          ast::pat_tup(elts) => Some(elts),\n-          _ => Some(vec::from_elem(n_elts, dummy))\n+            ast::pat_tup(elts) => {\n+                Some(elts)\n+            }\n+            _ => {\n+                assert_is_binding_or_wild(bcx, p);\n+                Some(vec::from_elem(n_elts, dummy))\n+            }\n         }\n     }\n }\n \n-fn enter_box(bcx: block, dm: DefMap, m: match_, col: uint, val: ValueRef)\n-          -> match_ {\n+fn enter_box(bcx: block, dm: DefMap, m: &[@Match/&r],\n+             col: uint, val: ValueRef)\n+    -> ~[@Match/&r]\n+{\n+    debug!(\"enter_box(bcx=%s, m=%s, col=%u, val=%?)\",\n+           bcx.to_str(),\n+           matches_to_str(bcx, m),\n+           col,\n+           bcx.val_str(val));\n+    let _indenter = indenter();\n+\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(bcx, dm, m, col, val) |p| {\n         match p.node {\n-          ast::pat_box(sub) => Some(~[sub]),\n-          _ => Some(~[dummy])\n+            ast::pat_box(sub) => {\n+                Some(~[sub])\n+            }\n+            _ => {\n+                assert_is_binding_or_wild(bcx, p);\n+                Some(~[dummy])\n+            }\n         }\n     }\n }\n \n-fn enter_uniq(bcx: block, dm: DefMap, m: match_, col: uint, val: ValueRef)\n-           -> match_ {\n+fn enter_uniq(bcx: block, dm: DefMap, m: &[@Match/&r],\n+              col: uint, val: ValueRef)\n+    -> ~[@Match/&r]\n+{\n+    debug!(\"enter_uniq(bcx=%s, m=%s, col=%u, val=%?)\",\n+           bcx.to_str(),\n+           matches_to_str(bcx, m),\n+           col,\n+           bcx.val_str(val));\n+    let _indenter = indenter();\n+\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(bcx, dm, m, col, val) |p| {\n         match p.node {\n-          ast::pat_uniq(sub) => Some(~[sub]),\n-          _ => Some(~[dummy])\n+            ast::pat_uniq(sub) => {\n+                Some(~[sub])\n+            }\n+            _ => {\n+                assert_is_binding_or_wild(bcx, p);\n+                Some(~[dummy])\n+            }\n         }\n     }\n }\n \n-fn get_options(ccx: @crate_ctxt, m: match_, col: uint) -> ~[opt] {\n-    fn add_to_set(tcx: ty::ctxt, &&set: DVec<opt>, val: opt) {\n+fn get_options(ccx: @crate_ctxt, m: &[@Match], col: uint) -> ~[opt] {\n+    fn add_to_set(tcx: ty::ctxt, set: &DVec<opt>, val: opt) {\n         if set.any(|l| opt_eq(tcx, l, val)) {return;}\n         set.push(val);\n     }\n@@ -274,23 +497,27 @@ fn get_options(ccx: @crate_ctxt, m: match_, col: uint) -> ~[opt] {\n     for vec::each(m) |br| {\n         let cur = br.pats[col];\n         if pat_is_variant(ccx.tcx.def_map, cur) {\n-            add_to_set(ccx.tcx, found, variant_opt(ccx.tcx, br.pats[col].id));\n+            add_to_set(ccx.tcx, &found, variant_opt(ccx.tcx, cur.id));\n         } else {\n             match cur.node {\n-              ast::pat_lit(l) => add_to_set(ccx.tcx, found, lit(l)),\n-              ast::pat_range(l1, l2) => {\n-                add_to_set(ccx.tcx, found, range(l1, l2));\n-              }\n-              _ => ()\n+                ast::pat_lit(l) => {\n+                    add_to_set(ccx.tcx, &found, lit(l));\n+                }\n+                ast::pat_range(l1, l2) => {\n+                    add_to_set(ccx.tcx, &found, range(l1, l2));\n+                }\n+                _ => ()\n             }\n         }\n     }\n     return dvec::unwrap(move found);\n }\n \n fn extract_variant_args(bcx: block, pat_id: ast::node_id,\n-                        vdefs: {enm: def_id, var: def_id}, val: ValueRef) ->\n-   {vals: ~[ValueRef], bcx: block} {\n+                        vdefs: {enm: def_id, var: def_id},\n+                        val: ValueRef)\n+    -> {vals: ~[ValueRef], bcx: block}\n+{\n     let _icx = bcx.insn_ctxt(\"alt::extract_variant_args\");\n     let ccx = bcx.fcx.ccx;\n     let enum_ty_substs = match ty::get(node_id_type(bcx, pat_id)).sty {\n@@ -315,7 +542,7 @@ fn extract_variant_args(bcx: block, pat_id: ast::node_id,\n     return {vals: args, bcx: bcx};\n }\n \n-fn collect_record_or_struct_fields(m: match_, col: uint) -> ~[ast::ident] {\n+fn collect_record_or_struct_fields(m: &[@Match], col: uint) -> ~[ast::ident] {\n     let mut fields: ~[ast::ident] = ~[];\n     for vec::each(m) |br| {\n         match br.pats[col].node {\n@@ -336,7 +563,9 @@ fn collect_record_or_struct_fields(m: match_, col: uint) -> ~[ast::ident] {\n     }\n }\n \n-fn root_pats_as_necessary(bcx: block, m: match_, col: uint, val: ValueRef) {\n+fn root_pats_as_necessary(bcx: block, m: &[@Match],\n+                          col: uint, val: ValueRef)\n+{\n     for vec::each(m) |br| {\n         let pat_id = br.pats[col].id;\n \n@@ -356,7 +585,7 @@ fn root_pats_as_necessary(bcx: block, m: match_, col: uint, val: ValueRef) {\n     }\n }\n \n-fn any_box_pat(m: match_, col: uint) -> bool {\n+fn any_box_pat(m: &[@Match], col: uint) -> bool {\n     for vec::each(m) |br| {\n         match br.pats[col].node {\n           ast::pat_box(_) => return true,\n@@ -366,7 +595,7 @@ fn any_box_pat(m: match_, col: uint) -> bool {\n     return false;\n }\n \n-fn any_uniq_pat(m: match_, col: uint) -> bool {\n+fn any_uniq_pat(m: &[@Match], col: uint) -> bool {\n     for vec::each(m) |br| {\n         match br.pats[col].node {\n           ast::pat_uniq(_) => return true,\n@@ -376,7 +605,7 @@ fn any_uniq_pat(m: match_, col: uint) -> bool {\n     return false;\n }\n \n-fn any_tup_pat(m: match_, col: uint) -> bool {\n+fn any_tup_pat(m: &[@Match], col: uint) -> bool {\n     for vec::each(m) |br| {\n         match br.pats[col].node {\n           ast::pat_tup(_) => return true,\n@@ -386,10 +615,9 @@ fn any_tup_pat(m: match_, col: uint) -> bool {\n     return false;\n }\n \n-type exit_node = {bound: bind_map, from: BasicBlockRef, to: BasicBlockRef};\n type mk_fail = fn@() -> BasicBlockRef;\n \n-fn pick_col(m: match_) -> uint {\n+fn pick_col(m: &[@Match]) -> uint {\n     fn score(p: @ast::pat) -> uint {\n         match p.node {\n           ast::pat_lit(_) | ast::pat_enum(_, _) | ast::pat_range(_, _) => 1u,\n@@ -458,8 +686,152 @@ fn compare_values(cx: block, lhs: ValueRef, rhs: ValueRef, rhs_t: ty::t) ->\n     }\n }\n \n-fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n-                    chk: Option<mk_fail>, &exits: ~[exit_node]) {\n+fn store_non_ref_bindings(bcx: block,\n+                          data: &ArmData,\n+                          opt_temp_cleanups: Option<&DVec<ValueRef>>)\n+    -> block\n+{\n+    /*!\n+     *\n+     * For each copy/move binding, copy the value from the value\n+     * being matched into its final home.  This code executes once\n+     * one of the patterns for a given arm has completely matched.\n+     * It adds temporary cleanups to the `temp_cleanups` array,\n+     * if one is provided.\n+     */\n+\n+    let mut bcx = bcx;\n+    for data.bindings_map.each_value |binding_info| {\n+        match binding_info.trmode {\n+            TrByValue(is_move, lldest) => {\n+                let llval = Load(bcx, binding_info.llmatch); // get a T*\n+                let datum = Datum {val: llval, ty: binding_info.ty,\n+                                   mode: ByRef, source: FromLvalue};\n+                bcx = {\n+                    if is_move {\n+                        datum.move_to(bcx, INIT, lldest)\n+                    } else {\n+                        datum.copy_to(bcx, INIT, lldest)\n+                    }\n+                };\n+\n+                for opt_temp_cleanups.each |temp_cleanups| {\n+                    add_clean_temp_mem(bcx, lldest, binding_info.ty);\n+                    temp_cleanups.push(lldest);\n+                }\n+            }\n+            TrByRef | TrByImplicitRef => {}\n+        }\n+    }\n+    return bcx;\n+}\n+\n+fn insert_lllocals(bcx: block,\n+                   data: &ArmData,\n+                   add_cleans: bool) -> block {\n+    /*!\n+     *\n+     * For each binding in `data.bindings_map`, adds an appropriate entry into\n+     * the `fcx.lllocals` map.  If add_cleans is true, then adds cleanups for\n+     * the bindings. */\n+\n+    for data.bindings_map.each_value |binding_info| {\n+        let llval = match binding_info.trmode {\n+            // By value bindings: use the stack slot that we\n+            // copied/moved the value into\n+            TrByValue(_, lldest) => {\n+                if add_cleans {\n+                    add_clean(bcx, lldest, binding_info.ty);\n+                }\n+\n+                lldest\n+            }\n+\n+            // By ref binding: use the ptr into the matched value\n+            TrByRef => {\n+                binding_info.llmatch\n+            }\n+\n+            // Ugly: for implicit ref, we actually want a T*, but\n+            // we have a T**, so we had to load.  This will go away\n+            // once implicit refs go away.\n+            TrByImplicitRef => {\n+                Load(bcx, binding_info.llmatch)\n+            }\n+        };\n+\n+        bcx.fcx.lllocals.insert(binding_info.id,\n+                                local_mem(llval));\n+    }\n+    return bcx;\n+}\n+\n+fn compile_guard(bcx: block,\n+                 guard_expr: @ast::expr,\n+                 data: &ArmData,\n+                 m: &[@Match],\n+                 vals: &[ValueRef],\n+                 chk: Option<mk_fail>)\n+    -> block\n+{\n+    debug!(\"compile_guard(bcx=%s, guard_expr=%s, m=%s, vals=%?)\",\n+           bcx.to_str(),\n+           bcx.expr_to_str(guard_expr),\n+           matches_to_str(bcx, m),\n+           vals.map(|v| bcx.val_str(v)));\n+    let _indenter = indenter();\n+\n+    let mut bcx = bcx;\n+    let temp_cleanups = DVec();\n+    bcx = store_non_ref_bindings(bcx, data, Some(&temp_cleanups));\n+    bcx = insert_lllocals(bcx, data, false);\n+\n+    let val = unpack_result!(bcx, {\n+        do with_scope_result(bcx, guard_expr.info(),\n+                             ~\"guard\") |bcx| {\n+            expr::trans_to_datum(bcx, guard_expr).to_result()\n+        }\n+    });\n+\n+    // Revoke the temp cleanups now that the guard successfully executed.\n+    for temp_cleanups.each |llval| {\n+        revoke_clean(bcx, llval);\n+    }\n+\n+    return do with_cond(bcx, Not(bcx, val)) |bcx| {\n+        // Guard does not match: free the values we copied,\n+        // and remove all bindings from the lllocals table\n+        let bcx = drop_bindings(bcx, data);\n+        compile_submatch(bcx, m, vals, chk);\n+        bcx\n+    };\n+\n+    fn drop_bindings(bcx: block, data: &ArmData) -> block {\n+        let mut bcx = bcx;\n+        for data.bindings_map.each_value |binding_info| {\n+            match binding_info.trmode {\n+                TrByValue(_, llval) => {\n+                    bcx = glue::drop_ty(bcx, llval, binding_info.ty);\n+                }\n+                TrByRef | TrByImplicitRef => {}\n+            }\n+            bcx.fcx.lllocals.remove(binding_info.id);\n+        }\n+        return bcx;\n+    }\n+}\n+\n+fn compile_submatch(bcx: block,\n+                    m: &[@Match],\n+                    vals: &[ValueRef],\n+                    chk: Option<mk_fail>)\n+{\n+    debug!(\"compile_submatch(bcx=%s, m=%s, vals=%?)\",\n+           bcx.to_str(),\n+           matches_to_str(bcx, m),\n+           vals.map(|v| bcx.val_str(v)));\n+    let _indenter = indenter();\n+\n     /*\n       For an empty match, a fall-through case must exist\n      */\n@@ -473,57 +845,27 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n     }\n     if m[0].pats.len() == 0u {\n         let data = m[0].data;\n-        match data.guard {\n-          Some(e) => {\n-            // Temporarily set bindings. They'll be rewritten to PHI nodes\n-            // for the actual arm block.\n-            //\n-            // Also, in the case of by-value, do the copy now.\n-\n-            for data.id_map.each |key, val| {\n-                let binding = assoc(key, m[0].bound).get();\n-                let datum = Datum {val: binding.val, ty: binding.ty,\n-                                   mode: ByRef, source: FromLvalue};\n-\n-                if binding.mode == ast::bind_by_value {\n-                    let llty = type_of::type_of(bcx.fcx.ccx, binding.ty);\n-                    let alloc = alloca(bcx, llty);\n-                    bcx = datum.copy_to(bcx, INIT, alloc);\n-                    bcx.fcx.lllocals.insert(val, local_mem(alloc));\n-                    add_clean(bcx, alloc, binding.ty);\n-                } else if binding.mode == ast::bind_by_move {\n-                    fail ~\"can't translate bind_by_move into a pattern guard\";\n-                } else {\n-                    bcx.fcx.lllocals.insert(val, local_mem(datum.val));\n-                }\n-            };\n-\n-            let Result {bcx: guard_cx, val} = {\n-                do with_scope_result(bcx, e.info(), ~\"guard\") |bcx| {\n-                    expr::trans_to_datum(bcx, e).to_result()\n-                }\n-            };\n-\n-            bcx = do with_cond(guard_cx, Not(guard_cx, val)) |bcx| {\n-                compile_submatch(bcx, vec::tail(m), vals, chk, exits);\n-                bcx\n-            };\n-          }\n-          _ => ()\n-        }\n-        if !bcx.unreachable {\n-            vec::push(exits, {bound: m[0].bound, from: bcx.llbb,\n-                       to: data.bodycx.llbb});\n+        match data.arm.guard {\n+            Some(guard_expr) => {\n+                bcx = compile_guard(bcx, guard_expr, m[0].data,\n+                                    vec::view(m, 1, m.len()),\n+                                    vals, chk);\n+            }\n+            _ => ()\n         }\n         Br(bcx, data.bodycx.llbb);\n         return;\n     }\n \n     let col = pick_col(m);\n     let val = vals[col];\n-    let m = if has_nested_bindings(m, col) {\n-                expand_nested_bindings(bcx, m, col, val)\n-            } else { m };\n+    let m = {\n+        if has_nested_bindings(m, col) {\n+            expand_nested_bindings(bcx, m, col, val)\n+        } else {\n+            m.to_vec()\n+        }\n+    };\n \n     let vals_left = vec::append(vec::slice(vals, 0u, col),\n                                 vec::view(vals, col + 1u, vals.len()));\n@@ -541,17 +883,15 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n     if rec_fields.len() > 0 {\n         let pat_ty = node_id_type(bcx, pat_id);\n         do expr::with_field_tys(tcx, pat_ty) |_has_dtor, field_tys| {\n-            let mut rec_vals = ~[];\n-            for vec::each(rec_fields) |field_name| {\n+            let rec_vals = rec_fields.map(|field_name| {\n                 let ix = ty::field_idx_strict(tcx, field_name, field_tys);\n-                vec::push(rec_vals, GEPi(bcx, val, struct_field(ix)));\n-            }\n+                GEPi(bcx, val, struct_field(ix))\n+            });\n             compile_submatch(\n                 bcx,\n                 enter_rec_or_struct(bcx, dm, m, col, rec_fields, val),\n                 vec::append(rec_vals, vals_left),\n-                chk,\n-                exits);\n+                chk);\n         }\n         return;\n     }\n@@ -562,13 +902,9 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n           ty::ty_tup(elts) => elts.len(),\n           _ => ccx.sess.bug(~\"non-tuple type in tuple pattern\")\n         };\n-        let mut tup_vals = ~[], i = 0u;\n-        while i < n_tup_elts {\n-            vec::push(tup_vals, GEPi(bcx, val, [0u, i]));\n-            i += 1u;\n-        }\n+        let tup_vals = vec::from_fn(n_tup_elts, |i| GEPi(bcx, val, [0u, i]));\n         compile_submatch(bcx, enter_tup(bcx, dm, m, col, val, n_tup_elts),\n-                         vec::append(tup_vals, vals_left), chk, exits);\n+                         vec::append(tup_vals, vals_left), chk);\n         return;\n     }\n \n@@ -579,7 +915,7 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n         let unboxed =\n             GEPi(bcx, box_no_addrspace, [0u, abi::box_field_body]);\n         compile_submatch(bcx, enter_box(bcx, dm, m, col, val),\n-                         vec::append(~[unboxed], vals_left), chk, exits);\n+                         vec::append(~[unboxed], vals_left), chk);\n         return;\n     }\n \n@@ -589,7 +925,7 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n         let unboxed =\n             GEPi(bcx, box_no_addrspace, [0u, abi::box_field_body]);\n         compile_submatch(bcx, enter_uniq(bcx, dm, m, col, val),\n-                         vec::append(~[unboxed], vals_left), chk, exits);\n+                         vec::append(~[unboxed], vals_left), chk);\n         return;\n     }\n \n@@ -599,44 +935,46 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n     let mut test_val = val;\n     if opts.len() > 0u {\n         match opts[0] {\n-          var(_, vdef) => {\n-            if (*ty::enum_variants(tcx, vdef.enm)).len() == 1u {\n-                kind = single;\n-            } else {\n-                let enumptr =\n-                    PointerCast(bcx, val, T_opaque_enum_ptr(ccx));\n-                let discrimptr = GEPi(bcx, enumptr, [0u, 0u]);\n-                test_val = Load(bcx, discrimptr);\n-                kind = switch;\n-            }\n-          }\n-          lit(_) => {\n-            let pty = node_id_type(bcx, pat_id);\n-            test_val = load_if_immediate(bcx, val, pty);\n-            kind = if ty::type_is_integral(pty) { switch }\n-                   else { compare };\n-          }\n-          range(_, _) => {\n-            test_val = Load(bcx, val);\n-            kind = compare;\n-          }\n+            var(_, vdef) => {\n+                if (*ty::enum_variants(tcx, vdef.enm)).len() == 1u {\n+                    kind = single;\n+                } else {\n+                    let enumptr =\n+                        PointerCast(bcx, val, T_opaque_enum_ptr(ccx));\n+                    let discrimptr = GEPi(bcx, enumptr, [0u, 0u]);\n+                    test_val = Load(bcx, discrimptr);\n+                    kind = switch;\n+                }\n+            }\n+            lit(_) => {\n+                let pty = node_id_type(bcx, pat_id);\n+                test_val = load_if_immediate(bcx, val, pty);\n+                kind = if ty::type_is_integral(pty) { switch }\n+                else { compare };\n+            }\n+            range(_, _) => {\n+                test_val = Load(bcx, val);\n+                kind = compare;\n+            }\n         }\n     }\n     for vec::each(opts) |o| {\n         match o {\n-          range(_, _) => { kind = compare; break }\n-          _ => ()\n+            range(_, _) => { kind = compare; break }\n+            _ => ()\n         }\n     }\n     let else_cx = match kind {\n-      no_branch | single => bcx,\n-      _ => sub_block(bcx, ~\"match_else\")\n+        no_branch | single => bcx,\n+        _ => sub_block(bcx, ~\"match_else\")\n     };\n     let sw = if kind == switch {\n         Switch(bcx, test_val, else_cx.llbb, opts.len())\n-    } else { C_int(ccx, 0) }; // Placeholder for when not using a switch\n+    } else {\n+        C_int(ccx, 0) // Placeholder for when not using a switch\n+    };\n \n-    let defaults = enter_default(bcx, dm, m, col, val);\n+    let defaults = enter_default(else_cx, dm, m, col, val);\n     let exhaustive = option::is_none(chk) && defaults.len() == 0u;\n     let len = opts.len();\n     let mut i = 0u;\n@@ -650,157 +988,76 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n             match kind {\n               single => Br(bcx, opt_cx.llbb),\n               switch => {\n-                match trans_opt(bcx, opt) {\n-                  single_result(r) => {\n-                    llvm::LLVMAddCase(sw, r.val, opt_cx.llbb);\n-                    bcx = r.bcx;\n+                  match trans_opt(bcx, opt) {\n+                      single_result(r) => {\n+                          llvm::LLVMAddCase(sw, r.val, opt_cx.llbb);\n+                          bcx = r.bcx;\n+                      }\n+                      _ => {\n+                          bcx.sess().bug(\n+                              ~\"in compile_submatch, expected \\\n+                                trans_opt to return a single_result\")\n+                      }\n                   }\n-                  _ => bcx.sess().bug(~\"in compile_submatch, expected \\\n-                         trans_opt to return a single_result\")\n-                }\n               }\n               compare => {\n-                let t = node_id_type(bcx, pat_id);\n-                let Result {bcx: after_cx, val: matches} = {\n-                    do with_scope_result(bcx, None, ~\"compare_scope\") |bcx| {\n-                        match trans_opt(bcx, opt) {\n-                            single_result(\n-                                Result {bcx, val}) => {\n-                                compare_values(bcx, test_val, val, t)\n-                            }\n-                            range_result(\n-                                Result {val: vbegin, _},\n-                                Result {bcx, val: vend}) => {\n-                                let Result {bcx, val: llge} =\n-                                    compare_scalar_types(bcx, test_val,\n-                                                         vbegin, t, ast::ge);\n-                                let Result {bcx, val: llle} =\n-                                    compare_scalar_types(bcx, test_val, vend,\n-                                                         t, ast::le);\n-                                rslt(bcx, And(bcx, llge, llle))\n-                            }\n-                        }\n-                    }\n-                };\n-                bcx = sub_block(after_cx, ~\"compare_next\");\n-                CondBr(after_cx, matches, opt_cx.llbb, bcx.llbb);\n+                  let t = node_id_type(bcx, pat_id);\n+                  let Result {bcx: after_cx, val: matches} = {\n+                      do with_scope_result(bcx, None,\n+                                           ~\"compare_scope\") |bcx| {\n+                          match trans_opt(bcx, opt) {\n+                              single_result(\n+                                  Result {bcx, val}) => {\n+                                  compare_values(bcx, test_val, val, t)\n+                              }\n+                              range_result(\n+                                  Result {val: vbegin, _},\n+                                  Result {bcx, val: vend}) => {\n+                                  let Result {bcx, val: llge} =\n+                                      compare_scalar_types(\n+                                          bcx, test_val,\n+                                          vbegin, t, ast::ge);\n+                                  let Result {bcx, val: llle} =\n+                                      compare_scalar_types(\n+                                          bcx, test_val, vend,\n+                                          t, ast::le);\n+                                  rslt(bcx, And(bcx, llge, llle))\n+                              }\n+                          }\n+                      }\n+                  };\n+                  bcx = sub_block(after_cx, ~\"compare_next\");\n+                  CondBr(after_cx, matches, opt_cx.llbb, bcx.llbb);\n               }\n-              _ => ()\n+                _ => ()\n             }\n-        } else if kind == compare { Br(bcx, else_cx.llbb); }\n+        } else if kind == compare {\n+            Br(bcx, else_cx.llbb);\n+        }\n+\n         let mut size = 0u;\n         let mut unpacked = ~[];\n         match opt {\n-          var(_, vdef) => {\n-            let args = extract_variant_args(opt_cx, pat_id, vdef, val);\n-            size = args.vals.len();\n-            unpacked = args.vals;\n-            opt_cx = args.bcx;\n-          }\n-          lit(_) | range(_, _) => ()\n+            var(_, vdef) => {\n+                let args = extract_variant_args(opt_cx, pat_id, vdef, val);\n+                size = args.vals.len();\n+                unpacked = args.vals;\n+                opt_cx = args.bcx;\n+            }\n+            lit(_) | range(_, _) => ()\n         }\n-        compile_submatch(opt_cx, enter_opt(bcx, m, opt, col, size, val),\n-                         vec::append(unpacked, vals_left), chk, exits);\n+        let opt_ms = enter_opt(opt_cx, m, opt, col, size, val);\n+        let opt_vals = vec::append(unpacked, vals_left);\n+        compile_submatch(opt_cx, opt_ms, opt_vals, chk);\n     }\n \n     // Compile the fall-through case, if any\n     if !exhaustive {\n         if kind == compare { Br(bcx, else_cx.llbb); }\n         if kind != single {\n-            compile_submatch(else_cx, defaults, vals_left, chk, exits);\n-        }\n-    }\n-}\n-\n-struct phi_binding {\n-    pat_id: ast::node_id,\n-    phi_val: ValueRef,\n-    mode: ast::binding_mode,\n-    ty: ty::t\n-}\n-\n-type phi_bindings_list = ~[phi_binding];\n-\n-// Returns false for unreachable blocks\n-fn make_phi_bindings(bcx: block,\n-                     map: ~[exit_node],\n-                     ids: pat_util::pat_id_map)\n-    -> Option<phi_bindings_list> {\n-    let _icx = bcx.insn_ctxt(\"alt::make_phi_bindings\");\n-    let our_block = bcx.llbb as uint;\n-    let mut phi_bindings = ~[];\n-    for ids.each |name, node_id| {\n-        let mut llbbs = ~[];\n-        let mut vals = ~[];\n-        let mut binding = None;\n-        for vec::each(map) |ex| {\n-            if ex.to as uint == our_block {\n-                match assoc(name, ex.bound) {\n-                  Some(b) => {\n-                    vec::push(llbbs, ex.from);\n-                    vec::push(vals, b.val);\n-                    binding = Some(b);\n-                  }\n-                  None => ()\n-                }\n-            }\n+            compile_submatch(else_cx, defaults, vals_left, chk);\n         }\n-\n-        let binding = match binding {\n-          Some(binding) => binding,\n-          None => {\n-            Unreachable(bcx);\n-            return None;\n-          }\n-        };\n-\n-        let phi_val = Phi(bcx, val_ty(vals[0]), vals, llbbs);\n-        vec::push(phi_bindings, phi_binding {\n-            pat_id: node_id,\n-            phi_val: phi_val,\n-            mode: binding.mode,\n-            ty: binding.ty\n-        });\n     }\n-    return Some(move phi_bindings);\n-}\n-\n-// Copies by-value bindings into their homes.\n-fn make_pattern_bindings(bcx: block, phi_bindings: phi_bindings_list)\n-    -> block {\n-    let mut bcx = bcx;\n-\n-    for phi_bindings.each |binding| {\n-        let phi_val = binding.phi_val;\n-        match binding.mode {\n-            ast::bind_by_implicit_ref => {\n-                // use local: phi is a ptr to the value\n-                bcx.fcx.lllocals.insert(binding.pat_id,\n-                                        local_mem(phi_val));\n-            }\n-            ast::bind_by_ref(_) => {\n-                // use local_imm: ptr is the value\n-                bcx.fcx.lllocals.insert(binding.pat_id,\n-                                        local_imm(phi_val));\n-            }\n-            ast::bind_by_value | ast::bind_by_move => {\n-                // by value: make a new temporary and copy the value out\n-                let phi_datum = Datum {val: phi_val, ty: binding.ty,\n-                                       mode: ByRef, source: FromLvalue};\n-                let scratch = scratch_datum(bcx, binding.ty, false);\n-                if binding.mode == ast::bind_by_value {\n-                    phi_datum.copy_to_datum(bcx, INIT, scratch);\n-                } else {\n-                    phi_datum.move_to_datum(bcx, INIT, scratch);\n-                }\n-                bcx.fcx.lllocals.insert(binding.pat_id,\n-                                        local_mem(scratch.val));\n-                add_clean(bcx, scratch.val, binding.ty);\n-            }\n-        }\n-    }\n-\n-    return bcx;\n }\n \n fn trans_alt(bcx: block,\n@@ -816,7 +1073,7 @@ fn trans_alt(bcx: block,\n \n fn trans_alt_inner(scope_cx: block,\n                    discr_expr: @ast::expr,\n-                   arms: ~[ast::arm],\n+                   arms: &[ast::arm],\n                    dest: Dest) -> block {\n     let _icx = scope_cx.insn_ctxt(\"alt::trans_alt_inner\");\n     let mut bcx = scope_cx;\n@@ -829,16 +1086,50 @@ fn trans_alt_inner(scope_cx: block,\n         return bcx;\n     }\n \n-    let mut bodies = ~[], matches = ~[];\n-    for vec::each(arms) |a| {\n-        let body = scope_block(bcx, a.body.info(), ~\"case_body\");\n-        let id_map = pat_util::pat_id_map(tcx.def_map, a.pats[0]);\n-        vec::push(bodies, body);\n-        for vec::each(a.pats) |p| {\n-            vec::push(matches, @{pats: ~[p],\n-                        bound: ~[],\n-                        data: @{bodycx: body, guard: a.guard,\n-                                id_map: id_map}});\n+    let mut arm_datas = ~[], matches = ~[];\n+    for vec::each_ref(arms) |arm| {\n+        let body = scope_block(bcx, arm.body.info(), ~\"case_body\");\n+\n+        // Create the bindings map, which is a mapping from each binding name\n+        // to an alloca() that will be the value for that local variable.\n+        // Note that we use the names because each binding will have many ids\n+        // from the various alternatives.\n+        let bindings_map = std::map::uint_hash();\n+        do pat_bindings(tcx.def_map, arm.pats[0]) |bm, p_id, _s, path| {\n+            let ident = path_to_ident(path);\n+            let variable_ty = node_id_type(bcx, p_id);\n+            let llvariable_ty = type_of::type_of(bcx.ccx(), variable_ty);\n+\n+            let llmatch, trmode;\n+            match bm {\n+                ast::bind_by_value | ast::bind_by_move => {\n+                    // in this case, the type of the variable will be T,\n+                    // but we need to store a *T\n+                    let is_move = (bm == ast::bind_by_move);\n+                    llmatch = alloca(bcx, T_ptr(llvariable_ty));\n+                    trmode = TrByValue(is_move, alloca(bcx, llvariable_ty));\n+                }\n+                ast::bind_by_implicit_ref => {\n+                    llmatch = alloca(bcx, T_ptr(llvariable_ty));\n+                    trmode = TrByImplicitRef;\n+                }\n+                ast::bind_by_ref(_) => {\n+                    llmatch = alloca(bcx, llvariable_ty);\n+                    trmode = TrByRef;\n+                }\n+            };\n+            bindings_map.insert(ident, BindingInfo {\n+                llmatch: llmatch, trmode: trmode,\n+                id: p_id, ty: variable_ty\n+            });\n+        }\n+\n+        let arm_data = @ArmData {bodycx: body,\n+                                 arm: arm,\n+                                 bindings_map: bindings_map};\n+        vec::push(arm_datas, arm_data);\n+        for vec::each(arm.pats) |p| {\n+            vec::push(matches, @Match {pats: ~[p], data: arm_data});\n         }\n     }\n \n@@ -853,28 +1144,30 @@ fn trans_alt_inner(scope_cx: block,\n             None\n         }\n     };\n-    let mut exit_map = ~[];\n     let lldiscr = discr_datum.to_ref_llval(bcx);\n-    compile_submatch(bcx, matches, ~[lldiscr], chk, exit_map);\n-\n-    let mut arm_cxs = ~[], i = 0u;\n-    for vec::each(arms) |a| {\n-        let body_cx = bodies[i];\n-        let id_map = pat_util::pat_id_map(tcx.def_map, a.pats[0]);\n-        match make_phi_bindings(body_cx, exit_map, id_map) {\n-            None => {}\n-            Some(phi_bindings) => {\n-                let body_cx = make_pattern_bindings(body_cx, phi_bindings);\n-                let mut arm_cx =\n-                    controlflow::trans_block(body_cx, a.body, dest);\n-                arm_cx = trans_block_cleanups(arm_cx,\n-                                              block_cleanups(body_cx));\n-                vec::push(arm_cxs, arm_cx);\n-            }\n+    compile_submatch(bcx, matches, ~[lldiscr], chk);\n+\n+    let arm_cxs = DVec();\n+    for arm_datas.each |arm_data| {\n+        let mut bcx = arm_data.bodycx;\n+\n+        // If this arm has a guard, then the various by-value bindings have\n+        // already been copied into their homes.  If not, we do it here.  This\n+        // is just to reduce code space.  See extensive comment at the start\n+        // of the file for more details.\n+        if arm_data.arm.guard.is_none() {\n+            bcx = store_non_ref_bindings(bcx, arm_data, None);\n         }\n-        i += 1u;\n+\n+        // insert bindings into the lllocals map and add cleanups\n+        bcx = insert_lllocals(bcx, arm_data, true);\n+\n+        bcx = controlflow::trans_block(bcx, arm_data.arm.body, dest);\n+        bcx = trans_block_cleanups(bcx, block_cleanups(arm_data.bodycx));\n+        arm_cxs.push(bcx);\n     }\n-    return controlflow::join_blocks(scope_cx, arm_cxs);\n+\n+    return controlflow::join_blocks(scope_cx, dvec::unwrap(arm_cxs));\n \n     fn mk_fail(bcx: block, sp: span, msg: ~str,\n                done: @mut Option<BasicBlockRef>) -> BasicBlockRef {"}, {"sha": "2fb7b8a48907816f29f8d1159021113c4b267eab", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34bf0b9e979e528f14e1265a36488d0707e71805/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34bf0b9e979e528f14e1265a36488d0707e71805/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=34bf0b9e979e528f14e1265a36488d0707e71805", "patch": "@@ -49,7 +49,7 @@ use metadata::csearch;\n use driver::session::session;\n use util::common::may_break;\n use syntax::codemap::span;\n-use pat_util::{pat_is_variant, pat_id_map};\n+use pat_util::{pat_is_variant, pat_id_map, PatIdMap};\n use middle::ty;\n use middle::ty::{arg, field, node_type_table, mk_nil, ty_param_bounds_and_ty};\n use middle::ty::{vstore_uniq};"}, {"sha": "b0cd3157b35f762fa6a25e51c07a332c3be6019e", "filename": "src/rustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34bf0b9e979e528f14e1265a36488d0707e71805/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34bf0b9e979e528f14e1265a36488d0707e71805/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=34bf0b9e979e528f14e1265a36488d0707e71805", "patch": "@@ -111,7 +111,7 @@ fn check_legality_of_move_bindings(fcx: @fn_ctxt,\n \n type pat_ctxt = {\n     fcx: @fn_ctxt,\n-    map: pat_id_map,\n+    map: PatIdMap,\n     alt_region: ty::region,   // Region for the alt as a whole\n     block_region: ty::region, // Region for the block of the arm\n };"}, {"sha": "6dc6440350a9333d13238b8446db97238489adb4", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/34bf0b9e979e528f14e1265a36488d0707e71805/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34bf0b9e979e528f14e1265a36488d0707e71805/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=34bf0b9e979e528f14e1265a36488d0707e71805", "patch": "@@ -112,17 +112,17 @@ fn explain_region_and_span(cx: ctxt, region: ty::region)\n fn bound_region_to_str(cx: ctxt, br: bound_region) -> ~str {\n     match br {\n       br_named(id)                   => fmt!(\"&%s\", cx.sess.str_of(id)),\n-      br_self if cx.sess.ppregions() => ~\"&<self>\",\n+      br_self if cx.sess.verbose() => ~\"&<self>\",\n       br_self                        => ~\"&self\",\n \n       br_anon(idx) => {\n-        if cx.sess.ppregions() {fmt!(\"&%u\", idx)} else {~\"&\"}\n+        if cx.sess.verbose() {fmt!(\"&%u\", idx)} else {~\"&\"}\n       }\n \n       // FIXME(#3011) -- even if this arm is removed, exhaustiveness checking\n       // does not fail\n       br_cap_avoid(id, br) => {\n-        if cx.sess.ppregions() {\n+        if cx.sess.verbose() {\n             fmt!(\"br_cap_avoid(%?, %s)\", id, bound_region_to_str(cx, *br))\n         } else {\n             bound_region_to_str(cx, *br)\n@@ -175,7 +175,7 @@ fn re_scope_id_to_str(cx: ctxt, node_id: ast::node_id) -> ~str {\n // you should use `explain_region()` or, better yet,\n // `note_and_explain_region()`\n fn region_to_str(cx: ctxt, region: region) -> ~str {\n-    if cx.sess.ppregions() {\n+    if cx.sess.verbose() {\n         return fmt!(\"&%?\", region);\n     }\n "}, {"sha": "d3181a6b9ccff9990265533e7d4db02fbac85e73", "filename": "src/test/run-pass/alt-ref-binding-in-guard-3256.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/34bf0b9e979e528f14e1265a36488d0707e71805/src%2Ftest%2Frun-pass%2Falt-ref-binding-in-guard-3256.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34bf0b9e979e528f14e1265a36488d0707e71805/src%2Ftest%2Frun-pass%2Falt-ref-binding-in-guard-3256.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-ref-binding-in-guard-3256.rs?ref=34bf0b9e979e528f14e1265a36488d0707e71805", "patch": "@@ -0,0 +1,9 @@\n+fn main() {\n+    let x = Some(unsafe::exclusive(true));\n+    match move x {\n+        Some(ref z) if z.with(|b| *b) => {\n+            do z.with |b| { assert *b; }\n+        },\n+        _ => fail\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "cdafcaf6a82fd8e19076710b0bf857c64788cde1", "filename": "src/test/run-pass/alt-value-binding-in-guard-3291.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/34bf0b9e979e528f14e1265a36488d0707e71805/src%2Ftest%2Frun-pass%2Falt-value-binding-in-guard-3291.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34bf0b9e979e528f14e1265a36488d0707e71805/src%2Ftest%2Frun-pass%2Falt-value-binding-in-guard-3291.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-value-binding-in-guard-3291.rs?ref=34bf0b9e979e528f14e1265a36488d0707e71805", "patch": "@@ -0,0 +1,14 @@\n+fn foo(x: Option<~int>, b: bool) -> int {\n+    match x {\n+      None => { 1 }\n+      Some(copy x) if b => { *x }\n+      Some(_) => { 0 }\n+    }\n+}\n+\n+fn main() {\n+    foo(Some(~22), true);\n+    foo(Some(~22), false);\n+    foo(None, true);\n+    foo(None, false);\n+}\n\\ No newline at end of file"}]}