{"sha": "8c378d30271de8cb9e09a4b70f28db71f282f413", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjMzc4ZDMwMjcxZGU4Y2I5ZTA5YTRiNzBmMjhkYjcxZjI4MmY0MTM=", "commit": {"author": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2021-02-13T20:58:44Z"}, "committer": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2021-02-15T23:22:56Z"}, "message": "Add documentation", "tree": {"sha": "6efccd300c81c6a473178968453af661f1669ed5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6efccd300c81c6a473178968453af661f1669ed5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c378d30271de8cb9e09a4b70f28db71f282f413", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c378d30271de8cb9e09a4b70f28db71f282f413", "html_url": "https://github.com/rust-lang/rust/commit/8c378d30271de8cb9e09a4b70f28db71f282f413", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c378d30271de8cb9e09a4b70f28db71f282f413/comments", "author": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "714ad639b39f7a35422b3fc342eb843013cc89ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/714ad639b39f7a35422b3fc342eb843013cc89ba", "html_url": "https://github.com/rust-lang/rust/commit/714ad639b39f7a35422b3fc342eb843013cc89ba"}], "stats": {"total": 162, "additions": 36, "deletions": 126}, "files": [{"sha": "9da2bdfce42e90b9eb3dcb38bb104c043935259c", "filename": "crates/core_simd/tests/helpers/biteq.rs", "status": "removed", "additions": 0, "deletions": 120, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/714ad639b39f7a35422b3fc342eb843013cc89ba/crates%2Fcore_simd%2Ftests%2Fhelpers%2Fbiteq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/714ad639b39f7a35422b3fc342eb843013cc89ba/crates%2Fcore_simd%2Ftests%2Fhelpers%2Fbiteq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fhelpers%2Fbiteq.rs?ref=714ad639b39f7a35422b3fc342eb843013cc89ba", "patch": "@@ -1,120 +0,0 @@\n-pub(crate) trait BitEq {\n-    fn biteq(&self, other: &Self) -> bool;\n-    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result;\n-}\n-\n-macro_rules! impl_biteq {\n-    { integer impl BitEq for $($type:ty,)* } => {\n-        $(\n-        impl BitEq for $type {\n-            fn biteq(&self, other: &Self) -> bool {\n-                self == other\n-            }\n-\n-            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                write!(f, \"{:?} ({:x})\", self, self)\n-            }\n-        }\n-        )*\n-    };\n-    { float impl BitEq for $($type:ty,)* } => {\n-        $(\n-        impl BitEq for $type {\n-            fn biteq(&self, other: &Self) -> bool {\n-                self.to_bits() == other.to_bits()\n-            }\n-\n-            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                write!(f, \"{:?} ({:x})\", self, self.to_bits())\n-            }\n-        }\n-        )*\n-    };\n-    { vector impl BitEq for $($type:ty,)* } => {\n-        $(\n-        impl BitEq for $type {\n-            fn biteq(&self, other: &Self) -> bool {\n-                let a: &[_] = self.as_ref();\n-                let b: &[_] = other.as_ref();\n-                if a.len() == b.len() {\n-                    a.iter().zip(b.iter()).fold(true, |value, (left, right)| {\n-                        value && left.biteq(right)\n-                    })\n-                } else {\n-                    false\n-                }\n-            }\n-\n-            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                #[repr(transparent)]\n-                struct Wrapper<'a, T: BitEq>(&'a T);\n-\n-                impl<T: BitEq> core::fmt::Debug for Wrapper<'_, T> {\n-                    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                        self.0.fmt(f)\n-                    }\n-                }\n-\n-                let slice: &[_] = self.as_ref();\n-\n-                f.debug_list()\n-                    .entries(slice.iter().map(|x| Wrapper(x)))\n-                    .finish()\n-            }\n-        }\n-        )*\n-    };\n-}\n-\n-impl_biteq! {\n-    integer impl BitEq for\n-        u8, u16, u32, u64, u128, usize,\n-        i8, i16, i32, i64, i128, isize,\n-}\n-\n-impl_biteq! {\n-    float impl BitEq for f32, f64,\n-}\n-\n-impl_biteq! {\n-    vector impl BitEq for\n-        core_simd::u8x8,    core_simd::u8x16,   core_simd::u8x32,   core_simd::u8x64,\n-        core_simd::i8x8,    core_simd::i8x16,   core_simd::i8x32,   core_simd::i8x64,\n-        core_simd::u16x4,   core_simd::u16x8,   core_simd::u16x16,  core_simd::u16x32,\n-        core_simd::i16x4,   core_simd::i16x8,   core_simd::i16x16,  core_simd::i16x32,\n-        core_simd::u32x2,   core_simd::u32x4,   core_simd::u32x8,   core_simd::u32x16,\n-        core_simd::i32x2,   core_simd::i32x4,   core_simd::i32x8,   core_simd::i32x16,\n-        core_simd::u64x2,   core_simd::u64x4,   core_simd::u64x8,\n-        core_simd::i64x2,   core_simd::i64x4,   core_simd::i64x8,\n-        core_simd::u128x2,  core_simd::u128x4,\n-        core_simd::i128x2,  core_simd::i128x4,\n-        core_simd::usizex2, core_simd::usizex4, core_simd::usizex8,\n-        core_simd::isizex2, core_simd::isizex4, core_simd::isizex8,\n-        core_simd::f32x2, core_simd::f32x4, core_simd::f32x8, core_simd::f32x16,\n-        core_simd::f64x2, core_simd::f64x4, core_simd::f64x8,\n-}\n-\n-pub(crate) struct BitEqWrapper<'a, T>(pub(crate) &'a T);\n-\n-impl<T: BitEq> PartialEq for BitEqWrapper<'_, T> {\n-    fn eq(&self, other: &Self) -> bool {\n-        self.0.biteq(other.0)\n-    }\n-}\n-\n-impl<T: BitEq> core::fmt::Debug for BitEqWrapper<'_, T> {\n-    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-        self.0.fmt(f)\n-    }\n-}\n-\n-macro_rules! assert_biteq {\n-    { $a:expr, $b:expr } => {\n-        {\n-            use helpers::biteq::BitEqWrapper;\n-            let a = $a;\n-            let b = $b;\n-            assert_eq!(BitEqWrapper(&a), BitEqWrapper(&b));\n-        }\n-    }\n-}"}, {"sha": "41b4fea9d95d09a14496133e4631845edd8f857b", "filename": "crates/core_simd/tests/helpers/mod.rs", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/714ad639b39f7a35422b3fc342eb843013cc89ba/crates%2Fcore_simd%2Ftests%2Fhelpers%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/714ad639b39f7a35422b3fc342eb843013cc89ba/crates%2Fcore_simd%2Ftests%2Fhelpers%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fhelpers%2Fmod.rs?ref=714ad639b39f7a35422b3fc342eb843013cc89ba", "patch": "@@ -1,2 +0,0 @@\n-#[macro_use]\n-pub mod biteq;"}, {"sha": "99d735be29356d718370be1f8aba14c549a33865", "filename": "crates/core_simd/tests/mask_ops_impl/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c378d30271de8cb9e09a4b70f28db71f282f413/crates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c378d30271de8cb9e09a4b70f28db71f282f413/crates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmod.rs?ref=8c378d30271de8cb9e09a4b70f28db71f282f413", "patch": "@@ -1,7 +1,3 @@\n-#[macro_use]\n-#[path = \"../helpers/mod.rs\"]\n-mod helpers;\n-\n #[macro_use]\n mod mask_macros;\n "}, {"sha": "58e80a8f277e0bc1291319ea6ce6d441d03c9963", "filename": "crates/core_simd/tests/ops_macros.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8c378d30271de8cb9e09a4b70f28db71f282f413/crates%2Fcore_simd%2Ftests%2Fops_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c378d30271de8cb9e09a4b70f28db71f282f413/crates%2Fcore_simd%2Ftests%2Fops_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_macros.rs?ref=8c378d30271de8cb9e09a4b70f28db71f282f413", "patch": "@@ -1,3 +1,6 @@\n+/// Implements a test on a unary operation using proptest.\n+///\n+/// Compares the vector operation to the equivalent scalar operation.\n #[macro_export]\n macro_rules! impl_unary_op_test {\n     { $vector:ty, $scalar:ty, $trait:ident :: $fn:ident, $scalar_fn:expr } => {\n@@ -16,6 +19,9 @@ macro_rules! impl_unary_op_test {\n     };\n }\n \n+/// Implements a test on a binary operation using proptest.\n+///\n+/// Compares the vector operation to the equivalent scalar operation.\n #[macro_export]\n macro_rules! impl_binary_op_test {\n     { $vector:ty, $scalar:ty, $trait:ident :: $fn:ident, $trait_assign:ident :: $fn_assign:ident, $scalar_fn:expr } => {\n@@ -70,6 +76,12 @@ macro_rules! impl_binary_op_test {\n     };\n }\n \n+/// Implements a test on a binary operation using proptest.\n+///\n+/// Like `impl_binary_op_test`, but allows providing a function for rejecting particular inputs\n+/// (like the `proptest_assume` macro).\n+///\n+/// Compares the vector operation to the equivalent scalar operation.\n #[macro_export]\n macro_rules! impl_binary_checked_op_test {\n     { $vector:ty, $scalar:ty, $trait:ident :: $fn:ident, $trait_assign:ident :: $fn_assign:ident, $scalar_fn:expr, $check_fn:expr } => {\n@@ -124,6 +136,7 @@ macro_rules! impl_binary_checked_op_test {\n     };\n }\n \n+/// Implement tests for signed integers.\n #[macro_export]\n macro_rules! impl_signed_tests {\n     { $vector:ident, $scalar:tt } => {\n@@ -191,6 +204,8 @@ macro_rules! impl_signed_tests {\n             impl_binary_op_test!(Vector<LANES>, Scalar, Add::add, AddAssign::add_assign, Scalar::wrapping_add);\n             impl_binary_op_test!(Vector<LANES>, Scalar, Sub::sub, SubAssign::sub_assign, Scalar::wrapping_sub);\n             impl_binary_op_test!(Vector<LANES>, Scalar, Mul::mul, MulAssign::mul_assign, Scalar::wrapping_mul);\n+\n+            // Exclude Div and Rem panicking cases\n             impl_binary_checked_op_test!(Vector<LANES>, Scalar, Div::div, DivAssign::div_assign, Scalar::wrapping_div, |x, y| y != 0 && !(x == Scalar::MIN && y == -1));\n             impl_binary_checked_op_test!(Vector<LANES>, Scalar, Rem::rem, RemAssign::rem_assign, Scalar::wrapping_rem, |x, y| y != 0 && !(x == Scalar::MIN && y == -1));\n \n@@ -202,6 +217,7 @@ macro_rules! impl_signed_tests {\n     }\n }\n \n+/// Implement tests for unsigned integers.\n #[macro_export]\n macro_rules! impl_unsigned_tests {\n     { $vector:ident, $scalar:tt } => {\n@@ -220,6 +236,8 @@ macro_rules! impl_unsigned_tests {\n             impl_binary_op_test!(Vector<LANES>, Scalar, Add::add, AddAssign::add_assign, Scalar::wrapping_add);\n             impl_binary_op_test!(Vector<LANES>, Scalar, Sub::sub, SubAssign::sub_assign, Scalar::wrapping_sub);\n             impl_binary_op_test!(Vector<LANES>, Scalar, Mul::mul, MulAssign::mul_assign, Scalar::wrapping_mul);\n+\n+            // Exclude Div and Rem panicking cases\n             impl_binary_checked_op_test!(Vector<LANES>, Scalar, Div::div, DivAssign::div_assign, Scalar::wrapping_div, |_, y| y != 0);\n             impl_binary_checked_op_test!(Vector<LANES>, Scalar, Rem::rem, RemAssign::rem_assign, Scalar::wrapping_rem, |_, y| y != 0);\n \n@@ -231,6 +249,7 @@ macro_rules! impl_unsigned_tests {\n     }\n }\n \n+/// Implement tests for floating point numbers.\n #[macro_export]\n macro_rules! impl_float_tests {\n     { $vector:ident, $scalar:tt, $int_scalar:tt } => {"}, {"sha": "c64bfee4f2d1f772a680f04d6c5bed4b84654cdb", "filename": "crates/test_helpers/src/array.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c378d30271de8cb9e09a4b70f28db71f282f413/crates%2Ftest_helpers%2Fsrc%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c378d30271de8cb9e09a4b70f28db71f282f413/crates%2Ftest_helpers%2Fsrc%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_helpers%2Fsrc%2Farray.rs?ref=8c378d30271de8cb9e09a4b70f28db71f282f413", "patch": "@@ -1,3 +1,5 @@\n+//! Generic-length array strategy.\n+\n // Adapted from proptest's array code\n // Copyright 2017 Jason Lingle\n "}, {"sha": "8c62806438034b0e00e38e01e90ecc3f93c5f84f", "filename": "crates/test_helpers/src/biteq.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c378d30271de8cb9e09a4b70f28db71f282f413/crates%2Ftest_helpers%2Fsrc%2Fbiteq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c378d30271de8cb9e09a4b70f28db71f282f413/crates%2Ftest_helpers%2Fsrc%2Fbiteq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_helpers%2Fsrc%2Fbiteq.rs?ref=8c378d30271de8cb9e09a4b70f28db71f282f413", "patch": "@@ -1,3 +1,5 @@\n+//! Compare numeric types by exact bit value.\n+\n pub trait BitEq {\n     fn biteq(&self, other: &Self) -> bool;\n     fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result;"}, {"sha": "a81713e865b706b46592e81b07d3763cf44e5afd", "filename": "crates/test_helpers/src/lib.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8c378d30271de8cb9e09a4b70f28db71f282f413/crates%2Ftest_helpers%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c378d30271de8cb9e09a4b70f28db71f282f413/crates%2Ftest_helpers%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_helpers%2Fsrc%2Flib.rs?ref=8c378d30271de8cb9e09a4b70f28db71f282f413", "patch": "@@ -6,6 +6,9 @@ pub mod wasm;\n #[macro_use]\n pub mod biteq;\n \n+/// Specifies the default strategy for testing a type.\n+///\n+/// This strategy should be what \"makes sense\" to test.\n pub trait DefaultStrategy {\n     type Strategy: proptest::strategy::Strategy<Value = Self>;\n     fn default_strategy() -> Self::Strategy;\n@@ -74,13 +77,15 @@ impl<T: core::fmt::Debug + DefaultStrategy, const LANES: usize> DefaultStrategy\n     }\n }\n \n+/// Test a function that takes a single value.\n pub fn test_1<A: core::fmt::Debug + DefaultStrategy>(\n     f: &dyn Fn(A) -> proptest::test_runner::TestCaseResult,\n ) {\n     let mut runner = proptest::test_runner::TestRunner::default();\n     runner.run(&A::default_strategy(), f).unwrap();\n }\n \n+/// Test a function that takes two values.\n pub fn test_2<A: core::fmt::Debug + DefaultStrategy, B: core::fmt::Debug + DefaultStrategy>(\n     f: &dyn Fn(A, B) -> proptest::test_runner::TestCaseResult,\n ) {\n@@ -92,6 +97,7 @@ pub fn test_2<A: core::fmt::Debug + DefaultStrategy, B: core::fmt::Debug + Defau\n         .unwrap();\n }\n \n+/// Test a unary vector function against a unary scalar function, applied elementwise.\n #[inline(never)]\n pub fn test_unary_elementwise<Scalar, ScalarResult, Vector, VectorResult, const LANES: usize>(\n     fv: &dyn Fn(Vector) -> VectorResult,\n@@ -118,6 +124,7 @@ pub fn test_unary_elementwise<Scalar, ScalarResult, Vector, VectorResult, const\n     });\n }\n \n+/// Test a binary vector function against a binary scalar function, applied elementwise.\n #[inline(never)]\n pub fn test_binary_elementwise<\n     Scalar1,\n@@ -154,6 +161,7 @@ pub fn test_binary_elementwise<\n     });\n }\n \n+/// Test a binary vector-scalar function against a binary scalar function, applied elementwise.\n #[inline(never)]\n pub fn test_binary_scalar_rhs_elementwise<\n     Scalar1,\n@@ -188,6 +196,7 @@ pub fn test_binary_scalar_rhs_elementwise<\n     });\n }\n \n+/// Test a binary vector-scalar function against a binary scalar function, applied elementwise.\n #[inline(never)]\n pub fn test_binary_scalar_lhs_elementwise<\n     Scalar1,\n@@ -222,6 +231,7 @@ pub fn test_binary_scalar_lhs_elementwise<\n     });\n }\n \n+/// Expand a const-generic test into separate tests for each possible lane count.\n #[macro_export]\n macro_rules! test_lanes {\n     {\n@@ -282,6 +292,7 @@ macro_rules! test_lanes {\n     }\n }  \n \n+/// Expand a const-generic `#[should_panic]` test into separate tests for each possible lane count.\n #[macro_export]\n macro_rules! test_lanes_panic {\n     {"}, {"sha": "3f11d67cbf390bea2a93daaacaada98761e0a858", "filename": "crates/test_helpers/src/wasm.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c378d30271de8cb9e09a4b70f28db71f282f413/crates%2Ftest_helpers%2Fsrc%2Fwasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c378d30271de8cb9e09a4b70f28db71f282f413/crates%2Ftest_helpers%2Fsrc%2Fwasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_helpers%2Fsrc%2Fwasm.rs?ref=8c378d30271de8cb9e09a4b70f28db71f282f413", "patch": "@@ -1,3 +1,5 @@\n+//! Strategies for `u128` and `i128`, since proptest doesn't provide them for the wasm target.\n+\n macro_rules! impl_num {\n     { $name:ident } => {\n         pub(crate) mod $name {"}]}