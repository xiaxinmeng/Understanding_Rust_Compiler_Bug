{"sha": "4b71c8332daf9ef461891d278f2cf3530baaa833", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiNzFjODMzMmRhZjllZjQ2MTg5MWQyNzhmMmNmMzUzMGJhYWE4MzM=", "commit": {"author": {"name": "Arnaud", "email": "arnaud.golfouse@free.fr", "date": "2021-01-12T16:41:45Z"}, "committer": {"name": "Arnaud", "email": "arnaud.golfouse@free.fr", "date": "2021-01-12T17:01:47Z"}, "message": "Document vfs private items", "tree": {"sha": "1a0d16083438c999539c2c9e8a643e449e40fa53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a0d16083438c999539c2c9e8a643e449e40fa53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b71c8332daf9ef461891d278f2cf3530baaa833", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b71c8332daf9ef461891d278f2cf3530baaa833", "html_url": "https://github.com/rust-lang/rust/commit/4b71c8332daf9ef461891d278f2cf3530baaa833", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b71c8332daf9ef461891d278f2cf3530baaa833/comments", "author": null, "committer": null, "parents": [{"sha": "311ec70d03c27b1b37457ef44510e735fcce0885", "url": "https://api.github.com/repos/rust-lang/rust/commits/311ec70d03c27b1b37457ef44510e735fcce0885", "html_url": "https://github.com/rust-lang/rust/commit/311ec70d03c27b1b37457ef44510e735fcce0885"}], "stats": {"total": 119, "additions": 117, "deletions": 2}, "files": [{"sha": "0a4590c8db1abc2d8690ebce6af2a061ee1664f1", "filename": "crates/vfs/src/file_set.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4b71c8332daf9ef461891d278f2cf3530baaa833/crates%2Fvfs%2Fsrc%2Ffile_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b71c8332daf9ef461891d278f2cf3530baaa833/crates%2Fvfs%2Fsrc%2Ffile_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Ffile_set.rs?ref=4b71c8332daf9ef461891d278f2cf3530baaa833", "patch": "@@ -83,7 +83,12 @@ impl fmt::Debug for FileSet {\n /// ```\n #[derive(Debug)]\n pub struct FileSetConfig {\n+    /// Number of sets that `self` can partition a [`Vfs`] into.\n+    ///\n+    /// This should be the number of sets in `self.map` + 1 for files that don't fit in any\n+    /// defined set.\n     n_file_sets: usize,\n+    /// Map from encoded paths to the set they belong to.\n     map: fst::Map<Vec<u8>>,\n }\n \n@@ -111,9 +116,15 @@ impl FileSetConfig {\n         }\n         res\n     }\n+\n+    /// Number of sets that `self` can partition a [`Vfs`] into.\n     fn len(&self) -> usize {\n         self.n_file_sets\n     }\n+\n+    /// Returns the set index for the given `path`.\n+    ///\n+    /// `scratch_space` is used as a buffer and will be entirely replaced.\n     fn classify(&self, path: &VfsPath, scratch_space: &mut Vec<u8>) -> usize {\n         scratch_space.clear();\n         path.encode(scratch_space);\n@@ -169,11 +180,15 @@ impl FileSetConfigBuilder {\n     }\n }\n \n+/// Implements [`fst::Automaton`]\n+///\n+/// It will match if `prefix_of` is a prefix of the given data.\n struct PrefixOf<'a> {\n     prefix_of: &'a [u8],\n }\n \n impl<'a> PrefixOf<'a> {\n+    /// Creates a new `PrefixOf` from the given slice.\n     fn new(prefix_of: &'a [u8]) -> Self {\n         Self { prefix_of }\n     }"}, {"sha": "e075d752b7ff4a7ebe2b70a8a2ed9543488a17bb", "filename": "crates/vfs/src/lib.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4b71c8332daf9ef461891d278f2cf3530baaa833/crates%2Fvfs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b71c8332daf9ef461891d278f2cf3530baaa833/crates%2Fvfs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Flib.rs?ref=4b71c8332daf9ef461891d278f2cf3530baaa833", "patch": "@@ -176,16 +176,36 @@ impl Vfs {\n     pub fn take_changes(&mut self) -> Vec<ChangedFile> {\n         mem::take(&mut self.changes)\n     }\n+\n+    /// Returns the id associated with `path`\n+    ///\n+    /// - If `path` does not exists in the `Vfs`, allocate a new id for it, associated with a\n+    /// deleted file;\n+    /// - Else, returns `path`'s id.\n+    ///\n+    /// Does not record a change.\n     fn alloc_file_id(&mut self, path: VfsPath) -> FileId {\n         let file_id = self.interner.intern(path);\n         let idx = file_id.0 as usize;\n         let len = self.data.len().max(idx + 1);\n         self.data.resize_with(len, || None);\n         file_id\n     }\n+\n+    /// Returns the content associated with the given `file_id`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if no file is associated to that id.\n     fn get(&self, file_id: FileId) -> &Option<Vec<u8>> {\n         &self.data[file_id.0 as usize]\n     }\n+\n+    /// Mutably returns the content associated with the given `file_id`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if no file is associated to that id.\n     fn get_mut(&mut self, file_id: FileId) -> &mut Option<Vec<u8>> {\n         &mut self.data[file_id.0 as usize]\n     }"}, {"sha": "d3bdae562d49a32ab1192c03f58c47ca91f01643", "filename": "crates/vfs/src/loader.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4b71c8332daf9ef461891d278f2cf3530baaa833/crates%2Fvfs%2Fsrc%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b71c8332daf9ef461891d278f2cf3530baaa833/crates%2Fvfs%2Fsrc%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Floader.rs?ref=4b71c8332daf9ef461891d278f2cf3530baaa833", "patch": "@@ -147,6 +147,13 @@ impl Directories {\n     pub fn contains_dir(&self, path: &AbsPath) -> bool {\n         self.includes_path(path)\n     }\n+\n+    /// Returns `true` if `path` is included in `self`.\n+    ///\n+    /// It is included if\n+    ///   - An element in `self.include` is a prefix of `path`.\n+    ///   - This path is longer than any element in `self.exclude` that is a prefix\n+    ///     of `path`. In case of equality, exclusion wins.\n     fn includes_path(&self, path: &AbsPath) -> bool {\n         let mut include: Option<&AbsPathBuf> = None;\n         for incl in &self.include {\n@@ -170,6 +177,14 @@ impl Directories {\n     }\n }\n \n+/// Returns :\n+/// ```text\n+/// Directories {\n+///     extensions: [\"rs\"],\n+///     include: [base],\n+///     exclude: [base/<exclude>],\n+/// }\n+/// ```\n fn dirs(base: AbsPathBuf, exclude: &[&str]) -> Directories {\n     let exclude = exclude.iter().map(|it| base.join(it)).collect::<Vec<_>>();\n     Directories { extensions: vec![\"rs\".to_string()], include: vec![base], exclude }"}, {"sha": "2189e5e258e62015bc4b1984c3c4c288359dcf9c", "filename": "crates/vfs/src/path_interner.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4b71c8332daf9ef461891d278f2cf3530baaa833/crates%2Fvfs%2Fsrc%2Fpath_interner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b71c8332daf9ef461891d278f2cf3530baaa833/crates%2Fvfs%2Fsrc%2Fpath_interner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Fpath_interner.rs?ref=4b71c8332daf9ef461891d278f2cf3530baaa833", "patch": "@@ -5,16 +5,25 @@ use rustc_hash::FxHashMap;\n \n use crate::{FileId, VfsPath};\n \n+/// Structure to map between [`VfsPath`] and [`FileId`].\n #[derive(Default)]\n pub(crate) struct PathInterner {\n     map: FxHashMap<VfsPath, FileId>,\n     vec: Vec<VfsPath>,\n }\n \n impl PathInterner {\n+    /// Get the id corresponding to `path`.\n+    ///\n+    /// If `path` does not exists in `self`, returns [`None`].\n     pub(crate) fn get(&self, path: &VfsPath) -> Option<FileId> {\n         self.map.get(path).copied()\n     }\n+\n+    /// Insert `path` in `self`.\n+    ///\n+    /// - If `path` already exists in `self`, returns its associated id;\n+    /// - Else, returns a newly allocated id.\n     pub(crate) fn intern(&mut self, path: VfsPath) -> FileId {\n         if let Some(id) = self.get(&path) {\n             return id;\n@@ -25,6 +34,11 @@ impl PathInterner {\n         id\n     }\n \n+    /// Returns the path corresponding to `id`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `id` does not exists in `self`.\n     pub(crate) fn lookup(&self, id: FileId) -> &VfsPath {\n         &self.vec[id.0 as usize]\n     }"}, {"sha": "2b3d7fd84f03c3584cb2be83bb3aac04ad3c1c3e", "filename": "crates/vfs/src/vfs_path.rs", "status": "modified", "additions": 53, "deletions": 2, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/4b71c8332daf9ef461891d278f2cf3530baaa833/crates%2Fvfs%2Fsrc%2Fvfs_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b71c8332daf9ef461891d278f2cf3530baaa833/crates%2Fvfs%2Fsrc%2Fvfs_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Fvfs_path.rs?ref=4b71c8332daf9ef461891d278f2cf3530baaa833", "patch": "@@ -102,7 +102,14 @@ impl VfsPath {\n         }\n     }\n \n-    // Don't make this `pub`\n+    /// **Don't make this `pub`**\n+    ///\n+    /// Encode the path in the given buffer.\n+    ///\n+    /// The encoding will be `0` if [`AbsPathBuf`], `1` if [`VirtualPath`], followed\n+    /// by `self`'s representation.\n+    ///\n+    /// Note that this encoding is dependent on the operating system.\n     pub(crate) fn encode(&self, buf: &mut Vec<u8>) {\n         let tag = match &self.0 {\n             VfsPathRepr::PathBuf(_) => 0,\n@@ -259,6 +266,7 @@ mod windows_paths {\n     }\n }\n \n+/// Internal, private representation of [`VfsPath`].\n #[derive(Clone, Ord, PartialOrd, Eq, PartialEq, Hash)]\n enum VfsPathRepr {\n     PathBuf(AbsPathBuf),\n@@ -295,13 +303,34 @@ impl fmt::Debug for VfsPathRepr {\n     }\n }\n \n+/// `/`-separated virtual path.\n+///\n+/// This is used to describe files that do not reside on the file system.\n #[derive(Debug, Clone, Ord, PartialOrd, Eq, PartialEq, Hash)]\n struct VirtualPath(String);\n \n impl VirtualPath {\n+    /// Returns `true` if `other` is a prefix of `self` (as strings).\n     fn starts_with(&self, other: &VirtualPath) -> bool {\n         self.0.starts_with(&other.0)\n     }\n+\n+    /// Remove the last component of `self`.\n+    ///\n+    /// This will find the last `'/'` in `self`, and remove everything after it,\n+    /// including the `'/'`.\n+    ///\n+    /// If `self` contains no `'/'`, returns `false`; else returns `true`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust,ignore\n+    /// let mut path = VirtualPath(\"/foo/bar\".to_string());\n+    /// path.pop();\n+    /// assert_eq!(path.0, \"/foo\");\n+    /// path.pop();\n+    /// assert_eq!(path.0, \"\");\n+    /// ```\n     fn pop(&mut self) -> bool {\n         let pos = match self.0.rfind('/') {\n             Some(pos) => pos,\n@@ -310,6 +339,17 @@ impl VirtualPath {\n         self.0 = self.0[..pos].to_string();\n         true\n     }\n+\n+    /// Append the given *relative* path `path` to `self`.\n+    ///\n+    /// This will resolve any leading `\"../\"` in `path` before appending it.\n+    ///\n+    /// Returns [`None`] if `path` has more leading `\"../\"` than the number of\n+    /// components in `self`.\n+    ///\n+    /// # Notes\n+    ///\n+    /// In practice, appending here means `self/path` as strings.\n     fn join(&self, mut path: &str) -> Option<VirtualPath> {\n         let mut res = self.clone();\n         while path.starts_with(\"../\") {\n@@ -322,7 +362,18 @@ impl VirtualPath {\n         Some(res)\n     }\n \n-    pub(crate) fn name_and_extension(&self) -> Option<(&str, Option<&str>)> {\n+    /// Returns `self`'s base name and file extension.\n+    ///\n+    /// # Returns\n+    /// - `None` if `self` ends with `\"//\"`.\n+    /// - `Some((name, None))` if `self`'s base contains no `.`, or only one `.` at\n+    /// the start.\n+    /// - `Some((name, Some(extension))` else.\n+    ///\n+    /// # Note\n+    /// The extension will not contains `.`. This means `\"/foo/bar.baz.rs\"` will\n+    /// return `Some((\"bar.baz\", Some(\"rs\"))`.\n+    fn name_and_extension(&self) -> Option<(&str, Option<&str>)> {\n         let file_path = if self.0.ends_with('/') { &self.0[..&self.0.len() - 1] } else { &self.0 };\n         let file_name = match file_path.rfind('/') {\n             Some(position) => &file_path[position + 1..],"}]}