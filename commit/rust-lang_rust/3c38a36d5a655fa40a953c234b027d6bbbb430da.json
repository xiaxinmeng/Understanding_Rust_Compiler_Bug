{"sha": "3c38a36d5a655fa40a953c234b027d6bbbb430da", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjMzhhMzZkNWE2NTVmYTQwYTk1M2MyMzRiMDI3ZDZiYmJiNDMwZGE=", "commit": {"author": {"name": "Joe Clay", "email": "27cupsofcoffee@gmail.com", "date": "2018-04-19T19:34:31Z"}, "committer": {"name": "Joe Clay", "email": "27cupsofcoffee@gmail.com", "date": "2018-04-24T16:56:13Z"}, "message": "Implement lint for destructuring tuple structs with a let and a match (closes #2671)", "tree": {"sha": "de51354480995137d3904687e707269134234e47", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de51354480995137d3904687e707269134234e47"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c38a36d5a655fa40a953c234b027d6bbbb430da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c38a36d5a655fa40a953c234b027d6bbbb430da", "html_url": "https://github.com/rust-lang/rust/commit/3c38a36d5a655fa40a953c234b027d6bbbb430da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c38a36d5a655fa40a953c234b027d6bbbb430da/comments", "author": {"login": "17cupsofcoffee", "id": 784533, "node_id": "MDQ6VXNlcjc4NDUzMw==", "avatar_url": "https://avatars.githubusercontent.com/u/784533?v=4", "gravatar_id": "", "url": "https://api.github.com/users/17cupsofcoffee", "html_url": "https://github.com/17cupsofcoffee", "followers_url": "https://api.github.com/users/17cupsofcoffee/followers", "following_url": "https://api.github.com/users/17cupsofcoffee/following{/other_user}", "gists_url": "https://api.github.com/users/17cupsofcoffee/gists{/gist_id}", "starred_url": "https://api.github.com/users/17cupsofcoffee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/17cupsofcoffee/subscriptions", "organizations_url": "https://api.github.com/users/17cupsofcoffee/orgs", "repos_url": "https://api.github.com/users/17cupsofcoffee/repos", "events_url": "https://api.github.com/users/17cupsofcoffee/events{/privacy}", "received_events_url": "https://api.github.com/users/17cupsofcoffee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "17cupsofcoffee", "id": 784533, "node_id": "MDQ6VXNlcjc4NDUzMw==", "avatar_url": "https://avatars.githubusercontent.com/u/784533?v=4", "gravatar_id": "", "url": "https://api.github.com/users/17cupsofcoffee", "html_url": "https://github.com/17cupsofcoffee", "followers_url": "https://api.github.com/users/17cupsofcoffee/followers", "following_url": "https://api.github.com/users/17cupsofcoffee/following{/other_user}", "gists_url": "https://api.github.com/users/17cupsofcoffee/gists{/gist_id}", "starred_url": "https://api.github.com/users/17cupsofcoffee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/17cupsofcoffee/subscriptions", "organizations_url": "https://api.github.com/users/17cupsofcoffee/orgs", "repos_url": "https://api.github.com/users/17cupsofcoffee/repos", "events_url": "https://api.github.com/users/17cupsofcoffee/events{/privacy}", "received_events_url": "https://api.github.com/users/17cupsofcoffee/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae3213747d1bcd722e7a1236cd528cd32e1bafcb", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae3213747d1bcd722e7a1236cd528cd32e1bafcb", "html_url": "https://github.com/rust-lang/rust/commit/ae3213747d1bcd722e7a1236cd528cd32e1bafcb"}], "stats": {"total": 194, "additions": 194, "deletions": 0}, "files": [{"sha": "a2b3846b986fbd9914b4395487f1b4cb315d7fce", "filename": "clippy_lints/src/infallible_destructuring_match.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/3c38a36d5a655fa40a953c234b027d6bbbb430da/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c38a36d5a655fa40a953c234b027d6bbbb430da/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs?ref=3c38a36d5a655fa40a953c234b027d6bbbb430da", "patch": "@@ -0,0 +1,79 @@\n+use super::utils::{get_arg_name, match_var, remove_blocks, snippet, span_lint_and_sugg};\n+use rustc::hir::*;\n+use rustc::lint::*;\n+\n+/// **What it does:** Checks for matches being used to destructure a single-variant enum\n+/// or tuple struct where a `let` will suffice.\n+///\n+/// **Why is this bad?** Just readability \u2013 `let` doesn't nest, whereas a `match` does.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust\n+/// enum Wrapper {\n+///     Data(i32),\n+/// }\n+///\n+/// let wrapper = Wrapper::Data(42);\n+///\n+/// let data = match wrapper {\n+///     Wrapper::Data(i) => i,\n+/// };\n+/// ```\n+///\n+/// The correct use would be:\n+/// ```rust\n+/// enum Wrapper {\n+///     Data(i32),\n+/// }\n+///\n+/// let wrapper = Wrapper::Data(42);\n+/// let Wrapper::Data(data) = wrapper;\n+/// ```\n+declare_clippy_lint! {\n+    pub INFALLIBLE_DESTRUCTURING_MATCH,\n+    style,\n+    \"a match statement with a single infallible arm instead of a `let`\"\n+}\n+\n+#[derive(Copy, Clone, Default)]\n+pub struct Pass;\n+\n+impl LintPass for Pass {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(INFALLIBLE_DESTRUCTURING_MATCH)\n+    }\n+}\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_local(&mut self, cx: &LateContext<'a, 'tcx>, local: &'tcx Local) {\n+        if_chain! {\n+            if let Some(ref expr) = local.init;\n+            if let Expr_::ExprMatch(ref target, ref arms, MatchSource::Normal) = expr.node;\n+            if arms.len() == 1 && arms[0].pats.len() == 1 && arms[0].guard.is_none();\n+            if let PatKind::TupleStruct(QPath::Resolved(None, ref variant_name), ref args, _) = arms[0].pats[0].node;\n+            if args.len() == 1;\n+            if let Some(arg) = get_arg_name(&args[0]);\n+            let body = remove_blocks(&arms[0].body);\n+            if match_var(body, arg);\n+\n+            then {\n+                span_lint_and_sugg(\n+                    cx,\n+                    INFALLIBLE_DESTRUCTURING_MATCH,\n+                    local.span,\n+                    \"you seem to be trying to use match to destructure a single infallible pattern. \\\n+                     Consider using `let`\",\n+                    \"try this\",\n+                    format!(\n+                        \"let {}({}) = {};\",\n+                        snippet(cx, variant_name.span, \"..\"),\n+                        snippet(cx, local.pat.span, \"..\"),\n+                        snippet(cx, target.span, \"..\"),\n+                    ),\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "33dd352b6571dd22793432696965daf12ac93ed7", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c38a36d5a655fa40a953c234b027d6bbbb430da/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c38a36d5a655fa40a953c234b027d6bbbb430da/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=3c38a36d5a655fa40a953c234b027d6bbbb430da", "patch": "@@ -133,6 +133,7 @@ pub mod identity_conversion;\n pub mod identity_op;\n pub mod if_let_redundant_pattern_matching;\n pub mod if_not_else;\n+pub mod infallible_destructuring_match;\n pub mod infinite_iter;\n pub mod inline_fn_without_body;\n pub mod int_plus_one;\n@@ -407,6 +408,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box suspicious_trait_impl::SuspiciousImpl);\n     reg.register_late_lint_pass(box redundant_field_names::RedundantFieldNames);\n     reg.register_late_lint_pass(box map_unit_fn::Pass);\n+    reg.register_late_lint_pass(box infallible_destructuring_match::Pass);\n \n \n     reg.register_lint_group(\"clippy_restriction\", vec![\n@@ -522,6 +524,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         identity_conversion::IDENTITY_CONVERSION,\n         identity_op::IDENTITY_OP,\n         if_let_redundant_pattern_matching::IF_LET_REDUNDANT_PATTERN_MATCHING,\n+        infallible_destructuring_match::INFALLIBLE_DESTRUCTURING_MATCH,\n         infinite_iter::INFINITE_ITER,\n         inline_fn_without_body::INLINE_FN_WITHOUT_BODY,\n         int_plus_one::INT_PLUS_ONE,\n@@ -688,6 +691,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         formatting::SUSPICIOUS_ASSIGNMENT_FORMATTING,\n         formatting::SUSPICIOUS_ELSE_FORMATTING,\n         if_let_redundant_pattern_matching::IF_LET_REDUNDANT_PATTERN_MATCHING,\n+        infallible_destructuring_match::INFALLIBLE_DESTRUCTURING_MATCH,\n         len_zero::LEN_WITHOUT_IS_EMPTY,\n         len_zero::LEN_ZERO,\n         let_if_seq::USELESS_LET_IF_SEQ,"}, {"sha": "270272261b597c9b712719e5cfcf36a6c7fd5cc6", "filename": "tests/ui/infallible_destructuring_match.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/3c38a36d5a655fa40a953c234b027d6bbbb430da/tests%2Fui%2Finfallible_destructuring_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c38a36d5a655fa40a953c234b027d6bbbb430da/tests%2Fui%2Finfallible_destructuring_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finfallible_destructuring_match.rs?ref=3c38a36d5a655fa40a953c234b027d6bbbb430da", "patch": "@@ -0,0 +1,83 @@\n+#![feature(exhaustive_patterns)]\n+#![allow(let_and_return)]\n+\n+enum SingleVariantEnum {\n+    Variant(i32),\n+}\n+\n+struct TupleStruct(i32);\n+\n+enum EmptyEnum {}\n+\n+fn infallible_destructuring_match_enum() {\n+    let wrapper = SingleVariantEnum::Variant(0);\n+\n+    // This should lint!\n+    let data = match wrapper {\n+        SingleVariantEnum::Variant(i) => i,\n+    };\n+\n+    // This shouldn't!\n+    let data = match wrapper {\n+        SingleVariantEnum::Variant(_) => -1,\n+    };\n+\n+    // Neither should this!\n+    let data = match wrapper {\n+        SingleVariantEnum::Variant(i) => -1,\n+    };\n+\n+    let SingleVariantEnum::Variant(data) = wrapper;\n+}\n+\n+fn infallible_destructuring_match_struct() {\n+    let wrapper = TupleStruct(0);\n+\n+    // This should lint!\n+    let data = match wrapper {\n+        TupleStruct(i) => i,\n+    };\n+\n+    // This shouldn't!\n+    let data = match wrapper {\n+        TupleStruct(_) => -1,\n+    };\n+\n+    // Neither should this!\n+    let data = match wrapper {\n+        TupleStruct(i) => -1,\n+    };\n+\n+    let TupleStruct(data) = wrapper;\n+}\n+\n+fn never_enum() {\n+    let wrapper: Result<i32, !> = Ok(23);\n+\n+    // This should lint!\n+    let data = match wrapper {\n+        Ok(i) => i,\n+    };\n+\n+    // This shouldn't!\n+    let data = match wrapper {\n+        Ok(_) => -1,\n+    };\n+\n+    // Neither should this!\n+    let data = match wrapper {\n+        Ok(i) => -1,\n+    };\n+\n+    let Ok(data) = wrapper;\n+}\n+\n+impl EmptyEnum {\n+    fn match_on(&self) -> ! {\n+        // The lint shouldn't pick this up, as `let` won't work here!\n+        let data = match *self {};\n+        data\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "8ee73bbfde8d8eca5aa5783dfecc8bbbc577dc94", "filename": "tests/ui/infallible_destructuring_match.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3c38a36d5a655fa40a953c234b027d6bbbb430da/tests%2Fui%2Finfallible_destructuring_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c38a36d5a655fa40a953c234b027d6bbbb430da/tests%2Fui%2Finfallible_destructuring_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finfallible_destructuring_match.stderr?ref=3c38a36d5a655fa40a953c234b027d6bbbb430da", "patch": "@@ -0,0 +1,28 @@\n+error: you seem to be trying to use match to destructure a single infallible pattern. Consider using `let`\n+  --> $DIR/infallible_destructuring_match.rs:16:5\n+   |\n+16 | /     let data = match wrapper {\n+17 | |         SingleVariantEnum::Variant(i) => i,\n+18 | |     };\n+   | |______^ help: try this: `let SingleVariantEnum::Variant(data) = wrapper;`\n+   |\n+   = note: `-D infallible-destructuring-match` implied by `-D warnings`\n+\n+error: you seem to be trying to use match to destructure a single infallible pattern. Consider using `let`\n+  --> $DIR/infallible_destructuring_match.rs:37:5\n+   |\n+37 | /     let data = match wrapper {\n+38 | |         TupleStruct(i) => i,\n+39 | |     };\n+   | |______^ help: try this: `let TupleStruct(data) = wrapper;`\n+\n+error: you seem to be trying to use match to destructure a single infallible pattern. Consider using `let`\n+  --> $DIR/infallible_destructuring_match.rs:58:5\n+   |\n+58 | /     let data = match wrapper {\n+59 | |         Ok(i) => i,\n+60 | |     };\n+   | |______^ help: try this: `let Ok(data) = wrapper;`\n+\n+error: aborting due to 3 previous errors\n+"}]}