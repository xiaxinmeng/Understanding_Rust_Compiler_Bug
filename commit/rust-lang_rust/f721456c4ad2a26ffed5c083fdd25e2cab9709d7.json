{"sha": "f721456c4ad2a26ffed5c083fdd25e2cab9709d7", "node_id": "C_kwDOAAsO6NoAKGY3MjE0NTZjNGFkMmEyNmZmZWQ1YzA4M2ZkZDI1ZTJjYWI5NzA5ZDc", "commit": {"author": {"name": "Jonas Goronczy", "email": "goronczy.jonas@gmail.com", "date": "2022-02-21T22:00:16Z"}, "committer": {"name": "Jonas Goronczy", "email": "goronczy.jonas@gmail.com", "date": "2022-02-21T22:00:16Z"}, "message": "Removes ExtractedGenerics struct", "tree": {"sha": "7c288e73a0bd03f66062f4cb7b8108c4e2fe2052", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c288e73a0bd03f66062f4cb7b8108c4e2fe2052"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f721456c4ad2a26ffed5c083fdd25e2cab9709d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f721456c4ad2a26ffed5c083fdd25e2cab9709d7", "html_url": "https://github.com/rust-lang/rust/commit/f721456c4ad2a26ffed5c083fdd25e2cab9709d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f721456c4ad2a26ffed5c083fdd25e2cab9709d7/comments", "author": {"login": "jo-goro", "id": 13321616, "node_id": "MDQ6VXNlcjEzMzIxNjE2", "avatar_url": "https://avatars.githubusercontent.com/u/13321616?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jo-goro", "html_url": "https://github.com/jo-goro", "followers_url": "https://api.github.com/users/jo-goro/followers", "following_url": "https://api.github.com/users/jo-goro/following{/other_user}", "gists_url": "https://api.github.com/users/jo-goro/gists{/gist_id}", "starred_url": "https://api.github.com/users/jo-goro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jo-goro/subscriptions", "organizations_url": "https://api.github.com/users/jo-goro/orgs", "repos_url": "https://api.github.com/users/jo-goro/repos", "events_url": "https://api.github.com/users/jo-goro/events{/privacy}", "received_events_url": "https://api.github.com/users/jo-goro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jo-goro", "id": 13321616, "node_id": "MDQ6VXNlcjEzMzIxNjE2", "avatar_url": "https://avatars.githubusercontent.com/u/13321616?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jo-goro", "html_url": "https://github.com/jo-goro", "followers_url": "https://api.github.com/users/jo-goro/followers", "following_url": "https://api.github.com/users/jo-goro/following{/other_user}", "gists_url": "https://api.github.com/users/jo-goro/gists{/gist_id}", "starred_url": "https://api.github.com/users/jo-goro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jo-goro/subscriptions", "organizations_url": "https://api.github.com/users/jo-goro/orgs", "repos_url": "https://api.github.com/users/jo-goro/repos", "events_url": "https://api.github.com/users/jo-goro/events{/privacy}", "received_events_url": "https://api.github.com/users/jo-goro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5f3921fab4a24e7cf0246e0349f184ce58991c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5f3921fab4a24e7cf0246e0349f184ce58991c7", "html_url": "https://github.com/rust-lang/rust/commit/f5f3921fab4a24e7cf0246e0349f184ce58991c7"}], "stats": {"total": 157, "additions": 76, "deletions": 81}, "files": [{"sha": "cfcbfc246989b5987aa46dcb4c98dbdd5e438f82", "filename": "crates/ide_assists/src/handlers/extract_struct_from_enum_variant.rs", "status": "modified", "additions": 76, "deletions": 81, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/f721456c4ad2a26ffed5c083fdd25e2cab9709d7/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f721456c4ad2a26ffed5c083fdd25e2cab9709d7/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs?ref=f721456c4ad2a26ffed5c083fdd25e2cab9709d7", "patch": "@@ -109,22 +109,8 @@ pub(crate) fn extract_struct_from_enum_variant(\n             let indent = enum_ast.indent_level();\n             let generic_params = enum_ast\n                 .generic_param_list()\n-                .map(|known_generics| extract_generic_params(&known_generics, &field_list));\n-            let generics =\n-                generic_params.as_ref().filter(|generics| !generics.all_empty()).map(|generics| {\n-                    make::generic_param_list(\n-                        generics\n-                            .lifetimes\n-                            .iter()\n-                            .cloned()\n-                            .map(ast::GenericParam::LifetimeParam)\n-                            .chain(generics.types.iter().cloned().map(ast::GenericParam::TypeParam))\n-                            .chain(\n-                                generics.consts.iter().cloned().map(ast::GenericParam::ConstParam),\n-                            ),\n-                    )\n-                    .clone_for_update()\n-                });\n+                .and_then(|known_generics| extract_generic_params(&known_generics, &field_list));\n+            let generics = generic_params.as_ref().map(|generics| generics.clone_for_update());\n             let def =\n                 create_struct_def(variant_name.clone(), &variant, &field_list, generics, &enum_ast);\n             def.reindent_to(indent);\n@@ -138,7 +124,7 @@ pub(crate) fn extract_struct_from_enum_variant(\n                 ],\n             );\n \n-            update_variant(&variant, generic_params);\n+            update_variant(&variant, generic_params.map(|g| g.clone_for_update()));\n         },\n     )\n }\n@@ -179,83 +165,70 @@ fn existing_definition(db: &RootDatabase, variant_name: &ast::Name, variant: &Va\n         .any(|(name, _)| name.to_string() == variant_name.to_string())\n }\n \n-struct ExtractedGenerics {\n-    lifetimes: Vec<ast::LifetimeParam>,\n-    types: Vec<ast::TypeParam>,\n-    consts: Vec<ast::ConstParam>,\n-}\n-\n-impl ExtractedGenerics {\n-    fn all_empty(&self) -> bool {\n-        self.lifetimes.is_empty() && self.types.is_empty() && self.consts.is_empty()\n-    }\n-}\n-\n fn extract_generic_params(\n     known_generics: &ast::GenericParamList,\n     field_list: &Either<ast::RecordFieldList, ast::TupleFieldList>,\n-) -> ExtractedGenerics {\n-    let mut lifetimes = known_generics.lifetime_params().map(|x| (x, false)).collect_vec();\n-    let mut types = known_generics.type_params().map(|x| (x, false)).collect_vec();\n-    let mut consts = known_generics.const_params().map(|x| (x, false)).collect_vec();\n+) -> Option<ast::GenericParamList> {\n+    let mut generics = known_generics.generic_params().map(|param| (param, false)).collect_vec();\n \n-    match field_list {\n+    let tagged_one = match field_list {\n         Either::Left(field_list) => field_list\n             .fields()\n             .filter_map(|f| f.ty())\n-            .for_each(|ty| tag_generics_in_variant(&ty, &mut lifetimes, &mut types, &mut consts)),\n+            .fold(false, |tagged, ty| tag_generics_in_variant(&ty, &mut generics) || tagged),\n         Either::Right(field_list) => field_list\n             .fields()\n             .filter_map(|f| f.ty())\n-            .for_each(|ty| tag_generics_in_variant(&ty, &mut lifetimes, &mut types, &mut consts)),\n-    }\n-\n-    let lifetimes = lifetimes.into_iter().filter_map(|(x, present)| present.then(|| x)).collect();\n-    let types = types.into_iter().filter_map(|(x, present)| present.then(|| x)).collect();\n-    let consts = consts.into_iter().filter_map(|(x, present)| present.then(|| x)).collect();\n+            .fold(false, |tagged, ty| tag_generics_in_variant(&ty, &mut generics) || tagged),\n+    };\n \n-    ExtractedGenerics { lifetimes, types, consts }\n+    let generics = generics.into_iter().filter_map(|(param, tag)| tag.then(|| param));\n+    tagged_one.then(|| make::generic_param_list(generics))\n }\n \n-fn tag_generics_in_variant(\n-    ty: &ast::Type,\n-    lifetimes: &mut [(ast::LifetimeParam, bool)],\n-    types: &mut [(ast::TypeParam, bool)],\n-    consts: &mut [(ast::ConstParam, bool)],\n-) {\n+fn tag_generics_in_variant(ty: &ast::Type, generics: &mut [(ast::GenericParam, bool)]) -> bool {\n+    let mut tagged_one = false;\n+\n     for token in ty.syntax().descendants_with_tokens().filter_map(SyntaxElement::into_token) {\n-        match token.kind() {\n-            T![lifetime_ident] => {\n-                for (lt, present) in lifetimes.iter_mut() {\n+        for (param, tag) in generics.iter_mut().filter(|(_, tag)| !tag) {\n+            match param {\n+                ast::GenericParam::LifetimeParam(lt)\n+                    if matches!(token.kind(), T![lifetime_ident]) =>\n+                {\n                     if let Some(lt) = lt.lifetime() {\n                         if lt.text().as_str() == token.text() {\n-                            *present = true;\n-                            break;\n-                        }\n-                    }\n-                }\n-            }\n-            T![ident] => {\n-                for (ty, present) in types.iter_mut() {\n-                    if let Some(name) = ty.name() {\n-                        if name.text().as_str() == token.text() {\n-                            *present = true;\n+                            *tag = true;\n+                            tagged_one = true;\n                             break;\n                         }\n                     }\n                 }\n-                for (cnst, present) in consts.iter_mut() {\n-                    if let Some(name) = cnst.name() {\n-                        if name.text().as_str() == token.text() {\n-                            *present = true;\n-                            break;\n-                        }\n+                param if matches!(token.kind(), T![ident]) => {\n+                    if match param {\n+                        ast::GenericParam::ConstParam(konst) => konst\n+                            .name()\n+                            .map(|name| name.text().as_str() == token.text())\n+                            .unwrap_or_default(),\n+                        ast::GenericParam::TypeParam(ty) => ty\n+                            .name()\n+                            .map(|name| name.text().as_str() == token.text())\n+                            .unwrap_or_default(),\n+                        ast::GenericParam::LifetimeParam(lt) => lt\n+                            .lifetime()\n+                            .map(|lt| lt.text().as_str() == token.text())\n+                            .unwrap_or_default(),\n+                    } {\n+                        *tag = true;\n+                        tagged_one = true;\n+                        break;\n                     }\n                 }\n+                _ => (),\n             }\n-            _ => (),\n         }\n     }\n+\n+    tagged_one\n }\n \n fn create_struct_def(\n@@ -341,21 +314,43 @@ fn create_struct_def(\n     strukt\n }\n \n-fn update_variant(variant: &ast::Variant, generics: Option<ExtractedGenerics>) -> Option<()> {\n+fn update_variant(variant: &ast::Variant, generics: Option<ast::GenericParamList>) -> Option<()> {\n     let name = variant.name()?;\n     let ty = generics\n-        .filter(|generics| !generics.all_empty())\n+        .filter(|generics| generics.generic_params().count() > 0)\n         .map(|generics| {\n-            let generics_str = [\n-                generics.lifetimes.iter().filter_map(|lt| lt.lifetime()).join(\", \"),\n-                generics.types.iter().filter_map(|ty| ty.name()).join(\", \"),\n-                generics.consts.iter().filter_map(|cnst| cnst.name()).join(\", \"),\n-            ]\n-            .iter()\n-            .filter(|s| !s.is_empty())\n-            .join(\", \");\n-\n-            make::ty(&format!(\"{}<{}>\", &name.text(), &generics_str))\n+            let generic_str = generics\n+                .generic_params()\n+                .with_position()\n+                .map(|p| match p {\n+                    itertools::Position::First(p) | itertools::Position::Middle(p) => (p, true),\n+                    itertools::Position::Last(p) | itertools::Position::Only(p) => (p, false),\n+                })\n+                .fold(String::with_capacity(8), |mut s, (p, more)| {\n+                    match p {\n+                        ast::GenericParam::ConstParam(konst) => {\n+                            if let Some(name) = konst.name() {\n+                                s.push_str(name.text().as_str());\n+                            }\n+                        }\n+                        ast::GenericParam::LifetimeParam(lt) => {\n+                            if let Some(lt) = lt.lifetime() {\n+                                s.push_str(lt.text().as_str());\n+                            }\n+                        }\n+                        ast::GenericParam::TypeParam(ty) => {\n+                            if let Some(name) = ty.name() {\n+                                s.push_str(name.text().as_str());\n+                            }\n+                        }\n+                    }\n+                    if more {\n+                        s.push_str(\", \");\n+                    }\n+                    s\n+                });\n+\n+            make::ty(&format!(\"{}<{}>\", &name.text(), &generic_str))\n         })\n         .unwrap_or_else(|| make::ty(&name.text()));\n "}]}