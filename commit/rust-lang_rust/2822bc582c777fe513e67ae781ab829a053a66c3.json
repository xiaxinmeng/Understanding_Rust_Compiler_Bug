{"sha": "2822bc582c777fe513e67ae781ab829a053a66c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4MjJiYzU4MmM3NzdmZTUxM2U2N2FlNzgxYWI4MjlhMDUzYTY2YzM=", "commit": {"author": {"name": "Richo Healey", "email": "richo@psych0tik.net", "date": "2015-01-27T08:13:35Z"}, "committer": {"name": "Richo Healey", "email": "richo@psych0tik.net", "date": "2015-01-27T09:25:54Z"}, "message": "Fix PEP8 in lldb_rust_formatters.py", "tree": {"sha": "9d98bcdc641232daaa6388bbb71bdfb9bf925464", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d98bcdc641232daaa6388bbb71bdfb9bf925464"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2822bc582c777fe513e67ae781ab829a053a66c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2822bc582c777fe513e67ae781ab829a053a66c3", "html_url": "https://github.com/rust-lang/rust/commit/2822bc582c777fe513e67ae781ab829a053a66c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2822bc582c777fe513e67ae781ab829a053a66c3/comments", "author": {"login": "richo", "id": 476418, "node_id": "MDQ6VXNlcjQ3NjQxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/476418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richo", "html_url": "https://github.com/richo", "followers_url": "https://api.github.com/users/richo/followers", "following_url": "https://api.github.com/users/richo/following{/other_user}", "gists_url": "https://api.github.com/users/richo/gists{/gist_id}", "starred_url": "https://api.github.com/users/richo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richo/subscriptions", "organizations_url": "https://api.github.com/users/richo/orgs", "repos_url": "https://api.github.com/users/richo/repos", "events_url": "https://api.github.com/users/richo/events{/privacy}", "received_events_url": "https://api.github.com/users/richo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "richo", "id": 476418, "node_id": "MDQ6VXNlcjQ3NjQxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/476418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richo", "html_url": "https://github.com/richo", "followers_url": "https://api.github.com/users/richo/followers", "following_url": "https://api.github.com/users/richo/following{/other_user}", "gists_url": "https://api.github.com/users/richo/gists{/gist_id}", "starred_url": "https://api.github.com/users/richo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richo/subscriptions", "organizations_url": "https://api.github.com/users/richo/orgs", "repos_url": "https://api.github.com/users/richo/repos", "events_url": "https://api.github.com/users/richo/events{/privacy}", "received_events_url": "https://api.github.com/users/richo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f697a06da43374c94a20bbc9e60ed45c4bda6fd4", "url": "https://api.github.com/repos/rust-lang/rust/commits/f697a06da43374c94a20bbc9e60ed45c4bda6fd4", "html_url": "https://github.com/rust-lang/rust/commit/f697a06da43374c94a20bbc9e60ed45c4bda6fd4"}], "stats": {"total": 340, "additions": 171, "deletions": 169}, "files": [{"sha": "42c83b6a42ed6f6df6ad7ec765fa5eb5e809b897", "filename": "src/etc/lldb_rust_formatters.py", "status": "modified", "additions": 171, "deletions": 169, "changes": 340, "blob_url": "https://github.com/rust-lang/rust/blob/2822bc582c777fe513e67ae781ab829a053a66c3/src%2Fetc%2Flldb_rust_formatters.py", "raw_url": "https://github.com/rust-lang/rust/raw/2822bc582c777fe513e67ae781ab829a053a66c3/src%2Fetc%2Flldb_rust_formatters.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_rust_formatters.py?ref=2822bc582c777fe513e67ae781ab829a053a66c3", "patch": "@@ -10,186 +10,189 @@\n \n import lldb\n \n+\n def print_val(val, internal_dict):\n-  '''Prints the given value with Rust syntax'''\n-  type_class = val.GetType().GetTypeClass()\n+    '''Prints the given value with Rust syntax'''\n+    type_class = val.GetType().GetTypeClass()\n \n-  if type_class == lldb.eTypeClassStruct:\n-    return print_struct_val(val, internal_dict)\n+    if type_class == lldb.eTypeClassStruct:\n+        return print_struct_val(val, internal_dict)\n \n-  if type_class == lldb.eTypeClassUnion:\n-    return print_enum_val(val, internal_dict)\n+    if type_class == lldb.eTypeClassUnion:\n+        return print_enum_val(val, internal_dict)\n \n-  if type_class == lldb.eTypeClassPointer:\n-    return print_pointer_val(val, internal_dict)\n+    if type_class == lldb.eTypeClassPointer:\n+        return print_pointer_val(val, internal_dict)\n \n-  if type_class == lldb.eTypeClassArray:\n-    return print_fixed_size_vec_val(val, internal_dict)\n+    if type_class == lldb.eTypeClassArray:\n+        return print_fixed_size_vec_val(val, internal_dict)\n \n-  return val.GetValue()\n+    return val.GetValue()\n \n \n #=--------------------------------------------------------------------------------------------------\n # Type-Specialized Printing Functions\n #=--------------------------------------------------------------------------------------------------\n \n def print_struct_val(val, internal_dict):\n-  '''Prints a struct, tuple, or tuple struct value with Rust syntax'''\n-  assert val.GetType().GetTypeClass() == lldb.eTypeClassStruct\n+    '''Prints a struct, tuple, or tuple struct value with Rust syntax'''\n+    assert val.GetType().GetTypeClass() == lldb.eTypeClassStruct\n+\n+    if is_vec_slice(val):\n+        return print_vec_slice_val(val, internal_dict)\n+    else:\n+        return print_struct_val_starting_from(0, val, internal_dict)\n \n-  if is_vec_slice(val):\n-    return print_vec_slice_val(val, internal_dict)\n-  else:\n-    return print_struct_val_starting_from(0, val, internal_dict)\n \n def print_vec_slice_val(val, internal_dict):\n-  length = val.GetChildAtIndex(1).GetValueAsUnsigned()\n+    length = val.GetChildAtIndex(1).GetValueAsUnsigned()\n \n-  data_ptr_val = val.GetChildAtIndex(0)\n-  data_ptr_type = data_ptr_val.GetType()\n-  assert data_ptr_type.IsPointerType()\n+    data_ptr_val = val.GetChildAtIndex(0)\n+    data_ptr_type = data_ptr_val.GetType()\n+    assert data_ptr_type.IsPointerType()\n \n-  element_type = data_ptr_type.GetPointeeType()\n-  element_type_size = element_type.GetByteSize()\n+    element_type = data_ptr_type.GetPointeeType()\n+    element_type_size = element_type.GetByteSize()\n \n-  start_address = data_ptr_val.GetValueAsUnsigned()\n+    start_address = data_ptr_val.GetValueAsUnsigned()\n \n-  def render_element(i):\n-    address = start_address + i * element_type_size\n-    element_val = val.CreateValueFromAddress( val.GetName() + (\"[%s]\" % i), address, element_type)\n-    return print_val(element_val, internal_dict)\n+    def render_element(i):\n+        address = start_address + i * element_type_size\n+        element_val = val.CreateValueFromAddress(val.GetName() +\n+                                                 (\"[%s]\" % i), address, element_type)\n+        return print_val(element_val, internal_dict)\n \n-  return \"&[%s]\" % (', '.join([render_element(i) for i in range(length)]))\n+    return \"&[%s]\" % (', '.join([render_element(i) for i in range(length)]))\n \n-def print_struct_val_starting_from(field_start_index, val, internal_dict):\n-  '''\n-  Prints a struct, tuple, or tuple struct value with Rust syntax.\n-  Ignores any fields before field_start_index.\n-  '''\n-  assert val.GetType().GetTypeClass() == lldb.eTypeClassStruct\n-\n-  t = val.GetType()\n-  type_name = extract_type_name(t.GetName())\n-  num_children = val.num_children\n-\n-  if (num_children - field_start_index) == 0:\n-    # The only field of this struct is the enum discriminant\n-    return type_name\n-\n-  has_field_names = type_has_field_names(t)\n-\n-  if has_field_names:\n-    template = \"%(type_name)s {\\n%(body)s\\n}\"\n-    separator = \", \\n\"\n-  else:\n-    template = \"%(type_name)s(%(body)s)\"\n-    separator = \", \"\n-\n-  if type_name.startswith(\"(\"):\n-    # this is a tuple, so don't print the type name\n-    type_name = \"\"\n-\n-  def render_child(child_index):\n-    this = \"\"\n-    if has_field_names:\n-      field_name = t.GetFieldAtIndex(child_index).GetName()\n-      this += field_name + \": \"\n \n-    field_val = val.GetChildAtIndex(child_index)\n-    return this + print_val(field_val, internal_dict)\n+def print_struct_val_starting_from(field_start_index, val, internal_dict):\n+    '''\n+    Prints a struct, tuple, or tuple struct value with Rust syntax.\n+    Ignores any fields before field_start_index.\n+    '''\n+    assert val.GetType().GetTypeClass() == lldb.eTypeClassStruct\n \n-  body = separator.join([render_child(idx) for idx in range(field_start_index, num_children)])\n+    t = val.GetType()\n+    type_name = extract_type_name(t.GetName())\n+    num_children = val.num_children\n \n-  return template % {\"type_name\": type_name,\n-                     \"body\": body}\n+    if (num_children - field_start_index) == 0:\n+        # The only field of this struct is the enum discriminant\n+        return type_name\n \n+    has_field_names = type_has_field_names(t)\n \n-def print_enum_val(val, internal_dict):\n-  '''Prints an enum value with Rust syntax'''\n-\n-  assert val.GetType().GetTypeClass() == lldb.eTypeClassUnion\n-\n-  if val.num_children == 1:\n-    # This is either an enum with just one variant, or it is an Option-like enum\n-    # where the discriminant is encoded in a non-nullable pointer field. We find\n-    # out which one it is by looking at the member name of the sole union\n-    # variant. If it starts with \"RUST$ENCODED$ENUM$\" then we have an\n-    # Option-like enum.\n-    first_variant_name = val.GetChildAtIndex(0).GetName()\n-    if first_variant_name and first_variant_name.startswith(\"RUST$ENCODED$ENUM$\"):\n-\n-      # This is an Option-like enum. The position of the discriminator field is\n-      # encoded in the name which has the format:\n-      #  RUST$ENCODED$ENUM$<index of discriminator field>$<name of null variant>\n-      last_separator_index = first_variant_name.rfind(\"$\")\n-      if last_separator_index == -1:\n-        return \"<invalid enum encoding: %s>\" % first_variant_name\n-\n-      start_index = len(\"RUST$ENCODED$ENUM$\")\n-\n-      # Extract indices of the discriminator field\n-      try:\n-        disr_field_indices = first_variant_name[start_index :\n-                                              last_separator_index].split(\"$\")\n-        disr_field_indices = [int(index) for index in disr_field_indices]\n-      except:\n-        return \"<invalid enum encoding: %s>\" % first_variant_name\n-\n-      # Read the discriminant\n-      disr_val = val.GetChildAtIndex(0)\n-      for index in disr_field_indices:\n-        disr_val = disr_val.GetChildAtIndex(index)\n-\n-      # If the discriminant field is a fat pointer we have to consider the\n-      # first word as the true discriminant\n-      if disr_val.GetType().GetTypeClass() == lldb.eTypeClassStruct:\n-        disr_val = disr_val.GetChildAtIndex(0)\n-\n-      if disr_val.GetValueAsUnsigned() == 0:\n-        # Null case: Print the name of the null-variant\n-        null_variant_name = first_variant_name[last_separator_index + 1:]\n-        return null_variant_name\n-      else:\n-        # Non-null case: Interpret the data as a value of the non-null variant type\n-        return print_struct_val_starting_from(0, val.GetChildAtIndex(0), internal_dict)\n+    if has_field_names:\n+        template = \"%(type_name)s {\\n%(body)s\\n}\"\n+        separator = \", \\n\"\n     else:\n-      # This is just a regular uni-variant enum without discriminator field\n-      return print_struct_val_starting_from(0, val.GetChildAtIndex(0), internal_dict)\n+        template = \"%(type_name)s(%(body)s)\"\n+        separator = \", \"\n+\n+    if type_name.startswith(\"(\"):\n+        # this is a tuple, so don't print the type name\n+        type_name = \"\"\n \n-  # If we are here, this is a regular enum with more than one variant\n-  disr_val = val.GetChildAtIndex(0).GetChildMemberWithName(\"RUST$ENUM$DISR\")\n-  disr_type = disr_val.GetType()\n+    def render_child(child_index):\n+        this = \"\"\n+        if has_field_names:\n+            field_name = t.GetFieldAtIndex(child_index).GetName()\n+            this += field_name + \": \"\n \n-  if disr_type.GetTypeClass() != lldb.eTypeClassEnumeration:\n-    return \"<Invalid enum value encountered: Discriminator is not an enum>\"\n+        field_val = val.GetChildAtIndex(child_index)\n+        return this + print_val(field_val, internal_dict)\n \n-  variant_index = disr_val.GetValueAsUnsigned()\n-  return print_struct_val_starting_from(1, val.GetChildAtIndex(variant_index), internal_dict)\n+    body = separator.join([render_child(idx) for idx in range(field_start_index, num_children)])\n+\n+    return template % {\"type_name\": type_name,\n+                       \"body\": body}\n+\n+\n+def print_enum_val(val, internal_dict):\n+    '''Prints an enum value with Rust syntax'''\n+\n+    assert val.GetType().GetTypeClass() == lldb.eTypeClassUnion\n+\n+    if val.num_children == 1:\n+        # This is either an enum with just one variant, or it is an Option-like\n+        # enum where the discriminant is encoded in a non-nullable pointer\n+        # field. We find out which one it is by looking at the member name of\n+        # the sole union variant. If it starts with \"RUST$ENCODED$ENUM$\" then\n+        # we have an Option-like enum.\n+        first_variant_name = val.GetChildAtIndex(0).GetName()\n+        if first_variant_name and first_variant_name.startswith(\"RUST$ENCODED$ENUM$\"):\n+\n+            # This is an Option-like enum. The position of the discriminator field is\n+            # encoded in the name which has the format:\n+            #  RUST$ENCODED$ENUM$<index of discriminator field>$<name of null variant>\n+            last_separator_index = first_variant_name.rfind(\"$\")\n+            if last_separator_index == -1:\n+                return \"<invalid enum encoding: %s>\" % first_variant_name\n+\n+            start_index = len(\"RUST$ENCODED$ENUM$\")\n+\n+            # Extract indices of the discriminator field\n+            try:\n+                disr_field_indices = first_variant_name[start_index:last_separator_index].split(\"$\")\n+                disr_field_indices = [int(index) for index in disr_field_indices]\n+            except:\n+                return \"<invalid enum encoding: %s>\" % first_variant_name\n+\n+            # Read the discriminant\n+            disr_val = val.GetChildAtIndex(0)\n+            for index in disr_field_indices:\n+                disr_val = disr_val.GetChildAtIndex(index)\n+\n+            # If the discriminant field is a fat pointer we have to consider the\n+            # first word as the true discriminant\n+            if disr_val.GetType().GetTypeClass() == lldb.eTypeClassStruct:\n+                disr_val = disr_val.GetChildAtIndex(0)\n+\n+            if disr_val.GetValueAsUnsigned() == 0:\n+                # Null case: Print the name of the null-variant\n+                null_variant_name = first_variant_name[last_separator_index + 1:]\n+                return null_variant_name\n+            else:\n+                # Non-null case: Interpret the data as a value of the non-null variant type\n+                return print_struct_val_starting_from(0, val.GetChildAtIndex(0), internal_dict)\n+        else:\n+            # This is just a regular uni-variant enum without discriminator field\n+            return print_struct_val_starting_from(0, val.GetChildAtIndex(0), internal_dict)\n+\n+    # If we are here, this is a regular enum with more than one variant\n+    disr_val = val.GetChildAtIndex(0).GetChildMemberWithName(\"RUST$ENUM$DISR\")\n+    disr_type = disr_val.GetType()\n+\n+    if disr_type.GetTypeClass() != lldb.eTypeClassEnumeration:\n+        return \"<Invalid enum value encountered: Discriminator is not an enum>\"\n+\n+    variant_index = disr_val.GetValueAsUnsigned()\n+    return print_struct_val_starting_from(1, val.GetChildAtIndex(variant_index), internal_dict)\n \n \n def print_pointer_val(val, internal_dict):\n-  '''Prints a pointer value with Rust syntax'''\n-  assert val.GetType().IsPointerType()\n-  sigil = \"&\"\n-  type_name = extract_type_name(val.GetType().GetName())\n-  if type_name and type_name[0:1] in [\"&\", \"~\", \"*\"]:\n-    sigil = type_name[0:1]\n+    '''Prints a pointer value with Rust syntax'''\n+    assert val.GetType().IsPointerType()\n+    sigil = \"&\"\n+    type_name = extract_type_name(val.GetType().GetName())\n+    if type_name and type_name[0:1] in [\"&\", \"~\", \"*\"]:\n+        sigil = type_name[0:1]\n \n-  return sigil + hex(val.GetValueAsUnsigned()) #print_val(val.Dereference(), internal_dict)\n+    return sigil + hex(val.GetValueAsUnsigned()) #print_val(val.Dereference(), internal_dict)\n \n \n def print_fixed_size_vec_val(val, internal_dict):\n-  assert val.GetType().GetTypeClass() == lldb.eTypeClassArray\n+    assert val.GetType().GetTypeClass() == lldb.eTypeClassArray\n \n-  output = \"[\"\n+    output = \"[\"\n \n-  for i in range(val.num_children):\n-    output += print_val(val.GetChildAtIndex(i), internal_dict)\n-    if i != val.num_children - 1:\n-      output += \", \"\n+    for i in range(val.num_children):\n+        output += print_val(val.GetChildAtIndex(i), internal_dict)\n+        if i != val.num_children - 1:\n+            output += \", \"\n \n-  output += \"]\"\n-  return output\n+    output += \"]\"\n+    return output\n \n \n #=--------------------------------------------------------------------------------------------------\n@@ -198,46 +201,45 @@ def print_fixed_size_vec_val(val, internal_dict):\n \n unqualified_type_markers = frozenset([\"(\", \"[\", \"&\", \"*\"])\n \n+\n def extract_type_name(qualified_type_name):\n-  '''Extracts the type name from a fully qualified path'''\n-  if qualified_type_name[0] in unqualified_type_markers:\n-    return qualified_type_name\n+    '''Extracts the type name from a fully qualified path'''\n+    if qualified_type_name[0] in unqualified_type_markers:\n+        return qualified_type_name\n \n-  end_of_search = qualified_type_name.find(\"<\")\n-  if end_of_search < 0:\n-    end_of_search = len(qualified_type_name)\n+    end_of_search = qualified_type_name.find(\"<\")\n+    if end_of_search < 0:\n+        end_of_search = len(qualified_type_name)\n \n-  index = qualified_type_name.rfind(\"::\", 0, end_of_search)\n-  if index < 0:\n-    return qualified_type_name\n-  else:\n-    return qualified_type_name[index + 2:]\n+    index = qualified_type_name.rfind(\"::\", 0, end_of_search)\n+    if index < 0:\n+        return qualified_type_name\n+    else:\n+        return qualified_type_name[index + 2:]\n \n \n def type_has_field_names(ty):\n-  '''Returns true of this is a type with field names (struct, struct-like enum variant)'''\n-  # This may also be an enum variant where the first field doesn't have a name but the rest has\n-  if ty.GetNumberOfFields() > 1:\n-    return ty.GetFieldAtIndex(1).GetName() != None\n-  else:\n-    return ty.GetFieldAtIndex(0).GetName() != None\n+    '''Returns true of this is a type with field names (struct, struct-like enum variant)'''\n+    # This may also be an enum variant where the first field doesn't have a name but the rest has\n+    if ty.GetNumberOfFields() > 1:\n+        return ty.GetFieldAtIndex(1).GetName() is not None\n+    else:\n+        return ty.GetFieldAtIndex(0).GetName() is not None\n \n \n def is_vec_slice(val):\n-  ty = val.GetType()\n-  if ty.GetTypeClass() != lldb.eTypeClassStruct:\n-    return False\n-\n-  if ty.GetNumberOfFields() != 2:\n-    return False\n+    ty = val.GetType()\n+    if ty.GetTypeClass() != lldb.eTypeClassStruct:\n+        return False\n \n-  if ty.GetFieldAtIndex(0).GetName() != \"data_ptr\":\n-    return False\n+    if ty.GetNumberOfFields() != 2:\n+        return False\n \n-  if ty.GetFieldAtIndex(1).GetName() != \"length\":\n-    return False\n+    if ty.GetFieldAtIndex(0).GetName() != \"data_ptr\":\n+        return False\n \n-  type_name = extract_type_name(ty.GetName()).replace(\"&'static\", \"&\").replace(\" \", \"\")\n-  return type_name.startswith(\"&[\") and type_name.endswith(\"]\")\n+    if ty.GetFieldAtIndex(1).GetName() != \"length\":\n+        return False\n \n-# vi: sw=2:ts=2\n+    type_name = extract_type_name(ty.GetName()).replace(\"&'static\", \"&\").replace(\" \", \"\")\n+    return type_name.startswith(\"&[\") and type_name.endswith(\"]\")"}]}