{"sha": "d90cb1e77249856d530a522769048f4430933fde", "node_id": "C_kwDOAAsO6NoAKGQ5MGNiMWU3NzI0OTg1NmQ1MzBhNTIyNzY5MDQ4ZjQ0MzA5MzNmZGU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-01T16:24:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-01T16:24:15Z"}, "message": "Auto merge of #13516 - unexge:add-convert-match-to-let-else-assist, r=jonas-schievink\n\nAdd `Convert match to let-else` assist\n\nCloses https://github.com/rust-lang/rust-analyzer/issues/13254", "tree": {"sha": "042bfcc1ab3095bd00003f84d0482df046397124", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/042bfcc1ab3095bd00003f84d0482df046397124"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d90cb1e77249856d530a522769048f4430933fde", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d90cb1e77249856d530a522769048f4430933fde", "html_url": "https://github.com/rust-lang/rust/commit/d90cb1e77249856d530a522769048f4430933fde", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d90cb1e77249856d530a522769048f4430933fde/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07f6efc4e7302d05f31a4bde1f5bd23424ba6a45", "url": "https://api.github.com/repos/rust-lang/rust/commits/07f6efc4e7302d05f31a4bde1f5bd23424ba6a45", "html_url": "https://github.com/rust-lang/rust/commit/07f6efc4e7302d05f31a4bde1f5bd23424ba6a45"}, {"sha": "72d5b456e1435023d9e7bd25174e2f5dbe37f535", "url": "https://api.github.com/repos/rust-lang/rust/commits/72d5b456e1435023d9e7bd25174e2f5dbe37f535", "html_url": "https://github.com/rust-lang/rust/commit/72d5b456e1435023d9e7bd25174e2f5dbe37f535"}], "stats": {"total": 436, "additions": 436, "deletions": 0}, "files": [{"sha": "5bf04a3ad3719fadf64a91d989b00eff4bac0e2d", "filename": "crates/ide-assists/src/handlers/convert_match_to_let_else.rs", "status": "added", "additions": 413, "deletions": 0, "changes": 413, "blob_url": "https://github.com/rust-lang/rust/blob/d90cb1e77249856d530a522769048f4430933fde/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_match_to_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d90cb1e77249856d530a522769048f4430933fde/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_match_to_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_match_to_let_else.rs?ref=d90cb1e77249856d530a522769048f4430933fde", "patch": "@@ -0,0 +1,413 @@\n+use ide_db::defs::{Definition, NameRefClass};\n+use syntax::{\n+    ast::{self, HasName},\n+    ted, AstNode, SyntaxNode,\n+};\n+\n+use crate::{\n+    assist_context::{AssistContext, Assists},\n+    AssistId, AssistKind,\n+};\n+\n+// Assist: convert_match_to_let_else\n+//\n+// Converts let statement with match initializer to let-else statement.\n+//\n+// ```\n+// # //- minicore: option\n+// fn foo(opt: Option<()>) {\n+//     let val = $0match opt {\n+//         Some(it) => it,\n+//         None => return,\n+//     };\n+// }\n+// ```\n+// ->\n+// ```\n+// fn foo(opt: Option<()>) {\n+//     let Some(val) = opt else { return };\n+// }\n+// ```\n+pub(crate) fn convert_match_to_let_else(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n+    let let_stmt: ast::LetStmt = ctx.find_node_at_offset()?;\n+    let binding = find_binding(let_stmt.pat()?)?;\n+\n+    let initializer = match let_stmt.initializer() {\n+        Some(ast::Expr::MatchExpr(it)) => it,\n+        _ => return None,\n+    };\n+    let initializer_expr = initializer.expr()?;\n+\n+    let (extracting_arm, diverging_arm) = match find_arms(ctx, &initializer) {\n+        Some(it) => it,\n+        None => return None,\n+    };\n+    if extracting_arm.guard().is_some() {\n+        cov_mark::hit!(extracting_arm_has_guard);\n+        return None;\n+    }\n+\n+    let diverging_arm_expr = diverging_arm.expr()?;\n+    let extracting_arm_pat = extracting_arm.pat()?;\n+    let extracted_variable = find_extracted_variable(ctx, &extracting_arm)?;\n+\n+    acc.add(\n+        AssistId(\"convert_match_to_let_else\", AssistKind::RefactorRewrite),\n+        \"Convert match to let-else\",\n+        let_stmt.syntax().text_range(),\n+        |builder| {\n+            let extracting_arm_pat = rename_variable(&extracting_arm_pat, extracted_variable, binding);\n+            builder.replace(\n+                let_stmt.syntax().text_range(),\n+                format!(\"let {extracting_arm_pat} = {initializer_expr} else {{ {diverging_arm_expr} }};\")\n+            )\n+        },\n+    )\n+}\n+\n+// Given a pattern, find the name introduced to the surrounding scope.\n+fn find_binding(pat: ast::Pat) -> Option<ast::IdentPat> {\n+    if let ast::Pat::IdentPat(ident) = pat {\n+        Some(ident)\n+    } else {\n+        None\n+    }\n+}\n+\n+// Given a match expression, find extracting and diverging arms.\n+fn find_arms(\n+    ctx: &AssistContext<'_>,\n+    match_expr: &ast::MatchExpr,\n+) -> Option<(ast::MatchArm, ast::MatchArm)> {\n+    let arms = match_expr.match_arm_list()?.arms().collect::<Vec<_>>();\n+    if arms.len() != 2 {\n+        return None;\n+    }\n+\n+    let mut extracting = None;\n+    let mut diverging = None;\n+    for arm in arms {\n+        if ctx.sema.type_of_expr(&arm.expr().unwrap()).unwrap().original().is_never() {\n+            diverging = Some(arm);\n+        } else {\n+            extracting = Some(arm);\n+        }\n+    }\n+\n+    match (extracting, diverging) {\n+        (Some(extracting), Some(diverging)) => Some((extracting, diverging)),\n+        _ => {\n+            cov_mark::hit!(non_diverging_match);\n+            None\n+        }\n+    }\n+}\n+\n+// Given an extracting arm, find the extracted variable.\n+fn find_extracted_variable(ctx: &AssistContext<'_>, arm: &ast::MatchArm) -> Option<ast::Name> {\n+    match arm.expr()? {\n+        ast::Expr::PathExpr(path) => {\n+            let name_ref = path.syntax().descendants().find_map(ast::NameRef::cast)?;\n+            match NameRefClass::classify(&ctx.sema, &name_ref)? {\n+                NameRefClass::Definition(Definition::Local(local)) => {\n+                    let source = local.source(ctx.db()).value.left()?;\n+                    Some(source.name()?)\n+                }\n+                _ => None,\n+            }\n+        }\n+        _ => {\n+            cov_mark::hit!(extracting_arm_is_not_an_identity_expr);\n+            return None;\n+        }\n+    }\n+}\n+\n+// Rename `extracted` with `binding` in `pat`.\n+fn rename_variable(pat: &ast::Pat, extracted: ast::Name, binding: ast::IdentPat) -> SyntaxNode {\n+    let syntax = pat.syntax().clone_for_update();\n+    let extracted_syntax = syntax.covering_element(extracted.syntax().text_range());\n+\n+    // If `extracted` variable is a record field, we should rename it to `binding`,\n+    // otherwise we just need to replace `extracted` with `binding`.\n+\n+    if let Some(record_pat_field) = extracted_syntax.ancestors().find_map(ast::RecordPatField::cast)\n+    {\n+        if let Some(name_ref) = record_pat_field.field_name() {\n+            ted::replace(\n+                record_pat_field.syntax(),\n+                ast::make::record_pat_field(ast::make::name_ref(&name_ref.text()), binding.into())\n+                    .syntax()\n+                    .clone_for_update(),\n+            );\n+        }\n+    } else {\n+        ted::replace(extracted_syntax, binding.syntax().clone_for_update());\n+    }\n+\n+    syntax\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn should_not_be_applicable_for_non_diverging_match() {\n+        cov_mark::check!(non_diverging_match);\n+        check_assist_not_applicable(\n+            convert_match_to_let_else,\n+            r#\"\n+//- minicore: option\n+fn foo(opt: Option<()>) {\n+    let val = $0match opt {\n+        Some(it) => it,\n+        None => (),\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn should_not_be_applicable_if_extracting_arm_is_not_an_identity_expr() {\n+        cov_mark::check_count!(extracting_arm_is_not_an_identity_expr, 2);\n+        check_assist_not_applicable(\n+            convert_match_to_let_else,\n+            r#\"\n+//- minicore: option\n+fn foo(opt: Option<i32>) {\n+    let val = $0match opt {\n+        Some(it) => it + 1,\n+        None => return,\n+    };\n+}\n+\"#,\n+        );\n+\n+        check_assist_not_applicable(\n+            convert_match_to_let_else,\n+            r#\"\n+//- minicore: option\n+fn foo(opt: Option<()>) {\n+    let val = $0match opt {\n+        Some(it) => {\n+            let _ = 1 + 1;\n+            it\n+        },\n+        None => return,\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn should_not_be_applicable_if_extracting_arm_has_guard() {\n+        cov_mark::check!(extracting_arm_has_guard);\n+        check_assist_not_applicable(\n+            convert_match_to_let_else,\n+            r#\"\n+//- minicore: option\n+fn foo(opt: Option<()>) {\n+    let val = $0match opt {\n+        Some(it) if 2 > 1 => it,\n+        None => return,\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn basic_pattern() {\n+        check_assist(\n+            convert_match_to_let_else,\n+            r#\"\n+//- minicore: option\n+fn foo(opt: Option<()>) {\n+    let val = $0match opt {\n+        Some(it) => it,\n+        None => return,\n+    };\n+}\n+    \"#,\n+            r#\"\n+fn foo(opt: Option<()>) {\n+    let Some(val) = opt else { return };\n+}\n+    \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn keeps_modifiers() {\n+        check_assist(\n+            convert_match_to_let_else,\n+            r#\"\n+//- minicore: option\n+fn foo(opt: Option<()>) {\n+    let ref mut val = $0match opt {\n+        Some(it) => it,\n+        None => return,\n+    };\n+}\n+    \"#,\n+            r#\"\n+fn foo(opt: Option<()>) {\n+    let Some(ref mut val) = opt else { return };\n+}\n+    \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn nested_pattern() {\n+        check_assist(\n+            convert_match_to_let_else,\n+            r#\"\n+//- minicore: option, result\n+fn foo(opt: Option<Result<()>>) {\n+    let val = $0match opt {\n+        Some(Ok(it)) => it,\n+        _ => return,\n+    };\n+}\n+    \"#,\n+            r#\"\n+fn foo(opt: Option<Result<()>>) {\n+    let Some(Ok(val)) = opt else { return };\n+}\n+    \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn works_with_any_diverging_block() {\n+        check_assist(\n+            convert_match_to_let_else,\n+            r#\"\n+//- minicore: option\n+fn foo(opt: Option<()>) {\n+    loop {\n+        let val = $0match opt {\n+            Some(it) => it,\n+            None => break,\n+        };\n+    }\n+}\n+    \"#,\n+            r#\"\n+fn foo(opt: Option<()>) {\n+    loop {\n+        let Some(val) = opt else { break };\n+    }\n+}\n+    \"#,\n+        );\n+\n+        check_assist(\n+            convert_match_to_let_else,\n+            r#\"\n+//- minicore: option\n+fn foo(opt: Option<()>) {\n+    loop {\n+        let val = $0match opt {\n+            Some(it) => it,\n+            None => continue,\n+        };\n+    }\n+}\n+    \"#,\n+            r#\"\n+fn foo(opt: Option<()>) {\n+    loop {\n+        let Some(val) = opt else { continue };\n+    }\n+}\n+    \"#,\n+        );\n+\n+        check_assist(\n+            convert_match_to_let_else,\n+            r#\"\n+//- minicore: option\n+fn panic() -> ! {}\n+\n+fn foo(opt: Option<()>) {\n+    loop {\n+        let val = $0match opt {\n+            Some(it) => it,\n+            None => panic(),\n+        };\n+    }\n+}\n+    \"#,\n+            r#\"\n+fn panic() -> ! {}\n+\n+fn foo(opt: Option<()>) {\n+    loop {\n+        let Some(val) = opt else { panic() };\n+    }\n+}\n+    \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn struct_pattern() {\n+        check_assist(\n+            convert_match_to_let_else,\n+            r#\"\n+//- minicore: option\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+\n+fn foo(opt: Option<Point>) {\n+    let val = $0match opt {\n+        Some(Point { x: 0, y }) => y,\n+        _ => return,\n+    };\n+}\n+    \"#,\n+            r#\"\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+\n+fn foo(opt: Option<Point>) {\n+    let Some(Point { x: 0, y: val }) = opt else { return };\n+}\n+    \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn renames_whole_binding() {\n+        check_assist(\n+            convert_match_to_let_else,\n+            r#\"\n+//- minicore: option\n+fn foo(opt: Option<i32>) -> Option<i32> {\n+    let val = $0match opt {\n+        it @ Some(42) => it,\n+        _ => return None,\n+    };\n+    val\n+}\n+    \"#,\n+            r#\"\n+fn foo(opt: Option<i32>) -> Option<i32> {\n+    let val @ Some(42) = opt else { return None };\n+    val\n+}\n+    \"#,\n+        );\n+    }\n+}"}, {"sha": "387cc631428250e9fa82ee9afe72a9a8608849f0", "filename": "crates/ide-assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d90cb1e77249856d530a522769048f4430933fde/crates%2Fide-assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d90cb1e77249856d530a522769048f4430933fde/crates%2Fide-assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Flib.rs?ref=d90cb1e77249856d530a522769048f4430933fde", "patch": "@@ -120,6 +120,7 @@ mod handlers {\n     mod convert_into_to_from;\n     mod convert_iter_for_each_to_for;\n     mod convert_let_else_to_match;\n+    mod convert_match_to_let_else;\n     mod convert_tuple_struct_to_named_struct;\n     mod convert_named_struct_to_tuple_struct;\n     mod convert_to_guarded_return;\n@@ -220,6 +221,7 @@ mod handlers {\n             convert_iter_for_each_to_for::convert_for_loop_with_for_each,\n             convert_let_else_to_match::convert_let_else_to_match,\n             convert_named_struct_to_tuple_struct::convert_named_struct_to_tuple_struct,\n+            convert_match_to_let_else::convert_match_to_let_else,\n             convert_to_guarded_return::convert_to_guarded_return,\n             convert_tuple_struct_to_named_struct::convert_tuple_struct_to_named_struct,\n             convert_two_arm_bool_match_to_matches_macro::convert_two_arm_bool_match_to_matches_macro,"}, {"sha": "029d169899bb44a9e5ee76f49b1891fabdd3f991", "filename": "crates/ide-assists/src/tests/generated.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d90cb1e77249856d530a522769048f4430933fde/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d90cb1e77249856d530a522769048f4430933fde/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=d90cb1e77249856d530a522769048f4430933fde", "patch": "@@ -407,6 +407,27 @@ fn main() {\n     )\n }\n \n+#[test]\n+fn doctest_convert_match_to_let_else() {\n+    check_doc_test(\n+        \"convert_match_to_let_else\",\n+        r#####\"\n+//- minicore: option\n+fn foo(opt: Option<()>) {\n+    let val = $0match opt {\n+        Some(it) => it,\n+        None => return,\n+    };\n+}\n+\"#####,\n+        r#####\"\n+fn foo(opt: Option<()>) {\n+    let Some(val) = opt else { return };\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_convert_named_struct_to_tuple_struct() {\n     check_doc_test("}]}