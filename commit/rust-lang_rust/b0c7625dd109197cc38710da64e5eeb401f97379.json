{"sha": "b0c7625dd109197cc38710da64e5eeb401f97379", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwYzc2MjVkZDEwOTE5N2NjMzg3MTBkYTY0ZTVlZWI0MDFmOTczNzk=", "commit": {"author": {"name": "Christian Poveda", "email": "christianpoveda@protonmail.com", "date": "2019-11-30T20:09:52Z"}, "committer": {"name": "Christian Poveda", "email": "git@christianpoveda.xyz", "date": "2019-12-22T16:46:02Z"}, "message": "add `statx` shim for linux", "tree": {"sha": "272a4af1b887e35763107abfb06e83dd40f165b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/272a4af1b887e35763107abfb06e83dd40f165b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0c7625dd109197cc38710da64e5eeb401f97379", "comment_count": 0, "verification": {"verified": false, "reason": "bad_email", "signature": "-----BEGIN PGP SIGNATURE-----\n\niI4EABYIADYWIQRsB8A/3NrzTlMMjT0nUl7150IKUAUCXf+d4hgcZ2l0QGNocmlz\ndGlhbnBvdmVkYS54eXoACgkQJ1Je9edCClCWhAD+NSzq0h9qIOlm6QAB6j7CfwOX\neXi77OOictJE6E4Lf3wA/iXbVgxcHrUPOwCz9dhEosk1F9c7oTXAGvRFuq5/CrEO\n=rvTO\n-----END PGP SIGNATURE-----", "payload": "tree 272a4af1b887e35763107abfb06e83dd40f165b4\nparent 878bb4d78f547d13936feca1ac8f8f33b7744b11\nauthor Christian Poveda <christianpoveda@protonmail.com> 1575144592 -0500\ncommitter Christian Poveda <git@christianpoveda.xyz> 1577033162 -0500\n\nadd `statx` shim for linux\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0c7625dd109197cc38710da64e5eeb401f97379", "html_url": "https://github.com/rust-lang/rust/commit/b0c7625dd109197cc38710da64e5eeb401f97379", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0c7625dd109197cc38710da64e5eeb401f97379/comments", "author": {"login": "pvdrz", "id": 31802960, "node_id": "MDQ6VXNlcjMxODAyOTYw", "avatar_url": "https://avatars.githubusercontent.com/u/31802960?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pvdrz", "html_url": "https://github.com/pvdrz", "followers_url": "https://api.github.com/users/pvdrz/followers", "following_url": "https://api.github.com/users/pvdrz/following{/other_user}", "gists_url": "https://api.github.com/users/pvdrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/pvdrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pvdrz/subscriptions", "organizations_url": "https://api.github.com/users/pvdrz/orgs", "repos_url": "https://api.github.com/users/pvdrz/repos", "events_url": "https://api.github.com/users/pvdrz/events{/privacy}", "received_events_url": "https://api.github.com/users/pvdrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pvdrz", "id": 31802960, "node_id": "MDQ6VXNlcjMxODAyOTYw", "avatar_url": "https://avatars.githubusercontent.com/u/31802960?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pvdrz", "html_url": "https://github.com/pvdrz", "followers_url": "https://api.github.com/users/pvdrz/followers", "following_url": "https://api.github.com/users/pvdrz/following{/other_user}", "gists_url": "https://api.github.com/users/pvdrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/pvdrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pvdrz/subscriptions", "organizations_url": "https://api.github.com/users/pvdrz/orgs", "repos_url": "https://api.github.com/users/pvdrz/repos", "events_url": "https://api.github.com/users/pvdrz/events{/privacy}", "received_events_url": "https://api.github.com/users/pvdrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "878bb4d78f547d13936feca1ac8f8f33b7744b11", "url": "https://api.github.com/repos/rust-lang/rust/commits/878bb4d78f547d13936feca1ac8f8f33b7744b11", "html_url": "https://github.com/rust-lang/rust/commit/878bb4d78f547d13936feca1ac8f8f33b7744b11"}], "stats": {"total": 340, "additions": 303, "deletions": 37}, "files": [{"sha": "ac63a3a9b3a4c32a294abe0763217e4cc7977fd4", "filename": "src/helpers.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b0c7625dd109197cc38710da64e5eeb401f97379/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0c7625dd109197cc38710da64e5eeb401f97379/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=b0c7625dd109197cc38710da64e5eeb401f97379", "patch": "@@ -509,3 +509,45 @@ fn bytes_to_os_str<'tcx, 'a>(bytes: &'a [u8]) -> InterpResult<'tcx, &'a OsStr> {\n         .map_err(|_| err_unsup_format!(\"{:?} is not a valid utf-8 string\", bytes))?;\n     Ok(&OsStr::new(s))\n }\n+\n+// FIXME: change `ImmTy::from_int` so it returns an `InterpResult` instead and remove this\n+// function.\n+pub fn immty_from_int_checked<'tcx>(\n+    int: impl Into<i128>,\n+    layout: TyLayout<'tcx>,\n+) -> InterpResult<'tcx, ImmTy<'tcx, Tag>> {\n+    let int = int.into();\n+    // If `int` does not fit in `size` bits, we error instead of letting\n+    // `ImmTy::from_int` panic.\n+    let size = layout.size;\n+    let truncated = truncate(int as u128, size);\n+    if sign_extend(truncated, size) as i128 != int {\n+        throw_unsup_format!(\n+            \"Signed value {:#x} does not fit in {} bits\",\n+            int,\n+            size.bits()\n+        )\n+    }\n+    Ok(ImmTy::from_int(int, layout))\n+}\n+\n+// FIXME: change `ImmTy::from_uint` so it returns an `InterpResult` instead and remove this\n+// function.\n+pub fn immty_from_uint_checked<'tcx>(\n+    int: impl Into<u128>,\n+    layout: TyLayout<'tcx>,\n+) -> InterpResult<'tcx, ImmTy<'tcx, Tag>> {\n+    let int = int.into();\n+    // If `int` does not fit in `size` bits, we error instead of letting\n+    // `ImmTy::from_int` panic.\n+    let size = layout.size;\n+    if truncate(int, size) != int {\n+        throw_unsup_format!(\n+            \"Unsigned value {:#x} does not fit in {} bits\",\n+            int,\n+            size.bits()\n+        )\n+    }\n+    Ok(ImmTy::from_uint(int, layout))\n+}\n+"}, {"sha": "3994cf78780aafb869b6ab985815ca3dbf5f2302", "filename": "src/shims/env.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b0c7625dd109197cc38710da64e5eeb401f97379/src%2Fshims%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0c7625dd109197cc38710da64e5eeb401f97379/src%2Fshims%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fenv.rs?ref=b0c7625dd109197cc38710da64e5eeb401f97379", "patch": "@@ -20,8 +20,12 @@ impl EnvVars {\n         ecx: &mut InterpCx<'mir, 'tcx, Evaluator<'tcx>>,\n         mut excluded_env_vars: Vec<String>,\n     ) {\n-        // Exclude `TERM` var to avoid terminfo trying to open the termcap file.\n-        excluded_env_vars.push(\"TERM\".to_owned());\n+\n+        // FIXME: this can be removed when we have the `stat64` shim for macos.\n+        if ecx.tcx.sess.target.target.target_os.to_lowercase() != \"linux\" {\n+            // Exclude `TERM` var to avoid terminfo trying to open the termcap file.\n+            excluded_env_vars.push(\"TERM\".to_owned());\n+        }\n \n         if ecx.machine.communicate {\n             for (name, value) in env::vars() {"}, {"sha": "3989f7f48a0b931e0fa1451024a279eb3ff34032", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b0c7625dd109197cc38710da64e5eeb401f97379/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0c7625dd109197cc38710da64e5eeb401f97379/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=b0c7625dd109197cc38710da64e5eeb401f97379", "patch": "@@ -303,14 +303,25 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     .expect(\"Failed to get libc::SYS_getrandom\")\n                     .to_machine_usize(this)?;\n \n-                // `libc::syscall(NR_GETRANDOM, buf.as_mut_ptr(), buf.len(), GRND_NONBLOCK)`\n-                // is called if a `HashMap` is created the regular way (e.g. HashMap<K, V>).\n+                let sys_statx = this\n+                    .eval_path_scalar(&[\"libc\", \"SYS_statx\"])?\n+                    .expect(\"Failed to get libc::SYS_statx\")\n+                    .to_machine_usize(this)?;\n+\n                 match this.read_scalar(args[0])?.to_machine_usize(this)? {\n+                    // `libc::syscall(NR_GETRANDOM, buf.as_mut_ptr(), buf.len(), GRND_NONBLOCK)`\n+                    // is called if a `HashMap` is created the regular way (e.g. HashMap<K, V>).\n                     id if id == sys_getrandom => {\n                         // The first argument is the syscall id,\n                         // so skip over it.\n                         linux_getrandom(this, &args[1..], dest)?;\n                     }\n+                    id if id == sys_statx => {\n+                        // The first argument is the syscall id,\n+                        // so skip over it.\n+                        let result = this.statx(args[1], args[2], args[3], args[4], args[5])?;\n+                        this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n+                    }\n                     id => throw_unsup_format!(\"miri does not support syscall ID {}\", id),\n                 }\n             }"}, {"sha": "47f3f50b76aff2e6c2069a5178155fc069a27161", "filename": "src/shims/fs.rs", "status": "modified", "additions": 195, "deletions": 3, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/b0c7625dd109197cc38710da64e5eeb401f97379/src%2Fshims%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0c7625dd109197cc38710da64e5eeb401f97379/src%2Fshims%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ffs.rs?ref=b0c7625dd109197cc38710da64e5eeb401f97379", "patch": "@@ -1,12 +1,16 @@\n use std::collections::HashMap;\n-use std::convert::TryFrom;\n+use std::convert::{TryInto, TryFrom};\n use std::fs::{remove_file, File, OpenOptions};\n use std::io::{Read, Write};\n+use std::path::PathBuf;\n+use std::time::SystemTime;\n \n-use rustc::ty::layout::{Size, Align};\n+use rustc::ty::layout::{Size, Align, LayoutOf};\n \n use crate::stacked_borrows::Tag;\n use crate::*;\n+use helpers::immty_from_uint_checked;\n+use shims::time::system_time_to_duration;\n \n #[derive(Debug)]\n pub struct FileHandle {\n@@ -98,7 +102,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let path = this.read_os_str_from_c_str(this.read_scalar(path_op)?.not_undef()?)?;\n \n-        let fd = options.open(path).map(|file| {\n+        let fd = options.open(&path).map(|file| {\n             let mut fh = &mut this.machine.file_handler;\n             fh.low += 1;\n             fh.handles.insert(fh.low, FileHandle { file }).unwrap_none();\n@@ -257,6 +261,181 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.try_unwrap_io_result(result)\n     }\n \n+    fn statx(\n+        &mut self,\n+        dirfd_op: OpTy<'tcx, Tag>, // Should be an `int`\n+        pathname_op: OpTy<'tcx, Tag>, // Should be a `const char *`\n+        flags_op: OpTy<'tcx, Tag>, // Should be an `int`\n+        _mask_op: OpTy<'tcx, Tag>, // Should be an `unsigned int`\n+        statxbuf_op: OpTy<'tcx, Tag> // Should be a `struct statx *`\n+    ) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        this.check_no_isolation(\"statx\")?;\n+\n+        let statxbuf_scalar = this.read_scalar(statxbuf_op)?.not_undef()?;\n+        let pathname_scalar = this.read_scalar(pathname_op)?.not_undef()?;\n+\n+        // If the statxbuf or pathname pointers are null, the function fails with `EFAULT`.\n+        if this.is_null(statxbuf_scalar)? || this.is_null(pathname_scalar)? {\n+            let efault = this.eval_libc(\"EFAULT\")?;\n+            this.set_last_error(efault)?;\n+            return Ok(-1);\n+        }\n+\n+        // Under normal circumstances, we would use `deref_operand(statxbuf_op)` to produce a\n+        // proper `MemPlace` and then write the results of this function to it. However, the\n+        // `syscall` function is untyped. This means that all the `statx` parameters are provided\n+        // as `isize`s instead of having the proper types. Thus, we have to recover the layout of\n+        // `statxbuf_op` by using the `libc::statx` struct type.\n+        let statxbuf_place = {\n+            // FIXME: This long path is required because `libc::statx` is an struct and also a\n+            // function and `resolve_path` is returning the latter.\n+            let statx_ty = this\n+                .resolve_path(&[\"libc\", \"unix\", \"linux_like\", \"linux\", \"gnu\", \"statx\"])?\n+                .ty(*this.tcx);\n+            let statxbuf_ty = this.tcx.mk_mut_ptr(statx_ty);\n+            let statxbuf_layout = this.layout_of(statxbuf_ty)?;\n+            let statxbuf_imm = ImmTy::from_scalar(statxbuf_scalar, statxbuf_layout);\n+            this.ref_to_mplace(statxbuf_imm)?\n+        };\n+\n+        let path: PathBuf = this.read_os_str_from_c_str(pathname_scalar)?.into();\n+        // `flags` should be a `c_int` but the `syscall` function provides an `isize`.\n+        let flags: i32 = this\n+            .read_scalar(flags_op)?\n+            .to_machine_isize(&*this.tcx)?\n+            .try_into()\n+            .map_err(|e| err_unsup_format!(\n+                \"Failed to convert pointer sized operand to integer: {}\",\n+                e\n+            ))?;\n+        // `dirfd` should be a `c_int` but the `syscall` function provides an `isize`.\n+        let dirfd: i32 = this\n+            .read_scalar(dirfd_op)?\n+            .to_machine_isize(&*this.tcx)?\n+            .try_into()\n+            .map_err(|e| err_unsup_format!(\n+                \"Failed to convert pointer sized operand to integer: {}\",\n+                e\n+            ))?;\n+        // we only support interpreting `path` as an absolute directory or as a directory relative\n+        // to `dirfd` when the latter is `AT_FDCWD`. The behavior of `statx` with a relative path\n+        // and a directory file descriptor other than `AT_FDCWD` is specified but it cannot be\n+        // tested from `libstd`. If you found this error, please open an issue reporting it.\n+        if !(path.is_absolute() || dirfd == this.eval_libc_i32(\"AT_FDCWD\")?)\n+        {\n+            throw_unsup_format!(\n+                \"Using statx with a relative path and a file descriptor different from `AT_FDCWD` is not supported\"\n+            )\n+        }\n+\n+        // the `_mask_op` paramter specifies the file information that the caller requested.\n+        // However `statx` is allowed to return information that was not requested or to not\n+        // return information that was requested. This `mask` represents the information we can\n+        // actually provide in any host platform.\n+        let mut mask =\n+            this.eval_libc(\"STATX_TYPE\")?.to_u32()? | this.eval_libc(\"STATX_SIZE\")?.to_u32()?;\n+\n+        // If the `AT_SYMLINK_NOFOLLOW` flag is set, we query the file's metadata without following\n+        // symbolic links.\n+        let metadata = if flags & this.eval_libc(\"AT_SYMLINK_NOFOLLOW\")?.to_i32()? != 0 {\n+            // FIXME: metadata for symlinks need testing.\n+            std::fs::symlink_metadata(path)\n+        } else {\n+            std::fs::metadata(path)\n+        };\n+\n+        let metadata = match metadata {\n+            Ok(metadata) => metadata,\n+            Err(e) => {\n+                this.set_last_error_from_io_error(e)?;\n+                return Ok(-1);\n+            }\n+        };\n+\n+        let file_type = metadata.file_type();\n+\n+        let mode_name = if file_type.is_file() {\n+            \"S_IFREG\"\n+        } else if file_type.is_dir() {\n+            \"S_IFDIR\"\n+        } else {\n+            \"S_IFLNK\"\n+        };\n+\n+        // The `mode` field specifies the type of the file and the permissions over the file for\n+        // the owner, its group and other users. Given that we can only provide the file type\n+        // without using platform specific methods, we only set the bits corresponding to the file\n+        // type. This should be an `__u16` but `libc` provides its values as `u32`.\n+        let mode: u16 = this.eval_libc(mode_name)?\n+                .to_u32()?\n+                .try_into()\n+                .unwrap_or_else(|_| bug!(\"libc contains bad value for `{}` constant\", mode_name));\n+\n+        let size = metadata.len();\n+\n+        let (access_sec, access_nsec) = extract_sec_and_nsec(\n+            metadata.accessed(),\n+            &mut mask,\n+            this.eval_libc(\"STATX_ATIME\")?.to_u32()?\n+        )?;\n+\n+        let (created_sec, created_nsec) = extract_sec_and_nsec(\n+            metadata.created(),\n+            &mut mask,\n+            this.eval_libc(\"STATX_BTIME\")?.to_u32()?\n+        )?;\n+\n+        let (modified_sec, modified_nsec) = extract_sec_and_nsec(\n+            metadata.modified(),\n+            &mut mask,\n+            this.eval_libc(\"STATX_MTIME\")?.to_u32()?\n+        )?;\n+\n+        let __u32_layout = this.libc_ty_layout(\"__u32\")?;\n+        let __u64_layout = this.libc_ty_layout(\"__u64\")?;\n+        let __u16_layout = this.libc_ty_layout(\"__u16\")?;\n+\n+        // Now we transform all this fields into `ImmTy`s and write them to `statxbuf`. We write a\n+        // zero for the unavailable fields.\n+        // FIXME: Provide more fields using platform specific methods.\n+        let imms = [\n+            immty_from_uint_checked(mask, __u32_layout)?,  // stx_mask\n+            immty_from_uint_checked(0u128, __u32_layout)?, // stx_blksize\n+            immty_from_uint_checked(0u128, __u64_layout)?, // stx_attributes\n+            immty_from_uint_checked(0u128, __u32_layout)?, // stx_nlink\n+            immty_from_uint_checked(0u128, __u32_layout)?, // stx_uid\n+            immty_from_uint_checked(0u128, __u32_layout)?, // stx_gid\n+            immty_from_uint_checked(mode, __u16_layout)?,  // stx_mode\n+            immty_from_uint_checked(0u128, __u16_layout)?, // statx padding\n+            immty_from_uint_checked(0u128, __u64_layout)?, // stx_ino\n+            immty_from_uint_checked(size, __u64_layout)?,  // stx_size\n+            immty_from_uint_checked(0u128, __u64_layout)?, // stx_blocks\n+            immty_from_uint_checked(0u128, __u64_layout)?, // stx_attributes\n+            immty_from_uint_checked(access_sec, __u64_layout)?, // stx_atime.tv_sec\n+            immty_from_uint_checked(access_nsec, __u32_layout)?, // stx_atime.tv_nsec\n+            immty_from_uint_checked(0u128, __u32_layout)?, // statx_timestamp padding\n+            immty_from_uint_checked(created_sec, __u64_layout)?, // stx_btime.tv_sec\n+            immty_from_uint_checked(created_nsec, __u32_layout)?, // stx_btime.tv_nsec\n+            immty_from_uint_checked(0u128, __u32_layout)?, // statx_timestamp padding\n+            immty_from_uint_checked(0u128, __u64_layout)?, // stx_ctime.tv_sec\n+            immty_from_uint_checked(0u128, __u32_layout)?, // stx_ctime.tv_nsec\n+            immty_from_uint_checked(0u128, __u32_layout)?, // statx_timestamp padding\n+            immty_from_uint_checked(modified_sec, __u64_layout)?, // stx_mtime.tv_sec\n+            immty_from_uint_checked(modified_nsec, __u32_layout)?, // stx_mtime.tv_nsec\n+            immty_from_uint_checked(0u128, __u32_layout)?, // statx_timestamp padding\n+            immty_from_uint_checked(0u128, __u64_layout)?, // stx_rdev_major\n+            immty_from_uint_checked(0u128, __u64_layout)?, // stx_rdev_minor\n+            immty_from_uint_checked(0u128, __u64_layout)?, // stx_dev_major\n+            immty_from_uint_checked(0u128, __u64_layout)?, // stx_dev_minor\n+        ];\n+\n+        this.write_packed_immediates(&statxbuf_place, &imms)?;\n+\n+        Ok(0)\n+    }\n+\n     /// Function used when a handle is not found inside `FileHandler`. It returns `Ok(-1)`and sets\n     /// the last OS error to `libc::EBADF` (invalid file descriptor). This function uses\n     /// `T: From<i32>` instead of `i32` directly because some fs functions return different integer\n@@ -268,3 +447,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok((-1).into())\n     }\n }\n+\n+// Extracts the number of seconds and nanoseconds elapsed between `time` and the unix epoch, and\n+// then sets the `mask` bits determined by `flag` when `time` is Ok. If `time` is an error, it\n+// returns `(0, 0)` without setting any bits.\n+fn extract_sec_and_nsec<'tcx>(time: std::io::Result<SystemTime>, mask: &mut u32, flag: u32) -> InterpResult<'tcx, (u64, u32)> {\n+    if let Ok(time) = time {\n+        let duration = system_time_to_duration(&time)?;\n+        *mask |= flag;\n+        Ok((duration.as_secs(), duration.subsec_nanos()))\n+    } else {\n+        Ok((0, 0))\n+    }\n+}"}, {"sha": "da9ea07c4f257b8f9392a1946753486fa639a2d8", "filename": "src/shims/time.rs", "status": "modified", "additions": 12, "deletions": 27, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b0c7625dd109197cc38710da64e5eeb401f97379/src%2Fshims%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0c7625dd109197cc38710da64e5eeb401f97379/src%2Fshims%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftime.rs?ref=b0c7625dd109197cc38710da64e5eeb401f97379", "patch": "@@ -1,34 +1,19 @@\n use std::time::{Duration, SystemTime};\n \n-use rustc::ty::layout::TyLayout;\n-\n use crate::stacked_borrows::Tag;\n use crate::*;\n+use helpers::immty_from_int_checked;\n \n-// Returns the time elapsed between now and the unix epoch as a `Duration` and the sign of the time\n-// interval\n+// Returns the time elapsed between now and the unix epoch as a `Duration`.\n fn get_time<'tcx>() -> InterpResult<'tcx, Duration> {\n-    SystemTime::now()\n-        .duration_since(SystemTime::UNIX_EPOCH)\n-        .map_err(|_| err_unsup_format!(\"Times before the Unix epoch are not supported\").into())\n+    system_time_to_duration(&SystemTime::now())\n }\n \n-fn int_to_immty_checked<'tcx>(\n-    int: i128,\n-    layout: TyLayout<'tcx>,\n-) -> InterpResult<'tcx, ImmTy<'tcx, Tag>> {\n-    // If `int` does not fit in `size` bits, we error instead of letting\n-    // `ImmTy::from_int` panic.\n-    let size = layout.size;\n-    let truncated = truncate(int as u128, size);\n-    if sign_extend(truncated, size) as i128 != int {\n-        throw_unsup_format!(\n-            \"Signed value {:#x} does not fit in {} bits\",\n-            int,\n-            size.bits()\n-        )\n-    }\n-    Ok(ImmTy::from_int(int, layout))\n+// Returns the time elapsed between the provided time and the unix epoch as a `Duration`.\n+pub fn system_time_to_duration<'tcx>(time: &SystemTime) -> InterpResult<'tcx, Duration> {\n+    time\n+        .duration_since(SystemTime::UNIX_EPOCH)\n+        .map_err(|_| err_unsup_format!(\"Times before the Unix epoch are not supported\").into())\n }\n \n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n@@ -57,8 +42,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let tv_nsec = duration.subsec_nanos() as i128;\n \n         let imms = [\n-            int_to_immty_checked(tv_sec, this.libc_ty_layout(\"time_t\")?)?,\n-            int_to_immty_checked(tv_nsec, this.libc_ty_layout(\"c_long\")?)?,\n+            immty_from_int_checked(tv_sec, this.libc_ty_layout(\"time_t\")?)?,\n+            immty_from_int_checked(tv_nsec, this.libc_ty_layout(\"c_long\")?)?,\n         ];\n \n         this.write_packed_immediates(&tp, &imms)?;\n@@ -89,8 +74,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let tv_usec = duration.subsec_micros() as i128;\n \n         let imms = [\n-            int_to_immty_checked(tv_sec, this.libc_ty_layout(\"time_t\")?)?,\n-            int_to_immty_checked(tv_usec, this.libc_ty_layout(\"suseconds_t\")?)?,\n+            immty_from_int_checked(tv_sec, this.libc_ty_layout(\"time_t\")?)?,\n+            immty_from_int_checked(tv_usec, this.libc_ty_layout(\"suseconds_t\")?)?,\n         ];\n \n         this.write_packed_immediates(&tv, &imms)?;"}, {"sha": "b8f9e3229af67c918cf419b18b4eaaaab23135d9", "filename": "tests/run-pass/fs.rs", "status": "modified", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b0c7625dd109197cc38710da64e5eeb401f97379/tests%2Frun-pass%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0c7625dd109197cc38710da64e5eeb401f97379/tests%2Frun-pass%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ffs.rs?ref=b0c7625dd109197cc38710da64e5eeb401f97379", "patch": "@@ -2,11 +2,32 @@\n // compile-flags: -Zmiri-disable-isolation\n \n use std::fs::{File, remove_file};\n-use std::io::{Read, Write, ErrorKind};\n+use std::io::{Read, Write, ErrorKind, Result};\n+use std::path::{PathBuf, Path};\n+\n+#[cfg(target_os = \"linux\")]\n+fn test_metadata(bytes: &[u8], path: &Path) -> Result<()> {\n+    // Test that the file metadata is correct.\n+    let metadata = path.metadata()?;\n+    // `path` should point to a file.\n+    assert!(metadata.is_file());\n+    // The size of the file must be equal to the number of written bytes.\n+    assert_eq!(bytes.len() as u64, metadata.len());\n+    Ok(())\n+}\n+\n+// FIXME: Implement stat64 for macos.\n+#[cfg(not(target_os = \"linux\"))]\n+fn test_metadata(_bytes: &[u8], _path: &Path) -> Result<()> {\n+    Ok(())\n+}\n \n fn main() {\n-    let path = std::env::temp_dir().join(\"miri_test_fs.txt\");\n+    let tmp = std::env::temp_dir();\n+    let filename = PathBuf::from(\"miri_test_fs.txt\");\n+    let path = tmp.join(&filename);\n     let bytes = b\"Hello, World!\\n\";\n+\n     // Test creating, writing and closing a file (closing is tested when `file` is dropped).\n     let mut file = File::create(&path).unwrap();\n     // Writing 0 bytes should not change the file contents.\n@@ -21,12 +42,23 @@ fn main() {\n     // Reading until EOF should get the whole text.\n     file.read_to_end(&mut contents).unwrap();\n     assert_eq!(bytes, contents.as_slice());\n-    // Removing file should succeed\n+\n+    // Test that metadata of an absolute path is correct.\n+    test_metadata(bytes, &path).unwrap();\n+    // Test that metadata of a relative path is correct.\n+    std::env::set_current_dir(tmp).unwrap();\n+    test_metadata(bytes, &filename).unwrap();\n+\n+    // Removing file should succeed.\n     remove_file(&path).unwrap();\n \n     // The two following tests also check that the `__errno_location()` shim is working properly.\n     // Opening a non-existing file should fail with a \"not found\" error.\n     assert_eq!(ErrorKind::NotFound, File::open(&path).unwrap_err().kind());\n     // Removing a non-existing file should fail with a \"not found\" error.\n     assert_eq!(ErrorKind::NotFound, remove_file(&path).unwrap_err().kind());\n+    // Reading the metadata of a non-existing file should fail with a \"not found\" error.\n+    if cfg!(target_os = \"linux\") { // FIXME: Implement stat64 for macos.\n+        assert_eq!(ErrorKind::NotFound, test_metadata(bytes, &path).unwrap_err().kind());\n+    }\n }"}]}