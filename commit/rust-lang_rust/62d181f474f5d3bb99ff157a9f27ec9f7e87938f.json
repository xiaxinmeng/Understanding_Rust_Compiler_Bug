{"sha": "62d181f474f5d3bb99ff157a9f27ec9f7e87938f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyZDE4MWY0NzRmNWQzYmI5OWZmMTU3YTlmMjdlYzlmN2U4NzkzOGY=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-02-24T10:58:35Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-03-30T21:26:32Z"}, "message": "Autoderef privacy for fields", "tree": {"sha": "11a6d98392ed0e9201768105299ed3ed4ea9475e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11a6d98392ed0e9201768105299ed3ed4ea9475e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62d181f474f5d3bb99ff157a9f27ec9f7e87938f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62d181f474f5d3bb99ff157a9f27ec9f7e87938f", "html_url": "https://github.com/rust-lang/rust/commit/62d181f474f5d3bb99ff157a9f27ec9f7e87938f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62d181f474f5d3bb99ff157a9f27ec9f7e87938f/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5a91e69582b63f19192ad860df0f7a9a8530f56", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5a91e69582b63f19192ad860df0f7a9a8530f56", "html_url": "https://github.com/rust-lang/rust/commit/d5a91e69582b63f19192ad860df0f7a9a8530f56"}], "stats": {"total": 83, "additions": 48, "deletions": 35}, "files": [{"sha": "294ebb9915b943f4728753f96e59019a7f6e934c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 48, "deletions": 35, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/62d181f474f5d3bb99ff157a9f27ec9f7e87938f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62d181f474f5d3bb99ff157a9f27ec9f7e87938f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=62d181f474f5d3bb99ff157a9f27ec9f7e87938f", "patch": "@@ -2938,25 +2938,26 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                             base: &'tcx hir::Expr,\n                             field: &Spanned<ast::Name>) {\n         check_expr_with_lvalue_pref(fcx, base, lvalue_pref);\n-        let expr_t = structurally_resolved_type(fcx, expr.span,\n-                                                fcx.expr_ty(base));\n-        // FIXME(eddyb) #12808 Integrate privacy into this auto-deref loop.\n+        let expr_t = structurally_resolved_type(fcx, expr.span, fcx.expr_ty(base));\n+        let mut private_candidate = None;\n         let (_, autoderefs, field_ty) = autoderef(fcx,\n                                                   expr.span,\n                                                   expr_t,\n                                                   || Some(base),\n                                                   UnresolvedTypeAction::Error,\n                                                   lvalue_pref,\n                                                   |base_t, _| {\n-                match base_t.sty {\n-                    ty::TyStruct(base_def, substs) => {\n-                        debug!(\"struct named {:?}\",  base_t);\n-                        base_def.struct_variant()\n-                                .find_field_named(field.node)\n-                                .map(|f| fcx.field_ty(expr.span, f, substs))\n+                if let ty::TyStruct(base_def, substs) = base_t.sty {\n+                    debug!(\"struct named {:?}\",  base_t);\n+                    if let Some(field) = base_def.struct_variant().find_field_named(field.node) {\n+                        let field_ty = fcx.field_ty(expr.span, field, substs);\n+                        if field.vis == hir::Public || fcx.private_item_is_visible(base_def.did) {\n+                            return Some(field_ty);\n+                        }\n+                        private_candidate = Some((base_def.did, field_ty));\n                     }\n-                    _ => None\n                 }\n+                None\n             });\n         match field_ty {\n             Some(field_ty) => {\n@@ -2967,12 +2968,14 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             None => {}\n         }\n \n-        if field.node == special_idents::invalid.name {\n+        if let Some((did, field_ty)) = private_candidate {\n+            let struct_path = fcx.tcx().item_path_str(did);\n+            let msg = format!(\"field `{}` of struct `{}` is private\", field.node, struct_path);\n+            fcx.tcx().sess.span_err(expr.span, &msg);\n+            fcx.write_ty(expr.id, field_ty);\n+        } else if field.node == special_idents::invalid.name {\n             fcx.write_error(expr.id);\n-            return;\n-        }\n-\n-        if method::exists(fcx, field.span, field.node, expr_t, expr.id) {\n+        } else if method::exists(fcx, field.span, field.node, expr_t, expr.id) {\n             fcx.type_error_struct(field.span,\n                                   |actual| {\n                                        format!(\"attempted to take value of method `{}` on type \\\n@@ -2983,6 +2986,7 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                \"maybe a `()` to call it is missing? \\\n                                If not, try an anonymous function\")\n                 .emit();\n+            fcx.write_error(expr.id);\n         } else {\n             let mut err = fcx.type_error_struct(\n                 expr.span,\n@@ -2998,9 +3002,8 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 suggest_field_names(&mut err, def.struct_variant(), field, vec![]);\n             }\n             err.emit();\n+            fcx.write_error(expr.id);\n         }\n-\n-        fcx.write_error(expr.id);\n     }\n \n     // displays hints about the closest matches in field names\n@@ -3035,36 +3038,37 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                 base: &'tcx hir::Expr,\n                                 idx: codemap::Spanned<usize>) {\n         check_expr_with_lvalue_pref(fcx, base, lvalue_pref);\n-        let expr_t = structurally_resolved_type(fcx, expr.span,\n-                                                fcx.expr_ty(base));\n+        let expr_t = structurally_resolved_type(fcx, expr.span, fcx.expr_ty(base));\n+        let mut private_candidate = None;\n         let mut tuple_like = false;\n-        // FIXME(eddyb) #12808 Integrate privacy into this auto-deref loop.\n         let (_, autoderefs, field_ty) = autoderef(fcx,\n                                                   expr.span,\n                                                   expr_t,\n                                                   || Some(base),\n                                                   UnresolvedTypeAction::Error,\n                                                   lvalue_pref,\n                                                   |base_t, _| {\n-                match base_t.sty {\n-                    ty::TyStruct(base_def, substs) => {\n-                        tuple_like = base_def.struct_variant().is_tuple_struct();\n-                        if tuple_like {\n-                            debug!(\"tuple struct named {:?}\",  base_t);\n-                            base_def.struct_variant()\n-                                    .fields\n-                                    .get(idx.node)\n-                                    .map(|f| fcx.field_ty(expr.span, f, substs))\n-                        } else {\n-                            None\n-                        }\n-                    }\n+                let (base_def, substs) = match base_t.sty {\n+                    ty::TyStruct(base_def, substs) => (base_def, substs),\n                     ty::TyTuple(ref v) => {\n                         tuple_like = true;\n-                        if idx.node < v.len() { Some(v[idx.node]) } else { None }\n+                        return if idx.node < v.len() { Some(v[idx.node]) } else { None }\n                     }\n-                    _ => None\n+                    _ => return None,\n+                };\n+\n+                tuple_like = base_def.struct_variant().is_tuple_struct();\n+                if !tuple_like { return None }\n+\n+                debug!(\"tuple struct named {:?}\",  base_t);\n+                if let Some(field) = base_def.struct_variant().fields.get(idx.node) {\n+                    let field_ty = fcx.field_ty(expr.span, field, substs);\n+                    if field.vis == hir::Public || fcx.private_item_is_visible(base_def.did) {\n+                        return Some(field_ty);\n+                    }\n+                    private_candidate = Some((base_def.did, field_ty));\n                 }\n+                None\n             });\n         match field_ty {\n             Some(field_ty) => {\n@@ -3074,6 +3078,15 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             }\n             None => {}\n         }\n+\n+        if let Some((did, field_ty)) = private_candidate {\n+            let struct_path = fcx.tcx().item_path_str(did);\n+            let msg = format!(\"field `{}` of struct `{}` is private\", idx.node, struct_path);\n+            fcx.tcx().sess.span_err(expr.span, &msg);\n+            fcx.write_ty(expr.id, field_ty);\n+            return;\n+        }\n+\n         fcx.type_error_message(\n             expr.span,\n             |actual| {"}]}