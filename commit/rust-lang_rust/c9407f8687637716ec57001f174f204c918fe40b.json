{"sha": "c9407f8687637716ec57001f174f204c918fe40b", "node_id": "C_kwDOAAsO6NoAKGM5NDA3Zjg2ODc2Mzc3MTZlYzU3MDAxZjE3NGYyMDRjOTE4ZmU0MGI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-30T06:52:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-30T06:52:13Z"}, "message": "Auto merge of #2091 - dtolnay-contrib:clippy, r=oli-obk\n\nResolve some clippy lints, ignore the rest\n\n`cargo clippy` finishes cleanly after this. I stuck to only what I think are the least objectionable lints: cleaning up useless identity conversions that do `from`/`try_from`/`into` going from T-&gt;T, extraneous `&` on expressions that are already a reference, unused lifetime parameters, and similar.\n\nBelow in the \\<details\\> is the complete remaining output of `cargo clippy` with the `allow` attribute removed. I think all the lints left are fine to keep ignoring.\n\n<details>\n<summary><code>$ cargo clippy -- -Dclippy::all</code></summary>\n\n```console\nerror: this `else { if .. }` block can be collapsed\n   --> src/data_race.rs:559:16\n    |\n559 |           } else {\n    |  ________________^\n560 | |             if lt { &rhs } else { &old }\n561 | |         };\n    | |_________^ help: collapse nested if block: `if lt { &rhs } else { &old }`\n    |\n    = note: `-D clippy::collapsible-else-if` implied by `-D clippy::all`\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if\n\nerror: this `if` statement can be collapsed\n   --> src/range_map.rs:166:17\n    |\n166 | /                 if successful_merge_count > 0 {\n167 | |                     if done || self.v[end_idx].data != self.v[equal_since_idx].data {\n168 | |                         // Everything in `equal_since..end` was equal. Make them just one element covering\n169 | |                         // the entire range.\n...   |\n187 | |                     }\n188 | |                 }\n    | |_________________^\n    |\n    = note: `-D clippy::collapsible-if` implied by `-D clippy::all`\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\nhelp: collapse nested if block\n    |\n166 ~                 if successful_merge_count > 0 && (done || self.v[end_idx].data != self.v[equal_since_idx].data) {\n167 +                     // Everything in `equal_since..end` was equal. Make them just one element covering\n168 +                     // the entire range.\n169 +                     let removed_elems = end_idx - equal_since_idx - 1; // number of elements that we would remove\n170 +                     if removed_elems > 0 {\n171 +                         // Adjust the range of the first element to cover all of them.\n  ...\n\nerror: this `else { if .. }` block can be collapsed\n   --> src/shims/foreign_items.rs:114:16\n    |\n114 |           } else {\n    |  ________________^\n115 | |             if new_size == 0 {\n116 | |                 this.deallocate_ptr(old_ptr, None, kind.into())?;\n117 | |                 Ok(Pointer::null())\n...   |\n127 | |             }\n128 | |         }\n    | |_________^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if\nhelp: collapse nested if block\n    |\n114 ~         } else if new_size == 0 {\n115 +             this.deallocate_ptr(old_ptr, None, kind.into())?;\n116 +             Ok(Pointer::null())\n117 +         } else {\n118 +             let new_ptr = this.reallocate_ptr(\n119 +                 old_ptr,\n  ...\n\nerror: this `else { if .. }` block can be collapsed\n   --> src/shims/posix/sync.rs:459:20\n    |\n459 |               } else {\n    |  ____________________^\n460 | |                 if is_mutex_kind_default(this, kind)?\n461 | |                     || is_mutex_kind_normal(this, kind)?\n462 | |                     || kind == this.eval_libc(\"PTHREAD_MUTEX_ERRORCHECK\")?\n...   |\n472 | |                 }\n473 | |             }\n    | |_____________^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if\nhelp: collapse nested if block\n    |\n459 ~             } else if is_mutex_kind_default(this, kind)?\n460 +                 || is_mutex_kind_normal(this, kind)?\n461 +                 || kind == this.eval_libc(\"PTHREAD_MUTEX_ERRORCHECK\")?\n462 +             {\n463 +                 this.eval_libc_i32(\"EBUSY\")\n464 +             } else if kind == this.eval_libc(\"PTHREAD_MUTEX_RECURSIVE\")? {\n  ...\n\nerror: this `if` statement can be collapsed\n   --> src/thread.rs:132:9\n    |\n132 | /         if self.state == ThreadState::Enabled {\n133 | |             if self.stack.is_empty() {\n134 | |                 self.state = ThreadState::Terminated;\n135 | |                 return true;\n136 | |             }\n137 | |         }\n    | |_________^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\nhelp: collapse nested if block\n    |\n132 ~         if self.state == ThreadState::Enabled && self.stack.is_empty() {\n133 +             self.state = ThreadState::Terminated;\n134 +             return true;\n135 +         }\n    |\n\nerror: this `if` statement can be collapsed\n   --> src/thread.rs:523:13\n    |\n523 | /             if thread.state == ThreadState::Enabled {\n524 | |                 if !self.yield_active_thread || id != self.active_thread {\n525 | |                     self.active_thread = id;\n526 | |                     if let Some(data_race) = data_race {\n...   |\n530 | |                 }\n531 | |             }\n    | |_____________^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\nhelp: collapse nested if block\n    |\n523 ~             if thread.state == ThreadState::Enabled && (!self.yield_active_thread || id != self.active_thread) {\n524 +                 self.active_thread = id;\n525 +                 if let Some(data_race) = data_race {\n526 +                     data_race.thread_set_active(self.active_thread);\n527 +                 }\n528 +                 break;\n  ...\n\nerror: you should consider adding a `Default` implementation for `GlobalState`\n    --> src/data_race.rs:1132:5\n     |\n1132 | /     pub fn new() -> Self {\n1133 | |         let mut global_state = GlobalState {\n1134 | |             multi_threaded: Cell::new(false),\n1135 | |             vector_clocks: RefCell::new(IndexVec::new()),\n...    |\n1155 | |         global_state\n1156 | |     }\n     | |_____^\n     |\n     = note: `-D clippy::new-without-default` implied by `-D clippy::all`\n     = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#new_without_default\nhelp: try adding this\n     |\n1129 + impl Default for GlobalState {\n1130 +     fn default() -> Self {\n1131 +         Self::new()\n1132 +     }\n1133 + }\n     |\n\nerror: useless use of `format!`\n   --> src/diagnostics.rs:155:32\n    |\n155 |                         (None, format!(\"pass the flag `-Zmiri-disable-isolation` to disable isolation;\")),\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `\"pass the flag `-Zmiri-disable-isolation` to disable isolation;\".to_string()`\n    |\n    = note: `-D clippy::useless-format` implied by `-D clippy::all`\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#useless_format\n\nerror: useless use of `format!`\n   --> src/diagnostics.rs:156:32\n    |\n156 | ...e, format!(\"or pass `-Zmiri-isolation-error=warn` to configure Miri to return an error code from isolated operations (if supported for that operation) and continue with a warning\"...\n    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `\"or pass `-Zmiri-isolation-error=warn` to configure Miri to return an error code from isolated operations (if supported for that operation) and continue with a warning\".to_string()`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#useless_format\n\nerror: useless use of `format!`\n   --> src/diagnostics.rs:161:32\n    |\n161 | ...e, format!(\"this indicates a potential bug in the program: it performed an invalid operation, but the rules it violated are still experimental\"...\n    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `\"this indicates a potential bug in the program: it performed an invalid operation, but the rules it violated are still experimental\".to_string()`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#useless_format\n\nerror: useless use of `format!`\n   --> src/diagnostics.rs:197:33\n    |\n197 | ...e, format!(\"this is likely not a bug in the program; it indicates that the program performed an operation that the interpreter does not support\")...\n    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `\"this is likely not a bug in the program; it indicates that the program performed an operation that the interpreter does not support\".to_string()`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#useless_format\n\nerror: useless use of `format!`\n   --> src/diagnostics.rs:202:32\n    |\n202 | ...  (None, format!(\"this usually indicates that your program performed an invalid operation and caused Undefined Behavior\")),\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `\"this usually indicates that your program performed an invalid operation and caused Undefined Behavior\".to_string()`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#useless_format\n\nerror: useless use of `format!`\n   --> src/diagnostics.rs:203:32\n    |\n203 |                         (None, format!(\"but due to `-Zmiri-symbolic-alignment-check`, alignment errors can also be false positives\")),\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `\"but due to `-Zmiri-symbolic-alignment-check`, alignment errors can also be false positives\".to_string()`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#useless_format\n\nerror: useless use of `format!`\n   --> src/diagnostics.rs:207:32\n    |\n207 | ...  (None, format!(\"this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\")),\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `\"this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\".to_string()`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#useless_format\n\nerror: useless use of `format!`\n   --> src/diagnostics.rs:208:32\n    |\n208 | ...(None, format!(\"see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\")),\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `\"see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\".to_string()`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#useless_format\n\nerror: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n   --> src/diagnostics.rs:247:5\n    |\n247 | /     match e.kind() {\n248 | |         UndefinedBehavior(UndefinedBehaviorInfo::InvalidUninitBytes(Some((alloc_id, access)))) => {\n249 | |             eprintln!(\n250 | |                 \"Uninitialized read occurred at offsets 0x{:x}..0x{:x} into this allocation:\",\n...   |\n256 | |         _ => {}\n257 | |     }\n    | |_____^\n    |\n    = note: `-D clippy::single-match` implied by `-D clippy::all`\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#single_match\nhelp: try this\n    |\n247 ~     if let UndefinedBehavior(UndefinedBehaviorInfo::InvalidUninitBytes(Some((alloc_id, access)))) = e.kind() {\n248 +         eprintln!(\n249 +             \"Uninitialized read occurred at offsets 0x{:x}..0x{:x} into this allocation:\",\n250 +             access.uninit_offset.bytes(),\n251 +             access.uninit_offset.bytes() + access.uninit_size.bytes(),\n252 +         );\n  ...\n\nerror: an implementation of `From` is preferred since it gives you `Into<_>` for free where the reverse isn't true\n  --> src/machine.rs:92:1\n   |\n92 | impl Into<MemoryKind<MiriMemoryKind>> for MiriMemoryKind {\n   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: `-D clippy::from-over-into` implied by `-D clippy::all`\n   = help: consider to implement `From<machine::MiriMemoryKind>` instead\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#from_over_into\n\nerror: manual implementation of `Option::map`\n   --> src/machine.rs:570:22\n    |\n570 |           let stacks = if let Some(stacked_borrows) = &ecx.machine.stacked_borrows {\n    |  ______________________^\n571 | |             Some(Stacks::new_allocation(id, alloc.size(), stacked_borrows, kind))\n572 | |         } else {\n573 | |             None\n574 | |         };\n    | |_________^ help: try this: `ecx.machine.stacked_borrows.as_ref().map(|stacked_borrows| Stacks::new_allocation(id, alloc.size(), stacked_borrows, kind))`\n    |\n    = note: `-D clippy::manual-map` implied by `-D clippy::all`\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#manual_map\n\nerror: manual implementation of `Option::map`\n   --> src/machine.rs:575:26\n    |\n575 |           let race_alloc = if let Some(data_race) = &ecx.machine.data_race {\n    |  __________________________^\n576 | |             Some(data_race::AllocExtra::new_allocation(data_race, alloc.size(), kind))\n577 | |         } else {\n578 | |             None\n579 | |         };\n    | |_________^ help: try this: `ecx.machine.data_race.as_ref().map(|data_race| data_race::AllocExtra::new_allocation(data_race, alloc.size(), kind))`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#manual_map\n\nerror: variant name ends with the enum's name\n   --> src/shims/intrinsics.rs:354:21\n    |\n354 |                     MirOp(mir::UnOp),\n    |                     ^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::enum-variant-names` implied by `-D clippy::all`\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#enum_variant_names\n\nerror: variant name ends with the enum's name\n   --> src/shims/intrinsics.rs:453:21\n    |\n453 |                     MirOp(BinOp),\n    |                     ^^^^^^^^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#enum_variant_names\n\nerror: variant name ends with the enum's name\n   --> src/shims/intrinsics.rs:454:21\n    |\n454 |                     SaturatingOp(BinOp),\n    |                     ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#enum_variant_names\n\nerror: variant name ends with the enum's name\n   --> src/shims/intrinsics.rs:580:21\n    |\n580 |                     MirOp(BinOp),\n    |                     ^^^^^^^^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#enum_variant_names\n\nerror: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n    --> src/shims/intrinsics.rs:1391:1\n     |\n1391 | fn simd_element_to_bool<'tcx>(elem: ImmTy<'tcx, Tag>) -> InterpResult<'tcx, bool> {\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `-D clippy::needless-lifetimes` implied by `-D clippy::all`\n     = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#needless_lifetimes\n\nerror: this `if` has identical blocks\n   --> src/shims/posix/sync.rs:503:75\n    |\n503 |               } else if kind == this.eval_libc(\"PTHREAD_MUTEX_ERRORCHECK\")? {\n    |  ___________________________________________________________________________^\n504 | |                 this.eval_libc_i32(\"EPERM\")\n505 | |             } else if kind == this.eval_libc(\"PTHREAD_MUTEX_RECURSIVE\")? {\n    | |_____________^\n    |\n    = note: `-D clippy::if-same-then-else` implied by `-D clippy::all`\nnote: same as this\n   --> src/shims/posix/sync.rs:505:74\n    |\n505 |               } else if kind == this.eval_libc(\"PTHREAD_MUTEX_RECURSIVE\")? {\n    |  __________________________________________________________________________^\n506 | |                 this.eval_libc_i32(\"EPERM\")\n507 | |             } else {\n    | |_____________^\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#if_same_then_else\n\nerror: this `if` has identical blocks\n   --> src/shims/posix/sync.rs:610:57\n    |\n610 |           if this.rwlock_reader_unlock(id, active_thread) {\n    |  _________________________________________________________^\n611 | |             Ok(0)\n612 | |         } else if this.rwlock_writer_unlock(id, active_thread) {\n    | |_________^\n    |\nnote: same as this\n   --> src/shims/posix/sync.rs:612:64\n    |\n612 |           } else if this.rwlock_writer_unlock(id, active_thread) {\n    |  ________________________________________________________________^\n613 | |             Ok(0)\n614 | |         } else {\n    | |_________^\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#if_same_then_else\n\nerror: useless use of `format!`\n   --> src/stacked_borrows.rs:228:14\n    |\n228 |           url: format!(\n    |  ______________^\n229 | |             \"https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md\"\n230 | |         ),\n    | |_________^ help: consider using `.to_string()`: `\"https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md\".to_string()`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#useless_format\n\nerror: field assignment outside of initializer for an instance created with Default::default()\n   --> src/thread.rs:234:9\n    |\n234 |         main_thread.join_status = ThreadJoinStatus::Detached;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::field-reassign-with-default` implied by `-D clippy::all`\nnote: consider initializing the variable with `Thread::<'_, '_> { join_status: ThreadJoinStatus::Detached, ..Default::default() }` and removing relevant reassignments\n   --> src/thread.rs:232:9\n    |\n232 |         let mut main_thread = Thread::default();\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#field_reassign_with_default\n\nerror: `if` chain can be rewritten with `match`\n   --> src/vector_clock.rs:224:17\n    |\n224 | /                 if l > r {\n225 | |                     return false;\n226 | |                 } else if l < r {\n227 | |                     equal = false;\n228 | |                 }\n    | |_________________^\n    |\n    = note: `-D clippy::comparison-chain` implied by `-D clippy::all`\n    = help: consider rewriting the `if` chain to use `cmp` and `match`\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#comparison_chain\n\nerror: `if` chain can be rewritten with `match`\n   --> src/vector_clock.rs:278:17\n    |\n278 | /                 if l < r {\n279 | |                     return false;\n280 | |                 } else if l > r {\n281 | |                     equal = false;\n282 | |                 }\n    | |_________________^\n    |\n    = help: consider rewriting the `if` chain to use `cmp` and `match`\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#comparison_chain\n\nerror: manual `RangeInclusive::contains` implementation\n   --> src/bin/miri.rs:473:37\n    |\n473 |                         Ok(rate) if rate >= 0.0 && rate <= 1.0 => rate,\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use: `(0.0..=1.0).contains(&rate)`\n    |\n    = note: `-D clippy::manual-range-contains` implied by `-D clippy::all`\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#manual_range_contains\n```\n</details>", "tree": {"sha": "d4c301e2c92055157702186b37fc17e17ee75b10", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4c301e2c92055157702186b37fc17e17ee75b10"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9407f8687637716ec57001f174f204c918fe40b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9407f8687637716ec57001f174f204c918fe40b", "html_url": "https://github.com/rust-lang/rust/commit/c9407f8687637716ec57001f174f204c918fe40b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9407f8687637716ec57001f174f204c918fe40b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0fce9f499404a96c3885862c967484c0f0dd03ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/0fce9f499404a96c3885862c967484c0f0dd03ea", "html_url": "https://github.com/rust-lang/rust/commit/0fce9f499404a96c3885862c967484c0f0dd03ea"}, {"sha": "96036c65bfa1251c4ba2bcf1ebd2f00bfe9b4e2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/96036c65bfa1251c4ba2bcf1ebd2f00bfe9b4e2e", "html_url": "https://github.com/rust-lang/rust/commit/96036c65bfa1251c4ba2bcf1ebd2f00bfe9b4e2e"}], "stats": {"total": 150, "additions": 80, "deletions": 70}, "files": [{"sha": "0030c24b19e6d5adb6624a2f7b625659861f27a9", "filename": "src/bin/miri.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c9407f8687637716ec57001f174f204c918fe40b/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9407f8687637716ec57001f174f204c918fe40b/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=c9407f8687637716ec57001f174f204c918fe40b", "patch": "@@ -1,4 +1,5 @@\n #![feature(rustc_private, bool_to_option, stmt_expr_attributes)]\n+#![allow(clippy::manual_range_contains)]\n \n extern crate rustc_data_structures;\n extern crate rustc_driver;"}, {"sha": "d249d28d03f54ca027e11a5f89a2a3f601f4b065", "filename": "src/data_race.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9407f8687637716ec57001f174f204c918fe40b/src%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9407f8687637716ec57001f174f204c918fe40b/src%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdata_race.rs?ref=c9407f8687637716ec57001f174f204c918fe40b", "patch": "@@ -562,7 +562,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n \n         this.allow_data_races_mut(|this| this.write_immediate(**new_val, &(*place).into()))?;\n \n-        this.validate_atomic_rmw(&place, atomic)?;\n+        this.validate_atomic_rmw(place, atomic)?;\n \n         // Return the old value.\n         Ok(old)\n@@ -784,7 +784,7 @@ impl VClockAlloc {\n                     None\n                 }\n             })\n-            .map(|idx| VectorIdx::new(idx))\n+            .map(VectorIdx::new)\n     }\n \n     /// Report a data-race found in the program.\n@@ -1410,7 +1410,7 @@ impl GlobalState {\n     /// incremented.\n     pub fn validate_lock_acquire(&self, lock: &VClock, thread: ThreadId) {\n         let (_, mut clocks) = self.load_thread_state_mut(thread);\n-        clocks.clock.join(&lock);\n+        clocks.clock.join(lock);\n     }\n \n     /// Release a lock handle, express that this happens-before"}, {"sha": "1a39a1ff332e97f7a7060a350602c984828a6ebf", "filename": "src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9407f8687637716ec57001f174f204c918fe40b/src%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9407f8687637716ec57001f174f204c918fe40b/src%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiagnostics.rs?ref=c9407f8687637716ec57001f174f204c918fe40b", "patch": "@@ -296,7 +296,7 @@ fn report_msg<'mir, 'tcx>(\n     // Show help messages.\n     if !helps.is_empty() {\n         // Add visual separator before backtrace.\n-        helps.last_mut().unwrap().1.push_str(\"\\n\");\n+        helps.last_mut().unwrap().1.push('\\n');\n         for (span_data, help) in helps {\n             if let Some(span_data) = span_data {\n                 err.span_help(span_data.span(), &help);"}, {"sha": "107a2551995adae7f891d042976f3f866c4b3ce0", "filename": "src/helpers.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c9407f8687637716ec57001f174f204c918fe40b/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9407f8687637716ec57001f174f204c918fe40b/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=c9407f8687637716ec57001f174f204c918fe40b", "patch": "@@ -43,15 +43,15 @@ const UNIX_IO_ERROR_TABLE: &[(std::io::ErrorKind, &str)] = {\n };\n \n /// Gets an instance for a path.\n-fn try_resolve_did<'mir, 'tcx>(tcx: TyCtxt<'tcx>, path: &[&str]) -> Option<DefId> {\n+fn try_resolve_did<'tcx>(tcx: TyCtxt<'tcx>, path: &[&str]) -> Option<DefId> {\n     tcx.crates(()).iter().find(|&&krate| tcx.crate_name(krate).as_str() == path[0]).and_then(\n         |krate| {\n             let krate = DefId { krate: *krate, index: CRATE_DEF_INDEX };\n             let mut items = tcx.module_children(krate);\n             let mut path_it = path.iter().skip(1).peekable();\n \n             while let Some(segment) = path_it.next() {\n-                for item in mem::replace(&mut items, Default::default()).iter() {\n+                for item in mem::take(&mut items).iter() {\n                     if item.ident.name.as_str() == *segment {\n                         if path_it.peek().is_none() {\n                             return Some(item.res.def_id());\n@@ -83,7 +83,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let cid = GlobalId { instance, promoted: None };\n         let const_val = this.eval_to_allocation(cid)?;\n         let const_val = this.read_scalar(&const_val.into())?;\n-        return Ok(const_val.check_init()?);\n+        const_val.check_init()\n     }\n \n     /// Helper function to get a `libc` constant as a `Scalar`.\n@@ -196,7 +196,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// Get the `Place` for a local\n     fn local_place(&mut self, local: mir::Local) -> InterpResult<'tcx, PlaceTy<'tcx, Tag>> {\n         let this = self.eval_context_mut();\n-        let place = mir::Place { local: local, projection: List::empty() };\n+        let place = mir::Place { local, projection: List::empty() };\n         this.eval_place(place)\n     }\n \n@@ -323,7 +323,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     trace!(\"unsafe_cell_action on {:?}\", place.ptr);\n                     // We need a size to go on.\n                     let unsafe_cell_size = this\n-                        .size_and_align_of_mplace(&place)?\n+                        .size_and_align_of_mplace(place)?\n                         .map(|(size, _)| size)\n                         // for extern types, just cover what we can\n                         .unwrap_or_else(|| place.layout.size);\n@@ -362,7 +362,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             #[inline(always)]\n             fn ecx(&self) -> &MiriEvalContext<'mir, 'tcx> {\n-                &self.ecx\n+                self.ecx\n             }\n \n             // Hook to detect `UnsafeCell`.\n@@ -631,10 +631,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// `EINVAL` in this case.\n     fn read_timespec(&mut self, tp: &MPlaceTy<'tcx, Tag>) -> InterpResult<'tcx, Option<Duration>> {\n         let this = self.eval_context_mut();\n-        let seconds_place = this.mplace_field(&tp, 0)?;\n+        let seconds_place = this.mplace_field(tp, 0)?;\n         let seconds_scalar = this.read_scalar(&seconds_place.into())?;\n         let seconds = seconds_scalar.to_machine_isize(this)?;\n-        let nanoseconds_place = this.mplace_field(&tp, 1)?;\n+        let nanoseconds_place = this.mplace_field(tp, 1)?;\n         let nanoseconds_scalar = this.read_scalar(&nanoseconds_place.into())?;\n         let nanoseconds = nanoseconds_scalar.to_machine_isize(this)?;\n \n@@ -664,18 +664,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         loop {\n             // FIXME: We are re-getting the allocation each time around the loop.\n             // Would be nice if we could somehow \"extend\" an existing AllocRange.\n-            let alloc =\n-                this.get_ptr_alloc(ptr.offset(len, this)?.into(), size1, Align::ONE)?.unwrap(); // not a ZST, so we will get a result\n+            let alloc = this.get_ptr_alloc(ptr.offset(len, this)?, size1, Align::ONE)?.unwrap(); // not a ZST, so we will get a result\n             let byte = alloc.read_scalar(alloc_range(Size::ZERO, size1))?.to_u8()?;\n             if byte == 0 {\n                 break;\n             } else {\n-                len = len + size1;\n+                len += size1;\n             }\n         }\n \n         // Step 2: get the bytes.\n-        this.read_bytes_ptr(ptr.into(), len)\n+        this.read_bytes_ptr(ptr, len)\n     }\n \n     fn read_wide_str(&self, mut ptr: Pointer<Option<Tag>>) -> InterpResult<'tcx, Vec<u16>> {\n@@ -687,7 +686,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         loop {\n             // FIXME: We are re-getting the allocation each time around the loop.\n             // Would be nice if we could somehow \"extend\" an existing AllocRange.\n-            let alloc = this.get_ptr_alloc(ptr.into(), size2, align2)?.unwrap(); // not a ZST, so we will get a result\n+            let alloc = this.get_ptr_alloc(ptr, size2, align2)?.unwrap(); // not a ZST, so we will get a result\n             let wchar = alloc.read_scalar(alloc_range(Size::ZERO, size2))?.to_u16()?;\n             if wchar == 0 {\n                 break;\n@@ -731,7 +730,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // message is slightly different here to make automated analysis easier\n             let error_msg = format!(\"unsupported Miri functionality: {}\", error_msg.as_ref());\n             this.start_panic(error_msg.as_ref(), StackPopUnwind::Skip)?;\n-            return Ok(());\n+            Ok(())\n         } else {\n             throw_unsup_format!(\"{}\", error_msg.as_ref());\n         }\n@@ -802,7 +801,7 @@ pub fn get_local_crates(tcx: &TyCtxt<'_>) -> Vec<CrateNum> {\n     // Convert the local crate names from the passed-in config into CrateNums so that they can\n     // be looked up quickly during execution\n     let local_crate_names = std::env::var(\"MIRI_LOCAL_CRATES\")\n-        .map(|crates| crates.split(\",\").map(|krate| krate.to_string()).collect::<Vec<_>>())\n+        .map(|crates| crates.split(',').map(|krate| krate.to_string()).collect::<Vec<_>>())\n         .unwrap_or_default();\n     let mut local_crates = Vec::new();\n     for &crate_num in tcx.crates(()) {"}, {"sha": "3f1ba574ce069c4e7fcb2b63fd7ef1a24e3a9805", "filename": "src/lib.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c9407f8687637716ec57001f174f204c918fe40b/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9407f8687637716ec57001f174f204c918fe40b/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=c9407f8687637716ec57001f174f204c918fe40b", "patch": "@@ -7,7 +7,21 @@\n #![feature(bool_to_option)]\n #![feature(io_error_more)]\n #![warn(rust_2018_idioms)]\n-#![allow(clippy::cast_lossless)]\n+#![allow(\n+    clippy::cast_lossless,\n+    clippy::collapsible_else_if,\n+    clippy::collapsible_if,\n+    clippy::comparison_chain,\n+    clippy::enum_variant_names,\n+    clippy::field_reassign_with_default,\n+    clippy::from_over_into,\n+    clippy::if_same_then_else,\n+    clippy::manual_map,\n+    clippy::needless_lifetimes,\n+    clippy::new_without_default,\n+    clippy::single_match,\n+    clippy::useless_format\n+)]\n \n extern crate rustc_apfloat;\n extern crate rustc_ast;"}, {"sha": "0a8a229c8aa2cc5464133f2449321b4567d6012f", "filename": "src/machine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9407f8687637716ec57001f174f204c918fe40b/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9407f8687637716ec57001f174f204c918fe40b/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=c9407f8687637716ec57001f174f204c918fe40b", "patch": "@@ -544,7 +544,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         def_id: DefId,\n     ) -> InterpResult<'tcx, Pointer<Tag>> {\n         let attrs = ecx.tcx.get_attrs(def_id);\n-        let link_name = match ecx.tcx.sess.first_attr_value_str_by_name(&attrs, sym::link_name) {\n+        let link_name = match ecx.tcx.sess.first_attr_value_str_by_name(attrs, sym::link_name) {\n             Some(name) => name,\n             None => ecx.tcx.item_name(def_id),\n         };\n@@ -573,7 +573,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n             None\n         };\n         let race_alloc = if let Some(data_race) = &ecx.machine.data_race {\n-            Some(data_race::AllocExtra::new_allocation(&data_race, alloc.size(), kind))\n+            Some(data_race::AllocExtra::new_allocation(data_race, alloc.size(), kind))\n         } else {\n             None\n         };"}, {"sha": "474ad9dcccd933977765f045fb23703500cb0a90", "filename": "src/range_map.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c9407f8687637716ec57001f174f204c918fe40b/src%2Frange_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9407f8687637716ec57001f174f204c918fe40b/src%2Frange_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frange_map.rs?ref=c9407f8687637716ec57001f174f204c918fe40b", "patch": "@@ -63,7 +63,7 @@ impl<T> RangeMap<T> {\n     /// through interior mutability.\n     ///\n     /// The iterator also provides the offset of the given element.\n-    pub fn iter<'a>(&'a self, offset: Size, len: Size) -> impl Iterator<Item = (Size, &'a T)> + 'a {\n+    pub fn iter(&self, offset: Size, len: Size) -> impl Iterator<Item = (Size, &T)> {\n         let offset = offset.bytes();\n         let len = len.bytes();\n         // Compute a slice starting with the elements we care about.\n@@ -83,7 +83,7 @@ impl<T> RangeMap<T> {\n             .map(|elem| (Size::from_bytes(elem.range.start), &elem.data))\n     }\n \n-    pub fn iter_mut_all<'a>(&'a mut self) -> impl Iterator<Item = &'a mut T> + 'a {\n+    pub fn iter_mut_all(&mut self) -> impl Iterator<Item = &mut T> {\n         self.v.iter_mut().map(|elem| &mut elem.data)\n     }\n \n@@ -110,7 +110,7 @@ impl<T> RangeMap<T> {\n         // Copy the data, and insert second element.\n         let second = Elem { range: second_range, data: elem.data.clone() };\n         self.v.insert(index + 1, second);\n-        return true;\n+        true\n     }\n \n     /// Provides mutable iteration over everything in the given range. As a side-effect,\n@@ -119,11 +119,7 @@ impl<T> RangeMap<T> {\n     /// Moreover, this will opportunistically merge neighbouring equal blocks.\n     ///\n     /// The iterator also provides the offset of the given element.\n-    pub fn iter_mut<'a>(\n-        &'a mut self,\n-        offset: Size,\n-        len: Size,\n-    ) -> impl Iterator<Item = (Size, &'a mut T)> + 'a\n+    pub fn iter_mut(&mut self, offset: Size, len: Size) -> impl Iterator<Item = (Size, &mut T)>\n     where\n         T: Clone + PartialEq,\n     {"}, {"sha": "ae9b8c75145f78a2cfabf1f00dd0e322dadaf07e", "filename": "src/shims/env.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c9407f8687637716ec57001f174f204c918fe40b/src%2Fshims%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9407f8687637716ec57001f174f204c918fe40b/src%2Fshims%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fenv.rs?ref=c9407f8687637716ec57001f174f204c918fe40b", "patch": "@@ -50,8 +50,8 @@ impl<'tcx> EnvVars<'tcx> {\n         if ecx.machine.communicate() || !config.forwarded_env_vars.is_empty() {\n             for (name, value) in env::vars_os() {\n                 let forward = match ecx.machine.communicate() {\n-                    true => !excluded_env_vars.iter().any(|v| v.as_str() == &name),\n-                    false => config.forwarded_env_vars.iter().any(|v| v.as_str() == &name),\n+                    true => !excluded_env_vars.iter().any(|v| **v == name),\n+                    false => config.forwarded_env_vars.iter().any(|v| **v == name),\n                 };\n                 if forward {\n                     let var_ptr = match target_os {\n@@ -64,7 +64,7 @@ impl<'tcx> EnvVars<'tcx> {\n                                 unsupported\n                             ),\n                     };\n-                    ecx.machine.env_vars.map.insert(OsString::from(name), var_ptr);\n+                    ecx.machine.env_vars.map.insert(name, var_ptr);\n                 }\n             }\n         }\n@@ -210,7 +210,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         name_op: &OpTy<'tcx, Tag>,\n         value_op: &OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, i32> {\n-        let mut this = self.eval_context_mut();\n+        let this = self.eval_context_mut();\n         let target_os = &this.tcx.sess.target.os;\n         assert!(\n             target_os == \"linux\" || target_os == \"macos\",\n@@ -229,7 +229,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n         }\n         if let Some((name, value)) = new {\n-            let var_ptr = alloc_env_var_as_c_str(&name, &value, &mut this)?;\n+            let var_ptr = alloc_env_var_as_c_str(&name, &value, this)?;\n             if let Some(var) = this.machine.env_vars.map.insert(name, var_ptr) {\n                 this.deallocate_ptr(var, None, MiriMemoryKind::Runtime.into())?;\n             }\n@@ -249,7 +249,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         name_op: &OpTy<'tcx, Tag>,  // LPCWSTR\n         value_op: &OpTy<'tcx, Tag>, // LPCWSTR\n     ) -> InterpResult<'tcx, i32> {\n-        let mut this = self.eval_context_mut();\n+        let this = self.eval_context_mut();\n         this.assert_target_os(\"windows\", \"SetEnvironmentVariableW\");\n \n         let name_ptr = this.read_pointer(name_op)?;\n@@ -274,7 +274,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             Ok(1) // return non-zero on success\n         } else {\n             let value = this.read_os_str_from_wide_str(value_ptr)?;\n-            let var_ptr = alloc_env_var_as_wide_str(&name, &value, &mut this)?;\n+            let var_ptr = alloc_env_var_as_wide_str(&name, &value, this)?;\n             if let Some(var) = this.machine.env_vars.map.insert(name, var_ptr) {\n                 this.deallocate_ptr(var, None, MiriMemoryKind::Runtime.into())?;\n             }\n@@ -325,8 +325,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"`getcwd` is only available for the UNIX target family\"\n         );\n \n-        let buf = this.read_pointer(&buf_op)?;\n-        let size = this.read_scalar(&size_op)?.to_machine_usize(&*this.tcx)?;\n+        let buf = this.read_pointer(buf_op)?;\n+        let size = this.read_scalar(size_op)?.to_machine_usize(&*this.tcx)?;\n \n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n             this.reject_in_isolation(\"`getcwd`\", reject_with)?;"}, {"sha": "9256013fb157f14d60c5720885d66d94dcd87a5c", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9407f8687637716ec57001f174f204c918fe40b/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9407f8687637716ec57001f174f204c918fe40b/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=c9407f8687637716ec57001f174f204c918fe40b", "patch": "@@ -238,7 +238,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let link_name = this\n             .tcx\n             .sess\n-            .first_attr_value_str_by_name(&attrs, sym::link_name)\n+            .first_attr_value_str_by_name(attrs, sym::link_name)\n             .unwrap_or_else(|| this.tcx.item_name(def_id));\n         let tcx = this.tcx.tcx;\n "}, {"sha": "b2c31f1c140b103c53d1b4cf8d054ca8f2a47487", "filename": "src/shims/intrinsics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9407f8687637716ec57001f174f204c918fe40b/src%2Fshims%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9407f8687637716ec57001f174f204c918fe40b/src%2Fshims%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics.rs?ref=c9407f8687637716ec57001f174f204c918fe40b", "patch": "@@ -775,7 +775,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n                 for i in 0..dest_len {\n                     let src_index: u64 = this\n-                        .read_immediate(&this.operand_index(&index, i)?.into())?\n+                        .read_immediate(&this.operand_index(index, i)?)?\n                         .to_scalar()?\n                         .to_u32()?\n                         .into();\n@@ -1192,12 +1192,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         match atomic_op {\n             AtomicOp::Min => {\n                 let old = this.atomic_min_max_scalar(&place, rhs, true, atomic)?;\n-                this.write_immediate(*old, &dest)?; // old value is returned\n+                this.write_immediate(*old, dest)?; // old value is returned\n                 Ok(())\n             }\n             AtomicOp::Max => {\n                 let old = this.atomic_min_max_scalar(&place, rhs, false, atomic)?;\n-                this.write_immediate(*old, &dest)?; // old value is returned\n+                this.write_immediate(*old, dest)?; // old value is returned\n                 Ok(())\n             }\n             AtomicOp::MirOp(op, neg) => {"}, {"sha": "d6669b21a731a8fde8b7e59d5d964bb7d3881b1e", "filename": "src/shims/os_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9407f8687637716ec57001f174f204c918fe40b/src%2Fshims%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9407f8687637716ec57001f174f204c918fe40b/src%2Fshims%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fos_str.rs?ref=c9407f8687637716ec57001f174f204c918fe40b", "patch": "@@ -78,7 +78,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             Ok(OsString::from_wide(&u16_vec[..]))\n         }\n         #[cfg(not(windows))]\n-        pub fn u16vec_to_osstring<'tcx, 'a>(u16_vec: Vec<u16>) -> InterpResult<'tcx, OsString> {\n+        pub fn u16vec_to_osstring<'tcx>(u16_vec: Vec<u16>) -> InterpResult<'tcx, OsString> {\n             let s = String::from_utf16(&u16_vec[..])\n                 .map_err(|_| err_unsup_format!(\"{:?} is not a valid utf-16 string\", u16_vec))?;\n             Ok(s.into())"}, {"sha": "96d3b7c9f891e03d7da39fa584b86d1788fa96f5", "filename": "src/shims/panic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9407f8687637716ec57001f174f204c918fe40b/src%2Fshims%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9407f8687637716ec57001f174f204c918fe40b/src%2Fshims%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fpanic.rs?ref=c9407f8687637716ec57001f174f204c918fe40b", "patch": "@@ -59,7 +59,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         // Jump to the unwind block to begin unwinding.\n         this.unwind_to_block(unwind)?;\n-        return Ok(());\n+        Ok(())\n     }\n \n     /// Handles the `try` intrinsic, the underlying implementation of `std::panicking::try`.\n@@ -112,7 +112,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 Some(CatchUnwindData { catch_fn, data, dest: *dest, ret });\n         }\n \n-        return Ok(());\n+        Ok(())\n     }\n \n     fn handle_stack_pop("}, {"sha": "a63b2ad80c27855687d0b64b3d06db15f802d3ce", "filename": "src/shims/posix/fs.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c9407f8687637716ec57001f174f204c918fe40b/src%2Fshims%2Fposix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9407f8687637716ec57001f174f204c918fe40b/src%2Fshims%2Fposix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Ffs.rs?ref=c9407f8687637716ec57001f174f204c918fe40b", "patch": "@@ -46,12 +46,12 @@ trait FileDescriptor: std::fmt::Debug {\n         _communicate_allowed: bool,\n     ) -> InterpResult<'tcx, io::Result<i32>>;\n \n-    fn dup<'tcx>(&mut self) -> io::Result<Box<dyn FileDescriptor>>;\n+    fn dup(&mut self) -> io::Result<Box<dyn FileDescriptor>>;\n }\n \n impl FileDescriptor for FileHandle {\n     fn as_file_handle<'tcx>(&self) -> InterpResult<'tcx, &FileHandle> {\n-        Ok(&self)\n+        Ok(self)\n     }\n \n     fn read<'tcx>(\n@@ -107,7 +107,7 @@ impl FileDescriptor for FileHandle {\n         }\n     }\n \n-    fn dup<'tcx>(&mut self) -> io::Result<Box<dyn FileDescriptor>> {\n+    fn dup(&mut self) -> io::Result<Box<dyn FileDescriptor>> {\n         let duplicated = self.file.try_clone()?;\n         Ok(Box::new(FileHandle { file: duplicated, writable: self.writable }))\n     }\n@@ -153,7 +153,7 @@ impl FileDescriptor for io::Stdin {\n         throw_unsup_format!(\"stdin cannot be closed\");\n     }\n \n-    fn dup<'tcx>(&mut self) -> io::Result<Box<dyn FileDescriptor>> {\n+    fn dup(&mut self) -> io::Result<Box<dyn FileDescriptor>> {\n         Ok(Box::new(io::stdin()))\n     }\n }\n@@ -203,7 +203,7 @@ impl FileDescriptor for io::Stdout {\n         throw_unsup_format!(\"stdout cannot be closed\");\n     }\n \n-    fn dup<'tcx>(&mut self) -> io::Result<Box<dyn FileDescriptor>> {\n+    fn dup(&mut self) -> io::Result<Box<dyn FileDescriptor>> {\n         Ok(Box::new(io::stdout()))\n     }\n }\n@@ -246,7 +246,7 @@ impl FileDescriptor for io::Stderr {\n         throw_unsup_format!(\"stderr cannot be closed\");\n     }\n \n-    fn dup<'tcx>(&mut self) -> io::Result<Box<dyn FileDescriptor>> {\n+    fn dup(&mut self) -> io::Result<Box<dyn FileDescriptor>> {\n         Ok(Box::new(io::stderr()))\n     }\n }\n@@ -645,13 +645,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                         }\n                     }\n                 }\n-                None => return this.handle_not_found(),\n+                None => this.handle_not_found(),\n             }\n         } else if this.tcx.sess.target.os == \"macos\" && cmd == this.eval_libc_i32(\"F_FULLFSYNC\")? {\n             if let Some(file_descriptor) = this.machine.file_handler.handles.get(&fd) {\n                 // FIXME: Support fullfsync for all FDs\n                 let FileHandle { file, writable } = file_descriptor.as_file_handle()?;\n-                let io_result = maybe_sync_file(&file, *writable, File::sync_all);\n+                let io_result = maybe_sync_file(file, *writable, File::sync_all);\n                 this.try_unwrap_io_result(io_result)\n             } else {\n                 this.handle_not_found()\n@@ -743,7 +743,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         if let Some(file_descriptor) = this.machine.file_handler.handles.get(&fd) {\n             let bytes = this.read_bytes_ptr(buf, Size::from_bytes(count))?;\n             let result =\n-                file_descriptor.write(communicate, &bytes)?.map(|c| i64::try_from(c).unwrap());\n+                file_descriptor.write(communicate, bytes)?.map(|c| i64::try_from(c).unwrap());\n             this.try_unwrap_io_result(result)\n         } else {\n             this.handle_not_found()\n@@ -1168,7 +1168,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         #[cfg(unix)]\n         {\n             use std::os::unix::fs::DirBuilderExt;\n-            builder.mode(mode.into());\n+            builder.mode(mode);\n         }\n \n         let result = builder.create(path).map(|_| 0i32);\n@@ -1491,7 +1491,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         if let Some(file_descriptor) = this.machine.file_handler.handles.get(&fd) {\n             // FIXME: Support fsync for all FDs\n             let FileHandle { file, writable } = file_descriptor.as_file_handle()?;\n-            let io_result = maybe_sync_file(&file, *writable, File::sync_all);\n+            let io_result = maybe_sync_file(file, *writable, File::sync_all);\n             this.try_unwrap_io_result(io_result)\n         } else {\n             this.handle_not_found()\n@@ -1513,7 +1513,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         if let Some(file_descriptor) = this.machine.file_handler.handles.get(&fd) {\n             // FIXME: Support fdatasync for all FDs\n             let FileHandle { file, writable } = file_descriptor.as_file_handle()?;\n-            let io_result = maybe_sync_file(&file, *writable, File::sync_data);\n+            let io_result = maybe_sync_file(file, *writable, File::sync_data);\n             this.try_unwrap_io_result(io_result)\n         } else {\n             this.handle_not_found()\n@@ -1558,7 +1558,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         if let Some(file_descriptor) = this.machine.file_handler.handles.get(&fd) {\n             // FIXME: Support sync_data_range for all FDs\n             let FileHandle { file, writable } = file_descriptor.as_file_handle()?;\n-            let io_result = maybe_sync_file(&file, *writable, File::sync_data);\n+            let io_result = maybe_sync_file(file, *writable, File::sync_data);\n             this.try_unwrap_io_result(io_result)\n         } else {\n             this.handle_not_found()"}, {"sha": "0b8684d39eb215eb59188d3023d8d572280a9a8b", "filename": "src/shims/posix/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9407f8687637716ec57001f174f204c918fe40b/src%2Fshims%2Fposix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9407f8687637716ec57001f174f204c918fe40b/src%2Fshims%2Fposix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fthread.rs?ref=c9407f8687637716ec57001f174f204c918fe40b", "patch": "@@ -99,7 +99,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n         this.assert_target_os(\"linux\", \"prctl\");\n \n-        if args.len() < 1 {\n+        if args.is_empty() {\n             throw_ub_format!(\n                 \"incorrect number of arguments for `prctl`: got {}, expected at least 1\",\n                 args.len()"}, {"sha": "3de739a8d048bece43c6b2edffef50413eac422a", "filename": "src/shims/tls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9407f8687637716ec57001f174f204c918fe40b/src%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9407f8687637716ec57001f174f204c918fe40b/src%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftls.rs?ref=c9407f8687637716ec57001f174f204c918fe40b", "patch": "@@ -99,7 +99,7 @@ impl<'tcx> TlsData<'tcx> {\n             Some(TlsEntry { data, .. }) => {\n                 let value = data.get(&thread_id).copied();\n                 trace!(\"TLS key {} for thread {:?} loaded: {:?}\", key, thread_id, value);\n-                Ok(value.unwrap_or_else(|| Scalar::null_ptr(cx).into()))\n+                Ok(value.unwrap_or_else(|| Scalar::null_ptr(cx)))\n             }\n             None => throw_ub_format!(\"loading from a non-existing TLS key: {}\", key),\n         }\n@@ -304,7 +304,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         assert!(this.has_terminated(active_thread), \"running TLS dtors for non-terminated thread\");\n         // Fetch next dtor after `key`.\n-        let last_key = this.machine.tls.dtors_running[&active_thread].last_dtor_key.clone();\n+        let last_key = this.machine.tls.dtors_running[&active_thread].last_dtor_key;\n         let dtor = match this.machine.tls.fetch_tls_dtor(last_key, active_thread) {\n             dtor @ Some(_) => dtor,\n             // We ran each dtor once, start over from the beginning."}, {"sha": "d6caba81713cfa64429b0d04b4879615c5be4554", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9407f8687637716ec57001f174f204c918fe40b/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9407f8687637716ec57001f174f204c918fe40b/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=c9407f8687637716ec57001f174f204c918fe40b", "patch": "@@ -314,7 +314,7 @@ impl<'tcx> Stack {\n         if let SbTag::Tagged(id) = item.tag {\n             if global.tracked_pointer_tags.contains(&id) {\n                 register_diagnostic(NonHaltingDiagnostic::PoppedPointerTag(\n-                    item.clone(),\n+                    *item,\n                     provoking_access,\n                 ));\n             }"}, {"sha": "ac1687a22e305e2e2c5223cbad4f048ddaed698e", "filename": "src/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9407f8687637716ec57001f174f204c918fe40b/src%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9407f8687637716ec57001f174f204c918fe40b/src%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsync.rs?ref=c9407f8687637716ec57001f174f204c918fe40b", "patch": "@@ -474,7 +474,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n         condvar.waiters.pop_front().map(|waiter| {\n             if let Some(data_race) = data_race {\n-                data_race.validate_lock_acquire(&mut condvar.data_race, waiter.thread);\n+                data_race.validate_lock_acquire(&condvar.data_race, waiter.thread);\n             }\n             (waiter.thread, waiter.mutex)\n         })"}, {"sha": "8edd6672a7478e635fc827b02aa39352df41c7bc", "filename": "src/thread.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c9407f8687637716ec57001f174f204c918fe40b/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9407f8687637716ec57001f174f204c918fe40b/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=c9407f8687637716ec57001f174f204c918fe40b", "patch": "@@ -58,7 +58,7 @@ impl Idx for ThreadId {\n impl TryFrom<u64> for ThreadId {\n     type Error = TryFromIntError;\n     fn try_from(id: u64) -> Result<Self, Self::Error> {\n-        u32::try_from(id).map(|id_u32| Self(id_u32))\n+        u32::try_from(id).map(Self)\n     }\n }\n \n@@ -69,8 +69,8 @@ impl From<u32> for ThreadId {\n }\n \n impl ThreadId {\n-    pub fn to_u32_scalar<'tcx>(&self) -> Scalar<Tag> {\n-        Scalar::from_u32(u32::try_from(self.0).unwrap())\n+    pub fn to_u32_scalar(&self) -> Scalar<Tag> {\n+        Scalar::from_u32(self.0)\n     }\n }\n \n@@ -235,7 +235,7 @@ impl<'mir, 'tcx> Default for ThreadManager<'mir, 'tcx> {\n         threads.push(main_thread);\n         Self {\n             active_thread: ThreadId::new(0),\n-            threads: threads,\n+            threads,\n             sync: SynchronizationState::default(),\n             thread_local_alloc_ids: Default::default(),\n             yield_active_thread: false,\n@@ -456,7 +456,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n                 // Delete this static from the map and from memory.\n                 // We cannot free directly here as we cannot use `?` in this context.\n                 free_tls_statics.push(alloc_id);\n-                return false;\n+                false\n             });\n         }\n         // Set the thread into a terminated state in the data-race detector\n@@ -474,7 +474,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n                 thread.state = ThreadState::Enabled;\n             }\n         }\n-        return free_tls_statics;\n+        free_tls_statics\n     }\n \n     /// Decide which action to take next and on which thread."}]}