{"sha": "c7125ba0fa4e9abe826f004a023c0bf3678a8963", "node_id": "C_kwDOAAsO6NoAKGM3MTI1YmEwZmE0ZTlhYmU4MjZmMDA0YTAyM2MwYmYzNjc4YTg5NjM", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-01-04T15:34:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-04T15:34:14Z"}, "message": "Rollup merge of #91884 - woppopo:const_box, r=oli-obk\n\nConstify `Box<T, A>` methods\n\nTracking issue: none yet\n\nMost of the methods bounded on `~const`. `intrinsics::const_eval_select` is used for handling an allocation error.\n\n<details><summary>Constified API</summary>\n\n```rust\nimpl<T, A: Allocator> Box<T, A> {\n    pub const fn new_in(x: T, alloc: A) -> Self\n    where\n        A: ~const Allocator + ~const Drop;\n    pub const fn try_new_in(x: T, alloc: A) -> Result<Self, AllocError>\n    where\n        T: ~const Drop,\n        A: ~const Allocator + ~const Drop;\n    pub const fn new_uninit_in(alloc: A) -> Box<mem::MaybeUninit<T>, A>\n    where\n        A: ~const Allocator + ~const Drop;\n    pub const fn try_new_uninit_in(alloc: A) -> Result<Box<mem::MaybeUninit<T>, A>, AllocError>\n    where\n        A: ~const Allocator + ~const Drop;\n    pub const fn new_zeroed_in(alloc: A) -> Box<mem::MaybeUninit<T>, A>\n    where\n        A: ~const Allocator + ~const Drop;\n    pub const fn try_new_zeroed_in(alloc: A) -> Result<Box<mem::MaybeUninit<T>, A>, AllocError>\n    where\n        A: ~const Allocator + ~const Drop;\n    pub const fn pin_in(x: T, alloc: A) -> Pin<Self>\n    where\n        A: 'static,\n        A: 'static + ~const Allocator + ~const Drop,\n    pub const fn into_boxed_slice(boxed: Self) -> Box<[T], A>;\n    pub const fn into_inner(boxed: Self) -> T\n    where\n        Self: ~const Drop,\n}\n\nimpl<T, A: Allocator> Box<MaybeUninit<T>, A> {\n    pub const unsafe fn assume_init(self) -> Box<T, A>;\n    pub const fn write(mut boxed: Self, value: T) -> Box<T, A>;\n    pub const unsafe fn from_raw_in(raw: *mut T, alloc: A) -> Self;\n    pub const fn into_raw_with_allocator(b: Self) -> (*mut T, A);\n    pub const fn into_unique(b: Self) -> (Unique<T>, A);\n    pub const fn allocator(b: &Self) -> &A;\n    pub const fn leak<'a>(b: Self) -> &'a mut T\n    where\n        A: 'a;\n    pub const fn into_pin(boxed: Self) -> Pin<Self>\n    where\n        A: 'static;\n}\n\nunsafe impl<#[may_dangle] T: ?Sized, A: Allocator> const Drop for Box<T, A>;\nimpl<T: ?Sized, A: Allocator> const From<Box<T, A>> for Pin<Box<T, A>>\nwhere\n    A: 'static;\nimpl<T: ?Sized, A: Allocator> const Deref for Box<T, A>;\nimpl<T: ?Sized, A: Allocator> const DerefMut for Box<T, A>;\nimpl<T: ?Sized, A: Allocator> const Unpin for Box<T, A> where A: 'static;\n```\n\n</details>\n\n<details><summary>Example</summary>\n\n```rust\npub struct ConstAllocator;\n\nunsafe impl const Allocator for ConstAllocator {\n    fn allocate(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n        unsafe {\n            let ptr = core::intrinsics::const_allocate(layout.size(), layout.align());\n            Ok(NonNull::new_unchecked(ptr as *mut [u8; 0] as *mut [u8]))\n        }\n    }\n\n    unsafe fn deallocate(&self, _ptr: NonNull<u8>, _layout: Layout) {\n        /* do nothing */\n    }\n\n    fn allocate_zeroed(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n        self.allocate(layout)\n    }\n\n    unsafe fn grow(\n        &self,\n        _ptr: NonNull<u8>,\n        _old_layout: Layout,\n        _new_layout: Layout,\n    ) -> Result<NonNull<[u8]>, AllocError> {\n        unimplemented!()\n    }\n\n    unsafe fn grow_zeroed(\n        &self,\n        _ptr: NonNull<u8>,\n        _old_layout: Layout,\n        _new_layout: Layout,\n    ) -> Result<NonNull<[u8]>, AllocError> {\n        unimplemented!()\n    }\n\n    unsafe fn shrink(\n        &self,\n        _ptr: NonNull<u8>,\n        _old_layout: Layout,\n        _new_layout: Layout,\n    ) -> Result<NonNull<[u8]>, AllocError> {\n        unimplemented!()\n    }\n\n    fn by_ref(&self) -> &Self\n    where\n        Self: Sized,\n    {\n        self\n    }\n}\n\n#[test]\nfn const_box() {\n    const VALUE: u32 = {\n        let mut boxed = Box::new_in(1u32, ConstAllocator);\n        assert!(*boxed == 1);\n\n        *boxed = 42;\n        assert!(*boxed == 42);\n\n        *boxed\n    };\n\n    assert!(VALUE == 42);\n}\n```\n\n</details>", "tree": {"sha": "5e8f67865ea68ec8a9ca08deb3e81c91bab6894a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e8f67865ea68ec8a9ca08deb3e81c91bab6894a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7125ba0fa4e9abe826f004a023c0bf3678a8963", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh1Gj3CRBK7hj4Ov3rIwAADpsIAHWcJDz5ER05NTkENIxj9gfG\nOkd9O6meLKpHyl8jkL4pr70EFQkS9jTyaO6fp4Oo06iDLLwBviCHNnnjqAfxe9dH\n1Ey2Ee0QwI56Kldv2oWhCe1n1d1kzVR8XlHxPZ6f+KB5UZLRlqlgF9qxIuglUl1g\nX8So1VAo7eJvKgVxsOPD2uwdcYAORV7wqk/sTEJOUoJvP81hpKwxZZn9pjEk/wg4\n5DltnuCZW4ZLjstRAes7e4QAKzu1pn45jH2al7IPwS9gkD4adyVnVJ1JWzO7vIly\nATd+TxshlofTPaj4NH6o8pc3KwnjJZjzJZXsgJxHQo3Yn6knM/V1hsqoidDatrI=\n=nxJG\n-----END PGP SIGNATURE-----\n", "payload": "tree 5e8f67865ea68ec8a9ca08deb3e81c91bab6894a\nparent 50a66b75dcfb69fd23b1dca441d756f31d0b483f\nparent 51e4291f2b3c63e62a61855d162c7dd700fcb44b\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1641310454 +0100\ncommitter GitHub <noreply@github.com> 1641310454 +0100\n\nRollup merge of #91884 - woppopo:const_box, r=oli-obk\n\nConstify `Box<T, A>` methods\n\nTracking issue: none yet\n\nMost of the methods bounded on `~const`. `intrinsics::const_eval_select` is used for handling an allocation error.\n\n<details><summary>Constified API</summary>\n\n```rust\nimpl<T, A: Allocator> Box<T, A> {\n    pub const fn new_in(x: T, alloc: A) -> Self\n    where\n        A: ~const Allocator + ~const Drop;\n    pub const fn try_new_in(x: T, alloc: A) -> Result<Self, AllocError>\n    where\n        T: ~const Drop,\n        A: ~const Allocator + ~const Drop;\n    pub const fn new_uninit_in(alloc: A) -> Box<mem::MaybeUninit<T>, A>\n    where\n        A: ~const Allocator + ~const Drop;\n    pub const fn try_new_uninit_in(alloc: A) -> Result<Box<mem::MaybeUninit<T>, A>, AllocError>\n    where\n        A: ~const Allocator + ~const Drop;\n    pub const fn new_zeroed_in(alloc: A) -> Box<mem::MaybeUninit<T>, A>\n    where\n        A: ~const Allocator + ~const Drop;\n    pub const fn try_new_zeroed_in(alloc: A) -> Result<Box<mem::MaybeUninit<T>, A>, AllocError>\n    where\n        A: ~const Allocator + ~const Drop;\n    pub const fn pin_in(x: T, alloc: A) -> Pin<Self>\n    where\n        A: 'static,\n        A: 'static + ~const Allocator + ~const Drop,\n    pub const fn into_boxed_slice(boxed: Self) -> Box<[T], A>;\n    pub const fn into_inner(boxed: Self) -> T\n    where\n        Self: ~const Drop,\n}\n\nimpl<T, A: Allocator> Box<MaybeUninit<T>, A> {\n    pub const unsafe fn assume_init(self) -> Box<T, A>;\n    pub const fn write(mut boxed: Self, value: T) -> Box<T, A>;\n    pub const unsafe fn from_raw_in(raw: *mut T, alloc: A) -> Self;\n    pub const fn into_raw_with_allocator(b: Self) -> (*mut T, A);\n    pub const fn into_unique(b: Self) -> (Unique<T>, A);\n    pub const fn allocator(b: &Self) -> &A;\n    pub const fn leak<'a>(b: Self) -> &'a mut T\n    where\n        A: 'a;\n    pub const fn into_pin(boxed: Self) -> Pin<Self>\n    where\n        A: 'static;\n}\n\nunsafe impl<#[may_dangle] T: ?Sized, A: Allocator> const Drop for Box<T, A>;\nimpl<T: ?Sized, A: Allocator> const From<Box<T, A>> for Pin<Box<T, A>>\nwhere\n    A: 'static;\nimpl<T: ?Sized, A: Allocator> const Deref for Box<T, A>;\nimpl<T: ?Sized, A: Allocator> const DerefMut for Box<T, A>;\nimpl<T: ?Sized, A: Allocator> const Unpin for Box<T, A> where A: 'static;\n```\n\n</details>\n\n<details><summary>Example</summary>\n\n```rust\npub struct ConstAllocator;\n\nunsafe impl const Allocator for ConstAllocator {\n    fn allocate(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n        unsafe {\n            let ptr = core::intrinsics::const_allocate(layout.size(), layout.align());\n            Ok(NonNull::new_unchecked(ptr as *mut [u8; 0] as *mut [u8]))\n        }\n    }\n\n    unsafe fn deallocate(&self, _ptr: NonNull<u8>, _layout: Layout) {\n        /* do nothing */\n    }\n\n    fn allocate_zeroed(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n        self.allocate(layout)\n    }\n\n    unsafe fn grow(\n        &self,\n        _ptr: NonNull<u8>,\n        _old_layout: Layout,\n        _new_layout: Layout,\n    ) -> Result<NonNull<[u8]>, AllocError> {\n        unimplemented!()\n    }\n\n    unsafe fn grow_zeroed(\n        &self,\n        _ptr: NonNull<u8>,\n        _old_layout: Layout,\n        _new_layout: Layout,\n    ) -> Result<NonNull<[u8]>, AllocError> {\n        unimplemented!()\n    }\n\n    unsafe fn shrink(\n        &self,\n        _ptr: NonNull<u8>,\n        _old_layout: Layout,\n        _new_layout: Layout,\n    ) -> Result<NonNull<[u8]>, AllocError> {\n        unimplemented!()\n    }\n\n    fn by_ref(&self) -> &Self\n    where\n        Self: Sized,\n    {\n        self\n    }\n}\n\n#[test]\nfn const_box() {\n    const VALUE: u32 = {\n        let mut boxed = Box::new_in(1u32, ConstAllocator);\n        assert!(*boxed == 1);\n\n        *boxed = 42;\n        assert!(*boxed == 42);\n\n        *boxed\n    };\n\n    assert!(VALUE == 42);\n}\n```\n\n</details>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7125ba0fa4e9abe826f004a023c0bf3678a8963", "html_url": "https://github.com/rust-lang/rust/commit/c7125ba0fa4e9abe826f004a023c0bf3678a8963", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7125ba0fa4e9abe826f004a023c0bf3678a8963/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50a66b75dcfb69fd23b1dca441d756f31d0b483f", "url": "https://api.github.com/repos/rust-lang/rust/commits/50a66b75dcfb69fd23b1dca441d756f31d0b483f", "html_url": "https://github.com/rust-lang/rust/commit/50a66b75dcfb69fd23b1dca441d756f31d0b483f"}, {"sha": "51e4291f2b3c63e62a61855d162c7dd700fcb44b", "url": "https://api.github.com/repos/rust-lang/rust/commits/51e4291f2b3c63e62a61855d162c7dd700fcb44b", "html_url": "https://github.com/rust-lang/rust/commit/51e4291f2b3c63e62a61855d162c7dd700fcb44b"}], "stats": {"total": 257, "additions": 225, "deletions": 32}, "files": [{"sha": "d075658f51a3e7b3fb7c46df8619787e77b6b68b", "filename": "library/alloc/src/alloc.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c7125ba0fa4e9abe826f004a023c0bf3678a8963/library%2Falloc%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7125ba0fa4e9abe826f004a023c0bf3678a8963/library%2Falloc%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc.rs?ref=c7125ba0fa4e9abe826f004a023c0bf3678a8963", "patch": "@@ -323,17 +323,21 @@ unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n \n #[cfg_attr(not(test), lang = \"box_free\")]\n #[inline]\n+#[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n // This signature has to be the same as `Box`, otherwise an ICE will happen.\n // When an additional parameter to `Box` is added (like `A: Allocator`), this has to be added here as\n // well.\n // For example if `Box` is changed to  `struct Box<T: ?Sized, A: Allocator>(Unique<T>, A)`,\n // this function has to be changed to `fn box_free<T: ?Sized, A: Allocator>(Unique<T>, A)` as well.\n-pub(crate) unsafe fn box_free<T: ?Sized, A: Allocator>(ptr: Unique<T>, alloc: A) {\n+pub(crate) const unsafe fn box_free<T: ?Sized, A: ~const Allocator + ~const Drop>(\n+    ptr: Unique<T>,\n+    alloc: A,\n+) {\n     unsafe {\n         let size = size_of_val(ptr.as_ref());\n         let align = min_align_of_val(ptr.as_ref());\n         let layout = Layout::from_size_align_unchecked(size, align);\n-        alloc.deallocate(ptr.cast().into(), layout)\n+        alloc.deallocate(From::from(ptr.cast()), layout)\n     }\n }\n \n@@ -361,13 +365,22 @@ extern \"Rust\" {\n /// [`set_alloc_error_hook`]: ../../std/alloc/fn.set_alloc_error_hook.html\n /// [`take_alloc_error_hook`]: ../../std/alloc/fn.take_alloc_error_hook.html\n #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n+#[rustc_const_unstable(feature = \"const_alloc_error\", issue = \"92523\")]\n #[cfg(all(not(no_global_oom_handling), not(test)))]\n #[rustc_allocator_nounwind]\n #[cold]\n-pub fn handle_alloc_error(layout: Layout) -> ! {\n-    unsafe {\n-        __rust_alloc_error_handler(layout.size(), layout.align());\n+pub const fn handle_alloc_error(layout: Layout) -> ! {\n+    const fn ct_error(_: Layout) -> ! {\n+        panic!(\"allocation failed\");\n     }\n+\n+    fn rt_error(layout: Layout) -> ! {\n+        unsafe {\n+            __rust_alloc_error_handler(layout.size(), layout.align());\n+        }\n+    }\n+\n+    unsafe { core::intrinsics::const_eval_select((layout,), ct_error, rt_error) }\n }\n \n // For alloc test `std::alloc::handle_alloc_error` can be used directly."}, {"sha": "aa7344ba405a988c31598701bcf7759940ea1e2f", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 68, "deletions": 24, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/c7125ba0fa4e9abe826f004a023c0bf3678a8963/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7125ba0fa4e9abe826f004a023c0bf3678a8963/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=c7125ba0fa4e9abe826f004a023c0bf3678a8963", "patch": "@@ -346,9 +346,13 @@ impl<T, A: Allocator> Box<T, A> {\n     /// ```\n     #[cfg(not(no_global_oom_handling))]\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n     #[must_use]\n     #[inline]\n-    pub fn new_in(x: T, alloc: A) -> Self {\n+    pub const fn new_in(x: T, alloc: A) -> Self\n+    where\n+        A: ~const Allocator + ~const Drop,\n+    {\n         let mut boxed = Self::new_uninit_in(alloc);\n         unsafe {\n             boxed.as_mut_ptr().write(x);\n@@ -372,8 +376,13 @@ impl<T, A: Allocator> Box<T, A> {\n     /// # Ok::<(), std::alloc::AllocError>(())\n     /// ```\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n     #[inline]\n-    pub fn try_new_in(x: T, alloc: A) -> Result<Self, AllocError> {\n+    pub const fn try_new_in(x: T, alloc: A) -> Result<Self, AllocError>\n+    where\n+        T: ~const Drop,\n+        A: ~const Allocator + ~const Drop,\n+    {\n         let mut boxed = Self::try_new_uninit_in(alloc)?;\n         unsafe {\n             boxed.as_mut_ptr().write(x);\n@@ -402,10 +411,14 @@ impl<T, A: Allocator> Box<T, A> {\n     /// assert_eq!(*five, 5)\n     /// ```\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n     #[cfg(not(no_global_oom_handling))]\n     #[must_use]\n     // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n-    pub fn new_uninit_in(alloc: A) -> Box<mem::MaybeUninit<T>, A> {\n+    pub const fn new_uninit_in(alloc: A) -> Box<mem::MaybeUninit<T>, A>\n+    where\n+        A: ~const Allocator + ~const Drop,\n+    {\n         let layout = Layout::new::<mem::MaybeUninit<T>>();\n         // NOTE: Prefer match over unwrap_or_else since closure sometimes not inlineable.\n         // That would make code size bigger.\n@@ -439,7 +452,11 @@ impl<T, A: Allocator> Box<T, A> {\n     /// ```\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n-    pub fn try_new_uninit_in(alloc: A) -> Result<Box<mem::MaybeUninit<T>, A>, AllocError> {\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n+    pub const fn try_new_uninit_in(alloc: A) -> Result<Box<mem::MaybeUninit<T>, A>, AllocError>\n+    where\n+        A: ~const Allocator + ~const Drop,\n+    {\n         let layout = Layout::new::<mem::MaybeUninit<T>>();\n         let ptr = alloc.allocate(layout)?.cast();\n         unsafe { Ok(Box::from_raw_in(ptr.as_ptr(), alloc)) }\n@@ -466,10 +483,14 @@ impl<T, A: Allocator> Box<T, A> {\n     ///\n     /// [zeroed]: mem::MaybeUninit::zeroed\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n     #[cfg(not(no_global_oom_handling))]\n     // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     #[must_use]\n-    pub fn new_zeroed_in(alloc: A) -> Box<mem::MaybeUninit<T>, A> {\n+    pub const fn new_zeroed_in(alloc: A) -> Box<mem::MaybeUninit<T>, A>\n+    where\n+        A: ~const Allocator + ~const Drop,\n+    {\n         let layout = Layout::new::<mem::MaybeUninit<T>>();\n         // NOTE: Prefer match over unwrap_or_else since closure sometimes not inlineable.\n         // That would make code size bigger.\n@@ -503,7 +524,11 @@ impl<T, A: Allocator> Box<T, A> {\n     /// [zeroed]: mem::MaybeUninit::zeroed\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n-    pub fn try_new_zeroed_in(alloc: A) -> Result<Box<mem::MaybeUninit<T>, A>, AllocError> {\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n+    pub const fn try_new_zeroed_in(alloc: A) -> Result<Box<mem::MaybeUninit<T>, A>, AllocError>\n+    where\n+        A: ~const Allocator + ~const Drop,\n+    {\n         let layout = Layout::new::<mem::MaybeUninit<T>>();\n         let ptr = alloc.allocate_zeroed(layout)?.cast();\n         unsafe { Ok(Box::from_raw_in(ptr.as_ptr(), alloc)) }\n@@ -513,20 +538,22 @@ impl<T, A: Allocator> Box<T, A> {\n     /// `x` will be pinned in memory and unable to be moved.\n     #[cfg(not(no_global_oom_handling))]\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n     #[must_use]\n     #[inline(always)]\n-    pub fn pin_in(x: T, alloc: A) -> Pin<Self>\n+    pub const fn pin_in(x: T, alloc: A) -> Pin<Self>\n     where\n-        A: 'static,\n+        A: 'static + ~const Allocator + ~const Drop,\n     {\n-        Self::new_in(x, alloc).into()\n+        Self::into_pin(Self::new_in(x, alloc))\n     }\n \n     /// Converts a `Box<T>` into a `Box<[T]>`\n     ///\n     /// This conversion does not allocate on the heap and happens in place.\n     #[unstable(feature = \"box_into_boxed_slice\", issue = \"71582\")]\n-    pub fn into_boxed_slice(boxed: Self) -> Box<[T], A> {\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n+    pub const fn into_boxed_slice(boxed: Self) -> Box<[T], A> {\n         let (raw, alloc) = Box::into_raw_with_allocator(boxed);\n         unsafe { Box::from_raw_in(raw as *mut [T; 1], alloc) }\n     }\n@@ -543,8 +570,12 @@ impl<T, A: Allocator> Box<T, A> {\n     /// assert_eq!(Box::into_inner(c), 5);\n     /// ```\n     #[unstable(feature = \"box_into_inner\", issue = \"80437\")]\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n     #[inline]\n-    pub fn into_inner(boxed: Self) -> T {\n+    pub const fn into_inner(boxed: Self) -> T\n+    where\n+        Self: ~const Drop,\n+    {\n         *boxed\n     }\n }\n@@ -758,8 +789,9 @@ impl<T, A: Allocator> Box<mem::MaybeUninit<T>, A> {\n     /// assert_eq!(*five, 5)\n     /// ```\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n     #[inline]\n-    pub unsafe fn assume_init(self) -> Box<T, A> {\n+    pub const unsafe fn assume_init(self) -> Box<T, A> {\n         let (raw, alloc) = Box::into_raw_with_allocator(self);\n         unsafe { Box::from_raw_in(raw as *mut T, alloc) }\n     }\n@@ -792,8 +824,9 @@ impl<T, A: Allocator> Box<mem::MaybeUninit<T>, A> {\n     /// }\n     /// ```\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n     #[inline]\n-    pub fn write(mut boxed: Self, value: T) -> Box<T, A> {\n+    pub const fn write(mut boxed: Self, value: T) -> Box<T, A> {\n         unsafe {\n             (*boxed).write(value);\n             boxed.assume_init()\n@@ -938,8 +971,9 @@ impl<T: ?Sized, A: Allocator> Box<T, A> {\n     /// [memory layout]: self#memory-layout\n     /// [`Layout`]: crate::Layout\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n     #[inline]\n-    pub unsafe fn from_raw_in(raw: *mut T, alloc: A) -> Self {\n+    pub const unsafe fn from_raw_in(raw: *mut T, alloc: A) -> Self {\n         Box(unsafe { Unique::new_unchecked(raw) }, alloc)\n     }\n \n@@ -1035,8 +1069,9 @@ impl<T: ?Sized, A: Allocator> Box<T, A> {\n     ///\n     /// [memory layout]: self#memory-layout\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n     #[inline]\n-    pub fn into_raw_with_allocator(b: Self) -> (*mut T, A) {\n+    pub const fn into_raw_with_allocator(b: Self) -> (*mut T, A) {\n         let (leaked, alloc) = Box::into_unique(b);\n         (leaked.as_ptr(), alloc)\n     }\n@@ -1046,9 +1081,10 @@ impl<T: ?Sized, A: Allocator> Box<T, A> {\n         issue = \"none\",\n         reason = \"use `Box::leak(b).into()` or `Unique::from(Box::leak(b))` instead\"\n     )]\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n     #[inline]\n     #[doc(hidden)]\n-    pub fn into_unique(b: Self) -> (Unique<T>, A) {\n+    pub const fn into_unique(b: Self) -> (Unique<T>, A) {\n         // Box is recognized as a \"unique pointer\" by Stacked Borrows, but internally it is a\n         // raw pointer for the type system. Turning it directly into a raw pointer would not be\n         // recognized as \"releasing\" the unique pointer to permit aliased raw accesses,\n@@ -1064,8 +1100,9 @@ impl<T: ?Sized, A: Allocator> Box<T, A> {\n     /// to call it as `Box::allocator(&b)` instead of `b.allocator()`. This\n     /// is so that there is no conflict with a method on the inner type.\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n     #[inline]\n-    pub fn allocator(b: &Self) -> &A {\n+    pub const fn allocator(b: &Self) -> &A {\n         &b.1\n     }\n \n@@ -1105,8 +1142,9 @@ impl<T: ?Sized, A: Allocator> Box<T, A> {\n     /// assert_eq!(*static_ref, [4, 2, 3]);\n     /// ```\n     #[stable(feature = \"box_leak\", since = \"1.26.0\")]\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n     #[inline]\n-    pub fn leak<'a>(b: Self) -> &'a mut T\n+    pub const fn leak<'a>(b: Self) -> &'a mut T\n     where\n         A: 'a,\n     {\n@@ -1119,7 +1157,8 @@ impl<T: ?Sized, A: Allocator> Box<T, A> {\n     ///\n     /// This is also available via [`From`].\n     #[unstable(feature = \"box_into_pin\", issue = \"62370\")]\n-    pub fn into_pin(boxed: Self) -> Pin<Self>\n+    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n+    pub const fn into_pin(boxed: Self) -> Pin<Self>\n     where\n         A: 'static,\n     {\n@@ -1131,7 +1170,8 @@ impl<T: ?Sized, A: Allocator> Box<T, A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<#[may_dangle] T: ?Sized, A: Allocator> Drop for Box<T, A> {\n+#[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n+unsafe impl<#[may_dangle] T: ?Sized, A: Allocator> const Drop for Box<T, A> {\n     fn drop(&mut self) {\n         // FIXME: Do nothing, drop is currently performed by compiler.\n     }\n@@ -1341,7 +1381,8 @@ impl<T> From<T> for Box<T> {\n }\n \n #[stable(feature = \"pin\", since = \"1.33.0\")]\n-impl<T: ?Sized, A: Allocator> From<Box<T, A>> for Pin<Box<T, A>>\n+#[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n+impl<T: ?Sized, A: Allocator> const From<Box<T, A>> for Pin<Box<T, A>>\n where\n     A: 'static,\n {\n@@ -1720,7 +1761,8 @@ impl<T: ?Sized, A: Allocator> fmt::Pointer for Box<T, A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized, A: Allocator> Deref for Box<T, A> {\n+#[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n+impl<T: ?Sized, A: Allocator> const Deref for Box<T, A> {\n     type Target = T;\n \n     fn deref(&self) -> &T {\n@@ -1729,7 +1771,8 @@ impl<T: ?Sized, A: Allocator> Deref for Box<T, A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized, A: Allocator> DerefMut for Box<T, A> {\n+#[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n+impl<T: ?Sized, A: Allocator> const DerefMut for Box<T, A> {\n     fn deref_mut(&mut self) -> &mut T {\n         &mut **self\n     }\n@@ -1908,7 +1951,8 @@ impl<T: ?Sized, A: Allocator> AsMut<T> for Box<T, A> {\n  *  could have a method to project a Pin<T> from it.\n  */\n #[stable(feature = \"pin\", since = \"1.33.0\")]\n-impl<T: ?Sized, A: Allocator> Unpin for Box<T, A> where A: 'static {}\n+#[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n+impl<T: ?Sized, A: Allocator> const Unpin for Box<T, A> where A: 'static {}\n \n #[unstable(feature = \"generator_trait\", issue = \"43122\")]\n impl<G: ?Sized + Generator<R> + Unpin, R, A: Allocator> Generator<R> for Box<G, A>"}, {"sha": "7e663fab16af544dbbffdbe8e9c17a41560715db", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c7125ba0fa4e9abe826f004a023c0bf3678a8963/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7125ba0fa4e9abe826f004a023c0bf3678a8963/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=c7125ba0fa4e9abe826f004a023c0bf3678a8963", "patch": "@@ -96,9 +96,20 @@\n #![feature(array_windows)]\n #![feature(async_stream)]\n #![feature(coerce_unsized)]\n+#![cfg_attr(not(no_global_oom_handling), feature(const_alloc_error))]\n+#![feature(const_box)]\n #![cfg_attr(not(no_global_oom_handling), feature(const_btree_new))]\n #![feature(const_cow_is_borrowed)]\n+#![feature(const_convert)]\n+#![feature(const_size_of_val)]\n+#![feature(const_align_of_val)]\n+#![feature(const_ptr_read)]\n+#![feature(const_maybe_uninit_write)]\n+#![feature(const_maybe_uninit_as_mut_ptr)]\n+#![feature(const_refs_to_cell)]\n #![feature(core_intrinsics)]\n+#![feature(const_eval_select)]\n+#![feature(const_pin)]\n #![feature(dispatch_from_dyn)]\n #![feature(exact_size_is_empty)]\n #![feature(extend_one)]\n@@ -134,8 +145,13 @@\n #![feature(box_syntax)]\n #![feature(cfg_sanitize)]\n #![feature(cfg_target_has_atomic)]\n+#![feature(const_deref)]\n #![feature(const_fn_trait_bound)]\n+#![feature(const_mut_refs)]\n+#![feature(const_ptr_write)]\n+#![feature(const_precise_live_drops)]\n #![feature(const_trait_impl)]\n+#![feature(const_try)]\n #![cfg_attr(bootstrap, feature(destructuring_assignment))]\n #![feature(dropck_eyepatch)]\n #![feature(exclusive_range_pattern)]"}, {"sha": "0d7acfed8c6a1b36f0354714fa375f9de8efd9b4", "filename": "library/alloc/tests/boxed.rs", "status": "modified", "additions": 111, "deletions": 3, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/c7125ba0fa4e9abe826f004a023c0bf3678a8963/library%2Falloc%2Ftests%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7125ba0fa4e9abe826f004a023c0bf3678a8963/library%2Falloc%2Ftests%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fboxed.rs?ref=c7125ba0fa4e9abe826f004a023c0bf3678a8963", "patch": "@@ -1,6 +1,7 @@\n-use std::cell::Cell;\n-use std::mem::MaybeUninit;\n-use std::ptr::NonNull;\n+use core::alloc::{AllocError, Allocator, Layout};\n+use core::cell::Cell;\n+use core::mem::MaybeUninit;\n+use core::ptr::NonNull;\n \n #[test]\n fn uninitialized_zero_size_box() {\n@@ -57,3 +58,110 @@ fn box_deref_lval() {\n     x.set(1000);\n     assert_eq!(x.get(), 1000);\n }\n+\n+pub struct ConstAllocator;\n+\n+unsafe impl const Allocator for ConstAllocator {\n+    fn allocate(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n+        match layout.size() {\n+            0 => Ok(NonNull::slice_from_raw_parts(layout.dangling(), 0)),\n+            _ => unsafe {\n+                let ptr = core::intrinsics::const_allocate(layout.size(), layout.align());\n+                Ok(NonNull::new_unchecked(ptr as *mut [u8; 0] as *mut [u8]))\n+            },\n+        }\n+    }\n+\n+    unsafe fn deallocate(&self, _ptr: NonNull<u8>, layout: Layout) {\n+        match layout.size() {\n+            0 => { /* do nothing */ }\n+            _ => { /* do nothing too */ }\n+        }\n+    }\n+\n+    fn allocate_zeroed(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n+        let ptr = self.allocate(layout)?;\n+        if layout.size() > 0 {\n+            unsafe {\n+                ptr.as_mut_ptr().write_bytes(0, layout.size());\n+            }\n+        }\n+        Ok(ptr)\n+    }\n+\n+    unsafe fn grow(\n+        &self,\n+        ptr: NonNull<u8>,\n+        old_layout: Layout,\n+        new_layout: Layout,\n+    ) -> Result<NonNull<[u8]>, AllocError> {\n+        debug_assert!(\n+            new_layout.size() >= old_layout.size(),\n+            \"`new_layout.size()` must be greater than or equal to `old_layout.size()`\"\n+        );\n+\n+        let new_ptr = self.allocate(new_layout)?;\n+        if new_layout.size() > 0 {\n+            new_ptr.as_mut_ptr().copy_from_nonoverlapping(ptr.as_ptr(), old_layout.size());\n+            self.deallocate(ptr, old_layout);\n+        }\n+        Ok(new_ptr)\n+    }\n+\n+    unsafe fn grow_zeroed(\n+        &self,\n+        ptr: NonNull<u8>,\n+        old_layout: Layout,\n+        new_layout: Layout,\n+    ) -> Result<NonNull<[u8]>, AllocError> {\n+        let new_ptr = self.grow(ptr, old_layout, new_layout)?;\n+        if new_layout.size() > 0 {\n+            let old_size = old_layout.size();\n+            let new_size = new_layout.size();\n+            let raw_ptr = new_ptr.as_mut_ptr();\n+            raw_ptr.add(old_size).write_bytes(0, new_size - old_size);\n+        }\n+        Ok(new_ptr)\n+    }\n+\n+    unsafe fn shrink(\n+        &self,\n+        ptr: NonNull<u8>,\n+        old_layout: Layout,\n+        new_layout: Layout,\n+    ) -> Result<NonNull<[u8]>, AllocError> {\n+        debug_assert!(\n+            new_layout.size() <= old_layout.size(),\n+            \"`new_layout.size()` must be smaller than or equal to `old_layout.size()`\"\n+        );\n+\n+        let new_ptr = self.allocate(new_layout)?;\n+        if new_layout.size() > 0 {\n+            new_ptr.as_mut_ptr().copy_from_nonoverlapping(ptr.as_ptr(), new_layout.size());\n+            self.deallocate(ptr, old_layout);\n+        }\n+        Ok(new_ptr)\n+    }\n+\n+    fn by_ref(&self) -> &Self\n+    where\n+        Self: Sized,\n+    {\n+        self\n+    }\n+}\n+\n+#[test]\n+fn const_box() {\n+    const VALUE: u32 = {\n+        let mut boxed = Box::new_in(1u32, ConstAllocator);\n+        assert!(*boxed == 1);\n+\n+        *boxed = 42;\n+        assert!(*boxed == 42);\n+\n+        *boxed\n+    };\n+\n+    assert!(VALUE == 42);\n+}"}, {"sha": "eec24a5c3f7e69ea3ca90574ba44c82609c78842", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c7125ba0fa4e9abe826f004a023c0bf3678a8963/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7125ba0fa4e9abe826f004a023c0bf3678a8963/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=c7125ba0fa4e9abe826f004a023c0bf3678a8963", "patch": "@@ -1,8 +1,19 @@\n #![feature(allocator_api)]\n+#![feature(alloc_layout_extra)]\n #![feature(assert_matches)]\n #![feature(box_syntax)]\n #![feature(cow_is_borrowed)]\n+#![feature(const_box)]\n+#![feature(const_convert)]\n #![feature(const_cow_is_borrowed)]\n+#![feature(const_heap)]\n+#![feature(const_intrinsic_copy)]\n+#![feature(const_mut_refs)]\n+#![feature(const_nonnull_slice_from_raw_parts)]\n+#![feature(const_ptr_offset)]\n+#![feature(const_ptr_write)]\n+#![feature(const_try)]\n+#![feature(core_intrinsics)]\n #![feature(drain_filter)]\n #![feature(exact_size_is_empty)]\n #![feature(new_uninit)]\n@@ -26,6 +37,7 @@\n #![feature(const_default_impls)]\n #![feature(const_trait_impl)]\n #![feature(const_str_from_utf8)]\n+#![feature(nonnull_slice_from_raw_parts)]\n \n use std::collections::hash_map::DefaultHasher;\n use std::hash::{Hash, Hasher};"}]}