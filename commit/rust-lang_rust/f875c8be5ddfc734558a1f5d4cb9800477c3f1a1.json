{"sha": "f875c8be5ddfc734558a1f5d4cb9800477c3f1a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4NzVjOGJlNWRkZmM3MzQ1NThhMWY1ZDRjYjk4MDA0NzdjM2YxYTE=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-10-07T17:01:56Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-10-16T04:18:59Z"}, "message": "Take sys/vxworks/rwlock from sys/unix instead.", "tree": {"sha": "8ea703a817809b10d91eff51f6adaf8d7921265b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ea703a817809b10d91eff51f6adaf8d7921265b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f875c8be5ddfc734558a1f5d4cb9800477c3f1a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f875c8be5ddfc734558a1f5d4cb9800477c3f1a1", "html_url": "https://github.com/rust-lang/rust/commit/f875c8be5ddfc734558a1f5d4cb9800477c3f1a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f875c8be5ddfc734558a1f5d4cb9800477c3f1a1/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3f30c7132c20825833074044b00c7e02016ca25", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3f30c7132c20825833074044b00c7e02016ca25", "html_url": "https://github.com/rust-lang/rust/commit/f3f30c7132c20825833074044b00c7e02016ca25"}], "stats": {"total": 115, "additions": 1, "deletions": 114}, "files": [{"sha": "def23c70456b01675cde2c9e00505c958fb92e3f", "filename": "library/std/src/sys/vxworks/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f875c8be5ddfc734558a1f5d4cb9800477c3f1a1/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f875c8be5ddfc734558a1f5d4cb9800477c3f1a1/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fmod.rs?ref=f875c8be5ddfc734558a1f5d4cb9800477c3f1a1", "patch": "@@ -26,6 +26,7 @@ pub mod path;\n pub mod pipe;\n pub mod process;\n pub mod rand;\n+#[path = \"../unix/rwlock.rs\"]\n pub mod rwlock;\n pub mod stack_overflow;\n pub mod stdio;"}, {"sha": "c90304c2b4a6a2d90dede9cd798a4b6d4063a8aa", "filename": "library/std/src/sys/vxworks/rwlock.rs", "status": "removed", "additions": 0, "deletions": 114, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/f3f30c7132c20825833074044b00c7e02016ca25/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3f30c7132c20825833074044b00c7e02016ca25/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Frwlock.rs?ref=f3f30c7132c20825833074044b00c7e02016ca25", "patch": "@@ -1,114 +0,0 @@\n-use crate::cell::UnsafeCell;\n-use crate::sync::atomic::{AtomicUsize, Ordering};\n-\n-pub struct RWLock {\n-    inner: UnsafeCell<libc::pthread_rwlock_t>,\n-    write_locked: UnsafeCell<bool>,\n-    num_readers: AtomicUsize,\n-}\n-\n-unsafe impl Send for RWLock {}\n-unsafe impl Sync for RWLock {}\n-\n-impl RWLock {\n-    pub const fn new() -> RWLock {\n-        RWLock {\n-            inner: UnsafeCell::new(libc::PTHREAD_RWLOCK_INITIALIZER),\n-            write_locked: UnsafeCell::new(false),\n-            num_readers: AtomicUsize::new(0),\n-        }\n-    }\n-\n-    #[inline]\n-    pub unsafe fn read(&self) {\n-        let r = libc::pthread_rwlock_rdlock(self.inner.get());\n-        if r == libc::EAGAIN {\n-            panic!(\"rwlock maximum reader count exceeded\");\n-        } else if r == libc::EDEADLK || (r == 0 && *self.write_locked.get()) {\n-            if r == 0 {\n-                self.raw_unlock();\n-            }\n-            panic!(\"rwlock read lock would result in deadlock\");\n-        } else {\n-            debug_assert_eq!(r, 0);\n-            self.num_readers.fetch_add(1, Ordering::Relaxed);\n-        }\n-    }\n-\n-    #[inline]\n-    pub unsafe fn try_read(&self) -> bool {\n-        let r = libc::pthread_rwlock_tryrdlock(self.inner.get());\n-        if r == 0 {\n-            if *self.write_locked.get() {\n-                self.raw_unlock();\n-                false\n-            } else {\n-                self.num_readers.fetch_add(1, Ordering::Relaxed);\n-                true\n-            }\n-        } else {\n-            false\n-        }\n-    }\n-\n-    #[inline]\n-    pub unsafe fn write(&self) {\n-        let r = libc::pthread_rwlock_wrlock(self.inner.get());\n-        // See comments above for why we check for EDEADLK and write_locked. We\n-        // also need to check that num_readers is 0.\n-        if r == libc::EDEADLK\n-            || *self.write_locked.get()\n-            || self.num_readers.load(Ordering::Relaxed) != 0\n-        {\n-            if r == 0 {\n-                self.raw_unlock();\n-            }\n-            panic!(\"rwlock write lock would result in deadlock\");\n-        } else {\n-            debug_assert_eq!(r, 0);\n-        }\n-        *self.write_locked.get() = true;\n-    }\n-\n-    #[inline]\n-    pub unsafe fn try_write(&self) -> bool {\n-        let r = libc::pthread_rwlock_trywrlock(self.inner.get());\n-        if r == 0 {\n-            if *self.write_locked.get() || self.num_readers.load(Ordering::Relaxed) != 0 {\n-                self.raw_unlock();\n-                false\n-            } else {\n-                *self.write_locked.get() = true;\n-                true\n-            }\n-        } else {\n-            false\n-        }\n-    }\n-\n-    #[inline]\n-    unsafe fn raw_unlock(&self) {\n-        let r = libc::pthread_rwlock_unlock(self.inner.get());\n-        debug_assert_eq!(r, 0);\n-    }\n-\n-    #[inline]\n-    pub unsafe fn read_unlock(&self) {\n-        debug_assert!(!*self.write_locked.get());\n-        self.num_readers.fetch_sub(1, Ordering::Relaxed);\n-        self.raw_unlock();\n-    }\n-\n-    #[inline]\n-    pub unsafe fn write_unlock(&self) {\n-        debug_assert_eq!(self.num_readers.load(Ordering::Relaxed), 0);\n-        debug_assert!(*self.write_locked.get());\n-        *self.write_locked.get() = false;\n-        self.raw_unlock();\n-    }\n-    #[inline]\n-    pub unsafe fn destroy(&self) {\n-        let r = libc::pthread_rwlock_destroy(self.inner.get());\n-        debug_assert_eq!(r, 0);\n-    }\n-}"}]}