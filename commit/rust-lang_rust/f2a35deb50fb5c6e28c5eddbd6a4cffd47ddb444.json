{"sha": "f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444", "node_id": "C_kwDOAAsO6NoAKGYyYTM1ZGViNTBmYjVjNmUyOGM1ZWRkYmQ2YTRjZmZkNDdkZGI0NDQ", "commit": {"author": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2023-05-11T06:52:13Z"}, "committer": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2023-05-11T12:13:12Z"}, "message": "Consider macro sub-namespace during name resolution", "tree": {"sha": "b851a751b76e722a4a91afec64cb85f9c0ee80d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b851a751b76e722a4a91afec64cb85f9c0ee80d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEkSbsQIURluxz4rzf4laYqTBYYXEFAmRc29gACgkQ4laYqTBY\nYXEmtBAAmOnVm2S+fwlOc5heEv3d7HXR0duS6T+b4cYgkJAGFU0IutN4V6cKHkPk\ngVwjhEPWWV4GDNL9rTWk0XiNopcwrV3o6y4M929oKRoWRv8rqme0Mozbar7Ye3N2\nq1mAX4RqmScmk/B7l5gAAC0PxjSbaiSVpBCAiGzvH2AqPJat515u+1Z1x9ZeSIzj\nofQuVMgZmxeXS+M5js2JB5kxGWruqxjRJfCHcRTB7DtheFwoQ15Mo6bRY8kTzlrf\n2bSWKXGQfoa8PFpNk43rn2XCESw2whURPHKxrcaFNa9/8gmuio1OvIhsl3AIaYnH\nzhRv6slomoCZ+T0wg2w/U6s2s6GbmOa8tPT5WAB9ryI6B18oC/rDWkmw3ZUXAml3\n9QSeh2TVpIPzntcITtAA76ACk2SjmHcpME6Nwdw2Dbp686swv66HrjbDkhCgsSqZ\n0LjjY5ELj3i3gjf00pqCtSkeUUnRxwQD/qvzy5hY5j/L3ty5zWSSTgra2cqa21co\nokXPeiQOj4DzZQTS6n/QBhlEDrOJXmjfPTCDDxGy6fGyM8WqAFnMDQ0Ry56U++6o\nm6XLM2+UzHDE8KMqV42t/coyUhmsPZcEl7MIYN0Xl7ztnt9EafjSr55LErPP++b4\n6J6D05IJrS0HfpN36/h5n/BMTLIV60fbmLQQ9HxbHfOst6plifw=\n=bS3s\n-----END PGP SIGNATURE-----", "payload": "tree b851a751b76e722a4a91afec64cb85f9c0ee80d9\nparent 3203ea896d1ed9f6b8a8af25a8028df51a6bd5b3\nauthor Ryo Yoshida <low.ryoshida@gmail.com> 1683787933 +0900\ncommitter Ryo Yoshida <low.ryoshida@gmail.com> 1683807192 +0900\n\nConsider macro sub-namespace during name resolution\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444", "html_url": "https://github.com/rust-lang/rust/commit/f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444/comments", "author": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3203ea896d1ed9f6b8a8af25a8028df51a6bd5b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/3203ea896d1ed9f6b8a8af25a8028df51a6bd5b3", "html_url": "https://github.com/rust-lang/rust/commit/3203ea896d1ed9f6b8a8af25a8028df51a6bd5b3"}], "stats": {"total": 272, "additions": 236, "deletions": 36}, "files": [{"sha": "d92698a938a7b11e1588eed6ee2c454ac7ceefac", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444", "patch": "@@ -37,7 +37,7 @@ use crate::{\n     item_scope::BuiltinShadowMode,\n     lang_item::LangItem,\n     lower::LowerCtx,\n-    nameres::DefMap,\n+    nameres::{DefMap, MacroSubNs},\n     path::{GenericArgs, Path},\n     type_ref::{Mutability, Rawness, TypeRef},\n     AdtId, BlockId, BlockLoc, ModuleDefId, UnresolvedMacro,\n@@ -800,7 +800,13 @@ impl ExprCollector<'_> {\n         let module = self.expander.module.local_id;\n         let res = self.expander.enter_expand(self.db, mcall, |path| {\n             self.def_map\n-                .resolve_path(self.db, module, &path, crate::item_scope::BuiltinShadowMode::Other)\n+                .resolve_path(\n+                    self.db,\n+                    module,\n+                    &path,\n+                    crate::item_scope::BuiltinShadowMode::Other,\n+                    Some(MacroSubNs::Bang),\n+                )\n                 .0\n                 .take_macros()\n         });\n@@ -1056,6 +1062,7 @@ impl ExprCollector<'_> {\n                         self.expander.module.local_id,\n                         &name.clone().into(),\n                         BuiltinShadowMode::Other,\n+                        None,\n                     );\n                     match resolved.take_values() {\n                         Some(ModuleDefId::ConstId(_)) => (None, Pat::Path(name.into())),"}, {"sha": "40e6a4308784c546cedd8ed462fe8bd198541d57", "filename": "crates/hir-def/src/data.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444/crates%2Fhir-def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444/crates%2Fhir-def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fdata.rs?ref=f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444", "patch": "@@ -22,7 +22,7 @@ use crate::{\n         attr_resolution::ResolvedAttr,\n         diagnostics::DefDiagnostic,\n         proc_macro::{parse_macro_name_and_helper_attrs, ProcMacroKind},\n-        DefMap,\n+        DefMap, MacroSubNs,\n     },\n     type_ref::{TraitRef, TypeBound, TypeRef},\n     visibility::RawVisibility,\n@@ -673,6 +673,7 @@ impl<'a> AssocItemCollector<'a> {\n                             module,\n                             &path,\n                             crate::item_scope::BuiltinShadowMode::Other,\n+                            Some(MacroSubNs::Bang),\n                         )\n                         .0\n                         .take_macros()"}, {"sha": "b401762255ef8a1911fde3d1b4aabf7b274a8008", "filename": "crates/hir-def/src/find_path.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444/crates%2Fhir-def%2Fsrc%2Ffind_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444/crates%2Fhir-def%2Fsrc%2Ffind_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Ffind_path.rs?ref=f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444", "patch": "@@ -543,6 +543,7 @@ mod tests {\n                 module.local_id,\n                 &mod_path,\n                 crate::item_scope::BuiltinShadowMode::Module,\n+                None,\n             )\n             .0\n             .take_types()"}, {"sha": "f19c3f028f42f7c41fe7f412cf23c894bfaa418a", "filename": "crates/hir-def/src/generics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444/crates%2Fhir-def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444/crates%2Fhir-def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fgenerics.rs?ref=f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444", "patch": "@@ -22,7 +22,7 @@ use crate::{\n     dyn_map::{keys, DynMap},\n     expander::Expander,\n     lower::LowerCtx,\n-    nameres::DefMap,\n+    nameres::{DefMap, MacroSubNs},\n     src::{HasChildSource, HasSource},\n     type_ref::{LifetimeRef, TypeBound, TypeRef},\n     AdtId, ConstParamId, GenericDefId, HasModule, LifetimeParamId, LocalLifetimeParamId,\n@@ -361,6 +361,7 @@ impl GenericParams {\n                             module,\n                             &path,\n                             crate::item_scope::BuiltinShadowMode::Other,\n+                            Some(MacroSubNs::Bang),\n                         )\n                         .0\n                         .take_macros()"}, {"sha": "40849d4a66d8ca672e0d98eec382c6977b6eab3b", "filename": "crates/hir-def/src/macro_expansion_tests/mod.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmod.rs?ref=f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444", "patch": "@@ -33,8 +33,13 @@ use syntax::{\n use tt::token_id::{Subtree, TokenId};\n \n use crate::{\n-    db::DefDatabase, macro_id_to_def_id, nameres::ModuleSource, resolver::HasResolver,\n-    src::HasSource, test_db::TestDB, AdtId, AsMacroCall, Lookup, ModuleDefId,\n+    db::DefDatabase,\n+    macro_id_to_def_id,\n+    nameres::{MacroSubNs, ModuleSource},\n+    resolver::HasResolver,\n+    src::HasSource,\n+    test_db::TestDB,\n+    AdtId, AsMacroCall, Lookup, ModuleDefId,\n };\n \n #[track_caller]\n@@ -127,7 +132,9 @@ pub fn identity_when_valid(_attr: TokenStream, item: TokenStream) -> TokenStream\n         let macro_call = InFile::new(source.file_id, &macro_call);\n         let res = macro_call\n             .as_call_id_with_errors(&db, krate, |path| {\n-                resolver.resolve_path_as_macro(&db, &path).map(|it| macro_id_to_def_id(&db, it))\n+                resolver\n+                    .resolve_path_as_macro(&db, &path, Some(MacroSubNs::Bang))\n+                    .map(|it| macro_id_to_def_id(&db, it))\n             })\n             .unwrap();\n         let macro_call_id = res.value.unwrap();"}, {"sha": "39a56814ed88bee0127df9753e9eb538bb79f183", "filename": "crates/hir-def/src/nameres.rs", "status": "modified", "additions": 58, "deletions": 4, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444/crates%2Fhir-def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444/crates%2Fhir-def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres.rs?ref=f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444", "patch": "@@ -59,7 +59,7 @@ mod tests;\n \n use std::{cmp::Ord, ops::Deref};\n \n-use base_db::{CrateId, Edition, FileId};\n+use base_db::{CrateId, Edition, FileId, ProcMacroKind};\n use hir_expand::{name::Name, InFile, MacroCallId, MacroDefId};\n use itertools::Itertools;\n use la_arena::Arena;\n@@ -77,7 +77,8 @@ use crate::{\n     path::ModPath,\n     per_ns::PerNs,\n     visibility::Visibility,\n-    AstId, BlockId, BlockLoc, FunctionId, LocalModuleId, MacroId, ModuleId, ProcMacroId,\n+    AstId, BlockId, BlockLoc, FunctionId, LocalModuleId, Lookup, MacroExpander, MacroId, ModuleId,\n+    ProcMacroId,\n };\n \n /// Contains the results of (early) name resolution.\n@@ -380,9 +381,16 @@ impl DefMap {\n         original_module: LocalModuleId,\n         path: &ModPath,\n         shadow: BuiltinShadowMode,\n+        expected_macro_subns: Option<MacroSubNs>,\n     ) -> (PerNs, Option<usize>) {\n-        let res =\n-            self.resolve_path_fp_with_macro(db, ResolveMode::Other, original_module, path, shadow);\n+        let res = self.resolve_path_fp_with_macro(\n+            db,\n+            ResolveMode::Other,\n+            original_module,\n+            path,\n+            shadow,\n+            expected_macro_subns,\n+        );\n         (res.resolved_def, res.segment_index)\n     }\n \n@@ -399,6 +407,7 @@ impl DefMap {\n             original_module,\n             path,\n             shadow,\n+            None, // Currently this function isn't used for macro resolution.\n         );\n         (res.resolved_def, res.segment_index)\n     }\n@@ -568,3 +577,48 @@ pub enum ModuleSource {\n     Module(ast::Module),\n     BlockExpr(ast::BlockExpr),\n }\n+\n+/// See `sub_namespace_match()`.\n+#[derive(Clone, Copy, PartialEq, Eq)]\n+pub enum MacroSubNs {\n+    /// Function-like macros, suffixed with `!`.\n+    Bang,\n+    /// Macros inside attributes, i.e. attribute macros and derive macros.\n+    Attr,\n+}\n+\n+impl MacroSubNs {\n+    fn from_id(db: &dyn DefDatabase, macro_id: MacroId) -> Self {\n+        let expander = match macro_id {\n+            MacroId::Macro2Id(it) => it.lookup(db).expander,\n+            MacroId::MacroRulesId(it) => it.lookup(db).expander,\n+            MacroId::ProcMacroId(it) => {\n+                return match it.lookup(db).kind {\n+                    ProcMacroKind::CustomDerive | ProcMacroKind::Attr => Self::Attr,\n+                    ProcMacroKind::FuncLike => Self::Bang,\n+                };\n+            }\n+        };\n+\n+        // Eager macros aren't *guaranteed* to be bang macros, but they *are* all bang macros currently.\n+        match expander {\n+            MacroExpander::Declarative\n+            | MacroExpander::BuiltIn(_)\n+            | MacroExpander::BuiltInEager(_) => Self::Bang,\n+            MacroExpander::BuiltInAttr(_) | MacroExpander::BuiltInDerive(_) => Self::Attr,\n+        }\n+    }\n+}\n+\n+/// Quoted from [rustc]:\n+/// Macro namespace is separated into two sub-namespaces, one for bang macros and\n+/// one for attribute-like macros (attributes, derives).\n+/// We ignore resolutions from one sub-namespace when searching names in scope for another.\n+///\n+/// [rustc]: https://github.com/rust-lang/rust/blob/1.69.0/compiler/rustc_resolve/src/macros.rs#L75\n+fn sub_namespace_match(candidate: Option<MacroSubNs>, expected: Option<MacroSubNs>) -> bool {\n+    match (candidate, expected) {\n+        (Some(candidate), Some(expected)) => candidate == expected,\n+        _ => true,\n+    }\n+}"}, {"sha": "6567bda709d6384a57c1df0ae2c54197078dcec0", "filename": "crates/hir-def/src/nameres/attr_resolution.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444/crates%2Fhir-def%2Fsrc%2Fnameres%2Fattr_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444/crates%2Fhir-def%2Fsrc%2Fnameres%2Fattr_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fattr_resolution.rs?ref=f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444", "patch": "@@ -14,7 +14,7 @@ use crate::{\n     AstIdWithPath, LocalModuleId, UnresolvedMacro,\n };\n \n-use super::DefMap;\n+use super::{DefMap, MacroSubNs};\n \n pub enum ResolvedAttr {\n     /// Attribute resolved to an attribute macro.\n@@ -43,9 +43,12 @@ impl DefMap {\n             original_module,\n             &ast_id.path,\n             BuiltinShadowMode::Module,\n+            Some(MacroSubNs::Attr),\n         );\n         let def = match resolved_res.resolved_def.take_macros() {\n             Some(def) => {\n+                // `MacroSubNs` is just a hint, so the path may still resolve to a custom derive\n+                // macro, or even function-like macro when the path is qualified.\n                 if def.is_attribute(db) {\n                     def\n                 } else {"}, {"sha": "177edcbb7f2401a22570718082b03980cb34e1a0", "filename": "crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444", "patch": "@@ -44,7 +44,7 @@ use crate::{\n         mod_resolution::ModDir,\n         path_resolution::ReachedFixedPoint,\n         proc_macro::{parse_macro_name_and_helper_attrs, ProcMacroDef, ProcMacroKind},\n-        BuiltinShadowMode, DefMap, ModuleData, ModuleOrigin, ResolveMode,\n+        BuiltinShadowMode, DefMap, MacroSubNs, ModuleData, ModuleOrigin, ResolveMode,\n     },\n     path::{ImportAlias, ModPath, PathKind},\n     per_ns::PerNs,\n@@ -549,8 +549,13 @@ impl DefCollector<'_> {\n         };\n         let path = ModPath::from_segments(path_kind, [krate, name![prelude], edition]);\n \n-        let (per_ns, _) =\n-            self.def_map.resolve_path(self.db, self.def_map.root, &path, BuiltinShadowMode::Other);\n+        let (per_ns, _) = self.def_map.resolve_path(\n+            self.db,\n+            self.def_map.root,\n+            &path,\n+            BuiltinShadowMode::Other,\n+            None,\n+        );\n \n         match per_ns.types {\n             Some((ModuleDefId::ModuleId(m), _)) => {\n@@ -796,6 +801,7 @@ impl DefCollector<'_> {\n                 module_id,\n                 &import.path,\n                 BuiltinShadowMode::Module,\n+                None, // An import may resolve to any kind of macro.\n             );\n \n             let def = res.resolved_def;\n@@ -1093,14 +1099,22 @@ impl DefCollector<'_> {\n             resolved.push((directive.module_id, directive.depth, directive.container, call_id));\n         };\n         let mut res = ReachedFixedPoint::Yes;\n+        // Retain unresolved macros after this round of resolution.\n         macros.retain(|directive| {\n+            let subns = match &directive.kind {\n+                MacroDirectiveKind::FnLike { .. } => MacroSubNs::Bang,\n+                MacroDirectiveKind::Attr { .. } | MacroDirectiveKind::Derive { .. } => {\n+                    MacroSubNs::Attr\n+                }\n+            };\n             let resolver = |path| {\n                 let resolved_res = self.def_map.resolve_path_fp_with_macro(\n                     self.db,\n                     ResolveMode::Other,\n                     directive.module_id,\n                     &path,\n                     BuiltinShadowMode::Module,\n+                    Some(subns),\n                 );\n                 resolved_res\n                     .resolved_def\n@@ -1419,6 +1433,7 @@ impl DefCollector<'_> {\n                                 directive.module_id,\n                                 &path,\n                                 BuiltinShadowMode::Module,\n+                                Some(MacroSubNs::Bang),\n                             );\n                             resolved_res\n                                 .resolved_def"}, {"sha": "4740fd7f449944755a3747c356589df85a3306ee", "filename": "crates/hir-def/src/nameres/path_resolution.rs", "status": "modified", "additions": 39, "deletions": 6, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444/crates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444/crates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444", "patch": "@@ -16,7 +16,7 @@ use hir_expand::name::Name;\n use crate::{\n     db::DefDatabase,\n     item_scope::BUILTIN_SCOPE,\n-    nameres::{BuiltinShadowMode, DefMap},\n+    nameres::{sub_namespace_match, BuiltinShadowMode, DefMap, MacroSubNs},\n     path::{ModPath, PathKind},\n     per_ns::PerNs,\n     visibility::{RawVisibility, Visibility},\n@@ -58,6 +58,17 @@ impl ResolvePathResult {\n     }\n }\n \n+impl PerNs {\n+    fn filter_macro(mut self, db: &dyn DefDatabase, expected: Option<MacroSubNs>) -> Self {\n+        self.macros = self.macros.filter(|&(id, _)| {\n+            let this = MacroSubNs::from_id(db, id);\n+            sub_namespace_match(Some(this), expected)\n+        });\n+\n+        self\n+    }\n+}\n+\n impl DefMap {\n     pub(super) fn resolve_name_in_extern_prelude(\n         &self,\n@@ -83,7 +94,7 @@ impl DefMap {\n         let mut vis = match visibility {\n             RawVisibility::Module(path) => {\n                 let (result, remaining) =\n-                    self.resolve_path(db, original_module, path, BuiltinShadowMode::Module);\n+                    self.resolve_path(db, original_module, path, BuiltinShadowMode::Module, None);\n                 if remaining.is_some() {\n                     return None;\n                 }\n@@ -124,6 +135,9 @@ impl DefMap {\n         mut original_module: LocalModuleId,\n         path: &ModPath,\n         shadow: BuiltinShadowMode,\n+        // Pass `MacroSubNs` if we know we're resolving macro names and which kind of macro we're\n+        // resolving them to. Pass `None` otherwise, e.g. when we're resolving import paths.\n+        expected_macro_subns: Option<MacroSubNs>,\n     ) -> ResolvePathResult {\n         let mut result = ResolvePathResult::empty(ReachedFixedPoint::No);\n \n@@ -136,6 +150,7 @@ impl DefMap {\n                 original_module,\n                 path,\n                 shadow,\n+                expected_macro_subns,\n             );\n \n             // Merge `new` into `result`.\n@@ -169,6 +184,7 @@ impl DefMap {\n         original_module: LocalModuleId,\n         path: &ModPath,\n         shadow: BuiltinShadowMode,\n+        expected_macro_subns: Option<MacroSubNs>,\n     ) -> ResolvePathResult {\n         let graph = db.crate_graph();\n         let _cx = stdx::panic_context::enter(format!(\n@@ -220,7 +236,13 @@ impl DefMap {\n                     if path.segments().len() == 1 { shadow } else { BuiltinShadowMode::Module };\n \n                 tracing::debug!(\"resolving {:?} in module\", segment);\n-                self.resolve_name_in_module(db, original_module, segment, prefer_module)\n+                self.resolve_name_in_module(\n+                    db,\n+                    original_module,\n+                    segment,\n+                    prefer_module,\n+                    expected_macro_subns,\n+                )\n             }\n             PathKind::Super(lvl) => {\n                 let mut module = original_module;\n@@ -245,6 +267,7 @@ impl DefMap {\n                                     block.parent.local_id,\n                                     &new_path,\n                                     shadow,\n+                                    expected_macro_subns,\n                                 );\n                             }\n                             None => {\n@@ -303,7 +326,12 @@ impl DefMap {\n                         );\n                         tracing::debug!(\"resolving {:?} in other crate\", path);\n                         let defp_map = module.def_map(db);\n-                        let (def, s) = defp_map.resolve_path(db, module.local_id, &path, shadow);\n+                        // Macro sub-namespaces only matter when resolving single-segment paths\n+                        // because `macro_use` and other preludes should be taken into account. At\n+                        // this point, we know we're resolving a multi-segment path so macro kind\n+                        // expectation is discarded.\n+                        let (def, s) =\n+                            defp_map.resolve_path(db, module.local_id, &path, shadow, None);\n                         return ResolvePathResult::with(\n                             def,\n                             ReachedFixedPoint::Yes,\n@@ -381,6 +409,7 @@ impl DefMap {\n         module: LocalModuleId,\n         name: &Name,\n         shadow: BuiltinShadowMode,\n+        expected_macro_subns: Option<MacroSubNs>,\n     ) -> PerNs {\n         // Resolve in:\n         //  - legacy scope of macro\n@@ -392,8 +421,12 @@ impl DefMap {\n             .get_legacy_macro(name)\n             // FIXME: shadowing\n             .and_then(|it| it.last())\n-            .map_or_else(PerNs::none, |&m| PerNs::macros(m, Visibility::Public));\n-        let from_scope = self[module].scope.get(name);\n+            .copied()\n+            .filter(|&id| {\n+                sub_namespace_match(Some(MacroSubNs::from_id(db, id)), expected_macro_subns)\n+            })\n+            .map_or_else(PerNs::none, |m| PerNs::macros(m, Visibility::Public));\n+        let from_scope = self[module].scope.get(name).filter_macro(db, expected_macro_subns);\n         let from_builtin = match self.block {\n             Some(_) => {\n                 // Only resolve to builtins in the root `DefMap`."}, {"sha": "e795b7b9b7e6fadb7bb1f5843195e28a5bf0477d", "filename": "crates/hir-def/src/nameres/tests/macros.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444/crates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444/crates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444", "patch": "@@ -1271,3 +1271,57 @@ pub mod prelude {\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn macro_sub_namespace() {\n+    let map = compute_crate_def_map(\n+        r#\"\n+//- minicore: derive, clone\n+macro_rules! Clone { () => {} }\n+macro_rules! derive { () => {} }\n+\n+#[derive(Clone)]\n+struct S;\n+    \"#,\n+    );\n+    assert_eq!(map.modules[map.root].scope.impls().len(), 1);\n+}\n+\n+#[test]\n+fn macro_sub_namespace2() {\n+    check(\n+        r#\"\n+//- /main.rs edition:2021 crate:main deps:proc,core\n+use proc::{foo, bar};\n+\n+foo!();\n+bar!();\n+\n+//- /proc.rs crate:proc\n+#![crate_type=\"proc-macro\"]\n+#[proc_macro_derive(foo)]\n+pub fn foo() {}\n+#[proc_macro_attribute]\n+pub fn bar() {}\n+\n+//- /core.rs crate:core\n+pub mod prelude {\n+    pub mod rust_2021 {\n+        pub macro foo() {\n+            struct Ok;\n+        }\n+        pub macro bar() {\n+            fn ok() {}\n+        }\n+    }\n+}\n+    \"#,\n+        expect![[r#\"\n+            crate\n+            Ok: t v\n+            bar: m\n+            foo: m\n+            ok: v\n+        \"#]],\n+    );\n+}"}, {"sha": "4bec2b4dea429fb157af120267fe0d17033a5cad", "filename": "crates/hir-def/src/resolver.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fresolver.rs?ref=f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444", "patch": "@@ -17,7 +17,7 @@ use crate::{\n     hir::{BindingId, ExprId, LabelId},\n     item_scope::{BuiltinShadowMode, BUILTIN_SCOPE},\n     lang_item::LangItemTarget,\n-    nameres::DefMap,\n+    nameres::{DefMap, MacroSubNs},\n     path::{ModPath, Path, PathKind},\n     per_ns::PerNs,\n     visibility::{RawVisibility, Visibility},\n@@ -155,7 +155,8 @@ impl Resolver {\n         path: &ModPath,\n     ) -> Option<PerNs> {\n         let (item_map, module) = self.item_scope();\n-        let (module_res, idx) = item_map.resolve_path(db, module, path, BuiltinShadowMode::Module);\n+        let (module_res, idx) =\n+            item_map.resolve_path(db, module, path, BuiltinShadowMode::Module, None);\n         match module_res.take_types()? {\n             ModuleDefId::TraitId(it) => {\n                 let idx = idx?;\n@@ -385,9 +386,17 @@ impl Resolver {\n         }\n     }\n \n-    pub fn resolve_path_as_macro(&self, db: &dyn DefDatabase, path: &ModPath) -> Option<MacroId> {\n+    pub fn resolve_path_as_macro(\n+        &self,\n+        db: &dyn DefDatabase,\n+        path: &ModPath,\n+        expected_macro_kind: Option<MacroSubNs>,\n+    ) -> Option<MacroId> {\n         let (item_map, module) = self.item_scope();\n-        item_map.resolve_path(db, module, path, BuiltinShadowMode::Other).0.take_macros()\n+        item_map\n+            .resolve_path(db, module, path, BuiltinShadowMode::Other, expected_macro_kind)\n+            .0\n+            .take_macros()\n     }\n \n     /// Returns a set of names available in the current scope.\n@@ -626,7 +635,8 @@ impl Resolver {\n         shadow: BuiltinShadowMode,\n     ) -> PerNs {\n         let (item_map, module) = self.item_scope();\n-        let (module_res, segment_index) = item_map.resolve_path(db, module, path, shadow);\n+        // This method resolves `path` just like import paths, so no expected macro subns is given.\n+        let (module_res, segment_index) = item_map.resolve_path(db, module, path, shadow, None);\n         if segment_index.is_some() {\n             return PerNs::none();\n         }"}, {"sha": "098b677b15012040bad5740a5d6871754639f6d2", "filename": "crates/hir-ty/src/lower.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444/crates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444/crates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flower.rs?ref=f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444", "patch": "@@ -24,6 +24,7 @@ use hir_def::{\n         TypeOrConstParamData, TypeParamProvenance, WherePredicate, WherePredicateTypeTarget,\n     },\n     lang_item::{lang_attr, LangItem},\n+    nameres::MacroSubNs,\n     path::{GenericArg, GenericArgs, ModPath, Path, PathKind, PathSegment, PathSegments},\n     resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::{ConstRefOrPath, TraitBoundModifier, TraitRef as HirTraitRef, TypeBound, TypeRef},\n@@ -378,9 +379,15 @@ impl<'a> TyLoweringContext<'a> {\n                 };\n                 let ty = {\n                     let macro_call = macro_call.to_node(self.db.upcast());\n-                    match expander.enter_expand::<ast::Type>(self.db.upcast(), macro_call, |path| {\n-                        self.resolver.resolve_path_as_macro(self.db.upcast(), &path)\n-                    }) {\n+                    let resolver = |path| {\n+                        self.resolver.resolve_path_as_macro(\n+                            self.db.upcast(),\n+                            &path,\n+                            Some(MacroSubNs::Bang),\n+                        )\n+                    };\n+                    match expander.enter_expand::<ast::Type>(self.db.upcast(), macro_call, resolver)\n+                    {\n                         Ok(ExpandResult { value: Some((mark, expanded)), .. }) => {\n                             let ctx = expander.ctx(self.db.upcast());\n                             // FIXME: Report syntax errors in expansion here"}, {"sha": "b817937296d204607493bb4e98463db8e20a4c7e", "filename": "crates/hir/src/attrs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444/crates%2Fhir%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444/crates%2Fhir%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fattrs.rs?ref=f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444", "patch": "@@ -120,6 +120,7 @@ impl HasAttrs for AssocItem {\n     }\n }\n \n+/// Resolves the item `link` points to in the scope of `def`.\n fn resolve_doc_path(\n     db: &dyn HirDatabase,\n     def: AttrDefId,"}, {"sha": "2d2b00b147e554078dd79c0a676672c82cfde769", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444", "patch": "@@ -10,6 +10,7 @@ use hir_def::{\n     hir::Expr,\n     lower::LowerCtx,\n     macro_id_to_def_id,\n+    nameres::MacroSubNs,\n     resolver::{self, HasResolver, Resolver, TypeNs},\n     type_ref::Mutability,\n     AsMacroCall, DefWithBodyId, FieldId, FunctionId, MacroId, TraitId, VariantId,\n@@ -616,7 +617,7 @@ impl<'db> SemanticsImpl<'db> {\n         let krate = resolver.krate();\n         let macro_call_id = macro_call.as_call_id(self.db.upcast(), krate, |path| {\n             resolver\n-                .resolve_path_as_macro(self.db.upcast(), &path)\n+                .resolve_path_as_macro(self.db.upcast(), &path, Some(MacroSubNs::Bang))\n                 .map(|it| macro_id_to_def_id(self.db.upcast(), it))\n         })?;\n         hir_expand::db::expand_speculative("}, {"sha": "dae77fad2f37b2a425cce8e7cdf49d662e751e9c", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=f2a35deb50fb5c6e28c5eddbd6a4cffd47ddb444", "patch": "@@ -17,6 +17,7 @@ use hir_def::{\n     lang_item::LangItem,\n     lower::LowerCtx,\n     macro_id_to_def_id,\n+    nameres::MacroSubNs,\n     path::{ModPath, Path, PathKind},\n     resolver::{resolver_for_scope, Resolver, TypeNs, ValueNs},\n     type_ref::Mutability,\n@@ -484,7 +485,9 @@ impl SourceAnalyzer {\n     ) -> Option<Macro> {\n         let ctx = LowerCtx::with_file_id(db.upcast(), macro_call.file_id);\n         let path = macro_call.value.path().and_then(|ast| Path::from_src(ast, &ctx))?;\n-        self.resolver.resolve_path_as_macro(db.upcast(), path.mod_path()?).map(|it| it.into())\n+        self.resolver\n+            .resolve_path_as_macro(db.upcast(), path.mod_path()?, Some(MacroSubNs::Bang))\n+            .map(|it| it.into())\n     }\n \n     pub(crate) fn resolve_bind_pat_to_const(\n@@ -678,7 +681,7 @@ impl SourceAnalyzer {\n                     }\n                 }\n             }\n-            return match resolve_hir_path_as_macro(db, &self.resolver, &hir_path) {\n+            return match resolve_hir_path_as_attr_macro(db, &self.resolver, &hir_path) {\n                 Some(m) => Some(PathResolution::Def(ModuleDef::Macro(m))),\n                 // this labels any path that starts with a tool module as the tool itself, this is technically wrong\n                 // but there is no benefit in differentiating these two cases for the time being\n@@ -756,7 +759,7 @@ impl SourceAnalyzer {\n         let krate = self.resolver.krate();\n         let macro_call_id = macro_call.as_call_id(db.upcast(), krate, |path| {\n             self.resolver\n-                .resolve_path_as_macro(db.upcast(), &path)\n+                .resolve_path_as_macro(db.upcast(), &path, Some(MacroSubNs::Bang))\n                 .map(|it| macro_id_to_def_id(db.upcast(), it))\n         })?;\n         Some(macro_call_id.as_file()).filter(|it| it.expansion_level(db.upcast()) < 64)\n@@ -956,12 +959,14 @@ pub(crate) fn resolve_hir_path(\n }\n \n #[inline]\n-pub(crate) fn resolve_hir_path_as_macro(\n+pub(crate) fn resolve_hir_path_as_attr_macro(\n     db: &dyn HirDatabase,\n     resolver: &Resolver,\n     path: &Path,\n ) -> Option<Macro> {\n-    resolver.resolve_path_as_macro(db.upcast(), path.mod_path()?).map(Into::into)\n+    resolver\n+        .resolve_path_as_macro(db.upcast(), path.mod_path()?, Some(MacroSubNs::Attr))\n+        .map(Into::into)\n }\n \n fn resolve_hir_path_(\n@@ -1060,7 +1065,7 @@ fn resolve_hir_path_(\n \n     let macros = || {\n         resolver\n-            .resolve_path_as_macro(db.upcast(), path.mod_path()?)\n+            .resolve_path_as_macro(db.upcast(), path.mod_path()?, None)\n             .map(|def| PathResolution::Def(ModuleDef::Macro(def.into())))\n     };\n "}]}