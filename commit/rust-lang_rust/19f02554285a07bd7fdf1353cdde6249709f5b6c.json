{"sha": "19f02554285a07bd7fdf1353cdde6249709f5b6c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5ZjAyNTU0Mjg1YTA3YmQ3ZmRmMTM1M2NkZGU2MjQ5NzA5ZjViNmM=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-08-31T17:56:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-08-31T17:56:15Z"}, "message": "Merge pull request #694 from Atul9/cargo-fmt\n\nFormat code using 'cargo fmt'", "tree": {"sha": "16e6e2f971427b701d26cf1ee4019b9b8a938988", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16e6e2f971427b701d26cf1ee4019b9b8a938988"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19f02554285a07bd7fdf1353cdde6249709f5b6c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdarS/CRBK7hj4Ov3rIwAAdHIIAFleAvoxTMq7iGioSyPV2mqw\nLGsoFf02Z7gUe84rJfhNdpK3Ffg+bhiWToYOhshwwB73Rv3UmrmXm4ZMNVanGzP4\nVyOecNjfc9rd7Wi6DhuBJSlZPpzuRl8dFNn5mL6Tfbbv1HUDQ3hdUmyjVamA7XO2\nbIrkxusRufnuxYZbKGP+NUmuI4LqnWsz7rJPHJ6y37nstMxTDO5lwMsXkfwaJhiC\ngFrPfR1FxX85N6FJqiGl1er9DxXQUYfgU7ahjdEMpT32vr1aYIhAfrFfNUjsAam5\n2U8rRQlLKJkN6QCu3QGTlqZPLNfVldGAQ907Gas0ypryvCBdadz2OfVvDKdf4Es=\n=deap\n-----END PGP SIGNATURE-----\n", "payload": "tree 16e6e2f971427b701d26cf1ee4019b9b8a938988\nparent 5b17cf208330511a0cd9b5f496075f150b7821a4\nparent f481a4b6851f619db4273199074a98b271088173\nauthor bjorn3 <bjorn3@users.noreply.github.com> 1567274175 +0200\ncommitter GitHub <noreply@github.com> 1567274175 +0200\n\nMerge pull request #694 from Atul9/cargo-fmt\n\nFormat code using 'cargo fmt'"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19f02554285a07bd7fdf1353cdde6249709f5b6c", "html_url": "https://github.com/rust-lang/rust/commit/19f02554285a07bd7fdf1353cdde6249709f5b6c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19f02554285a07bd7fdf1353cdde6249709f5b6c/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b17cf208330511a0cd9b5f496075f150b7821a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b17cf208330511a0cd9b5f496075f150b7821a4", "html_url": "https://github.com/rust-lang/rust/commit/5b17cf208330511a0cd9b5f496075f150b7821a4"}, {"sha": "f481a4b6851f619db4273199074a98b271088173", "url": "https://api.github.com/repos/rust-lang/rust/commits/f481a4b6851f619db4273199074a98b271088173", "html_url": "https://github.com/rust-lang/rust/commit/f481a4b6851f619db4273199074a98b271088173"}], "stats": {"total": 1349, "additions": 831, "deletions": 518}, "files": [{"sha": "656731eb97cce68be9c493f65d62d1dd2c2d495d", "filename": "src/abi/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Fabi%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Fabi%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fcomments.rs?ref=19f02554285a07bd7fdf1353cdde6249709f5b6c", "patch": "@@ -2,8 +2,8 @@ use std::borrow::Cow;\n \n use rustc::mir;\n \n-use crate::prelude::*;\n use crate::abi::pass_mode::*;\n+use crate::prelude::*;\n \n pub fn add_args_header_comment(fx: &mut FunctionCx<impl Backend>) {\n     fx.add_global_comment(format!("}, {"sha": "0bb422f8cc089fe7f0fc2283ba6d55abde5c12e0", "filename": "src/abi/mod.rs", "status": "modified", "additions": 84, "deletions": 62, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fmod.rs?ref=19f02554285a07bd7fdf1353cdde6249709f5b6c", "patch": "@@ -1,16 +1,20 @@\n #[cfg(debug_assertions)]\n mod comments;\n-mod returning;\n mod pass_mode;\n+mod returning;\n \n use rustc_target::spec::abi::Abi;\n \n-use crate::prelude::*;\n use self::pass_mode::*;\n+use crate::prelude::*;\n \n pub use self::returning::codegen_return;\n \n-fn clif_sig_from_fn_sig<'tcx>(tcx: TyCtxt<'tcx>, sig: FnSig<'tcx>, is_vtable_fn: bool) -> Signature {\n+fn clif_sig_from_fn_sig<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    sig: FnSig<'tcx>,\n+    is_vtable_fn: bool,\n+) -> Signature {\n     let abi = match sig.abi {\n         Abi::System => {\n             if tcx.sess.target.target.options.is_like_windows {\n@@ -47,12 +51,18 @@ fn clif_sig_from_fn_sig<'tcx>(tcx: TyCtxt<'tcx>, sig: FnSig<'tcx>, is_vtable_fn:\n             if i == 0 && is_vtable_fn {\n                 // Virtual calls turn their self param into a thin pointer.\n                 // See https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src/librustc/ty/layout.rs#L2519-L2572 for more info\n-                layout = tcx.layout_of(ParamEnv::reveal_all().and(tcx.mk_mut_ptr(tcx.mk_unit()))).unwrap();\n+                layout = tcx\n+                    .layout_of(ParamEnv::reveal_all().and(tcx.mk_mut_ptr(tcx.mk_unit())))\n+                    .unwrap();\n             }\n             get_pass_mode(tcx, layout).get_param_ty(tcx).into_iter()\n-        }).flatten();\n+        })\n+        .flatten();\n \n-    let (params, returns) = match get_pass_mode(tcx, tcx.layout_of(ParamEnv::reveal_all().and(output)).unwrap()) {\n+    let (params, returns) = match get_pass_mode(\n+        tcx,\n+        tcx.layout_of(ParamEnv::reveal_all().and(output)).unwrap(),\n+    ) {\n         PassMode::NoPass => (inputs.map(AbiParam::new).collect(), vec![]),\n         PassMode::ByVal(ret_ty) => (\n             inputs.map(AbiParam::new).collect(),\n@@ -87,7 +97,8 @@ pub fn get_function_name_and_sig<'tcx>(\n     support_vararg: bool,\n ) -> (String, Signature) {\n     assert!(!inst.substs.needs_infer() && !inst.substs.has_param_types());\n-    let fn_sig = tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), &inst.fn_sig(tcx));\n+    let fn_sig =\n+        tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), &inst.fn_sig(tcx));\n     if fn_sig.c_variadic && !support_vararg {\n         unimpl!(\"Variadic function definitions are not yet supported\");\n     }\n@@ -141,7 +152,8 @@ impl<'tcx, B: Backend + 'static> FunctionCx<'_, 'tcx, B> {\n             .module\n             .declare_func_in_func(func_id, &mut self.bcx.func);\n         let call_inst = self.bcx.ins().call(func_ref, args);\n-        #[cfg(debug_assertions)] {\n+        #[cfg(debug_assertions)]\n+        {\n             self.add_comment(call_inst, format!(\"easy_call {}\", name));\n         }\n         let results = self.bcx.inst_results(call_inst);\n@@ -185,7 +197,10 @@ impl<'tcx, B: Backend + 'static> FunctionCx<'_, 'tcx, B> {\n     }\n \n     fn self_sig(&self) -> FnSig<'tcx> {\n-        self.tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), &self.instance.fn_sig(self.tcx))\n+        self.tcx.normalize_erasing_late_bound_regions(\n+            ParamEnv::reveal_all(),\n+            &self.instance.fn_sig(self.tcx),\n+        )\n     }\n \n     fn return_layout(&self) -> TyLayout<'tcx> {\n@@ -213,10 +228,7 @@ fn local_place<'tcx>(\n     fx.local_map[&local]\n }\n \n-pub fn codegen_fn_prelude(\n-    fx: &mut FunctionCx<'_, '_, impl Backend>,\n-    start_ebb: Ebb,\n-) {\n+pub fn codegen_fn_prelude(fx: &mut FunctionCx<'_, '_, impl Backend>, start_ebb: Ebb) {\n     let ssa_analyzed = crate::analyze::analyze(fx);\n \n     #[cfg(debug_assertions)]\n@@ -250,20 +262,13 @@ pub fn codegen_fn_prelude(\n \n                 let mut params = Vec::new();\n                 for (i, arg_ty) in tupled_arg_tys.types().enumerate() {\n-                    let param = cvalue_for_param(\n-                        fx,\n-                        start_ebb,\n-                        local,\n-                        Some(i),\n-                        arg_ty,\n-                    );\n+                    let param = cvalue_for_param(fx, start_ebb, local, Some(i), arg_ty);\n                     params.push(param);\n                 }\n \n                 (local, ArgKind::Spread(params), arg_ty)\n             } else {\n-                let param =\n-                    cvalue_for_param(fx, start_ebb, local, None, arg_ty);\n+                let param = cvalue_for_param(fx, start_ebb, local, None, arg_ty);\n                 (local, ArgKind::Normal(param), arg_ty)\n             }\n         })\n@@ -354,7 +359,9 @@ pub fn codegen_terminator_call<'tcx>(\n     destination: &Option<(Place<'tcx>, BasicBlock)>,\n ) {\n     let fn_ty = fx.monomorphize(&func.ty(fx.mir, fx.tcx));\n-    let sig = fx.tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), &fn_ty.fn_sig(fx.tcx));\n+    let sig = fx\n+        .tcx\n+        .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), &fn_ty.fn_sig(fx.tcx));\n \n     let destination = destination\n         .as_ref()\n@@ -365,7 +372,13 @@ pub fn codegen_terminator_call<'tcx>(\n             ty::Instance::resolve(fx.tcx, ty::ParamEnv::reveal_all(), def_id, substs).unwrap();\n \n         if fx.tcx.symbol_name(instance).as_str().starts_with(\"llvm.\") {\n-            crate::llvm_intrinsics::codegen_llvm_intrinsic_call(fx, &fx.tcx.symbol_name(instance).as_str(), substs, args, destination);\n+            crate::llvm_intrinsics::codegen_llvm_intrinsic_call(\n+                fx,\n+                &fx.tcx.symbol_name(instance).as_str(),\n+                substs,\n+                args,\n+                destination,\n+            );\n             return;\n         }\n \n@@ -430,7 +443,9 @@ fn codegen_call_inner<'tcx>(\n     args: Vec<CValue<'tcx>>,\n     ret_place: Option<CPlace<'tcx>>,\n ) {\n-    let fn_sig = fx.tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), &fn_ty.fn_sig(fx.tcx));\n+    let fn_sig = fx\n+        .tcx\n+        .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), &fn_ty.fn_sig(fx.tcx));\n \n     let instance = match fn_ty.sty {\n         ty::FnDef(def_id, substs) => {\n@@ -453,15 +468,24 @@ fn codegen_call_inner<'tcx>(\n                 let nop_inst = fx.bcx.ins().nop();\n                 fx.add_comment(\n                     nop_inst,\n-                    format!(\"virtual call; self arg pass mode: {:?}\", get_pass_mode(fx.tcx, args[0].layout())),\n+                    format!(\n+                        \"virtual call; self arg pass mode: {:?}\",\n+                        get_pass_mode(fx.tcx, args[0].layout())\n+                    ),\n                 );\n             }\n             let (ptr, method) = crate::vtable::get_ptr_and_method_ref(fx, args[0], idx);\n             (Some(method), Single(ptr), true)\n         }\n \n         // Normal call\n-        Some(_) => (None, args.get(0).map(|arg| adjust_arg_for_abi(fx, *arg)).unwrap_or(Empty), false),\n+        Some(_) => (\n+            None,\n+            args.get(0)\n+                .map(|arg| adjust_arg_for_abi(fx, *arg))\n+                .unwrap_or(Empty),\n+            false,\n+        ),\n \n         // Indirect call\n         None => {\n@@ -474,36 +498,40 @@ fn codegen_call_inner<'tcx>(\n                 .load_scalar(fx);\n             (\n                 Some(func),\n-                args.get(0).map(|arg| adjust_arg_for_abi(fx, *arg)).unwrap_or(Empty),\n+                args.get(0)\n+                    .map(|arg| adjust_arg_for_abi(fx, *arg))\n+                    .unwrap_or(Empty),\n                 false,\n             )\n         }\n     };\n \n-    let (call_inst, call_args) = self::returning::codegen_with_call_return_arg(fx, fn_sig, ret_place, |fx, return_ptr| {\n-        let call_args: Vec<Value> = return_ptr\n-            .into_iter()\n-            .chain(first_arg.into_iter())\n-            .chain(\n-                args.into_iter()\n-                    .skip(1)\n-                    .map(|arg| adjust_arg_for_abi(fx, arg).into_iter())\n-                    .flatten(),\n-            )\n-            .collect::<Vec<_>>();\n+    let (call_inst, call_args) =\n+        self::returning::codegen_with_call_return_arg(fx, fn_sig, ret_place, |fx, return_ptr| {\n+            let call_args: Vec<Value> = return_ptr\n+                .into_iter()\n+                .chain(first_arg.into_iter())\n+                .chain(\n+                    args.into_iter()\n+                        .skip(1)\n+                        .map(|arg| adjust_arg_for_abi(fx, arg).into_iter())\n+                        .flatten(),\n+                )\n+                .collect::<Vec<_>>();\n \n-        let call_inst = if let Some(func_ref) = func_ref {\n-            let sig = fx\n-                .bcx\n-                .import_signature(clif_sig_from_fn_sig(fx.tcx, fn_sig, is_virtual_call));\n-            fx.bcx.ins().call_indirect(sig, func_ref, &call_args)\n-        } else {\n-            let func_ref = fx.get_function_ref(instance.expect(\"non-indirect call on non-FnDef type\"));\n-            fx.bcx.ins().call(func_ref, &call_args)\n-        };\n+            let call_inst = if let Some(func_ref) = func_ref {\n+                let sig =\n+                    fx.bcx\n+                        .import_signature(clif_sig_from_fn_sig(fx.tcx, fn_sig, is_virtual_call));\n+                fx.bcx.ins().call_indirect(sig, func_ref, &call_args)\n+            } else {\n+                let func_ref =\n+                    fx.get_function_ref(instance.expect(\"non-indirect call on non-FnDef type\"));\n+                fx.bcx.ins().call(func_ref, &call_args)\n+            };\n \n-        (call_inst, call_args)\n-    });\n+            (call_inst, call_args)\n+        });\n \n     // FIXME find a cleaner way to support varargs\n     if fn_sig.c_variadic {\n@@ -526,10 +554,7 @@ fn codegen_call_inner<'tcx>(\n     }\n }\n \n-pub fn codegen_drop<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n-    drop_place: CPlace<'tcx>,\n-) {\n+pub fn codegen_drop<'tcx>(fx: &mut FunctionCx<'_, 'tcx, impl Backend>, drop_place: CPlace<'tcx>) {\n     let ty = drop_place.layout().ty;\n     let drop_fn = Instance::resolve_drop_in_place(fx.tcx, ty);\n \n@@ -542,7 +567,10 @@ pub fn codegen_drop<'tcx>(\n                 let (ptr, vtable) = drop_place.to_addr_maybe_unsized(fx);\n                 let drop_fn = crate::vtable::drop_fn_of_obj(fx, vtable.unwrap());\n \n-                let fn_sig = fx.tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), &drop_fn_ty.fn_sig(fx.tcx));\n+                let fn_sig = fx.tcx.normalize_erasing_late_bound_regions(\n+                    ParamEnv::reveal_all(),\n+                    &drop_fn_ty.fn_sig(fx.tcx),\n+                );\n \n                 assert_eq!(fn_sig.output(), fx.tcx.mk_unit());\n \n@@ -564,13 +592,7 @@ pub fn codegen_drop<'tcx>(\n                 );\n                 drop_place.write_place_ref(fx, arg_place);\n                 let arg_value = arg_place.to_cvalue(fx);\n-                codegen_call_inner(\n-                    fx,\n-                    None,\n-                    drop_fn_ty,\n-                    vec![arg_value],\n-                    None,\n-                );\n+                codegen_call_inner(fx, None, drop_fn_ty, vec![arg_value], None);\n             }\n         }\n     }"}, {"sha": "64d53566dcc1ad8a64fe46d707073f22fb46a08f", "filename": "src/abi/pass_mode.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fpass_mode.rs?ref=19f02554285a07bd7fdf1353cdde6249709f5b6c", "patch": "@@ -50,14 +50,14 @@ impl<T: std::fmt::Debug> EmptySinglePair<T> {\n     pub fn assert_single(self) -> T {\n         match self {\n             Single(v) => v,\n-            _ => panic!(\"Called assert_single on {:?}\", self)\n+            _ => panic!(\"Called assert_single on {:?}\", self),\n         }\n     }\n \n     pub fn assert_pair(self) -> (T, T) {\n         match self {\n             Pair(a, b) => (a, b),\n-            _ => panic!(\"Called assert_pair on {:?}\", self)\n+            _ => panic!(\"Called assert_pair on {:?}\", self),\n         }\n     }\n }\n@@ -75,10 +75,7 @@ impl PassMode {\n     }\n }\n \n-pub fn get_pass_mode<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    layout: TyLayout<'tcx>,\n-) -> PassMode {\n+pub fn get_pass_mode<'tcx>(tcx: TyCtxt<'tcx>, layout: TyLayout<'tcx>) -> PassMode {\n     assert!(!layout.is_unsized());\n \n     if layout.is_zst() {"}, {"sha": "f827f11df350a0c8edf9e72cbc3fa09b64e56083", "filename": "src/abi/returning.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Fabi%2Freturning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Fabi%2Freturning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Freturning.rs?ref=19f02554285a07bd7fdf1353cdde6249709f5b6c", "patch": "@@ -1,5 +1,5 @@\n-use crate::prelude::*;\n use crate::abi::pass_mode::*;\n+use crate::prelude::*;\n \n pub fn codegen_return_param(\n     fx: &mut FunctionCx<impl Backend>,\n@@ -27,10 +27,8 @@ pub fn codegen_return_param(\n         }\n         PassMode::ByRef => {\n             let ret_param = fx.bcx.append_ebb_param(start_ebb, fx.pointer_type);\n-            fx.local_map.insert(\n-                RETURN_PLACE,\n-                CPlace::for_addr(ret_param, ret_layout),\n-            );\n+            fx.local_map\n+                .insert(RETURN_PLACE, CPlace::for_addr(ret_param, ret_layout));\n \n             Single(ret_param)\n         }"}, {"sha": "7b0cffcfffa1bc968f76b87ca8e5e221e48e9be3", "filename": "src/archive.rs", "status": "modified", "additions": 63, "deletions": 23, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Farchive.rs?ref=19f02554285a07bd7fdf1353cdde6249709f5b6c", "patch": "@@ -3,8 +3,8 @@ use std::path::{Path, PathBuf};\n \n use crate::prelude::*;\n \n+use rustc_codegen_ssa::back::archive::{find_library, ArchiveBuilder};\n use rustc_codegen_ssa::{METADATA_FILENAME, RLIB_BYTECODE_EXTENSION};\n-use rustc_codegen_ssa::back::archive::{ArchiveBuilder, find_library};\n \n struct ArchiveConfig<'a> {\n     sess: &'a Session,\n@@ -16,7 +16,10 @@ struct ArchiveConfig<'a> {\n \n #[derive(Debug)]\n enum ArchiveEntry {\n-    FromArchive { archive_index: usize, entry_index: usize },\n+    FromArchive {\n+        archive_index: usize,\n+        entry_index: usize,\n+    },\n     File(PathBuf),\n }\n \n@@ -50,7 +53,10 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n                 let entry = entry.unwrap();\n                 entries.push((\n                     String::from_utf8(entry.header().identifier().to_vec()).unwrap(),\n-                    ArchiveEntry::FromArchive { archive_index: 0, entry_index: i },\n+                    ArchiveEntry::FromArchive {\n+                        archive_index: 0,\n+                        entry_index: i,\n+                    },\n                 ));\n                 i += 1;\n             }\n@@ -73,7 +79,8 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n     }\n \n     fn remove_file(&mut self, name: &str) {\n-        let index = self.entries\n+        let index = self\n+            .entries\n             .iter()\n             .position(|(entry_name, _)| entry_name == name)\n             .expect(\"Tried to remove file not existing in src archive\");\n@@ -89,12 +96,23 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n \n     fn add_native_library(&mut self, name: &str) {\n         let location = find_library(name, &self.config.lib_search_paths, self.config.sess);\n-        self.add_archive(location.clone(), |_| false).unwrap_or_else(|e| {\n-            panic!(\"failed to add native library {}: {}\", location.to_string_lossy(), e);\n-        });\n+        self.add_archive(location.clone(), |_| false)\n+            .unwrap_or_else(|e| {\n+                panic!(\n+                    \"failed to add native library {}: {}\",\n+                    location.to_string_lossy(),\n+                    e\n+                );\n+            });\n     }\n \n-    fn add_rlib(&mut self, rlib: &Path, name: &str, lto: bool, skip_objects: bool) -> std::io::Result<()> {\n+    fn add_rlib(\n+        &mut self,\n+        rlib: &Path,\n+        name: &str,\n+        lto: bool,\n+        skip_objects: bool,\n+    ) -> std::io::Result<()> {\n         let obj_start = name.to_owned();\n \n         self.add_archive(rlib.to_owned(), move |fname: &str| {\n@@ -147,7 +165,10 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n         } else if self.config.use_gnu_style_archive {\n             BuilderKind::Gnu(ar::GnuBuilder::new(\n                 File::create(&self.config.dst).unwrap(),\n-                self.entries.iter().map(|(name, _)| name.as_bytes().to_vec()).collect(),\n+                self.entries\n+                    .iter()\n+                    .map(|(name, _)| name.as_bytes().to_vec())\n+                    .collect(),\n             ))\n         } else {\n             BuilderKind::Bsd(ar::Builder::new(File::create(&self.config.dst).unwrap()))\n@@ -156,8 +177,12 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n         // Add all files\n         for (entry_name, entry) in self.entries.into_iter() {\n             match entry {\n-                ArchiveEntry::FromArchive { archive_index, entry_index } => {\n-                    let (ref src_archive_path, ref mut src_archive) = self.src_archives[archive_index];\n+                ArchiveEntry::FromArchive {\n+                    archive_index,\n+                    entry_index,\n+                } => {\n+                    let (ref src_archive_path, ref mut src_archive) =\n+                        self.src_archives[archive_index];\n                     let entry = src_archive.jump_to_entry(entry_index).unwrap();\n                     let orig_header = entry.header();\n \n@@ -170,22 +195,33 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n                     header.set_mode(orig_header.mode());\n \n                     match builder {\n-                        BuilderKind::Bsd(ref mut builder) => builder.append(&header, entry).unwrap(),\n-                        BuilderKind::Gnu(ref mut builder) => builder.append(&header, entry).unwrap(),\n+                        BuilderKind::Bsd(ref mut builder) => {\n+                            builder.append(&header, entry).unwrap()\n+                        }\n+                        BuilderKind::Gnu(ref mut builder) => {\n+                            builder.append(&header, entry).unwrap()\n+                        }\n                         BuilderKind::NativeAr(archive_file) => {\n-                            Command::new(\"ar\").arg(\"x\").arg(src_archive_path).arg(&entry_name).status().unwrap();\n+                            Command::new(\"ar\")\n+                                .arg(\"x\")\n+                                .arg(src_archive_path)\n+                                .arg(&entry_name)\n+                                .status()\n+                                .unwrap();\n                             add_file_using_ar(archive_file, Path::new(&entry_name));\n                             std::fs::remove_file(entry_name).unwrap();\n                         }\n                     }\n                 }\n-                ArchiveEntry::File(file) => {\n-                    match builder {\n-                        BuilderKind::Bsd(ref mut builder) => builder.append_file(entry_name.as_bytes(), &mut File::open(file).unwrap()).unwrap(),\n-                        BuilderKind::Gnu(ref mut builder) => builder.append_file(entry_name.as_bytes(), &mut File::open(file).unwrap()).unwrap(),\n-                        BuilderKind::NativeAr(archive_file) => add_file_using_ar(archive_file, &file),\n-                    }\n-                }\n+                ArchiveEntry::File(file) => match builder {\n+                    BuilderKind::Bsd(ref mut builder) => builder\n+                        .append_file(entry_name.as_bytes(), &mut File::open(file).unwrap())\n+                        .unwrap(),\n+                    BuilderKind::Gnu(ref mut builder) => builder\n+                        .append_file(entry_name.as_bytes(), &mut File::open(file).unwrap())\n+                        .unwrap(),\n+                    BuilderKind::NativeAr(archive_file) => add_file_using_ar(archive_file, &file),\n+                },\n             }\n         }\n \n@@ -207,7 +243,8 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n \n impl<'a> ArArchiveBuilder<'a> {\n     fn add_archive<F>(&mut self, archive_path: PathBuf, mut skip: F) -> std::io::Result<()>\n-        where F: FnMut(&str) -> bool + 'static\n+    where\n+        F: FnMut(&str) -> bool + 'static,\n     {\n         let mut archive = ar::Archive::new(std::fs::File::open(&archive_path)?);\n         let archive_index = self.src_archives.len();\n@@ -219,7 +256,10 @@ impl<'a> ArArchiveBuilder<'a> {\n             if !skip(&file_name) {\n                 self.entries.push((\n                     file_name,\n-                    ArchiveEntry::FromArchive { archive_index, entry_index: i },\n+                    ArchiveEntry::FromArchive {\n+                        archive_index,\n+                        entry_index: i,\n+                    },\n                 ));\n             }\n             i += 1;"}, {"sha": "5adf9d3301b57ddb6b550cdda504824b6872e672", "filename": "src/base.rs", "status": "modified", "additions": 84, "deletions": 34, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=19f02554285a07bd7fdf1353cdde6249709f5b6c", "patch": "@@ -72,15 +72,22 @@ pub fn trans_fn<'clif, 'tcx, B: Backend + 'static>(\n     // Define function\n     let context = &mut cx.caches.context;\n     context.func = func;\n-    cx.module\n-        .define_function(func_id, context)\n-        .unwrap();\n+    cx.module.define_function(func_id, context).unwrap();\n \n-    let value_ranges = context.build_value_labels_ranges(cx.module.isa()).expect(\"value location ranges\");\n+    let value_ranges = context\n+        .build_value_labels_ranges(cx.module.isa())\n+        .expect(\"value location ranges\");\n \n     // Write optimized function to file for debugging\n     #[cfg(debug_assertions)]\n-    crate::pretty_clif::write_clif_file(cx.tcx, \"opt\", instance, &context.func, &clif_comments, Some(&value_ranges));\n+    crate::pretty_clif::write_clif_file(\n+        cx.tcx,\n+        \"opt\",\n+        instance,\n+        &context.func,\n+        &clif_comments,\n+        Some(&value_ranges),\n+    );\n \n     // Define debuginfo for function\n     let isa = cx.module.isa();\n@@ -164,7 +171,14 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Backend>) {\n                 } else {\n                     fx.bcx.ins().brz(cond, target, &[]);\n                 };\n-                trap_panic(fx, format!(\"[panic] Assert {:?} at {:?} failed.\", msg, bb_data.terminator().source_info.span));\n+                trap_panic(\n+                    fx,\n+                    format!(\n+                        \"[panic] Assert {:?} at {:?} failed.\",\n+                        msg,\n+                        bb_data.terminator().source_info.span\n+                    ),\n+                );\n             }\n \n             TerminatorKind::SwitchInt {\n@@ -272,7 +286,8 @@ fn trans_stmt<'tcx>(\n                     let rhs = trans_operand(fx, rhs);\n \n                     let res = if !fx.tcx.sess.overflow_checks() {\n-                        let val = crate::num::trans_int_binop(fx, *bin_op, lhs, rhs).load_scalar(fx);\n+                        let val =\n+                            crate::num::trans_int_binop(fx, *bin_op, lhs, rhs).load_scalar(fx);\n                         let is_overflow = fx.bcx.ins().iconst(types::I8, 0);\n                         CValue::by_val_pair(val, is_overflow, lval.layout())\n                     } else {\n@@ -293,9 +308,7 @@ fn trans_stmt<'tcx>(\n                                     let res = fx.bcx.ins().icmp_imm(IntCC::Equal, val, 0);\n                                     fx.bcx.ins().bint(types::I8, res)\n                                 }\n-                                ty::Uint(_) | ty::Int(_) => {\n-                                    fx.bcx.ins().bnot(val)\n-                                }\n+                                ty::Uint(_) | ty::Int(_) => fx.bcx.ins().bnot(val),\n                                 _ => unimplemented!(\"un op Not for {:?}\", layout.ty),\n                             }\n                         }\n@@ -304,7 +317,12 @@ fn trans_stmt<'tcx>(\n                                 let clif_ty = fx.clif_type(layout.ty).unwrap();\n                                 if clif_ty == types::I128 {\n                                     // FIXME implement it\n-                                    crate::trap::trap_unreachable_ret_value(fx, layout, \"i128 neg is not yet supported\").load_scalar(fx)\n+                                    crate::trap::trap_unreachable_ret_value(\n+                                        fx,\n+                                        layout,\n+                                        \"i128 neg is not yet supported\",\n+                                    )\n+                                    .load_scalar(fx)\n                                 } else {\n                                     let zero = fx.bcx.ins().iconst(clif_ty, 0);\n                                     fx.bcx.ins().isub(zero, val)\n@@ -343,10 +361,19 @@ fn trans_stmt<'tcx>(\n                     let operand = trans_operand(fx, operand);\n                     let from_ty = operand.layout().ty;\n \n-                    fn is_fat_ptr<'tcx>(fx: &FunctionCx<'_, 'tcx, impl Backend>, ty: Ty<'tcx>) -> bool {\n-                        ty\n-                            .builtin_deref(true)\n-                            .map(|ty::TypeAndMut {ty: pointee_ty, mutbl: _ }| fx.layout_of(pointee_ty).is_unsized())\n+                    fn is_fat_ptr<'tcx>(\n+                        fx: &FunctionCx<'_, 'tcx, impl Backend>,\n+                        ty: Ty<'tcx>,\n+                    ) -> bool {\n+                        ty.builtin_deref(true)\n+                            .map(\n+                                |ty::TypeAndMut {\n+                                     ty: pointee_ty,\n+                                     mutbl: _,\n+                                 }| {\n+                                    fx.layout_of(pointee_ty).is_unsized()\n+                                },\n+                            )\n                             .unwrap_or(false)\n                     }\n \n@@ -363,17 +390,27 @@ fn trans_stmt<'tcx>(\n                         // enum -> discriminant value\n                         assert!(adt_def.is_enum());\n                         match to_ty.sty {\n-                            ty::Uint(_) | ty::Int(_) => {},\n+                            ty::Uint(_) | ty::Int(_) => {}\n                             _ => unreachable!(\"cast adt {} -> {}\", from_ty, to_ty),\n                         }\n \n-                        let discr = crate::discriminant::codegen_get_discriminant(fx, operand, fx.layout_of(to_ty));\n+                        let discr = crate::discriminant::codegen_get_discriminant(\n+                            fx,\n+                            operand,\n+                            fx.layout_of(to_ty),\n+                        );\n                         lval.write_cvalue(fx, discr);\n                     } else {\n                         let to_clif_ty = fx.clif_type(to_ty).unwrap();\n                         let from = operand.load_scalar(fx);\n \n-                        let res = clif_int_or_float_cast(fx, from, type_sign(from_ty), to_clif_ty, type_sign(to_ty));\n+                        let res = clif_int_or_float_cast(\n+                            fx,\n+                            from,\n+                            type_sign(from_ty),\n+                            to_clif_ty,\n+                            type_sign(to_ty),\n+                        );\n                         lval.write_cvalue(fx, CValue::by_val(res, dest_layout));\n                     }\n                 }\n@@ -391,9 +428,7 @@ fn trans_stmt<'tcx>(\n                             let func_addr = fx.bcx.ins().func_addr(fx.pointer_type, func_ref);\n                             lval.write_cvalue(fx, CValue::by_val(func_addr, lval.layout()));\n                         }\n-                        _ => {\n-                            bug!(\"{} cannot be cast to a fn ptr\", operand.layout().ty)\n-                        }\n+                        _ => bug!(\"{} cannot be cast to a fn ptr\", operand.layout().ty),\n                     }\n                 }\n                 Rvalue::Cast(CastKind::Pointer(PointerCast::Unsize), operand, _ty) => {\n@@ -403,7 +438,8 @@ fn trans_stmt<'tcx>(\n                 Rvalue::Discriminant(place) => {\n                     let place = trans_place(fx, place);\n                     let value = place.to_cvalue(fx);\n-                    let discr = crate::discriminant::codegen_get_discriminant(fx, value, dest_layout);\n+                    let discr =\n+                        crate::discriminant::codegen_get_discriminant(fx, value, dest_layout);\n                     lval.write_cvalue(fx, discr);\n                 }\n                 Rvalue::Repeat(operand, times) => {\n@@ -478,23 +514,30 @@ fn trans_stmt<'tcx>(\n \n         StatementKind::InlineAsm(asm) => {\n             use syntax::ast::Name;\n-            let InlineAsm { asm, outputs: _, inputs: _ } = &**asm;\n+            let InlineAsm {\n+                asm,\n+                outputs: _,\n+                inputs: _,\n+            } = &**asm;\n             let rustc::hir::InlineAsm {\n                 asm: asm_code, // Name\n-                outputs, // Vec<Name>\n-                inputs, // Vec<Name>\n-                clobbers, // Vec<Name>\n-                volatile, // bool\n-                alignstack, // bool\n-                dialect: _, // syntax::ast::AsmDialect\n+                outputs,       // Vec<Name>\n+                inputs,        // Vec<Name>\n+                clobbers,      // Vec<Name>\n+                volatile,      // bool\n+                alignstack,    // bool\n+                dialect: _,    // syntax::ast::AsmDialect\n                 asm_str_style: _,\n             } = asm;\n             match &*asm_code.as_str() {\n                 \"cpuid\" | \"cpuid\\n\" => {\n                     assert_eq!(inputs, &[Name::intern(\"{eax}\"), Name::intern(\"{ecx}\")]);\n \n                     assert_eq!(outputs.len(), 4);\n-                    for (i, c) in (&[\"={eax}\", \"={ebx}\", \"={ecx}\", \"={edx}\"]).iter().enumerate() {\n+                    for (i, c) in (&[\"={eax}\", \"={ebx}\", \"={ecx}\", \"={edx}\"])\n+                        .iter()\n+                        .enumerate()\n+                    {\n                         assert_eq!(&outputs[i].constraint.as_str(), c);\n                         assert!(!outputs[i].is_rw);\n                         assert!(!outputs[i].is_indirect);\n@@ -505,7 +548,10 @@ fn trans_stmt<'tcx>(\n                     assert!(!volatile);\n                     assert!(!alignstack);\n \n-                    crate::trap::trap_unimplemented(fx, \"__cpuid_count arch intrinsic is not supported\");\n+                    crate::trap::trap_unimplemented(\n+                        fx,\n+                        \"__cpuid_count arch intrinsic is not supported\",\n+                    );\n                 }\n                 \"xgetbv\" => {\n                     assert_eq!(inputs, &[Name::intern(\"{ecx}\")]);\n@@ -565,7 +611,7 @@ pub fn trans_place<'tcx>(\n                 let instance = Instance::new(static_.def_id, fx.monomorphize(&substs));\n                 crate::constant::trans_promoted(fx, instance, promoted, static_.ty)\n             }\n-        }\n+        },\n     };\n \n     trans_place_projection(fx, base, &place.projection)\n@@ -615,7 +661,9 @@ pub fn trans_place_projection<'tcx>(\n                     let len = crate::constant::force_eval_const(fx, len)\n                         .eval_usize(fx.tcx, ParamEnv::reveal_all());\n                     CPlace::for_addr(\n-                        fx.bcx.ins().iadd_imm(ptr, elem_layout.size.bytes() as i64 * from as i64),\n+                        fx.bcx\n+                            .ins()\n+                            .iadd_imm(ptr, elem_layout.size.bytes() as i64 * from as i64),\n                         fx.layout_of(fx.tcx.mk_array(elem_ty, len - from as u64 - to as u64)),\n                     )\n                 }\n@@ -624,7 +672,9 @@ pub fn trans_place_projection<'tcx>(\n                     let (ptr, len) = base.to_addr_maybe_unsized(fx);\n                     let len = len.unwrap();\n                     CPlace::for_addr_with_extra(\n-                        fx.bcx.ins().iadd_imm(ptr, elem_layout.size.bytes() as i64 * from as i64),\n+                        fx.bcx\n+                            .ins()\n+                            .iadd_imm(ptr, elem_layout.size.bytes() as i64 * from as i64),\n                         fx.bcx.ins().iadd_imm(len, -(from as i64 + to as i64)),\n                         base.layout(),\n                     )"}, {"sha": "41503ea86c835bbe4108c042f80b07762e125a19", "filename": "src/cast.rs", "status": "modified", "additions": 28, "deletions": 48, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcast.rs?ref=19f02554285a07bd7fdf1353cdde6249709f5b6c", "patch": "@@ -40,9 +40,7 @@ pub fn clif_intcast(\n                 fx.bcx.ins().ireduce(to, lsb)\n             }\n         }\n-        (_, _) => {\n-            fx.bcx.ins().ireduce(to, val)\n-        }\n+        (_, _) => fx.bcx.ins().ireduce(to, val),\n     }\n }\n \n@@ -71,13 +69,10 @@ pub fn clif_int_or_float_cast(\n             // __floatuntisf: u128 -> f32\n             // __floatuntidf: u128 -> f64\n \n-            let name = format!(\"__float{sign}ti{flt}f\",\n-                sign=if from_signed {\n-                    \"\"\n-                } else {\n-                    \"un\"\n-                },\n-                flt=match to_ty {\n+            let name = format!(\n+                \"__float{sign}ti{flt}f\",\n+                sign = if from_signed { \"\" } else { \"un\" },\n+                flt = match to_ty {\n                     types::F32 => \"s\",\n                     types::F64 => \"d\",\n                     _ => unreachable!(\"{:?}\", to_ty),\n@@ -96,11 +91,13 @@ pub fn clif_int_or_float_cast(\n                 _ => unreachable!(),\n             };\n \n-            return fx.easy_call(\n-                &name,\n-                &[CValue::by_val(from, fx.layout_of(from_rust_ty))],\n-                to_rust_ty,\n-            ).load_scalar(fx);\n+            return fx\n+                .easy_call(\n+                    &name,\n+                    &[CValue::by_val(from, fx.layout_of(from_rust_ty))],\n+                    to_rust_ty,\n+                )\n+                .load_scalar(fx);\n         }\n \n         // int-like -> float\n@@ -117,13 +114,10 @@ pub fn clif_int_or_float_cast(\n             // __fixunssfti: f32 -> u128\n             // __fixunsdfti: f64 -> u128\n \n-            let name = format!(\"__fix{sign}{flt}fti\",\n-                sign=if to_signed {\n-                    \"\"\n-                } else {\n-                    \"uns\"\n-                },\n-                flt=match from_ty {\n+            let name = format!(\n+                \"__fix{sign}{flt}fti\",\n+                sign = if to_signed { \"\" } else { \"uns\" },\n+                flt = match from_ty {\n                     types::F32 => \"s\",\n                     types::F64 => \"d\",\n                     _ => unreachable!(\"{:?}\", to_ty),\n@@ -142,11 +136,13 @@ pub fn clif_int_or_float_cast(\n                 fx.tcx.types.u128\n             };\n \n-            return fx.easy_call(\n-                &name,\n-                &[CValue::by_val(from, fx.layout_of(from_rust_ty))],\n-                to_rust_ty,\n-            ).load_scalar(fx);\n+            return fx\n+                .easy_call(\n+                    &name,\n+                    &[CValue::by_val(from, fx.layout_of(from_rust_ty))],\n+                    to_rust_ty,\n+                )\n+                .load_scalar(fx);\n         }\n \n         // float -> int-like\n@@ -162,24 +158,12 @@ pub fn clif_int_or_float_cast(\n             let max_val = fx.bcx.ins().iconst(types::I32, max);\n \n             let val = if to_signed {\n-                let has_underflow = fx.bcx.ins().icmp_imm(\n-                    IntCC::SignedLessThan,\n-                    val,\n-                    min,\n-                );\n-                let has_overflow = fx.bcx.ins().icmp_imm(\n-                    IntCC::SignedGreaterThan,\n-                    val,\n-                    max,\n-                );\n+                let has_underflow = fx.bcx.ins().icmp_imm(IntCC::SignedLessThan, val, min);\n+                let has_overflow = fx.bcx.ins().icmp_imm(IntCC::SignedGreaterThan, val, max);\n                 let bottom_capped = fx.bcx.ins().select(has_underflow, min_val, val);\n                 fx.bcx.ins().select(has_overflow, max_val, bottom_capped)\n             } else {\n-                let has_overflow = fx.bcx.ins().icmp_imm(\n-                    IntCC::UnsignedGreaterThan,\n-                    val,\n-                    max,\n-                );\n+                let has_overflow = fx.bcx.ins().icmp_imm(IntCC::UnsignedGreaterThan, val, max);\n                 fx.bcx.ins().select(has_overflow, max_val, val)\n             };\n             fx.bcx.ins().ireduce(to_ty, val)\n@@ -193,12 +177,8 @@ pub fn clif_int_or_float_cast(\n     } else if from_ty.is_float() && to_ty.is_float() {\n         // float -> float\n         match (from_ty, to_ty) {\n-            (types::F32, types::F64) => {\n-                fx.bcx.ins().fpromote(types::F64, from)\n-            }\n-            (types::F64, types::F32) => {\n-                fx.bcx.ins().fdemote(types::F32, from)\n-            }\n+            (types::F32, types::F64) => fx.bcx.ins().fpromote(types::F64, from),\n+            (types::F64, types::F32) => fx.bcx.ins().fdemote(types::F32, from),\n             _ => from,\n         }\n     } else {"}, {"sha": "6653b4e2d91f558fb389ce98e0a4d05e2986da15", "filename": "src/codegen_i128.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Fcodegen_i128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Fcodegen_i128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcodegen_i128.rs?ref=19f02554285a07bd7fdf1353cdde6249709f5b6c", "patch": "@@ -30,15 +30,15 @@ pub fn maybe_codegen<'tcx>(\n                 fx.easy_call(\"__rust_i128_addo\", &[lhs, rhs], out_ty)\n             } else {\n                 fx.easy_call(\"__rust_u128_addo\", &[lhs, rhs], out_ty)\n-            })\n+            });\n         }\n         BinOp::Sub => {\n             let out_ty = fx.tcx.mk_tup([lhs.layout().ty, fx.tcx.types.bool].iter());\n             return Some(if is_signed {\n                 fx.easy_call(\"__rust_i128_subo\", &[lhs, rhs], out_ty)\n             } else {\n                 fx.easy_call(\"__rust_u128_subo\", &[lhs, rhs], out_ty)\n-            })\n+            });\n         }\n         BinOp::Offset => unreachable!(\"offset should only be used on pointers, not 128bit ints\"),\n         BinOp::Mul => {\n@@ -50,7 +50,11 @@ pub fn maybe_codegen<'tcx>(\n                     fx.easy_call(\"__rust_u128_mulo\", &[lhs, rhs], out_ty)\n                 }\n             } else {\n-                let val_ty = if is_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 };\n+                let val_ty = if is_signed {\n+                    fx.tcx.types.i128\n+                } else {\n+                    fx.tcx.types.u128\n+                };\n                 fx.easy_call(\"__multi3\", &[lhs, rhs], val_ty)\n             };\n             return Some(res);\n@@ -111,17 +115,21 @@ pub fn maybe_codegen<'tcx>(\n                         Some(CValue::by_val(val, fx.layout_of(fx.tcx.types.i128)))\n                     }\n                     (BinOp::Shl, _) => {\n-                        let val_ty = if is_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 };\n+                        let val_ty = if is_signed {\n+                            fx.tcx.types.i128\n+                        } else {\n+                            fx.tcx.types.u128\n+                        };\n                         let val = fx.bcx.ins().iconcat(all_zeros, lhs_lsb);\n                         Some(CValue::by_val(val, fx.layout_of(val_ty)))\n                     }\n-                    _ => None\n+                    _ => None,\n                 };\n                 if let Some(val) = val {\n                     if let Some(is_overflow) = is_overflow {\n                         let out_ty = fx.tcx.mk_tup([lhs.layout().ty, fx.tcx.types.bool].iter());\n                         let val = val.load_scalar(fx);\n-                        return Some(CValue::by_val_pair(val, is_overflow, fx.layout_of(out_ty)))\n+                        return Some(CValue::by_val_pair(val, is_overflow, fx.layout_of(out_ty)));\n                     } else {\n                         return Some(val);\n                     }"}, {"sha": "67af9506b79e9ab76cf9afd9526aba13314ae673", "filename": "src/common.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=19f02554285a07bd7fdf1353cdde6249709f5b6c", "patch": "@@ -1,7 +1,7 @@\n use rustc::ty::layout::{FloatTy, Integer, Primitive};\n use rustc_target::spec::{HasTargetSpec, Target};\n \n-use cranelift::codegen::ir::{Opcode, InstructionData, ValueDef};\n+use cranelift::codegen::ir::{InstructionData, Opcode, ValueDef};\n \n use crate::prelude::*;\n \n@@ -35,10 +35,7 @@ pub fn scalar_to_clif_type(tcx: TyCtxt, scalar: Scalar) -> Type {\n     }\n }\n \n-pub fn clif_type_from_ty<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    ty: Ty<'tcx>,\n-) -> Option<types::Type> {\n+pub fn clif_type_from_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Option<types::Type> {\n     Some(match ty.sty {\n         ty::Bool => types::I8,\n         ty::Uint(size) => match size {\n@@ -184,7 +181,8 @@ fn resolve_normal_value_imm(func: &Function, val: Value) -> Option<i64> {\n         if let InstructionData::UnaryImm {\n             opcode: Opcode::Iconst,\n             imm,\n-        } = func.dfg[inst] {\n+        } = func.dfg[inst]\n+        {\n             Some(imm.into())\n         } else {\n             None\n@@ -199,7 +197,8 @@ fn resolve_128bit_value_imm(func: &Function, val: Value) -> Option<u128> {\n         if let InstructionData::Binary {\n             opcode: Opcode::Iconcat,\n             args: [lsb, msb],\n-        } = func.dfg[inst] {\n+        } = func.dfg[inst]\n+        {\n             (lsb, msb)\n         } else {\n             return None;\n@@ -225,10 +224,9 @@ pub fn resolve_value_imm(func: &Function, val: Value) -> Option<u128> {\n pub fn type_min_max_value(ty: Type, signed: bool) -> (i64, i64) {\n     assert!(ty.is_int());\n     let min = match (ty, signed) {\n-        (types::I8 , false)\n-        | (types::I16, false)\n-        | (types::I32, false)\n-        | (types::I64, false) => 0i64,\n+        (types::I8, false) | (types::I16, false) | (types::I32, false) | (types::I64, false) => {\n+            0i64\n+        }\n         (types::I8, true) => i8::min_value() as i64,\n         (types::I16, true) => i16::min_value() as i64,\n         (types::I32, true) => i32::min_value() as i64,\n@@ -287,11 +285,14 @@ impl<'tcx, B: Backend> LayoutOf for FunctionCx<'_, 'tcx, B> {\n \n     fn layout_of(&self, ty: Ty<'tcx>) -> TyLayout<'tcx> {\n         let ty = self.monomorphize(&ty);\n-        self.tcx.layout_of(ParamEnv::reveal_all().and(&ty))\n-            .unwrap_or_else(|e| if let layout::LayoutError::SizeOverflow(_) = e {\n-                self.tcx.sess.fatal(&e.to_string())\n-            } else {\n-                bug!(\"failed to get layout for `{}`: {}\", ty, e)\n+        self.tcx\n+            .layout_of(ParamEnv::reveal_all().and(&ty))\n+            .unwrap_or_else(|e| {\n+                if let layout::LayoutError::SizeOverflow(_) = e {\n+                    self.tcx.sess.fatal(&e.to_string())\n+                } else {\n+                    bug!(\"failed to get layout for `{}`: {}\", ty, e)\n+                }\n             })\n     }\n }"}, {"sha": "1397758c27660c0503e74b87d58c6941cc961d81", "filename": "src/constant.rs", "status": "modified", "additions": 75, "deletions": 54, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconstant.rs?ref=19f02554285a07bd7fdf1353cdde6249709f5b6c", "patch": "@@ -1,12 +1,11 @@\n use std::borrow::Cow;\n \n use rustc::mir::interpret::{\n-    read_target_uint, AllocId, GlobalAlloc, Allocation, ConstValue, InterpResult, GlobalId, Scalar,\n+    read_target_uint, AllocId, Allocation, ConstValue, GlobalAlloc, GlobalId, InterpResult, Scalar,\n };\n-use rustc::ty::{Const, layout::Align};\n+use rustc::ty::{layout::Align, Const};\n use rustc_mir::interpret::{\n-    InterpCx, ImmTy, Machine, Memory, MemoryKind, OpTy, PlaceTy, Pointer,\n-    StackPopCleanup,\n+    ImmTy, InterpCx, Machine, Memory, MemoryKind, OpTy, PlaceTy, Pointer, StackPopCleanup,\n };\n \n use cranelift_module::*;\n@@ -26,11 +25,7 @@ enum TodoItem {\n }\n \n impl ConstantCx {\n-    pub fn finalize(\n-        mut self,\n-        tcx: TyCtxt<'_>,\n-        module: &mut Module<impl Backend>,\n-    ) {\n+    pub fn finalize(mut self, tcx: TyCtxt<'_>, module: &mut Module<impl Backend>) {\n         //println!(\"todo {:?}\", self.todo);\n         define_all_allocs(tcx, module, &mut self);\n         //println!(\"done {:?}\", self.done);\n@@ -58,25 +53,20 @@ pub fn trans_promoted<'tcx>(\n     promoted: Promoted,\n     dest_ty: Ty<'tcx>,\n ) -> CPlace<'tcx> {\n-    match fx\n-        .tcx\n-        .const_eval(ParamEnv::reveal_all().and(GlobalId {\n-            instance,\n-            promoted: Some(promoted),\n-        }))\n-    {\n+    match fx.tcx.const_eval(ParamEnv::reveal_all().and(GlobalId {\n+        instance,\n+        promoted: Some(promoted),\n+    })) {\n         Ok(const_) => {\n             let cplace = trans_const_place(fx, const_);\n             debug_assert_eq!(cplace.layout(), fx.layout_of(dest_ty));\n             cplace\n         }\n-        Err(_) => {\n-            crate::trap::trap_unreachable_ret_place(\n-                fx,\n-                fx.layout_of(dest_ty),\n-                \"[panic] Tried to get value of promoted value with errored during const eval.\",\n-            )\n-        }\n+        Err(_) => crate::trap::trap_unreachable_ret_place(\n+            fx,\n+            fx.layout_of(dest_ty),\n+            \"[panic] Tried to get value of promoted value with errored during const eval.\",\n+        ),\n     }\n }\n \n@@ -120,13 +110,23 @@ pub fn trans_const_value<'tcx>(\n         }\n         ty::Int(_) => {\n             let bits = const_.val.try_to_bits(layout.size).unwrap();\n-            CValue::const_val(fx, ty, rustc::mir::interpret::sign_extend(bits, layout.size))\n+            CValue::const_val(\n+                fx,\n+                ty,\n+                rustc::mir::interpret::sign_extend(bits, layout.size),\n+            )\n         }\n         ty::Float(fty) => {\n             let bits = const_.val.try_to_bits(layout.size).unwrap();\n             let val = match fty {\n-                FloatTy::F32 => fx.bcx.ins().f32const(Ieee32::with_bits(u32::try_from(bits).unwrap())),\n-                FloatTy::F64 => fx.bcx.ins().f64const(Ieee64::with_bits(u64::try_from(bits).unwrap())),\n+                FloatTy::F32 => fx\n+                    .bcx\n+                    .ins()\n+                    .f32const(Ieee32::with_bits(u32::try_from(bits).unwrap())),\n+                FloatTy::F64 => fx\n+                    .bcx\n+                    .ins()\n+                    .f64const(Ieee64::with_bits(u64::try_from(bits).unwrap())),\n             };\n             CValue::by_val(val, layout)\n         }\n@@ -170,7 +170,9 @@ fn trans_const_place<'tcx>(\n         )?;\n         let ptr = ecx.allocate(op.layout, MemoryKind::Stack);\n         ecx.copy_op(op, ptr.into())?;\n-        let alloc = ecx.memory().get(ptr.to_ref().to_scalar()?.to_ptr()?.alloc_id)?;\n+        let alloc = ecx\n+            .memory()\n+            .get(ptr.to_ref().to_scalar()?.to_ptr()?.alloc_id)?;\n         Ok(fx.tcx.intern_const_alloc(alloc.clone()))\n     };\n     let alloc = result().expect(\"unable to convert ConstValue to Allocation\");\n@@ -182,9 +184,18 @@ fn trans_const_place<'tcx>(\n     cplace_for_dataid(fx, const_.ty, data_id)\n }\n \n-fn data_id_for_alloc_id<B: Backend>(module: &mut Module<B>, alloc_id: AllocId, align: Align) -> DataId {\n+fn data_id_for_alloc_id<B: Backend>(\n+    module: &mut Module<B>,\n+    alloc_id: AllocId,\n+    align: Align,\n+) -> DataId {\n     module\n-        .declare_data(&format!(\"__alloc_{}\", alloc_id.0), Linkage::Local, false, Some(align.bytes() as u8))\n+        .declare_data(\n+            &format!(\"__alloc_{}\", alloc_id.0),\n+            Linkage::Local,\n+            false,\n+            Some(align.bytes() as u8),\n+        )\n         .unwrap()\n }\n \n@@ -202,16 +213,29 @@ fn data_id_for_static(\n     } else {\n         !ty.is_freeze(tcx, ParamEnv::reveal_all(), DUMMY_SP)\n     };\n-    let align = tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap().align.pref.bytes();\n+    let align = tcx\n+        .layout_of(ParamEnv::reveal_all().and(ty))\n+        .unwrap()\n+        .align\n+        .pref\n+        .bytes();\n \n     let data_id = module\n-        .declare_data(&*symbol_name, linkage, is_mutable, Some(align.try_into().unwrap()))\n+        .declare_data(\n+            &*symbol_name,\n+            linkage,\n+            is_mutable,\n+            Some(align.try_into().unwrap()),\n+        )\n         .unwrap();\n \n     if linkage == Linkage::Preemptible {\n         if let ty::RawPtr(_) = ty.sty {\n         } else {\n-            tcx.sess.span_fatal(tcx.def_span(def_id), \"must have type `*const T` or `*mut T` due to `#[linkage]` attribute\")\n+            tcx.sess.span_fatal(\n+                tcx.def_span(def_id),\n+                \"must have type `*const T` or `*mut T` due to `#[linkage]` attribute\",\n+            )\n         }\n \n         let mut data_ctx = DataContext::new();\n@@ -243,11 +267,7 @@ fn cplace_for_dataid<'tcx>(\n     CPlace::for_addr(global_ptr, layout)\n }\n \n-fn define_all_allocs(\n-    tcx: TyCtxt<'_>,\n-    module: &mut Module<impl Backend>,\n-    cx: &mut ConstantCx,\n-) {\n+fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut Module<impl Backend>, cx: &mut ConstantCx) {\n     let memory = Memory::<TransPlaceInterpreter>::new(tcx.at(DUMMY_SP), ());\n \n     while let Some(todo_item) = pop_set(&mut cx.todo) {\n@@ -277,11 +297,16 @@ fn define_all_allocs(\n                     _ => bug!(\"static const eval returned {:#?}\", const_),\n                 };\n \n-                let data_id = data_id_for_static(tcx, module, def_id, if tcx.is_reachable_non_generic(def_id) {\n-                    Linkage::Export\n-                } else {\n-                    Linkage::Local\n-                });\n+                let data_id = data_id_for_static(\n+                    tcx,\n+                    module,\n+                    def_id,\n+                    if tcx.is_reachable_non_generic(def_id) {\n+                        Linkage::Export\n+                    } else {\n+                        Linkage::Local\n+                    },\n+                );\n                 (data_id, alloc)\n             }\n         };\n@@ -395,10 +420,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for TransPlaceInterpreter {\n         panic!();\n     }\n \n-    fn find_foreign_static(\n-        _: TyCtxt<'tcx>,\n-        _: DefId,\n-    ) -> InterpResult<'tcx, Cow<'tcx, Allocation>> {\n+    fn find_foreign_static(_: TyCtxt<'tcx>, _: DefId) -> InterpResult<'tcx, Cow<'tcx, Allocation>> {\n         panic!();\n     }\n \n@@ -411,10 +433,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for TransPlaceInterpreter {\n         panic!();\n     }\n \n-    fn ptr_to_int(\n-        _: &Memory<'mir, 'tcx, Self>,\n-        _: Pointer<()>,\n-    ) -> InterpResult<'tcx, u64> {\n+    fn ptr_to_int(_: &Memory<'mir, 'tcx, Self>, _: Pointer<()>) -> InterpResult<'tcx, u64> {\n         panic!();\n     }\n \n@@ -473,10 +492,12 @@ pub fn mir_operand_get_const_val<'tcx>(\n         StaticKind::Static => unimplemented!(),\n         StaticKind::Promoted(promoted, substs) => {\n             let instance = Instance::new(static_.def_id, fx.monomorphize(substs));\n-            fx.tcx.const_eval(ParamEnv::reveal_all().and(GlobalId {\n-                instance,\n-                promoted: Some(*promoted),\n-            })).unwrap()\n+            fx.tcx\n+                .const_eval(ParamEnv::reveal_all().and(GlobalId {\n+                    instance,\n+                    promoted: Some(*promoted),\n+                }))\n+                .unwrap()\n         }\n     })\n }"}, {"sha": "0ded96cec8a588cad7644ab713e2936f83ef5045", "filename": "src/debuginfo.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo.rs?ref=19f02554285a07bd7fdf1353cdde6249709f5b6c", "patch": "@@ -30,11 +30,7 @@ fn line_program_add_file(\n         FileName::Real(path) => {\n             let dir_name = path.parent().unwrap().to_str().unwrap().as_bytes();\n             let dir_id = if !dir_name.is_empty() {\n-                let dir_name = LineString::new(\n-                    dir_name,\n-                    line_program.encoding(),\n-                    line_strings,\n-                );\n+                let dir_name = LineString::new(dir_name, line_program.encoding(), line_strings);\n                 line_program.add_directory(dir_name)\n             } else {\n                 line_program.default_directory()\n@@ -196,7 +192,11 @@ impl<'tcx> DebugContext<'tcx> {\n         let _: Result<()> = sections.for_each_mut(|id, section| {\n             if !section.writer.slice().is_empty() {\n                 artifact\n-                    .declare_with(id.name(), Decl::section(SectionKind::Debug), section.writer.take())\n+                    .declare_with(\n+                        id.name(),\n+                        Decl::section(SectionKind::Debug),\n+                        section.writer.take(),\n+                    )\n                     .unwrap();\n             }\n             Ok(())"}, {"sha": "ccc474401b62f7f2227b5a205b50b88504f0a1e6", "filename": "src/discriminant.rs", "status": "modified", "additions": 35, "deletions": 22, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Fdiscriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Fdiscriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiscriminant.rs?ref=19f02554285a07bd7fdf1353cdde6249709f5b6c", "patch": "@@ -33,11 +33,12 @@ pub fn codegen_set_discriminant<'tcx>(\n         layout::Variants::Multiple {\n             discr: _,\n             discr_index,\n-            discr_kind: layout::DiscriminantKind::Niche {\n-                dataful_variant,\n-                ref niche_variants,\n-                niche_start,\n-            },\n+            discr_kind:\n+                layout::DiscriminantKind::Niche {\n+                    dataful_variant,\n+                    ref niche_variants,\n+                    niche_start,\n+                },\n             variants: _,\n         } => {\n             if variant_index != dataful_variant {\n@@ -59,7 +60,11 @@ pub fn codegen_get_discriminant<'tcx>(\n     let layout = value.layout();\n \n     if layout.abi == layout::Abi::Uninhabited {\n-        return trap_unreachable_ret_value(fx, dest_layout, \"[panic] Tried to get discriminant for uninhabited type.\");\n+        return trap_unreachable_ret_value(\n+            fx,\n+            dest_layout,\n+            \"[panic] Tried to get discriminant for uninhabited type.\",\n+        );\n     }\n \n     let (discr_scalar, discr_index, discr_kind) = match &layout.variants {\n@@ -70,9 +75,12 @@ pub fn codegen_get_discriminant<'tcx>(\n                 .map_or(u128::from(index.as_u32()), |discr| discr.val);\n             return CValue::const_val(fx, dest_layout.ty, discr_val);\n         }\n-        layout::Variants::Multiple { discr, discr_index, discr_kind, variants: _ } => {\n-            (discr, *discr_index, discr_kind)\n-        }\n+        layout::Variants::Multiple {\n+            discr,\n+            discr_index,\n+            discr_kind,\n+            variants: _,\n+        } => (discr, *discr_index, discr_kind),\n     };\n \n     let cast_to = fx.clif_type(dest_layout.ty).unwrap();\n@@ -86,7 +94,7 @@ pub fn codegen_get_discriminant<'tcx>(\n         layout::DiscriminantKind::Tag => {\n             let signed = match discr_scalar.value {\n                 layout::Int(_, signed) => signed,\n-                _ => false\n+                _ => false,\n             };\n             let val = clif_intcast(fx, encoded_discr, cast_to, signed);\n             return CValue::by_val(val, dest_layout);\n@@ -112,11 +120,18 @@ pub fn codegen_get_discriminant<'tcx>(\n                 encoded_discr\n             } else {\n                 // FIXME handle niche_start > i64::max_value()\n-                fx.bcx.ins().iadd_imm(encoded_discr, -i64::try_from(niche_start).unwrap())\n+                fx.bcx\n+                    .ins()\n+                    .iadd_imm(encoded_discr, -i64::try_from(niche_start).unwrap())\n             };\n             let relative_max = niche_variants.end().as_u32() - niche_variants.start().as_u32();\n             let is_niche = {\n-                codegen_icmp_imm(fx, IntCC::UnsignedLessThanOrEqual, relative_discr, i128::from(relative_max))\n+                codegen_icmp_imm(\n+                    fx,\n+                    IntCC::UnsignedLessThanOrEqual,\n+                    relative_discr,\n+                    i128::from(relative_max),\n+                )\n             };\n \n             // NOTE(eddyb) this addition needs to be performed on the final\n@@ -135,18 +150,16 @@ pub fn codegen_get_discriminant<'tcx>(\n                 } else {\n                     clif_intcast(fx, relative_discr, cast_to, false)\n                 };\n-                fx.bcx.ins().iadd_imm(\n-                    relative_discr,\n-                    i64::from(niche_variants.start().as_u32()),\n-                )\n+                fx.bcx\n+                    .ins()\n+                    .iadd_imm(relative_discr, i64::from(niche_variants.start().as_u32()))\n             };\n \n-            let dataful_variant = fx.bcx.ins().iconst(cast_to, i64::from(dataful_variant.as_u32()));\n-            let discr = fx.bcx.ins().select(\n-                is_niche,\n-                niche_discr,\n-                dataful_variant,\n-            );\n+            let dataful_variant = fx\n+                .bcx\n+                .ins()\n+                .iconst(cast_to, i64::from(dataful_variant.as_u32()));\n+            let discr = fx.bcx.ins().select(is_niche, niche_discr, dataful_variant);\n             CValue::by_val(discr, dest_layout)\n         }\n     }"}, {"sha": "f78ea1ef765486dd36ca96cb0489858ae1117ef4", "filename": "src/driver.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver.rs?ref=19f02554285a07bd7fdf1353cdde6249709f5b6c", "patch": "@@ -109,7 +109,9 @@ fn load_imported_symbols_for_jit(tcx: TyCtxt<'_>) -> Vec<(String, *const u8)> {\n             Linkage::NotLinked | Linkage::IncludedFromDylib => {}\n             Linkage::Static => {\n                 let name = tcx.crate_name(cnum);\n-                let mut err = tcx.sess.struct_err(&format!(\"Can't load static lib {}\", name.as_str()));\n+                let mut err = tcx\n+                    .sess\n+                    .struct_err(&format!(\"Can't load static lib {}\", name.as_str()));\n                 err.note(\"rustc_codegen_cranelift can only load dylibs in JIT mode.\");\n                 err.emit();\n             }\n@@ -222,8 +224,10 @@ fn run_aot(\n             .as_str()\n             .to_string();\n \n-        let mut metadata_artifact =\n-            faerie::Artifact::new(crate::build_isa(tcx.sess, true).triple().clone(), metadata_cgu_name.clone());\n+        let mut metadata_artifact = faerie::Artifact::new(\n+            crate::build_isa(tcx.sess, true).triple().clone(),\n+            metadata_cgu_name.clone(),\n+        );\n         crate::metadata::write_metadata(tcx, &mut metadata_artifact);\n \n         let tmp_file = tcx"}, {"sha": "215790e5d93ff1d64f01f808443cad19dc664605", "filename": "src/intrinsics.rs", "status": "modified", "additions": 123, "deletions": 60, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics.rs?ref=19f02554285a07bd7fdf1353cdde6249709f5b6c", "patch": "@@ -138,7 +138,10 @@ pub fn lane_type_and_count<'tcx>(\n     assert!(layout.ty.is_simd());\n     let lane_count = match layout.fields {\n         layout::FieldPlacement::Array { stride: _, count } => u32::try_from(count).unwrap(),\n-        _ => panic!(\"Non vector type {:?} passed to or returned from simd_* intrinsic {}\", layout.ty, intrinsic),\n+        _ => panic!(\n+            \"Non vector type {:?} passed to or returned from simd_* intrinsic {}\",\n+            layout.ty, intrinsic\n+        ),\n     };\n     let lane_layout = layout.field(fx, 0);\n     (lane_layout, lane_count)\n@@ -150,7 +153,13 @@ pub fn simd_for_each_lane<'tcx, B: Backend>(\n     x: CValue<'tcx>,\n     y: CValue<'tcx>,\n     ret: CPlace<'tcx>,\n-    f: impl Fn(&mut FunctionCx<'_, 'tcx, B>, TyLayout<'tcx>, TyLayout<'tcx>, Value, Value) -> CValue<'tcx>,\n+    f: impl Fn(\n+        &mut FunctionCx<'_, 'tcx, B>,\n+        TyLayout<'tcx>,\n+        TyLayout<'tcx>,\n+        Value,\n+        Value,\n+    ) -> CValue<'tcx>,\n ) {\n     assert_eq!(x.layout(), y.layout());\n     let layout = x.layout();\n@@ -184,7 +193,10 @@ pub fn bool_to_zero_or_max_uint<'tcx>(\n     };\n \n     let zero = fx.bcx.ins().iconst(int_ty, 0);\n-    let max = fx.bcx.ins().iconst(int_ty, (u64::max_value() >> (64 - int_ty.bits())) as i64);\n+    let max = fx\n+        .bcx\n+        .ins()\n+        .iconst(int_ty, (u64::max_value() >> (64 - int_ty.bits())) as i64);\n     let mut res = crate::common::codegen_select(&mut fx.bcx, val, max, zero);\n \n     if ty.is_float() {\n@@ -196,83 +208,131 @@ pub fn bool_to_zero_or_max_uint<'tcx>(\n \n macro_rules! simd_cmp {\n     ($fx:expr, $intrinsic:expr, $cc:ident($x:ident, $y:ident) -> $ret:ident) => {\n-        simd_for_each_lane($fx, $intrinsic, $x, $y, $ret, |fx, lane_layout, res_lane_layout, x_lane, y_lane| {\n-            let res_lane = match lane_layout.ty.sty {\n-                ty::Uint(_) | ty::Int(_) => codegen_icmp(fx, IntCC::$cc, x_lane, y_lane),\n-                _ => unreachable!(\"{:?}\", lane_layout.ty),\n-            };\n-            bool_to_zero_or_max_uint(fx, res_lane_layout, res_lane)\n-        });\n+        simd_for_each_lane(\n+            $fx,\n+            $intrinsic,\n+            $x,\n+            $y,\n+            $ret,\n+            |fx, lane_layout, res_lane_layout, x_lane, y_lane| {\n+                let res_lane = match lane_layout.ty.sty {\n+                    ty::Uint(_) | ty::Int(_) => codegen_icmp(fx, IntCC::$cc, x_lane, y_lane),\n+                    _ => unreachable!(\"{:?}\", lane_layout.ty),\n+                };\n+                bool_to_zero_or_max_uint(fx, res_lane_layout, res_lane)\n+            },\n+        );\n     };\n     ($fx:expr, $intrinsic:expr, $cc_u:ident|$cc_s:ident($x:ident, $y:ident) -> $ret:ident) => {\n-        simd_for_each_lane($fx, $intrinsic, $x, $y, $ret, |fx, lane_layout, res_lane_layout, x_lane, y_lane| {\n-            let res_lane = match lane_layout.ty.sty {\n-                ty::Uint(_) => codegen_icmp(fx, IntCC::$cc_u, x_lane, y_lane),\n-                ty::Int(_) => codegen_icmp(fx, IntCC::$cc_s, x_lane, y_lane),\n-                _ => unreachable!(\"{:?}\", lane_layout.ty),\n-            };\n-            bool_to_zero_or_max_uint(fx, res_lane_layout, res_lane)\n-        });\n+        simd_for_each_lane(\n+            $fx,\n+            $intrinsic,\n+            $x,\n+            $y,\n+            $ret,\n+            |fx, lane_layout, res_lane_layout, x_lane, y_lane| {\n+                let res_lane = match lane_layout.ty.sty {\n+                    ty::Uint(_) => codegen_icmp(fx, IntCC::$cc_u, x_lane, y_lane),\n+                    ty::Int(_) => codegen_icmp(fx, IntCC::$cc_s, x_lane, y_lane),\n+                    _ => unreachable!(\"{:?}\", lane_layout.ty),\n+                };\n+                bool_to_zero_or_max_uint(fx, res_lane_layout, res_lane)\n+            },\n+        );\n     };\n-\n }\n \n macro_rules! simd_int_binop {\n     ($fx:expr, $intrinsic:expr, $op:ident($x:ident, $y:ident) -> $ret:ident) => {\n-        simd_for_each_lane($fx, $intrinsic, $x, $y, $ret, |fx, lane_layout, ret_lane_layout, x_lane, y_lane| {\n-            let res_lane = match lane_layout.ty.sty {\n-                ty::Uint(_) | ty::Int(_) => fx.bcx.ins().$op(x_lane, y_lane),\n-                _ => unreachable!(\"{:?}\", lane_layout.ty),\n-            };\n-            CValue::by_val(res_lane, ret_lane_layout)\n-        });\n+        simd_for_each_lane(\n+            $fx,\n+            $intrinsic,\n+            $x,\n+            $y,\n+            $ret,\n+            |fx, lane_layout, ret_lane_layout, x_lane, y_lane| {\n+                let res_lane = match lane_layout.ty.sty {\n+                    ty::Uint(_) | ty::Int(_) => fx.bcx.ins().$op(x_lane, y_lane),\n+                    _ => unreachable!(\"{:?}\", lane_layout.ty),\n+                };\n+                CValue::by_val(res_lane, ret_lane_layout)\n+            },\n+        );\n     };\n     ($fx:expr, $intrinsic:expr, $op_u:ident|$op_s:ident($x:ident, $y:ident) -> $ret:ident) => {\n-        simd_for_each_lane($fx, $intrinsic, $x, $y, $ret, |fx, lane_layout, ret_lane_layout, x_lane, y_lane| {\n-            let res_lane = match lane_layout.ty.sty {\n-                ty::Uint(_) => fx.bcx.ins().$op_u(x_lane, y_lane),\n-                ty::Int(_) => fx.bcx.ins().$op_s(x_lane, y_lane),\n-                _ => unreachable!(\"{:?}\", lane_layout.ty),\n-            };\n-            CValue::by_val(res_lane, ret_lane_layout)\n-        });\n+        simd_for_each_lane(\n+            $fx,\n+            $intrinsic,\n+            $x,\n+            $y,\n+            $ret,\n+            |fx, lane_layout, ret_lane_layout, x_lane, y_lane| {\n+                let res_lane = match lane_layout.ty.sty {\n+                    ty::Uint(_) => fx.bcx.ins().$op_u(x_lane, y_lane),\n+                    ty::Int(_) => fx.bcx.ins().$op_s(x_lane, y_lane),\n+                    _ => unreachable!(\"{:?}\", lane_layout.ty),\n+                };\n+                CValue::by_val(res_lane, ret_lane_layout)\n+            },\n+        );\n     };\n }\n \n macro_rules! simd_int_flt_binop {\n     ($fx:expr, $intrinsic:expr, $op:ident|$op_f:ident($x:ident, $y:ident) -> $ret:ident) => {\n-        simd_for_each_lane($fx, $intrinsic, $x, $y, $ret, |fx, lane_layout, ret_lane_layout, x_lane, y_lane| {\n-            let res_lane = match lane_layout.ty.sty {\n-                ty::Uint(_) | ty::Int(_) => fx.bcx.ins().$op(x_lane, y_lane),\n-                ty::Float(_) => fx.bcx.ins().$op_f(x_lane, y_lane),\n-                _ => unreachable!(\"{:?}\", lane_layout.ty),\n-            };\n-            CValue::by_val(res_lane, ret_lane_layout)\n-        });\n+        simd_for_each_lane(\n+            $fx,\n+            $intrinsic,\n+            $x,\n+            $y,\n+            $ret,\n+            |fx, lane_layout, ret_lane_layout, x_lane, y_lane| {\n+                let res_lane = match lane_layout.ty.sty {\n+                    ty::Uint(_) | ty::Int(_) => fx.bcx.ins().$op(x_lane, y_lane),\n+                    ty::Float(_) => fx.bcx.ins().$op_f(x_lane, y_lane),\n+                    _ => unreachable!(\"{:?}\", lane_layout.ty),\n+                };\n+                CValue::by_val(res_lane, ret_lane_layout)\n+            },\n+        );\n     };\n     ($fx:expr, $intrinsic:expr, $op_u:ident|$op_s:ident|$op_f:ident($x:ident, $y:ident) -> $ret:ident) => {\n-        simd_for_each_lane($fx, $intrinsic, $x, $y, $ret, |fx, lane_layout, ret_lane_layout, x_lane, y_lane| {\n-            let res_lane = match lane_layout.ty.sty {\n-                ty::Uint(_) => fx.bcx.ins().$op_u(x_lane, y_lane),\n-                ty::Int(_) => fx.bcx.ins().$op_s(x_lane, y_lane),\n-                ty::Float(_) => fx.bcx.ins().$op_f(x_lane, y_lane),\n-                _ => unreachable!(\"{:?}\", lane_layout.ty),\n-            };\n-            CValue::by_val(res_lane, ret_lane_layout)\n-        });\n+        simd_for_each_lane(\n+            $fx,\n+            $intrinsic,\n+            $x,\n+            $y,\n+            $ret,\n+            |fx, lane_layout, ret_lane_layout, x_lane, y_lane| {\n+                let res_lane = match lane_layout.ty.sty {\n+                    ty::Uint(_) => fx.bcx.ins().$op_u(x_lane, y_lane),\n+                    ty::Int(_) => fx.bcx.ins().$op_s(x_lane, y_lane),\n+                    ty::Float(_) => fx.bcx.ins().$op_f(x_lane, y_lane),\n+                    _ => unreachable!(\"{:?}\", lane_layout.ty),\n+                };\n+                CValue::by_val(res_lane, ret_lane_layout)\n+            },\n+        );\n     };\n }\n \n macro_rules! simd_flt_binop {\n     ($fx:expr, $intrinsic:expr, $op:ident($x:ident, $y:ident) -> $ret:ident) => {\n-        simd_for_each_lane($fx, $intrinsic, $x, $y, $ret, |fx, lane_layout, ret_lane_layout, x_lane, y_lane| {\n-            let res_lane = match lane_layout.ty.sty {\n-                ty::Float(_) => fx.bcx.ins().$op(x_lane, y_lane),\n-                _ => unreachable!(\"{:?}\", lane_layout.ty),\n-            };\n-            CValue::by_val(res_lane, ret_lane_layout)\n-        });\n-    }\n+        simd_for_each_lane(\n+            $fx,\n+            $intrinsic,\n+            $x,\n+            $y,\n+            $ret,\n+            |fx, lane_layout, ret_lane_layout, x_lane, y_lane| {\n+                let res_lane = match lane_layout.ty.sty {\n+                    ty::Float(_) => fx.bcx.ins().$op(x_lane, y_lane),\n+                    _ => unreachable!(\"{:?}\", lane_layout.ty),\n+                };\n+                CValue::by_val(res_lane, ret_lane_layout)\n+            },\n+        );\n+    };\n }\n \n pub fn codegen_intrinsic_call<'tcx>(\n@@ -297,7 +357,10 @@ pub fn codegen_intrinsic_call<'tcx>(\n                     trap_unreachable(fx, \"[corruption] Called intrinsic::unreachable.\");\n                 }\n                 \"transmute\" => {\n-                    trap_unreachable(fx, \"[corruption] Called intrinsic::transmute with uninhabited argument.\");\n+                    trap_unreachable(\n+                        fx,\n+                        \"[corruption] Called intrinsic::transmute with uninhabited argument.\",\n+                    );\n                 }\n                 _ => unimplemented!(\"unsupported instrinsic {}\", intrinsic),\n             }"}, {"sha": "f90941d7ba43b83d714d62e5b23a48e7e3117d24", "filename": "src/lib.rs", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=19f02554285a07bd7fdf1353cdde6249709f5b6c", "patch": "@@ -71,8 +71,8 @@ mod prelude {\n     };\n     pub use rustc::ty::layout::{self, Abi, LayoutOf, Scalar, Size, TyLayout, VariantIdx};\n     pub use rustc::ty::{\n-        self, FnSig, Instance, InstanceDef, ParamEnv, PolyFnSig, Ty, TyCtxt,\n-        TypeAndMut, TypeFoldable,\n+        self, FnSig, Instance, InstanceDef, ParamEnv, PolyFnSig, Ty, TyCtxt, TypeAndMut,\n+        TypeFoldable,\n     };\n     pub use rustc_data_structures::{\n         fx::{FxHashMap, FxHashSet},\n@@ -102,7 +102,7 @@ mod prelude {\n     pub use crate::debuginfo::{DebugContext, FunctionDebugContext};\n     pub use crate::trap::*;\n     pub use crate::unimpl::{unimpl, with_unimpl_span};\n-    pub use crate::value_and_place::{CValue, CPlace, CPlaceInner};\n+    pub use crate::value_and_place::{CPlace, CPlaceInner, CValue};\n     pub use crate::{Caches, CodegenCx};\n \n     pub struct PrintOnPanic<F: Fn() -> String>(pub F);\n@@ -175,14 +175,18 @@ impl CodegenBackend for CraneliftCodegenBackend {\n             if tcx.sess.opts.actually_rustdoc {\n                 // rustdoc needs to be able to document functions that use all the features, so\n                 // whitelist them all\n-                 tcx.arena.alloc(target_features_whitelist::all_known_features()\n-                    .map(|(a, b)| (a.to_string(), b))\n-                    .collect())\n+                tcx.arena.alloc(\n+                    target_features_whitelist::all_known_features()\n+                        .map(|(a, b)| (a.to_string(), b))\n+                        .collect(),\n+                )\n             } else {\n-                tcx.arena.alloc(target_features_whitelist::target_feature_whitelist(tcx.sess)\n-                    .iter()\n-                    .map(|&(a, b)| (a.to_string(), b))\n-                    .collect())\n+                tcx.arena.alloc(\n+                    target_features_whitelist::target_feature_whitelist(tcx.sess)\n+                        .iter()\n+                        .map(|&(a, b)| (a.to_string(), b))\n+                        .collect(),\n+                )\n             }\n         };\n     }\n@@ -252,11 +256,16 @@ fn build_isa(sess: &Session, enable_pic: bool) -> Box<dyn isa::TargetIsa + 'stat\n         flags_builder.set(\"is_pic\", \"false\").unwrap();\n     }\n     flags_builder.set(\"probestack_enabled\", \"false\").unwrap(); // __cranelift_probestack is not provided\n-        flags_builder.set(\"enable_verifier\", if cfg!(debug_assertions) {\n-        \"true\"\n-    } else {\n-        \"false\"\n-    }).unwrap();\n+    flags_builder\n+        .set(\n+            \"enable_verifier\",\n+            if cfg!(debug_assertions) {\n+                \"true\"\n+            } else {\n+                \"false\"\n+            },\n+        )\n+        .unwrap();\n \n     // FIXME(CraneStation/cranelift#732) fix LICM in presence of jump tables\n     //flags_builder.set(\"opt_level\", \"best\").unwrap();"}, {"sha": "08604e87c33eccddbb0d14ad10b32e6a38ab9168", "filename": "src/linkage.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Flinkage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Flinkage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flinkage.rs?ref=19f02554285a07bd7fdf1353cdde6249709f5b6c", "patch": "@@ -1,4 +1,4 @@\n-use rustc::mir::mono::{MonoItem, Linkage as RLinkage, Visibility};\n+use rustc::mir::mono::{Linkage as RLinkage, MonoItem, Visibility};\n \n use crate::prelude::*;\n "}, {"sha": "e367a165bf60519e1f3e22570e3ebf123185b0cf", "filename": "src/llvm_intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Fllvm_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Fllvm_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm_intrinsics.rs?ref=19f02554285a07bd7fdf1353cdde6249709f5b6c", "patch": "@@ -1,5 +1,5 @@\n-use crate::prelude::*;\n use crate::intrinsics::*;\n+use crate::prelude::*;\n \n use rustc::ty::subst::SubstsRef;\n "}, {"sha": "b619cb9b0adb0557d0624ae361ed649241806a15", "filename": "src/main_shim.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Fmain_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Fmain_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmain_shim.rs?ref=19f02554285a07bd7fdf1353cdde6249709f5b6c", "patch": "@@ -2,10 +2,7 @@ use crate::prelude::*;\n \n /// Create the `main` function which will initialize the rust runtime and call\n /// users main function.\n-pub fn maybe_create_entry_wrapper(\n-    tcx: TyCtxt<'_>,\n-    module: &mut Module<impl Backend + 'static>,\n-) {\n+pub fn maybe_create_entry_wrapper(tcx: TyCtxt<'_>, module: &mut Module<impl Backend + 'static>) {\n     use rustc::middle::lang_items::StartFnLangItem;\n     use rustc::session::config::EntryFnType;\n "}, {"sha": "8d17922725aa7c794fde5ea6a715bdf0ed5e0f11", "filename": "src/metadata.rs", "status": "modified", "additions": 42, "deletions": 30, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmetadata.rs?ref=19f02554285a07bd7fdf1353cdde6249709f5b6c", "patch": "@@ -1,9 +1,9 @@\n use std::fs::File;\n use std::path::Path;\n \n+use rustc::middle::cstore::{EncodedMetadata, MetadataLoader};\n use rustc::session::config;\n use rustc::ty::TyCtxt;\n-use rustc::middle::cstore::{EncodedMetadata, MetadataLoader};\n use rustc_codegen_ssa::METADATA_FILENAME;\n use rustc_data_structures::owning_ref::{self, OwningRef};\n use rustc_data_structures::rustc_erase_owner;\n@@ -41,40 +41,44 @@ impl MetadataLoader for CraneliftMetadataLoader {\n         use object::Object;\n         let file = std::fs::read(path).map_err(|e| format!(\"read:{:?}\", e))?;\n         let file = object::File::parse(&file).map_err(|e| format!(\"parse: {:?}\", e))?;\n-        let buf = file.section_data_by_name(\".rustc\").ok_or(\"no .rustc section\")?.into_owned();\n+        let buf = file\n+            .section_data_by_name(\".rustc\")\n+            .ok_or(\"no .rustc section\")?\n+            .into_owned();\n         let buf: OwningRef<Vec<u8>, [u8]> = OwningRef::new(buf).into();\n         Ok(rustc_erase_owner!(buf.map_owner_box()))\n     }\n }\n \n // Adapted from https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src/librustc_codegen_llvm/base.rs#L47-L112\n-pub fn write_metadata(\n-    tcx: TyCtxt<'_>,\n-    artifact: &mut faerie::Artifact\n-) -> EncodedMetadata {\n-    use std::io::Write;\n-    use flate2::Compression;\n+pub fn write_metadata(tcx: TyCtxt<'_>, artifact: &mut faerie::Artifact) -> EncodedMetadata {\n     use flate2::write::DeflateEncoder;\n+    use flate2::Compression;\n+    use std::io::Write;\n \n     #[derive(PartialEq, Eq, PartialOrd, Ord)]\n     enum MetadataKind {\n         None,\n         Uncompressed,\n-        Compressed\n+        Compressed,\n     }\n \n-    let kind = tcx.sess.crate_types.borrow().iter().map(|ty| {\n-        match *ty {\n-            config::CrateType::Executable |\n-            config::CrateType::Staticlib |\n-            config::CrateType::Cdylib => MetadataKind::None,\n+    let kind = tcx\n+        .sess\n+        .crate_types\n+        .borrow()\n+        .iter()\n+        .map(|ty| match *ty {\n+            config::CrateType::Executable\n+            | config::CrateType::Staticlib\n+            | config::CrateType::Cdylib => MetadataKind::None,\n \n             config::CrateType::Rlib => MetadataKind::Uncompressed,\n \n-            config::CrateType::Dylib |\n-            config::CrateType::ProcMacro => MetadataKind::Compressed,\n-        }\n-    }).max().unwrap_or(MetadataKind::None);\n+            config::CrateType::Dylib | config::CrateType::ProcMacro => MetadataKind::Compressed,\n+        })\n+        .max()\n+        .unwrap_or(MetadataKind::None);\n \n     if kind == MetadataKind::None {\n         return EncodedMetadata::new();\n@@ -88,19 +92,27 @@ pub fn write_metadata(\n     assert!(kind == MetadataKind::Compressed);\n     let mut compressed = tcx.metadata_encoding_version();\n     DeflateEncoder::new(&mut compressed, Compression::fast())\n-        .write_all(&metadata.raw_data).unwrap();\n+        .write_all(&metadata.raw_data)\n+        .unwrap();\n \n-    artifact.declare(\".rustc\", faerie::Decl::section(faerie::SectionKind::Data)).unwrap();\n-    artifact.define_with_symbols(\".rustc\", compressed, {\n-        let mut map = std::collections::BTreeMap::new();\n-        // FIXME implement faerie elf backend section custom symbols\n-        // For MachO this is necessary to prevent the linker from throwing away the .rustc section,\n-        // but for ELF it isn't.\n-        if tcx.sess.target.target.options.is_like_osx {\n-            map.insert(rustc::middle::exported_symbols::metadata_symbol_name(tcx), 0);\n-        }\n-        map\n-    }).unwrap();\n+    artifact\n+        .declare(\".rustc\", faerie::Decl::section(faerie::SectionKind::Data))\n+        .unwrap();\n+    artifact\n+        .define_with_symbols(\".rustc\", compressed, {\n+            let mut map = std::collections::BTreeMap::new();\n+            // FIXME implement faerie elf backend section custom symbols\n+            // For MachO this is necessary to prevent the linker from throwing away the .rustc section,\n+            // but for ELF it isn't.\n+            if tcx.sess.target.target.options.is_like_osx {\n+                map.insert(\n+                    rustc::middle::exported_symbols::metadata_symbol_name(tcx),\n+                    0,\n+                );\n+            }\n+            map\n+        })\n+        .unwrap();\n \n     metadata\n }"}, {"sha": "7cd99b4b76f1b750a2bcb2b65751e032ad39717a", "filename": "src/num.rs", "status": "modified", "additions": 77, "deletions": 21, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fnum.rs?ref=19f02554285a07bd7fdf1353cdde6249709f5b6c", "patch": "@@ -5,11 +5,35 @@ pub fn bin_op_to_intcc(bin_op: BinOp, signed: bool) -> Option<IntCC> {\n     use IntCC::*;\n     Some(match bin_op {\n         Eq => Equal,\n-        Lt => if signed { SignedLessThan } else { UnsignedLessThan},\n-        Le => if signed { SignedLessThanOrEqual } else { UnsignedLessThanOrEqual},\n+        Lt => {\n+            if signed {\n+                SignedLessThan\n+            } else {\n+                UnsignedLessThan\n+            }\n+        }\n+        Le => {\n+            if signed {\n+                SignedLessThanOrEqual\n+            } else {\n+                UnsignedLessThanOrEqual\n+            }\n+        }\n         Ne => NotEqual,\n-        Ge => if signed { SignedGreaterThanOrEqual } else { UnsignedGreaterThanOrEqual },\n-        Gt => if signed { SignedGreaterThan } else { UnsignedGreaterThan },\n+        Ge => {\n+            if signed {\n+                SignedGreaterThanOrEqual\n+            } else {\n+                UnsignedGreaterThanOrEqual\n+            }\n+        }\n+        Gt => {\n+            if signed {\n+                SignedGreaterThan\n+            } else {\n+                UnsignedGreaterThan\n+            }\n+        }\n         _ => return None,\n     })\n }\n@@ -41,9 +65,9 @@ pub fn codegen_binop<'tcx>(\n                     let lhs = in_lhs.load_scalar(fx);\n                     let rhs = in_rhs.load_scalar(fx);\n \n-                    let (lhs, rhs) = if\n-                        (bin_op == BinOp::Eq || bin_op == BinOp::Ne)\n-                        && (in_lhs.layout().ty.sty == fx.tcx.types.i8.sty || in_lhs.layout().ty.sty == fx.tcx.types.i16.sty)\n+                    let (lhs, rhs) = if (bin_op == BinOp::Eq || bin_op == BinOp::Ne)\n+                        && (in_lhs.layout().ty.sty == fx.tcx.types.i8.sty\n+                            || in_lhs.layout().ty.sty == fx.tcx.types.i16.sty)\n                     {\n                         // FIXME(CraneStation/cranelift#896) icmp_imm.i8/i16 with eq/ne for signed ints is implemented wrong.\n                         (\n@@ -64,14 +88,15 @@ pub fn codegen_binop<'tcx>(\n \n     match in_lhs.layout().ty.sty {\n         ty::Bool => crate::num::trans_bool_binop(fx, bin_op, in_lhs, in_rhs),\n-        ty::Uint(_) | ty::Int(_)=> {\n-            crate::num::trans_int_binop(fx, bin_op, in_lhs, in_rhs)\n-        }\n+        ty::Uint(_) | ty::Int(_) => crate::num::trans_int_binop(fx, bin_op, in_lhs, in_rhs),\n         ty::Float(_) => crate::num::trans_float_binop(fx, bin_op, in_lhs, in_rhs),\n-        ty::RawPtr(..) | ty::FnPtr(..) => {\n-            crate::num::trans_ptr_binop(fx, bin_op, in_lhs, in_rhs)\n-        }\n-        _ => unimplemented!(\"{:?}({:?}, {:?})\", bin_op, in_lhs.layout().ty, in_rhs.layout().ty),\n+        ty::RawPtr(..) | ty::FnPtr(..) => crate::num::trans_ptr_binop(fx, bin_op, in_lhs, in_rhs),\n+        _ => unimplemented!(\n+            \"{:?}({:?}, {:?})\",\n+            bin_op,\n+            in_lhs.layout().ty,\n+            in_rhs.layout().ty\n+        ),\n     }\n }\n \n@@ -124,8 +149,20 @@ pub fn trans_int_binop<'tcx>(\n         BinOp::Add => b.iadd(lhs, rhs),\n         BinOp::Sub => b.isub(lhs, rhs),\n         BinOp::Mul => b.imul(lhs, rhs),\n-        BinOp::Div => if signed { b.sdiv(lhs, rhs) } else { b.udiv(lhs, rhs) },\n-        BinOp::Rem => if signed { b.srem(lhs, rhs) } else { b.urem(lhs, rhs) },\n+        BinOp::Div => {\n+            if signed {\n+                b.sdiv(lhs, rhs)\n+            } else {\n+                b.udiv(lhs, rhs)\n+            }\n+        }\n+        BinOp::Rem => {\n+            if signed {\n+                b.srem(lhs, rhs)\n+            } else {\n+                b.urem(lhs, rhs)\n+            }\n+        }\n         BinOp::BitXor => b.bxor(lhs, rhs),\n         BinOp::BitAnd => b.band(lhs, rhs),\n         BinOp::BitOr => b.bor(lhs, rhs),\n@@ -144,7 +181,12 @@ pub fn trans_int_binop<'tcx>(\n             }\n         }\n         // Compare binops handles by `codegen_binop`.\n-        _ => unreachable!(\"{:?}({:?}, {:?})\", bin_op, in_lhs.layout().ty, in_rhs.layout().ty),\n+        _ => unreachable!(\n+            \"{:?}({:?}, {:?})\",\n+            bin_op,\n+            in_lhs.layout().ty,\n+            in_rhs.layout().ty\n+        ),\n     };\n \n     CValue::by_val(val, in_lhs.layout())\n@@ -239,7 +281,11 @@ pub fn trans_checked_int_binop<'tcx>(\n     };\n \n     let has_overflow = fx.bcx.ins().bint(types::I8, has_overflow);\n-    let out_place = CPlace::new_stack_slot(fx, fx.tcx.mk_tup([in_lhs.layout().ty, fx.tcx.types.bool].iter()));\n+    let out_place = CPlace::new_stack_slot(\n+        fx,\n+        fx.tcx\n+            .mk_tup([in_lhs.layout().ty, fx.tcx.types.bool].iter()),\n+    );\n     let out_layout = out_place.layout();\n     out_place.write_cvalue(fx, CValue::by_val_pair(res, has_overflow, out_layout));\n \n@@ -341,14 +387,24 @@ pub fn trans_ptr_binop<'tcx>(\n             BinOp::Lt | BinOp::Le | BinOp::Ge | BinOp::Gt => {\n                 let ptr_eq = fx.bcx.ins().icmp(IntCC::Equal, lhs_ptr, rhs_ptr);\n \n-                let ptr_cmp = fx.bcx.ins().icmp(bin_op_to_intcc(bin_op, false).unwrap(), lhs_ptr, rhs_ptr);\n-                let extra_cmp = fx.bcx.ins().icmp(bin_op_to_intcc(bin_op, false).unwrap(), lhs_extra, rhs_extra);\n+                let ptr_cmp =\n+                    fx.bcx\n+                        .ins()\n+                        .icmp(bin_op_to_intcc(bin_op, false).unwrap(), lhs_ptr, rhs_ptr);\n+                let extra_cmp = fx.bcx.ins().icmp(\n+                    bin_op_to_intcc(bin_op, false).unwrap(),\n+                    lhs_extra,\n+                    rhs_extra,\n+                );\n \n                 fx.bcx.ins().select(ptr_eq, extra_cmp, ptr_cmp)\n             }\n             _ => panic!(\"bin_op {:?} on ptr\", bin_op),\n         };\n \n-        CValue::by_val(fx.bcx.ins().bint(types::I8, res), fx.layout_of(fx.tcx.types.bool))\n+        CValue::by_val(\n+            fx.bcx.ins().bint(types::I8, res),\n+            fx.layout_of(fx.tcx.types.bool),\n+        )\n     }\n }"}, {"sha": "0179f51eede3ce7974cfb96b75fe33f10f727eab", "filename": "src/pretty_clif.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Fpretty_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Fpretty_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpretty_clif.rs?ref=19f02554285a07bd7fdf1353cdde6249709f5b6c", "patch": "@@ -4,11 +4,7 @@ use std::fmt;\n \n use cranelift::codegen::{\n     entity::SecondaryMap,\n-    ir::{\n-        self,\n-        entities::AnyEntity,\n-        function::DisplayFunctionAnnotations,\n-    },\n+    ir::{self, entities::AnyEntity, function::DisplayFunctionAnnotations},\n     write::{FuncWriter, PlainWriter},\n     ValueLabelsRanges,\n };\n@@ -82,7 +78,13 @@ impl CommentWriter {\n             global_comments: vec![\n                 format!(\"symbol {}\", tcx.symbol_name(instance).as_str()),\n                 format!(\"instance {:?}\", instance),\n-                format!(\"sig {:?}\", tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), &instance.fn_sig(tcx))),\n+                format!(\n+                    \"sig {:?}\",\n+                    tcx.normalize_erasing_late_bound_regions(\n+                        ParamEnv::reveal_all(),\n+                        &instance.fn_sig(tcx)\n+                    )\n+                ),\n                 String::new(),\n             ],\n             entity_comments: HashMap::new(),\n@@ -218,7 +220,9 @@ pub fn write_clif_file<'tcx>(\n         &mut clif,\n         &func,\n         &DisplayFunctionAnnotations {\n-            isa: Some(&*crate::build_isa(tcx.sess, true /* PIC doesn't matter here */)),\n+            isa: Some(&*crate::build_isa(\n+                tcx.sess, true, /* PIC doesn't matter here */\n+            )),\n             value_ranges,\n         },\n     )"}, {"sha": "3626905db997efec47708538bbd1ed2ffd58709a", "filename": "src/target_features_whitelist.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Ftarget_features_whitelist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Ftarget_features_whitelist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftarget_features_whitelist.rs?ref=19f02554285a07bd7fdf1353cdde6249709f5b6c", "patch": "@@ -115,8 +115,10 @@ const WASM_WHITELIST: &[(&str, Option<Symbol>)] = &[\n ///\n /// IMPORTANT: If you're adding another whitelist to the above lists, make sure to add it to this\n /// iterator!\n-pub fn all_known_features() -> impl Iterator<Item=(&'static str, Option<Symbol>)> {\n-    ARM_WHITELIST.iter().cloned()\n+pub fn all_known_features() -> impl Iterator<Item = (&'static str, Option<Symbol>)> {\n+    ARM_WHITELIST\n+        .iter()\n+        .cloned()\n         .chain(AARCH64_WHITELIST.iter().cloned())\n         .chain(X86_WHITELIST.iter().cloned())\n         .chain(HEXAGON_WHITELIST.iter().cloned())\n@@ -125,9 +127,7 @@ pub fn all_known_features() -> impl Iterator<Item=(&'static str, Option<Symbol>)\n         .chain(WASM_WHITELIST.iter().cloned())\n }\n \n-pub fn target_feature_whitelist(sess: &Session)\n-    -> &'static [(&'static str, Option<Symbol>)]\n-{\n+pub fn target_feature_whitelist(sess: &Session) -> &'static [(&'static str, Option<Symbol>)] {\n     match &*sess.target.target.arch {\n         \"arm\" => ARM_WHITELIST,\n         \"aarch64\" => AARCH64_WHITELIST,"}, {"sha": "0ff9d39d78a2e7548e1ee778fefaddac109215aa", "filename": "src/trap.rs", "status": "modified", "additions": 47, "deletions": 13, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Ftrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Ftrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftrap.rs?ref=19f02554285a07bd7fdf1353cdde6249709f5b6c", "patch": "@@ -1,27 +1,44 @@\n use crate::prelude::*;\n \n fn codegen_print(fx: &mut FunctionCx<'_, '_, impl cranelift_module::Backend>, msg: &str) {\n-    let puts = fx.module.declare_function(\"puts\", Linkage::Import, &Signature {\n-        call_conv: CallConv::SystemV,\n-        params: vec![AbiParam::new(pointer_ty(fx.tcx))],\n-        returns: vec![],\n-    }).unwrap();\n+    let puts = fx\n+        .module\n+        .declare_function(\n+            \"puts\",\n+            Linkage::Import,\n+            &Signature {\n+                call_conv: CallConv::SystemV,\n+                params: vec![AbiParam::new(pointer_ty(fx.tcx))],\n+                returns: vec![],\n+            },\n+        )\n+        .unwrap();\n     let puts = fx.module.declare_func_in_func(puts, &mut fx.bcx.func);\n-    #[cfg(debug_assertions)] {\n+    #[cfg(debug_assertions)]\n+    {\n         fx.add_entity_comment(puts, \"puts\");\n     }\n \n     let symbol_name = fx.tcx.symbol_name(fx.instance);\n     let real_msg = format!(\"trap at {:?} ({}): {}\\0\", fx.instance, symbol_name, msg);\n     let mut data_ctx = DataContext::new();\n     data_ctx.define(real_msg.as_bytes().to_vec().into_boxed_slice());\n-    let msg_id = fx.module.declare_data(&(symbol_name.as_str().to_string() + msg), Linkage::Local, false, None).unwrap();\n+    let msg_id = fx\n+        .module\n+        .declare_data(\n+            &(symbol_name.as_str().to_string() + msg),\n+            Linkage::Local,\n+            false,\n+            None,\n+        )\n+        .unwrap();\n \n     // Ignore DuplicateDefinition error, as the data will be the same\n     let _ = fx.module.define_data(msg_id, &data_ctx);\n \n     let local_msg_id = fx.module.declare_data_in_func(msg_id, fx.bcx.func);\n-    #[cfg(debug_assertions)] {\n+    #[cfg(debug_assertions)]\n+    {\n         fx.add_entity_comment(local_msg_id, msg);\n     }\n     let msg_ptr = fx.bcx.ins().global_value(pointer_ty(fx.tcx), local_msg_id);\n@@ -31,7 +48,10 @@ fn codegen_print(fx: &mut FunctionCx<'_, '_, impl cranelift_module::Backend>, ms\n /// Use this when `rustc_codegen_llvm` would insert a call to the panic handler.\n ///\n /// Trap code: user0\n-pub fn trap_panic(fx: &mut FunctionCx<'_, '_, impl cranelift_module::Backend>, msg: impl AsRef<str>) {\n+pub fn trap_panic(\n+    fx: &mut FunctionCx<'_, '_, impl cranelift_module::Backend>,\n+    msg: impl AsRef<str>,\n+) {\n     codegen_print(fx, msg.as_ref());\n     fx.bcx.ins().trap(TrapCode::User(0));\n }\n@@ -40,7 +60,10 @@ pub fn trap_panic(fx: &mut FunctionCx<'_, '_, impl cranelift_module::Backend>, m\n /// so you can **not** add instructions to it afterwards.\n ///\n /// Trap code: user65535\n-pub fn trap_unreachable(fx: &mut FunctionCx<'_, '_, impl cranelift_module::Backend>, msg: impl AsRef<str>) {\n+pub fn trap_unreachable(\n+    fx: &mut FunctionCx<'_, '_, impl cranelift_module::Backend>,\n+    msg: impl AsRef<str>,\n+) {\n     codegen_print(fx, msg.as_ref());\n     fx.bcx.ins().trap(TrapCode::User(!0));\n }\n@@ -50,7 +73,10 @@ pub fn trap_unreachable(fx: &mut FunctionCx<'_, '_, impl cranelift_module::Backe\n /// to it afterwards.\n ///\n /// Trap code: user65535\n-pub fn trap_unimplemented(fx: &mut FunctionCx<'_, '_, impl cranelift_module::Backend>, msg: impl AsRef<str>) {\n+pub fn trap_unimplemented(\n+    fx: &mut FunctionCx<'_, '_, impl cranelift_module::Backend>,\n+    msg: impl AsRef<str>,\n+) {\n     codegen_print(fx, msg.as_ref());\n     let true_ = fx.bcx.ins().iconst(types::I32, 1);\n     fx.bcx.ins().trapnz(true_, TrapCode::User(!0));\n@@ -59,7 +85,11 @@ pub fn trap_unimplemented(fx: &mut FunctionCx<'_, '_, impl cranelift_module::Bac\n /// Like `trap_unreachable` but returns a fake value of the specified type.\n ///\n /// Trap code: user65535\n-pub fn trap_unreachable_ret_value<'tcx>(fx: &mut FunctionCx<'_, 'tcx, impl cranelift_module::Backend>, dest_layout: TyLayout<'tcx>, msg: impl AsRef<str>) -> CValue<'tcx> {\n+pub fn trap_unreachable_ret_value<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl cranelift_module::Backend>,\n+    dest_layout: TyLayout<'tcx>,\n+    msg: impl AsRef<str>,\n+) -> CValue<'tcx> {\n     trap_unimplemented(fx, msg);\n     let zero = fx.bcx.ins().iconst(fx.pointer_type, 0);\n     CValue::by_ref(zero, dest_layout)\n@@ -68,7 +98,11 @@ pub fn trap_unreachable_ret_value<'tcx>(fx: &mut FunctionCx<'_, 'tcx, impl crane\n /// Like `trap_unreachable` but returns a fake place for the specified type.\n ///\n /// Trap code: user65535\n-pub fn trap_unreachable_ret_place<'tcx>(fx: &mut FunctionCx<'_, 'tcx, impl cranelift_module::Backend>, dest_layout: TyLayout<'tcx>, msg: impl AsRef<str>) -> CPlace<'tcx> {\n+pub fn trap_unreachable_ret_place<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl cranelift_module::Backend>,\n+    dest_layout: TyLayout<'tcx>,\n+    msg: impl AsRef<str>,\n+) -> CPlace<'tcx> {\n     trap_unimplemented(fx, msg);\n     let zero = fx.bcx.ins().iconst(fx.pointer_type, 0);\n     CPlace::for_addr(zero, dest_layout)"}, {"sha": "cd1b5be99a06d981555cba725e40c41f2a88e447", "filename": "src/unsize.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Funsize.rs?ref=19f02554285a07bd7fdf1353cdde6249709f5b6c", "patch": "@@ -15,15 +15,13 @@ pub fn unsized_info<'tcx>(\n     old_info: Option<Value>,\n ) -> Value {\n     let (source, target) =\n-        fx.tcx.struct_lockstep_tails_erasing_lifetimes(source, target, ParamEnv::reveal_all());\n+        fx.tcx\n+            .struct_lockstep_tails_erasing_lifetimes(source, target, ParamEnv::reveal_all());\n     match (&source.sty, &target.sty) {\n-        (&ty::Array(_, len), &ty::Slice(_)) => fx\n-            .bcx\n-            .ins()\n-            .iconst(\n-                fx.pointer_type,\n-                len.eval_usize(fx.tcx, ParamEnv::reveal_all()) as i64,\n-            ),\n+        (&ty::Array(_, len), &ty::Slice(_)) => fx.bcx.ins().iconst(\n+            fx.pointer_type,\n+            len.eval_usize(fx.tcx, ParamEnv::reveal_all()) as i64,\n+        ),\n         (&ty::Dynamic(..), &ty::Dynamic(..)) => {\n             // For now, upcasts are limited to changes in marker\n             // traits, and hence never actually require an actual"}, {"sha": "09db4b144002dac9b355bdb85a5c6f26a6069487", "filename": "src/value_and_place.rs", "status": "modified", "additions": 59, "deletions": 49, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue_and_place.rs?ref=19f02554285a07bd7fdf1353cdde6249709f5b6c", "patch": "@@ -19,7 +19,10 @@ fn codegen_field<'tcx>(\n }\n \n fn scalar_pair_calculate_b_offset(tcx: TyCtxt<'_>, a_scalar: &Scalar, b_scalar: &Scalar) -> i32 {\n-    let b_offset = a_scalar.value.size(&tcx).align_to(b_scalar.value.align(&tcx).abi);\n+    let b_offset = a_scalar\n+        .value\n+        .size(&tcx)\n+        .align_to(b_scalar.value.align(&tcx).abi);\n     b_offset.bytes().try_into().unwrap()\n }\n \n@@ -88,7 +91,10 @@ impl<'tcx> CValue<'tcx> {\n     }\n \n     /// Load a value pair with layout.abi of scalar pair\n-    pub fn load_scalar_pair<'a>(self, fx: &mut FunctionCx<'_, 'tcx, impl Backend>) -> (Value, Value) {\n+    pub fn load_scalar_pair<'a>(\n+        self,\n+        fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n+    ) -> (Value, Value) {\n         let layout = self.1;\n         match self.0 {\n             CValueInner::ByRef(addr) => {\n@@ -100,12 +106,7 @@ impl<'tcx> CValue<'tcx> {\n                 let clif_ty1 = scalar_to_clif_type(fx.tcx, a_scalar.clone());\n                 let clif_ty2 = scalar_to_clif_type(fx.tcx, b_scalar.clone());\n                 let val1 = fx.bcx.ins().load(clif_ty1, MemFlags::new(), addr, 0);\n-                let val2 = fx.bcx.ins().load(\n-                    clif_ty2,\n-                    MemFlags::new(),\n-                    addr,\n-                    b_offset,\n-                );\n+                let val2 = fx.bcx.ins().load(clif_ty2, MemFlags::new(), addr, b_offset);\n                 (val1, val2)\n             }\n             CValueInner::ByVal(_) => bug!(\"Please use load_scalar for ByVal\"),\n@@ -144,20 +145,29 @@ impl<'tcx> CValue<'tcx> {\n         let val = match ty.sty {\n             ty::TyKind::Uint(UintTy::U128) | ty::TyKind::Int(IntTy::I128) => {\n                 let lsb = fx.bcx.ins().iconst(types::I64, const_val as u64 as i64);\n-                let msb = fx.bcx.ins().iconst(types::I64, (const_val >> 64) as u64 as i64);\n+                let msb = fx\n+                    .bcx\n+                    .ins()\n+                    .iconst(types::I64, (const_val >> 64) as u64 as i64);\n                 fx.bcx.ins().iconcat(lsb, msb)\n             }\n             ty::TyKind::Bool => {\n-                assert!(const_val == 0 || const_val == 1, \"Invalid bool 0x{:032X}\", const_val);\n+                assert!(\n+                    const_val == 0 || const_val == 1,\n+                    \"Invalid bool 0x{:032X}\",\n+                    const_val\n+                );\n                 fx.bcx.ins().iconst(types::I8, const_val as i64)\n             }\n-            ty::TyKind::Uint(_) | ty::TyKind::Ref(..) | ty::TyKind::RawPtr(.. )=> {\n-                fx.bcx.ins().iconst(clif_ty, u64::try_from(const_val).expect(\"uint\") as i64)\n-            }\n-            ty::TyKind::Int(_) => {\n-                fx.bcx.ins().iconst(clif_ty, const_val as i128 as i64)\n-            }\n-            _ => panic!(\"CValue::const_val for non bool/integer/pointer type {:?} is not allowed\", ty),\n+            ty::TyKind::Uint(_) | ty::TyKind::Ref(..) | ty::TyKind::RawPtr(..) => fx\n+                .bcx\n+                .ins()\n+                .iconst(clif_ty, u64::try_from(const_val).expect(\"uint\") as i64),\n+            ty::TyKind::Int(_) => fx.bcx.ins().iconst(clif_ty, const_val as i128 as i64),\n+            _ => panic!(\n+                \"CValue::const_val for non bool/integer/pointer type {:?} is not allowed\",\n+                ty\n+            ),\n         };\n \n         CValue::by_val(val, layout)\n@@ -193,9 +203,9 @@ impl<'tcx> CPlace<'tcx> {\n     }\n \n     pub fn no_place(layout: TyLayout<'tcx>) -> CPlace<'tcx> {\n-        CPlace{\n+        CPlace {\n             inner: CPlaceInner::NoPlace,\n-            layout\n+            layout,\n         }\n     }\n \n@@ -299,7 +309,11 @@ impl<'tcx> CPlace<'tcx> {\n         let from_ty = from.layout().ty;\n         let to_ty = self.layout().ty;\n \n-        fn assert_assignable<'tcx>(fx: &FunctionCx<'_, 'tcx, impl Backend>, from_ty: Ty<'tcx>, to_ty: Ty<'tcx>) {\n+        fn assert_assignable<'tcx>(\n+            fx: &FunctionCx<'_, 'tcx, impl Backend>,\n+            from_ty: Ty<'tcx>,\n+            to_ty: Ty<'tcx>,\n+        ) {\n             match (&from_ty.sty, &to_ty.sty) {\n                 (ty::Ref(_, t, MutImmutable), ty::Ref(_, u, MutImmutable))\n                 | (ty::Ref(_, t, MutMutable), ty::Ref(_, u, MutImmutable))\n@@ -308,9 +322,10 @@ impl<'tcx> CPlace<'tcx> {\n                     // &mut T -> &T is allowed\n                     // &'a T -> &'b T is allowed\n                 }\n-                (ty::Ref(_, _, MutImmutable), ty::Ref(_, _, MutMutable)) => {\n-                    panic!(\"Cant assign value of type {} to place of type {}\", from_ty, to_ty)\n-                }\n+                (ty::Ref(_, _, MutImmutable), ty::Ref(_, _, MutMutable)) => panic!(\n+                    \"Cant assign value of type {} to place of type {}\",\n+                    from_ty, to_ty\n+                ),\n                 (ty::FnPtr(_), ty::FnPtr(_)) => {\n                     let from_sig = fx.tcx.normalize_erasing_late_bound_regions(\n                         ParamEnv::reveal_all(),\n@@ -328,14 +343,12 @@ impl<'tcx> CPlace<'tcx> {\n                     // fn(&T) -> for<'l> fn(&'l T) is allowed\n                 }\n                 (ty::Dynamic(from_traits, _), ty::Dynamic(to_traits, _)) => {\n-                    let from_traits = fx.tcx.normalize_erasing_late_bound_regions(\n-                        ParamEnv::reveal_all(),\n-                        from_traits,\n-                    );\n-                    let to_traits = fx.tcx.normalize_erasing_late_bound_regions(\n-                        ParamEnv::reveal_all(),\n-                        to_traits,\n-                    );\n+                    let from_traits = fx\n+                        .tcx\n+                        .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), from_traits);\n+                    let to_traits = fx\n+                        .tcx\n+                        .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), to_traits);\n                     assert_eq!(\n                         from_traits, to_traits,\n                         \"Can't write trait object of incompatible traits {:?} to place with traits {:?}\\n\\n{:#?}\",\n@@ -382,24 +395,17 @@ impl<'tcx> CPlace<'tcx> {\n             CValueInner::ByVal(val) => {\n                 fx.bcx.ins().store(MemFlags::new(), val, addr, 0);\n             }\n-            CValueInner::ByValPair(value, extra) => {\n-                match dst_layout.abi {\n-                    Abi::ScalarPair(ref a_scalar, ref b_scalar) => {\n-                        let b_offset = scalar_pair_calculate_b_offset(fx.tcx, a_scalar, b_scalar);\n-                        fx.bcx.ins().store(MemFlags::new(), value, addr, 0);\n-                        fx.bcx.ins().store(\n-                            MemFlags::new(),\n-                            extra,\n-                            addr,\n-                            b_offset,\n-                        );\n-                    }\n-                    _ => bug!(\n-                        \"Non ScalarPair abi {:?} for ByValPair CValue\",\n-                        dst_layout.abi\n-                    ),\n+            CValueInner::ByValPair(value, extra) => match dst_layout.abi {\n+                Abi::ScalarPair(ref a_scalar, ref b_scalar) => {\n+                    let b_offset = scalar_pair_calculate_b_offset(fx.tcx, a_scalar, b_scalar);\n+                    fx.bcx.ins().store(MemFlags::new(), value, addr, 0);\n+                    fx.bcx.ins().store(MemFlags::new(), extra, addr, b_offset);\n                 }\n-            }\n+                _ => bug!(\n+                    \"Non ScalarPair abi {:?} for ByValPair CValue\",\n+                    dst_layout.abi\n+                ),\n+            },\n             CValueInner::ByRef(from_addr) => {\n                 let src_layout = from.1;\n                 let size = dst_layout.size.bytes();\n@@ -468,7 +474,11 @@ impl<'tcx> CPlace<'tcx> {\n             dest.write_cvalue(fx, ptr);\n         } else {\n             let (value, extra) = self.to_addr_maybe_unsized(fx);\n-            let ptr = CValue::by_val_pair(value, extra.expect(\"unsized type without metadata\"), dest.layout());\n+            let ptr = CValue::by_val_pair(\n+                value,\n+                extra.expect(\"unsized type without metadata\"),\n+                dest.layout(),\n+            );\n             dest.write_cvalue(fx, ptr);\n         }\n     }"}, {"sha": "155237a402f0cab00cbb79c7383907427029e593", "filename": "src/vtable.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f02554285a07bd7fdf1353cdde6249709f5b6c/src%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvtable.rs?ref=19f02554285a07bd7fdf1353cdde6249709f5b6c", "patch": "@@ -6,10 +6,7 @@ const DROP_FN_INDEX: usize = 0;\n const SIZE_INDEX: usize = 1;\n const ALIGN_INDEX: usize = 2;\n \n-pub fn drop_fn_of_obj(\n-    fx: &mut FunctionCx<'_, '_, impl Backend>,\n-    vtable: Value,\n-) -> Value {\n+pub fn drop_fn_of_obj(fx: &mut FunctionCx<'_, '_, impl Backend>, vtable: Value) -> Value {\n     let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes() as usize;\n     fx.bcx.ins().load(\n         pointer_ty(fx.tcx),\n@@ -19,10 +16,7 @@ pub fn drop_fn_of_obj(\n     )\n }\n \n-pub fn size_of_obj(\n-    fx: &mut FunctionCx<'_, '_, impl Backend>,\n-    vtable: Value,\n-) -> Value {\n+pub fn size_of_obj(fx: &mut FunctionCx<'_, '_, impl Backend>, vtable: Value) -> Value {\n     let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes() as usize;\n     fx.bcx.ins().load(\n         pointer_ty(fx.tcx),\n@@ -32,10 +26,7 @@ pub fn size_of_obj(\n     )\n }\n \n-pub fn min_align_of_obj(\n-    fx: &mut FunctionCx<'_, '_, impl Backend>,\n-    vtable: Value,\n-) -> Value {\n+pub fn min_align_of_obj(fx: &mut FunctionCx<'_, '_, impl Backend>, vtable: Value) -> Value {\n     let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes() as usize;\n     fx.bcx.ins().load(\n         pointer_ty(fx.tcx),\n@@ -86,11 +77,8 @@ fn build_vtable<'tcx>(\n     let tcx = fx.tcx;\n     let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes() as usize;\n \n-    let drop_in_place_fn = import_function(\n-        tcx,\n-        fx.module,\n-        Instance::resolve_drop_in_place(tcx, ty),\n-    );\n+    let drop_in_place_fn =\n+        import_function(tcx, fx.module, Instance::resolve_drop_in_place(tcx, ty));\n \n     let mut components: Vec<_> = vec![Some(drop_in_place_fn), None, None];\n \n@@ -136,7 +124,15 @@ fn build_vtable<'tcx>(\n             &format!(\"vtable.{:?}.for.{:?}\", trait_ref, ty),\n             Linkage::Local,\n             false,\n-            Some(fx.tcx.data_layout.pointer_align.pref.bytes().try_into().unwrap())\n+            Some(\n+                fx.tcx\n+                    .data_layout\n+                    .pointer_align\n+                    .pref\n+                    .bytes()\n+                    .try_into()\n+                    .unwrap(),\n+            ),\n         )\n         .unwrap();\n "}]}