{"sha": "26ba0e12e838bb674064c5e04d20ed91b7420e2e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2YmEwZTEyZTgzOGJiNjc0MDY0YzVlMDRkMjBlZDkxYjc0MjBlMmU=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-07-18T19:02:03Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-07-18T23:13:04Z"}, "message": "Use intra-doc links in std::io", "tree": {"sha": "ddec69baed1c648fbe566cd23c2ae777543620e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ddec69baed1c648fbe566cd23c2ae777543620e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26ba0e12e838bb674064c5e04d20ed91b7420e2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26ba0e12e838bb674064c5e04d20ed91b7420e2e", "html_url": "https://github.com/rust-lang/rust/commit/26ba0e12e838bb674064c5e04d20ed91b7420e2e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26ba0e12e838bb674064c5e04d20ed91b7420e2e/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c48ac3e88e438f6b478adca61629a611db6b3dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c48ac3e88e438f6b478adca61629a611db6b3dc", "html_url": "https://github.com/rust-lang/rust/commit/4c48ac3e88e438f6b478adca61629a611db6b3dc"}], "stats": {"total": 141, "additions": 51, "deletions": 90}, "files": [{"sha": "ce9dd19ace104495f8442228c2d379d1bf328038", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 51, "deletions": 90, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/26ba0e12e838bb674064c5e04d20ed91b7420e2e/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26ba0e12e838bb674064c5e04d20ed91b7420e2e/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=26ba0e12e838bb674064c5e04d20ed91b7420e2e", "patch": "@@ -238,25 +238,14 @@\n //! contract. The implementation of many of these functions are subject to change over\n //! time and may call fewer or more syscalls/library functions.\n //!\n-//! [`Read`]: trait.Read.html\n-//! [`Write`]: trait.Write.html\n-//! [`Seek`]: trait.Seek.html\n-//! [`BufRead`]: trait.BufRead.html\n-//! [`File`]: ../fs/struct.File.html\n-//! [`TcpStream`]: ../net/struct.TcpStream.html\n-//! [`Vec<T>`]: ../vec/struct.Vec.html\n-//! [`BufReader`]: struct.BufReader.html\n-//! [`BufWriter`]: struct.BufWriter.html\n-//! [`Write::write`]: trait.Write.html#tymethod.write\n-//! [`io::stdout`]: fn.stdout.html\n-//! [`println!`]: ../macro.println.html\n-//! [`Lines`]: struct.Lines.html\n-//! [`io::Result`]: type.Result.html\n+//! [`File`]: crate::fs::File\n+//! [`TcpStream`]: crate::net::TcpStream\n+//! [`Vec<T>`]: crate::vec::Vec\n+//! [`io::stdout`]: stdout\n+//! [`io::Result`]: crate::io::Result\n //! [`?` operator]: ../../book/appendix-02-operators.html\n-//! [`Read::read`]: trait.Read.html#tymethod.read\n-//! [`Result`]: ../result/enum.Result.html\n-//! [`.unwrap()`]: ../result/enum.Result.html#method.unwrap\n-// ignore-tidy-filelength\n+//! [`Result`]: crate::result::Result\n+//! [`.unwrap()`]: crate::result::Result::unwrap\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -491,12 +480,10 @@ where\n /// }\n /// ```\n ///\n-/// [`read()`]: trait.Read.html#tymethod.read\n-/// [`std::io`]: ../../std/io/index.html\n-/// [`File`]: ../fs/struct.File.html\n-/// [`BufRead`]: trait.BufRead.html\n-/// [`BufReader`]: struct.BufReader.html\n-/// [`&str`]: ../../std/primitive.str.html\n+/// [`read()`]: Read::read\n+/// [`&str`]: str\n+/// [`std::io`]: self\n+/// [`File`]: crate::fs::File\n /// [slice]: ../../std/primitive.slice.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(spotlight)]\n@@ -535,7 +522,7 @@ pub trait Read {\n     /// before calling `read`. Calling `read` with an uninitialized `buf` (of the kind one\n     /// obtains via [`MaybeUninit<T>`]) is not safe, and can lead to undefined behavior.\n     ///\n-    /// [`MaybeUninit<T>`]: ../mem/union.MaybeUninit.html\n+    /// [`MaybeUninit<T>`]: crate::mem::MaybeUninit\n     ///\n     /// # Errors\n     ///\n@@ -550,10 +537,8 @@ pub trait Read {\n     ///\n     /// [`File`]s implement `Read`:\n     ///\n-    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n-    /// [`Ok(n)`]: ../../std/result/enum.Result.html#variant.Ok\n-    /// [`ErrorKind::Interrupted`]: ../../std/io/enum.ErrorKind.html#variant.Interrupted\n-    /// [`File`]: ../fs/struct.File.html\n+    /// [`Ok(n)`]: Ok\n+    /// [`File`]: crate::fs::File\n     ///\n     /// ```no_run\n     /// use std::io;\n@@ -620,9 +605,6 @@ pub trait Read {\n     /// This method is unsafe because a `Read`er could otherwise return a\n     /// non-zeroing `Initializer` from another `Read` type without an `unsafe`\n     /// block.\n-    ///\n-    /// [`Initializer::nop()`]: ../../std/io/struct.Initializer.html#method.nop\n-    /// [`Initializer`]: ../../std/io/struct.Initializer.html\n     #[unstable(feature = \"read_initializer\", issue = \"42788\")]\n     #[inline]\n     unsafe fn initializer(&self) -> Initializer {\n@@ -652,10 +634,9 @@ pub trait Read {\n     ///\n     /// [`File`]s implement `Read`:\n     ///\n-    /// [`read()`]: trait.Read.html#tymethod.read\n-    /// [`Ok(0)`]: ../../std/result/enum.Result.html#variant.Ok\n-    /// [`ErrorKind::Interrupted`]: ../../std/io/enum.ErrorKind.html#variant.Interrupted\n-    /// [`File`]: ../fs/struct.File.html\n+    /// [`read()`]: Read::read\n+    /// [`Ok(0)`]: Ok\n+    /// [`File`]: crate::fs::File\n     ///\n     /// ```no_run\n     /// use std::io;\n@@ -675,7 +656,7 @@ pub trait Read {\n     /// (See also the [`std::fs::read`] convenience function for reading from a\n     /// file.)\n     ///\n-    /// [`std::fs::read`]: ../fs/fn.read.html\n+    /// [`std::fs::read`]: crate::fs::read\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn read_to_end(&mut self, buf: &mut Vec<u8>) -> Result<usize> {\n         read_to_end(self, buf)\n@@ -693,13 +674,13 @@ pub trait Read {\n     ///\n     /// See [`read_to_end`][readtoend] for other error semantics.\n     ///\n-    /// [readtoend]: #method.read_to_end\n+    /// [readtoend]: Self::read_to_end\n     ///\n     /// # Examples\n     ///\n     /// [`File`][file]s implement `Read`:\n     ///\n-    /// [file]: ../fs/struct.File.html\n+    /// [file]: crate::fs::File\n     ///\n     /// ```no_run\n     /// use std::io;\n@@ -718,7 +699,7 @@ pub trait Read {\n     /// (See also the [`std::fs::read_to_string`] convenience function for\n     /// reading from a file.)\n     ///\n-    /// [`std::fs::read_to_string`]: ../fs/fn.read_to_string.html\n+    /// [`std::fs::read_to_string`]: crate::fs::read_to_string\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn read_to_string(&mut self, buf: &mut String) -> Result<usize> {\n         // Note that we do *not* call `.read_to_end()` here. We are passing\n@@ -764,9 +745,7 @@ pub trait Read {\n     ///\n     /// [`File`]s implement `Read`:\n     ///\n-    /// [`File`]: ../fs/struct.File.html\n-    /// [`ErrorKind::Interrupted`]: ../../std/io/enum.ErrorKind.html#variant.Interrupted\n-    /// [`ErrorKind::UnexpectedEof`]: ../../std/io/enum.ErrorKind.html#variant.UnexpectedEof\n+    /// [`File`]: crate::fs::File\n     ///\n     /// ```no_run\n     /// use std::io;\n@@ -811,7 +790,7 @@ pub trait Read {\n     ///\n     /// [`File`][file]s implement `Read`:\n     ///\n-    /// [file]: ../fs/struct.File.html\n+    /// [file]: crate::fs::File\n     ///\n     /// ```no_run\n     /// use std::io;\n@@ -855,14 +834,10 @@ pub trait Read {\n     ///\n     /// [`File`][file]s implement `Read`:\n     ///\n-    /// [file]: ../fs/struct.File.html\n-    /// [`Iterator`]: ../../std/iter/trait.Iterator.html\n-    /// [`Result`]: ../../std/result/enum.Result.html\n-    /// [`io::Error`]: ../../std/io/struct.Error.html\n-    /// [`u8`]: ../../std/primitive.u8.html\n-    /// [`Ok`]: ../../std/result/enum.Result.html#variant.Ok\n-    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [file]: crate::fs::File\n+    /// [`Iterator`]: crate::iter::Iterator\n+    /// [`Result`]: crate::result::Result\n+    /// [`io::Error`]: self::Error\n     ///\n     /// ```no_run\n     /// use std::io;\n@@ -896,7 +871,7 @@ pub trait Read {\n     ///\n     /// [`File`][file]s implement `Read`:\n     ///\n-    /// [file]: ../fs/struct.File.html\n+    /// [file]: crate::fs::File\n     ///\n     /// ```no_run\n     /// use std::io;\n@@ -935,9 +910,9 @@ pub trait Read {\n     ///\n     /// [`File`]s implement `Read`:\n     ///\n-    /// [`File`]: ../fs/struct.File.html\n-    /// [`Ok(0)`]: ../../std/result/enum.Result.html#variant.Ok\n-    /// [`read()`]: trait.Read.html#tymethod.read\n+    /// [`File`]: crate::fs::File\n+    /// [`Ok(0)`]: Ok\n+    /// [`read()`]: Read::read\n     ///\n     /// ```no_run\n     /// use std::io;\n@@ -1233,8 +1208,8 @@ impl Initializer {\n /// throughout [`std::io`] take and provide types which implement the `Write`\n /// trait.\n ///\n-/// [`write`]: #tymethod.write\n-/// [`flush`]: #tymethod.flush\n+/// [`write`]: Self::write\n+/// [`flush`]: Self::flush\n /// [`std::io`]: index.html\n ///\n /// # Examples\n@@ -1260,7 +1235,7 @@ impl Initializer {\n /// The trait also provides convenience methods like [`write_all`], which calls\n /// `write` in a loop until its entire input has been written.\n ///\n-/// [`write_all`]: #method.write_all\n+/// [`write_all`]: Self::write_all\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(spotlight)]\n pub trait Write {\n@@ -1292,10 +1267,6 @@ pub trait Write {\n     /// An error of the [`ErrorKind::Interrupted`] kind is non-fatal and the\n     /// write operation should be retried if there is nothing else to do.\n     ///\n-    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n-    /// [`Ok(n)`]:  ../../std/result/enum.Result.html#variant.Ok\n-    /// [`ErrorKind::Interrupted`]: ../../std/io/enum.ErrorKind.html#variant.Interrupted\n-    ///\n     /// # Examples\n     ///\n     /// ```no_run\n@@ -1381,8 +1352,7 @@ pub trait Write {\n     /// This function will return the first error of\n     /// non-[`ErrorKind::Interrupted`] kind that [`write`] returns.\n     ///\n-    /// [`ErrorKind::Interrupted`]: ../../std/io/enum.ErrorKind.html#variant.Interrupted\n-    /// [`write`]: #tymethod.write\n+    /// [`write`]: Self::write\n     ///\n     /// # Examples\n     ///\n@@ -1423,8 +1393,7 @@ pub trait Write {\n     ///\n     /// If the buffer contains no data, this will never call [`write_vectored`].\n     ///\n-    /// [`write_vectored`]: #method.write_vectored\n-    /// [`ErrorKind::Interrupted`]: ../../std/io/enum.ErrorKind.html#variant.Interrupted\n+    /// [`write_vectored`]: Self::write_vectored\n     ///\n     /// # Notes\n     ///\n@@ -1480,19 +1449,16 @@ pub trait Write {\n     /// encountered.\n     ///\n     /// This method is primarily used to interface with the\n-    /// [`format_args!`][formatargs] macro, but it is rare that this should\n-    /// explicitly be called. The [`write!`][write] macro should be favored to\n+    /// [`format_args!()`] macro, but it is rare that this should\n+    /// explicitly be called. The [`write!()`][write] macro should be favored to\n     /// invoke this method instead.\n     ///\n-    /// [formatargs]: ../macro.format_args.html\n-    /// [write]: ../macro.write.html\n-    ///\n     /// This function internally uses the [`write_all`][writeall] method on\n     /// this trait and hence will continuously write data so long as no errors\n     /// are received. This also means that partial writes are not indicated in\n     /// this signature.\n     ///\n-    /// [writeall]: #method.write_all\n+    /// [writeall]: Self::write_all\n     ///\n     /// # Errors\n     ///\n@@ -1589,7 +1555,7 @@ pub trait Write {\n ///\n /// [`File`][file]s implement `Seek`:\n ///\n-/// [file]: ../fs/struct.File.html\n+/// [file]: crate::fs::File\n ///\n /// ```no_run\n /// use std::io;\n@@ -1789,9 +1755,9 @@ fn read_until<R: BufRead + ?Sized>(r: &mut R, delim: u8, buf: &mut Vec<u8>) -> R\n /// [`BufReader`] to the rescue!\n ///\n /// [`BufReader`]: struct.BufReader.html\n-/// [`File`]: ../fs/struct.File.html\n-/// [`read_line`]: #method.read_line\n-/// [`lines`]: #method.lines\n+/// [`File`]: crate::fs::File\n+/// [`read_line`]: Self::read_line\n+/// [`lines`]: Self::lines\n /// [`Read`]: trait.Read.html\n ///\n /// ```no_run\n@@ -1823,7 +1789,7 @@ pub trait BufRead: Read {\n     /// be called with the number of bytes that are consumed from this buffer to\n     /// ensure that the bytes are never returned twice.\n     ///\n-    /// [`consume`]: #tymethod.consume\n+    /// [`consume`]: Self::consume\n     ///\n     /// An empty buffer returned indicates that the stream has reached EOF.\n     ///\n@@ -1873,7 +1839,7 @@ pub trait BufRead: Read {\n     /// Since `consume()` is meant to be used with [`fill_buf`],\n     /// that method's example includes an example of `consume()`.\n     ///\n-    /// [`fill_buf`]: #tymethod.fill_buf\n+    /// [`fill_buf`]: Self::fill_buf\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn consume(&mut self, amt: usize);\n \n@@ -1897,7 +1863,7 @@ pub trait BufRead: Read {\n     /// If an I/O error is encountered then all bytes read so far will be\n     /// present in `buf` and its length will have been adjusted appropriately.\n     ///\n-    /// [`fill_buf`]: #tymethod.fill_buf\n+    /// [`fill_buf`]: Self::fill_buf\n     /// [`ErrorKind::Interrupted`]: enum.ErrorKind.html#variant.Interrupted\n     ///\n     /// # Examples\n@@ -1962,7 +1928,7 @@ pub trait BufRead: Read {\n     /// error is encountered then `buf` may contain some bytes already read in\n     /// the event that all data read so far was valid UTF-8.\n     ///\n-    /// [`read_until`]: #method.read_until\n+    /// [`read_until`]: Self::read_until\n     ///\n     /// # Examples\n     ///\n@@ -2015,9 +1981,9 @@ pub trait BufRead: Read {\n     /// This function will yield errors whenever [`read_until`] would have\n     /// also yielded an error.\n     ///\n-    /// [`io::Result`]: type.Result.html\n-    /// [`Vec<u8>`]: ../vec/struct.Vec.html\n-    /// [`read_until`]: #method.read_until\n+    /// [`io::Result`]: self::Result\n+    /// [`Vec<u8>`]: crate::vec::Vec\n+    /// [`read_until`]: Self::read_until\n     ///\n     /// # Examples\n     ///\n@@ -2052,17 +2018,14 @@ pub trait BufRead: Read {\n     /// [`io::Result`]`<`[`String`]`>`. Each string returned will *not* have a newline\n     /// byte (the 0xA byte) or CRLF (0xD, 0xA bytes) at the end.\n     ///\n-    /// [`io::Result`]: type.Result.html\n-    /// [`String`]: ../string/struct.String.html\n+    /// [`io::Result`]: self::Result\n     ///\n     /// # Examples\n     ///\n     /// [`std::io::Cursor`][`Cursor`] is a type that implements `BufRead`. In\n     /// this example, we use [`Cursor`] to iterate over all the lines in a byte\n     /// slice.\n     ///\n-    /// [`Cursor`]: struct.Cursor.html\n-    ///\n     /// ```\n     /// use std::io::{self, BufRead};\n     ///\n@@ -2253,8 +2216,6 @@ impl<T> Take<T> {\n     /// This instance may reach `EOF` after reading fewer bytes than indicated by\n     /// this method if the underlying [`Read`] instance reaches EOF.\n     ///\n-    /// [`Read`]: ../../std/io/trait.Read.html\n-    ///\n     /// # Examples\n     ///\n     /// ```no_run"}]}