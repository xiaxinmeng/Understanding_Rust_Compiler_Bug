{"sha": "7f97aeaf73047268299ab55288b3dd886130be47", "node_id": "C_kwDOAAsO6NoAKDdmOTdhZWFmNzMwNDcyNjgyOTlhYjU1Mjg4YjNkZDg4NjEzMGJlNDc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-05T11:10:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-05T11:10:11Z"}, "message": "Auto merge of #107679 - est31:less_import_overhead, r=compiler-errors\n\nLess import overhead for errors\n\nThis removes huge (3+ lines) import lists found in files that had their error reporting migrated. These lists are bad for developer workflows as adding, removing, or editing a single error's name might cause a chain reaction that bloats the git diff. As the error struct names are long, the likelihood of such chain reactions is high.\n\nFollows the suggestion by `@Nilstrieb` in the [zulip thread](https://rust-lang.zulipchat.com/#narrow/stream/147480-t-compiler.2Fwg-diagnostics/topic/massive.20use.20statements) to replace the `use errors::{FooErr, BarErr};` with `use errors;` and then changing to `errors::FooErr` on the usage sites.\n\nI have used sed to do most of the changes, i.e. something like:\n\n```\nsed -i -E 's/(create_err|create_feature_err|emit_err|create_note|emit_fatal|emit_warning)\\(([[:alnum:]]+|[A-Z][[:alnum:]:]*)( \\{|\\))/\\1(errors::\\2\\3/' path/to/file.rs\n```\n\n& then I manually fixed the errors that occured. Most manual changes were required in `compiler/rustc_parse/src/parser/expr.rs`.\n\nr? `@compiler-errors`", "tree": {"sha": "28ef3869cb8034a8ab5e4ad389c139ec7dbd6df1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/28ef3869cb8034a8ab5e4ad389c139ec7dbd6df1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f97aeaf73047268299ab55288b3dd886130be47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f97aeaf73047268299ab55288b3dd886130be47", "html_url": "https://github.com/rust-lang/rust/commit/7f97aeaf73047268299ab55288b3dd886130be47", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f97aeaf73047268299ab55288b3dd886130be47/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a6ff729233c62d1d991da5ed4d01aa29e59d637", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a6ff729233c62d1d991da5ed4d01aa29e59d637", "html_url": "https://github.com/rust-lang/rust/commit/2a6ff729233c62d1d991da5ed4d01aa29e59d637"}, {"sha": "580cc89e9c36a89d3cc13a352c96f874eaa76581", "url": "https://api.github.com/repos/rust-lang/rust/commits/580cc89e9c36a89d3cc13a352c96f874eaa76581", "html_url": "https://github.com/rust-lang/rust/commit/580cc89e9c36a89d3cc13a352c96f874eaa76581"}], "stats": {"total": 732, "additions": 356, "deletions": 376}, "files": [{"sha": "782a62accad9e984479cc4c1bd98d351dd6cb75b", "filename": "compiler/rustc_const_eval/src/transform/check_consts/ops.rs", "status": "modified", "additions": 35, "deletions": 37, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/7f97aeaf73047268299ab55288b3dd886130be47/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f97aeaf73047268299ab55288b3dd886130be47/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=7f97aeaf73047268299ab55288b3dd886130be47", "patch": "@@ -22,13 +22,7 @@ use rustc_span::{BytePos, Pos, Span, Symbol};\n use rustc_trait_selection::traits::SelectionContext;\n \n use super::ConstCx;\n-use crate::errors::{\n-    InteriorMutabilityBorrow, InteriorMutableDataRefer, MutDerefErr, NonConstFmtMacroCall,\n-    NonConstFnCall, NonConstOpErr, PanicNonStrErr, RawPtrToIntErr, StaticAccessErr,\n-    TransientMutBorrowErr, TransientMutBorrowErrRaw, UnallowedFnPointerCall,\n-    UnallowedHeapAllocations, UnallowedInlineAsm, UnallowedMutableRefs, UnallowedMutableRefsRaw,\n-    UnallowedOpInConstContext, UnstableConstFn,\n-};\n+use crate::errors;\n use crate::util::{call_kind, CallDesugaringKind, CallKind};\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n@@ -99,7 +93,7 @@ impl<'tcx> NonConstOp<'tcx> for FnCallIndirect {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        ccx.tcx.sess.create_err(UnallowedFnPointerCall { span, kind: ccx.const_kind() })\n+        ccx.tcx.sess.create_err(errors::UnallowedFnPointerCall { span, kind: ccx.const_kind() })\n     }\n }\n \n@@ -303,10 +297,11 @@ impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n                 diag_trait(&mut err, self_ty, tcx.require_lang_item(LangItem::Deref, Some(span)));\n                 err\n             }\n-            _ if tcx.opt_parent(callee) == tcx.get_diagnostic_item(sym::ArgumentV1Methods) => {\n-                ccx.tcx.sess.create_err(NonConstFmtMacroCall { span, kind: ccx.const_kind() })\n-            }\n-            _ => ccx.tcx.sess.create_err(NonConstFnCall {\n+            _ if tcx.opt_parent(callee) == tcx.get_diagnostic_item(sym::ArgumentV1Methods) => ccx\n+                .tcx\n+                .sess\n+                .create_err(errors::NonConstFmtMacroCall { span, kind: ccx.const_kind() }),\n+            _ => ccx.tcx.sess.create_err(errors::NonConstFnCall {\n                 span,\n                 def_path_str: ccx.tcx.def_path_str_with_substs(callee, substs),\n                 kind: ccx.const_kind(),\n@@ -351,7 +346,7 @@ impl<'tcx> NonConstOp<'tcx> for FnCallUnstable {\n         let mut err = ccx\n             .tcx\n             .sess\n-            .create_err(UnstableConstFn { span, def_path: ccx.tcx.def_path_str(def_id) });\n+            .create_err(errors::UnstableConstFn { span, def_path: ccx.tcx.def_path_str(def_id) });\n \n         if ccx.is_const_stable_const_fn() {\n             err.help(\"const-stable functions can only call other const-stable functions\");\n@@ -387,11 +382,11 @@ impl<'tcx> NonConstOp<'tcx> for Generator {\n         let msg = format!(\"{}s are not allowed in {}s\", self.0.descr(), ccx.const_kind());\n         if let hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Block) = self.0 {\n             ccx.tcx.sess.create_feature_err(\n-                UnallowedOpInConstContext { span, msg },\n+                errors::UnallowedOpInConstContext { span, msg },\n                 sym::const_async_blocks,\n             )\n         } else {\n-            ccx.tcx.sess.create_err(UnallowedOpInConstContext { span, msg })\n+            ccx.tcx.sess.create_err(errors::UnallowedOpInConstContext { span, msg })\n         }\n     }\n }\n@@ -404,7 +399,7 @@ impl<'tcx> NonConstOp<'tcx> for HeapAllocation {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        ccx.tcx.sess.create_err(UnallowedHeapAllocations {\n+        ccx.tcx.sess.create_err(errors::UnallowedHeapAllocations {\n             span,\n             kind: ccx.const_kind(),\n             teach: ccx.tcx.sess.teach(&error_code!(E0010)).then_some(()),\n@@ -420,7 +415,7 @@ impl<'tcx> NonConstOp<'tcx> for InlineAsm {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        ccx.tcx.sess.create_err(UnallowedInlineAsm { span, kind: ccx.const_kind() })\n+        ccx.tcx.sess.create_err(errors::UnallowedInlineAsm { span, kind: ccx.const_kind() })\n     }\n }\n \n@@ -471,7 +466,9 @@ impl<'tcx> NonConstOp<'tcx> for TransientCellBorrow {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        ccx.tcx.sess.create_feature_err(InteriorMutabilityBorrow { span }, sym::const_refs_to_cell)\n+        ccx.tcx\n+            .sess\n+            .create_feature_err(errors::InteriorMutabilityBorrow { span }, sym::const_refs_to_cell)\n     }\n }\n \n@@ -488,14 +485,14 @@ impl<'tcx> NonConstOp<'tcx> for CellBorrow {\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         // FIXME: Maybe a more elegant solution to this if else case\n         if let hir::ConstContext::Static(_) = ccx.const_kind() {\n-            ccx.tcx.sess.create_err(InteriorMutableDataRefer {\n+            ccx.tcx.sess.create_err(errors::InteriorMutableDataRefer {\n                 span,\n                 opt_help: Some(()),\n                 kind: ccx.const_kind(),\n                 teach: ccx.tcx.sess.teach(&error_code!(E0492)).then_some(()),\n             })\n         } else {\n-            ccx.tcx.sess.create_err(InteriorMutableDataRefer {\n+            ccx.tcx.sess.create_err(errors::InteriorMutableDataRefer {\n                 span,\n                 opt_help: None,\n                 kind: ccx.const_kind(),\n@@ -528,12 +525,12 @@ impl<'tcx> NonConstOp<'tcx> for MutBorrow {\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         match self.0 {\n-            hir::BorrowKind::Raw => ccx.tcx.sess.create_err(UnallowedMutableRefsRaw {\n+            hir::BorrowKind::Raw => ccx.tcx.sess.create_err(errors::UnallowedMutableRefsRaw {\n                 span,\n                 kind: ccx.const_kind(),\n                 teach: ccx.tcx.sess.teach(&error_code!(E0764)).then_some(()),\n             }),\n-            hir::BorrowKind::Ref => ccx.tcx.sess.create_err(UnallowedMutableRefs {\n+            hir::BorrowKind::Ref => ccx.tcx.sess.create_err(errors::UnallowedMutableRefs {\n                 span,\n                 kind: ccx.const_kind(),\n                 teach: ccx.tcx.sess.teach(&error_code!(E0764)).then_some(()),\n@@ -557,14 +554,14 @@ impl<'tcx> NonConstOp<'tcx> for TransientMutBorrow {\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let kind = ccx.const_kind();\n         match self.0 {\n-            hir::BorrowKind::Raw => ccx\n-                .tcx\n-                .sess\n-                .create_feature_err(TransientMutBorrowErrRaw { span, kind }, sym::const_mut_refs),\n-            hir::BorrowKind::Ref => ccx\n-                .tcx\n-                .sess\n-                .create_feature_err(TransientMutBorrowErr { span, kind }, sym::const_mut_refs),\n+            hir::BorrowKind::Raw => ccx.tcx.sess.create_feature_err(\n+                errors::TransientMutBorrowErrRaw { span, kind },\n+                sym::const_mut_refs,\n+            ),\n+            hir::BorrowKind::Ref => ccx.tcx.sess.create_feature_err(\n+                errors::TransientMutBorrowErr { span, kind },\n+                sym::const_mut_refs,\n+            ),\n         }\n     }\n }\n@@ -586,9 +583,10 @@ impl<'tcx> NonConstOp<'tcx> for MutDeref {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        ccx.tcx\n-            .sess\n-            .create_feature_err(MutDerefErr { span, kind: ccx.const_kind() }, sym::const_mut_refs)\n+        ccx.tcx.sess.create_feature_err(\n+            errors::MutDerefErr { span, kind: ccx.const_kind() },\n+            sym::const_mut_refs,\n+        )\n     }\n }\n \n@@ -601,7 +599,7 @@ impl<'tcx> NonConstOp<'tcx> for PanicNonStr {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        ccx.tcx.sess.create_err(PanicNonStrErr { span })\n+        ccx.tcx.sess.create_err(errors::PanicNonStrErr { span })\n     }\n }\n \n@@ -652,7 +650,7 @@ impl<'tcx> NonConstOp<'tcx> for RawPtrToIntCast {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        ccx.tcx.sess.create_err(RawPtrToIntErr { span })\n+        ccx.tcx.sess.create_err(errors::RawPtrToIntErr { span })\n     }\n }\n \n@@ -673,7 +671,7 @@ impl<'tcx> NonConstOp<'tcx> for StaticAccess {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        ccx.tcx.sess.create_err(StaticAccessErr {\n+        ccx.tcx.sess.create_err(errors::StaticAccessErr {\n             span,\n             kind: ccx.const_kind(),\n             teach: ccx.tcx.sess.teach(&error_code!(E0013)).then_some(()),\n@@ -690,7 +688,7 @@ impl<'tcx> NonConstOp<'tcx> for ThreadLocalAccess {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        ccx.tcx.sess.create_err(NonConstOpErr { span })\n+        ccx.tcx.sess.create_err(errors::NonConstOpErr { span })\n     }\n }\n "}, {"sha": "cf7cff739b340f346ac59d75309c3a13f4fd109c", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7f97aeaf73047268299ab55288b3dd886130be47/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f97aeaf73047268299ab55288b3dd886130be47/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=7f97aeaf73047268299ab55288b3dd886130be47", "patch": "@@ -1,11 +1,6 @@\n #![deny(rustc::untranslatable_diagnostic)]\n \n-use crate::errors::{\n-    ArgumentNotAttributes, AttrNoArguments, AttributeMetaItem, AttributeSingleWord,\n-    AttributesWrongForm, CannotBeNameOfMacro, ExpectedCommaInList, HelperAttributeNameInvalid,\n-    MacroBodyStability, MacroConstStability, NotAMetaItem, OnlyOneArgument, OnlyOneWord,\n-    ResolveRelativePath, TakesNoArguments, TraceMacro,\n-};\n+use crate::errors;\n use crate::expand::{self, AstFragment, Invocation};\n use crate::module::DirOwnership;\n \n@@ -796,13 +791,13 @@ impl SyntaxExtension {\n             .unwrap_or_else(|| (None, helper_attrs));\n         let (stability, const_stability, body_stability) = attr::find_stability(&sess, attrs, span);\n         if let Some((_, sp)) = const_stability {\n-            sess.emit_err(MacroConstStability {\n+            sess.emit_err(errors::MacroConstStability {\n                 span: sp,\n                 head_span: sess.source_map().guess_head_span(span),\n             });\n         }\n         if let Some((_, sp)) = body_stability {\n-            sess.emit_err(MacroBodyStability {\n+            sess.emit_err(errors::MacroBodyStability {\n                 span: sp,\n                 head_span: sess.source_map().guess_head_span(span),\n             });\n@@ -1143,7 +1138,7 @@ impl<'a> ExtCtxt<'a> {\n     }\n     pub fn trace_macros_diag(&mut self) {\n         for (span, notes) in self.expansions.iter() {\n-            let mut db = self.sess.parse_sess.create_note(TraceMacro { span: *span });\n+            let mut db = self.sess.parse_sess.create_note(errors::TraceMacro { span: *span });\n             for note in notes {\n                 db.note(note);\n             }\n@@ -1197,7 +1192,7 @@ pub fn resolve_path(\n                 .expect(\"attempting to resolve a file path in an external file\"),\n             FileName::DocTest(path, _) => path,\n             other => {\n-                return Err(ResolveRelativePath {\n+                return Err(errors::ResolveRelativePath {\n                     span,\n                     path: parse_sess.source_map().filename_for_diagnostics(&other).to_string(),\n                 }\n@@ -1279,7 +1274,7 @@ pub fn expr_to_string(\n /// done as rarely as possible).\n pub fn check_zero_tts(cx: &ExtCtxt<'_>, span: Span, tts: TokenStream, name: &str) {\n     if !tts.is_empty() {\n-        cx.emit_err(TakesNoArguments { span, name });\n+        cx.emit_err(errors::TakesNoArguments { span, name });\n     }\n }\n \n@@ -1307,14 +1302,14 @@ pub fn get_single_str_from_tts(\n ) -> Option<Symbol> {\n     let mut p = cx.new_parser_from_tts(tts);\n     if p.token == token::Eof {\n-        cx.emit_err(OnlyOneArgument { span, name });\n+        cx.emit_err(errors::OnlyOneArgument { span, name });\n         return None;\n     }\n     let ret = parse_expr(&mut p)?;\n     let _ = p.eat(&token::Comma);\n \n     if p.token != token::Eof {\n-        cx.emit_err(OnlyOneArgument { span, name });\n+        cx.emit_err(errors::OnlyOneArgument { span, name });\n     }\n     expr_to_string(cx, ret, \"argument must be a string literal\").map(|(s, _)| s)\n }\n@@ -1336,7 +1331,7 @@ pub fn get_exprs_from_tts(cx: &mut ExtCtxt<'_>, tts: TokenStream) -> Option<Vec<\n             continue;\n         }\n         if p.token != token::Eof {\n-            cx.emit_err(ExpectedCommaInList { span: p.token.span });\n+            cx.emit_err(errors::ExpectedCommaInList { span: p.token.span });\n             return None;\n         }\n     }\n@@ -1353,51 +1348,58 @@ pub fn parse_macro_name_and_helper_attrs(\n     // `#[proc_macro_derive(Foo, attributes(A, ..))]`\n     let list = attr.meta_item_list()?;\n     if list.len() != 1 && list.len() != 2 {\n-        diag.emit_err(AttrNoArguments { span: attr.span });\n+        diag.emit_err(errors::AttrNoArguments { span: attr.span });\n         return None;\n     }\n     let Some(trait_attr) = list[0].meta_item() else {\n-        diag.emit_err(NotAMetaItem {span: list[0].span()});\n+        diag.emit_err(errors::NotAMetaItem {span: list[0].span()});\n         return None;\n     };\n     let trait_ident = match trait_attr.ident() {\n         Some(trait_ident) if trait_attr.is_word() => trait_ident,\n         _ => {\n-            diag.emit_err(OnlyOneWord { span: trait_attr.span });\n+            diag.emit_err(errors::OnlyOneWord { span: trait_attr.span });\n             return None;\n         }\n     };\n \n     if !trait_ident.name.can_be_raw() {\n-        diag.emit_err(CannotBeNameOfMacro { span: trait_attr.span, trait_ident, macro_type });\n+        diag.emit_err(errors::CannotBeNameOfMacro {\n+            span: trait_attr.span,\n+            trait_ident,\n+            macro_type,\n+        });\n     }\n \n     let attributes_attr = list.get(1);\n     let proc_attrs: Vec<_> = if let Some(attr) = attributes_attr {\n         if !attr.has_name(sym::attributes) {\n-            diag.emit_err(ArgumentNotAttributes { span: attr.span() });\n+            diag.emit_err(errors::ArgumentNotAttributes { span: attr.span() });\n         }\n         attr.meta_item_list()\n             .unwrap_or_else(|| {\n-                diag.emit_err(AttributesWrongForm { span: attr.span() });\n+                diag.emit_err(errors::AttributesWrongForm { span: attr.span() });\n                 &[]\n             })\n             .iter()\n             .filter_map(|attr| {\n                 let Some(attr) = attr.meta_item() else {\n-                    diag.emit_err(AttributeMetaItem { span: attr.span() });\n+                    diag.emit_err(errors::AttributeMetaItem { span: attr.span() });\n                     return None;\n                 };\n \n                 let ident = match attr.ident() {\n                     Some(ident) if attr.is_word() => ident,\n                     _ => {\n-                        diag.emit_err(AttributeSingleWord { span: attr.span });\n+                        diag.emit_err(errors::AttributeSingleWord { span: attr.span });\n                         return None;\n                     }\n                 };\n                 if !ident.name.can_be_raw() {\n-                    diag.emit_err(HelperAttributeNameInvalid { span: attr.span, name: ident });\n+                    diag.emit_err(errors::HelperAttributeNameInvalid {\n+                        span: attr.span,\n+                        name: ident,\n+                    });\n                 }\n \n                 Some(ident.name)"}, {"sha": "2a373ebc1324da0112c47002f85b2b1e86e62b5f", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7f97aeaf73047268299ab55288b3dd886130be47/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f97aeaf73047268299ab55288b3dd886130be47/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=7f97aeaf73047268299ab55288b3dd886130be47", "patch": "@@ -1,9 +1,4 @@\n-use crate::errors::{\n-    CantEmitMIR, EmojiIdentifier, ErrorWritingDependencies, FerrisIdentifier,\n-    GeneratedFileConflictsWithDirectory, InputFileWouldBeOverWritten, MixedBinCrate,\n-    MixedProcMacroCrate, OutDirError, ProcMacroCratePanicAbort, ProcMacroDocWithoutArg,\n-    TempsDirError,\n-};\n+use crate::errors;\n use crate::interface::{Compiler, Result};\n use crate::proc_macro_decls;\n use crate::util;\n@@ -374,15 +369,15 @@ pub fn configure_and_expand(\n \n     if crate_types.len() > 1 {\n         if is_executable_crate {\n-            sess.emit_err(MixedBinCrate);\n+            sess.emit_err(errors::MixedBinCrate);\n         }\n         if is_proc_macro_crate {\n-            sess.emit_err(MixedProcMacroCrate);\n+            sess.emit_err(errors::MixedProcMacroCrate);\n         }\n     }\n \n     if is_proc_macro_crate && sess.panic_strategy() == PanicStrategy::Abort {\n-        sess.emit_warning(ProcMacroCratePanicAbort);\n+        sess.emit_warning(errors::ProcMacroCratePanicAbort);\n     }\n \n     // For backwards compatibility, we don't try to run proc macro injection\n@@ -392,7 +387,7 @@ pub fn configure_and_expand(\n     // However, we do emit a warning, to let such users know that they should\n     // start passing '--crate-type proc-macro'\n     if has_proc_macro_decls && sess.opts.actually_rustdoc && !is_proc_macro_crate {\n-        sess.emit_warning(ProcMacroDocWithoutArg);\n+        sess.emit_warning(errors::ProcMacroDocWithoutArg);\n     } else {\n         krate = sess.time(\"maybe_create_a_macro_crate\", || {\n             let is_test_crate = sess.opts.test;\n@@ -441,9 +436,9 @@ pub fn configure_and_expand(\n             spans.sort();\n             if ident == sym::ferris {\n                 let first_span = spans[0];\n-                sess.emit_err(FerrisIdentifier { spans, first_span });\n+                sess.emit_err(errors::FerrisIdentifier { spans, first_span });\n             } else {\n-                sess.emit_err(EmojiIdentifier { spans, ident });\n+                sess.emit_err(errors::EmojiIdentifier { spans, ident });\n             }\n         }\n     });\n@@ -655,7 +650,7 @@ fn write_out_deps(\n             }\n         }\n         Err(error) => {\n-            sess.emit_fatal(ErrorWritingDependencies { path: &deps_filename, error });\n+            sess.emit_fatal(errors::ErrorWritingDependencies { path: &deps_filename, error });\n         }\n     }\n }\n@@ -676,17 +671,20 @@ fn output_filenames(tcx: TyCtxt<'_>, (): ()) -> Arc<OutputFilenames> {\n     if let Some(ref input_path) = sess.io.input.opt_path() {\n         if sess.opts.will_create_output_file() {\n             if output_contains_path(&output_paths, input_path) {\n-                sess.emit_fatal(InputFileWouldBeOverWritten { path: input_path });\n+                sess.emit_fatal(errors::InputFileWouldBeOverWritten { path: input_path });\n             }\n             if let Some(ref dir_path) = output_conflicts_with_dir(&output_paths) {\n-                sess.emit_fatal(GeneratedFileConflictsWithDirectory { input_path, dir_path });\n+                sess.emit_fatal(errors::GeneratedFileConflictsWithDirectory {\n+                    input_path,\n+                    dir_path,\n+                });\n             }\n         }\n     }\n \n     if let Some(ref dir) = sess.io.temps_dir {\n         if fs::create_dir_all(dir).is_err() {\n-            sess.emit_fatal(TempsDirError);\n+            sess.emit_fatal(errors::TempsDirError);\n         }\n     }\n \n@@ -698,7 +696,7 @@ fn output_filenames(tcx: TyCtxt<'_>, (): ()) -> Arc<OutputFilenames> {\n     if !only_dep_info {\n         if let Some(ref dir) = sess.io.output_dir {\n             if fs::create_dir_all(dir).is_err() {\n-                sess.emit_fatal(OutDirError);\n+                sess.emit_fatal(errors::OutDirError);\n             }\n         }\n     }\n@@ -977,7 +975,7 @@ pub fn start_codegen<'tcx>(\n \n     if tcx.sess.opts.output_types.contains_key(&OutputType::Mir) {\n         if let Err(error) = rustc_mir_transform::dump_mir::emit_mir(tcx) {\n-            tcx.sess.emit_err(CantEmitMIR { error });\n+            tcx.sess.emit_err(errors::CantEmitMIR { error });\n             tcx.sess.abort_if_errors();\n         }\n     }"}, {"sha": "21652063b47167585124ef8f3293cc7acf031985", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7f97aeaf73047268299ab55288b3dd886130be47/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f97aeaf73047268299ab55288b3dd886130be47/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=7f97aeaf73047268299ab55288b3dd886130be47", "patch": "@@ -1,10 +1,6 @@\n //! Validates all used crates and extern libraries and loads their metadata\n \n-use crate::errors::{\n-    ConflictingAllocErrorHandler, ConflictingGlobalAlloc, CrateNotPanicRuntime,\n-    GlobalAllocRequired, NoMultipleAllocErrorHandler, NoMultipleGlobalAlloc, NoPanicStrategy,\n-    NoTransitiveNeedsDep, NotProfilerRuntime, ProfilerBuiltinsNeedsCore,\n-};\n+use crate::errors;\n use crate::locator::{CrateError, CrateLocator, CratePaths};\n use crate::rmeta::{CrateDep, CrateMetadata, CrateNumMap, CrateRoot, MetadataBlob};\n \n@@ -768,10 +764,11 @@ impl<'a> CrateLoader<'a> {\n         // Sanity check the loaded crate to ensure it is indeed a panic runtime\n         // and the panic strategy is indeed what we thought it was.\n         if !data.is_panic_runtime() {\n-            self.sess.emit_err(CrateNotPanicRuntime { crate_name: name });\n+            self.sess.emit_err(errors::CrateNotPanicRuntime { crate_name: name });\n         }\n         if data.required_panic_strategy() != Some(desired_strategy) {\n-            self.sess.emit_err(NoPanicStrategy { crate_name: name, strategy: desired_strategy });\n+            self.sess\n+                .emit_err(errors::NoPanicStrategy { crate_name: name, strategy: desired_strategy });\n         }\n \n         self.cstore.injected_panic_runtime = Some(cnum);\n@@ -791,29 +788,30 @@ impl<'a> CrateLoader<'a> {\n \n         let name = Symbol::intern(&self.sess.opts.unstable_opts.profiler_runtime);\n         if name == sym::profiler_builtins && self.sess.contains_name(&krate.attrs, sym::no_core) {\n-            self.sess.emit_err(ProfilerBuiltinsNeedsCore);\n+            self.sess.emit_err(errors::ProfilerBuiltinsNeedsCore);\n         }\n \n         let Some(cnum) = self.resolve_crate(name, DUMMY_SP, CrateDepKind::Implicit) else { return; };\n         let data = self.cstore.get_crate_data(cnum);\n \n         // Sanity check the loaded crate to ensure it is indeed a profiler runtime\n         if !data.is_profiler_runtime() {\n-            self.sess.emit_err(NotProfilerRuntime { crate_name: name });\n+            self.sess.emit_err(errors::NotProfilerRuntime { crate_name: name });\n         }\n     }\n \n     fn inject_allocator_crate(&mut self, krate: &ast::Crate) {\n         self.cstore.has_global_allocator = match &*global_allocator_spans(&self.sess, krate) {\n             [span1, span2, ..] => {\n-                self.sess.emit_err(NoMultipleGlobalAlloc { span2: *span2, span1: *span1 });\n+                self.sess.emit_err(errors::NoMultipleGlobalAlloc { span2: *span2, span1: *span1 });\n                 true\n             }\n             spans => !spans.is_empty(),\n         };\n         self.cstore.has_alloc_error_handler = match &*alloc_error_handler_spans(&self.sess, krate) {\n             [span1, span2, ..] => {\n-                self.sess.emit_err(NoMultipleAllocErrorHandler { span2: *span2, span1: *span1 });\n+                self.sess\n+                    .emit_err(errors::NoMultipleAllocErrorHandler { span2: *span2, span1: *span1 });\n                 true\n             }\n             spans => !spans.is_empty(),\n@@ -849,7 +847,7 @@ impl<'a> CrateLoader<'a> {\n             if data.has_global_allocator() {\n                 match global_allocator {\n                     Some(other_crate) => {\n-                        self.sess.emit_err(ConflictingGlobalAlloc {\n+                        self.sess.emit_err(errors::ConflictingGlobalAlloc {\n                             crate_name: data.name(),\n                             other_crate_name: other_crate,\n                         });\n@@ -864,7 +862,7 @@ impl<'a> CrateLoader<'a> {\n             if data.has_alloc_error_handler() {\n                 match alloc_error_handler {\n                     Some(other_crate) => {\n-                        self.sess.emit_err(ConflictingAllocErrorHandler {\n+                        self.sess.emit_err(errors::ConflictingAllocErrorHandler {\n                             crate_name: data.name(),\n                             other_crate_name: other_crate,\n                         });\n@@ -884,7 +882,7 @@ impl<'a> CrateLoader<'a> {\n             if !self.sess.contains_name(&krate.attrs, sym::default_lib_allocator)\n                 && !self.cstore.iter_crate_data().any(|(_, data)| data.has_default_lib_allocator())\n             {\n-                self.sess.emit_err(GlobalAllocRequired);\n+                self.sess.emit_err(errors::GlobalAllocRequired);\n             }\n             self.cstore.allocator_kind = Some(AllocatorKind::Default);\n         }\n@@ -917,7 +915,7 @@ impl<'a> CrateLoader<'a> {\n         for dep in self.cstore.crate_dependencies_in_reverse_postorder(krate) {\n             let data = self.cstore.get_crate_data(dep);\n             if needs_dep(&data) {\n-                self.sess.emit_err(NoTransitiveNeedsDep {\n+                self.sess.emit_err(errors::NoTransitiveNeedsDep {\n                     crate_name: self.cstore.get_crate_data(krate).name(),\n                     needs_crate_name: what,\n                     deps_crate_name: data.name(),"}, {"sha": "74f91a14ea9ae742c2e93a338fa8e050b62f23d9", "filename": "compiler/rustc_metadata/src/locator.rs", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7f97aeaf73047268299ab55288b3dd886130be47/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f97aeaf73047268299ab55288b3dd886130be47/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs?ref=7f97aeaf73047268299ab55288b3dd886130be47", "patch": "@@ -213,12 +213,7 @@\n //! metadata::locator or metadata::creader for all the juicy details!\n \n use crate::creader::Library;\n-use crate::errors::{\n-    CannotFindCrate, CrateLocationUnknownType, DlError, ExternLocationNotExist,\n-    ExternLocationNotFile, FoundStaticlib, IncompatibleRustc, InvalidMetadataFiles,\n-    LibFilenameForm, MultipleCandidates, NewerCrateVersion, NoCrateWithTriple, NoDylibPlugin,\n-    NonAsciiName, StableCrateIdCollision, SymbolConflictsCurrent, SymbolConflictsOthers,\n-};\n+use crate::errors;\n use crate::rmeta::{rustc_version, MetadataBlob, METADATA_HEADER};\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -980,28 +975,28 @@ impl CrateError {\n     pub(crate) fn report(self, sess: &Session, span: Span, missing_core: bool) {\n         match self {\n             CrateError::NonAsciiName(crate_name) => {\n-                sess.emit_err(NonAsciiName { span, crate_name });\n+                sess.emit_err(errors::NonAsciiName { span, crate_name });\n             }\n             CrateError::ExternLocationNotExist(crate_name, loc) => {\n-                sess.emit_err(ExternLocationNotExist { span, crate_name, location: &loc });\n+                sess.emit_err(errors::ExternLocationNotExist { span, crate_name, location: &loc });\n             }\n             CrateError::ExternLocationNotFile(crate_name, loc) => {\n-                sess.emit_err(ExternLocationNotFile { span, crate_name, location: &loc });\n+                sess.emit_err(errors::ExternLocationNotFile { span, crate_name, location: &loc });\n             }\n             CrateError::MultipleCandidates(crate_name, flavor, candidates) => {\n-                sess.emit_err(MultipleCandidates { span, crate_name, flavor, candidates });\n+                sess.emit_err(errors::MultipleCandidates { span, crate_name, flavor, candidates });\n             }\n             CrateError::SymbolConflictsCurrent(root_name) => {\n-                sess.emit_err(SymbolConflictsCurrent { span, crate_name: root_name });\n+                sess.emit_err(errors::SymbolConflictsCurrent { span, crate_name: root_name });\n             }\n             CrateError::SymbolConflictsOthers(root_name) => {\n-                sess.emit_err(SymbolConflictsOthers { span, crate_name: root_name });\n+                sess.emit_err(errors::SymbolConflictsOthers { span, crate_name: root_name });\n             }\n             CrateError::StableCrateIdCollision(crate_name0, crate_name1) => {\n-                sess.emit_err(StableCrateIdCollision { span, crate_name0, crate_name1 });\n+                sess.emit_err(errors::StableCrateIdCollision { span, crate_name0, crate_name1 });\n             }\n             CrateError::DlOpen(s) | CrateError::DlSym(s) => {\n-                sess.emit_err(DlError { span, err: s });\n+                sess.emit_err(errors::DlError { span, err: s });\n             }\n             CrateError::LocatorCombined(locator) => {\n                 let crate_name = locator.crate_name;\n@@ -1012,8 +1007,12 @@ impl CrateError {\n                 if !locator.crate_rejections.via_filename.is_empty() {\n                     let mismatches = locator.crate_rejections.via_filename.iter();\n                     for CrateMismatch { path, .. } in mismatches {\n-                        sess.emit_err(CrateLocationUnknownType { span, path: &path, crate_name });\n-                        sess.emit_err(LibFilenameForm {\n+                        sess.emit_err(errors::CrateLocationUnknownType {\n+                            span,\n+                            path: &path,\n+                            crate_name,\n+                        });\n+                        sess.emit_err(errors::LibFilenameForm {\n                             span,\n                             dll_prefix: &locator.dll_prefix,\n                             dll_suffix: &locator.dll_suffix,\n@@ -1039,7 +1038,7 @@ impl CrateError {\n                             ));\n                         }\n                     }\n-                    sess.emit_err(NewerCrateVersion {\n+                    sess.emit_err(errors::NewerCrateVersion {\n                         span,\n                         crate_name: crate_name,\n                         add_info,\n@@ -1055,7 +1054,7 @@ impl CrateError {\n                             path.display(),\n                         ));\n                     }\n-                    sess.emit_err(NoCrateWithTriple {\n+                    sess.emit_err(errors::NoCrateWithTriple {\n                         span,\n                         crate_name,\n                         locator_triple: locator.triple.triple(),\n@@ -1071,7 +1070,12 @@ impl CrateError {\n                             path.display()\n                         ));\n                     }\n-                    sess.emit_err(FoundStaticlib { span, crate_name, add_info, found_crates });\n+                    sess.emit_err(errors::FoundStaticlib {\n+                        span,\n+                        crate_name,\n+                        add_info,\n+                        found_crates,\n+                    });\n                 } else if !locator.crate_rejections.via_version.is_empty() {\n                     let mismatches = locator.crate_rejections.via_version.iter();\n                     for CrateMismatch { path, got } in mismatches {\n@@ -1082,7 +1086,7 @@ impl CrateError {\n                             path.display(),\n                         ));\n                     }\n-                    sess.emit_err(IncompatibleRustc {\n+                    sess.emit_err(errors::IncompatibleRustc {\n                         span,\n                         crate_name,\n                         add_info,\n@@ -1094,14 +1098,14 @@ impl CrateError {\n                     for CrateMismatch { path: _, got } in locator.crate_rejections.via_invalid {\n                         crate_rejections.push(got);\n                     }\n-                    sess.emit_err(InvalidMetadataFiles {\n+                    sess.emit_err(errors::InvalidMetadataFiles {\n                         span,\n                         crate_name,\n                         add_info,\n                         crate_rejections,\n                     });\n                 } else {\n-                    sess.emit_err(CannotFindCrate {\n+                    sess.emit_err(errors::CannotFindCrate {\n                         span,\n                         crate_name,\n                         add_info,\n@@ -1118,7 +1122,7 @@ impl CrateError {\n                 }\n             }\n             CrateError::NonDylibPlugin(crate_name) => {\n-                sess.emit_err(NoDylibPlugin { span, crate_name });\n+                sess.emit_err(errors::NoDylibPlugin { span, crate_name });\n             }\n         }\n     }"}, {"sha": "e263fc7483537607483a9da0de99a0f4bdb881d4", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 49, "deletions": 54, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/7f97aeaf73047268299ab55288b3dd886130be47/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f97aeaf73047268299ab55288b3dd886130be47/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=7f97aeaf73047268299ab55288b3dd886130be47", "patch": "@@ -13,17 +13,7 @@ use rustc_session::Session;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_target::spec::abi::Abi;\n \n-use crate::errors::{\n-    AsNeededCompatibility, BundleNeedsStatic, EmptyLinkName, EmptyRenamingTarget,\n-    FrameworkOnlyWindows, ImportNameTypeForm, ImportNameTypeRaw, ImportNameTypeX86,\n-    IncompatibleWasmLink, InvalidLinkModifier, LibFrameworkApple, LinkCfgForm,\n-    LinkCfgSinglePredicate, LinkFrameworkApple, LinkKindForm, LinkModifiersForm, LinkNameForm,\n-    LinkOrdinalRawDylib, LinkRequiresName, MissingNativeLibrary, MultipleCfgs,\n-    MultipleImportNameType, MultipleKindsInLink, MultipleLinkModifiers, MultipleModifiers,\n-    MultipleNamesInLink, MultipleRenamings, MultipleWasmImport, NoLinkModOverride, RawDylibNoNul,\n-    RenamingNoLink, UnexpectedLinkArg, UnknownImportNameType, UnknownLinkKind, UnknownLinkModifier,\n-    UnsupportedAbi, UnsupportedAbiI686, WasmImportForm, WholeArchiveNeedsStatic,\n-};\n+use crate::errors;\n \n use std::path::PathBuf;\n \n@@ -52,7 +42,7 @@ pub fn find_native_static_library(\n         }\n     }\n \n-    sess.emit_fatal(MissingNativeLibrary::new(name, verbatim));\n+    sess.emit_fatal(errors::MissingNativeLibrary::new(name, verbatim));\n }\n \n fn find_bundled_library(\n@@ -129,26 +119,26 @@ impl<'tcx> Collector<'tcx> {\n                 match item.name_or_empty() {\n                     sym::name => {\n                         if name.is_some() {\n-                            sess.emit_err(MultipleNamesInLink { span: item.span() });\n+                            sess.emit_err(errors::MultipleNamesInLink { span: item.span() });\n                             continue;\n                         }\n                         let Some(link_name) = item.value_str() else {\n-                            sess.emit_err(LinkNameForm { span: item.span() });\n+                            sess.emit_err(errors::LinkNameForm { span: item.span() });\n                             continue;\n                         };\n                         let span = item.name_value_literal_span().unwrap();\n                         if link_name.is_empty() {\n-                            sess.emit_err(EmptyLinkName { span });\n+                            sess.emit_err(errors::EmptyLinkName { span });\n                         }\n                         name = Some((link_name, span));\n                     }\n                     sym::kind => {\n                         if kind.is_some() {\n-                            sess.emit_err(MultipleKindsInLink { span: item.span() });\n+                            sess.emit_err(errors::MultipleKindsInLink { span: item.span() });\n                             continue;\n                         }\n                         let Some(link_kind) = item.value_str() else {\n-                            sess.emit_err(LinkKindForm { span: item.span() });\n+                            sess.emit_err(errors::LinkKindForm { span: item.span() });\n                             continue;\n                         };\n \n@@ -158,13 +148,13 @@ impl<'tcx> Collector<'tcx> {\n                             \"dylib\" => NativeLibKind::Dylib { as_needed: None },\n                             \"framework\" => {\n                                 if !sess.target.is_like_osx {\n-                                    sess.emit_err(LinkFrameworkApple { span });\n+                                    sess.emit_err(errors::LinkFrameworkApple { span });\n                                 }\n                                 NativeLibKind::Framework { as_needed: None }\n                             }\n                             \"raw-dylib\" => {\n                                 if !sess.target.is_like_windows {\n-                                    sess.emit_err(FrameworkOnlyWindows { span });\n+                                    sess.emit_err(errors::FrameworkOnlyWindows { span });\n                                 } else if !features.raw_dylib && sess.target.arch == \"x86\" {\n                                     feature_err(\n                                         &sess.parse_sess,\n@@ -177,34 +167,34 @@ impl<'tcx> Collector<'tcx> {\n                                 NativeLibKind::RawDylib\n                             }\n                             kind => {\n-                                sess.emit_err(UnknownLinkKind { span, kind });\n+                                sess.emit_err(errors::UnknownLinkKind { span, kind });\n                                 continue;\n                             }\n                         };\n                         kind = Some(link_kind);\n                     }\n                     sym::modifiers => {\n                         if modifiers.is_some() {\n-                            sess.emit_err(MultipleLinkModifiers { span: item.span() });\n+                            sess.emit_err(errors::MultipleLinkModifiers { span: item.span() });\n                             continue;\n                         }\n                         let Some(link_modifiers) = item.value_str() else {\n-                            sess.emit_err(LinkModifiersForm { span: item.span() });\n+                            sess.emit_err(errors::LinkModifiersForm { span: item.span() });\n                             continue;\n                         };\n                         modifiers = Some((link_modifiers, item.name_value_literal_span().unwrap()));\n                     }\n                     sym::cfg => {\n                         if cfg.is_some() {\n-                            sess.emit_err(MultipleCfgs { span: item.span() });\n+                            sess.emit_err(errors::MultipleCfgs { span: item.span() });\n                             continue;\n                         }\n                         let Some(link_cfg) = item.meta_item_list() else {\n-                            sess.emit_err(LinkCfgForm { span: item.span() });\n+                            sess.emit_err(errors::LinkCfgForm { span: item.span() });\n                             continue;\n                         };\n                         let [NestedMetaItem::MetaItem(link_cfg)] = link_cfg else {\n-                            sess.emit_err(LinkCfgSinglePredicate { span: item.span() });\n+                            sess.emit_err(errors::LinkCfgSinglePredicate { span: item.span() });\n                             continue;\n                         };\n                         if !features.link_cfg {\n@@ -220,26 +210,26 @@ impl<'tcx> Collector<'tcx> {\n                     }\n                     sym::wasm_import_module => {\n                         if wasm_import_module.is_some() {\n-                            sess.emit_err(MultipleWasmImport { span: item.span() });\n+                            sess.emit_err(errors::MultipleWasmImport { span: item.span() });\n                             continue;\n                         }\n                         let Some(link_wasm_import_module) = item.value_str() else {\n-                            sess.emit_err(WasmImportForm { span: item.span() });\n+                            sess.emit_err(errors::WasmImportForm { span: item.span() });\n                             continue;\n                         };\n                         wasm_import_module = Some((link_wasm_import_module, item.span()));\n                     }\n                     sym::import_name_type => {\n                         if import_name_type.is_some() {\n-                            sess.emit_err(MultipleImportNameType { span: item.span() });\n+                            sess.emit_err(errors::MultipleImportNameType { span: item.span() });\n                             continue;\n                         }\n                         let Some(link_import_name_type) = item.value_str() else {\n-                            sess.emit_err(ImportNameTypeForm { span: item.span() });\n+                            sess.emit_err(errors::ImportNameTypeForm { span: item.span() });\n                             continue;\n                         };\n                         if self.tcx.sess.target.arch != \"x86\" {\n-                            sess.emit_err(ImportNameTypeX86 { span: item.span() });\n+                            sess.emit_err(errors::ImportNameTypeX86 { span: item.span() });\n                             continue;\n                         }\n \n@@ -248,7 +238,7 @@ impl<'tcx> Collector<'tcx> {\n                             \"noprefix\" => PeImportNameType::NoPrefix,\n                             \"undecorated\" => PeImportNameType::Undecorated,\n                             import_name_type => {\n-                                sess.emit_err(UnknownImportNameType {\n+                                sess.emit_err(errors::UnknownImportNameType {\n                                     span: item.span(),\n                                     import_name_type,\n                                 });\n@@ -268,7 +258,7 @@ impl<'tcx> Collector<'tcx> {\n                         import_name_type = Some((link_import_name_type, item.span()));\n                     }\n                     _ => {\n-                        sess.emit_err(UnexpectedLinkArg { span: item.span() });\n+                        sess.emit_err(errors::UnexpectedLinkArg { span: item.span() });\n                     }\n                 }\n             }\n@@ -280,7 +270,7 @@ impl<'tcx> Collector<'tcx> {\n                     let (modifier, value) = match modifier.strip_prefix(&['+', '-']) {\n                         Some(m) => (m, modifier.starts_with('+')),\n                         None => {\n-                            sess.emit_err(InvalidLinkModifier { span });\n+                            sess.emit_err(errors::InvalidLinkModifier { span });\n                             continue;\n                         }\n                     };\n@@ -298,7 +288,7 @@ impl<'tcx> Collector<'tcx> {\n                     }\n                     let assign_modifier = |dst: &mut Option<bool>| {\n                         if dst.is_some() {\n-                            sess.emit_err(MultipleModifiers { span, modifier });\n+                            sess.emit_err(errors::MultipleModifiers { span, modifier });\n                         } else {\n                             *dst = Some(value);\n                         }\n@@ -308,7 +298,7 @@ impl<'tcx> Collector<'tcx> {\n                             assign_modifier(bundle)\n                         }\n                         (\"bundle\", _) => {\n-                            sess.emit_err(BundleNeedsStatic { span });\n+                            sess.emit_err(errors::BundleNeedsStatic { span });\n                         }\n \n                         (\"verbatim\", _) => assign_modifier(&mut verbatim),\n@@ -317,7 +307,7 @@ impl<'tcx> Collector<'tcx> {\n                             assign_modifier(whole_archive)\n                         }\n                         (\"whole-archive\", _) => {\n-                            sess.emit_err(WholeArchiveNeedsStatic { span });\n+                            sess.emit_err(errors::WholeArchiveNeedsStatic { span });\n                         }\n \n                         (\"as-needed\", Some(NativeLibKind::Dylib { as_needed }))\n@@ -326,35 +316,35 @@ impl<'tcx> Collector<'tcx> {\n                             assign_modifier(as_needed)\n                         }\n                         (\"as-needed\", _) => {\n-                            sess.emit_err(AsNeededCompatibility { span });\n+                            sess.emit_err(errors::AsNeededCompatibility { span });\n                         }\n \n                         _ => {\n-                            sess.emit_err(UnknownLinkModifier { span, modifier });\n+                            sess.emit_err(errors::UnknownLinkModifier { span, modifier });\n                         }\n                     }\n                 }\n             }\n \n             if let Some((_, span)) = wasm_import_module {\n                 if name.is_some() || kind.is_some() || modifiers.is_some() || cfg.is_some() {\n-                    sess.emit_err(IncompatibleWasmLink { span });\n+                    sess.emit_err(errors::IncompatibleWasmLink { span });\n                 }\n             } else if name.is_none() {\n-                sess.emit_err(LinkRequiresName { span: m.span });\n+                sess.emit_err(errors::LinkRequiresName { span: m.span });\n             }\n \n             // Do this outside of the loop so that `import_name_type` can be specified before `kind`.\n             if let Some((_, span)) = import_name_type {\n                 if kind != Some(NativeLibKind::RawDylib) {\n-                    sess.emit_err(ImportNameTypeRaw { span });\n+                    sess.emit_err(errors::ImportNameTypeRaw { span });\n                 }\n             }\n \n             let dll_imports = match kind {\n                 Some(NativeLibKind::RawDylib) => {\n                     if let Some((name, span)) = name && name.as_str().contains('\\0') {\n-                        sess.emit_err(RawDylibNoNul { span });\n+                        sess.emit_err(errors::RawDylibNoNul { span });\n                     }\n                     foreign_mod_items\n                         .iter()\n@@ -383,7 +373,9 @@ impl<'tcx> Collector<'tcx> {\n                                 .iter()\n                                 .find(|a| a.has_name(sym::link_ordinal))\n                                 .unwrap();\n-                            sess.emit_err(LinkOrdinalRawDylib { span: link_ordinal_attr.span });\n+                            sess.emit_err(errors::LinkOrdinalRawDylib {\n+                                span: link_ordinal_attr.span,\n+                            });\n                         }\n                     }\n \n@@ -414,7 +406,7 @@ impl<'tcx> Collector<'tcx> {\n         for lib in &self.tcx.sess.opts.libs {\n             if let NativeLibKind::Framework { .. } = lib.kind && !self.tcx.sess.target.is_like_osx {\n                 // Cannot check this when parsing options because the target is not yet available.\n-                self.tcx.sess.emit_err(LibFrameworkApple);\n+                self.tcx.sess.emit_err(errors::LibFrameworkApple);\n             }\n             if let Some(ref new_name) = lib.new_name {\n                 let any_duplicate = self\n@@ -423,11 +415,11 @@ impl<'tcx> Collector<'tcx> {\n                     .filter_map(|lib| lib.name.as_ref())\n                     .any(|n| n.as_str() == lib.name);\n                 if new_name.is_empty() {\n-                    self.tcx.sess.emit_err(EmptyRenamingTarget { lib_name: &lib.name });\n+                    self.tcx.sess.emit_err(errors::EmptyRenamingTarget { lib_name: &lib.name });\n                 } else if !any_duplicate {\n-                    self.tcx.sess.emit_err(RenamingNoLink { lib_name: &lib.name });\n+                    self.tcx.sess.emit_err(errors::RenamingNoLink { lib_name: &lib.name });\n                 } else if !renames.insert(&lib.name) {\n-                    self.tcx.sess.emit_err(MultipleRenamings { lib_name: &lib.name });\n+                    self.tcx.sess.emit_err(errors::MultipleRenamings { lib_name: &lib.name });\n                 }\n             }\n         }\n@@ -453,12 +445,15 @@ impl<'tcx> Collector<'tcx> {\n                             // explicit `:rename` in particular.\n                             if lib.has_modifiers() || passed_lib.has_modifiers() {\n                                 match lib.foreign_module {\n-                                    Some(def_id) => self.tcx.sess.emit_err(NoLinkModOverride {\n-                                        span: Some(self.tcx.def_span(def_id)),\n-                                    }),\n-                                    None => {\n-                                        self.tcx.sess.emit_err(NoLinkModOverride { span: None })\n+                                    Some(def_id) => {\n+                                        self.tcx.sess.emit_err(errors::NoLinkModOverride {\n+                                            span: Some(self.tcx.def_span(def_id)),\n+                                        })\n                                     }\n+                                    None => self\n+                                        .tcx\n+                                        .sess\n+                                        .emit_err(errors::NoLinkModOverride { span: None }),\n                                 };\n                             }\n                             if passed_lib.kind != NativeLibKind::Unspecified {\n@@ -542,14 +537,14 @@ impl<'tcx> Collector<'tcx> {\n                     DllCallingConvention::Vectorcall(self.i686_arg_list_size(item))\n                 }\n                 _ => {\n-                    self.tcx.sess.emit_fatal(UnsupportedAbiI686 { span: item.span });\n+                    self.tcx.sess.emit_fatal(errors::UnsupportedAbiI686 { span: item.span });\n                 }\n             }\n         } else {\n             match abi {\n                 Abi::C { .. } | Abi::Win64 { .. } | Abi::System { .. } => DllCallingConvention::C,\n                 _ => {\n-                    self.tcx.sess.emit_fatal(UnsupportedAbi { span: item.span });\n+                    self.tcx.sess.emit_fatal(errors::UnsupportedAbi { span: item.span });\n                 }\n             }\n         };"}, {"sha": "473a5bb8cb8c15fddf8ade2fcd4943f1cdbe495b", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 88, "deletions": 98, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/7f97aeaf73047268299ab55288b3dd886130be47/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f97aeaf73047268299ab55288b3dd886130be47/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=7f97aeaf73047268299ab55288b3dd886130be47", "patch": "@@ -5,26 +5,7 @@ use super::{\n     AttrWrapper, BlockMode, ClosureSpans, ForceCollect, Parser, PathStyle, Restrictions,\n     SemiColonMode, SeqSep, TokenExpectType, TokenType, TrailingToken,\n };\n-use crate::errors::{\n-    ArrayBracketsInsteadOfSpaces, ArrayBracketsInsteadOfSpacesSugg, AsyncBlockIn2015,\n-    AsyncMoveOrderIncorrect, BracesForStructLiteral, CatchAfterTry, CommaAfterBaseStruct,\n-    ComparisonInterpretedAsGeneric, ComparisonOrShiftInterpretedAsGenericSugg,\n-    DoCatchSyntaxRemoved, DotDotDot, EqFieldInit, ExpectedElseBlock, ExpectedEqForLetExpr,\n-    ExpectedExpressionFoundLet, FieldExpressionWithGeneric, FloatLiteralRequiresIntegerPart,\n-    FoundExprWouldBeStmt, HelpUseLatestEdition, IfExpressionLetSomeSub,\n-    IfExpressionMissingCondition, IfExpressionMissingThenBlock, IfExpressionMissingThenBlockSub,\n-    InvalidBlockMacroSegment, InvalidComparisonOperator, InvalidComparisonOperatorSub,\n-    InvalidInterpolatedExpression, InvalidLiteralSuffixOnTupleIndex, InvalidLogicalOperator,\n-    InvalidLogicalOperatorSub, LabeledLoopInBreak, LeadingPlusNotSupported, LeftArrowOperator,\n-    LifetimeInBorrowExpression, MacroInvocationWithQualifiedPath, MalformedLoopLabel,\n-    MatchArmBodyWithoutBraces, MatchArmBodyWithoutBracesSugg, MissingCommaAfterMatchArm,\n-    MissingDotDot, MissingInInForLoop, MissingInInForLoopSub, MissingSemicolonBeforeArray,\n-    NoFieldsForFnCall, NotAsNegationOperator, NotAsNegationOperatorSub,\n-    OuterAttributeNotAllowedOnIfElse, ParenthesesWithStructFields,\n-    RequireColonAfterLabeledExpression, ShiftInterpretedAsGeneric, StructLiteralNotAllowedHere,\n-    StructLiteralNotAllowedHereSugg, TildeAsUnaryOperator, UnexpectedIfWithIf,\n-    UnexpectedTokenAfterLabel, UnexpectedTokenAfterLabelSugg, WrapExpressionInParentheses,\n-};\n+use crate::errors;\n use crate::maybe_recover_from_interpolated_ty_qpath;\n use core::mem;\n use rustc_ast::ptr::P;\n@@ -244,10 +225,10 @@ impl<'a> Parser<'a> {\n                 }\n                 .into();\n                 let invalid = format!(\"{}=\", &sugg);\n-                self.sess.emit_err(InvalidComparisonOperator {\n+                self.sess.emit_err(errors::InvalidComparisonOperator {\n                     span: sp,\n                     invalid: invalid.clone(),\n-                    sub: InvalidComparisonOperatorSub::Correctable {\n+                    sub: errors::InvalidComparisonOperatorSub::Correctable {\n                         span: sp,\n                         invalid,\n                         correct: sugg,\n@@ -262,10 +243,10 @@ impl<'a> Parser<'a> {\n                 && self.prev_token.span.hi() == self.token.span.lo()\n             {\n                 let sp = op.span.to(self.token.span);\n-                self.sess.emit_err(InvalidComparisonOperator {\n+                self.sess.emit_err(errors::InvalidComparisonOperator {\n                     span: sp,\n                     invalid: \"<>\".into(),\n-                    sub: InvalidComparisonOperatorSub::Correctable {\n+                    sub: errors::InvalidComparisonOperatorSub::Correctable {\n                         span: sp,\n                         invalid: \"<>\".into(),\n                         correct: \"!=\".into(),\n@@ -280,10 +261,10 @@ impl<'a> Parser<'a> {\n                 && self.prev_token.span.hi() == self.token.span.lo()\n             {\n                 let sp = op.span.to(self.token.span);\n-                self.sess.emit_err(InvalidComparisonOperator {\n+                self.sess.emit_err(errors::InvalidComparisonOperator {\n                     span: sp,\n                     invalid: \"<=>\".into(),\n-                    sub: InvalidComparisonOperatorSub::Spaceship(sp),\n+                    sub: errors::InvalidComparisonOperatorSub::Spaceship(sp),\n                 });\n                 self.bump();\n             }\n@@ -420,7 +401,7 @@ impl<'a> Parser<'a> {\n     /// but the next token implies this should be parsed as an expression.\n     /// For example: `if let Some(x) = x { x } else { 0 } / 2`.\n     fn error_found_expr_would_be_stmt(&self, lhs: &Expr) {\n-        self.sess.emit_err(FoundExprWouldBeStmt {\n+        self.sess.emit_err(errors::FoundExprWouldBeStmt {\n             span: self.token.span,\n             token: self.token.clone(),\n             suggestion: ExprParenthesesNeeded::surrounding(lhs.span),\n@@ -447,18 +428,18 @@ impl<'a> Parser<'a> {\n             }\n             (Some(op), _) => (op, self.token.span),\n             (None, Some((Ident { name: sym::and, span }, false))) if self.may_recover() => {\n-                self.sess.emit_err(InvalidLogicalOperator {\n+                self.sess.emit_err(errors::InvalidLogicalOperator {\n                     span: self.token.span,\n                     incorrect: \"and\".into(),\n-                    sub: InvalidLogicalOperatorSub::Conjunction(self.token.span),\n+                    sub: errors::InvalidLogicalOperatorSub::Conjunction(self.token.span),\n                 });\n                 (AssocOp::LAnd, span)\n             }\n             (None, Some((Ident { name: sym::or, span }, false))) if self.may_recover() => {\n-                self.sess.emit_err(InvalidLogicalOperator {\n+                self.sess.emit_err(errors::InvalidLogicalOperator {\n                     span: self.token.span,\n                     incorrect: \"or\".into(),\n-                    sub: InvalidLogicalOperatorSub::Disjunction(self.token.span),\n+                    sub: errors::InvalidLogicalOperatorSub::Disjunction(self.token.span),\n                 });\n                 (AssocOp::LOr, span)\n             }\n@@ -581,8 +562,11 @@ impl<'a> Parser<'a> {\n             }\n             // `+lit`\n             token::BinOp(token::Plus) if this.look_ahead(1, |tok| tok.is_numeric_lit()) => {\n-                let mut err =\n-                    LeadingPlusNotSupported { span: lo, remove_plus: None, add_parentheses: None };\n+                let mut err = errors::LeadingPlusNotSupported {\n+                    span: lo,\n+                    remove_plus: None,\n+                    add_parentheses: None,\n+                };\n \n                 // a block on the LHS might have been intended to be an expression instead\n                 if let Some(sp) = this.sess.ambiguous_block_expr_parse.borrow().get(&lo) {\n@@ -633,7 +617,7 @@ impl<'a> Parser<'a> {\n \n     /// Recover on `~expr` in favor of `!expr`.\n     fn recover_tilde_expr(&mut self, lo: Span) -> PResult<'a, (Span, ExprKind)> {\n-        self.sess.emit_err(TildeAsUnaryOperator(lo));\n+        self.sess.emit_err(errors::TildeAsUnaryOperator(lo));\n \n         self.parse_unary_expr(lo, UnOp::Not)\n     }\n@@ -661,14 +645,14 @@ impl<'a> Parser<'a> {\n         let negated_token = self.look_ahead(1, |t| t.clone());\n \n         let sub_diag = if negated_token.is_numeric_lit() {\n-            NotAsNegationOperatorSub::SuggestNotBitwise\n+            errors::NotAsNegationOperatorSub::SuggestNotBitwise\n         } else if negated_token.is_bool_lit() {\n-            NotAsNegationOperatorSub::SuggestNotLogical\n+            errors::NotAsNegationOperatorSub::SuggestNotLogical\n         } else {\n-            NotAsNegationOperatorSub::SuggestNotDefault\n+            errors::NotAsNegationOperatorSub::SuggestNotDefault\n         };\n \n-        self.sess.emit_err(NotAsNegationOperator {\n+        self.sess.emit_err(errors::NotAsNegationOperator {\n             negated: negated_token.span,\n             negated_desc: super::token_descr(&negated_token),\n             // Span the `not` plus trailing whitespace to avoid\n@@ -739,7 +723,7 @@ impl<'a> Parser<'a> {\n                         match self.parse_labeled_expr(label, false) {\n                             Ok(expr) => {\n                                 type_err.cancel();\n-                                self.sess.emit_err(MalformedLoopLabel {\n+                                self.sess.emit_err(errors::MalformedLoopLabel {\n                                     span: label.ident.span,\n                                     correct_label: label.ident,\n                                 });\n@@ -764,20 +748,22 @@ impl<'a> Parser<'a> {\n                         );\n \n                         let args_span = self.look_ahead(1, |t| t.span).to(span_after_type);\n-                        let suggestion = ComparisonOrShiftInterpretedAsGenericSugg {\n+                        let suggestion = errors::ComparisonOrShiftInterpretedAsGenericSugg {\n                             left: expr.span.shrink_to_lo(),\n                             right: expr.span.shrink_to_hi(),\n                         };\n \n                         match self.token.kind {\n-                            token::Lt => self.sess.emit_err(ComparisonInterpretedAsGeneric {\n-                                comparison: self.token.span,\n-                                r#type: path,\n-                                args: args_span,\n-                                suggestion,\n-                            }),\n+                            token::Lt => {\n+                                self.sess.emit_err(errors::ComparisonInterpretedAsGeneric {\n+                                    comparison: self.token.span,\n+                                    r#type: path,\n+                                    args: args_span,\n+                                    suggestion,\n+                                })\n+                            }\n                             token::BinOp(token::Shl) => {\n-                                self.sess.emit_err(ShiftInterpretedAsGeneric {\n+                                self.sess.emit_err(errors::ShiftInterpretedAsGeneric {\n                                     shift: self.token.span,\n                                     r#type: path,\n                                     args: args_span,\n@@ -918,7 +904,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn error_remove_borrow_lifetime(&self, span: Span, lt_span: Span) {\n-        self.sess.emit_err(LifetimeInBorrowExpression { span, lifetime_span: lt_span });\n+        self.sess.emit_err(errors::LifetimeInBorrowExpression { span, lifetime_span: lt_span });\n     }\n \n     /// Parse `mut?` or `raw [ const | mut ]`.\n@@ -1212,14 +1198,14 @@ impl<'a> Parser<'a> {\n                         let close_paren = self.prev_token.span;\n                         let span = lo.to(self.prev_token.span);\n                         if !fields.is_empty() {\n-                            let mut replacement_err = ParenthesesWithStructFields {\n+                            let mut replacement_err = errors::ParenthesesWithStructFields {\n                                 span,\n                                 r#type: path,\n-                                braces_for_struct: BracesForStructLiteral {\n+                                braces_for_struct: errors::BracesForStructLiteral {\n                                     first: open_paren,\n                                     second: close_paren,\n                                 },\n-                                no_fields_for_fn: NoFieldsForFnCall {\n+                                no_fields_for_fn: errors::NoFieldsForFnCall {\n                                     fields: fields\n                                         .into_iter()\n                                         .map(|field| field.span.until(field.expr.span))\n@@ -1286,7 +1272,7 @@ impl<'a> Parser<'a> {\n         } else {\n             // Field access `expr.f`\n             if let Some(args) = seg.args {\n-                self.sess.emit_err(FieldExpressionWithGeneric(args.span()));\n+                self.sess.emit_err(errors::FieldExpressionWithGeneric(args.span()));\n             }\n \n             let span = lo.to(self.prev_token.span);\n@@ -1500,7 +1486,7 @@ impl<'a> Parser<'a> {\n         let (span, kind) = if self.eat(&token::Not) {\n             // MACRO INVOCATION expression\n             if qself.is_some() {\n-                self.sess.emit_err(MacroInvocationWithQualifiedPath(path.span));\n+                self.sess.emit_err(errors::MacroInvocationWithQualifiedPath(path.span));\n             }\n             let lo = path.span;\n             let mac = P(MacCall {\n@@ -1550,7 +1536,7 @@ impl<'a> Parser<'a> {\n         {\n             let (lit, _) =\n                 self.recover_unclosed_char(label_.ident, Parser::mk_token_lit_char, |self_| {\n-                    self_.sess.create_err(UnexpectedTokenAfterLabel {\n+                    self_.sess.create_err(errors::UnexpectedTokenAfterLabel {\n                         span: self_.token.span,\n                         remove_label: None,\n                         enclose_in_block: None,\n@@ -1562,15 +1548,15 @@ impl<'a> Parser<'a> {\n             && (self.check_noexpect(&TokenKind::Comma) || self.check_noexpect(&TokenKind::Gt))\n         {\n             // We're probably inside of a `Path<'a>` that needs a turbofish\n-            self.sess.emit_err(UnexpectedTokenAfterLabel {\n+            self.sess.emit_err(errors::UnexpectedTokenAfterLabel {\n                 span: self.token.span,\n                 remove_label: None,\n                 enclose_in_block: None,\n             });\n             consume_colon = false;\n             Ok(self.mk_expr_err(lo))\n         } else {\n-            let mut err = UnexpectedTokenAfterLabel {\n+            let mut err = errors::UnexpectedTokenAfterLabel {\n                 span: self.token.span,\n                 remove_label: None,\n                 enclose_in_block: None,\n@@ -1606,7 +1592,7 @@ impl<'a> Parser<'a> {\n                     return expr;\n                 }\n \n-                err.enclose_in_block = Some(UnexpectedTokenAfterLabelSugg {\n+                err.enclose_in_block = Some(errors::UnexpectedTokenAfterLabelSugg {\n                     left: span.shrink_to_lo(),\n                     right: span.shrink_to_hi(),\n                 });\n@@ -1622,7 +1608,7 @@ impl<'a> Parser<'a> {\n         }?;\n \n         if !ate_colon && consume_colon {\n-            self.sess.emit_err(RequireColonAfterLabeledExpression {\n+            self.sess.emit_err(errors::RequireColonAfterLabeledExpression {\n                 span: expr.span,\n                 label: lo,\n                 label_end: lo.shrink_to_hi(),\n@@ -1671,7 +1657,7 @@ impl<'a> Parser<'a> {\n         self.bump(); // `catch`\n \n         let span = lo.to(self.prev_token.span);\n-        self.sess.emit_err(DoCatchSyntaxRemoved { span });\n+        self.sess.emit_err(errors::DoCatchSyntaxRemoved { span });\n \n         self.parse_try_block(lo)\n     }\n@@ -1719,9 +1705,9 @@ impl<'a> Parser<'a> {\n             // The value expression can be a labeled loop, see issue #86948, e.g.:\n             // `loop { break 'label: loop { break 'label 42; }; }`\n             let lexpr = self.parse_labeled_expr(label, true)?;\n-            self.sess.emit_err(LabeledLoopInBreak {\n+            self.sess.emit_err(errors::LabeledLoopInBreak {\n                 span: lexpr.span,\n-                sub: WrapExpressionInParentheses {\n+                sub: errors::WrapExpressionInParentheses {\n                     left: lexpr.span.shrink_to_lo(),\n                     right: lexpr.span.shrink_to_hi(),\n                 },\n@@ -1841,7 +1827,7 @@ impl<'a> Parser<'a> {\n             };\n             if let Some(expr) = expr {\n                 if matches!(expr.kind, ExprKind::Err) {\n-                    let mut err = InvalidInterpolatedExpression { span: self.token.span }\n+                    let mut err = errors::InvalidInterpolatedExpression { span: self.token.span }\n                         .into_diagnostic(&self.sess.span_diagnostic);\n                     err.downgrade_to_delayed_bug();\n                     return Err(err);\n@@ -1902,7 +1888,7 @@ impl<'a> Parser<'a> {\n             });\n             if let Some(token) = &recovered {\n                 self.bump();\n-                self.sess.emit_err(FloatLiteralRequiresIntegerPart {\n+                self.sess.emit_err(errors::FloatLiteralRequiresIntegerPart {\n                     span: token.span,\n                     correct: pprust::token_to_string(token).into_owned(),\n                 });\n@@ -1963,13 +1949,17 @@ impl<'a> Parser<'a> {\n         if [sym::i32, sym::u32, sym::isize, sym::usize].contains(&suffix) {\n             // #59553: warn instead of reject out of hand to allow the fix to percolate\n             // through the ecosystem when people fix their macros\n-            self.sess.emit_warning(InvalidLiteralSuffixOnTupleIndex {\n+            self.sess.emit_warning(errors::InvalidLiteralSuffixOnTupleIndex {\n                 span,\n                 suffix,\n                 exception: Some(()),\n             });\n         } else {\n-            self.sess.emit_err(InvalidLiteralSuffixOnTupleIndex { span, suffix, exception: None });\n+            self.sess.emit_err(errors::InvalidLiteralSuffixOnTupleIndex {\n+                span,\n+                suffix,\n+                exception: None,\n+            });\n         }\n     }\n \n@@ -2003,9 +1993,9 @@ impl<'a> Parser<'a> {\n         let mut snapshot = self.create_snapshot_for_diagnostic();\n         match snapshot.parse_array_or_repeat_expr(Delimiter::Brace) {\n             Ok(arr) => {\n-                self.sess.emit_err(ArrayBracketsInsteadOfSpaces {\n+                self.sess.emit_err(errors::ArrayBracketsInsteadOfSpaces {\n                     span: arr.span,\n-                    sub: ArrayBracketsInsteadOfSpacesSugg {\n+                    sub: errors::ArrayBracketsInsteadOfSpacesSugg {\n                         left: lo,\n                         right: snapshot.prev_token.span,\n                     },\n@@ -2051,7 +2041,7 @@ impl<'a> Parser<'a> {\n                         .span_to_snippet(snapshot.token.span)\n                         .map_or(false, |snippet| snippet == \"]\") =>\n                 {\n-                    return Err(MissingSemicolonBeforeArray {\n+                    return Err(errors::MissingSemicolonBeforeArray {\n                         open_delim: open_delim_span,\n                         semicolon: prev_span.shrink_to_hi(),\n                     }.into_diagnostic(&self.sess.span_diagnostic));\n@@ -2077,7 +2067,7 @@ impl<'a> Parser<'a> {\n         }\n \n         if self.token.is_whole_block() {\n-            self.sess.emit_err(InvalidBlockMacroSegment {\n+            self.sess.emit_err(errors::InvalidBlockMacroSegment {\n                 span: self.token.span,\n                 context: lo.to(self.token.span),\n             });\n@@ -2181,7 +2171,7 @@ impl<'a> Parser<'a> {\n             // Check for `move async` and recover\n             if self.check_keyword(kw::Async) {\n                 let move_async_span = self.token.span.with_lo(self.prev_token.span.data().lo);\n-                Err(AsyncMoveOrderIncorrect { span: move_async_span }\n+                Err(errors::AsyncMoveOrderIncorrect { span: move_async_span }\n                     .into_diagnostic(&self.sess.span_diagnostic))\n             } else {\n                 Ok(CaptureBy::Value)\n@@ -2259,17 +2249,17 @@ impl<'a> Parser<'a> {\n             let block = match &mut cond.kind {\n                 ExprKind::Binary(Spanned { span: binop_span, .. }, _, right)\n                     if let ExprKind::Block(_, None) = right.kind => {\n-                        self.sess.emit_err(IfExpressionMissingThenBlock {\n+                        self.sess.emit_err(errors::IfExpressionMissingThenBlock {\n                             if_span: lo,\n                             missing_then_block_sub:\n-                                IfExpressionMissingThenBlockSub::UnfinishedCondition(cond_span.shrink_to_lo().to(*binop_span)),\n+                                errors::IfExpressionMissingThenBlockSub::UnfinishedCondition(cond_span.shrink_to_lo().to(*binop_span)),\n                                 let_else_sub: None,\n \n                         });\n                         std::mem::replace(right, this.mk_expr_err(binop_span.shrink_to_hi()))\n                     },\n                 ExprKind::Block(_, None) => {\n-                    self.sess.emit_err(IfExpressionMissingCondition {\n+                    self.sess.emit_err(errors::IfExpressionMissingCondition {\n                         if_span: lo.shrink_to_hi(),\n                         block_span: self.sess.source_map().start_point(cond_span),\n                     });\n@@ -2291,11 +2281,11 @@ impl<'a> Parser<'a> {\n                 block\n             } else {\n                 let let_else_sub = matches!(cond.kind, ExprKind::Let(..))\n-                    .then(|| IfExpressionLetSomeSub { if_span: lo.until(cond_span) });\n+                    .then(|| errors::IfExpressionLetSomeSub { if_span: lo.until(cond_span) });\n \n-                self.sess.emit_err(IfExpressionMissingThenBlock {\n+                self.sess.emit_err(errors::IfExpressionMissingThenBlock {\n                     if_span: lo,\n-                    missing_then_block_sub: IfExpressionMissingThenBlockSub::AddThenBlock(\n+                    missing_then_block_sub: errors::IfExpressionMissingThenBlockSub::AddThenBlock(\n                         cond_span.shrink_to_hi(),\n                     ),\n                     let_else_sub,\n@@ -2351,7 +2341,7 @@ impl<'a> Parser<'a> {\n             TokenKind::AndAnd | TokenKind::Ident(kw::If, _) | TokenKind::Ident(kw::While, _)\n         );\n         if !self.restrictions.contains(Restrictions::ALLOW_LET) || not_in_chain {\n-            self.sess.emit_err(ExpectedExpressionFoundLet { span: self.token.span });\n+            self.sess.emit_err(errors::ExpectedExpressionFoundLet { span: self.token.span });\n         }\n \n         self.bump(); // Eat `let` token\n@@ -2363,7 +2353,7 @@ impl<'a> Parser<'a> {\n             CommaRecoveryMode::LikelyTuple,\n         )?;\n         if self.token == token::EqEq {\n-            self.sess.emit_err(ExpectedEqForLetExpr {\n+            self.sess.emit_err(errors::ExpectedEqForLetExpr {\n                 span: self.token.span,\n                 sugg_span: self.token.span,\n             });\n@@ -2398,7 +2388,7 @@ impl<'a> Parser<'a> {\n                     if self.check(&TokenKind::OpenDelim(Delimiter::Brace))\n                         && classify::expr_requires_semi_to_be_stmt(&cond) =>\n                 {\n-                    self.sess.emit_err(ExpectedElseBlock {\n+                    self.sess.emit_err(errors::ExpectedElseBlock {\n                         first_tok_span,\n                         first_tok,\n                         else_span,\n@@ -2438,7 +2428,7 @@ impl<'a> Parser<'a> {\n             [x0 @ xn] | [x0, .., xn] => (x0.span.to(xn.span), xn.span),\n         };\n         let ctx = if is_ctx_else { \"else\" } else { \"if\" };\n-        self.sess.emit_err(OuterAttributeNotAllowedOnIfElse {\n+        self.sess.emit_err(errors::OuterAttributeNotAllowedOnIfElse {\n             last,\n             branch_span,\n             ctx_span,\n@@ -2451,7 +2441,7 @@ impl<'a> Parser<'a> {\n         if let ExprKind::Binary(Spanned { span: binop_span, node: binop}, _, right) = &cond.kind &&\n             let BinOpKind::And = binop &&\n             let ExprKind::If(cond, ..) = &right.kind {\n-                    Err(self.sess.create_err(UnexpectedIfWithIf(binop_span.shrink_to_hi().to(cond.span.shrink_to_lo()))))\n+                    Err(self.sess.create_err(errors::UnexpectedIfWithIf(binop_span.shrink_to_hi().to(cond.span.shrink_to_lo()))))\n             } else {\n                 Ok(())\n             }\n@@ -2492,12 +2482,12 @@ impl<'a> Parser<'a> {\n             // Possibly using JS syntax (#75311).\n             let span = self.token.span;\n             self.bump();\n-            (span, MissingInInForLoopSub::InNotOf)\n+            (span, errors::MissingInInForLoopSub::InNotOf)\n         } else {\n-            (self.prev_token.span.between(self.token.span), MissingInInForLoopSub::AddIn)\n+            (self.prev_token.span.between(self.token.span), errors::MissingInInForLoopSub::AddIn)\n         };\n \n-        self.sess.emit_err(MissingInInForLoop { span, sub: sub(span) });\n+        self.sess.emit_err(errors::MissingInInForLoop { span, sub: sub(span) });\n     }\n \n     /// Parses a `while` or `while let` expression (`while` token already eaten).\n@@ -2601,17 +2591,17 @@ impl<'a> Parser<'a> {\n         let err = |this: &Parser<'_>, stmts: Vec<ast::Stmt>| {\n             let span = stmts[0].span.to(stmts[stmts.len() - 1].span);\n \n-            this.sess.emit_err(MatchArmBodyWithoutBraces {\n+            this.sess.emit_err(errors::MatchArmBodyWithoutBraces {\n                 statements: span,\n                 arrow: arrow_span,\n                 num_statements: stmts.len(),\n                 sub: if stmts.len() > 1 {\n-                    MatchArmBodyWithoutBracesSugg::AddBraces {\n+                    errors::MatchArmBodyWithoutBracesSugg::AddBraces {\n                         left: span.shrink_to_lo(),\n                         right: span.shrink_to_hi(),\n                     }\n                 } else {\n-                    MatchArmBodyWithoutBracesSugg::UseComma { semicolon: semi_sp }\n+                    errors::MatchArmBodyWithoutBracesSugg::UseComma { semicolon: semi_sp }\n                 },\n             });\n             this.mk_expr_err(span)\n@@ -2802,7 +2792,7 @@ impl<'a> Parser<'a> {\n                                 .is_ok();\n                             if pattern_follows && snapshot.check(&TokenKind::FatArrow) {\n                                 err.cancel();\n-                                this.sess.emit_err(MissingCommaAfterMatchArm {\n+                                this.sess.emit_err(errors::MissingCommaAfterMatchArm {\n                                     span: hi.shrink_to_hi(),\n                                 });\n                                 return Ok(true);\n@@ -2834,7 +2824,7 @@ impl<'a> Parser<'a> {\n     fn parse_try_block(&mut self, span_lo: Span) -> PResult<'a, P<Expr>> {\n         let (attrs, body) = self.parse_inner_attrs_and_block()?;\n         if self.eat_keyword(kw::Catch) {\n-            Err(CatchAfterTry { span: self.prev_token.span }\n+            Err(errors::CatchAfterTry { span: self.prev_token.span }\n                 .into_diagnostic(&self.sess.span_diagnostic))\n         } else {\n             let span = span_lo.to(body.span);\n@@ -2910,9 +2900,9 @@ impl<'a> Parser<'a> {\n             let expr = self.parse_struct_expr(qself.clone(), path.clone(), true);\n             if let (Ok(expr), false) = (&expr, struct_allowed) {\n                 // This is a struct literal, but we don't can't accept them here.\n-                self.sess.emit_err(StructLiteralNotAllowedHere {\n+                self.sess.emit_err(errors::StructLiteralNotAllowedHere {\n                     span: expr.span,\n-                    sub: StructLiteralNotAllowedHereSugg {\n+                    sub: errors::StructLiteralNotAllowedHereSugg {\n                         left: path.span.shrink_to_lo(),\n                         right: expr.span.shrink_to_hi(),\n                     },\n@@ -2935,8 +2925,8 @@ impl<'a> Parser<'a> {\n \n         let mut async_block_err = |e: &mut Diagnostic, span: Span| {\n             recover_async = true;\n-            AsyncBlockIn2015 { span }.add_to_diagnostic(e);\n-            HelpUseLatestEdition::new().add_to_diagnostic(e);\n+            errors::AsyncBlockIn2015 { span }.add_to_diagnostic(e);\n+            errors::HelpUseLatestEdition::new().add_to_diagnostic(e);\n         };\n \n         while self.token != token::CloseDelim(close_delim) {\n@@ -3080,7 +3070,7 @@ impl<'a> Parser<'a> {\n         if self.token != token::Comma {\n             return;\n         }\n-        self.sess.emit_err(CommaAfterBaseStruct {\n+        self.sess.emit_err(errors::CommaAfterBaseStruct {\n             span: span.to(self.prev_token.span),\n             comma: self.token.span,\n         });\n@@ -3093,7 +3083,7 @@ impl<'a> Parser<'a> {\n         {\n             // recover from typo of `...`, suggest `..`\n             let span = self.prev_token.span;\n-            self.sess.emit_err(MissingDotDot { token_span: span, sugg_span: span });\n+            self.sess.emit_err(errors::MissingDotDot { token_span: span, sugg_span: span });\n             return true;\n         }\n         false\n@@ -3161,18 +3151,18 @@ impl<'a> Parser<'a> {\n             return;\n         }\n \n-        self.sess.emit_err(EqFieldInit {\n+        self.sess.emit_err(errors::EqFieldInit {\n             span: self.token.span,\n             eq: field_name.span.shrink_to_hi().to(self.token.span),\n         });\n     }\n \n     fn err_dotdotdot_syntax(&self, span: Span) {\n-        self.sess.emit_err(DotDotDot { span });\n+        self.sess.emit_err(errors::DotDotDot { span });\n     }\n \n     fn err_larrow_operator(&self, span: Span) {\n-        self.sess.emit_err(LeftArrowOperator { span });\n+        self.sess.emit_err(errors::LeftArrowOperator { span });\n     }\n \n     fn mk_assign_op(&self, binop: BinOp, lhs: P<Expr>, rhs: P<Expr>) -> ExprKind {"}, {"sha": "3afda5f69f0e1f4eceb99a29858507af08b1071c", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7f97aeaf73047268299ab55288b3dd886130be47/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f97aeaf73047268299ab55288b3dd886130be47/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=7f97aeaf73047268299ab55288b3dd886130be47", "patch": "@@ -7,12 +7,7 @@ use super::TrailingToken;\n use super::{\n     AttrWrapper, BlockMode, FnParseMode, ForceCollect, Parser, Restrictions, SemiColonMode,\n };\n-use crate::errors::{\n-    AssignmentElseNotAllowed, CompoundAssignmentExpressionInLet, ConstLetMutuallyExclusive,\n-    DocCommentDoesNotDocumentAnything, ExpectedStatementAfterOuterAttr, InvalidCurlyInLetElse,\n-    InvalidExpressionInLetElse, InvalidIdentiferStartsWithNumber, InvalidVariableDeclaration,\n-    InvalidVariableDeclarationSub, WrapExpressionInParentheses,\n-};\n+use crate::errors;\n use crate::maybe_whole;\n \n use rustc_ast as ast;\n@@ -64,29 +59,33 @@ impl<'a> Parser<'a> {\n         if self.token.is_keyword(kw::Mut) && self.is_keyword_ahead(1, &[kw::Let]) {\n             self.bump();\n             let mut_let_span = lo.to(self.token.span);\n-            self.sess.emit_err(InvalidVariableDeclaration {\n+            self.sess.emit_err(errors::InvalidVariableDeclaration {\n                 span: mut_let_span,\n-                sub: InvalidVariableDeclarationSub::SwitchMutLetOrder(mut_let_span),\n+                sub: errors::InvalidVariableDeclarationSub::SwitchMutLetOrder(mut_let_span),\n             });\n         }\n \n         Ok(Some(if self.token.is_keyword(kw::Let) {\n             self.parse_local_mk(lo, attrs, capture_semi, force_collect)?\n         } else if self.is_kw_followed_by_ident(kw::Mut) && self.may_recover() {\n-            self.recover_stmt_local_after_let(lo, attrs, InvalidVariableDeclarationSub::MissingLet)?\n+            self.recover_stmt_local_after_let(\n+                lo,\n+                attrs,\n+                errors::InvalidVariableDeclarationSub::MissingLet,\n+            )?\n         } else if self.is_kw_followed_by_ident(kw::Auto) && self.may_recover() {\n             self.bump(); // `auto`\n             self.recover_stmt_local_after_let(\n                 lo,\n                 attrs,\n-                InvalidVariableDeclarationSub::UseLetNotAuto,\n+                errors::InvalidVariableDeclarationSub::UseLetNotAuto,\n             )?\n         } else if self.is_kw_followed_by_ident(sym::var) && self.may_recover() {\n             self.bump(); // `var`\n             self.recover_stmt_local_after_let(\n                 lo,\n                 attrs,\n-                InvalidVariableDeclarationSub::UseLetNotVar,\n+                errors::InvalidVariableDeclarationSub::UseLetNotVar,\n             )?\n         } else if self.check_path() && !self.token.is_qpath_start() && !self.is_path_start_item() {\n             // We have avoided contextual keywords like `union`, items with `crate` visibility,\n@@ -124,7 +123,7 @@ impl<'a> Parser<'a> {\n                 let bl = self.parse_block()?;\n                 // Destructuring assignment ... else.\n                 // This is not allowed, but point it out in a nice way.\n-                self.sess.emit_err(AssignmentElseNotAllowed { span: e.span.to(bl.span) });\n+                self.sess.emit_err(errors::AssignmentElseNotAllowed { span: e.span.to(bl.span) });\n             }\n             self.mk_stmt(lo.to(e.span), StmtKind::Expr(e))\n         } else {\n@@ -217,12 +216,12 @@ impl<'a> Parser<'a> {\n         && let attrs = attrs.take_for_recovery(self.sess)\n         && let attrs @ [.., last] = &*attrs {\n             if last.is_doc_comment() {\n-                self.sess.emit_err(DocCommentDoesNotDocumentAnything {\n+                self.sess.emit_err(errors::DocCommentDoesNotDocumentAnything {\n                     span: last.span,\n                     missing_comma: None,\n                 });\n             } else if attrs.iter().any(|a| a.style == AttrStyle::Outer) {\n-                self.sess.emit_err(ExpectedStatementAfterOuterAttr { span: last.span });\n+                self.sess.emit_err(errors::ExpectedStatementAfterOuterAttr { span: last.span });\n             }\n         }\n     }\n@@ -231,7 +230,7 @@ impl<'a> Parser<'a> {\n         &mut self,\n         lo: Span,\n         attrs: AttrWrapper,\n-        subdiagnostic: fn(Span) -> InvalidVariableDeclarationSub,\n+        subdiagnostic: fn(Span) -> errors::InvalidVariableDeclarationSub,\n     ) -> PResult<'a, Stmt> {\n         let stmt =\n             self.collect_tokens_trailing_token(attrs, ForceCollect::Yes, |this, attrs| {\n@@ -242,7 +241,7 @@ impl<'a> Parser<'a> {\n                     TrailingToken::None,\n                 ))\n             })?;\n-        self.sess.emit_err(InvalidVariableDeclaration { span: lo, sub: subdiagnostic(lo) });\n+        self.sess.emit_err(errors::InvalidVariableDeclaration { span: lo, sub: subdiagnostic(lo) });\n         Ok(stmt)\n     }\n \n@@ -270,7 +269,7 @@ impl<'a> Parser<'a> {\n         let lo = self.prev_token.span;\n \n         if self.token.is_keyword(kw::Const) && self.look_ahead(1, |t| t.is_ident()) {\n-            self.sess.emit_err(ConstLetMutuallyExclusive { span: lo.to(self.token.span) });\n+            self.sess.emit_err(errors::ConstLetMutuallyExclusive { span: lo.to(self.token.span) });\n             self.bump();\n         }\n \n@@ -373,18 +372,18 @@ impl<'a> Parser<'a> {\n             rustc_ast::MetaItemLit::from_token(&self.token).is_none() &&\n             (lit.kind == token::LitKind::Integer || lit.kind == token::LitKind::Float) &&\n             self.look_ahead(1, |t| matches!(t.kind, token::Eq) || matches!(t.kind, token::Colon ) ) {\n-                return Err(self.sess.create_err(InvalidIdentiferStartsWithNumber { span: self.token.span }));\n+                return Err(self.sess.create_err(errors::InvalidIdentiferStartsWithNumber { span: self.token.span }));\n         }\n         Ok(())\n     }\n \n     fn check_let_else_init_bool_expr(&self, init: &ast::Expr) {\n         if let ast::ExprKind::Binary(op, ..) = init.kind {\n             if op.node.lazy() {\n-                self.sess.emit_err(InvalidExpressionInLetElse {\n+                self.sess.emit_err(errors::InvalidExpressionInLetElse {\n                     span: init.span,\n                     operator: op.node.to_string(),\n-                    sugg: WrapExpressionInParentheses {\n+                    sugg: errors::WrapExpressionInParentheses {\n                         left: init.span.shrink_to_lo(),\n                         right: init.span.shrink_to_hi(),\n                     },\n@@ -395,9 +394,9 @@ impl<'a> Parser<'a> {\n \n     fn check_let_else_init_trailing_brace(&self, init: &ast::Expr) {\n         if let Some(trailing) = classify::expr_trailing_brace(init) {\n-            self.sess.emit_err(InvalidCurlyInLetElse {\n+            self.sess.emit_err(errors::InvalidCurlyInLetElse {\n                 span: trailing.span.with_lo(trailing.span.hi() - BytePos(1)),\n-                sugg: WrapExpressionInParentheses {\n+                sugg: errors::WrapExpressionInParentheses {\n                     left: trailing.span.shrink_to_lo(),\n                     right: trailing.span.shrink_to_hi(),\n                 },\n@@ -410,7 +409,8 @@ impl<'a> Parser<'a> {\n         let eq_consumed = match self.token.kind {\n             token::BinOpEq(..) => {\n                 // Recover `let x <op>= 1` as `let x = 1`\n-                self.sess.emit_err(CompoundAssignmentExpressionInLet { span: self.token.span });\n+                self.sess\n+                    .emit_err(errors::CompoundAssignmentExpressionInLet { span: self.token.span });\n                 self.bump();\n                 true\n             }"}, {"sha": "238ec9ca30f704a99b0e72eb65e8d58454180062", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/7f97aeaf73047268299ab55288b3dd886130be47/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f97aeaf73047268299ab55288b3dd886130be47/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=7f97aeaf73047268299ab55288b3dd886130be47", "patch": "@@ -4,11 +4,7 @@\n //! conflicts between multiple such attributes attached to the same\n //! item.\n \n-use crate::errors::{\n-    self, AttrApplication, DebugVisualizerUnreadable, InvalidAttrAtCrateLevel, ObjectLifetimeErr,\n-    OnlyHasEffectOn, ProcMacroDiffArguments, ProcMacroInvalidAbi, ProcMacroMissingArguments,\n-    ProcMacroTypeError, ProcMacroUnsafe, TransparentIncompatible, UnrecognizedReprHint,\n-};\n+use crate::errors;\n use rustc_ast::{ast, AttrStyle, Attribute, LitKind, MetaItemKind, MetaItemLit, NestedMetaItem};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{fluent, Applicability, IntoDiagnosticArg, MultiSpan};\n@@ -399,7 +395,7 @@ impl CheckAttrVisitor<'_> {\n                 UNUSED_ATTRIBUTES,\n                 hir_id,\n                 attr.span,\n-                OnlyHasEffectOn {\n+                errors::OnlyHasEffectOn {\n                     attr_name: attr.name_or_empty(),\n                     target_name: allowed_target.name().replace(' ', \"_\"),\n                 },\n@@ -468,7 +464,7 @@ impl CheckAttrVisitor<'_> {\n                     ObjectLifetimeDefault::Param(def_id) => tcx.item_name(def_id).to_string(),\n                     ObjectLifetimeDefault::Ambiguous => \"Ambiguous\".to_owned(),\n                 };\n-                tcx.sess.emit_err(ObjectLifetimeErr { span: p.span, repr });\n+                tcx.sess.emit_err(errors::ObjectLifetimeErr { span: p.span, repr });\n             }\n         }\n     }\n@@ -1715,7 +1711,7 @@ impl CheckAttrVisitor<'_> {\n                     match target {\n                         Target::Struct | Target::Union | Target::Enum => continue,\n                         _ => {\n-                            self.tcx.sess.emit_err(AttrApplication::StructEnumUnion {\n+                            self.tcx.sess.emit_err(errors::AttrApplication::StructEnumUnion {\n                                 hint_span: hint.span(),\n                                 span,\n                             });\n@@ -1736,16 +1732,18 @@ impl CheckAttrVisitor<'_> {\n                     match target {\n                         Target::Struct | Target::Union | Target::Enum | Target::Fn => continue,\n                         _ => {\n-                            self.tcx.sess.emit_err(AttrApplication::StructEnumFunctionUnion {\n-                                hint_span: hint.span(),\n-                                span,\n-                            });\n+                            self.tcx.sess.emit_err(\n+                                errors::AttrApplication::StructEnumFunctionUnion {\n+                                    hint_span: hint.span(),\n+                                    span,\n+                                },\n+                            );\n                         }\n                     }\n                 }\n                 sym::packed => {\n                     if target != Target::Struct && target != Target::Union {\n-                        self.tcx.sess.emit_err(AttrApplication::StructUnion {\n+                        self.tcx.sess.emit_err(errors::AttrApplication::StructUnion {\n                             hint_span: hint.span(),\n                             span,\n                         });\n@@ -1756,9 +1754,10 @@ impl CheckAttrVisitor<'_> {\n                 sym::simd => {\n                     is_simd = true;\n                     if target != Target::Struct {\n-                        self.tcx\n-                            .sess\n-                            .emit_err(AttrApplication::Struct { hint_span: hint.span(), span });\n+                        self.tcx.sess.emit_err(errors::AttrApplication::Struct {\n+                            hint_span: hint.span(),\n+                            span,\n+                        });\n                     } else {\n                         continue;\n                     }\n@@ -1768,7 +1767,7 @@ impl CheckAttrVisitor<'_> {\n                     match target {\n                         Target::Struct | Target::Union | Target::Enum => continue,\n                         _ => {\n-                            self.tcx.sess.emit_err(AttrApplication::StructEnumUnion {\n+                            self.tcx.sess.emit_err(errors::AttrApplication::StructEnumUnion {\n                                 hint_span: hint.span(),\n                                 span,\n                             });\n@@ -1789,15 +1788,16 @@ impl CheckAttrVisitor<'_> {\n                 | sym::usize => {\n                     int_reprs += 1;\n                     if target != Target::Enum {\n-                        self.tcx\n-                            .sess\n-                            .emit_err(AttrApplication::Enum { hint_span: hint.span(), span });\n+                        self.tcx.sess.emit_err(errors::AttrApplication::Enum {\n+                            hint_span: hint.span(),\n+                            span,\n+                        });\n                     } else {\n                         continue;\n                     }\n                 }\n                 _ => {\n-                    self.tcx.sess.emit_err(UnrecognizedReprHint { span: hint.span() });\n+                    self.tcx.sess.emit_err(errors::UnrecognizedReprHint { span: hint.span() });\n                     continue;\n                 }\n             };\n@@ -1810,9 +1810,10 @@ impl CheckAttrVisitor<'_> {\n         // Error on repr(transparent, <anything else>).\n         if is_transparent && hints.len() > 1 {\n             let hint_spans: Vec<_> = hint_spans.clone().collect();\n-            self.tcx\n-                .sess\n-                .emit_err(TransparentIncompatible { hint_spans, target: target.to_string() });\n+            self.tcx.sess.emit_err(errors::TransparentIncompatible {\n+                hint_spans,\n+                target: target.to_string(),\n+            });\n         }\n         // Warn on repr(u8, u16), repr(C, simd), and c-like-enum-repr(C, u8)\n         if (int_reprs > 1)\n@@ -1965,7 +1966,7 @@ impl CheckAttrVisitor<'_> {\n         match std::fs::File::open(&file) {\n             Ok(_) => true,\n             Err(error) => {\n-                self.tcx.sess.emit_err(DebugVisualizerUnreadable {\n+                self.tcx.sess.emit_err(errors::DebugVisualizerUnreadable {\n                     span: meta_item.span,\n                     file: &file,\n                     error,\n@@ -2175,20 +2176,23 @@ impl CheckAttrVisitor<'_> {\n             let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsInfer };\n \n             if sig.abi != Abi::Rust {\n-                tcx.sess.emit_err(ProcMacroInvalidAbi { span: hir_sig.span, abi: sig.abi.name() });\n+                tcx.sess.emit_err(errors::ProcMacroInvalidAbi {\n+                    span: hir_sig.span,\n+                    abi: sig.abi.name(),\n+                });\n                 self.abort.set(true);\n             }\n \n             if sig.unsafety == Unsafety::Unsafe {\n-                tcx.sess.emit_err(ProcMacroUnsafe { span: hir_sig.span });\n+                tcx.sess.emit_err(errors::ProcMacroUnsafe { span: hir_sig.span });\n                 self.abort.set(true);\n             }\n \n             let output = sig.output();\n \n             // Typecheck the output\n             if !drcx.types_may_unify(output, tokenstream) {\n-                tcx.sess.emit_err(ProcMacroTypeError {\n+                tcx.sess.emit_err(errors::ProcMacroTypeError {\n                     span: hir_sig.decl.output.span(),\n                     found: output,\n                     kind,\n@@ -2198,7 +2202,7 @@ impl CheckAttrVisitor<'_> {\n             }\n \n             if sig.inputs().len() < expected_input_count {\n-                tcx.sess.emit_err(ProcMacroMissingArguments {\n+                tcx.sess.emit_err(errors::ProcMacroMissingArguments {\n                     expected_input_count,\n                     span: hir_sig.span,\n                     kind,\n@@ -2213,7 +2217,7 @@ impl CheckAttrVisitor<'_> {\n                     sig.inputs().iter().zip(hir_sig.decl.inputs).take(expected_input_count)\n                 {\n                     if !drcx.types_may_unify(*arg, tokenstream) {\n-                        tcx.sess.emit_err(ProcMacroTypeError {\n+                        tcx.sess.emit_err(errors::ProcMacroTypeError {\n                             span: input.span,\n                             found: *arg,\n                             kind,\n@@ -2228,7 +2232,7 @@ impl CheckAttrVisitor<'_> {\n             let body_id = tcx.hir().body_owned_by(id.def_id);\n             let excess = tcx.hir().body(body_id).params.get(expected_input_count..);\n             if let Some(excess @ [begin @ end] | excess @ [begin, .., end]) = excess {\n-                tcx.sess.emit_err(ProcMacroDiffArguments {\n+                tcx.sess.emit_err(errors::ProcMacroDiffArguments {\n                     span: begin.span.to(end.span),\n                     count: excess.len(),\n                     kind,\n@@ -2378,7 +2382,7 @@ fn check_invalid_crate_level_attr(tcx: TyCtxt<'_>, attrs: &[Attribute]) {\n         if attr.style == AttrStyle::Inner {\n             for attr_to_check in ATTRS_TO_CHECK {\n                 if attr.has_name(*attr_to_check) {\n-                    tcx.sess.emit_err(InvalidAttrAtCrateLevel {\n+                    tcx.sess.emit_err(errors::InvalidAttrAtCrateLevel {\n                         span: attr.span,\n                         snippet: tcx.sess.source_map().span_to_snippet(attr.span).ok(),\n                         name: *attr_to_check,"}, {"sha": "7299fc9705cc6036046b3d3036b561042931f123", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/7f97aeaf73047268299ab55288b3dd886130be47/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f97aeaf73047268299ab55288b3dd886130be47/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=7f97aeaf73047268299ab55288b3dd886130be47", "patch": "@@ -1,12 +1,7 @@\n //! A pass that annotates every item and method with its stability level,\n //! propagating default levels lexically from parent to children ast nodes.\n \n-use crate::errors::{\n-    self, CannotStabilizeDeprecated, DeprecatedAttribute, DuplicateFeatureErr,\n-    FeatureOnlyOnNightly, ImpliedFeatureNotExist, InvalidDeprecationVersion, InvalidStability,\n-    MissingConstErr, MissingConstStabAttr, MissingStabilityAttr, TraitImplConstStable,\n-    UnknownFeature, UselessStability,\n-};\n+use crate::errors;\n use rustc_attr::{\n     self as attr, rust_version_symbol, ConstStability, Stability, StabilityLevel, Unstable,\n     UnstableReason, VERSION_PLACEHOLDER,\n@@ -185,7 +180,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n                 {\n                     self.tcx\n                         .sess\n-                        .emit_err(MissingConstErr { fn_sig_span: fn_sig.span, const_span });\n+                        .emit_err(errors::MissingConstErr { fn_sig_span: fn_sig.span, const_span });\n                 }\n             }\n         }\n@@ -203,7 +198,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n \n         if let Some((rustc_attr::Deprecation { is_since_rustc_version: true, .. }, span)) = &depr {\n             if stab.is_none() {\n-                self.tcx.sess.emit_err(DeprecatedAttribute { span: *span });\n+                self.tcx.sess.emit_err(errors::DeprecatedAttribute { span: *span });\n             }\n         }\n \n@@ -219,7 +214,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n             if kind == AnnotationKind::Prohibited\n                 || (kind == AnnotationKind::Container && stab.level.is_stable() && is_deprecated)\n             {\n-                self.tcx.sess.emit_err(UselessStability { span, item_sp });\n+                self.tcx.sess.emit_err(errors::UselessStability { span, item_sp });\n             }\n \n             debug!(\"annotate: found {:?}\", stab);\n@@ -235,25 +230,27 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n                 {\n                     match stab_v.parse::<u64>() {\n                         Err(_) => {\n-                            self.tcx.sess.emit_err(InvalidStability { span, item_sp });\n+                            self.tcx.sess.emit_err(errors::InvalidStability { span, item_sp });\n                             break;\n                         }\n                         Ok(stab_vp) => match dep_v.parse::<u64>() {\n                             Ok(dep_vp) => match dep_vp.cmp(&stab_vp) {\n                                 Ordering::Less => {\n-                                    self.tcx\n-                                        .sess\n-                                        .emit_err(CannotStabilizeDeprecated { span, item_sp });\n+                                    self.tcx.sess.emit_err(errors::CannotStabilizeDeprecated {\n+                                        span,\n+                                        item_sp,\n+                                    });\n                                     break;\n                                 }\n                                 Ordering::Equal => continue,\n                                 Ordering::Greater => break,\n                             },\n                             Err(_) => {\n                                 if dep_v != \"TBD\" {\n-                                    self.tcx\n-                                        .sess\n-                                        .emit_err(InvalidDeprecationVersion { span, item_sp });\n+                                    self.tcx.sess.emit_err(errors::InvalidDeprecationVersion {\n+                                        span,\n+                                        item_sp,\n+                                    });\n                                 }\n                                 break;\n                             }\n@@ -527,7 +524,7 @@ impl<'tcx> MissingStabilityAnnotations<'tcx> {\n             && self.effective_visibilities.is_reachable(def_id)\n         {\n             let descr = self.tcx.def_kind(def_id).descr(def_id.to_def_id());\n-            self.tcx.sess.emit_err(MissingStabilityAttr { span, descr });\n+            self.tcx.sess.emit_err(errors::MissingStabilityAttr { span, descr });\n         }\n     }\n \n@@ -555,7 +552,7 @@ impl<'tcx> MissingStabilityAnnotations<'tcx> {\n \n         if is_const && is_stable && missing_const_stability_attribute && is_reachable {\n             let descr = self.tcx.def_kind(def_id).descr(def_id.to_def_id());\n-            self.tcx.sess.emit_err(MissingConstStabAttr { span, descr });\n+            self.tcx.sess.emit_err(errors::MissingConstStabAttr { span, descr });\n         }\n     }\n }\n@@ -768,7 +765,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'tcx> {\n                         && *constness == hir::Constness::Const\n                         && const_stab.map_or(false, |(stab, _)| stab.is_const_stable())\n                     {\n-                        self.tcx.sess.emit_err(TraitImplConstStable { span: item.span });\n+                        self.tcx.sess.emit_err(errors::TraitImplConstStable { span: item.span });\n                     }\n                 }\n \n@@ -947,22 +944,22 @@ pub fn check_unused_or_stable_features(tcx: TyCtxt<'_>) {\n         }\n         if !lang_features.insert(feature) {\n             // Warn if the user enables a lang feature multiple times.\n-            tcx.sess.emit_err(DuplicateFeatureErr { span, feature });\n+            tcx.sess.emit_err(errors::DuplicateFeatureErr { span, feature });\n         }\n     }\n \n     let declared_lib_features = &tcx.features().declared_lib_features;\n     let mut remaining_lib_features = FxIndexMap::default();\n     for (feature, span) in declared_lib_features {\n         if !tcx.sess.opts.unstable_features.is_nightly_build() {\n-            tcx.sess.emit_err(FeatureOnlyOnNightly {\n+            tcx.sess.emit_err(errors::FeatureOnlyOnNightly {\n                 span: *span,\n                 release_channel: env!(\"CFG_RELEASE_CHANNEL\"),\n             });\n         }\n         if remaining_lib_features.contains_key(&feature) {\n             // Warn if the user enables a lib feature multiple times.\n-            tcx.sess.emit_err(DuplicateFeatureErr { span: *span, feature: *feature });\n+            tcx.sess.emit_err(errors::DuplicateFeatureErr { span: *span, feature: *feature });\n         }\n         remaining_lib_features.insert(feature, *span);\n     }\n@@ -1063,7 +1060,7 @@ pub fn check_unused_or_stable_features(tcx: TyCtxt<'_>) {\n     }\n \n     for (feature, span) in remaining_lib_features {\n-        tcx.sess.emit_err(UnknownFeature { span, feature: *feature });\n+        tcx.sess.emit_err(errors::UnknownFeature { span, feature: *feature });\n     }\n \n     for (implied_by, feature) in remaining_implications {\n@@ -1074,7 +1071,7 @@ pub fn check_unused_or_stable_features(tcx: TyCtxt<'_>) {\n             .map(|(_, span)| span)\n             .or_else(|| local_defined_features.unstable.get(&feature))\n             .expect(\"feature that implied another does not exist\");\n-        tcx.sess.emit_err(ImpliedFeatureNotExist { span, feature, implied_by });\n+        tcx.sess.emit_err(errors::ImpliedFeatureNotExist { span, feature, implied_by });\n     }\n \n     // FIXME(#44232): the `used_features` table no longer exists, so we"}, {"sha": "8a0176f6391743adb6a17ccf30a3fc49223b92b3", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 23, "deletions": 29, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/7f97aeaf73047268299ab55288b3dd886130be47/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f97aeaf73047268299ab55288b3dd886130be47/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=7f97aeaf73047268299ab55288b3dd886130be47", "patch": "@@ -3,15 +3,7 @@ use crate::code_stats::CodeStats;\n pub use crate::code_stats::{DataTypeKind, FieldInfo, FieldKind, SizeKind, VariantInfo};\n use crate::config::Input;\n use crate::config::{self, CrateType, InstrumentCoverage, OptLevel, OutputType, SwitchWithOptPath};\n-use crate::errors::{\n-    BranchProtectionRequiresAArch64, CannotEnableCrtStaticLinux, CannotMixAndMatchSanitizers,\n-    LinkerPluginToWindowsNotSupported, NotCircumventFeature, OptimisationFuelExhausted,\n-    ProfileSampleUseFileDoesNotExist, ProfileUseFileDoesNotExist, SanitizerCfiEnabled,\n-    SanitizerNotSupported, SanitizersNotSupported, SkippingConstChecks,\n-    SplitDebugInfoUnstablePlatform, StackProtectorNotSupportedForTarget,\n-    TargetRequiresUnwindTables, UnleashedFeatureHelp, UnstableVirtualFunctionElimination,\n-    UnsupportedDwarfVersion,\n-};\n+use crate::errors;\n use crate::parse::{add_feature_diagnostics, ParseSess};\n use crate::search_paths::{PathKind, SearchPath};\n use crate::{filesearch, lint};\n@@ -246,23 +238,23 @@ impl Session {\n         if !unleashed_features.is_empty() {\n             let mut must_err = false;\n             // Create a diagnostic pointing at where things got unleashed.\n-            self.emit_warning(SkippingConstChecks {\n+            self.emit_warning(errors::SkippingConstChecks {\n                 unleashed_features: unleashed_features\n                     .iter()\n                     .map(|(span, gate)| {\n                         gate.map(|gate| {\n                             must_err = true;\n-                            UnleashedFeatureHelp::Named { span: *span, gate }\n+                            errors::UnleashedFeatureHelp::Named { span: *span, gate }\n                         })\n-                        .unwrap_or(UnleashedFeatureHelp::Unnamed { span: *span })\n+                        .unwrap_or(errors::UnleashedFeatureHelp::Unnamed { span: *span })\n                     })\n                     .collect(),\n             });\n \n             // If we should err, make sure we did.\n             if must_err && self.has_errors().is_none() {\n                 // We have skipped a feature gate, and not run into other errors... reject.\n-                self.emit_err(NotCircumventFeature);\n+                self.emit_err(errors::NotCircumventFeature);\n             }\n         }\n     }\n@@ -901,7 +893,7 @@ impl Session {\n                         // We only call `msg` in case we can actually emit warnings.\n                         // Otherwise, this could cause a `delay_good_path_bug` to\n                         // trigger (issue #79546).\n-                        self.emit_warning(OptimisationFuelExhausted { msg: msg() });\n+                        self.emit_warning(errors::OptimisationFuelExhausted { msg: msg() });\n                     }\n                     fuel.out_of_fuel = true;\n                 } else if fuel.remaining > 0 {\n@@ -1502,28 +1494,28 @@ fn validate_commandline_args_with_session_available(sess: &Session) {\n         && sess.opts.cg.prefer_dynamic\n         && sess.target.is_like_windows\n     {\n-        sess.emit_err(LinkerPluginToWindowsNotSupported);\n+        sess.emit_err(errors::LinkerPluginToWindowsNotSupported);\n     }\n \n     // Make sure that any given profiling data actually exists so LLVM can't\n     // decide to silently skip PGO.\n     if let Some(ref path) = sess.opts.cg.profile_use {\n         if !path.exists() {\n-            sess.emit_err(ProfileUseFileDoesNotExist { path });\n+            sess.emit_err(errors::ProfileUseFileDoesNotExist { path });\n         }\n     }\n \n     // Do the same for sample profile data.\n     if let Some(ref path) = sess.opts.unstable_opts.profile_sample_use {\n         if !path.exists() {\n-            sess.emit_err(ProfileSampleUseFileDoesNotExist { path });\n+            sess.emit_err(errors::ProfileSampleUseFileDoesNotExist { path });\n         }\n     }\n \n     // Unwind tables cannot be disabled if the target requires them.\n     if let Some(include_uwtables) = sess.opts.cg.force_unwind_tables {\n         if sess.target.requires_uwtable && !include_uwtables {\n-            sess.emit_err(TargetRequiresUnwindTables);\n+            sess.emit_err(errors::TargetRequiresUnwindTables);\n         }\n     }\n \n@@ -1533,67 +1525,69 @@ fn validate_commandline_args_with_session_available(sess: &Session) {\n     match unsupported_sanitizers.into_iter().count() {\n         0 => {}\n         1 => {\n-            sess.emit_err(SanitizerNotSupported { us: unsupported_sanitizers.to_string() });\n+            sess.emit_err(errors::SanitizerNotSupported { us: unsupported_sanitizers.to_string() });\n         }\n         _ => {\n-            sess.emit_err(SanitizersNotSupported { us: unsupported_sanitizers.to_string() });\n+            sess.emit_err(errors::SanitizersNotSupported {\n+                us: unsupported_sanitizers.to_string(),\n+            });\n         }\n     }\n     // Cannot mix and match sanitizers.\n     let mut sanitizer_iter = sess.opts.unstable_opts.sanitizer.into_iter();\n     if let (Some(first), Some(second)) = (sanitizer_iter.next(), sanitizer_iter.next()) {\n-        sess.emit_err(CannotMixAndMatchSanitizers {\n+        sess.emit_err(errors::CannotMixAndMatchSanitizers {\n             first: first.to_string(),\n             second: second.to_string(),\n         });\n     }\n \n     // Cannot enable crt-static with sanitizers on Linux\n     if sess.crt_static(None) && !sess.opts.unstable_opts.sanitizer.is_empty() {\n-        sess.emit_err(CannotEnableCrtStaticLinux);\n+        sess.emit_err(errors::CannotEnableCrtStaticLinux);\n     }\n \n     // LLVM CFI and VFE both require LTO.\n     if sess.lto() != config::Lto::Fat {\n         if sess.is_sanitizer_cfi_enabled() {\n-            sess.emit_err(SanitizerCfiEnabled);\n+            sess.emit_err(errors::SanitizerCfiEnabled);\n         }\n         if sess.opts.unstable_opts.virtual_function_elimination {\n-            sess.emit_err(UnstableVirtualFunctionElimination);\n+            sess.emit_err(errors::UnstableVirtualFunctionElimination);\n         }\n     }\n \n     // LLVM CFI and KCFI are mutually exclusive\n     if sess.is_sanitizer_cfi_enabled() && sess.is_sanitizer_kcfi_enabled() {\n-        sess.emit_err(CannotMixAndMatchSanitizers {\n+        sess.emit_err(errors::CannotMixAndMatchSanitizers {\n             first: \"cfi\".to_string(),\n             second: \"kcfi\".to_string(),\n         });\n     }\n \n     if sess.opts.unstable_opts.stack_protector != StackProtector::None {\n         if !sess.target.options.supports_stack_protector {\n-            sess.emit_warning(StackProtectorNotSupportedForTarget {\n+            sess.emit_warning(errors::StackProtectorNotSupportedForTarget {\n                 stack_protector: sess.opts.unstable_opts.stack_protector,\n                 target_triple: &sess.opts.target_triple,\n             });\n         }\n     }\n \n     if sess.opts.unstable_opts.branch_protection.is_some() && sess.target.arch != \"aarch64\" {\n-        sess.emit_err(BranchProtectionRequiresAArch64);\n+        sess.emit_err(errors::BranchProtectionRequiresAArch64);\n     }\n \n     if let Some(dwarf_version) = sess.opts.unstable_opts.dwarf_version {\n         if dwarf_version > 5 {\n-            sess.emit_err(UnsupportedDwarfVersion { dwarf_version });\n+            sess.emit_err(errors::UnsupportedDwarfVersion { dwarf_version });\n         }\n     }\n \n     if !sess.target.options.supported_split_debuginfo.contains(&sess.split_debuginfo())\n         && !sess.opts.unstable_opts.unstable_options\n     {\n-        sess.emit_err(SplitDebugInfoUnstablePlatform { debuginfo: sess.split_debuginfo() });\n+        sess.emit_err(errors::SplitDebugInfoUnstablePlatform { debuginfo: sess.split_debuginfo() });\n     }\n }\n "}]}