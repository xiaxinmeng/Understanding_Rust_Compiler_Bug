{"sha": "ac1d0d8b28008277a39a3f4d4a6bc34772c06888", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjMWQwZDhiMjgwMDgyNzdhMzlhM2Y0ZDRhNmJjMzQ3NzJjMDY4ODg=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-09-22T07:48:20Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-09-24T07:03:14Z"}, "message": "fmt, use IndexSet directly instead of UniquePredicates", "tree": {"sha": "f053d8049627518cafabc0ed86b666465de17330", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f053d8049627518cafabc0ed86b666465de17330"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac1d0d8b28008277a39a3f4d4a6bc34772c06888", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac1d0d8b28008277a39a3f4d4a6bc34772c06888", "html_url": "https://github.com/rust-lang/rust/commit/ac1d0d8b28008277a39a3f4d4a6bc34772c06888", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac1d0d8b28008277a39a3f4d4a6bc34772c06888/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1f408e6c8d440224dfa45f8b1a97ed84c790fcd", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1f408e6c8d440224dfa45f8b1a97ed84c790fcd", "html_url": "https://github.com/rust-lang/rust/commit/e1f408e6c8d440224dfa45f8b1a97ed84c790fcd"}], "stats": {"total": 55, "additions": 20, "deletions": 35}, "files": [{"sha": "fd2cd03a9c1808f6aa6b745067ca8c32f97a0601", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 20, "deletions": 35, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/ac1d0d8b28008277a39a3f4d4a6bc34772c06888/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1d0d8b28008277a39a3f4d4a6bc34772c06888/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=ac1d0d8b28008277a39a3f4d4a6bc34772c06888", "patch": "@@ -1679,8 +1679,9 @@ fn predicates_defined_on(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicate\n     if tcx.features().const_evaluatable_checked {\n         let const_evaluatable = const_evaluatable_predicates_of(tcx, def_id, &result);\n         if !const_evaluatable.is_empty() {\n-            result.predicates =\n-                tcx.arena.alloc_from_iter(result.predicates.iter().copied().chain(const_evaluatable));\n+            result.predicates = tcx\n+                .arena\n+                .alloc_from_iter(result.predicates.iter().copied().chain(const_evaluatable));\n         }\n     }\n \n@@ -1725,9 +1726,13 @@ pub fn const_evaluatable_predicates_of<'tcx>(\n     // We only want unique const evaluatable predicates.\n     collector.ct.sort();\n     collector.ct.dedup();\n-    collector.ct.into_iter().map(move |(def_id, subst, span)| {\n-        (ty::PredicateAtom::ConstEvaluatable(def_id, subst).to_predicate(tcx), span)\n-    }).collect()\n+    collector\n+        .ct\n+        .into_iter()\n+        .map(move |(def_id, subst, span)| {\n+            (ty::PredicateAtom::ConstEvaluatable(def_id, subst).to_predicate(tcx), span)\n+        })\n+        .collect()\n }\n \n /// Returns a list of all type predicates (explicit and implicit) for the definition with\n@@ -1767,29 +1772,6 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n \n     debug!(\"explicit_predicates_of(def_id={:?})\", def_id);\n \n-    /// A data structure with unique elements, which preserves order of insertion.\n-    /// Preserving the order of insertion is important here so as not to break\n-    /// compile-fail UI tests.\n-    struct UniquePredicates<'tcx> {\n-        predicates: FxIndexSet<(ty::Predicate<'tcx>, Span)>,\n-    }\n-\n-    impl<'tcx> UniquePredicates<'tcx> {\n-        fn new() -> Self {\n-            UniquePredicates { predicates: FxIndexSet::default() }\n-        }\n-\n-        fn push(&mut self, value: (ty::Predicate<'tcx>, Span)) {\n-            self.predicates.insert(value);\n-        }\n-\n-        fn extend<I: IntoIterator<Item = (ty::Predicate<'tcx>, Span)>>(&mut self, iter: I) {\n-            for value in iter {\n-                self.push(value);\n-            }\n-        }\n-    }\n-\n     let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n     let node = tcx.hir().get(hir_id);\n \n@@ -1802,7 +1784,10 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n \n     const NO_GENERICS: &hir::Generics<'_> = &hir::Generics::empty();\n \n-    let mut predicates = UniquePredicates::new();\n+    // We use an `IndexSet` to preserves order of insertion.\n+    // Preserving the order of insertion is important here so as not to break\n+    // compile-fail UI tests.\n+    let mut predicates: FxIndexSet<(ty::Predicate<'_>, Span)> = FxIndexSet::default();\n \n     let ast_generics = match node {\n         Node::TraitItem(item) => {\n@@ -1904,7 +1889,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n     // (see below). Recall that a default impl is not itself an impl, but rather a\n     // set of defaults that can be incorporated into another impl.\n     if let Some(trait_ref) = is_default_impl_trait {\n-        predicates.push((\n+        predicates.insert((\n             trait_ref.to_poly_trait_ref().without_const().to_predicate(tcx),\n             tcx.def_span(def_id),\n         ));\n@@ -1928,7 +1913,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n                     hir::GenericBound::Outlives(lt) => {\n                         let bound = AstConv::ast_region_to_region(&icx, &lt, None);\n                         let outlives = ty::Binder::bind(ty::OutlivesPredicate(region, bound));\n-                        predicates.push((outlives.to_predicate(tcx), lt.span));\n+                        predicates.insert((outlives.to_predicate(tcx), lt.span));\n                     }\n                     _ => bug!(),\n                 });\n@@ -1983,7 +1968,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n                         let span = bound_pred.bounded_ty.span;\n                         let re_root_empty = tcx.lifetimes.re_root_empty;\n                         let predicate = ty::OutlivesPredicate(ty, re_root_empty);\n-                        predicates.push((\n+                        predicates.insert((\n                             ty::PredicateAtom::TypeOutlives(predicate)\n                                 .potentially_quantified(tcx, ty::PredicateKind::ForAll),\n                             span,\n@@ -2027,11 +2012,11 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n \n                         &hir::GenericBound::Outlives(ref lifetime) => {\n                             let region = AstConv::ast_region_to_region(&icx, lifetime, None);\n-                            predicates.push((\n+                            predicates.insert((\n                                 ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(ty, region))\n                                     .potentially_quantified(tcx, ty::PredicateKind::ForAll),\n                                 lifetime.span,\n-                            ))\n+                            ));\n                         }\n                     }\n                 }\n@@ -2076,7 +2061,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n         }))\n     }\n \n-    let mut predicates: Vec<_> = predicates.predicates.into_iter().collect();\n+    let mut predicates: Vec<_> = predicates.into_iter().collect();\n \n     // Subtle: before we store the predicates into the tcx, we\n     // sort them so that predicates like `T: Foo<Item=U>` come"}]}