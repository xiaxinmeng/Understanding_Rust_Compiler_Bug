{"sha": "ab33f71a8be01a93d4d14ee5755beeefe38f1946", "node_id": "C_kwDOAAsO6NoAKGFiMzNmNzFhOGJlMDFhOTNkNGQxNGVlNTc1NWJlZWVmZTM4ZjE5NDY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-13T13:42:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-13T13:42:19Z"}, "message": "Auto merge of #95727 - m-ou-se:futex-reentrantmutex, r=Amanieu\n\nReplace ReentrantMutex by a futex-based one on Linux.\n\nTracking issue: https://github.com/rust-lang/rust/issues/93740\n\nr? `@Amanieu`", "tree": {"sha": "dfdebd6758fae0af3c1ae1a76864d82b6e9bae67", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dfdebd6758fae0af3c1ae1a76864d82b6e9bae67"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab33f71a8be01a93d4d14ee5755beeefe38f1946", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab33f71a8be01a93d4d14ee5755beeefe38f1946", "html_url": "https://github.com/rust-lang/rust/commit/ab33f71a8be01a93d4d14ee5755beeefe38f1946", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab33f71a8be01a93d4d14ee5755beeefe38f1946/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f38c5c8e5d76ea9a87fece143425ef7c703c706a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f38c5c8e5d76ea9a87fece143425ef7c703c706a", "html_url": "https://github.com/rust-lang/rust/commit/f38c5c8e5d76ea9a87fece143425ef7c703c706a"}, {"sha": "d4e44a63910c0e2d06c54534538b4a6e41348556", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4e44a63910c0e2d06c54534538b4a6e41348556", "html_url": "https://github.com/rust-lang/rust/commit/d4e44a63910c0e2d06c54534538b4a6e41348556"}], "stats": {"total": 108, "additions": 101, "deletions": 7}, "files": [{"sha": "d97777e4da29df9bd47b7ac4e06eff635100e31e", "filename": "library/std/src/sys/unix/locks/futex.rs", "status": "modified", "additions": 97, "deletions": 1, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/ab33f71a8be01a93d4d14ee5755beeefe38f1946/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab33f71a8be01a93d4d14ee5755beeefe38f1946/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex.rs?ref=ab33f71a8be01a93d4d14ee5755beeefe38f1946", "patch": "@@ -1,5 +1,6 @@\n+use crate::cell::UnsafeCell;\n use crate::sync::atomic::{\n-    AtomicI32,\n+    AtomicI32, AtomicUsize,\n     Ordering::{Acquire, Relaxed, Release},\n };\n use crate::sys::futex::{futex_wait, futex_wake, futex_wake_all};\n@@ -162,3 +163,98 @@ impl Condvar {\n         r\n     }\n }\n+\n+/// A reentrant mutex. Used by stdout().lock() and friends.\n+///\n+/// The 'owner' field tracks which thread has locked the mutex.\n+///\n+/// We use current_thread_unique_ptr() as the thread identifier,\n+/// which is just the address of a thread local variable.\n+///\n+/// If `owner` is set to the identifier of the current thread,\n+/// we assume the mutex is already locked and instead of locking it again,\n+/// we increment `lock_count`.\n+///\n+/// When unlocking, we decrement `lock_count`, and only unlock the mutex when\n+/// it reaches zero.\n+///\n+/// `lock_count` is protected by the mutex and only accessed by the thread that has\n+/// locked the mutex, so needs no synchronization.\n+///\n+/// `owner` can be checked by other threads that want to see if they already\n+/// hold the lock, so needs to be atomic. If it compares equal, we're on the\n+/// same thread that holds the mutex and memory access can use relaxed ordering\n+/// since we're not dealing with multiple threads. If it compares unequal,\n+/// synchronization is left to the mutex, making relaxed memory ordering for\n+/// the `owner` field fine in all cases.\n+pub struct ReentrantMutex {\n+    mutex: Mutex,\n+    owner: AtomicUsize,\n+    lock_count: UnsafeCell<u32>,\n+}\n+\n+unsafe impl Send for ReentrantMutex {}\n+unsafe impl Sync for ReentrantMutex {}\n+\n+impl ReentrantMutex {\n+    #[inline]\n+    pub const unsafe fn uninitialized() -> Self {\n+        Self { mutex: Mutex::new(), owner: AtomicUsize::new(0), lock_count: UnsafeCell::new(0) }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn init(&self) {}\n+\n+    #[inline]\n+    pub unsafe fn destroy(&self) {}\n+\n+    pub unsafe fn try_lock(&self) -> bool {\n+        let this_thread = current_thread_unique_ptr();\n+        if self.owner.load(Relaxed) == this_thread {\n+            self.increment_lock_count();\n+            true\n+        } else if self.mutex.try_lock() {\n+            self.owner.store(this_thread, Relaxed);\n+            debug_assert_eq!(*self.lock_count.get(), 0);\n+            *self.lock_count.get() = 1;\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    pub unsafe fn lock(&self) {\n+        let this_thread = current_thread_unique_ptr();\n+        if self.owner.load(Relaxed) == this_thread {\n+            self.increment_lock_count();\n+        } else {\n+            self.mutex.lock();\n+            self.owner.store(this_thread, Relaxed);\n+            debug_assert_eq!(*self.lock_count.get(), 0);\n+            *self.lock_count.get() = 1;\n+        }\n+    }\n+\n+    unsafe fn increment_lock_count(&self) {\n+        *self.lock_count.get() = (*self.lock_count.get())\n+            .checked_add(1)\n+            .expect(\"lock count overflow in reentrant mutex\");\n+    }\n+\n+    pub unsafe fn unlock(&self) {\n+        *self.lock_count.get() -= 1;\n+        if *self.lock_count.get() == 0 {\n+            self.owner.store(0, Relaxed);\n+            self.mutex.unlock();\n+        }\n+    }\n+}\n+\n+/// Get an address that is unique per running thread.\n+///\n+/// This can be used as a non-null usize-sized ID.\n+pub fn current_thread_unique_ptr() -> usize {\n+    // Use a non-drop type to make sure it's still available during thread destruction.\n+    thread_local! { static X: u8 = const { 0 } }\n+    X.with(|x| <*const _>::addr(x))\n+}"}, {"sha": "e0404f40c69bfbdcd0b9fddce862b4d5af2f2ade", "filename": "library/std/src/sys/unix/locks/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab33f71a8be01a93d4d14ee5755beeefe38f1946/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab33f71a8be01a93d4d14ee5755beeefe38f1946/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fmod.rs?ref=ab33f71a8be01a93d4d14ee5755beeefe38f1946", "patch": "@@ -5,11 +5,7 @@ cfg_if::cfg_if! {\n     ))] {\n         mod futex;\n         mod futex_rwlock;\n-        #[allow(dead_code)]\n-        mod pthread_mutex; // Only used for PthreadMutexAttr, needed by pthread_remutex.\n-        mod pthread_remutex; // FIXME: Implement this using a futex\n-        pub use futex::{Mutex, MovableMutex, Condvar, MovableCondvar};\n-        pub use pthread_remutex::ReentrantMutex;\n+        pub use futex::{Mutex, MovableMutex, Condvar, MovableCondvar, ReentrantMutex};\n         pub use futex_rwlock::{RwLock, MovableRwLock};\n     } else {\n         mod pthread_mutex;"}, {"sha": "3ad03a8868199e105787858f8893026e9faa68ad", "filename": "library/std/src/sys/unix/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ab33f71a8be01a93d4d14ee5755beeefe38f1946/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab33f71a8be01a93d4d14ee5755beeefe38f1946/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs?ref=ab33f71a8be01a93d4d14ee5755beeefe38f1946", "patch": "@@ -215,6 +215,7 @@ where\n     }\n }\n \n+#[allow(dead_code)] // Not used on all platforms.\n pub fn cvt_nz(error: libc::c_int) -> crate::io::Result<()> {\n     if error == 0 { Ok(()) } else { Err(crate::io::Error::from_raw_os_error(error)) }\n }"}, {"sha": "047d07ad57df148035ae8a1003082529985c91c3", "filename": "library/std/src/thread/local.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ab33f71a8be01a93d4d14ee5755beeefe38f1946/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab33f71a8be01a93d4d14ee5755beeefe38f1946/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs?ref=ab33f71a8be01a93d4d14ee5755beeefe38f1946", "patch": "@@ -179,6 +179,7 @@ macro_rules! __thread_local_inner {\n     // used to generate the `LocalKey` value for const-initialized thread locals\n     (@key $t:ty, const $init:expr) => {{\n         #[cfg_attr(not(windows), inline(always))] // see comments below\n+        #[deny(unsafe_op_in_unsafe_fn)]\n         unsafe fn __getit(\n             _init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n         ) -> $crate::option::Option<&'static $t> {\n@@ -193,7 +194,7 @@ macro_rules! __thread_local_inner {\n             #[cfg(all(target_family = \"wasm\", not(target_feature = \"atomics\")))]\n             {\n                 static mut VAL: $t = INIT_EXPR;\n-                $crate::option::Option::Some(&VAL)\n+                unsafe { $crate::option::Option::Some(&VAL) }\n             }\n \n             // If the platform has support for `#[thread_local]`, use it."}]}