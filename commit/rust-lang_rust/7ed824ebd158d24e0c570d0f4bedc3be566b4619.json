{"sha": "7ed824ebd158d24e0c570d0f4bedc3be566b4619", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlZDgyNGViZDE1OGQyNGUwYzU3MGQwZjRiZWRjM2JlNTY2YjQ2MTk=", "commit": {"author": {"name": "Lukas Lueg", "email": "lukas.lueg@gmail.com", "date": "2020-12-31T21:14:19Z"}, "committer": {"name": "Lukas Lueg", "email": "lukas.lueg@gmail.com", "date": "2020-12-31T22:09:13Z"}, "message": "Add Iterator::intersperse_with", "tree": {"sha": "f02cc3c73d61bd22728fedf08a38a01ce6c51af5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f02cc3c73d61bd22728fedf08a38a01ce6c51af5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ed824ebd158d24e0c570d0f4bedc3be566b4619", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ed824ebd158d24e0c570d0f4bedc3be566b4619", "html_url": "https://github.com/rust-lang/rust/commit/7ed824ebd158d24e0c570d0f4bedc3be566b4619", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ed824ebd158d24e0c570d0f4bedc3be566b4619/comments", "author": {"login": "lukaslueg", "id": 3148704, "node_id": "MDQ6VXNlcjMxNDg3MDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3148704?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lukaslueg", "html_url": "https://github.com/lukaslueg", "followers_url": "https://api.github.com/users/lukaslueg/followers", "following_url": "https://api.github.com/users/lukaslueg/following{/other_user}", "gists_url": "https://api.github.com/users/lukaslueg/gists{/gist_id}", "starred_url": "https://api.github.com/users/lukaslueg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lukaslueg/subscriptions", "organizations_url": "https://api.github.com/users/lukaslueg/orgs", "repos_url": "https://api.github.com/users/lukaslueg/repos", "events_url": "https://api.github.com/users/lukaslueg/events{/privacy}", "received_events_url": "https://api.github.com/users/lukaslueg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lukaslueg", "id": 3148704, "node_id": "MDQ6VXNlcjMxNDg3MDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3148704?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lukaslueg", "html_url": "https://github.com/lukaslueg", "followers_url": "https://api.github.com/users/lukaslueg/followers", "following_url": "https://api.github.com/users/lukaslueg/following{/other_user}", "gists_url": "https://api.github.com/users/lukaslueg/gists{/gist_id}", "starred_url": "https://api.github.com/users/lukaslueg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lukaslueg/subscriptions", "organizations_url": "https://api.github.com/users/lukaslueg/orgs", "repos_url": "https://api.github.com/users/lukaslueg/repos", "events_url": "https://api.github.com/users/lukaslueg/events{/privacy}", "received_events_url": "https://api.github.com/users/lukaslueg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae", "html_url": "https://github.com/rust-lang/rust/commit/9775ffef2a4c3a36cadb58b72ea60cefb92c86ae"}], "stats": {"total": 217, "additions": 192, "deletions": 25}, "files": [{"sha": "adae47459f7f493d91236a7995c05d72d93ee8b3", "filename": "library/core/src/iter/adapters/intersperse.rs", "status": "modified", "additions": 133, "deletions": 21, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/7ed824ebd158d24e0c570d0f4bedc3be566b4619/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fintersperse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed824ebd158d24e0c570d0f4bedc3be566b4619/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fintersperse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fintersperse.rs?ref=7ed824ebd158d24e0c570d0f4bedc3be566b4619", "patch": "@@ -40,37 +40,149 @@ where\n         }\n     }\n \n-    fn fold<B, F>(mut self, init: B, mut f: F) -> B\n+    fn fold<B, F>(self, init: B, f: F) -> B\n     where\n         Self: Sized,\n         F: FnMut(B, Self::Item) -> B,\n     {\n-        let mut accum = init;\n+        let separator = self.separator;\n+        intersperse_fold(self.iter, init, f, move || separator.clone(), self.needs_sep)\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        intersperse_size_hint(&self.iter, self.needs_sep)\n+    }\n+}\n+\n+/// An iterator adapter that places a separator between all elements.\n+#[unstable(feature = \"iter_intersperse\", reason = \"recently added\", issue = \"79524\")]\n+pub struct IntersperseWith<I, G>\n+where\n+    I: Iterator,\n+{\n+    separator: G,\n+    iter: Peekable<I>,\n+    needs_sep: bool,\n+}\n+\n+// FIXME This manual implementation is needed as #[derive] misplaces trait bounds,\n+// requiring <I as Iterator>::Item to be Debug on the struct-definition, which is\n+// not what we want.\n+#[unstable(feature = \"iter_intersperse\", reason = \"recently added\", issue = \"79524\")]\n+impl<I, G> crate::fmt::Debug for IntersperseWith<I, G>\n+where\n+    I: Iterator + crate::fmt::Debug,\n+    I::Item: crate::fmt::Debug,\n+    G: crate::fmt::Debug,\n+{\n+    fn fmt(&self, f: &mut crate::fmt::Formatter<'_>) -> crate::fmt::Result {\n+        f.debug_struct(\"IntersperseWith\")\n+            .field(\"separator\", &self.separator)\n+            .field(\"iter\", &self.iter)\n+            .field(\"needs_sep\", &self.needs_sep)\n+            .finish()\n+    }\n+}\n \n-        // Use `peek()` first to avoid calling `next()` on an empty iterator.\n-        if !self.needs_sep || self.iter.peek().is_some() {\n-            if let Some(x) = self.iter.next() {\n-                accum = f(accum, x);\n-            }\n+// FIXME This manual implementation is needed as #[derive] misplaces trait bounds,\n+// requiring <I as Iterator>::Item to be Clone on the struct-definition, which is\n+// not what we want.\n+#[unstable(feature = \"iter_intersperse\", reason = \"recently added\", issue = \"79524\")]\n+impl<I, G> crate::clone::Clone for IntersperseWith<I, G>\n+where\n+    I: Iterator + crate::clone::Clone,\n+    I::Item: crate::clone::Clone,\n+    G: Clone,\n+{\n+    fn clone(&self) -> Self {\n+        IntersperseWith {\n+            separator: self.separator.clone(),\n+            iter: self.iter.clone(),\n+            needs_sep: self.needs_sep.clone(),\n         }\n+    }\n+}\n \n-        let element = &self.separator;\n+impl<I, G> IntersperseWith<I, G>\n+where\n+    I: Iterator,\n+    G: FnMut() -> I::Item,\n+{\n+    pub(in crate::iter) fn new(iter: I, separator: G) -> Self {\n+        Self { iter: iter.peekable(), separator, needs_sep: false }\n+    }\n+}\n \n-        self.iter.fold(accum, |mut accum, x| {\n-            accum = f(accum, element.clone());\n-            accum = f(accum, x);\n-            accum\n-        })\n+#[unstable(feature = \"iter_intersperse\", reason = \"recently added\", issue = \"79524\")]\n+impl<I, G> Iterator for IntersperseWith<I, G>\n+where\n+    I: Iterator,\n+    G: FnMut() -> I::Item,\n+{\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        if self.needs_sep && self.iter.peek().is_some() {\n+            self.needs_sep = false;\n+            Some((self.separator)())\n+        } else {\n+            self.needs_sep = true;\n+            self.iter.next()\n+        }\n+    }\n+\n+    fn fold<B, F>(self, init: B, f: F) -> B\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> B,\n+    {\n+        intersperse_fold(self.iter, init, f, self.separator, self.needs_sep)\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (lo, hi) = self.iter.size_hint();\n-        let next_is_elem = !self.needs_sep;\n-        let lo = lo.saturating_sub(next_is_elem as usize).saturating_add(lo);\n-        let hi = match hi {\n-            Some(hi) => hi.saturating_sub(next_is_elem as usize).checked_add(hi),\n-            None => None,\n-        };\n-        (lo, hi)\n+        intersperse_size_hint(&self.iter, self.needs_sep)\n     }\n }\n+\n+fn intersperse_size_hint<I>(iter: &I, needs_sep: bool) -> (usize, Option<usize>)\n+where\n+    I: Iterator,\n+{\n+    let (lo, hi) = iter.size_hint();\n+    let next_is_elem = !needs_sep;\n+    let lo = lo.saturating_sub(next_is_elem as usize).saturating_add(lo);\n+    let hi = match hi {\n+        Some(hi) => hi.saturating_sub(next_is_elem as usize).checked_add(hi),\n+        None => None,\n+    };\n+    (lo, hi)\n+}\n+\n+fn intersperse_fold<I, B, F, G>(\n+    mut iter: Peekable<I>,\n+    init: B,\n+    mut f: F,\n+    mut separator: G,\n+    needs_sep: bool,\n+) -> B\n+where\n+    I: Iterator,\n+    F: FnMut(B, I::Item) -> B,\n+    G: FnMut() -> I::Item,\n+{\n+    let mut accum = init;\n+\n+    // Use `peek()` first to avoid calling `next()` on an empty iterator.\n+    if !needs_sep || iter.peek().is_some() {\n+        if let Some(x) = iter.next() {\n+            accum = f(accum, x);\n+        }\n+    }\n+\n+    iter.fold(accum, |mut accum, x| {\n+        accum = f(accum, separator());\n+        accum = f(accum, x);\n+        accum\n+    })\n+}"}, {"sha": "41a7b13232adf465dce0c20ce6d416ba2f92de46", "filename": "library/core/src/iter/adapters/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ed824ebd158d24e0c570d0f4bedc3be566b4619/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed824ebd158d24e0c570d0f4bedc3be566b4619/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs?ref=7ed824ebd158d24e0c570d0f4bedc3be566b4619", "patch": "@@ -43,7 +43,7 @@ pub use self::flatten::Flatten;\n pub use self::copied::Copied;\n \n #[unstable(feature = \"iter_intersperse\", reason = \"recently added\", issue = \"79524\")]\n-pub use self::intersperse::Intersperse;\n+pub use self::intersperse::{Intersperse, IntersperseWith};\n \n #[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"68537\")]\n pub use self::map_while::MapWhile;"}, {"sha": "c57ba2bf626452b80fe3e23b30e67ad5cc61500c", "filename": "library/core/src/iter/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ed824ebd158d24e0c570d0f4bedc3be566b4619/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed824ebd158d24e0c570d0f4bedc3be566b4619/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs?ref=7ed824ebd158d24e0c570d0f4bedc3be566b4619", "patch": "@@ -395,8 +395,6 @@ pub use self::adapters::Cloned;\n pub use self::adapters::Copied;\n #[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n pub use self::adapters::Flatten;\n-#[unstable(feature = \"iter_intersperse\", reason = \"recently added\", issue = \"79524\")]\n-pub use self::adapters::Intersperse;\n #[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"68537\")]\n pub use self::adapters::MapWhile;\n #[unstable(feature = \"inplace_iteration\", issue = \"none\")]\n@@ -410,6 +408,8 @@ pub use self::adapters::{\n     Chain, Cycle, Enumerate, Filter, FilterMap, FlatMap, Fuse, Inspect, Map, Peekable, Rev, Scan,\n     Skip, SkipWhile, Take, TakeWhile, Zip,\n };\n+#[unstable(feature = \"iter_intersperse\", reason = \"recently added\", issue = \"79524\")]\n+pub use self::adapters::{Intersperse, IntersperseWith};\n \n pub(crate) use self::adapters::process_results;\n "}, {"sha": "91d7a47907a461b91bdd4118a3caa08b4252869e", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7ed824ebd158d24e0c570d0f4bedc3be566b4619/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed824ebd158d24e0c570d0f4bedc3be566b4619/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=7ed824ebd158d24e0c570d0f4bedc3be566b4619", "patch": "@@ -8,7 +8,7 @@ use crate::ops::{Add, ControlFlow, Try};\n use super::super::TrustedRandomAccess;\n use super::super::{Chain, Cloned, Copied, Cycle, Enumerate, Filter, FilterMap, Fuse};\n use super::super::{FlatMap, Flatten};\n-use super::super::{FromIterator, Intersperse, Product, Sum, Zip};\n+use super::super::{FromIterator, Intersperse, IntersperseWith, Product, Sum, Zip};\n use super::super::{\n     Inspect, Map, MapWhile, Peekable, Rev, Scan, Skip, SkipWhile, StepBy, Take, TakeWhile,\n };\n@@ -591,6 +591,31 @@ pub trait Iterator {\n         Intersperse::new(self, separator)\n     }\n \n+    /// Places an element generated by `separator` between all elements.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(iter_intersperse)]\n+    ///\n+    /// let src = [\"Hello\", \"to\", \"all\", \"people\"].iter().copied();\n+    /// let mut separator = [\" \u2764\ufe0f \", \" \ud83d\ude00 \"].iter().copied().cycle();\n+    ///\n+    /// let result = src.intersperse_with(|| separator.next().unwrap()).collect::<String>();\n+    /// assert_eq!(result, \"Hello \u2764\ufe0f to \ud83d\ude00 all \u2764\ufe0f people\");\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"iter_intersperse\", reason = \"recently added\", issue = \"79524\")]\n+    fn intersperse_with<G>(self, separator: G) -> IntersperseWith<Self, G>\n+    where\n+        Self: Sized,\n+        G: FnMut() -> Self::Item,\n+    {\n+        IntersperseWith::new(self, separator)\n+    }\n+\n     /// Takes a closure and creates an iterator which calls that closure on each\n     /// element.\n     ///"}, {"sha": "691767edea6d9659527696e870a23409a86cbb50", "filename": "library/core/tests/iter.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7ed824ebd158d24e0c570d0f4bedc3be566b4619/library%2Fcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed824ebd158d24e0c570d0f4bedc3be566b4619/library%2Fcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter.rs?ref=7ed824ebd158d24e0c570d0f4bedc3be566b4619", "patch": "@@ -3508,6 +3508,12 @@ pub fn extend_for_unit() {\n \n #[test]\n fn test_intersperse() {\n+    let v = std::iter::empty().intersperse(0u32).collect::<Vec<_>>();\n+    assert_eq!(v, vec![]);\n+\n+    let v = std::iter::once(1).intersperse(0).collect::<Vec<_>>();\n+    assert_eq!(v, vec![1]);\n+\n     let xs = [\"a\", \"\", \"b\", \"c\"];\n     let v: Vec<&str> = xs.iter().map(|x| x.clone()).intersperse(\", \").collect();\n     let text: String = v.concat();\n@@ -3520,6 +3526,9 @@ fn test_intersperse() {\n \n #[test]\n fn test_intersperse_size_hint() {\n+    let iter = std::iter::empty::<i32>().intersperse(0);\n+    assert_eq!(iter.size_hint(), (0, Some(0)));\n+\n     let xs = [\"a\", \"\", \"b\", \"c\"];\n     let mut iter = xs.iter().map(|x| x.clone()).intersperse(\", \");\n     assert_eq!(iter.size_hint(), (7, Some(7)));\n@@ -3587,3 +3596,24 @@ fn test_try_fold_specialization_intersperse_err() {\n     iter.try_for_each(|item| if item == \"b\" { None } else { Some(()) });\n     assert_eq!(iter.next(), None);\n }\n+\n+#[test]\n+fn test_intersperse_with() {\n+    #[derive(PartialEq, Debug)]\n+    struct NotClone {\n+        u: u32,\n+    }\n+    let r = vec![NotClone { u: 0 }, NotClone { u: 1 }]\n+        .into_iter()\n+        .intersperse_with(|| NotClone { u: 2 })\n+        .collect::<Vec<_>>();\n+    assert_eq!(r, vec![NotClone { u: 0 }, NotClone { u: 2 }, NotClone { u: 1 }]);\n+\n+    let mut ctr = 100;\n+    let separator = || {\n+        ctr *= 2;\n+        ctr\n+    };\n+    let r = (0..3).intersperse_with(separator).collect::<Vec<_>>();\n+    assert_eq!(r, vec![0, 200, 1, 400, 2]);\n+}"}]}