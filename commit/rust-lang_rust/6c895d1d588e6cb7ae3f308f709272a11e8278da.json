{"sha": "6c895d1d588e6cb7ae3f308f709272a11e8278da", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjODk1ZDFkNTg4ZTZjYjdhZTNmMzA4ZjcwOTI3MmExMWU4Mjc4ZGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-14T07:41:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-14T07:41:34Z"}, "message": "auto merge of #12864 : huonw/rust/hash-docs, r=alexcrichton\n\ncollections: move hashmap's example to the struct.\r\n\r\nMost people go straight to the struct, not looking at the module, so the\r\nexample was well hidden.", "tree": {"sha": "b19bc545486d4bdec402f929e11d8bc7a0a7d741", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b19bc545486d4bdec402f929e11d8bc7a0a7d741"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c895d1d588e6cb7ae3f308f709272a11e8278da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c895d1d588e6cb7ae3f308f709272a11e8278da", "html_url": "https://github.com/rust-lang/rust/commit/6c895d1d588e6cb7ae3f308f709272a11e8278da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c895d1d588e6cb7ae3f308f709272a11e8278da/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b35e8fbfcb1ddf613184dbd512f1c896d99c77c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/b35e8fbfcb1ddf613184dbd512f1c896d99c77c9", "html_url": "https://github.com/rust-lang/rust/commit/b35e8fbfcb1ddf613184dbd512f1c896d99c77c9"}, {"sha": "d06266995cc3e0ed17d9a677893c2e5896b06298", "url": "https://api.github.com/repos/rust-lang/rust/commits/d06266995cc3e0ed17d9a677893c2e5896b06298", "html_url": "https://github.com/rust-lang/rust/commit/d06266995cc3e0ed17d9a677893c2e5896b06298"}], "stats": {"total": 106, "additions": 53, "deletions": 53}, "files": [{"sha": "fdf09a039848c6b979a81b05468735b7ff3db61e", "filename": "src/libcollections/hashmap.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/6c895d1d588e6cb7ae3f308f709272a11e8278da/src%2Flibcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c895d1d588e6cb7ae3f308f709272a11e8278da/src%2Flibcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhashmap.rs?ref=6c895d1d588e6cb7ae3f308f709272a11e8278da", "patch": "@@ -9,56 +9,6 @@\n // except according to those terms.\n \n //! Unordered containers, implemented as hash-tables (`HashSet` and `HashMap` types)\n-//!\n-//! The tables use a keyed hash with new random keys generated for each container, so the ordering\n-//! of a set of keys in a hash table is randomized.\n-//!\n-//! This is currently implemented with robin hood hashing, as described in [1][2][3].\n-//!\n-//! # Example\n-//!\n-//! ```rust\n-//! use collections::HashMap;\n-//!\n-//! // type inference lets us omit an explicit type signature (which\n-//! // would be `HashMap<&str, &str>` in this example).\n-//! let mut book_reviews = HashMap::new();\n-//!\n-//! // review some books.\n-//! book_reviews.insert(\"Adventures of Hucklebury Fin\",      \"My favorite book.\");\n-//! book_reviews.insert(\"Grimms' Fairy Tales\",               \"Masterpiece.\");\n-//! book_reviews.insert(\"Pride and Prejudice\",               \"Very enjoyable.\");\n-//! book_reviews.insert(\"The Adventures of Sherlock Holmes\", \"Eye lyked it alot.\");\n-//!\n-//! // check for a specific one.\n-//! if !book_reviews.contains_key(& &\"Les Mis\u00e9rables\") {\n-//!     println!(\"We've got {} reviews, but Les Mis\u00e9rables ain't one.\",\n-//!              book_reviews.len());\n-//! }\n-//!\n-//! // oops, this review has a lot of spelling mistakes, let's delete it.\n-//! book_reviews.remove(& &\"The Adventures of Sherlock Holmes\");\n-//!\n-//! // look up the values associated with some keys.\n-//! let to_find = [\"Pride and Prejudice\", \"Alice's Adventure in Wonderland\"];\n-//! for book in to_find.iter() {\n-//!     match book_reviews.find(book) {\n-//!         Some(review) => println!(\"{}: {}\", *book, *review),\n-//!         None => println!(\"{} is unreviewed.\", *book)\n-//!     }\n-//! }\n-//!\n-//! // iterate over everything.\n-//! for (book, review) in book_reviews.iter() {\n-//!     println!(\"{}: \\\"{}\\\"\", *book, *review);\n-//! }\n-//! ```\n-//!\n-//! Relevant papers/articles:\n-//!\n-//! [1]: Pedro Celis. [\"Robin Hood Hashing\"](https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf)\n-//! [2]: (http://codecapsule.com/2013/11/11/robin-hood-hashing/)\n-//! [3]: (http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/)\n \n use std::container::{Container, Mutable, Map, MutableMap, Set, MutableSet};\n use std::clone::Clone;\n@@ -667,14 +617,64 @@ static INITIAL_LOAD_FACTOR: Fraction = (9, 10);\n // `table::RawTable::new`, but I'm not confident it works for all sane alignments,\n // especially if a type needs more alignment than `malloc` provides.\n \n-/// A hash map implementation which uses linear probing with Robin Hood bucket\n-/// stealing.\n+/// A hash map implementation which uses linear probing with Robin\n+/// Hood bucket stealing.\n ///\n /// The hashes are all keyed by the task-local random number generator\n-/// on creation by default. This can be overriden with one of the constructors.\n+/// on creation by default, this means the ordering of the keys is\n+/// randomized, but makes the tables more resistant to\n+/// denial-of-service attacks (Hash DoS). This behaviour can be\n+/// overriden with one of the constructors.\n ///\n /// It is required that the keys implement the `Eq` and `Hash` traits, although\n /// this can frequently be achieved by using `#[deriving(Eq, Hash)]`.\n+///\n+/// Relevant papers/articles:\n+///\n+/// 1. Pedro Celis. [\"Robin Hood Hashing\"](https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf)\n+/// 2. Emmanuel Goossaert. [\"Robin Hood\n+///    hashing\"](http://codecapsule.com/2013/11/11/robin-hood-hashing/)\n+/// 3. Emmanuel Goossaert. [\"Robin Hood hashing: backward shift\n+///    deletion\"](http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/)\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use collections::HashMap;\n+///\n+/// // type inference lets us omit an explicit type signature (which\n+/// // would be `HashMap<&str, &str>` in this example).\n+/// let mut book_reviews = HashMap::new();\n+///\n+/// // review some books.\n+/// book_reviews.insert(\"Adventures of Hucklebury Fin\",      \"My favorite book.\");\n+/// book_reviews.insert(\"Grimms' Fairy Tales\",               \"Masterpiece.\");\n+/// book_reviews.insert(\"Pride and Prejudice\",               \"Very enjoyable.\");\n+/// book_reviews.insert(\"The Adventures of Sherlock Holmes\", \"Eye lyked it alot.\");\n+///\n+/// // check for a specific one.\n+/// if !book_reviews.contains_key(& &\"Les Mis\u00e9rables\") {\n+///     println!(\"We've got {} reviews, but Les Mis\u00e9rables ain't one.\",\n+///              book_reviews.len());\n+/// }\n+///\n+/// // oops, this review has a lot of spelling mistakes, let's delete it.\n+/// book_reviews.remove(& &\"The Adventures of Sherlock Holmes\");\n+///\n+/// // look up the values associated with some keys.\n+/// let to_find = [\"Pride and Prejudice\", \"Alice's Adventure in Wonderland\"];\n+/// for book in to_find.iter() {\n+///     match book_reviews.find(book) {\n+///         Some(review) => println!(\"{}: {}\", *book, *review),\n+///         None => println!(\"{} is unreviewed.\", *book)\n+///     }\n+/// }\n+///\n+/// // iterate over everything.\n+/// for (book, review) in book_reviews.iter() {\n+///     println!(\"{}: \\\"{}\\\"\", *book, *review);\n+/// }\n+/// ```\n #[deriving(Clone)]\n pub struct HashMap<K, V, H = sip::SipHasher> {\n     // All hashes are keyed on these values, to prevent hash collision attacks."}]}