{"sha": "0ae7054210b0bbc48ea51c3672be640d3096cfdd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhZTcwNTQyMTBiMGJiYzQ4ZWE1MWMzNjcyYmU2NDBkMzA5NmNmZGQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-02-29T15:27:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-29T15:27:53Z"}, "message": "Merge #3376\n\n3376: Fix a common false-positive type mismatch r=matklad a=flodiebold\n\nE.g. for `&{ some_string() }` in a context where a `&str` is expected, we\r\nreported a mismatch inside the block. The problem is that we're passing an\r\nexpectation of `str` down, but the expectation is more of a hint in this case.\r\nThere's a long comment in rustc about this, which I just copied.\r\n\r\nAlso, fix reported location for type mismatches in macros.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "51599b3664e16cd5f0ef288dac924330c5cd0af0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51599b3664e16cd5f0ef288dac924330c5cd0af0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ae7054210b0bbc48ea51c3672be640d3096cfdd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeWoL5CRBK7hj4Ov3rIwAAdHIIAA14rZldtvOJxveQMgbUsGyq\n/2N5Tn+l0+k0APhP6lswsrc3b10FeVfOFrKMRSUuobHlooEZHateIwR0M0+lXo0W\nt4u4C5V5schQ4j7KqGnBm5DiUi/gCLOItmyWIVYYdDDEqq6TB4/ems/7Oj/iuG5Q\nYfcgcGHjelRon1NuFl4+7GhUqH+FSGlNWLQ2Bz1LRpA+MM4aoOhS03PQOzzQAqs1\nBgbYRg+Xbyo8IOC5EU9/BunCyFqPr/q6CtAzU/p8FzuCwFfbjvhfgOxE/JkpxMhp\nYO/bQ5RT5EPyvp4BAVFxQqhSEoOnZ1UiR4RovNKFOS/fw9vgAkt/GM9iTxDfMQk=\n=zh91\n-----END PGP SIGNATURE-----\n", "payload": "tree 51599b3664e16cd5f0ef288dac924330c5cd0af0\nparent 0ec7f760fcd8bb9c2273e004468faa2a8cbeb29d\nparent 5fe220b9873d587188adae63fa205481a9aae9ce\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1582990073 +0000\ncommitter GitHub <noreply@github.com> 1582990073 +0000\n\nMerge #3376\n\n3376: Fix a common false-positive type mismatch r=matklad a=flodiebold\n\nE.g. for `&{ some_string() }` in a context where a `&str` is expected, we\r\nreported a mismatch inside the block. The problem is that we're passing an\r\nexpectation of `str` down, but the expectation is more of a hint in this case.\r\nThere's a long comment in rustc about this, which I just copied.\r\n\r\nAlso, fix reported location for type mismatches in macros.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ae7054210b0bbc48ea51c3672be640d3096cfdd", "html_url": "https://github.com/rust-lang/rust/commit/0ae7054210b0bbc48ea51c3672be640d3096cfdd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ae7054210b0bbc48ea51c3672be640d3096cfdd/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ec7f760fcd8bb9c2273e004468faa2a8cbeb29d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ec7f760fcd8bb9c2273e004468faa2a8cbeb29d", "html_url": "https://github.com/rust-lang/rust/commit/0ec7f760fcd8bb9c2273e004468faa2a8cbeb29d"}, {"sha": "5fe220b9873d587188adae63fa205481a9aae9ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fe220b9873d587188adae63fa205481a9aae9ce", "html_url": "https://github.com/rust-lang/rust/commit/5fe220b9873d587188adae63fa205481a9aae9ce"}], "stats": {"total": 104, "additions": 86, "deletions": 18}, "files": [{"sha": "569d46cc380e8e183b7268a261300c8aba48ec9b", "filename": "crates/ra_hir_ty/src/infer.rs", "status": "modified", "additions": 36, "deletions": 5, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0ae7054210b0bbc48ea51c3672be640d3096cfdd/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ae7054210b0bbc48ea51c3672be640d3096cfdd/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs?ref=0ae7054210b0bbc48ea51c3672be640d3096cfdd", "patch": "@@ -583,21 +583,52 @@ impl InferTy {\n #[derive(Clone, PartialEq, Eq, Debug)]\n struct Expectation {\n     ty: Ty,\n-    // FIXME: In some cases, we need to be aware whether the expectation is that\n-    // the type match exactly what we passed, or whether it just needs to be\n-    // coercible to the expected type. See Expectation::rvalue_hint in rustc.\n+    /// See the `rvalue_hint` method.\n+    rvalue_hint: bool,\n }\n \n impl Expectation {\n     /// The expectation that the type of the expression needs to equal the given\n     /// type.\n     fn has_type(ty: Ty) -> Self {\n-        Expectation { ty }\n+        Expectation { ty, rvalue_hint: false }\n+    }\n+\n+    /// The following explanation is copied straight from rustc:\n+    /// Provides an expectation for an rvalue expression given an *optional*\n+    /// hint, which is not required for type safety (the resulting type might\n+    /// be checked higher up, as is the case with `&expr` and `box expr`), but\n+    /// is useful in determining the concrete type.\n+    ///\n+    /// The primary use case is where the expected type is a fat pointer,\n+    /// like `&[isize]`. For example, consider the following statement:\n+    ///\n+    ///    let x: &[isize] = &[1, 2, 3];\n+    ///\n+    /// In this case, the expected type for the `&[1, 2, 3]` expression is\n+    /// `&[isize]`. If however we were to say that `[1, 2, 3]` has the\n+    /// expectation `ExpectHasType([isize])`, that would be too strong --\n+    /// `[1, 2, 3]` does not have the type `[isize]` but rather `[isize; 3]`.\n+    /// It is only the `&[1, 2, 3]` expression as a whole that can be coerced\n+    /// to the type `&[isize]`. Therefore, we propagate this more limited hint,\n+    /// which still is useful, because it informs integer literals and the like.\n+    /// See the test case `test/ui/coerce-expect-unsized.rs` and #20169\n+    /// for examples of where this comes up,.\n+    fn rvalue_hint(ty: Ty) -> Self {\n+        Expectation { ty, rvalue_hint: true }\n     }\n \n     /// This expresses no expectation on the type.\n     fn none() -> Self {\n-        Expectation { ty: Ty::Unknown }\n+        Expectation { ty: Ty::Unknown, rvalue_hint: false }\n+    }\n+\n+    fn coercion_target(&self) -> &Ty {\n+        if self.rvalue_hint {\n+            &Ty::Unknown\n+        } else {\n+            &self.ty\n+        }\n     }\n }\n "}, {"sha": "3db5b2b5152786539821c877b4a817ee76d6b24a", "filename": "crates/ra_hir_ty/src/infer/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0ae7054210b0bbc48ea51c3672be640d3096cfdd/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ae7054210b0bbc48ea51c3672be640d3096cfdd/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=0ae7054210b0bbc48ea51c3672be640d3096cfdd", "patch": "@@ -42,14 +42,14 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     /// Return the type after possible coercion.\n     pub(super) fn infer_expr_coerce(&mut self, expr: ExprId, expected: &Expectation) -> Ty {\n         let ty = self.infer_expr_inner(expr, &expected);\n-        let ty = if !self.coerce(&ty, &expected.ty) {\n+        let ty = if !self.coerce(&ty, &expected.coercion_target()) {\n             self.result\n                 .type_mismatches\n                 .insert(expr, TypeMismatch { expected: expected.ty.clone(), actual: ty.clone() });\n             // Return actual type when type mismatch.\n             // This is needed for diagnostic when return type mismatch.\n             ty\n-        } else if expected.ty == Ty::Unknown {\n+        } else if expected.coercion_target() == &Ty::Unknown {\n             ty\n         } else {\n             expected.ty.clone()\n@@ -297,7 +297,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                             // FIXME: throw type error - expected mut reference but found shared ref,\n                             // which cannot be coerced\n                         }\n-                        Expectation::has_type(Ty::clone(exp_inner))\n+                        Expectation::rvalue_hint(Ty::clone(exp_inner))\n                     } else {\n                         Expectation::none()\n                     };\n@@ -542,7 +542,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         let ty = if let Some(expr) = tail {\n             self.infer_expr_coerce(expr, expected)\n         } else {\n-            self.coerce(&Ty::unit(), &expected.ty);\n+            self.coerce(&Ty::unit(), expected.coercion_target());\n             Ty::unit()\n         };\n         if diverges {"}, {"sha": "1e303f5ce4be78853edd6eb36854449bba1692fe", "filename": "crates/ra_hir_ty/src/tests/coercion.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0ae7054210b0bbc48ea51c3672be640d3096cfdd/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ae7054210b0bbc48ea51c3672be640d3096cfdd/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=0ae7054210b0bbc48ea51c3672be640d3096cfdd", "patch": "@@ -457,6 +457,37 @@ fn test() {\n     );\n }\n \n+#[test]\n+fn coerce_autoderef_block() {\n+    assert_snapshot!(\n+        infer_with_mismatches(r#\"\n+struct String {}\n+#[lang = \"deref\"]\n+trait Deref { type Target; }\n+impl Deref for String { type Target = str; }\n+fn takes_ref_str(x: &str) {}\n+fn returns_string() -> String { loop {} }\n+fn test() {\n+    takes_ref_str(&{ returns_string() });\n+}\n+\"#, true),\n+        @r###\"\n+    [127; 128) 'x': &str\n+    [136; 138) '{}': ()\n+    [169; 180) '{ loop {} }': String\n+    [171; 178) 'loop {}': !\n+    [176; 178) '{}': ()\n+    [191; 236) '{     ... }); }': ()\n+    [197; 210) 'takes_ref_str': fn takes_ref_str(&str) -> ()\n+    [197; 233) 'takes_...g() })': ()\n+    [211; 232) '&{ ret...ng() }': &String\n+    [212; 232) '{ retu...ng() }': String\n+    [214; 228) 'returns_string': fn returns_string() -> String\n+    [214; 230) 'return...ring()': String\n+    \"###\n+    );\n+}\n+\n #[test]\n fn closure_return_coerce() {\n     assert_snapshot!("}, {"sha": "d70d34bdc3828ac3ebe8d9d11b63cab9eea53d44", "filename": "crates/rust-analyzer/src/cli/analysis_stats.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0ae7054210b0bbc48ea51c3672be640d3096cfdd/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ae7054210b0bbc48ea51c3672be640d3096cfdd/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs?ref=0ae7054210b0bbc48ea51c3672be640d3096cfdd", "patch": "@@ -4,8 +4,8 @@\n use std::{collections::HashSet, fmt::Write, path::Path, time::Instant};\n \n use hir::{\n-    db::{DefDatabase, HirDatabase},\n-    AssocItem, Crate, HasSource, HirDisplay, ModuleDef,\n+    db::{AstDatabase, DefDatabase, HirDatabase},\n+    original_range, AssocItem, Crate, HasSource, HirDisplay, ModuleDef,\n };\n use hir_def::FunctionId;\n use hir_ty::{Ty, TypeWalk};\n@@ -188,13 +188,19 @@ pub fn analysis_stats(\n                     let src = sm.expr_syntax(expr_id);\n                     if let Some(src) = src {\n                         // FIXME: it might be nice to have a function (on Analysis?) that goes from Source<T> -> (LineCol, LineCol) directly\n-                        let original_file = src.file_id.original_file(db);\n-                        let path = db.file_relative_path(original_file);\n-                        let line_index = host.analysis().file_line_index(original_file).unwrap();\n-                        let text_range = src.value.either(\n-                            |it| it.syntax_node_ptr().range(),\n-                            |it| it.syntax_node_ptr().range(),\n-                        );\n+                        // But also, we should just turn the type mismatches into diagnostics and provide these\n+                        let root = db.parse_or_expand(src.file_id).unwrap();\n+                        let node = src.map(|e| {\n+                            e.either(\n+                                |p| p.to_node(&root).syntax().clone(),\n+                                |p| p.to_node(&root).syntax().clone(),\n+                            )\n+                        });\n+                        let original_range = original_range(db, node.as_ref());\n+                        let path = db.file_relative_path(original_range.file_id);\n+                        let line_index =\n+                            host.analysis().file_line_index(original_range.file_id).unwrap();\n+                        let text_range = original_range.range;\n                         let (start, end) = (\n                             line_index.line_col(text_range.start()),\n                             line_index.line_col(text_range.end()),"}]}