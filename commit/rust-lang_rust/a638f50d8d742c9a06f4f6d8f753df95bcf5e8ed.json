{"sha": "a638f50d8d742c9a06f4f6d8f753df95bcf5e8ed", "node_id": "C_kwDOAAsO6NoAKGE2MzhmNTBkOGQ3NDJjOWEwNmY0ZjZkOGY3NTNkZjk1YmNmNWU4ZWQ", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-03-03T19:01:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-03T19:01:43Z"}, "message": "Rollup merge of #92697 - the8472:cgroups, r=joshtriplett\n\nUse cgroup quotas for calculating `available_parallelism`\n\nAutomated tests for this are possible but would require a bunch of assumptions. It requires root + a recent kernel, systemd and maybe docker. And even then it would need a helper binary since the test has to run in a separate process.\n\nLimitations\n\n* only supports cgroup v2 and assumes it's mounted under `/sys/fs/cgroup`\n* procfs must be available\n* the quota gets mixed into `sched_getaffinity`, so if the latter doesn't work then quota information gets ignored too\n\nManually tested via\n\n```\n// spawn a new cgroup scope for the current user\n$ sudo systemd-run -p CPUQuota=\"300%\" --uid=$(id -u) -tdS\n\n// quota.rs\n#![feature(available_parallelism)]\nfn main() {\n    println!(\"{:?}\", std::thread::available_parallelism()); // prints Ok(3)\n}\n```\n\nstrace:\n\n```\nsched_getaffinity(3041643, 32, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47]) = 32\nopenat(AT_FDCWD, \"/proc/self/cgroup\", O_RDONLY|O_CLOEXEC) = 3\nstatx(0, NULL, AT_STATX_SYNC_AS_STAT, STATX_ALL, NULL) = -1 EFAULT (Bad address)\nstatx(3, \"\", AT_STATX_SYNC_AS_STAT|AT_EMPTY_PATH, STATX_ALL, {stx_mask=STATX_BASIC_STATS|STATX_MNT_ID, stx_attributes=0, stx_mode=S_IFREG|0444, stx_size=0, ...}) = 0\nlseek(3, 0, SEEK_CUR)                   = 0\nread(3, \"0::/system.slice/run-u31477.serv\"..., 128) = 36\nread(3, \"\", 92)                         = 0\nclose(3)                                = 0\nstatx(AT_FDCWD, \"/sys/fs/cgroup/system.slice/run-u31477.service/cgroup.controllers\", AT_STATX_SYNC_AS_STAT, STATX_ALL, {stx_mask=STATX_BASIC_STATS|STATX_MNT_ID, stx_attributes=0, stx_mode=S_IFREG|0444, stx_size=0, ...}) = 0\nopenat(AT_FDCWD, \"/sys/fs/cgroup/system.slice/run-u31477.service/cpu.max\", O_RDONLY|O_CLOEXEC) = 3\nstatx(3, \"\", AT_STATX_SYNC_AS_STAT|AT_EMPTY_PATH, STATX_ALL, {stx_mask=STATX_BASIC_STATS|STATX_MNT_ID, stx_attributes=0, stx_mode=S_IFREG|0644, stx_size=0, ...}) = 0\nlseek(3, 0, SEEK_CUR)                   = 0\nread(3, \"300000 100000\\n\", 20)          = 14\nread(3, \"\", 6)                          = 0\nclose(3)                                = 0\nopenat(AT_FDCWD, \"/sys/fs/cgroup/system.slice/cpu.max\", O_RDONLY|O_CLOEXEC) = 3\nstatx(3, \"\", AT_STATX_SYNC_AS_STAT|AT_EMPTY_PATH, STATX_ALL, {stx_mask=STATX_BASIC_STATS|STATX_MNT_ID, stx_attributes=0, stx_mode=S_IFREG|0644, stx_size=0, ...}) = 0\nlseek(3, 0, SEEK_CUR)                   = 0\nread(3, \"max 100000\\n\", 20)             = 11\nread(3, \"\", 9)                          = 0\nclose(3)                                = 0\nopenat(AT_FDCWD, \"/sys/fs/cgroup/cpu.max\", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)\nsched_getaffinity(0, 128, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47]) = 40\n```\n\nr? ```````@joshtriplett```````\ncc ```````@yoshuawuyts```````\n\nTracking issue and previous discussion: #74479", "tree": {"sha": "a42db09ba660b78669f05223ab592ab5abab9866", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a42db09ba660b78669f05223ab592ab5abab9866"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a638f50d8d742c9a06f4f6d8f753df95bcf5e8ed", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiIRCYCRBK7hj4Ov3rIwAAlRwIABrA4Vh0b9hsWBUSUwAtvuNc\nBvgFANjOhMIrX8QcWdBZniRLBn/svB8oytw0TcauZkIYB6HCkVxRt2EwEQ68Q+3p\n9FZQ6KRDI3S5L/GJd2HJJSZe820LQ/LaQAz1gefSN3gCKCxPv0yzAg5i3s0STz7n\nqbODlho+zY1hgDfBlxJ0qOEg1km+9Sc27YzmfRdTHBzlh7aaqVvgx+cn/edrF3DX\nto3MyzkRkmpm111ziRHbyMRoCHZx/Dua+Okd0tc7PAgMRo6Z/JibuhBfSu4lhfVI\nFiPECvk8CZSGUgiLVQzCKCv7w+hAHm5wIqLg5RGAbRNw5Nr5UVpwh96h4WxyPY0=\n=+PaJ\n-----END PGP SIGNATURE-----\n", "payload": "tree a42db09ba660b78669f05223ab592ab5abab9866\nparent 32cbc7630b2d6b7141e2588f91380c1a58cf0016\nparent e18abbf2ac544ef744c5aa95df434b2c81c066a2\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1646334103 +0100\ncommitter GitHub <noreply@github.com> 1646334103 +0100\n\nRollup merge of #92697 - the8472:cgroups, r=joshtriplett\n\nUse cgroup quotas for calculating `available_parallelism`\n\nAutomated tests for this are possible but would require a bunch of assumptions. It requires root + a recent kernel, systemd and maybe docker. And even then it would need a helper binary since the test has to run in a separate process.\n\nLimitations\n\n* only supports cgroup v2 and assumes it's mounted under `/sys/fs/cgroup`\n* procfs must be available\n* the quota gets mixed into `sched_getaffinity`, so if the latter doesn't work then quota information gets ignored too\n\nManually tested via\n\n```\n// spawn a new cgroup scope for the current user\n$ sudo systemd-run -p CPUQuota=\"300%\" --uid=$(id -u) -tdS\n\n// quota.rs\n#![feature(available_parallelism)]\nfn main() {\n    println!(\"{:?}\", std::thread::available_parallelism()); // prints Ok(3)\n}\n```\n\nstrace:\n\n```\nsched_getaffinity(3041643, 32, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47]) = 32\nopenat(AT_FDCWD, \"/proc/self/cgroup\", O_RDONLY|O_CLOEXEC) = 3\nstatx(0, NULL, AT_STATX_SYNC_AS_STAT, STATX_ALL, NULL) = -1 EFAULT (Bad address)\nstatx(3, \"\", AT_STATX_SYNC_AS_STAT|AT_EMPTY_PATH, STATX_ALL, {stx_mask=STATX_BASIC_STATS|STATX_MNT_ID, stx_attributes=0, stx_mode=S_IFREG|0444, stx_size=0, ...}) = 0\nlseek(3, 0, SEEK_CUR)                   = 0\nread(3, \"0::/system.slice/run-u31477.serv\"..., 128) = 36\nread(3, \"\", 92)                         = 0\nclose(3)                                = 0\nstatx(AT_FDCWD, \"/sys/fs/cgroup/system.slice/run-u31477.service/cgroup.controllers\", AT_STATX_SYNC_AS_STAT, STATX_ALL, {stx_mask=STATX_BASIC_STATS|STATX_MNT_ID, stx_attributes=0, stx_mode=S_IFREG|0444, stx_size=0, ...}) = 0\nopenat(AT_FDCWD, \"/sys/fs/cgroup/system.slice/run-u31477.service/cpu.max\", O_RDONLY|O_CLOEXEC) = 3\nstatx(3, \"\", AT_STATX_SYNC_AS_STAT|AT_EMPTY_PATH, STATX_ALL, {stx_mask=STATX_BASIC_STATS|STATX_MNT_ID, stx_attributes=0, stx_mode=S_IFREG|0644, stx_size=0, ...}) = 0\nlseek(3, 0, SEEK_CUR)                   = 0\nread(3, \"300000 100000\\n\", 20)          = 14\nread(3, \"\", 6)                          = 0\nclose(3)                                = 0\nopenat(AT_FDCWD, \"/sys/fs/cgroup/system.slice/cpu.max\", O_RDONLY|O_CLOEXEC) = 3\nstatx(3, \"\", AT_STATX_SYNC_AS_STAT|AT_EMPTY_PATH, STATX_ALL, {stx_mask=STATX_BASIC_STATS|STATX_MNT_ID, stx_attributes=0, stx_mode=S_IFREG|0644, stx_size=0, ...}) = 0\nlseek(3, 0, SEEK_CUR)                   = 0\nread(3, \"max 100000\\n\", 20)             = 11\nread(3, \"\", 9)                          = 0\nclose(3)                                = 0\nopenat(AT_FDCWD, \"/sys/fs/cgroup/cpu.max\", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)\nsched_getaffinity(0, 128, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47]) = 40\n```\n\nr? ```````@joshtriplett```````\ncc ```````@yoshuawuyts```````\n\nTracking issue and previous discussion: #74479\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a638f50d8d742c9a06f4f6d8f753df95bcf5e8ed", "html_url": "https://github.com/rust-lang/rust/commit/a638f50d8d742c9a06f4f6d8f753df95bcf5e8ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a638f50d8d742c9a06f4f6d8f753df95bcf5e8ed/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32cbc7630b2d6b7141e2588f91380c1a58cf0016", "url": "https://api.github.com/repos/rust-lang/rust/commits/32cbc7630b2d6b7141e2588f91380c1a58cf0016", "html_url": "https://github.com/rust-lang/rust/commit/32cbc7630b2d6b7141e2588f91380c1a58cf0016"}, {"sha": "e18abbf2ac544ef744c5aa95df434b2c81c066a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/e18abbf2ac544ef744c5aa95df434b2c81c066a2", "html_url": "https://github.com/rust-lang/rust/commit/e18abbf2ac544ef744c5aa95df434b2c81c066a2"}], "stats": {"total": 90, "additions": 86, "deletions": 4}, "files": [{"sha": "ff01ce273332909b3ee2dd06621f0b0c838549ce", "filename": "library/std/src/sys/unix/thread.rs", "status": "modified", "additions": 82, "deletions": 3, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/a638f50d8d742c9a06f4f6d8f753df95bcf5e8ed/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a638f50d8d742c9a06f4f6d8f753df95bcf5e8ed/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs?ref=a638f50d8d742c9a06f4f6d8f753df95bcf5e8ed", "patch": "@@ -279,10 +279,15 @@ pub fn available_parallelism() -> io::Result<NonZeroUsize> {\n         ))] {\n             #[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n             {\n+                let quota = cgroup2_quota().max(1);\n                 let mut set: libc::cpu_set_t = unsafe { mem::zeroed() };\n-                if unsafe { libc::sched_getaffinity(0, mem::size_of::<libc::cpu_set_t>(), &mut set) } == 0 {\n-                    let count = unsafe { libc::CPU_COUNT(&set) };\n-                    return Ok(unsafe { NonZeroUsize::new_unchecked(count as usize) });\n+                unsafe {\n+                    if libc::sched_getaffinity(0, mem::size_of::<libc::cpu_set_t>(), &mut set) == 0 {\n+                        let count = libc::CPU_COUNT(&set) as usize;\n+                        let count = count.min(quota);\n+                        // SAFETY: affinity mask can't be empty and the quota gets clamped to a minimum of 1\n+                        return Ok(NonZeroUsize::new_unchecked(count));\n+                    }\n                 }\n             }\n             match unsafe { libc::sysconf(libc::_SC_NPROCESSORS_ONLN) } {\n@@ -368,6 +373,80 @@ pub fn available_parallelism() -> io::Result<NonZeroUsize> {\n     }\n }\n \n+/// Returns cgroup CPU quota in core-equivalents, rounded down, or usize::MAX if the quota cannot\n+/// be determined or is not set.\n+#[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n+fn cgroup2_quota() -> usize {\n+    use crate::ffi::OsString;\n+    use crate::fs::{try_exists, File};\n+    use crate::io::Read;\n+    use crate::os::unix::ffi::OsStringExt;\n+    use crate::path::PathBuf;\n+\n+    let mut quota = usize::MAX;\n+\n+    let _: Option<()> = try {\n+        let mut buf = Vec::with_capacity(128);\n+        // find our place in the cgroup hierarchy\n+        File::open(\"/proc/self/cgroup\").ok()?.read_to_end(&mut buf).ok()?;\n+        let cgroup_path = buf\n+            .split(|&c| c == b'\\n')\n+            .filter_map(|line| {\n+                let mut fields = line.splitn(3, |&c| c == b':');\n+                // expect cgroupv2 which has an empty 2nd field\n+                if fields.nth(1) != Some(b\"\") {\n+                    return None;\n+                }\n+                let path = fields.last()?;\n+                // skip leading slash\n+                Some(path[1..].to_owned())\n+            })\n+            .next()?;\n+        let cgroup_path = PathBuf::from(OsString::from_vec(cgroup_path));\n+\n+        let mut path = PathBuf::with_capacity(128);\n+        let mut read_buf = String::with_capacity(20);\n+\n+        let cgroup_mount = \"/sys/fs/cgroup\";\n+\n+        path.push(cgroup_mount);\n+        path.push(&cgroup_path);\n+\n+        path.push(\"cgroup.controllers\");\n+\n+        // skip if we're not looking at cgroup2\n+        if matches!(try_exists(&path), Err(_) | Ok(false)) {\n+            return usize::MAX;\n+        };\n+\n+        path.pop();\n+\n+        while path.starts_with(cgroup_mount) {\n+            path.push(\"cpu.max\");\n+\n+            read_buf.clear();\n+\n+            if File::open(&path).and_then(|mut f| f.read_to_string(&mut read_buf)).is_ok() {\n+                let raw_quota = read_buf.lines().next()?;\n+                let mut raw_quota = raw_quota.split(' ');\n+                let limit = raw_quota.next()?;\n+                let period = raw_quota.next()?;\n+                match (limit.parse::<usize>(), period.parse::<usize>()) {\n+                    (Ok(limit), Ok(period)) => {\n+                        quota = quota.min(limit / period);\n+                    }\n+                    _ => {}\n+                }\n+            }\n+\n+            path.pop(); // pop filename\n+            path.pop(); // pop dir\n+        }\n+    };\n+\n+    quota\n+}\n+\n #[cfg(all(\n     not(target_os = \"linux\"),\n     not(target_os = \"freebsd\"),"}, {"sha": "09d1e714ab6ddcab91a76175ac32497fe1f6f4ab", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a638f50d8d742c9a06f4f6d8f753df95bcf5e8ed/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a638f50d8d742c9a06f4f6d8f753df95bcf5e8ed/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=a638f50d8d742c9a06f4f6d8f753df95bcf5e8ed", "patch": "@@ -1524,7 +1524,10 @@ fn _assert_sync_and_send() {\n ///\n /// On Linux:\n /// - It may overcount the amount of parallelism available when limited by a\n-///   process-wide affinity mask, or when affected by cgroup limits.\n+///   process-wide affinity mask or cgroup quotas and cgroup2 fs or `sched_getaffinity()` can't be\n+///   queried, e.g. due to sandboxing.\n+/// - It may undercount the amount of parallelism if the current thread's affinity mask\n+///   does not reflect the process' cpuset, e.g. due to pinned threads.\n ///\n /// On all targets:\n /// - It may overcount the amount of parallelism available when running in a VM"}]}