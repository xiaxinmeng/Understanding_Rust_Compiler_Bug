{"sha": "9e963b9b2f7da465e66b733403b726b89304d976", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllOTYzYjliMmY3ZGE0NjVlNjZiNzMzNDAzYjcyNmI4OTMwNGQ5NzY=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-22T17:12:56Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-31T15:38:55Z"}, "message": "Add a non type-specific arena.\n\nIt relies on the underlying types not having special Drop behavior.", "tree": {"sha": "3db0eb862d575cc6ffa3cac6c662a498ae7b7101", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3db0eb862d575cc6ffa3cac6c662a498ae7b7101"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e963b9b2f7da465e66b733403b726b89304d976", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e963b9b2f7da465e66b733403b726b89304d976", "html_url": "https://github.com/rust-lang/rust/commit/9e963b9b2f7da465e66b733403b726b89304d976", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e963b9b2f7da465e66b733403b726b89304d976/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca0cc27ab6569c1afbd6aa1e3ab7b925b226b679", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca0cc27ab6569c1afbd6aa1e3ab7b925b226b679", "html_url": "https://github.com/rust-lang/rust/commit/ca0cc27ab6569c1afbd6aa1e3ab7b925b226b679"}], "stats": {"total": 117, "additions": 117, "deletions": 0}, "files": [{"sha": "02e548c4f6e24d8c97e432ef0d3b08f35e779737", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/9e963b9b2f7da465e66b733403b726b89304d976/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e963b9b2f7da465e66b733403b726b89304d976/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=9e963b9b2f7da465e66b733403b726b89304d976", "patch": "@@ -280,6 +280,123 @@ impl<T> Drop for TypedArena<T> {\n \n unsafe impl<T: Send> Send for TypedArena<T> {}\n \n+pub struct DroplessArena {\n+    /// A pointer to the next object to be allocated.\n+    ptr: Cell<*mut u8>,\n+\n+    /// A pointer to the end of the allocated area. When this pointer is\n+    /// reached, a new chunk is allocated.\n+    end: Cell<*mut u8>,\n+\n+    /// A vector of arena chunks.\n+    chunks: RefCell<Vec<TypedArenaChunk<u8>>>,\n+}\n+\n+impl DroplessArena {\n+    pub fn new() -> DroplessArena {\n+        DroplessArena {\n+            ptr: Cell::new(0 as *mut u8),\n+            end: Cell::new(0 as *mut u8),\n+            chunks: RefCell::new(vec![]),\n+        }\n+    }\n+\n+    fn align_for<T>(&self) {\n+        let align = mem::align_of::<T>();\n+        let final_address = ((self.ptr.get() as usize) + align - 1) & !(align - 1);\n+        self.ptr.set(final_address as *mut u8);\n+        assert!(self.ptr <= self.end);\n+    }\n+\n+    #[inline(never)]\n+    #[cold]\n+    fn grow<T>(&self, n: usize) {\n+        let needed_bytes = n * mem::size_of::<T>();\n+        unsafe {\n+            let mut chunks = self.chunks.borrow_mut();\n+            let (chunk, mut new_capacity);\n+            if let Some(last_chunk) = chunks.last_mut() {\n+                let used_bytes = self.ptr.get() as usize - last_chunk.start() as usize;\n+                if last_chunk.storage.reserve_in_place(used_bytes, needed_bytes) {\n+                    self.end.set(last_chunk.end());\n+                    return;\n+                } else {\n+                    new_capacity = last_chunk.storage.cap();\n+                    loop {\n+                        new_capacity = new_capacity.checked_mul(2).unwrap();\n+                        if new_capacity >= used_bytes + needed_bytes {\n+                            break;\n+                        }\n+                    }\n+                }\n+            } else {\n+                new_capacity = needed_bytes;\n+            }\n+            chunk = TypedArenaChunk::<u8>::new(new_capacity);\n+            self.ptr.set(chunk.start());\n+            self.end.set(chunk.end());\n+            self.align_for::<T>();\n+            chunks.push(chunk);\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn alloc<T>(&self, object: T) -> &mut T {\n+        unsafe {\n+            assert!(!intrinsics::needs_drop::<T>());\n+            assert!(mem::size_of::<T>() != 0);\n+\n+            self.align_for::<T>();\n+            let future_end = intrinsics::arith_offset(self.ptr.get(), mem::size_of::<T>() as isize);\n+            if (future_end as *mut u8) >= self.end.get() {\n+                self.grow::<T>(1)\n+            }\n+\n+            let ptr = self.ptr.get();\n+            // Set the pointer past ourselves\n+            self.ptr.set(intrinsics::arith_offset(\n+                    self.ptr.get(), mem::size_of::<T>() as isize\n+            ) as *mut u8);\n+            // Write into uninitialized memory.\n+            ptr::write(ptr as *mut T, object);\n+            &mut *(ptr as *mut T)\n+        }\n+    }\n+\n+    /// Allocates a slice of objects that are copied into the `DroplessArena`, returning a mutable\n+    /// reference to it. Will panic if passed a zero-sized type.\n+    ///\n+    /// Panics:\n+    ///  - Zero-sized types\n+    ///  - Zero-length slices\n+    #[inline]\n+    pub fn alloc_slice<T>(&self, slice: &[T]) -> &mut [T]\n+        where T: Copy {\n+        unsafe {\n+            assert!(!intrinsics::needs_drop::<T>());\n+        }\n+        assert!(mem::size_of::<T>() != 0);\n+        assert!(slice.len() != 0);\n+        self.align_for::<T>();\n+\n+        let future_end = unsafe {\n+            intrinsics::arith_offset(self.ptr.get(), (slice.len() * mem::size_of::<T>()) as isize)\n+        };\n+        if (future_end as *mut u8) >= self.end.get() {\n+            self.grow::<T>(slice.len());\n+        }\n+\n+        unsafe {\n+            let arena_slice = slice::from_raw_parts_mut(self.ptr.get() as *mut T, slice.len());\n+            self.ptr.set(intrinsics::arith_offset(\n+                    self.ptr.get(), (slice.len() * mem::size_of::<T>()) as isize\n+            ) as *mut u8);\n+            arena_slice.copy_from_slice(slice);\n+            arena_slice\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     extern crate test;"}]}