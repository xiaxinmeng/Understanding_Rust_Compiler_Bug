{"sha": "d51973a6a66756c2f2cb7ab0649483ef41ba3050", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1MTk3M2E2YTY2NzU2YzJmMmNiN2FiMDY0OTQ4M2VmNDFiYTMwNTA=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-18T04:14:40Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-18T17:50:50Z"}, "message": "syntax: Move some functions from parser to token", "tree": {"sha": "ac3834098002e7364b8aea4efe532bced641de0e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac3834098002e7364b8aea4efe532bced641de0e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d51973a6a66756c2f2cb7ab0649483ef41ba3050", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d51973a6a66756c2f2cb7ab0649483ef41ba3050", "html_url": "https://github.com/rust-lang/rust/commit/d51973a6a66756c2f2cb7ab0649483ef41ba3050", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d51973a6a66756c2f2cb7ab0649483ef41ba3050/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "476d5a099d9eddc1d090d57c85f53deb4fdb2866", "url": "https://api.github.com/repos/rust-lang/rust/commits/476d5a099d9eddc1d090d57c85f53deb4fdb2866", "html_url": "https://github.com/rust-lang/rust/commit/476d5a099d9eddc1d090d57c85f53deb4fdb2866"}], "stats": {"total": 105, "additions": 59, "deletions": 46}, "files": [{"sha": "a5eb2d6b8bec88afca59866f6f5221c2d3906f56", "filename": "src/librustsyntax/parse/parser.rs", "status": "modified", "additions": 15, "deletions": 46, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/d51973a6a66756c2f2cb7ab0649483ef41ba3050/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51973a6a66756c2f2cb7ab0649483ef41ba3050/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Fparser.rs?ref=d51973a6a66756c2f2cb7ab0649483ef41ba3050", "patch": "@@ -1,7 +1,7 @@\n import result::result;\n import either::{either, left, right};\n import std::map::{hashmap, str_hash};\n-import token::can_begin_expr;\n+import token::{can_begin_expr, is_ident, is_plain_ident};\n import codemap::{span,fss_none};\n import util::interner;\n import ast::{node_id, spanned};\n@@ -160,24 +160,7 @@ fn new_parser(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader,\n       mut restriction: UNRESTRICTED,\n       reader: rdr,\n       binop_precs: binop_prec_table(),\n-      bad_expr_words: bad_expr_word_table()}\n-}\n-\n-// These are the words that shouldn't be allowed as value identifiers,\n-// because, if used at the start of a line, they will cause the line to be\n-// interpreted as a specific kind of statement, which would be confusing.\n-fn bad_expr_word_table() -> hashmap<str, ()> {\n-    let words = str_hash();\n-    let keys = [\"alt\", \"assert\", \"be\", \"break\", \"check\", \"claim\",\n-                \"class\", \"const\", \"cont\", \"copy\", \"crust\", \"do\", \"else\",\n-                \"enum\", \"export\", \"fail\", \"fn\", \"for\", \"if\",  \"iface\",\n-                \"impl\", \"import\", \"let\", \"log\", \"loop\", \"mod\",\n-                \"mut\", \"native\", \"pure\", \"resource\", \"ret\", \"trait\",\n-                \"type\", \"unchecked\", \"unsafe\", \"while\", \"new\"];\n-    for keys.each {|word|\n-        words.insert(word, ());\n-    }\n-    words\n+      bad_expr_words: token::bad_expr_word_table()}\n }\n \n fn token_to_str(reader: reader, token: token::token) -> str {\n@@ -276,21 +259,19 @@ fn expect_word(p: parser, word: str) {\n }\n \n fn check_bad_word(p: parser) {\n-    alt p.token {\n-      token::IDENT(sid, false) {\n-        let w = p.get_str(sid);\n-        if p.bad_expr_words.contains_key(w) {\n-            p.fatal(\"found \" + w + \" in expression position\");\n-        }\n-      }\n-      _ { }\n+    if token::is_bad_expr_word(p.token, p.bad_expr_words,\n+                               *p.reader.interner) {\n+        let w = token_to_str(p.reader, p.token);\n+        p.fatal(\"found \" + w + \" in expression position\");\n     }\n }\n \n fn parse_ty_fn(p: parser) -> ast::fn_decl {\n     fn parse_fn_input_ty(p: parser) -> ast::arg {\n         let mode = parse_arg_mode(p);\n-        let name = if is_plain_ident(p) && p.look_ahead(1u) == token::COLON {\n+        let name = if is_plain_ident(p.token)\n+            && p.look_ahead(1u) == token::COLON {\n+\n             let name = parse_value_ident(p);\n             p.bump();\n             name\n@@ -783,15 +764,6 @@ fn parse_lit(p: parser) -> ast::lit {\n     ret {node: lit, span: ast_util::mk_sp(lo, p.last_span.hi)};\n }\n \n-fn is_ident(t: token::token) -> bool {\n-    alt t { token::IDENT(_, _) { ret true; } _ { } }\n-    ret false;\n-}\n-\n-fn is_plain_ident(p: parser) -> bool {\n-    ret alt p.token { token::IDENT(_, false) { true } _ { false } };\n-}\n-\n fn parse_path(p: parser) -> @ast::path {\n     let lo = p.span.lo;\n     let global = eat(p, token::MOD_SEP);\n@@ -858,10 +830,6 @@ fn mk_mac_expr(p: parser, lo: uint, hi: uint, m: ast::mac_) -> @ast::expr {\n           span: ast_util::mk_sp(lo, hi)};\n }\n \n-fn is_bar(t: token::token) -> bool {\n-    alt t { token::BINOP(token::OR) | token::OROR { true } _ { false } }\n-}\n-\n fn mk_lit_u32(p: parser, i: u32) -> @ast::expr {\n     let span = p.span;\n     let lv_lit = @{node: ast::lit_uint(i as u64, ast::ty_u32),\n@@ -925,7 +893,7 @@ fn parse_bottom_expr(p: parser) -> pexpr {\n     } else if p.token == token::LBRACE {\n         p.bump();\n         if is_word(p, \"mut\") ||\n-               is_plain_ident(p) && p.look_ahead(1u) == token::COLON {\n+               is_plain_ident(p.token) && p.look_ahead(1u) == token::COLON {\n             let mut fields = [parse_field(p, token::COLON)];\n             let mut base = none;\n             while p.token != token::RBRACE {\n@@ -940,7 +908,7 @@ fn parse_bottom_expr(p: parser) -> pexpr {\n             hi = p.span.hi;\n             expect(p, token::RBRACE);\n             ex = ast::expr_rec(fields, base);\n-        } else if is_bar(p.token) {\n+        } else if token::is_bar(p.token) {\n             ret pexpr(parse_fn_block_expr(p));\n         } else {\n             let blk = parse_block_tail(p, lo, ast::default_blk);\n@@ -1211,7 +1179,8 @@ fn parse_dot_or_call_expr_with(p: parser, e0: pexpr) -> pexpr {\n           }\n \n           // expr {|| ... }\n-          token::LBRACE if is_bar(p.look_ahead(1u)) && permits_call(p) {\n+          token::LBRACE if (token::is_bar(p.look_ahead(1u))\n+                            && permits_call(p)) {\n             p.bump();\n             let blk = parse_fn_block_expr(p);\n             alt e.node {\n@@ -1683,7 +1652,7 @@ fn parse_pat(p: parser) -> @ast::pat {\n                 hi = val.span.hi;\n                 pat = ast::pat_lit(val);\n             }\n-        } else if is_plain_ident(p) &&\n+        } else if is_plain_ident(p.token) &&\n             alt p.look_ahead(1u) {\n               token::LPAREN | token::LBRACKET | token::LT { false }\n               _ { true }\n@@ -1751,7 +1720,7 @@ fn parse_instance_var(p:parser, pr: ast::privacy) -> @ast::class_member {\n     if eat_word(p, \"mut\") || eat_word(p, \"mutable\") {\n         is_mutbl = ast::class_mutable;\n     }\n-    if !is_plain_ident(p) {\n+    if !is_plain_ident(p.token) {\n         p.fatal(\"expecting ident\");\n     }\n     let name = parse_ident(p);"}, {"sha": "1b4e871270abf973ae10adade8e41830a133e14c", "filename": "src/librustsyntax/parse/token.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d51973a6a66756c2f2cb7ab0649483ef41ba3050/src%2Flibrustsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51973a6a66756c2f2cb7ab0649483ef41ba3050/src%2Flibrustsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Ftoken.rs?ref=d51973a6a66756c2f2cb7ab0649483ef41ba3050", "patch": "@@ -1,6 +1,7 @@\n \n import util::interner;\n import util::interner::interner;\n+import std::map::{hashmap, str_hash};\n \n type str_num = uint;\n \n@@ -192,6 +193,49 @@ pure fn can_begin_expr(t: token) -> bool {\n     }\n }\n \n+fn is_ident(t: token::token) -> bool {\n+    alt t { token::IDENT(_, _) { ret true; } _ { } }\n+    ret false;\n+}\n+\n+fn is_plain_ident(t: token::token) -> bool {\n+    ret alt t { token::IDENT(_, false) { true } _ { false } };\n+}\n+\n+fn is_bar(t: token::token) -> bool {\n+    alt t { token::BINOP(token::OR) | token::OROR { true } _ { false } }\n+}\n+\n+fn is_bad_expr_word(t: token,\n+                    bad_expr_words: hashmap<str, ()>,\n+                    in: interner<str>) -> bool {\n+    alt t {\n+      token::IDENT(_, false) {\n+        bad_expr_words.contains_key(to_str(in, t))\n+      }\n+      _ { false }\n+    }\n+}\n+\n+#[doc = \"\n+These are the words that shouldn't be allowed as value identifiers,\n+because, if used at the start of a line, they will cause the line to be\n+interpreted as a specific kind of statement, which would be confusing.\n+\"]\n+fn bad_expr_word_table() -> hashmap<str, ()> {\n+    let words = str_hash();\n+    let keys = [\"alt\", \"assert\", \"be\", \"break\", \"check\", \"claim\",\n+                \"class\", \"const\", \"cont\", \"copy\", \"crust\", \"do\", \"else\",\n+                \"enum\", \"export\", \"fail\", \"fn\", \"for\", \"if\",  \"iface\",\n+                \"impl\", \"import\", \"let\", \"log\", \"loop\", \"mod\",\n+                \"mut\", \"native\", \"pure\", \"resource\", \"ret\", \"trait\",\n+                \"type\", \"unchecked\", \"unsafe\", \"while\", \"new\"];\n+    for keys.each {|word|\n+        words.insert(word, ());\n+    }\n+    words\n+}\n+\n // Local Variables:\n // fill-column: 78;\n // indent-tabs-mode: nil"}]}