{"sha": "cbf262a1bc72f10dc93a4993da0012d3b0abb56f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiZjI2MmExYmM3MmYxMGRjOTNhNDk5M2RhMDAxMmQzYjBhYmI1NmY=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-11-02T14:18:26Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-12-02T18:33:13Z"}, "message": "Change order of calls to get method candidate order correct", "tree": {"sha": "5a45fdae6d7c2eba8488ef18c1ab2cc12ab8e270", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a45fdae6d7c2eba8488ef18c1ab2cc12ab8e270"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cbf262a1bc72f10dc93a4993da0012d3b0abb56f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cbf262a1bc72f10dc93a4993da0012d3b0abb56f", "html_url": "https://github.com/rust-lang/rust/commit/cbf262a1bc72f10dc93a4993da0012d3b0abb56f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cbf262a1bc72f10dc93a4993da0012d3b0abb56f/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3376c08052a563a5d2db487c458972378edebf44", "url": "https://api.github.com/repos/rust-lang/rust/commits/3376c08052a563a5d2db487c458972378edebf44", "html_url": "https://github.com/rust-lang/rust/commit/3376c08052a563a5d2db487c458972378edebf44"}], "stats": {"total": 154, "additions": 115, "deletions": 39}, "files": [{"sha": "fbb932a3e5b87e82f876a224c07e653a48f40cdb", "filename": "crates/ra_hir_ty/src/method_resolution.rs", "status": "modified", "additions": 115, "deletions": 37, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/cbf262a1bc72f10dc93a4993da0012d3b0abb56f/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf262a1bc72f10dc93a4993da0012d3b0abb56f/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs?ref=cbf262a1bc72f10dc93a4993da0012d3b0abb56f", "patch": "@@ -176,7 +176,6 @@ pub fn iterate_method_candidates<T>(\n     mode: LookupMode,\n     mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n ) -> Option<T> {\n-    let krate = resolver.krate()?;\n     match mode {\n         LookupMode::MethodCall => {\n             // For method calls, rust first does any number of autoderef, and then one\n@@ -189,57 +188,125 @@ pub fn iterate_method_candidates<T>(\n             // rustc does an autoderef and then autoref again).\n             let environment = TraitEnvironment::lower(db, resolver);\n             let ty = InEnvironment { value: ty.clone(), environment };\n-            for derefed_ty in autoderef::autoderef(db, resolver.krate(), ty) {\n-                if let Some(result) =\n-                    iterate_inherent_methods(&derefed_ty, db, name, mode, krate, &mut callback)\n-                {\n-                    return Some(result);\n-                }\n-                if let Some(result) = iterate_trait_method_candidates(\n-                    &derefed_ty,\n+            let krate = resolver.krate()?;\n+\n+            // We have to be careful about the order of operations here.\n+            // Consider the case where we're resolving `x.clone()` where `x:\n+            // &Vec<_>`. This resolves to the clone method with self type\n+            // `Vec<_>`, *not* `&_`. I.e. we need to consider methods where the\n+            // receiver type exactly matches before cases where we have to do\n+            // autoref. But in the autoderef steps, the `&_` self type comes up\n+            // *before* the `Vec<_>` self type.\n+            //\n+            // On the other hand, we don't want to just pick any by-value method\n+            // before any by-autoref method; it's just that we need to consider\n+            // the methods by autoderef order of *receiver types*, not *self\n+            // types*.\n+\n+            let deref_chain: Vec<_> = autoderef::autoderef(db, Some(krate), ty.clone()).collect();\n+            for i in 0..deref_chain.len() {\n+                if let Some(result) = iterate_method_candidates_autoref(\n+                    &deref_chain[i..],\n                     db,\n                     resolver,\n                     name,\n-                    mode,\n                     &mut callback,\n                 ) {\n                     return Some(result);\n                 }\n             }\n+            None\n         }\n         LookupMode::Path => {\n             // No autoderef for path lookups\n-            if let Some(result) =\n-                iterate_inherent_methods(&ty, db, name, mode, krate.into(), &mut callback)\n-            {\n-                return Some(result);\n-            }\n-            if let Some(result) =\n-                iterate_trait_method_candidates(&ty, db, resolver, name, mode, &mut callback)\n-            {\n-                return Some(result);\n-            }\n+            iterate_method_candidates_inner(&ty, db, resolver, name, None, &mut callback)\n+        }\n+    }\n+}\n+\n+fn iterate_method_candidates_autoref<T>(\n+    deref_chain: &[Canonical<Ty>],\n+    db: &impl HirDatabase,\n+    resolver: &Resolver,\n+    name: Option<&Name>,\n+    mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n+) -> Option<T> {\n+    if let Some(result) = iterate_method_candidates_by_receiver(&deref_chain[0], &deref_chain[1..], db, resolver, name, &mut callback) {\n+        return Some(result);\n+    }\n+    let refed = Canonical {\n+        num_vars: deref_chain[0].num_vars,\n+        value: Ty::apply_one(TypeCtor::Ref(Mutability::Shared), deref_chain[0].value.clone()),\n+    };\n+    if let Some(result) = iterate_method_candidates_by_receiver(&refed, deref_chain, db, resolver, name, &mut callback) {\n+        return Some(result);\n+    }\n+    let ref_muted = Canonical {\n+        num_vars: deref_chain[0].num_vars,\n+        value: Ty::apply_one(TypeCtor::Ref(Mutability::Mut), deref_chain[0].value.clone()),\n+    };\n+    if let Some(result) = iterate_method_candidates_by_receiver(&ref_muted, deref_chain, db, resolver, name, &mut callback) {\n+        return Some(result);\n+    }\n+    None\n+}\n+\n+fn iterate_method_candidates_by_receiver<T>(\n+    receiver_ty: &Canonical<Ty>,\n+    deref_chain: &[Canonical<Ty>],\n+    db: &impl HirDatabase,\n+    resolver: &Resolver,\n+    name: Option<&Name>,\n+    mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n+) -> Option<T> {\n+    // TODO: do we need to do the whole loop for inherents before traits?\n+    // We're looking for methods with *receiver* type receiver_ty. These could\n+    // be found in any of the derefs of receiver_ty, so we have to go through\n+    // that.\n+    for self_ty in std::iter::once(receiver_ty).chain(deref_chain) {\n+        if let Some(result) = iterate_method_candidates_inner(self_ty, db, resolver, name, Some(receiver_ty), &mut callback) {\n+            return Some(result);\n         }\n     }\n     None\n }\n \n+fn iterate_method_candidates_inner<T>(\n+    self_ty: &Canonical<Ty>,\n+    db: &impl HirDatabase,\n+    resolver: &Resolver,\n+    name: Option<&Name>,\n+    receiver_ty: Option<&Canonical<Ty>>,\n+    mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n+) -> Option<T> {\n+    let krate = resolver.krate()?;\n+    if let Some(result) = iterate_inherent_methods(self_ty, db, name, receiver_ty, krate, &mut callback) {\n+        return Some(result);\n+    }\n+    if let Some(result) =\n+        iterate_trait_method_candidates(self_ty, db, resolver, name, receiver_ty, &mut callback)\n+    {\n+        return Some(result);\n+    }\n+    None\n+}\n+\n fn iterate_trait_method_candidates<T>(\n-    ty: &Canonical<Ty>,\n+    self_ty: &Canonical<Ty>,\n     db: &impl HirDatabase,\n     resolver: &Resolver,\n     name: Option<&Name>,\n-    mode: LookupMode,\n+    receiver_ty: Option<&Canonical<Ty>>,\n     mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n ) -> Option<T> {\n     let krate = resolver.krate()?;\n     // FIXME: maybe put the trait_env behind a query (need to figure out good input parameters for that)\n     let env = TraitEnvironment::lower(db, resolver);\n     // if ty is `impl Trait` or `dyn Trait`, the trait doesn't need to be in scope\n-    let inherent_trait = ty.value.inherent_trait().into_iter();\n+    let inherent_trait = self_ty.value.inherent_trait().into_iter();\n     // if we have `T: Trait` in the param env, the trait doesn't need to be in scope\n     let traits_from_env = env\n-        .trait_predicates_for_self_ty(&ty.value)\n+        .trait_predicates_for_self_ty(&self_ty.value)\n         .map(|tr| tr.trait_)\n         .flat_map(|t| all_super_traits(db, t));\n     let traits =\n@@ -252,17 +319,17 @@ fn iterate_trait_method_candidates<T>(\n         // iteration\n         let mut known_implemented = false;\n         for (_name, item) in data.items.iter() {\n-            if !is_valid_candidate(db, name, mode, (*item).into()) {\n+            if !is_valid_candidate(db, name, receiver_ty, (*item).into(), self_ty) {\n                 continue;\n             }\n             if !known_implemented {\n-                let goal = generic_implements_goal(db, env.clone(), t, ty.clone());\n+                let goal = generic_implements_goal(db, env.clone(), t, self_ty.clone());\n                 if db.trait_solve(krate.into(), goal).is_none() {\n                     continue 'traits;\n                 }\n             }\n             known_implemented = true;\n-            if let Some(result) = callback(&ty.value, (*item).into()) {\n+            if let Some(result) = callback(&self_ty.value, (*item).into()) {\n                 return Some(result);\n             }\n         }\n@@ -271,22 +338,22 @@ fn iterate_trait_method_candidates<T>(\n }\n \n fn iterate_inherent_methods<T>(\n-    ty: &Canonical<Ty>,\n+    self_ty: &Canonical<Ty>,\n     db: &impl HirDatabase,\n     name: Option<&Name>,\n-    mode: LookupMode,\n+    receiver_ty: Option<&Canonical<Ty>>,\n     krate: CrateId,\n     mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n ) -> Option<T> {\n-    for krate in ty.value.def_crates(db, krate)? {\n+    for krate in self_ty.value.def_crates(db, krate)? {\n         let impls = db.impls_in_crate(krate);\n \n-        for impl_block in impls.lookup_impl_blocks(&ty.value) {\n+        for impl_block in impls.lookup_impl_blocks(&self_ty.value) {\n             for &item in db.impl_data(impl_block).items.iter() {\n-                if !is_valid_candidate(db, name, mode, item) {\n+                if !is_valid_candidate(db, name, receiver_ty, item, self_ty) {\n                     continue;\n                 }\n-                if let Some(result) = callback(&ty.value, item.into()) {\n+                if let Some(result) = callback(&self_ty.value, item) {\n                     return Some(result);\n                 }\n             }\n@@ -298,18 +365,29 @@ fn iterate_inherent_methods<T>(\n fn is_valid_candidate(\n     db: &impl HirDatabase,\n     name: Option<&Name>,\n-    mode: LookupMode,\n+    receiver_ty: Option<&Canonical<Ty>>,\n     item: AssocItemId,\n+    self_ty: &Canonical<Ty>,\n ) -> bool {\n     match item {\n         AssocItemId::FunctionId(m) => {\n             let data = db.function_data(m);\n-            name.map_or(true, |name| &data.name == name)\n-                && (data.has_self_param || mode == LookupMode::Path)\n+            if let Some(name) = name {\n+                if &data.name != name {\n+                    return false;\n+                }\n+            }\n+            if let Some(receiver_ty) = receiver_ty {\n+                if !data.has_self_param {\n+                    return false;\n+                }\n+                // TODO compare receiver ty\n+            }\n+            true\n         }\n         AssocItemId::ConstId(c) => {\n             let data = db.const_data(c);\n-            name.map_or(true, |name| data.name.as_ref() == Some(name)) && (mode == LookupMode::Path)\n+            name.map_or(true, |name| data.name.as_ref() == Some(name)) && receiver_ty.is_none()\n         }\n         _ => false,\n     }"}, {"sha": "be8768c622ba902a9a542e21a35f76024cc2d549", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbf262a1bc72f10dc93a4993da0012d3b0abb56f/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf262a1bc72f10dc93a4993da0012d3b0abb56f/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=cbf262a1bc72f10dc93a4993da0012d3b0abb56f", "patch": "@@ -3433,7 +3433,6 @@ pub fn baz() -> usize { 31usize }\n     assert_eq!(\"(i32, usize)\", type_at_pos(&db, pos));\n }\n \n-#[ignore]\n #[test]\n fn method_resolution_trait_before_autoref() {\n     let t = type_at(\n@@ -3449,7 +3448,6 @@ fn test() { S.foo()<|>; }\n     assert_eq!(t, \"u128\");\n }\n \n-#[ignore]\n #[test]\n fn method_resolution_by_value_before_autoref() {\n     let t = type_at("}]}