{"sha": "298ab6f45957591d13104e8c667e83928d2276a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5OGFiNmY0NTk1NzU5MWQxMzEwNGU4YzY2N2U4MzkyOGQyMjc2YTQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-22T02:04:06Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-22T02:04:06Z"}, "message": "Revert \"core: De-export at_vec and extfmt\"\n\nThis reverts commit 6267d8a94a7a215be446f5a431a1aae029a4e357.", "tree": {"sha": "b420d2dbac2959ceadab5027eb1a65bed48b6f99", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b420d2dbac2959ceadab5027eb1a65bed48b6f99"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/298ab6f45957591d13104e8c667e83928d2276a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/298ab6f45957591d13104e8c667e83928d2276a4", "html_url": "https://github.com/rust-lang/rust/commit/298ab6f45957591d13104e8c667e83928d2276a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/298ab6f45957591d13104e8c667e83928d2276a4/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6267d8a94a7a215be446f5a431a1aae029a4e357", "url": "https://api.github.com/repos/rust-lang/rust/commits/6267d8a94a7a215be446f5a431a1aae029a4e357", "html_url": "https://github.com/rust-lang/rust/commit/6267d8a94a7a215be446f5a431a1aae029a4e357"}], "stats": {"total": 153, "additions": 80, "deletions": 73}, "files": [{"sha": "7864983bde26d68fc851f4ec689620dcf3332b80", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/298ab6f45957591d13104e8c667e83928d2276a4/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298ab6f45957591d13104e8c667e83928d2276a4/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=298ab6f45957591d13104e8c667e83928d2276a4", "patch": "@@ -2,24 +2,34 @@\n \n use ptr::addr_of;\n \n+export init_op;\n+export capacity;\n+export build_sized, build, build_sized_opt;\n+export map;\n+export from_fn, from_elem;\n+export raw;\n+export traits;\n+\n /// Code for dealing with @-vectors. This is pretty incomplete, and\n /// contains a bunch of duplication from the code for ~-vectors.\n \n #[abi = \"cdecl\"]\n extern mod rustrt {\n-    pub fn vec_reserve_shared_actual(++t: *sys::TypeDesc,\n+    #[legacy_exports];\n+    fn vec_reserve_shared_actual(++t: *sys::TypeDesc,\n                                  ++v: **vec::raw::VecRepr,\n                                  ++n: libc::size_t);\n }\n \n #[abi = \"rust-intrinsic\"]\n extern mod rusti {\n-    pub fn move_val_init<T>(&dst: T, -src: T);\n+    #[legacy_exports];\n+    fn move_val_init<T>(&dst: T, -src: T);\n }\n \n /// Returns the number of elements the vector can hold without reallocating\n #[inline(always)]\n-pub pure fn capacity<T>(&&v: @[const T]) -> uint {\n+pure fn capacity<T>(&&v: @[const T]) -> uint {\n     unsafe {\n         let repr: **raw::VecRepr =\n             ::cast::reinterpret_cast(&addr_of(v));\n@@ -40,8 +50,7 @@ pub pure fn capacity<T>(&&v: @[const T]) -> uint {\n  *             onto the vector being constructed.\n  */\n #[inline(always)]\n-pub pure fn build_sized<A>(size: uint,\n-                           builder: fn(push: pure fn(+A))) -> @[A] {\n+pure fn build_sized<A>(size: uint, builder: fn(push: pure fn(+A))) -> @[A] {\n     let mut vec = @[];\n     unsafe { raw::reserve(vec, size); }\n     builder(|+x| unsafe { raw::push(vec, move x) });\n@@ -59,7 +68,7 @@ pub pure fn build_sized<A>(size: uint,\n  *             onto the vector being constructed.\n  */\n #[inline(always)]\n-pub pure fn build<A>(builder: fn(push: pure fn(+A))) -> @[A] {\n+pure fn build<A>(builder: fn(push: pure fn(+A))) -> @[A] {\n     build_sized(4, builder)\n }\n \n@@ -76,7 +85,7 @@ pub pure fn build<A>(builder: fn(push: pure fn(+A))) -> @[A] {\n  *             onto the vector being constructed.\n  */\n #[inline(always)]\n-pub pure fn build_sized_opt<A>(size: Option<uint>,\n+pure fn build_sized_opt<A>(size: Option<uint>,\n                            builder: fn(push: pure fn(+A))) -> @[A] {\n     build_sized(size.get_default(4), builder)\n }\n@@ -92,7 +101,7 @@ pure fn append<T: Copy>(lhs: @[T], rhs: &[const T]) -> @[T] {\n \n \n /// Apply a function to each element of a vector and return the results\n-pub pure fn map<T, U>(v: &[T], f: fn(T) -> U) -> @[U] {\n+pure fn map<T, U>(v: &[T], f: fn(T) -> U) -> @[U] {\n     do build_sized(v.len()) |push| {\n         for vec::each(v) |elem| {\n             push(f(*elem));\n@@ -106,7 +115,7 @@ pub pure fn map<T, U>(v: &[T], f: fn(T) -> U) -> @[U] {\n  * Creates an immutable vector of size `n_elts` and initializes the elements\n  * to the value returned by the function `op`.\n  */\n-pub pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> @[T] {\n+pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> @[T] {\n     do build_sized(n_elts) |push| {\n         let mut i: uint = 0u;\n         while i < n_elts { push(op(i)); i += 1u; }\n@@ -119,7 +128,7 @@ pub pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> @[T] {\n  * Creates an immutable vector of size `n_elts` and initializes the elements\n  * to the value `t`.\n  */\n-pub pure fn from_elem<T: Copy>(n_elts: uint, t: T) -> @[T] {\n+pure fn from_elem<T: Copy>(n_elts: uint, t: T) -> @[T] {\n     do build_sized(n_elts) |push| {\n         let mut i: uint = 0u;\n         while i < n_elts { push(t); i += 1u; }\n@@ -128,6 +137,7 @@ pub pure fn from_elem<T: Copy>(n_elts: uint, t: T) -> @[T] {\n \n #[cfg(notest)]\n mod traits {\n+    #[legacy_exports];\n     #[cfg(stage0)]\n     impl<T: Copy> @[T]: Add<&[const T],@[T]> {\n         #[inline(always)]\n@@ -149,9 +159,10 @@ mod traits {\n mod traits {\n     #[legacy_exports];}\n \n-pub mod raw {\n-    pub type VecRepr = vec::raw::VecRepr;\n-    pub type SliceRepr = vec::raw::SliceRepr;\n+mod raw {\n+    #[legacy_exports];\n+    type VecRepr = vec::raw::VecRepr;\n+    type SliceRepr = vec::raw::SliceRepr;\n \n     /**\n      * Sets the length of a vector\n@@ -161,13 +172,13 @@ pub mod raw {\n      * the vector is actually the specified size.\n      */\n     #[inline(always)]\n-    pub unsafe fn set_len<T>(&&v: @[const T], new_len: uint) {\n+    unsafe fn set_len<T>(&&v: @[const T], new_len: uint) {\n         let repr: **VecRepr = ::cast::reinterpret_cast(&addr_of(v));\n         (**repr).unboxed.fill = new_len * sys::size_of::<T>();\n     }\n \n     #[inline(always)]\n-    pub unsafe fn push<T>(&v: @[const T], +initval: T) {\n+    unsafe fn push<T>(&v: @[const T], +initval: T) {\n         let repr: **VecRepr = ::cast::reinterpret_cast(&addr_of(v));\n         let fill = (**repr).unboxed.fill;\n         if (**repr).unboxed.alloc > fill {\n@@ -204,7 +215,7 @@ pub mod raw {\n      * * v - A vector\n      * * n - The number of elements to reserve space for\n      */\n-    pub unsafe fn reserve<T>(&v: @[const T], n: uint) {\n+    unsafe fn reserve<T>(&v: @[const T], n: uint) {\n         // Only make the (slow) call into the runtime if we have to\n         if capacity(v) < n {\n             let ptr = addr_of(v) as **VecRepr;\n@@ -228,7 +239,7 @@ pub mod raw {\n      * * v - A vector\n      * * n - The number of elements to reserve space for\n      */\n-    pub unsafe fn reserve_at_least<T>(&v: @[const T], n: uint) {\n+    unsafe fn reserve_at_least<T>(&v: @[const T], n: uint) {\n         reserve(v, uint::next_power_of_two(n));\n     }\n "}, {"sha": "624cb97dbca34214b150bd974b4335b0003c96a8", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/298ab6f45957591d13104e8c667e83928d2276a4/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298ab6f45957591d13104e8c667e83928d2276a4/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=298ab6f45957591d13104e8c667e83928d2276a4", "patch": "@@ -41,36 +41,37 @@ use option::{Some, None};\n  */\n \n // Functions used by the fmt extension at compile time\n-pub mod ct {\n-    pub enum Signedness { pub Signed, pub Unsigned, }\n-    pub enum Caseness { pub CaseUpper, pub CaseLower, }\n-    pub enum Ty {\n-        pub TyBool,\n-        pub TyStr,\n-        pub TyChar,\n-        pub TyInt(Signedness),\n-        pub TyBits,\n-        pub TyHex(Caseness),\n-        pub TyOctal,\n-        pub TyFloat,\n-        pub TyPoly,\n-    }\n-    pub enum Flag {\n-        pub FlagLeftJustify,\n-        pub FlagLeftZeroPad,\n-        pub FlagSpaceForSign,\n-        pub FlagSignAlways,\n-        pub FlagAlternate,\n-    }\n-    pub enum Count {\n-        pub CountIs(int),\n-        pub CountIsParam(int),\n-        pub CountIsNextParam,\n-        pub CountImplied,\n+mod ct {\n+    #[legacy_exports];\n+    enum Signedness { Signed, Unsigned, }\n+    enum Caseness { CaseUpper, CaseLower, }\n+    enum Ty {\n+        TyBool,\n+        TyStr,\n+        TyChar,\n+        TyInt(Signedness),\n+        TyBits,\n+        TyHex(Caseness),\n+        TyOctal,\n+        TyFloat,\n+        TyPoly,\n+    }\n+    enum Flag {\n+        FlagLeftJustify,\n+        FlagLeftZeroPad,\n+        FlagSpaceForSign,\n+        FlagSignAlways,\n+        FlagAlternate,\n+    }\n+    enum Count {\n+        CountIs(int),\n+        CountIsParam(int),\n+        CountIsNextParam,\n+        CountImplied,\n     }\n \n     // A formatted conversion from an expression to a string\n-    pub type Conv =\n+    type Conv =\n         {param: Option<int>,\n          flags: ~[Flag],\n          width: Count,\n@@ -79,10 +80,10 @@ pub mod ct {\n \n \n     // A fragment of the output sequence\n-    pub enum Piece { PieceString(~str), PieceConv(Conv), }\n-    pub type ErrorFn = fn@(~str) -> ! ;\n+    enum Piece { PieceString(~str), PieceConv(Conv), }\n+    type ErrorFn = fn@(~str) -> ! ;\n \n-    pub fn parse_fmt_string(s: ~str, error: ErrorFn) -> ~[Piece] {\n+    fn parse_fmt_string(s: ~str, error: ErrorFn) -> ~[Piece] {\n         let mut pieces: ~[Piece] = ~[];\n         let lim = str::len(s);\n         let mut buf = ~\"\";\n@@ -272,26 +273,21 @@ pub mod ct {\n // decisions made a runtime. If it proves worthwhile then some of these\n // conditions can be evaluated at compile-time. For now though it's cleaner to\n // implement it 0this way, I think.\n-pub mod rt {\n-    pub const flag_none: u32 = 0u32;\n-    pub const flag_left_justify : u32 = 0b00000000000000000000000000000001u32;\n-    pub const flag_left_zero_pad: u32 = 0b00000000000000000000000000000010u32;\n-    pub const flag_space_for_sign:u32 = 0b00000000000000000000000000000100u32;\n-    pub const flag_sign_always  : u32 = 0b00000000000000000000000000001000u32;\n-    pub const flag_alternate    : u32 = 0b00000000000000000000000000010000u32;\n-\n-    pub enum Count { pub CountIs(int), pub CountImplied, }\n-    pub enum Ty {\n-        pub TyDefault,\n-        pub TyBits,\n-        pub TyHexUpper,\n-        pub TyHexLower,\n-        pub TyOctal\n-    }\n-\n-    pub type Conv = {flags: u32, width: Count, precision: Count, ty: Ty};\n-\n-    pub pure fn conv_int(cv: Conv, i: int) -> ~str {\n+mod rt {\n+    #[legacy_exports];\n+    const flag_none : u32 = 0u32;\n+    const flag_left_justify   : u32 = 0b00000000000000000000000000000001u32;\n+    const flag_left_zero_pad  : u32 = 0b00000000000000000000000000000010u32;\n+    const flag_space_for_sign : u32 = 0b00000000000000000000000000000100u32;\n+    const flag_sign_always    : u32 = 0b00000000000000000000000000001000u32;\n+    const flag_alternate      : u32 = 0b00000000000000000000000000010000u32;\n+\n+    enum Count { CountIs(int), CountImplied, }\n+    enum Ty { TyDefault, TyBits, TyHexUpper, TyHexLower, TyOctal, }\n+\n+    type Conv = {flags: u32, width: Count, precision: Count, ty: Ty};\n+\n+    pure fn conv_int(cv: Conv, i: int) -> ~str {\n         let radix = 10u;\n         let prec = get_int_precision(cv);\n         let mut s : ~str = int_to_str_prec(i, radix, prec);\n@@ -304,7 +300,7 @@ pub mod rt {\n         }\n         return unsafe { pad(cv, s, PadSigned) };\n     }\n-    pub pure fn conv_uint(cv: Conv, u: uint) -> ~str {\n+    pure fn conv_uint(cv: Conv, u: uint) -> ~str {\n         let prec = get_int_precision(cv);\n         let mut rs =\n             match cv.ty {\n@@ -316,17 +312,17 @@ pub mod rt {\n             };\n         return unsafe { pad(cv, rs, PadUnsigned) };\n     }\n-    pub pure fn conv_bool(cv: Conv, b: bool) -> ~str {\n+    pure fn conv_bool(cv: Conv, b: bool) -> ~str {\n         let s = if b { ~\"true\" } else { ~\"false\" };\n         // run the boolean conversion through the string conversion logic,\n         // giving it the same rules for precision, etc.\n         return conv_str(cv, s);\n     }\n-    pub pure fn conv_char(cv: Conv, c: char) -> ~str {\n+    pure fn conv_char(cv: Conv, c: char) -> ~str {\n         let mut s = str::from_char(c);\n         return unsafe { pad(cv, s, PadNozero) };\n     }\n-    pub pure fn conv_str(cv: Conv, s: &str) -> ~str {\n+    pure fn conv_str(cv: Conv, s: &str) -> ~str {\n         // For strings, precision is the maximum characters\n         // displayed\n         let mut unpadded = match cv.precision {\n@@ -339,7 +335,7 @@ pub mod rt {\n         };\n         return unsafe { pad(cv, unpadded, PadNozero) };\n     }\n-    pub pure fn conv_float(cv: Conv, f: float) -> ~str {\n+    pure fn conv_float(cv: Conv, f: float) -> ~str {\n         let (to_str, digits) = match cv.precision {\n               CountIs(c) => (float::to_str_exact, c as uint),\n               CountImplied => (float::to_str, 6u)\n@@ -354,7 +350,7 @@ pub mod rt {\n         }\n         return unsafe { pad(cv, s, PadFloat) };\n     }\n-    pub pure fn conv_poly<T>(cv: Conv, v: T) -> ~str {\n+    pure fn conv_poly<T>(cv: Conv, v: T) -> ~str {\n         let s = sys::log_str(&v);\n         return conv_str(cv, s);\n     }"}]}