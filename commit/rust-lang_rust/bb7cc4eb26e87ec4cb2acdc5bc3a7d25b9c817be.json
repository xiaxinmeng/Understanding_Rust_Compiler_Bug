{"sha": "bb7cc4eb26e87ec4cb2acdc5bc3a7d25b9c817be", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiN2NjNGViMjZlODdlYzRjYjJhY2RjNWJjM2E3ZDI1YjljODE3YmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-24T19:39:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-24T19:39:52Z"}, "message": "Auto merge of #21488 - aturon:os-str, r=alexcrichton\n\nPer [RFC 517](https://github.com/rust-lang/rfcs/pull/575/), this commit introduces platform-native strings. The API is essentially as described in the RFC.\r\n\r\nThe WTF-8 implementation is adapted from @SimonSapin's [implementation](https://github.com/SimonSapin/rust-wtf8). To make this work, some encodign and decoding functionality in `libcore` is now exported in a \"raw\" fashion reusable for WTF-8. These exports are *not* reexported in `std`, nor are they stable.", "tree": {"sha": "04338cf8bf55a8510cd6ab0771698e320beb13e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/04338cf8bf55a8510cd6ab0771698e320beb13e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb7cc4eb26e87ec4cb2acdc5bc3a7d25b9c817be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb7cc4eb26e87ec4cb2acdc5bc3a7d25b9c817be", "html_url": "https://github.com/rust-lang/rust/commit/bb7cc4eb26e87ec4cb2acdc5bc3a7d25b9c817be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb7cc4eb26e87ec4cb2acdc5bc3a7d25b9c817be/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76fbb3583174ca8856b4e149929839888f503e6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/76fbb3583174ca8856b4e149929839888f503e6b", "html_url": "https://github.com/rust-lang/rust/commit/76fbb3583174ca8856b4e149929839888f503e6b"}, {"sha": "c5369ebc7f4791c4e291951751b8964052c7a523", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5369ebc7f4791c4e291951751b8964052c7a523", "html_url": "https://github.com/rust-lang/rust/commit/c5369ebc7f4791c4e291951751b8964052c7a523"}], "stats": {"total": 1942, "additions": 1850, "deletions": 92}, "files": [{"sha": "0e6b634bd11ef74430d1b433425ed8efd65751f4", "filename": "src/libcore/char.rs", "status": "modified", "additions": 58, "deletions": 38, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/bb7cc4eb26e87ec4cb2acdc5bc3a7d25b9c817be/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb7cc4eb26e87ec4cb2acdc5bc3a7d25b9c817be/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=bb7cc4eb26e87ec4cb2acdc5bc3a7d25b9c817be", "patch": "@@ -258,49 +258,69 @@ impl CharExt for char {\n     #[inline]\n     #[unstable = \"pending decision about Iterator/Writer/Reader\"]\n     fn encode_utf8(self, dst: &mut [u8]) -> Option<uint> {\n-        // Marked #[inline] to allow llvm optimizing it away\n-        let code = self as u32;\n-        if code < MAX_ONE_B && dst.len() >= 1 {\n-            dst[0] = code as u8;\n-            Some(1)\n-        } else if code < MAX_TWO_B && dst.len() >= 2 {\n-            dst[0] = (code >> 6u & 0x1F_u32) as u8 | TAG_TWO_B;\n-            dst[1] = (code & 0x3F_u32) as u8 | TAG_CONT;\n-            Some(2)\n-        } else if code < MAX_THREE_B && dst.len() >= 3  {\n-            dst[0] = (code >> 12u & 0x0F_u32) as u8 | TAG_THREE_B;\n-            dst[1] = (code >>  6u & 0x3F_u32) as u8 | TAG_CONT;\n-            dst[2] = (code & 0x3F_u32) as u8 | TAG_CONT;\n-            Some(3)\n-        } else if dst.len() >= 4 {\n-            dst[0] = (code >> 18u & 0x07_u32) as u8 | TAG_FOUR_B;\n-            dst[1] = (code >> 12u & 0x3F_u32) as u8 | TAG_CONT;\n-            dst[2] = (code >>  6u & 0x3F_u32) as u8 | TAG_CONT;\n-            dst[3] = (code & 0x3F_u32) as u8 | TAG_CONT;\n-            Some(4)\n-        } else {\n-            None\n-        }\n+        encode_utf8_raw(self as u32, dst)\n     }\n \n     #[inline]\n     #[unstable = \"pending decision about Iterator/Writer/Reader\"]\n     fn encode_utf16(self, dst: &mut [u16]) -> Option<uint> {\n-        // Marked #[inline] to allow llvm optimizing it away\n-        let mut ch = self as u32;\n-        if (ch & 0xFFFF_u32) == ch  && dst.len() >= 1 {\n-            // The BMP falls through (assuming non-surrogate, as it should)\n-            dst[0] = ch as u16;\n-            Some(1)\n-        } else if dst.len() >= 2 {\n-            // Supplementary planes break into surrogates.\n-            ch -= 0x1_0000_u32;\n-            dst[0] = 0xD800_u16 | ((ch >> 10) as u16);\n-            dst[1] = 0xDC00_u16 | ((ch as u16) & 0x3FF_u16);\n-            Some(2)\n-        } else {\n-            None\n-        }\n+        encode_utf16_raw(self as u32, dst)\n+    }\n+}\n+\n+/// Encodes a raw u32 value as UTF-8 into the provided byte buffer,\n+/// and then returns the number of bytes written.\n+///\n+/// If the buffer is not large enough, nothing will be written into it\n+/// and a `None` will be returned.\n+#[inline]\n+#[unstable]\n+pub fn encode_utf8_raw(code: u32, dst: &mut [u8]) -> Option<uint> {\n+    // Marked #[inline] to allow llvm optimizing it away\n+    if code < MAX_ONE_B && dst.len() >= 1 {\n+        dst[0] = code as u8;\n+        Some(1)\n+    } else if code < MAX_TWO_B && dst.len() >= 2 {\n+        dst[0] = (code >> 6u & 0x1F_u32) as u8 | TAG_TWO_B;\n+        dst[1] = (code & 0x3F_u32) as u8 | TAG_CONT;\n+        Some(2)\n+    } else if code < MAX_THREE_B && dst.len() >= 3  {\n+        dst[0] = (code >> 12u & 0x0F_u32) as u8 | TAG_THREE_B;\n+        dst[1] = (code >>  6u & 0x3F_u32) as u8 | TAG_CONT;\n+        dst[2] = (code & 0x3F_u32) as u8 | TAG_CONT;\n+        Some(3)\n+    } else if dst.len() >= 4 {\n+        dst[0] = (code >> 18u & 0x07_u32) as u8 | TAG_FOUR_B;\n+        dst[1] = (code >> 12u & 0x3F_u32) as u8 | TAG_CONT;\n+        dst[2] = (code >>  6u & 0x3F_u32) as u8 | TAG_CONT;\n+        dst[3] = (code & 0x3F_u32) as u8 | TAG_CONT;\n+        Some(4)\n+    } else {\n+        None\n+    }\n+}\n+\n+/// Encodes a raw u32 value as UTF-16 into the provided `u16` buffer,\n+/// and then returns the number of `u16`s written.\n+///\n+/// If the buffer is not large enough, nothing will be written into it\n+/// and a `None` will be returned.\n+#[inline]\n+#[unstable]\n+pub fn encode_utf16_raw(mut ch: u32, dst: &mut [u16]) -> Option<uint> {\n+    // Marked #[inline] to allow llvm optimizing it away\n+    if (ch & 0xFFFF_u32) == ch  && dst.len() >= 1 {\n+        // The BMP falls through (assuming non-surrogate, as it should)\n+        dst[0] = ch as u16;\n+        Some(1)\n+    } else if dst.len() >= 2 {\n+        // Supplementary planes break into surrogates.\n+        ch -= 0x1_0000_u32;\n+        dst[0] = 0xD800_u16 | ((ch >> 10) as u16);\n+        dst[1] = 0xDC00_u16 | ((ch as u16) & 0x3FF_u16);\n+        Some(2)\n+    } else {\n+        None\n     }\n }\n "}, {"sha": "1e01da4e41d2730eaef4027cfd7e4e12a42ea4ed", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 67, "deletions": 49, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/bb7cc4eb26e87ec4cb2acdc5bc3a7d25b9c817be/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb7cc4eb26e87ec4cb2acdc5bc3a7d25b9c817be/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=bb7cc4eb26e87ec4cb2acdc5bc3a7d25b9c817be", "patch": "@@ -305,43 +305,52 @@ fn unwrap_or_0(opt: Option<&u8>) -> u8 {\n     }\n }\n \n+/// Reads the next code point out of a byte iterator (assuming a\n+/// UTF-8-like encoding).\n+#[unstable]\n+pub fn next_code_point(bytes: &mut slice::Iter<u8>) -> Option<u32> {\n+    // Decode UTF-8\n+    let x = match bytes.next() {\n+        None => return None,\n+        Some(&next_byte) if next_byte < 128 => return Some(next_byte as u32),\n+        Some(&next_byte) => next_byte,\n+    };\n+\n+    // Multibyte case follows\n+    // Decode from a byte combination out of: [[[x y] z] w]\n+    // NOTE: Performance is sensitive to the exact formulation here\n+    let init = utf8_first_byte!(x, 2);\n+    let y = unwrap_or_0(bytes.next());\n+    let mut ch = utf8_acc_cont_byte!(init, y);\n+    if x >= 0xE0 {\n+        // [[x y z] w] case\n+        // 5th bit in 0xE0 .. 0xEF is always clear, so `init` is still valid\n+        let z = unwrap_or_0(bytes.next());\n+        let y_z = utf8_acc_cont_byte!((y & CONT_MASK) as u32, z);\n+        ch = init << 12 | y_z;\n+        if x >= 0xF0 {\n+            // [x y z w] case\n+            // use only the lower 3 bits of `init`\n+            let w = unwrap_or_0(bytes.next());\n+            ch = (init & 7) << 18 | utf8_acc_cont_byte!(y_z, w);\n+        }\n+    }\n+\n+    Some(ch)\n+}\n+\n #[stable]\n impl<'a> Iterator for Chars<'a> {\n     type Item = char;\n \n     #[inline]\n     fn next(&mut self) -> Option<char> {\n-        // Decode UTF-8, using the valid UTF-8 invariant\n-        let x = match self.iter.next() {\n-            None => return None,\n-            Some(&next_byte) if next_byte < 128 => return Some(next_byte as char),\n-            Some(&next_byte) => next_byte,\n-        };\n-\n-        // Multibyte case follows\n-        // Decode from a byte combination out of: [[[x y] z] w]\n-        // NOTE: Performance is sensitive to the exact formulation here\n-        let init = utf8_first_byte!(x, 2);\n-        let y = unwrap_or_0(self.iter.next());\n-        let mut ch = utf8_acc_cont_byte!(init, y);\n-        if x >= 0xE0 {\n-            // [[x y z] w] case\n-            // 5th bit in 0xE0 .. 0xEF is always clear, so `init` is still valid\n-            let z = unwrap_or_0(self.iter.next());\n-            let y_z = utf8_acc_cont_byte!((y & CONT_MASK) as u32, z);\n-            ch = init << 12 | y_z;\n-            if x >= 0xF0 {\n-                // [x y z w] case\n-                // use only the lower 3 bits of `init`\n-                let w = unwrap_or_0(self.iter.next());\n-                ch = (init & 7) << 18 | utf8_acc_cont_byte!(y_z, w);\n+        next_code_point(&mut self.iter).map(|ch| {\n+            // str invariant says `ch` is a valid Unicode Scalar Value\n+            unsafe {\n+                mem::transmute(ch)\n             }\n-        }\n-\n-        // str invariant says `ch` is a valid Unicode Scalar Value\n-        unsafe {\n-            Some(mem::transmute(ch))\n-        }\n+        })\n     }\n \n     #[inline]\n@@ -1517,25 +1526,8 @@ impl StrExt for str {\n \n     #[inline]\n     fn char_range_at(&self, i: uint) -> CharRange {\n-        if self.as_bytes()[i] < 128u8 {\n-            return CharRange {ch: self.as_bytes()[i] as char, next: i + 1 };\n-        }\n-\n-        // Multibyte case is a fn to allow char_range_at to inline cleanly\n-        fn multibyte_char_range_at(s: &str, i: uint) -> CharRange {\n-            let mut val = s.as_bytes()[i] as u32;\n-            let w = UTF8_CHAR_WIDTH[val as uint] as uint;\n-            assert!((w != 0));\n-\n-            val = utf8_first_byte!(val, w);\n-            val = utf8_acc_cont_byte!(val, s.as_bytes()[i + 1]);\n-            if w > 2 { val = utf8_acc_cont_byte!(val, s.as_bytes()[i + 2]); }\n-            if w > 3 { val = utf8_acc_cont_byte!(val, s.as_bytes()[i + 3]); }\n-\n-            return CharRange {ch: unsafe { mem::transmute(val) }, next: i + w};\n-        }\n-\n-        return multibyte_char_range_at(self, i);\n+        let (c, n) = char_range_at_raw(self.as_bytes(), i);\n+        CharRange { ch: unsafe { mem::transmute(c) }, next: n }\n     }\n \n     #[inline]\n@@ -1653,6 +1645,32 @@ impl StrExt for str {\n     fn parse<T: FromStr>(&self) -> Option<T> { FromStr::from_str(self) }\n }\n \n+/// Pluck a code point out of a UTF-8-like byte slice and return the\n+/// index of the next code point.\n+#[inline]\n+#[unstable]\n+pub fn char_range_at_raw(bytes: &[u8], i: uint) -> (u32, usize) {\n+    if bytes[i] < 128u8 {\n+        return (bytes[i] as u32, i + 1);\n+    }\n+\n+    // Multibyte case is a fn to allow char_range_at to inline cleanly\n+    fn multibyte_char_range_at(bytes: &[u8], i: uint) -> (u32, usize) {\n+        let mut val = bytes[i] as u32;\n+        let w = UTF8_CHAR_WIDTH[val as uint] as uint;\n+        assert!((w != 0));\n+\n+        val = utf8_first_byte!(val, w);\n+        val = utf8_acc_cont_byte!(val, bytes[i + 1]);\n+        if w > 2 { val = utf8_acc_cont_byte!(val, bytes[i + 2]); }\n+        if w > 3 { val = utf8_acc_cont_byte!(val, bytes[i + 3]); }\n+\n+        return (val, i + w);\n+    }\n+\n+    multibyte_char_range_at(bytes, i)\n+}\n+\n #[stable]\n impl<'a> Default for &'a str {\n     #[stable]"}, {"sha": "95ad6178babe291c4ca6470ba327202a8594f999", "filename": "src/libstd/ffi/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bb7cc4eb26e87ec4cb2acdc5bc3a7d25b9c817be/src%2Flibstd%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb7cc4eb26e87ec4cb2acdc5bc3a7d25b9c817be/src%2Flibstd%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fmod.rs?ref=bb7cc4eb26e87ec4cb2acdc5bc3a7d25b9c817be", "patch": "@@ -17,4 +17,9 @@ pub use self::c_str::CString;\n pub use self::c_str::c_str_to_bytes;\n pub use self::c_str::c_str_to_bytes_with_nul;\n \n+pub use self::os_str::OsString;\n+pub use self::os_str::OsStr;\n+pub use self::os_str::AsOsStr;\n+\n mod c_str;\n+mod os_str;"}, {"sha": "9c5cf62f8534c076d00a50bde2272c5248e69eaa", "filename": "src/libstd/ffi/os_str.rs", "status": "added", "additions": 259, "deletions": 0, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/bb7cc4eb26e87ec4cb2acdc5bc3a7d25b9c817be/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb7cc4eb26e87ec4cb2acdc5bc3a7d25b9c817be/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=bb7cc4eb26e87ec4cb2acdc5bc3a7d25b9c817be", "patch": "@@ -0,0 +1,259 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A type that can represent all platform-native strings, but is cheaply\n+//! interconvertable with Rust strings.\n+//!\n+//! The need for this type arises from the fact that:\n+//!\n+//! * On Unix systems, strings are often arbitrary sequences of non-zero\n+//!   bytes, in many cases interpreted as UTF-8.\n+//!\n+//! * On Windows, strings are often arbitrary sequences of non-zero 16-bit\n+//!   values, interpreted as UTF-16 when it is valid to do so.\n+//!\n+//! * In Rust, strings are always valid UTF-8, but may contain zeros.\n+//!\n+//! The types in this module bridge this gap by simultaneously representing Rust\n+//! and platform-native string values, and in particular allowing a Rust string\n+//! to be converted into an \"OS\" string with no cost.\n+//!\n+//! **Note**: At the moment, these types are extremely bare-bones, usable only\n+//! for conversion to/from various other string types. Eventually these types\n+//! will offer a full-fledged string API.\n+\n+#![unstable = \"recently added as part of path/io reform\"]\n+\n+use core::prelude::*;\n+\n+use core::borrow::{BorrowFrom, ToOwned};\n+use fmt::{self, Debug};\n+use mem;\n+use string::{String, CowString};\n+use ops;\n+use cmp;\n+use hash::{Hash, Hasher, Writer};\n+\n+use sys::os_str::{Buf, Slice};\n+use sys_common::{AsInner, IntoInner, FromInner};\n+\n+/// Owned, mutable OS strings.\n+#[derive(Clone)]\n+pub struct OsString {\n+    inner: Buf\n+}\n+\n+/// Slices into OS strings.\n+pub struct OsStr {\n+    inner: Slice\n+}\n+\n+impl OsString {\n+    /// Constructs an `OsString` at no cost by consuming a `String`.\n+    pub fn from_string(s: String) -> OsString {\n+        OsString { inner: Buf::from_string(s) }\n+    }\n+\n+    /// Constructs an `OsString` by copying from a `&str` slice.\n+    ///\n+    /// Equivalent to: `OsString::from_string(String::from_str(s))`.\n+    pub fn from_str(s: &str) -> OsString {\n+        OsString { inner: Buf::from_str(s) }\n+    }\n+\n+    /// Convert the `OsString` into a `String` if it contains valid Unicode data.\n+    ///\n+    /// On failure, ownership of the original `OsString` is returned.\n+    pub fn into_string(self) -> Result<String, OsString> {\n+        self.inner.into_string().map_err(|buf| OsString { inner: buf} )\n+    }\n+\n+    /// Extend the string with the given `&OsStr` slice.\n+    pub fn push_os_str(&mut self, s: &OsStr) {\n+        self.inner.push_slice(&s.inner)\n+    }\n+}\n+\n+impl ops::Index<ops::FullRange> for OsString {\n+    type Output = OsStr;\n+\n+    #[inline]\n+    fn index(&self, _index: &ops::FullRange) -> &OsStr {\n+        unsafe { mem::transmute(self.inner.as_slice()) }\n+    }\n+}\n+\n+impl ops::Deref for OsString {\n+    type Target = OsStr;\n+\n+    #[inline]\n+    fn deref(&self) -> &OsStr {\n+        &self[]\n+    }\n+}\n+\n+impl Debug for OsString {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        fmt::Debug::fmt(&**self, formatter)\n+    }\n+}\n+\n+impl OsStr {\n+    /// Coerce directly from a `&str` slice to a `&OsStr` slice.\n+    pub fn from_str(s: &str) -> &OsStr {\n+        unsafe { mem::transmute(Slice::from_str(s)) }\n+    }\n+\n+    /// Yield a `&str` slice if the `OsStr` is valid unicode.\n+    ///\n+    /// This conversion may entail doing a check for UTF-8 validity.\n+    pub fn to_str(&self) -> Option<&str> {\n+        self.inner.to_str()\n+    }\n+\n+    /// Convert an `OsStr` to a `CowString`.\n+    ///\n+    /// Any non-Unicode sequences are replaced with U+FFFD REPLACEMENT CHARACTER.\n+    pub fn to_string_lossy(&self) -> CowString {\n+        self.inner.to_string_lossy()\n+    }\n+\n+    /// Copy the slice into an onwed `OsString`.\n+    pub fn to_os_string(&self) -> OsString {\n+        OsString { inner: self.inner.to_owned() }\n+    }\n+\n+    /// Get the underlying byte representation.\n+    ///\n+    /// Note: it is *crucial* that this API is private, to avoid\n+    /// revealing the internal, platform-specific encodings.\n+    fn bytes(&self) -> &[u8] {\n+        unsafe { mem::transmute(&self.inner) }\n+    }\n+}\n+\n+impl PartialEq for OsStr {\n+    fn eq(&self, other: &OsStr) -> bool {\n+        self.bytes().eq(other.bytes())\n+    }\n+}\n+\n+impl PartialEq<str> for OsStr {\n+    fn eq(&self, other: &str) -> bool {\n+        *self == *OsStr::from_str(other)\n+    }\n+}\n+\n+impl PartialEq<OsStr> for str {\n+    fn eq(&self, other: &OsStr) -> bool {\n+        *other == *OsStr::from_str(self)\n+    }\n+}\n+\n+impl Eq for OsStr {}\n+\n+impl PartialOrd for OsStr {\n+    #[inline]\n+    fn partial_cmp(&self, other: &OsStr) -> Option<cmp::Ordering> {\n+        self.bytes().partial_cmp(other.bytes())\n+    }\n+    #[inline]\n+    fn lt(&self, other: &OsStr) -> bool { self.bytes().lt(other.bytes()) }\n+    #[inline]\n+    fn le(&self, other: &OsStr) -> bool { self.bytes().le(other.bytes()) }\n+    #[inline]\n+    fn gt(&self, other: &OsStr) -> bool { self.bytes().gt(other.bytes()) }\n+    #[inline]\n+    fn ge(&self, other: &OsStr) -> bool { self.bytes().ge(other.bytes()) }\n+}\n+\n+impl PartialOrd<str> for OsStr {\n+    #[inline]\n+    fn partial_cmp(&self, other: &str) -> Option<cmp::Ordering> {\n+        self.partial_cmp(OsStr::from_str(other))\n+    }\n+}\n+\n+// FIXME (#19470): cannot provide PartialOrd<OsStr> for str until we\n+// have more flexible coherence rules.\n+\n+impl Ord for OsStr {\n+    #[inline]\n+    fn cmp(&self, other: &OsStr) -> cmp::Ordering { self.bytes().cmp(other.bytes()) }\n+}\n+\n+impl<'a, S: Hasher + Writer> Hash<S> for OsStr {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        self.bytes().hash(state)\n+    }\n+}\n+\n+impl Debug for OsStr {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        self.inner.fmt(formatter)\n+    }\n+}\n+\n+impl BorrowFrom<OsString> for OsStr {\n+    fn borrow_from(owned: &OsString) -> &OsStr { &owned[] }\n+}\n+\n+impl ToOwned<OsString> for OsStr {\n+    fn to_owned(&self) -> OsString { self.to_os_string() }\n+}\n+\n+/// Freely convertible to an `&OsStr` slice.\n+pub trait AsOsStr {\n+    /// Convert to an `&OsStr` slice.\n+    fn as_os_str(&self) -> &OsStr;\n+}\n+\n+impl AsOsStr for OsStr {\n+    fn as_os_str(&self) -> &OsStr {\n+        self\n+    }\n+}\n+\n+impl AsOsStr for OsString {\n+    fn as_os_str(&self) -> &OsStr {\n+        &self[]\n+    }\n+}\n+\n+impl AsOsStr for str {\n+    fn as_os_str(&self) -> &OsStr {\n+        OsStr::from_str(self)\n+    }\n+}\n+\n+impl AsOsStr for String {\n+    fn as_os_str(&self) -> &OsStr {\n+        OsStr::from_str(&self[])\n+    }\n+}\n+\n+impl FromInner<Buf> for OsString {\n+    fn from_inner(buf: Buf) -> OsString {\n+        OsString { inner: buf }\n+    }\n+}\n+\n+impl IntoInner<Buf> for OsString {\n+    fn into_inner(self) -> Buf {\n+        self.inner\n+    }\n+}\n+\n+impl AsInner<Slice> for OsStr {\n+    fn as_inner(&self) -> &Slice {\n+        &self.inner\n+    }\n+}"}, {"sha": "272cf9bd0c07a388cc9928095640eb3fc97d327d", "filename": "src/libstd/sys/common/mod.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bb7cc4eb26e87ec4cb2acdc5bc3a7d25b9c817be/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb7cc4eb26e87ec4cb2acdc5bc3a7d25b9c817be/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs?ref=bb7cc4eb26e87ec4cb2acdc5bc3a7d25b9c817be", "patch": "@@ -29,6 +29,7 @@ pub mod stack;\n pub mod thread;\n pub mod thread_info;\n pub mod thread_local;\n+pub mod wtf8;\n \n // common error constructors\n \n@@ -93,11 +94,21 @@ pub fn keep_going<F>(data: &[u8], mut f: F) -> i64 where\n     return (origamt - amt) as i64;\n }\n \n-// A trait for extracting representations from std::io types\n-pub trait AsInner<Inner> {\n+/// A trait for viewing representations from std types\n+pub trait AsInner<Inner: ?Sized> {\n     fn as_inner(&self) -> &Inner;\n }\n \n+/// A trait for extracting representations from std types\n+pub trait IntoInner<Inner> {\n+    fn into_inner(self) -> Inner;\n+}\n+\n+/// A trait for creating std types from internal representations\n+pub trait FromInner<Inner> {\n+    fn from_inner(inner: Inner) -> Self;\n+}\n+\n pub trait ProcessConfig<K: BytesContainer, V: BytesContainer> {\n     fn program(&self) -> &CString;\n     fn args(&self) -> &[CString];"}, {"sha": "bc0721550634c21b5d9ecddc1b826eebcc460f45", "filename": "src/libstd/sys/common/wtf8.rs", "status": "added", "additions": 1212, "deletions": 0, "changes": 1212, "blob_url": "https://github.com/rust-lang/rust/blob/bb7cc4eb26e87ec4cb2acdc5bc3a7d25b9c817be/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb7cc4eb26e87ec4cb2acdc5bc3a7d25b9c817be/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=bb7cc4eb26e87ec4cb2acdc5bc3a7d25b9c817be", "patch": "@@ -0,0 +1,1212 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Implementation of [the WTF-8 encoding](https://simonsapin.github.io/wtf-8/).\n+//!\n+//! This library uses Rust\u2019s type system to maintain\n+//! [well-formedness](https://simonsapin.github.io/wtf-8/#well-formed),\n+//! like the `String` and `&str` types do for UTF-8.\n+//!\n+//! Since [WTF-8 must not be used\n+//! for interchange](https://simonsapin.github.io/wtf-8/#intended-audience),\n+//! this library deliberately does not provide access to the underlying bytes\n+//! of WTF-8 strings,\n+//! nor can it decode WTF-8 from arbitrary bytes.\n+//! WTF-8 strings can be obtained from UTF-8, UTF-16, or code points.\n+\n+use core::prelude::*;\n+\n+use core::char::{encode_utf8_raw, encode_utf16_raw};\n+use core::str::{char_range_at_raw, next_code_point};\n+use core::raw::Slice as RawSlice;\n+\n+use borrow::Cow;\n+use cmp;\n+use fmt;\n+use hash::{Hash, Writer, Hasher};\n+use iter::FromIterator;\n+use mem;\n+use num::Int;\n+use ops;\n+use slice;\n+use str;\n+use string::{String, CowString};\n+use unicode::str::{Utf16Item, utf16_items};\n+use vec::Vec;\n+\n+static UTF8_REPLACEMENT_CHARACTER: &'static [u8] = b\"\\xEF\\xBF\\xBD\";\n+\n+/// A Unicode code point: from U+0000 to U+10FFFF.\n+///\n+/// Compare with the `char` type,\n+/// which represents a Unicode scalar value:\n+/// a code point that is not a surrogate (U+D800 to U+DFFF).\n+#[derive(Eq, PartialEq, Ord, PartialOrd, Clone, Copy)]\n+pub struct CodePoint {\n+    value: u32\n+}\n+\n+/// Format the code point as `U+` followed by four to six hexadecimal digits.\n+/// Example: `U+1F4A9`\n+impl fmt::Debug for CodePoint {\n+    #[inline]\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        write!(formatter, \"U+{:04X}\", self.value)\n+    }\n+}\n+\n+impl CodePoint {\n+    /// Unsafely create a new `CodePoint` without checking the value.\n+    ///\n+    /// Only use when `value` is known to be less than or equal to 0x10FFFF.\n+    #[inline]\n+    pub unsafe fn from_u32_unchecked(value: u32) -> CodePoint {\n+        CodePoint { value: value }\n+    }\n+\n+    /// Create a new `CodePoint` if the value is a valid code point.\n+    ///\n+    /// Return `None` if `value` is above 0x10FFFF.\n+    #[inline]\n+    pub fn from_u32(value: u32) -> Option<CodePoint> {\n+        match value {\n+            0 ... 0x10FFFF => Some(CodePoint { value: value }),\n+            _ => None\n+        }\n+    }\n+\n+    /// Create a new `CodePoint` from a `char`.\n+    ///\n+    /// Since all Unicode scalar values are code points, this always succeds.\n+    #[inline]\n+    pub fn from_char(value: char) -> CodePoint {\n+        CodePoint { value: value as u32 }\n+    }\n+\n+    /// Return the numeric value of the code point.\n+    #[inline]\n+    pub fn to_u32(&self) -> u32 {\n+        self.value\n+    }\n+\n+    /// Optionally return a Unicode scalar value for the code point.\n+    ///\n+    /// Return `None` if the code point is a surrogate (from U+D800 to U+DFFF).\n+    #[inline]\n+    pub fn to_char(&self) -> Option<char> {\n+        match self.value {\n+            0xD800 ... 0xDFFF => None,\n+            _ => Some(unsafe { mem::transmute(self.value) })\n+        }\n+    }\n+\n+    /// Return a Unicode scalar value for the code point.\n+    ///\n+    /// Return `'\\u{FFFD}'` (the replacement character \u201c\ufffd\u201d)\n+    /// if the code point is a surrogate (from U+D800 to U+DFFF).\n+    #[inline]\n+    pub fn to_char_lossy(&self) -> char {\n+        self.to_char().unwrap_or('\\u{FFFD}')\n+    }\n+}\n+\n+/// An owned, growable string of well-formed WTF-8 data.\n+///\n+/// Similar to `String`, but can additionally contain surrogate code points\n+/// if they\u2019re not in a surrogate pair.\n+#[derive(Eq, PartialEq, Ord, PartialOrd, Clone)]\n+pub struct Wtf8Buf {\n+    bytes: Vec<u8>\n+}\n+\n+impl ops::Deref for Wtf8Buf {\n+    type Target = Wtf8;\n+\n+    fn deref(&self) -> &Wtf8 {\n+        self.as_slice()\n+    }\n+}\n+\n+/// Format the string with double quotes,\n+/// and surrogates as `\\u` followed by four hexadecimal digits.\n+/// Example: `\"a\\u{D800}\"` for a string with code points [U+0061, U+D800]\n+impl fmt::Debug for Wtf8Buf {\n+    #[inline]\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        self.as_slice().fmt(formatter)\n+    }\n+}\n+\n+impl Wtf8Buf {\n+    /// Create an new, empty WTF-8 string.\n+    #[inline]\n+    pub fn new() -> Wtf8Buf {\n+        Wtf8Buf { bytes: Vec::new() }\n+    }\n+\n+    /// Create an new, empty WTF-8 string with pre-allocated capacity for `n` bytes.\n+    #[inline]\n+    pub fn with_capacity(n: uint) -> Wtf8Buf {\n+        Wtf8Buf { bytes: Vec::with_capacity(n) }\n+    }\n+\n+    /// Create a WTF-8 string from an UTF-8 `String`.\n+    ///\n+    /// This takes ownership of the `String` and does not copy.\n+    ///\n+    /// Since WTF-8 is a superset of UTF-8, this always succeeds.\n+    #[inline]\n+    pub fn from_string(string: String) -> Wtf8Buf {\n+        Wtf8Buf { bytes: string.into_bytes() }\n+    }\n+\n+    /// Create a WTF-8 string from an UTF-8 `&str` slice.\n+    ///\n+    /// This copies the content of the slice.\n+    ///\n+    /// Since WTF-8 is a superset of UTF-8, this always succeeds.\n+    #[inline]\n+    pub fn from_str(str: &str) -> Wtf8Buf {\n+        Wtf8Buf { bytes: slice::SliceExt::to_vec(str.as_bytes()) }\n+    }\n+\n+    /// Create a WTF-8 string from a potentially ill-formed UTF-16 slice of 16-bit code units.\n+    ///\n+    /// This is lossless: calling `.encode_wide()` on the resulting string\n+    /// will always return the original code units.\n+    pub fn from_wide(v: &[u16]) -> Wtf8Buf {\n+        let mut string = Wtf8Buf::with_capacity(v.len());\n+        for item in utf16_items(v) {\n+            match item {\n+                Utf16Item::ScalarValue(c) => string.push_char(c),\n+                Utf16Item::LoneSurrogate(s) => {\n+                    // Surrogates are known to be in the code point range.\n+                    let code_point = unsafe { CodePoint::from_u32_unchecked(s as u32) };\n+                    // Skip the WTF-8 concatenation check,\n+                    // surrogate pairs are already decoded by utf16_items\n+                    string.push_code_point_unchecked(code_point)\n+                }\n+            }\n+        }\n+        string\n+    }\n+\n+    /// Copied from String::push\n+    /// This does **not** include the WTF-8 concatenation check.\n+    fn push_code_point_unchecked(&mut self, code_point: CodePoint) {\n+        let cur_len = self.len();\n+        // This may use up to 4 bytes.\n+        self.reserve(4);\n+\n+        unsafe {\n+            // Attempt to not use an intermediate buffer by just pushing bytes\n+            // directly onto this string.\n+            let slice = RawSlice {\n+                data: self.bytes.as_ptr().offset(cur_len as int),\n+                len: 4,\n+            };\n+            let used = encode_utf8_raw(code_point.value, mem::transmute(slice))\n+                .unwrap_or(0);\n+            self.bytes.set_len(cur_len + used);\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn as_slice(&self) -> &Wtf8 {\n+        unsafe { mem::transmute(self.bytes.as_slice()) }\n+    }\n+\n+    /// Reserves capacity for at least `additional` more bytes to be inserted\n+    /// in the given `Wtf8Buf`.\n+    /// The collection may reserve more space to avoid frequent reallocations.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the new capacity overflows `uint`.\n+    #[inline]\n+    pub fn reserve(&mut self, additional: uint) {\n+        self.bytes.reserve(additional)\n+    }\n+\n+    /// Returns the number of bytes that this string buffer can hold without reallocating.\n+    #[inline]\n+    pub fn capacity(&self) -> uint {\n+        self.bytes.capacity()\n+    }\n+\n+    /// Append an UTF-8 slice at the end of the string.\n+    #[inline]\n+    pub fn push_str(&mut self, other: &str) {\n+        self.bytes.push_all(other.as_bytes())\n+    }\n+\n+    /// Append a WTF-8 slice at the end of the string.\n+    ///\n+    /// This replaces newly paired surrogates at the boundary\n+    /// with a supplementary code point,\n+    /// like concatenating ill-formed UTF-16 strings effectively would.\n+    #[inline]\n+    pub fn push_wtf8(&mut self, other: &Wtf8) {\n+        match ((&*self).final_lead_surrogate(), other.initial_trail_surrogate()) {\n+            // Replace newly paired surrogates by a supplementary code point.\n+            (Some(lead), Some(trail)) => {\n+                let len_without_lead_surrogate = self.len() - 3;\n+                self.bytes.truncate(len_without_lead_surrogate);\n+                let other_without_trail_surrogate = &other.bytes[3..];\n+                // 4 bytes for the supplementary code point\n+                self.bytes.reserve(4 + other_without_trail_surrogate.len());\n+                self.push_char(decode_surrogate_pair(lead, trail));\n+                self.bytes.push_all(other_without_trail_surrogate);\n+            }\n+            _ => self.bytes.push_all(&other.bytes)\n+        }\n+    }\n+\n+    /// Append a Unicode scalar value at the end of the string.\n+    #[inline]\n+    pub fn push_char(&mut self, c: char) {\n+        self.push_code_point_unchecked(CodePoint::from_char(c))\n+    }\n+\n+    /// Append a code point at the end of the string.\n+    ///\n+    /// This replaces newly paired surrogates at the boundary\n+    /// with a supplementary code point,\n+    /// like concatenating ill-formed UTF-16 strings effectively would.\n+    #[inline]\n+    pub fn push(&mut self, code_point: CodePoint) {\n+        match code_point.to_u32() {\n+            trail @ 0xDC00...0xDFFF => {\n+                match (&*self).final_lead_surrogate() {\n+                    Some(lead) => {\n+                        let len_without_lead_surrogate = self.len() - 3;\n+                        self.bytes.truncate(len_without_lead_surrogate);\n+                        self.push_char(decode_surrogate_pair(lead, trail as u16));\n+                        return\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        // No newly paired surrogates at the boundary.\n+        self.push_code_point_unchecked(code_point)\n+    }\n+\n+    /// Shortens a string to the specified length.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `new_len` > current length,\n+    /// or if `new_len` is not a code point boundary.\n+    #[inline]\n+    pub fn truncate(&mut self, new_len: uint) {\n+        assert!(is_code_point_boundary(self.as_slice(), new_len));\n+        self.bytes.truncate(new_len)\n+    }\n+\n+    /// Consume the WTF-8 string and try to convert it to UTF-8.\n+    ///\n+    /// This does not copy the data.\n+    ///\n+    /// If the contents are not well-formed UTF-8\n+    /// (that is, if the string contains surrogates),\n+    /// the original WTF-8 string is returned instead.\n+    pub fn into_string(self) -> Result<String, Wtf8Buf> {\n+        match self.next_surrogate(0) {\n+            None => Ok(unsafe { String::from_utf8_unchecked(self.bytes) }),\n+            Some(_) => Err(self),\n+        }\n+    }\n+\n+    /// Consume the WTF-8 string and convert it lossily to UTF-8.\n+    ///\n+    /// This does not copy the data (but may overwrite parts of it in place).\n+    ///\n+    /// Surrogates are replaced with `\"\\u{FFFD}\"` (the replacement character \u201c\ufffd\u201d)\n+    pub fn into_string_lossy(mut self) -> String {\n+        let mut pos = 0;\n+        loop {\n+            match self.next_surrogate(pos) {\n+                Some((surrogate_pos, _)) => {\n+                    pos = surrogate_pos + 3;\n+                    slice::bytes::copy_memory(\n+                        &mut self.bytes[surrogate_pos .. pos],\n+                        UTF8_REPLACEMENT_CHARACTER\n+                    );\n+                },\n+                None => return unsafe { String::from_utf8_unchecked(self.bytes) }\n+            }\n+        }\n+    }\n+}\n+\n+/// Create a new WTF-8 string from an iterator of code points.\n+///\n+/// This replaces surrogate code point pairs with supplementary code points,\n+/// like concatenating ill-formed UTF-16 strings effectively would.\n+impl FromIterator<CodePoint> for Wtf8Buf {\n+    fn from_iter<T: Iterator<Item=CodePoint>>(iterator: T) -> Wtf8Buf {\n+        let mut string = Wtf8Buf::new();\n+        string.extend(iterator);\n+        string\n+    }\n+}\n+\n+/// Append code points from an iterator to the string.\n+///\n+/// This replaces surrogate code point pairs with supplementary code points,\n+/// like concatenating ill-formed UTF-16 strings effectively would.\n+impl Extend<CodePoint> for Wtf8Buf {\n+    fn extend<T: Iterator<Item=CodePoint>>(&mut self, mut iterator: T) {\n+        let (low, _high) = iterator.size_hint();\n+        // Lower bound of one byte per code point (ASCII only)\n+        self.bytes.reserve(low);\n+        for code_point in iterator {\n+            self.push(code_point);\n+        }\n+    }\n+}\n+\n+/// A borrowed slice of well-formed WTF-8 data.\n+///\n+/// Similar to `&str`, but can additionally contain surrogate code points\n+/// if they\u2019re not in a surrogate pair.\n+pub struct Wtf8 {\n+    bytes: [u8]\n+}\n+\n+// FIXME: https://github.com/rust-lang/rust/issues/18805\n+impl PartialEq for Wtf8 {\n+    fn eq(&self, other: &Wtf8) -> bool { self.bytes.eq(&other.bytes) }\n+}\n+\n+// FIXME: https://github.com/rust-lang/rust/issues/18805\n+impl Eq for Wtf8 {}\n+\n+// FIXME: https://github.com/rust-lang/rust/issues/18738\n+impl PartialOrd for Wtf8 {\n+    #[inline]\n+    fn partial_cmp(&self, other: &Wtf8) -> Option<cmp::Ordering> {\n+        self.bytes.partial_cmp(&other.bytes)\n+    }\n+    #[inline]\n+    fn lt(&self, other: &Wtf8) -> bool { self.bytes.lt(&other.bytes) }\n+    #[inline]\n+    fn le(&self, other: &Wtf8) -> bool { self.bytes.le(&other.bytes) }\n+    #[inline]\n+    fn gt(&self, other: &Wtf8) -> bool { self.bytes.gt(&other.bytes) }\n+    #[inline]\n+    fn ge(&self, other: &Wtf8) -> bool { self.bytes.ge(&other.bytes) }\n+}\n+\n+// FIXME: https://github.com/rust-lang/rust/issues/18738\n+impl Ord for Wtf8 {\n+    #[inline]\n+    fn cmp(&self, other: &Wtf8) -> cmp::Ordering { self.bytes.cmp(&other.bytes) }\n+}\n+\n+/// Format the slice with double quotes,\n+/// and surrogates as `\\u` followed by four hexadecimal digits.\n+/// Example: `\"a\\u{D800}\"` for a slice with code points [U+0061, U+D800]\n+impl fmt::Debug for Wtf8 {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        try!(formatter.write_str(\"\\\"\"));\n+        let mut pos = 0;\n+        loop {\n+            match self.next_surrogate(pos) {\n+                None => break,\n+                Some((surrogate_pos, surrogate)) => {\n+                    try!(formatter.write_str(unsafe {\n+                        // the data in this slice is valid UTF-8, transmute to &str\n+                        mem::transmute(&self.bytes[pos .. surrogate_pos])\n+                    }));\n+                    try!(write!(formatter, \"\\\\u{{{:X}}}\", surrogate));\n+                    pos = surrogate_pos + 3;\n+                }\n+            }\n+        }\n+        try!(formatter.write_str(unsafe {\n+            // the data in this slice is valid UTF-8, transmute to &str\n+            mem::transmute(&self.bytes[pos..])\n+        }));\n+        formatter.write_str(\"\\\"\")\n+    }\n+}\n+\n+impl Wtf8 {\n+    /// Create a WTF-8 slice from a UTF-8 `&str` slice.\n+    ///\n+    /// Since WTF-8 is a superset of UTF-8, this always succeeds.\n+    #[inline]\n+    pub fn from_str(value: &str) -> &Wtf8 {\n+        unsafe { mem::transmute(value.as_bytes()) }\n+    }\n+\n+    /// Return the length, in WTF-8 bytes.\n+    #[inline]\n+    pub fn len(&self) -> uint {\n+        self.bytes.len()\n+    }\n+\n+    /// Return the code point at `position` if it is in the ASCII range,\n+    /// or `b'\\xFF' otherwise.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `position` is beyond the end of the string.\n+    #[inline]\n+    pub fn ascii_byte_at(&self, position: uint) -> u8 {\n+        match self.bytes[position] {\n+            ascii_byte @ 0x00 ... 0x7F => ascii_byte,\n+            _ => 0xFF\n+        }\n+    }\n+\n+    /// Return the code point at `position`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `position` is not at a code point boundary,\n+    /// or is beyond the end of the string.\n+    #[inline]\n+    pub fn code_point_at(&self, position: uint) -> CodePoint {\n+        let (code_point, _) = self.code_point_range_at(position);\n+        code_point\n+    }\n+\n+    /// Return the code point at `position`\n+    /// and the position of the next code point.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `position` is not at a code point boundary,\n+    /// or is beyond the end of the string.\n+    #[inline]\n+    pub fn code_point_range_at(&self, position: uint) -> (CodePoint, uint) {\n+        let (c, n) = char_range_at_raw(&self.bytes, position);\n+        (CodePoint { value: c }, n)\n+    }\n+\n+    /// Return an iterator for the string\u2019s code points.\n+    #[inline]\n+    pub fn code_points(&self) -> Wtf8CodePoints {\n+        Wtf8CodePoints { bytes: self.bytes.iter() }\n+    }\n+\n+    /// Try to convert the string to UTF-8 and return a `&str` slice.\n+    ///\n+    /// Return `None` if the string contains surrogates.\n+    ///\n+    /// This does not copy the data.\n+    #[inline]\n+    pub fn as_str(&self) -> Option<&str> {\n+        // Well-formed WTF-8 is also well-formed UTF-8\n+        // if and only if it contains no surrogate.\n+        match self.next_surrogate(0) {\n+            None => Some(unsafe { str::from_utf8_unchecked(&self.bytes) }),\n+            Some(_) => None,\n+        }\n+    }\n+\n+    /// Lossily convert the string to UTF-8.\n+    /// Return an UTF-8 `&str` slice if the contents are well-formed in UTF-8.\n+    ///\n+    /// Surrogates are replaced with `\"\\u{FFFD}\"` (the replacement character \u201c\ufffd\u201d).\n+    ///\n+    /// This only copies the data if necessary (if it contains any surrogate).\n+    pub fn to_string_lossy(&self) -> CowString {\n+        let surrogate_pos = match self.next_surrogate(0) {\n+            None => return Cow::Borrowed(unsafe { str::from_utf8_unchecked(&self.bytes) }),\n+            Some((pos, _)) => pos,\n+        };\n+        let wtf8_bytes = &self.bytes;\n+        let mut utf8_bytes = Vec::with_capacity(self.len());\n+        utf8_bytes.push_all(&wtf8_bytes[..surrogate_pos]);\n+        utf8_bytes.push_all(UTF8_REPLACEMENT_CHARACTER);\n+        let mut pos = surrogate_pos + 3;\n+        loop {\n+            match self.next_surrogate(pos) {\n+                Some((surrogate_pos, _)) => {\n+                    utf8_bytes.push_all(&wtf8_bytes[pos .. surrogate_pos]);\n+                    utf8_bytes.push_all(UTF8_REPLACEMENT_CHARACTER);\n+                    pos = surrogate_pos + 3;\n+                },\n+                None => {\n+                    utf8_bytes.push_all(&wtf8_bytes[pos..]);\n+                    return Cow::Owned(unsafe { String::from_utf8_unchecked(utf8_bytes) })\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Convert the WTF-8 string to potentially ill-formed UTF-16\n+    /// and return an iterator of 16-bit code units.\n+    ///\n+    /// This is lossless:\n+    /// calling `Wtf8Buf::from_ill_formed_utf16` on the resulting code units\n+    /// would always return the original WTF-8 string.\n+    #[inline]\n+    pub fn encode_wide(&self) -> EncodeWide {\n+        EncodeWide { code_points: self.code_points(), extra: 0 }\n+    }\n+\n+    #[inline]\n+    fn next_surrogate(&self, mut pos: uint) -> Option<(uint, u16)> {\n+        let mut iter = self.bytes[pos..].iter();\n+        loop {\n+            let b = match iter.next() {\n+                None => return None,\n+                Some(&b) => b,\n+            };\n+            if b < 0x80 {\n+                pos += 1;\n+            } else if b < 0xE0 {\n+                iter.next();\n+                pos += 2;\n+            } else if b == 0xED {\n+                match (iter.next(), iter.next()) {\n+                    (Some(&b2), Some(&b3)) if b2 >= 0xA0 => {\n+                        return Some((pos, decode_surrogate(b2, b3)))\n+                    }\n+                    _ => pos += 3\n+                }\n+            } else if b < 0xF0 {\n+                iter.next();\n+                iter.next();\n+                pos += 3;\n+            } else {\n+                iter.next();\n+                iter.next();\n+                iter.next();\n+                pos += 4;\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn final_lead_surrogate(&self) -> Option<u16> {\n+        let len = self.len();\n+        if len < 3 {\n+            return None\n+        }\n+        match &self.bytes[(len - 3)..] {\n+            [0xED, b2 @ 0xA0...0xAF, b3] => Some(decode_surrogate(b2, b3)),\n+            _ => None\n+        }\n+    }\n+\n+    #[inline]\n+    fn initial_trail_surrogate(&self) -> Option<u16> {\n+        let len = self.len();\n+        if len < 3 {\n+            return None\n+        }\n+        match &self.bytes[..3] {\n+            [0xED, b2 @ 0xB0...0xBF, b3] => Some(decode_surrogate(b2, b3)),\n+            _ => None\n+        }\n+    }\n+}\n+\n+\n+/// Return a slice of the given string for the byte range [`begin`..`end`).\n+///\n+/// # Panics\n+///\n+/// Panics when `begin` and `end` do not point to code point boundaries,\n+/// or point beyond the end of the string.\n+impl ops::Index<ops::Range<usize>> for Wtf8 {\n+    type Output = Wtf8;\n+\n+    #[inline]\n+    fn index(&self, range: &ops::Range<usize>) -> &Wtf8 {\n+        // is_code_point_boundary checks that the index is in [0, .len()]\n+        if range.start <= range.end &&\n+           is_code_point_boundary(self, range.start) &&\n+           is_code_point_boundary(self, range.end) {\n+            unsafe { slice_unchecked(self, range.start, range.end) }\n+        } else {\n+            slice_error_fail(self, range.start, range.end)\n+        }\n+    }\n+}\n+\n+/// Return a slice of the given string from byte `begin` to its end.\n+///\n+/// # Panics\n+///\n+/// Panics when `begin` is not at a code point boundary,\n+/// or is beyond the end of the string.\n+impl ops::Index<ops::RangeFrom<usize>> for Wtf8 {\n+    type Output = Wtf8;\n+\n+    #[inline]\n+    fn index(&self, range: &ops::RangeFrom<usize>) -> &Wtf8 {\n+        // is_code_point_boundary checks that the index is in [0, .len()]\n+        if is_code_point_boundary(self, range.start) {\n+            unsafe { slice_unchecked(self, range.start, self.len()) }\n+        } else {\n+            slice_error_fail(self, range.start, self.len())\n+        }\n+    }\n+}\n+\n+/// Return a slice of the given string from its beginning to byte `end`.\n+///\n+/// # Panics\n+///\n+/// Panics when `end` is not at a code point boundary,\n+/// or is beyond the end of the string.\n+impl ops::Index<ops::RangeTo<usize>> for Wtf8 {\n+    type Output = Wtf8;\n+\n+    #[inline]\n+    fn index(&self, range: &ops::RangeTo<usize>) -> &Wtf8 {\n+        // is_code_point_boundary checks that the index is in [0, .len()]\n+        if is_code_point_boundary(self, range.end) {\n+            unsafe { slice_unchecked(self, 0, range.end) }\n+        } else {\n+            slice_error_fail(self, 0, range.end)\n+        }\n+    }\n+}\n+\n+impl ops::Index<ops::FullRange> for Wtf8 {\n+    type Output = Wtf8;\n+\n+    #[inline]\n+    fn index(&self, _range: &ops::FullRange) -> &Wtf8 {\n+        self\n+    }\n+}\n+\n+#[inline]\n+fn decode_surrogate(second_byte: u8, third_byte: u8) -> u16 {\n+    // The first byte is assumed to be 0xED\n+    0xD800 | (second_byte as u16 & 0x3F) << 6 | third_byte as u16 & 0x3F\n+}\n+\n+#[inline]\n+fn decode_surrogate_pair(lead: u16, trail: u16) -> char {\n+    let code_point = 0x10000 + ((((lead - 0xD800) as u32) << 10) | (trail - 0xDC00) as u32);\n+    unsafe { mem::transmute(code_point) }\n+}\n+\n+/// Copied from core::str::StrPrelude::is_char_boundary\n+#[inline]\n+pub fn is_code_point_boundary(slice: &Wtf8, index: uint) -> bool {\n+    if index == slice.len() { return true; }\n+    match slice.bytes.get(index) {\n+        None => false,\n+        Some(&b) => b < 128u8 || b >= 192u8,\n+    }\n+}\n+\n+/// Copied from core::str::raw::slice_unchecked\n+#[inline]\n+pub unsafe fn slice_unchecked(s: &Wtf8, begin: uint, end: uint) -> &Wtf8 {\n+    mem::transmute(RawSlice {\n+        data: s.bytes.as_ptr().offset(begin as int),\n+        len: end - begin,\n+    })\n+}\n+\n+/// Copied from core::str::raw::slice_error_fail\n+#[inline(never)]\n+pub fn slice_error_fail(s: &Wtf8, begin: uint, end: uint) -> ! {\n+    assert!(begin <= end);\n+    panic!(\"index {} and/or {} in `{:?}` do not lie on character boundary\",\n+          begin, end, s);\n+}\n+\n+/// Iterator for the code points of a WTF-8 string.\n+///\n+/// Created with the method `.code_points()`.\n+#[derive(Clone)]\n+pub struct Wtf8CodePoints<'a> {\n+    bytes: slice::Iter<'a, u8>\n+}\n+\n+impl<'a> Iterator for Wtf8CodePoints<'a> {\n+    type Item = CodePoint;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<CodePoint> {\n+        next_code_point(&mut self.bytes).map(|c| CodePoint { value: c })\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let (len, _) = self.bytes.size_hint();\n+        (len.saturating_add(3) / 4, Some(len))\n+    }\n+}\n+\n+#[derive(Clone)]\n+pub struct EncodeWide<'a> {\n+    code_points: Wtf8CodePoints<'a>,\n+    extra: u16\n+}\n+\n+// Copied from libunicode/u_str.rs\n+impl<'a> Iterator for EncodeWide<'a> {\n+    type Item = u16;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<u16> {\n+        if self.extra != 0 {\n+            let tmp = self.extra;\n+            self.extra = 0;\n+            return Some(tmp);\n+        }\n+\n+        let mut buf = [0u16; 2];\n+        self.code_points.next().map(|code_point| {\n+            let n = encode_utf16_raw(code_point.value, buf.as_mut_slice())\n+                .unwrap_or(0);\n+            if n == 2 { self.extra = buf[1]; }\n+            buf[0]\n+        })\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let (low, high) = self.code_points.size_hint();\n+        // every code point gets either one u16 or two u16,\n+        // so this iterator is between 1 or 2 times as\n+        // long as the underlying iterator.\n+        (low, high.and_then(|n| n.checked_mul(2)))\n+    }\n+}\n+\n+impl<S: Writer + Hasher> Hash<S> for CodePoint {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        self.value.hash(state)\n+    }\n+}\n+\n+impl<S: Writer + Hasher> Hash<S> for Wtf8Buf {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        state.write(self.bytes.as_slice());\n+        0xfeu8.hash(state)\n+    }\n+}\n+\n+impl<'a, S: Writer + Hasher> Hash<S> for Wtf8 {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        state.write(&self.bytes);\n+        0xfeu8.hash(state)\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use prelude::v1::*;\n+    use borrow::Cow;\n+    use super::*;\n+    use mem::transmute;\n+    use string::CowString;\n+\n+    #[test]\n+    fn code_point_from_u32() {\n+        assert!(CodePoint::from_u32(0).is_some());\n+        assert!(CodePoint::from_u32(0xD800).is_some());\n+        assert!(CodePoint::from_u32(0x10FFFF).is_some());\n+        assert!(CodePoint::from_u32(0x110000).is_none());\n+    }\n+\n+    #[test]\n+    fn code_point_to_u32() {\n+        fn c(value: u32) -> CodePoint { CodePoint::from_u32(value).unwrap() }\n+        assert_eq!(c(0).to_u32(), 0);\n+        assert_eq!(c(0xD800).to_u32(), 0xD800);\n+        assert_eq!(c(0x10FFFF).to_u32(), 0x10FFFF);\n+    }\n+\n+    #[test]\n+    fn code_point_from_char() {\n+        assert_eq!(CodePoint::from_char('a').to_u32(), 0x61);\n+        assert_eq!(CodePoint::from_char('\ud83d\udca9').to_u32(), 0x1F4A9);\n+    }\n+\n+    #[test]\n+    fn code_point_to_string() {\n+        assert_eq!(format!(\"{:?}\", CodePoint::from_char('a')).as_slice(), \"U+0061\");\n+        assert_eq!(format!(\"{:?}\", CodePoint::from_char('\ud83d\udca9')).as_slice(), \"U+1F4A9\");\n+    }\n+\n+    #[test]\n+    fn code_point_to_char() {\n+        fn c(value: u32) -> CodePoint { CodePoint::from_u32(value).unwrap() }\n+        assert_eq!(c(0x61).to_char(), Some('a'));\n+        assert_eq!(c(0x1F4A9).to_char(), Some('\ud83d\udca9'));\n+        assert_eq!(c(0xD800).to_char(), None);\n+    }\n+\n+    #[test]\n+    fn code_point_to_char_lossy() {\n+        fn c(value: u32) -> CodePoint { CodePoint::from_u32(value).unwrap() }\n+        assert_eq!(c(0x61).to_char_lossy(), 'a');\n+        assert_eq!(c(0x1F4A9).to_char_lossy(), '\ud83d\udca9');\n+        assert_eq!(c(0xD800).to_char_lossy(), '\\u{FFFD}');\n+    }\n+\n+    #[test]\n+    fn wtf8buf_new() {\n+        assert_eq!(Wtf8Buf::new().bytes.as_slice(), b\"\");\n+    }\n+\n+    #[test]\n+    fn wtf8buf_from_str() {\n+        assert_eq!(Wtf8Buf::from_str(\"\").bytes.as_slice(), b\"\");\n+        assert_eq!(Wtf8Buf::from_str(\"a\u00e9 \ud83d\udca9\").bytes.as_slice(),\n+                   b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n+    }\n+\n+    #[test]\n+    fn wtf8buf_from_string() {\n+        assert_eq!(Wtf8Buf::from_string(String::from_str(\"\")).bytes.as_slice(), b\"\");\n+        assert_eq!(Wtf8Buf::from_string(String::from_str(\"a\u00e9 \ud83d\udca9\")).bytes.as_slice(),\n+                   b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n+    }\n+\n+    #[test]\n+    fn wtf8buf_from_wide() {\n+        assert_eq!(Wtf8Buf::from_wide(&[]).bytes.as_slice(), b\"\");\n+        assert_eq!(Wtf8Buf::from_wide(\n+                      &[0x61, 0xE9, 0x20, 0xD83D, 0xD83D, 0xDCA9]).bytes.as_slice(),\n+                   b\"a\\xC3\\xA9 \\xED\\xA0\\xBD\\xF0\\x9F\\x92\\xA9\");\n+    }\n+\n+    #[test]\n+    fn wtf8buf_push_str() {\n+        let mut string = Wtf8Buf::new();\n+        assert_eq!(string.bytes.as_slice(), b\"\");\n+        string.push_str(\"a\u00e9 \ud83d\udca9\");\n+        assert_eq!(string.bytes.as_slice(), b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n+    }\n+\n+    #[test]\n+    fn wtf8buf_push_char() {\n+        let mut string = Wtf8Buf::from_str(\"a\u00e9 \");\n+        assert_eq!(string.bytes.as_slice(), b\"a\\xC3\\xA9 \");\n+        string.push_char('\ud83d\udca9');\n+        assert_eq!(string.bytes.as_slice(), b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n+    }\n+\n+    #[test]\n+    fn wtf8buf_push() {\n+        let mut string = Wtf8Buf::from_str(\"a\u00e9 \");\n+        assert_eq!(string.bytes.as_slice(), b\"a\\xC3\\xA9 \");\n+        string.push(CodePoint::from_char('\ud83d\udca9'));\n+        assert_eq!(string.bytes.as_slice(), b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n+\n+        fn c(value: u32) -> CodePoint { CodePoint::from_u32(value).unwrap() }\n+\n+        let mut string = Wtf8Buf::new();\n+        string.push(c(0xD83D));  // lead\n+        string.push(c(0xDCA9));  // trail\n+        assert_eq!(string.bytes.as_slice(), b\"\\xF0\\x9F\\x92\\xA9\");  // Magic!\n+\n+        let mut string = Wtf8Buf::new();\n+        string.push(c(0xD83D));  // lead\n+        string.push(c(0x20));  // not surrogate\n+        string.push(c(0xDCA9));  // trail\n+        assert_eq!(string.bytes.as_slice(), b\"\\xED\\xA0\\xBD \\xED\\xB2\\xA9\");\n+\n+        let mut string = Wtf8Buf::new();\n+        string.push(c(0xD800));  // lead\n+        string.push(c(0xDBFF));  // lead\n+        assert_eq!(string.bytes.as_slice(), b\"\\xED\\xA0\\x80\\xED\\xAF\\xBF\");\n+\n+        let mut string = Wtf8Buf::new();\n+        string.push(c(0xD800));  // lead\n+        string.push(c(0xE000));  // not surrogate\n+        assert_eq!(string.bytes.as_slice(), b\"\\xED\\xA0\\x80\\xEE\\x80\\x80\");\n+\n+        let mut string = Wtf8Buf::new();\n+        string.push(c(0xD7FF));  // not surrogate\n+        string.push(c(0xDC00));  // trail\n+        assert_eq!(string.bytes.as_slice(), b\"\\xED\\x9F\\xBF\\xED\\xB0\\x80\");\n+\n+        let mut string = Wtf8Buf::new();\n+        string.push(c(0x61));  // not surrogate, < 3 bytes\n+        string.push(c(0xDC00));  // trail\n+        assert_eq!(string.bytes.as_slice(), b\"\\x61\\xED\\xB0\\x80\");\n+\n+        let mut string = Wtf8Buf::new();\n+        string.push(c(0xDC00));  // trail\n+        assert_eq!(string.bytes.as_slice(), b\"\\xED\\xB0\\x80\");\n+    }\n+\n+    #[test]\n+    fn wtf8buf_push_wtf8() {\n+        let mut string = Wtf8Buf::from_str(\"a\u00e9\");\n+        assert_eq!(string.bytes.as_slice(), b\"a\\xC3\\xA9\");\n+        string.push_wtf8(Wtf8::from_str(\" \ud83d\udca9\"));\n+        assert_eq!(string.bytes.as_slice(), b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n+\n+        fn w(value: &[u8]) -> &Wtf8 { unsafe { transmute(value) } }\n+\n+        let mut string = Wtf8Buf::new();\n+        string.push_wtf8(w(b\"\\xED\\xA0\\xBD\"));  // lead\n+        string.push_wtf8(w(b\"\\xED\\xB2\\xA9\"));  // trail\n+        assert_eq!(string.bytes.as_slice(), b\"\\xF0\\x9F\\x92\\xA9\");  // Magic!\n+\n+        let mut string = Wtf8Buf::new();\n+        string.push_wtf8(w(b\"\\xED\\xA0\\xBD\"));  // lead\n+        string.push_wtf8(w(b\" \"));  // not surrogate\n+        string.push_wtf8(w(b\"\\xED\\xB2\\xA9\"));  // trail\n+        assert_eq!(string.bytes.as_slice(), b\"\\xED\\xA0\\xBD \\xED\\xB2\\xA9\");\n+\n+        let mut string = Wtf8Buf::new();\n+        string.push_wtf8(w(b\"\\xED\\xA0\\x80\"));  // lead\n+        string.push_wtf8(w(b\"\\xED\\xAF\\xBF\"));  // lead\n+        assert_eq!(string.bytes.as_slice(), b\"\\xED\\xA0\\x80\\xED\\xAF\\xBF\");\n+\n+        let mut string = Wtf8Buf::new();\n+        string.push_wtf8(w(b\"\\xED\\xA0\\x80\"));  // lead\n+        string.push_wtf8(w(b\"\\xEE\\x80\\x80\"));  // not surrogate\n+        assert_eq!(string.bytes.as_slice(), b\"\\xED\\xA0\\x80\\xEE\\x80\\x80\");\n+\n+        let mut string = Wtf8Buf::new();\n+        string.push_wtf8(w(b\"\\xED\\x9F\\xBF\"));  // not surrogate\n+        string.push_wtf8(w(b\"\\xED\\xB0\\x80\"));  // trail\n+        assert_eq!(string.bytes.as_slice(), b\"\\xED\\x9F\\xBF\\xED\\xB0\\x80\");\n+\n+        let mut string = Wtf8Buf::new();\n+        string.push_wtf8(w(b\"a\"));  // not surrogate, < 3 bytes\n+        string.push_wtf8(w(b\"\\xED\\xB0\\x80\"));  // trail\n+        assert_eq!(string.bytes.as_slice(), b\"\\x61\\xED\\xB0\\x80\");\n+\n+        let mut string = Wtf8Buf::new();\n+        string.push_wtf8(w(b\"\\xED\\xB0\\x80\"));  // trail\n+        assert_eq!(string.bytes.as_slice(), b\"\\xED\\xB0\\x80\");\n+    }\n+\n+    #[test]\n+    fn wtf8buf_truncate() {\n+        let mut string = Wtf8Buf::from_str(\"a\u00e9\");\n+        string.truncate(1);\n+        assert_eq!(string.bytes.as_slice(), b\"a\");\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn wtf8buf_truncate_fail_code_point_boundary() {\n+        let mut string = Wtf8Buf::from_str(\"a\u00e9\");\n+        string.truncate(2);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn wtf8buf_truncate_fail_longer() {\n+        let mut string = Wtf8Buf::from_str(\"a\u00e9\");\n+        string.truncate(4);\n+    }\n+\n+    #[test]\n+    fn wtf8buf_into_string() {\n+        let mut string = Wtf8Buf::from_str(\"a\u00e9 \ud83d\udca9\");\n+        assert_eq!(string.clone().into_string(), Ok(String::from_str(\"a\u00e9 \ud83d\udca9\")));\n+        string.push(CodePoint::from_u32(0xD800).unwrap());\n+        assert_eq!(string.clone().into_string(), Err(string));\n+    }\n+\n+    #[test]\n+    fn wtf8buf_into_string_lossy() {\n+        let mut string = Wtf8Buf::from_str(\"a\u00e9 \ud83d\udca9\");\n+        assert_eq!(string.clone().into_string_lossy(), String::from_str(\"a\u00e9 \ud83d\udca9\"));\n+        string.push(CodePoint::from_u32(0xD800).unwrap());\n+        assert_eq!(string.clone().into_string_lossy(), String::from_str(\"a\u00e9 \ud83d\udca9\ufffd\"));\n+    }\n+\n+    #[test]\n+    fn wtf8buf_from_iterator() {\n+        fn f(values: &[u32]) -> Wtf8Buf {\n+            values.iter().map(|&c| CodePoint::from_u32(c).unwrap()).collect::<Wtf8Buf>()\n+        };\n+        assert_eq!(f(&[0x61, 0xE9, 0x20, 0x1F4A9]).bytes.as_slice(), b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n+\n+        assert_eq!(f(&[0xD83D, 0xDCA9]).bytes.as_slice(), b\"\\xF0\\x9F\\x92\\xA9\");  // Magic!\n+        assert_eq!(f(&[0xD83D, 0x20, 0xDCA9]).bytes.as_slice(), b\"\\xED\\xA0\\xBD \\xED\\xB2\\xA9\");\n+        assert_eq!(f(&[0xD800, 0xDBFF]).bytes.as_slice(), b\"\\xED\\xA0\\x80\\xED\\xAF\\xBF\");\n+        assert_eq!(f(&[0xD800, 0xE000]).bytes.as_slice(), b\"\\xED\\xA0\\x80\\xEE\\x80\\x80\");\n+        assert_eq!(f(&[0xD7FF, 0xDC00]).bytes.as_slice(), b\"\\xED\\x9F\\xBF\\xED\\xB0\\x80\");\n+        assert_eq!(f(&[0x61, 0xDC00]).bytes.as_slice(), b\"\\x61\\xED\\xB0\\x80\");\n+        assert_eq!(f(&[0xDC00]).bytes.as_slice(), b\"\\xED\\xB0\\x80\");\n+    }\n+\n+    #[test]\n+    fn wtf8buf_extend() {\n+        fn e(initial: &[u32], extended: &[u32]) -> Wtf8Buf {\n+            fn c(value: &u32) -> CodePoint { CodePoint::from_u32(*value).unwrap() }\n+            let mut string = initial.iter().map(c).collect::<Wtf8Buf>();\n+            string.extend(extended.iter().map(c));\n+            string\n+        };\n+\n+        assert_eq!(e(&[0x61, 0xE9], &[0x20, 0x1F4A9]).bytes.as_slice(),\n+                   b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n+\n+        assert_eq!(e(&[0xD83D], &[0xDCA9]).bytes.as_slice(), b\"\\xF0\\x9F\\x92\\xA9\");  // Magic!\n+        assert_eq!(e(&[0xD83D, 0x20], &[0xDCA9]).bytes.as_slice(), b\"\\xED\\xA0\\xBD \\xED\\xB2\\xA9\");\n+        assert_eq!(e(&[0xD800], &[0xDBFF]).bytes.as_slice(), b\"\\xED\\xA0\\x80\\xED\\xAF\\xBF\");\n+        assert_eq!(e(&[0xD800], &[0xE000]).bytes.as_slice(), b\"\\xED\\xA0\\x80\\xEE\\x80\\x80\");\n+        assert_eq!(e(&[0xD7FF], &[0xDC00]).bytes.as_slice(), b\"\\xED\\x9F\\xBF\\xED\\xB0\\x80\");\n+        assert_eq!(e(&[0x61], &[0xDC00]).bytes.as_slice(), b\"\\x61\\xED\\xB0\\x80\");\n+        assert_eq!(e(&[], &[0xDC00]).bytes.as_slice(), b\"\\xED\\xB0\\x80\");\n+    }\n+\n+    #[test]\n+    fn wtf8buf_show() {\n+        let mut string = Wtf8Buf::from_str(\"a\u00e9 \ud83d\udca9\");\n+        string.push(CodePoint::from_u32(0xD800).unwrap());\n+        assert_eq!(format!(\"{:?}\", string).as_slice(), r#\"\"a\u00e9 \ud83d\udca9\\u{D800}\"\"#);\n+    }\n+\n+    #[test]\n+    fn wtf8buf_as_slice() {\n+        assert_eq!(Wtf8Buf::from_str(\"a\u00e9\").as_slice(), Wtf8::from_str(\"a\u00e9\"));\n+    }\n+\n+    #[test]\n+    fn wtf8_show() {\n+        let mut string = Wtf8Buf::from_str(\"a\u00e9 \ud83d\udca9\");\n+        string.push(CodePoint::from_u32(0xD800).unwrap());\n+        assert_eq!(format!(\"{:?}\", string.as_slice()).as_slice(), r#\"\"a\u00e9 \ud83d\udca9\\u{D800}\"\"#);\n+    }\n+\n+    #[test]\n+    fn wtf8_from_str() {\n+        assert_eq!(&Wtf8::from_str(\"\").bytes, b\"\");\n+        assert_eq!(&Wtf8::from_str(\"a\u00e9 \ud83d\udca9\").bytes, b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n+    }\n+\n+    #[test]\n+    fn wtf8_len() {\n+        assert_eq!(Wtf8::from_str(\"\").len(), 0);\n+        assert_eq!(Wtf8::from_str(\"a\u00e9 \ud83d\udca9\").len(), 8);\n+    }\n+\n+    #[test]\n+    fn wtf8_slice() {\n+        assert_eq!(&Wtf8::from_str(\"a\u00e9 \ud83d\udca9\")[1.. 4].bytes, b\"\\xC3\\xA9 \");\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn wtf8_slice_not_code_point_boundary() {\n+        &Wtf8::from_str(\"a\u00e9 \ud83d\udca9\")[2.. 4];\n+    }\n+\n+    #[test]\n+    fn wtf8_slice_from() {\n+        assert_eq!(&Wtf8::from_str(\"a\u00e9 \ud83d\udca9\")[1..].bytes, b\"\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn wtf8_slice_from_not_code_point_boundary() {\n+        &Wtf8::from_str(\"a\u00e9 \ud83d\udca9\")[2..];\n+    }\n+\n+    #[test]\n+    fn wtf8_slice_to() {\n+        assert_eq!(&Wtf8::from_str(\"a\u00e9 \ud83d\udca9\")[..4].bytes, b\"a\\xC3\\xA9 \");\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn wtf8_slice_to_not_code_point_boundary() {\n+        &Wtf8::from_str(\"a\u00e9 \ud83d\udca9\")[5..];\n+    }\n+\n+    #[test]\n+    fn wtf8_ascii_byte_at() {\n+        let slice = Wtf8::from_str(\"a\u00e9 \ud83d\udca9\");\n+        assert_eq!(slice.ascii_byte_at(0), b'a');\n+        assert_eq!(slice.ascii_byte_at(1), b'\\xFF');\n+        assert_eq!(slice.ascii_byte_at(2), b'\\xFF');\n+        assert_eq!(slice.ascii_byte_at(3), b' ');\n+        assert_eq!(slice.ascii_byte_at(4), b'\\xFF');\n+    }\n+\n+    #[test]\n+    fn wtf8_code_point_at() {\n+        let mut string = Wtf8Buf::from_str(\"a\u00e9 \");\n+        string.push(CodePoint::from_u32(0xD83D).unwrap());\n+        string.push_char('\ud83d\udca9');\n+        assert_eq!(string.code_point_at(0), CodePoint::from_char('a'));\n+        assert_eq!(string.code_point_at(1), CodePoint::from_char('\u00e9'));\n+        assert_eq!(string.code_point_at(3), CodePoint::from_char(' '));\n+        assert_eq!(string.code_point_at(4), CodePoint::from_u32(0xD83D).unwrap());\n+        assert_eq!(string.code_point_at(7), CodePoint::from_char('\ud83d\udca9'));\n+    }\n+\n+    #[test]\n+    fn wtf8_code_point_range_at() {\n+        let mut string = Wtf8Buf::from_str(\"a\u00e9 \");\n+        string.push(CodePoint::from_u32(0xD83D).unwrap());\n+        string.push_char('\ud83d\udca9');\n+        assert_eq!(string.code_point_range_at(0), (CodePoint::from_char('a'), 1));\n+        assert_eq!(string.code_point_range_at(1), (CodePoint::from_char('\u00e9'), 3));\n+        assert_eq!(string.code_point_range_at(3), (CodePoint::from_char(' '), 4));\n+        assert_eq!(string.code_point_range_at(4), (CodePoint::from_u32(0xD83D).unwrap(), 7));\n+        assert_eq!(string.code_point_range_at(7), (CodePoint::from_char('\ud83d\udca9'), 11));\n+    }\n+\n+    #[test]\n+    fn wtf8_code_points() {\n+        fn c(value: u32) -> CodePoint { CodePoint::from_u32(value).unwrap() }\n+        fn cp(string: &Wtf8Buf) -> Vec<Option<char>> {\n+            string.code_points().map(|c| c.to_char()).collect::<Vec<_>>()\n+        }\n+        let mut string = Wtf8Buf::from_str(\"\u00e9 \");\n+        assert_eq!(cp(&string), vec![Some('\u00e9'), Some(' ')]);\n+        string.push(c(0xD83D));\n+        assert_eq!(cp(&string), vec![Some('\u00e9'), Some(' '), None]);\n+        string.push(c(0xDCA9));\n+        assert_eq!(cp(&string), vec![Some('\u00e9'), Some(' '), Some('\ud83d\udca9')]);\n+    }\n+\n+    #[test]\n+    fn wtf8_as_str() {\n+        assert_eq!(Wtf8::from_str(\"\").as_str(), Some(\"\"));\n+        assert_eq!(Wtf8::from_str(\"a\u00e9 \ud83d\udca9\").as_str(), Some(\"a\u00e9 \ud83d\udca9\"));\n+        let mut string = Wtf8Buf::new();\n+        string.push(CodePoint::from_u32(0xD800).unwrap());\n+        assert_eq!(string.as_str(), None);\n+    }\n+\n+    #[test]\n+    fn wtf8_to_string_lossy() {\n+        assert_eq!(Wtf8::from_str(\"\").to_string_lossy(), Cow::Borrowed(\"\"));\n+        assert_eq!(Wtf8::from_str(\"a\u00e9 \ud83d\udca9\").to_string_lossy(), Cow::Borrowed(\"a\u00e9 \ud83d\udca9\"));\n+        let mut string = Wtf8Buf::from_str(\"a\u00e9 \ud83d\udca9\");\n+        string.push(CodePoint::from_u32(0xD800).unwrap());\n+        let expected: CowString = Cow::Owned(String::from_str(\"a\u00e9 \ud83d\udca9\ufffd\"));\n+        assert_eq!(string.to_string_lossy(), expected);\n+    }\n+\n+    #[test]\n+    fn wtf8_encode_wide() {\n+        let mut string = Wtf8Buf::from_str(\"a\u00e9 \");\n+        string.push(CodePoint::from_u32(0xD83D).unwrap());\n+        string.push_char('\ud83d\udca9');\n+        assert_eq!(string.encode_wide().collect::<Vec<_>>(),\n+                   vec![0x61, 0xE9, 0x20, 0xD83D, 0xD83D, 0xDCA9]);\n+    }\n+}"}, {"sha": "9c659b56d9380ab2a89f5d2216a338712ee9400f", "filename": "src/libstd/sys/unix/ext.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/bb7cc4eb26e87ec4cb2acdc5bc3a7d25b9c817be/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb7cc4eb26e87ec4cb2acdc5bc3a7d25b9c817be/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext.rs?ref=bb7cc4eb26e87ec4cb2acdc5bc3a7d25b9c817be", "patch": "@@ -31,7 +31,10 @@\n \n #![unstable]\n \n-use sys_common::AsInner;\n+use vec::Vec;\n+use sys::os_str::Buf;\n+use sys_common::{AsInner, IntoInner, FromInner};\n+use ffi::{OsStr, OsString};\n use libc;\n \n use io;\n@@ -99,6 +102,36 @@ impl AsRawFd for io::net::udp::UdpSocket {\n     }\n }\n \n+// Unix-specific extensions to `OsString`.\n+pub trait OsStringExt {\n+    /// Create an `OsString` from a byte vector.\n+    fn from_vec(vec: Vec<u8>) -> Self;\n+\n+    /// Yield the underlying byte vector of this `OsString`.\n+    fn into_vec(self) -> Vec<u8>;\n+}\n+\n+impl OsStringExt for OsString {\n+    fn from_vec(vec: Vec<u8>) -> OsString {\n+        FromInner::from_inner(Buf { inner: vec })\n+    }\n+\n+    fn into_vec(self) -> Vec<u8> {\n+        self.into_inner().inner\n+    }\n+}\n+\n+// Unix-specific extensions to `OsStr`.\n+pub trait OsStrExt {\n+    fn as_byte_slice(&self) -> &[u8];\n+}\n+\n+impl OsStrExt for OsStr {\n+    fn as_byte_slice(&self) -> &[u8] {\n+        &self.as_inner().inner\n+    }\n+}\n+\n /// A prelude for conveniently writing platform-specific code.\n ///\n /// Includes all extension traits, and some important type definitions."}, {"sha": "5493bc20a87ef92246bf1dca131d4432b7d470d2", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bb7cc4eb26e87ec4cb2acdc5bc3a7d25b9c817be/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb7cc4eb26e87ec4cb2acdc5bc3a7d25b9c817be/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=bb7cc4eb26e87ec4cb2acdc5bc3a7d25b9c817be", "patch": "@@ -44,6 +44,7 @@ pub mod fs;\n pub mod helper_signal;\n pub mod mutex;\n pub mod os;\n+pub mod os_str;\n pub mod pipe;\n pub mod process;\n pub mod rwlock;"}, {"sha": "3dd89ad07593a2c48a0dbf5a782fd1340288b343", "filename": "src/libstd/sys/unix/os_str.rs", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/bb7cc4eb26e87ec4cb2acdc5bc3a7d25b9c817be/src%2Flibstd%2Fsys%2Funix%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb7cc4eb26e87ec4cb2acdc5bc3a7d25b9c817be/src%2Flibstd%2Fsys%2Funix%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos_str.rs?ref=bb7cc4eb26e87ec4cb2acdc5bc3a7d25b9c817be", "patch": "@@ -0,0 +1,86 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// The underlying OsString/OsStr implementation on Unix systems: just\n+/// a `Vec<u8>`/`[u8]`.\n+\n+use core::prelude::*;\n+\n+use fmt::{self, Debug};\n+use vec::Vec;\n+use slice::SliceExt as StdSliceExt;\n+use str;\n+use string::{String, CowString};\n+use mem;\n+\n+#[derive(Clone)]\n+pub struct Buf {\n+    pub inner: Vec<u8>\n+}\n+\n+pub struct Slice {\n+    pub inner: [u8]\n+}\n+\n+impl Debug for Slice {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        self.to_string_lossy().fmt(formatter)\n+    }\n+}\n+\n+impl Debug for Buf {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        self.as_slice().fmt(formatter)\n+    }\n+}\n+\n+impl Buf {\n+    pub fn from_string(s: String) -> Buf {\n+        Buf { inner: s.into_bytes() }\n+    }\n+\n+    pub fn from_str(s: &str) -> Buf {\n+        Buf { inner: s.as_bytes().to_vec() }\n+    }\n+\n+    pub fn as_slice(&self) -> &Slice {\n+        unsafe { mem::transmute(self.inner.as_slice()) }\n+    }\n+\n+    pub fn into_string(self) -> Result<String, Buf> {\n+        String::from_utf8(self.inner).map_err(|p| Buf { inner: p.into_bytes() } )\n+    }\n+\n+    pub fn push_slice(&mut self, s: &Slice) {\n+        self.inner.push_all(&s.inner)\n+    }\n+}\n+\n+impl Slice {\n+    fn from_u8_slice(s: &[u8]) -> &Slice {\n+        unsafe { mem::transmute(s) }\n+    }\n+\n+    pub fn from_str(s: &str) -> &Slice {\n+        unsafe { mem::transmute(s.as_bytes()) }\n+    }\n+\n+    pub fn to_str(&self) -> Option<&str> {\n+        str::from_utf8(&self.inner).ok()\n+    }\n+\n+    pub fn to_string_lossy(&self) -> CowString {\n+        String::from_utf8_lossy(&self.inner)\n+    }\n+\n+    pub fn to_owned(&self) -> Buf {\n+        Buf { inner: self.inner.to_vec() }\n+    }\n+}"}, {"sha": "de37c4282884cc695c5124d3b39513479c6569a7", "filename": "src/libstd/sys/windows/ext.rs", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bb7cc4eb26e87ec4cb2acdc5bc3a7d25b9c817be/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb7cc4eb26e87ec4cb2acdc5bc3a7d25b9c817be/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs?ref=bb7cc4eb26e87ec4cb2acdc5bc3a7d25b9c817be", "patch": "@@ -16,7 +16,11 @@\n \n #![unstable]\n \n-use sys_common::AsInner;\n+pub use sys_common::wtf8::{Wtf8Buf, EncodeWide};\n+\n+use sys::os_str::Buf;\n+use sys_common::{AsInner, FromInner};\n+use ffi::{OsStr, OsString};\n use libc;\n \n use io;\n@@ -92,9 +96,35 @@ impl AsRawSocket for io::net::udp::UdpSocket {\n     }\n }\n \n+// Windows-specific extensions to `OsString`.\n+pub trait OsStringExt {\n+    /// Create an `OsString` from a potentially ill-formed UTF-16 slice of 16-bit code units.\n+    ///\n+    /// This is lossless: calling `.encode_wide()` on the resulting string\n+    /// will always return the original code units.\n+    fn from_wide(wide: &[u16]) -> Self;\n+}\n+\n+impl OsStringExt for OsString {\n+    fn from_wide(wide: &[u16]) -> OsString {\n+        FromInner::from_inner(Buf { inner: Wtf8Buf::from_wide(wide) })\n+    }\n+}\n+\n+// Windows-specific extensions to `OsStr`.\n+pub trait OsStrExt {\n+    fn encode_wide(&self) -> EncodeWide;\n+}\n+\n+impl OsStrExt for OsStr {\n+    fn encode_wide(&self) -> EncodeWide {\n+        self.as_inner().inner.encode_wide()\n+    }\n+}\n+\n /// A prelude for conveniently writing platform-specific code.\n ///\n /// Includes all extension traits, and some important type definitions.\n pub mod prelude {\n-    pub use super::{Socket, Handle, AsRawSocket, AsRawHandle};\n+    pub use super::{Socket, Handle, AsRawSocket, AsRawHandle, OsStrExt, OsStringExt};\n }"}, {"sha": "876159623ac9915cf7734c31fbb4a1e89c654528", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bb7cc4eb26e87ec4cb2acdc5bc3a7d25b9c817be/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb7cc4eb26e87ec4cb2acdc5bc3a7d25b9c817be/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=bb7cc4eb26e87ec4cb2acdc5bc3a7d25b9c817be", "patch": "@@ -44,6 +44,7 @@ pub mod fs;\n pub mod helper_signal;\n pub mod mutex;\n pub mod os;\n+pub mod os_str;\n pub mod pipe;\n pub mod process;\n pub mod rwlock;"}, {"sha": "aab2406cef92bd0a21aeb1dba5e9e2f0a56beaae", "filename": "src/libstd/sys/windows/os_str.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/bb7cc4eb26e87ec4cb2acdc5bc3a7d25b9c817be/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb7cc4eb26e87ec4cb2acdc5bc3a7d25b9c817be/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs?ref=bb7cc4eb26e87ec4cb2acdc5bc3a7d25b9c817be", "patch": "@@ -0,0 +1,82 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// The underlying OsString/OsStr implementation on Windows is a\n+/// wrapper around the \"WTF-8\" encoding; see the `wtf8` module for more.\n+\n+use fmt::{self, Debug};\n+use sys_common::wtf8::{Wtf8, Wtf8Buf};\n+use string::{String, CowString};\n+use result::Result;\n+use option::Option;\n+use mem;\n+\n+#[derive(Clone)]\n+pub struct Buf {\n+    pub inner: Wtf8Buf\n+}\n+\n+impl Debug for Buf {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        self.as_slice().fmt(formatter)\n+    }\n+}\n+\n+pub struct Slice {\n+    pub inner: Wtf8\n+}\n+\n+impl Debug for Slice {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        self.inner.fmt(formatter)\n+    }\n+}\n+\n+impl Buf {\n+    pub fn from_string(s: String) -> Buf {\n+        Buf { inner: Wtf8Buf::from_string(s) }\n+    }\n+\n+    pub fn from_str(s: &str) -> Buf {\n+        Buf { inner: Wtf8Buf::from_str(s) }\n+    }\n+\n+    pub fn as_slice(&self) -> &Slice {\n+        unsafe { mem::transmute(self.inner.as_slice()) }\n+    }\n+\n+    pub fn into_string(self) -> Result<String, Buf> {\n+        self.inner.into_string().map_err(|buf| Buf { inner: buf })\n+    }\n+\n+    pub fn push_slice(&mut self, s: &Slice) {\n+        self.inner.push_wtf8(&s.inner)\n+    }\n+}\n+\n+impl Slice {\n+    pub fn from_str(s: &str) -> &Slice {\n+        unsafe { mem::transmute(Wtf8::from_str(s)) }\n+    }\n+\n+    pub fn to_str(&self) -> Option<&str> {\n+        self.inner.as_str()\n+    }\n+\n+    pub fn to_string_lossy(&self) -> CowString {\n+        self.inner.to_string_lossy()\n+    }\n+\n+    pub fn to_owned(&self) -> Buf {\n+        let mut buf = Wtf8Buf::with_capacity(self.inner.len());\n+        buf.push_wtf8(&self.inner);\n+        Buf { inner: buf }\n+    }\n+}"}]}