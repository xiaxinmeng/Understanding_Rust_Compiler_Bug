{"sha": "72958acd57fb32e0f8027c0d7e76c9a0c7f155d2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyOTU4YWNkNTdmYjMyZTBmODAyN2MwZDdlNzZjOWEwYzdmMTU1ZDI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2019-03-01T19:47:06Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2019-03-05T15:42:17Z"}, "message": "std: Spin for a global malloc lock on wasm32\n\nThere's lots of comments in the code, but the main gist of this commit\nis that the acquisition of the global malloc lock on the\n`wasm32-unknown-unknown` target when threads are enabled will not spin\non contention rather than block.", "tree": {"sha": "7dc0878e9eca020d4016ce8cdab57e6f742826fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7dc0878e9eca020d4016ce8cdab57e6f742826fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/72958acd57fb32e0f8027c0d7e76c9a0c7f155d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/72958acd57fb32e0f8027c0d7e76c9a0c7f155d2", "html_url": "https://github.com/rust-lang/rust/commit/72958acd57fb32e0f8027c0d7e76c9a0c7f155d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/72958acd57fb32e0f8027c0d7e76c9a0c7f155d2/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1999a2288123173b2e487865c9a04386173025f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/1999a2288123173b2e487865c9a04386173025f7", "html_url": "https://github.com/rust-lang/rust/commit/1999a2288123173b2e487865c9a04386173025f7"}], "stats": {"total": 95, "additions": 80, "deletions": 15}, "files": [{"sha": "c1af6ec12623c51bf7d9509b398f41e7452157d7", "filename": "src/libstd/sys/wasm/alloc.rs", "status": "modified", "additions": 80, "deletions": 15, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/72958acd57fb32e0f8027c0d7e76c9a0c7f155d2/src%2Flibstd%2Fsys%2Fwasm%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72958acd57fb32e0f8027c0d7e76c9a0c7f155d2/src%2Flibstd%2Fsys%2Fwasm%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Falloc.rs?ref=72958acd57fb32e0f8027c0d7e76c9a0c7f155d2", "patch": "@@ -49,7 +49,6 @@ unsafe impl GlobalAlloc for System {\n \n #[cfg(target_feature = \"atomics\")]\n mod lock {\n-    use crate::arch::wasm32;\n     use crate::sync::atomic::{AtomicI32, Ordering::SeqCst};\n \n     static LOCKED: AtomicI32 = AtomicI32::new(0);\n@@ -61,27 +60,93 @@ mod lock {\n             if LOCKED.swap(1, SeqCst) == 0 {\n                 return DropLock\n             }\n-            unsafe {\n-                let r = wasm32::i32_atomic_wait(\n-                    &LOCKED as *const AtomicI32 as *mut i32,\n-                    1,  // expected value\n-                    -1, // timeout\n-                );\n-                debug_assert!(r == 0 || r == 1);\n-            }\n+            // Ok so here's where things get a little depressing. At this point\n+            // in time we need to synchronously acquire a lock, but we're\n+            // contending with some other thread. Typically we'd execute some\n+            // form of `i32.atomic.wait` like so:\n+            //\n+            //     unsafe {\n+            //         let r = core::arch::wasm32::i32_atomic_wait(\n+            //             &LOCKED as *const AtomicI32 as *mut i32,\n+            //             1,  //     expected value\n+            //             -1, //     timeout\n+            //         );\n+            //         debug_assert!(r == 0 || r == 1);\n+            //     }\n+            //\n+            // Unfortunately though in doing so we would cause issues for the\n+            // main thread. The main thread in a web browser *cannot ever\n+            // block*, no exceptions. This means that the main thread can't\n+            // actually execute the `i32.atomic.wait` instruction.\n+            //\n+            // As a result if we want to work within the context of browsers we\n+            // need to figure out some sort of allocation scheme for the main\n+            // thread where when there's contention on the global malloc lock we\n+            // do... something.\n+            //\n+            // Possible ideas include:\n+            //\n+            // 1. Attempt to acquire the global lock. If it fails, fall back to\n+            //    memory allocation via `memory.grow`. Later just ... somehow\n+            //    ... inject this raw page back into the main allocator as it\n+            //    gets sliced up over time. This strategy has the downside of\n+            //    forcing allocation of a page to happen whenever the main\n+            //    thread contents with other threads, which is unfortunate.\n+            //\n+            // 2. Maintain a form of \"two level\" allocator scheme where the main\n+            //    thread has its own allocator. Somehow this allocator would\n+            //    also be balanced with a global allocator, not only to have\n+            //    allocations cross between threads but also to ensure that the\n+            //    two allocators stay \"balanced\" in terms of free'd memory and\n+            //    such. This, however, seems significantly complicated.\n+            //\n+            // Out of a lack of other ideas, the current strategy implemented\n+            // here is to simply spin. Typical spin loop algorithms have some\n+            // form of \"hint\" here to the CPU that it's what we're doing to\n+            // ensure that the CPU doesn't get too hot, but wasm doesn't have\n+            // such an instruction.\n+            //\n+            // To be clear, spinning here is not a great solution.\n+            // Another thread with the lock may take quite a long time to wake\n+            // up. For example it could be in `memory.grow` or it could be\n+            // evicted from the CPU for a timeslice like 10ms. For these periods\n+            // of time our thread will \"helpfully\" sit here and eat CPU time\n+            // until it itself is evicted or the lock holder finishes. This\n+            // means we're just burning and wasting CPU time to no one's\n+            // benefit.\n+            //\n+            // Spinning does have the nice properties, though, of being\n+            // semantically correct, being fair to all threads for memory\n+            // allocation, and being simple enough to implement.\n+            //\n+            // This will surely (hopefully) be replaced in the future with a\n+            // real memory allocator that can handle the restriction of the main\n+            // thread.\n+            //\n+            //\n+            // FIXME: We can also possibly add an optimization here to detect\n+            // when a thread is the main thread or not and block on all\n+            // non-main-thread threads. Currently, however, we have no way\n+            // of knowing which wasm thread is on the browser main thread, but\n+            // if we could figure out we could at least somewhat mitigate the\n+            // cost of this spinning.\n         }\n     }\n \n     impl Drop for DropLock {\n         fn drop(&mut self) {\n             let r = LOCKED.swap(0, SeqCst);\n             debug_assert_eq!(r, 1);\n-            unsafe {\n-                wasm32::atomic_notify(\n-                    &LOCKED as *const AtomicI32 as *mut i32,\n-                    1, // only one thread\n-                );\n-            }\n+\n+            // Note that due to the above logic we don't actually need to wake\n+            // anyone up, but if we did it'd likely look something like this:\n+            //\n+            //     unsafe {\n+            //         core::arch::wasm32::atomic_notify(\n+            //             &LOCKED as *const AtomicI32 as *mut i32,\n+            //             1, //     only one thread\n+            //         );\n+            //     }\n         }\n     }\n }"}]}