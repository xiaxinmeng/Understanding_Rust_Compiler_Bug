{"sha": "8465daf9825a380d3109ecf9fd79945f5e9b367a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0NjVkYWY5ODI1YTM4MGQzMTA5ZWNmOWZkNzk5NDVmNWU5YjM2N2E=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2019-06-15T23:32:38Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2019-06-26T11:04:06Z"}, "message": "Check for local types in writeback with debug assertions", "tree": {"sha": "d5ce81a612ae8a39ecd9e7a24f59def01101f147", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5ce81a612ae8a39ecd9e7a24f59def01101f147"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8465daf9825a380d3109ecf9fd79945f5e9b367a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8465daf9825a380d3109ecf9fd79945f5e9b367a", "html_url": "https://github.com/rust-lang/rust/commit/8465daf9825a380d3109ecf9fd79945f5e9b367a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8465daf9825a380d3109ecf9fd79945f5e9b367a/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9325181d673445151ac3625dafb1869973fdd1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9325181d673445151ac3625dafb1869973fdd1c", "html_url": "https://github.com/rust-lang/rust/commit/c9325181d673445151ac3625dafb1869973fdd1c"}], "stats": {"total": 37, "additions": 19, "deletions": 18}, "files": [{"sha": "c085df6a6e7ab6536a99192c8db0232fdfe1e83d", "filename": "src/librustc/infer/outlives/free_region_map.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8465daf9825a380d3109ecf9fd79945f5e9b367a/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8465daf9825a380d3109ecf9fd79945f5e9b367a/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs?ref=8465daf9825a380d3109ecf9fd79945f5e9b367a", "patch": "@@ -11,6 +11,10 @@ pub struct FreeRegionMap<'tcx> {\n }\n \n impl<'tcx> FreeRegionMap<'tcx> {\n+    pub fn elements(&self) -> impl Iterator<Item=&Region<'tcx>> {\n+        self.relation.elements()\n+    }\n+\n     pub fn is_empty(&self) -> bool {\n         self.relation.is_empty()\n     }"}, {"sha": "d7cbd1e2e4b476e28a2b87727388997c6b9b4f46", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8465daf9825a380d3109ecf9fd79945f5e9b367a/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8465daf9825a380d3109ecf9fd79945f5e9b367a/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=8465daf9825a380d3109ecf9fd79945f5e9b367a", "patch": "@@ -58,6 +58,10 @@ impl<T: Clone + Debug + Eq + Hash> TransitiveRelation<T> {\n         self.edges.is_empty()\n     }\n \n+    pub fn elements(&self) -> impl Iterator<Item=&T> {\n+        self.elements.iter()\n+    }\n+\n     fn index(&self, a: &T) -> Option<Index> {\n         self.map.get(a).cloned()\n     }"}, {"sha": "28711e32a4c51d5eaf1d26b2329276ec12829a1c", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8465daf9825a380d3109ecf9fd79945f5e9b367a/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8465daf9825a380d3109ecf9fd79945f5e9b367a/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=8465daf9825a380d3109ecf9fd79945f5e9b367a", "patch": "@@ -363,10 +363,8 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     }\n \n     fn visit_free_region_map(&mut self) {\n-        let free_region_map = self.tcx()\n-            .lift_to_global(&self.fcx.tables.borrow().free_region_map);\n-        let free_region_map = free_region_map.expect(\"all regions in free-region-map are global\");\n-        self.tables.free_region_map = free_region_map;\n+        self.tables.free_region_map = self.fcx.tables.borrow().free_region_map.clone();\n+        debug_assert!(!self.tables.free_region_map.elements().any(|r| r.has_local_value()));\n     }\n \n     fn visit_user_provided_tys(&mut self) {\n@@ -381,12 +379,10 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                 local_id,\n             };\n \n-            let c_ty = if let Some(c_ty) = self.tcx().lift_to_global(c_ty) {\n-                c_ty\n-            } else {\n+            if cfg!(debug_assertions) && c_ty.has_local_value() {\n                 span_bug!(\n                     hir_id.to_span(self.fcx.tcx),\n-                    \"writeback: `{:?}` missing from the global type context\",\n+                    \"writeback: `{:?}` is a local value\",\n                     c_ty\n                 );\n             };\n@@ -423,12 +419,10 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         debug_assert_eq!(fcx_tables.local_id_root, self.tables.local_id_root);\n \n         for (&def_id, c_sig) in fcx_tables.user_provided_sigs.iter() {\n-            let c_sig = if let Some(c_sig) = self.tcx().lift_to_global(c_sig) {\n-                c_sig\n-            } else {\n+            if cfg!(debug_assertions) && c_sig.has_local_value() {\n                 span_bug!(\n                     self.fcx.tcx.hir().span_if_local(def_id).unwrap(),\n-                    \"writeback: `{:?}` missing from the global type context\",\n+                    \"writeback: `{:?}` is a local value\",\n                     c_sig\n                 );\n             };\n@@ -743,20 +737,19 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         }\n     }\n \n-    fn resolve<T>(&self, x: &T, span: &dyn Locatable) -> T::Lifted\n+    fn resolve<T>(&self, x: &T, span: &dyn Locatable) -> T\n     where\n-        T: TypeFoldable<'tcx> + ty::Lift<'tcx>,\n+        T: TypeFoldable<'tcx>,\n     {\n         let x = x.fold_with(&mut Resolver::new(self.fcx, span, self.body));\n-        if let Some(lifted) = self.tcx().lift_to_global(&x) {\n-            lifted\n-        } else {\n+        if cfg!(debug_assertions) && x.has_local_value() {\n             span_bug!(\n                 span.to_span(self.fcx.tcx),\n-                \"writeback: `{:?}` missing from the global type context\",\n+                \"writeback: `{:?}` is a local value\",\n                 x\n             );\n         }\n+        x\n     }\n }\n "}]}