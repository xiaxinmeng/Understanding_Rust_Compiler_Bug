{"sha": "28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4ZjliODQwNDJiN2QwZmZkMWY5MTNlOGJhODIzNDhlYmUyM2RkMWI=", "commit": {"author": {"name": "LeSeulArtichaut", "email": "leseulartichaut@gmail.com", "date": "2020-08-03T22:18:29Z"}, "committer": {"name": "LeSeulArtichaut", "email": "leseulartichaut@gmail.com", "date": "2020-09-04T16:27:33Z"}, "message": "`ty.kind` -> `ty.kind()` in rustdoc and clippy", "tree": {"sha": "3ed810f418f8363c0c77a29f770113c55a67d866", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ed810f418f8363c0c77a29f770113c55a67d866"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "html_url": "https://github.com/rust-lang/rust/commit/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/comments", "author": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "committer": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "365b13c0e71f4af148e544a9f35aa0241dc2a56e", "url": "https://api.github.com/repos/rust-lang/rust/commits/365b13c0e71f4af148e544a9f35aa0241dc2a56e", "html_url": "https://github.com/rust-lang/rust/commit/365b13c0e71f4af148e544a9f35aa0241dc2a56e"}], "stats": {"total": 375, "additions": 187, "deletions": 188}, "files": [{"sha": "2d964ac2b9f64c7cae2f4a0bc511cfbb23ff5355", "filename": "clippy_lints/src/atomic_ordering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fatomic_ordering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fatomic_ordering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fatomic_ordering.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -53,7 +53,7 @@ const ATOMIC_TYPES: [&str; 12] = [\n ];\n \n fn type_is_atomic(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    if let ty::Adt(&ty::AdtDef { did, .. }, _) = cx.typeck_results().expr_ty(expr).kind {\n+    if let ty::Adt(&ty::AdtDef { did, .. }, _) = cx.typeck_results().expr_ty(expr).kind() {\n         ATOMIC_TYPES\n             .iter()\n             .any(|ty| match_def_path(cx, did, &[\"core\", \"sync\", \"atomic\", ty]))"}, {"sha": "f18e7e5d99755d425d75ec2eab98574c409cb7a0", "filename": "clippy_lints/src/await_holding_lock.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fawait_holding_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fawait_holding_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fawait_holding_lock.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -67,7 +67,7 @@ impl LateLintPass<'_> for AwaitHoldingLock {\n \n fn check_interior_types(cx: &LateContext<'_>, ty_causes: &[GeneratorInteriorTypeCause<'_>], span: Span) {\n     for ty_cause in ty_causes {\n-        if let rustc_middle::ty::Adt(adt, _) = ty_cause.ty.kind {\n+        if let rustc_middle::ty::Adt(adt, _) = ty_cause.ty.kind() {\n             if is_mutex_guard(cx, adt.did) {\n                 span_lint_and_note(\n                     cx,"}, {"sha": "189c07427ae99c82583ebab999557ebee40844f0", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -63,7 +63,7 @@ impl<'tcx> LateLintPass<'tcx> for ByteCount {\n                                 _ => { return; }\n                             }\n                         };\n-                        if ty::Uint(UintTy::U8) != walk_ptrs_ty(cx.typeck_results().expr_ty(needle)).kind {\n+                        if ty::Uint(UintTy::U8) != *walk_ptrs_ty(cx.typeck_results().expr_ty(needle)).kind() {\n                             return;\n                         }\n                         let haystack = if let ExprKind::MethodCall(ref path, _, ref args, _) ="}, {"sha": "3ee022e4e68a0e5d20357b081eedcb5225b47525", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -123,7 +123,7 @@ impl Constant {\n             (&Self::Str(ref ls), &Self::Str(ref rs)) => Some(ls.cmp(rs)),\n             (&Self::Char(ref l), &Self::Char(ref r)) => Some(l.cmp(r)),\n             (&Self::Int(l), &Self::Int(r)) => {\n-                if let ty::Int(int_ty) = cmp_type.kind {\n+                if let ty::Int(int_ty) = *cmp_type.kind() {\n                     Some(sext(tcx, l, int_ty).cmp(&sext(tcx, r, int_ty)))\n                 } else {\n                     Some(l.cmp(&r))\n@@ -162,7 +162,7 @@ pub fn lit_to_constant(lit: &LitKind, ty: Option<Ty<'_>>) -> Constant {\n             FloatTy::F32 => Constant::F32(is.as_str().parse().unwrap()),\n             FloatTy::F64 => Constant::F64(is.as_str().parse().unwrap()),\n         },\n-        LitKind::Float(ref is, LitFloatType::Unsuffixed) => match ty.expect(\"type of float is known\").kind {\n+        LitKind::Float(ref is, LitFloatType::Unsuffixed) => match ty.expect(\"type of float is known\").kind() {\n             ty::Float(FloatTy::F32) => Constant::F32(is.as_str().parse().unwrap()),\n             ty::Float(FloatTy::F64) => Constant::F64(is.as_str().parse().unwrap()),\n             _ => bug!(),\n@@ -230,7 +230,7 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n             ExprKind::Array(ref vec) => self.multi(vec).map(Constant::Vec),\n             ExprKind::Tup(ref tup) => self.multi(tup).map(Constant::Tuple),\n             ExprKind::Repeat(ref value, _) => {\n-                let n = match self.typeck_results.expr_ty(e).kind {\n+                let n = match self.typeck_results.expr_ty(e).kind() {\n                     ty::Array(_, n) => n.try_eval_usize(self.lcx.tcx, self.lcx.param_env)?,\n                     _ => span_bug!(e.span, \"typeck error\"),\n                 };\n@@ -281,7 +281,7 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n             Bool(b) => Some(Bool(!b)),\n             Int(value) => {\n                 let value = !value;\n-                match ty.kind {\n+                match *ty.kind() {\n                     ty::Int(ity) => Some(Int(unsext(self.lcx.tcx, value as i128, ity))),\n                     ty::Uint(ity) => Some(Int(clip(self.lcx.tcx, value, ity))),\n                     _ => None,\n@@ -295,7 +295,7 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n         use self::Constant::{Int, F32, F64};\n         match *o {\n             Int(value) => {\n-                let ity = match ty.kind {\n+                let ity = match *ty.kind() {\n                     ty::Int(ity) => ity,\n                     _ => return None,\n                 };\n@@ -402,7 +402,7 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n         let l = self.expr(left)?;\n         let r = self.expr(right);\n         match (l, r) {\n-            (Constant::Int(l), Some(Constant::Int(r))) => match self.typeck_results.expr_ty_opt(left)?.kind {\n+            (Constant::Int(l), Some(Constant::Int(r))) => match *self.typeck_results.expr_ty_opt(left)?.kind() {\n                 ty::Int(ity) => {\n                     let l = sext(self.lcx.tcx, l, ity);\n                     let r = sext(self.lcx.tcx, r, ity);\n@@ -495,7 +495,7 @@ pub fn miri_to_const(result: &ty::Const<'_>) -> Option<Constant> {\n     use rustc_middle::mir::interpret::{ConstValue, Scalar};\n     match result.val {\n         ty::ConstKind::Value(ConstValue::Scalar(Scalar::Raw { data: d, .. })) => {\n-            match result.ty.kind {\n+            match result.ty.kind() {\n                 ty::Bool => Some(Constant::Bool(d == 1)),\n                 ty::Uint(_) | ty::Int(_) => Some(Constant::Int(d)),\n                 ty::Float(FloatTy::F32) => Some(Constant::F32(f32::from_bits(\n@@ -505,7 +505,7 @@ pub fn miri_to_const(result: &ty::Const<'_>) -> Option<Constant> {\n                     d.try_into().expect(\"invalid f64 bit representation\"),\n                 ))),\n                 ty::RawPtr(type_and_mut) => {\n-                    if let ty::Uint(_) = type_and_mut.ty.kind {\n+                    if let ty::Uint(_) = type_and_mut.ty.kind() {\n                         return Some(Constant::RawPtr(d));\n                     }\n                     None\n@@ -514,8 +514,8 @@ pub fn miri_to_const(result: &ty::Const<'_>) -> Option<Constant> {\n                 _ => None,\n             }\n         },\n-        ty::ConstKind::Value(ConstValue::Slice { data, start, end }) => match result.ty.kind {\n-            ty::Ref(_, tam, _) => match tam.kind {\n+        ty::ConstKind::Value(ConstValue::Slice { data, start, end }) => match result.ty.kind() {\n+            ty::Ref(_, tam, _) => match tam.kind() {\n                 ty::Str => String::from_utf8(\n                     data.inspect_with_uninit_and_ptr_outside_interpreter(start..end)\n                         .to_owned(),\n@@ -526,8 +526,8 @@ pub fn miri_to_const(result: &ty::Const<'_>) -> Option<Constant> {\n             },\n             _ => None,\n         },\n-        ty::ConstKind::Value(ConstValue::ByRef { alloc, offset: _ }) => match result.ty.kind {\n-            ty::Array(sub_type, len) => match sub_type.kind {\n+        ty::ConstKind::Value(ConstValue::ByRef { alloc, offset: _ }) => match result.ty.kind() {\n+            ty::Array(sub_type, len) => match sub_type.kind() {\n                 ty::Float(FloatTy::F32) => match miri_to_const(len) {\n                     Some(Constant::Int(len)) => alloc\n                         .inspect_with_uninit_and_ptr_outside_interpreter(0..(4 * len as usize))"}, {"sha": "1654df56a9a5bce1900592f941d11372c19a474e", "filename": "clippy_lints/src/default_trait_access.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault_trait_access.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -55,7 +55,7 @@ impl<'tcx> LateLintPass<'tcx> for DefaultTraitAccess {\n                         // TODO: Work out a way to put \"whatever the imported way of referencing\n                         // this type in this file\" rather than a fully-qualified type.\n                         let expr_ty = cx.typeck_results().expr_ty(expr);\n-                        if let ty::Adt(..) = expr_ty.kind {\n+                        if let ty::Adt(..) = expr_ty.kind() {\n                             let replacement = format!(\"{}::default()\", expr_ty);\n                             span_lint_and_sugg(\n                                 cx,"}, {"sha": "bf8e030cc294b25d57699644c8cec428906dcb0e", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -299,20 +299,20 @@ fn check_copy_clone<'tcx>(cx: &LateContext<'tcx>, item: &Item<'_>, trait_ref: &T\n             return;\n         }\n \n-        match ty.kind {\n+        match *ty.kind() {\n             ty::Adt(def, _) if def.is_union() => return,\n \n             // Some types are not Clone by default but could be cloned \u201cby hand\u201d if necessary\n             ty::Adt(def, substs) => {\n                 for variant in &def.variants {\n                     for field in &variant.fields {\n-                        if let ty::FnDef(..) = field.ty(cx.tcx, substs).kind {\n+                        if let ty::FnDef(..) = field.ty(cx.tcx, substs).kind() {\n                             return;\n                         }\n                     }\n                     for subst in substs {\n                         if let ty::subst::GenericArgKind::Type(subst) = subst.unpack() {\n-                            if let ty::Param(_) = subst.kind {\n+                            if let ty::Param(_) = subst.kind() {\n                                 return;\n                             }\n                         }\n@@ -353,7 +353,7 @@ fn check_unsafe_derive_deserialize<'tcx>(\n \n     if_chain! {\n         if match_path(&trait_ref.path, &paths::SERDE_DESERIALIZE);\n-        if let ty::Adt(def, _) = ty.kind;\n+        if let ty::Adt(def, _) = ty.kind();\n         if let Some(local_def_id) = def.did.as_local();\n         let adt_hir_id = cx.tcx.hir().local_def_id_to_hir_id(local_def_id);\n         if !is_allowed(cx, UNSAFE_DERIVE_DESERIALIZE, adt_hir_id);"}, {"sha": "50121a054c79830676aac61494779ce2445b1e66", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -239,9 +239,9 @@ fn lint_for_missing_headers<'tcx>(\n                 let mir = cx.tcx.optimized_mir(def_id.to_def_id());\n                 let ret_ty = mir.return_ty();\n                 if implements_trait(cx, ret_ty, future, &[]);\n-                if let ty::Opaque(_, subs) = ret_ty.kind;\n+                if let ty::Opaque(_, subs) = ret_ty.kind();\n                 if let Some(gen) = subs.types().next();\n-                if let ty::Generator(_, subs, _) = gen.kind;\n+                if let ty::Generator(_, subs, _) = gen.kind();\n                 if is_type_diagnostic_item(cx, subs.as_generator().return_ty(), sym!(result_type));\n                 then {\n                     span_lint("}, {"sha": "cf528d189b4b14220833a1eac46f54c58e666c14", "filename": "clippy_lints/src/drop_forget_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -121,7 +121,7 @@ impl<'tcx> LateLintPass<'tcx> for DropForgetRef {\n                 let arg = &args[0];\n                 let arg_ty = cx.typeck_results().expr_ty(arg);\n \n-                if let ty::Ref(..) = arg_ty.kind {\n+                if let ty::Ref(..) = arg_ty.kind() {\n                     if match_def_path(cx, def_id, &paths::DROP) {\n                         lint = DROP_REF;\n                         msg = DROP_REF_SUMMARY.to_string();"}, {"sha": "fb80f48a9ccf361bbb36bf55ce421bfde402a008", "filename": "clippy_lints/src/enum_clike.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_clike.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -53,12 +53,12 @@ impl<'tcx> LateLintPass<'tcx> for UnportableVariant {\n                         .ok()\n                         .map(|val| rustc_middle::ty::Const::from_value(cx.tcx, val, ty));\n                     if let Some(Constant::Int(val)) = constant.and_then(miri_to_const) {\n-                        if let ty::Adt(adt, _) = ty.kind {\n+                        if let ty::Adt(adt, _) = ty.kind() {\n                             if adt.is_enum() {\n                                 ty = adt.repr.discr_type().to_ty(cx.tcx);\n                             }\n                         }\n-                        match ty.kind {\n+                        match ty.kind() {\n                             ty::Int(IntTy::Isize) => {\n                                 let val = ((val as i128) << 64) >> 64;\n                                 if i32::try_from(val).is_ok() {"}, {"sha": "53df3abbf543744ef1300c6b80ddaef834a2afdb", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -99,7 +99,7 @@ fn check_closure(cx: &LateContext<'_>, expr: &Expr<'_>) {\n \n             let fn_ty = cx.typeck_results().expr_ty(caller);\n \n-            if matches!(fn_ty.kind, ty::FnDef(_, _) | ty::FnPtr(_) | ty::Closure(_, _));\n+            if matches!(fn_ty.kind(), ty::FnDef(_, _) | ty::FnPtr(_) | ty::Closure(_, _));\n \n             if !type_is_unsafe_function(cx, fn_ty);\n \n@@ -173,14 +173,14 @@ fn get_ufcs_type_name(cx: &LateContext<'_>, method_def_id: def_id::DefId, self_a\n }\n \n fn match_borrow_depth(lhs: Ty<'_>, rhs: Ty<'_>) -> bool {\n-    match (&lhs.kind, &rhs.kind) {\n+    match (&lhs.kind(), &rhs.kind()) {\n         (ty::Ref(_, t1, mut1), ty::Ref(_, t2, mut2)) => mut1 == mut2 && match_borrow_depth(&t1, &t2),\n         (l, r) => !matches!((l, r), (ty::Ref(_, _, _), _) | (_, ty::Ref(_, _, _))),\n     }\n }\n \n fn match_types(lhs: Ty<'_>, rhs: Ty<'_>) -> bool {\n-    match (&lhs.kind, &rhs.kind) {\n+    match (&lhs.kind(), &rhs.kind()) {\n         (ty::Bool, ty::Bool)\n         | (ty::Char, ty::Char)\n         | (ty::Int(_), ty::Int(_))\n@@ -194,7 +194,7 @@ fn match_types(lhs: Ty<'_>, rhs: Ty<'_>) -> bool {\n }\n \n fn get_type_name(cx: &LateContext<'_>, ty: Ty<'_>) -> String {\n-    match ty.kind {\n+    match ty.kind() {\n         ty::Adt(t, _) => cx.tcx.def_path_str(t.did),\n         ty::Ref(_, r, _) => get_type_name(cx, &r),\n         _ => ty.to_string(),"}, {"sha": "4240147f498db43a2742f0eb69171043f1ccd970", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -138,10 +138,10 @@ impl<'a, 'tcx> Visitor<'tcx> for DivergenceVisitor<'a, 'tcx> {\n             ExprKind::Continue(_) | ExprKind::Break(_, _) | ExprKind::Ret(_) => self.report_diverging_sub_expr(e),\n             ExprKind::Call(ref func, _) => {\n                 let typ = self.cx.typeck_results().expr_ty(func);\n-                match typ.kind {\n+                match typ.kind() {\n                     ty::FnDef(..) | ty::FnPtr(_) => {\n                         let sig = typ.fn_sig(self.cx.tcx);\n-                        if let ty::Never = self.cx.tcx.erase_late_bound_regions(&sig).output().kind {\n+                        if let ty::Never = self.cx.tcx.erase_late_bound_regions(&sig).output().kind() {\n                             self.report_diverging_sub_expr(e);\n                         }\n                     },"}, {"sha": "69818b4d3c642e1e5c29853c3713aee959473c2e", "filename": "clippy_lints/src/float_equality_without_abs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Ffloat_equality_without_abs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Ffloat_equality_without_abs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloat_equality_without_abs.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -81,8 +81,8 @@ impl<'tcx> LateLintPass<'tcx> for FloatEqualityWithoutAbs {\n             // values of the substractions on the left hand side are of the type float\n             let t_val_l = cx.typeck_results().expr_ty(val_l);\n             let t_val_r = cx.typeck_results().expr_ty(val_r);\n-            if let ty::Float(_) = t_val_l.kind;\n-            if let ty::Float(_) = t_val_r.kind;\n+            if let ty::Float(_) = t_val_l.kind();\n+            if let ty::Float(_) = t_val_r.kind();\n \n             then {\n                 let sug_l = sugg::Sugg::hir(cx, &val_l, \"..\");"}, {"sha": "1fe4461533b36840a3330ed09f72e8a46d3fdda3", "filename": "clippy_lints/src/float_literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Ffloat_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Ffloat_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloat_literal.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -62,7 +62,7 @@ impl<'tcx> LateLintPass<'tcx> for FloatLiteral {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if_chain! {\n             let ty = cx.typeck_results().expr_ty(expr);\n-            if let ty::Float(fty) = ty.kind;\n+            if let ty::Float(fty) = *ty.kind();\n             if let hir::ExprKind::Lit(ref lit) = expr.kind;\n             if let LitKind::Float(sym, lit_float_ty) = lit.node;\n             then {"}, {"sha": "18fea8b34bfd46514e559bbf5437e292e0033f85", "filename": "clippy_lints/src/floating_point_arithmetic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -136,7 +136,7 @@ fn prepare_receiver_sugg<'a>(cx: &LateContext<'_>, mut expr: &'a Expr<'a>) -> Su\n     if_chain! {\n         // if the expression is a float literal and it is unsuffixed then\n         // add a suffix so the suggestion is valid and unambiguous\n-        if let ty::Float(float_ty) = cx.typeck_results().expr_ty(expr).kind;\n+        if let ty::Float(float_ty) = cx.typeck_results().expr_ty(expr).kind();\n         if let ExprKind::Lit(lit) = &expr.kind;\n         if let ast::LitKind::Float(sym, ast::LitFloatType::Unsuffixed) = lit.node;\n         then {"}, {"sha": "8bd85af87682a3027c0b5e7eb3efee27952aca8c", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -91,7 +91,7 @@ fn on_argumentv1_new<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, arms: &\n         if pats.len() == 1;\n         then {\n             let ty = walk_ptrs_ty(cx.typeck_results().pat_ty(&pats[0]));\n-            if ty.kind != rustc_middle::ty::Str && !is_type_diagnostic_item(cx, ty, sym!(string_type)) {\n+            if *ty.kind() != rustc_middle::ty::Str && !is_type_diagnostic_item(cx, ty, sym!(string_type)) {\n                 return None;\n             }\n             if let ExprKind::Lit(ref lit) = format_args.kind {"}, {"sha": "89fde1d509d30b96a69a71909ec25a320f4ca7f1", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -505,7 +505,7 @@ fn is_mutable_pat(cx: &LateContext<'_>, pat: &hir::Pat<'_>, tys: &mut FxHashSet<\n static KNOWN_WRAPPER_TYS: &[&[&str]] = &[&[\"alloc\", \"rc\", \"Rc\"], &[\"std\", \"sync\", \"Arc\"]];\n \n fn is_mutable_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span, tys: &mut FxHashSet<DefId>) -> bool {\n-    match ty.kind {\n+    match *ty.kind() {\n         // primitive types are never mutable\n         ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str => false,\n         ty::Adt(ref adt, ref substs) => {"}, {"sha": "2ab257ca88e3bdedc0794f4ea18ea1c617e0a8ef", "filename": "clippy_lints/src/future_not_send.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Ffuture_not_send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Ffuture_not_send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffuture_not_send.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -61,7 +61,7 @@ impl<'tcx> LateLintPass<'tcx> for FutureNotSend {\n             return;\n         }\n         let ret_ty = utils::return_ty(cx, hir_id);\n-        if let Opaque(id, subst) = ret_ty.kind {\n+        if let Opaque(id, subst) = *ret_ty.kind() {\n             let preds = cx.tcx.predicates_of(id).instantiate(cx.tcx, subst);\n             let mut is_future = false;\n             for p in preds.predicates {"}, {"sha": "8501d34770201b1a80d77210dcb6999bbda9d7be", "filename": "clippy_lints/src/identity_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_op.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -75,7 +75,7 @@ fn is_allowed(cx: &LateContext<'_>, cmp: BinOp, left: &Expr<'_>, right: &Expr<'_\n #[allow(clippy::cast_possible_wrap)]\n fn check(cx: &LateContext<'_>, e: &Expr<'_>, m: i8, span: Span, arg: Span) {\n     if let Some(Constant::Int(v)) = constant_simple(cx, cx.typeck_results(), e) {\n-        let check = match cx.typeck_results().expr_ty(e).kind {\n+        let check = match *cx.typeck_results().expr_ty(e).kind() {\n             ty::Int(ity) => unsext(cx.tcx, -1_i128, ity),\n             ty::Uint(uty) => clip(cx.tcx, !0, uty),\n             _ => return,"}, {"sha": "a28eda8be15a4ec8a129bb44a9aa172fb10cc247", "filename": "clippy_lints/src/indexing_slicing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Findexing_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Findexing_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Findexing_slicing.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -91,7 +91,7 @@ impl<'tcx> LateLintPass<'tcx> for IndexingSlicing {\n             let ty = cx.typeck_results().expr_ty(array);\n             if let Some(range) = higher::range(index) {\n                 // Ranged indexes, i.e., &x[n..m], &x[n..], &x[..n] and &x[..]\n-                if let ty::Array(_, s) = ty.kind {\n+                if let ty::Array(_, s) = ty.kind() {\n                     let size: u128 = if let Some(size) = s.try_eval_usize(cx.tcx, cx.param_env) {\n                         size.into()\n                     } else {\n@@ -141,7 +141,7 @@ impl<'tcx> LateLintPass<'tcx> for IndexingSlicing {\n                 span_lint_and_help(cx, INDEXING_SLICING, expr.span, \"slicing may panic.\", None, help_msg);\n             } else {\n                 // Catchall non-range index, i.e., [n] or [n << m]\n-                if let ty::Array(..) = ty.kind {\n+                if let ty::Array(..) = ty.kind() {\n                     // Index is a constant uint.\n                     if let Some(..) = constant(cx, cx.typeck_results(), index) {\n                         // Let rustc's `const_err` lint handle constant `usize` indexing on arrays."}, {"sha": "025ff86da39d8cc9fd6b117fce951e37f400ebcd", "filename": "clippy_lints/src/large_const_arrays.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Flarge_const_arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Flarge_const_arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_const_arrays.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -51,7 +51,7 @@ impl<'tcx> LateLintPass<'tcx> for LargeConstArrays {\n             if !item.span.from_expansion();\n             if let ItemKind::Const(hir_ty, _) = &item.kind;\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n-            if let ty::Array(element_type, cst) = ty.kind;\n+            if let ty::Array(element_type, cst) = ty.kind();\n             if let ConstKind::Value(val) = cst.val;\n             if let ConstValue::Scalar(element_count) = val;\n             if let Ok(element_count) = element_count.to_machine_usize(&cx.tcx);"}, {"sha": "9fd3780e14e04023423491d9c94cac1994de5b3a", "filename": "clippy_lints/src/large_stack_arrays.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Flarge_stack_arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Flarge_stack_arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_stack_arrays.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -42,7 +42,7 @@ impl<'tcx> LateLintPass<'tcx> for LargeStackArrays {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if_chain! {\n             if let ExprKind::Repeat(_, _) = expr.kind;\n-            if let ty::Array(element_type, cst) = cx.typeck_results().expr_ty(expr).kind;\n+            if let ty::Array(element_type, cst) = cx.typeck_results().expr_ty(expr).kind();\n             if let ConstKind::Value(val) = cst.val;\n             if let ConstValue::Scalar(element_count) = val;\n             if let Ok(element_count) = element_count.to_machine_usize(&cx.tcx);"}, {"sha": "42a98dc963d2084cfe93eca9ac759608bcbfd5d4", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -286,7 +286,7 @@ fn has_is_empty(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     }\n \n     let ty = &walk_ptrs_ty(cx.typeck_results().expr_ty(expr));\n-    match ty.kind {\n+    match ty.kind() {\n         ty::Dynamic(ref tt, ..) => tt.principal().map_or(false, |principal| {\n             cx.tcx\n                 .associated_items(principal.def_id())"}, {"sha": "604a97e3c083565b6f2fdde71e05b164d6c77d41", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -826,7 +826,7 @@ struct FixedOffsetVar<'hir> {\n }\n \n fn is_slice_like<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'_>) -> bool {\n-    let is_slice = match ty.kind {\n+    let is_slice = match ty.kind() {\n         ty::Ref(_, subty, _) => is_slice_like(cx, subty),\n         ty::Slice(..) | ty::Array(..) => true,\n         _ => false,\n@@ -1375,7 +1375,7 @@ fn is_end_eq_array_len<'tcx>(\n     if_chain! {\n         if let ExprKind::Lit(ref lit) = end.kind;\n         if let ast::LitKind::Int(end_int, _) = lit.node;\n-        if let ty::Array(_, arr_len_const) = indexed_ty.kind;\n+        if let ty::Array(_, arr_len_const) = indexed_ty.kind();\n         if let Some(arr_len) = arr_len_const.try_eval_usize(cx.tcx, cx.param_env);\n         then {\n             return match limits {\n@@ -1612,7 +1612,7 @@ fn check_for_loop_over_map_kv<'tcx>(\n     if let PatKind::Tuple(ref pat, _) = pat.kind {\n         if pat.len() == 2 {\n             let arg_span = arg.span;\n-            let (new_pat_span, kind, ty, mutbl) = match cx.typeck_results().expr_ty(arg).kind {\n+            let (new_pat_span, kind, ty, mutbl) = match *cx.typeck_results().expr_ty(arg).kind() {\n                 ty::Ref(_, ty, mutbl) => match (&pat[0].kind, &pat[1].kind) {\n                     (key, _) if pat_is_wild(key, body) => (pat[1].span, \"value\", ty, mutbl),\n                     (_, value) if pat_is_wild(value, body) => (pat[0].span, \"key\", ty, Mutability::Not),\n@@ -1940,7 +1940,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n                 for expr in args {\n                     let ty = self.cx.typeck_results().expr_ty_adjusted(expr);\n                     self.prefer_mutable = false;\n-                    if let ty::Ref(_, _, mutbl) = ty.kind {\n+                    if let ty::Ref(_, _, mutbl) = *ty.kind() {\n                         if mutbl == Mutability::Mut {\n                             self.prefer_mutable = true;\n                         }\n@@ -1952,7 +1952,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n                 let def_id = self.cx.typeck_results().type_dependent_def_id(expr.hir_id).unwrap();\n                 for (ty, expr) in self.cx.tcx.fn_sig(def_id).inputs().skip_binder().iter().zip(args) {\n                     self.prefer_mutable = false;\n-                    if let ty::Ref(_, _, mutbl) = ty.kind {\n+                    if let ty::Ref(_, _, mutbl) = *ty.kind() {\n                         if mutbl == Mutability::Mut {\n                             self.prefer_mutable = true;\n                         }\n@@ -2050,7 +2050,7 @@ fn is_ref_iterable_type(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n \n fn is_iterable_array<'tcx>(ty: Ty<'tcx>, cx: &LateContext<'tcx>) -> bool {\n     // IntoIterator is currently only implemented for array sizes <= 32 in rustc\n-    match ty.kind {\n+    match ty.kind() {\n         ty::Array(_, n) => n\n             .try_eval_usize(cx.tcx, cx.param_env)\n             .map_or(false, |val| (0..=32).contains(&val)),"}, {"sha": "6d1c2ffbfbdd21a21ee450473b3ebfadffda323c", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -70,7 +70,7 @@ impl<'tcx> LateLintPass<'tcx> for MapClone {\n                         match closure_expr.kind {\n                             hir::ExprKind::Unary(hir::UnOp::UnDeref, ref inner) => {\n                                 if ident_eq(name, inner) {\n-                                    if let ty::Ref(.., Mutability::Not) = cx.typeck_results().expr_ty(inner).kind {\n+                                    if let ty::Ref(.., Mutability::Not) = cx.typeck_results().expr_ty(inner).kind() {\n                                         lint(cx, e.span, args[0].span, true);\n                                     }\n                                 }\n@@ -80,7 +80,7 @@ impl<'tcx> LateLintPass<'tcx> for MapClone {\n                                     && match_trait_method(cx, closure_expr, &paths::CLONE_TRAIT) {\n \n                                     let obj_ty = cx.typeck_results().expr_ty(&obj[0]);\n-                                    if let ty::Ref(_, ty, _) = obj_ty.kind {\n+                                    if let ty::Ref(_, ty, _) = obj_ty.kind() {\n                                         let copy = is_copy(cx, ty);\n                                         lint(cx, e.span, args[0].span, copy);\n                                     } else {"}, {"sha": "1f9ae8c931a1ee3aea3cbb5e683987a31ce71252", "filename": "clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -93,7 +93,7 @@ declare_clippy_lint! {\n declare_lint_pass!(MapUnit => [OPTION_MAP_UNIT_FN, RESULT_MAP_UNIT_FN]);\n \n fn is_unit_type(ty: Ty<'_>) -> bool {\n-    match ty.kind {\n+    match ty.kind() {\n         ty::Tuple(slice) => slice.is_empty(),\n         ty::Never => true,\n         _ => false,\n@@ -103,7 +103,7 @@ fn is_unit_type(ty: Ty<'_>) -> bool {\n fn is_unit_function(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> bool {\n     let ty = cx.typeck_results().expr_ty(expr);\n \n-    if let ty::FnDef(id, _) = ty.kind {\n+    if let ty::FnDef(id, _) = *ty.kind() {\n         if let Some(fn_type) = cx.tcx.fn_sig(id).no_bound_vars() {\n             return is_unit_type(fn_type.output());\n         }"}, {"sha": "7ba7397c29cb66797e5fdb8668e133c7825448b6", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -573,7 +573,7 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n             if let QPath::Resolved(_, ref path) = qpath;\n             if let Some(def_id) = path.res.opt_def_id();\n             let ty = cx.tcx.type_of(def_id);\n-            if let ty::Adt(def, _) = ty.kind;\n+            if let ty::Adt(def, _) = ty.kind();\n             if def.is_struct() || def.is_union();\n             if fields.len() == def.non_enum_variant().fields.len();\n \n@@ -621,7 +621,7 @@ fn check_single_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], exp\n         };\n \n         let ty = cx.typeck_results().expr_ty(ex);\n-        if ty.kind != ty::Bool || is_allowed(cx, MATCH_BOOL, ex.hir_id) {\n+        if *ty.kind() != ty::Bool || is_allowed(cx, MATCH_BOOL, ex.hir_id) {\n             check_single_match_single_pattern(cx, ex, arms, expr, els);\n             check_single_match_opt_like(cx, ex, arms, expr, ty, els);\n         }\n@@ -712,7 +712,7 @@ fn check_single_match_opt_like(\n \n fn check_match_bool(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n     // Type of expression is `bool`.\n-    if cx.typeck_results().expr_ty(ex).kind == ty::Bool {\n+    if *cx.typeck_results().expr_ty(ex).kind() == ty::Bool {\n         span_lint_and_then(\n             cx,\n             MATCH_BOOL,\n@@ -860,7 +860,7 @@ fn check_wild_enum_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>])\n         // already covered.\n \n         let mut missing_variants = vec![];\n-        if let ty::Adt(def, _) = ty.kind {\n+        if let ty::Adt(def, _) = ty.kind() {\n             for variant in &def.variants {\n                 missing_variants.push(variant);\n             }\n@@ -914,7 +914,7 @@ fn check_wild_enum_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>])\n \n         let mut message = \"wildcard match will miss any future added variants\";\n \n-        if let ty::Adt(def, _) = ty.kind {\n+        if let ty::Adt(def, _) = ty.kind() {\n             if def.is_variant_list_non_exhaustive() {\n                 message = \"match on non-exhaustive enum doesn't explicitly match all known variants\";\n                 suggestion.push(String::from(\"_\"));\n@@ -1014,11 +1014,11 @@ fn check_match_as_ref(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], exp\n             let input_ty = cx.typeck_results().expr_ty(ex);\n \n             let cast = if_chain! {\n-                if let ty::Adt(_, substs) = input_ty.kind;\n+                if let ty::Adt(_, substs) = input_ty.kind();\n                 let input_ty = substs.type_at(0);\n-                if let ty::Adt(_, substs) = output_ty.kind;\n+                if let ty::Adt(_, substs) = output_ty.kind();\n                 let output_ty = substs.type_at(0);\n-                if let ty::Ref(_, output_ty, _) = output_ty.kind;\n+                if let ty::Ref(_, output_ty, _) = *output_ty.kind();\n                 if input_ty != output_ty;\n                 then {\n                     \".map(|x| x as _)\""}, {"sha": "5dae7efad9763da38ff5e6ce4215715db489e2bc", "filename": "clippy_lints/src/methods/inefficient_to_string.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -46,15 +46,15 @@ pub fn lint<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, arg: &hir::Expr<\n /// Returns whether `ty` specializes `ToString`.\n /// Currently, these are `str`, `String`, and `Cow<'_, str>`.\n fn specializes_tostring(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n-    if let ty::Str = ty.kind {\n+    if let ty::Str = ty.kind() {\n         return true;\n     }\n \n     if is_type_diagnostic_item(cx, ty, sym!(string_type)) {\n         return true;\n     }\n \n-    if let ty::Adt(adt, substs) = ty.kind {\n+    if let ty::Adt(adt, substs) = ty.kind() {\n         match_def_path(cx, adt.did, &paths::COW) && substs.type_at(1).is_str()\n     } else {\n         false"}, {"sha": "a7a3d67515678db2c2c0895b78a41caeda1651bb", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -1534,8 +1534,8 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                     }\n                 }\n \n-                match self_ty.kind {\n-                    ty::Ref(_, ty, _) if ty.kind == ty::Str => {\n+                match self_ty.kind() {\n+                    ty::Ref(_, ty, _) if *ty.kind() == ty::Str => {\n                         for &(method, pos) in &PATTERN_METHODS {\n                             if method_call.ident.name.as_str() == method && args.len() > pos {\n                                 lint_single_char_pattern(cx, expr, &args[pos]);\n@@ -1661,7 +1661,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             }\n \n             // if return type is impl trait, check the associated types\n-            if let ty::Opaque(def_id, _) = ret_ty.kind {\n+            if let ty::Opaque(def_id, _) = *ret_ty.kind() {\n                 // one of the associated types must be Self\n                 for &(predicate, _span) in cx.tcx.predicates_of(def_id).predicates {\n                     if let ty::PredicateAtom::Projection(projection_predicate) = predicate.skip_binders() {\n@@ -1803,7 +1803,7 @@ fn lint_or_fun_call<'tcx>(\n             if path.ident.as_str() == \"len\" {\n                 let ty = walk_ptrs_ty(cx.typeck_results().expr_ty(&args[0]));\n \n-                match ty.kind {\n+                match ty.kind() {\n                     ty::Slice(_) | ty::Array(_, _) => return,\n                     _ => (),\n                 }\n@@ -1910,7 +1910,7 @@ fn lint_expect_fun_call(\n                         && {\n                             let arg_type = cx.typeck_results().expr_ty(&call_args[0]);\n                             let base_type = walk_ptrs_ty(arg_type);\n-                            base_type.kind == ty::Str || is_type_diagnostic_item(cx, base_type, sym!(string_type))\n+                            *base_type.kind() == ty::Str || is_type_diagnostic_item(cx, base_type, sym!(string_type))\n                         }\n                     {\n                         &call_args[0]\n@@ -1931,8 +1931,8 @@ fn lint_expect_fun_call(\n         if is_type_diagnostic_item(cx, arg_ty, sym!(string_type)) {\n             return false;\n         }\n-        if let ty::Ref(_, ty, ..) = arg_ty.kind {\n-            if ty.kind == ty::Str && can_be_static_str(cx, arg) {\n+        if let ty::Ref(_, ty, ..) = arg_ty.kind() {\n+            if *ty.kind() == ty::Str && can_be_static_str(cx, arg) {\n                 return false;\n             }\n         };\n@@ -1948,7 +1948,7 @@ fn lint_expect_fun_call(\n                 if let hir::ExprKind::Path(ref p) = fun.kind {\n                     match cx.qpath_res(p, fun.hir_id) {\n                         hir::def::Res::Def(hir::def::DefKind::Fn | hir::def::DefKind::AssocFn, def_id) => matches!(\n-                            cx.tcx.fn_sig(def_id).output().skip_binder().kind,\n+                            cx.tcx.fn_sig(def_id).output().skip_binder().kind(),\n                             ty::Ref(ty::ReStatic, ..)\n                         ),\n                         _ => false,\n@@ -1962,7 +1962,7 @@ fn lint_expect_fun_call(\n                     .type_dependent_def_id(arg.hir_id)\n                     .map_or(false, |method_id| {\n                         matches!(\n-                            cx.tcx.fn_sig(method_id).output().skip_binder().kind,\n+                            cx.tcx.fn_sig(method_id).output().skip_binder().kind(),\n                             ty::Ref(ty::ReStatic, ..)\n                         )\n                     })\n@@ -2081,8 +2081,8 @@ fn lint_expect_fun_call(\n /// Checks for the `CLONE_ON_COPY` lint.\n fn lint_clone_on_copy(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>, arg_ty: Ty<'_>) {\n     let ty = cx.typeck_results().expr_ty(expr);\n-    if let ty::Ref(_, inner, _) = arg_ty.kind {\n-        if let ty::Ref(_, innermost, _) = inner.kind {\n+    if let ty::Ref(_, inner, _) = arg_ty.kind() {\n+        if let ty::Ref(_, innermost, _) = inner.kind() {\n             span_lint_and_then(\n                 cx,\n                 CLONE_DOUBLE_REF,\n@@ -2093,7 +2093,7 @@ fn lint_clone_on_copy(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Exp\n                     if let Some(snip) = sugg::Sugg::hir_opt(cx, arg) {\n                         let mut ty = innermost;\n                         let mut n = 0;\n-                        while let ty::Ref(_, inner, _) = ty.kind {\n+                        while let ty::Ref(_, inner, _) = ty.kind() {\n                             ty = inner;\n                             n += 1;\n                         }\n@@ -2172,7 +2172,7 @@ fn lint_clone_on_copy(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Exp\n fn lint_clone_on_ref_ptr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>) {\n     let obj_ty = walk_ptrs_ty(cx.typeck_results().expr_ty(arg));\n \n-    if let ty::Adt(_, subst) = obj_ty.kind {\n+    if let ty::Adt(_, subst) = obj_ty.kind() {\n         let caller_type = if is_type_diagnostic_item(cx, obj_ty, sym::Rc) {\n             \"Rc\"\n         } else if is_type_diagnostic_item(cx, obj_ty, sym::Arc) {\n@@ -2202,7 +2202,7 @@ fn lint_string_extend(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::E\n     if let Some(arglists) = method_chain_args(arg, &[\"chars\"]) {\n         let target = &arglists[0][0];\n         let self_ty = walk_ptrs_ty(cx.typeck_results().expr_ty(target));\n-        let ref_str = if self_ty.kind == ty::Str {\n+        let ref_str = if *self_ty.kind() == ty::Str {\n             \"\"\n         } else if is_type_diagnostic_item(cx, self_ty, sym!(string_type)) {\n             \"&\"\n@@ -2238,7 +2238,7 @@ fn lint_extend(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>\n fn lint_cstring_as_ptr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, source: &hir::Expr<'_>, unwrap: &hir::Expr<'_>) {\n     if_chain! {\n         let source_type = cx.typeck_results().expr_ty(source);\n-        if let ty::Adt(def, substs) = source_type.kind;\n+        if let ty::Adt(def, substs) = source_type.kind();\n         if cx.tcx.is_diagnostic_item(sym!(result_type), def.did);\n         if match_type(cx, substs.type_at(0), &paths::CSTRING);\n         then {\n@@ -2412,7 +2412,7 @@ fn lint_iter_next<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, iter_\n         }\n     } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(caller_expr), sym!(vec_type))\n         || matches!(\n-            &walk_ptrs_ty(cx.typeck_results().expr_ty(caller_expr)).kind,\n+            &walk_ptrs_ty(cx.typeck_results().expr_ty(caller_expr)).kind(),\n             ty::Array(_, _)\n         )\n     {\n@@ -2579,7 +2579,7 @@ fn derefs_to_slice<'tcx>(\n     ty: Ty<'tcx>,\n ) -> Option<&'tcx hir::Expr<'tcx>> {\n     fn may_slice<'a>(cx: &LateContext<'a>, ty: Ty<'a>) -> bool {\n-        match ty.kind {\n+        match ty.kind() {\n             ty::Slice(_) => true,\n             ty::Adt(def, _) if def.is_box() => may_slice(cx, ty.boxed_ty()),\n             ty::Adt(..) => is_type_diagnostic_item(cx, ty, sym!(vec_type)),\n@@ -2598,7 +2598,7 @@ fn derefs_to_slice<'tcx>(\n             None\n         }\n     } else {\n-        match ty.kind {\n+        match ty.kind() {\n             ty::Slice(_) => Some(expr),\n             ty::Adt(def, _) if def.is_box() && may_slice(cx, ty.boxed_ty()) => Some(expr),\n             ty::Ref(_, inner, _) => {\n@@ -2692,9 +2692,9 @@ fn lint_map_flatten<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map\n     // lint if caller of `.map().flatten()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n         let map_closure_ty = cx.typeck_results().expr_ty(&map_args[1]);\n-        let is_map_to_option = match map_closure_ty.kind {\n+        let is_map_to_option = match map_closure_ty.kind() {\n             ty::Closure(_, _) | ty::FnDef(_, _) | ty::FnPtr(_) => {\n-                let map_closure_sig = match map_closure_ty.kind {\n+                let map_closure_sig = match map_closure_ty.kind() {\n                     ty::Closure(_, substs) => substs.as_closure().sig(),\n                     _ => map_closure_ty.fn_sig(cx.tcx),\n                 };\n@@ -3164,7 +3164,7 @@ fn lint_chars_cmp(\n             let mut applicability = Applicability::MachineApplicable;\n             let self_ty = walk_ptrs_ty(cx.typeck_results().expr_ty_adjusted(&args[0][0]));\n \n-            if self_ty.kind != ty::Str {\n+            if *self_ty.kind() != ty::Str {\n                 return false;\n             }\n \n@@ -3352,7 +3352,7 @@ fn lint_asref(cx: &LateContext<'_>, expr: &hir::Expr<'_>, call_name: &str, as_re\n \n fn ty_has_iter_method(cx: &LateContext<'_>, self_ref_ty: Ty<'_>) -> Option<(&'static str, &'static str)> {\n     has_iter_method(cx, self_ref_ty).map(|ty_name| {\n-        let mutbl = match self_ref_ty.kind {\n+        let mutbl = match self_ref_ty.kind() {\n             ty::Ref(_, _, mutbl) => mutbl,\n             _ => unreachable!(),\n         };\n@@ -3404,7 +3404,7 @@ fn lint_maybe_uninit(cx: &LateContext<'_>, expr: &hir::Expr<'_>, outer: &hir::Ex\n }\n \n fn is_maybe_uninit_ty_valid(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n-    match ty.kind {\n+    match ty.kind() {\n         ty::Array(ref component, _) => is_maybe_uninit_ty_valid(cx, component),\n         ty::Tuple(ref types) => types.types().all(|ty| is_maybe_uninit_ty_valid(cx, ty)),\n         ty::Adt(ref adt, _) => match_def_path(cx, adt.did, &paths::MEM_MAYBEUNINIT),\n@@ -3531,7 +3531,7 @@ fn lint_option_as_ref_deref<'tcx>(\n \n /// Given a `Result<T, E>` type, return its error type (`E`).\n fn get_error_type<'a>(cx: &LateContext<'_>, ty: Ty<'a>) -> Option<Ty<'a>> {\n-    match ty.kind {\n+    match ty.kind() {\n         ty::Adt(_, substs) if is_type_diagnostic_item(cx, ty, sym!(result_type)) => substs.types().nth(1),\n         _ => None,\n     }\n@@ -3685,7 +3685,7 @@ impl SelfKind {\n             } else if ty.is_box() {\n                 ty.boxed_ty() == parent_ty\n             } else if is_type_diagnostic_item(cx, ty, sym::Rc) || is_type_diagnostic_item(cx, ty, sym::Arc) {\n-                if let ty::Adt(_, substs) = ty.kind {\n+                if let ty::Adt(_, substs) = ty.kind() {\n                     substs.types().next().map_or(false, |t| t == parent_ty)\n                 } else {\n                     false\n@@ -3696,7 +3696,7 @@ impl SelfKind {\n         }\n \n         fn matches_ref<'a>(cx: &LateContext<'a>, mutability: hir::Mutability, parent_ty: Ty<'a>, ty: Ty<'a>) -> bool {\n-            if let ty::Ref(_, t, m) = ty.kind {\n+            if let ty::Ref(_, t, m) = *ty.kind() {\n                 return m == mutability && t == parent_ty;\n             }\n \n@@ -3813,7 +3813,7 @@ fn contains_return(expr: &hir::Expr<'_>) -> bool {\n fn check_pointer_offset(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n     if_chain! {\n         if args.len() == 2;\n-        if let ty::RawPtr(ty::TypeAndMut { ref ty, .. }) = cx.typeck_results().expr_ty(&args[0]).kind;\n+        if let ty::RawPtr(ty::TypeAndMut { ref ty, .. }) = cx.typeck_results().expr_ty(&args[0]).kind();\n         if let Ok(layout) = cx.tcx.layout_of(cx.param_env.and(ty));\n         if layout.is_zst();\n         then {"}, {"sha": "d4a50dd9013f01a8e8862399fc57c67a8275d900", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -561,17 +561,17 @@ fn is_signum(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n }\n \n fn is_float(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    let value = &walk_ptrs_ty(cx.typeck_results().expr_ty(expr)).kind;\n+    let value = &walk_ptrs_ty(cx.typeck_results().expr_ty(expr)).kind();\n \n     if let ty::Array(arr_ty, _) = value {\n-        return matches!(arr_ty.kind, ty::Float(_));\n+        return matches!(arr_ty.kind(), ty::Float(_));\n     };\n \n     matches!(value, ty::Float(_))\n }\n \n fn is_array(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    matches!(&walk_ptrs_ty(cx.typeck_results().expr_ty(expr)).kind, ty::Array(_, _))\n+    matches!(&walk_ptrs_ty(cx.typeck_results().expr_ty(expr)).kind(), ty::Array(_, _))\n }\n \n fn check_to_owned(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>, left: bool) {"}, {"sha": "da3ae1d652f6c515862ebb2c74016b4c7e69c4f0", "filename": "clippy_lints/src/modulo_arithmetic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fmodulo_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fmodulo_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmodulo_arithmetic.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -38,7 +38,7 @@ struct OperandInfo {\n \n fn analyze_operand(operand: &Expr<'_>, cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<OperandInfo> {\n     match constant(cx, cx.typeck_results(), operand) {\n-        Some((Constant::Int(v), _)) => match cx.typeck_results().expr_ty(expr).kind {\n+        Some((Constant::Int(v), _)) => match *cx.typeck_results().expr_ty(expr).kind() {\n             ty::Int(ity) => {\n                 let value = sext(cx.tcx, v, ity);\n                 return Some(OperandInfo {"}, {"sha": "7423107e8f9453fb48906f151988894411a58c83", "filename": "clippy_lints/src/mut_key.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fmut_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fmut_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_key.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -97,7 +97,7 @@ fn check_sig<'tcx>(cx: &LateContext<'tcx>, item_hir_id: hir::HirId, decl: &hir::\n // generics (because the compiler cannot ensure immutability for unknown types).\n fn check_ty<'tcx>(cx: &LateContext<'tcx>, span: Span, ty: Ty<'tcx>) {\n     let ty = walk_ptrs_ty(ty);\n-    if let Adt(def, substs) = ty.kind {\n+    if let Adt(def, substs) = ty.kind() {\n         if [&paths::HASHMAP, &paths::BTREEMAP, &paths::HASHSET, &paths::BTREESET]\n             .iter()\n             .any(|path| match_def_path(cx, def.did, &**path))\n@@ -109,7 +109,7 @@ fn check_ty<'tcx>(cx: &LateContext<'tcx>, span: Span, ty: Ty<'tcx>) {\n }\n \n fn is_mutable_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span) -> bool {\n-    match ty.kind {\n+    match *ty.kind() {\n         RawPtr(TypeAndMut { ty: inner_ty, mutbl }) | Ref(_, inner_ty, mutbl) => {\n             mutbl == hir::Mutability::Mut || is_mutable_type(cx, inner_ty, span)\n         },"}, {"sha": "2f3cdb894f01c666de9fb75cec810b97594deca6", "filename": "clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_mut.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -69,7 +69,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {\n                     expr.span,\n                     \"generally you want to avoid `&mut &mut _` if possible\",\n                 );\n-            } else if let ty::Ref(_, _, hir::Mutability::Mut) = self.cx.typeck_results().expr_ty(e).kind {\n+            } else if let ty::Ref(_, _, hir::Mutability::Mut) = self.cx.typeck_results().expr_ty(e).kind() {\n                 span_lint(\n                     self.cx,\n                     MUT_MUT,"}, {"sha": "3f0b765df1561dc9543984506ea475dca498299a", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -61,11 +61,11 @@ fn check_arguments<'tcx>(\n     name: &str,\n     fn_kind: &str,\n ) {\n-    match type_definition.kind {\n+    match type_definition.kind() {\n         ty::FnDef(..) | ty::FnPtr(_) => {\n             let parameters = type_definition.fn_sig(cx.tcx).skip_binder().inputs();\n             for (argument, parameter) in arguments.iter().zip(parameters.iter()) {\n-                match parameter.kind {\n+                match parameter.kind() {\n                     ty::Ref(_, _, Mutability::Not)\n                     | ty::RawPtr(ty::TypeAndMut {\n                         mutbl: Mutability::Not, .."}, {"sha": "cc635c2a202f6d4da3000d1ee1603a59b253bbe5", "filename": "clippy_lints/src/mutable_debug_assertion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -138,7 +138,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MutArgVisitor<'a, 'tcx> {\n                 if let Some(adj) = self.cx.typeck_results().adjustments().get(expr.hir_id) {\n                     if adj\n                         .iter()\n-                        .any(|a| matches!(a.target.kind, ty::Ref(_, _, Mutability::Mut)))\n+                        .any(|a| matches!(a.target.kind(), ty::Ref(_, _, Mutability::Mut)))\n                     {\n                         self.found = true;\n                         return;"}, {"sha": "ea986874291e020f54c9751689383e1d4551ef3c", "filename": "clippy_lints/src/mutex_atomic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutex_atomic.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -67,7 +67,7 @@ declare_lint_pass!(Mutex => [MUTEX_ATOMIC, MUTEX_INTEGER]);\n impl<'tcx> LateLintPass<'tcx> for Mutex {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         let ty = cx.typeck_results().expr_ty(expr);\n-        if let ty::Adt(_, subst) = ty.kind {\n+        if let ty::Adt(_, subst) = ty.kind() {\n             if is_type_diagnostic_item(cx, ty, sym!(mutex_type)) {\n                 let mutex_param = subst.type_at(0);\n                 if let Some(atomic_name) = get_atomic_name(mutex_param) {\n@@ -76,7 +76,7 @@ impl<'tcx> LateLintPass<'tcx> for Mutex {\n                          behavior and not the internal type, consider using `Mutex<()>`\",\n                         atomic_name\n                     );\n-                    match mutex_param.kind {\n+                    match *mutex_param.kind() {\n                         ty::Uint(t) if t != ast::UintTy::Usize => span_lint(cx, MUTEX_INTEGER, expr.span, &msg),\n                         ty::Int(t) if t != ast::IntTy::Isize => span_lint(cx, MUTEX_INTEGER, expr.span, &msg),\n                         _ => span_lint(cx, MUTEX_ATOMIC, expr.span, &msg),\n@@ -88,7 +88,7 @@ impl<'tcx> LateLintPass<'tcx> for Mutex {\n }\n \n fn get_atomic_name(ty: Ty<'_>) -> Option<&'static str> {\n-    match ty.kind {\n+    match ty.kind() {\n         ty::Bool => Some(\"AtomicBool\"),\n         ty::Uint(_) => Some(\"AtomicUsize\"),\n         ty::Int(_) => Some(\"AtomicIsize\"),"}, {"sha": "b71d5496a37a3e27b610ac5da97cf01279f0fe13", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -46,7 +46,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBorrow {\n             return;\n         }\n         if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, ref inner) = e.kind {\n-            if let ty::Ref(..) = cx.typeck_results().expr_ty(inner).kind {\n+            if let ty::Ref(..) = cx.typeck_results().expr_ty(inner).kind() {\n                 for adj3 in cx.typeck_results().expr_adjustments(e).windows(3) {\n                     if let [Adjustment {\n                         kind: Adjust::Deref(_), ..\n@@ -85,9 +85,9 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBorrow {\n         }\n         if_chain! {\n             if let PatKind::Binding(BindingAnnotation::Ref, .., name, _) = pat.kind;\n-            if let ty::Ref(_, tam, mutbl) = cx.typeck_results().pat_ty(pat).kind;\n+            if let ty::Ref(_, tam, mutbl) = *cx.typeck_results().pat_ty(pat).kind();\n             if mutbl == Mutability::Not;\n-            if let ty::Ref(_, _, mutbl) = tam.kind;\n+            if let ty::Ref(_, _, mutbl) = *tam.kind();\n             // only lint immutable refs, because borrowed `&mut T` cannot be moved out\n             if mutbl == Mutability::Not;\n             then {"}, {"sha": "7e933c674dd781a7093df9eb6c77e7457f6d56c3", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -194,7 +194,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n \n                     // Dereference suggestion\n                     let sugg = |diag: &mut DiagnosticBuilder<'_>| {\n-                        if let ty::Adt(def, ..) = ty.kind {\n+                        if let ty::Adt(def, ..) = ty.kind() {\n                             if let Some(span) = cx.tcx.hir().span_if_local(def.did) {\n                                 if can_type_implement_copy(cx.tcx, cx.param_env, ty).is_ok() {\n                                     diag.span_help(span, \"consider marking this type as `Copy`\");"}, {"sha": "98e9078094a225b0f9acaee37eb4e32c3c231163", "filename": "clippy_lints/src/needless_update.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_update.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -48,7 +48,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessUpdate {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::Struct(_, ref fields, Some(ref base)) = expr.kind {\n             let ty = cx.typeck_results().expr_ty(expr);\n-            if let ty::Adt(def, _) = ty.kind {\n+            if let ty::Adt(def, _) = ty.kind() {\n                 if fields.len() == def.non_enum_variant().fields.len() {\n                     span_lint(\n                         cx,"}, {"sha": "5539331d0460be96f00928833e1eb1300f5f3935", "filename": "clippy_lints/src/pattern_type_mismatch.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fpattern_type_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fpattern_type_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpattern_type_mismatch.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -187,19 +187,19 @@ fn find_first_mismatch<'tcx>(\n     level: Level,\n ) -> Option<(Span, Mutability, Level)> {\n     if let PatKind::Ref(ref sub_pat, _) = pat.kind {\n-        if let TyKind::Ref(_, sub_ty, _) = ty.kind {\n+        if let TyKind::Ref(_, sub_ty, _) = ty.kind() {\n             return find_first_mismatch(cx, sub_pat, sub_ty, Level::Lower);\n         }\n     }\n \n-    if let TyKind::Ref(_, _, mutability) = ty.kind {\n+    if let TyKind::Ref(_, _, mutability) = *ty.kind() {\n         if is_non_ref_pattern(&pat.kind) {\n             return Some((pat.span, mutability, level));\n         }\n     }\n \n     if let PatKind::Struct(ref qpath, ref field_pats, _) = pat.kind {\n-        if let TyKind::Adt(ref adt_def, ref substs_ref) = ty.kind {\n+        if let TyKind::Adt(ref adt_def, ref substs_ref) = ty.kind() {\n             if let Some(variant) = get_variant(adt_def, qpath) {\n                 let field_defs = &variant.fields;\n                 return find_first_mismatch_in_struct(cx, field_pats, field_defs, substs_ref);\n@@ -208,7 +208,7 @@ fn find_first_mismatch<'tcx>(\n     }\n \n     if let PatKind::TupleStruct(ref qpath, ref pats, _) = pat.kind {\n-        if let TyKind::Adt(ref adt_def, ref substs_ref) = ty.kind {\n+        if let TyKind::Adt(ref adt_def, ref substs_ref) = ty.kind() {\n             if let Some(variant) = get_variant(adt_def, qpath) {\n                 let field_defs = &variant.fields;\n                 let ty_iter = field_defs.iter().map(|field_def| field_def.ty(cx.tcx, substs_ref));\n@@ -218,7 +218,7 @@ fn find_first_mismatch<'tcx>(\n     }\n \n     if let PatKind::Tuple(ref pats, _) = pat.kind {\n-        if let TyKind::Tuple(..) = ty.kind {\n+        if let TyKind::Tuple(..) = ty.kind() {\n             return find_first_mismatch_in_tuple(cx, pats, ty.tuple_fields());\n         }\n     }"}, {"sha": "6b1c848a9467b2693334d12d6dad98f224128478", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -180,7 +180,7 @@ fn check_fn(cx: &LateContext<'_>, decl: &FnDecl<'_>, fn_id: HirId, opt_body_id:\n             }\n         }\n \n-        if let ty::Ref(_, ty, Mutability::Not) = ty.kind {\n+        if let ty::Ref(_, ty, Mutability::Not) = ty.kind() {\n             if is_type_diagnostic_item(cx, ty, sym!(vec_type)) {\n                 let mut ty_snippet = None;\n                 if_chain! {"}, {"sha": "cc492917b9dafdd96b4cc89afa26ddfde4f4b635", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -281,7 +281,7 @@ fn check_reversed_empty_range(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {\n         if let Some(higher::Range { start: Some(start), end: Some(end), limits }) = higher::range(expr);\n         let ty = cx.typeck_results().expr_ty(start);\n-        if let ty::Int(_) | ty::Uint(_) = ty.kind;\n+        if let ty::Int(_) | ty::Uint(_) = ty.kind();\n         if let Some((start_idx, _)) = constant(cx, cx.typeck_results(), start);\n         if let Some((end_idx, _)) = constant(cx, cx.typeck_results(), end);\n         if let Some(ordering) = Constant::partial_cmp(cx.tcx, ty, &start_idx, &end_idx);"}, {"sha": "4773731e3272fc3b3e315525c10d34264302c7ea", "filename": "clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -124,7 +124,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClone {\n                 continue;\n             }\n \n-            if let ty::Adt(ref def, _) = arg_ty.kind {\n+            if let ty::Adt(ref def, _) = arg_ty.kind() {\n                 if match_def_path(cx, def.did, &paths::MEM_MANUALLY_DROP) {\n                     continue;\n                 }\n@@ -287,7 +287,7 @@ fn is_call_with_ref_arg<'tcx>(\n         if let mir::TerminatorKind::Call { func, args, destination, .. } = kind;\n         if args.len() == 1;\n         if let mir::Operand::Move(mir::Place { local, .. }) = &args[0];\n-        if let ty::FnDef(def_id, _) = func.ty(&*mir, cx.tcx).kind;\n+        if let ty::FnDef(def_id, _) = *func.ty(&*mir, cx.tcx).kind();\n         if let (inner_ty, 1) = walk_ptrs_ty_depth(args[0].ty(&*mir, cx.tcx));\n         if !is_copy(cx, inner_ty);\n         then {"}, {"sha": "087d50c90e671236b090fa44266aeb3a0cda2e07", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -165,7 +165,7 @@ fn check_local<'tcx>(cx: &LateContext<'tcx>, local: &'tcx Local<'_>, bindings: &\n \n fn is_binding(cx: &LateContext<'_>, pat_id: HirId) -> bool {\n     let var_ty = cx.typeck_results().node_type_opt(pat_id);\n-    var_ty.map_or(false, |var_ty| !matches!(var_ty.kind, ty::Adt(..)))\n+    var_ty.map_or(false, |var_ty| !matches!(var_ty.kind(), ty::Adt(..)))\n }\n \n fn check_pat<'tcx>("}, {"sha": "47a73ca9a24cf7eb5b46f6ee03d377700d48ec34", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -196,8 +196,8 @@ fn check_for_slice<'a>(cx: &LateContext<'_>, lhs1: &'a Expr<'_>, lhs2: &'a Expr<\n             if eq_expr_value(cx, lhs1, lhs2) {\n                 let ty = walk_ptrs_ty(cx.typeck_results().expr_ty(lhs1));\n \n-                if matches!(ty.kind, ty::Slice(_))\n-                    || matches!(ty.kind, ty::Array(_, _))\n+                if matches!(ty.kind(), ty::Slice(_))\n+                    || matches!(ty.kind(), ty::Array(_, _))\n                     || is_type_diagnostic_item(cx, ty, sym!(vec_type))\n                     || is_type_diagnostic_item(cx, ty, sym!(vecdeque_type))\n                 {"}, {"sha": "eeda39bfa20874fc2fd856767de67dd698a2fe39", "filename": "clippy_lints/src/to_digit_is_some.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fto_digit_is_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fto_digit_is_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fto_digit_is_some.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -44,7 +44,7 @@ impl<'tcx> LateLintPass<'tcx> for ToDigitIsSome {\n                             if let [char_arg, radix_arg] = &**to_digit_args;\n                             if to_digits_path.ident.name.as_str() == \"to_digit\";\n                             let char_arg_ty = cx.typeck_results().expr_ty_adjusted(char_arg);\n-                            if char_arg_ty.kind == ty::Char;\n+                            if *char_arg_ty.kind() == ty::Char;\n                             then {\n                                 Some((true, char_arg, radix_arg))\n                             } else {"}, {"sha": "87c5408c78588cf62bf04d1e482dc2a0cfa035c6", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -338,7 +338,7 @@ impl<'tcx> LateLintPass<'tcx> for Transmute {\n                 let from_ty = cx.typeck_results().expr_ty(&args[0]);\n                 let to_ty = cx.typeck_results().expr_ty(e);\n \n-                match (&from_ty.kind, &to_ty.kind) {\n+                match (&from_ty.kind(), &to_ty.kind()) {\n                     _ if from_ty == to_ty => span_lint(\n                         cx,\n                         USELESS_TRANSMUTE,\n@@ -446,7 +446,7 @@ impl<'tcx> LateLintPass<'tcx> for Transmute {\n                             &format!(\"transmute from a `{}` to a `char`\", from_ty),\n                             |diag| {\n                                 let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n-                                let arg = if let ty::Int(_) = from_ty.kind {\n+                                let arg = if let ty::Int(_) = from_ty.kind() {\n                                     arg.as_ty(ast::UintTy::U32.name_str())\n                                 } else {\n                                     arg\n@@ -462,8 +462,8 @@ impl<'tcx> LateLintPass<'tcx> for Transmute {\n                     },\n                     (ty::Ref(_, ty_from, from_mutbl), ty::Ref(_, ty_to, to_mutbl)) => {\n                         if_chain! {\n-                            if let (&ty::Slice(slice_ty), &ty::Str) = (&ty_from.kind, &ty_to.kind);\n-                            if let ty::Uint(ast::UintTy::U8) = slice_ty.kind;\n+                            if let (&ty::Slice(slice_ty), &ty::Str) = (&ty_from.kind(), &ty_to.kind());\n+                            if let ty::Uint(ast::UintTy::U8) = slice_ty.kind();\n                             if from_mutbl == to_mutbl;\n                             then {\n                                 let postfix = if *from_mutbl == Mutability::Mut {\n@@ -555,7 +555,7 @@ impl<'tcx> LateLintPass<'tcx> for Transmute {\n                         &format!(\"transmute from a `{}` to a `{}`\", from_ty, to_ty),\n                         |diag| {\n                             let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n-                            let arg = if let ty::Int(int_ty) = from_ty.kind {\n+                            let arg = if let ty::Int(int_ty) = from_ty.kind() {\n                                 arg.as_ty(format!(\n                                     \"u{}\",\n                                     int_ty.bit_width().map_or_else(|| \"size\".to_string(), |v| v.to_string())\n@@ -601,7 +601,7 @@ impl<'tcx> LateLintPass<'tcx> for Transmute {\n                             arg = sugg::Sugg::NonParen(format!(\"{}.to_bits()\", arg.maybe_par()).into());\n \n                             // cast the result of `to_bits` if `to_ty` is signed\n-                            arg = if let ty::Int(int_ty) = to_ty.kind {\n+                            arg = if let ty::Int(int_ty) = to_ty.kind() {\n                                 arg.as_ty(int_ty.name_str().to_string())\n                             } else {\n                                 arg"}, {"sha": "1f06d2dbe9144e0beb56fc0e33a090ac70e3457c", "filename": "clippy_lints/src/trivially_copy_pass_by_ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -83,7 +83,7 @@ impl<'tcx> TriviallyCopyPassByRef {\n         // Use lifetimes to determine if we're returning a reference to the\n         // argument. In that case we can't switch to pass-by-value as the\n         // argument will not live long enough.\n-        let output_lts = match fn_sig.output().kind {\n+        let output_lts = match *fn_sig.output().kind() {\n             ty::Ref(output_lt, _, _) => vec![output_lt],\n             ty::Adt(_, substs) => substs.regions().collect(),\n             _ => vec![],\n@@ -97,7 +97,7 @@ impl<'tcx> TriviallyCopyPassByRef {\n             }\n \n             if_chain! {\n-                if let ty::Ref(input_lt, ty, Mutability::Not) = ty.kind;\n+                if let ty::Ref(input_lt, ty, Mutability::Not) = ty.kind();\n                 if !output_lts.contains(&input_lt);\n                 if is_copy(cx, ty);\n                 if let Some(size) = cx.layout_of(ty).ok().map(|l| l.size.bytes());"}, {"sha": "3e747ec4ad9e25dcdb5b4bdc2fc03c9fb813bf55", "filename": "clippy_lints/src/try_err.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Ftry_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Ftry_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftry_err.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -132,7 +132,7 @@ fn find_return_type<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx ExprKind<'_>) -> O\n /// Extracts the error type from Result<T, E>.\n fn result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n     if_chain! {\n-        if let ty::Adt(_, subst) = ty.kind;\n+        if let ty::Adt(_, subst) = ty.kind();\n         if is_type_diagnostic_item(cx, ty, sym!(result_type));\n         let err_ty = subst.type_at(1);\n         then {\n@@ -146,11 +146,11 @@ fn result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'t\n /// Extracts the error type from Poll<Result<T, E>>.\n fn poll_result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n     if_chain! {\n-        if let ty::Adt(def, subst) = ty.kind;\n+        if let ty::Adt(def, subst) = ty.kind();\n         if match_def_path(cx, def.did, &paths::POLL);\n         let ready_ty = subst.type_at(0);\n \n-        if let ty::Adt(ready_def, ready_subst) = ready_ty.kind;\n+        if let ty::Adt(ready_def, ready_subst) = ready_ty.kind();\n         if cx.tcx.is_diagnostic_item(sym!(result_type), ready_def.did);\n         let err_ty = ready_subst.type_at(1);\n \n@@ -165,15 +165,15 @@ fn poll_result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<\n /// Extracts the error type from Poll<Option<Result<T, E>>>.\n fn poll_option_result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n     if_chain! {\n-        if let ty::Adt(def, subst) = ty.kind;\n+        if let ty::Adt(def, subst) = ty.kind();\n         if match_def_path(cx, def.did, &paths::POLL);\n         let ready_ty = subst.type_at(0);\n \n-        if let ty::Adt(ready_def, ready_subst) = ready_ty.kind;\n+        if let ty::Adt(ready_def, ready_subst) = ready_ty.kind();\n         if cx.tcx.is_diagnostic_item(sym!(option_type), ready_def.did);\n         let some_ty = ready_subst.type_at(0);\n \n-        if let ty::Adt(some_def, some_subst) = some_ty.kind;\n+        if let ty::Adt(some_def, some_subst) = some_ty.kind();\n         if cx.tcx.is_diagnostic_item(sym!(result_type), some_def.did);\n         let err_ty = some_subst.type_at(1);\n "}, {"sha": "c82deaa43b2667eff7dbe47c708ef7c2a0a4f839", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -907,7 +907,7 @@ fn is_questionmark_desugar_marked_call(expr: &Expr<'_>) -> bool {\n }\n \n fn is_unit(ty: Ty<'_>) -> bool {\n-    matches!(ty.kind, ty::Tuple(slice) if slice.is_empty())\n+    matches!(ty.kind(), ty::Tuple(slice) if slice.is_empty())\n }\n \n fn is_unit_literal(expr: &Expr<'_>) -> bool {\n@@ -1134,7 +1134,7 @@ declare_clippy_lint! {\n /// Returns the size in bits of an integral type.\n /// Will return 0 if the type is not an int or uint variant\n fn int_ty_to_nbits(typ: Ty<'_>, tcx: TyCtxt<'_>) -> u64 {\n-    match typ.kind {\n+    match typ.kind() {\n         ty::Int(i) => match i {\n             IntTy::Isize => tcx.data_layout.pointer_size.bits(),\n             IntTy::I8 => 8,\n@@ -1156,7 +1156,7 @@ fn int_ty_to_nbits(typ: Ty<'_>, tcx: TyCtxt<'_>) -> u64 {\n }\n \n fn is_isize_or_usize(typ: Ty<'_>) -> bool {\n-    matches!(typ.kind, ty::Int(IntTy::Isize) | ty::Uint(UintTy::Usize))\n+    matches!(typ.kind(), ty::Int(IntTy::Isize) | ty::Uint(UintTy::Usize))\n }\n \n fn span_precision_loss_lint(cx: &LateContext<'_>, expr: &Expr<'_>, cast_from: Ty<'_>, cast_to_f64: bool) {\n@@ -1248,7 +1248,7 @@ fn check_loss_of_sign(cx: &LateContext<'_>, expr: &Expr<'_>, op: &Expr<'_>, cast\n     if_chain! {\n         if let Some((const_val, _)) = const_val;\n         if let Constant::Int(n) = const_val;\n-        if let ty::Int(ity) = cast_from.kind;\n+        if let ty::Int(ity) = *cast_from.kind();\n         if sext(cx.tcx, n, ity) >= 0;\n         then {\n             return\n@@ -1381,7 +1381,7 @@ declare_lint_pass!(Casts => [\n // Check if the given type is either `core::ffi::c_void` or\n // one of the platform specific `libc::<platform>::c_void` of libc.\n fn is_c_void(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n-    if let ty::Adt(adt, _) = ty.kind {\n+    if let ty::Adt(adt, _) = ty.kind() {\n         let names = cx.get_def_path(adt.did);\n \n         if names.is_empty() {\n@@ -1397,7 +1397,7 @@ fn is_c_void(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n /// Returns the mantissa bits wide of a fp type.\n /// Will return 0 if the type is not a fp\n fn fp_ty_mantissa_nbits(typ: Ty<'_>) -> u32 {\n-    match typ.kind {\n+    match typ.kind() {\n         ty::Float(FloatTy::F32) => 23,\n         ty::Float(FloatTy::F64) | ty::Infer(InferTy::FloatVar(_)) => 52,\n         _ => 0,\n@@ -1437,7 +1437,7 @@ impl<'tcx> LateLintPass<'tcx> for Casts {\n                 match lit.node {\n                     LitKind::Int(_, LitIntType::Unsuffixed) | LitKind::Float(_, LitFloatType::Unsuffixed) => {},\n                     _ => {\n-                        if cast_from.kind == cast_to.kind && !in_external_macro(cx.sess(), expr.span) {\n+                        if cast_from.kind() == cast_to.kind() && !in_external_macro(cx.sess(), expr.span) {\n                             span_lint(\n                                 cx,\n                                 UNNECESSARY_CAST,\n@@ -1470,7 +1470,7 @@ fn lint_numeric_casts<'tcx>(\n     match (cast_from.is_integral(), cast_to.is_integral()) {\n         (true, false) => {\n             let from_nbits = int_ty_to_nbits(cast_from, cx.tcx);\n-            let to_nbits = if let ty::Float(FloatTy::F32) = cast_to.kind {\n+            let to_nbits = if let ty::Float(FloatTy::F32) = cast_to.kind() {\n                 32\n             } else {\n                 64\n@@ -1507,15 +1507,15 @@ fn lint_numeric_casts<'tcx>(\n             check_lossless(cx, expr, cast_expr, cast_from, cast_to);\n         },\n         (false, false) => {\n-            if let (&ty::Float(FloatTy::F64), &ty::Float(FloatTy::F32)) = (&cast_from.kind, &cast_to.kind) {\n+            if let (&ty::Float(FloatTy::F64), &ty::Float(FloatTy::F32)) = (&cast_from.kind(), &cast_to.kind()) {\n                 span_lint(\n                     cx,\n                     CAST_POSSIBLE_TRUNCATION,\n                     expr.span,\n                     \"casting `f64` to `f32` may truncate the value\",\n                 );\n             }\n-            if let (&ty::Float(FloatTy::F32), &ty::Float(FloatTy::F64)) = (&cast_from.kind, &cast_to.kind) {\n+            if let (&ty::Float(FloatTy::F32), &ty::Float(FloatTy::F64)) = (&cast_from.kind(), &cast_to.kind()) {\n                 span_lossless_lint(cx, expr, cast_expr, cast_from, cast_to);\n             }\n         },\n@@ -1524,8 +1524,8 @@ fn lint_numeric_casts<'tcx>(\n \n fn lint_cast_ptr_alignment<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, cast_from: Ty<'tcx>, cast_to: Ty<'tcx>) {\n     if_chain! {\n-        if let ty::RawPtr(from_ptr_ty) = &cast_from.kind;\n-        if let ty::RawPtr(to_ptr_ty) = &cast_to.kind;\n+        if let ty::RawPtr(from_ptr_ty) = &cast_from.kind();\n+        if let ty::RawPtr(to_ptr_ty) = &cast_to.kind();\n         if let Ok(from_layout) = cx.layout_of(from_ptr_ty.ty);\n         if let Ok(to_layout) = cx.layout_of(to_ptr_ty.ty);\n         if from_layout.align.abi < to_layout.align.abi;\n@@ -1558,11 +1558,11 @@ fn lint_fn_to_numeric_cast(\n     cast_to: Ty<'_>,\n ) {\n     // We only want to check casts to `ty::Uint` or `ty::Int`\n-    match cast_to.kind {\n+    match cast_to.kind() {\n         ty::Uint(_) | ty::Int(..) => { /* continue on */ },\n         _ => return,\n     }\n-    match cast_from.kind {\n+    match cast_from.kind() {\n         ty::FnDef(..) | ty::FnPtr(_) => {\n             let mut applicability = Applicability::MaybeIncorrect;\n             let from_snippet = snippet_with_applicability(cx, cast_expr.span, \"x\", &mut applicability);\n@@ -1581,7 +1581,7 @@ fn lint_fn_to_numeric_cast(\n                     format!(\"{} as usize\", from_snippet),\n                     applicability,\n                 );\n-            } else if cast_to.kind != ty::Uint(UintTy::Usize) {\n+            } else if *cast_to.kind() != ty::Uint(UintTy::Usize) {\n                 span_lint_and_sugg(\n                     cx,\n                     FN_TO_NUMERIC_CAST,\n@@ -1798,7 +1798,7 @@ impl<'tcx> LateLintPass<'tcx> for CharLitAsU8 {\n             if let ExprKind::Cast(e, _) = &expr.kind;\n             if let ExprKind::Lit(l) = &e.kind;\n             if let LitKind::Char(c) = l.node;\n-            if ty::Uint(UintTy::U8) == cx.typeck_results().expr_ty(expr).kind;\n+            if ty::Uint(UintTy::U8) == *cx.typeck_results().expr_ty(expr).kind();\n             then {\n                 let mut applicability = Applicability::MachineApplicable;\n                 let snippet = snippet_with_applicability(cx, e.span, \"'x'\", &mut applicability);\n@@ -1937,7 +1937,7 @@ fn detect_extreme_expr<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Op\n \n     let cv = constant(cx, cx.typeck_results(), expr)?.0;\n \n-    let which = match (&ty.kind, cv) {\n+    let which = match (ty.kind(), cv) {\n         (&ty::Bool, Constant::Bool(false)) | (&ty::Uint(_), Constant::Int(0)) => Minimum,\n         (&ty::Int(ity), Constant::Int(i)) if i == unsext(cx.tcx, i128::MIN >> (128 - int_bits(cx.tcx, ity)), ity) => {\n             Minimum\n@@ -2071,7 +2071,7 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext<'_>, expr: &'a Expr<'_>) ->\n         if cx.layout_of(pre_cast_ty).ok().map(|l| l.size) == cx.layout_of(cast_ty).ok().map(|l| l.size) {\n             return None;\n         }\n-        match pre_cast_ty.kind {\n+        match pre_cast_ty.kind() {\n             ty::Int(int_ty) => Some(match int_ty {\n                 IntTy::I8 => (FullInt::S(i128::from(i8::MIN)), FullInt::S(i128::from(i8::MAX))),\n                 IntTy::I16 => (FullInt::S(i128::from(i16::MIN)), FullInt::S(i128::from(i16::MAX))),\n@@ -2098,7 +2098,7 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext<'_>, expr: &'a Expr<'_>) ->\n fn node_as_const_fullint<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<FullInt> {\n     let val = constant(cx, cx.typeck_results(), expr)?.0;\n     if let Constant::Int(const_int) = val {\n-        match cx.typeck_results().expr_ty(expr).kind {\n+        match *cx.typeck_results().expr_ty(expr).kind() {\n             ty::Int(ity) => Some(FullInt::S(sext(cx.tcx, const_int, ity))),\n             ty::Uint(_) => Some(FullInt::U(const_int)),\n             _ => None,\n@@ -2601,7 +2601,7 @@ impl<'tcx> LateLintPass<'tcx> for RefToMut {\n             if let TyKind::Ptr(MutTy { mutbl: Mutability::Mut, .. }) = t.kind;\n             if let ExprKind::Cast(e, t) = &e.kind;\n             if let TyKind::Ptr(MutTy { mutbl: Mutability::Not, .. }) = t.kind;\n-            if let ty::Ref(..) = cx.typeck_results().node_type(e.hir_id).kind;\n+            if let ty::Ref(..) = cx.typeck_results().node_type(e.hir_id).kind();\n             then {\n                 span_lint(\n                     cx,"}, {"sha": "0d5a5017331b78bf0e6a16f6ebe276e19559d24f", "filename": "clippy_lints/src/unit_return_expecting_ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -110,7 +110,7 @@ fn get_args_to_check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Ve\n fn check_arg<'tcx>(cx: &LateContext<'tcx>, arg: &'tcx Expr<'tcx>) -> Option<(Span, Option<Span>)> {\n     if_chain! {\n         if let ExprKind::Closure(_, _fn_decl, body_id, span, _) = arg.kind;\n-        if let ty::Closure(_def_id, substs) = &cx.typeck_results().node_type(arg.hir_id).kind;\n+        if let ty::Closure(_def_id, substs) = &cx.typeck_results().node_type(arg.hir_id).kind();\n         let ret_ty = substs.as_closure().sig().output();\n         let ty = cx.tcx.erase_late_bound_regions(&ret_ty);\n         if ty.is_unit();"}, {"sha": "9582c162e77b274734c7e976bc1e17735fde48f5", "filename": "clippy_lints/src/unnamed_address.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Funnamed_address.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Funnamed_address.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnamed_address.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -65,14 +65,14 @@ impl LateLintPass<'_> for UnnamedAddress {\n         }\n \n         fn is_trait_ptr(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-            match cx.typeck_results().expr_ty_adjusted(expr).kind {\n+            match cx.typeck_results().expr_ty_adjusted(expr).kind() {\n                 ty::RawPtr(ty::TypeAndMut { ty, .. }) => ty.is_trait(),\n                 _ => false,\n             }\n         }\n \n         fn is_fn_def(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-            matches!(cx.typeck_results().expr_ty(expr).kind, ty::FnDef(..))\n+            matches!(cx.typeck_results().expr_ty(expr).kind(), ty::FnDef(..))\n         }\n \n         if_chain! {"}, {"sha": "8b00d29acb52c65ed79b28035419930d2d00d17d", "filename": "clippy_lints/src/unnecessary_sort_by.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -230,7 +230,7 @@ fn key_returns_borrow(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     if let Some(def_id) = utils::fn_def_id(cx, expr) {\n         let output = cx.tcx.fn_sig(def_id).output();\n         let ty = output.skip_binder();\n-        return matches!(ty.kind, ty::Ref(..))\n+        return matches!(ty.kind(), ty::Ref(..))\n             || ty.walk().any(|arg| matches!(arg.unpack(), GenericArgKind::Lifetime(_)));\n     }\n "}, {"sha": "615440e15f384bca82bff66cdda8796cf7e5266a", "filename": "clippy_lints/src/useless_conversion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuseless_conversion.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -107,7 +107,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                         let a = cx.typeck_results().expr_ty(e);\n                         let b = cx.typeck_results().expr_ty(&args[0]);\n                         if is_type_diagnostic_item(cx, a, sym!(result_type));\n-                        if let ty::Adt(_, substs) = a.kind;\n+                        if let ty::Adt(_, substs) = a.kind();\n                         if let Some(a_type) = substs.types().next();\n                         if TyS::same_type(a_type, b);\n \n@@ -137,7 +137,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                         if_chain! {\n                             if match_def_path(cx, def_id, &paths::TRY_FROM);\n                             if is_type_diagnostic_item(cx, a, sym!(result_type));\n-                            if let ty::Adt(_, substs) = a.kind;\n+                            if let ty::Adt(_, substs) = a.kind();\n                             if let Some(a_type) = substs.types().next();\n                             if TyS::same_type(a_type, b);\n "}, {"sha": "45add9ab284d2c05e7b2c02279fbe35648e61391", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -129,23 +129,23 @@ pub fn is_wild<'tcx>(pat: &impl std::ops::Deref<Target = Pat<'tcx>>) -> bool {\n \n /// Checks if type is struct, enum or union type with the given def path.\n pub fn match_type(cx: &LateContext<'_>, ty: Ty<'_>, path: &[&str]) -> bool {\n-    match ty.kind {\n+    match ty.kind() {\n         ty::Adt(adt, _) => match_def_path(cx, adt.did, path),\n         _ => false,\n     }\n }\n \n /// Checks if the type is equal to a diagnostic item\n pub fn is_type_diagnostic_item(cx: &LateContext<'_>, ty: Ty<'_>, diag_item: Symbol) -> bool {\n-    match ty.kind {\n+    match ty.kind() {\n         ty::Adt(adt, _) => cx.tcx.is_diagnostic_item(diag_item, adt.did),\n         _ => false,\n     }\n }\n \n /// Checks if the type is equal to a lang item\n pub fn is_type_lang_item(cx: &LateContext<'_>, ty: Ty<'_>, lang_item: hir::LangItem) -> bool {\n-    match ty.kind {\n+    match ty.kind() {\n         ty::Adt(adt, _) => cx.tcx.lang_items().require(lang_item).unwrap() == adt.did,\n         _ => false,\n     }\n@@ -754,7 +754,7 @@ pub fn walk_ptrs_hir_ty<'tcx>(ty: &'tcx hir::Ty<'tcx>) -> &'tcx hir::Ty<'tcx> {\n \n /// Returns the base type for references and raw pointers.\n pub fn walk_ptrs_ty(ty: Ty<'_>) -> Ty<'_> {\n-    match ty.kind {\n+    match ty.kind() {\n         ty::Ref(_, ty, _) => walk_ptrs_ty(ty),\n         _ => ty,\n     }\n@@ -764,7 +764,7 @@ pub fn walk_ptrs_ty(ty: Ty<'_>) -> Ty<'_> {\n /// depth.\n pub fn walk_ptrs_ty_depth(ty: Ty<'_>) -> (Ty<'_>, usize) {\n     fn inner(ty: Ty<'_>, depth: usize) -> (Ty<'_>, usize) {\n-        match ty.kind {\n+        match ty.kind() {\n             ty::Ref(_, ty, _) => inner(ty, depth + 1),\n             _ => (ty, depth),\n         }\n@@ -877,7 +877,7 @@ pub fn contains_ty(ty: Ty<'_>, other_ty: Ty<'_>) -> bool {\n \n /// Returns `true` if the given type is an `unsafe` function.\n pub fn type_is_unsafe_function<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n-    match ty.kind {\n+    match ty.kind() {\n         ty::FnDef(..) | ty::FnPtr(_) => ty.fn_sig(cx.tcx).unsafety() == Unsafety::Unsafe,\n         _ => false,\n     }\n@@ -942,7 +942,7 @@ pub fn is_refutable(cx: &LateContext<'_>, pat: &Pat<'_>) -> bool {\n             is_enum_variant(cx, qpath, pat.hir_id) || are_refutable(cx, pats.iter().map(|pat| &**pat))\n         },\n         PatKind::Slice(ref head, ref middle, ref tail) => {\n-            match &cx.typeck_results().node_type(pat.hir_id).kind {\n+            match &cx.typeck_results().node_type(pat.hir_id).kind() {\n                 ty::Slice(..) => {\n                     // [..] is the only irrefutable slice pattern.\n                     !head.is_empty() || middle.is_none() || !tail.is_empty()\n@@ -1156,12 +1156,12 @@ pub fn has_iter_method(cx: &LateContext<'_>, probably_ref_ty: Ty<'_>) -> Option<\n         &paths::RECEIVER,\n     ];\n \n-    let ty_to_check = match probably_ref_ty.kind {\n+    let ty_to_check = match probably_ref_ty.kind() {\n         ty::Ref(_, ty_to_check, _) => ty_to_check,\n         _ => probably_ref_ty,\n     };\n \n-    let def_id = match ty_to_check.kind {\n+    let def_id = match ty_to_check.kind() {\n         ty::Array(..) => return Some(\"array\"),\n         ty::Slice(..) => return Some(\"slice\"),\n         ty::Adt(adt, _) => adt.did,\n@@ -1277,7 +1277,7 @@ pub fn must_use_attr(attrs: &[Attribute]) -> Option<&Attribute> {\n \n // Returns whether the type has #[must_use] attribute\n pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n-    match ty.kind {\n+    match ty.kind() {\n         ty::Adt(ref adt, _) => must_use_attr(&cx.tcx.get_attrs(adt.did)).is_some(),\n         ty::Foreign(ref did) => must_use_attr(&cx.tcx.get_attrs(*did)).is_some(),\n         ty::Slice(ref ty)\n@@ -1409,9 +1409,9 @@ pub fn run_lints(cx: &LateContext<'_>, lints: &[&'static Lint], id: HirId) -> bo\n /// Returns true iff the given type is a primitive (a bool or char, any integer or floating-point\n /// number type, a str, or an array, slice, or tuple of those types).\n pub fn is_recursively_primitive_type(ty: Ty<'_>) -> bool {\n-    match ty.kind {\n+    match ty.kind() {\n         ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str => true,\n-        ty::Ref(_, inner, _) if inner.kind == ty::Str => true,\n+        ty::Ref(_, inner, _) if *inner.kind() == ty::Str => true,\n         ty::Array(inner_type, _) | ty::Slice(inner_type) => is_recursively_primitive_type(inner_type),\n         ty::Tuple(inner_types) => inner_types.types().all(is_recursively_primitive_type),\n         _ => false,\n@@ -1423,24 +1423,23 @@ pub fn is_recursively_primitive_type(ty: Ty<'_>) -> bool {\n /// `is_recursively_primitive_type` function) and None otherwise.\n pub fn is_slice_of_primitives(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<String> {\n     let expr_type = cx.typeck_results().expr_ty_adjusted(expr);\n-    let expr_kind = &expr_type.kind;\n+    let expr_kind = expr_type.kind();\n     let is_primitive = match expr_kind {\n-        ty::Slice(ref element_type)\n-        | ty::Ref(\n-            _,\n-            ty::TyS {\n-                kind: ty::Slice(ref element_type),\n-                ..\n-            },\n-            _,\n-        ) => is_recursively_primitive_type(element_type),\n+        ty::Slice(element_type) => is_recursively_primitive_type(element_type),\n+        ty::Ref(_, inner_ty, _) if matches!(inner_ty.kind(), &ty::Slice(_)) => {\n+            if let ty::Slice(element_type) = inner_ty.kind() {\n+                is_recursively_primitive_type(element_type)\n+            } else {\n+                unreachable!()\n+            }\n+        }\n         _ => false,\n     };\n \n     if is_primitive {\n         // if we have wrappers like Array, Slice or Tuple, print these\n         // and get the type enclosed in the slice ref\n-        match expr_type.peel_refs().walk().nth(1).unwrap().expect_ty().kind {\n+        match expr_type.peel_refs().walk().nth(1).unwrap().expect_ty().kind() {\n             ty::Slice(..) => return Some(\"slice\".into()),\n             ty::Array(..) => return Some(\"array\".into()),\n             ty::Tuple(..) => return Some(\"tuple\".into()),"}, {"sha": "149cceb39dd9903cc2625d0ccf1508f8f96f94be", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=28f9b84042b7d0ffd1f913e8ba82348ebe23dd1b", "patch": "@@ -44,8 +44,8 @@ impl<'tcx> LateLintPass<'tcx> for UselessVec {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         // search for `&vec![_]` expressions where the adjusted type is `&[_]`\n         if_chain! {\n-            if let ty::Ref(_, ty, _) = cx.typeck_results().expr_ty_adjusted(expr).kind;\n-            if let ty::Slice(..) = ty.kind;\n+            if let ty::Ref(_, ty, _) = cx.typeck_results().expr_ty_adjusted(expr).kind();\n+            if let ty::Slice(..) = ty.kind();\n             if let ExprKind::AddrOf(BorrowKind::Ref, _, ref addressee) = expr.kind;\n             if let Some(vec_args) = higher::vec_macro(cx, addressee);\n             then {\n@@ -127,7 +127,7 @@ fn size_of(cx: &LateContext<'_>, expr: &Expr<'_>) -> u64 {\n \n /// Returns the item type of the vector (i.e., the `T` in `Vec<T>`).\n fn vec_type(ty: Ty<'_>) -> Ty<'_> {\n-    if let ty::Adt(_, substs) = ty.kind {\n+    if let ty::Adt(_, substs) = ty.kind() {\n         substs.type_at(0)\n     } else {\n         panic!(\"The type of `vec!` is a not a struct?\");"}]}