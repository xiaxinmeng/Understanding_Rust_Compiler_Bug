{"sha": "84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0YWQ5NWJlNzBkM2ExYjA2ZWQ1MzdlNGU3ZWMwYzhlMTA4NmNiMzY=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2021-01-28T06:09:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-01-28T06:09:06Z"}, "message": "Rollup merge of #81062 - sexxi-goose:precise_capture_diagnostics, r=nikomatsakis\n\nImprove diagnostics for Precise Capture\n\nThis is just the capture analysis part and borrow checker logging will updated as part of rust-lang/project-rfc-2229#8\n\nCloses rust-lang/project-rfc-2229#22", "tree": {"sha": "145cd2a0e5fc77116cbab6a22882d17417bb970c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/145cd2a0e5fc77116cbab6a22882d17417bb970c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgElUDCRBK7hj4Ov3rIwAAdHIIAAPwp0bN9VVbKnlGQ/yz1vyx\n8X4Ikv/mfclJoxpiN2z3LxRKH+zNJ/k/IIBkiyyCC7f8mH+vGGfBsv1NaqO9EVv0\nlxAiPEwAGVOWz5Jl5fYqaFmDNnivBWlFyT04+V7OzI+AEBvud/eYYPzyCxTdQ/9C\nvfo/mIK+PEEaj0w/mhZvy3dN0y/D1J4xHLLlyixDK6+603iDjH+pLABnbTlxi6c9\nt5cWAWxJXjihwGW5Hqmmyjy4A6c+T2CWAPKgUD3AVSc3taMxRo6bl7f9SR1t91Xf\n041Ol+V2Rg7PZ1rMTo2l+wCLWRdTxX0eLrBxrq2lZte6PovWfQMaHY5w0N+8Oqw=\n=SGKm\n-----END PGP SIGNATURE-----\n", "payload": "tree 145cd2a0e5fc77116cbab6a22882d17417bb970c\nparent 98226638fd014ec7786878a0b102448f3530bcdb\nparent cf71d83bd22a9aac4757f9bc144b42f3bbff6aae\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1611814146 +0900\ncommitter GitHub <noreply@github.com> 1611814146 +0900\n\nRollup merge of #81062 - sexxi-goose:precise_capture_diagnostics, r=nikomatsakis\n\nImprove diagnostics for Precise Capture\n\nThis is just the capture analysis part and borrow checker logging will updated as part of rust-lang/project-rfc-2229#8\n\nCloses rust-lang/project-rfc-2229#22\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36", "html_url": "https://github.com/rust-lang/rust/commit/84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98226638fd014ec7786878a0b102448f3530bcdb", "url": "https://api.github.com/repos/rust-lang/rust/commits/98226638fd014ec7786878a0b102448f3530bcdb", "html_url": "https://github.com/rust-lang/rust/commit/98226638fd014ec7786878a0b102448f3530bcdb"}, {"sha": "cf71d83bd22a9aac4757f9bc144b42f3bbff6aae", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf71d83bd22a9aac4757f9bc144b42f3bbff6aae", "html_url": "https://github.com/rust-lang/rust/commit/cf71d83bd22a9aac4757f9bc144b42f3bbff6aae"}], "stats": {"total": 804, "additions": 773, "deletions": 31}, "files": [{"sha": "8e8caa46c3802edc8ad0f3964f6f77b6ba895ddf", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36", "patch": "@@ -712,8 +712,20 @@ pub fn place_to_string_for_capture(tcx: TyCtxt<'tcx>, place: &HirPlace<'tcx>) ->\n pub struct CaptureInfo<'tcx> {\n     /// Expr Id pointing to use that resulted in selecting the current capture kind\n     ///\n+    /// Eg:\n+    /// ```rust,no_run\n+    /// let mut t = (0,1);\n+    ///\n+    /// let c = || {\n+    ///     println!(\"{}\",t); // L1\n+    ///     t.1 = 4; // L2\n+    /// };\n+    /// ```\n+    /// `capture_kind_expr_id` will point to the use on L2 and `path_expr_id` will point to the\n+    /// use on L1.\n+    ///\n     /// If the user doesn't enable feature `capture_disjoint_fields` (RFC 2229) then, it is\n-    /// possible that we don't see the use of a particular place resulting in expr_id being\n+    /// possible that we don't see the use of a particular place resulting in capture_kind_expr_id being\n     /// None. In such case we fallback on uvpars_mentioned for span.\n     ///\n     /// Eg:\n@@ -727,7 +739,12 @@ pub struct CaptureInfo<'tcx> {\n     ///\n     /// In this example, if `capture_disjoint_fields` is **not** set, then x will be captured,\n     /// but we won't see it being used during capture analysis, since it's essentially a discard.\n-    pub expr_id: Option<hir::HirId>,\n+    pub capture_kind_expr_id: Option<hir::HirId>,\n+    /// Expr Id pointing to use that resulted the corresponding place being captured\n+    ///\n+    /// See `capture_kind_expr_id` for example.\n+    ///\n+    pub path_expr_id: Option<hir::HirId>,\n \n     /// Capture mode that was selected\n     pub capture_kind: UpvarCapture<'tcx>,"}, {"sha": "6b2cba62fa6b7eca6d531c20042dce460b883792", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 124, "deletions": 25, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36", "patch": "@@ -42,7 +42,7 @@ use rustc_infer::infer::UpvarRegion;\n use rustc_middle::hir::place::{Place, PlaceBase, PlaceWithHirId, ProjectionKind};\n use rustc_middle::ty::{self, Ty, TyCtxt, UpvarSubsts};\n use rustc_span::sym;\n-use rustc_span::{Span, Symbol};\n+use rustc_span::{MultiSpan, Span, Symbol};\n \n /// Describe the relationship between the paths of two places\n /// eg:\n@@ -135,7 +135,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                     let upvar_id = ty::UpvarId::new(var_hir_id, local_def_id);\n                     let capture_kind = self.init_capture_kind(capture_clause, upvar_id, span);\n-                    let info = ty::CaptureInfo { expr_id: None, capture_kind };\n+                    let info = ty::CaptureInfo {\n+                        capture_kind_expr_id: None,\n+                        path_expr_id: None,\n+                        capture_kind,\n+                    };\n \n                     capture_information.insert(place, info);\n                 }\n@@ -308,8 +312,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         if let Some(capture_kind) = upvar_capture_map.get(&upvar_id) {\n                             // upvar_capture_map only stores the UpvarCapture (CaptureKind),\n                             // so we create a fake capture info with no expression.\n-                            let fake_capture_info =\n-                                ty::CaptureInfo { expr_id: None, capture_kind: *capture_kind };\n+                            let fake_capture_info = ty::CaptureInfo {\n+                                capture_kind_expr_id: None,\n+                                path_expr_id: None,\n+                                capture_kind: *capture_kind,\n+                            };\n                             determine_capture_info(fake_capture_info, capture_info).capture_kind\n                         } else {\n                             capture_info.capture_kind\n@@ -359,20 +366,44 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ///\n     /// ```\n     /// {\n-    ///       Place(base: hir_id_s, projections: [], ....) -> (hir_id_L5, ByValue),\n-    ///       Place(base: hir_id_p, projections: [Field(0, 0)], ...) -> (hir_id_L2, ByRef(MutBorrow))\n-    ///       Place(base: hir_id_p, projections: [Field(1, 0)], ...) -> (hir_id_L3, ByRef(ImmutBorrow))\n-    ///       Place(base: hir_id_p, projections: [], ...) -> (hir_id_L4, ByRef(ImmutBorrow))\n+    ///       Place(base: hir_id_s, projections: [], ....) -> {\n+    ///                                                            capture_kind_expr: hir_id_L5,\n+    ///                                                            path_expr_id: hir_id_L5,\n+    ///                                                            capture_kind: ByValue\n+    ///                                                       },\n+    ///       Place(base: hir_id_p, projections: [Field(0, 0)], ...) -> {\n+    ///                                                                     capture_kind_expr: hir_id_L2,\n+    ///                                                                     path_expr_id: hir_id_L2,\n+    ///                                                                     capture_kind: ByValue\n+    ///                                                                 },\n+    ///       Place(base: hir_id_p, projections: [Field(1, 0)], ...) -> {\n+    ///                                                                     capture_kind_expr: hir_id_L3,\n+    ///                                                                     path_expr_id: hir_id_L3,\n+    ///                                                                     capture_kind: ByValue\n+    ///                                                                 },\n+    ///       Place(base: hir_id_p, projections: [], ...) -> {\n+    ///                                                          capture_kind_expr: hir_id_L4,\n+    ///                                                          path_expr_id: hir_id_L4,\n+    ///                                                          capture_kind: ByValue\n+    ///                                                      },\n     /// ```\n     ///\n     /// After the min capture analysis, we get:\n     /// ```\n     /// {\n     ///       hir_id_s -> [\n-    ///            Place(base: hir_id_s, projections: [], ....) -> (hir_id_L4, ByValue)\n+    ///            Place(base: hir_id_s, projections: [], ....) -> {\n+    ///                                                                capture_kind_expr: hir_id_L5,\n+    ///                                                                path_expr_id: hir_id_L5,\n+    ///                                                                capture_kind: ByValue\n+    ///                                                            },\n     ///       ],\n     ///       hir_id_p -> [\n-    ///            Place(base: hir_id_p, projections: [], ...) -> (hir_id_L2, ByRef(MutBorrow)),\n+    ///            Place(base: hir_id_p, projections: [], ...) -> {\n+    ///                                                               capture_kind_expr: hir_id_L2,\n+    ///                                                               path_expr_id: hir_id_L4,\n+    ///                                                               capture_kind: ByValue\n+    ///                                                           },\n     ///       ],\n     /// ```\n     fn compute_min_captures(\n@@ -425,8 +456,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // current place is ancestor of possible_descendant\n                     PlaceAncestryRelation::Ancestor => {\n                         descendant_found = true;\n+                        let backup_path_expr_id = updated_capture_info.path_expr_id;\n+\n                         updated_capture_info =\n                             determine_capture_info(updated_capture_info, possible_descendant.info);\n+\n+                        // we need to keep the ancestor's `path_expr_id`\n+                        updated_capture_info.path_expr_id = backup_path_expr_id;\n                         false\n                     }\n \n@@ -441,9 +477,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // current place is descendant of possible_ancestor\n                         PlaceAncestryRelation::Descendant => {\n                             ancestor_found = true;\n+                            let backup_path_expr_id = possible_ancestor.info.path_expr_id;\n                             possible_ancestor.info =\n                                 determine_capture_info(possible_ancestor.info, capture_info);\n \n+                            // we need to keep the ancestor's `path_expr_id`\n+                            possible_ancestor.info.path_expr_id = backup_path_expr_id;\n+\n                             // Only one ancestor of the current place will be in the list.\n                             break;\n                         }\n@@ -518,7 +558,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let capture_str = construct_capture_info_string(self.tcx, place, capture_info);\n                 let output_str = format!(\"Capturing {}\", capture_str);\n \n-                let span = capture_info.expr_id.map_or(closure_span, |e| self.tcx.hir().span(e));\n+                let span =\n+                    capture_info.path_expr_id.map_or(closure_span, |e| self.tcx.hir().span(e));\n                 diag.span_note(span, &output_str);\n             }\n             diag.emit();\n@@ -542,9 +583,32 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             construct_capture_info_string(self.tcx, place, capture_info);\n                         let output_str = format!(\"Min Capture {}\", capture_str);\n \n-                        let span =\n-                            capture_info.expr_id.map_or(closure_span, |e| self.tcx.hir().span(e));\n-                        diag.span_note(span, &output_str);\n+                        if capture.info.path_expr_id != capture.info.capture_kind_expr_id {\n+                            let path_span = capture_info\n+                                .path_expr_id\n+                                .map_or(closure_span, |e| self.tcx.hir().span(e));\n+                            let capture_kind_span = capture_info\n+                                .capture_kind_expr_id\n+                                .map_or(closure_span, |e| self.tcx.hir().span(e));\n+\n+                            let mut multi_span: MultiSpan =\n+                                MultiSpan::from_spans(vec![path_span, capture_kind_span]);\n+\n+                            let capture_kind_label =\n+                                construct_capture_kind_reason_string(self.tcx, place, capture_info);\n+                            let path_label = construct_path_string(self.tcx, place);\n+\n+                            multi_span.push_span_label(path_span, path_label);\n+                            multi_span.push_span_label(capture_kind_span, capture_kind_label);\n+\n+                            diag.span_note(multi_span, &output_str);\n+                        } else {\n+                            let span = capture_info\n+                                .path_expr_id\n+                                .map_or(closure_span, |e| self.tcx.hir().span(e));\n+\n+                            diag.span_note(span, &output_str);\n+                        };\n                     }\n                 }\n                 diag.emit();\n@@ -642,7 +706,8 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n         );\n \n         let capture_info = ty::CaptureInfo {\n-            expr_id: Some(diag_expr_id),\n+            capture_kind_expr_id: Some(diag_expr_id),\n+            path_expr_id: Some(diag_expr_id),\n             capture_kind: ty::UpvarCapture::ByValue(Some(usage_span)),\n         };\n \n@@ -762,7 +827,8 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n             let new_upvar_borrow = ty::UpvarBorrow { kind, region: curr_upvar_borrow.region };\n \n             let capture_info = ty::CaptureInfo {\n-                expr_id: Some(diag_expr_id),\n+                capture_kind_expr_id: Some(diag_expr_id),\n+                path_expr_id: Some(diag_expr_id),\n                 capture_kind: ty::UpvarCapture::ByRef(new_upvar_borrow),\n             };\n             let updated_info = determine_capture_info(curr_capture_info, capture_info);\n@@ -824,7 +890,11 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n                 self.fcx.init_capture_kind(self.capture_clause, upvar_id, self.closure_span);\n \n             let expr_id = Some(diag_expr_id);\n-            let capture_info = ty::CaptureInfo { expr_id, capture_kind };\n+            let capture_info = ty::CaptureInfo {\n+                capture_kind_expr_id: expr_id,\n+                path_expr_id: expr_id,\n+                capture_kind,\n+            };\n \n             debug!(\"Capturing new place {:?}, capture_info={:?}\", place_with_id, capture_info);\n \n@@ -890,11 +960,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n     }\n }\n \n-fn construct_capture_info_string(\n-    tcx: TyCtxt<'_>,\n-    place: &Place<'tcx>,\n-    capture_info: &ty::CaptureInfo<'tcx>,\n-) -> String {\n+fn construct_place_string(tcx: TyCtxt<'_>, place: &Place<'tcx>) -> String {\n     let variable_name = match place.base {\n         PlaceBase::Upvar(upvar_id) => var_name(tcx, upvar_id.var_path.hir_id).to_string(),\n         _ => bug!(\"Capture_information should only contain upvars\"),\n@@ -914,11 +980,42 @@ fn construct_capture_info_string(\n         projections_str.push_str(proj.as_str());\n     }\n \n+    format!(\"{}[{}]\", variable_name, projections_str)\n+}\n+\n+fn construct_capture_kind_reason_string(\n+    tcx: TyCtxt<'_>,\n+    place: &Place<'tcx>,\n+    capture_info: &ty::CaptureInfo<'tcx>,\n+) -> String {\n+    let place_str = construct_place_string(tcx, &place);\n+\n     let capture_kind_str = match capture_info.capture_kind {\n         ty::UpvarCapture::ByValue(_) => \"ByValue\".into(),\n         ty::UpvarCapture::ByRef(borrow) => format!(\"{:?}\", borrow.kind),\n     };\n-    format!(\"{}[{}] -> {}\", variable_name, projections_str, capture_kind_str)\n+\n+    format!(\"{} captured as {} here\", place_str, capture_kind_str)\n+}\n+\n+fn construct_path_string(tcx: TyCtxt<'_>, place: &Place<'tcx>) -> String {\n+    let place_str = construct_place_string(tcx, &place);\n+\n+    format!(\"{} used here\", place_str)\n+}\n+\n+fn construct_capture_info_string(\n+    tcx: TyCtxt<'_>,\n+    place: &Place<'tcx>,\n+    capture_info: &ty::CaptureInfo<'tcx>,\n+) -> String {\n+    let place_str = construct_place_string(tcx, &place);\n+\n+    let capture_kind_str = match capture_info.capture_kind {\n+        ty::UpvarCapture::ByValue(_) => \"ByValue\".into(),\n+        ty::UpvarCapture::ByRef(borrow) => format!(\"{:?}\", borrow.kind),\n+    };\n+    format!(\"{} -> {}\", place_str, capture_kind_str)\n }\n \n fn var_name(tcx: TyCtxt<'_>, var_hir_id: hir::HirId) -> Symbol {\n@@ -930,7 +1027,9 @@ fn var_name(tcx: TyCtxt<'_>, var_hir_id: hir::HirId) -> Symbol {\n /// (Note: CaptureInfo contains CaptureKind and an expression that led to capture it in that way)\n ///\n /// If both `CaptureKind`s are considered equivalent, then the CaptureInfo is selected based\n-/// on the `CaptureInfo` containing an associated expression id.\n+/// on the `CaptureInfo` containing an associated `capture_kind_expr_id`.\n+///\n+/// It is the caller's duty to figure out which path_expr_id to use.\n ///\n /// If both the CaptureKind and Expression are considered to be equivalent,\n /// then `CaptureInfo` A is preferred. This can be useful in cases where we want to priortize\n@@ -981,7 +1080,7 @@ fn determine_capture_info(\n     };\n \n     if eq_capture_kind {\n-        match (capture_info_a.expr_id, capture_info_b.expr_id) {\n+        match (capture_info_a.capture_kind_expr_id, capture_info_b.capture_kind_expr_id) {\n             (Some(_), _) | (None, None) => capture_info_a,\n             (None, Some(_)) => capture_info_b,\n         }"}, {"sha": "b6d740a4fdb57c8b93e9f579dbbda88153984465", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36", "patch": "@@ -348,7 +348,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                 let min_list_wb = min_list\n                     .iter()\n                     .map(|captured_place| {\n-                        let locatable = captured_place.info.expr_id.unwrap_or(\n+                        let locatable = captured_place.info.path_expr_id.unwrap_or(\n                             self.tcx().hir().local_def_id_to_hir_id(closure_def_id.expect_local()),\n                         );\n "}, {"sha": "bd2c266d93dca6a8c94e4c22b59f97b7a53b9096", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36", "patch": "@@ -630,7 +630,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                         PlaceBase::Local(*var_hir_id)\n                     };\n                     let place_with_id = PlaceWithHirId::new(\n-                        capture_info.expr_id.unwrap_or(closure_expr.hir_id),\n+                        capture_info.path_expr_id.unwrap_or(closure_expr.hir_id),\n                         place.base_ty,\n                         place_base,\n                         place.projections.clone(),"}, {"sha": "4368c830e1c612b8162e5780bd544b462b1d294a", "filename": "src/test/ui/closures/2229_closure_analysis/capture-analysis-1.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-1.rs?ref=84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36", "patch": "@@ -0,0 +1,35 @@\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![feature(rustc_attrs)]\n+\n+#[derive(Debug)]\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+\n+fn main() {\n+    let p = Point { x: 10, y: 10 };\n+    let q = Point { x: 10, y: 10 };\n+\n+    let c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ First Pass analysis includes:\n+    //~| Min Capture analysis includes:\n+        println!(\"{:?}\", p);\n+        //~^ NOTE: Capturing p[] -> ImmBorrow\n+        //~| NOTE: Min Capture p[] -> ImmBorrow\n+        println!(\"{:?}\", p.x);\n+        //~^ NOTE: Capturing p[(0, 0)] -> ImmBorrow\n+\n+        println!(\"{:?}\", q.x);\n+        //~^ NOTE: Capturing q[(0, 0)] -> ImmBorrow\n+        println!(\"{:?}\", q);\n+        //~^ NOTE: Capturing q[] -> ImmBorrow\n+        //~| NOTE: Min Capture q[] -> ImmBorrow\n+    };\n+}"}, {"sha": "09255343af0e8bc3fa95efb0a1b0f281ce76b657", "filename": "src/test/ui/closures/2229_closure_analysis/capture-analysis-1.stderr", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-1.stderr?ref=84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36", "patch": "@@ -0,0 +1,77 @@\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/capture-analysis-1.rs:17:13\n+   |\n+LL |     let c = #[rustc_capture_analysis]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/capture-analysis-1.rs:1:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error: First Pass analysis includes:\n+  --> $DIR/capture-analysis-1.rs:20:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         println!(\"{:?}\", p);\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing p[] -> ImmBorrow\n+  --> $DIR/capture-analysis-1.rs:23:26\n+   |\n+LL |         println!(\"{:?}\", p);\n+   |                          ^\n+note: Capturing p[(0, 0)] -> ImmBorrow\n+  --> $DIR/capture-analysis-1.rs:26:26\n+   |\n+LL |         println!(\"{:?}\", p.x);\n+   |                          ^^^\n+note: Capturing q[(0, 0)] -> ImmBorrow\n+  --> $DIR/capture-analysis-1.rs:29:26\n+   |\n+LL |         println!(\"{:?}\", q.x);\n+   |                          ^^^\n+note: Capturing q[] -> ImmBorrow\n+  --> $DIR/capture-analysis-1.rs:31:26\n+   |\n+LL |         println!(\"{:?}\", q);\n+   |                          ^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/capture-analysis-1.rs:20:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         println!(\"{:?}\", p);\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture p[] -> ImmBorrow\n+  --> $DIR/capture-analysis-1.rs:23:26\n+   |\n+LL |         println!(\"{:?}\", p);\n+   |                          ^\n+note: Min Capture q[] -> ImmBorrow\n+  --> $DIR/capture-analysis-1.rs:31:26\n+   |\n+LL |         println!(\"{:?}\", q);\n+   |                          ^\n+\n+error: aborting due to 3 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "ab7fce6a43099eb887dc713b969e69b0c12c295c", "filename": "src/test/ui/closures/2229_closure_analysis/capture-analysis-2.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-2.rs?ref=84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36", "patch": "@@ -0,0 +1,30 @@\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![feature(rustc_attrs)]\n+\n+#[derive(Debug)]\n+struct Point {\n+    x: String,\n+    y: i32,\n+}\n+\n+fn main() {\n+    let mut p = Point { x: String::new(), y: 10 };\n+\n+    let c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ First Pass analysis includes:\n+    //~| Min Capture analysis includes:\n+        let _x = p.x;\n+        //~^ NOTE: Capturing p[(0, 0)] -> ByValue\n+        //~| NOTE: p[] captured as ByValue here\n+        println!(\"{:?}\", p);\n+        //~^ NOTE: Capturing p[] -> ImmBorrow\n+        //~| NOTE: Min Capture p[] -> ByValue\n+        //~| NOTE: p[] used here\n+    };\n+}"}, {"sha": "0e48d6b300b7252f403447681780dc26b0101842", "filename": "src/test/ui/closures/2229_closure_analysis/capture-analysis-2.stderr", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-2.stderr?ref=84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36", "patch": "@@ -0,0 +1,65 @@\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/capture-analysis-2.rs:16:13\n+   |\n+LL |     let c = #[rustc_capture_analysis]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/capture-analysis-2.rs:1:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error: First Pass analysis includes:\n+  --> $DIR/capture-analysis-2.rs:19:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let _x = p.x;\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing p[(0, 0)] -> ByValue\n+  --> $DIR/capture-analysis-2.rs:22:18\n+   |\n+LL |         let _x = p.x;\n+   |                  ^^^\n+note: Capturing p[] -> ImmBorrow\n+  --> $DIR/capture-analysis-2.rs:25:26\n+   |\n+LL |         println!(\"{:?}\", p);\n+   |                          ^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/capture-analysis-2.rs:19:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let _x = p.x;\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture p[] -> ByValue\n+  --> $DIR/capture-analysis-2.rs:22:18\n+   |\n+LL |         let _x = p.x;\n+   |                  ^^^ p[] captured as ByValue here\n+...\n+LL |         println!(\"{:?}\", p);\n+   |                          ^ p[] used here\n+\n+error: aborting due to 3 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "817ade899e2a0bc290e2f76fa65e368a85cc3479", "filename": "src/test/ui/closures/2229_closure_analysis/capture-analysis-3.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-3.rs?ref=84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36", "patch": "@@ -0,0 +1,35 @@\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![feature(rustc_attrs)]\n+\n+#[derive(Debug)]\n+struct Child {\n+    c: String,\n+    d: String,\n+}\n+\n+#[derive(Debug)]\n+struct Parent {\n+    b: Child,\n+}\n+\n+fn main() {\n+    let mut a = Parent { b: Child {c: String::new(), d: String::new()} };\n+\n+    let c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ First Pass analysis includes:\n+    //~| Min Capture analysis includes:\n+        let _x = a.b.c;\n+        //~^ NOTE: Capturing a[(0, 0),(0, 0)] -> ByValue\n+        //~| NOTE: a[(0, 0)] captured as ByValue here\n+        println!(\"{:?}\", a.b);\n+        //~^ NOTE: Capturing a[(0, 0)] -> ImmBorrow\n+        //~| NOTE: Min Capture a[(0, 0)] -> ByValue\n+        //~| NOTE: a[(0, 0)] used here\n+    };\n+}"}, {"sha": "263e9ca56ebf6e840fe97cf4d83d29d1490c2348", "filename": "src/test/ui/closures/2229_closure_analysis/capture-analysis-3.stderr", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-3.stderr?ref=84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36", "patch": "@@ -0,0 +1,65 @@\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/capture-analysis-3.rs:21:13\n+   |\n+LL |     let c = #[rustc_capture_analysis]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/capture-analysis-3.rs:1:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error: First Pass analysis includes:\n+  --> $DIR/capture-analysis-3.rs:24:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let _x = a.b.c;\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing a[(0, 0),(0, 0)] -> ByValue\n+  --> $DIR/capture-analysis-3.rs:27:18\n+   |\n+LL |         let _x = a.b.c;\n+   |                  ^^^^^\n+note: Capturing a[(0, 0)] -> ImmBorrow\n+  --> $DIR/capture-analysis-3.rs:30:26\n+   |\n+LL |         println!(\"{:?}\", a.b);\n+   |                          ^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/capture-analysis-3.rs:24:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let _x = a.b.c;\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture a[(0, 0)] -> ByValue\n+  --> $DIR/capture-analysis-3.rs:27:18\n+   |\n+LL |         let _x = a.b.c;\n+   |                  ^^^^^ a[(0, 0)] captured as ByValue here\n+...\n+LL |         println!(\"{:?}\", a.b);\n+   |                          ^^^ a[(0, 0)] used here\n+\n+error: aborting due to 3 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "e8401299b30ada6f0f4b0fbdaca5694780f5430d", "filename": "src/test/ui/closures/2229_closure_analysis/capture-analysis-4.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-4.rs?ref=84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36", "patch": "@@ -0,0 +1,33 @@\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![feature(rustc_attrs)]\n+\n+#[derive(Debug)]\n+struct Child {\n+    c: String,\n+    d: String,\n+}\n+\n+#[derive(Debug)]\n+struct Parent {\n+    b: Child,\n+}\n+\n+fn main() {\n+    let mut a = Parent { b: Child {c: String::new(), d: String::new()} };\n+\n+    let c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ First Pass analysis includes:\n+    //~| Min Capture analysis includes:\n+        let _x = a.b;\n+        //~^ NOTE: Capturing a[(0, 0)] -> ByValue\n+        //~| NOTE: Min Capture a[(0, 0)] -> ByValue\n+        println!(\"{:?}\", a.b.c);\n+        //~^ NOTE: Capturing a[(0, 0),(0, 0)] -> ImmBorrow\n+    };\n+}"}, {"sha": "f4605c1d51b760225a032691c9bdc1e0cc0a1146", "filename": "src/test/ui/closures/2229_closure_analysis/capture-analysis-4.stderr", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-4.stderr?ref=84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36", "patch": "@@ -0,0 +1,62 @@\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/capture-analysis-4.rs:21:13\n+   |\n+LL |     let c = #[rustc_capture_analysis]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/capture-analysis-4.rs:1:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error: First Pass analysis includes:\n+  --> $DIR/capture-analysis-4.rs:24:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let _x = a.b;\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing a[(0, 0)] -> ByValue\n+  --> $DIR/capture-analysis-4.rs:27:18\n+   |\n+LL |         let _x = a.b;\n+   |                  ^^^\n+note: Capturing a[(0, 0),(0, 0)] -> ImmBorrow\n+  --> $DIR/capture-analysis-4.rs:30:26\n+   |\n+LL |         println!(\"{:?}\", a.b.c);\n+   |                          ^^^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/capture-analysis-4.rs:24:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let _x = a.b;\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture a[(0, 0)] -> ByValue\n+  --> $DIR/capture-analysis-4.rs:27:18\n+   |\n+LL |         let _x = a.b;\n+   |                  ^^^\n+\n+error: aborting due to 3 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "f81866bb7e0967ea8e0780517af02e5a7ded4f5f", "filename": "src/test/ui/closures/2229_closure_analysis/deep-multilevel-struct.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdeep-multilevel-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdeep-multilevel-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdeep-multilevel-struct.rs?ref=84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36", "patch": "@@ -0,0 +1,52 @@\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![feature(rustc_attrs)]\n+#![allow(unused)]\n+\n+#[derive(Debug)]\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+#[derive(Debug)]\n+struct Line {\n+    p: Point,\n+    q: Point\n+}\n+#[derive(Debug)]\n+struct Plane {\n+    a: Line,\n+    b: Line,\n+}\n+\n+fn main() {\n+    let mut p = Plane {\n+        a: Line {\n+            p: Point { x: 1,y: 2 },\n+            q: Point { x: 3,y: 4 },\n+        },\n+        b: Line {\n+            p: Point { x: 1,y: 2 },\n+            q: Point { x: 3,y: 4 },\n+        }\n+    };\n+\n+    let c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ ERROR: First Pass analysis includes:\n+    //~| ERROR: Min Capture analysis includes:\n+        let x = &p.a.p.x;\n+        //~^ NOTE: Capturing p[(0, 0),(0, 0),(0, 0)] -> ImmBorrow\n+        p.b.q.y = 9;\n+        //~^ NOTE: Capturing p[(1, 0),(1, 0),(1, 0)] -> MutBorrow\n+        //~| NOTE: p[] captured as MutBorrow here\n+        println!(\"{:?}\", p);\n+        //~^ NOTE: Capturing p[] -> ImmBorrow\n+        //~| NOTE: Min Capture p[] -> MutBorrow\n+        //~| NOTE: p[] used here\n+    };\n+}"}, {"sha": "863f1009131a161d0e963469d5dab132d85a54ba", "filename": "src/test/ui/closures/2229_closure_analysis/deep-multilevel-struct.stderr", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdeep-multilevel-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdeep-multilevel-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdeep-multilevel-struct.stderr?ref=84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36", "patch": "@@ -0,0 +1,70 @@\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/deep-multilevel-struct.rs:36:13\n+   |\n+LL |     let c = #[rustc_capture_analysis]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/deep-multilevel-struct.rs:1:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error: First Pass analysis includes:\n+  --> $DIR/deep-multilevel-struct.rs:39:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let x = &p.a.p.x;\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing p[(0, 0),(0, 0),(0, 0)] -> ImmBorrow\n+  --> $DIR/deep-multilevel-struct.rs:42:18\n+   |\n+LL |         let x = &p.a.p.x;\n+   |                  ^^^^^^^\n+note: Capturing p[(1, 0),(1, 0),(1, 0)] -> MutBorrow\n+  --> $DIR/deep-multilevel-struct.rs:44:9\n+   |\n+LL |         p.b.q.y = 9;\n+   |         ^^^^^^^\n+note: Capturing p[] -> ImmBorrow\n+  --> $DIR/deep-multilevel-struct.rs:47:26\n+   |\n+LL |         println!(\"{:?}\", p);\n+   |                          ^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/deep-multilevel-struct.rs:39:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let x = &p.a.p.x;\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture p[] -> MutBorrow\n+  --> $DIR/deep-multilevel-struct.rs:44:9\n+   |\n+LL |         p.b.q.y = 9;\n+   |         ^^^^^^^ p[] captured as MutBorrow here\n+...\n+LL |         println!(\"{:?}\", p);\n+   |                          ^ p[] used here\n+\n+error: aborting due to 3 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "fb03a02efa09e3e9d870a0405b99a96238ee91dd", "filename": "src/test/ui/closures/2229_closure_analysis/deep-multilevel-tuple.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdeep-multilevel-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdeep-multilevel-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdeep-multilevel-tuple.rs?ref=84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36", "patch": "@@ -0,0 +1,27 @@\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![feature(rustc_attrs)]\n+#![allow(unused)]\n+\n+fn main() {\n+    let mut t = (((1,2),(3,4)),((5,6),(7,8)));\n+\n+    let c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ ERROR: First Pass analysis includes:\n+    //~| ERROR: Min Capture analysis includes:\n+        let x = &t.0.0.0;\n+        //~^ NOTE: Capturing t[(0, 0),(0, 0),(0, 0)] -> ImmBorrow\n+        t.1.1.1 = 9;\n+        //~^ NOTE: Capturing t[(1, 0),(1, 0),(1, 0)] -> MutBorrow\n+        //~| NOTE: t[] captured as MutBorrow here\n+        println!(\"{:?}\", t);\n+        //~^ NOTE: Min Capture t[] -> MutBorrow\n+        //~| NOTE: Capturing t[] -> ImmBorrow\n+        //~| NOTE: t[] used here\n+    };\n+}"}, {"sha": "252db4447322288f64432a7c238b414d5dd2df36", "filename": "src/test/ui/closures/2229_closure_analysis/deep-multilevel-tuple.stderr", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdeep-multilevel-tuple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdeep-multilevel-tuple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdeep-multilevel-tuple.stderr?ref=84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36", "patch": "@@ -0,0 +1,70 @@\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/deep-multilevel-tuple.rs:11:13\n+   |\n+LL |     let c = #[rustc_capture_analysis]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/deep-multilevel-tuple.rs:1:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error: First Pass analysis includes:\n+  --> $DIR/deep-multilevel-tuple.rs:14:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let x = &t.0.0.0;\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing t[(0, 0),(0, 0),(0, 0)] -> ImmBorrow\n+  --> $DIR/deep-multilevel-tuple.rs:17:18\n+   |\n+LL |         let x = &t.0.0.0;\n+   |                  ^^^^^^^\n+note: Capturing t[(1, 0),(1, 0),(1, 0)] -> MutBorrow\n+  --> $DIR/deep-multilevel-tuple.rs:19:9\n+   |\n+LL |         t.1.1.1 = 9;\n+   |         ^^^^^^^\n+note: Capturing t[] -> ImmBorrow\n+  --> $DIR/deep-multilevel-tuple.rs:22:26\n+   |\n+LL |         println!(\"{:?}\", t);\n+   |                          ^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/deep-multilevel-tuple.rs:14:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let x = &t.0.0.0;\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture t[] -> MutBorrow\n+  --> $DIR/deep-multilevel-tuple.rs:19:9\n+   |\n+LL |         t.1.1.1 = 9;\n+   |         ^^^^^^^ t[] captured as MutBorrow here\n+...\n+LL |         println!(\"{:?}\", t);\n+   |                          ^ t[] used here\n+\n+error: aborting due to 3 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "a6b5e12d2ed78e4d6f562d00794764af78f67f10", "filename": "src/test/ui/closures/2229_closure_analysis/simple-struct-min-capture.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fsimple-struct-min-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fsimple-struct-min-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fsimple-struct-min-capture.rs?ref=84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36", "patch": "@@ -32,9 +32,11 @@ fn main() {\n     //~| ERROR: Min Capture analysis includes:\n         p.x += 10;\n         //~^ NOTE: Capturing p[(0, 0)] -> MutBorrow\n-        //~| NOTE: Min Capture p[] -> MutBorrow\n+        //~| NOTE: p[] captured as MutBorrow here\n         println!(\"{:?}\", p);\n         //~^ NOTE: Capturing p[] -> ImmBorrow\n+        //~| NOTE: Min Capture p[] -> MutBorrow\n+        //~| NOTE: p[] used here\n     };\n \n     c();"}, {"sha": "cbbc8792199153639bdd13bb1074e16e5b299074", "filename": "src/test/ui/closures/2229_closure_analysis/simple-struct-min-capture.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fsimple-struct-min-capture.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fsimple-struct-min-capture.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fsimple-struct-min-capture.stderr?ref=84ad95be70d3a1b06ed537e4e7ec0c8e1086cb36", "patch": "@@ -55,7 +55,10 @@ note: Min Capture p[] -> MutBorrow\n   --> $DIR/simple-struct-min-capture.rs:33:9\n    |\n LL |         p.x += 10;\n-   |         ^^^\n+   |         ^^^ p[] captured as MutBorrow here\n+...\n+LL |         println!(\"{:?}\", p);\n+   |                          ^ p[] used here\n \n error: aborting due to 3 previous errors; 1 warning emitted\n "}]}