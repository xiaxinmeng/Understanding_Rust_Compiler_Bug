{"sha": "0a4d55ddb89521899da2d1b6bf047ce01386595e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhNGQ1NWRkYjg5NTIxODk5ZGEyZDFiNmJmMDQ3Y2UwMTM4NjU5NWU=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-09-25T20:35:19Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-09-27T17:34:14Z"}, "message": "Remove stray uses of gcx name", "tree": {"sha": "23594a21293d9b5224eb95fa78c22271ff8c7e29", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23594a21293d9b5224eb95fa78c22271ff8c7e29"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a4d55ddb89521899da2d1b6bf047ce01386595e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a4d55ddb89521899da2d1b6bf047ce01386595e", "html_url": "https://github.com/rust-lang/rust/commit/0a4d55ddb89521899da2d1b6bf047ce01386595e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a4d55ddb89521899da2d1b6bf047ce01386595e/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f226ab4ad97fbc2e183d319616f17998c66f64e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/f226ab4ad97fbc2e183d319616f17998c66f64e8", "html_url": "https://github.com/rust-lang/rust/commit/f226ab4ad97fbc2e183d319616f17998c66f64e8"}], "stats": {"total": 54, "additions": 27, "deletions": 27}, "files": [{"sha": "989c4aeea0964d587e66d23caeef9e7097ee3a53", "filename": "src/librustc/traits/query/type_op/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a4d55ddb89521899da2d1b6bf047ce01386595e/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a4d55ddb89521899da2d1b6bf047ce01386595e/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=0a4d55ddb89521899da2d1b6bf047ce01386595e", "patch": "@@ -66,7 +66,7 @@ pub trait QueryTypeOp<'tcx>: fmt::Debug + Sized + TypeFoldable<'tcx> + 'tcx {\n         canonicalized: Canonicalized<'tcx, ParamEnvAnd<'tcx, Self>>,\n     ) -> Fallible<CanonicalizedQueryResponse<'tcx, Self::QueryResponse>>;\n \n-    /// Casts a lifted query result (which is in the gcx lifetime)\n+    /// Casts a lifted query result (which is in the tcx lifetime)\n     /// into the tcx lifetime. This is always just an identity cast,\n     /// but the generic code doesn't realize it -- put another way, in\n     /// the generic code, we have a `Lifted<'tcx, Self::QueryResponse>`"}, {"sha": "20c517d779b42c0c6057682b1c290d0d8ac7b132", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a4d55ddb89521899da2d1b6bf047ce01386595e/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a4d55ddb89521899da2d1b6bf047ce01386595e/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=0a4d55ddb89521899da2d1b6bf047ce01386595e", "patch": "@@ -366,8 +366,8 @@ fn check_item_type(\n ) {\n     debug!(\"check_item_type: {:?}\", item_id);\n \n-    for_id(tcx, item_id, ty_span).with_fcx(|fcx, gcx| {\n-        let ty = gcx.type_of(gcx.hir().local_def_id(item_id));\n+    for_id(tcx, item_id, ty_span).with_fcx(|fcx, tcx| {\n+        let ty = tcx.type_of(tcx.hir().local_def_id(item_id));\n         let item_ty = fcx.normalize_associated_types_in(ty_span, &ty);\n \n         let mut forbid_unsized = true;"}, {"sha": "1e3939cbfcdf284d503ded7cd6e9bc0ff27c8f37", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0a4d55ddb89521899da2d1b6bf047ce01386595e/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a4d55ddb89521899da2d1b6bf047ce01386595e/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=0a4d55ddb89521899da2d1b6bf047ce01386595e", "patch": "@@ -322,29 +322,29 @@ fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: DefId) {\n     }\n }\n \n-pub fn coerce_unsized_info<'tcx>(gcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUnsizedInfo {\n+pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUnsizedInfo {\n     debug!(\"compute_coerce_unsized_info(impl_did={:?})\", impl_did);\n-    let coerce_unsized_trait = gcx.lang_items().coerce_unsized_trait().unwrap();\n+    let coerce_unsized_trait = tcx.lang_items().coerce_unsized_trait().unwrap();\n \n-    let unsize_trait = gcx.lang_items().require(UnsizeTraitLangItem).unwrap_or_else(|err| {\n-        gcx.sess.fatal(&format!(\"`CoerceUnsized` implementation {}\", err));\n+    let unsize_trait = tcx.lang_items().require(UnsizeTraitLangItem).unwrap_or_else(|err| {\n+        tcx.sess.fatal(&format!(\"`CoerceUnsized` implementation {}\", err));\n     });\n \n     // this provider should only get invoked for local def-ids\n-    let impl_hir_id = gcx.hir().as_local_hir_id(impl_did).unwrap_or_else(|| {\n+    let impl_hir_id = tcx.hir().as_local_hir_id(impl_did).unwrap_or_else(|| {\n         bug!(\"coerce_unsized_info: invoked for non-local def-id {:?}\", impl_did)\n     });\n \n-    let source = gcx.type_of(impl_did);\n-    let trait_ref = gcx.impl_trait_ref(impl_did).unwrap();\n+    let source = tcx.type_of(impl_did);\n+    let trait_ref = tcx.impl_trait_ref(impl_did).unwrap();\n     assert_eq!(trait_ref.def_id, coerce_unsized_trait);\n     let target = trait_ref.substs.type_at(1);\n     debug!(\"visit_implementation_of_coerce_unsized: {:?} -> {:?} (bound)\",\n            source,\n            target);\n \n-    let span = gcx.hir().span(impl_hir_id);\n-    let param_env = gcx.param_env(impl_did);\n+    let span = tcx.hir().span(impl_hir_id);\n+    let param_env = tcx.param_env(impl_did);\n     assert!(!source.has_escaping_bound_vars());\n \n     let err_info = CoerceUnsizedInfo { custom_kind: None };\n@@ -353,7 +353,7 @@ pub fn coerce_unsized_info<'tcx>(gcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n            source,\n            target);\n \n-    gcx.infer_ctxt().enter(|infcx| {\n+    tcx.infer_ctxt().enter(|infcx| {\n         let cause = ObligationCause::misc(span, impl_hir_id);\n         let check_mutbl = |mt_a: ty::TypeAndMut<'tcx>,\n                            mt_b: ty::TypeAndMut<'tcx>,\n@@ -372,24 +372,24 @@ pub fn coerce_unsized_info<'tcx>(gcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n                 infcx.sub_regions(infer::RelateObjectBound(span), r_b, r_a);\n                 let mt_a = ty::TypeAndMut { ty: ty_a, mutbl: mutbl_a };\n                 let mt_b = ty::TypeAndMut { ty: ty_b, mutbl: mutbl_b };\n-                check_mutbl(mt_a, mt_b, &|ty| gcx.mk_imm_ref(r_b, ty))\n+                check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ref(r_b, ty))\n             }\n \n             (&ty::Ref(_, ty_a, mutbl_a), &ty::RawPtr(mt_b)) => {\n                 let mt_a = ty::TypeAndMut { ty: ty_a, mutbl: mutbl_a };\n-                check_mutbl(mt_a, mt_b, &|ty| gcx.mk_imm_ptr(ty))\n+                check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ptr(ty))\n             }\n \n             (&ty::RawPtr(mt_a), &ty::RawPtr(mt_b)) => {\n-                check_mutbl(mt_a, mt_b, &|ty| gcx.mk_imm_ptr(ty))\n+                check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ptr(ty))\n             }\n \n             (&ty::Adt(def_a, substs_a), &ty::Adt(def_b, substs_b)) if def_a.is_struct() &&\n                                                                       def_b.is_struct() => {\n                 if def_a != def_b {\n-                    let source_path = gcx.def_path_str(def_a.did);\n-                    let target_path = gcx.def_path_str(def_b.did);\n-                    span_err!(gcx.sess,\n+                    let source_path = tcx.def_path_str(def_a.did);\n+                    let target_path = tcx.def_path_str(def_b.did);\n+                    span_err!(tcx.sess,\n                               span,\n                               E0377,\n                               \"the trait `CoerceUnsized` may only be implemented \\\n@@ -443,9 +443,9 @@ pub fn coerce_unsized_info<'tcx>(gcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n                 let diff_fields = fields.iter()\n                     .enumerate()\n                     .filter_map(|(i, f)| {\n-                        let (a, b) = (f.ty(gcx, substs_a), f.ty(gcx, substs_b));\n+                        let (a, b) = (f.ty(tcx, substs_a), f.ty(tcx, substs_b));\n \n-                        if gcx.type_of(f.did).is_phantom_data() {\n+                        if tcx.type_of(f.did).is_phantom_data() {\n                             // Ignore PhantomData fields\n                             return None;\n                         }\n@@ -472,22 +472,22 @@ pub fn coerce_unsized_info<'tcx>(gcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n                     .collect::<Vec<_>>();\n \n                 if diff_fields.is_empty() {\n-                    span_err!(gcx.sess,\n+                    span_err!(tcx.sess,\n                               span,\n                               E0374,\n                               \"the trait `CoerceUnsized` may only be implemented \\\n                                for a coercion between structures with one field \\\n                                being coerced, none found\");\n                     return err_info;\n                 } else if diff_fields.len() > 1 {\n-                    let item = gcx.hir().expect_item(impl_hir_id);\n+                    let item = tcx.hir().expect_item(impl_hir_id);\n                     let span = if let ItemKind::Impl(.., Some(ref t), _, _) = item.kind {\n                         t.path.span\n                     } else {\n-                        gcx.hir().span(impl_hir_id)\n+                        tcx.hir().span(impl_hir_id)\n                     };\n \n-                    let mut err = struct_span_err!(gcx.sess,\n+                    let mut err = struct_span_err!(tcx.sess,\n                                                    span,\n                                                    E0375,\n                                                    \"implementing the trait \\\n@@ -514,7 +514,7 @@ pub fn coerce_unsized_info<'tcx>(gcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n             }\n \n             _ => {\n-                span_err!(gcx.sess,\n+                span_err!(tcx.sess,\n                           span,\n                           E0376,\n                           \"the trait `CoerceUnsized` may only be implemented \\\n@@ -527,7 +527,7 @@ pub fn coerce_unsized_info<'tcx>(gcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n \n         // Register an obligation for `A: Trait<B>`.\n         let cause = traits::ObligationCause::misc(span, impl_hir_id);\n-        let predicate = gcx.predicate_for_trait_def(param_env,\n+        let predicate = tcx.predicate_for_trait_def(param_env,\n                                                     cause,\n                                                     trait_def_id,\n                                                     0,"}]}