{"sha": "9c8222474696d3d833cf850a1d50f1c485b63f09", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljODIyMjQ3NDY5NmQzZDgzM2NmODUwYTFkNTBmMWM0ODViNjNmMDk=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-09T02:18:58Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-24T03:43:29Z"}, "message": "chains: simplify visual formatting a bit", "tree": {"sha": "e1f3ce32d06d2dbe25f913d45606e589a2a63be0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1f3ce32d06d2dbe25f913d45606e589a2a63be0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c8222474696d3d833cf850a1d50f1c485b63f09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c8222474696d3d833cf850a1d50f1c485b63f09", "html_url": "https://github.com/rust-lang/rust/commit/9c8222474696d3d833cf850a1d50f1c485b63f09", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c8222474696d3d833cf850a1d50f1c485b63f09/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d244234607417e850e264afc9fbf7a4842ebad19", "url": "https://api.github.com/repos/rust-lang/rust/commits/d244234607417e850e264afc9fbf7a4842ebad19", "html_url": "https://github.com/rust-lang/rust/commit/d244234607417e850e264afc9fbf7a4842ebad19"}], "stats": {"total": 58, "additions": 27, "deletions": 31}, "files": [{"sha": "220cc4b8750e4ae20a63a3e096d7278a5b945313", "filename": "src/chains.rs", "status": "modified", "additions": 27, "deletions": 31, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/9c8222474696d3d833cf850a1d50f1c485b63f09/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c8222474696d3d833cf850a1d50f1c485b63f09/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=9c8222474696d3d833cf850a1d50f1c485b63f09", "patch": "@@ -340,9 +340,9 @@ fn rewrite_chain_block(chain: Chain, context: &RewriteContext, shape: Shape) ->\n }\n \n fn rewrite_chain_visual(chain: Chain, context: &RewriteContext, shape: Shape) -> Option<String> {\n-    let (parent, subexpr_list) = (&chain.parent.expr, &chain.children);\n+    let parent = &chain.parent.expr;\n \n-    let suffix_try_num = subexpr_list.iter().take_while(|e| is_try(e)).count();\n+    let suffix_try_num = chain.children.iter().take_while(|e| is_try(e)).count();\n \n     // Parent is the first item in the chain, e.g., `foo` in `foo.bar.baz()`.\n     let parent_shape = if is_block_expr(context, &parent, \"\\n\") {\n@@ -355,22 +355,13 @@ fn rewrite_chain_visual(chain: Chain, context: &RewriteContext, shape: Shape) ->\n         .map(|parent_rw| parent_rw + &\"?\".repeat(chain.parent.tries))?;\n     let parent_rewrite_contains_newline = parent_rewrite.contains('\\n');\n     let is_small_parent = shape.offset + parent_rewrite.len() <= context.config.tab_spaces();\n-    let parent_is_block = is_block_expr(context, &parent, &parent_rewrite);\n+\n+    let nested_shape = shape.visual_indent(0);\n+    let other_child_shape = nested_shape.with_max_width(context.config);\n \n     // Decide how to layout the rest of the chain. `extend` is true if we can\n     // put the first non-parent item on the same line as the parent.\n-    let (nested_shape, extend) = if !parent_rewrite_contains_newline && is_continuable(&parent) {\n-        (shape.visual_indent(0), true)\n-    } else if parent_is_block {\n-        (parent_shape, false)\n-    } else {\n-        (\n-            shape.visual_indent(0),\n-            false,\n-        )\n-    };\n-\n-    let other_child_shape = nested_shape.with_max_width(context.config);\n+    let extend = !parent_rewrite_contains_newline && is_continuable(&parent);\n \n     let first_child_shape = if extend {\n         let overhead = last_line_width(&parent_rewrite);\n@@ -383,20 +374,17 @@ fn rewrite_chain_visual(chain: Chain, context: &RewriteContext, shape: Shape) ->\n         first_child_shape, other_child_shape\n     );\n \n-    let last_subexpr = &subexpr_list[suffix_try_num];\n-    let subexpr_list = &subexpr_list[suffix_try_num..];\n+    let last_subexpr = &chain.children[suffix_try_num];\n+    let subexpr_list = &chain.children[suffix_try_num..];\n \n     let mut rewrites: Vec<String> = Vec::with_capacity(subexpr_list.len());\n-    let mut is_block_like = Vec::with_capacity(subexpr_list.len());\n-    is_block_like.push(true);\n     for (i, expr) in subexpr_list.iter().skip(1).rev().enumerate() {\n-        let shape = if *is_block_like.last().unwrap() && !(extend && i == 0) {\n+        let shape = if i == 0 {\n             first_child_shape\n         } else {\n             other_child_shape\n         };\n         let rewrite = rewrite_chain_subexpr(expr, chain.span, context, shape)?;\n-        is_block_like.push(is_block_expr(context, expr, &rewrite));\n         rewrites.push(rewrite);\n     }\n \n@@ -419,11 +407,8 @@ fn rewrite_chain_visual(chain: Chain, context: &RewriteContext, shape: Shape) ->\n     let all_in_one_line = !parent_rewrite_contains_newline\n         && rewrites.iter().all(|s| !s.contains('\\n'))\n         && almost_total < one_line_budget;\n-    let last_shape = if is_block_like[rewrites.len()] {\n-        first_child_shape\n-    } else {\n-        other_child_shape\n-    }.sub_width(shape.rhs_overhead(context.config) + suffix_try_num)?;\n+    let last_shape =\n+        other_child_shape.sub_width(shape.rhs_overhead(context.config) + suffix_try_num)?;\n \n     // Rewrite the last child. The last child of a chain requires special treatment. We need to\n     // know whether 'overflowing' the last child make a better formatting:\n@@ -494,9 +479,6 @@ fn rewrite_chain_visual(chain: Chain, context: &RewriteContext, shape: Shape) ->\n         (rewrite_last(), false)\n     };\n     rewrites.push(last_subexpr_str?);\n-    // We should never look at this, since we only look at the block-ness of the\n-    // previous item in the chain.\n-    is_block_like.push(false);\n \n     let connector = if fits_single_line && !parent_rewrite_contains_newline {\n         // Yay, we can put everything on one line.\n@@ -514,13 +496,13 @@ fn rewrite_chain_visual(chain: Chain, context: &RewriteContext, shape: Shape) ->\n             \"{}{}{}\",\n             parent_rewrite,\n             rewrites[0],\n-            join_rewrites(&rewrites[1..], &is_block_like[2..], &connector),\n+            join_rewrites_vis(&rewrites[1..], &connector),\n         )\n     } else {\n         format!(\n             \"{}{}\",\n             parent_rewrite,\n-            join_rewrites(&rewrites, &is_block_like[1..], &connector),\n+            join_rewrites_vis(&rewrites, &connector),\n         )\n     };\n     let result = format!(\"{}{}\", result, \"?\".repeat(suffix_try_num));\n@@ -551,6 +533,20 @@ fn join_rewrites(rewrites: &[String], is_block_like: &[bool], connector: &str) -\n     result\n }\n \n+fn join_rewrites_vis(rewrites: &[String], connector: &str) -> String {\n+    let mut rewrite_iter = rewrites.iter();\n+    let mut result = rewrite_iter.next().unwrap().clone();\n+\n+    for rewrite in rewrite_iter {\n+        if rewrite != \"?\" {\n+            result.push_str(connector);\n+        }\n+        result.push_str(&rewrite);\n+    }\n+\n+    result\n+}\n+\n // States whether an expression's last line exclusively consists of closing\n // parens, braces, and brackets in its idiomatic formatting.\n fn is_block_expr(context: &RewriteContext, expr: &ast::Expr, repr: &str) -> bool {"}]}