{"sha": "2304fe6208404ce952aaa37e7634db570ff71f6c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzMDRmZTYyMDg0MDRjZTk1MmFhYTM3ZTc2MzRkYjU3MGZmNzFmNmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-02T13:15:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-02T13:15:39Z"}, "message": "auto merge of #5196 : thestinger/rust/ord, r=catamorphism\n\nThis allows `TreeMap`/`TreeSet` to fully express their requirements and reduces the comparisons from ~1.5 per level to 1 which really helps for string keys.\r\n\r\nI also added `ReverseIter` to the prelude exports because I forgot when I originally added it.", "tree": {"sha": "ff90158dc320e3c59e5572a41adbbd148bf82cf7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff90158dc320e3c59e5572a41adbbd148bf82cf7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2304fe6208404ce952aaa37e7634db570ff71f6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2304fe6208404ce952aaa37e7634db570ff71f6c", "html_url": "https://github.com/rust-lang/rust/commit/2304fe6208404ce952aaa37e7634db570ff71f6c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2304fe6208404ce952aaa37e7634db570ff71f6c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5aca7d6aef2f5e18b640d918b243a71fc893a65b", "url": "https://api.github.com/repos/rust-lang/rust/commits/5aca7d6aef2f5e18b640d918b243a71fc893a65b", "html_url": "https://github.com/rust-lang/rust/commit/5aca7d6aef2f5e18b640d918b243a71fc893a65b"}, {"sha": "035233a25907af8206d254878e7e04048fcac95e", "url": "https://api.github.com/repos/rust-lang/rust/commits/035233a25907af8206d254878e7e04048fcac95e", "html_url": "https://github.com/rust-lang/rust/commit/035233a25907af8206d254878e7e04048fcac95e"}], "stats": {"total": 346, "additions": 253, "deletions": 93}, "files": [{"sha": "d588f0c53b17e1f47dea3b9b12b23d733619a1ca", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/2304fe6208404ce952aaa37e7634db570ff71f6c/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2304fe6208404ce952aaa37e7634db570ff71f6c/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=2304fe6208404ce952aaa37e7634db570ff71f6c", "patch": "@@ -37,6 +37,70 @@ pub trait Eq {\n     pure fn ne(&self, other: &Self) -> bool;\n }\n \n+#[deriving_eq]\n+pub enum Ordering { Less, Equal, Greater }\n+\n+/// Trait for types that form a total order\n+pub trait TotalOrd {\n+    pure fn cmp(&self, other: &Self) -> Ordering;\n+}\n+\n+pure fn icmp<T: Ord>(a: &T, b: &T) -> Ordering {\n+    if *a < *b { Less }\n+    else if *a > *b { Greater }\n+    else { Equal }\n+}\n+\n+impl TotalOrd for u8 {\n+    #[inline(always)]\n+    pure fn cmp(&self, other: &u8) -> Ordering { icmp(self, other) }\n+}\n+\n+impl TotalOrd for u16 {\n+    #[inline(always)]\n+    pure fn cmp(&self, other: &u16) -> Ordering { icmp(self, other) }\n+}\n+\n+impl TotalOrd for u32 {\n+    #[inline(always)]\n+    pure fn cmp(&self, other: &u32) -> Ordering { icmp(self, other) }\n+}\n+\n+impl TotalOrd for u64 {\n+    #[inline(always)]\n+    pure fn cmp(&self, other: &u64) -> Ordering { icmp(self, other) }\n+}\n+\n+impl TotalOrd for i8 {\n+    #[inline(always)]\n+    pure fn cmp(&self, other: &i8) -> Ordering { icmp(self, other) }\n+}\n+\n+impl TotalOrd for i16 {\n+    #[inline(always)]\n+    pure fn cmp(&self, other: &i16) -> Ordering { icmp(self, other) }\n+}\n+\n+impl TotalOrd for i32 {\n+    #[inline(always)]\n+    pure fn cmp(&self, other: &i32) -> Ordering { icmp(self, other) }\n+}\n+\n+impl TotalOrd for i64 {\n+    #[inline(always)]\n+    pure fn cmp(&self, other: &i64) -> Ordering { icmp(self, other) }\n+}\n+\n+impl TotalOrd for int {\n+    #[inline(always)]\n+    pure fn cmp(&self, other: &int) -> Ordering { icmp(self, other) }\n+}\n+\n+impl TotalOrd for uint {\n+    #[inline(always)]\n+    pure fn cmp(&self, other: &uint) -> Ordering { icmp(self, other) }\n+}\n+\n /**\n * Trait for values that can be compared for a sort-order.\n *\n@@ -94,3 +158,15 @@ pub pure fn min<T:Ord>(v1: T, v2: T) -> T {\n pub pure fn max<T:Ord>(v1: T, v2: T) -> T {\n     if v1 > v2 { v1 } else { v2 }\n }\n+\n+#[cfg(test)]\n+mod test {\n+    #[test]\n+    fn test_int() {\n+        assert 5.cmp(&10) == Less;\n+        assert 10.cmp(&5) == Greater;\n+        assert 5.cmp(&5) == Equal;\n+        assert (-5).cmp(&12) == Less;\n+        assert 12.cmp(-5) == Greater;\n+    }\n+}"}, {"sha": "e4be0cf98dd4e96b9a9ac035b369d46a4825ec66", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2304fe6208404ce952aaa37e7634db570ff71f6c/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2304fe6208404ce952aaa37e7634db570ff71f6c/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=2304fe6208404ce952aaa37e7634db570ff71f6c", "patch": "@@ -24,10 +24,10 @@ pub use result::{Result, Ok, Err};\n /* Reexported types and traits */\n \n pub use clone::Clone;\n-pub use cmp::{Eq, Ord};\n+pub use cmp::{Eq, Ord, TotalOrd, Ordering, Less, Equal, Greater};\n pub use container::{Container, Mutable, Map, Set};\n pub use hash::Hash;\n-pub use iter::{BaseIter, ExtendedIter, EqIter, CopyableIter};\n+pub use iter::{BaseIter, ReverseIter, ExtendedIter, EqIter, CopyableIter};\n pub use iter::{CopyableOrderedIter, CopyableNonstrictIter, Times};\n pub use num::NumCast;\n pub use path::GenericPath;"}, {"sha": "f1e23f01e7b51f53bbfff3b46f347bf20e84e68a", "filename": "src/libcore/str.rs", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2304fe6208404ce952aaa37e7634db570ff71f6c/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2304fe6208404ce952aaa37e7634db570ff71f6c/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=2304fe6208404ce952aaa37e7634db570ff71f6c", "patch": "@@ -20,7 +20,7 @@\n use at_vec;\n use cast;\n use char;\n-use cmp::{Eq, Ord};\n+use cmp::{Eq, Ord, TotalOrd, Ordering, Less, Equal, Greater};\n use libc;\n use libc::size_t;\n use io::WriterUtil;\n@@ -773,6 +773,35 @@ pub pure fn eq(a: &~str, b: &~str) -> bool {\n     eq_slice(*a, *b)\n }\n \n+pure fn cmp(a: &str, b: &str) -> Ordering {\n+    let low = uint::min(a.len(), b.len());\n+\n+    for uint::range(0, low) |idx| {\n+        match a[idx].cmp(&b[idx]) {\n+          Greater => return Greater,\n+          Less => return Less,\n+          Equal => ()\n+        }\n+    }\n+\n+    a.len().cmp(&b.len())\n+}\n+\n+#[cfg(notest)]\n+impl TotalOrd for &str {\n+    pure fn cmp(&self, other: & &self/str) -> Ordering { cmp(*self, *other) }\n+}\n+\n+#[cfg(notest)]\n+impl TotalOrd for ~str {\n+    pure fn cmp(&self, other: &~str) -> Ordering { cmp(*self, *other) }\n+}\n+\n+#[cfg(notest)]\n+impl TotalOrd for @str {\n+    pure fn cmp(&self, other: &@str) -> Ordering { cmp(*self, *other) }\n+}\n+\n /// Bytewise slice less than\n pure fn lt(a: &str, b: &str) -> bool {\n     let (a_len, b_len) = (a.len(), b.len());\n@@ -2389,6 +2418,7 @@ mod tests {\n     use ptr;\n     use str::*;\n     use vec;\n+    use cmp::{TotalOrd, Less, Equal, Greater};\n \n     #[test]\n     fn test_eq() {\n@@ -3395,4 +3425,12 @@ mod tests {\n         assert view(\"abcdef\", 1, 5).to_managed() == @\"bcde\";\n     }\n \n+    #[test]\n+    fn test_total_ord() {\n+        \"1234\".cmp(& &\"123\") == Greater;\n+        \"123\".cmp(& &\"1234\") == Less;\n+        \"1234\".cmp(& &\"1234\") == Equal;\n+        \"12345555\".cmp(& &\"123456\") == Less;\n+        \"22\".cmp(& &\"1234\") == Greater;\n+    }\n }"}, {"sha": "925d78a3b81b0b86436767ef159695d610ce2741", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 50, "deletions": 9, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/2304fe6208404ce952aaa37e7634db570ff71f6c/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2304fe6208404ce952aaa37e7634db570ff71f6c/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=2304fe6208404ce952aaa37e7634db570ff71f6c", "patch": "@@ -15,7 +15,7 @@\n use container::{Container, Mutable};\n use cast::transmute;\n use cast;\n-use cmp::{Eq, Ord};\n+use cmp::{Eq, Ord, TotalOrd, Ordering, Less, Equal, Greater};\n use iter::BaseIter;\n use iter;\n use kinds::Copy;\n@@ -1425,7 +1425,7 @@ pub pure fn rev_eachi<T>(v: &r/[T], blk: fn(i: uint, v: &r/T) -> bool) {\n  * Both vectors must have the same length\n  */\n #[inline]\n-pub fn each2<U, T>(v1: &[U], v2: &[T], f: fn(u: &U, t: &T) -> bool) {\n+pub pure fn each2<U, T>(v1: &[U], v2: &[T], f: fn(u: &U, t: &T) -> bool) {\n     assert len(v1) == len(v2);\n     for uint::range(0u, len(v1)) |i| {\n         if !f(&v1[i], &v2[i]) {\n@@ -1575,6 +1575,38 @@ impl<T:Eq> Eq for @[T] {\n \n // Lexicographical comparison\n \n+pure fn cmp<T: TotalOrd>(a: &[T], b: &[T]) -> Ordering {\n+    let low = uint::min(a.len(), b.len());\n+\n+    for uint::range(0, low) |idx| {\n+        match a[idx].cmp(&b[idx]) {\n+          Greater => return Greater,\n+          Less => return Less,\n+          Equal => ()\n+        }\n+    }\n+\n+    a.len().cmp(&b.len())\n+}\n+\n+#[cfg(notest)]\n+impl<T: TotalOrd> TotalOrd for &[T] {\n+    #[inline(always)]\n+    pure fn cmp(&self, other: & &self/[T]) -> Ordering { cmp(*self, *other) }\n+}\n+\n+#[cfg(notest)]\n+impl<T: TotalOrd> TotalOrd for ~[T] {\n+    #[inline(always)]\n+    pure fn cmp(&self, other: &~[T]) -> Ordering { cmp(*self, *other) }\n+}\n+\n+#[cfg(notest)]\n+impl<T: TotalOrd> TotalOrd for @[T] {\n+    #[inline(always)]\n+    pure fn cmp(&self, other: &@[T]) -> Ordering { cmp(*self, *other) }\n+}\n+\n pure fn lt<T:Ord>(a: &[T], b: &[T]) -> bool {\n     let (a_len, b_len) = (a.len(), b.len());\n     let mut end = uint::min(a_len, b_len);\n@@ -2151,7 +2183,7 @@ pub mod bytes {\n     use vec;\n \n     /// Bytewise string comparison\n-    pub pure fn cmp(a: &~[u8], b: &~[u8]) -> int {\n+    pub pure fn memcmp(a: &~[u8], b: &~[u8]) -> int {\n         let a_len = len(*a);\n         let b_len = len(*b);\n         let n = uint::min(a_len, b_len) as libc::size_t;\n@@ -2172,22 +2204,22 @@ pub mod bytes {\n     }\n \n     /// Bytewise less than or equal\n-    pub pure fn lt(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) < 0 }\n+    pub pure fn lt(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) < 0 }\n \n     /// Bytewise less than or equal\n-    pub pure fn le(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) <= 0 }\n+    pub pure fn le(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) <= 0 }\n \n     /// Bytewise equality\n-    pub pure fn eq(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) == 0 }\n+    pub pure fn eq(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) == 0 }\n \n     /// Bytewise inequality\n-    pub pure fn ne(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) != 0 }\n+    pub pure fn ne(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) != 0 }\n \n     /// Bytewise greater than or equal\n-    pub pure fn ge(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) >= 0 }\n+    pub pure fn ge(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) >= 0 }\n \n     /// Bytewise greater than\n-    pub pure fn gt(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) > 0 }\n+    pub pure fn gt(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) > 0 }\n \n     /**\n       * Copies data from one vector to another.\n@@ -2429,6 +2461,7 @@ mod tests {\n     use option;\n     use sys;\n     use vec::*;\n+    use cmp::*;\n \n     fn square(n: uint) -> uint { return n * n; }\n \n@@ -3942,6 +3975,14 @@ mod tests {\n         }\n     }\n \n+    #[test]\n+    fn test_total_ord() {\n+        [1, 2, 3, 4].cmp(& &[1, 2, 3]) == Greater;\n+        [1, 2, 3].cmp(& &[1, 2, 3, 4]) == Less;\n+        [1, 2, 3, 4].cmp(& &[1, 2, 3, 4]) == Equal;\n+        [1, 2, 3, 4, 5, 5, 5, 5].cmp(& &[1, 2, 3, 4, 5, 6]) == Less;\n+        [2, 2].cmp(& &[1, 2, 3, 4]) == Greater;\n+    }\n }\n \n // Local Variables:"}, {"sha": "a093351c4a76387e9674ad28268e9b878e59c02a", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 86, "deletions": 81, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/2304fe6208404ce952aaa37e7634db570ff71f6c/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2304fe6208404ce952aaa37e7634db570ff71f6c/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=2304fe6208404ce952aaa37e7634db570ff71f6c", "patch": "@@ -10,12 +10,8 @@\n \n //! An ordered map and set implemented as self-balancing binary search\n //! trees. The only requirement for the types is that the key implements\n-//! `Ord`, and that the `lt` method provides a total ordering.\n+//! `TotalOrd`.\n \n-use core::container::{Container, Mutable, Map, Set};\n-use core::cmp::{Eq, Ord};\n-use core::iter::{BaseIter, ReverseIter};\n-use core::option::{Option, Some, None};\n use core::prelude::*;\n \n // This is implemented as an AA tree, which is a simplified variation of\n@@ -39,7 +35,7 @@ pub struct TreeMap<K, V> {\n     priv length: uint\n }\n \n-impl<K:Eq + Ord,V:Eq> Eq for TreeMap<K, V> {\n+impl<K: Eq + TotalOrd, V: Eq> Eq for TreeMap<K, V> {\n     pure fn eq(&self, other: &TreeMap<K, V>) -> bool {\n         if self.len() != other.len() {\n             false\n@@ -61,7 +57,8 @@ impl<K:Eq + Ord,V:Eq> Eq for TreeMap<K, V> {\n }\n \n // Lexicographical comparison\n-pure fn lt<K:Ord,V>(a: &TreeMap<K, V>, b: &TreeMap<K, V>) -> bool {\n+pure fn lt<K: Ord + TotalOrd, V>(a: &TreeMap<K, V>,\n+                                 b: &TreeMap<K, V>) -> bool {\n     let mut x = a.iter();\n     let mut y = b.iter();\n \n@@ -78,7 +75,7 @@ pure fn lt<K:Ord,V>(a: &TreeMap<K, V>, b: &TreeMap<K, V>) -> bool {\n     return a_len < b_len;\n }\n \n-impl<K:Ord,V> Ord for TreeMap<K, V> {\n+impl<K: Ord + TotalOrd, V> Ord for TreeMap<K, V> {\n     #[inline(always)]\n     pure fn lt(&self, other: &TreeMap<K, V>) -> bool {\n         lt(self, other)\n@@ -97,38 +94,38 @@ impl<K:Ord,V> Ord for TreeMap<K, V> {\n     }\n }\n \n-impl<K:Ord,V> BaseIter<(&K, &V)> for TreeMap<K, V> {\n+impl<K: TotalOrd, V> BaseIter<(&K, &V)> for TreeMap<K, V> {\n     /// Visit all key-value pairs in order\n     pure fn each(&self, f: fn(&(&self/K, &self/V)) -> bool) {\n         each(&self.root, f)\n     }\n     pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n-impl<K:Ord,V> ReverseIter<(&K, &V)> for TreeMap<K, V> {\n+impl<K: TotalOrd, V> ReverseIter<(&K, &V)> for TreeMap<K, V> {\n     /// Visit all key-value pairs in reverse order\n     pure fn each_reverse(&self, f: fn(&(&self/K, &self/V)) -> bool) {\n         each_reverse(&self.root, f);\n     }\n }\n \n-impl<K:Ord,V> Container for TreeMap<K, V> {\n+impl<K: TotalOrd, V> Container for TreeMap<K, V> {\n     /// Return the number of elements in the map\n     pure fn len(&self) -> uint { self.length }\n \n     /// Return true if the map contains no elements\n     pure fn is_empty(&self) -> bool { self.root.is_none() }\n }\n \n-impl<K:Ord,V> Mutable for TreeMap<K, V> {\n+impl<K: TotalOrd, V> Mutable for TreeMap<K, V> {\n     /// Clear the map, removing all key-value pairs.\n     fn clear(&mut self) {\n         self.root = None;\n         self.length = 0\n     }\n }\n \n-impl<K:Ord,V> Map<K, V> for TreeMap<K, V> {\n+impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n     /// Return true if the map contains a value for the specified key\n     pure fn contains_key(&self, key: &K) -> bool {\n         self.find(key).is_some()\n@@ -146,12 +143,10 @@ impl<K:Ord,V> Map<K, V> for TreeMap<K, V> {\n         loop {\n             match *current {\n               Some(ref r) => {\n-                if *key < r.key {\n-                    current = &r.left;\n-                } else if r.key < *key {\n-                    current = &r.right;\n-                } else {\n-                    return Some(&r.value);\n+                match key.cmp(&r.key) {\n+                   Less => current = &r.left,\n+                   Greater => current = &r.right,\n+                   Equal => return Some(&r.value)\n                 }\n               }\n               None => return None\n@@ -177,7 +172,7 @@ impl<K:Ord,V> Map<K, V> for TreeMap<K, V> {\n     }\n }\n \n-pub impl <K:Ord,V> TreeMap<K, V> {\n+pub impl<K: TotalOrd, V> TreeMap<K, V> {\n     /// Create an empty TreeMap\n     static pure fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n \n@@ -207,7 +202,7 @@ pub struct TreeMapIterator<K, V> {\n /// Advance the iterator to the next node (in order) and return a\n /// tuple with a reference to the key and value. If there are no\n /// more nodes, return `None`.\n-pub fn map_next<K: Ord, V>(iter: &mut TreeMapIterator/&r<K, V>)\n+pub fn map_next<K, V>(iter: &mut TreeMapIterator/&r<K, V>)\n                         -> Option<(&r/K, &r/V)> {\n     while !iter.stack.is_empty() || iter.node.is_some() {\n         match *iter.node {\n@@ -226,8 +221,8 @@ pub fn map_next<K: Ord, V>(iter: &mut TreeMapIterator/&r<K, V>)\n }\n \n /// Advance the iterator through the map\n-pub fn map_advance<K: Ord, V>(iter: &mut TreeMapIterator/&r<K, V>,\n-                          f: fn((&r/K, &r/V)) -> bool) {\n+pub fn map_advance<K, V>(iter: &mut TreeMapIterator/&r<K, V>,\n+                         f: fn((&r/K, &r/V)) -> bool) {\n     loop {\n         match map_next(iter) {\n           Some(x) => {\n@@ -242,25 +237,25 @@ pub struct TreeSet<T> {\n     priv map: TreeMap<T, ()>\n }\n \n-impl<T:Ord> BaseIter<T> for TreeSet<T> {\n+impl<T: TotalOrd> BaseIter<T> for TreeSet<T> {\n     /// Visit all values in order\n     pure fn each(&self, f: fn(&T) -> bool) { self.map.each_key(f) }\n     pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n-impl<T:Ord> ReverseIter<T> for TreeSet<T> {\n+impl<T: TotalOrd> ReverseIter<T> for TreeSet<T> {\n     /// Visit all values in reverse order\n     pure fn each_reverse(&self, f: fn(&T) -> bool) {\n         self.map.each_key_reverse(f)\n     }\n }\n \n-impl<T:Eq + Ord> Eq for TreeSet<T> {\n+impl<T: Eq + TotalOrd> Eq for TreeSet<T> {\n     pure fn eq(&self, other: &TreeSet<T>) -> bool { self.map == other.map }\n     pure fn ne(&self, other: &TreeSet<T>) -> bool { self.map != other.map }\n }\n \n-impl<T:Ord> Ord for TreeSet<T> {\n+impl<T: Ord + TotalOrd> Ord for TreeSet<T> {\n     #[inline(always)]\n     pure fn lt(&self, other: &TreeSet<T>) -> bool { self.map < other.map }\n     #[inline(always)]\n@@ -271,20 +266,20 @@ impl<T:Ord> Ord for TreeSet<T> {\n     pure fn gt(&self, other: &TreeSet<T>) -> bool { self.map > other.map }\n }\n \n-impl<T:Ord> Container for TreeSet<T> {\n+impl<T: TotalOrd> Container for TreeSet<T> {\n     /// Return the number of elements in the set\n     pure fn len(&self) -> uint { self.map.len() }\n \n     /// Return true if the set contains no elements\n     pure fn is_empty(&self) -> bool { self.map.is_empty() }\n }\n \n-impl<T:Ord> Mutable for TreeSet<T> {\n+impl<T: TotalOrd> Mutable for TreeSet<T> {\n     /// Clear the set, removing all values.\n     fn clear(&mut self) { self.map.clear() }\n }\n \n-impl<T:Ord> Set<T> for TreeSet<T> {\n+impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     /// Return true if the set contains a value\n     pure fn contains(&self, value: &T) -> bool {\n         self.map.contains_key(value)\n@@ -309,12 +304,10 @@ impl<T:Ord> Set<T> for TreeSet<T> {\n             while a.is_some() && b.is_some() {\n                 let a1 = a.unwrap();\n                 let b1 = b.unwrap();\n-                if a1 < b1 {\n-                    a = set_next(&mut x);\n-                } else if b1 < a1 {\n-                    b = set_next(&mut y);\n-                } else {\n-                    return false;\n+                match a1.cmp(b1) {\n+                  Less => a = set_next(&mut x),\n+                  Greater => b = set_next(&mut y),\n+                  Equal => return false\n                 }\n             }\n         }\n@@ -341,13 +334,12 @@ impl<T:Ord> Set<T> for TreeSet<T> {\n                 let a1 = a.unwrap();\n                 let b1 = b.unwrap();\n \n-                if b1 < a1 {\n-                    return false\n+                match a1.cmp(b1) {\n+                  Less => (),\n+                  Greater => return false,\n+                  Equal => b = set_next(&mut y),\n                 }\n \n-                if !(a1 < b1) {\n-                    b = set_next(&mut y);\n-                }\n                 a = set_next(&mut x);\n             }\n         }\n@@ -373,11 +365,13 @@ impl<T:Ord> Set<T> for TreeSet<T> {\n                 let a1 = a.unwrap();\n                 let b1 = b.unwrap();\n \n-                if a1 < b1 {\n+                let cmp = a1.cmp(b1);\n+\n+                if cmp == Less {\n                     if !f(a1) { return }\n                     a = set_next(&mut x);\n                 } else {\n-                    if !(b1 < a1) { a = set_next(&mut x) }\n+                    if cmp == Equal { a = set_next(&mut x) }\n                     b = set_next(&mut y);\n                 }\n             }\n@@ -404,11 +398,13 @@ impl<T:Ord> Set<T> for TreeSet<T> {\n                 let a1 = a.unwrap();\n                 let b1 = b.unwrap();\n \n-                if a1 < b1 {\n+                let cmp = a1.cmp(b1);\n+\n+                if cmp == Less {\n                     if !f(a1) { return }\n                     a = set_next(&mut x);\n                 } else {\n-                    if b1 < a1 {\n+                    if cmp == Greater {\n                         if !f(b1) { return }\n                     } else {\n                         a = set_next(&mut x);\n@@ -434,10 +430,13 @@ impl<T:Ord> Set<T> for TreeSet<T> {\n             while a.is_some() && b.is_some() {\n                 let a1 = a.unwrap();\n                 let b1 = b.unwrap();\n-                if a1 < b1 {\n+\n+                let cmp = a1.cmp(b1);\n+\n+                if cmp == Less {\n                     a = set_next(&mut x);\n                 } else {\n-                    if !(b1 < a1) {\n+                    if cmp == Equal {\n                         if !f(a1) { return }\n                     }\n                     b = set_next(&mut y);\n@@ -465,12 +464,14 @@ impl<T:Ord> Set<T> for TreeSet<T> {\n                 let a1 = a.unwrap();\n                 let b1 = b.unwrap();\n \n-                if b1 < a1 {\n+                let cmp = a1.cmp(b1);\n+\n+                if cmp == Greater {\n                     if !f(b1) { return }\n                     b = set_next(&mut y);\n                 } else {\n                     if !f(a1) { return }\n-                    if !(a1 < b1) {\n+                    if cmp == Equal {\n                         b = set_next(&mut y);\n                     }\n                     a = set_next(&mut x);\n@@ -480,7 +481,7 @@ impl<T:Ord> Set<T> for TreeSet<T> {\n     }\n }\n \n-pub impl <T:Ord> TreeSet<T> {\n+pub impl <T: TotalOrd> TreeSet<T> {\n     /// Create an empty TreeSet\n     static pure fn new() -> TreeSet<T> { TreeSet{map: TreeMap::new()} }\n \n@@ -498,12 +499,12 @@ pub struct TreeSetIterator<T> {\n \n /// Advance the iterator to the next node (in order). If this iterator is\n /// finished, does nothing.\n-pub fn set_next<T: Ord>(iter: &mut TreeSetIterator/&r<T>) -> Option<&r/T> {\n+pub fn set_next<T>(iter: &mut TreeSetIterator/&r<T>) -> Option<&r/T> {\n     do map_next(&mut iter.iter).map |&(value, _)| { value }\n }\n \n /// Advance the iterator through the set\n-fn set_advance<T: Ord>(iter: &mut TreeSetIterator/&r<T>,\n+fn set_advance<T>(iter: &mut TreeSetIterator/&r<T>,\n                        f: fn(&r/T) -> bool) {\n     do map_advance(&mut iter.iter) |(k, _)| { f(k) }\n }\n@@ -518,22 +519,22 @@ struct TreeNode<K, V> {\n     level: uint\n }\n \n-pub impl <K:Ord,V> TreeNode<K, V> {\n+pub impl<K: TotalOrd, V> TreeNode<K, V> {\n     #[inline(always)]\n     static pure fn new(key: K, value: V) -> TreeNode<K, V> {\n         TreeNode{key: key, value: value, left: None, right: None, level: 1}\n     }\n }\n \n-pure fn each<K:Ord,V>(node: &r/Option<~TreeNode<K, V>>,\n+pure fn each<K: TotalOrd, V>(node: &r/Option<~TreeNode<K, V>>,\n                         f: fn(&(&r/K, &r/V)) -> bool) {\n     do node.iter |x| {\n         each(&x.left, f);\n         if f(&(&x.key, &x.value)) { each(&x.right, f) }\n     }\n }\n \n-pure fn each_reverse<K:Ord,V>(node: &r/Option<~TreeNode<K, V>>,\n+pure fn each_reverse<K: TotalOrd, V>(node: &r/Option<~TreeNode<K, V>>,\n                                 f: fn(&(&r/K, &r/V)) -> bool) {\n     do node.iter |x| {\n         each_reverse(&x.right, f);\n@@ -542,7 +543,7 @@ pure fn each_reverse<K:Ord,V>(node: &r/Option<~TreeNode<K, V>>,\n }\n \n // Remove left horizontal link by rotating right\n-fn skew<K:Ord,V>(node: &mut ~TreeNode<K, V>) {\n+fn skew<K: TotalOrd, V>(node: &mut ~TreeNode<K, V>) {\n     if node.left.map_default(false, |x| x.level == node.level) {\n         let mut save = node.left.swap_unwrap();\n         node.left <-> save.right; // save.right now None\n@@ -553,7 +554,7 @@ fn skew<K:Ord,V>(node: &mut ~TreeNode<K, V>) {\n \n // Remove dual horizontal link by rotating left and increasing level of\n // the parent\n-fn split<K:Ord,V>(node: &mut ~TreeNode<K, V>) {\n+fn split<K: TotalOrd, V>(node: &mut ~TreeNode<K, V>) {\n     if node.right.map_default(false,\n       |x| x.right.map_default(false, |y| y.level == node.level)) {\n         let mut save = node.right.swap_unwrap();\n@@ -564,24 +565,28 @@ fn split<K:Ord,V>(node: &mut ~TreeNode<K, V>) {\n     }\n }\n \n-fn insert<K:Ord,V>(node: &mut Option<~TreeNode<K, V>>, key: K,\n-                     value: V) -> bool {\n+fn insert<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>, key: K,\n+                          value: V) -> bool {\n     match *node {\n       Some(ref mut save) => {\n-        if key < save.key {\n+        match key.cmp(&save.key) {\n+          Less => {\n             let inserted = insert(&mut save.left, key, value);\n             skew(save);\n             split(save);\n             inserted\n-        } else if save.key < key {\n+          }\n+          Greater => {\n             let inserted = insert(&mut save.right, key, value);\n             skew(save);\n             split(save);\n             inserted\n-        } else {\n+          }\n+          Equal => {\n             save.key = key;\n             save.value = value;\n             false\n+          }\n         }\n       }\n       None => {\n@@ -591,8 +596,9 @@ fn insert<K:Ord,V>(node: &mut Option<~TreeNode<K, V>>, key: K,\n     }\n }\n \n-fn remove<K:Ord,V>(node: &mut Option<~TreeNode<K, V>>, key: &K) -> bool {\n-    fn heir_swap<K:Ord,V>(node: &mut ~TreeNode<K, V>,\n+fn remove<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>,\n+                          key: &K) -> bool {\n+    fn heir_swap<K: TotalOrd, V>(node: &mut ~TreeNode<K, V>,\n                             child: &mut Option<~TreeNode<K, V>>) {\n         // *could* be done without recursion, but it won't borrow check\n         do child.mutate |mut child| {\n@@ -611,11 +617,10 @@ fn remove<K:Ord,V>(node: &mut Option<~TreeNode<K, V>>, key: &K) -> bool {\n         return false // bottom of tree\n       }\n       Some(ref mut save) => {\n-        let (removed, this) = if save.key < *key {\n-            (remove(&mut save.right, key), false)\n-        } else if *key < save.key {\n-            (remove(&mut save.left, key), false)\n-        } else {\n+        let (removed, this) = match key.cmp(&save.key) {\n+          Less => (remove(&mut save.left, key), false),\n+          Greater => (remove(&mut save.right, key), false),\n+          Equal => {\n             if save.left.is_some() {\n                 if save.right.is_some() {\n                     let mut left = save.left.swap_unwrap();\n@@ -637,6 +642,7 @@ fn remove<K:Ord,V>(node: &mut Option<~TreeNode<K, V>>, key: &K) -> bool {\n             } else {\n                 (true, true)\n             }\n+          }\n         };\n \n         if !this {\n@@ -682,12 +688,9 @@ fn remove<K:Ord,V>(node: &mut Option<~TreeNode<K, V>>, key: &K) -> bool {\n \n #[cfg(test)]\n mod test_treemap {\n+    use core::prelude::*;\n     use super::*;\n-    use core::cmp::{Ord, Eq};\n-    use core::option::{Some, Option, None};\n     use core::rand;\n-    use core::str;\n-    use core::vec;\n \n     #[test]\n     fn find_empty() {\n@@ -742,7 +745,8 @@ mod test_treemap {\n         assert m.find(&k1) == Some(&v1);\n     }\n \n-    fn check_equal<K:Eq + Ord,V:Eq>(ctrl: &[(K, V)], map: &TreeMap<K, V>) {\n+    fn check_equal<K: Eq + TotalOrd, V: Eq>(ctrl: &[(K, V)],\n+                                            map: &TreeMap<K, V>) {\n         assert ctrl.is_empty() == map.is_empty();\n         for ctrl.each |x| {\n             let &(k, v) = x;\n@@ -762,11 +766,11 @@ mod test_treemap {\n         }\n     }\n \n-    fn check_left<K:Ord,V>(node: &Option<~TreeNode<K, V>>,\n-                             parent: &~TreeNode<K, V>) {\n+    fn check_left<K: TotalOrd, V>(node: &Option<~TreeNode<K, V>>,\n+                                  parent: &~TreeNode<K, V>) {\n         match *node {\n           Some(ref r) => {\n-            assert r.key < parent.key;\n+            assert r.key.cmp(&parent.key) == Less;\n             assert r.level == parent.level - 1; // left is black\n             check_left(&r.left, r);\n             check_right(&r.right, r, false);\n@@ -775,11 +779,12 @@ mod test_treemap {\n         }\n     }\n \n-    fn check_right<K:Ord,V>(node: &Option<~TreeNode<K, V>>,\n-                              parent: &~TreeNode<K, V>, parent_red: bool) {\n+    fn check_right<K: TotalOrd, V>(node: &Option<~TreeNode<K, V>>,\n+                                   parent: &~TreeNode<K, V>,\n+                                   parent_red: bool) {\n         match *node {\n           Some(ref r) => {\n-            assert r.key > parent.key;\n+            assert r.key.cmp(&parent.key) == Greater;\n             let red = r.level == parent.level;\n             if parent_red { assert !red } // no dual horizontal links\n             assert red || r.level == parent.level - 1; // right red or black\n@@ -790,7 +795,7 @@ mod test_treemap {\n         }\n     }\n \n-    fn check_structure<K:Ord,V>(map: &TreeMap<K, V>) {\n+    fn check_structure<K: TotalOrd, V>(map: &TreeMap<K, V>) {\n         match map.root {\n           Some(ref r) => {\n             check_left(&r.left, r);"}]}