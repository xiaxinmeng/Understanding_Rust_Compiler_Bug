{"sha": "8471da62e64b3c143e2fea2ad4cf43732ff27c47", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0NzFkYTYyZTY0YjNjMTQzZTJmZWEyYWQ0Y2Y0MzczMmZmMjdjNDc=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-03-02T13:38:51Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-03-02T15:35:52Z"}, "message": "Compress tests", "tree": {"sha": "84500b04b7a041894608269560eeee1ac5c40682", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84500b04b7a041894608269560eeee1ac5c40682"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8471da62e64b3c143e2fea2ad4cf43732ff27c47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8471da62e64b3c143e2fea2ad4cf43732ff27c47", "html_url": "https://github.com/rust-lang/rust/commit/8471da62e64b3c143e2fea2ad4cf43732ff27c47", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8471da62e64b3c143e2fea2ad4cf43732ff27c47/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7066e6b3620d06dbc2143b9dfdda4d7c97d6a8ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/7066e6b3620d06dbc2143b9dfdda4d7c97d6a8ba", "html_url": "https://github.com/rust-lang/rust/commit/7066e6b3620d06dbc2143b9dfdda4d7c97d6a8ba"}], "stats": {"total": 1040, "additions": 424, "deletions": 616}, "files": [{"sha": "b7f6167607a1d243209a18d4a1921f7cddc4d18d", "filename": "crates/ide_assists/src/tests.rs", "status": "modified", "additions": 1, "deletions": 45, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8471da62e64b3c143e2fea2ad4cf43732ff27c47/crates%2Fide_assists%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8471da62e64b3c143e2fea2ad4cf43732ff27c47/crates%2Fide_assists%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Ftests.rs?ref=8471da62e64b3c143e2fea2ad4cf43732ff27c47", "patch": "@@ -12,7 +12,7 @@ use ide_db::{\n     RootDatabase,\n };\n use stdx::{format_to, trim_indent};\n-use syntax::{ast, AstNode, TextRange};\n+use syntax::TextRange;\n use test_utils::{assert_eq_text, extract_offset};\n \n use crate::{handlers::Handler, Assist, AssistConfig, AssistContext, AssistKind, Assists};\n@@ -180,50 +180,6 @@ fn labels(assists: &[Assist]) -> String {\n     labels.into_iter().collect::<String>()\n }\n \n-pub(crate) type NameSuggestion = fn(&ast::Expr, &Semantics<'_, RootDatabase>) -> Option<String>;\n-\n-#[track_caller]\n-pub(crate) fn check_name_suggestion(\n-    suggestion: NameSuggestion,\n-    ra_fixture: &str,\n-    suggested_name: &str,\n-) {\n-    check_name(suggestion, ra_fixture, Some(suggested_name));\n-}\n-\n-#[track_caller]\n-pub(crate) fn check_name_suggestion_not_applicable(suggestion: NameSuggestion, ra_fixture: &str) {\n-    check_name(suggestion, ra_fixture, None);\n-}\n-\n-#[track_caller]\n-fn check_name(suggestion: NameSuggestion, ra_fixture: &str, expected: Option<&str>) {\n-    let (db, file_with_carret_id, range_or_offset) = RootDatabase::with_range_or_offset(ra_fixture);\n-    let frange = FileRange { file_id: file_with_carret_id, range: range_or_offset.into() };\n-\n-    let sema = Semantics::new(&db);\n-    let source_file = sema.parse(frange.file_id);\n-    let element = source_file.syntax().covering_element(frange.range);\n-    let expr =\n-        element.ancestors().find_map(ast::Expr::cast).expect(\"selection is not an expression\");\n-    assert_eq!(\n-        expr.syntax().text_range(),\n-        frange.range,\n-        \"selection is not an expression(yet contained in one)\"\n-    );\n-\n-    let name = suggestion(&expr, &sema);\n-\n-    match (name, expected) {\n-        (Some(name), Some(expected_name)) => {\n-            assert_eq_text!(&name, expected_name);\n-        }\n-        (Some(_), None) => panic!(\"name suggestion should not be applicable\"),\n-        (None, Some(_)) => panic!(\"name suggestion is not applicable\"),\n-        (None, None) => (),\n-    }\n-}\n-\n #[test]\n fn assist_order_field_struct() {\n     let before = \"struct Foo { $0bar: u32 }\";"}, {"sha": "533624c1fd42f00e75f42417cafa932ff0776784", "filename": "crates/ide_assists/src/utils/suggest_name.rs", "status": "modified", "additions": 423, "deletions": 571, "changes": 994, "blob_url": "https://github.com/rust-lang/rust/blob/8471da62e64b3c143e2fea2ad4cf43732ff27c47/crates%2Fide_assists%2Fsrc%2Futils%2Fsuggest_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8471da62e64b3c143e2fea2ad4cf43732ff27c47/crates%2Fide_assists%2Fsrc%2Futils%2Fsuggest_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils%2Fsuggest_name.rs?ref=8471da62e64b3c143e2fea2ad4cf43732ff27c47", "patch": "@@ -11,24 +11,28 @@ use syntax::{\n \n /// Trait names, that will be ignored when in `impl Trait` and `dyn Trait`\n const USELESS_TRAITS: &[&str] = &[\"Send\", \"Sync\", \"Copy\", \"Clone\", \"Eq\", \"PartialEq\"];\n+\n /// Identifier names that won't be suggested, ever\n ///\n /// **NOTE**: they all must be snake lower case\n const USELESS_NAMES: &[&str] =\n     &[\"new\", \"default\", \"option\", \"some\", \"none\", \"ok\", \"err\", \"str\", \"string\"];\n+\n /// Generic types replaced by their first argument\n ///\n /// # Examples\n /// `Option<Name>` -> `Name`\n /// `Result<User, Error>` -> `User`\n const WRAPPER_TYPES: &[&str] = &[\"Box\", \"Option\", \"Result\"];\n+\n /// Prefixes to strip from methods names\n ///\n /// # Examples\n /// `vec.as_slice()` -> `slice`\n /// `args.into_config()` -> `config`\n /// `bytes.to_vec()` -> `vec`\n const USELESS_METHOD_PREFIXES: &[&str] = &[\"into_\", \"as_\", \"to_\"];\n+\n /// Useless methods that are stripped from expression\n ///\n /// # Examples\n@@ -253,625 +257,473 @@ fn trait_name(trait_: &hir::Trait, db: &RootDatabase) -> Option<String> {\n \n #[cfg(test)]\n mod tests {\n-    use super::*;\n-\n-    use crate::tests::check_name_suggestion;\n-\n-    mod from_func_call {\n-        use super::*;\n-\n-        #[test]\n-        fn no_args() {\n-            check_name_suggestion(\n-                |e, _| from_func_call(e),\n-                r#\"\n-                fn foo() {\n-                    $0bar()$0\n-                }\"#,\n-                \"bar\",\n-            );\n-        }\n+    use ide_db::base_db::{fixture::WithFixture, FileRange};\n \n-        #[test]\n-        fn single_arg() {\n-            check_name_suggestion(\n-                |e, _| from_func_call(e),\n-                r#\"\n-                fn foo() {\n-                    $0bar(1)$0\n-                }\"#,\n-                \"bar\",\n-            );\n-        }\n-\n-        #[test]\n-        fn many_args() {\n-            check_name_suggestion(\n-                |e, _| from_func_call(e),\n-                r#\"\n-                fn foo() {\n-                    $0bar(1, 2, 3)$0\n-                }\"#,\n-                \"bar\",\n-            );\n-        }\n-\n-        #[test]\n-        fn path() {\n-            check_name_suggestion(\n-                |e, _| from_func_call(e),\n-                r#\"\n-                fn foo() {\n-                    $0i32::bar(1, 2, 3)$0\n-                }\"#,\n-                \"bar\",\n-            );\n-        }\n+    use super::*;\n \n-        #[test]\n-        fn generic_params() {\n-            check_name_suggestion(\n-                |e, _| from_func_call(e),\n-                r#\"\n-                fn foo() {\n-                    $0bar::<i32>(1, 2, 3)$0\n-                }\"#,\n-                \"bar\",\n-            );\n-        }\n+    #[track_caller]\n+    fn check(ra_fixture: &str, expected: &str) {\n+        let (db, file_id, range_or_offset) = RootDatabase::with_range_or_offset(ra_fixture);\n+        let frange = FileRange { file_id, range: range_or_offset.into() };\n+\n+        let sema = Semantics::new(&db);\n+        let source_file = sema.parse(frange.file_id);\n+        let element = source_file.syntax().covering_element(frange.range);\n+        let expr =\n+            element.ancestors().find_map(ast::Expr::cast).expect(\"selection is not an expression\");\n+        assert_eq!(\n+            expr.syntax().text_range(),\n+            frange.range,\n+            \"selection is not an expression(yet contained in one)\"\n+        );\n+        let name = variable(&expr, &sema);\n+        assert_eq!(&name, expected);\n     }\n \n-    mod from_method_call {\n-        use super::*;\n-\n-        #[test]\n-        fn no_args() {\n-            check_name_suggestion(\n-                |e, _| from_method_call(e),\n-                r#\"\n-                fn foo() {\n-                    $0bar.frobnicate()$0\n-                }\"#,\n-                \"frobnicate\",\n-            );\n-        }\n-\n-        #[test]\n-        fn generic_params() {\n-            check_name_suggestion(\n-                |e, _| from_method_call(e),\n-                r#\"\n-                fn foo() {\n-                    $0bar.frobnicate::<i32, u32>()$0\n-                }\"#,\n-                \"frobnicate\",\n-            );\n-        }\n-\n-        #[test]\n-        fn to_name() {\n-            check_name_suggestion(\n-                |e, _| from_method_call(e),\n-                r#\"\n-                struct Args;\n-                struct Config;\n-                impl Args {\n-                    fn to_config(&self) -> Config {}\n-                }\n-                fn foo() {\n-                    $0Args.to_config()$0;\n-                }\"#,\n-                \"config\",\n-            );\n-        }\n+    #[test]\n+    fn no_args() {\n+        check(r#\"fn foo() { $0bar()$0 }\"#, \"bar\");\n+        check(r#\"fn foo() { $0bar.frobnicate()$0 }\"#, \"frobnicate\");\n     }\n \n-    mod from_param {\n-        use crate::tests::check_name_suggestion_not_applicable;\n+    #[test]\n+    fn single_arg() {\n+        check(r#\"fn foo() { $0bar(1)$0 }\"#, \"bar\");\n+    }\n \n-        use super::*;\n+    #[test]\n+    fn many_args() {\n+        check(r#\"fn foo() { $0bar(1, 2, 3)$0 }\"#, \"bar\");\n+    }\n \n-        #[test]\n-        fn plain_func() {\n-            check_name_suggestion(\n-                from_param,\n-                r#\"\n-                fn bar(n: i32, m: u32);\n-                fn foo() {\n-                    bar($01$0, 2)\n-                }\"#,\n-                \"n\",\n-            );\n-        }\n+    #[test]\n+    fn path() {\n+        check(r#\"fn foo() { $0i32::bar(1, 2, 3)$0 }\"#, \"bar\");\n+    }\n \n-        #[test]\n-        fn mut_param() {\n-            check_name_suggestion(\n-                from_param,\n-                r#\"\n-                fn bar(mut n: i32, m: u32);\n-                fn foo() {\n-                    bar($01$0, 2)\n-                }\"#,\n-                \"n\",\n-            );\n-        }\n+    #[test]\n+    fn generic_params() {\n+        check(r#\"fn foo() { $0bar::<i32>(1, 2, 3)$0 }\"#, \"bar\");\n+        check(r#\"fn foo() { $0bar.frobnicate::<i32, u32>()$0 }\"#, \"frobnicate\");\n+    }\n \n-        #[test]\n-        fn func_does_not_exist() {\n-            check_name_suggestion_not_applicable(\n-                from_param,\n-                r#\"\n-                fn foo() {\n-                    bar($01$0, 2)\n-                }\"#,\n-            );\n-        }\n+    #[test]\n+    fn to_name() {\n+        check(\n+            r#\"\n+struct Args;\n+struct Config;\n+impl Args {\n+    fn to_config(&self) -> Config {}\n+}\n+fn foo() {\n+    $0Args.to_config()$0;\n+}\n+\"#,\n+            \"config\",\n+        );\n+    }\n \n-        #[test]\n-        fn unnamed_param() {\n-            check_name_suggestion_not_applicable(\n-                from_param,\n-                r#\"\n-                fn bar(_: i32, m: u32);\n-                fn foo() {\n-                    bar($01$0, 2)\n-                }\"#,\n-            );\n-        }\n+    #[test]\n+    fn plain_func() {\n+        check(\n+            r#\"\n+fn bar(n: i32, m: u32);\n+fn foo() { bar($01$0, 2) }\n+\"#,\n+            \"n\",\n+        );\n+    }\n \n-        #[test]\n-        fn tuple_pat() {\n-            check_name_suggestion_not_applicable(\n-                from_param,\n-                r#\"\n-                fn bar((n, k): (i32, i32), m: u32);\n-                fn foo() {\n-                    bar($0(1, 2)$0, 3)\n-                }\"#,\n-            );\n-        }\n+    #[test]\n+    fn mut_param() {\n+        check(\n+            r#\"\n+fn bar(mut n: i32, m: u32);\n+fn foo() { bar($01$0, 2) }\n+\"#,\n+            \"n\",\n+        );\n+    }\n \n-        #[test]\n-        fn ref_pat() {\n-            check_name_suggestion(\n-                from_param,\n-                r#\"\n-                fn bar(&n: &i32, m: u32);\n-                fn foo() {\n-                    bar($0&1$0, 3)\n-                }\"#,\n-                \"n\",\n-            );\n-        }\n+    #[test]\n+    fn func_does_not_exist() {\n+        check(r#\"fn foo() { bar($01$0, 2) }\"#, \"var_name\");\n+    }\n \n-        #[test]\n-        fn box_pat() {\n-            check_name_suggestion(\n-                from_param,\n-                r#\"\n-                fn bar(box n: &i32, m: u32);\n-                fn foo() {\n-                    bar($01$0, 3)\n-                }\"#,\n-                \"n\",\n-            );\n-        }\n+    #[test]\n+    fn unnamed_param() {\n+        check(\n+            r#\"\n+fn bar(_: i32, m: u32);\n+fn foo() { bar($01$0, 2) }\n+\"#,\n+            \"var_name\",\n+        );\n+    }\n \n-        #[test]\n-        fn param_out_of_index() {\n-            check_name_suggestion_not_applicable(\n-                from_param,\n-                r#\"\n-                fn bar(n: i32, m: u32);\n-                fn foo() {\n-                    bar(1, 2, $03$0)\n-                }\"#,\n-            );\n-        }\n+    #[test]\n+    fn tuple_pat() {\n+        check(\n+            r#\"\n+fn bar((n, k): (i32, i32), m: u32);\n+fn foo() {\n+    bar($0(1, 2)$0, 3)\n+}\n+\"#,\n+            \"var_name\",\n+        );\n+    }\n \n-        #[test]\n-        fn generic_param_resolved() {\n-            check_name_suggestion(\n-                from_param,\n-                r#\"\n-                fn bar<T>(n: T, m: u32);\n-                fn foo() {\n-                    bar($01$0, 2)\n-                }\"#,\n-                \"n\",\n-            );\n-        }\n+    #[test]\n+    fn ref_pat() {\n+        check(\n+            r#\"\n+fn bar(&n: &i32, m: u32);\n+fn foo() { bar($0&1$0, 3) }\n+\"#,\n+            \"n\",\n+        );\n+    }\n \n-        #[test]\n-        fn generic_param_unresolved() {\n-            check_name_suggestion(\n-                from_param,\n-                r#\"\n-                fn bar<T>(n: T, m: u32);\n-                fn foo<T>(x: T) {\n-                    bar($0x$0, 2)\n-                }\"#,\n-                \"n\",\n-            );\n-        }\n+    #[test]\n+    fn box_pat() {\n+        check(\n+            r#\"\n+fn bar(box n: &i32, m: u32);\n+fn foo() { bar($01$0, 3) }\n+\"#,\n+            \"n\",\n+        );\n+    }\n \n-        #[test]\n-        fn method() {\n-            check_name_suggestion(\n-                from_param,\n-                r#\"\n-                struct S;\n-                impl S {\n-                    fn bar(&self, n: i32, m: u32);\n-                }\n-                fn foo() {\n-                    S.bar($01$0, 2)\n-                }\"#,\n-                \"n\",\n-            );\n-        }\n+    #[test]\n+    fn param_out_of_index() {\n+        check(\n+            r#\"\n+fn bar(n: i32, m: u32);\n+fn foo() { bar(1, 2, $03$0) }\n+\"#,\n+            \"var_name\",\n+        );\n+    }\n \n-        #[test]\n-        fn method_ufcs() {\n-            check_name_suggestion(\n-                from_param,\n-                r#\"\n-                struct S;\n-                impl S {\n-                    fn bar(&self, n: i32, m: u32);\n-                }\n-                fn foo() {\n-                    S::bar(&S, $01$0, 2)\n-                }\"#,\n-                \"n\",\n-            );\n-        }\n+    #[test]\n+    fn generic_param_resolved() {\n+        check(\n+            r#\"\n+fn bar<T>(n: T, m: u32);\n+fn foo() { bar($01$0, 2) }\n+\"#,\n+            \"n\",\n+        );\n+    }\n \n-        #[test]\n-        fn method_self() {\n-            check_name_suggestion_not_applicable(\n-                from_param,\n-                r#\"\n-                struct S;\n-                impl S {\n-                    fn bar(&self, n: i32, m: u32);\n-                }\n-                fn foo() {\n-                    S::bar($0&S$0, 1, 2)\n-                }\"#,\n-            );\n-        }\n+    #[test]\n+    fn generic_param_unresolved() {\n+        check(\n+            r#\"\n+fn bar<T>(n: T, m: u32);\n+fn foo<T>(x: T) { bar($0x$0, 2) }\n+\"#,\n+            \"n\",\n+        );\n+    }\n \n-        #[test]\n-        fn method_self_named() {\n-            check_name_suggestion(\n-                from_param,\n-                r#\"\n-                struct S;\n-                impl S {\n-                    fn bar(strukt: &Self, n: i32, m: u32);\n-                }\n-                fn foo() {\n-                    S::bar($0&S$0, 1, 2)\n-                }\"#,\n-                \"strukt\",\n-            );\n-        }\n+    #[test]\n+    fn method() {\n+        check(\n+            r#\"\n+struct S;\n+impl S { fn bar(&self, n: i32, m: u32); }\n+fn foo() { S.bar($01$0, 2) }\n+\"#,\n+            \"n\",\n+        );\n     }\n \n-    mod from_type {\n-        use crate::tests::check_name_suggestion_not_applicable;\n+    #[test]\n+    fn method_ufcs() {\n+        check(\n+            r#\"\n+struct S;\n+impl S { fn bar(&self, n: i32, m: u32); }\n+fn foo() { S::bar(&S, $01$0, 2) }\n+\"#,\n+            \"n\",\n+        );\n+    }\n \n-        use super::*;\n+    #[test]\n+    fn method_self() {\n+        check(\n+            r#\"\n+struct S;\n+impl S { fn bar(&self, n: i32, m: u32); }\n+fn foo() { S::bar($0&S$0, 1, 2) }\n+\"#,\n+            \"s\",\n+        );\n+    }\n \n-        #[test]\n-        fn i32() {\n-            check_name_suggestion_not_applicable(\n-                from_type,\n-                r#\"\n-                fn foo() {\n-                    let _: i32 = $01$0;\n-                }\"#,\n-            );\n-        }\n+    #[test]\n+    fn method_self_named() {\n+        check(\n+            r#\"\n+struct S;\n+impl S { fn bar(strukt: &Self, n: i32, m: u32); }\n+fn foo() { S::bar($0&S$0, 1, 2) }\n+\"#,\n+            \"strukt\",\n+        );\n+    }\n \n-        #[test]\n-        fn u64() {\n-            check_name_suggestion_not_applicable(\n-                from_type,\n-                r#\"\n-                fn foo() {\n-                    let _: u64 = $01$0;\n-                }\"#,\n-            );\n-        }\n+    #[test]\n+    fn i32() {\n+        check(r#\"fn foo() { let _: i32 = $01$0; }\"#, \"var_name\");\n+    }\n \n-        #[test]\n-        fn bool() {\n-            check_name_suggestion_not_applicable(\n-                from_type,\n-                r#\"\n-                fn foo() {\n-                    let _: bool = $0true$0;\n-                }\"#,\n-            );\n-        }\n+    #[test]\n+    fn u64() {\n+        check(r#\"fn foo() { let _: u64 = $01$0; }\"#, \"var_name\");\n+    }\n \n-        #[test]\n-        fn struct_unit() {\n-            check_name_suggestion(\n-                from_type,\n-                r#\"\n-                struct Seed;\n-                fn foo() {\n-                    let _ = $0Seed$0;\n-                }\"#,\n-                \"seed\",\n-            );\n-        }\n+    #[test]\n+    fn bool() {\n+        check(r#\"fn foo() { let _: bool = $0true$0; }\"#, \"var_name\");\n+    }\n \n-        #[test]\n-        fn struct_unit_to_snake() {\n-            check_name_suggestion(\n-                from_type,\n-                r#\"\n-                struct SeedState;\n-                fn foo() {\n-                    let _ = $0SeedState$0;\n-                }\"#,\n-                \"seed_state\",\n-            );\n-        }\n+    #[test]\n+    fn struct_unit() {\n+        check(\n+            r#\"\n+struct Seed;\n+fn foo() { let _ = $0Seed$0; }\n+\"#,\n+            \"seed\",\n+        );\n+    }\n \n-        #[test]\n-        fn struct_single_arg() {\n-            check_name_suggestion(\n-                from_type,\n-                r#\"\n-                struct Seed(u32);\n-                fn foo() {\n-                    let _ = $0Seed(0)$0;\n-                }\"#,\n-                \"seed\",\n-            );\n-        }\n+    #[test]\n+    fn struct_unit_to_snake() {\n+        check(\n+            r#\"\n+struct SeedState;\n+fn foo() { let _ = $0SeedState$0; }\n+\"#,\n+            \"seed_state\",\n+        );\n+    }\n \n-        #[test]\n-        fn struct_with_fields() {\n-            check_name_suggestion(\n-                from_type,\n-                r#\"\n-                struct Seed { value: u32 }\n-                fn foo() {\n-                    let _ = $0Seed { value: 0 }$0;\n-                }\"#,\n-                \"seed\",\n-            );\n-        }\n+    #[test]\n+    fn struct_single_arg() {\n+        check(\n+            r#\"\n+struct Seed(u32);\n+fn foo() { let _ = $0Seed(0)$0; }\n+\"#,\n+            \"seed\",\n+        );\n+    }\n \n-        #[test]\n-        fn enum_() {\n-            check_name_suggestion(\n-                from_type,\n-                r#\"\n-                enum Kind { A, B }\n-                fn foo() {\n-                    let _ = $0Kind::A$0;\n-                }\"#,\n-                \"kind\",\n-            );\n-        }\n+    #[test]\n+    fn struct_with_fields() {\n+        check(\n+            r#\"\n+struct Seed { value: u32 }\n+fn foo() { let _ = $0Seed { value: 0 }$0; }\n+\"#,\n+            \"seed\",\n+        );\n+    }\n \n-        #[test]\n-        fn enum_generic_resolved() {\n-            check_name_suggestion(\n-                from_type,\n-                r#\"\n-                enum Kind<T> { A(T), B }\n-                fn foo() {\n-                    let _ = $0Kind::A(1)$0;\n-                }\"#,\n-                \"kind\",\n-            );\n-        }\n+    #[test]\n+    fn enum_() {\n+        check(\n+            r#\"\n+enum Kind { A, B }\n+fn foo() { let _ = $0Kind::A$0; }\n+\"#,\n+            \"kind\",\n+        );\n+    }\n \n-        #[test]\n-        fn enum_generic_unresolved() {\n-            check_name_suggestion(\n-                from_type,\n-                r#\"\n-                enum Kind<T> { A(T), B }\n-                fn foo<T>(x: T) {\n-                    let _ = $0Kind::A(x)$0;\n-                }\"#,\n-                \"kind\",\n-            );\n-        }\n+    #[test]\n+    fn enum_generic_resolved() {\n+        check(\n+            r#\"\n+enum Kind<T> { A { x: T }, B }\n+fn foo() { let _ = $0Kind::A { x:1 }$0; }\n+\"#,\n+            \"kind\",\n+        );\n+    }\n \n-        #[test]\n-        fn dyn_trait() {\n-            check_name_suggestion(\n-                from_type,\n-                r#\"\n-                trait DynHandler {}\n-                fn bar() -> dyn DynHandler {}\n-                fn foo() {\n-                    $0bar()$0;\n-                }\"#,\n-                \"dyn_handler\",\n-            );\n-        }\n+    #[test]\n+    fn enum_generic_unresolved() {\n+        check(\n+            r#\"\n+enum Kind<T> { A { x: T }, B }\n+fn foo<T>(x: T) { let _ = $0Kind::A { x }$0; }\n+\"#,\n+            \"kind\",\n+        );\n+    }\n \n-        #[test]\n-        fn impl_trait() {\n-            check_name_suggestion(\n-                from_type,\n-                r#\"\n-                trait StaticHandler {}\n-                fn bar() -> impl StaticHandler {}\n-                fn foo() {\n-                    $0bar()$0;\n-                }\"#,\n-                \"static_handler\",\n-            );\n-        }\n+    #[test]\n+    fn dyn_trait() {\n+        check(\n+            r#\"\n+trait DynHandler {}\n+fn bar() -> dyn DynHandler {}\n+fn foo() { $0(bar())$0; }\n+\"#,\n+            \"dyn_handler\",\n+        );\n+    }\n \n-        #[test]\n-        fn impl_trait_plus_clone() {\n-            check_name_suggestion(\n-                from_type,\n-                r#\"\n-                trait StaticHandler {}\n-                trait Clone {}\n-                fn bar() -> impl StaticHandler + Clone {}\n-                fn foo() {\n-                    $0bar()$0;\n-                }\"#,\n-                \"static_handler\",\n-            );\n-        }\n+    #[test]\n+    fn impl_trait() {\n+        check(\n+            r#\"\n+trait StaticHandler {}\n+fn bar() -> impl StaticHandler {}\n+fn foo() { $0(bar())$0; }\n+\"#,\n+            \"static_handler\",\n+        );\n+    }\n \n-        #[test]\n-        fn impl_trait_plus_lifetime() {\n-            check_name_suggestion(\n-                from_type,\n-                r#\"\n-                trait StaticHandler {}\n-                trait Clone {}\n-                fn bar<'a>(&'a i32) -> impl StaticHandler + 'a {}\n-                fn foo() {\n-                    $0bar(&1)$0;\n-                }\"#,\n-                \"static_handler\",\n-            );\n-        }\n+    #[test]\n+    fn impl_trait_plus_clone() {\n+        check(\n+            r#\"\n+trait StaticHandler {}\n+trait Clone {}\n+fn bar() -> impl StaticHandler + Clone {}\n+fn foo() { $0(bar())$0; }\n+\"#,\n+            \"static_handler\",\n+        );\n+    }\n \n-        #[test]\n-        fn impl_trait_plus_trait() {\n-            check_name_suggestion_not_applicable(\n-                from_type,\n-                r#\"\n-                trait Handler {}\n-                trait StaticHandler {}\n-                fn bar() -> impl StaticHandler + Handler {}\n-                fn foo() {\n-                    $0bar()$0;\n-                }\"#,\n-            );\n-        }\n+    #[test]\n+    fn impl_trait_plus_lifetime() {\n+        check(\n+            r#\"\n+trait StaticHandler {}\n+trait Clone {}\n+fn bar<'a>(&'a i32) -> impl StaticHandler + 'a {}\n+fn foo() { $0(bar(&1))$0; }\n+\"#,\n+            \"static_handler\",\n+        );\n+    }\n \n-        #[test]\n-        fn ref_value() {\n-            check_name_suggestion(\n-                from_type,\n-                r#\"\n-                struct Seed;\n-                fn bar() -> &Seed {}\n-                fn foo() {\n-                    $0bar()$0;\n-                }\"#,\n-                \"seed\",\n-            );\n-        }\n+    #[test]\n+    fn impl_trait_plus_trait() {\n+        check(\n+            r#\"\n+trait Handler {}\n+trait StaticHandler {}\n+fn bar() -> impl StaticHandler + Handler {}\n+fn foo() { $0(bar())$0; }\n+\"#,\n+            \"bar\",\n+        );\n+    }\n \n-        #[test]\n-        fn box_value() {\n-            check_name_suggestion(\n-                from_type,\n-                r#\"\n-                struct Box<T>(*const T);\n-                struct Seed;\n-                fn bar() -> Box<Seed> {}\n-                fn foo() {\n-                    $0bar()$0;\n-                }\"#,\n-                \"seed\",\n-            );\n-        }\n+    #[test]\n+    fn ref_value() {\n+        check(\n+            r#\"\n+struct Seed;\n+fn bar() -> &Seed {}\n+fn foo() { $0(bar())$0; }\n+\"#,\n+            \"seed\",\n+        );\n+    }\n \n-        #[test]\n-        fn box_generic() {\n-            check_name_suggestion_not_applicable(\n-                from_type,\n-                r#\"\n-                struct Box<T>(*const T);\n-                fn bar<T>() -> Box<T> {}\n-                fn foo<T>() {\n-                    $0bar::<T>()$0;\n-                }\"#,\n-            );\n-        }\n+    #[test]\n+    fn box_value() {\n+        check(\n+            r#\"\n+struct Box<T>(*const T);\n+struct Seed;\n+fn bar() -> Box<Seed> {}\n+fn foo() { $0(bar())$0; }\n+\"#,\n+            \"seed\",\n+        );\n+    }\n \n-        #[test]\n-        fn option_value() {\n-            check_name_suggestion(\n-                from_type,\n-                r#\"\n-                enum Option<T> { Some(T) }\n-                struct Seed;\n-                fn bar() -> Option<Seed> {}\n-                fn foo() {\n-                    $0bar()$0;\n-                }\"#,\n-                \"seed\",\n-            );\n-        }\n+    #[test]\n+    fn box_generic() {\n+        check(\n+            r#\"\n+struct Box<T>(*const T);\n+fn bar<T>() -> Box<T> {}\n+fn foo<T>() { $0(bar::<T>())$0; }\n+\"#,\n+            \"bar\",\n+        );\n+    }\n \n-        #[test]\n-        fn result_value() {\n-            check_name_suggestion(\n-                from_type,\n-                r#\"\n-                enum Result<T, E> { Ok(T), Err(E) }\n-                struct Seed;\n-                struct Error;\n-                fn bar() -> Result<Seed, Error> {}\n-                fn foo() {\n-                    $0bar()$0;\n-                }\"#,\n-                \"seed\",\n-            );\n-        }\n+    #[test]\n+    fn option_value() {\n+        check(\n+            r#\"\n+enum Option<T> { Some(T) }\n+struct Seed;\n+fn bar() -> Option<Seed> {}\n+fn foo() { $0(bar())$0; }\n+\"#,\n+            \"seed\",\n+        );\n     }\n \n-    mod variable {\n-        use super::*;\n+    #[test]\n+    fn result_value() {\n+        check(\n+            r#\"\n+enum Result<T, E> { Ok(T), Err(E) }\n+struct Seed;\n+struct Error;\n+fn bar() -> Result<Seed, Error> {}\n+fn foo() { $0(bar())$0; }\n+\"#,\n+            \"seed\",\n+        );\n+    }\n \n-        #[test]\n-        fn ref_call() {\n-            check_name_suggestion(\n-                |e, c| Some(variable(e, c)),\n-                r#\"\n-                fn foo() {\n-                    $0&bar(1, 3)$0\n-                }\"#,\n-                \"bar\",\n-            );\n-        }\n+    #[test]\n+    fn ref_call() {\n+        check(\n+            r#\"\n+fn foo() { $0&bar(1, 3)$0 }\n+\"#,\n+            \"bar\",\n+        );\n+    }\n \n-        #[test]\n-        fn name_to_string() {\n-            check_name_suggestion(\n-                |e, c| Some(variable(e, c)),\n-                r#\"\n-                fn foo() {\n-                    $0function.name().to_string()$0\n-                }\"#,\n-                \"name\",\n-            );\n-        }\n+    #[test]\n+    fn name_to_string() {\n+        check(\n+            r#\"\n+fn foo() { $0function.name().to_string()$0 }\n+\"#,\n+            \"name\",\n+        );\n+    }\n \n-        #[test]\n-        fn nested_useless_method() {\n-            check_name_suggestion(\n-                |e, c| Some(variable(e, c)),\n-                r#\"\n-                fn foo() {\n-                    $0function.name().as_ref().unwrap().to_string()$0\n-                }\"#,\n-                \"name\",\n-            );\n-        }\n+    #[test]\n+    fn nested_useless_method() {\n+        check(\n+            r#\"\n+fn foo() { $0function.name().as_ref().unwrap().to_string()$0 }\n+\"#,\n+            \"name\",\n+        );\n     }\n }"}]}