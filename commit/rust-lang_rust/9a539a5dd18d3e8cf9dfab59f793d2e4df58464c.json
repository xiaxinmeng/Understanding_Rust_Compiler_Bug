{"sha": "9a539a5dd18d3e8cf9dfab59f793d2e4df58464c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhNTM5YTVkZDE4ZDNlOGNmOWRmYWI1OWY3OTNkMmU0ZGY1ODQ2NGM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-10-21T00:57:11Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-10-21T00:58:55Z"}, "message": "Move the \"friendly\" type printer to semant", "tree": {"sha": "18094e5d8ea3c91e6073a22982b962d0e9a4df01", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18094e5d8ea3c91e6073a22982b962d0e9a4df01"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a539a5dd18d3e8cf9dfab59f793d2e4df58464c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a539a5dd18d3e8cf9dfab59f793d2e4df58464c", "html_url": "https://github.com/rust-lang/rust/commit/9a539a5dd18d3e8cf9dfab59f793d2e4df58464c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a539a5dd18d3e8cf9dfab59f793d2e4df58464c/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f71dad2c94d2e4c3f63c85cef5eaf42cf31d74f", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f71dad2c94d2e4c3f63c85cef5eaf42cf31d74f", "html_url": "https://github.com/rust-lang/rust/commit/8f71dad2c94d2e4c3f63c85cef5eaf42cf31d74f"}], "stats": {"total": 172, "additions": 85, "deletions": 87}, "files": [{"sha": "f6be30afc1d3a8a194d8b2b148db330eda264d29", "filename": "src/boot/me/semant.ml", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/9a539a5dd18d3e8cf9dfab59f793d2e4df58464c/src%2Fboot%2Fme%2Fsemant.ml", "raw_url": "https://github.com/rust-lang/rust/raw/9a539a5dd18d3e8cf9dfab59f793d2e4df58464c/src%2Fboot%2Fme%2Fsemant.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fsemant.ml?ref=9a539a5dd18d3e8cf9dfab59f793d2e4df58464c", "patch": "@@ -2679,6 +2679,78 @@ let glue_str (cx:ctxt) (g:glue) : string =\n     | GLUE_vec_grow -> \"glue$vec_grow\"\n ;;\n \n+let rec pretty_ty_str (cx:ctxt) (fallback:(Ast.ty -> string)) (ty:Ast.ty) =\n+  let cache = cx.ctxt_user_type_names in\n+  if Hashtbl.mem cache ty then\n+    let names = List.map (Ast.sprintf_name ()) (Hashtbl.find_all cache ty) in\n+    String.concat \" = \" names\n+  else\n+    match ty with\n+        Ast.TY_vec ty' -> \"vec[\" ^ (pretty_ty_str cx fallback ty') ^ \"]\"\n+      | Ast.TY_chan ty' ->\n+          \"chan[\" ^ (pretty_ty_str cx fallback ty') ^ \"]\"\n+      | Ast.TY_port ty' ->\n+          \"port[\" ^ (pretty_ty_str cx fallback ty') ^ \"]\"\n+      | Ast.TY_box ty' -> \"@\" ^ (pretty_ty_str cx fallback ty')\n+      | Ast.TY_mutable ty' ->\n+          \"(mutable \" ^ (pretty_ty_str cx fallback ty') ^ \")\"\n+      | Ast.TY_constrained (ty', _) ->\n+          \"(\" ^ (pretty_ty_str cx fallback ty') ^ \" : <constrained>)\"\n+      | Ast.TY_tup tys ->\n+          let tys_str = Array.map (pretty_ty_str cx fallback) tys in\n+          \"tup(\" ^ (String.concat \", \" (Array.to_list tys_str)) ^ \")\"\n+      | Ast.TY_rec fields ->\n+          let format_field (ident, ty') =\n+            ident ^ \"=\" ^ (pretty_ty_str cx fallback ty')\n+          in\n+          let fields = Array.to_list (Array.map format_field fields) in\n+          \"rec(\" ^ (String.concat \", \" fields) ^ \")\"\n+      | Ast.TY_fn (fnsig, _) ->\n+          let format_slot slot =\n+            match slot.Ast.slot_ty with\n+                None -> Common.bug () \"no ty in slot\"\n+              | Some ty' -> pretty_ty_str cx fallback ty'\n+          in\n+          let fn_args = Array.map format_slot fnsig.Ast.sig_input_slots in\n+          let fn_args_str = String.concat \", \" (Array.to_list fn_args) in\n+          let fn_rv_str = format_slot fnsig.Ast.sig_output_slot in\n+          Printf.sprintf \"fn(%s) -> %s\" fn_args_str fn_rv_str\n+      | Ast.TY_tag { Ast.tag_id = tag_id; Ast.tag_args = args } ->\n+          let tag_info = Hashtbl.find cx.ctxt_all_tag_info tag_id in\n+          let tag_idents = tag_info.tag_idents in\n+          let item_id = ref None in\n+          (* Ugly hack ahead... *)\n+          begin\n+            try\n+              Hashtbl.iter\n+                begin\n+                  fun _ (_, item_id', _) ->\n+                    item_id := Some item_id'; raise Exit\n+                end\n+                tag_idents\n+            with Exit -> ();\n+          end;\n+          begin\n+            match !item_id with\n+                None -> fallback ty\n+              | Some item_id ->\n+                  let item_types = cx.ctxt_all_item_types in\n+                  let ty = Hashtbl.find item_types item_id in\n+                  let args_suffix =\n+                    if Array.length args == 0 then \"\"\n+                    else\n+                      Printf.sprintf \"[%s]\"\n+                        (String.concat \",\"\n+                          (Array.to_list\n+                            (Array.map\n+                              (pretty_ty_str cx fallback)\n+                              args)))\n+                  in\n+                  (pretty_ty_str cx fallback ty) ^ args_suffix\n+          end\n+\n+      | _ -> fallback ty (* TODO: we can do better for objects *)\n+;;\n \n (*\n  * Local Variables:"}, {"sha": "d22e0b051ce9ae4149a06d29a7725e86abf2439f", "filename": "src/boot/me/type.ml", "status": "modified", "additions": 13, "deletions": 87, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/9a539a5dd18d3e8cf9dfab59f793d2e4df58464c/src%2Fboot%2Fme%2Ftype.ml", "raw_url": "https://github.com/rust-lang/rust/raw/9a539a5dd18d3e8cf9dfab59f793d2e4df58464c/src%2Fboot%2Fme%2Ftype.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftype.ml?ref=9a539a5dd18d3e8cf9dfab59f793d2e4df58464c", "patch": "@@ -37,80 +37,6 @@ let iflog cx thunk =\n   else ()\n ;;\n \n-(* Pretty-printing of type names *)\n-\n-let rec friendly_stringify cx fallback ty =\n-  let cache = cx.Semant.ctxt_user_type_names in\n-  if Hashtbl.mem cache ty then\n-    let names = List.map (Ast.sprintf_name ()) (Hashtbl.find_all cache ty) in\n-    String.concat \" = \" names\n-  else\n-    match ty with\n-        Ast.TY_vec ty' -> \"vec[\" ^ (friendly_stringify cx fallback ty') ^ \"]\"\n-      | Ast.TY_chan ty' ->\n-          \"chan[\" ^ (friendly_stringify cx fallback ty') ^ \"]\"\n-      | Ast.TY_port ty' ->\n-          \"port[\" ^ (friendly_stringify cx fallback ty') ^ \"]\"\n-      | Ast.TY_box ty' -> \"@\" ^ (friendly_stringify cx fallback ty')\n-      | Ast.TY_mutable ty' ->\n-          \"(mutable \" ^ (friendly_stringify cx fallback ty') ^ \")\"\n-      | Ast.TY_constrained (ty', _) ->\n-          \"(\" ^ (friendly_stringify cx fallback ty') ^ \" : <constrained>)\"\n-      | Ast.TY_tup tys ->\n-          let tys_str = Array.map (friendly_stringify cx fallback) tys in\n-          \"tup(\" ^ (String.concat \", \" (Array.to_list tys_str)) ^ \")\"\n-      | Ast.TY_rec fields ->\n-          let format_field (ident, ty') =\n-            ident ^ \"=\" ^ (friendly_stringify cx fallback ty')\n-          in\n-          let fields = Array.to_list (Array.map format_field fields) in\n-          \"rec(\" ^ (String.concat \", \" fields) ^ \")\"\n-      | Ast.TY_fn (fnsig, _) ->\n-          let format_slot slot =\n-            match slot.Ast.slot_ty with\n-                None -> Common.bug () \"no ty in slot\"\n-              | Some ty' -> friendly_stringify cx fallback ty'\n-          in\n-          let fn_args = Array.map format_slot fnsig.Ast.sig_input_slots in\n-          let fn_args_str = String.concat \", \" (Array.to_list fn_args) in\n-          let fn_rv_str = format_slot fnsig.Ast.sig_output_slot in\n-          Printf.sprintf \"fn(%s) -> %s\" fn_args_str fn_rv_str\n-      | Ast.TY_tag { Ast.tag_id = tag_id; Ast.tag_args = args } ->\n-          let tag_info = Hashtbl.find cx.Semant.ctxt_all_tag_info tag_id in\n-          let tag_idents = tag_info.Semant.tag_idents in\n-          let item_id = ref None in\n-          (* Ugly hack ahead... *)\n-          begin\n-            try\n-              Hashtbl.iter\n-                begin\n-                  fun _ (_, item_id', _) ->\n-                    item_id := Some item_id'; raise Exit\n-                end\n-                tag_idents\n-            with Exit -> ();\n-          end;\n-          begin\n-            match !item_id with\n-                None -> fallback ty\n-              | Some item_id ->\n-                  let item_types = cx.Semant.ctxt_all_item_types in\n-                  let ty = Hashtbl.find item_types item_id in\n-                  let args_suffix =\n-                    if Array.length args == 0 then \"\"\n-                    else\n-                      Printf.sprintf \"[%s]\"\n-                        (String.concat \",\"\n-                          (Array.to_list\n-                            (Array.map\n-                              (friendly_stringify cx fallback)\n-                              args)))\n-                  in\n-                  (friendly_stringify cx fallback ty) ^ args_suffix\n-          end\n-\n-      | _ -> fallback ty (* TODO: we can do better for objects *)\n-\n let head_only ty =\n   match ty with\n \n@@ -220,7 +146,7 @@ and summarize_difference cx (expected:Ast.ty) (actual:Ast.ty)\n           Printf.bprintf abuf \"%s\" a\n       in\n \n-      Buffer.add_string ebuf (friendly_stringify cx head_only expected);\n+      Buffer.add_string ebuf (Semant.pretty_ty_str cx head_only expected);\n \n         begin\n           match expected, actual with\n@@ -246,7 +172,7 @@ and summarize_difference cx (expected:Ast.ty) (actual:Ast.ty)\n                 p \"mutable \"; sub e a;\n \n             | (_, a) ->\n-                Buffer.add_string abuf (friendly_stringify cx head_only a)\n+                Buffer.add_string abuf (Semant.pretty_ty_str cx head_only a)\n         end;\n         (Buffer.contents ebuf, Buffer.contents abuf)\n     end\n@@ -257,13 +183,13 @@ let type_error_full expected actual =\n ;;\n \n let type_error cx expected actual =\n-  type_error_full expected (friendly_stringify cx head_only actual)\n+  type_error_full expected (Semant.pretty_ty_str cx head_only actual)\n ;;\n \n (* We explicitly curry [cx] like this to avoid threading it through all the\n  * inner functions. *)\n let check_stmt (cx:Semant.ctxt) : (fn_ctx -> Ast.stmt -> unit) =\n-  let friendly_string_of_ty = friendly_stringify cx (Ast.sprintf_ty ()) in\n+  let pretty_ty_str = Semant.pretty_ty_str cx (Ast.sprintf_ty ()) in\n \n   (* Returns the part of the type that matters for typechecking. *)\n   let rec fundamental_ty (ty:Ast.ty) : Ast.ty =\n@@ -274,7 +200,7 @@ let check_stmt (cx:Semant.ctxt) : (fn_ctx -> Ast.stmt -> unit) =\n \n   let sprintf_ltype _ (lty:ltype) : string =\n     match lty with\n-        LTYPE_mono ty | LTYPE_poly (_, ty) -> friendly_string_of_ty ty\n+        LTYPE_mono ty | LTYPE_poly (_, ty) -> pretty_ty_str ty\n       | LTYPE_module items -> Ast.sprintf_mod_items () items\n   in\n \n@@ -553,14 +479,14 @@ let check_stmt (cx:Semant.ctxt) : (fn_ctx -> Ast.stmt -> unit) =\n       match internal_check_lval TYPAT_wild base with\n           LTYPE_poly (_, ty) ->\n             Common.err None \"can't index the polymorphic type '%s'\"\n-              (friendly_string_of_ty ty)\n+              (pretty_ty_str ty)\n         | LTYPE_mono ty -> `Type (fundamental_ty ty)\n         | LTYPE_module items -> `Module items\n     in\n \n     let string_of_itype () =\n       match base_ity with\n-          `Type ty -> friendly_string_of_ty ty\n+          `Type ty -> pretty_ty_str ty\n         | `Module items -> Ast.sprintf_mod_items () items\n     in\n \n@@ -650,14 +576,14 @@ let check_stmt (cx:Semant.ctxt) : (fn_ctx -> Ast.stmt -> unit) =\n \n         | `Type ty, Ast.COMP_named (Ast.COMP_ident _) ->\n             Common.err None \"the type '%s' can't be indexed by name\"\n-              (friendly_string_of_ty ty)\n+              (pretty_ty_str ty)\n \n         | `Type ty, Ast.COMP_named (Ast.COMP_app _) ->\n             Common.err\n               None\n               \"the type '%s' has no type parameters, so it can't be applied \\\n               to types\"\n-              (friendly_string_of_ty ty)\n+              (pretty_ty_str ty)\n \n         | `Module items, Ast.COMP_named ((Ast.COMP_ident id) as name_comp)\n         | `Module items, Ast.COMP_named ((Ast.COMP_app (id, _))\n@@ -697,7 +623,7 @@ let check_stmt (cx:Semant.ctxt) : (fn_ctx -> Ast.stmt -> unit) =\n               None\n               \"%s can't by indexed by the type '%s'\"\n               (string_of_itype ())\n-              (friendly_string_of_ty (check_atom atom))\n+              (pretty_ty_str (check_atom atom))\n \n         | _, Ast.COMP_deref ->\n             Common.err\n@@ -775,7 +701,7 @@ let check_stmt (cx:Semant.ctxt) : (fn_ctx -> Ast.stmt -> unit) =\n             \"not enough context to automatically instantiate '%a' to '%s'; \\\n             please supply type parameters explicitly\"\n             sprintf_ltype lty\n-            (friendly_string_of_ty expected)\n+            (pretty_ty_str expected)\n       | _, LTYPE_module _ ->\n           Common.err None \"can't refer to a module as a first-class value\"\n \n@@ -1059,8 +985,8 @@ let check_stmt (cx:Semant.ctxt) : (fn_ctx -> Ast.stmt -> unit) =\n                     else\n                       Common.err None\n                         \"mismatched types in vec-append: %s += %s\"\n-                        (friendly_string_of_ty dst_ty)\n-                        (friendly_string_of_ty src_ty)\n+                        (pretty_ty_str dst_ty)\n+                        (pretty_ty_str src_ty)\n                 | Ast.TY_str, (Ast.TY_mach Common.TY_u8)\n                 | Ast.TY_str, Ast.TY_str -> ()\n                 | _ ->"}]}