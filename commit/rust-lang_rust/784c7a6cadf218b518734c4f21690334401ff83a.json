{"sha": "784c7a6cadf218b518734c4f21690334401ff83a", "node_id": "C_kwDOAAsO6NoAKDc4NGM3YTZjYWRmMjE4YjUxODczNGM0ZjIxNjkwMzM0NDAxZmY4M2E", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-02-11T06:45:58Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-02-11T06:55:00Z"}, "message": "only mark projection as ambiguous if GAT substs are constrained", "tree": {"sha": "b3ba86458a69356c8ebee731c19ee54fc53040e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3ba86458a69356c8ebee731c19ee54fc53040e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/784c7a6cadf218b518734c4f21690334401ff83a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/784c7a6cadf218b518734c4f21690334401ff83a", "html_url": "https://github.com/rust-lang/rust/commit/784c7a6cadf218b518734c4f21690334401ff83a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/784c7a6cadf218b518734c4f21690334401ff83a/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e646f3d2a9541952310778288854943678738ea9", "url": "https://api.github.com/repos/rust-lang/rust/commits/e646f3d2a9541952310778288854943678738ea9", "html_url": "https://github.com/rust-lang/rust/commit/e646f3d2a9541952310778288854943678738ea9"}], "stats": {"total": 133, "additions": 89, "deletions": 44}, "files": [{"sha": "6a968005f3eaa00de81463262c3f041b610e547c", "filename": "compiler/rustc_infer/src/infer/type_variable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/784c7a6cadf218b518734c4f21690334401ff83a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/784c7a6cadf218b518734c4f21690334401ff83a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs?ref=784c7a6cadf218b518734c4f21690334401ff83a", "patch": "@@ -259,7 +259,7 @@ impl<'tcx> TypeVariableTable<'_, 'tcx> {\n         let index = self.values().push(TypeVariableData { origin });\n         assert_eq!(eq_key.vid.as_u32(), index as u32);\n \n-        debug!(\"new_var(index={:?}, universe={:?}, origin={:?}\", eq_key.vid, universe, origin,);\n+        debug!(\"new_var(index={:?}, universe={:?}, origin={:?})\", eq_key.vid, universe, origin);\n \n         eq_key.vid\n     }"}, {"sha": "a8d15d98eea5718da63b1dba711da5d1e49d50e6", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 27, "deletions": 30, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/784c7a6cadf218b518734c4f21690334401ff83a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/784c7a6cadf218b518734c4f21690334401ff83a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=784c7a6cadf218b518734c4f21690334401ff83a", "patch": "@@ -1073,16 +1073,6 @@ fn project<'cx, 'tcx>(\n         return Ok(Projected::Progress(Progress::error(selcx.tcx())));\n     }\n \n-    // If the obligation contains any inference types or consts in associated\n-    // type substs, then we don't assemble any candidates.\n-    // This isn't really correct, but otherwise we can end up in a case where\n-    // we constrain inference variables by selecting a single predicate, when\n-    // we need to stay general. See issue #91762.\n-    let (_, predicate_own_substs) = obligation.predicate.trait_ref_and_own_substs(selcx.tcx());\n-    if predicate_own_substs.iter().any(|g| g.has_infer_types_or_consts()) {\n-        return Err(ProjectionError::TooManyCandidates);\n-    }\n-\n     let mut candidates = ProjectionCandidateSet::None;\n \n     // Make sure that the following procedures are kept in order. ParamEnv\n@@ -1180,7 +1170,7 @@ fn assemble_candidates_from_trait_def<'cx, 'tcx>(\n         ProjectionCandidate::TraitDef,\n         bounds.iter(),\n         true,\n-    )\n+    );\n }\n \n /// In the case of a trait object like\n@@ -1245,27 +1235,34 @@ fn assemble_candidates_from_predicates<'cx, 'tcx>(\n         let bound_predicate = predicate.kind();\n         if let ty::PredicateKind::Projection(data) = predicate.kind().skip_binder() {\n             let data = bound_predicate.rebind(data);\n-            let same_def_id = data.projection_def_id() == obligation.predicate.item_def_id;\n-\n-            let is_match = same_def_id\n-                && infcx.probe(|_| {\n-                    selcx.match_projection_projections(\n-                        obligation,\n-                        data,\n-                        potentially_unnormalized_candidates,\n-                    )\n-                });\n+            if data.projection_def_id() != obligation.predicate.item_def_id {\n+                continue;\n+            }\n \n-            if is_match {\n-                candidate_set.push_candidate(ctor(data));\n+            let is_match = infcx.probe(|_| {\n+                selcx.match_projection_projections(\n+                    obligation,\n+                    data,\n+                    potentially_unnormalized_candidates,\n+                )\n+            });\n \n-                if potentially_unnormalized_candidates\n-                    && !obligation.predicate.has_infer_types_or_consts()\n-                {\n-                    // HACK: Pick the first trait def candidate for a fully\n-                    // inferred predicate. This is to allow duplicates that\n-                    // differ only in normalization.\n-                    return;\n+            match is_match {\n+                Some(true) => {\n+                    candidate_set.push_candidate(ctor(data));\n+\n+                    if potentially_unnormalized_candidates\n+                        && !obligation.predicate.has_infer_types_or_consts()\n+                    {\n+                        // HACK: Pick the first trait def candidate for a fully\n+                        // inferred predicate. This is to allow duplicates that\n+                        // differ only in normalization.\n+                        return;\n+                    }\n+                }\n+                Some(false) => {}\n+                None => {\n+                    candidate_set.mark_ambiguous();\n                 }\n             }\n         }"}, {"sha": "4ca60a65485c5bcc40e692caa5c6cc15db1212e5", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/784c7a6cadf218b518734c4f21690334401ff83a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/784c7a6cadf218b518734c4f21690334401ff83a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=784c7a6cadf218b518734c4f21690334401ff83a", "patch": "@@ -1508,12 +1508,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         })\n     }\n \n+    /// Return Some(true) if the obligation's predicate type applies to the env_predicate, and\n+    /// Some(false) if it does not. Returns None in the case that the projection type is a GAT,\n+    /// and applying this env_predicate constrains any of the obligation's GAT substitutions.\n     pub(super) fn match_projection_projections(\n         &mut self,\n         obligation: &ProjectionTyObligation<'tcx>,\n         env_predicate: PolyProjectionPredicate<'tcx>,\n         potentially_unnormalized_candidates: bool,\n-    ) -> bool {\n+    ) -> Option<bool> {\n         let mut nested_obligations = Vec::new();\n         let (infer_predicate, _) = self.infcx.replace_bound_vars_with_fresh_vars(\n             obligation.cause.span,\n@@ -1535,7 +1538,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             infer_predicate.projection_ty\n         };\n \n-        self.infcx\n+        let is_match = self\n+            .infcx\n             .at(&obligation.cause, obligation.param_env)\n             .define_opaque_types(false)\n             .sup(obligation.predicate, infer_projection)\n@@ -1545,7 +1549,24 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     nested_obligations.into_iter().chain(obligations),\n                 )\n                 .map_or(false, |res| res.may_apply())\n-            })\n+            });\n+\n+        if is_match {\n+            let generics = self.tcx().generics_of(obligation.predicate.item_def_id);\n+            if !generics.params.is_empty() {\n+                // If any of the obligation's predicate substs shallow-resolve to\n+                // something new, that means that we must have newly inferred something\n+                // about the GAT. We should give up with ambiguity in that case.\n+                if obligation.predicate.substs[generics.parent_count..]\n+                    .iter()\n+                    .any(|&p| p.has_infer_types_or_consts() && self.infcx.shallow_resolve(p) != p)\n+                {\n+                    return None;\n+                }\n+            }\n+        }\n+\n+        Some(is_match)\n     }\n \n     ///////////////////////////////////////////////////////////////////////////"}, {"sha": "1bbf7aac5cdabc6ff70bb90f645e3f85ccda02f8", "filename": "src/test/ui/generic-associated-types/issue-74824.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/784c7a6cadf218b518734c4f21690334401ff83a/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-74824.rs", "raw_url": "https://github.com/rust-lang/rust/raw/784c7a6cadf218b518734c4f21690334401ff83a/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-74824.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-74824.rs?ref=784c7a6cadf218b518734c4f21690334401ff83a", "patch": "@@ -17,7 +17,6 @@ impl<T> UnsafeCopy for T {}\n fn main() {\n     let b = Box::new(42usize);\n     let copy = <()>::copy(&b);\n-    //~^ type annotations needed\n \n     let raw_b = Box::deref(&b) as *const _;\n     let raw_copy = Box::deref(&copy) as *const _;"}, {"sha": "8517eb9fa21026c915453e4dcb1463593b7cee28", "filename": "src/test/ui/generic-associated-types/issue-74824.stderr", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/784c7a6cadf218b518734c4f21690334401ff83a/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-74824.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/784c7a6cadf218b518734c4f21690334401ff83a/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-74824.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-74824.stderr?ref=784c7a6cadf218b518734c4f21690334401ff83a", "patch": "@@ -27,13 +27,6 @@ help: consider restricting type parameter `T`\n LL |     type Copy<T: std::clone::Clone>: Copy = Box<T>;\n    |                +++++++++++++++++++\n \n-error[E0282]: type annotations needed\n-  --> $DIR/issue-74824.rs:19:16\n-   |\n-LL |     let copy = <()>::copy(&b);\n-   |                ^^^^^^^^^^ cannot infer type for type parameter `T` declared on the associated function `copy`\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0277, E0282.\n-For more information about an error, try `rustc --explain E0277`.\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "f403d75167d8a9f73a29ae2994ac7b2471c2f48d", "filename": "src/test/ui/generic-associated-types/issue-93874.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/784c7a6cadf218b518734c4f21690334401ff83a/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-93874.rs", "raw_url": "https://github.com/rust-lang/rust/raw/784c7a6cadf218b518734c4f21690334401ff83a/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-93874.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-93874.rs?ref=784c7a6cadf218b518734c4f21690334401ff83a", "patch": "@@ -0,0 +1,35 @@\n+// check-pass\n+\n+#![feature(generic_associated_types)]\n+\n+pub trait Build {\n+    type Output<O>;\n+    fn build<O>(self, input: O) -> Self::Output<O>;\n+}\n+\n+pub struct IdentityBuild;\n+impl Build for IdentityBuild {\n+    type Output<O> = O;\n+    fn build<O>(self, input: O) -> Self::Output<O> {\n+        input\n+    }\n+}\n+\n+fn a() {\n+    let _x: u8 = IdentityBuild.build(10);\n+}\n+\n+fn b() {\n+    let _x: Vec<u8> = IdentityBuild.build(Vec::new());\n+}\n+\n+fn c() {\n+    let mut f = IdentityBuild.build(|| ());\n+    (f)();\n+}\n+\n+pub fn main() {\n+    a();\n+    b();\n+    c();\n+}"}]}