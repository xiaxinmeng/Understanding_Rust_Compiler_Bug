{"sha": "b9b45a0e96ad86d35aa3be45b7ef9080679abdd3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5YjQ1YTBlOTZhZDg2ZDM1YWEzYmU0NWI3ZWY5MDgwNjc5YWJkZDM=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-11-12T22:12:50Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-11-13T22:09:36Z"}, "message": "address review comments", "tree": {"sha": "fa94c5a847897d2874909aa680a183b21f8fd38f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa94c5a847897d2874909aa680a183b21f8fd38f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9b45a0e96ad86d35aa3be45b7ef9080679abdd3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9b45a0e96ad86d35aa3be45b7ef9080679abdd3", "html_url": "https://github.com/rust-lang/rust/commit/b9b45a0e96ad86d35aa3be45b7ef9080679abdd3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9b45a0e96ad86d35aa3be45b7ef9080679abdd3/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e82f5d4f54e9e9c7004c67354a696eacf5f9b155", "url": "https://api.github.com/repos/rust-lang/rust/commits/e82f5d4f54e9e9c7004c67354a696eacf5f9b155", "html_url": "https://github.com/rust-lang/rust/commit/e82f5d4f54e9e9c7004c67354a696eacf5f9b155"}], "stats": {"total": 172, "additions": 98, "deletions": 74}, "files": [{"sha": "15a49fc9d8572dd8fa098456e3d372020696b44e", "filename": "src/librustc_mir/tcx/mod.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b9b45a0e96ad86d35aa3be45b7ef9080679abdd3/src%2Flibrustc_mir%2Ftcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9b45a0e96ad86d35aa3be45b7ef9080679abdd3/src%2Flibrustc_mir%2Ftcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftcx%2Fmod.rs?ref=b9b45a0e96ad86d35aa3be45b7ef9080679abdd3", "patch": "@@ -103,6 +103,31 @@ impl<'tcx> Mir<'tcx> {\n         }\n     }\n \n+    pub fn binop_ty(&self,\n+                    tcx: &ty::ctxt<'tcx>,\n+                    op: BinOp,\n+                    lhs_ty: Ty<'tcx>,\n+                    rhs_ty: Ty<'tcx>)\n+                    -> Ty<'tcx>\n+    {\n+        // FIXME: handle SIMD correctly\n+        match op {\n+            BinOp::Add | BinOp::Sub | BinOp::Mul | BinOp::Div | BinOp::Rem |\n+            BinOp::BitXor | BinOp::BitAnd | BinOp::BitOr => {\n+                // these should be integers or floats of the same size.\n+                assert_eq!(lhs_ty, rhs_ty);\n+                lhs_ty\n+            }\n+            BinOp::Shl | BinOp::Shr => {\n+                lhs_ty // lhs_ty can be != rhs_ty\n+            }\n+            BinOp::Eq | BinOp::Lt | BinOp::Le |\n+            BinOp::Ne | BinOp::Ge | BinOp::Gt => {\n+                tcx.types.bool\n+            }\n+        }\n+    }\n+\n     pub fn lvalue_ty(&self,\n                      tcx: &ty::ctxt<'tcx>,\n                      lvalue: &Lvalue<'tcx>)\n@@ -138,3 +163,26 @@ impl BorrowKind {\n         }\n     }\n }\n+\n+impl BinOp {\n+    pub fn to_hir_binop(self) -> hir::BinOp_ {\n+        match self {\n+            BinOp::Add => hir::BinOp_::BiAdd,\n+            BinOp::Sub => hir::BinOp_::BiSub,\n+            BinOp::Mul => hir::BinOp_::BiMul,\n+            BinOp::Div => hir::BinOp_::BiDiv,\n+            BinOp::Rem => hir::BinOp_::BiRem,\n+            BinOp::BitXor => hir::BinOp_::BiBitXor,\n+            BinOp::BitAnd => hir::BinOp_::BiBitAnd,\n+            BinOp::BitOr => hir::BinOp_::BiBitOr,\n+            BinOp::Shl => hir::BinOp_::BiShl,\n+            BinOp::Shr => hir::BinOp_::BiShr,\n+            BinOp::Eq => hir::BinOp_::BiEq,\n+            BinOp::Ne => hir::BinOp_::BiNe,\n+            BinOp::Lt => hir::BinOp_::BiLt,\n+            BinOp::Gt => hir::BinOp_::BiGt,\n+            BinOp::Le => hir::BinOp_::BiLe,\n+            BinOp::Ge => hir::BinOp_::BiGe\n+        }\n+    }\n+}"}, {"sha": "8c0d8b10bfe47a8f26d8de942530ed839f5277d0", "filename": "src/librustc_trans/trans/mir/constant.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b9b45a0e96ad86d35aa3be45b7ef9080679abdd3/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9b45a0e96ad86d35aa3be45b7ef9080679abdd3/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs?ref=b9b45a0e96ad86d35aa3be45b7ef9080679abdd3", "patch": "@@ -16,7 +16,7 @@ use trans::common::{self, Block};\n use trans::common::{C_bool, C_bytes, C_floating_f64, C_integral, C_str_slice};\n use trans::type_of;\n \n-use super::operand::{OperandRef, OperandValue};\n+use super::operand::OperandRef;\n use super::MirContext;\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n@@ -26,19 +26,21 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                           ty: Ty<'tcx>)\n                           -> OperandRef<'tcx>\n     {\n+        use super::operand::OperandValue::{Ref, Immediate};\n+\n         let ccx = bcx.ccx();\n         let llty = type_of::type_of(ccx, ty);\n         let val = match *cv {\n-            ConstVal::Float(v) => OperandValue::Imm(C_floating_f64(v, llty)),\n-            ConstVal::Bool(v) => OperandValue::Imm(C_bool(ccx, v)),\n-            ConstVal::Int(v) => OperandValue::Imm(C_integral(llty, v as u64, true)),\n-            ConstVal::Uint(v) => OperandValue::Imm(C_integral(llty, v, false)),\n-            ConstVal::Str(ref v) => OperandValue::Imm(C_str_slice(ccx, v.clone())),\n+            ConstVal::Float(v) => Immediate(C_floating_f64(v, llty)),\n+            ConstVal::Bool(v) => Immediate(C_bool(ccx, v)),\n+            ConstVal::Int(v) => Immediate(C_integral(llty, v as u64, true)),\n+            ConstVal::Uint(v) => Immediate(C_integral(llty, v, false)),\n+            ConstVal::Str(ref v) => Immediate(C_str_slice(ccx, v.clone())),\n             ConstVal::ByteStr(ref v) => {\n-                OperandValue::Imm(consts::addr_of(ccx,\n-                                                  C_bytes(ccx, v),\n-                                                  1,\n-                                                  \"byte_str\"))\n+                Immediate(consts::addr_of(ccx,\n+                                          C_bytes(ccx, v),\n+                                          1,\n+                                          \"byte_str\"))\n             }\n \n             ConstVal::Struct(id) | ConstVal::Tuple(id) => {\n@@ -52,9 +54,9 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     Err(_) => panic!(\"constant eval failure\"),\n                 };\n                 if common::type_is_immediate(bcx.ccx(), ty) {\n-                    OperandValue::Imm(llval)\n+                    Immediate(llval)\n                 } else {\n-                    OperandValue::Ref(llval)\n+                    Ref(llval)\n                 }\n             }\n             ConstVal::Function(_) => {"}, {"sha": "63abdfe2dd9176c46fa3695e9c475936725817d7", "filename": "src/librustc_trans/trans/mir/operand.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b9b45a0e96ad86d35aa3be45b7ef9080679abdd3/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9b45a0e96ad86d35aa3be45b7ef9080679abdd3/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs?ref=b9b45a0e96ad86d35aa3be45b7ef9080679abdd3", "patch": "@@ -17,35 +17,43 @@ use trans::datum;\n \n use super::{MirContext, TempRef};\n \n-/// The Rust representation of an operand's value. This is uniquely\n-/// determined by the operand type, but is kept as an enum as a\n+/// The representation of a Rust value. The enum variant is in fact\n+/// uniquely determined by the value's type, but is kept as a\n /// safety check.\n #[derive(Copy, Clone)]\n pub enum OperandValue {\n     /// A reference to the actual operand. The data is guaranteed\n     /// to be valid for the operand's lifetime.\n     Ref(ValueRef),\n     /// A single LLVM value.\n-    Imm(ValueRef),\n+    Immediate(ValueRef),\n     /// A fat pointer. The first ValueRef is the data and the second\n     /// is the extra.\n     FatPtr(ValueRef, ValueRef)\n }\n \n+/// An `OperandRef` is an \"SSA\" reference to a Rust value, along with\n+/// its type.\n+///\n+/// NOTE: unless you know a value's type exactly, you should not\n+/// generate LLVM opcodes acting on it and instead act via methods,\n+/// to avoid nasty edge cases. In particular, using `build::Store`\n+/// directly is sure to cause problems - use `store_operand` instead.\n #[derive(Copy, Clone)]\n pub struct OperandRef<'tcx> {\n-    // This will be \"indirect\" if `appropriate_rvalue_mode` returns\n-    // ByRef, and otherwise ByValue.\n+    // The value.\n     pub val: OperandValue,\n \n     // The type of value being returned.\n     pub ty: Ty<'tcx>\n }\n \n impl<'tcx> OperandRef<'tcx> {\n+    /// Asserts that this operand refers to a scalar and returns\n+    /// a reference to its value.\n     pub fn immediate(self) -> ValueRef {\n         match self.val {\n-            OperandValue::Imm(s) => s,\n+            OperandValue::Immediate(s) => s,\n             _ => unreachable!()\n         }\n     }\n@@ -56,8 +64,8 @@ impl<'tcx> OperandRef<'tcx> {\n                 format!(\"OperandRef(Ref({}) @ {:?})\",\n                         bcx.val_to_string(r), self.ty)\n             }\n-            OperandValue::Imm(i) => {\n-                format!(\"OperandRef(Imm({}) @ {:?})\",\n+            OperandValue::Immediate(i) => {\n+                format!(\"OperandRef(Immediate({}) @ {:?})\",\n                         bcx.val_to_string(i), self.ty)\n             }\n             OperandValue::FatPtr(a, d) => {\n@@ -106,7 +114,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                        ty);\n                 let val = match datum::appropriate_rvalue_mode(bcx.ccx(), ty) {\n                     datum::ByValue => {\n-                        OperandValue::Imm(base::load_ty(bcx, tr_lvalue.llval, ty))\n+                        OperandValue::Immediate(base::load_ty(bcx, tr_lvalue.llval, ty))\n                     }\n                     datum::ByRef if common::type_is_fat_ptr(bcx.tcx(), ty) => {\n                         let (lldata, llextra) = base::load_fat_ptr(bcx, tr_lvalue.llval, ty);\n@@ -150,7 +158,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         debug!(\"store_operand: operand={}\", operand.repr(bcx));\n         match operand.val {\n             OperandValue::Ref(r) => base::memcpy_ty(bcx, lldest, r, operand.ty),\n-            OperandValue::Imm(s) => base::store_ty(bcx, s, lldest, operand.ty),\n+            OperandValue::Immediate(s) => base::store_ty(bcx, s, lldest, operand.ty),\n             OperandValue::FatPtr(data, extra) => {\n                 base::store_fat_ptr(bcx, data, extra, lldest, operand.ty);\n             }"}, {"sha": "cce71b2570263b2b4e757c7b0877d23df3e7e4e4", "filename": "src/librustc_trans/trans/mir/rvalue.rs", "status": "modified", "additions": 18, "deletions": 52, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/b9b45a0e96ad86d35aa3be45b7ef9080679abdd3/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9b45a0e96ad86d35aa3be45b7ef9080679abdd3/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs?ref=b9b45a0e96ad86d35aa3be45b7ef9080679abdd3", "patch": "@@ -10,7 +10,6 @@\n \n use llvm::ValueRef;\n use rustc::middle::ty::{self, Ty};\n-use rustc_front::hir;\n use rustc_mir::repr as mir;\n \n use trans::asm;\n@@ -47,6 +46,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n             mir::Rvalue::Cast(mir::CastKind::Unsize, ref operand, cast_ty) => {\n                 if common::type_is_fat_ptr(bcx.tcx(), cast_ty) {\n+                    // into-coerce of a thin pointer to a fat pointer - just\n+                    // use the operand path.\n                     let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue);\n                     self.store_operand(bcx, lldest, temp);\n                     return bcx;\n@@ -59,8 +60,13 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let operand = self.trans_operand(bcx, operand);\n                 match operand.val {\n                     OperandValue::FatPtr(..) => unreachable!(),\n-                    OperandValue::Imm(llval) => {\n-                        // ugly alloca.\n+                    OperandValue::Immediate(llval) => {\n+                        // unsize from an immediate structure. We don't\n+                        // really need a temporary alloca here, but\n+                        // avoiding it would require us to have\n+                        // `coerce_unsized_into` use extractvalue to\n+                        // index into the struct, and this case isn't\n+                        // important enough for it.\n                         debug!(\"trans_rvalue: creating ugly alloca\");\n                         let lltemp = base::alloc_ty(bcx, operand.ty, \"__unsize_temp\");\n                         base::store_ty(bcx, llval, lltemp, operand.ty);\n@@ -165,7 +171,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                 // and is a no-op at the LLVM level\n                                 operand.val\n                             }\n-                            OperandValue::Imm(lldata) => {\n+                            OperandValue::Immediate(lldata) => {\n                                 // \"standard\" unsize\n                                 let (lldata, llextra) =\n                                     base::unsize_thin_ptr(bcx, lldata,\n@@ -200,7 +206,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 // destination effectively creates a reference.\n                 if common::type_is_sized(bcx.tcx(), ty) {\n                     (bcx, OperandRef {\n-                        val: OperandValue::Imm(tr_lvalue.llval),\n+                        val: OperandValue::Immediate(tr_lvalue.llval),\n                         ty: ref_ty,\n                     })\n                 } else {\n@@ -215,7 +221,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             mir::Rvalue::Len(ref lvalue) => {\n                 let tr_lvalue = self.trans_lvalue(bcx, lvalue);\n                 (bcx, OperandRef {\n-                    val: OperandValue::Imm(self.lvalue_len(bcx, tr_lvalue)),\n+                    val: OperandValue::Immediate(self.lvalue_len(bcx, tr_lvalue)),\n                     ty: bcx.tcx().types.usize,\n                 })\n             }\n@@ -230,7 +236,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                             base::compare_fat_ptrs(bcx,\n                                                    lhs_addr, lhs_extra,\n                                                    rhs_addr, rhs_extra,\n-                                                   lhs.ty, cmp_to_hir_cmp(op),\n+                                                   lhs.ty, op.to_hir_binop(),\n                                                    DebugLoc::None)\n                         }\n                         _ => unreachable!()\n@@ -242,8 +248,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                             lhs.ty, DebugLoc::None)\n                 };\n                 (bcx, OperandRef {\n-                    val: OperandValue::Imm(llresult),\n-                    ty: type_of_binop(bcx.tcx(), op, lhs.ty, rhs.ty),\n+                    val: OperandValue::Immediate(llresult),\n+                    ty: self.mir.binop_ty(bcx.tcx(), op, lhs.ty, rhs.ty),\n                 })\n             }\n \n@@ -261,7 +267,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     }\n                 };\n                 (bcx, OperandRef {\n-                    val: OperandValue::Imm(llval),\n+                    val: OperandValue::Immediate(llval),\n                     ty: operand.ty,\n                 })\n             }\n@@ -281,7 +287,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                                                       llalign,\n                                                                       DebugLoc::None);\n                 (bcx, OperandRef {\n-                    val: OperandValue::Imm(llval),\n+                    val: OperandValue::Immediate(llval),\n                     ty: box_ty,\n                 })\n             }\n@@ -388,7 +394,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             mir::BinOp::Eq | mir::BinOp::Lt | mir::BinOp::Gt |\n             mir::BinOp::Ne | mir::BinOp::Le | mir::BinOp::Ge => {\n                 base::compare_scalar_types(bcx, lhs, rhs, input_ty,\n-                                           cmp_to_hir_cmp(op), debug_loc)\n+                                           op.to_hir_binop(), debug_loc)\n             }\n         }\n     }\n@@ -413,43 +419,3 @@ pub fn rvalue_creates_operand<'tcx>(rvalue: &mir::Rvalue<'tcx>) -> bool {\n \n     // (*) this is only true if the type is suitable\n }\n-\n-fn cmp_to_hir_cmp(op: mir::BinOp) -> hir::BinOp_ {\n-    match op {\n-        mir::BinOp::Eq => hir::BiEq,\n-        mir::BinOp::Ne => hir::BiNe,\n-        mir::BinOp::Lt => hir::BiLt,\n-        mir::BinOp::Le => hir::BiLe,\n-        mir::BinOp::Gt => hir::BiGt,\n-        mir::BinOp::Ge => hir::BiGe,\n-        _ => unreachable!()\n-    }\n-}\n-\n-/// FIXME(nikomatsakis): I don't think this function should go here\n-fn type_of_binop<'tcx>(\n-    tcx: &ty::ctxt<'tcx>,\n-    op: mir::BinOp,\n-    lhs_ty: Ty<'tcx>,\n-    rhs_ty: Ty<'tcx>)\n-    -> Ty<'tcx>\n-{\n-    match op {\n-        mir::BinOp::Add | mir::BinOp::Sub |\n-        mir::BinOp::Mul | mir::BinOp::Div | mir::BinOp::Rem |\n-        mir::BinOp::BitXor | mir::BinOp::BitAnd | mir::BinOp::BitOr => {\n-            // these should be integers or floats of the same size. We\n-            // probably want to dump all ops in some intrinsics framework\n-            // someday.\n-            assert_eq!(lhs_ty, rhs_ty);\n-            lhs_ty\n-        }\n-        mir::BinOp::Shl | mir::BinOp::Shr => {\n-            lhs_ty // lhs_ty can be != rhs_ty\n-        }\n-        mir::BinOp::Eq | mir::BinOp::Lt | mir::BinOp::Le |\n-        mir::BinOp::Ne | mir::BinOp::Ge | mir::BinOp::Gt => {\n-            tcx.types.bool\n-        }\n-    }\n-}"}]}