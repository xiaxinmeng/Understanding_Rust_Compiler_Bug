{"sha": "95a824c02c3f9a50bb4fa49e7af7d3a5a2faf51e", "node_id": "C_kwDOAAsO6NoAKDk1YTgyNGMwMmMzZjlhNTBiYjRmYTQ5ZTdhZjdkM2E1YTJmYWY1MWU", "commit": {"author": {"name": "clubby789", "email": "jamie@hill-daniel.co.uk", "date": "2023-01-19T15:52:29Z"}, "committer": {"name": "clubby789", "email": "jamie@hill-daniel.co.uk", "date": "2023-01-19T15:53:31Z"}, "message": "Special case `derive(Debug)` for fieldless enums", "tree": {"sha": "b44c34336357ef5702ff23d56b78bd6d55c09c3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b44c34336357ef5702ff23d56b78bd6d55c09c3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/95a824c02c3f9a50bb4fa49e7af7d3a5a2faf51e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/95a824c02c3f9a50bb4fa49e7af7d3a5a2faf51e", "html_url": "https://github.com/rust-lang/rust/commit/95a824c02c3f9a50bb4fa49e7af7d3a5a2faf51e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/95a824c02c3f9a50bb4fa49e7af7d3a5a2faf51e/comments", "author": {"login": "clubby789", "id": 13556931, "node_id": "MDQ6VXNlcjEzNTU2OTMx", "avatar_url": "https://avatars.githubusercontent.com/u/13556931?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clubby789", "html_url": "https://github.com/clubby789", "followers_url": "https://api.github.com/users/clubby789/followers", "following_url": "https://api.github.com/users/clubby789/following{/other_user}", "gists_url": "https://api.github.com/users/clubby789/gists{/gist_id}", "starred_url": "https://api.github.com/users/clubby789/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clubby789/subscriptions", "organizations_url": "https://api.github.com/users/clubby789/orgs", "repos_url": "https://api.github.com/users/clubby789/repos", "events_url": "https://api.github.com/users/clubby789/events{/privacy}", "received_events_url": "https://api.github.com/users/clubby789/received_events", "type": "User", "site_admin": false}, "committer": {"login": "clubby789", "id": 13556931, "node_id": "MDQ6VXNlcjEzNTU2OTMx", "avatar_url": "https://avatars.githubusercontent.com/u/13556931?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clubby789", "html_url": "https://github.com/clubby789", "followers_url": "https://api.github.com/users/clubby789/followers", "following_url": "https://api.github.com/users/clubby789/following{/other_user}", "gists_url": "https://api.github.com/users/clubby789/gists{/gist_id}", "starred_url": "https://api.github.com/users/clubby789/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clubby789/subscriptions", "organizations_url": "https://api.github.com/users/clubby789/orgs", "repos_url": "https://api.github.com/users/clubby789/repos", "events_url": "https://api.github.com/users/clubby789/events{/privacy}", "received_events_url": "https://api.github.com/users/clubby789/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97cf1713d19d01666bf4613fae51eacce3974640", "url": "https://api.github.com/repos/rust-lang/rust/commits/97cf1713d19d01666bf4613fae51eacce3974640", "html_url": "https://github.com/rust-lang/rust/commit/97cf1713d19d01666bf4613fae51eacce3974640"}], "stats": {"total": 62, "additions": 55, "deletions": 7}, "files": [{"sha": "e0f487e864898d72d530efd0d1b1b0815d01894d", "filename": "compiler/rustc_builtin_macros/src/deriving/debug.rs", "status": "modified", "additions": 49, "deletions": 2, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/95a824c02c3f9a50bb4fa49e7af7d3a5a2faf51e/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95a824c02c3f9a50bb4fa49e7af7d3a5a2faf51e/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs?ref=95a824c02c3f9a50bb4fa49e7af7d3a5a2faf51e", "patch": "@@ -2,6 +2,7 @@ use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::path_std;\n \n+use ast::EnumDef;\n use rustc_ast::{self as ast, MetaItem};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident, Symbol};\n@@ -31,7 +32,8 @@ pub fn expand_deriving_debug(\n             nonself_args: vec![(fmtr, sym::f)],\n             ret_ty: Path(path_std!(fmt::Result)),\n             attributes: ast::AttrVec::new(),\n-            fieldless_variants_strategy: FieldlessVariantsStrategy::Default,\n+            fieldless_variants_strategy:\n+                FieldlessVariantsStrategy::SpecializeIfAllVariantsFieldless,\n             combine_substructure: combine_substructure(Box::new(|a, b, c| {\n                 show_substructure(a, b, c)\n             })),\n@@ -49,7 +51,8 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n     let (ident, vdata, fields) = match substr.fields {\n         Struct(vdata, fields) => (substr.type_ident, *vdata, fields),\n         EnumMatching(_, _, v, fields) => (v.ident, &v.data, fields),\n-        AllFieldlessEnum(..) | EnumTag(..) | StaticStruct(..) | StaticEnum(..) => {\n+        AllFieldlessEnum(enum_def) => return show_fieldless_enum(cx, span, enum_def, substr),\n+        EnumTag(..) | StaticStruct(..) | StaticEnum(..) => {\n             cx.span_bug(span, \"nonsensical .fields in `#[derive(Debug)]`\")\n         }\n     };\n@@ -174,3 +177,47 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n         BlockOrExpr::new_mixed(stmts, Some(expr))\n     }\n }\n+\n+/// Special case for enums with no fields. Builds:\n+/// ```text\n+/// impl ::core::fmt::Debug for A {\n+///     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n+///          ::core::fmt::Formatter::write_str(f,\n+///             match self {\n+///                 A::A => \"A\",\n+///                 A::B() => \"B\",\n+///                 A::C {} => \"C\",\n+///             })\n+///     }\n+/// }\n+/// ```\n+fn show_fieldless_enum(\n+    cx: &mut ExtCtxt<'_>,\n+    span: Span,\n+    def: &EnumDef,\n+    substr: &Substructure<'_>,\n+) -> BlockOrExpr {\n+    let fmt = substr.nonselflike_args[0].clone();\n+    let arms = def\n+        .variants\n+        .iter()\n+        .map(|v| {\n+            let variant_path = cx.path(span, vec![substr.type_ident, v.ident]);\n+            let pat = match &v.data {\n+                ast::VariantData::Tuple(fields, _) => {\n+                    debug_assert!(fields.is_empty());\n+                    cx.pat_tuple_struct(span, variant_path, vec![])\n+                }\n+                ast::VariantData::Struct(fields, _) => {\n+                    debug_assert!(fields.is_empty());\n+                    cx.pat_struct(span, variant_path, vec![])\n+                }\n+                ast::VariantData::Unit(_) => cx.pat_path(span, variant_path),\n+            };\n+            cx.arm(span, pat, cx.expr_str(span, v.ident.name))\n+        })\n+        .collect::<Vec<_>>();\n+    let name = cx.expr_match(span, cx.expr_self(span), arms);\n+    let fn_path_write_str = cx.std_path(&[sym::fmt, sym::Formatter, sym::write_str]);\n+    BlockOrExpr::new_expr(cx.expr_call_global(span, fn_path_write_str, vec![fmt, name]))\n+}"}, {"sha": "e6ee11a783b8849acabb006b020b5dad05d4f5ce", "filename": "tests/ui/deriving/deriving-all-codegen.stdout", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/95a824c02c3f9a50bb4fa49e7af7d3a5a2faf51e/tests%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/95a824c02c3f9a50bb4fa49e7af7d3a5a2faf51e/tests%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderiving%2Fderiving-all-codegen.stdout?ref=95a824c02c3f9a50bb4fa49e7af7d3a5a2faf51e", "patch": "@@ -731,11 +731,12 @@ impl ::core::marker::Copy for Fieldless { }\n #[automatically_derived]\n impl ::core::fmt::Debug for Fieldless {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n-        match self {\n-            Fieldless::A => ::core::fmt::Formatter::write_str(f, \"A\"),\n-            Fieldless::B => ::core::fmt::Formatter::write_str(f, \"B\"),\n-            Fieldless::C => ::core::fmt::Formatter::write_str(f, \"C\"),\n-        }\n+        ::core::fmt::Formatter::write_str(f,\n+            match self {\n+                Fieldless::A => \"A\",\n+                Fieldless::B => \"B\",\n+                Fieldless::C => \"C\",\n+            })\n     }\n }\n #[automatically_derived]"}]}