{"sha": "6045059916beaab2860d22dba96b7061f66535e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwNDUwNTk5MTZiZWFhYjI4NjBkMjJkYmE5NmI3MDYxZjY2NTM1ZTM=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-08-11T15:52:09Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-08-11T15:52:09Z"}, "message": "extract_variable handles selection ranges better", "tree": {"sha": "1cba821e74fbd4aad56bb48fbd5d7156f2c5289f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1cba821e74fbd4aad56bb48fbd5d7156f2c5289f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6045059916beaab2860d22dba96b7061f66535e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6045059916beaab2860d22dba96b7061f66535e3", "html_url": "https://github.com/rust-lang/rust/commit/6045059916beaab2860d22dba96b7061f66535e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6045059916beaab2860d22dba96b7061f66535e3/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f438dbb100a947ed6b541c83342c97bb3408e8e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/f438dbb100a947ed6b541c83342c97bb3408e8e2", "html_url": "https://github.com/rust-lang/rust/commit/f438dbb100a947ed6b541c83342c97bb3408e8e2"}], "stats": {"total": 79, "additions": 57, "deletions": 22}, "files": [{"sha": "692c3f7f07155fcbc65e748671d8a0e959664959", "filename": "crates/ide_assists/src/handlers/extract_function.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6045059916beaab2860d22dba96b7061f66535e3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6045059916beaab2860d22dba96b7061f66535e3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=6045059916beaab2860d22dba96b7061f66535e3", "patch": "@@ -1080,8 +1080,7 @@ fn node_to_insert_after(body: &FunctionBody, anchor: Anchor) -> Option<SyntaxNod\n fn make_call(ctx: &AssistContext, fun: &Function, indent: IndentLevel) -> String {\n     let ret_ty = fun.return_type(ctx);\n \n-    let args = fun.params.iter().map(|param| param.to_arg(ctx));\n-    let args = make::arg_list(args);\n+    let args = make::arg_list(fun.params.iter().map(|param| param.to_arg(ctx)));\n     let name = fun.name.clone();\n     let call_expr = if fun.self_param.is_some() {\n         let self_arg = make::expr_path(make::ext::ident_path(\"self\"));\n@@ -1103,12 +1102,12 @@ fn make_call(ctx: &AssistContext, fun: &Function, indent: IndentLevel) -> String\n         [var] => {\n             format_to!(buf, \"let {}{} = \", mut_modifier(var), var.local.name(ctx.db()).unwrap())\n         }\n-        [v0, vs @ ..] => {\n+        vars => {\n             buf.push_str(\"let (\");\n-            format_to!(buf, \"{}{}\", mut_modifier(v0), v0.local.name(ctx.db()).unwrap());\n-            for var in vs {\n-                format_to!(buf, \", {}{}\", mut_modifier(var), var.local.name(ctx.db()).unwrap());\n-            }\n+            let bindings = vars.iter().format_with(\", \", |local, f| {\n+                f(&format_args!(\"{}{}\", mut_modifier(local), local.local.name(ctx.db()).unwrap()))\n+            });\n+            format_to!(buf, \"{}\", bindings);\n             buf.push_str(\") = \");\n         }\n     }"}, {"sha": "19e09d80686ca0ac942f5b18c472e3f9057978ba", "filename": "crates/ide_assists/src/handlers/inline_local_variable.rs", "status": "modified", "additions": 51, "deletions": 15, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/6045059916beaab2860d22dba96b7061f66535e3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6045059916beaab2860d22dba96b7061f66535e3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs?ref=6045059916beaab2860d22dba96b7061f66535e3", "patch": "@@ -1,8 +1,10 @@\n use either::Either;\n-use hir::PathResolution;\n+use hir::{PathResolution, Semantics};\n use ide_db::{\n+    base_db::{FileId, FileRange},\n     defs::Definition,\n     search::{FileReference, UsageSearchResult},\n+    RootDatabase,\n };\n use syntax::{\n     ast::{self, AstNode, AstToken, NameOwner},\n@@ -31,8 +33,15 @@ use crate::{\n // }\n // ```\n pub(crate) fn inline_local_variable(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let FileRange { file_id, range } = ctx.frange;\n     let InlineData { let_stmt, delete_let, references, target } =\n-        inline_let(ctx).or_else(|| inline_usage(ctx))?;\n+        if let Some(let_stmt) = ctx.find_node_at_offset::<ast::LetStmt>() {\n+            inline_let(&ctx.sema, let_stmt, range, file_id)\n+        } else if let Some(path_expr) = ctx.find_node_at_offset::<ast::PathExpr>() {\n+            inline_usage(&ctx.sema, path_expr, range, file_id)\n+        } else {\n+            None\n+        }?;\n     let initializer_expr = let_stmt.initializer()?;\n \n     let delete_range = delete_let.then(|| {\n@@ -139,8 +148,12 @@ struct InlineData {\n     references: Vec<FileReference>,\n }\n \n-fn inline_let(ctx: &AssistContext) -> Option<InlineData> {\n-    let let_stmt = ctx.find_node_at_offset::<ast::LetStmt>()?;\n+fn inline_let(\n+    sema: &Semantics<RootDatabase>,\n+    let_stmt: ast::LetStmt,\n+    range: TextRange,\n+    file_id: FileId,\n+) -> Option<InlineData> {\n     let bind_pat = match let_stmt.pat()? {\n         ast::Pat::IdentPat(pat) => pat,\n         _ => return None,\n@@ -149,14 +162,14 @@ fn inline_let(ctx: &AssistContext) -> Option<InlineData> {\n         cov_mark::hit!(test_not_inline_mut_variable);\n         return None;\n     }\n-    if !bind_pat.syntax().text_range().contains_inclusive(ctx.offset()) {\n+    if !bind_pat.syntax().text_range().contains_range(range) {\n         cov_mark::hit!(not_applicable_outside_of_bind_pat);\n         return None;\n     }\n \n-    let local = ctx.sema.to_def(&bind_pat)?;\n-    let UsageSearchResult { mut references } = Definition::Local(local).usages(&ctx.sema).all();\n-    match references.remove(&ctx.frange.file_id) {\n+    let local = sema.to_def(&bind_pat)?;\n+    let UsageSearchResult { mut references } = Definition::Local(local).usages(sema).all();\n+    match references.remove(&file_id) {\n         Some(references) => Some(InlineData {\n             let_stmt,\n             delete_let: true,\n@@ -170,29 +183,37 @@ fn inline_let(ctx: &AssistContext) -> Option<InlineData> {\n     }\n }\n \n-fn inline_usage(ctx: &AssistContext) -> Option<InlineData> {\n-    let path_expr = ctx.find_node_at_offset::<ast::PathExpr>()?;\n+fn inline_usage(\n+    sema: &Semantics<RootDatabase>,\n+    path_expr: ast::PathExpr,\n+    range: TextRange,\n+    file_id: FileId,\n+) -> Option<InlineData> {\n     let path = path_expr.path()?;\n     let name = path.as_single_name_ref()?;\n+    if !name.syntax().text_range().contains_range(range) {\n+        cov_mark::hit!(test_not_inline_selection_too_broad);\n+        return None;\n+    }\n \n-    let local = match ctx.sema.resolve_path(&path)? {\n+    let local = match sema.resolve_path(&path)? {\n         PathResolution::Local(local) => local,\n         _ => return None,\n     };\n-    if local.is_mut(ctx.db()) {\n+    if local.is_mut(sema.db) {\n         cov_mark::hit!(test_not_inline_mut_variable_use);\n         return None;\n     }\n \n-    let bind_pat = match local.source(ctx.db()).value {\n+    let bind_pat = match local.source(sema.db).value {\n         Either::Left(ident) => ident,\n         _ => return None,\n     };\n \n     let let_stmt = ast::LetStmt::cast(bind_pat.syntax().parent()?)?;\n \n-    let UsageSearchResult { mut references } = Definition::Local(local).usages(&ctx.sema).all();\n-    let mut references = references.remove(&ctx.frange.file_id)?;\n+    let UsageSearchResult { mut references } = Definition::Local(local).usages(sema).all();\n+    let mut references = references.remove(&file_id)?;\n     let delete_let = references.len() == 1;\n     references.retain(|fref| fref.name.as_name_ref() == Some(&name));\n \n@@ -875,6 +896,21 @@ fn f() {\n     let xyz$0 = 0;\n     m!(xyz); // replacing it would break the macro\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_not_inline_selection_too_broad() {\n+        cov_mark::check!(test_not_inline_selection_too_broad);\n+        check_assist_not_applicable(\n+            inline_local_variable,\n+            r#\"\n+fn f() {\n+    let foo = 0;\n+    let bar = 0;\n+    $0foo + bar$0;\n+}\n \"#,\n         );\n     }"}]}