{"sha": "2de6ddd75e202acdedfcd05b51a863dcc10459ca", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkZTZkZGQ3NWUyMDJhY2RlZGZjZDA1YjUxYTg2M2RjYzEwNDU5Y2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-18T09:46:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-18T09:46:35Z"}, "message": "Auto merge of #32248 - dstu:master, r=alexcrichton\n\nExpose the key of Entry variants for HashMap and BTreeMap.\n\nThis PR addresses [issue 1541](https://github.com/rust-lang/rfcs/issues/1541) by exposing the key of `HashMap` and `BTreeMap` entry variants. Basic tests are provided.", "tree": {"sha": "556c7c429f526d4b94f6e3c1f09c9691e6d6600a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/556c7c429f526d4b94f6e3c1f09c9691e6d6600a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2de6ddd75e202acdedfcd05b51a863dcc10459ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2de6ddd75e202acdedfcd05b51a863dcc10459ca", "html_url": "https://github.com/rust-lang/rust/commit/2de6ddd75e202acdedfcd05b51a863dcc10459ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2de6ddd75e202acdedfcd05b51a863dcc10459ca/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a77d7bde60fd2ba5d55809a44df0e162a901dbfc", "url": "https://api.github.com/repos/rust-lang/rust/commits/a77d7bde60fd2ba5d55809a44df0e162a901dbfc", "html_url": "https://github.com/rust-lang/rust/commit/a77d7bde60fd2ba5d55809a44df0e162a901dbfc"}, {"sha": "2ddba6f361cc8c6c08a1d5a655b11d32935c5bda", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ddba6f361cc8c6c08a1d5a655b11d32935c5bda", "html_url": "https://github.com/rust-lang/rust/commit/2ddba6f361cc8c6c08a1d5a655b11d32935c5bda"}], "stats": {"total": 99, "additions": 99, "deletions": 0}, "files": [{"sha": "7819c7ef7969b9af7ae0e816dfdab40a352d57bc", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2de6ddd75e202acdedfcd05b51a863dcc10459ca/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2de6ddd75e202acdedfcd05b51a863dcc10459ca/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=2de6ddd75e202acdedfcd05b51a863dcc10459ca", "patch": "@@ -1465,6 +1465,13 @@ impl<'a, K: Ord, V> Entry<'a, K, V> {\n }\n \n impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n+    /// Gets a reference to the key that would be used when inserting a value\n+    /// through the VacantEntry.\n+    #[unstable(feature = \"map_entry_keys\", issue = \"32281\")]\n+    pub fn key(&self) -> &K {\n+        &self.key\n+    }\n+\n     /// Sets the value of the entry with the VacantEntry's key,\n     /// and returns a mutable reference to it.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1509,6 +1516,12 @@ impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n }\n \n impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n+    /// Gets a reference to the key in the entry.\n+    #[unstable(feature = \"map_entry_keys\", issue = \"32281\")]\n+    pub fn key(&self) -> &K {\n+        self.handle.reborrow().into_kv().0\n+    }\n+\n     /// Gets a reference to the value in the entry.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self) -> &V {"}, {"sha": "a27c2847a98bcc9f770fb43851ea9b8bf7e5ef65", "filename": "src/libcollectionstest/btree/map.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2de6ddd75e202acdedfcd05b51a863dcc10459ca/src%2Flibcollectionstest%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2de6ddd75e202acdedfcd05b51a863dcc10459ca/src%2Flibcollectionstest%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbtree%2Fmap.rs?ref=2de6ddd75e202acdedfcd05b51a863dcc10459ca", "patch": "@@ -395,6 +395,42 @@ fn test_variance() {\n     fn vals<'a, 'new>(v: Values<'a, (), &'static str>) -> Values<'a, (), &'new str> { v }\n }\n \n+#[test]\n+fn test_occupied_entry_key() {\n+    let mut a = BTreeMap::new();\n+    let key = \"hello there\";\n+    let value = \"value goes here\";\n+    assert!(a.is_empty());\n+    a.insert(key.clone(), value.clone());\n+    assert_eq!(a.len(), 1);\n+    assert_eq!(a[key], value);\n+\n+    match a.entry(key.clone()) {\n+        Vacant(_) => panic!(),\n+        Occupied(e) => assert_eq!(key, *e.key()),\n+    }\n+    assert_eq!(a.len(), 1);\n+    assert_eq!(a[key], value);\n+}\n+\n+#[test]\n+fn test_vacant_entry_key() {\n+    let mut a = BTreeMap::new();\n+    let key = \"hello there\";\n+    let value = \"value goes here\";\n+\n+    assert!(a.is_empty());\n+    match a.entry(key.clone()) {\n+        Occupied(_) => panic!(),\n+        Vacant(e) => {\n+            assert_eq!(key, *e.key());\n+            e.insert(value.clone());\n+        },\n+    }\n+    assert_eq!(a.len(), 1);\n+    assert_eq!(a[key], value);\n+}\n+\n mod bench {\n     use std::collections::BTreeMap;\n     use std::__rand::{Rng, thread_rng};"}, {"sha": "62fefaa10f677a694c66962b6d5f398d42206c30", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2de6ddd75e202acdedfcd05b51a863dcc10459ca/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2de6ddd75e202acdedfcd05b51a863dcc10459ca/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=2de6ddd75e202acdedfcd05b51a863dcc10459ca", "patch": "@@ -21,6 +21,7 @@\n #![feature(fn_traits)]\n #![feature(enumset)]\n #![feature(iter_arith)]\n+#![feature(map_entry_keys)]\n #![feature(pattern)]\n #![feature(rand)]\n #![feature(set_recovery)]"}, {"sha": "56d95401a9a4c189fb4f87f247c369eeb36e798b", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/2de6ddd75e202acdedfcd05b51a863dcc10459ca/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2de6ddd75e202acdedfcd05b51a863dcc10459ca/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=2de6ddd75e202acdedfcd05b51a863dcc10459ca", "patch": "@@ -1554,6 +1554,12 @@ impl<'a, K, V> Entry<'a, K, V> {\n }\n \n impl<'a, K, V> OccupiedEntry<'a, K, V> {\n+    /// Gets a reference to the key in the entry.\n+    #[unstable(feature = \"map_entry_keys\", issue = \"32281\")]\n+    pub fn key(&self) -> &K {\n+        self.elem.read().0\n+    }\n+\n     /// Gets a reference to the value in the entry.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self) -> &V {\n@@ -1589,6 +1595,13 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n }\n \n impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n+    /// Gets a reference to the key that would be used when inserting a value\n+    /// through the VacantEntry.\n+    #[unstable(feature = \"map_entry_keys\", issue = \"32281\")]\n+    pub fn key(&self) -> &K {\n+        &self.key\n+    }\n+\n     /// Sets the value of the entry with the VacantEntry's key,\n     /// and returns a mutable reference to it\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2434,4 +2447,40 @@ mod test_map {\n         a.insert(item, 0);\n         assert!(a.capacity() > a.len());\n     }\n+\n+    #[test]\n+    fn test_occupied_entry_key() {\n+        let mut a = HashMap::new();\n+        let key = \"hello there\";\n+        let value = \"value goes here\";\n+        assert!(a.is_empty());\n+        a.insert(key.clone(), value.clone());\n+        assert_eq!(a.len(), 1);\n+        assert_eq!(a[key], value);\n+\n+        match a.entry(key.clone()) {\n+            Vacant(_) => panic!(),\n+            Occupied(e) => assert_eq!(key, *e.key()),\n+        }\n+        assert_eq!(a.len(), 1);\n+        assert_eq!(a[key], value);\n+    }\n+\n+    #[test]\n+    fn test_vacant_entry_key() {\n+        let mut a = HashMap::new();\n+        let key = \"hello there\";\n+        let value = \"value goes here\";\n+\n+        assert!(a.is_empty());\n+        match a.entry(key.clone()) {\n+            Occupied(_) => panic!(),\n+            Vacant(e) => {\n+                assert_eq!(key, *e.key());\n+                e.insert(value.clone());\n+            },\n+        }\n+        assert_eq!(a.len(), 1);\n+        assert_eq!(a[key], value);\n+    }\n }"}]}