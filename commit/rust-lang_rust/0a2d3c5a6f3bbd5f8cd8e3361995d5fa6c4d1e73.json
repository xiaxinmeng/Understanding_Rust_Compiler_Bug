{"sha": "0a2d3c5a6f3bbd5f8cd8e3361995d5fa6c4d1e73", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhMmQzYzVhNmYzYmJkNWY4Y2Q4ZTMzNjE5OTVkNWZhNmM0ZDFlNzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-12T11:36:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-12T11:36:06Z"}, "message": "auto merge of #9096 : huonw/rust/linenoise, r=brson\n\n- Wrap calls into linenoise in a mutex so that the functions don't have to be `unsafe` any more (fixes #3921)\r\n- Stop leaking every line that linenoise reads.\r\n- Handle the situation of `rl::complete(some_function); do spawn { rl::read(\"\"); }` which would crash (`fail!` that turned into an abort, possibly due to failing with the lock locked) when the user attempted to tab-complete anything.\r\n- Add a test for the various functions; it has to be run by hand to verify anything works, but it won't bitrot.", "tree": {"sha": "df63170dd1385f7f4b5d23dd95d9bb02faa5196a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df63170dd1385f7f4b5d23dd95d9bb02faa5196a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a2d3c5a6f3bbd5f8cd8e3361995d5fa6c4d1e73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a2d3c5a6f3bbd5f8cd8e3361995d5fa6c4d1e73", "html_url": "https://github.com/rust-lang/rust/commit/0a2d3c5a6f3bbd5f8cd8e3361995d5fa6c4d1e73", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a2d3c5a6f3bbd5f8cd8e3361995d5fa6c4d1e73/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4825db44c81ca2b122282dfb59aa705ad2475e5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4825db44c81ca2b122282dfb59aa705ad2475e5d", "html_url": "https://github.com/rust-lang/rust/commit/4825db44c81ca2b122282dfb59aa705ad2475e5d"}, {"sha": "a9184975da62769dfccbca73fb9bd554298a4d36", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9184975da62769dfccbca73fb9bd554298a4d36", "html_url": "https://github.com/rust-lang/rust/commit/a9184975da62769dfccbca73fb9bd554298a4d36"}], "stats": {"total": 211, "additions": 170, "deletions": 41}, "files": [{"sha": "74b7aea99787794ad9735519ca9a49023b285d5d", "filename": "src/libextra/rl.rs", "status": "modified", "additions": 73, "deletions": 31, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/0a2d3c5a6f3bbd5f8cd8e3361995d5fa6c4d1e73/src%2Flibextra%2Frl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2d3c5a6f3bbd5f8cd8e3361995d5fa6c4d1e73/src%2Flibextra%2Frl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frl.rs?ref=0a2d3c5a6f3bbd5f8cd8e3361995d5fa6c4d1e73", "patch": "@@ -8,13 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// FIXME #3921. This is unsafe because linenoise uses global mutable\n-// state without mutexes.\n-\n use std::c_str::ToCStr;\n use std::libc::{c_char, c_int};\n-use std::local_data;\n-use std::str;\n+use std::{local_data, str, rt};\n+use std::unstable::finally::Finally;\n \n #[cfg(stage0)]\n pub mod rustrt {\n@@ -28,6 +25,9 @@ pub mod rustrt {\n         fn linenoiseHistoryLoad(file: *c_char) -> c_int;\n         fn linenoiseSetCompletionCallback(callback: *u8);\n         fn linenoiseAddCompletion(completions: *(), line: *c_char);\n+\n+        fn rust_take_linenoise_lock();\n+        fn rust_drop_linenoise_lock();\n     }\n }\n \n@@ -42,65 +42,107 @@ pub mod rustrt {\n     externfn!(fn linenoiseHistoryLoad(file: *c_char) -> c_int)\n     externfn!(fn linenoiseSetCompletionCallback(callback: extern \"C\" fn(*i8, *())))\n     externfn!(fn linenoiseAddCompletion(completions: *(), line: *c_char))\n+\n+    externfn!(fn rust_take_linenoise_lock())\n+    externfn!(fn rust_drop_linenoise_lock())\n+}\n+\n+macro_rules! locked {\n+    ($expr:expr) => {\n+        unsafe {\n+            // FIXME #9105: can't use a static mutex in pure Rust yet.\n+            rustrt::rust_take_linenoise_lock();\n+            let x = $expr;\n+            rustrt::rust_drop_linenoise_lock();\n+            x\n+        }\n+    }\n }\n \n /// Add a line to history\n-pub unsafe fn add_history(line: &str) -> bool {\n+pub fn add_history(line: &str) -> bool {\n     do line.with_c_str |buf| {\n-        rustrt::linenoiseHistoryAdd(buf) == 1 as c_int\n+        (locked!(rustrt::linenoiseHistoryAdd(buf))) == 1 as c_int\n     }\n }\n \n /// Set the maximum amount of lines stored\n-pub unsafe fn set_history_max_len(len: int) -> bool {\n-    rustrt::linenoiseHistorySetMaxLen(len as c_int) == 1 as c_int\n+pub fn set_history_max_len(len: int) -> bool {\n+    (locked!(rustrt::linenoiseHistorySetMaxLen(len as c_int))) == 1 as c_int\n }\n \n /// Save line history to a file\n-pub unsafe fn save_history(file: &str) -> bool {\n+pub fn save_history(file: &str) -> bool {\n     do file.with_c_str |buf| {\n-        rustrt::linenoiseHistorySave(buf) == 1 as c_int\n+        // 0 on success, -1 on failure\n+        (locked!(rustrt::linenoiseHistorySave(buf))) == 0 as c_int\n     }\n }\n \n /// Load line history from a file\n-pub unsafe fn load_history(file: &str) -> bool {\n+pub fn load_history(file: &str) -> bool {\n     do file.with_c_str |buf| {\n-        rustrt::linenoiseHistoryLoad(buf) == 1 as c_int\n+        // 0 on success, -1 on failure\n+        (locked!(rustrt::linenoiseHistoryLoad(buf))) == 0 as c_int\n     }\n }\n \n /// Print out a prompt and then wait for input and return it\n-pub unsafe fn read(prompt: &str) -> Option<~str> {\n+pub fn read(prompt: &str) -> Option<~str> {\n     do prompt.with_c_str |buf| {\n-        let line = rustrt::linenoise(buf);\n+        let line = locked!(rustrt::linenoise(buf));\n \n         if line.is_null() { None }\n-        else { Some(str::raw::from_c_str(line)) }\n+        else {\n+            unsafe {\n+                do (|| {\n+                    Some(str::raw::from_c_str(line))\n+                }).finally {\n+                    // linenoise's return value is from strdup, so we\n+                    // better not leak it.\n+                    rt::global_heap::exchange_free(line);\n+                }\n+            }\n+        }\n     }\n }\n \n pub type CompletionCb = @fn(~str, @fn(~str));\n \n-static complete_key: local_data::Key<@CompletionCb> = &local_data::Key;\n-\n-/// Bind to the main completion callback\n-pub unsafe fn complete(cb: CompletionCb) {\n-    local_data::set(complete_key, @cb);\n-\n-    extern fn callback(line: *c_char, completions: *()) {\n-        do local_data::get(complete_key) |cb| {\n-            let cb = **cb.unwrap();\n-\n-            unsafe {\n-                do cb(str::raw::from_c_str(line)) |suggestion| {\n-                    do suggestion.with_c_str |buf| {\n-                        rustrt::linenoiseAddCompletion(completions, buf);\n+static complete_key: local_data::Key<CompletionCb> = &local_data::Key;\n+\n+/// Bind to the main completion callback in the current task.\n+///\n+/// The completion callback should not call any `extra::rl` functions\n+/// other than the closure that it receives as its second\n+/// argument. Calling such a function will deadlock on the mutex used\n+/// to ensure that the calls are thread-safe.\n+pub fn complete(cb: CompletionCb) {\n+    local_data::set(complete_key, cb);\n+\n+    extern fn callback(c_line: *c_char, completions: *()) {\n+        do local_data::get(complete_key) |opt_cb| {\n+            // only fetch completions if a completion handler has been\n+            // registered in the current task.\n+            match opt_cb {\n+                None => {},\n+                Some(cb) => {\n+                    let line = unsafe { str::raw::from_c_str(c_line) };\n+                    do (*cb)(line) |suggestion| {\n+                        do suggestion.with_c_str |buf| {\n+                            // This isn't locked, because `callback` gets\n+                            // called inside `rustrt::linenoise`, which\n+                            // *is* already inside the mutex, so\n+                            // re-locking would be a deadlock.\n+                            unsafe {\n+                                rustrt::linenoiseAddCompletion(completions, buf);\n+                            }\n+                        }\n                     }\n                 }\n             }\n         }\n     }\n \n-    rustrt::linenoiseSetCompletionCallback(callback);\n+    locked!(rustrt::linenoiseSetCompletionCallback(callback));\n }"}, {"sha": "8d61a971157fc35e69687b423794dac6c797753e", "filename": "src/librusti/rusti.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0a2d3c5a6f3bbd5f8cd8e3361995d5fa6c4d1e73/src%2Flibrusti%2Frusti.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2d3c5a6f3bbd5f8cd8e3361995d5fa6c4d1e73/src%2Flibrusti%2Frusti.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rs?ref=0a2d3c5a6f3bbd5f8cd8e3361995d5fa6c4d1e73", "patch": "@@ -355,12 +355,12 @@ fn compile_crate(src_filename: ~str, binary: ~str) -> Option<bool> {\n /// None if no input was read (e.g. EOF was reached).\n fn get_line(use_rl: bool, prompt: &str) -> Option<~str> {\n     if use_rl {\n-        let result = unsafe { rl::read(prompt) };\n+        let result = rl::read(prompt);\n \n         match result {\n             None => None,\n             Some(line) => {\n-                unsafe { rl::add_history(line) };\n+                rl::add_history(line);\n                 Some(line)\n             }\n         }\n@@ -525,14 +525,12 @@ pub fn main_args(args: &[~str]) {\n         println(\"unstable. If you encounter problems, please use the\");\n         println(\"compiler instead. Type :help for help.\");\n \n-        unsafe {\n-            do rl::complete |line, suggest| {\n-                if line.starts_with(\":\") {\n-                    suggest(~\":clear\");\n-                    suggest(~\":exit\");\n-                    suggest(~\":help\");\n-                    suggest(~\":load\");\n-                }\n+        do rl::complete |line, suggest| {\n+            if line.starts_with(\":\") {\n+                suggest(~\":clear\");\n+                suggest(~\":exit\");\n+                suggest(~\":help\");\n+                suggest(~\":load\");\n             }\n         }\n     }"}, {"sha": "1871e7f36b363a376591db071278e86e636a5280", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0a2d3c5a6f3bbd5f8cd8e3361995d5fa6c4d1e73/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/0a2d3c5a6f3bbd5f8cd8e3361995d5fa6c4d1e73/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=0a2d3c5a6f3bbd5f8cd8e3361995d5fa6c4d1e73", "patch": "@@ -633,6 +633,18 @@ rust_drop_env_lock() {\n     env_lock.unlock();\n }\n \n+static lock_and_signal linenoise_lock;\n+\n+extern \"C\" CDECL void\n+rust_take_linenoise_lock() {\n+    linenoise_lock.lock();\n+}\n+\n+extern \"C\" CDECL void\n+rust_drop_linenoise_lock() {\n+    linenoise_lock.unlock();\n+}\n+\n extern \"C\" CDECL unsigned int\n rust_valgrind_stack_register(void *start, void *end) {\n   return VALGRIND_STACK_REGISTER(start, end);"}, {"sha": "56405224c8a9f4de9cdbf6c7f0aa86a9d79e4d7d", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a2d3c5a6f3bbd5f8cd8e3361995d5fa6c4d1e73/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/0a2d3c5a6f3bbd5f8cd8e3361995d5fa6c4d1e73/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=0a2d3c5a6f3bbd5f8cd8e3361995d5fa6c4d1e73", "patch": "@@ -189,6 +189,8 @@ rust_take_global_args_lock\n rust_drop_global_args_lock\n rust_take_change_dir_lock\n rust_drop_change_dir_lock\n+rust_take_linenoise_lock\n+rust_drop_linenoise_lock\n rust_get_test_int\n rust_get_task\n rust_uv_get_loop_from_getaddrinfo_req"}, {"sha": "558e0b6820dcbee720b2d36bcb5a3b3928a07e57", "filename": "src/test/run-pass/rl-human-test.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/0a2d3c5a6f3bbd5f8cd8e3361995d5fa6c4d1e73/src%2Ftest%2Frun-pass%2Frl-human-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2d3c5a6f3bbd5f8cd8e3361995d5fa6c4d1e73/src%2Ftest%2Frun-pass%2Frl-human-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frl-human-test.rs?ref=0a2d3c5a6f3bbd5f8cd8e3361995d5fa6c4d1e73", "patch": "@@ -0,0 +1,75 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-fast no compile flags for check-fast\n+\n+// we want this to be compiled to avoid bitrot, but the actual test\n+//has to be conducted by a human, i.e. someone (you?) compiling this\n+//file with a plain rustc invocation and running it and checking it\n+//works.\n+\n+// compile-flags: --cfg robot_mode\n+\n+extern mod extra;\n+use extra::rl;\n+\n+static HISTORY_FILE: &'static str = \"rl-human-test-history.txt\";\n+\n+fn main() {\n+    // don't run this in robot mode, but still typecheck it.\n+    if !cfg!(robot_mode) {\n+        println(\"~~ Welcome to the rl test \\\"suite\\\". ~~\");\n+        println!(\"Operations:\n+ - restrict the history to 2 lines,\n+ - set the tab-completion to suggest three copies of each of the last 3 letters (or 'empty'),\n+ - add 'one' and 'two' to the history,\n+ - save it to `{0}`,\n+ - add 'three',\n+ - prompt & save input (check the history & completion work and contains only 'two', 'three'),\n+ - load from `{0}`\n+ - prompt & save input (history should be 'one', 'two' again),\n+ - prompt once more.\n+\n+The bool return values of each step are printed.\",\n+                 HISTORY_FILE);\n+\n+        println!(\"restricting history length: {}\", rl::set_history_max_len(3));\n+\n+        do rl::complete |line, suggest| {\n+            if line.is_empty() {\n+                suggest(~\"empty\")\n+            } else {\n+                for c in line.rev_iter().take(3) {\n+                    suggest(format!(\"{0}{1}{1}{1}\", line, c))\n+                }\n+            }\n+        }\n+\n+        println!(\"adding 'one': {}\", rl::add_history(\"one\"));\n+        println!(\"adding 'two': {}\", rl::add_history(\"two\"));\n+\n+        println!(\"saving history: {}\", rl::save_history(HISTORY_FILE));\n+\n+        println!(\"adding 'three': {}\", rl::add_history(\"three\"));\n+\n+        match rl::read(\"> \") {\n+            Some(s) => println!(\"saving input: {}\", rl::add_history(s)),\n+            None => return\n+        }\n+        println!(\"loading history: {}\", rl::load_history(HISTORY_FILE));\n+\n+        match rl::read(\"> \") {\n+            Some(s) => println!(\"saving input: {}\", rl::add_history(s)),\n+            None => return\n+        }\n+\n+        rl::read(\"> \");\n+    }\n+}"}]}