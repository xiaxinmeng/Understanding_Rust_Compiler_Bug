{"sha": "2896278313ede1b24b47c88bafe684adabbc92d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4OTYyNzgzMTNlZGUxYjI0YjQ3Yzg4YmFmZTY4NGFkYWJiYzkyZDQ=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-10-30T01:11:16Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-11-06T01:12:00Z"}, "message": "DSTify PartialEq, PartialOrd, Eq, Ord", "tree": {"sha": "2150e45567ef3738d42d639862dfb56ad8c91e4f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2150e45567ef3738d42d639862dfb56ad8c91e4f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2896278313ede1b24b47c88bafe684adabbc92d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2896278313ede1b24b47c88bafe684adabbc92d4", "html_url": "https://github.com/rust-lang/rust/commit/2896278313ede1b24b47c88bafe684adabbc92d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2896278313ede1b24b47c88bafe684adabbc92d4/comments", "author": null, "committer": null, "parents": [{"sha": "1a943754262a621fb06db4de7ca657a225706531", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a943754262a621fb06db4de7ca657a225706531", "html_url": "https://github.com/rust-lang/rust/commit/1a943754262a621fb06db4de7ca657a225706531"}], "stats": {"total": 329, "additions": 329, "deletions": 0}, "files": [{"sha": "6e87fe4ced02dbc141b0cc49a28c5f3a364d8d9f", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/2896278313ede1b24b47c88bafe684adabbc92d4/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2896278313ede1b24b47c88bafe684adabbc92d4/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=2896278313ede1b24b47c88bafe684adabbc92d4", "patch": "@@ -55,6 +55,8 @@ use option::{Option, Some, None};\n ///\n /// Eventually, this will be implemented by default for types that implement\n /// `Eq`.\n+// NOTE(stage0): remove trait after a snapshot\n+#[cfg(stage0)]\n #[lang=\"eq\"]\n #[unstable = \"Definition may change slightly after trait reform\"]\n pub trait PartialEq {\n@@ -66,6 +68,31 @@ pub trait PartialEq {\n     fn ne(&self, other: &Self) -> bool { !self.eq(other) }\n }\n \n+/// Trait for values that can be compared for equality and inequality.\n+///\n+/// This trait allows for partial equality, for types that do not have an\n+/// equivalence relation. For example, in floating point numbers `NaN != NaN`,\n+/// so floating point types implement `PartialEq` but not `Eq`.\n+///\n+/// PartialEq only requires the `eq` method to be implemented; `ne` is defined\n+/// in terms of it by default. Any manual implementation of `ne` *must* respect\n+/// the rule that `eq` is a strict inverse of `ne`; that is, `!(a == b)` if and\n+/// only if `a != b`.\n+///\n+/// Eventually, this will be implemented by default for types that implement\n+/// `Eq`.\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[lang=\"eq\"]\n+#[unstable = \"Definition may change slightly after trait reform\"]\n+pub trait PartialEq for Sized? {\n+    /// This method tests for `self` and `other` values to be equal, and is used by `==`.\n+    fn eq(&self, other: &Self) -> bool;\n+\n+    /// This method tests for `!=`.\n+    #[inline]\n+    fn ne(&self, other: &Self) -> bool { !self.eq(other) }\n+}\n+\n /// Trait for equality comparisons which are [equivalence relations](\n /// https://en.wikipedia.org/wiki/Equivalence_relation).\n ///\n@@ -75,6 +102,8 @@ pub trait PartialEq {\n /// - reflexive: `a == a`;\n /// - symmetric: `a == b` implies `b == a`; and\n /// - transitive: `a == b` and `b == c` implies `a == c`.\n+// NOTE(stage0): remove trait after a snapshot\n+#[cfg(stage0)]\n #[unstable = \"Definition may change slightly after trait reform\"]\n pub trait Eq: PartialEq {\n     // FIXME #13101: this method is used solely by #[deriving] to\n@@ -89,6 +118,30 @@ pub trait Eq: PartialEq {\n     fn assert_receiver_is_total_eq(&self) {}\n }\n \n+/// Trait for equality comparisons which are [equivalence relations](\n+/// https://en.wikipedia.org/wiki/Equivalence_relation).\n+///\n+/// This means, that in addition to `a == b` and `a != b` being strict\n+/// inverses, the equality must be (for all `a`, `b` and `c`):\n+///\n+/// - reflexive: `a == a`;\n+/// - symmetric: `a == b` implies `b == a`; and\n+/// - transitive: `a == b` and `b == c` implies `a == c`.\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[unstable = \"Definition may change slightly after trait reform\"]\n+pub trait Eq for Sized?: PartialEq {\n+    // FIXME #13101: this method is used solely by #[deriving] to\n+    // assert that every component of a type implements #[deriving]\n+    // itself, the current deriving infrastructure means doing this\n+    // assertion without using a method on this trait is nearly\n+    // impossible.\n+    //\n+    // This should never be implemented by hand.\n+    #[doc(hidden)]\n+    #[inline(always)]\n+    fn assert_receiver_is_total_eq(&self) {}\n+}\n+\n /// An ordering is, e.g, a result of a comparison between two values.\n #[deriving(Clone, PartialEq, Show)]\n #[stable]\n@@ -145,6 +198,8 @@ impl Ordering {\n ///   true; and\n /// - transitive, `a < b` and `b < c` implies `a < c`. The same must hold for\n ///   both `==` and `>`.\n+// NOTE(stage0): remove trait after a snapshot\n+#[cfg(stage0)]\n #[unstable = \"Definition may change slightly after trait reform\"]\n pub trait Ord: Eq + PartialOrd {\n     /// This method returns an ordering between `self` and `other` values.\n@@ -160,6 +215,31 @@ pub trait Ord: Eq + PartialOrd {\n     fn cmp(&self, other: &Self) -> Ordering;\n }\n \n+/// Trait for types that form a [total order](\n+/// https://en.wikipedia.org/wiki/Total_order).\n+///\n+/// An order is a total order if it is (for all `a`, `b` and `c`):\n+///\n+/// - total and antisymmetric: exactly one of `a < b`, `a == b` or `a > b` is\n+///   true; and\n+/// - transitive, `a < b` and `b < c` implies `a < c`. The same must hold for\n+///   both `==` and `>`.\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[unstable = \"Definition may change slightly after trait reform\"]\n+pub trait Ord for Sized?: Eq + PartialOrd {\n+    /// This method returns an ordering between `self` and `other` values.\n+    ///\n+    /// By convention, `self.cmp(&other)` returns the ordering matching\n+    /// the expression `self <operator> other` if true.  For example:\n+    ///\n+    /// ```\n+    /// assert_eq!( 5u.cmp(&10), Less);     // because 5 < 10\n+    /// assert_eq!(10u.cmp(&5),  Greater);  // because 10 > 5\n+    /// assert_eq!( 5u.cmp(&5),  Equal);    // because 5 == 5\n+    /// ```\n+    fn cmp(&self, other: &Self) -> Ordering;\n+}\n+\n #[unstable = \"Trait is unstable.\"]\n impl Eq for Ordering {}\n \n@@ -188,6 +268,8 @@ impl PartialOrd for Ordering {\n /// which do not have a total order. For example, for floating point numbers,\n /// `NaN < 0 == false` and `NaN >= 0 == false` (cf. IEEE 754-2008 section\n /// 5.11).\n+// NOTE(stage0): remove trait after a snapshot\n+#[cfg(stage0)]\n #[lang=\"ord\"]\n #[unstable = \"Definition may change slightly after trait reform\"]\n pub trait PartialOrd: PartialEq {\n@@ -232,6 +314,60 @@ pub trait PartialOrd: PartialEq {\n     }\n }\n \n+/// Trait for values that can be compared for a sort-order.\n+///\n+/// PartialOrd only requires implementation of the `partial_cmp` method,\n+/// with the others generated from default implementations.\n+///\n+/// However it remains possible to implement the others separately for types\n+/// which do not have a total order. For example, for floating point numbers,\n+/// `NaN < 0 == false` and `NaN >= 0 == false` (cf. IEEE 754-2008 section\n+/// 5.11).\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[lang=\"ord\"]\n+#[unstable = \"Definition may change slightly after trait reform\"]\n+pub trait PartialOrd for Sized?: PartialEq {\n+    /// This method returns an ordering between `self` and `other` values\n+    /// if one exists.\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering>;\n+\n+    /// This method tests less than (for `self` and `other`) and is used by the `<` operator.\n+    #[inline]\n+    fn lt(&self, other: &Self) -> bool {\n+        match self.partial_cmp(other) {\n+            Some(Less) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// This method tests less than or equal to (`<=`).\n+    #[inline]\n+    fn le(&self, other: &Self) -> bool {\n+        match self.partial_cmp(other) {\n+            Some(Less) | Some(Equal) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// This method tests greater than (`>`).\n+    #[inline]\n+    fn gt(&self, other: &Self) -> bool {\n+        match self.partial_cmp(other) {\n+            Some(Greater) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// This method tests greater than or equal to (`>=`).\n+    #[inline]\n+    fn ge(&self, other: &Self) -> bool {\n+        match self.partial_cmp(other) {\n+            Some(Greater) | Some(Equal) => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n /// The equivalence relation. Two values may be equivalent even if they are\n /// of different types. The most common use case for this relation is\n /// container types; e.g. it is often desirable to be able to use `&str`\n@@ -286,6 +422,8 @@ pub fn partial_max<T: PartialOrd>(v1: T, v2: T) -> Option<T> {\n mod impls {\n     use cmp::{PartialOrd, Ord, PartialEq, Eq, Ordering,\n               Less, Greater, Equal};\n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    use kinds::Sized;\n     use option::{Option, Some, None};\n \n     macro_rules! partial_eq_impl(\n@@ -393,13 +531,17 @@ mod impls {\n     ord_impl!(char uint u8 u16 u32 u64 int i8 i16 i32 i64)\n \n     // & pointers\n+    // NOTE(stage0): remove impl after a snapshot\n+    #[cfg(stage0)]\n     #[unstable = \"Trait is unstable.\"]\n     impl<'a, T: PartialEq> PartialEq for &'a T {\n         #[inline]\n         fn eq(&self, other: & &'a T) -> bool { *(*self) == *(*other) }\n         #[inline]\n         fn ne(&self, other: & &'a T) -> bool { *(*self) != *(*other) }\n     }\n+    // NOTE(stage0): remove impl after a snapshot\n+    #[cfg(stage0)]\n     #[unstable = \"Trait is unstable.\"]\n     impl<'a, T: PartialOrd> PartialOrd for &'a T {\n         #[inline]\n@@ -415,22 +557,64 @@ mod impls {\n         #[inline]\n         fn gt(&self, other: & &'a T) -> bool { *(*self) > *(*other) }\n     }\n+    // NOTE(stage0): remove impl after a snapshot\n+    #[cfg(stage0)]\n     #[unstable = \"Trait is unstable.\"]\n     impl<'a, T: Ord> Ord for &'a T {\n         #[inline]\n         fn cmp(&self, other: & &'a T) -> Ordering { (**self).cmp(*other) }\n     }\n+    // NOTE(stage0): remove impl after a snapshot\n+    #[cfg(stage0)]\n     #[unstable = \"Trait is unstable.\"]\n     impl<'a, T: Eq> Eq for &'a T {}\n \n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    #[unstable = \"Trait is unstable.\"]\n+    impl<'a, Sized? T: PartialEq> PartialEq for &'a T {\n+        #[inline]\n+        fn eq(&self, other: & &'a T) -> bool { PartialEq::eq(*self, *other) }\n+        #[inline]\n+        fn ne(&self, other: & &'a T) -> bool { PartialEq::ne(*self, *other) }\n+    }\n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    #[unstable = \"Trait is unstable.\"]\n+    impl<'a, Sized? T: PartialOrd> PartialOrd for &'a T {\n+        #[inline]\n+        fn partial_cmp(&self, other: &&'a T) -> Option<Ordering> {\n+            PartialOrd::partial_cmp(*self, *other)\n+        }\n+        #[inline]\n+        fn lt(&self, other: & &'a T) -> bool { PartialOrd::lt(*self, *other) }\n+        #[inline]\n+        fn le(&self, other: & &'a T) -> bool { PartialOrd::le(*self, *other) }\n+        #[inline]\n+        fn ge(&self, other: & &'a T) -> bool { PartialOrd::ge(*self, *other) }\n+        #[inline]\n+        fn gt(&self, other: & &'a T) -> bool { PartialOrd::gt(*self, *other) }\n+    }\n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    #[unstable = \"Trait is unstable.\"]\n+    impl<'a, Sized? T: Ord> Ord for &'a T {\n+        #[inline]\n+        fn cmp(&self, other: & &'a T) -> Ordering { Ord::cmp(*self, *other) }\n+    }\n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    #[unstable = \"Trait is unstable.\"]\n+    impl<'a, Sized? T: Eq> Eq for &'a T {}\n+\n     // &mut pointers\n+    // NOTE(stage0): remove impl after a snapshot\n+    #[cfg(stage0)]\n     #[unstable = \"Trait is unstable.\"]\n     impl<'a, T: PartialEq> PartialEq for &'a mut T {\n         #[inline]\n         fn eq(&self, other: &&'a mut T) -> bool { **self == *(*other) }\n         #[inline]\n         fn ne(&self, other: &&'a mut T) -> bool { **self != *(*other) }\n     }\n+    // NOTE(stage0): remove impl after a snapshot\n+    #[cfg(stage0)]\n     #[unstable = \"Trait is unstable.\"]\n     impl<'a, T: PartialOrd> PartialOrd for &'a mut T {\n         #[inline]\n@@ -446,11 +630,49 @@ mod impls {\n         #[inline]\n         fn gt(&self, other: &&'a mut T) -> bool { **self > **other }\n     }\n+    // NOTE(stage0): remove impl after a snapshot\n+    #[cfg(stage0)]\n     #[unstable = \"Trait is unstable.\"]\n     impl<'a, T: Ord> Ord for &'a mut T {\n         #[inline]\n         fn cmp(&self, other: &&'a mut T) -> Ordering { (**self).cmp(*other) }\n     }\n+    // NOTE(stage0): remove impl after a snapshot\n+    #[cfg(stage0)]\n     #[unstable = \"Trait is unstable.\"]\n     impl<'a, T: Eq> Eq for &'a mut T {}\n+\n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    #[unstable = \"Trait is unstable.\"]\n+    impl<'a, Sized? T: PartialEq> PartialEq for &'a mut T {\n+        #[inline]\n+        fn eq(&self, other: &&'a mut T) -> bool { PartialEq::eq(*self, *other) }\n+        #[inline]\n+        fn ne(&self, other: &&'a mut T) -> bool { PartialEq::ne(*self, *other) }\n+    }\n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    #[unstable = \"Trait is unstable.\"]\n+    impl<'a, Sized? T: PartialOrd> PartialOrd for &'a mut T {\n+        #[inline]\n+        fn partial_cmp(&self, other: &&'a mut T) -> Option<Ordering> {\n+            PartialOrd::partial_cmp(*self, *other)\n+        }\n+        #[inline]\n+        fn lt(&self, other: &&'a mut T) -> bool { PartialOrd::lt(*self, *other) }\n+        #[inline]\n+        fn le(&self, other: &&'a mut T) -> bool { PartialOrd::le(*self, *other) }\n+        #[inline]\n+        fn ge(&self, other: &&'a mut T) -> bool { PartialOrd::ge(*self, *other) }\n+        #[inline]\n+        fn gt(&self, other: &&'a mut T) -> bool { PartialOrd::gt(*self, *other) }\n+    }\n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    #[unstable = \"Trait is unstable.\"]\n+    impl<'a, Sized? T: Ord> Ord for &'a mut T {\n+        #[inline]\n+        fn cmp(&self, other: &&'a mut T) -> Ordering { Ord::cmp(*self, *other) }\n+    }\n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    #[unstable = \"Trait is unstable.\"]\n+    impl<'a, Sized? T: Eq> Eq for &'a mut T {}\n }"}, {"sha": "3cc904162a13464bffec6de2bb3717f976404080", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/2896278313ede1b24b47c88bafe684adabbc92d4/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2896278313ede1b24b47c88bafe684adabbc92d4/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=2896278313ede1b24b47c88bafe684adabbc92d4", "patch": "@@ -1555,6 +1555,8 @@ pub mod bytes {\n // Boilerplate traits\n //\n \n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n #[unstable = \"waiting for DST\"]\n impl<'a,T:PartialEq> PartialEq for &'a [T] {\n     fn eq(&self, other: & &'a [T]) -> bool {\n@@ -1567,15 +1569,36 @@ impl<'a,T:PartialEq> PartialEq for &'a [T] {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[unstable = \"waiting for DST\"]\n+impl<T: PartialEq> PartialEq for [T] {\n+    fn eq(&self, other: &[T]) -> bool {\n+        self.len() == other.len() &&\n+            order::eq(self.iter(), other.iter())\n+    }\n+    fn ne(&self, other: &[T]) -> bool {\n+        self.len() != other.len() ||\n+            order::ne(self.iter(), other.iter())\n+    }\n+}\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n #[unstable = \"waiting for DST\"]\n impl<'a,T:Eq> Eq for &'a [T] {}\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[unstable = \"waiting for DST\"]\n+impl<T: Eq> Eq for [T] {}\n+\n #[unstable = \"waiting for DST\"]\n impl<T: PartialEq, V: AsSlice<T>> Equiv<V> for [T] {\n     #[inline]\n     fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n }\n \n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n #[unstable = \"waiting for DST\"]\n impl<'a,T:PartialEq> PartialEq for &'a mut [T] {\n     fn eq(&self, other: & &'a mut [T]) -> bool {\n@@ -1588,6 +1611,8 @@ impl<'a,T:PartialEq> PartialEq for &'a mut [T] {\n     }\n }\n \n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n #[unstable = \"waiting for DST\"]\n impl<'a,T:Eq> Eq for &'a mut [T] {}\n \n@@ -1597,13 +1622,25 @@ impl<'a,T:PartialEq, V: AsSlice<T>> Equiv<V> for &'a mut [T] {\n     fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n }\n \n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n #[unstable = \"waiting for DST\"]\n impl<'a,T:Ord> Ord for &'a [T] {\n     fn cmp(&self, other: & &'a [T]) -> Ordering {\n         order::cmp(self.iter(), other.iter())\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[unstable = \"waiting for DST\"]\n+impl<T: Ord> Ord for [T] {\n+    fn cmp(&self, other: &[T]) -> Ordering {\n+        order::cmp(self.iter(), other.iter())\n+    }\n+}\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n #[unstable = \"waiting for DST\"]\n impl<'a, T: PartialOrd> PartialOrd for &'a [T] {\n     #[inline]\n@@ -1628,6 +1665,31 @@ impl<'a, T: PartialOrd> PartialOrd for &'a [T] {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[unstable = \"waiting for DST\"]\n+impl<T: PartialOrd> PartialOrd for [T] {\n+    #[inline]\n+    fn partial_cmp(&self, other: &[T]) -> Option<Ordering> {\n+        order::partial_cmp(self.iter(), other.iter())\n+    }\n+    #[inline]\n+    fn lt(&self, other: &[T]) -> bool {\n+        order::lt(self.iter(), other.iter())\n+    }\n+    #[inline]\n+    fn le(&self, other: &[T]) -> bool {\n+        order::le(self.iter(), other.iter())\n+    }\n+    #[inline]\n+    fn ge(&self, other: &[T]) -> bool {\n+        order::ge(self.iter(), other.iter())\n+    }\n+    #[inline]\n+    fn gt(&self, other: &[T]) -> bool {\n+        order::gt(self.iter(), other.iter())\n+    }\n+}\n+\n /// Extension methods for immutable slices containing integers.\n #[experimental]\n pub trait ImmutableIntSlice<U, S> for Sized? {"}, {"sha": "175f9f3f5771c44ecfff763331245978a014357f", "filename": "src/libcore/str.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/2896278313ede1b24b47c88bafe684adabbc92d4/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2896278313ede1b24b47c88bafe684adabbc92d4/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=2896278313ede1b24b47c88bafe684adabbc92d4", "patch": "@@ -1122,6 +1122,8 @@ pub mod traits {\n     use ops;\n     use str::{Str, StrSlice, eq_slice};\n \n+    // NOTE(stage0): remove impl after a snapshot\n+    #[cfg(stage0)]\n     impl<'a> Ord for &'a str {\n         #[inline]\n         fn cmp(&self, other: & &'a str) -> Ordering {\n@@ -1137,6 +1139,24 @@ pub mod traits {\n         }\n     }\n \n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    impl Ord for str {\n+        #[inline]\n+        fn cmp(&self, other: &str) -> Ordering {\n+            for (s_b, o_b) in self.bytes().zip(other.bytes()) {\n+                match s_b.cmp(&o_b) {\n+                    Greater => return Greater,\n+                    Less => return Less,\n+                    Equal => ()\n+                }\n+            }\n+\n+            self.len().cmp(&other.len())\n+        }\n+    }\n+\n+    // NOTE(stage0): remove impl after a snapshot\n+    #[cfg(stage0)]\n     impl<'a> PartialEq for &'a str {\n         #[inline]\n         fn eq(&self, other: & &'a str) -> bool {\n@@ -1146,15 +1166,40 @@ pub mod traits {\n         fn ne(&self, other: & &'a str) -> bool { !(*self).eq(other) }\n     }\n \n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    impl PartialEq for str {\n+        #[inline]\n+        fn eq(&self, other: &str) -> bool {\n+            eq_slice(self, other)\n+        }\n+        #[inline]\n+        fn ne(&self, other: &str) -> bool { !(*self).eq(other) }\n+    }\n+\n+    // NOTE(stage0): remove impl after a snapshot\n+    #[cfg(stage0)]\n     impl<'a> Eq for &'a str {}\n \n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    impl Eq for str {}\n+\n+    // NOTE(stage0): remove impl after a snapshot\n+    #[cfg(stage0)]\n     impl<'a> PartialOrd for &'a str {\n         #[inline]\n         fn partial_cmp(&self, other: &&'a str) -> Option<Ordering> {\n             Some(self.cmp(other))\n         }\n     }\n \n+    #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+    impl PartialOrd for str {\n+        #[inline]\n+        fn partial_cmp(&self, other: &str) -> Option<Ordering> {\n+            Some(self.cmp(other))\n+        }\n+    }\n+\n     impl<S: Str> Equiv<S> for str {\n         #[inline]\n         fn equiv(&self, other: &S) -> bool { eq_slice(self, other.as_slice()) }"}]}