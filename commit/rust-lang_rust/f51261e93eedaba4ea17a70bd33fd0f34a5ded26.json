{"sha": "f51261e93eedaba4ea17a70bd33fd0f34a5ded26", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1MTI2MWU5M2VlZGFiYTRlYTE3YTcwYmQzM2ZkMGYzNGE1ZGVkMjY=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-09-15T03:10:58Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-09-15T03:10:58Z"}, "message": "Cargo fmt", "tree": {"sha": "4a3270de7222fa894e416630c05270811bbc8ac6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a3270de7222fa894e416630c05270811bbc8ac6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f51261e93eedaba4ea17a70bd33fd0f34a5ded26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f51261e93eedaba4ea17a70bd33fd0f34a5ded26", "html_url": "https://github.com/rust-lang/rust/commit/f51261e93eedaba4ea17a70bd33fd0f34a5ded26", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f51261e93eedaba4ea17a70bd33fd0f34a5ded26/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45e48ec424b2e1db489db860581aaf7e684fbae0", "url": "https://api.github.com/repos/rust-lang/rust/commits/45e48ec424b2e1db489db860581aaf7e684fbae0", "html_url": "https://github.com/rust-lang/rust/commit/45e48ec424b2e1db489db860581aaf7e684fbae0"}], "stats": {"total": 381, "additions": 192, "deletions": 189}, "files": [{"sha": "f6055927f863c3facf3102eeaff69e2827694764", "filename": "src/chains.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f51261e93eedaba4ea17a70bd33fd0f34a5ded26/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f51261e93eedaba4ea17a70bd33fd0f34a5ded26/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=f51261e93eedaba4ea17a70bd33fd0f34a5ded26", "patch": "@@ -183,9 +183,9 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n     } else {\n         min(shape.width, context.config.chain_one_line_max())\n     };\n-    let all_in_one_line = !parent_rewrite_contains_newline &&\n-        rewrites.iter().all(|s| !s.contains('\\n')) &&\n-        almost_total < one_line_budget;\n+    let all_in_one_line = !parent_rewrite_contains_newline\n+        && rewrites.iter().all(|s| !s.contains('\\n'))\n+        && almost_total < one_line_budget;\n     let rewrite_last = || rewrite_chain_subexpr(last_subexpr, total_span, context, nested_shape);\n     let (last_subexpr_str, fits_single_line) = try_opt!(if all_in_one_line || extend_last_subexr {\n         parent_shape.offset_left(almost_total).map(|shape| {\n@@ -224,9 +224,9 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n         format!(\"\\n{}\", nested_shape.indent.to_string(context.config))\n     };\n \n-    let first_connector = if is_small_parent || fits_single_line ||\n-        last_line_extendable(&parent_rewrite) ||\n-        context.config.chain_indent() == IndentStyle::Visual\n+    let first_connector = if is_small_parent || fits_single_line\n+        || last_line_extendable(&parent_rewrite)\n+        || context.config.chain_indent() == IndentStyle::Visual\n     {\n         \"\"\n     } else {\n@@ -445,12 +445,12 @@ fn choose_first_connector<'a>(\n ) -> &'a str {\n     if subexpr_list.is_empty() {\n         \"\"\n-    } else if extend || subexpr_list.last().map_or(false, is_try) ||\n-        is_extendable_parent(context, parent_str)\n+    } else if extend || subexpr_list.last().map_or(false, is_try)\n+        || is_extendable_parent(context, parent_str)\n     {\n         // 1 = \";\", being conservative here.\n-        if last_line_width(parent_str) + first_line_width(first_child_str) + 1 <=\n-            context.config.max_width()\n+        if last_line_width(parent_str) + first_line_width(first_child_str) + 1\n+            <= context.config.max_width()\n         {\n             \"\"\n         } else {"}, {"sha": "32f46e195c13bc7dcc38ccc4604887414dc2a471", "filename": "src/comment.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f51261e93eedaba4ea17a70bd33fd0f34a5ded26/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f51261e93eedaba4ea17a70bd33fd0f34a5ded26/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=f51261e93eedaba4ea17a70bd33fd0f34a5ded26", "patch": "@@ -91,13 +91,13 @@ impl<'a> CommentStyle<'a> {\n     pub fn line_with_same_comment_style(&self, line: &str, normalize_comments: bool) -> bool {\n         match *self {\n             CommentStyle::DoubleSlash | CommentStyle::TripleSlash | CommentStyle::Doc => {\n-                line.trim_left().starts_with(self.line_start().trim_left()) ||\n-                    comment_style(line, normalize_comments) == *self\n+                line.trim_left().starts_with(self.line_start().trim_left())\n+                    || comment_style(line, normalize_comments) == *self\n             }\n             CommentStyle::DoubleBullet | CommentStyle::SingleBullet | CommentStyle::Exclamation => {\n-                line.trim_left().starts_with(self.closer().trim_left()) ||\n-                    line.trim_left().starts_with(self.line_start().trim_left()) ||\n-                    comment_style(line, normalize_comments) == *self\n+                line.trim_left().starts_with(self.closer().trim_left())\n+                    || line.trim_left().starts_with(self.line_start().trim_left())\n+                    || comment_style(line, normalize_comments) == *self\n             }\n             CommentStyle::Custom(opener) => line.trim_left().starts_with(opener.trim_right()),\n         }\n@@ -121,8 +121,8 @@ fn comment_style(orig: &str, normalize_comments: bool) -> CommentStyle {\n         } else {\n             CommentStyle::DoubleSlash\n         }\n-    } else if (orig.starts_with(\"///\") && orig.chars().nth(3).map_or(true, |c| c != '/')) ||\n-        (orig.starts_with(\"/**\") && !orig.starts_with(\"/**/\"))\n+    } else if (orig.starts_with(\"///\") && orig.chars().nth(3).map_or(true, |c| c != '/'))\n+        || (orig.starts_with(\"/**\") && !orig.starts_with(\"/**/\"))\n     {\n         CommentStyle::TripleSlash\n     } else if orig.starts_with(\"//!\") || orig.starts_with(\"/*!\") {\n@@ -424,8 +424,8 @@ fn light_rewrite_comment(orig: &str, offset: Indent, config: &Config) -> Option<\n /// Trims comment characters and possibly a single space from the left of a string.\n /// Does not trim all whitespace.\n fn left_trim_comment_line<'a>(line: &'a str, style: &CommentStyle) -> &'a str {\n-    if line.starts_with(\"//! \") || line.starts_with(\"/// \") || line.starts_with(\"/*! \") ||\n-        line.starts_with(\"/** \")\n+    if line.starts_with(\"//! \") || line.starts_with(\"/// \") || line.starts_with(\"/*! \")\n+        || line.starts_with(\"/** \")\n     {\n         &line[4..]\n     } else if let CommentStyle::Custom(opener) = *style {\n@@ -434,14 +434,14 @@ fn left_trim_comment_line<'a>(line: &'a str, style: &CommentStyle) -> &'a str {\n         } else {\n             &line[opener.trim_right().len()..]\n         }\n-    } else if line.starts_with(\"/* \") || line.starts_with(\"// \") || line.starts_with(\"//!\") ||\n-        line.starts_with(\"///\") || line.starts_with(\"** \") ||\n-        line.starts_with(\"/*!\") ||\n-        (line.starts_with(\"/**\") && !line.starts_with(\"/**/\"))\n+    } else if line.starts_with(\"/* \") || line.starts_with(\"// \") || line.starts_with(\"//!\")\n+        || line.starts_with(\"///\") || line.starts_with(\"** \")\n+        || line.starts_with(\"/*!\")\n+        || (line.starts_with(\"/**\") && !line.starts_with(\"/**/\"))\n     {\n         &line[3..]\n-    } else if line.starts_with(\"/*\") || line.starts_with(\"* \") || line.starts_with(\"//\") ||\n-        line.starts_with(\"**\")\n+    } else if line.starts_with(\"/*\") || line.starts_with(\"* \") || line.starts_with(\"//\")\n+        || line.starts_with(\"**\")\n     {\n         &line[2..]\n     } else if line.starts_with('*') {\n@@ -771,9 +771,9 @@ impl<'a> Iterator for CommentCodeSlices<'a> {\n         let mut iter = CharClasses::new(subslice.char_indices());\n \n         for (kind, (i, c)) in &mut iter {\n-            let is_comment_connector = self.last_slice_kind == CodeCharKind::Normal &&\n-                &subslice[..2] == \"//\" &&\n-                [' ', '\\t'].contains(&c);\n+            let is_comment_connector = self.last_slice_kind == CodeCharKind::Normal\n+                && &subslice[..2] == \"//\"\n+                && [' ', '\\t'].contains(&c);\n \n             if is_comment_connector && first_whitespace.is_none() {\n                 first_whitespace = Some(i);\n@@ -913,8 +913,8 @@ fn remove_comment_header(comment: &str) -> &str {\n         &comment[3..]\n     } else if comment.starts_with(\"//\") {\n         &comment[2..]\n-    } else if (comment.starts_with(\"/**\") && !comment.starts_with(\"/**/\")) ||\n-        comment.starts_with(\"/*!\")\n+    } else if (comment.starts_with(\"/**\") && !comment.starts_with(\"/**/\"))\n+        || comment.starts_with(\"/*!\")\n     {\n         &comment[3..comment.len() - 2]\n     } else {"}, {"sha": "0d422ce7387ea46658e8769c6382837675c9c6c1", "filename": "src/expr.rs", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/f51261e93eedaba4ea17a70bd33fd0f34a5ded26/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f51261e93eedaba4ea17a70bd33fd0f34a5ded26/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=f51261e93eedaba4ea17a70bd33fd0f34a5ded26", "patch": "@@ -513,8 +513,8 @@ where\n         },\n     };\n     let ends_with_newline = tactic.ends_with_newline(context.config.array_layout());\n-    if context.config.array_horizontal_layout_threshold() > 0 &&\n-        items.len() > context.config.array_horizontal_layout_threshold()\n+    if context.config.array_horizontal_layout_threshold() > 0\n+        && items.len() > context.config.array_horizontal_layout_threshold()\n     {\n         tactic = DefinitiveListTactic::Mixed;\n     }\n@@ -537,8 +537,8 @@ where\n     };\n     let list_str = try_opt!(write_list(&items, &fmt));\n \n-    let result = if context.config.array_layout() == IndentStyle::Visual ||\n-        tactic == DefinitiveListTactic::Horizontal\n+    let result = if context.config.array_layout() == IndentStyle::Visual\n+        || tactic == DefinitiveListTactic::Horizontal\n     {\n         if context.config.spaces_within_square_brackets() && !list_str.is_empty() {\n             format!(\"[ {} ]\", list_str)\n@@ -671,10 +671,10 @@ fn rewrite_closure(\n         }\n \n         // Figure out if the block is necessary.\n-        let needs_block = block.rules != ast::BlockCheckMode::Default || block.stmts.len() > 1 ||\n-            context.inside_macro ||\n-            block_contains_comment(block, context.codemap) ||\n-            prefix.contains('\\n');\n+        let needs_block = block.rules != ast::BlockCheckMode::Default || block.stmts.len() > 1\n+            || context.inside_macro\n+            || block_contains_comment(block, context.codemap)\n+            || prefix.contains('\\n');\n \n         let no_return_type = if let ast::FunctionRetTy::Default(_) = fn_decl.output {\n             true\n@@ -756,8 +756,8 @@ fn rewrite_closure_block(\n     let block_threshold = context.config.closure_block_indent_threshold();\n     if block_threshold >= 0 {\n         if let Some(block_str) = block.rewrite(context, shape) {\n-            if block_str.matches('\\n').count() <= block_threshold as usize &&\n-                !need_block_indent(&block_str, shape)\n+            if block_str.matches('\\n').count() <= block_threshold as usize\n+                && !need_block_indent(&block_str, shape)\n             {\n                 if let Some(block_str) = block_str.rewrite(context, shape) {\n                     return Some(format!(\"{} {}\", prefix, block_str));\n@@ -780,8 +780,8 @@ fn and_one_line(x: Option<String>) -> Option<String> {\n fn nop_block_collapse(block_str: Option<String>, budget: usize) -> Option<String> {\n     debug!(\"nop_block_collapse {:?} {}\", block_str, budget);\n     block_str.map(|block_str| {\n-        if block_str.starts_with('{') && budget >= 2 &&\n-            (block_str[1..].find(|c: char| !c.is_whitespace()).unwrap() == block_str.len() - 2)\n+        if block_str.starts_with('{') && budget >= 2\n+            && (block_str[1..].find(|c: char| !c.is_whitespace()).unwrap() == block_str.len() - 2)\n         {\n             \"{}\".to_owned()\n         } else {\n@@ -805,8 +805,8 @@ fn rewrite_empty_block(\n     let user_str = user_str.trim();\n     if user_str.starts_with('{') && user_str.ends_with('}') {\n         let comment_str = user_str[1..user_str.len() - 1].trim();\n-        if block.stmts.is_empty() && !comment_str.contains('\\n') &&\n-            !comment_str.starts_with(\"//\") && comment_str.len() + 4 <= shape.width\n+        if block.stmts.is_empty() && !comment_str.contains('\\n') && !comment_str.starts_with(\"//\")\n+            && comment_str.len() + 4 <= shape.width\n         {\n             return Some(format!(\"{{ {} }}\", comment_str));\n         }\n@@ -1118,9 +1118,9 @@ impl<'a> ControlFlow<'a> {\n         let fixed_cost = self.keyword.len() + \"  {  } else {  }\".len();\n \n         if let ast::ExprKind::Block(ref else_node) = else_block.node {\n-            if !is_simple_block(self.block, context.codemap) ||\n-                !is_simple_block(else_node, context.codemap) ||\n-                pat_expr_str.contains('\\n')\n+            if !is_simple_block(self.block, context.codemap)\n+                || !is_simple_block(else_node, context.codemap)\n+                || pat_expr_str.contains('\\n')\n             {\n                 return None;\n             }\n@@ -1216,9 +1216,9 @@ impl<'a> ControlFlow<'a> {\n             .max_width()\n             .checked_sub(constr_shape.used_width() + offset + brace_overhead)\n             .unwrap_or(0);\n-        let force_newline_brace = context.config.control_style() == Style::Rfc &&\n-            (pat_expr_string.contains('\\n') || pat_expr_string.len() > one_line_budget) &&\n-            !last_line_extendable(&pat_expr_string);\n+        let force_newline_brace = context.config.control_style() == Style::Rfc\n+            && (pat_expr_string.contains('\\n') || pat_expr_string.len() > one_line_budget)\n+            && !last_line_extendable(&pat_expr_string);\n \n         // Try to format if-else on single line.\n         if self.allow_single_line && context.config.single_line_if_else_max_width() > 0 {\n@@ -1259,8 +1259,8 @@ impl<'a> ControlFlow<'a> {\n \n         let block_sep = if self.cond.is_none() && between_kwd_cond_comment.is_some() {\n             \"\"\n-        } else if context.config.control_brace_style() == ControlBraceStyle::AlwaysNextLine ||\n-            force_newline_brace\n+        } else if context.config.control_brace_style() == ControlBraceStyle::AlwaysNextLine\n+            || force_newline_brace\n         {\n             alt_block_sep\n         } else {\n@@ -1443,8 +1443,8 @@ fn block_contains_comment(block: &ast::Block, codemap: &CodeMap) -> bool {\n // FIXME: incorrectly returns false when comment is contained completely within\n // the expression.\n pub fn is_simple_block(block: &ast::Block, codemap: &CodeMap) -> bool {\n-    (block.stmts.len() == 1 && stmt_is_expr(&block.stmts[0]) &&\n-        !block_contains_comment(block, codemap))\n+    (block.stmts.len() == 1 && stmt_is_expr(&block.stmts[0])\n+        && !block_contains_comment(block, codemap))\n }\n \n /// Checks whether a block contains at most one statement or expression, and no comments.\n@@ -1739,17 +1739,17 @@ fn flatten_arm_body<'a>(context: &'a RewriteContext, body: &'a ast::Expr) -> (bo\n         {\n             if let ast::StmtKind::Expr(ref expr) = block.stmts[0].node {\n                 (\n-                    !context.config.multiline_match_arm_forces_block() &&\n-                        expr.can_be_overflowed(context, 1),\n+                    !context.config.multiline_match_arm_forces_block()\n+                        && expr.can_be_overflowed(context, 1),\n                     &**expr,\n                 )\n             } else {\n                 (false, &*body)\n             }\n         }\n         _ => (\n-            !context.config.multiline_match_arm_forces_block() &&\n-                body.can_be_overflowed(context, 1),\n+            !context.config.multiline_match_arm_forces_block()\n+                && body.can_be_overflowed(context, 1),\n             &*body,\n         ),\n     }\n@@ -1841,9 +1841,9 @@ fn rewrite_match_body(\n \n         match rewrite {\n             Some(ref body_str)\n-                if !forbid_same_line &&\n-                    (is_block ||\n-                        (!body_str.contains('\\n') && body_str.len() <= body_shape.width)) =>\n+                if !forbid_same_line\n+                    && (is_block\n+                        || (!body_str.contains('\\n') && body_str.len() <= body_shape.width)) =>\n             {\n                 return combine_orig_body(body_str);\n             }\n@@ -1989,8 +1989,8 @@ fn rewrite_string_lit(context: &RewriteContext, span: Span, shape: Shape) -> Opt\n         }\n     }\n \n-    if !context.config.force_format_strings() &&\n-        !string_requires_rewrite(context, span, &string_lit, shape)\n+    if !context.config.force_format_strings()\n+        && !string_requires_rewrite(context, span, &string_lit, shape)\n     {\n         return Some(string_lit);\n     }\n@@ -2370,8 +2370,8 @@ where\n             ast::ExprKind::Closure(..) => {\n                 // If the argument consists of multiple closures, we do not overflow\n                 // the last closure.\n-                if args.len() > 1 &&\n-                    args.iter()\n+                if args.len() > 1\n+                    && args.iter()\n                         .rev()\n                         .skip(1)\n                         .filter_map(|arg| arg.to_expr())\n@@ -2410,8 +2410,8 @@ where\n pub fn can_be_overflowed_expr(context: &RewriteContext, expr: &ast::Expr, args_len: usize) -> bool {\n     match expr.node {\n         ast::ExprKind::Match(..) => {\n-            (context.use_block_indent() && args_len == 1) ||\n-                (context.config.fn_call_style() == IndentStyle::Visual && args_len > 1)\n+            (context.use_block_indent() && args_len == 1)\n+                || (context.config.fn_call_style() == IndentStyle::Visual && args_len > 1)\n         }\n         ast::ExprKind::If(..) |\n         ast::ExprKind::IfLet(..) |\n@@ -2422,8 +2422,8 @@ pub fn can_be_overflowed_expr(context: &RewriteContext, expr: &ast::Expr, args_l\n             context.config.combine_control_expr() && context.use_block_indent() && args_len == 1\n         }\n         ast::ExprKind::Block(..) | ast::ExprKind::Closure(..) => {\n-            context.use_block_indent() ||\n-                context.config.fn_call_style() == IndentStyle::Visual && args_len > 1\n+            context.use_block_indent()\n+                || context.config.fn_call_style() == IndentStyle::Visual && args_len > 1\n         }\n         ast::ExprKind::Array(..) |\n         ast::ExprKind::Call(..) |\n@@ -2447,9 +2447,9 @@ pub fn wrap_args_with_parens(\n     shape: Shape,\n     nested_shape: Shape,\n ) -> String {\n-    if !context.use_block_indent() ||\n-        (context.inside_macro && !args_str.contains('\\n') &&\n-            args_str.len() + paren_overhead(context) <= shape.width) || is_extendable\n+    if !context.use_block_indent()\n+        || (context.inside_macro && !args_str.contains('\\n')\n+            && args_str.len() + paren_overhead(context) <= shape.width) || is_extendable\n     {\n         if context.config.spaces_within_parens() && !args_str.is_empty() {\n             format!(\"( {} )\", args_str)\n@@ -2492,8 +2492,8 @@ fn rewrite_paren(context: &RewriteContext, subexpr: &ast::Expr, shape: Shape) ->\n     let subexpr_str = try_opt!(subexpr.rewrite(context, sub_shape));\n     debug!(\"rewrite_paren, subexpr_str: `{:?}`\", subexpr_str);\n \n-    if subexpr_str.contains('\\n') ||\n-        first_line_width(&subexpr_str) + total_paren_overhead <= shape.width\n+    if subexpr_str.contains('\\n')\n+        || first_line_width(&subexpr_str) + total_paren_overhead <= shape.width\n     {\n         Some(paren_wrapper(&subexpr_str))\n     } else {\n@@ -2603,8 +2603,8 @@ fn rewrite_struct_lit<'a>(\n \n     let one_line_width = h_shape.map_or(0, |shape| shape.width);\n     let body_lo = context.codemap.span_after(span, \"{\");\n-    let fields_str = if struct_lit_can_be_aligned(fields, &base) &&\n-        context.config.struct_field_align_threshold() > 0\n+    let fields_str = if struct_lit_can_be_aligned(fields, &base)\n+        && context.config.struct_field_align_threshold() > 0\n     {\n         try_opt!(rewrite_with_alignment(\n             fields,\n@@ -2678,10 +2678,10 @@ pub fn wrap_struct_field(\n     nested_shape: Shape,\n     one_line_width: usize,\n ) -> String {\n-    if context.config.struct_lit_style() == IndentStyle::Block &&\n-        (fields_str.contains('\\n') ||\n-            context.config.struct_lit_multiline_style() == MultilineStyle::ForceMulti ||\n-            fields_str.len() > one_line_width)\n+    if context.config.struct_lit_style() == IndentStyle::Block\n+        && (fields_str.contains('\\n')\n+            || context.config.struct_lit_multiline_style() == MultilineStyle::ForceMulti\n+            || fields_str.len() > one_line_width)\n     {\n         format!(\n             \"\\n{}{}\\n{}\",\n@@ -2992,8 +2992,8 @@ fn prefer_next_line(orig_rhs: &str, next_line_rhs: &str) -> bool {\n         src.chars().filter(|&x| x == '\\n').count()\n     }\n \n-    !next_line_rhs.contains('\\n') ||\n-        count_line_breaks(orig_rhs) > count_line_breaks(next_line_rhs) + 1\n+    !next_line_rhs.contains('\\n')\n+        || count_line_breaks(orig_rhs) > count_line_breaks(next_line_rhs) + 1\n }\n \n fn rewrite_expr_addrof("}, {"sha": "948ffac073157cac8bbce8bcf4b4e5cd0d8cb422", "filename": "src/file_lines.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f51261e93eedaba4ea17a70bd33fd0f34a5ded26/src%2Ffile_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f51261e93eedaba4ea17a70bd33fd0f34a5ded26/src%2Ffile_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffile_lines.rs?ref=f51261e93eedaba4ea17a70bd33fd0f34a5ded26", "patch": "@@ -51,8 +51,8 @@ impl Range {\n         if self.is_empty() || other.is_empty() {\n             false\n         } else {\n-            (self.lo <= other.hi && other.hi <= self.hi) ||\n-                (other.lo <= self.hi && self.hi <= other.hi)\n+            (self.lo <= other.hi && other.hi <= self.hi)\n+                || (other.lo <= self.hi && self.hi <= other.hi)\n         }\n     }\n "}, {"sha": "39446d1a97b9709370a7b5fa1b1d9471215c8001", "filename": "src/imports.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f51261e93eedaba4ea17a70bd33fd0f34a5ded26/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f51261e93eedaba4ea17a70bd33fd0f34a5ded26/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=f51261e93eedaba4ea17a70bd33fd0f34a5ded26", "patch": "@@ -132,8 +132,8 @@ fn rewrite_view_path_prefix(\n     context: &RewriteContext,\n     shape: Shape,\n ) -> Option<String> {\n-    let path_str = if path.segments.last().unwrap().identifier.to_string() == \"self\" &&\n-        path.segments.len() > 1\n+    let path_str = if path.segments.last().unwrap().identifier.to_string() == \"self\"\n+        && path.segments.len() > 1\n     {\n         let path = &ast::Path {\n             span: path.span,\n@@ -503,8 +503,8 @@ fn rewrite_use_list(\n         IndentStyle::Visual => Shape::legacy(remaining_width, nested_indent),\n     };\n \n-    let ends_with_newline = context.config.imports_indent() == IndentStyle::Block &&\n-        tactic != DefinitiveListTactic::Horizontal;\n+    let ends_with_newline = context.config.imports_indent() == IndentStyle::Block\n+        && tactic != DefinitiveListTactic::Horizontal;\n \n     let fmt = ListFormatting {\n         tactic: tactic,"}, {"sha": "21ff353ff413c530597e5f97c6b8ad7e51647bb4", "filename": "src/items.rs", "status": "modified", "additions": 51, "deletions": 48, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/f51261e93eedaba4ea17a70bd33fd0f34a5ded26/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f51261e93eedaba4ea17a70bd33fd0f34a5ded26/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=f51261e93eedaba4ea17a70bd33fd0f34a5ded26", "patch": "@@ -228,8 +228,8 @@ impl<'a> FmtVisitor<'a> {\n         let context = self.get_context();\n \n         let block_snippet = self.snippet(mk_sp(block.span.lo(), block.span.hi()));\n-        let has_body = !block_snippet[1..block_snippet.len() - 1].trim().is_empty() ||\n-            !context.config.fn_empty_single_line();\n+        let has_body = !block_snippet[1..block_snippet.len() - 1].trim().is_empty()\n+            || !context.config.fn_empty_single_line();\n         let mut newline_brace = newline_for_brace(self.config, &generics.where_clause, has_body);\n \n         let (mut result, force_newline_brace) = try_opt!(rewrite_fn_base(\n@@ -251,8 +251,8 @@ impl<'a> FmtVisitor<'a> {\n \n         if force_newline_brace {\n             newline_brace = true;\n-        } else if self.config.fn_brace_style() != BraceStyle::AlwaysNextLine &&\n-            !result.contains('\\n')\n+        } else if self.config.fn_brace_style() != BraceStyle::AlwaysNextLine\n+            && !result.contains('\\n')\n         {\n             newline_brace = false;\n         }\n@@ -313,8 +313,8 @@ impl<'a> FmtVisitor<'a> {\n \n         let codemap = self.get_context().codemap;\n \n-        if self.config.fn_empty_single_line() && is_empty_block(block, codemap) &&\n-            self.block_indent.width() + fn_str.len() + 2 <= self.config.max_width()\n+        if self.config.fn_empty_single_line() && is_empty_block(block, codemap)\n+            && self.block_indent.width() + fn_str.len() + 2 <= self.config.max_width()\n         {\n             return Some(format!(\"{}{{}}\", fn_str));\n         }\n@@ -503,9 +503,9 @@ impl<'a> FmtVisitor<'a> {\n             },\n         };\n \n-        let attrs_extendable = attrs_str.is_empty() ||\n-            (context.config.attributes_on_same_line_as_variant() &&\n-                is_attributes_extendable(&attrs_str));\n+        let attrs_extendable = attrs_str.is_empty()\n+            || (context.config.attributes_on_same_line_as_variant()\n+                && is_attributes_extendable(&attrs_str));\n         combine_strs_with_missing_comments(\n             &context,\n             &attrs_str,\n@@ -650,9 +650,9 @@ fn is_impl_single_line(\n     let open_pos = try_opt!(snippet.find_uncommented(\"{\")) + 1;\n \n     Some(\n-        context.config.impl_empty_single_line() && items.is_empty() && !result.contains('\\n') &&\n-            result.len() + where_clause_str.len() <= context.config.max_width() &&\n-            !contains_comment(&snippet[open_pos..]),\n+        context.config.impl_empty_single_line() && items.is_empty() && !result.contains('\\n')\n+            && result.len() + where_clause_str.len() <= context.config.max_width()\n+            && !contains_comment(&snippet[open_pos..]),\n     )\n }\n \n@@ -895,8 +895,8 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n         ));\n         // If the trait, generics, and trait bound cannot fit on the same line,\n         // put the trait bounds on an indented new line\n-        if offset.width() + last_line_width(&result) + trait_bound_str.len() >\n-            context.config.comment_width()\n+        if offset.width() + last_line_width(&result) + trait_bound_str.len()\n+            > context.config.comment_width()\n         {\n             result.push('\\n');\n             let trait_indent = offset.block_only().block_indent(context.config);\n@@ -906,11 +906,11 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n \n         let has_body = !trait_items.is_empty();\n \n-        let where_density = if (context.config.where_density() == Density::Compressed &&\n-            (!result.contains('\\n') || context.config.fn_args_layout() == IndentStyle::Block)) ||\n-            (context.config.fn_args_layout() == IndentStyle::Block && result.is_empty()) ||\n-            (context.config.where_density() == Density::CompressedIfEmpty && !has_body &&\n-                !result.contains('\\n'))\n+        let where_density = if (context.config.where_density() == Density::Compressed\n+            && (!result.contains('\\n') || context.config.fn_args_layout() == IndentStyle::Block))\n+            || (context.config.fn_args_layout() == IndentStyle::Block && result.is_empty())\n+            || (context.config.where_density() == Density::CompressedIfEmpty && !has_body\n+                && !result.contains('\\n'))\n         {\n             Density::Compressed\n         } else {\n@@ -937,9 +937,9 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n         ));\n         // If the where clause cannot fit on the same line,\n         // put the where clause on a new line\n-        if !where_clause_str.contains('\\n') &&\n-            last_line_width(&result) + where_clause_str.len() + offset.width() >\n-                context.config.comment_width()\n+        if !where_clause_str.contains('\\n')\n+            && last_line_width(&result) + where_clause_str.len() + offset.width()\n+                > context.config.comment_width()\n         {\n             result.push('\\n');\n             let width = offset.block_indent + context.config.tab_spaces() - 1;\n@@ -980,8 +980,8 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n                 result.push_str(&offset.to_string(context.config));\n             }\n             BraceStyle::PreferSameLine => result.push(' '),\n-            BraceStyle::SameLineWhere => if !where_clause_str.is_empty() &&\n-                (!trait_items.is_empty() || result.contains('\\n'))\n+            BraceStyle::SameLineWhere => if !where_clause_str.is_empty()\n+                && (!trait_items.is_empty() || result.contains('\\n'))\n             {\n                 result.push('\\n');\n                 result.push_str(&offset.to_string(context.config));\n@@ -1061,9 +1061,9 @@ pub fn format_struct_struct(\n         None => {\n             // 3 = ` {}`, 2 = ` {`.\n             let overhead = if fields.is_empty() { 3 } else { 2 };\n-            if (context.config.item_brace_style() == BraceStyle::AlwaysNextLine &&\n-                !fields.is_empty()) ||\n-                context.config.max_width() < overhead + result.len()\n+            if (context.config.item_brace_style() == BraceStyle::AlwaysNextLine\n+                && !fields.is_empty())\n+                || context.config.max_width() < overhead + result.len()\n             {\n                 format!(\"\\n{}{{\", offset.block_only().to_string(context.config))\n             } else {\n@@ -1074,8 +1074,8 @@ pub fn format_struct_struct(\n     // 1 = `}`\n     let overhead = if fields.is_empty() { 1 } else { 0 };\n     let total_width = result.len() + generics_str.len() + overhead;\n-    if !generics_str.is_empty() && !generics_str.contains('\\n') &&\n-        total_width > context.config.max_width()\n+    if !generics_str.is_empty() && !generics_str.contains('\\n')\n+        && total_width > context.config.max_width()\n     {\n         result.push('\\n');\n         result.push_str(&offset.to_string(context.config));\n@@ -1224,10 +1224,10 @@ fn format_tuple_struct(\n         result.push_str(&body);\n     }\n \n-    if !where_clause_str.is_empty() && !where_clause_str.contains('\\n') &&\n-        (result.contains('\\n') ||\n-            offset.block_indent + result.len() + where_clause_str.len() + 1 >\n-                context.config.max_width())\n+    if !where_clause_str.is_empty() && !where_clause_str.contains('\\n')\n+        && (result.contains('\\n')\n+            || offset.block_indent + result.len() + where_clause_str.len() + 1\n+                > context.config.max_width())\n     {\n         // We need to put the where clause on a new line, but we didn't\n         // know that earlier, so the where clause will not be indented properly.\n@@ -1368,8 +1368,9 @@ pub fn rewrite_struct_field(\n     let prefix = try_opt!(rewrite_struct_field_prefix(context, field));\n \n     let attrs_str = try_opt!(field.attrs.rewrite(context, shape));\n-    let attrs_extendable = attrs_str.is_empty() ||\n-        (context.config.attributes_on_same_line_as_field() && is_attributes_extendable(&attrs_str));\n+    let attrs_extendable = attrs_str.is_empty()\n+        || (context.config.attributes_on_same_line_as_field()\n+            && is_attributes_extendable(&attrs_str));\n     let missing_span = if field.attrs.is_empty() {\n         mk_sp(field.span.lo(), field.span.lo())\n     } else {\n@@ -2154,8 +2155,9 @@ fn rewrite_args(\n         arg_items.extend(more_items);\n     }\n \n-    let fits_in_one_line = !generics_str_contains_newline &&\n-        (arg_items.is_empty() || arg_items.len() == 1 && arg_item_strs[0].len() <= one_line_budget);\n+    let fits_in_one_line = !generics_str_contains_newline\n+        && (arg_items.is_empty()\n+            || arg_items.len() == 1 && arg_item_strs[0].len() <= one_line_budget);\n \n     for (item, arg) in arg_items.iter_mut().zip(arg_item_strs) {\n         item.item = Some(arg);\n@@ -2419,8 +2421,8 @@ pub fn wrap_generics_with_angle_brackets(\n     list_str: &str,\n     list_offset: Indent,\n ) -> String {\n-    if context.config.generics_indent() == IndentStyle::Block &&\n-        (list_str.contains('\\n') || list_str.ends_with(','))\n+    if context.config.generics_indent() == IndentStyle::Block\n+        && (list_str.contains('\\n') || list_str.ends_with(','))\n     {\n         format!(\n             \"<\\n{}{}\\n{}>\",\n@@ -2528,9 +2530,9 @@ fn rewrite_where_clause_rfc_style(\n     let newline_after_where = comment_separator(&comment_after, clause_shape);\n \n     // 6 = `where `\n-    let clause_sep = if where_clause_option.compress_where && comment_before.is_empty() &&\n-        comment_after.is_empty() && !preds_str.contains('\\n') &&\n-        6 + preds_str.len() <= shape.width\n+    let clause_sep = if where_clause_option.compress_where && comment_before.is_empty()\n+        && comment_after.is_empty() && !preds_str.contains('\\n')\n+        && 6 + preds_str.len() <= shape.width\n     {\n         String::from(\" \")\n     } else {\n@@ -2643,8 +2645,8 @@ fn rewrite_where_clause(\n     } else {\n         terminator.len()\n     };\n-    if density == Density::Tall || preds_str.contains('\\n') ||\n-        shape.indent.width() + \" where \".len() + preds_str.len() + end_length > shape.width\n+    if density == Density::Tall || preds_str.contains('\\n')\n+        || shape.indent.width() + \" where \".len() + preds_str.len() + end_length > shape.width\n     {\n         Some(format!(\n             \"\\n{}where {}\",\n@@ -2715,11 +2717,12 @@ fn format_generics(\n             option,\n         ));\n         result.push_str(&where_clause_str);\n-        force_same_line_brace || brace_style == BraceStyle::PreferSameLine ||\n-            (generics.where_clause.predicates.is_empty() && trimmed_last_line_width(&result) == 1)\n+        force_same_line_brace || brace_style == BraceStyle::PreferSameLine\n+            || (generics.where_clause.predicates.is_empty()\n+                && trimmed_last_line_width(&result) == 1)\n     } else {\n-        force_same_line_brace || trimmed_last_line_width(&result) == 1 ||\n-            brace_style != BraceStyle::AlwaysNextLine\n+        force_same_line_brace || trimmed_last_line_width(&result) == 1\n+            || brace_style != BraceStyle::AlwaysNextLine\n     };\n     let total_used_width = last_line_used_width(&result, used_width);\n     let remaining_budget = context.budget(total_used_width);"}, {"sha": "d5ea44393ca221f17a7ad8af10e8d5f8c2d3675c", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f51261e93eedaba4ea17a70bd33fd0f34a5ded26/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f51261e93eedaba4ea17a70bd33fd0f34a5ded26/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=f51261e93eedaba4ea17a70bd33fd0f34a5ded26", "patch": "@@ -786,8 +786,8 @@ fn format_lines(text: &mut StringBuffer, name: &str, config: &Config, report: &m\n                 }\n \n                 // Check for any line width errors we couldn't correct.\n-                let report_error_on_line_overflow = config.error_on_line_overflow() &&\n-                    (config.error_on_line_overflow_comments() || !is_comment);\n+                let report_error_on_line_overflow = config.error_on_line_overflow()\n+                    && (config.error_on_line_overflow_comments() || !is_comment);\n                 if report_error_on_line_overflow && line_len > config.max_width() {\n                     errors.push(FormattingError {\n                         line: cur_line,"}, {"sha": "543e5296432e4fff1fe190a7aee846bc32baed22", "filename": "src/lists.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f51261e93eedaba4ea17a70bd33fd0f34a5ded26/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f51261e93eedaba4ea17a70bd33fd0f34a5ded26/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=f51261e93eedaba4ea17a70bd33fd0f34a5ded26", "patch": "@@ -118,27 +118,27 @@ impl ListItem {\n     }\n \n     pub fn is_different_group(&self) -> bool {\n-        self.inner_as_ref().contains('\\n') || self.pre_comment.is_some() ||\n-            self.post_comment\n+        self.inner_as_ref().contains('\\n') || self.pre_comment.is_some()\n+            || self.post_comment\n                 .as_ref()\n                 .map_or(false, |s| s.contains('\\n'))\n     }\n \n     pub fn is_multiline(&self) -> bool {\n-        self.inner_as_ref().contains('\\n') ||\n-            self.pre_comment\n+        self.inner_as_ref().contains('\\n')\n+            || self.pre_comment\n                 .as_ref()\n-                .map_or(false, |s| s.contains('\\n')) ||\n-            self.post_comment\n+                .map_or(false, |s| s.contains('\\n'))\n+            || self.post_comment\n                 .as_ref()\n                 .map_or(false, |s| s.contains('\\n'))\n     }\n \n     pub fn has_comment(&self) -> bool {\n         self.pre_comment\n             .as_ref()\n-            .map_or(false, |comment| comment.starts_with(\"//\")) ||\n-            self.post_comment\n+            .map_or(false, |comment| comment.starts_with(\"//\"))\n+            || self.post_comment\n                 .as_ref()\n                 .map_or(false, |comment| comment.starts_with(\"//\"))\n     }\n@@ -243,8 +243,8 @@ where\n     let total_sep_len = sep.len() * sep_count.checked_sub(1).unwrap_or(0);\n     let real_total = total_width + total_sep_len;\n \n-    if real_total <= limit && !pre_line_comments &&\n-        !items.into_iter().any(|item| item.as_ref().is_multiline())\n+    if real_total <= limit && !pre_line_comments\n+        && !items.into_iter().any(|item| item.as_ref().is_multiline())\n     {\n         DefinitiveListTactic::Horizontal\n     } else {\n@@ -346,8 +346,8 @@ where\n \n             if tactic == DefinitiveListTactic::Vertical {\n                 // We cannot keep pre-comments on the same line if the comment if normalized.\n-                let keep_comment = if formatting.config.normalize_comments() ||\n-                    item.pre_comment_style == ListItemCommentStyle::DifferentLine\n+                let keep_comment = if formatting.config.normalize_comments()\n+                    || item.pre_comment_style == ListItemCommentStyle::DifferentLine\n                 {\n                     false\n                 } else {\n@@ -416,9 +416,9 @@ where\n                 let comment_shape = Shape::legacy(width, offset);\n \n                 // Use block-style only for the last item or multiline comments.\n-                let block_style = !formatting.ends_with_newline && last ||\n-                    comment.trim().contains('\\n') ||\n-                    comment.trim().len() > width;\n+                let block_style = !formatting.ends_with_newline && last\n+                    || comment.trim().contains('\\n')\n+                    || comment.trim().len() > width;\n \n                 rewrite_comment(comment, block_style, comment_shape, formatting.config)\n             };\n@@ -428,8 +428,8 @@ where\n             if !formatted_comment.starts_with('\\n') {\n                 let mut comment_alignment =\n                     post_comment_alignment(item_max_width, inner_item.len());\n-                if first_line_width(&formatted_comment) + last_line_width(&result) +\n-                    comment_alignment + 1 > formatting.config.max_width()\n+                if first_line_width(&formatted_comment) + last_line_width(&result)\n+                    + comment_alignment + 1 > formatting.config.max_width()\n                 {\n                     item_max_width = None;\n                     formatted_comment = try_opt!(rewrite_post_comment(&mut item_max_width));\n@@ -452,8 +452,8 @@ where\n             item_max_width = None;\n         }\n \n-        if formatting.preserve_newline && !last && tactic == DefinitiveListTactic::Vertical &&\n-            item.new_lines\n+        if formatting.preserve_newline && !last && tactic == DefinitiveListTactic::Vertical\n+            && item.new_lines\n         {\n             item_max_width = None;\n             result.push('\\n');\n@@ -478,9 +478,9 @@ where\n     for item in items.clone().into_iter().skip(i) {\n         let item = item.as_ref();\n         let inner_item_width = item.inner_as_ref().len();\n-        if !first &&\n-            (item.is_different_group() || !item.post_comment.is_some() ||\n-                inner_item_width + overhead > max_budget)\n+        if !first\n+            && (item.is_different_group() || !item.post_comment.is_some()\n+                || inner_item_width + overhead > max_budget)\n         {\n             return max_width;\n         }\n@@ -714,9 +714,9 @@ where\n }\n \n fn total_item_width(item: &ListItem) -> usize {\n-    comment_len(item.pre_comment.as_ref().map(|x| &(*x)[..])) +\n-        comment_len(item.post_comment.as_ref().map(|x| &(*x)[..])) +\n-        item.item.as_ref().map_or(0, |str| str.len())\n+    comment_len(item.pre_comment.as_ref().map(|x| &(*x)[..]))\n+        + comment_len(item.post_comment.as_ref().map(|x| &(*x)[..]))\n+        + item.item.as_ref().map_or(0, |str| str.len())\n }\n \n fn comment_len(comment: Option<&str>) -> usize {\n@@ -800,8 +800,8 @@ pub fn struct_lit_formatting<'a>(\n     context: &'a RewriteContext,\n     force_no_trailing_comma: bool,\n ) -> ListFormatting<'a> {\n-    let ends_with_newline = context.config.struct_lit_style() != IndentStyle::Visual &&\n-        tactic == DefinitiveListTactic::Vertical;\n+    let ends_with_newline = context.config.struct_lit_style() != IndentStyle::Visual\n+        && tactic == DefinitiveListTactic::Vertical;\n     ListFormatting {\n         tactic: tactic,\n         separator: \",\","}, {"sha": "1e1bffaf995dfa6cbddbdf741a593dbaf28da6d7", "filename": "src/macros.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f51261e93eedaba4ea17a70bd33fd0f34a5ded26/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f51261e93eedaba4ea17a70bd33fd0f34a5ded26/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=f51261e93eedaba4ea17a70bd33fd0f34a5ded26", "patch": "@@ -230,8 +230,8 @@ pub fn rewrite_macro(\n                 let nested_shape = mac_shape.block_indent(context.config.tab_spaces());\n                 let lhs = try_opt!(arg_vec[0].rewrite(context, nested_shape));\n                 let rhs = try_opt!(arg_vec[1].rewrite(context, nested_shape));\n-                if !lhs.contains('\\n') && !rhs.contains('\\n') &&\n-                    lhs.len() + rhs.len() + total_overhead <= shape.width\n+                if !lhs.contains('\\n') && !rhs.contains('\\n')\n+                    && lhs.len() + rhs.len() + total_overhead <= shape.width\n                 {\n                     Some(format!(\"{}{}{}; {}{}\", macro_name, lbr, lhs, rhs, rbr))\n                 } else {\n@@ -373,13 +373,13 @@ fn indent_macro_snippet(\n     );\n \n     Some(\n-        String::from(first_line) + \"\\n\" +\n-            &trimmed_lines\n+        String::from(first_line) + \"\\n\"\n+            + &trimmed_lines\n                 .iter()\n                 .map(|&(line, prefix_space_width)| match prefix_space_width {\n                     Some(original_indent_width) => {\n-                        let new_indent_width = indent.width() +\n-                            original_indent_width\n+                        let new_indent_width = indent.width()\n+                            + original_indent_width\n                                 .checked_sub(min_prefix_space_width)\n                                 .unwrap_or(0);\n                         let new_indent = Indent::from_width(context.config, new_indent_width);"}, {"sha": "c6f3e66669a228d21055d485a1bd17eef7e8a58e", "filename": "src/missed_spans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f51261e93eedaba4ea17a70bd33fd0f34a5ded26/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f51261e93eedaba4ea17a70bd33fd0f34a5ded26/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=f51261e93eedaba4ea17a70bd33fd0f34a5ded26", "patch": "@@ -145,8 +145,8 @@ impl<'a> FmtVisitor<'a> {\n \n                 let subslice_num_lines = subslice.chars().filter(|c| *c == '\\n').count();\n \n-                if rewrite_next_comment &&\n-                    !self.config.file_lines().intersects_range(\n+                if rewrite_next_comment\n+                    && !self.config.file_lines().intersects_range(\n                         file_name,\n                         cur_line,\n                         cur_line + subslice_num_lines,"}, {"sha": "84271f20082656cae349905fe4e2f17f8781bdc8", "filename": "src/string.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f51261e93eedaba4ea17a70bd33fd0f34a5ded26/src%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f51261e93eedaba4ea17a70bd33fd0f34a5ded26/src%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstring.rs?ref=f51261e93eedaba4ea17a70bd33fd0f34a5ded26", "patch": "@@ -82,8 +82,8 @@ pub fn rewrite_string<'a>(orig: &str, fmt: &StringFormat<'a>) -> Option<String>\n                     // If we can't break at whitespace or punctuation, grow the string instead.\n                     if cur_end < cur_start + MIN_STRING {\n                         cur_end = cur_start + max_chars;\n-                        while !(punctuation.contains(graphemes[cur_end - 1]) ||\n-                            graphemes[cur_end - 1].trim().is_empty())\n+                        while !(punctuation.contains(graphemes[cur_end - 1])\n+                            || graphemes[cur_end - 1].trim().is_empty())\n                         {\n                             if cur_end >= graphemes.len() {\n                                 let line = &graphemes[cur_start..].join(\"\");"}, {"sha": "cf034e7dff69516538c6d29a384efc7c07638d31", "filename": "src/summary.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f51261e93eedaba4ea17a70bd33fd0f34a5ded26/src%2Fsummary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f51261e93eedaba4ea17a70bd33fd0f34a5ded26/src%2Fsummary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsummary.rs?ref=f51261e93eedaba4ea17a70bd33fd0f34a5ded26", "patch": "@@ -44,8 +44,8 @@ impl Summary {\n     }\n \n     pub fn has_no_errors(&self) -> bool {\n-        !(self.has_operational_errors || self.has_parsing_errors || self.has_formatting_errors ||\n-            self.has_diff)\n+        !(self.has_operational_errors || self.has_parsing_errors || self.has_formatting_errors\n+            || self.has_diff)\n     }\n \n     pub fn add(&mut self, other: Summary) {"}, {"sha": "265ed723355bd0c405ad5e742de406d5ba67abe2", "filename": "src/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f51261e93eedaba4ea17a70bd33fd0f34a5ded26/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f51261e93eedaba4ea17a70bd33fd0f34a5ded26/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=f51261e93eedaba4ea17a70bd33fd0f34a5ded26", "patch": "@@ -208,8 +208,8 @@ fn rewrite_segment(\n     let params = if let Some(ref params) = segment.parameters {\n         match **params {\n             ast::PathParameters::AngleBracketed(ref data)\n-                if !data.lifetimes.is_empty() || !data.types.is_empty() ||\n-                    !data.bindings.is_empty() =>\n+                if !data.lifetimes.is_empty() || !data.types.is_empty()\n+                    || !data.bindings.is_empty() =>\n             {\n                 let param_list = data.lifetimes\n                     .iter()"}, {"sha": "d8c18034830eacaf08822bfc4acfbf62471fb18a", "filename": "src/utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f51261e93eedaba4ea17a70bd33fd0f34a5ded26/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f51261e93eedaba4ea17a70bd33fd0f34a5ded26/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=f51261e93eedaba4ea17a70bd33fd0f34a5ded26", "patch": "@@ -165,8 +165,8 @@ pub fn trimmed_last_line_width(s: &str) -> usize {\n #[inline]\n pub fn last_line_extendable(s: &str) -> bool {\n     s.lines().last().map_or(false, |s| {\n-        s.ends_with(\"\\\"#\") ||\n-            s.trim()\n+        s.ends_with(\"\\\"#\")\n+            || s.trim()\n                 .chars()\n                 .all(|c| c == ')' || c == ']' || c == '}' || c == '?')\n     })"}, {"sha": "a120eb868e5d45fc043ec12a11e2a9ea28b26a87", "filename": "src/vertical.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f51261e93eedaba4ea17a70bd33fd0f34a5ded26/src%2Fvertical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f51261e93eedaba4ea17a70bd33fd0f34a5ded26/src%2Fvertical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvertical.rs?ref=f51261e93eedaba4ea17a70bd33fd0f34a5ded26", "patch": "@@ -53,8 +53,8 @@ impl AlignedItem for ast::StructField {\n         } else {\n             mk_sp(self.attrs.last().unwrap().span.hi(), self.span.lo())\n         };\n-        let attrs_extendable = context.config.attributes_on_same_line_as_field() &&\n-            is_attributes_extendable(&attrs_str);\n+        let attrs_extendable = context.config.attributes_on_same_line_as_field()\n+            && is_attributes_extendable(&attrs_str);\n         rewrite_struct_field_prefix(context, self).and_then(|field_str| {\n             combine_strs_with_missing_comments(\n                 context,\n@@ -184,8 +184,8 @@ pub fn rewrite_with_alignment<T: AlignedItem>(\n             one_line_width,\n         ));\n         Some(\n-            result + spaces + \"\\n\" +\n-                &shape\n+            result + spaces + \"\\n\"\n+                + &shape\n                     .indent\n                     .block_indent(context.config)\n                     .to_string(context.config) + &rest_str,"}, {"sha": "beb9ce108d2cd53b3e3a9ad76e791bb7ff2d955f", "filename": "src/visitor.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f51261e93eedaba4ea17a70bd33fd0f34a5ded26/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f51261e93eedaba4ea17a70bd33fd0f34a5ded26/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=f51261e93eedaba4ea17a70bd33fd0f34a5ded26", "patch": "@@ -722,8 +722,8 @@ impl<'a> FmtVisitor<'a> {\n         // Decide whether this is an inline mod or an external mod.\n         let local_file_name = self.codemap.span_to_filename(s);\n         let inner_span = source!(self, m.inner);\n-        let is_internal = !(inner_span.lo().0 == 0 && inner_span.hi().0 == 0) &&\n-            local_file_name == self.codemap.span_to_filename(inner_span);\n+        let is_internal = !(inner_span.lo().0 == 0 && inner_span.hi().0 == 0)\n+            && local_file_name == self.codemap.span_to_filename(inner_span);\n \n         self.buffer.push_str(&*utils::format_visibility(vis));\n         self.buffer.push_str(\"mod \");\n@@ -883,8 +883,8 @@ impl<'a> Rewrite for [ast::Attribute] {\n                 // This particular horror show is to preserve line breaks in between doc\n                 // comments. An alternative would be to force such line breaks to start\n                 // with the usual doc comment token.\n-                let (multi_line_before, multi_line_after) = if a.is_sugared_doc ||\n-                    is_prev_sugared_doc\n+                let (multi_line_before, multi_line_after) = if a.is_sugared_doc\n+                    || is_prev_sugared_doc\n                 {\n                     // Look at before and after comment and see if there are any empty lines.\n                     let comment_begin = comment.chars().position(|c| c == '/');"}]}