{"sha": "8c8d0bb34f5495e0f260b5aaf3685ecb98406f32", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjOGQwYmIzNGY1NDk1ZTBmMjYwYjVhYWYzNjg1ZWNiOTg0MDZmMzI=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-02-09T18:57:01Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-02-09T22:06:15Z"}, "message": "Add or- and parenthesized-patterns", "tree": {"sha": "26df75871f23bb30fbef81fbc3c75beedaf20ab5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/26df75871f23bb30fbef81fbc3c75beedaf20ab5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c8d0bb34f5495e0f260b5aaf3685ecb98406f32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c8d0bb34f5495e0f260b5aaf3685ecb98406f32", "html_url": "https://github.com/rust-lang/rust/commit/8c8d0bb34f5495e0f260b5aaf3685ecb98406f32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c8d0bb34f5495e0f260b5aaf3685ecb98406f32/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b9b13b4b4a75b5531c3f046ce6bf72d681f2732", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b9b13b4b4a75b5531c3f046ce6bf72d681f2732", "html_url": "https://github.com/rust-lang/rust/commit/1b9b13b4b4a75b5531c3f046ce6bf72d681f2732"}], "stats": {"total": 230, "additions": 184, "deletions": 46}, "files": [{"sha": "ae2437ed32f1f785cd277936b11f02e626b757fd", "filename": "crates/ra_assists/src/handlers/fill_match_arms.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c8d0bb34f5495e0f260b5aaf3685ecb98406f32/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8d0bb34f5495e0f260b5aaf3685ecb98406f32/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs?ref=8c8d0bb34f5495e0f260b5aaf3685ecb98406f32", "patch": "@@ -75,10 +75,10 @@ pub(crate) fn fill_match_arms(ctx: AssistCtx) -> Option<Assist> {\n }\n \n fn is_trivial(arm: &ast::MatchArm) -> bool {\n-    arm.pats().any(|pat| match pat {\n-        ast::Pat::PlaceholderPat(..) => true,\n+    match arm.pat() {\n+        Some(ast::Pat::PlaceholderPat(..)) => true,\n         _ => false,\n-    })\n+    }\n }\n \n fn resolve_enum_def("}, {"sha": "b2a194cb5f2d02eddc5372deae2d9d21780784b1", "filename": "crates/ra_assists/src/handlers/merge_match_arms.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c8d0bb34f5495e0f260b5aaf3685ecb98406f32/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8d0bb34f5495e0f260b5aaf3685ecb98406f32/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs?ref=8c8d0bb34f5495e0f260b5aaf3685ecb98406f32", "patch": "@@ -75,7 +75,7 @@ pub(crate) fn merge_match_arms(ctx: AssistCtx) -> Option<Assist> {\n         } else {\n             arms_to_merge\n                 .iter()\n-                .flat_map(ast::MatchArm::pats)\n+                .filter_map(ast::MatchArm::pat)\n                 .map(|x| x.syntax().to_string())\n                 .collect::<Vec<String>>()\n                 .join(\" | \")\n@@ -96,10 +96,10 @@ pub(crate) fn merge_match_arms(ctx: AssistCtx) -> Option<Assist> {\n }\n \n fn contains_placeholder(a: &ast::MatchArm) -> bool {\n-    a.pats().any(|x| match x {\n-        ra_syntax::ast::Pat::PlaceholderPat(..) => true,\n+    match a.pat() {\n+        Some(ra_syntax::ast::Pat::PlaceholderPat(..)) => true,\n         _ => false,\n-    })\n+    }\n }\n \n fn next_arm(arm: &ast::MatchArm) -> Option<ast::MatchArm> {"}, {"sha": "a61a2ba3e12aa4a2e3f9a8e3907e9f1e82500b4a", "filename": "crates/ra_assists/src/handlers/move_guard.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c8d0bb34f5495e0f260b5aaf3685ecb98406f32/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8d0bb34f5495e0f260b5aaf3685ecb98406f32/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_guard.rs?ref=8c8d0bb34f5495e0f260b5aaf3685ecb98406f32", "patch": "@@ -90,7 +90,7 @@ pub(crate) fn move_guard_to_arm_body(ctx: AssistCtx) -> Option<Assist> {\n // ```\n pub(crate) fn move_arm_cond_to_match_guard(ctx: AssistCtx) -> Option<Assist> {\n     let match_arm: MatchArm = ctx.find_node_at_offset::<MatchArm>()?;\n-    let last_match_pat = match_arm.pats().last()?;\n+    let match_pat = match_arm.pat()?;\n \n     let arm_body = match_arm.expr()?;\n     let if_expr: IfExpr = IfExpr::cast(arm_body.syntax().clone())?;\n@@ -122,8 +122,8 @@ pub(crate) fn move_arm_cond_to_match_guard(ctx: AssistCtx) -> Option<Assist> {\n                 _ => edit.replace(if_expr.syntax().text_range(), then_block.syntax().text()),\n             }\n \n-            edit.insert(last_match_pat.syntax().text_range().end(), buf);\n-            edit.set_cursor(last_match_pat.syntax().text_range().end() + TextUnit::from(1));\n+            edit.insert(match_pat.syntax().text_range().end(), buf);\n+            edit.set_cursor(match_pat.syntax().text_range().end() + TextUnit::from(1));\n         },\n     )\n }"}, {"sha": "fe0973fc764c17a94f5e278dcb9a200d9cd6e8be", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8c8d0bb34f5495e0f260b5aaf3685ecb98406f32/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8d0bb34f5495e0f260b5aaf3685ecb98406f32/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=8c8d0bb34f5495e0f260b5aaf3685ecb98406f32", "patch": "@@ -164,9 +164,9 @@ where\n                             let match_expr = self.collect_expr_opt(condition.expr());\n                             let placeholder_pat = self.missing_pat();\n                             let arms = vec![\n-                                MatchArm { pats: vec![pat], expr: then_branch, guard: None },\n+                                MatchArm { pat, expr: then_branch, guard: None },\n                                 MatchArm {\n-                                    pats: vec![placeholder_pat],\n+                                    pat: placeholder_pat,\n                                     expr: else_branch.unwrap_or_else(|| self.empty_block()),\n                                     guard: None,\n                                 },\n@@ -203,8 +203,8 @@ where\n                             let placeholder_pat = self.missing_pat();\n                             let break_ = self.alloc_expr_desugared(Expr::Break { expr: None });\n                             let arms = vec![\n-                                MatchArm { pats: vec![pat], expr: body, guard: None },\n-                                MatchArm { pats: vec![placeholder_pat], expr: break_, guard: None },\n+                                MatchArm { pat, expr: body, guard: None },\n+                                MatchArm { pat: placeholder_pat, expr: break_, guard: None },\n                             ];\n                             let match_expr =\n                                 self.alloc_expr_desugared(Expr::Match { expr: match_expr, arms });\n@@ -250,7 +250,7 @@ where\n                     match_arm_list\n                         .arms()\n                         .map(|arm| MatchArm {\n-                            pats: arm.pats().map(|p| self.collect_pat(p)).collect(),\n+                            pat: self.collect_pat_opt(arm.pat()),\n                             expr: self.collect_expr_opt(arm.expr()),\n                             guard: arm\n                                 .guard()\n@@ -587,6 +587,11 @@ where\n                 let path = p.path().and_then(|path| self.expander.parse_path(path));\n                 path.map(Pat::Path).unwrap_or(Pat::Missing)\n             }\n+            ast::Pat::OrPat(p) => {\n+                let pats = p.pats().map(|p| self.collect_pat(p)).collect();\n+                Pat::Or(pats)\n+            }\n+            ast::Pat::ParenPat(p) => return self.collect_pat_opt(p.pat()),\n             ast::Pat::TuplePat(p) => {\n                 let args = p.args().map(|p| self.collect_pat(p)).collect();\n                 Pat::Tuple(args)"}, {"sha": "32c924accf5527bb0bd4d28954ea9017bb7b2e81", "filename": "crates/ra_hir_def/src/body/scope.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c8d0bb34f5495e0f260b5aaf3685ecb98406f32/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8d0bb34f5495e0f260b5aaf3685ecb98406f32/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs?ref=8c8d0bb34f5495e0f260b5aaf3685ecb98406f32", "patch": "@@ -158,9 +158,7 @@ fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut ExprScopes, scope\n             compute_expr_scopes(*expr, body, scopes, scope);\n             for arm in arms {\n                 let scope = scopes.new_scope(scope);\n-                for pat in &arm.pats {\n-                    scopes.add_bindings(body, scope, *pat);\n-                }\n+                scopes.add_bindings(body, scope, arm.pat);\n                 scopes.set_scope(arm.expr, scope);\n                 compute_expr_scopes(arm.expr, body, scopes, scope);\n             }"}, {"sha": "5a84e08ededcf2be52fa66e3451d87585970b9f1", "filename": "crates/ra_hir_def/src/expr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8c8d0bb34f5495e0f260b5aaf3685ecb98406f32/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8d0bb34f5495e0f260b5aaf3685ecb98406f32/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs?ref=8c8d0bb34f5495e0f260b5aaf3685ecb98406f32", "patch": "@@ -202,7 +202,7 @@ pub enum Array {\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n pub struct MatchArm {\n-    pub pats: Vec<PatId>,\n+    pub pat: PatId,\n     pub guard: Option<ExprId>,\n     pub expr: ExprId,\n }\n@@ -382,6 +382,7 @@ pub enum Pat {\n     Missing,\n     Wild,\n     Tuple(Vec<PatId>),\n+    Or(Vec<PatId>),\n     Record {\n         path: Option<Path>,\n         args: Vec<RecordFieldPat>,\n@@ -420,7 +421,7 @@ impl Pat {\n             Pat::Bind { subpat, .. } => {\n                 subpat.iter().copied().for_each(f);\n             }\n-            Pat::Tuple(args) | Pat::TupleStruct { args, .. } => {\n+            Pat::Or(args) | Pat::Tuple(args) | Pat::TupleStruct { args, .. } => {\n                 args.iter().copied().for_each(f);\n             }\n             Pat::Ref { pat, .. } => f(*pat),"}, {"sha": "186857b8b214b7170604028b67cd9416a7a91a25", "filename": "crates/ra_hir_ty/src/infer/expr.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c8d0bb34f5495e0f260b5aaf3685ecb98406f32/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8d0bb34f5495e0f260b5aaf3685ecb98406f32/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=8c8d0bb34f5495e0f260b5aaf3685ecb98406f32", "patch": "@@ -168,9 +168,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let mut result_ty = self.table.new_maybe_never_type_var();\n \n                 for arm in arms {\n-                    for &pat in &arm.pats {\n-                        let _pat_ty = self.infer_pat(pat, &input_ty, BindingMode::default());\n-                    }\n+                    let _pat_ty = self.infer_pat(arm.pat, &input_ty, BindingMode::default());\n                     if let Some(guard_expr) = arm.guard {\n                         self.infer_expr(\n                             guard_expr,"}, {"sha": "a5dfdf6c4be4db3032a3546576f36b0bddde5740", "filename": "crates/ra_hir_ty/src/infer/pat.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8c8d0bb34f5495e0f260b5aaf3685ecb98406f32/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8d0bb34f5495e0f260b5aaf3685ecb98406f32/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs?ref=8c8d0bb34f5495e0f260b5aaf3685ecb98406f32", "patch": "@@ -82,6 +82,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n         let is_non_ref_pat = match &body[pat] {\n             Pat::Tuple(..)\n+            | Pat::Or(..)\n             | Pat::TupleStruct { .. }\n             | Pat::Record { .. }\n             | Pat::Range { .. }\n@@ -126,6 +127,17 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n                 Ty::apply(TypeCtor::Tuple { cardinality: args.len() as u16 }, Substs(inner_tys))\n             }\n+            Pat::Or(ref pats) => {\n+                if let Some((first_pat, rest)) = pats.split_first() {\n+                    let ty = self.infer_pat(*first_pat, expected, default_bm);\n+                    for pat in rest {\n+                        self.infer_pat(*pat, expected, default_bm);\n+                    }\n+                    ty\n+                } else {\n+                    Ty::Unknown\n+                }\n+            }\n             Pat::Ref { pat, mutability } => {\n                 let expectation = match expected.as_reference() {\n                     Some((inner_ty, exp_mut)) => {"}, {"sha": "2ae97e65f506020df3330e0e1826e45b7c3cfd3a", "filename": "crates/ra_ide/src/inlay_hints.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8c8d0bb34f5495e0f260b5aaf3685ecb98406f32/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8d0bb34f5495e0f260b5aaf3685ecb98406f32/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs?ref=8c8d0bb34f5495e0f260b5aaf3685ecb98406f32", "patch": "@@ -80,8 +80,7 @@ fn get_inlay_hints(\n             },\n             ast::MatchArmList(it) => {\n                 it.arms()\n-                    .map(|match_arm| match_arm.pats())\n-                    .flatten()\n+                    .filter_map(|match_arm| match_arm.pat())\n                     .for_each(|root_pat| get_pat_type_hints(acc, db, &analyzer, root_pat, true, max_inlay_hint_length));\n             },\n             ast::CallExpr(it) => {\n@@ -202,6 +201,7 @@ fn get_leaf_pats(root_pat: ast::Pat) -> Vec<ast::Pat> {\n                 Some(pat) => pats_to_process.push_back(pat),\n                 _ => leaf_pats.push(maybe_leaf_pat),\n             },\n+            ast::Pat::OrPat(ref_pat) => pats_to_process.extend(ref_pat.pats()),\n             ast::Pat::TuplePat(tuple_pat) => pats_to_process.extend(tuple_pat.args()),\n             ast::Pat::RecordPat(record_pat) => {\n                 if let Some(pat_list) = record_pat.record_field_pat_list() {\n@@ -222,6 +222,7 @@ fn get_leaf_pats(root_pat: ast::Pat) -> Vec<ast::Pat> {\n             ast::Pat::TupleStructPat(tuple_struct_pat) => {\n                 pats_to_process.extend(tuple_struct_pat.args())\n             }\n+            ast::Pat::ParenPat(inner_pat) => pats_to_process.extend(inner_pat.pat()),\n             ast::Pat::RefPat(ref_pat) => pats_to_process.extend(ref_pat.pat()),\n             _ => (),\n         }"}, {"sha": "b72d2e9e64880f6f037583e4e8db83da7ada5d94", "filename": "crates/ra_parser/src/grammar/expressions/atom.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c8d0bb34f5495e0f260b5aaf3685ecb98406f32/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8d0bb34f5495e0f260b5aaf3685ecb98406f32/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs?ref=8c8d0bb34f5495e0f260b5aaf3685ecb98406f32", "patch": "@@ -336,7 +336,7 @@ fn for_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n fn cond(p: &mut Parser) {\n     let m = p.start();\n     if p.eat(T![let]) {\n-        patterns::pattern_list(p);\n+        patterns::pattern_top(p);\n         p.expect(T![=]);\n     }\n     expr_no_struct(p);\n@@ -430,7 +430,7 @@ fn match_arm(p: &mut Parser) -> BlockLike {\n     // }\n     attributes::outer_attributes(p);\n \n-    patterns::pattern_list_r(p, TokenSet::EMPTY);\n+    patterns::pattern_top_r(p, TokenSet::EMPTY);\n     if p.at(T![if]) {\n         match_guard(p);\n     }"}, {"sha": "ed4f93347a2ad2c43e2350087f2a59435db62f2e", "filename": "crates/ra_parser/src/grammar/params.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c8d0bb34f5495e0f260b5aaf3685ecb98406f32/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fparams.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8d0bb34f5495e0f260b5aaf3685ecb98406f32/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fparams.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fparams.rs?ref=8c8d0bb34f5495e0f260b5aaf3685ecb98406f32", "patch": "@@ -116,7 +116,7 @@ fn value_parameter(p: &mut Parser, flavor: Flavor) {\n         // type Qux = fn(baz: Bar::Baz);\n         Flavor::FnPointer => {\n             if p.at(IDENT) && p.nth(1) == T![:] && !p.nth_at(1, T![::]) {\n-                patterns::pattern(p);\n+                patterns::pattern_single(p);\n                 types::ascription(p);\n             } else {\n                 types::type_(p);\n@@ -127,7 +127,7 @@ fn value_parameter(p: &mut Parser, flavor: Flavor) {\n         //    let foo = |bar, baz: Baz, qux: Qux::Quux| ();\n         // }\n         Flavor::Closure => {\n-            patterns::pattern(p);\n+            patterns::pattern_single(p);\n             if p.at(T![:]) && !p.at(T![::]) {\n                 types::ascription(p);\n             }"}, {"sha": "c6a2e4d39959e875bff1316ed8a56f2876950bdd", "filename": "crates/ra_parser/src/grammar/patterns.rs", "status": "modified", "additions": 56, "deletions": 10, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/8c8d0bb34f5495e0f260b5aaf3685ecb98406f32/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8d0bb34f5495e0f260b5aaf3685ecb98406f32/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpatterns.rs?ref=8c8d0bb34f5495e0f260b5aaf3685ecb98406f32", "patch": "@@ -11,22 +11,49 @@ pub(crate) fn pattern(p: &mut Parser) {\n }\n \n /// Parses a pattern list separated by pipes `|`\n-pub(super) fn pattern_list(p: &mut Parser) {\n-    pattern_list_r(p, PAT_RECOVERY_SET)\n+pub(super) fn pattern_top(p: &mut Parser) {\n+    pattern_top_r(p, PAT_RECOVERY_SET)\n+}\n+\n+pub(crate) fn pattern_single(p: &mut Parser) {\n+    pattern_single_r(p, PAT_RECOVERY_SET);\n }\n \n /// Parses a pattern list separated by pipes `|`\n /// using the given `recovery_set`\n-pub(super) fn pattern_list_r(p: &mut Parser, recovery_set: TokenSet) {\n+pub(super) fn pattern_top_r(p: &mut Parser, recovery_set: TokenSet) {\n     p.eat(T![|]);\n     pattern_r(p, recovery_set);\n+}\n \n+/// Parses a pattern list separated by pipes `|`, with no leading `|`,using the\n+/// given `recovery_set`\n+// test or_pattern\n+// fn main() {\n+//     match () {\n+//         (_ | _) => (),\n+//         &(_ | _) => (),\n+//         (_ | _,) => (),\n+//         [_ | _,] => (),\n+//     }\n+// }\n+fn pattern_r(p: &mut Parser, recovery_set: TokenSet) {\n+    let m = p.start();\n+    pattern_single_r(p, recovery_set);\n+\n+    let mut is_or_pat = false;\n     while p.eat(T![|]) {\n-        pattern_r(p, recovery_set);\n+        is_or_pat = true;\n+        pattern_single_r(p, recovery_set);\n+    }\n+    if is_or_pat {\n+        m.complete(p, OR_PAT);\n+    } else {\n+        m.abandon(p);\n     }\n }\n \n-pub(super) fn pattern_r(p: &mut Parser, recovery_set: TokenSet) {\n+fn pattern_single_r(p: &mut Parser, recovery_set: TokenSet) {\n     if let Some(lhs) = atom_pat(p, recovery_set) {\n         // test range_pat\n         // fn main() {\n@@ -258,7 +285,7 @@ fn ref_pat(p: &mut Parser) -> CompletedMarker {\n     let m = p.start();\n     p.bump(T![&]);\n     p.eat(T![mut]);\n-    pattern(p);\n+    pattern_single(p);\n     m.complete(p, REF_PAT)\n }\n \n@@ -269,8 +296,27 @@ fn ref_pat(p: &mut Parser) -> CompletedMarker {\n fn tuple_pat(p: &mut Parser) -> CompletedMarker {\n     assert!(p.at(T!['(']));\n     let m = p.start();\n-    tuple_pat_fields(p);\n-    m.complete(p, TUPLE_PAT)\n+    p.bump(T!['(']);\n+    let mut has_comma = false;\n+    let mut has_pat = false;\n+    let mut has_rest = false;\n+    while !p.at(EOF) && !p.at(T![')']) {\n+        has_pat = true;\n+        if !p.at_ts(PATTERN_FIRST) {\n+            p.error(\"expected a pattern\");\n+            break;\n+        }\n+        has_rest |= p.at(T![..]);\n+\n+        pattern(p);\n+        if !p.at(T![')']) {\n+            has_comma = true;\n+            p.expect(T![,]);\n+        }\n+    }\n+    p.expect(T![')']);\n+\n+    m.complete(p, if !has_comma && !has_rest && has_pat { PAREN_PAT } else { TUPLE_PAT })\n }\n \n // test slice_pat\n@@ -315,7 +361,7 @@ fn bind_pat(p: &mut Parser, with_at: bool) -> CompletedMarker {\n     p.eat(T![mut]);\n     name(p);\n     if with_at && p.eat(T![@]) {\n-        pattern(p);\n+        pattern_single(p);\n     }\n     m.complete(p, BIND_PAT)\n }\n@@ -330,6 +376,6 @@ fn box_pat(p: &mut Parser) -> CompletedMarker {\n     assert!(p.at(T![box]));\n     let m = p.start();\n     p.bump(T![box]);\n-    pattern(p);\n+    pattern_single(p);\n     m.complete(p, BOX_PAT)\n }"}, {"sha": "1068da0a06316a5c1bc3882dec91849cb903a581", "filename": "crates/ra_parser/src/syntax_kind/generated.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c8d0bb34f5495e0f260b5aaf3685ecb98406f32/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8d0bb34f5495e0f260b5aaf3685ecb98406f32/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs?ref=8c8d0bb34f5495e0f260b5aaf3685ecb98406f32", "patch": "@@ -151,6 +151,8 @@ pub enum SyntaxKind {\n     FOR_TYPE,\n     IMPL_TRAIT_TYPE,\n     DYN_TRAIT_TYPE,\n+    OR_PAT,\n+    PAREN_PAT,\n     REF_PAT,\n     BOX_PAT,\n     BIND_PAT,"}, {"sha": "8d640642d275242fc1f4154ffcde8917b4ff1da0", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 75, "deletions": 6, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/8c8d0bb34f5495e0f260b5aaf3685ecb98406f32/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8d0bb34f5495e0f260b5aaf3685ecb98406f32/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=8c8d0bb34f5495e0f260b5aaf3685ecb98406f32", "patch": "@@ -1759,8 +1759,8 @@ impl AstNode for MatchArm {\n }\n impl ast::AttrsOwner for MatchArm {}\n impl MatchArm {\n-    pub fn pats(&self) -> AstChildren<Pat> {\n-        AstChildren::new(&self.syntax)\n+    pub fn pat(&self) -> Option<Pat> {\n+        AstChildren::new(&self.syntax).next()\n     }\n     pub fn guard(&self) -> Option<MatchGuard> {\n         AstChildren::new(&self.syntax).next()\n@@ -1887,6 +1887,60 @@ impl RecordField {\n     }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct OrPat {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl AstNode for OrPat {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            OR_PAT => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode {\n+        &self.syntax\n+    }\n+}\n+impl OrPat {\n+    pub fn pats(&self) -> AstChildren<Pat> {\n+        AstChildren::new(&self.syntax)\n+    }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct ParenPat {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl AstNode for ParenPat {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            PAREN_PAT => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode {\n+        &self.syntax\n+    }\n+}\n+impl ParenPat {\n+    pub fn pat(&self) -> Option<Pat> {\n+        AstChildren::new(&self.syntax).next()\n+    }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RefPat {\n     pub(crate) syntax: SyntaxNode,\n }\n@@ -3900,6 +3954,8 @@ impl AstNode for Expr {\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum Pat {\n+    OrPat(OrPat),\n+    ParenPat(ParenPat),\n     RefPat(RefPat),\n     BoxPat(BoxPat),\n     BindPat(BindPat),\n@@ -3913,6 +3969,16 @@ pub enum Pat {\n     RangePat(RangePat),\n     LiteralPat(LiteralPat),\n }\n+impl From<OrPat> for Pat {\n+    fn from(node: OrPat) -> Pat {\n+        Pat::OrPat(node)\n+    }\n+}\n+impl From<ParenPat> for Pat {\n+    fn from(node: ParenPat) -> Pat {\n+        Pat::ParenPat(node)\n+    }\n+}\n impl From<RefPat> for Pat {\n     fn from(node: RefPat) -> Pat {\n         Pat::RefPat(node)\n@@ -3976,15 +4042,16 @@ impl From<LiteralPat> for Pat {\n impl AstNode for Pat {\n     fn can_cast(kind: SyntaxKind) -> bool {\n         match kind {\n-            REF_PAT | BOX_PAT | BIND_PAT | PLACEHOLDER_PAT | DOT_DOT_PAT | PATH_PAT\n-            | RECORD_PAT | TUPLE_STRUCT_PAT | TUPLE_PAT | SLICE_PAT | RANGE_PAT | LITERAL_PAT => {\n-                true\n-            }\n+            OR_PAT | PAREN_PAT | REF_PAT | BOX_PAT | BIND_PAT | PLACEHOLDER_PAT | DOT_DOT_PAT\n+            | PATH_PAT | RECORD_PAT | TUPLE_STRUCT_PAT | TUPLE_PAT | SLICE_PAT | RANGE_PAT\n+            | LITERAL_PAT => true,\n             _ => false,\n         }\n     }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         let res = match syntax.kind() {\n+            OR_PAT => Pat::OrPat(OrPat { syntax }),\n+            PAREN_PAT => Pat::ParenPat(ParenPat { syntax }),\n             REF_PAT => Pat::RefPat(RefPat { syntax }),\n             BOX_PAT => Pat::BoxPat(BoxPat { syntax }),\n             BIND_PAT => Pat::BindPat(BindPat { syntax }),\n@@ -4003,6 +4070,8 @@ impl AstNode for Pat {\n     }\n     fn syntax(&self) -> &SyntaxNode {\n         match self {\n+            Pat::OrPat(it) => &it.syntax,\n+            Pat::ParenPat(it) => &it.syntax,\n             Pat::RefPat(it) => &it.syntax,\n             Pat::BoxPat(it) => &it.syntax,\n             Pat::BindPat(it) => &it.syntax,"}, {"sha": "3f530e4899c7cdb2424c73402f6aa0e0b57f754b", "filename": "xtask/src/ast_src.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c8d0bb34f5495e0f260b5aaf3685ecb98406f32/xtask%2Fsrc%2Fast_src.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8d0bb34f5495e0f260b5aaf3685ecb98406f32/xtask%2Fsrc%2Fast_src.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fast_src.rs?ref=8c8d0bb34f5495e0f260b5aaf3685ecb98406f32", "patch": "@@ -120,6 +120,8 @@ pub(crate) const KINDS_SRC: KindsSrc = KindsSrc {\n         \"FOR_TYPE\",\n         \"IMPL_TRAIT_TYPE\",\n         \"DYN_TRAIT_TYPE\",\n+        \"OR_PAT\",\n+        \"PAREN_PAT\",\n         \"REF_PAT\",\n         \"BOX_PAT\",\n         \"BIND_PAT\",\n@@ -412,7 +414,7 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n         struct MatchExpr { Expr, MatchArmList }\n         struct MatchArmList: AttrsOwner { arms: [MatchArm] }\n         struct MatchArm: AttrsOwner {\n-            pats: [Pat],\n+            pat: Pat,\n             guard: MatchGuard,\n             Expr,\n          }\n@@ -425,6 +427,8 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n          }\n         struct RecordField { NameRef, Expr }\n \n+        struct OrPat { pats: [Pat] }\n+        struct ParenPat { Pat }\n         struct RefPat { Pat }\n         struct BoxPat { Pat }\n         struct BindPat: NameOwner { Pat }\n@@ -601,6 +605,8 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n         }\n \n         enum Pat {\n+            OrPat,\n+            ParenPat,\n             RefPat,\n             BoxPat,\n             BindPat,"}]}