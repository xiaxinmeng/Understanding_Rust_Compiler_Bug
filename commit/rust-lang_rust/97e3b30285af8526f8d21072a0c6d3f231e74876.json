{"sha": "97e3b30285af8526f8d21072a0c6d3f231e74876", "node_id": "C_kwDOAAsO6NoAKDk3ZTNiMzAyODVhZjg1MjZmOGQyMTA3MmEwYzZkM2YyMzFlNzQ4NzY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-12T00:20:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-12T00:20:34Z"}, "message": "Auto merge of #89791 - matthiaskrgr:rollup-1lhxh5b, r=matthiaskrgr\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #89471 (Use Ancestory to check default fn in const impl instead of comparing idents)\n - #89643 (Fix inherent impl overlap check.)\n - #89651 (Add `Poll::ready` and revert stabilization of `task::ready!`)\n - #89675 (Re-use TypeChecker instead of passing around some of its fields )\n - #89710 (Add long explanation for error E0482)\n - #89756 (Greatly reduce amount of debuginfo compiled for bootstrap itself)\n - #89760 (Remove hack ignoring unused attributes for stage 0 std)\n - #89772 (Fix function-names test for GDB 10.1)\n - #89785 (Fix ICE when compiling nightly std/rustc on beta compiler)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "4ac047b9f4927369c428718b86c233ab4830c505", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ac047b9f4927369c428718b86c233ab4830c505"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97e3b30285af8526f8d21072a0c6d3f231e74876", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97e3b30285af8526f8d21072a0c6d3f231e74876", "html_url": "https://github.com/rust-lang/rust/commit/97e3b30285af8526f8d21072a0c6d3f231e74876", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97e3b30285af8526f8d21072a0c6d3f231e74876/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7cc8c44871b6e789d29fc0d42dacad9804c3a41c", "url": "https://api.github.com/repos/rust-lang/rust/commits/7cc8c44871b6e789d29fc0d42dacad9804c3a41c", "html_url": "https://github.com/rust-lang/rust/commit/7cc8c44871b6e789d29fc0d42dacad9804c3a41c"}, {"sha": "f94a325496a475ec866f41a8036d4a418832522c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f94a325496a475ec866f41a8036d4a418832522c", "html_url": "https://github.com/rust-lang/rust/commit/f94a325496a475ec866f41a8036d4a418832522c"}], "stats": {"total": 568, "additions": 385, "deletions": 183}, "files": [{"sha": "8d6afd2b4483773173d0f0c142af563225b09edb", "filename": "Cargo.toml", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/97e3b30285af8526f8d21072a0c6d3f231e74876/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/97e3b30285af8526f8d21072a0c6d3f231e74876/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=97e3b30285af8526f8d21072a0c6d3f231e74876", "patch": "@@ -89,6 +89,15 @@ gimli.debug = 0\n miniz_oxide.debug = 0\n object.debug = 0\n \n+# The only package that ever uses debug builds is bootstrap.\n+# We care a lot about bootstrap's compile times, so don't include debug info for\n+# dependencies, only bootstrap itself.\n+[profile.dev]\n+debug = 0\n+[profile.dev.package]\n+# Only use debuginfo=1 to further reduce compile times.\n+bootstrap.debug = 1\n+\n # We want the RLS to use the version of Cargo that we've got vendored in this\n # repository to ensure that the same exact version of Cargo is used by both the\n # RLS and the Cargo binary itself. The RLS depends on Cargo as a git repository"}, {"sha": "269740c171cfb29e3519fe9510eff74bf7750457", "filename": "RELEASES.md", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97e3b30285af8526f8d21072a0c6d3f231e74876/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/97e3b30285af8526f8d21072a0c6d3f231e74876/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=97e3b30285af8526f8d21072a0c6d3f231e74876", "patch": "@@ -64,7 +64,6 @@ Stabilised APIs\n - [`VecDeque::shrink_to`]\n - [`HashMap::shrink_to`]\n - [`HashSet::shrink_to`]\n-- [`task::ready!`]\n \n These APIs are now usable in const contexts:\n \n@@ -128,7 +127,6 @@ and related tools.\n [`VecDeque::shrink_to`]: https://doc.rust-lang.org/stable/std/collections/struct.VecDeque.html#method.shrink_to\n [`HashMap::shrink_to`]: https://doc.rust-lang.org/stable/std/collections/hash_map/struct.HashMap.html#method.shrink_to\n [`HashSet::shrink_to`]: https://doc.rust-lang.org/stable/std/collections/hash_set/struct.HashSet.html#method.shrink_to\n-[`task::ready!`]: https://doc.rust-lang.org/stable/std/task/macro.ready.html\n [`std::mem::transmute`]: https://doc.rust-lang.org/stable/std/mem/fn.transmute.html\n [`slice::first`]: https://doc.rust-lang.org/stable/std/primitive.slice.html#method.first\n [`slice::split_first`]: https://doc.rust-lang.org/stable/std/primitive.slice.html#method.split_first"}, {"sha": "07eadce17738e90847b3a2eb9e8056580187998e", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/97e3b30285af8526f8d21072a0c6d3f231e74876/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97e3b30285af8526f8d21072a0c6d3f231e74876/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=97e3b30285af8526f8d21072a0c6d3f231e74876", "patch": "@@ -1153,28 +1153,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         .convert_all(data);\n     }\n \n-    /// Convenient wrapper around `relate_tys::relate_types` -- see\n-    /// that fn for docs.\n-    fn relate_types(\n-        &mut self,\n-        a: Ty<'tcx>,\n-        v: ty::Variance,\n-        b: Ty<'tcx>,\n-        locations: Locations,\n-        category: ConstraintCategory,\n-    ) -> Fallible<()> {\n-        relate_tys::relate_types(\n-            self.infcx,\n-            self.param_env,\n-            a,\n-            v,\n-            b,\n-            locations,\n-            category,\n-            self.borrowck_context,\n-        )\n-    }\n-\n     /// Try to relate `sub <: sup`\n     fn sub_types(\n         &mut self,"}, {"sha": "415d1abaa8b089fdeb453251f99242f4563587a5", "filename": "compiler/rustc_borrowck/src/type_check/relate_tys.rs", "status": "modified", "additions": 53, "deletions": 59, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/97e3b30285af8526f8d21072a0c6d3f231e74876/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97e3b30285af8526f8d21072a0c6d3f231e74876/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs?ref=97e3b30285af8526f8d21072a0c6d3f231e74876", "patch": "@@ -1,54 +1,44 @@\n use rustc_infer::infer::nll_relate::{NormalizationStrategy, TypeRelating, TypeRelatingDelegate};\n-use rustc_infer::infer::{InferCtxt, NllRegionVariableOrigin};\n+use rustc_infer::infer::NllRegionVariableOrigin;\n use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::{self, Const, Ty};\n use rustc_trait_selection::traits::query::Fallible;\n \n use crate::constraints::OutlivesConstraint;\n use crate::diagnostics::UniverseInfo;\n-use crate::type_check::{BorrowCheckContext, Locations};\n-\n-/// Adds sufficient constraints to ensure that `a R b` where `R` depends on `v`:\n-///\n-/// - \"Covariant\" `a <: b`\n-/// - \"Invariant\" `a == b`\n-/// - \"Contravariant\" `a :> b`\n-///\n-/// N.B., the type `a` is permitted to have unresolved inference\n-/// variables, but not the type `b`.\n-#[instrument(skip(infcx, param_env, borrowck_context), level = \"debug\")]\n-pub(super) fn relate_types<'tcx>(\n-    infcx: &InferCtxt<'_, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    a: Ty<'tcx>,\n-    v: ty::Variance,\n-    b: Ty<'tcx>,\n-    locations: Locations,\n-    category: ConstraintCategory,\n-    borrowck_context: &mut BorrowCheckContext<'_, 'tcx>,\n-) -> Fallible<()> {\n-    TypeRelating::new(\n-        infcx,\n-        NllTypeRelatingDelegate::new(\n-            infcx,\n-            borrowck_context,\n-            param_env,\n-            locations,\n-            category,\n-            UniverseInfo::relate(a, b),\n-        ),\n-        v,\n-    )\n-    .relate(a, b)?;\n-    Ok(())\n+use crate::type_check::{Locations, TypeChecker};\n+\n+impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n+    /// Adds sufficient constraints to ensure that `a R b` where `R` depends on `v`:\n+    ///\n+    /// - \"Covariant\" `a <: b`\n+    /// - \"Invariant\" `a == b`\n+    /// - \"Contravariant\" `a :> b`\n+    ///\n+    /// N.B., the type `a` is permitted to have unresolved inference\n+    /// variables, but not the type `b`.\n+    #[instrument(skip(self), level = \"debug\")]\n+    pub(super) fn relate_types(\n+        &mut self,\n+        a: Ty<'tcx>,\n+        v: ty::Variance,\n+        b: Ty<'tcx>,\n+        locations: Locations,\n+        category: ConstraintCategory,\n+    ) -> Fallible<()> {\n+        TypeRelating::new(\n+            self.infcx,\n+            NllTypeRelatingDelegate::new(self, locations, category, UniverseInfo::relate(a, b)),\n+            v,\n+        )\n+        .relate(a, b)?;\n+        Ok(())\n+    }\n }\n \n struct NllTypeRelatingDelegate<'me, 'bccx, 'tcx> {\n-    infcx: &'me InferCtxt<'me, 'tcx>,\n-    borrowck_context: &'me mut BorrowCheckContext<'bccx, 'tcx>,\n-\n-    param_env: ty::ParamEnv<'tcx>,\n+    type_checker: &'me mut TypeChecker<'bccx, 'tcx>,\n \n     /// Where (and why) is this relation taking place?\n     locations: Locations,\n@@ -63,25 +53,24 @@ struct NllTypeRelatingDelegate<'me, 'bccx, 'tcx> {\n \n impl NllTypeRelatingDelegate<'me, 'bccx, 'tcx> {\n     fn new(\n-        infcx: &'me InferCtxt<'me, 'tcx>,\n-        borrowck_context: &'me mut BorrowCheckContext<'bccx, 'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n+        type_checker: &'me mut TypeChecker<'bccx, 'tcx>,\n         locations: Locations,\n         category: ConstraintCategory,\n         universe_info: UniverseInfo<'tcx>,\n     ) -> Self {\n-        Self { infcx, borrowck_context, param_env, locations, category, universe_info }\n+        Self { type_checker, locations, category, universe_info }\n     }\n }\n \n impl TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx> {\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n-        self.param_env\n+        self.type_checker.param_env\n     }\n \n     fn create_next_universe(&mut self) -> ty::UniverseIndex {\n-        let universe = self.infcx.create_next_universe();\n-        self.borrowck_context\n+        let universe = self.type_checker.infcx.create_next_universe();\n+        self.type_checker\n+            .borrowck_context\n             .constraints\n             .universe_causes\n             .insert(universe, self.universe_info.clone());\n@@ -90,15 +79,18 @@ impl TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx> {\n \n     fn next_existential_region_var(&mut self, from_forall: bool) -> ty::Region<'tcx> {\n         let origin = NllRegionVariableOrigin::Existential { from_forall };\n-        self.infcx.next_nll_region_var(origin)\n+        self.type_checker.infcx.next_nll_region_var(origin)\n     }\n \n     fn next_placeholder_region(&mut self, placeholder: ty::PlaceholderRegion) -> ty::Region<'tcx> {\n-        self.borrowck_context.constraints.placeholder_region(self.infcx, placeholder)\n+        self.type_checker\n+            .borrowck_context\n+            .constraints\n+            .placeholder_region(self.type_checker.infcx, placeholder)\n     }\n \n     fn generalize_existential(&mut self, universe: ty::UniverseIndex) -> ty::Region<'tcx> {\n-        self.infcx.next_nll_region_var_in_universe(\n+        self.type_checker.infcx.next_nll_region_var_in_universe(\n             NllRegionVariableOrigin::Existential { from_forall: false },\n             universe,\n         )\n@@ -110,15 +102,17 @@ impl TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx> {\n         sub: ty::Region<'tcx>,\n         info: ty::VarianceDiagInfo<'tcx>,\n     ) {\n-        let sub = self.borrowck_context.universal_regions.to_region_vid(sub);\n-        let sup = self.borrowck_context.universal_regions.to_region_vid(sup);\n-        self.borrowck_context.constraints.outlives_constraints.push(OutlivesConstraint {\n-            sup,\n-            sub,\n-            locations: self.locations,\n-            category: self.category,\n-            variance_info: info,\n-        });\n+        let sub = self.type_checker.borrowck_context.universal_regions.to_region_vid(sub);\n+        let sup = self.type_checker.borrowck_context.universal_regions.to_region_vid(sup);\n+        self.type_checker.borrowck_context.constraints.outlives_constraints.push(\n+            OutlivesConstraint {\n+                sup,\n+                sub,\n+                locations: self.locations,\n+                category: self.category,\n+                variance_info: info,\n+            },\n+        );\n     }\n \n     // We don't have to worry about the equality of consts during borrow checking"}, {"sha": "1b4b58314b3561806eca5011676a423fda50637b", "filename": "compiler/rustc_error_codes/src/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97e3b30285af8526f8d21072a0c6d3f231e74876/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97e3b30285af8526f8d21072a0c6d3f231e74876/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs?ref=97e3b30285af8526f8d21072a0c6d3f231e74876", "patch": "@@ -242,6 +242,7 @@ E0468: include_str!(\"./error_codes/E0468.md\"),\n E0469: include_str!(\"./error_codes/E0469.md\"),\n E0477: include_str!(\"./error_codes/E0477.md\"),\n E0478: include_str!(\"./error_codes/E0478.md\"),\n+E0482: include_str!(\"./error_codes/E0482.md\"),\n E0491: include_str!(\"./error_codes/E0491.md\"),\n E0492: include_str!(\"./error_codes/E0492.md\"),\n E0493: include_str!(\"./error_codes/E0493.md\"),\n@@ -599,7 +600,6 @@ E0785: include_str!(\"./error_codes/E0785.md\"),\n //  E0479, // the type `..` (provided as the value of a type parameter) is...\n //  E0480, // lifetime of method receiver does not outlive the method call\n //  E0481, // lifetime of function argument does not outlive the function call\n-    E0482, // lifetime of return value does not outlive the function call\n //  E0483, // lifetime of operand does not outlive the operation\n //  E0484, // reference is not valid at the time of borrow\n //  E0485, // automatically reference is not valid at the time of borrow"}, {"sha": "58ebf43cc98ced9ff3652ea13f49b10f067400c1", "filename": "compiler/rustc_error_codes/src/error_codes/E0482.md", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/97e3b30285af8526f8d21072a0c6d3f231e74876/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0482.md", "raw_url": "https://github.com/rust-lang/rust/raw/97e3b30285af8526f8d21072a0c6d3f231e74876/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0482.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0482.md?ref=97e3b30285af8526f8d21072a0c6d3f231e74876", "patch": "@@ -0,0 +1,73 @@\n+A lifetime of a returned value does not outlive the function call.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0482\n+fn prefix<'a>(\n+    words: impl Iterator<Item = &'a str>\n+) -> impl Iterator<Item = String> { // error!\n+    words.map(|v| format!(\"foo-{}\", v))\n+}\n+```\n+\n+To fix this error, make the lifetime of the returned value explicit:\n+\n+```\n+fn prefix<'a>(\n+    words: impl Iterator<Item = &'a str> + 'a\n+) -> impl Iterator<Item = String> + 'a { // ok!\n+    words.map(|v| format!(\"foo-{}\", v))\n+}\n+```\n+\n+The [`impl Trait`] feature in this example uses an implicit `'static` lifetime\n+restriction in the returned type. However the type implementing the `Iterator`\n+passed to the function lives just as long as `'a`, which is not long enough.\n+\n+The solution involves adding lifetime bound to both function argument and\n+the return value to make sure that the values inside the iterator\n+are not dropped when the function goes out of the scope.\n+\n+An alternative solution would be to guarantee that the `Item` references\n+in the iterator are alive for the whole lifetime of the program.\n+\n+```\n+fn prefix(\n+    words: impl Iterator<Item = &'static str>\n+) -> impl Iterator<Item = String> {  // ok!\n+    words.map(|v| format!(\"foo-{}\", v))\n+}\n+```\n+\n+A similar lifetime problem might arise when returning closures:\n+\n+```compile_fail,E0482\n+fn foo(\n+    x: &mut Vec<i32>\n+) -> impl FnMut(&mut Vec<i32>) -> &[i32] { // error!\n+    |y| {\n+        y.append(x);\n+        y\n+    }\n+}\n+```\n+\n+Analogically, a solution here is to use explicit return lifetime\n+and move the ownership of the variable to the closure.\n+\n+```\n+fn foo<'a>(\n+    x: &'a mut Vec<i32>\n+) -> impl FnMut(&mut Vec<i32>) -> &[i32] + 'a { // ok!\n+    move |y| {\n+        y.append(x);\n+        y\n+    }\n+}\n+```\n+\n+To better understand the lifetime treatment in the [`impl Trait`],\n+please see the [RFC 1951].\n+\n+[`impl Trait`]: https://doc.rust-lang.org/reference/types/impl-trait.html\n+[RFC 1951]: https://rust-lang.github.io/rfcs/1951-expand-impl-trait.html"}, {"sha": "69578e85f278175564365086d13d8f4bb22cea4e", "filename": "compiler/rustc_index/src/vec.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/97e3b30285af8526f8d21072a0c6d3f231e74876/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97e3b30285af8526f8d21072a0c6d3f231e74876/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fvec.rs?ref=97e3b30285af8526f8d21072a0c6d3f231e74876", "patch": "@@ -738,6 +738,12 @@ impl<I: Idx, T> IndexVec<I, Option<T>> {\n         self.ensure_contains_elem(index, || None);\n         self[index].get_or_insert_with(value)\n     }\n+\n+    #[inline]\n+    pub fn remove(&mut self, index: I) -> Option<T> {\n+        self.ensure_contains_elem(index, || None);\n+        self[index].take()\n+    }\n }\n \n impl<I: Idx, T: Clone> IndexVec<I, T> {"}, {"sha": "a0ceb567f25a6f8d13b6d04bc860153e86a3c478", "filename": "compiler/rustc_passes/src/check_const.rs", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/97e3b30285af8526f8d21072a0c6d3f231e74876/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97e3b30285af8526f8d21072a0c6d3f231e74876/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs?ref=97e3b30285af8526f8d21072a0c6d3f231e74876", "patch": "@@ -8,7 +8,6 @@\n //! through, but errors for structured control flow in a `const` should be emitted here.\n \n use rustc_attr as attr;\n-use rustc_data_structures::stable_set::FxHashSet;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n@@ -83,30 +82,39 @@ impl<'tcx> hir::itemlikevisit::ItemLikeVisitor<'tcx> for CheckConstTraitVisitor<\n         let _: Option<_> = try {\n             if let hir::ItemKind::Impl(ref imp) = item.kind {\n                 if let hir::Constness::Const = imp.constness {\n-                    let did = imp.of_trait.as_ref()?.trait_def_id()?;\n-                    let mut to_implement = FxHashSet::default();\n-\n-                    for did in self.tcx.associated_item_def_ids(did) {\n+                    let trait_def_id = imp.of_trait.as_ref()?.trait_def_id()?;\n+                    let ancestors = self\n+                        .tcx\n+                        .trait_def(trait_def_id)\n+                        .ancestors(self.tcx, item.def_id.to_def_id())\n+                        .ok()?;\n+                    let mut to_implement = Vec::new();\n+\n+                    for trait_item in self.tcx.associated_items(trait_def_id).in_definition_order()\n+                    {\n                         if let ty::AssocItem {\n                             kind: ty::AssocKind::Fn, ident, defaultness, ..\n-                        } = self.tcx.associated_item(*did)\n+                        } = trait_item\n                         {\n                             // we can ignore functions that do not have default bodies:\n                             // if those are unimplemented it will be catched by typeck.\n-                            if defaultness.has_value()\n-                                && !self.tcx.has_attr(*did, sym::default_method_body_is_const)\n+                            if !defaultness.has_value()\n+                                || self\n+                                    .tcx\n+                                    .has_attr(trait_item.def_id, sym::default_method_body_is_const)\n                             {\n-                                to_implement.insert(ident);\n+                                continue;\n                             }\n-                        }\n-                    }\n \n-                    for it in imp\n-                        .items\n-                        .iter()\n-                        .filter(|it| matches!(it.kind, hir::AssocItemKind::Fn { .. }))\n-                    {\n-                        to_implement.remove(&it.ident);\n+                            let is_implemented = ancestors\n+                                .leaf_def(self.tcx, trait_item.ident, trait_item.kind)\n+                                .map(|node_item| !node_item.defining_node.is_from_trait())\n+                                .unwrap_or(false);\n+\n+                            if !is_implemented {\n+                                to_implement.push(ident.to_string());\n+                            }\n+                        }\n                     }\n \n                     // all nonconst trait functions (not marked with #[default_method_body_is_const])\n@@ -118,7 +126,7 @@ impl<'tcx> hir::itemlikevisit::ItemLikeVisitor<'tcx> for CheckConstTraitVisitor<\n                                 item.span,\n                                 \"const trait implementations may not use non-const default functions\",\n                             )\n-                            .note(&format!(\"`{}` not implemented\", to_implement.into_iter().map(|id| id.to_string()).collect::<Vec<_>>().join(\"`, `\")))\n+                            .note(&format!(\"`{}` not implemented\", to_implement.join(\"`, `\")))\n                             .emit();\n                     }\n                 }"}, {"sha": "1a8f863952e6ad5cddaabc3247c5864edac6b354", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/97e3b30285af8526f8d21072a0c6d3f231e74876/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97e3b30285af8526f8d21072a0c6d3f231e74876/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=97e3b30285af8526f8d21072a0c6d3f231e74876", "patch": "@@ -704,7 +704,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 .filter_map(|lang_item| self.tcx.lang_items().require(*lang_item).ok())\n                 .collect();\n \n-        never_suggest_borrow.push(self.tcx.get_diagnostic_item(sym::Send).unwrap());\n+        if let Some(def_id) = self.tcx.get_diagnostic_item(sym::Send) {\n+            never_suggest_borrow.push(def_id);\n+        }\n \n         let param_env = obligation.param_env;\n         let trait_ref = poly_trait_ref.skip_binder();"}, {"sha": "0373035a09ad80606117228d074bcfadf3f8b22a", "filename": "compiler/rustc_typeck/src/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 58, "deletions": 45, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/97e3b30285af8526f8d21072a0c6d3f231e74876/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97e3b30285af8526f8d21072a0c6d3f231e74876/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs?ref=97e3b30285af8526f8d21072a0c6d3f231e74876", "patch": "@@ -3,6 +3,7 @@ use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n+use rustc_index::vec::IndexVec;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::Symbol;\n use rustc_trait_selection::traits::{self, SkipLeakCheck};\n@@ -158,22 +159,26 @@ impl ItemLikeVisitor<'v> for InherentOverlapChecker<'tcx> {\n                     // This is advantageous to running the algorithm over the\n                     // entire graph when there are many connected regions.\n \n+                    rustc_index::newtype_index! {\n+                        pub struct RegionId {\n+                            ENCODABLE = custom\n+                        }\n+                    }\n                     struct ConnectedRegion {\n                         idents: SmallVec<[Symbol; 8]>,\n                         impl_blocks: FxHashSet<usize>,\n                     }\n-                    // Highest connected region id\n-                    let mut highest_region_id = 0;\n+                    let mut connected_regions: IndexVec<RegionId, _> = Default::default();\n+                    // Reverse map from the Symbol to the connected region id.\n                     let mut connected_region_ids = FxHashMap::default();\n-                    let mut connected_regions = FxHashMap::default();\n \n                     for (i, &(&_impl_def_id, impl_items)) in impls_items.iter().enumerate() {\n                         if impl_items.len() == 0 {\n                             continue;\n                         }\n                         // First obtain a list of existing connected region ids\n                         let mut idents_to_add = SmallVec::<[Symbol; 8]>::new();\n-                        let ids = impl_items\n+                        let mut ids = impl_items\n                             .in_definition_order()\n                             .filter_map(|item| {\n                                 let entry = connected_region_ids.entry(item.ident.name);\n@@ -184,62 +189,64 @@ impl ItemLikeVisitor<'v> for InherentOverlapChecker<'tcx> {\n                                     None\n                                 }\n                             })\n-                            .collect::<FxHashSet<usize>>();\n-                        match ids.len() {\n-                            0 | 1 => {\n-                                let id_to_set = if ids.is_empty() {\n-                                    // Create a new connected region\n-                                    let region = ConnectedRegion {\n+                            .collect::<SmallVec<[RegionId; 8]>>();\n+                        // Sort the id list so that the algorithm is deterministic\n+                        ids.sort_unstable();\n+                        let ids = ids;\n+                        match &ids[..] {\n+                            // Create a new connected region\n+                            [] => {\n+                                let id_to_set = connected_regions.next_index();\n+                                // Update the connected region ids\n+                                for ident in &idents_to_add {\n+                                    connected_region_ids.insert(*ident, id_to_set);\n+                                }\n+                                connected_regions.insert(\n+                                    id_to_set,\n+                                    ConnectedRegion {\n                                         idents: idents_to_add,\n                                         impl_blocks: std::iter::once(i).collect(),\n-                                    };\n-                                    connected_regions.insert(highest_region_id, region);\n-                                    (highest_region_id, highest_region_id += 1).0\n-                                } else {\n-                                    // Take the only id inside the list\n-                                    let id_to_set = *ids.iter().next().unwrap();\n-                                    let region = connected_regions.get_mut(&id_to_set).unwrap();\n-                                    region.impl_blocks.insert(i);\n-                                    region.idents.extend_from_slice(&idents_to_add);\n-                                    id_to_set\n-                                };\n-                                let (_id, region) = connected_regions.iter().next().unwrap();\n+                                    },\n+                                );\n+                            }\n+                            // Take the only id inside the list\n+                            &[id_to_set] => {\n+                                let region = connected_regions[id_to_set].as_mut().unwrap();\n+                                region.impl_blocks.insert(i);\n+                                region.idents.extend_from_slice(&idents_to_add);\n                                 // Update the connected region ids\n-                                for ident in region.idents.iter() {\n+                                for ident in &idents_to_add {\n                                     connected_region_ids.insert(*ident, id_to_set);\n                                 }\n                             }\n-                            _ => {\n-                                // We have multiple connected regions to merge.\n-                                // In the worst case this might add impl blocks\n-                                // one by one and can thus be O(n^2) in the size\n-                                // of the resulting final connected region, but\n-                                // this is no issue as the final step to check\n-                                // for overlaps runs in O(n^2) as well.\n-\n-                                // Take the smallest id from the list\n-                                let id_to_set = *ids.iter().min().unwrap();\n-\n-                                // Sort the id list so that the algorithm is deterministic\n-                                let mut ids = ids.into_iter().collect::<SmallVec<[usize; 8]>>();\n-                                ids.sort_unstable();\n-\n-                                let mut region = connected_regions.remove(&id_to_set).unwrap();\n-                                region.idents.extend_from_slice(&idents_to_add);\n+                            // We have multiple connected regions to merge.\n+                            // In the worst case this might add impl blocks\n+                            // one by one and can thus be O(n^2) in the size\n+                            // of the resulting final connected region, but\n+                            // this is no issue as the final step to check\n+                            // for overlaps runs in O(n^2) as well.\n+                            &[id_to_set, ..] => {\n+                                let mut region = connected_regions.remove(id_to_set).unwrap();\n                                 region.impl_blocks.insert(i);\n+                                region.idents.extend_from_slice(&idents_to_add);\n+                                // Update the connected region ids\n+                                for ident in &idents_to_add {\n+                                    connected_region_ids.insert(*ident, id_to_set);\n+                                }\n \n+                                // Remove other regions from ids.\n                                 for &id in ids.iter() {\n                                     if id == id_to_set {\n                                         continue;\n                                     }\n-                                    let r = connected_regions.remove(&id).unwrap();\n-                                    // Update the connected region ids\n+                                    let r = connected_regions.remove(id).unwrap();\n                                     for ident in r.idents.iter() {\n                                         connected_region_ids.insert(*ident, id_to_set);\n                                     }\n                                     region.idents.extend_from_slice(&r.idents);\n                                     region.impl_blocks.extend(r.impl_blocks);\n                                 }\n+\n                                 connected_regions.insert(id_to_set, region);\n                             }\n                         }\n@@ -254,16 +261,22 @@ impl ItemLikeVisitor<'v> for InherentOverlapChecker<'tcx> {\n                             let avg = impls.len() / connected_regions.len();\n                             let s = connected_regions\n                                 .iter()\n-                                .map(|r| r.1.impl_blocks.len() as isize - avg as isize)\n+                                .flatten()\n+                                .map(|r| r.impl_blocks.len() as isize - avg as isize)\n                                 .map(|v| v.abs() as usize)\n                                 .sum::<usize>();\n                             s / connected_regions.len()\n                         },\n-                        connected_regions.iter().map(|r| r.1.impl_blocks.len()).max().unwrap()\n+                        connected_regions\n+                            .iter()\n+                            .flatten()\n+                            .map(|r| r.impl_blocks.len())\n+                            .max()\n+                            .unwrap()\n                     );\n                     // List of connected regions is built. Now, run the overlap check\n                     // for each pair of impl blocks in the same connected region.\n-                    for (_id, region) in connected_regions.into_iter() {\n+                    for region in connected_regions.into_iter().flatten() {\n                         let mut impl_blocks =\n                             region.impl_blocks.into_iter().collect::<SmallVec<[usize; 8]>>();\n                         impl_blocks.sort_unstable();"}, {"sha": "971776c882a157e4946fbe714bb2a54cafb375fd", "filename": "compiler/rustc_typeck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/97e3b30285af8526f8d21072a0c6d3f231e74876/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97e3b30285af8526f8d21072a0c6d3f231e74876/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Flib.rs?ref=97e3b30285af8526f8d21072a0c6d3f231e74876", "patch": "@@ -63,6 +63,7 @@ This API is completely unstable and subject to change.\n #![feature(in_band_lifetimes)]\n #![feature(is_sorted)]\n #![feature(iter_zip)]\n+#![feature(min_specialization)]\n #![feature(nll)]\n #![feature(try_blocks)]\n #![feature(never_type)]"}, {"sha": "e5c3fafe5f1f0a1b097eecc34af57f8ee92430d9", "filename": "library/core/src/marker.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/97e3b30285af8526f8d21072a0c6d3f231e74876/library%2Fcore%2Fsrc%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97e3b30285af8526f8d21072a0c6d3f231e74876/library%2Fcore%2Fsrc%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmarker.rs?ref=97e3b30285af8526f8d21072a0c6d3f231e74876", "patch": "@@ -30,7 +30,8 @@ use crate::hash::Hasher;\n /// [arc]: ../../std/sync/struct.Arc.html\n /// [ub]: ../../reference/behavior-considered-undefined.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg_attr(not(test), rustc_diagnostic_item = \"Send\")]\n+#[cfg_attr(all(not(test), bootstrap), rustc_diagnostic_item = \"send_trait\")]\n+#[cfg_attr(all(not(test), not(bootstrap)), rustc_diagnostic_item = \"Send\")]\n #[rustc_on_unimplemented(\n     message = \"`{Self}` cannot be sent between threads safely\",\n     label = \"`{Self}` cannot be sent between threads safely\""}, {"sha": "71a67a2793a46bfa83331c7a93d6f80d089ec2ef", "filename": "library/core/src/task/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/97e3b30285af8526f8d21072a0c6d3f231e74876/library%2Fcore%2Fsrc%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97e3b30285af8526f8d21072a0c6d3f231e74876/library%2Fcore%2Fsrc%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftask%2Fmod.rs?ref=97e3b30285af8526f8d21072a0c6d3f231e74876", "patch": "@@ -11,5 +11,7 @@ mod wake;\n pub use self::wake::{Context, RawWaker, RawWakerVTable, Waker};\n \n mod ready;\n-#[stable(feature = \"ready_macro\", since = \"1.56.0\")]\n+#[unstable(feature = \"ready_macro\", issue = \"70922\")]\n pub use ready::ready;\n+#[unstable(feature = \"poll_ready\", issue = \"89780\")]\n+pub use ready::Ready;"}, {"sha": "3e0b3e89758a64ac2e3824955320730fffd1f67a", "filename": "library/core/src/task/poll.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/97e3b30285af8526f8d21072a0c6d3f231e74876/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97e3b30285af8526f8d21072a0c6d3f231e74876/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs?ref=97e3b30285af8526f8d21072a0c6d3f231e74876", "patch": "@@ -3,6 +3,7 @@\n use crate::convert;\n use crate::ops::{self, ControlFlow};\n use crate::result::Result;\n+use crate::task::Ready;\n \n /// Indicates whether a value is available or if the current task has been\n /// scheduled to receive a wakeup instead.\n@@ -92,6 +93,38 @@ impl<T> Poll<T> {\n     pub const fn is_pending(&self) -> bool {\n         !self.is_ready()\n     }\n+\n+    /// Extracts the successful type of a [`Poll<T>`].\n+    ///\n+    /// When combined with the `?` operator, this function will\n+    /// propogate any [`Poll::Pending`] values to the caller, and\n+    /// extract the `T` from [`Poll::Ready`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// #![feature(poll_ready)]\n+    ///\n+    /// use std::task::{Context, Poll};\n+    /// use std::future::{self, Future};\n+    /// use std::pin::Pin;\n+    ///\n+    /// pub fn do_poll(cx: &mut Context<'_>) -> Poll<()> {\n+    ///     let mut fut = future::ready(42);\n+    ///     let fut = Pin::new(&mut fut);\n+    ///\n+    ///     let num = fut.poll(cx).ready()?;\n+    ///     # drop(num);\n+    ///     // ... use num\n+    ///\n+    ///     Poll::Ready(())\n+    /// }\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"poll_ready\", issue = \"89780\")]\n+    pub fn ready(self) -> Ready<T> {\n+        Ready(self)\n+    }\n }\n \n impl<T, E> Poll<Result<T, E>> {"}, {"sha": "174ca67546033d2aa4942b3a03971f8d1c8069b0", "filename": "library/core/src/task/ready.rs", "status": "modified", "additions": 61, "deletions": 1, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/97e3b30285af8526f8d21072a0c6d3f231e74876/library%2Fcore%2Fsrc%2Ftask%2Fready.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97e3b30285af8526f8d21072a0c6d3f231e74876/library%2Fcore%2Fsrc%2Ftask%2Fready.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftask%2Fready.rs?ref=97e3b30285af8526f8d21072a0c6d3f231e74876", "patch": "@@ -1,3 +1,8 @@\n+use core::convert;\n+use core::fmt;\n+use core::ops::{ControlFlow, FromResidual, Try};\n+use core::task::Poll;\n+\n /// Extracts the successful type of a [`Poll<T>`].\n ///\n /// This macro bakes in propagation of [`Pending`] signals by returning early.\n@@ -8,6 +13,8 @@\n /// # Examples\n ///\n /// ```\n+/// #![feature(ready_macro)]\n+///\n /// use std::task::{ready, Context, Poll};\n /// use std::future::{self, Future};\n /// use std::pin::Pin;\n@@ -27,6 +34,7 @@\n /// The `ready!` call expands to:\n ///\n /// ```\n+/// # #![feature(ready_macro)]\n /// # use std::task::{Context, Poll};\n /// # use std::future::{self, Future};\n /// # use std::pin::Pin;\n@@ -45,7 +53,7 @@\n ///     # Poll::Ready(())\n /// # }\n /// ```\n-#[stable(feature = \"ready_macro\", since = \"1.56.0\")]\n+#[unstable(feature = \"ready_macro\", issue = \"70922\")]\n #[rustc_macro_transparency = \"semitransparent\"]\n pub macro ready($e:expr) {\n     match $e {\n@@ -55,3 +63,55 @@ pub macro ready($e:expr) {\n         }\n     }\n }\n+\n+/// Extracts the successful type of a [`Poll<T>`].\n+///\n+/// See [`Poll::ready`] for details.\n+#[unstable(feature = \"poll_ready\", issue = \"89780\")]\n+pub struct Ready<T>(pub(crate) Poll<T>);\n+\n+#[unstable(feature = \"poll_ready\", issue = \"89780\")]\n+impl<T> Try for Ready<T> {\n+    type Output = T;\n+    type Residual = Ready<convert::Infallible>;\n+\n+    #[inline]\n+    fn from_output(output: Self::Output) -> Self {\n+        Ready(Poll::Ready(output))\n+    }\n+\n+    #[inline]\n+    fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {\n+        match self.0 {\n+            Poll::Ready(v) => ControlFlow::Continue(v),\n+            Poll::Pending => ControlFlow::Break(Ready(Poll::Pending)),\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"poll_ready\", issue = \"89780\")]\n+impl<T> FromResidual for Ready<T> {\n+    #[inline]\n+    fn from_residual(residual: Ready<convert::Infallible>) -> Self {\n+        match residual.0 {\n+            Poll::Pending => Ready(Poll::Pending),\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"poll_ready\", issue = \"89780\")]\n+impl<T> FromResidual<Ready<convert::Infallible>> for Poll<T> {\n+    #[inline]\n+    fn from_residual(residual: Ready<convert::Infallible>) -> Self {\n+        match residual.0 {\n+            Poll::Pending => Poll::Pending,\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"poll_ready\", issue = \"89780\")]\n+impl<T> fmt::Debug for Ready<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"Ready\").finish()\n+    }\n+}"}, {"sha": "1859130a7af5af35b6d3bf4a97588d63e4dde538", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/97e3b30285af8526f8d21072a0c6d3f231e74876/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/97e3b30285af8526f8d21072a0c6d3f231e74876/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=97e3b30285af8526f8d21072a0c6d3f231e74876", "patch": "@@ -933,10 +933,9 @@ def build_bootstrap(self):\n         env[\"LIBRARY_PATH\"] = os.path.join(self.bin_root(True), \"lib\") + \\\n             (os.pathsep + env[\"LIBRARY_PATH\"]) \\\n             if \"LIBRARY_PATH\" in env else \"\"\n+\n         # preserve existing RUSTFLAGS\n         env.setdefault(\"RUSTFLAGS\", \"\")\n-        env[\"RUSTFLAGS\"] += \" -Cdebuginfo=2\"\n-\n         build_section = \"target.{}\".format(self.build)\n         target_features = []\n         if self.get_toml(\"crt-static\", build_section) == \"true\":"}, {"sha": "7df7a36f540dd91727b776253aa834f5b235de8c", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/97e3b30285af8526f8d21072a0c6d3f231e74876/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97e3b30285af8526f8d21072a0c6d3f231e74876/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=97e3b30285af8526f8d21072a0c6d3f231e74876", "patch": "@@ -1342,12 +1342,6 @@ impl<'a> Builder<'a> {\n                 rustdocflags.arg(\"-Dwarnings\");\n             }\n \n-            // FIXME(#58633) hide \"unused attribute\" errors in incremental\n-            // builds of the standard library, as the underlying checks are\n-            // not yet properly integrated with incremental recompilation.\n-            if mode == Mode::Std && compiler.stage == 0 && self.config.incremental {\n-                lint_flags.push(\"-Aunused-attributes\");\n-            }\n             // This does not use RUSTFLAGS due to caching issues with Cargo.\n             // Clippy is treated as an \"in tree\" tool, but shares the same\n             // cache as other \"submodule\" tools. With these options set in"}, {"sha": "61d5fc93cd2ad5b7b985d15c07dbcecff0568fa4", "filename": "src/test/debuginfo/function-names.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/97e3b30285af8526f8d21072a0c6d3f231e74876/src%2Ftest%2Fdebuginfo%2Ffunction-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97e3b30285af8526f8d21072a0c6d3f231e74876/src%2Ftest%2Fdebuginfo%2Ffunction-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ffunction-names.rs?ref=97e3b30285af8526f8d21072a0c6d3f231e74876", "patch": "@@ -9,36 +9,37 @@\n // gdb-command:info functions -q function_names::main\n // gdb-check:[...]static fn function_names::main();\n // gdb-command:info functions -q function_names::generic_func<*\n-// gdb-check:[...]static fn function_names::generic_func(i32) -> i32;\n+// gdb-check:[...]static fn function_names::generic_func<i32>(i32) -> i32;\n \n // Implementations\n // gdb-command:info functions -q function_names::.*::impl_function.*\n-// gdb-check:[...]static fn function_names::GenericStruct<T1,T2>::impl_function();\n+// gdb-check:[...]static fn function_names::GenericStruct<i32, i32>::impl_function<i32, i32>();\n // gdb-check:[...]static fn function_names::Mod1::TestStruct2::impl_function();\n // gdb-check:[...]static fn function_names::TestStruct1::impl_function();\n \n // Trait implementations\n // gdb-command:info functions -q function_names::.*::trait_function.*\n-// gdb-check:[...]static fn <function_names::GenericStruct<T,i32> as function_names::TestTrait1>::trait_function();\n-// gdb-check:[...]static fn <function_names::GenericStruct<[T; N],f32> as function_names::TestTrait1>::trait_function();\n-// gdb-check:[...]static fn <function_names::Mod1::TestStruct2 as function_names::Mod1::TestTrait2>::trait_function();\n-// gdb-check:[...]static fn <function_names::TestStruct1 as function_names::TestTrait1>::trait_function();\n+// gdb-check:[...]static fn function_names::Mod1::{impl#1}::trait_function();\n+// gdb-check:[...]static fn function_names::{impl#1}::trait_function();\n+// gdb-check:[...]static fn function_names::{impl#3}::trait_function<i32>();\n+// gdb-check:[...]static fn function_names::{impl#5}::trait_function3<function_names::TestStruct1>();\n+// gdb-check:[...]static fn function_names::{impl#6}::trait_function<i32, 1>();\n \n // Closure\n-// gdb-command:info functions -q function_names::.*::{{closure.*\n-// gdb-check:[...]static fn function_names::GenericStruct<T1,T2>::impl_function::{{closure}}(*mut function_names::{impl#2}::impl_function::{closure#0});\n-// gdb-check:[...]static fn function_names::generic_func::{{closure}}(*mut function_names::generic_func::{closure#0});\n-// gdb-check:[...]static fn function_names::main::{{closure}}(*mut function_names::main::{closure#0});\n+// gdb-command:info functions -q function_names::.*::{closure.*\n+// gdb-check:[...]static fn function_names::generic_func::{closure#0}<i32>(*mut function_names::generic_func::{closure#0});\n+// gdb-check:[...]static fn function_names::main::{closure#0}(*mut function_names::main::{closure#0});\n+// gdb-check:[...]static fn function_names::{impl#2}::impl_function::{closure#0}<i32, i32>(*mut function_names::{impl#2}::impl_function::{closure#0});\n \n // Generator\n // Generators don't seem to appear in GDB's symbol table.\n \n // Const generic parameter\n // gdb-command:info functions -q function_names::const_generic_fn.*\n-// gdb-check:[...]static fn function_names::const_generic_fn_bool();\n-// gdb-check:[...]static fn function_names::const_generic_fn_non_int();\n-// gdb-check:[...]static fn function_names::const_generic_fn_signed_int();\n-// gdb-check:[...]static fn function_names::const_generic_fn_unsigned_int();\n+// gdb-check:[...]static fn function_names::const_generic_fn_bool<false>();\n+// gdb-check:[...]static fn function_names::const_generic_fn_non_int<{CONST#fe3cfa0214ac55c7}>();\n+// gdb-check:[...]static fn function_names::const_generic_fn_signed_int<-7>();\n+// gdb-check:[...]static fn function_names::const_generic_fn_unsigned_int<14>();\n \n // === CDB TESTS ===================================================================================\n \n@@ -103,7 +104,7 @@ fn main() {\n     GenericStruct::<TestStruct1, usize>::trait_function3();\n \n     // Generic function\n-    let _ = generic_func(42);\n+    let _ = generic_func(42i32);\n \n     // Closure\n     let closure = || { TestStruct1 };"}, {"sha": "8eefb375b8c1b9346b1520f9a7c7abeb6c6996bd", "filename": "src/test/ui/rfc-2632-const-trait-impl/impl-with-default-fn-fail.rs", "status": "renamed", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/97e3b30285af8526f8d21072a0c6d3f231e74876/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fimpl-with-default-fn-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97e3b30285af8526f8d21072a0c6d3f231e74876/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fimpl-with-default-fn-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fimpl-with-default-fn-fail.rs?ref=97e3b30285af8526f8d21072a0c6d3f231e74876", "patch": "@@ -1,4 +1,5 @@\n #![feature(const_trait_impl)]\n+#![feature(const_fn_trait_bound)]\n \n trait Tr {\n     fn req(&self);\n@@ -18,11 +19,6 @@ impl const Tr for S {\n     fn req(&self) {}\n } //~^^ ERROR const trait implementations may not use non-const default functions\n \n-impl const Tr for u8 {\n-    fn req(&self) {}\n-    fn prov(&self) {}\n-}\n-\n impl const Tr for u16 {\n     fn prov(&self) {}\n     fn default() {}", "previous_filename": "src/test/ui/rfc-2632-const-trait-impl/impl-with-default-fn.rs"}, {"sha": "a0916797041114b373ce94bbf1a541db340269fb", "filename": "src/test/ui/rfc-2632-const-trait-impl/impl-with-default-fn-fail.stderr", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/97e3b30285af8526f8d21072a0c6d3f231e74876/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fimpl-with-default-fn-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/97e3b30285af8526f8d21072a0c6d3f231e74876/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fimpl-with-default-fn-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fimpl-with-default-fn-fail.stderr?ref=97e3b30285af8526f8d21072a0c6d3f231e74876", "patch": "@@ -1,5 +1,5 @@\n error: const trait implementations may not use non-const default functions\n-  --> $DIR/impl-with-default-fn.rs:17:1\n+  --> $DIR/impl-with-default-fn-fail.rs:18:1\n    |\n LL | / impl const Tr for S {\n LL | |     fn req(&self) {}\n@@ -9,7 +9,7 @@ LL | | }\n    = note: `prov` not implemented\n \n error: const trait implementations may not use non-const default functions\n-  --> $DIR/impl-with-default-fn.rs:32:1\n+  --> $DIR/impl-with-default-fn-fail.rs:28:1\n    |\n LL | / impl const Tr for u32 {\n LL | |     fn req(&self) {}\n@@ -20,7 +20,7 @@ LL | | }\n    = note: `prov` not implemented\n \n error[E0046]: not all trait items implemented, missing: `req`\n-  --> $DIR/impl-with-default-fn.rs:26:1\n+  --> $DIR/impl-with-default-fn-fail.rs:22:1\n    |\n LL |     fn req(&self);\n    |     -------------- `req` from trait", "previous_filename": "src/test/ui/rfc-2632-const-trait-impl/impl-with-default-fn.stderr"}, {"sha": "ba3fec0882b02e306b3fd9919cfb1ca83d477a71", "filename": "src/test/ui/rfc-2632-const-trait-impl/impl-with-default-fn-pass.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/97e3b30285af8526f8d21072a0c6d3f231e74876/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fimpl-with-default-fn-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97e3b30285af8526f8d21072a0c6d3f231e74876/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fimpl-with-default-fn-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fimpl-with-default-fn-pass.rs?ref=97e3b30285af8526f8d21072a0c6d3f231e74876", "patch": "@@ -0,0 +1,34 @@\n+// check-pass\n+\n+#![feature(const_trait_impl)]\n+#![feature(const_fn_trait_bound)]\n+\n+trait Tr {\n+    fn req(&self);\n+\n+    fn prov(&self) {\n+        println!(\"lul\");\n+        self.req();\n+    }\n+\n+    #[default_method_body_is_const]\n+    fn default() {}\n+}\n+\n+impl const Tr for u8 {\n+    fn req(&self) {}\n+    fn prov(&self) {}\n+}\n+\n+macro_rules! impl_tr {\n+    ($ty: ty) => {\n+        impl const Tr for $ty {\n+            fn req(&self) {}\n+            fn prov(&self) {}\n+        }\n+    }\n+}\n+\n+impl_tr!(u64);\n+\n+fn main() {}"}, {"sha": "ce169867b7b1d851d5f38977bf4a41a79c405b21", "filename": "src/tools/tidy/src/error_codes_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97e3b30285af8526f8d21072a0c6d3f231e74876/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97e3b30285af8526f8d21072a0c6d3f231e74876/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs?ref=97e3b30285af8526f8d21072a0c6d3f231e74876", "patch": "@@ -11,7 +11,7 @@ use regex::Regex;\n // A few of those error codes can't be tested but all the others can and *should* be tested!\n const EXEMPTED_FROM_TEST: &[&str] = &[\n     \"E0227\", \"E0279\", \"E0280\", \"E0313\", \"E0377\", \"E0461\", \"E0462\", \"E0464\", \"E0465\", \"E0476\",\n-    \"E0482\", \"E0514\", \"E0519\", \"E0523\", \"E0554\", \"E0640\", \"E0717\", \"E0729\",\n+    \"E0514\", \"E0519\", \"E0523\", \"E0554\", \"E0640\", \"E0717\", \"E0729\",\n ];\n \n // Some error codes don't have any tests apparently..."}]}