{"sha": "d012a20f257571124bef303b2d9bef185e91c13b", "node_id": "C_kwDOAAsO6NoAKGQwMTJhMjBmMjU3NTcxMTI0YmVmMzAzYjJkOWJlZjE4NWU5MWMxM2I", "commit": {"author": {"name": "Lauren\u021biu Nicola", "email": "lnicola@dend.ro", "date": "2021-12-10T14:24:07Z"}, "committer": {"name": "Lauren\u021biu Nicola", "email": "lnicola@dend.ro", "date": "2021-12-10T14:24:07Z"}, "message": "Only prime direct dependencies of the workspace crates", "tree": {"sha": "fa928d0768fb04d721d1cf1a80337e9b745fe0df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa928d0768fb04d721d1cf1a80337e9b745fe0df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d012a20f257571124bef303b2d9bef185e91c13b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d012a20f257571124bef303b2d9bef185e91c13b", "html_url": "https://github.com/rust-lang/rust/commit/d012a20f257571124bef303b2d9bef185e91c13b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d012a20f257571124bef303b2d9bef185e91c13b/comments", "author": {"login": "lnicola", "id": 308347, "node_id": "MDQ6VXNlcjMwODM0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/308347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lnicola", "html_url": "https://github.com/lnicola", "followers_url": "https://api.github.com/users/lnicola/followers", "following_url": "https://api.github.com/users/lnicola/following{/other_user}", "gists_url": "https://api.github.com/users/lnicola/gists{/gist_id}", "starred_url": "https://api.github.com/users/lnicola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lnicola/subscriptions", "organizations_url": "https://api.github.com/users/lnicola/orgs", "repos_url": "https://api.github.com/users/lnicola/repos", "events_url": "https://api.github.com/users/lnicola/events{/privacy}", "received_events_url": "https://api.github.com/users/lnicola/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lnicola", "id": 308347, "node_id": "MDQ6VXNlcjMwODM0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/308347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lnicola", "html_url": "https://github.com/lnicola", "followers_url": "https://api.github.com/users/lnicola/followers", "following_url": "https://api.github.com/users/lnicola/following{/other_user}", "gists_url": "https://api.github.com/users/lnicola/gists{/gist_id}", "starred_url": "https://api.github.com/users/lnicola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lnicola/subscriptions", "organizations_url": "https://api.github.com/users/lnicola/orgs", "repos_url": "https://api.github.com/users/lnicola/repos", "events_url": "https://api.github.com/users/lnicola/events{/privacy}", "received_events_url": "https://api.github.com/users/lnicola/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2534b7db1a093543d5bd759b3a1ca9e34418fa31", "url": "https://api.github.com/repos/rust-lang/rust/commits/2534b7db1a093543d5bd759b3a1ca9e34418fa31", "html_url": "https://github.com/rust-lang/rust/commit/2534b7db1a093543d5bd759b3a1ca9e34418fa31"}], "stats": {"total": 31, "additions": 10, "deletions": 21}, "files": [{"sha": "5eba1d1e276f49c54ce4c7f4ef63c41b6749f53e", "filename": "crates/ide/src/prime_caches.rs", "status": "modified", "additions": 10, "deletions": 21, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d012a20f257571124bef303b2d9bef185e91c13b/crates%2Fide%2Fsrc%2Fprime_caches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d012a20f257571124bef303b2d9bef185e91c13b/crates%2Fide%2Fsrc%2Fprime_caches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fprime_caches.rs?ref=d012a20f257571124bef303b2d9bef185e91c13b", "patch": "@@ -4,7 +4,7 @@\n //! various caches, it's not really advanced at the moment.\n \n use hir::db::DefDatabase;\n-use ide_db::base_db::{CrateGraph, CrateId, SourceDatabase, SourceDatabaseExt};\n+use ide_db::base_db::{SourceDatabase, SourceDatabaseExt};\n use rustc_hash::FxHashSet;\n \n use crate::RootDatabase;\n@@ -20,40 +20,29 @@ pub struct PrimeCachesProgress {\n pub(crate) fn prime_caches(db: &RootDatabase, cb: &(dyn Fn(PrimeCachesProgress) + Sync)) {\n     let _p = profile::span(\"prime_caches\");\n     let graph = db.crate_graph();\n-    // We're only interested in the transitive dependencies of all workspace crates.\n+    // We're only interested in the workspace crates and the `ImportMap`s of their direct\n+    // dependencies, though in practice the latter also compute the `DefMap`s.\n+    // We don't prime transitive dependencies because they're generally not visible in\n+    // the current workspace.\n     let to_prime: FxHashSet<_> = graph\n         .iter()\n         .filter(|&id| {\n             let file_id = graph[id].root_file_id;\n             let root_id = db.file_source_root(file_id);\n             !db.source_root(root_id).is_library\n         })\n-        .flat_map(|id| graph.transitive_deps(id))\n+        .flat_map(|id| graph[id].dependencies.iter().map(|krate| krate.crate_id))\n         .collect();\n \n-    let topo = toposort(&graph, &to_prime);\n-\n     // FIXME: This would be easy to parallelize, since it's in the ideal ordering for that.\n     // Unfortunately rayon prevents panics from propagation out of a `scope`, which breaks\n     // cancellation, so we cannot use rayon.\n-    for (i, &crate_id) in topo.iter().enumerate() {\n+    let n_total = to_prime.len();\n+    for (n_done, &crate_id) in to_prime.iter().enumerate() {\n         let crate_name = graph[crate_id].display_name.as_deref().unwrap_or_default().to_string();\n \n-        cb(PrimeCachesProgress { on_crate: crate_name, n_done: i, n_total: topo.len() });\n-        db.crate_def_map(crate_id);\n+        cb(PrimeCachesProgress { on_crate: crate_name, n_done, n_total });\n+        // This also computes the DefMap\n         db.import_map(crate_id);\n     }\n }\n-\n-fn toposort(graph: &CrateGraph, crates: &FxHashSet<CrateId>) -> Vec<CrateId> {\n-    // Just subset the full topologically sorted set for simplicity.\n-\n-    let all = graph.crates_in_topological_order();\n-    let mut result = Vec::with_capacity(crates.len());\n-    for krate in all {\n-        if crates.contains(&krate) {\n-            result.push(krate);\n-        }\n-    }\n-    result\n-}"}]}