{"sha": "e6a4383bb475b866b67df6bb83ecbdf823d73667", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2YTQzODNiYjQ3NWI4NjZiNjdkZjZiYjgzZWNiZGY4MjNkNzM2Njc=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-08T15:16:26Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-08T15:16:26Z"}, "message": "move call-info to a separate file", "tree": {"sha": "6dbf7da77cd26e44597c40d1b5c802c552007ae8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6dbf7da77cd26e44597c40d1b5c802c552007ae8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6a4383bb475b866b67df6bb83ecbdf823d73667", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6a4383bb475b866b67df6bb83ecbdf823d73667", "html_url": "https://github.com/rust-lang/rust/commit/e6a4383bb475b866b67df6bb83ecbdf823d73667", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6a4383bb475b866b67df6bb83ecbdf823d73667/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f07976cb51f7be216678f410175ba4c09bc7e71", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f07976cb51f7be216678f410175ba4c09bc7e71", "html_url": "https://github.com/rust-lang/rust/commit/2f07976cb51f7be216678f410175ba4c09bc7e71"}], "stats": {"total": 248, "additions": 130, "deletions": 118}, "files": [{"sha": "a31a54ef6f23bd1d7dab6ac47905f467a41ca9d9", "filename": "crates/ra_analysis/src/call_info.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/e6a4383bb475b866b67df6bb83ecbdf823d73667/crates%2Fra_analysis%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6a4383bb475b866b67df6bb83ecbdf823d73667/crates%2Fra_analysis%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcall_info.rs?ref=e6a4383bb475b866b67df6bb83ecbdf823d73667", "patch": "@@ -0,0 +1,119 @@\n+use ra_db::{SyntaxDatabase, Cancelable};\n+use ra_syntax::{\n+    AstNode, SyntaxNode, TextUnit, TextRange,\n+    SyntaxKind::FN_DEF,\n+    ast::{self, ArgListOwner},\n+};\n+use ra_editor::find_node_at_offset;\n+use hir::FnSignatureInfo;\n+\n+use crate::{FilePosition, db::RootDatabase};\n+\n+/// Computes parameter information for the given call expression.\n+pub(crate) fn call_info(\n+    db: &RootDatabase,\n+    position: FilePosition,\n+) -> Cancelable<Option<(FnSignatureInfo, Option<usize>)>> {\n+    let file = db.source_file(position.file_id);\n+    let syntax = file.syntax();\n+\n+    // Find the calling expression and it's NameRef\n+    let calling_node = ctry!(FnCallNode::with_node(syntax, position.offset));\n+    let name_ref = ctry!(calling_node.name_ref());\n+\n+    // Resolve the function's NameRef (NOTE: this isn't entirely accurate).\n+    let file_symbols = db.index_resolve(name_ref)?;\n+    for symbol in file_symbols {\n+        if symbol.ptr.kind() == FN_DEF {\n+            let fn_file = db.source_file(symbol.file_id);\n+            let fn_def = symbol.ptr.resolve(&fn_file);\n+            let fn_def = ast::FnDef::cast(&fn_def).unwrap();\n+            let descr = ctry!(hir::source_binder::function_from_source(\n+                db,\n+                symbol.file_id,\n+                fn_def\n+            )?);\n+            if let Some(descriptor) = descr.signature_info(db) {\n+                // If we have a calling expression let's find which argument we are on\n+                let mut current_parameter = None;\n+\n+                let num_params = descriptor.params.len();\n+                let has_self = fn_def.param_list().and_then(|l| l.self_param()).is_some();\n+\n+                if num_params == 1 {\n+                    if !has_self {\n+                        current_parameter = Some(0);\n+                    }\n+                } else if num_params > 1 {\n+                    // Count how many parameters into the call we are.\n+                    // TODO: This is best effort for now and should be fixed at some point.\n+                    // It may be better to see where we are in the arg_list and then check\n+                    // where offset is in that list (or beyond).\n+                    // Revisit this after we get documentation comments in.\n+                    if let Some(ref arg_list) = calling_node.arg_list() {\n+                        let start = arg_list.syntax().range().start();\n+\n+                        let range_search = TextRange::from_to(start, position.offset);\n+                        let mut commas: usize = arg_list\n+                            .syntax()\n+                            .text()\n+                            .slice(range_search)\n+                            .to_string()\n+                            .matches(',')\n+                            .count();\n+\n+                        // If we have a method call eat the first param since it's just self.\n+                        if has_self {\n+                            commas += 1;\n+                        }\n+\n+                        current_parameter = Some(commas);\n+                    }\n+                }\n+\n+                return Ok(Some((descriptor, current_parameter)));\n+            }\n+        }\n+    }\n+\n+    Ok(None)\n+}\n+\n+enum FnCallNode<'a> {\n+    CallExpr(&'a ast::CallExpr),\n+    MethodCallExpr(&'a ast::MethodCallExpr),\n+}\n+\n+impl<'a> FnCallNode<'a> {\n+    pub fn with_node(syntax: &'a SyntaxNode, offset: TextUnit) -> Option<FnCallNode<'a>> {\n+        if let Some(expr) = find_node_at_offset::<ast::CallExpr>(syntax, offset) {\n+            return Some(FnCallNode::CallExpr(expr));\n+        }\n+        if let Some(expr) = find_node_at_offset::<ast::MethodCallExpr>(syntax, offset) {\n+            return Some(FnCallNode::MethodCallExpr(expr));\n+        }\n+        None\n+    }\n+\n+    pub fn name_ref(&self) -> Option<&'a ast::NameRef> {\n+        match *self {\n+            FnCallNode::CallExpr(call_expr) => Some(match call_expr.expr()?.kind() {\n+                ast::ExprKind::PathExpr(path_expr) => path_expr.path()?.segment()?.name_ref()?,\n+                _ => return None,\n+            }),\n+\n+            FnCallNode::MethodCallExpr(call_expr) => call_expr\n+                .syntax()\n+                .children()\n+                .filter_map(ast::NameRef::cast)\n+                .nth(0),\n+        }\n+    }\n+\n+    pub fn arg_list(&self) -> Option<&'a ast::ArgList> {\n+        match *self {\n+            FnCallNode::CallExpr(expr) => expr.arg_list(),\n+            FnCallNode::MethodCallExpr(expr) => expr.arg_list(),\n+        }\n+    }\n+}"}, {"sha": "b3f75fdbebcccc0b6281a85c3207160e2989c698", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 3, "deletions": 111, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/e6a4383bb475b866b67df6bb83ecbdf823d73667/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6a4383bb475b866b67df6bb83ecbdf823d73667/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=e6a4383bb475b866b67df6bb83ecbdf823d73667", "patch": "@@ -3,13 +3,13 @@ use std::sync::Arc;\n use salsa::Database;\n \n use hir::{\n-    self, FnSignatureInfo, Problem, source_binder,\n+    self, Problem, source_binder,\n };\n use ra_db::{FilesDatabase, SourceRoot, SourceRootId, SyntaxDatabase};\n use ra_editor::{self, find_node_at_offset, assists, LocalEdit, Severity};\n use ra_syntax::{\n-    SyntaxNode, TextRange, TextUnit, AstNode, SourceFile,\n-    ast::{self, ArgListOwner, NameOwner},\n+    TextRange, AstNode, SourceFile,\n+    ast::{self, NameOwner},\n     SyntaxKind::*,\n };\n \n@@ -262,75 +262,6 @@ impl db::RootDatabase {\n             .collect()\n     }\n \n-    pub(crate) fn resolve_callable(\n-        &self,\n-        position: FilePosition,\n-    ) -> Cancelable<Option<(FnSignatureInfo, Option<usize>)>> {\n-        let file = self.source_file(position.file_id);\n-        let syntax = file.syntax();\n-\n-        // Find the calling expression and it's NameRef\n-        let calling_node = ctry!(FnCallNode::with_node(syntax, position.offset));\n-        let name_ref = ctry!(calling_node.name_ref());\n-\n-        // Resolve the function's NameRef (NOTE: this isn't entirely accurate).\n-        let file_symbols = self.index_resolve(name_ref)?;\n-        for symbol in file_symbols {\n-            if symbol.ptr.kind() == FN_DEF {\n-                let fn_file = self.source_file(symbol.file_id);\n-                let fn_def = symbol.ptr.resolve(&fn_file);\n-                let fn_def = ast::FnDef::cast(&fn_def).unwrap();\n-                let descr = ctry!(source_binder::function_from_source(\n-                    self,\n-                    symbol.file_id,\n-                    fn_def\n-                )?);\n-                if let Some(descriptor) = descr.signature_info(self) {\n-                    // If we have a calling expression let's find which argument we are on\n-                    let mut current_parameter = None;\n-\n-                    let num_params = descriptor.params.len();\n-                    let has_self = fn_def.param_list().and_then(|l| l.self_param()).is_some();\n-\n-                    if num_params == 1 {\n-                        if !has_self {\n-                            current_parameter = Some(0);\n-                        }\n-                    } else if num_params > 1 {\n-                        // Count how many parameters into the call we are.\n-                        // TODO: This is best effort for now and should be fixed at some point.\n-                        // It may be better to see where we are in the arg_list and then check\n-                        // where offset is in that list (or beyond).\n-                        // Revisit this after we get documentation comments in.\n-                        if let Some(ref arg_list) = calling_node.arg_list() {\n-                            let start = arg_list.syntax().range().start();\n-\n-                            let range_search = TextRange::from_to(start, position.offset);\n-                            let mut commas: usize = arg_list\n-                                .syntax()\n-                                .text()\n-                                .slice(range_search)\n-                                .to_string()\n-                                .matches(',')\n-                                .count();\n-\n-                            // If we have a method call eat the first param since it's just self.\n-                            if has_self {\n-                                commas += 1;\n-                            }\n-\n-                            current_parameter = Some(commas);\n-                        }\n-                    }\n-\n-                    return Ok(Some((descriptor, current_parameter)));\n-                }\n-            }\n-        }\n-\n-        Ok(None)\n-    }\n-\n     pub(crate) fn rename(\n         &self,\n         position: FilePosition,\n@@ -375,42 +306,3 @@ impl SourceChange {\n         }\n     }\n }\n-\n-enum FnCallNode<'a> {\n-    CallExpr(&'a ast::CallExpr),\n-    MethodCallExpr(&'a ast::MethodCallExpr),\n-}\n-\n-impl<'a> FnCallNode<'a> {\n-    pub fn with_node(syntax: &'a SyntaxNode, offset: TextUnit) -> Option<FnCallNode<'a>> {\n-        if let Some(expr) = find_node_at_offset::<ast::CallExpr>(syntax, offset) {\n-            return Some(FnCallNode::CallExpr(expr));\n-        }\n-        if let Some(expr) = find_node_at_offset::<ast::MethodCallExpr>(syntax, offset) {\n-            return Some(FnCallNode::MethodCallExpr(expr));\n-        }\n-        None\n-    }\n-\n-    pub fn name_ref(&self) -> Option<&'a ast::NameRef> {\n-        match *self {\n-            FnCallNode::CallExpr(call_expr) => Some(match call_expr.expr()?.kind() {\n-                ast::ExprKind::PathExpr(path_expr) => path_expr.path()?.segment()?.name_ref()?,\n-                _ => return None,\n-            }),\n-\n-            FnCallNode::MethodCallExpr(call_expr) => call_expr\n-                .syntax()\n-                .children()\n-                .filter_map(ast::NameRef::cast)\n-                .nth(0),\n-        }\n-    }\n-\n-    pub fn arg_list(&self) -> Option<&'a ast::ArgList> {\n-        match *self {\n-            FnCallNode::CallExpr(expr) => expr.arg_list(),\n-            FnCallNode::MethodCallExpr(expr) => expr.arg_list(),\n-        }\n-    }\n-}"}, {"sha": "9192f66e825cee46273891d0d2d010cc6fe980d8", "filename": "crates/ra_analysis/src/lib.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e6a4383bb475b866b67df6bb83ecbdf823d73667/crates%2Fra_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6a4383bb475b866b67df6bb83ecbdf823d73667/crates%2Fra_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Flib.rs?ref=e6a4383bb475b866b67df6bb83ecbdf823d73667", "patch": "@@ -22,6 +22,7 @@ mod symbol_index;\n \n mod extend_selection;\n mod hover;\n+mod call_info;\n mod syntax_highlighting;\n \n use std::{fmt, sync::Arc};\n@@ -391,6 +392,13 @@ impl Analysis {\n     pub fn hover(&self, position: FilePosition) -> Cancelable<Option<RangeInfo<String>>> {\n         hover::hover(&*self.db, position)\n     }\n+    /// Computes parameter information for the given call expression.\n+    pub fn call_info(\n+        &self,\n+        position: FilePosition,\n+    ) -> Cancelable<Option<(FnSignatureInfo, Option<usize>)>> {\n+        call_info::call_info(&*self.db, position)\n+    }\n     /// Returns a `mod name;` declaration which created the current module.\n     pub fn parent_module(&self, position: FilePosition) -> Cancelable<Vec<NavigationTarget>> {\n         self.db.parent_module(position)\n@@ -425,13 +433,6 @@ impl Analysis {\n     pub fn diagnostics(&self, file_id: FileId) -> Cancelable<Vec<Diagnostic>> {\n         self.db.diagnostics(file_id)\n     }\n-    /// Computes parameter information for the given call expression.\n-    pub fn resolve_callable(\n-        &self,\n-        position: FilePosition,\n-    ) -> Cancelable<Option<(FnSignatureInfo, Option<usize>)>> {\n-        self.db.resolve_callable(position)\n-    }\n     /// Computes the type of the expression at the given position.\n     pub fn type_of(&self, frange: FileRange) -> Cancelable<Option<String>> {\n         hover::type_of(&*self.db, frange)"}]}