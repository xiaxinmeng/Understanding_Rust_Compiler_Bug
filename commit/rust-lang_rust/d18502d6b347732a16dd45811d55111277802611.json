{"sha": "d18502d6b347732a16dd45811d55111277802611", "node_id": "C_kwDOAAsO6NoAKGQxODUwMmQ2YjM0NzczMmExNmRkNDU4MTFkNTUxMTEyNzc4MDI2MTE", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2021-10-13T23:24:48Z"}, "committer": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2021-10-14T01:06:25Z"}, "message": "Suggest Box::pin when Pin::new is used instead", "tree": {"sha": "34c26380e7f4a181099ed343118ecc3d94f722b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34c26380e7f4a181099ed343118ecc3d94f722b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d18502d6b347732a16dd45811d55111277802611", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d18502d6b347732a16dd45811d55111277802611", "html_url": "https://github.com/rust-lang/rust/commit/d18502d6b347732a16dd45811d55111277802611", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d18502d6b347732a16dd45811d55111277802611/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8558e9efabc6640e8c1b1c353e62c233624f616", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8558e9efabc6640e8c1b1c353e62c233624f616", "html_url": "https://github.com/rust-lang/rust/commit/a8558e9efabc6640e8c1b1c353e62c233624f616"}], "stats": {"total": 110, "additions": 67, "deletions": 43}, "files": [{"sha": "babc06822ac529baa6b4a3b8b59d2afe1e94b2cc", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 60, "deletions": 30, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/d18502d6b347732a16dd45811d55111277802611/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18502d6b347732a16dd45811d55111277802611/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=d18502d6b347732a16dd45811d55111277802611", "patch": "@@ -8,11 +8,11 @@ use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind};\n use rustc_hir::lang_items::LangItem;\n-use rustc_hir::{Expr, ExprKind, ItemKind, Node, Stmt, StmtKind};\n+use rustc_hir::{Expr, ExprKind, ItemKind, Node, Path, QPath, Stmt, StmtKind, TyKind};\n use rustc_infer::infer;\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{self, Binder, Ty};\n-use rustc_span::symbol::kw;\n+use rustc_span::symbol::{kw, sym};\n \n use std::iter;\n \n@@ -350,6 +350,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     /// When encountering an `impl Future` where `BoxFuture` is expected, suggest `Box::pin`.\n+    #[instrument(skip(self, err))]\n     pub(in super::super) fn suggest_calling_boxed_future_when_appropriate(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n@@ -368,41 +369,70 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if pin_did.is_none() || self.tcx.lang_items().owned_box().is_none() {\n             return false;\n         }\n-        match expected.kind() {\n-            ty::Adt(def, _) if Some(def.did) == pin_did => (),\n-            _ => return false,\n-        }\n         let box_found = self.tcx.mk_box(found);\n         let pin_box_found = self.tcx.mk_lang_item(box_found, LangItem::Pin).unwrap();\n         let pin_found = self.tcx.mk_lang_item(found, LangItem::Pin).unwrap();\n-        if self.can_coerce(pin_box_found, expected) {\n-            debug!(\"can coerce {:?} to {:?}, suggesting Box::pin\", pin_box_found, expected);\n-            match found.kind() {\n-                ty::Adt(def, _) if def.is_box() => {\n-                    err.help(\"use `Box::pin`\");\n-                }\n-                _ => {\n-                    err.multipart_suggestion(\n-                        \"you need to pin and box this expression\",\n-                        vec![\n-                            (expr.span.shrink_to_lo(), \"Box::pin(\".to_string()),\n-                            (expr.span.shrink_to_hi(), \")\".to_string()),\n-                        ],\n-                        Applicability::MaybeIncorrect,\n-                    );\n+        match expected.kind() {\n+            ty::Adt(def, _) if Some(def.did) == pin_did => {\n+                if self.can_coerce(pin_box_found, expected) {\n+                    debug!(\"can coerce {:?} to {:?}, suggesting Box::pin\", pin_box_found, expected);\n+                    match found.kind() {\n+                        ty::Adt(def, _) if def.is_box() => {\n+                            err.help(\"use `Box::pin`\");\n+                        }\n+                        _ => {\n+                            err.multipart_suggestion(\n+                                \"you need to pin and box this expression\",\n+                                vec![\n+                                    (expr.span.shrink_to_lo(), \"Box::pin(\".to_string()),\n+                                    (expr.span.shrink_to_hi(), \")\".to_string()),\n+                                ],\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        }\n+                    }\n+                    true\n+                } else if self.can_coerce(pin_found, expected) {\n+                    match found.kind() {\n+                        ty::Adt(def, _) if def.is_box() => {\n+                            err.help(\"use `Box::pin`\");\n+                            true\n+                        }\n+                        _ => false,\n+                    }\n+                } else {\n+                    false\n                 }\n             }\n-            true\n-        } else if self.can_coerce(pin_found, expected) {\n-            match found.kind() {\n-                ty::Adt(def, _) if def.is_box() => {\n-                    err.help(\"use `Box::pin`\");\n-                    true\n+            ty::Adt(def, _) if def.is_box() && self.can_coerce(box_found, expected) => {\n+                // Check if the parent expression is a call to Pin::new.  If it\n+                // is and we were expecting a Box, ergo Pin<Box<expected>>, we\n+                // can suggest Box::pin.\n+                let parent = self.tcx.hir().get_parent_node(expr.hir_id);\n+                let fn_name = match self.tcx.hir().find(parent) {\n+                    Some(Node::Expr(Expr { kind: ExprKind::Call(fn_name, _), .. })) => fn_name,\n+                    _ => return false,\n+                };\n+                match fn_name.kind {\n+                    ExprKind::Path(QPath::TypeRelative(\n+                        hir::Ty {\n+                            kind: TyKind::Path(QPath::Resolved(_, Path { res: recv_ty, .. })),\n+                            ..\n+                        },\n+                        method,\n+                    )) if Some(recv_ty.def_id()) == pin_did && method.ident.name == sym::new => {\n+                        err.span_suggestion(\n+                            fn_name.span,\n+                            \"use `Box::pin` to pin and box this expression\",\n+                            \"Box::pin\".to_string(),\n+                            Applicability::MachineApplicable,\n+                        );\n+                        true\n+                    }\n+                    _ => false,\n                 }\n-                _ => false,\n             }\n-        } else {\n-            false\n+            _ => false,\n         }\n     }\n "}, {"sha": "7e9c5492d1a6bc083e119eedace934dc90768b4e", "filename": "src/test/ui/suggestions/expected-boxed-future-isnt-pinned.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d18502d6b347732a16dd45811d55111277802611/src%2Ftest%2Fui%2Fsuggestions%2Fexpected-boxed-future-isnt-pinned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d18502d6b347732a16dd45811d55111277802611/src%2Ftest%2Fui%2Fsuggestions%2Fexpected-boxed-future-isnt-pinned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fexpected-boxed-future-isnt-pinned.rs?ref=d18502d6b347732a16dd45811d55111277802611", "patch": "@@ -15,9 +15,6 @@ fn bar<F: Future<Output=i32> + Send + 'static>(x: F) -> BoxFuture<'static, i32>\n     Box::new(x) //~ ERROR mismatched types\n }\n \n-// This case is still subpar:\n-// `Pin::new(x)`: store this in the heap by calling `Box::new`: `Box::new(x)`\n-// Should suggest changing the code from `Pin::new` to `Box::pin`.\n fn baz<F: Future<Output=i32> + Send + 'static>(x: F) -> BoxFuture<'static, i32> {\n     Pin::new(x) //~ ERROR mismatched types\n     //~^ ERROR E0277"}, {"sha": "aa3175dae2e66cca43d57f73472b30826c67ccce", "filename": "src/test/ui/suggestions/expected-boxed-future-isnt-pinned.stderr", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d18502d6b347732a16dd45811d55111277802611/src%2Ftest%2Fui%2Fsuggestions%2Fexpected-boxed-future-isnt-pinned.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d18502d6b347732a16dd45811d55111277802611/src%2Ftest%2Fui%2Fsuggestions%2Fexpected-boxed-future-isnt-pinned.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fexpected-boxed-future-isnt-pinned.stderr?ref=d18502d6b347732a16dd45811d55111277802611", "patch": "@@ -27,23 +27,20 @@ LL |     Box::new(x)\n    = help: use `Box::pin`\n \n error[E0308]: mismatched types\n-  --> $DIR/expected-boxed-future-isnt-pinned.rs:22:14\n+  --> $DIR/expected-boxed-future-isnt-pinned.rs:19:14\n    |\n LL | fn baz<F: Future<Output=i32> + Send + 'static>(x: F) -> BoxFuture<'static, i32> {\n    |        - this type parameter\n LL |     Pin::new(x)\n-   |              ^ expected struct `Box`, found type parameter `F`\n+   |     -------- ^ expected struct `Box`, found type parameter `F`\n+   |     |\n+   |     help: use `Box::pin` to pin and box this expression: `Box::pin`\n    |\n    = note:      expected struct `Box<dyn Future<Output = i32> + Send>`\n            found type parameter `F`\n-   = note: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n-help: store this in the heap by calling `Box::new`\n-   |\n-LL |     Pin::new(Box::new(x))\n-   |              +++++++++ +\n \n error[E0277]: `dyn Future<Output = i32> + Send` cannot be unpinned\n-  --> $DIR/expected-boxed-future-isnt-pinned.rs:22:5\n+  --> $DIR/expected-boxed-future-isnt-pinned.rs:19:5\n    |\n LL |     Pin::new(x)\n    |     ^^^^^^^^ the trait `Unpin` is not implemented for `dyn Future<Output = i32> + Send`\n@@ -56,7 +53,7 @@ LL |     pub const fn new(pointer: P) -> Pin<P> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0277]: `dyn Future<Output = i32> + Send` cannot be unpinned\n-  --> $DIR/expected-boxed-future-isnt-pinned.rs:27:5\n+  --> $DIR/expected-boxed-future-isnt-pinned.rs:24:5\n    |\n LL |     Pin::new(Box::new(x))\n    |     ^^^^^^^^ the trait `Unpin` is not implemented for `dyn Future<Output = i32> + Send`\n@@ -69,7 +66,7 @@ LL |     pub const fn new(pointer: P) -> Pin<P> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0308]: mismatched types\n-  --> $DIR/expected-boxed-future-isnt-pinned.rs:31:5\n+  --> $DIR/expected-boxed-future-isnt-pinned.rs:28:5\n    |\n LL |   fn zap() -> BoxFuture<'static, i32> {\n    |               ----------------------- expected `Pin<Box<(dyn Future<Output = i32> + Send + 'static)>>` because of return type"}]}