{"sha": "4fa69ab97ca4a5d570eec28c0ef979cd829686c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmYTY5YWI5N2NhNGE1ZDU3MGVlYzI4YzBlZjk3OWNkODI5Njg2YzY=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-07-10T01:49:32Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-07-11T13:54:34Z"}, "message": "dlist: Put all tests into a tests module\n\nThe exception is the function check_links which needs access to struct\nNode (which is not pub).", "tree": {"sha": "92e56506c0ba325d16773c7664d60557535fb371", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92e56506c0ba325d16773c7664d60557535fb371"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4fa69ab97ca4a5d570eec28c0ef979cd829686c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4fa69ab97ca4a5d570eec28c0ef979cd829686c6", "html_url": "https://github.com/rust-lang/rust/commit/4fa69ab97ca4a5d570eec28c0ef979cd829686c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4fa69ab97ca4a5d570eec28c0ef979cd829686c6/comments", "author": null, "committer": null, "parents": [{"sha": "8d06efb8ea0857844f856ab5fd87aed89d4bf718", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d06efb8ea0857844f856ab5fd87aed89d4bf718", "html_url": "https://github.com/rust-lang/rust/commit/8d06efb8ea0857844f856ab5fd87aed89d4bf718"}], "stats": {"total": 514, "additions": 256, "deletions": 258}, "files": [{"sha": "7cca33dbbd3493d8ba005f924a78f2f9e4fde892", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 256, "deletions": 258, "changes": 514, "blob_url": "https://github.com/rust-lang/rust/blob/4fa69ab97ca4a5d570eec28c0ef979cd829686c6/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa69ab97ca4a5d570eec28c0ef979cd829686c6/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=4fa69ab97ca4a5d570eec28c0ef979cd829686c6", "patch": "@@ -497,7 +497,7 @@ impl<A: Clone> Clone for List<A> {\n }\n \n #[cfg(test)]\n-fn check_links<T>(list: &List<T>) {\n+pub fn check_links<T>(list: &List<T>) {\n     let mut len = 0u;\n     let mut last_ptr: Option<&Node<T>> = None;\n     let mut node_ptr: &Node<T>;\n@@ -529,296 +529,294 @@ fn check_links<T>(list: &List<T>) {\n     assert_eq!(len, list.length);\n }\n \n-#[test]\n-fn test_basic() {\n-    let mut m = List::new::<~int>();\n-    assert_eq!(m.pop_front(), None);\n-    assert_eq!(m.pop_back(), None);\n-    assert_eq!(m.pop_front(), None);\n-    m.push_front(~1);\n-    assert_eq!(m.pop_front(), Some(~1));\n-    m.push_back(~2);\n-    m.push_back(~3);\n-    assert_eq!(m.len(), 2);\n-    assert_eq!(m.pop_front(), Some(~2));\n-    assert_eq!(m.pop_front(), Some(~3));\n-    assert_eq!(m.len(), 0);\n-    assert_eq!(m.pop_front(), None);\n-    m.push_back(~1);\n-    m.push_back(~3);\n-    m.push_back(~5);\n-    m.push_back(~7);\n-    assert_eq!(m.pop_front(), Some(~1));\n-\n-    let mut n = List::new();\n-    n.push_front(2);\n-    n.push_front(3);\n-    {\n-        assert_eq!(n.peek_front().unwrap(), &3);\n-        let x = n.peek_front_mut().unwrap();\n-        assert_eq!(*x, 3);\n-        *x = 0;\n-    }\n-    {\n-        assert_eq!(n.peek_back().unwrap(), &2);\n-        let y = n.peek_back_mut().unwrap();\n-        assert_eq!(*y, 2);\n-        *y = 1;\n-    }\n-    assert_eq!(n.pop_front(), Some(0));\n-    assert_eq!(n.pop_front(), Some(1));\n-}\n-\n #[cfg(test)]\n-fn generate_test() -> List<int> {\n-    list_from(&[0,1,2,3,4,5,6])\n-}\n+mod tests {\n+    use super::*;\n+    use std::rand;\n+    use std::int;\n+    use extra::test;\n \n-#[cfg(test)]\n-fn list_from<T: Copy>(v: &[T]) -> List<T> {\n-    v.iter().transform(|x| copy *x).collect()\n-}\n+    #[test]\n+    fn test_basic() {\n+        let mut m = List::new::<~int>();\n+        assert_eq!(m.pop_front(), None);\n+        assert_eq!(m.pop_back(), None);\n+        assert_eq!(m.pop_front(), None);\n+        m.push_front(~1);\n+        assert_eq!(m.pop_front(), Some(~1));\n+        m.push_back(~2);\n+        m.push_back(~3);\n+        assert_eq!(m.len(), 2);\n+        assert_eq!(m.pop_front(), Some(~2));\n+        assert_eq!(m.pop_front(), Some(~3));\n+        assert_eq!(m.len(), 0);\n+        assert_eq!(m.pop_front(), None);\n+        m.push_back(~1);\n+        m.push_back(~3);\n+        m.push_back(~5);\n+        m.push_back(~7);\n+        assert_eq!(m.pop_front(), Some(~1));\n \n-#[test]\n-fn test_append() {\n-    {\n-        let mut m = List::new();\n         let mut n = List::new();\n-        n.push_back(2);\n-        m.append(n);\n-        assert_eq!(m.len(), 1);\n-        assert_eq!(m.pop_back(), Some(2));\n-        check_links(&m);\n+        n.push_front(2);\n+        n.push_front(3);\n+        {\n+            assert_eq!(n.peek_front().unwrap(), &3);\n+            let x = n.peek_front_mut().unwrap();\n+            assert_eq!(*x, 3);\n+            *x = 0;\n+        }\n+        {\n+            assert_eq!(n.peek_back().unwrap(), &2);\n+            let y = n.peek_back_mut().unwrap();\n+            assert_eq!(*y, 2);\n+            *y = 1;\n+        }\n+        assert_eq!(n.pop_front(), Some(0));\n+        assert_eq!(n.pop_front(), Some(1));\n     }\n-    {\n-        let mut m = List::new();\n-        let n = List::new();\n-        m.push_back(2);\n-        m.append(n);\n-        assert_eq!(m.len(), 1);\n-        assert_eq!(m.pop_back(), Some(2));\n-        check_links(&m);\n+\n+    #[cfg(test)]\n+    fn generate_test() -> List<int> {\n+        list_from(&[0,1,2,3,4,5,6])\n     }\n \n-    let v = ~[1,2,3,4,5];\n-    let u = ~[9,8,1,2,3,4,5];\n-    let mut m = list_from(v);\n-    m.append(list_from(u));\n-    check_links(&m);\n-    let sum = v + u;\n-    assert_eq!(sum.len(), m.len());\n-    for sum.consume_iter().advance |elt| {\n-        assert_eq!(m.pop_front(), Some(elt))\n+    #[cfg(test)]\n+    fn list_from<T: Copy>(v: &[T]) -> List<T> {\n+        v.iter().transform(|x| copy *x).collect()\n     }\n-}\n \n-#[test]\n-fn test_prepend() {\n-    {\n-        let mut m = List::new();\n-        let mut n = List::new();\n-        n.push_back(2);\n-        m.prepend(n);\n-        assert_eq!(m.len(), 1);\n-        assert_eq!(m.pop_back(), Some(2));\n+    #[test]\n+    fn test_append() {\n+        {\n+            let mut m = List::new();\n+            let mut n = List::new();\n+            n.push_back(2);\n+            m.append(n);\n+            assert_eq!(m.len(), 1);\n+            assert_eq!(m.pop_back(), Some(2));\n+            check_links(&m);\n+        }\n+        {\n+            let mut m = List::new();\n+            let n = List::new();\n+            m.push_back(2);\n+            m.append(n);\n+            assert_eq!(m.len(), 1);\n+            assert_eq!(m.pop_back(), Some(2));\n+            check_links(&m);\n+        }\n+\n+        let v = ~[1,2,3,4,5];\n+        let u = ~[9,8,1,2,3,4,5];\n+        let mut m = list_from(v);\n+        m.append(list_from(u));\n         check_links(&m);\n+        let sum = v + u;\n+        assert_eq!(sum.len(), m.len());\n+        for sum.consume_iter().advance |elt| {\n+            assert_eq!(m.pop_front(), Some(elt))\n+        }\n     }\n \n-    let v = ~[1,2,3,4,5];\n-    let u = ~[9,8,1,2,3,4,5];\n-    let mut m = list_from(v);\n-    m.prepend(list_from(u));\n-    check_links(&m);\n-    let sum = u + v;\n-    assert_eq!(sum.len(), m.len());\n-    for sum.consume_iter().advance |elt| {\n-        assert_eq!(m.pop_front(), Some(elt))\n+    #[test]\n+    fn test_prepend() {\n+        {\n+            let mut m = List::new();\n+            let mut n = List::new();\n+            n.push_back(2);\n+            m.prepend(n);\n+            assert_eq!(m.len(), 1);\n+            assert_eq!(m.pop_back(), Some(2));\n+            check_links(&m);\n+        }\n+\n+        let v = ~[1,2,3,4,5];\n+        let u = ~[9,8,1,2,3,4,5];\n+        let mut m = list_from(v);\n+        m.prepend(list_from(u));\n+        check_links(&m);\n+        let sum = u + v;\n+        assert_eq!(sum.len(), m.len());\n+        for sum.consume_iter().advance |elt| {\n+            assert_eq!(m.pop_front(), Some(elt))\n+        }\n     }\n-}\n-\n-#[test]\n-fn test_iterator() {\n-    let m = generate_test();\n-    for m.iter().enumerate().advance |(i, elt)| {\n-        assert_eq!(i as int, *elt);\n-    }\n-    let mut n = List::new();\n-    assert_eq!(n.iter().next(), None);\n-    n.push_front(4);\n-    let mut it = n.iter();\n-    assert_eq!(it.size_hint(), (1, Some(1)));\n-    assert_eq!(it.next().unwrap(), &4);\n-    assert_eq!(it.size_hint(), (0, Some(0)));\n-    assert_eq!(it.next(), None);\n-}\n-\n-#[test]\n-fn test_rev_iter() {\n-    let m = generate_test();\n-    for m.rev_iter().enumerate().advance |(i, elt)| {\n-        assert_eq!((6 - i) as int, *elt);\n-    }\n-    let mut n = List::new();\n-    assert_eq!(n.rev_iter().next(), None);\n-    n.push_front(4);\n-    let mut it = n.rev_iter();\n-    assert_eq!(it.size_hint(), (1, Some(1)));\n-    assert_eq!(it.next().unwrap(), &4);\n-    assert_eq!(it.size_hint(), (0, Some(0)));\n-    assert_eq!(it.next(), None);\n-}\n \n-#[test]\n-fn test_mut_iter() {\n-    let mut m = generate_test();\n-    let mut len = m.len();\n-    for m.mut_iter().enumerate().advance |(i, elt)| {\n-        assert_eq!(i as int, *elt);\n-        len -= 1;\n-    }\n-    assert_eq!(len, 0);\n-    let mut n = List::new();\n-    assert!(n.mut_iter().next().is_none());\n-    n.push_front(4);\n-    let mut it = n.mut_iter();\n-    assert_eq!(it.size_hint(), (1, Some(1)));\n-    assert!(it.next().is_some());\n-    assert_eq!(it.size_hint(), (0, Some(0)));\n-    assert!(it.next().is_none());\n-}\n+    #[test]\n+    fn test_iterator() {\n+        let m = generate_test();\n+        for m.iter().enumerate().advance |(i, elt)| {\n+            assert_eq!(i as int, *elt);\n+        }\n+        let mut n = List::new();\n+        assert_eq!(n.iter().next(), None);\n+        n.push_front(4);\n+        let mut it = n.iter();\n+        assert_eq!(it.size_hint(), (1, Some(1)));\n+        assert_eq!(it.next().unwrap(), &4);\n+        assert_eq!(it.size_hint(), (0, Some(0)));\n+        assert_eq!(it.next(), None);\n+    }\n \n-#[test]\n-fn test_list_cursor() {\n-    let mut m = generate_test();\n-    let len = m.len();\n-    {\n-        let mut it = m.mut_iter();\n-        loop {\n-            match it.next() {\n-                None => break,\n-                Some(elt) => it.insert_before(*elt * 2),\n+    #[test]\n+    fn test_rev_iter() {\n+        let m = generate_test();\n+        for m.rev_iter().enumerate().advance |(i, elt)| {\n+            assert_eq!((6 - i) as int, *elt);\n+        }\n+        let mut n = List::new();\n+        assert_eq!(n.rev_iter().next(), None);\n+        n.push_front(4);\n+        let mut it = n.rev_iter();\n+        assert_eq!(it.size_hint(), (1, Some(1)));\n+        assert_eq!(it.next().unwrap(), &4);\n+        assert_eq!(it.size_hint(), (0, Some(0)));\n+        assert_eq!(it.next(), None);\n+    }\n+\n+    #[test]\n+    fn test_mut_iter() {\n+        let mut m = generate_test();\n+        let mut len = m.len();\n+        for m.mut_iter().enumerate().advance |(i, elt)| {\n+            assert_eq!(i as int, *elt);\n+            len -= 1;\n+        }\n+        assert_eq!(len, 0);\n+        let mut n = List::new();\n+        assert!(n.mut_iter().next().is_none());\n+        n.push_front(4);\n+        let mut it = n.mut_iter();\n+        assert_eq!(it.size_hint(), (1, Some(1)));\n+        assert!(it.next().is_some());\n+        assert_eq!(it.size_hint(), (0, Some(0)));\n+        assert!(it.next().is_none());\n+    }\n+\n+    #[test]\n+    fn test_list_cursor() {\n+        let mut m = generate_test();\n+        let len = m.len();\n+        {\n+            let mut it = m.mut_iter();\n+            loop {\n+                match it.next() {\n+                    None => break,\n+                    Some(elt) => it.insert_before(*elt * 2),\n+                }\n             }\n         }\n+        assert_eq!(m.len(), len * 2);\n+        check_links(&m);\n     }\n-    assert_eq!(m.len(), len * 2);\n-    check_links(&m);\n-}\n \n-#[test]\n-fn test_merge() {\n-    let mut m = list_from([0, 1, 3, 5, 6, 7, 2]);\n-    let n = list_from([-1, 0, 0, 7, 7, 9]);\n-    let len = m.len() + n.len();\n-    m.merge(n, |a, b| a <= b);\n-    assert_eq!(m.len(), len);\n-    check_links(&m);\n-    let res = m.consume_iter().collect::<~[int]>();\n-    assert_eq!(res, ~[-1, 0, 0, 1, 0, 3, 5, 6, 7, 2, 7, 7, 9]);\n-}\n+    #[test]\n+    fn test_merge() {\n+        let mut m = list_from([0, 1, 3, 5, 6, 7, 2]);\n+        let n = list_from([-1, 0, 0, 7, 7, 9]);\n+        let len = m.len() + n.len();\n+        m.merge(n, |a, b| a <= b);\n+        assert_eq!(m.len(), len);\n+        check_links(&m);\n+        let res = m.consume_iter().collect::<~[int]>();\n+        assert_eq!(res, ~[-1, 0, 0, 1, 0, 3, 5, 6, 7, 2, 7, 7, 9]);\n+    }\n \n-#[test]\n-fn test_insert_ordered() {\n-    let mut n = List::new();\n-    n.insert_ordered(1);\n-    assert_eq!(n.len(), 1);\n-    assert_eq!(n.pop_front(), Some(1));\n-\n-    let mut m = List::new();\n-    m.push_back(2);\n-    m.push_back(4);\n-    m.insert_ordered(3);\n-    check_links(&m);\n-    assert_eq!(~[2,3,4], m.consume_iter().collect::<~[int]>());\n-}\n+    #[test]\n+    fn test_insert_ordered() {\n+        let mut n = List::new();\n+        n.insert_ordered(1);\n+        assert_eq!(n.len(), 1);\n+        assert_eq!(n.pop_front(), Some(1));\n \n-#[test]\n-fn test_mut_rev_iter() {\n-    let mut m = generate_test();\n-    for m.mut_rev_iter().enumerate().advance |(i, elt)| {\n-        assert_eq!((6-i) as int, *elt);\n-    }\n-    let mut n = List::new();\n-    assert!(n.mut_rev_iter().next().is_none());\n-    n.push_front(4);\n-    let mut it = n.mut_rev_iter();\n-    assert!(it.next().is_some());\n-    assert!(it.next().is_none());\n-}\n+        let mut m = List::new();\n+        m.push_back(2);\n+        m.push_back(4);\n+        m.insert_ordered(3);\n+        check_links(&m);\n+        assert_eq!(~[2,3,4], m.consume_iter().collect::<~[int]>());\n+    }\n \n-#[test]\n-fn test_send() {\n-    let n = list_from([1,2,3]);\n-    do spawn {\n-        check_links(&n);\n-        assert_eq!(~[&1,&2,&3], n.iter().collect::<~[&int]>());\n+    #[test]\n+    fn test_mut_rev_iter() {\n+        let mut m = generate_test();\n+        for m.mut_rev_iter().enumerate().advance |(i, elt)| {\n+            assert_eq!((6-i) as int, *elt);\n+        }\n+        let mut n = List::new();\n+        assert!(n.mut_rev_iter().next().is_none());\n+        n.push_front(4);\n+        let mut it = n.mut_rev_iter();\n+        assert!(it.next().is_some());\n+        assert!(it.next().is_none());\n     }\n-}\n \n-#[test]\n-fn test_eq() {\n-    let mut n: List<u8> = list_from([]);\n-    let mut m = list_from([]);\n-    assert_eq!(&n, &m);\n-    n.push_front(1);\n-    assert!(n != m);\n-    m.push_back(1);\n-    assert_eq!(&n, &m);\n-}\n+    #[test]\n+    fn test_send() {\n+        let n = list_from([1,2,3]);\n+        do spawn {\n+            check_links(&n);\n+            assert_eq!(~[&1,&2,&3], n.iter().collect::<~[&int]>());\n+        }\n+    }\n \n-#[test]\n-fn test_fuzz() {\n-    for 25.times {\n-        fuzz_test(3);\n-        fuzz_test(16);\n-        fuzz_test(189);\n+    #[test]\n+    fn test_eq() {\n+        let mut n: List<u8> = list_from([]);\n+        let mut m = list_from([]);\n+        assert_eq!(&n, &m);\n+        n.push_front(1);\n+        assert!(n != m);\n+        m.push_back(1);\n+        assert_eq!(&n, &m);\n     }\n-}\n \n-#[cfg(test)]\n-fn fuzz_test(sz: int) {\n-    use std::rand;\n-    use std::int;\n+    #[test]\n+    fn test_fuzz() {\n+        for 25.times {\n+            fuzz_test(3);\n+            fuzz_test(16);\n+            fuzz_test(189);\n+        }\n+    }\n \n-    let mut m = List::new::<int>();\n-    let mut v = ~[];\n-    for int::range(0i, sz) |i| {\n-        check_links(&m);\n-        let r: u8 = rand::random();\n-        match r % 6 {\n-            0 => {\n-                m.pop_back();\n-                if v.len() > 0 { v.pop(); }\n-            }\n-            1 => {\n-                m.pop_front();\n-                if v.len() > 0 { v.shift(); }\n-            }\n-            2 | 4 =>  {\n-                m.push_front(-i);\n-                v.unshift(-i);\n-            }\n-            3 | 5 | _ => {\n-                m.push_back(i);\n-                v.push(i);\n+    #[cfg(test)]\n+    fn fuzz_test(sz: int) {\n+        let mut m = List::new::<int>();\n+        let mut v = ~[];\n+        for int::range(0i, sz) |i| {\n+            check_links(&m);\n+            let r: u8 = rand::random();\n+            match r % 6 {\n+                0 => {\n+                    m.pop_back();\n+                    if v.len() > 0 { v.pop(); }\n+                }\n+                1 => {\n+                    m.pop_front();\n+                    if v.len() > 0 { v.shift(); }\n+                }\n+                2 | 4 =>  {\n+                    m.push_front(-i);\n+                    v.unshift(-i);\n+                }\n+                3 | 5 | _ => {\n+                    m.push_back(i);\n+                    v.push(i);\n+                }\n             }\n         }\n-    }\n \n-    check_links(&m);\n+        check_links(&m);\n \n-    let mut i = 0u;\n-    for m.consume_iter().zip(v.iter()).advance |(a, &b)| {\n-        i += 1;\n-        assert_eq!(a, b);\n+        let mut i = 0u;\n+        for m.consume_iter().zip(v.iter()).advance |(a, &b)| {\n+            i += 1;\n+            assert_eq!(a, b);\n+        }\n+        assert_eq!(i, v.len());\n     }\n-    assert_eq!(i, v.len());\n-}\n-\n-#[cfg(test)]\n-mod test_bench {\n-    use extra::test;\n-\n-    use super::*;\n \n     #[bench]\n     fn bench_collect_into(b: &mut test::BenchHarness) {"}]}