{"sha": "b05788e859d3d553825eb114f07573f4839286b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwNTc4OGU4NTlkM2Q1NTM4MjVlYjExNGYwNzU3M2Y0ODM5Mjg2YjE=", "commit": {"author": {"name": "Anders Kaseorg", "email": "andersk@mit.edu", "date": "2021-01-25T20:19:25Z"}, "committer": {"name": "Anders Kaseorg", "email": "andersk@mit.edu", "date": "2021-01-25T20:21:33Z"}, "message": "libtest: Store pending timeouts in a deque\n\nThis reduces the total complexity of checking timeouts from quadratic\nto linear, and should also fix an unwrap of None on completion of an\nalready timed-out test.\n\nSigned-off-by: Anders Kaseorg <andersk@mit.edu>", "tree": {"sha": "c8aa5d41645ea0a7705311608a35eb08059a25ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8aa5d41645ea0a7705311608a35eb08059a25ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b05788e859d3d553825eb114f07573f4839286b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b05788e859d3d553825eb114f07573f4839286b1", "html_url": "https://github.com/rust-lang/rust/commit/b05788e859d3d553825eb114f07573f4839286b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b05788e859d3d553825eb114f07573f4839286b1/comments", "author": {"login": "andersk", "id": 26471, "node_id": "MDQ6VXNlcjI2NDcx", "avatar_url": "https://avatars.githubusercontent.com/u/26471?v=4", "gravatar_id": "", "url": "https://api.github.com/users/andersk", "html_url": "https://github.com/andersk", "followers_url": "https://api.github.com/users/andersk/followers", "following_url": "https://api.github.com/users/andersk/following{/other_user}", "gists_url": "https://api.github.com/users/andersk/gists{/gist_id}", "starred_url": "https://api.github.com/users/andersk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/andersk/subscriptions", "organizations_url": "https://api.github.com/users/andersk/orgs", "repos_url": "https://api.github.com/users/andersk/repos", "events_url": "https://api.github.com/users/andersk/events{/privacy}", "received_events_url": "https://api.github.com/users/andersk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "andersk", "id": 26471, "node_id": "MDQ6VXNlcjI2NDcx", "avatar_url": "https://avatars.githubusercontent.com/u/26471?v=4", "gravatar_id": "", "url": "https://api.github.com/users/andersk", "html_url": "https://github.com/andersk", "followers_url": "https://api.github.com/users/andersk/followers", "following_url": "https://api.github.com/users/andersk/following{/other_user}", "gists_url": "https://api.github.com/users/andersk/gists{/gist_id}", "starred_url": "https://api.github.com/users/andersk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/andersk/subscriptions", "organizations_url": "https://api.github.com/users/andersk/orgs", "repos_url": "https://api.github.com/users/andersk/repos", "events_url": "https://api.github.com/users/andersk/events{/privacy}", "received_events_url": "https://api.github.com/users/andersk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57c72ab8469883fd761a9bba9c4f49771e48256f", "url": "https://api.github.com/repos/rust-lang/rust/commits/57c72ab8469883fd761a9bba9c4f49771e48256f", "html_url": "https://github.com/rust-lang/rust/commit/57c72ab8469883fd761a9bba9c4f49771e48256f"}], "stats": {"total": 45, "additions": 27, "deletions": 18}, "files": [{"sha": "3ff79eaea49aba18fa749b91c12e600de52d8cbe", "filename": "library/test/src/lib.rs", "status": "modified", "additions": 27, "deletions": 18, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b05788e859d3d553825eb114f07573f4839286b1/library%2Ftest%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b05788e859d3d553825eb114f07573f4839286b1/library%2Ftest%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Flib.rs?ref=b05788e859d3d553825eb114f07573f4839286b1", "patch": "@@ -62,6 +62,7 @@ pub mod test {\n }\n \n use std::{\n+    collections::VecDeque,\n     env, io,\n     io::prelude::Write,\n     panic::{self, catch_unwind, AssertUnwindSafe, PanicInfo},\n@@ -211,14 +212,18 @@ where\n     use std::sync::mpsc::RecvTimeoutError;\n \n     struct RunningTest {\n-        timeout: Instant,\n         join_handle: Option<thread::JoinHandle<()>>,\n     }\n \n     // Use a deterministic hasher\n     type TestMap =\n         HashMap<TestDesc, RunningTest, BuildHasherDefault<collections::hash_map::DefaultHasher>>;\n \n+    struct TimeoutEntry {\n+        desc: TestDesc,\n+        timeout: Instant,\n+    }\n+\n     let tests_len = tests.len();\n \n     let mut filtered_tests = filter_tests(opts, tests);\n@@ -262,25 +267,28 @@ where\n     };\n \n     let mut running_tests: TestMap = HashMap::default();\n+    let mut timeout_queue: VecDeque<TimeoutEntry> = VecDeque::new();\n \n-    fn get_timed_out_tests(running_tests: &mut TestMap) -> Vec<TestDesc> {\n+    fn get_timed_out_tests(\n+        running_tests: &TestMap,\n+        timeout_queue: &mut VecDeque<TimeoutEntry>,\n+    ) -> Vec<TestDesc> {\n         let now = Instant::now();\n-        let timed_out = running_tests\n-            .iter()\n-            .filter_map(\n-                |(desc, running_test)| {\n-                    if now >= running_test.timeout { Some(desc.clone()) } else { None }\n-                },\n-            )\n-            .collect();\n-        for test in &timed_out {\n-            running_tests.remove(test);\n+        let mut timed_out = Vec::new();\n+        while let Some(timeout_entry) = timeout_queue.front() {\n+            if now < timeout_entry.timeout {\n+                break;\n+            }\n+            let timeout_entry = timeout_queue.pop_front().unwrap();\n+            if running_tests.contains_key(&timeout_entry.desc) {\n+                timed_out.push(timeout_entry.desc);\n+            }\n         }\n         timed_out\n     }\n \n-    fn calc_timeout(running_tests: &TestMap) -> Option<Duration> {\n-        running_tests.values().map(|running_test| running_test.timeout).min().map(|next_timeout| {\n+    fn calc_timeout(timeout_queue: &VecDeque<TimeoutEntry>) -> Option<Duration> {\n+        timeout_queue.front().map(|&TimeoutEntry { timeout: next_timeout, .. }| {\n             let now = Instant::now();\n             if next_timeout >= now { next_timeout - now } else { Duration::new(0, 0) }\n         })\n@@ -305,7 +313,7 @@ where\n                 let timeout = time::get_default_test_timeout();\n                 let desc = test.desc.clone();\n \n-                let event = TestEvent::TeWait(test.desc.clone());\n+                let event = TestEvent::TeWait(desc.clone());\n                 notify_about_test_event(event)?; //here no pad\n                 let join_handle = run_test(\n                     opts,\n@@ -315,15 +323,16 @@ where\n                     tx.clone(),\n                     Concurrent::Yes,\n                 );\n-                running_tests.insert(desc, RunningTest { timeout, join_handle });\n+                running_tests.insert(desc.clone(), RunningTest { join_handle });\n+                timeout_queue.push_back(TimeoutEntry { desc, timeout });\n                 pending += 1;\n             }\n \n             let mut res;\n             loop {\n-                if let Some(timeout) = calc_timeout(&running_tests) {\n+                if let Some(timeout) = calc_timeout(&timeout_queue) {\n                     res = rx.recv_timeout(timeout);\n-                    for test in get_timed_out_tests(&mut running_tests) {\n+                    for test in get_timed_out_tests(&running_tests, &mut timeout_queue) {\n                         let event = TestEvent::TeTimeout(test);\n                         notify_about_test_event(event)?;\n                     }"}]}