{"sha": "3141f2d78c446b35930d4a73273578e6c6b488f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxNDFmMmQ3OGM0NDZiMzU5MzBkNGE3MzI3MzU3OGU2YzZiNDg4ZjU=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-12-14T01:09:06Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-12-22T15:20:23Z"}, "message": "Inline `all_constructors`", "tree": {"sha": "ab21093c6477068e727128aa6497f0cb99aa07c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ab21093c6477068e727128aa6497f0cb99aa07c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3141f2d78c446b35930d4a73273578e6c6b488f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3141f2d78c446b35930d4a73273578e6c6b488f5", "html_url": "https://github.com/rust-lang/rust/commit/3141f2d78c446b35930d4a73273578e6c6b488f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3141f2d78c446b35930d4a73273578e6c6b488f5/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bbb4ac06511fd0a45632327b7888a31e4f7854e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbb4ac06511fd0a45632327b7888a31e4f7854e5", "html_url": "https://github.com/rust-lang/rust/commit/bbb4ac06511fd0a45632327b7888a31e4f7854e5"}], "stats": {"total": 236, "additions": 115, "deletions": 121}, "files": [{"sha": "9e02cb2e36948200655cb50ab7845fe61e868b27", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 115, "deletions": 121, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/3141f2d78c446b35930d4a73273578e6c6b488f5/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3141f2d78c446b35930d4a73273578e6c6b488f5/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=3141f2d78c446b35930d4a73273578e6c6b488f5", "patch": "@@ -791,124 +791,6 @@ impl<'tcx> Constructor<'tcx> {\n     }\n }\n \n-/// This determines the set of all possible constructors of a pattern matching\n-/// values of type `left_ty`. For vectors, this would normally be an infinite set\n-/// but is instead bounded by the maximum fixed length of slice patterns in\n-/// the column of patterns being analyzed.\n-///\n-/// We make sure to omit constructors that are statically impossible. E.g., for\n-/// `Option<!>`, we do not include `Some(_)` in the returned list of constructors.\n-/// Invariant: this returns an empty `Vec` if and only if the type is uninhabited (as determined by\n-/// `cx.is_uninhabited()`).\n-fn all_constructors<'p, 'tcx>(pcx: PatCtxt<'_, 'p, 'tcx>) -> SmallVec<[Constructor<'tcx>; 1]> {\n-    debug!(\"all_constructors({:?})\", pcx.ty);\n-    let cx = pcx.cx;\n-    let make_range = |start, end| {\n-        IntRange(\n-            // `unwrap()` is ok because we know the type is an integer.\n-            IntRange::from_range(cx.tcx, start, end, pcx.ty, &RangeEnd::Included).unwrap(),\n-        )\n-    };\n-    match pcx.ty.kind() {\n-        ty::Bool => smallvec![make_range(0, 1)],\n-        ty::Array(sub_ty, len) if len.try_eval_usize(cx.tcx, cx.param_env).is_some() => {\n-            let len = len.eval_usize(cx.tcx, cx.param_env);\n-            if len != 0 && cx.is_uninhabited(sub_ty) {\n-                smallvec![]\n-            } else {\n-                smallvec![Slice(Slice::new(Some(len), VarLen(0, 0)))]\n-            }\n-        }\n-        // Treat arrays of a constant but unknown length like slices.\n-        ty::Array(sub_ty, _) | ty::Slice(sub_ty) => {\n-            let kind = if cx.is_uninhabited(sub_ty) { FixedLen(0) } else { VarLen(0, 0) };\n-            smallvec![Slice(Slice::new(None, kind))]\n-        }\n-        ty::Adt(def, substs) if def.is_enum() => {\n-            // If the enum is declared as `#[non_exhaustive]`, we treat it as if it had an\n-            // additional \"unknown\" constructor.\n-            // There is no point in enumerating all possible variants, because the user can't\n-            // actually match against them all themselves. So we always return only the fictitious\n-            // constructor.\n-            // E.g., in an example like:\n-            //\n-            // ```\n-            //     let err: io::ErrorKind = ...;\n-            //     match err {\n-            //         io::ErrorKind::NotFound => {},\n-            //     }\n-            // ```\n-            //\n-            // we don't want to show every possible IO error, but instead have only `_` as the\n-            // witness.\n-            let is_declared_nonexhaustive = cx.is_foreign_non_exhaustive_enum(pcx.ty);\n-\n-            // If `exhaustive_patterns` is disabled and our scrutinee is an empty enum, we treat it\n-            // as though it had an \"unknown\" constructor to avoid exposing its emptiness. The\n-            // exception is if the pattern is at the top level, because we want empty matches to be\n-            // considered exhaustive.\n-            let is_secretly_empty = def.variants.is_empty()\n-                && !cx.tcx.features().exhaustive_patterns\n-                && !pcx.is_top_level;\n-\n-            if is_secretly_empty || is_declared_nonexhaustive {\n-                smallvec![NonExhaustive]\n-            } else if cx.tcx.features().exhaustive_patterns {\n-                // If `exhaustive_patterns` is enabled, we exclude variants known to be\n-                // uninhabited.\n-                def.variants\n-                    .iter()\n-                    .filter(|v| {\n-                        !v.uninhabited_from(cx.tcx, substs, def.adt_kind(), cx.param_env)\n-                            .contains(cx.tcx, cx.module)\n-                    })\n-                    .map(|v| Variant(v.def_id))\n-                    .collect()\n-            } else {\n-                def.variants.iter().map(|v| Variant(v.def_id)).collect()\n-            }\n-        }\n-        ty::Char => {\n-            smallvec![\n-                // The valid Unicode Scalar Value ranges.\n-                make_range('\\u{0000}' as u128, '\\u{D7FF}' as u128),\n-                make_range('\\u{E000}' as u128, '\\u{10FFFF}' as u128),\n-            ]\n-        }\n-        ty::Int(_) | ty::Uint(_)\n-            if pcx.ty.is_ptr_sized_integral()\n-                && !cx.tcx.features().precise_pointer_size_matching =>\n-        {\n-            // `usize`/`isize` are not allowed to be matched exhaustively unless the\n-            // `precise_pointer_size_matching` feature is enabled. So we treat those types like\n-            // `#[non_exhaustive]` enums by returning a special unmatcheable constructor.\n-            smallvec![NonExhaustive]\n-        }\n-        &ty::Int(ity) => {\n-            let bits = Integer::from_attr(&cx.tcx, SignedInt(ity)).size().bits() as u128;\n-            let min = 1u128 << (bits - 1);\n-            let max = min - 1;\n-            smallvec![make_range(min, max)]\n-        }\n-        &ty::Uint(uty) => {\n-            let size = Integer::from_attr(&cx.tcx, UnsignedInt(uty)).size();\n-            let max = size.truncate(u128::MAX);\n-            smallvec![make_range(0, max)]\n-        }\n-        // If `exhaustive_patterns` is disabled and our scrutinee is the never type, we cannot\n-        // expose its emptiness. The exception is if the pattern is at the top level, because we\n-        // want empty matches to be considered exhaustive.\n-        ty::Never if !cx.tcx.features().exhaustive_patterns && !pcx.is_top_level => {\n-            smallvec![NonExhaustive]\n-        }\n-        ty::Never => smallvec![],\n-        _ if cx.is_uninhabited(pcx.ty) => smallvec![],\n-        ty::Adt(..) | ty::Tuple(..) | ty::Ref(..) => smallvec![Single],\n-        // This type is one for which we cannot list constructors, like `str` or `f64`.\n-        _ => smallvec![NonExhaustive],\n-    }\n-}\n-\n /// A wildcard constructor that we split relative to the constructors in the matrix, as explained\n /// at the top of the file.\n /// For splitting wildcards, there are two groups of constructors: there are the constructors\n@@ -926,9 +808,121 @@ pub(super) struct SplitWildcard<'tcx> {\n \n impl<'tcx> SplitWildcard<'tcx> {\n     pub(super) fn new<'p>(pcx: PatCtxt<'_, 'p, 'tcx>) -> Self {\n-        let matrix_ctors = Vec::new();\n-        let all_ctors = all_constructors(pcx);\n-        SplitWildcard { matrix_ctors, all_ctors }\n+        debug!(\"SplitWildcard::new({:?})\", pcx.ty);\n+        let cx = pcx.cx;\n+        let make_range = |start, end| {\n+            IntRange(\n+                // `unwrap()` is ok because we know the type is an integer.\n+                IntRange::from_range(cx.tcx, start, end, pcx.ty, &RangeEnd::Included).unwrap(),\n+            )\n+        };\n+        // This determines the set of all possible constructors for the type `pcx.ty`. For numbers,\n+        // arrays and slices we use ranges and variable-length slices when appropriate.\n+        //\n+        // If the `exhaustive_patterns` feature is enabled, we make sure to omit constructors that\n+        // are statically impossible. E.g., for `Option<!>`, we do not include `Some(_)` in the\n+        // returned list of constructors.\n+        // Invariant: this is empty if and only if the type is uninhabited (as determined by\n+        // `cx.is_uninhabited()`).\n+        let all_ctors = match pcx.ty.kind() {\n+            ty::Bool => smallvec![make_range(0, 1)],\n+            ty::Array(sub_ty, len) if len.try_eval_usize(cx.tcx, cx.param_env).is_some() => {\n+                let len = len.eval_usize(cx.tcx, cx.param_env);\n+                if len != 0 && cx.is_uninhabited(sub_ty) {\n+                    smallvec![]\n+                } else {\n+                    smallvec![Slice(Slice::new(Some(len), VarLen(0, 0)))]\n+                }\n+            }\n+            // Treat arrays of a constant but unknown length like slices.\n+            ty::Array(sub_ty, _) | ty::Slice(sub_ty) => {\n+                let kind = if cx.is_uninhabited(sub_ty) { FixedLen(0) } else { VarLen(0, 0) };\n+                smallvec![Slice(Slice::new(None, kind))]\n+            }\n+            ty::Adt(def, substs) if def.is_enum() => {\n+                // If the enum is declared as `#[non_exhaustive]`, we treat it as if it had an\n+                // additional \"unknown\" constructor.\n+                // There is no point in enumerating all possible variants, because the user can't\n+                // actually match against them all themselves. So we always return only the fictitious\n+                // constructor.\n+                // E.g., in an example like:\n+                //\n+                // ```\n+                //     let err: io::ErrorKind = ...;\n+                //     match err {\n+                //         io::ErrorKind::NotFound => {},\n+                //     }\n+                // ```\n+                //\n+                // we don't want to show every possible IO error, but instead have only `_` as the\n+                // witness.\n+                let is_declared_nonexhaustive = cx.is_foreign_non_exhaustive_enum(pcx.ty);\n+\n+                // If `exhaustive_patterns` is disabled and our scrutinee is an empty enum, we treat it\n+                // as though it had an \"unknown\" constructor to avoid exposing its emptiness. The\n+                // exception is if the pattern is at the top level, because we want empty matches to be\n+                // considered exhaustive.\n+                let is_secretly_empty = def.variants.is_empty()\n+                    && !cx.tcx.features().exhaustive_patterns\n+                    && !pcx.is_top_level;\n+\n+                if is_secretly_empty || is_declared_nonexhaustive {\n+                    smallvec![NonExhaustive]\n+                } else if cx.tcx.features().exhaustive_patterns {\n+                    // If `exhaustive_patterns` is enabled, we exclude variants known to be\n+                    // uninhabited.\n+                    def.variants\n+                        .iter()\n+                        .filter(|v| {\n+                            !v.uninhabited_from(cx.tcx, substs, def.adt_kind(), cx.param_env)\n+                                .contains(cx.tcx, cx.module)\n+                        })\n+                        .map(|v| Variant(v.def_id))\n+                        .collect()\n+                } else {\n+                    def.variants.iter().map(|v| Variant(v.def_id)).collect()\n+                }\n+            }\n+            ty::Char => {\n+                smallvec![\n+                    // The valid Unicode Scalar Value ranges.\n+                    make_range('\\u{0000}' as u128, '\\u{D7FF}' as u128),\n+                    make_range('\\u{E000}' as u128, '\\u{10FFFF}' as u128),\n+                ]\n+            }\n+            ty::Int(_) | ty::Uint(_)\n+                if pcx.ty.is_ptr_sized_integral()\n+                    && !cx.tcx.features().precise_pointer_size_matching =>\n+            {\n+                // `usize`/`isize` are not allowed to be matched exhaustively unless the\n+                // `precise_pointer_size_matching` feature is enabled. So we treat those types like\n+                // `#[non_exhaustive]` enums by returning a special unmatcheable constructor.\n+                smallvec![NonExhaustive]\n+            }\n+            &ty::Int(ity) => {\n+                let bits = Integer::from_attr(&cx.tcx, SignedInt(ity)).size().bits() as u128;\n+                let min = 1u128 << (bits - 1);\n+                let max = min - 1;\n+                smallvec![make_range(min, max)]\n+            }\n+            &ty::Uint(uty) => {\n+                let size = Integer::from_attr(&cx.tcx, UnsignedInt(uty)).size();\n+                let max = size.truncate(u128::MAX);\n+                smallvec![make_range(0, max)]\n+            }\n+            // If `exhaustive_patterns` is disabled and our scrutinee is the never type, we cannot\n+            // expose its emptiness. The exception is if the pattern is at the top level, because we\n+            // want empty matches to be considered exhaustive.\n+            ty::Never if !cx.tcx.features().exhaustive_patterns && !pcx.is_top_level => {\n+                smallvec![NonExhaustive]\n+            }\n+            ty::Never => smallvec![],\n+            _ if cx.is_uninhabited(pcx.ty) => smallvec![],\n+            ty::Adt(..) | ty::Tuple(..) | ty::Ref(..) => smallvec![Single],\n+            // This type is one for which we cannot list constructors, like `str` or `f64`.\n+            _ => smallvec![NonExhaustive],\n+        };\n+        SplitWildcard { matrix_ctors: Vec::new(), all_ctors }\n     }\n \n     /// Pass a set of constructors relative to which to split this one. Don't call twice, it won't"}]}