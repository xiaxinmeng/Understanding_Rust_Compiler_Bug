{"sha": "f7eae4e580d1e4db03800732421288c2ab557f1a", "node_id": "C_kwDOAAsO6NoAKGY3ZWFlNGU1ODBkMWU0ZGIwMzgwMDczMjQyMTI4OGMyYWI1NTdmMWE", "commit": {"author": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-04-24T08:59:21Z"}, "committer": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-04-24T08:59:21Z"}, "message": "include valtree creation and valtree -> constvalue conversion in debug assertions check", "tree": {"sha": "36cc254ed8e9296caaadfa9e99a181542dab21cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36cc254ed8e9296caaadfa9e99a181542dab21cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7eae4e580d1e4db03800732421288c2ab557f1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7eae4e580d1e4db03800732421288c2ab557f1a", "html_url": "https://github.com/rust-lang/rust/commit/f7eae4e580d1e4db03800732421288c2ab557f1a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7eae4e580d1e4db03800732421288c2ab557f1a/comments", "author": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "committer": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc698c73e90c253b0d37be8127b3fb542d9e95c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc698c73e90c253b0d37be8127b3fb542d9e95c2", "html_url": "https://github.com/rust-lang/rust/commit/bc698c73e90c253b0d37be8127b3fb542d9e95c2"}], "stats": {"total": 61, "additions": 30, "deletions": 31}, "files": [{"sha": "52b65c41b4f13dafdce143725a1c07cba07426e2", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f7eae4e580d1e4db03800732421288c2ab557f1a/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7eae4e580d1e4db03800732421288c2ab557f1a/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=f7eae4e580d1e4db03800732421288c2ab557f1a", "patch": "@@ -1,4 +1,4 @@\n-use super::{CompileTimeEvalContext, CompileTimeInterpreter, ConstEvalErr};\n+use super::{const_to_valtree, CompileTimeEvalContext, CompileTimeInterpreter, ConstEvalErr};\n use crate::interpret::eval_nullary_intrinsic;\n use crate::interpret::{\n     intern_const_alloc_recursive, Allocation, ConstAlloc, ConstValue, CtfeValidationMode, GlobalId,\n@@ -215,6 +215,13 @@ fn turn_into_const_value<'tcx>(\n         \"the `eval_to_const_value_raw` query should not be used for statics, use `eval_to_allocation` instead\"\n     );\n \n+    if cfg!(debug_assertions) {\n+        if let Some(valtree) = const_to_valtree(tcx, key.param_env, constant) {\n+            let const_val = tcx.valtree_to_const_val((constant.ty, valtree));\n+            debug!(?const_val);\n+        }\n+    }\n+\n     // Turn this into a proper constant.\n     let const_val = op_to_const(&ecx, &mplace.into());\n     debug!(?const_val);"}, {"sha": "f35b28e187a65de3d0efe6d186c4b60cc533ed2a", "filename": "compiler/rustc_const_eval/src/const_eval/valtrees.rs", "status": "modified", "additions": 22, "deletions": 30, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f7eae4e580d1e4db03800732421288c2ab557f1a/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7eae4e580d1e4db03800732421288c2ab557f1a/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs?ref=f7eae4e580d1e4db03800732421288c2ab557f1a", "patch": "@@ -5,7 +5,6 @@ use crate::interpret::{\n     Scalar, ScalarMaybeUninit,\n };\n use rustc_middle::mir::interpret::ConstAlloc;\n-use rustc_middle::mir::{Field, ProjectionElem};\n use rustc_middle::ty::{self, ScalarInt, Ty, TyCtxt};\n use rustc_span::source_map::DUMMY_SP;\n use rustc_target::abi::VariantIdx;\n@@ -197,45 +196,45 @@ pub fn valtree_to_const_value<'tcx>(\n     let mut ecx = mk_eval_cx(tcx, DUMMY_SP, param_env, false);\n \n     match ty.kind() {\n+        ty::FnDef(..) => {\n+            assert!(valtree.unwrap_branch().is_empty());\n+            ConstValue::Scalar(Scalar::ZST)\n+        }\n         ty::Bool | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Char => match valtree {\n             ty::ValTree::Leaf(scalar_int) => ConstValue::Scalar(Scalar::Int(scalar_int)),\n             ty::ValTree::Branch(_) => bug!(\n                 \"ValTrees for Bool, Int, Uint, Float or Char should have the form ValTree::Leaf\"\n             ),\n         },\n-        ty::Ref(_, inner_ty, _) => {\n-            // create a place for the pointee\n-            let mut pointee_place = create_pointee_place(&mut ecx, *inner_ty, valtree);\n-            debug!(?pointee_place);\n-\n-            // insert elements of valtree into `place`\n-            fill_place_recursively(&mut ecx, &mut pointee_place, valtree);\n-            dump_place(&ecx, pointee_place.into());\n-            intern_const_alloc_recursive(&mut ecx, InternKind::Constant, &pointee_place).unwrap();\n-\n-            let ref_place = pointee_place.to_ref(&tcx);\n-            let imm = ImmTy::from_immediate(ref_place, tcx.layout_of(param_env_ty).unwrap());\n-\n-            let const_val = op_to_const(&ecx, &imm.into());\n-            debug!(?const_val);\n-\n-            const_val\n-        }\n-        ty::Tuple(_) | ty::Array(_, _) | ty::Adt(..) => {\n-            let mut place = create_mplace_from_layout(&mut ecx, ty);\n+        ty::Ref(_, _, _) | ty::Tuple(_) | ty::Array(_, _) | ty::Adt(..) => {\n+            let mut place = match ty.kind() {\n+                ty::Ref(_, inner_ty, _) => {\n+                    // Need to create a place for the pointee to fill for Refs\n+                    create_pointee_place(&mut ecx, *inner_ty, valtree)\n+                }\n+                _ => create_mplace_from_layout(&mut ecx, ty),\n+            };\n             debug!(?place);\n \n             fill_place_recursively(&mut ecx, &mut place, valtree);\n             dump_place(&ecx, place.into());\n             intern_const_alloc_recursive(&mut ecx, InternKind::Constant, &place).unwrap();\n \n-            let const_val = op_to_const(&ecx, &place.into());\n+            let const_val = match ty.kind() {\n+                ty::Ref(_, _, _) => {\n+                    let ref_place = place.to_ref(&tcx);\n+                    let imm =\n+                        ImmTy::from_immediate(ref_place, tcx.layout_of(param_env_ty).unwrap());\n+\n+                    op_to_const(&ecx, &imm.into())\n+                }\n+                _ => op_to_const(&ecx, &place.into()),\n+            };\n             debug!(?const_val);\n \n             const_val\n         }\n         ty::Never\n-        | ty::FnDef(..)\n         | ty::Error(_)\n         | ty::Foreign(..)\n         | ty::Infer(ty::FreshIntTy(_))\n@@ -331,13 +330,6 @@ fn fill_place_recursively<'tcx>(\n                 debug!(?i, ?inner_valtree);\n \n                 let mut place_inner = match *ty.kind() {\n-                    ty::Adt(def, substs) if !def.is_enum() => {\n-                        let field = &def.variant(VariantIdx::from_usize(0)).fields[i];\n-                        let field_ty = field.ty(tcx, substs);\n-                        let projection_elem = ProjectionElem::Field(Field::from_usize(i), field_ty);\n-\n-                        ecx.mplace_projection(&place_adjusted, projection_elem).unwrap()\n-                    }\n                     ty::Adt(_, _) | ty::Tuple(_) => ecx.mplace_field(&place_adjusted, i).unwrap(),\n                     ty::Array(_, _) | ty::Str => {\n                         ecx.mplace_index(&place_adjusted, i as u64).unwrap()"}]}