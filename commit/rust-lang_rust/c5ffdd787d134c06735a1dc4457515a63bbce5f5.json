{"sha": "c5ffdd787d134c06735a1dc4457515a63bbce5f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1ZmZkZDc4N2QxMzRjMDY3MzVhMWRjNDQ1NzUxNWE2M2JiY2U1ZjU=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-04-11T18:16:45Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-04-12T20:53:22Z"}, "message": "Initial docs for the GlobalAlloc trait", "tree": {"sha": "b2583738ace3c1bc941845fd3c1373a3cabe1cc0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b2583738ace3c1bc941845fd3c1373a3cabe1cc0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5ffdd787d134c06735a1dc4457515a63bbce5f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5ffdd787d134c06735a1dc4457515a63bbce5f5", "html_url": "https://github.com/rust-lang/rust/commit/c5ffdd787d134c06735a1dc4457515a63bbce5f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5ffdd787d134c06735a1dc4457515a63bbce5f5/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f607a3872addf380846cae28661a777ec3e3c9a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/f607a3872addf380846cae28661a777ec3e3c9a2", "html_url": "https://github.com/rust-lang/rust/commit/f607a3872addf380846cae28661a777ec3e3c9a2"}], "stats": {"total": 44, "additions": 39, "deletions": 5}, "files": [{"sha": "8f8849e32e6cb6ef279bbcf66efc7687fa70722e", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 39, "deletions": 5, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c5ffdd787d134c06735a1dc4457515a63bbce5f5/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5ffdd787d134c06735a1dc4457515a63bbce5f5/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=c5ffdd787d134c06735a1dc4457515a63bbce5f5", "patch": "@@ -385,10 +385,25 @@ impl From<AllocErr> for CollectionAllocErr {\n     }\n }\n \n-// FIXME: docs\n+/// A memory allocator that can be registered to be the one backing `std::alloc::Global`\n+/// though the `#[global_allocator]` attributes.\n pub unsafe trait GlobalAlloc {\n+    /// Allocate memory as described by the given `layout`.\n+    ///\n+    /// Returns a pointer to newly-allocated memory,\n+    /// or NULL to indicate allocation failure.\n+    ///\n+    /// # Safety\n+    ///\n+    /// **FIXME:** what are the exact requirements?\n     unsafe fn alloc(&self, layout: Layout) -> *mut Opaque;\n \n+    /// Deallocate the block of memory at the given `ptr` pointer with the given `layout`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// **FIXME:** what are the exact requirements?\n+    /// In particular around layout *fit*. (See docs for the `Alloc` trait.)\n     unsafe fn dealloc(&self, ptr: *mut Opaque, layout: Layout);\n \n     unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut Opaque {\n@@ -400,24 +415,43 @@ pub unsafe trait GlobalAlloc {\n         ptr\n     }\n \n+    /// Shink or grow a block of memory to the given `new_size`.\n+    /// The block is described by the given `ptr` pointer and `layout`.\n+    ///\n+    /// Return a new pointer (which may or may not be the same as `ptr`),\n+    /// or NULL to indicate reallocation failure.\n+    ///\n+    /// If reallocation is successful, the old `ptr` pointer is considered\n+    /// to have been deallocated.\n+    ///\n     /// # Safety\n     ///\n     /// `new_size`, when rounded up to the nearest multiple of `old_layout.align()`,\n     /// must not overflow (i.e. the rounded value must be less than `usize::MAX`).\n-    unsafe fn realloc(&self, ptr: *mut Opaque, old_layout: Layout, new_size: usize) -> *mut Opaque {\n-        let new_layout = Layout::from_size_align_unchecked(new_size, old_layout.align());\n+    ///\n+    /// **FIXME:** what are the exact requirements?\n+    /// In particular around layout *fit*. (See docs for the `Alloc` trait.)\n+    unsafe fn realloc(&self, ptr: *mut Opaque, layout: Layout, new_size: usize) -> *mut Opaque {\n+        let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n         let new_ptr = self.alloc(new_layout);\n         if !new_ptr.is_null() {\n             ptr::copy_nonoverlapping(\n                 ptr as *const u8,\n                 new_ptr as *mut u8,\n-                cmp::min(old_layout.size(), new_size),\n+                cmp::min(layout.size(), new_size),\n             );\n-            self.dealloc(ptr, old_layout);\n+            self.dealloc(ptr, layout);\n         }\n         new_ptr\n     }\n \n+    /// Aborts the thread or process, optionally performing\n+    /// cleanup or logging diagnostic information before panicking or\n+    /// aborting.\n+    ///\n+    /// `oom` is meant to be used by clients unable to cope with an\n+    /// unsatisfied allocation request, and wish to abandon\n+    /// computation rather than attempt to recover locally.\n     fn oom(&self) -> ! {\n         unsafe { ::intrinsics::abort() }\n     }"}]}