{"sha": "b1e68b9e2d75e66bc866a194b744ddf8502ca129", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxZTY4YjllMmQ3NWU2NmJjODY2YTE5NGI3NDRkZGY4NTAyY2ExMjk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-28T21:36:56Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-04-06T16:42:02Z"}, "message": "make an incremental crate\n\nfor now, this houses `svh` and the code to check `assert_dep_graph` is\nsane", "tree": {"sha": "61c589cf387b254f6ab6f9c96f5dba5dc8c54c52", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61c589cf387b254f6ab6f9c96f5dba5dc8c54c52"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1e68b9e2d75e66bc866a194b744ddf8502ca129", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1e68b9e2d75e66bc866a194b744ddf8502ca129", "html_url": "https://github.com/rust-lang/rust/commit/b1e68b9e2d75e66bc866a194b744ddf8502ca129", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1e68b9e2d75e66bc866a194b744ddf8502ca129/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe47ca0d0b04f1cd46195b19cbb42602319aaf98", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe47ca0d0b04f1cd46195b19cbb42602319aaf98", "html_url": "https://github.com/rust-lang/rust/commit/fe47ca0d0b04f1cd46195b19cbb42602319aaf98"}], "stats": {"total": 1026, "additions": 584, "deletions": 442}, "files": [{"sha": "84452945f2706e820d4f6de75e076bb875df8644", "filename": "mk/crates.mk", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b1e68b9e2d75e66bc866a194b744ddf8502ca129/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b1e68b9e2d75e66bc866a194b744ddf8502ca129/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=b1e68b9e2d75e66bc866a194b744ddf8502ca129", "patch": "@@ -58,7 +58,7 @@ RUSTC_CRATES := rustc rustc_typeck rustc_mir rustc_borrowck rustc_resolve rustc_\n                 rustc_trans rustc_back rustc_llvm rustc_privacy rustc_lint \\\n                 rustc_data_structures rustc_platform_intrinsics \\\n                 rustc_plugin rustc_metadata rustc_passes rustc_save_analysis \\\n-                rustc_const_eval rustc_const_math\n+                rustc_const_eval rustc_const_math rustc_incremental\n HOST_CRATES := syntax syntax_ext $(RUSTC_CRATES) rustdoc fmt_macros \\\n \t\tflate arena graphviz rbml log serialize\n TOOLS := compiletest rustdoc rustc rustbook error_index_generator\n@@ -117,7 +117,8 @@ DEPS_rustc_plugin := rustc rustc_metadata syntax rustc_mir\n DEPS_rustc_privacy := rustc log syntax\n DEPS_rustc_trans := arena flate getopts graphviz libc rustc rustc_back rustc_mir \\\n                     log syntax serialize rustc_llvm rustc_platform_intrinsics \\\n-                    rustc_const_math rustc_const_eval\n+                    rustc_const_math rustc_const_eval rustc_incremental\n+DEPS_rustc_incremental := rbml rustc serialize rustc_data_structures\n DEPS_rustc_save_analysis := rustc log syntax\n DEPS_rustc_typeck := rustc syntax rustc_platform_intrinsics rustc_const_math \\\n                      rustc_const_eval"}, {"sha": "08c3d70034a0de516ea5cf918c6f653de869c2c6", "filename": "src/librustc/hir/svh.rs", "status": "modified", "additions": 11, "deletions": 363, "changes": 374, "blob_url": "https://github.com/rust-lang/rust/blob/b1e68b9e2d75e66bc866a194b744ddf8502ca129/src%2Flibrustc%2Fhir%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1e68b9e2d75e66bc866a194b744ddf8502ca129/src%2Flibrustc%2Fhir%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fsvh.rs?ref=b1e68b9e2d75e66bc866a194b744ddf8502ca129", "patch": "@@ -47,63 +47,23 @@\n //! Original issue: https://github.com/rust-lang/rust/issues/10207\n \n use std::fmt;\n-use std::hash::{Hash, SipHasher, Hasher};\n-use hir;\n-use hir::intravisit as visit;\n \n #[derive(Clone, PartialEq, Debug)]\n pub struct Svh {\n     hash: String,\n }\n \n impl Svh {\n-    pub fn new(hash: &str) -> Svh {\n+    /// Create a new `Svh` given the hash. If you actually want to\n+    /// compute the SVH from some HIR, you want the `calculate_svh`\n+    /// function found in `librustc_trans`.\n+    pub fn new(hash: String) -> Svh {\n         assert!(hash.len() == 16);\n-        Svh { hash: hash.to_string() }\n+        Svh { hash: hash }\n     }\n \n-    pub fn as_str<'a>(&'a self) -> &'a str {\n-        &self.hash\n-    }\n-\n-    pub fn calculate(crate_disambiguator: &str, krate: &hir::Crate) -> Svh {\n-        // FIXME (#14132): This is better than it used to be, but it still not\n-        // ideal. We now attempt to hash only the relevant portions of the\n-        // Crate AST as well as the top-level crate attributes. (However,\n-        // the hashing of the crate attributes should be double-checked\n-        // to ensure it is not incorporating implementation artifacts into\n-        // the hash that are not otherwise visible.)\n-\n-        // FIXME: this should use SHA1, not SipHash. SipHash is not built to\n-        //        avoid collisions.\n-        let mut state = SipHasher::new();\n-\n-        \"crate_disambiguator\".hash(&mut state);\n-        crate_disambiguator.len().hash(&mut state);\n-        crate_disambiguator.hash(&mut state);\n-\n-        {\n-            let mut visit = svh_visitor::make(&mut state, krate);\n-            visit::walk_crate(&mut visit, krate);\n-        }\n-\n-        // FIXME (#14132): This hash is still sensitive to e.g. the\n-        // spans of the crate Attributes and their underlying\n-        // MetaItems; we should make ContentHashable impl for those\n-        // types and then use hash_content.  But, since all crate\n-        // attributes should appear near beginning of the file, it is\n-        // not such a big deal to be sensitive to their spans for now.\n-        //\n-        // We hash only the MetaItems instead of the entire Attribute\n-        // to avoid hashing the AttrId\n-        for attr in &krate.attrs {\n-            attr.node.value.hash(&mut state);\n-        }\n-\n-        let hash = state.finish();\n-        return Svh {\n-            hash: (0..64).step_by(4).map(|i| hex(hash >> i)).collect()\n-        };\n+    pub fn from_hash(hash: u64) -> Svh {\n+        return Svh::new((0..64).step_by(4).map(|i| hex(hash >> i)).collect());\n \n         fn hex(b: u64) -> char {\n             let b = (b & 0xf) as u8;\n@@ -114,326 +74,14 @@ impl Svh {\n             b as char\n         }\n     }\n+\n+    pub fn as_str<'a>(&'a self) -> &'a str {\n+        &self.hash\n+    }\n }\n \n impl fmt::Display for Svh {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.pad(self.as_str())\n     }\n }\n-\n-// FIXME (#14132): Even this SVH computation still has implementation\n-// artifacts: namely, the order of item declaration will affect the\n-// hash computation, but for many kinds of items the order of\n-// declaration should be irrelevant to the ABI.\n-\n-mod svh_visitor {\n-    pub use self::SawExprComponent::*;\n-    pub use self::SawStmtComponent::*;\n-    use self::SawAbiComponent::*;\n-    use syntax::ast::{self, Name, NodeId};\n-    use syntax::codemap::Span;\n-    use syntax::parse::token;\n-    use hir::intravisit as visit;\n-    use hir::intravisit::{Visitor, FnKind};\n-    use hir::*;\n-    use hir;\n-\n-    use std::hash::{Hash, SipHasher};\n-\n-    pub struct StrictVersionHashVisitor<'a> {\n-        pub krate: &'a Crate,\n-        pub st: &'a mut SipHasher,\n-    }\n-\n-    pub fn make<'a>(st: &'a mut SipHasher, krate: &'a Crate) -> StrictVersionHashVisitor<'a> {\n-        StrictVersionHashVisitor { st: st, krate: krate }\n-    }\n-\n-    // To off-load the bulk of the hash-computation on #[derive(Hash)],\n-    // we define a set of enums corresponding to the content that our\n-    // crate visitor will encounter as it traverses the ast.\n-    //\n-    // The important invariant is that all of the Saw*Component enums\n-    // do not carry any Spans, Names, or Idents.\n-    //\n-    // Not carrying any Names/Idents is the important fix for problem\n-    // noted on PR #13948: using the ident.name as the basis for a\n-    // hash leads to unstable SVH, because ident.name is just an index\n-    // into intern table (i.e. essentially a random address), not\n-    // computed from the name content.\n-    //\n-    // With the below enums, the SVH computation is not sensitive to\n-    // artifacts of how rustc was invoked nor of how the source code\n-    // was laid out.  (Or at least it is *less* sensitive.)\n-\n-    // This enum represents the different potential bits of code the\n-    // visitor could encounter that could affect the ABI for the crate,\n-    // and assigns each a distinct tag to feed into the hash computation.\n-    #[derive(Hash)]\n-    enum SawAbiComponent<'a> {\n-\n-        // FIXME (#14132): should we include (some function of)\n-        // ident.ctxt as well?\n-        SawIdent(token::InternedString),\n-        SawStructDef(token::InternedString),\n-\n-        SawLifetime(token::InternedString),\n-        SawLifetimeDef(token::InternedString),\n-\n-        SawMod,\n-        SawForeignItem,\n-        SawItem,\n-        SawDecl,\n-        SawTy,\n-        SawGenerics,\n-        SawFn,\n-        SawTraitItem,\n-        SawImplItem,\n-        SawStructField,\n-        SawVariant,\n-        SawExplicitSelf,\n-        SawPath,\n-        SawBlock,\n-        SawPat,\n-        SawLocal,\n-        SawArm,\n-        SawExpr(SawExprComponent<'a>),\n-        SawStmt(SawStmtComponent),\n-    }\n-\n-    /// SawExprComponent carries all of the information that we want\n-    /// to include in the hash that *won't* be covered by the\n-    /// subsequent recursive traversal of the expression's\n-    /// substructure by the visitor.\n-    ///\n-    /// We know every Expr_ variant is covered by a variant because\n-    /// `fn saw_expr` maps each to some case below.  Ensuring that\n-    /// each variant carries an appropriate payload has to be verified\n-    /// by hand.\n-    ///\n-    /// (However, getting that *exactly* right is not so important\n-    /// because the SVH is just a developer convenience; there is no\n-    /// guarantee of collision-freedom, hash collisions are just\n-    /// (hopefully) unlikely.)\n-    #[derive(Hash)]\n-    pub enum SawExprComponent<'a> {\n-\n-        SawExprLoop(Option<token::InternedString>),\n-        SawExprField(token::InternedString),\n-        SawExprTupField(usize),\n-        SawExprBreak(Option<token::InternedString>),\n-        SawExprAgain(Option<token::InternedString>),\n-\n-        SawExprBox,\n-        SawExprVec,\n-        SawExprCall,\n-        SawExprMethodCall,\n-        SawExprTup,\n-        SawExprBinary(hir::BinOp_),\n-        SawExprUnary(hir::UnOp),\n-        SawExprLit(ast::LitKind),\n-        SawExprCast,\n-        SawExprType,\n-        SawExprIf,\n-        SawExprWhile,\n-        SawExprMatch,\n-        SawExprClosure,\n-        SawExprBlock,\n-        SawExprAssign,\n-        SawExprAssignOp(hir::BinOp_),\n-        SawExprIndex,\n-        SawExprPath(Option<usize>),\n-        SawExprAddrOf(hir::Mutability),\n-        SawExprRet,\n-        SawExprInlineAsm(&'a hir::InlineAsm),\n-        SawExprStruct,\n-        SawExprRepeat,\n-    }\n-\n-    fn saw_expr<'a>(node: &'a Expr_) -> SawExprComponent<'a> {\n-        match *node {\n-            ExprBox(..)              => SawExprBox,\n-            ExprVec(..)              => SawExprVec,\n-            ExprCall(..)             => SawExprCall,\n-            ExprMethodCall(..)       => SawExprMethodCall,\n-            ExprTup(..)              => SawExprTup,\n-            ExprBinary(op, _, _)     => SawExprBinary(op.node),\n-            ExprUnary(op, _)         => SawExprUnary(op),\n-            ExprLit(ref lit)         => SawExprLit(lit.node.clone()),\n-            ExprCast(..)             => SawExprCast,\n-            ExprType(..)             => SawExprType,\n-            ExprIf(..)               => SawExprIf,\n-            ExprWhile(..)            => SawExprWhile,\n-            ExprLoop(_, id)          => SawExprLoop(id.map(|id| id.name.as_str())),\n-            ExprMatch(..)            => SawExprMatch,\n-            ExprClosure(..)          => SawExprClosure,\n-            ExprBlock(..)            => SawExprBlock,\n-            ExprAssign(..)           => SawExprAssign,\n-            ExprAssignOp(op, _, _)   => SawExprAssignOp(op.node),\n-            ExprField(_, name)       => SawExprField(name.node.as_str()),\n-            ExprTupField(_, id)      => SawExprTupField(id.node),\n-            ExprIndex(..)            => SawExprIndex,\n-            ExprPath(ref qself, _)   => SawExprPath(qself.as_ref().map(|q| q.position)),\n-            ExprAddrOf(m, _)         => SawExprAddrOf(m),\n-            ExprBreak(id)            => SawExprBreak(id.map(|id| id.node.name.as_str())),\n-            ExprAgain(id)            => SawExprAgain(id.map(|id| id.node.name.as_str())),\n-            ExprRet(..)              => SawExprRet,\n-            ExprInlineAsm(ref a,_,_) => SawExprInlineAsm(a),\n-            ExprStruct(..)           => SawExprStruct,\n-            ExprRepeat(..)           => SawExprRepeat,\n-        }\n-    }\n-\n-    /// SawStmtComponent is analogous to SawExprComponent, but for statements.\n-    #[derive(Hash)]\n-    pub enum SawStmtComponent {\n-        SawStmtDecl,\n-        SawStmtExpr,\n-        SawStmtSemi,\n-    }\n-\n-    fn saw_stmt(node: &Stmt_) -> SawStmtComponent {\n-        match *node {\n-            StmtDecl(..) => SawStmtDecl,\n-            StmtExpr(..) => SawStmtExpr,\n-            StmtSemi(..) => SawStmtSemi,\n-        }\n-    }\n-\n-    impl<'a> Visitor<'a> for StrictVersionHashVisitor<'a> {\n-        fn visit_nested_item(&mut self, item: ItemId) {\n-            self.visit_item(self.krate.item(item.id))\n-        }\n-\n-        fn visit_variant_data(&mut self, s: &'a VariantData, name: Name,\n-                              g: &'a Generics, _: NodeId, _: Span) {\n-            SawStructDef(name.as_str()).hash(self.st);\n-            visit::walk_generics(self, g);\n-            visit::walk_struct_def(self, s)\n-        }\n-\n-        fn visit_variant(&mut self, v: &'a Variant, g: &'a Generics, item_id: NodeId) {\n-            SawVariant.hash(self.st);\n-            // walk_variant does not call walk_generics, so do it here.\n-            visit::walk_generics(self, g);\n-            visit::walk_variant(self, v, g, item_id)\n-        }\n-\n-        // All of the remaining methods just record (in the hash\n-        // SipHasher) that the visitor saw that particular variant\n-        // (with its payload), and continue walking as the default\n-        // visitor would.\n-        //\n-        // Some of the implementations have some notes as to how one\n-        // might try to make their SVH computation less discerning\n-        // (e.g. by incorporating reachability analysis).  But\n-        // currently all of their implementations are uniform and\n-        // uninteresting.\n-        //\n-        // (If you edit a method such that it deviates from the\n-        // pattern, please move that method up above this comment.)\n-\n-        fn visit_name(&mut self, _: Span, name: Name) {\n-            SawIdent(name.as_str()).hash(self.st);\n-        }\n-\n-        fn visit_lifetime(&mut self, l: &'a Lifetime) {\n-            SawLifetime(l.name.as_str()).hash(self.st);\n-        }\n-\n-        fn visit_lifetime_def(&mut self, l: &'a LifetimeDef) {\n-            SawLifetimeDef(l.lifetime.name.as_str()).hash(self.st);\n-        }\n-\n-        // We do recursively walk the bodies of functions/methods\n-        // (rather than omitting their bodies from the hash) since\n-        // monomorphization and cross-crate inlining generally implies\n-        // that a change to a crate body will require downstream\n-        // crates to be recompiled.\n-        fn visit_expr(&mut self, ex: &'a Expr) {\n-            SawExpr(saw_expr(&ex.node)).hash(self.st); visit::walk_expr(self, ex)\n-        }\n-\n-        fn visit_stmt(&mut self, s: &'a Stmt) {\n-            SawStmt(saw_stmt(&s.node)).hash(self.st); visit::walk_stmt(self, s)\n-        }\n-\n-        fn visit_foreign_item(&mut self, i: &'a ForeignItem) {\n-            // FIXME (#14132) ideally we would incorporate privacy (or\n-            // perhaps reachability) somewhere here, so foreign items\n-            // that do not leak into downstream crates would not be\n-            // part of the ABI.\n-            SawForeignItem.hash(self.st); visit::walk_foreign_item(self, i)\n-        }\n-\n-        fn visit_item(&mut self, i: &'a Item) {\n-            // FIXME (#14132) ideally would incorporate reachability\n-            // analysis somewhere here, so items that never leak into\n-            // downstream crates (e.g. via monomorphisation or\n-            // inlining) would not be part of the ABI.\n-            SawItem.hash(self.st); visit::walk_item(self, i)\n-        }\n-\n-        fn visit_mod(&mut self, m: &'a Mod, _s: Span, _n: NodeId) {\n-            SawMod.hash(self.st); visit::walk_mod(self, m)\n-        }\n-\n-        fn visit_decl(&mut self, d: &'a Decl) {\n-            SawDecl.hash(self.st); visit::walk_decl(self, d)\n-        }\n-\n-        fn visit_ty(&mut self, t: &'a Ty) {\n-            SawTy.hash(self.st); visit::walk_ty(self, t)\n-        }\n-\n-        fn visit_generics(&mut self, g: &'a Generics) {\n-            SawGenerics.hash(self.st); visit::walk_generics(self, g)\n-        }\n-\n-        fn visit_fn(&mut self, fk: FnKind<'a>, fd: &'a FnDecl,\n-                    b: &'a Block, s: Span, _: NodeId) {\n-            SawFn.hash(self.st); visit::walk_fn(self, fk, fd, b, s)\n-        }\n-\n-        fn visit_trait_item(&mut self, ti: &'a TraitItem) {\n-            SawTraitItem.hash(self.st); visit::walk_trait_item(self, ti)\n-        }\n-\n-        fn visit_impl_item(&mut self, ii: &'a ImplItem) {\n-            SawImplItem.hash(self.st); visit::walk_impl_item(self, ii)\n-        }\n-\n-        fn visit_struct_field(&mut self, s: &'a StructField) {\n-            SawStructField.hash(self.st); visit::walk_struct_field(self, s)\n-        }\n-\n-        fn visit_explicit_self(&mut self, es: &'a ExplicitSelf) {\n-            SawExplicitSelf.hash(self.st); visit::walk_explicit_self(self, es)\n-        }\n-\n-        fn visit_path(&mut self, path: &'a Path, _: ast::NodeId) {\n-            SawPath.hash(self.st); visit::walk_path(self, path)\n-        }\n-\n-        fn visit_path_list_item(&mut self, prefix: &'a Path, item: &'a PathListItem) {\n-            SawPath.hash(self.st); visit::walk_path_list_item(self, prefix, item)\n-        }\n-\n-        fn visit_block(&mut self, b: &'a Block) {\n-            SawBlock.hash(self.st); visit::walk_block(self, b)\n-        }\n-\n-        fn visit_pat(&mut self, p: &'a Pat) {\n-            SawPat.hash(self.st); visit::walk_pat(self, p)\n-        }\n-\n-        fn visit_local(&mut self, l: &'a Local) {\n-            SawLocal.hash(self.st); visit::walk_local(self, l)\n-        }\n-\n-        fn visit_arm(&mut self, a: &'a Arm) {\n-            SawArm.hash(self.st); visit::walk_arm(self, a)\n-        }\n-    }\n-}"}, {"sha": "342007d46c535bb5894beac64dfb64d094f0b16d", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b1e68b9e2d75e66bc866a194b744ddf8502ca129/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1e68b9e2d75e66bc866a194b744ddf8502ca129/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=b1e68b9e2d75e66bc866a194b744ddf8502ca129", "patch": "@@ -100,6 +100,7 @@ pub mod middle {\n     pub mod recursion_limit;\n     pub mod resolve_lifetime;\n     pub mod stability;\n+    pub mod svh;\n     pub mod weak_lang_items;\n }\n "}, {"sha": "0409451043dfb55037dbb76efd15fad0a0b5b1ec", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b1e68b9e2d75e66bc866a194b744ddf8502ca129/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1e68b9e2d75e66bc866a194b744ddf8502ca129/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=b1e68b9e2d75e66bc866a194b744ddf8502ca129", "patch": "@@ -28,6 +28,7 @@ use hir::def::{self, Def};\n use middle::lang_items;\n use ty::{self, Ty, TyCtxt, VariantKind};\n use hir::def_id::{DefId, DefIndex};\n+use hir::svh::Svh;\n use mir::repr::Mir;\n use mir::mir_map::MirMap;\n use session::Session;"}, {"sha": "4533946d26ea404fb0d9daae4d4e584cb9f96357", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b1e68b9e2d75e66bc866a194b744ddf8502ca129/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b1e68b9e2d75e66bc866a194b744ddf8502ca129/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=b1e68b9e2d75e66bc866a194b744ddf8502ca129", "patch": "@@ -23,6 +23,7 @@ rustc_mir = { path = \"../librustc_mir\" }\n rustc_plugin = { path = \"../librustc_plugin\" }\n rustc_passes = { path = \"../librustc_passes\" }\n rustc_privacy = { path = \"../librustc_privacy\" }\n+rustc_incremental = { path = \"../librustc_incremental\" }\n rustc_resolve = { path = \"../librustc_resolve\" }\n rustc_save_analysis = { path = \"../librustc_save_analysis\" }\n rustc_trans = { path = \"../librustc_trans\" }"}, {"sha": "f35d5f259621f418bd96190ce453497c8cb97590", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b1e68b9e2d75e66bc866a194b744ddf8502ca129/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1e68b9e2d75e66bc866a194b744ddf8502ca129/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=b1e68b9e2d75e66bc866a194b744ddf8502ca129", "patch": "@@ -24,6 +24,7 @@ use rustc::util::common::time;\n use rustc::util::nodemap::NodeSet;\n use rustc_back::sha2::{Sha256, Digest};\n use rustc_borrowck as borrowck;\n+use rustc_incremental;\n use rustc_resolve as resolve;\n use rustc_metadata::macro_import;\n use rustc_metadata::creader::LocalCrateReader;\n@@ -952,9 +953,16 @@ pub fn phase_4_translate_to_llvm<'tcx>(tcx: &TyCtxt<'tcx>,\n         passes.run_passes(tcx, &mut mir_map);\n     });\n \n+    let translation =\n+        time(time_passes,\n+             \"translation\",\n+             move || trans::trans_crate(tcx, &mir_map, analysis));\n+\n     time(time_passes,\n-         \"translation\",\n-         move || trans::trans_crate(tcx, &mir_map, analysis))\n+         \"assert dep graph\",\n+         move || rustc_incremental::assert_dep_graph(tcx));\n+\n+    translation\n }\n \n /// Run LLVM itself, producing a bitcode file, assembly file or object file"}, {"sha": "85807dec0ffe1b28e5a1b5a067121d8e3bcdb704", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b1e68b9e2d75e66bc866a194b744ddf8502ca129/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1e68b9e2d75e66bc866a194b744ddf8502ca129/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=b1e68b9e2d75e66bc866a194b744ddf8502ca129", "patch": "@@ -45,6 +45,7 @@ extern crate rustc_passes;\n extern crate rustc_lint;\n extern crate rustc_plugin;\n extern crate rustc_privacy;\n+extern crate rustc_incremental;\n extern crate rustc_metadata;\n extern crate rustc_mir;\n extern crate rustc_resolve;"}, {"sha": "1a8b5a483e01fa92768c475b43c4a0051a9d7d64", "filename": "src/librustc_incremental/Cargo.toml", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b1e68b9e2d75e66bc866a194b744ddf8502ca129/src%2Flibrustc_incremental%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b1e68b9e2d75e66bc866a194b744ddf8502ca129/src%2Flibrustc_incremental%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2FCargo.toml?ref=b1e68b9e2d75e66bc866a194b744ddf8502ca129", "patch": "@@ -0,0 +1,17 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_serialize\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"rustc_serialize\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\"]\n+\n+[dependencies]\n+graphviz = { path = \"../libgraphviz\" }\n+rbml = { path = \"../librbml\" }\n+rustc = { path = \"../librustc\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_front = { path = \"../librustc_front\" }\n+serialize = { path = \"../libserialize\" }"}, {"sha": "88d8ed8d58118b6bb2d81dea749ac710807628f9", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "renamed", "additions": 67, "deletions": 63, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/b1e68b9e2d75e66bc866a194b744ddf8502ca129/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1e68b9e2d75e66bc866a194b744ddf8502ca129/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=b1e68b9e2d75e66bc866a194b744ddf8502ca129", "patch": "@@ -13,12 +13,17 @@\n //! will dump graphs in graphviz form to disk, and it searches for\n //! `#[rustc_if_this_changed]` and `#[rustc_then_this_would_need]`\n //! annotations. These annotations can be used to test whether paths\n-//! exist in the graph. We report errors on each\n-//! `rustc_if_this_changed` annotation. If a path exists in all\n-//! cases, then we would report \"all path(s) exist\". Otherwise, we\n-//! report: \"no path to `foo`\" for each case where no path exists.\n-//! `compile-fail` tests can then be used to check when paths exist or\n-//! do not.\n+//! exist in the graph. These checks run after trans, so they view the\n+//! the final state of the dependency graph. Note that there are\n+//! similar assertions found in `persist::dirty_clean` which check the\n+//! **initial** state of the dependency graph, just after it has been\n+//! loaded from disk.\n+//!\n+//! In this code, we report errors on each `rustc_if_this_changed`\n+//! annotation. If a path exists in all cases, then we would report\n+//! \"all path(s) exist\". Otherwise, we report: \"no path to `foo`\" for\n+//! each case where no path exists.  `compile-fail` tests can then be\n+//! used to check when paths exist or do not.\n //!\n //! The full form of the `rustc_if_this_changed` annotation is\n //! `#[rustc_if_this_changed(id)]`. The `\"id\"` is optional and\n@@ -61,7 +66,7 @@ const ID: &'static str = \"id\";\n pub fn assert_dep_graph(tcx: &TyCtxt) {\n     let _ignore = tcx.dep_graph.in_ignore();\n \n-    if tcx.sess.opts.dump_dep_graph {\n+    if tcx.sess.opts.debugging_opts.dump_dep_graph {\n         dump_graph(tcx);\n     }\n \n@@ -74,14 +79,23 @@ pub fn assert_dep_graph(tcx: &TyCtxt) {\n         (visitor.if_this_changed, visitor.then_this_would_need)\n     };\n \n+    if !if_this_changed.is_empty() || !then_this_would_need.is_empty() {\n+        assert!(tcx.sess.opts.debugging_opts.query_dep_graph,\n+                \"cannot use the `#[{}]` or `#[{}]` annotations \\\n+                 without supplying `-Z query-dep-graph`\",\n+                IF_THIS_CHANGED, THEN_THIS_WOULD_NEED);\n+    }\n+\n     // Check paths.\n     check_paths(tcx, &if_this_changed, &then_this_would_need);\n }\n \n-type SourceHashMap = FnvHashMap<InternedString,\n-                                FnvHashSet<(Span, DefId, DepNode)>>;\n-type TargetHashMap = FnvHashMap<InternedString,\n-                                FnvHashSet<(Span, InternedString, ast::NodeId, DepNode)>>;\n+type SourceHashMap =\n+    FnvHashMap<InternedString,\n+               FnvHashSet<(Span, DefId, DepNode<DefId>)>>;\n+type TargetHashMap =\n+    FnvHashMap<InternedString,\n+               FnvHashSet<(Span, InternedString, ast::NodeId, DepNode<DefId>)>>;\n \n struct IfThisChanged<'a, 'tcx:'a> {\n     tcx: &'a TyCtxt<'tcx>,\n@@ -124,34 +138,21 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n                         }\n                     }\n                 }\n-                let dep_node_str = dep_node_interned.as_ref().map(|s| &**s);\n-                macro_rules! match_depnode_name {\n-                    ($input:expr, $def_id:expr, match { $($variant:ident,)* } else $y:expr) => {\n-                        match $input {\n-                            $(Some(stringify!($variant)) => DepNode::$variant($def_id),)*\n-                            _ => $y\n+                let dep_node = match dep_node_interned {\n+                    Some(ref n) => {\n+                        match DepNode::from_label_string(&n[..], def_id) {\n+                            Ok(n) => n,\n+                            Err(()) => {\n+                                self.tcx.sess.span_fatal(\n+                                    attr.span,\n+                                    &format!(\"unrecognized DepNode variant {:?}\", n));\n+                            }\n                         }\n                     }\n-                }\n-                let dep_node = match_depnode_name! {\n-                    dep_node_str, def_id, match {\n-                        CollectItem,\n-                        BorrowCheck,\n-                        TransCrateItem,\n-                        TypeckItemType,\n-                        TypeckItemBody,\n-                        ImplOrTraitItems,\n-                        ItemSignature,\n-                        FieldTy,\n-                        TraitItemDefIds,\n-                        InherentImpls,\n-                        ImplItems,\n-                        TraitImpls,\n-                        ReprHints,\n-                    } else {\n+                    None => {\n                         self.tcx.sess.span_fatal(\n                             attr.span,\n-                            &format!(\"unrecognized DepNode variant {:?}\", dep_node_str));\n+                            &format!(\"missing DepNode variant\"));\n                     }\n                 };\n                 let id = id.unwrap_or(InternedString::new(ID));\n@@ -194,7 +195,7 @@ fn check_paths(tcx: &TyCtxt,\n         };\n \n         for &(_, source_def_id, source_dep_node) in sources {\n-            let dependents = query.dependents(source_dep_node);\n+            let dependents = query.transitive_dependents(source_dep_node);\n             for &(target_span, ref target_pass, _, ref target_dep_node) in targets {\n                 if !dependents.contains(&target_dep_node) {\n                     tcx.sess.span_err(\n@@ -251,49 +252,52 @@ fn dump_graph(tcx: &TyCtxt) {\n     }\n }\n \n-pub struct GraphvizDepGraph(FnvHashSet<DepNode>, Vec<(DepNode, DepNode)>);\n+pub struct GraphvizDepGraph(FnvHashSet<DepNode<DefId>>,\n+                            Vec<(DepNode<DefId>, DepNode<DefId>)>);\n \n impl<'a, 'tcx> dot::GraphWalk<'a> for GraphvizDepGraph {\n-    type Node = DepNode;\n-    type Edge = (DepNode, DepNode);\n-    fn nodes(&self) -> dot::Nodes<DepNode> {\n+    type Node = DepNode<DefId>;\n+    type Edge = (DepNode<DefId>, DepNode<DefId>);\n+    fn nodes(&self) -> dot::Nodes<DepNode<DefId>> {\n         let nodes: Vec<_> = self.0.iter().cloned().collect();\n         nodes.into_cow()\n     }\n-    fn edges(&self) -> dot::Edges<(DepNode, DepNode)> {\n+    fn edges(&self) -> dot::Edges<(DepNode<DefId>, DepNode<DefId>)> {\n         self.1[..].into_cow()\n     }\n-    fn source(&self, edge: &(DepNode, DepNode)) -> DepNode {\n+    fn source(&self, edge: &(DepNode<DefId>, DepNode<DefId>)) -> DepNode<DefId> {\n         edge.0\n     }\n-    fn target(&self, edge: &(DepNode, DepNode)) -> DepNode {\n+    fn target(&self, edge: &(DepNode<DefId>, DepNode<DefId>)) -> DepNode<DefId> {\n         edge.1\n     }\n }\n \n impl<'a, 'tcx> dot::Labeller<'a> for GraphvizDepGraph {\n-    type Node = DepNode;\n-    type Edge = (DepNode, DepNode);\n+    type Node = DepNode<DefId>;\n+    type Edge = (DepNode<DefId>, DepNode<DefId>);\n     fn graph_id(&self) -> dot::Id {\n         dot::Id::new(\"DependencyGraph\").unwrap()\n     }\n-    fn node_id(&self, n: &DepNode) -> dot::Id {\n+    fn node_id(&self, n: &DepNode<DefId>) -> dot::Id {\n         let s: String =\n             format!(\"{:?}\", n).chars()\n                               .map(|c| if c == '_' || c.is_alphanumeric() { c } else { '_' })\n                               .collect();\n         debug!(\"n={:?} s={:?}\", n, s);\n         dot::Id::new(s).unwrap()\n     }\n-    fn node_label(&self, n: &DepNode) -> dot::LabelText {\n+    fn node_label(&self, n: &DepNode<DefId>) -> dot::LabelText {\n         dot::LabelText::label(format!(\"{:?}\", n))\n     }\n }\n \n // Given an optional filter like `\"x,y,z\"`, returns either `None` (no\n // filter) or the set of nodes whose labels contain all of those\n // substrings.\n-fn node_set(query: &DepGraphQuery, filter: &str) -> Option<FnvHashSet<DepNode>> {\n+fn node_set(query: &DepGraphQuery<DefId>, filter: &str)\n+            -> Option<FnvHashSet<DepNode<DefId>>>\n+{\n     debug!(\"node_set(filter={:?})\", filter);\n \n     if filter.trim().is_empty() {\n@@ -313,10 +317,10 @@ fn node_set(query: &DepGraphQuery, filter: &str) -> Option<FnvHashSet<DepNode>>\n         .collect())\n }\n \n-fn filter_nodes(query: &DepGraphQuery,\n-                sources: &Option<FnvHashSet<DepNode>>,\n-                targets: &Option<FnvHashSet<DepNode>>)\n-                -> FnvHashSet<DepNode>\n+fn filter_nodes(query: &DepGraphQuery<DefId>,\n+                sources: &Option<FnvHashSet<DepNode<DefId>>>,\n+                targets: &Option<FnvHashSet<DepNode<DefId>>>)\n+                -> FnvHashSet<DepNode<DefId>>\n {\n     if let &Some(ref sources) = sources {\n         if let &Some(ref targets) = targets {\n@@ -331,10 +335,10 @@ fn filter_nodes(query: &DepGraphQuery,\n     }\n }\n \n-fn walk_nodes(query: &DepGraphQuery,\n-              starts: &FnvHashSet<DepNode>,\n+fn walk_nodes(query: &DepGraphQuery<DefId>,\n+              starts: &FnvHashSet<DepNode<DefId>>,\n               direction: Direction)\n-              -> FnvHashSet<DepNode>\n+              -> FnvHashSet<DepNode<DefId>>\n {\n     let mut set = FnvHashSet();\n     for start in starts {\n@@ -355,10 +359,10 @@ fn walk_nodes(query: &DepGraphQuery,\n     set\n }\n \n-fn walk_between(query: &DepGraphQuery,\n-                sources: &FnvHashSet<DepNode>,\n-                targets: &FnvHashSet<DepNode>)\n-                -> FnvHashSet<DepNode>\n+fn walk_between(query: &DepGraphQuery<DefId>,\n+                sources: &FnvHashSet<DepNode<DefId>>,\n+                targets: &FnvHashSet<DepNode<DefId>>)\n+                -> FnvHashSet<DepNode<DefId>>\n {\n     // This is a bit tricky. We want to include a node only if it is:\n     // (a) reachable from a source and (b) will reach a target. And we\n@@ -386,7 +390,7 @@ fn walk_between(query: &DepGraphQuery,\n                 })\n                 .collect();\n \n-    fn recurse(query: &DepGraphQuery,\n+    fn recurse(query: &DepGraphQuery<DefId>,\n                node_states: &mut [State],\n                node: NodeIndex)\n                -> bool\n@@ -423,9 +427,9 @@ fn walk_between(query: &DepGraphQuery,\n     }\n }\n \n-fn filter_edges(query: &DepGraphQuery,\n-                nodes: &FnvHashSet<DepNode>)\n-                -> Vec<(DepNode, DepNode)>\n+fn filter_edges(query: &DepGraphQuery<DefId>,\n+                nodes: &FnvHashSet<DepNode<DefId>>)\n+                -> Vec<(DepNode<DefId>, DepNode<DefId>)>\n {\n     query.edges()\n          .into_iter()", "previous_filename": "src/librustc_trans/assert_dep_graph.rs"}, {"sha": "158db34ee8ac91b01068353a91f249d9445e6347", "filename": "src/librustc_incremental/calculate_svh.rs", "status": "added", "additions": 420, "deletions": 0, "changes": 420, "blob_url": "https://github.com/rust-lang/rust/blob/b1e68b9e2d75e66bc866a194b744ddf8502ca129/src%2Flibrustc_incremental%2Fcalculate_svh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1e68b9e2d75e66bc866a194b744ddf8502ca129/src%2Flibrustc_incremental%2Fcalculate_svh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh.rs?ref=b1e68b9e2d75e66bc866a194b744ddf8502ca129", "patch": "@@ -0,0 +1,420 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Calculation of a Strict Version Hash for crates.  For a length\n+//! comment explaining the general idea, see `librustc/middle/svh.rs`.\n+\n+use std::hash::{Hash, SipHasher, Hasher};\n+use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n+use rustc::hir::svh::Svh;\n+use rustc::ty;\n+use rustc_front::intravisit::{self, Visitor};\n+\n+use self::svh_visitor::StrictVersionHashVisitor;\n+\n+pub trait SvhCalculate {\n+    /// Calculate the SVH for an entire krate.\n+    fn calculate_krate_hash(&self) -> Svh;\n+\n+    /// Calculate the SVH for a particular item.\n+    fn calculate_item_hash(&self, def_id: DefId) -> u64;\n+}\n+\n+impl<'tcx> SvhCalculate for ty::TyCtxt<'tcx> {\n+    fn calculate_krate_hash(&self) -> Svh {\n+        // FIXME (#14132): This is better than it used to be, but it still not\n+        // ideal. We now attempt to hash only the relevant portions of the\n+        // Crate AST as well as the top-level crate attributes. (However,\n+        // the hashing of the crate attributes should be double-checked\n+        // to ensure it is not incorporating implementation artifacts into\n+        // the hash that are not otherwise visible.)\n+\n+        let crate_disambiguator = self.sess.crate_disambiguator.get();\n+        let krate = self.map.krate();\n+\n+        // FIXME: this should use SHA1, not SipHash. SipHash is not built to\n+        //        avoid collisions.\n+        let mut state = SipHasher::new();\n+        debug!(\"state: {:?}\", state);\n+\n+        \"crate_disambiguator\".hash(&mut state);\n+        crate_disambiguator.as_str().len().hash(&mut state);\n+        crate_disambiguator.as_str().hash(&mut state);\n+\n+        debug!(\"crate_disambiguator: {:?}\", crate_disambiguator.as_str());\n+        debug!(\"state: {:?}\", state);\n+\n+        {\n+            let mut visit = StrictVersionHashVisitor::new(&mut state, self);\n+            krate.visit_all_items(&mut visit);\n+        }\n+\n+        // FIXME (#14132): This hash is still sensitive to e.g. the\n+        // spans of the crate Attributes and their underlying\n+        // MetaItems; we should make ContentHashable impl for those\n+        // types and then use hash_content.  But, since all crate\n+        // attributes should appear near beginning of the file, it is\n+        // not such a big deal to be sensitive to their spans for now.\n+        //\n+        // We hash only the MetaItems instead of the entire Attribute\n+        // to avoid hashing the AttrId\n+        for attr in &krate.attrs {\n+            debug!(\"krate attr {:?}\", attr);\n+            attr.node.value.hash(&mut state);\n+        }\n+\n+        Svh::from_hash(state.finish())\n+    }\n+\n+    fn calculate_item_hash(&self, def_id: DefId) -> u64 {\n+        assert!(def_id.is_local());\n+\n+        let mut state = SipHasher::new();\n+\n+        {\n+            let mut visit = StrictVersionHashVisitor::new(&mut state, self);\n+            if def_id.index == CRATE_DEF_INDEX {\n+                // the crate root itself is not registered in the map\n+                // as an item, so we have to fetch it this way\n+                let krate = self.map.krate();\n+                intravisit::walk_crate(&mut visit, krate);\n+            } else {\n+                let node_id = self.map.as_local_node_id(def_id).unwrap();\n+                visit.visit_item(self.map.expect_item(node_id));\n+            }\n+        }\n+\n+        state.finish()\n+    }\n+}\n+\n+// FIXME (#14132): Even this SVH computation still has implementation\n+// artifacts: namely, the order of item declaration will affect the\n+// hash computation, but for many kinds of items the order of\n+// declaration should be irrelevant to the ABI.\n+\n+mod svh_visitor {\n+    pub use self::SawExprComponent::*;\n+    pub use self::SawStmtComponent::*;\n+    use self::SawAbiComponent::*;\n+    use syntax::ast::{self, Name, NodeId};\n+    use syntax::codemap::Span;\n+    use syntax::parse::token;\n+    use rustc::ty;\n+    use rustc_front::intravisit as visit;\n+    use rustc_front::intravisit::{Visitor, FnKind};\n+    use rustc_front::hir::*;\n+    use rustc_front::hir;\n+\n+    use std::hash::{Hash, SipHasher};\n+\n+    pub struct StrictVersionHashVisitor<'a, 'tcx: 'a> {\n+        pub tcx: &'a ty::TyCtxt<'tcx>,\n+        pub st: &'a mut SipHasher,\n+    }\n+\n+    impl<'a, 'tcx> StrictVersionHashVisitor<'a, 'tcx> {\n+        pub fn new(st: &'a mut SipHasher,\n+                   tcx: &'a ty::TyCtxt<'tcx>)\n+                   -> Self {\n+            StrictVersionHashVisitor { st: st, tcx: tcx }\n+        }\n+    }\n+\n+    // To off-load the bulk of the hash-computation on #[derive(Hash)],\n+    // we define a set of enums corresponding to the content that our\n+    // crate visitor will encounter as it traverses the ast.\n+    //\n+    // The important invariant is that all of the Saw*Component enums\n+    // do not carry any Spans, Names, or Idents.\n+    //\n+    // Not carrying any Names/Idents is the important fix for problem\n+    // noted on PR #13948: using the ident.name as the basis for a\n+    // hash leads to unstable SVH, because ident.name is just an index\n+    // into intern table (i.e. essentially a random address), not\n+    // computed from the name content.\n+    //\n+    // With the below enums, the SVH computation is not sensitive to\n+    // artifacts of how rustc was invoked nor of how the source code\n+    // was laid out.  (Or at least it is *less* sensitive.)\n+\n+    // This enum represents the different potential bits of code the\n+    // visitor could encounter that could affect the ABI for the crate,\n+    // and assigns each a distinct tag to feed into the hash computation.\n+    #[derive(Hash)]\n+    enum SawAbiComponent<'a> {\n+\n+        // FIXME (#14132): should we include (some function of)\n+        // ident.ctxt as well?\n+        SawIdent(token::InternedString),\n+        SawStructDef(token::InternedString),\n+\n+        SawLifetime(token::InternedString),\n+        SawLifetimeDef(token::InternedString),\n+\n+        SawMod,\n+        SawForeignItem,\n+        SawItem,\n+        SawDecl,\n+        SawTy,\n+        SawGenerics,\n+        SawFn,\n+        SawTraitItem,\n+        SawImplItem,\n+        SawStructField,\n+        SawVariant,\n+        SawExplicitSelf,\n+        SawPath,\n+        SawBlock,\n+        SawPat,\n+        SawLocal,\n+        SawArm,\n+        SawExpr(SawExprComponent<'a>),\n+        SawStmt(SawStmtComponent),\n+    }\n+\n+    /// SawExprComponent carries all of the information that we want\n+    /// to include in the hash that *won't* be covered by the\n+    /// subsequent recursive traversal of the expression's\n+    /// substructure by the visitor.\n+    ///\n+    /// We know every Expr_ variant is covered by a variant because\n+    /// `fn saw_expr` maps each to some case below.  Ensuring that\n+    /// each variant carries an appropriate payload has to be verified\n+    /// by hand.\n+    ///\n+    /// (However, getting that *exactly* right is not so important\n+    /// because the SVH is just a developer convenience; there is no\n+    /// guarantee of collision-freedom, hash collisions are just\n+    /// (hopefully) unlikely.)\n+    #[derive(Hash)]\n+    pub enum SawExprComponent<'a> {\n+\n+        SawExprLoop(Option<token::InternedString>),\n+        SawExprField(token::InternedString),\n+        SawExprTupField(usize),\n+        SawExprBreak(Option<token::InternedString>),\n+        SawExprAgain(Option<token::InternedString>),\n+\n+        SawExprBox,\n+        SawExprVec,\n+        SawExprCall,\n+        SawExprMethodCall,\n+        SawExprTup,\n+        SawExprBinary(hir::BinOp_),\n+        SawExprUnary(hir::UnOp),\n+        SawExprLit(ast::LitKind),\n+        SawExprCast,\n+        SawExprType,\n+        SawExprIf,\n+        SawExprWhile,\n+        SawExprMatch,\n+        SawExprClosure,\n+        SawExprBlock,\n+        SawExprAssign,\n+        SawExprAssignOp(hir::BinOp_),\n+        SawExprIndex,\n+        SawExprPath(Option<usize>),\n+        SawExprAddrOf(hir::Mutability),\n+        SawExprRet,\n+        SawExprInlineAsm(&'a hir::InlineAsm),\n+        SawExprStruct,\n+        SawExprRepeat,\n+    }\n+\n+    fn saw_expr<'a>(node: &'a Expr_) -> SawExprComponent<'a> {\n+        match *node {\n+            ExprBox(..)              => SawExprBox,\n+            ExprVec(..)              => SawExprVec,\n+            ExprCall(..)             => SawExprCall,\n+            ExprMethodCall(..)       => SawExprMethodCall,\n+            ExprTup(..)              => SawExprTup,\n+            ExprBinary(op, _, _)     => SawExprBinary(op.node),\n+            ExprUnary(op, _)         => SawExprUnary(op),\n+            ExprLit(ref lit)         => SawExprLit(lit.node.clone()),\n+            ExprCast(..)             => SawExprCast,\n+            ExprType(..)             => SawExprType,\n+            ExprIf(..)               => SawExprIf,\n+            ExprWhile(..)            => SawExprWhile,\n+            ExprLoop(_, id)          => SawExprLoop(id.map(|id| id.name.as_str())),\n+            ExprMatch(..)            => SawExprMatch,\n+            ExprClosure(..)          => SawExprClosure,\n+            ExprBlock(..)            => SawExprBlock,\n+            ExprAssign(..)           => SawExprAssign,\n+            ExprAssignOp(op, _, _)   => SawExprAssignOp(op.node),\n+            ExprField(_, name)       => SawExprField(name.node.as_str()),\n+            ExprTupField(_, id)      => SawExprTupField(id.node),\n+            ExprIndex(..)            => SawExprIndex,\n+            ExprPath(ref qself, _)   => SawExprPath(qself.as_ref().map(|q| q.position)),\n+            ExprAddrOf(m, _)         => SawExprAddrOf(m),\n+            ExprBreak(id)            => SawExprBreak(id.map(|id| id.node.name.as_str())),\n+            ExprAgain(id)            => SawExprAgain(id.map(|id| id.node.name.as_str())),\n+            ExprRet(..)              => SawExprRet,\n+            ExprInlineAsm(ref a,_,_) => SawExprInlineAsm(a),\n+            ExprStruct(..)           => SawExprStruct,\n+            ExprRepeat(..)           => SawExprRepeat,\n+        }\n+    }\n+\n+    /// SawStmtComponent is analogous to SawExprComponent, but for statements.\n+    #[derive(Hash)]\n+    pub enum SawStmtComponent {\n+        SawStmtDecl,\n+        SawStmtExpr,\n+        SawStmtSemi,\n+    }\n+\n+    fn saw_stmt(node: &Stmt_) -> SawStmtComponent {\n+        match *node {\n+            StmtDecl(..) => SawStmtDecl,\n+            StmtExpr(..) => SawStmtExpr,\n+            StmtSemi(..) => SawStmtSemi,\n+        }\n+    }\n+\n+    impl<'a, 'tcx> Visitor<'a> for StrictVersionHashVisitor<'a, 'tcx> {\n+        fn visit_nested_item(&mut self, item: ItemId) {\n+            debug!(\"visit_nested_item: {:?} st={:?}\", item, self.st);\n+            let def_path = self.tcx.map.def_path_from_id(item.id);\n+            def_path.hash(self.st);\n+        }\n+\n+        fn visit_variant_data(&mut self, s: &'a VariantData, name: Name,\n+                              g: &'a Generics, _: NodeId, _: Span) {\n+            SawStructDef(name.as_str()).hash(self.st);\n+            visit::walk_generics(self, g);\n+            visit::walk_struct_def(self, s)\n+        }\n+\n+        fn visit_variant(&mut self, v: &'a Variant, g: &'a Generics, item_id: NodeId) {\n+            SawVariant.hash(self.st);\n+            // walk_variant does not call walk_generics, so do it here.\n+            visit::walk_generics(self, g);\n+            visit::walk_variant(self, v, g, item_id)\n+        }\n+\n+        // All of the remaining methods just record (in the hash\n+        // SipHasher) that the visitor saw that particular variant\n+        // (with its payload), and continue walking as the default\n+        // visitor would.\n+        //\n+        // Some of the implementations have some notes as to how one\n+        // might try to make their SVH computation less discerning\n+        // (e.g. by incorporating reachability analysis).  But\n+        // currently all of their implementations are uniform and\n+        // uninteresting.\n+        //\n+        // (If you edit a method such that it deviates from the\n+        // pattern, please move that method up above this comment.)\n+\n+        fn visit_name(&mut self, _: Span, name: Name) {\n+            SawIdent(name.as_str()).hash(self.st);\n+        }\n+\n+        fn visit_lifetime(&mut self, l: &'a Lifetime) {\n+            SawLifetime(l.name.as_str()).hash(self.st);\n+        }\n+\n+        fn visit_lifetime_def(&mut self, l: &'a LifetimeDef) {\n+            SawLifetimeDef(l.lifetime.name.as_str()).hash(self.st);\n+        }\n+\n+        // We do recursively walk the bodies of functions/methods\n+        // (rather than omitting their bodies from the hash) since\n+        // monomorphization and cross-crate inlining generally implies\n+        // that a change to a crate body will require downstream\n+        // crates to be recompiled.\n+        fn visit_expr(&mut self, ex: &'a Expr) {\n+            SawExpr(saw_expr(&ex.node)).hash(self.st); visit::walk_expr(self, ex)\n+        }\n+\n+        fn visit_stmt(&mut self, s: &'a Stmt) {\n+            SawStmt(saw_stmt(&s.node)).hash(self.st); visit::walk_stmt(self, s)\n+        }\n+\n+        fn visit_foreign_item(&mut self, i: &'a ForeignItem) {\n+            // FIXME (#14132) ideally we would incorporate privacy (or\n+            // perhaps reachability) somewhere here, so foreign items\n+            // that do not leak into downstream crates would not be\n+            // part of the ABI.\n+            SawForeignItem.hash(self.st); visit::walk_foreign_item(self, i)\n+        }\n+\n+        fn visit_item(&mut self, i: &'a Item) {\n+            debug!(\"visit_item: {:?} st={:?}\", i, self.st);\n+            // FIXME (#14132) ideally would incorporate reachability\n+            // analysis somewhere here, so items that never leak into\n+            // downstream crates (e.g. via monomorphisation or\n+            // inlining) would not be part of the ABI.\n+            SawItem.hash(self.st); visit::walk_item(self, i)\n+        }\n+\n+        fn visit_mod(&mut self, m: &'a Mod, _s: Span, _n: NodeId) {\n+            SawMod.hash(self.st); visit::walk_mod(self, m)\n+        }\n+\n+        fn visit_decl(&mut self, d: &'a Decl) {\n+            SawDecl.hash(self.st); visit::walk_decl(self, d)\n+        }\n+\n+        fn visit_ty(&mut self, t: &'a Ty) {\n+            SawTy.hash(self.st); visit::walk_ty(self, t)\n+        }\n+\n+        fn visit_generics(&mut self, g: &'a Generics) {\n+            SawGenerics.hash(self.st); visit::walk_generics(self, g)\n+        }\n+\n+        fn visit_fn(&mut self, fk: FnKind<'a>, fd: &'a FnDecl,\n+                    b: &'a Block, s: Span, _: NodeId) {\n+            SawFn.hash(self.st); visit::walk_fn(self, fk, fd, b, s)\n+        }\n+\n+        fn visit_trait_item(&mut self, ti: &'a TraitItem) {\n+            SawTraitItem.hash(self.st); visit::walk_trait_item(self, ti)\n+        }\n+\n+        fn visit_impl_item(&mut self, ii: &'a ImplItem) {\n+            SawImplItem.hash(self.st); visit::walk_impl_item(self, ii)\n+        }\n+\n+        fn visit_struct_field(&mut self, s: &'a StructField) {\n+            SawStructField.hash(self.st); visit::walk_struct_field(self, s)\n+        }\n+\n+        fn visit_explicit_self(&mut self, es: &'a ExplicitSelf) {\n+            SawExplicitSelf.hash(self.st); visit::walk_explicit_self(self, es)\n+        }\n+\n+        fn visit_path(&mut self, path: &'a Path, _: ast::NodeId) {\n+            SawPath.hash(self.st); visit::walk_path(self, path)\n+        }\n+\n+        fn visit_path_list_item(&mut self, prefix: &'a Path, item: &'a PathListItem) {\n+            SawPath.hash(self.st); visit::walk_path_list_item(self, prefix, item)\n+        }\n+\n+        fn visit_block(&mut self, b: &'a Block) {\n+            SawBlock.hash(self.st); visit::walk_block(self, b)\n+        }\n+\n+        fn visit_pat(&mut self, p: &'a Pat) {\n+            SawPat.hash(self.st); visit::walk_pat(self, p)\n+        }\n+\n+        fn visit_local(&mut self, l: &'a Local) {\n+            SawLocal.hash(self.st); visit::walk_local(self, l)\n+        }\n+\n+        fn visit_arm(&mut self, a: &'a Arm) {\n+            SawArm.hash(self.st); visit::walk_arm(self, a)\n+        }\n+    }\n+}"}, {"sha": "3af8fe5cc5f90b586c49b4e667311bf180a60f62", "filename": "src/librustc_incremental/lib.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b1e68b9e2d75e66bc866a194b744ddf8502ca129/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1e68b9e2d75e66bc866a194b744ddf8502ca129/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=b1e68b9e2d75e66bc866a194b744ddf8502ca129", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Support for serializing the dep-graph and reloading it.\n+\n+#![crate_name = \"rustc_incremental\"]\n+#![unstable(feature = \"rustc_private\", issue = \"27812\")]\n+#![crate_type = \"dylib\"]\n+#![crate_type = \"rlib\"]\n+#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+      html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n+      html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![cfg_attr(not(stage0), deny(warnings))]\n+\n+#![feature(rustc_private)]\n+#![feature(staged_api)]\n+\n+extern crate graphviz;\n+extern crate rbml;\n+extern crate rustc;\n+extern crate rustc_data_structures;\n+extern crate serialize as rustc_serialize;\n+\n+#[macro_use] extern crate log;\n+#[macro_use] extern crate syntax;\n+\n+mod assert_dep_graph;\n+mod calculate_svh;\n+mod persist;\n+\n+pub use assert_dep_graph::assert_dep_graph;\n+pub use calculate_svh::SvhCalculate;\n+pub use persist::load_dep_graph;\n+pub use persist::save_dep_graph;"}, {"sha": "bb95104ffeaf6c4e741ec301face3dd8414b9e52", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b1e68b9e2d75e66bc866a194b744ddf8502ca129/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1e68b9e2d75e66bc866a194b744ddf8502ca129/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=b1e68b9e2d75e66bc866a194b744ddf8502ca129", "patch": "@@ -1242,7 +1242,7 @@ pub fn get_crate_deps(data: &[u8]) -> Vec<CrateDep> {\n \n     reader::tagged_docs(depsdoc, tag_crate_dep).enumerate().map(|(crate_num, depdoc)| {\n         let name = docstr(depdoc, tag_crate_dep_crate_name);\n-        let hash = Svh::new(&docstr(depdoc, tag_crate_dep_hash));\n+        let hash = Svh::new(docstr(depdoc, tag_crate_dep_hash));\n         let doc = reader::get_doc(depdoc, tag_crate_dep_explicitly_linked);\n         let explicitly_linked = reader::doc_as_u8(doc) != 0;\n         CrateDep {\n@@ -1266,14 +1266,14 @@ fn list_crate_deps(data: &[u8], out: &mut io::Write) -> io::Result<()> {\n pub fn maybe_get_crate_hash(data: &[u8]) -> Option<Svh> {\n     let cratedoc = rbml::Doc::new(data);\n     reader::maybe_get_doc(cratedoc, tag_crate_hash).map(|doc| {\n-        Svh::new(doc.as_str_slice())\n+        Svh::new(doc.as_str_slice().to_string())\n     })\n }\n \n pub fn get_crate_hash(data: &[u8]) -> Svh {\n     let cratedoc = rbml::Doc::new(data);\n     let hashdoc = reader::get_doc(cratedoc, tag_crate_hash);\n-    Svh::new(hashdoc.as_str_slice())\n+    Svh::new(hashdoc.as_str_slice().to_string())\n }\n \n pub fn maybe_get_crate_name(data: &[u8]) -> Option<&str> {"}, {"sha": "ccb430fbb782fe3d8e777319e6645177ba610f8b", "filename": "src/librustc_trans/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b1e68b9e2d75e66bc866a194b744ddf8502ca129/src%2Flibrustc_trans%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b1e68b9e2d75e66bc866a194b744ddf8502ca129/src%2Flibrustc_trans%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FCargo.toml?ref=b1e68b9e2d75e66bc866a194b744ddf8502ca129", "patch": "@@ -18,6 +18,7 @@ rustc_back = { path = \"../librustc_back\" }\n rustc_const_eval = { path = \"../librustc_const_eval\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_incremental = { path = \"../librustc_incremental\" }\n rustc_llvm = { path = \"../librustc_llvm\" }\n rustc_mir = { path = \"../librustc_mir\" }\n rustc_platform_intrinsics = { path = \"../librustc_platform_intrinsics\" }"}, {"sha": "1d15e67651aa592a262b69b57b6b8dea3b1bb12b", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b1e68b9e2d75e66bc866a194b744ddf8502ca129/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1e68b9e2d75e66bc866a194b744ddf8502ca129/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=b1e68b9e2d75e66bc866a194b744ddf8502ca129", "patch": "@@ -13,7 +13,6 @@ use super::linker::{Linker, GnuLinker, MsvcLinker};\n use super::rpath::RPathConfig;\n use super::rpath;\n use super::msvc;\n-use super::svh::Svh;\n use session::config;\n use session::config::NoDebugInfo;\n use session::config::{OutputFilenames, Input, OutputType};\n@@ -26,8 +25,10 @@ use middle::dependency_format::Linkage;\n use CrateTranslation;\n use util::common::time;\n use util::fs::fix_windows_verbatim_for_gcc;\n+use rustc::ty::TyCtxt;\n use rustc_back::tempdir::TempDir;\n \n+use rustc_incremental::SvhCalculate;\n use std::ascii;\n use std::char;\n use std::env;\n@@ -122,15 +123,15 @@ pub fn find_crate_name(sess: Option<&Session>,\n     }\n \n     \"rust_out\".to_string()\n+\n }\n \n-pub fn build_link_meta(sess: &Session,\n-                       krate: &hir::Crate,\n+pub fn build_link_meta(tcx: &TyCtxt,\n                        name: &str)\n                        -> LinkMeta {\n     let r = LinkMeta {\n         crate_name: name.to_owned(),\n-        crate_hash: Svh::calculate(&sess.crate_disambiguator.get().as_str(), krate),\n+        crate_hash: tcx.calculate_krate_hash(),\n     };\n     info!(\"{:?}\", r);\n     return r;"}, {"sha": "17230eff6e639aa382f89c98d252a7a99950a83e", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b1e68b9e2d75e66bc866a194b744ddf8502ca129/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1e68b9e2d75e66bc866a194b744ddf8502ca129/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=b1e68b9e2d75e66bc866a194b744ddf8502ca129", "patch": "@@ -54,7 +54,6 @@ use session::Session;\n use _match;\n use abi::{self, Abi, FnType};\n use adt;\n-use assert_dep_graph;\n use attributes;\n use build::*;\n use builder::{Builder, noname};\n@@ -2730,7 +2729,7 @@ pub fn trans_crate<'tcx>(tcx: &TyCtxt<'tcx>,\n         }\n     }\n \n-    let link_meta = link::build_link_meta(&tcx.sess, krate, name);\n+    let link_meta = link::build_link_meta(&tcx, name);\n \n     let codegen_units = tcx.sess.opts.cg.codegen_units;\n     let shared_ccx = SharedCrateContext::new(&link_meta.crate_name,\n@@ -2856,8 +2855,6 @@ pub fn trans_crate<'tcx>(tcx: &TyCtxt<'tcx>,\n     };\n     let no_builtins = attr::contains_name(&krate.attrs, \"no_builtins\");\n \n-    assert_dep_graph::assert_dep_graph(tcx);\n-\n     CrateTranslation {\n         modules: modules,\n         metadata_module: metadata_module,"}, {"sha": "cb421b6be472b077a3be091b2d1030cb6a002f84", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1e68b9e2d75e66bc866a194b744ddf8502ca129/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1e68b9e2d75e66bc866a194b744ddf8502ca129/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=b1e68b9e2d75e66bc866a194b744ddf8502ca129", "patch": "@@ -46,6 +46,7 @@ extern crate libc;\n #[macro_use] extern crate rustc;\n extern crate rustc_back;\n extern crate rustc_data_structures;\n+extern crate rustc_incremental;\n pub extern crate rustc_llvm as llvm;\n extern crate rustc_mir;\n extern crate rustc_platform_intrinsics as intrinsics;\n@@ -85,7 +86,6 @@ mod macros;\n mod abi;\n mod adt;\n mod asm;\n-mod assert_dep_graph;\n mod attributes;\n mod base;\n mod basic_block;"}]}