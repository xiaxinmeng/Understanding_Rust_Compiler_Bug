{"sha": "e3310a6a18d83016209d758ca2694fa1909f74f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzMzEwYTZhMThkODMwMTYyMDlkNzU4Y2EyNjk0ZmExOTA5Zjc0ZjM=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-07-11T12:53:10Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-07-11T12:53:10Z"}, "message": "Format source codes", "tree": {"sha": "9c49db5ec24774e4bb67d5dad85c9e746d7a8dd1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c49db5ec24774e4bb67d5dad85c9e746d7a8dd1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3310a6a18d83016209d758ca2694fa1909f74f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3310a6a18d83016209d758ca2694fa1909f74f3", "html_url": "https://github.com/rust-lang/rust/commit/e3310a6a18d83016209d758ca2694fa1909f74f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3310a6a18d83016209d758ca2694fa1909f74f3/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "08f3f03353b88c3845ae67efbdb86b4669f94ca7", "url": "https://api.github.com/repos/rust-lang/rust/commits/08f3f03353b88c3845ae67efbdb86b4669f94ca7", "html_url": "https://github.com/rust-lang/rust/commit/08f3f03353b88c3845ae67efbdb86b4669f94ca7"}], "stats": {"total": 830, "additions": 350, "deletions": 480}, "files": [{"sha": "3f7d11c0a97de22fa867ce7287ec2351fac116d2", "filename": "src/bin/cargo-fmt.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e3310a6a18d83016209d758ca2694fa1909f74f3/src%2Fbin%2Fcargo-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3310a6a18d83016209d758ca2694fa1909f74f3/src%2Fbin%2Fcargo-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcargo-fmt.rs?ref=e3310a6a18d83016209d758ca2694fa1909f74f3", "patch": "@@ -90,13 +90,11 @@ fn execute() -> i32 {\n             print_usage(&opts, &e.to_string());\n             failure\n         }\n-        Ok(status) => {\n-            if status.success() {\n-                success\n-            } else {\n-                status.code().unwrap_or(failure)\n-            }\n-        }\n+        Ok(status) => if status.success() {\n+            success\n+        } else {\n+            status.code().unwrap_or(failure)\n+        },\n     }\n }\n \n@@ -324,12 +322,10 @@ fn format_files(\n         .args(fmt_args)\n         .spawn()\n         .map_err(|e| match e.kind() {\n-            std::io::ErrorKind::NotFound => {\n-                std::io::Error::new(\n-                    std::io::ErrorKind::Other,\n-                    \"Could not run rustfmt, please make sure it is in your PATH.\",\n-                )\n-            }\n+            std::io::ErrorKind::NotFound => std::io::Error::new(\n+                std::io::ErrorKind::Other,\n+                \"Could not run rustfmt, please make sure it is in your PATH.\",\n+            ),\n             _ => e,\n         })?;\n     command.wait()"}, {"sha": "1660e113dcd23cd199ebf2544719fd4c9e28a197", "filename": "src/chains.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e3310a6a18d83016209d758ca2694fa1909f74f3/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3310a6a18d83016209d758ca2694fa1909f74f3/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=e3310a6a18d83016209d758ca2694fa1909f74f3", "patch": "@@ -444,12 +444,10 @@ fn rewrite_method_call_with_overflow(\n             None => return false,\n         };\n         let types = match segment.parameters {\n-            Some(ref params) => {\n-                match **params {\n-                    ast::PathParameters::AngleBracketed(ref data) => &data.types[..],\n-                    _ => &[],\n-                }\n-            }\n+            Some(ref params) => match **params {\n+                ast::PathParameters::AngleBracketed(ref data) => &data.types[..],\n+                _ => &[],\n+            },\n             _ => &[],\n         };\n         let mut last_rewrite = rewrite_method_call(\n@@ -516,12 +514,10 @@ fn rewrite_chain_subexpr(\n     match expr.node {\n         ast::ExprKind::MethodCall(ref segment, ref expressions) => {\n             let types = match segment.parameters {\n-                Some(ref params) => {\n-                    match **params {\n-                        ast::PathParameters::AngleBracketed(ref data) => &data.types[..],\n-                        _ => &[],\n-                    }\n-                }\n+                Some(ref params) => match **params {\n+                    ast::PathParameters::AngleBracketed(ref data) => &data.types[..],\n+                    _ => &[],\n+                },\n                 _ => &[],\n             };\n             rewrite_method_call(segment.identifier, types, expressions, span, context, shape)"}, {"sha": "df97c2bfef3ec5eee31a217698e90a1115fefa60", "filename": "src/comment.rs", "status": "modified", "additions": 38, "deletions": 50, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/e3310a6a18d83016209d758ca2694fa1909f74f3/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3310a6a18d83016209d758ca2694fa1909f74f3/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=e3310a6a18d83016209d758ca2694fa1909f74f3", "patch": "@@ -342,14 +342,12 @@ impl FindUncommented for str {\n                 None => {\n                     return Some(i - pat.len());\n                 }\n-                Some(c) => {\n-                    match kind {\n-                        FullCodeCharKind::Normal if b == c => {}\n-                        _ => {\n-                            needle_iter = pat.chars();\n-                        }\n+                Some(c) => match kind {\n+                    FullCodeCharKind::Normal if b == c => {}\n+                    _ => {\n+                        needle_iter = pat.chars();\n                     }\n-                }\n+                },\n             }\n         }\n \n@@ -494,42 +492,34 @@ where\n         let item = try_opt!(self.base.next());\n         let chr = item.get_char();\n         self.status = match self.status {\n-            CharClassesStatus::LitString => {\n-                match chr {\n-                    '\"' => CharClassesStatus::Normal,\n-                    '\\\\' => CharClassesStatus::LitStringEscape,\n-                    _ => CharClassesStatus::LitString,\n-                }\n-            }\n+            CharClassesStatus::LitString => match chr {\n+                '\"' => CharClassesStatus::Normal,\n+                '\\\\' => CharClassesStatus::LitStringEscape,\n+                _ => CharClassesStatus::LitString,\n+            },\n             CharClassesStatus::LitStringEscape => CharClassesStatus::LitString,\n-            CharClassesStatus::LitChar => {\n-                match chr {\n-                    '\\\\' => CharClassesStatus::LitCharEscape,\n-                    '\\'' => CharClassesStatus::Normal,\n-                    _ => CharClassesStatus::LitChar,\n-                }\n-            }\n+            CharClassesStatus::LitChar => match chr {\n+                '\\\\' => CharClassesStatus::LitCharEscape,\n+                '\\'' => CharClassesStatus::Normal,\n+                _ => CharClassesStatus::LitChar,\n+            },\n             CharClassesStatus::LitCharEscape => CharClassesStatus::LitChar,\n-            CharClassesStatus::Normal => {\n-                match chr {\n-                    '\"' => CharClassesStatus::LitString,\n-                    '\\'' => CharClassesStatus::LitChar,\n-                    '/' => {\n-                        match self.base.peek() {\n-                            Some(next) if next.get_char() == '*' => {\n-                                self.status = CharClassesStatus::BlockCommentOpening(1);\n-                                return Some((FullCodeCharKind::StartComment, item));\n-                            }\n-                            Some(next) if next.get_char() == '/' => {\n-                                self.status = CharClassesStatus::LineComment;\n-                                return Some((FullCodeCharKind::StartComment, item));\n-                            }\n-                            _ => CharClassesStatus::Normal,\n-                        }\n+            CharClassesStatus::Normal => match chr {\n+                '\"' => CharClassesStatus::LitString,\n+                '\\'' => CharClassesStatus::LitChar,\n+                '/' => match self.base.peek() {\n+                    Some(next) if next.get_char() == '*' => {\n+                        self.status = CharClassesStatus::BlockCommentOpening(1);\n+                        return Some((FullCodeCharKind::StartComment, item));\n+                    }\n+                    Some(next) if next.get_char() == '/' => {\n+                        self.status = CharClassesStatus::LineComment;\n+                        return Some((FullCodeCharKind::StartComment, item));\n                     }\n                     _ => CharClassesStatus::Normal,\n-                }\n-            }\n+                },\n+                _ => CharClassesStatus::Normal,\n+            },\n             CharClassesStatus::BlockComment(deepness) => {\n                 assert!(deepness != 0);\n                 self.status = match self.base.peek() {\n@@ -558,18 +548,16 @@ where\n                     return Some((FullCodeCharKind::InComment, item));\n                 }\n             }\n-            CharClassesStatus::LineComment => {\n-                match chr {\n-                    '\\n' => {\n-                        self.status = CharClassesStatus::Normal;\n-                        return Some((FullCodeCharKind::EndComment, item));\n-                    }\n-                    _ => {\n-                        self.status = CharClassesStatus::LineComment;\n-                        return Some((FullCodeCharKind::InComment, item));\n-                    }\n+            CharClassesStatus::LineComment => match chr {\n+                '\\n' => {\n+                    self.status = CharClassesStatus::Normal;\n+                    return Some((FullCodeCharKind::EndComment, item));\n                 }\n-            }\n+                _ => {\n+                    self.status = CharClassesStatus::LineComment;\n+                    return Some((FullCodeCharKind::InComment, item));\n+                }\n+            },\n         };\n         Some((FullCodeCharKind::Normal, item))\n     }"}, {"sha": "510cdef6f1b475e468809fcd8434e02b345c8866", "filename": "src/config.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e3310a6a18d83016209d758ca2694fa1909f74f3/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3310a6a18d83016209d758ca2694fa1909f74f3/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=e3310a6a18d83016209d758ca2694fa1909f74f3", "patch": "@@ -482,11 +482,9 @@ pub fn get_toml_path(dir: &Path) -> Result<Option<PathBuf>, Error> {\n             Ok(ref md) if md.is_file() => return Ok(Some(config_file)),\n             // Return the error if it's something other than `NotFound`; otherwise we didn't\n             // find the project file yet, and continue searching.\n-            Err(e) => {\n-                if e.kind() != ErrorKind::NotFound {\n-                    return Err(e);\n-                }\n-            }\n+            Err(e) => if e.kind() != ErrorKind::NotFound {\n+                return Err(e);\n+            },\n             _ => {}\n         }\n     }"}, {"sha": "9adb601c9cb3f532dfe447dc2708554838909f4a", "filename": "src/expr.rs", "status": "modified", "additions": 109, "deletions": 147, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/e3310a6a18d83016209d758ca2694fa1909f74f3/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3310a6a18d83016209d758ca2694fa1909f74f3/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=e3310a6a18d83016209d758ca2694fa1909f74f3", "patch": "@@ -88,29 +88,23 @@ pub fn format_expr(\n         }\n     }\n     let expr_rw = match expr.node {\n-        ast::ExprKind::Array(ref expr_vec) => {\n-            rewrite_array(\n-                expr_vec.iter().map(|e| &**e),\n-                mk_sp(context.codemap.span_after(expr.span, \"[\"), expr.span.hi),\n-                context,\n-                shape,\n-                false,\n-            )\n-        }\n-        ast::ExprKind::Lit(ref l) => {\n-            match l.node {\n-                ast::LitKind::Str(_, ast::StrStyle::Cooked) => {\n-                    rewrite_string_lit(context, l.span, shape)\n-                }\n-                _ => {\n-                    wrap_str(\n-                        context.snippet(expr.span),\n-                        context.config.max_width(),\n-                        shape,\n-                    )\n-                }\n+        ast::ExprKind::Array(ref expr_vec) => rewrite_array(\n+            expr_vec.iter().map(|e| &**e),\n+            mk_sp(context.codemap.span_after(expr.span, \"[\"), expr.span.hi),\n+            context,\n+            shape,\n+            false,\n+        ),\n+        ast::ExprKind::Lit(ref l) => match l.node {\n+            ast::LitKind::Str(_, ast::StrStyle::Cooked) => {\n+                rewrite_string_lit(context, l.span, shape)\n             }\n-        }\n+            _ => wrap_str(\n+                context.snippet(expr.span),\n+                context.config.max_width(),\n+                shape,\n+            ),\n+        },\n         ast::ExprKind::Call(ref callee, ref args) => {\n             let inner_span = mk_sp(callee.span.hi, expr.span.hi);\n             rewrite_call_with_binary_search(\n@@ -135,33 +129,27 @@ pub fn format_expr(\n             )\n         }\n         ast::ExprKind::Unary(ref op, ref subexpr) => rewrite_unary_op(context, op, subexpr, shape),\n-        ast::ExprKind::Struct(ref path, ref fields, ref base) => {\n-            rewrite_struct_lit(\n-                context,\n-                path,\n-                fields,\n-                base.as_ref().map(|e| &**e),\n-                expr.span,\n-                shape,\n-            )\n-        }\n-        ast::ExprKind::Tup(ref items) => {\n-            rewrite_tuple(\n-                context,\n-                &items.iter().map(|x| &**x).collect::<Vec<_>>()[..],\n-                expr.span,\n-                shape,\n-            )\n-        }\n+        ast::ExprKind::Struct(ref path, ref fields, ref base) => rewrite_struct_lit(\n+            context,\n+            path,\n+            fields,\n+            base.as_ref().map(|e| &**e),\n+            expr.span,\n+            shape,\n+        ),\n+        ast::ExprKind::Tup(ref items) => rewrite_tuple(\n+            context,\n+            &items.iter().map(|x| &**x).collect::<Vec<_>>()[..],\n+            expr.span,\n+            shape,\n+        ),\n         ast::ExprKind::If(..) |\n         ast::ExprKind::IfLet(..) |\n         ast::ExprKind::ForLoop(..) |\n         ast::ExprKind::Loop(..) |\n         ast::ExprKind::While(..) |\n-        ast::ExprKind::WhileLet(..) => {\n-            to_control_flow(expr, expr_type)\n-                .and_then(|control_flow| control_flow.rewrite(context, shape))\n-        }\n+        ast::ExprKind::WhileLet(..) => to_control_flow(expr, expr_type)\n+            .and_then(|control_flow| control_flow.rewrite(context, shape)),\n         ast::ExprKind::Block(ref block) => {\n             match expr_type {\n                 ExprType::Statement => {\n@@ -271,14 +259,12 @@ pub fn format_expr(\n \n             fn needs_space_before_range(context: &RewriteContext, lhs: &ast::Expr) -> bool {\n                 match lhs.node {\n-                    ast::ExprKind::Lit(ref lit) => {\n-                        match lit.node {\n-                            ast::LitKind::FloatUnsuffixed(..) => {\n-                                context.snippet(lit.span).ends_with('.')\n-                            }\n-                            _ => false,\n+                    ast::ExprKind::Lit(ref lit) => match lit.node {\n+                        ast::LitKind::FloatUnsuffixed(..) => {\n+                            context.snippet(lit.span).ends_with('.')\n                         }\n-                    }\n+                        _ => false,\n+                    },\n                     _ => false,\n                 }\n             }\n@@ -315,13 +301,11 @@ pub fn format_expr(\n         }\n         // We do not format these expressions yet, but they should still\n         // satisfy our width restrictions.\n-        ast::ExprKind::InPlace(..) | ast::ExprKind::InlineAsm(..) => {\n-            wrap_str(\n-                context.snippet(expr.span),\n-                context.config.max_width(),\n-                shape,\n-            )\n-        }\n+        ast::ExprKind::InPlace(..) | ast::ExprKind::InlineAsm(..) => wrap_str(\n+            context.snippet(expr.span),\n+            context.config.max_width(),\n+            shape,\n+        ),\n         ast::ExprKind::Catch(ref block) => {\n             if let rewrite @ Some(_) =\n                 rewrite_single_line_block(context, \"do catch \", block, shape)\n@@ -338,14 +322,12 @@ pub fn format_expr(\n         }\n     };\n     match (attr_rw, expr_rw) {\n-        (Some(attr_str), Some(expr_str)) => {\n-            recover_comment_removed(\n-                combine_attr_and_expr(context, shape, &attr_str, &expr_str),\n-                expr.span,\n-                context,\n-                shape,\n-            )\n-        }\n+        (Some(attr_str), Some(expr_str)) => recover_comment_removed(\n+            combine_attr_and_expr(context, shape, &attr_str, &expr_str),\n+            expr.span,\n+            context,\n+            shape,\n+        ),\n         _ => None,\n     }\n }\n@@ -460,22 +442,18 @@ where\n     };\n \n     let mut nested_shape = match context.config.array_layout() {\n-        IndentStyle::Block => {\n-            try_opt!(\n-                shape\n-                    .block()\n-                    .block_indent(context.config.tab_spaces())\n-                    .with_max_width(context.config)\n-                    .sub_width(1)\n-            )\n-        }\n-        IndentStyle::Visual => {\n-            try_opt!(\n-                shape\n-                    .visual_indent(bracket_size)\n-                    .sub_width(bracket_size * 2)\n-            )\n-        }\n+        IndentStyle::Block => try_opt!(\n+            shape\n+                .block()\n+                .block_indent(context.config.tab_spaces())\n+                .with_max_width(context.config)\n+                .sub_width(1)\n+        ),\n+        IndentStyle::Visual => try_opt!(\n+            shape\n+                .visual_indent(bracket_size)\n+                .sub_width(bracket_size * 2)\n+        ),\n     };\n \n     let items = itemize_list(\n@@ -513,17 +491,15 @@ where\n                 None => DefinitiveListTactic::Vertical,\n             }\n         }\n-        IndentStyle::Visual => {\n-            if has_long_item || items.iter().any(ListItem::is_multiline) {\n-                definitive_tactic(\n-                    &items,\n-                    ListTactic::LimitedHorizontalVertical(context.config.array_width()),\n-                    nested_shape.width,\n-                )\n-            } else {\n-                DefinitiveListTactic::Mixed\n-            }\n-        }\n+        IndentStyle::Visual => if has_long_item || items.iter().any(ListItem::is_multiline) {\n+            definitive_tactic(\n+                &items,\n+                ListTactic::LimitedHorizontalVertical(context.config.array_width()),\n+                nested_shape.width,\n+            )\n+        } else {\n+            DefinitiveListTactic::Mixed\n+        },\n     };\n     if context.config.array_horizontal_layout_threshold() > 0 &&\n         items.len() > context.config.array_horizontal_layout_threshold()\n@@ -965,15 +941,13 @@ fn rewrite_cond(context: &RewriteContext, expr: &ast::Expr, shape: Shape) -> Opt\n         ast::ExprKind::Block(ref block) if block.stmts.len() == 1 => {\n             stmt_expr(&block.stmts[0]).and_then(|e| rewrite_cond(context, e, shape))\n         }\n-        _ => {\n-            to_control_flow(expr, ExprType::SubExpression).and_then(|control_flow| {\n-                let alt_block_sep =\n-                    String::from(\"\\n\") + &shape.indent.block_only().to_string(context.config);\n-                control_flow\n-                    .rewrite_cond(context, shape, &alt_block_sep)\n-                    .and_then(|rw| Some(rw.0))\n-            })\n-        }\n+        _ => to_control_flow(expr, ExprType::SubExpression).and_then(|control_flow| {\n+            let alt_block_sep =\n+                String::from(\"\\n\") + &shape.indent.block_only().to_string(context.config);\n+            control_flow\n+                .rewrite_cond(context, shape, &alt_block_sep)\n+                .and_then(|rw| Some(rw.0))\n+        }),\n     }\n }\n \n@@ -996,17 +970,15 @@ struct ControlFlow<'a> {\n \n fn to_control_flow<'a>(expr: &'a ast::Expr, expr_type: ExprType) -> Option<ControlFlow<'a>> {\n     match expr.node {\n-        ast::ExprKind::If(ref cond, ref if_block, ref else_block) => {\n-            Some(ControlFlow::new_if(\n-                cond,\n-                None,\n-                if_block,\n-                else_block.as_ref().map(|e| &**e),\n-                expr_type == ExprType::SubExpression,\n-                false,\n-                expr.span,\n-            ))\n-        }\n+        ast::ExprKind::If(ref cond, ref if_block, ref else_block) => Some(ControlFlow::new_if(\n+            cond,\n+            None,\n+            if_block,\n+            else_block.as_ref().map(|e| &**e),\n+            expr_type == ExprType::SubExpression,\n+            false,\n+            expr.span,\n+        )),\n         ast::ExprKind::IfLet(ref pat, ref cond, ref if_block, ref else_block) => {\n             Some(ControlFlow::new_if(\n                 cond,\n@@ -1021,21 +993,15 @@ fn to_control_flow<'a>(expr: &'a ast::Expr, expr_type: ExprType) -> Option<Contr\n         ast::ExprKind::ForLoop(ref pat, ref cond, ref block, label) => {\n             Some(ControlFlow::new_for(pat, cond, block, label, expr.span))\n         }\n-        ast::ExprKind::Loop(ref block, label) => Some(\n-            ControlFlow::new_loop(block, label, expr.span),\n-        ),\n-        ast::ExprKind::While(ref cond, ref block, label) => Some(\n-            ControlFlow::new_while(None, cond, block, label, expr.span),\n-        ),\n-        ast::ExprKind::WhileLet(ref pat, ref cond, ref block, label) => {\n-            Some(ControlFlow::new_while(\n-                Some(pat),\n-                cond,\n-                block,\n-                label,\n-                expr.span,\n-            ))\n+        ast::ExprKind::Loop(ref block, label) => {\n+            Some(ControlFlow::new_loop(block, label, expr.span))\n+        }\n+        ast::ExprKind::While(ref cond, ref block, label) => {\n+            Some(ControlFlow::new_while(None, cond, block, label, expr.span))\n         }\n+        ast::ExprKind::WhileLet(ref pat, ref cond, ref block, label) => Some(\n+            ControlFlow::new_while(Some(pat), cond, block, label, expr.span),\n+        ),\n         _ => None,\n     }\n }\n@@ -2502,26 +2468,22 @@ fn rewrite_index(\n     let index_shape = try_opt!(index_shape.sub_width(rbr.len() + rhs_overhead));\n     let new_index_rw = index.rewrite(context, index_shape);\n     match (orig_index_rw, new_index_rw) {\n-        (_, Some(ref new_index_str)) if !new_index_str.contains('\\n') => {\n-            Some(format!(\n-                \"{}\\n{}{}{}{}\",\n-                expr_str,\n-                indent.to_string(&context.config),\n-                lbr,\n-                new_index_str,\n-                rbr\n-            ))\n-        }\n-        (None, Some(ref new_index_str)) => {\n-            Some(format!(\n-                \"{}\\n{}{}{}{}\",\n-                expr_str,\n-                indent.to_string(&context.config),\n-                lbr,\n-                new_index_str,\n-                rbr\n-            ))\n-        }\n+        (_, Some(ref new_index_str)) if !new_index_str.contains('\\n') => Some(format!(\n+            \"{}\\n{}{}{}{}\",\n+            expr_str,\n+            indent.to_string(&context.config),\n+            lbr,\n+            new_index_str,\n+            rbr\n+        )),\n+        (None, Some(ref new_index_str)) => Some(format!(\n+            \"{}\\n{}{}{}{}\",\n+            expr_str,\n+            indent.to_string(&context.config),\n+            lbr,\n+            new_index_str,\n+            rbr\n+        )),\n         (Some(ref index_str), _) => Some(format!(\"{}{}{}{}\", expr_str, lbr, index_str, rbr)),\n         _ => None,\n     }"}, {"sha": "d284b235c5e55309247974ce1a31fb1b7e71f053", "filename": "src/imports.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e3310a6a18d83016209d758ca2694fa1909f74f3/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3310a6a18d83016209d758ca2694fa1909f74f3/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=e3310a6a18d83016209d758ca2694fa1909f74f3", "patch": "@@ -60,12 +60,10 @@ fn compare_path_list_items(a: &ast::PathListItem, b: &ast::PathListItem) -> Orde\n     };\n     if name_ordering == Ordering::Equal {\n         match a.node.rename {\n-            Some(a_rename) => {\n-                match b.node.rename {\n-                    Some(b_rename) => a_rename.name.as_str().cmp(&b_rename.name.as_str()),\n-                    None => Ordering::Greater,\n-                }\n-            }\n+            Some(a_rename) => match b.node.rename {\n+                Some(b_rename) => a_rename.name.as_str().cmp(&b_rename.name.as_str()),\n+                None => Ordering::Greater,\n+            },\n             None => Ordering::Less,\n         }\n     } else {\n@@ -159,9 +157,9 @@ impl Rewrite for ast::ViewPath {\n     // Returns an empty string when the ViewPath is empty (like foo::bar::{})\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         match self.node {\n-            ast::ViewPath_::ViewPathList(_, ref path_list) if path_list.is_empty() => Some(\n-                String::new(),\n-            ),\n+            ast::ViewPath_::ViewPathList(_, ref path_list) if path_list.is_empty() => {\n+                Some(String::new())\n+            }\n             ast::ViewPath_::ViewPathList(ref path, ref path_list) => {\n                 rewrite_use_list(shape, path, path_list, self.span, context)\n             }"}, {"sha": "432fb797a6e481a1b373d21f58d790256c901ed0", "filename": "src/issues.rs", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e3310a6a18d83016209d758ca2694fa1909f74f3/src%2Fissues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3310a6a18d83016209d758ca2694fa1909f74f3/src%2Fissues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fissues.rs?ref=e3310a6a18d83016209d758ca2694fa1909f74f3", "patch": "@@ -189,25 +189,19 @@ impl BadIssueSeeker {\n         }\n \n         match part {\n-            NumberPart::OpenParen => {\n-                if c != '(' {\n-                    return IssueClassification::Bad(issue);\n-                } else {\n-                    part = NumberPart::Pound;\n-                }\n-            }\n-            NumberPart::Pound => {\n-                if c == '#' {\n-                    part = NumberPart::Number;\n-                }\n-            }\n-            NumberPart::Number => {\n-                if c >= '0' && c <= '9' {\n-                    part = NumberPart::CloseParen;\n-                } else {\n-                    return IssueClassification::Bad(issue);\n-                }\n-            }\n+            NumberPart::OpenParen => if c != '(' {\n+                return IssueClassification::Bad(issue);\n+            } else {\n+                part = NumberPart::Pound;\n+            },\n+            NumberPart::Pound => if c == '#' {\n+                part = NumberPart::Number;\n+            },\n+            NumberPart::Number => if c >= '0' && c <= '9' {\n+                part = NumberPart::CloseParen;\n+            } else {\n+                return IssueClassification::Bad(issue);\n+            },\n             NumberPart::CloseParen => {}\n         }\n "}, {"sha": "7e79e0a0b45c2bd68ea25215c7867f9ae0a46455", "filename": "src/items.rs", "status": "modified", "additions": 82, "deletions": 106, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/e3310a6a18d83016209d758ca2694fa1909f74f3/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3310a6a18d83016209d758ca2694fa1909f74f3/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=e3310a6a18d83016209d758ca2694fa1909f74f3", "patch": "@@ -362,12 +362,10 @@ impl<'a> FmtVisitor<'a> {\n                             ).map(|s| s + suffix)\n                                 .or_else(|| Some(self.snippet(e.span)))\n                         }\n-                        None => {\n-                            stmt.rewrite(\n-                                &self.get_context(),\n-                                Shape::indented(self.block_indent, self.config),\n-                            )\n-                        }\n+                        None => stmt.rewrite(\n+                            &self.get_context(),\n+                            Shape::indented(self.block_indent, self.config),\n+                        ),\n                     }\n                 } else {\n                     None\n@@ -418,13 +416,11 @@ impl<'a> FmtVisitor<'a> {\n         let variant_list = self.format_variant_list(enum_def, body_start, span.hi - BytePos(1));\n         match variant_list {\n             Some(ref body_str) => self.buffer.push_str(body_str),\n-            None => {\n-                if contains_comment(&enum_snippet[brace_pos..]) {\n-                    self.format_missing_no_indent(span.hi - BytePos(1))\n-                } else {\n-                    self.format_missing(span.hi - BytePos(1))\n-                }\n-            }\n+            None => if contains_comment(&enum_snippet[brace_pos..]) {\n+                self.format_missing_no_indent(span.hi - BytePos(1))\n+            } else {\n+                self.format_missing(span.hi - BytePos(1))\n+            },\n         }\n         self.block_indent = self.block_indent.block_unindent(self.config);\n \n@@ -620,14 +616,12 @@ pub fn format_impl(\n                 result.push_str(&offset.to_string(context.config));\n             }\n             BraceStyle::PreferSameLine => result.push(' '),\n-            BraceStyle::SameLineWhere => {\n-                if !where_clause_str.is_empty() {\n-                    result.push('\\n');\n-                    result.push_str(&offset.to_string(context.config));\n-                } else {\n-                    result.push(' ');\n-                }\n-            }\n+            BraceStyle::SameLineWhere => if !where_clause_str.is_empty() {\n+                result.push('\\n');\n+                result.push_str(&offset.to_string(context.config));\n+            } else {\n+                result.push(' ');\n+            },\n         }\n \n         result.push('{');\n@@ -876,31 +870,27 @@ pub fn format_struct(\n ) -> Option<String> {\n     match *struct_def {\n         ast::VariantData::Unit(..) => Some(format_unit_struct(item_name, ident, vis)),\n-        ast::VariantData::Tuple(ref fields, _) => {\n-            format_tuple_struct(\n-                context,\n-                item_name,\n-                ident,\n-                vis,\n-                fields,\n-                generics,\n-                span,\n-                offset,\n-            )\n-        }\n-        ast::VariantData::Struct(ref fields, _) => {\n-            format_struct_struct(\n-                context,\n-                item_name,\n-                ident,\n-                vis,\n-                fields,\n-                generics,\n-                span,\n-                offset,\n-                one_line_width,\n-            )\n-        }\n+        ast::VariantData::Tuple(ref fields, _) => format_tuple_struct(\n+            context,\n+            item_name,\n+            ident,\n+            vis,\n+            fields,\n+            generics,\n+            span,\n+            offset,\n+        ),\n+        ast::VariantData::Struct(ref fields, _) => format_struct_struct(\n+            context,\n+            item_name,\n+            ident,\n+            vis,\n+            fields,\n+            generics,\n+            span,\n+            offset,\n+            one_line_width,\n+        ),\n     }\n }\n \n@@ -1003,16 +993,14 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n                 result.push_str(&offset.to_string(context.config));\n             }\n             BraceStyle::PreferSameLine => result.push(' '),\n-            BraceStyle::SameLineWhere => {\n-                if !where_clause_str.is_empty() &&\n-                    (!trait_items.is_empty() || result.contains('\\n'))\n-                {\n-                    result.push('\\n');\n-                    result.push_str(&offset.to_string(context.config));\n-                } else {\n-                    result.push(' ');\n-                }\n-            }\n+            BraceStyle::SameLineWhere => if !where_clause_str.is_empty() &&\n+                (!trait_items.is_empty() || result.contains('\\n'))\n+            {\n+                result.push('\\n');\n+                result.push_str(&offset.to_string(context.config));\n+            } else {\n+                result.push(' ');\n+            },\n         }\n         result.push('{');\n \n@@ -1072,19 +1060,17 @@ pub fn format_struct_struct(\n     let body_lo = context.codemap.span_after(span, \"{\");\n \n     let generics_str = match generics {\n-        Some(g) => {\n-            try_opt!(format_generics(\n-                context,\n-                g,\n-                \"{\",\n-                \"{\",\n-                context.config.item_brace_style(),\n-                fields.is_empty(),\n-                offset,\n-                mk_sp(span.lo, body_lo),\n-                last_line_width(&result),\n-            ))\n-        }\n+        Some(g) => try_opt!(format_generics(\n+            context,\n+            g,\n+            \"{\",\n+            \"{\",\n+            context.config.item_brace_style(),\n+            fields.is_empty(),\n+            offset,\n+            mk_sp(span.lo, body_lo),\n+            last_line_width(&result),\n+        )),\n         None => {\n             // 3 = ` {}`, 2 = ` {`.\n             let overhead = if fields.is_empty() { 3 } else { 2 };\n@@ -1416,16 +1402,14 @@ pub fn rewrite_struct_field_prefix(\n \n     let type_annotation_spacing = type_annotation_spacing(context.config);\n     Some(match field.ident {\n-        Some(name) => {\n-            format!(\n-                \"{}{}{}{}{}:\",\n-                attr_str,\n-                missing_comment,\n-                vis,\n-                name,\n-                type_annotation_spacing.0\n-            )\n-        }\n+        Some(name) => format!(\n+            \"{}{}{}{}{}:\",\n+            attr_str,\n+            missing_comment,\n+            vis,\n+            name,\n+            type_annotation_spacing.0\n+        ),\n         None => format!(\"{}{}{}\", attr_str, missing_comment, vis),\n     })\n }\n@@ -1492,19 +1476,15 @@ pub fn rewrite_struct_field(\n \n     match ty_rewritten {\n         // If we start from the next line and type fits in a single line, then do so.\n-        Some(ref ty) => {\n-            match rewrite_type_in_next_line() {\n-                Some(ref new_ty) if !new_ty.contains('\\n') => {\n-                    Some(format!(\n-                        \"{}\\n{}{}\",\n-                        prefix,\n-                        type_offset.to_string(&context.config),\n-                        &new_ty\n-                    ))\n-                }\n-                _ => Some(prefix + &ty),\n-            }\n-        }\n+        Some(ref ty) => match rewrite_type_in_next_line() {\n+            Some(ref new_ty) if !new_ty.contains('\\n') => Some(format!(\n+                \"{}\\n{}{}\",\n+                prefix,\n+                type_offset.to_string(&context.config),\n+                &new_ty\n+            )),\n+            _ => Some(prefix + &ty),\n+        },\n         _ => {\n             let ty = try_opt!(rewrite_type_in_next_line());\n             Some(format!(\n@@ -2221,20 +2201,16 @@ fn rewrite_args(\n         .map_or(false, |s| s.trim().starts_with(\"//\"));\n \n     let (indent, trailing_comma, end_with_newline) = match context.config.fn_args_layout() {\n-        IndentStyle::Block if fits_in_one_line => {\n-            (\n-                indent.block_indent(context.config),\n-                SeparatorTactic::Never,\n-                true,\n-            )\n-        }\n-        IndentStyle::Block => {\n-            (\n-                indent.block_indent(context.config),\n-                context.config.trailing_comma(),\n-                true,\n-            )\n-        }\n+        IndentStyle::Block if fits_in_one_line => (\n+            indent.block_indent(context.config),\n+            SeparatorTactic::Never,\n+            true,\n+        ),\n+        IndentStyle::Block => (\n+            indent.block_indent(context.config),\n+            context.config.trailing_comma(),\n+            true,\n+        ),\n         IndentStyle::Visual if last_line_ends_with_comment => {\n             (arg_indent, context.config.trailing_comma(), true)\n         }"}, {"sha": "030d18c3000fe2388235f7b1d7c79a9aba32c2d0", "filename": "src/lib.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e3310a6a18d83016209d758ca2694fa1909f74f3/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3310a6a18d83016209d758ca2694fa1909f74f3/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=e3310a6a18d83016209d758ca2694fa1909f74f3", "patch": "@@ -442,14 +442,12 @@ pub enum ErrorKind {\n impl fmt::Display for ErrorKind {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n         match *self {\n-            ErrorKind::LineOverflow(found, maximum) => {\n-                write!(\n-                    fmt,\n-                    \"line exceeded maximum length (maximum: {}, found: {})\",\n-                    maximum,\n-                    found\n-                )\n-            }\n+            ErrorKind::LineOverflow(found, maximum) => write!(\n+                fmt,\n+                \"line exceeded maximum length (maximum: {}, found: {})\",\n+                maximum,\n+                found\n+            ),\n             ErrorKind::TrailingWhitespace => write!(fmt, \"left behind trailing whitespace\"),\n             ErrorKind::BadIssue(issue) => write!(fmt, \"found {}\", issue),\n         }"}, {"sha": "4bd7d76483a9b201b35b15cf9cea41ba90cb2cde", "filename": "src/lists.rs", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e3310a6a18d83016209d758ca2694fa1909f74f3/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3310a6a18d83016209d758ca2694fa1909f74f3/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=e3310a6a18d83016209d758ca2694fa1909f74f3", "patch": "@@ -440,29 +440,23 @@ where\n                         // Comment belongs to next item.\n                         (Some(i), None) if i > separator_index => separator_index + 1,\n                         // Block-style post-comment before the separator.\n-                        (Some(i), None) => {\n-                            cmp::max(\n-                                find_comment_end(&post_snippet[i..]).unwrap() + i,\n-                                separator_index + 1,\n-                            )\n-                        }\n+                        (Some(i), None) => cmp::max(\n+                            find_comment_end(&post_snippet[i..]).unwrap() + i,\n+                            separator_index + 1,\n+                        ),\n                         // Block-style post-comment. Either before or after the separator.\n-                        (Some(i), Some(j)) if i < j => {\n-                            cmp::max(\n-                                find_comment_end(&post_snippet[i..]).unwrap() + i,\n-                                separator_index + 1,\n-                            )\n-                        }\n+                        (Some(i), Some(j)) if i < j => cmp::max(\n+                            find_comment_end(&post_snippet[i..]).unwrap() + i,\n+                            separator_index + 1,\n+                        ),\n                         // Potential *single* line comment.\n                         (_, Some(j)) if j > separator_index => j + 1,\n                         _ => post_snippet.len(),\n                     }\n                 }\n-                None => {\n-                    post_snippet\n-                        .find_uncommented(self.terminator)\n-                        .unwrap_or(post_snippet.len())\n-                }\n+                None => post_snippet\n+                    .find_uncommented(self.terminator)\n+                    .unwrap_or(post_snippet.len()),\n             };\n \n             if !post_snippet.is_empty() && comment_end > 0 {\n@@ -595,11 +589,9 @@ pub fn struct_lit_shape(\n     suffix_width: usize,\n ) -> Option<(Option<Shape>, Shape)> {\n     let v_shape = match context.config.struct_lit_style() {\n-        IndentStyle::Visual => {\n-            try_opt!(\n-                try_opt!(shape.visual_indent(0).shrink_left(prefix_width)).sub_width(suffix_width)\n-            )\n-        }\n+        IndentStyle::Visual => try_opt!(\n+            try_opt!(shape.visual_indent(0).shrink_left(prefix_width)).sub_width(suffix_width)\n+        ),\n         IndentStyle::Block => {\n             let shape = shape.block_indent(context.config.tab_spaces());\n             Shape {"}, {"sha": "3f4adf881200761bf6896a6bf115d10cd0e2bb32", "filename": "src/macros.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e3310a6a18d83016209d758ca2694fa1909f74f3/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3310a6a18d83016209d758ca2694fa1909f74f3/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=e3310a6a18d83016209d758ca2694fa1909f74f3", "patch": "@@ -80,13 +80,11 @@ pub fn rewrite_macro(\n \n     let macro_name = match extra_ident {\n         None => format!(\"{}!\", mac.node.path),\n-        Some(ident) => {\n-            if ident == symbol::keywords::Invalid.ident() {\n-                format!(\"{}!\", mac.node.path)\n-            } else {\n-                format!(\"{}! {}\", mac.node.path, ident)\n-            }\n-        }\n+        Some(ident) => if ident == symbol::keywords::Invalid.ident() {\n+            format!(\"{}!\", mac.node.path)\n+        } else {\n+            format!(\"{}! {}\", mac.node.path, ident)\n+        },\n     };\n \n     let style = if FORCED_BRACKET_MACROS.contains(&&macro_name[..]) {"}, {"sha": "bcc57f93189a90f4e16531463d2822def087965b", "filename": "src/patterns.rs", "status": "modified", "additions": 23, "deletions": 35, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/e3310a6a18d83016209d758ca2694fa1909f74f3/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3310a6a18d83016209d758ca2694fa1909f74f3/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=e3310a6a18d83016209d758ca2694fa1909f74f3", "patch": "@@ -54,23 +54,15 @@ impl Rewrite for Pat {\n                 let result = format!(\"{}{}{}{}\", prefix, mut_infix, id_str, sub_pat);\n                 wrap_str(result, context.config.max_width(), shape)\n             }\n-            PatKind::Wild => {\n-                if 1 <= shape.width {\n-                    Some(\"_\".to_owned())\n-                } else {\n-                    None\n-                }\n-            }\n-            PatKind::Range(ref lhs, ref rhs, ref end_kind) => {\n-                match *end_kind {\n-                    RangeEnd::Included => {\n-                        rewrite_pair(&**lhs, &**rhs, \"\", \"...\", \"\", context, shape)\n-                    }\n-                    RangeEnd::Excluded => {\n-                        rewrite_pair(&**lhs, &**rhs, \"\", \"..\", \"\", context, shape)\n-                    }\n-                }\n-            }\n+            PatKind::Wild => if 1 <= shape.width {\n+                Some(\"_\".to_owned())\n+            } else {\n+                None\n+            },\n+            PatKind::Range(ref lhs, ref rhs, ref end_kind) => match *end_kind {\n+                RangeEnd::Included => rewrite_pair(&**lhs, &**rhs, \"\", \"...\", \"\", context, shape),\n+                RangeEnd::Excluded => rewrite_pair(&**lhs, &**rhs, \"\", \"..\", \"\", context, shape),\n+            },\n             PatKind::Ref(ref pat, mutability) => {\n                 let prefix = format!(\"&{}\", format_mutability(mutability));\n                 rewrite_unary_prefix(context, &prefix, &**pat, shape)\n@@ -121,13 +113,11 @@ impl Rewrite for Pat {\n                 rewrite_struct_pat(path, fields, elipses, self.span, context, shape)\n             }\n             // FIXME(#819) format pattern macros.\n-            PatKind::Mac(..) => {\n-                wrap_str(\n-                    context.snippet(self.span),\n-                    context.config.max_width(),\n-                    shape,\n-                )\n-            }\n+            PatKind::Mac(..) => wrap_str(\n+                context.snippet(self.span),\n+                context.config.max_width(),\n+                shape,\n+            ),\n         }\n     }\n }\n@@ -250,18 +240,16 @@ impl<'a> Spanned for TuplePatField<'a> {\n \n pub fn can_be_overflowed_pat(context: &RewriteContext, pat: &TuplePatField, len: usize) -> bool {\n     match pat {\n-        &TuplePatField::Pat(ref pat) => {\n-            match pat.node {\n-                ast::PatKind::Path(..) | ast::PatKind::Tuple(..) | ast::PatKind::Struct(..) => {\n-                    context.use_block_indent() && len == 1\n-                }\n-                ast::PatKind::Ref(ref p, _) | ast::PatKind::Box(ref p) => {\n-                    can_be_overflowed_pat(context, &TuplePatField::Pat(p), len)\n-                }\n-                ast::PatKind::Lit(ref expr) => can_be_overflowed_expr(context, expr, len),\n-                _ => false,\n+        &TuplePatField::Pat(ref pat) => match pat.node {\n+            ast::PatKind::Path(..) | ast::PatKind::Tuple(..) | ast::PatKind::Struct(..) => {\n+                context.use_block_indent() && len == 1\n             }\n-        }\n+            ast::PatKind::Ref(ref p, _) | ast::PatKind::Box(ref p) => {\n+                can_be_overflowed_pat(context, &TuplePatField::Pat(p), len)\n+            }\n+            ast::PatKind::Lit(ref expr) => can_be_overflowed_expr(context, expr, len),\n+            _ => false,\n+        },\n         &TuplePatField::Dotdot(..) => false,\n     }\n }"}, {"sha": "edab375b02defae31e4e5ac556164cd8de4e713d", "filename": "src/types.rs", "status": "modified", "additions": 19, "deletions": 27, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e3310a6a18d83016209d758ca2694fa1909f74f3/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3310a6a18d83016209d758ca2694fa1909f74f3/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=e3310a6a18d83016209d758ca2694fa1909f74f3", "patch": "@@ -474,14 +474,12 @@ impl Rewrite for ast::WherePredicate {\n                 ref lifetime,\n                 ref bounds,\n                 ..\n-            }) => {\n-                try_opt!(rewrite_bounded_lifetime(\n-                    lifetime,\n-                    bounds.iter(),\n-                    context,\n-                    shape,\n-                ))\n-            }\n+            }) => try_opt!(rewrite_bounded_lifetime(\n+                lifetime,\n+                bounds.iter(),\n+                context,\n+                shape,\n+            )),\n             ast::WherePredicate::EqPredicate(ast::WhereEqPredicate {\n                 ref lhs_ty,\n                 ref rhs_ty,\n@@ -727,14 +725,12 @@ impl Rewrite for ast::Ty {\n                         format!(\"[{}]\", ty_str)\n                     })\n             }\n-            ast::TyKind::Tup(ref items) => {\n-                rewrite_tuple(\n-                    context,\n-                    &items.iter().map(|x| &**x).collect::<Vec<_>>()[..],\n-                    self.span,\n-                    shape,\n-                )\n-            }\n+            ast::TyKind::Tup(ref items) => rewrite_tuple(\n+                context,\n+                &items.iter().map(|x| &**x).collect::<Vec<_>>()[..],\n+                self.span,\n+                shape,\n+            ),\n             ast::TyKind::Path(ref q_self, ref path) => {\n                 rewrite_path(context, PathContext::Type, q_self.as_ref(), path, shape)\n             }\n@@ -744,21 +740,17 @@ impl Rewrite for ast::Ty {\n                 let rbr = if use_spaces { \" ]\" } else { \"]\" };\n                 rewrite_pair(&**ty, &**repeats, lbr, \"; \", rbr, context, shape)\n             }\n-            ast::TyKind::Infer => {\n-                if shape.width >= 1 {\n-                    Some(\"_\".to_owned())\n-                } else {\n-                    None\n-                }\n-            }\n+            ast::TyKind::Infer => if shape.width >= 1 {\n+                Some(\"_\".to_owned())\n+            } else {\n+                None\n+            },\n             ast::TyKind::BareFn(ref bare_fn) => rewrite_bare_fn(bare_fn, self.span, context, shape),\n             ast::TyKind::Never => Some(String::from(\"!\")),\n             ast::TyKind::Mac(..) => None,\n             ast::TyKind::ImplicitSelf => Some(String::from(\"\")),\n-            ast::TyKind::ImplTrait(ref it) => {\n-                it.rewrite(context, shape)\n-                    .map(|it_str| format!(\"impl {}\", it_str))\n-            }\n+            ast::TyKind::ImplTrait(ref it) => it.rewrite(context, shape)\n+                .map(|it_str| format!(\"impl {}\", it_str)),\n             ast::TyKind::Err | ast::TyKind::Typeof(..) => unreachable!(),\n         }\n     }"}, {"sha": "2e0dce52e913e83728e8c70874c5f819c142a8bc", "filename": "src/utils.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e3310a6a18d83016209d758ca2694fa1909f74f3/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3310a6a18d83016209d758ca2694fa1909f74f3/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=e3310a6a18d83016209d758ca2694fa1909f74f3", "patch": "@@ -25,11 +25,9 @@ use SKIP_ANNOTATION;\n pub fn extra_offset(text: &str, shape: Shape) -> usize {\n     match text.rfind('\\n') {\n         // 1 for newline character\n-        Some(idx) => {\n-            text.len()\n-                .checked_sub(idx + 1 + shape.used_width())\n-                .unwrap_or(0)\n-        }\n+        Some(idx) => text.len()\n+            .checked_sub(idx + 1 + shape.used_width())\n+            .unwrap_or(0),\n         None => text.len(),\n     }\n }\n@@ -168,15 +166,13 @@ pub fn semicolon_for_expr(expr: &ast::Expr) -> bool {\n #[inline]\n pub fn semicolon_for_stmt(stmt: &ast::Stmt) -> bool {\n     match stmt.node {\n-        ast::StmtKind::Semi(ref expr) => {\n-            match expr.node {\n-                ast::ExprKind::While(..) |\n-                ast::ExprKind::WhileLet(..) |\n-                ast::ExprKind::Loop(..) |\n-                ast::ExprKind::ForLoop(..) => false,\n-                _ => true,\n-            }\n-        }\n+        ast::StmtKind::Semi(ref expr) => match expr.node {\n+            ast::ExprKind::While(..) |\n+            ast::ExprKind::WhileLet(..) |\n+            ast::ExprKind::Loop(..) |\n+            ast::ExprKind::ForLoop(..) => false,\n+            _ => true,\n+        },\n         ast::StmtKind::Expr(..) => false,\n         _ => true,\n     }"}, {"sha": "a1258092e8d8544035d3a2f935382d6833cd2d98", "filename": "src/visitor.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e3310a6a18d83016209d758ca2694fa1909f74f3/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3310a6a18d83016209d758ca2694fa1909f74f3/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=e3310a6a18d83016209d758ca2694fa1909f74f3", "patch": "@@ -289,12 +289,10 @@ impl<'a> FmtVisitor<'a> {\n                     assert!(!self.visit_attrs(&attrs));\n                 }\n             }\n-            _ => {\n-                if self.visit_attrs(&item.attrs) {\n-                    self.push_rewrite(item.span, None);\n-                    return;\n-                }\n-            }\n+            _ => if self.visit_attrs(&item.attrs) {\n+                self.push_rewrite(item.span, None);\n+                return;\n+            },\n         }\n \n         match item.node {"}]}