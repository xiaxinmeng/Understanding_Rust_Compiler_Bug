{"sha": "9ea4afe5daf359c7022057774f943645d0d32043", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllYTRhZmU1ZGFmMzU5YzcwMjIwNTc3NzRmOTQzNjQ1ZDBkMzIwNDM=", "commit": {"author": {"name": "Elliott Slaughter", "email": "eslaughter@mozilla.com", "date": "2012-08-17T23:17:18Z"}, "committer": {"name": "Elliott Slaughter", "email": "eslaughter@mozilla.com", "date": "2012-09-07T16:21:21Z"}, "message": "gc: Avoid double free when pointer appears on stack multiple times.", "tree": {"sha": "2d55895a9f3883fe7d0a63c63ce6196b0d32f531", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d55895a9f3883fe7d0a63c63ce6196b0d32f531"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ea4afe5daf359c7022057774f943645d0d32043", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ea4afe5daf359c7022057774f943645d0d32043", "html_url": "https://github.com/rust-lang/rust/commit/9ea4afe5daf359c7022057774f943645d0d32043", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ea4afe5daf359c7022057774f943645d0d32043/comments", "author": null, "committer": null, "parents": [{"sha": "3f0d207b3251e598488588765b942bf6b7a4f9bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f0d207b3251e598488588765b942bf6b7a4f9bb", "html_url": "https://github.com/rust-lang/rust/commit/3f0d207b3251e598488588765b942bf6b7a4f9bb"}], "stats": {"total": 37, "additions": 23, "deletions": 14}, "files": [{"sha": "066fa0b2e431eef6c545f39d76433aee65029615", "filename": "src/libcore/gc.rs", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/9ea4afe5daf359c7022057774f943645d0d32043/src%2Flibcore%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ea4afe5daf359c7022057774f943645d0d32043/src%2Flibcore%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fgc.rs?ref=9ea4afe5daf359c7022057774f943645d0d32043", "patch": "@@ -1,5 +1,6 @@\n import stackwalk::Word;\n import libc::size_t;\n+import send_map::linear::LinearMap;\n \n extern mod rustrt {\n     fn rust_annihilate_box(ptr: *Word);\n@@ -37,7 +38,7 @@ unsafe fn is_safe_point(pc: *Word) -> Option<SafePoint> {\n     return None;\n }\n \n-type Visitor = fn(root: **Word, tydesc: *Word);\n+type Visitor = fn(root: **Word, tydesc: *Word) -> bool;\n \n unsafe fn walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor) {\n     let fp_bytes: *u8 = unsafe::reinterpret_cast(&fp);\n@@ -69,7 +70,7 @@ unsafe fn walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor) {\n             } else {\n                 ptr::null()\n             };\n-            visitor(root, tydesc);\n+            if !visitor(root, tydesc) { return; }\n         }\n         sri += 1;\n     }\n@@ -94,25 +95,25 @@ const need_cleanup:    Memory = exchange_heap | stack;\n \n unsafe fn walk_gc_roots(mem: Memory, visitor: Visitor) {\n     let mut last_ret: *Word = ptr::null();\n-    do stackwalk::walk_stack |frame| {\n+    for stackwalk::walk_stack |frame| {\n         unsafe {\n             if ptr::is_not_null(last_ret) {\n                 let sp = is_safe_point(last_ret);\n                 match sp {\n                   Some(sp_info) => {\n-                    do walk_safe_point(frame.fp, sp_info) |root, tydesc| {\n+                    for walk_safe_point(frame.fp, sp_info) |root, tydesc| {\n                         if ptr::is_null(tydesc) {\n                             // Root is a generic box.\n                             let refcount = **root;\n                             if mem | task_local_heap != 0 && refcount != -1 {\n-                                visitor(root, tydesc);\n+                                if !visitor(root, tydesc) { return; }\n                             } else if mem | exchange_heap != 0 {\n-                                visitor(root, tydesc);\n+                                if !visitor(root, tydesc) { return; }\n                             }\n                         } else {\n                             // Root is a non-immediate.\n                             if mem | stack != 0 {\n-                                visitor(root, tydesc);\n+                                if !visitor(root, tydesc) { return; }\n                             }\n                         }\n                     }\n@@ -122,34 +123,42 @@ unsafe fn walk_gc_roots(mem: Memory, visitor: Visitor) {\n             }\n             last_ret = *ptr::offset(frame.fp, 1) as *Word;\n         }\n-        true\n     }\n }\n \n fn gc() {\n     unsafe {\n-        let mut i = 0;\n-        do walk_gc_roots(task_local_heap) |_root, _tydesc| {\n+        for walk_gc_roots(task_local_heap) |_root, _tydesc| {\n             // FIXME(#2997): Walk roots and mark them.\n             io::stdout().write([46]); // .\n-            i += 1;\n         }\n     }\n }\n \n+type RootSet = LinearMap<*Word,()>;\n+\n+fn RootSet() -> RootSet {\n+    LinearMap()\n+}\n+\n // This should only be called from fail, as it will drop the roots\n // which are *live* on the stack, rather than dropping those that are\n // dead.\n fn cleanup_stack_for_failure() {\n     unsafe {\n-        let mut i = 0;\n-        do walk_gc_roots(need_cleanup) |root, tydesc| {\n+        let mut roots = ~RootSet();\n+        for walk_gc_roots(need_cleanup) |root, tydesc| {\n+            // Track roots to avoid double frees.\n+            if option::is_some(roots.find(&*root)) {\n+                again;\n+            }\n+            roots.insert(*root, ());\n+\n             if ptr::is_null(tydesc) {\n                 rustrt::rust_annihilate_box(*root);\n             } else {\n                 rustrt::rust_call_tydesc_glue(*root, tydesc, 3 as size_t);\n             }\n-            i += 1;\n         }\n     }\n }"}]}