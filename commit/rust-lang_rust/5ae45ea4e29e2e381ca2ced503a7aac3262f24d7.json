{"sha": "5ae45ea4e29e2e381ca2ced503a7aac3262f24d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhZTQ1ZWE0ZTI5ZTJlMzgxY2EyY2VkNTAzYTdhYWMzMjYyZjI0ZDc=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-10-06T22:15:59Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-06T22:15:59Z"}, "message": "Rollup merge of #76911 - RalfJung:vecdeque-aliasing, r=oli-obk\n\nfix VecDeque::iter_mut aliasing issues\n\nFixes https://github.com/rust-lang/rust/issues/74029", "tree": {"sha": "6d1a067a140519e38d3e9691d98bbe2f1d7a5893", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d1a067a140519e38d3e9691d98bbe2f1d7a5893"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ae45ea4e29e2e381ca2ced503a7aac3262f24d7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJffOygCRBK7hj4Ov3rIwAAdHIIAHl2a1J1ibcJPfYQ1ROyI9xK\nZo+Q2qVwYwuLl/88ALa8pLzwaz6SgOT18oMpbXWyhC8dxHpz/Iuy7lBfZzO8ypyW\nfCq9ozMJ/UHsZ/I/BTgy61QbJGv99Cb+mFZUpvPFtB8oQl6MWU5lvU8KPdmLLBDZ\nr4YoGgmGru5zqbCll2Y9SbQOvsgHEVw+SLwB4L8bMuZqKS0XmmpWwOgemW05EtJc\ntjRJ/UDOoJzFDyKeIb438nefBRyLHe3eaydSZXQAWgOBHRI79aUdYDVTEOl6tfCQ\npNDGKzPu7xR8tBEgVXgUZth5P9kuie+eb/5g8/yAL8uAoVQcGak3iphZZSZEB1k=\n=JWr7\n-----END PGP SIGNATURE-----\n", "payload": "tree 6d1a067a140519e38d3e9691d98bbe2f1d7a5893\nparent d26ca984c32152d97eee51b7a7a400b75d2fff68\nparent fa6a4f7d374f2773a58eb10bf0cfe8e00d359039\nauthor Dylan DPC <dylan.dpc@gmail.com> 1602022559 +0200\ncommitter GitHub <noreply@github.com> 1602022559 +0200\n\nRollup merge of #76911 - RalfJung:vecdeque-aliasing, r=oli-obk\n\nfix VecDeque::iter_mut aliasing issues\n\nFixes https://github.com/rust-lang/rust/issues/74029\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ae45ea4e29e2e381ca2ced503a7aac3262f24d7", "html_url": "https://github.com/rust-lang/rust/commit/5ae45ea4e29e2e381ca2ced503a7aac3262f24d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ae45ea4e29e2e381ca2ced503a7aac3262f24d7/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d26ca984c32152d97eee51b7a7a400b75d2fff68", "url": "https://api.github.com/repos/rust-lang/rust/commits/d26ca984c32152d97eee51b7a7a400b75d2fff68", "html_url": "https://github.com/rust-lang/rust/commit/d26ca984c32152d97eee51b7a7a400b75d2fff68"}, {"sha": "fa6a4f7d374f2773a58eb10bf0cfe8e00d359039", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa6a4f7d374f2773a58eb10bf0cfe8e00d359039", "html_url": "https://github.com/rust-lang/rust/commit/fa6a4f7d374f2773a58eb10bf0cfe8e00d359039"}], "stats": {"total": 62, "additions": 55, "deletions": 7}, "files": [{"sha": "ff9b1553bf2fc0014b0594e8460ec99817257895", "filename": "library/alloc/src/collections/vec_deque.rs", "status": "modified", "additions": 55, "deletions": 7, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/5ae45ea4e29e2e381ca2ced503a7aac3262f24d7/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ae45ea4e29e2e381ca2ced503a7aac3262f24d7/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque.rs?ref=5ae45ea4e29e2e381ca2ced503a7aac3262f24d7", "patch": "@@ -14,6 +14,7 @@ use core::cmp::{self, Ordering};\n use core::fmt;\n use core::hash::{Hash, Hasher};\n use core::iter::{repeat_with, FromIterator, FusedIterator};\n+use core::marker::PhantomData;\n use core::mem::{self, replace, ManuallyDrop};\n use core::ops::{Index, IndexMut, Range, RangeBounds, Try};\n use core::ptr::{self, NonNull};\n@@ -982,7 +983,14 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<'_, T> {\n-        IterMut { tail: self.tail, head: self.head, ring: unsafe { self.buffer_as_mut_slice() } }\n+        // SAFETY: The internal `IterMut` safety invariant is established because the\n+        // `ring` we create is a dereferencable slice for lifetime '_.\n+        IterMut {\n+            tail: self.tail,\n+            head: self.head,\n+            ring: ptr::slice_from_raw_parts_mut(self.ptr(), self.cap()),\n+            phantom: PhantomData,\n+        }\n     }\n \n     /// Returns a pair of slices which contain, in order, the contents of the\n@@ -1170,11 +1178,14 @@ impl<T> VecDeque<T> {\n         R: RangeBounds<usize>,\n     {\n         let (tail, head) = self.range_tail_head(range);\n+\n+        // SAFETY: The internal `IterMut` safety invariant is established because the\n+        // `ring` we create is a dereferencable slice for lifetime '_.\n         IterMut {\n             tail,\n             head,\n-            // The shared reference we have in &mut self is maintained in the '_ of IterMut.\n-            ring: unsafe { self.buffer_as_mut_slice() },\n+            ring: ptr::slice_from_raw_parts_mut(self.ptr(), self.cap()),\n+            phantom: PhantomData,\n         }\n     }\n \n@@ -2493,6 +2504,25 @@ impl<T> RingSlices for &mut [T] {\n     }\n }\n \n+impl<T> RingSlices for *mut [T] {\n+    fn slice(self, from: usize, to: usize) -> Self {\n+        assert!(from <= to && to < self.len());\n+        // Not using `get_unchecked_mut` to keep this a safe operation.\n+        let len = to - from;\n+        ptr::slice_from_raw_parts_mut(self.as_mut_ptr().wrapping_add(from), len)\n+    }\n+\n+    fn split_at(self, mid: usize) -> (Self, Self) {\n+        let len = self.len();\n+        let ptr = self.as_mut_ptr();\n+        assert!(mid <= len);\n+        (\n+            ptr::slice_from_raw_parts_mut(ptr, mid),\n+            ptr::slice_from_raw_parts_mut(ptr.wrapping_add(mid), len - mid),\n+        )\n+    }\n+}\n+\n /// Calculate the number of elements left to be read in the buffer\n #[inline]\n fn count(tail: usize, head: usize, size: usize) -> usize {\n@@ -2662,15 +2692,27 @@ impl<T> FusedIterator for Iter<'_, T> {}\n /// [`iter_mut`]: VecDeque::iter_mut\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T: 'a> {\n-    ring: &'a mut [T],\n+    // Internal safety invariant: the entire slice is dereferencable.\n+    ring: *mut [T],\n     tail: usize,\n     head: usize,\n+    phantom: PhantomData<&'a mut [T]>,\n }\n \n+// SAFETY: we do nothing thread-local and there is no interior mutability,\n+// so the usual structural `Send`/`Sync` apply.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+unsafe impl<T: Send> Send for IterMut<'_, T> {}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+unsafe impl<T: Sync> Sync for IterMut<'_, T> {}\n+\n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for IterMut<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let (front, back) = RingSlices::ring_slices(&*self.ring, self.head, self.tail);\n+        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n+        // SAFETY: these are the elements we have not handed out yet, so aliasing is fine.\n+        // The `IterMut` invariant also ensures everything is dereferencable.\n+        let (front, back) = unsafe { (&*front, &*back) };\n         f.debug_tuple(\"IterMut\").field(&front).field(&back).finish()\n     }\n }\n@@ -2689,7 +2731,7 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n \n         unsafe {\n             let elem = self.ring.get_unchecked_mut(tail);\n-            Some(&mut *(elem as *mut _))\n+            Some(&mut *elem)\n         }\n     }\n \n@@ -2704,6 +2746,9 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n         F: FnMut(Acc, Self::Item) -> Acc,\n     {\n         let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n+        // SAFETY: these are the elements we have not handed out yet, so aliasing is fine.\n+        // The `IterMut` invariant also ensures everything is dereferencable.\n+        let (front, back) = unsafe { (&mut *front, &mut *back) };\n         accum = front.iter_mut().fold(accum, &mut f);\n         back.iter_mut().fold(accum, &mut f)\n     }\n@@ -2735,7 +2780,7 @@ impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n \n         unsafe {\n             let elem = self.ring.get_unchecked_mut(self.head);\n-            Some(&mut *(elem as *mut _))\n+            Some(&mut *elem)\n         }\n     }\n \n@@ -2744,6 +2789,9 @@ impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n         F: FnMut(Acc, Self::Item) -> Acc,\n     {\n         let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n+        // SAFETY: these are the elements we have not handed out yet, so aliasing is fine.\n+        // The `IterMut` invariant also ensures everything is dereferencable.\n+        let (front, back) = unsafe { (&mut *front, &mut *back) };\n         accum = back.iter_mut().rfold(accum, &mut f);\n         front.iter_mut().rfold(accum, &mut f)\n     }"}]}