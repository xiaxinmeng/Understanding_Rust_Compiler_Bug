{"sha": "afc2dcd0ca65a4960e65374b2c836f012c7d508c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmYzJkY2QwY2E2NWE0OTYwZTY1Mzc0YjJjODM2ZjAxMmM3ZDUwOGM=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-20T17:46:44Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-21T19:02:09Z"}, "message": "Make drop glue for unsized value pass two arguments instead of *(data, meta)", "tree": {"sha": "d9e020f7cda7714fde8e624101052cd5c52bcc4a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9e020f7cda7714fde8e624101052cd5c52bcc4a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/afc2dcd0ca65a4960e65374b2c836f012c7d508c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/afc2dcd0ca65a4960e65374b2c836f012c7d508c", "html_url": "https://github.com/rust-lang/rust/commit/afc2dcd0ca65a4960e65374b2c836f012c7d508c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/afc2dcd0ca65a4960e65374b2c836f012c7d508c/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b38776c1f68c6fd47c1b2f7b7974efc7dd64901", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b38776c1f68c6fd47c1b2f7b7974efc7dd64901", "html_url": "https://github.com/rust-lang/rust/commit/1b38776c1f68c6fd47c1b2f7b7974efc7dd64901"}], "stats": {"total": 363, "additions": 137, "deletions": 226}, "files": [{"sha": "daa2617ef6ed017d81531ee79c2d21afcbb70a57", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/afc2dcd0ca65a4960e65374b2c836f012c7d508c/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc2dcd0ca65a4960e65374b2c836f012c7d508c/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=afc2dcd0ca65a4960e65374b2c836f012c7d508c", "patch": "@@ -270,7 +270,8 @@ pub fn mk_section_iter(llof: ObjectFileRef) -> SectionIter {\n /// Safe wrapper around `LLVMGetParam`, because segfaults are no fun.\n pub fn get_param(llfn: ValueRef, index: c_uint) -> ValueRef {\n     unsafe {\n-        assert!(index < LLVMCountParams(llfn));\n+        assert!(index < LLVMCountParams(llfn),\n+            \"out of bounds argument access: {} out of {} arguments\", index, LLVMCountParams(llfn));\n         LLVMGetParam(llfn, index)\n     }\n }"}, {"sha": "1abe25ea6073e6579dbb0e464076b04f896430d3", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/afc2dcd0ca65a4960e65374b2c836f012c7d508c/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc2dcd0ca65a4960e65374b2c836f012c7d508c/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=afc2dcd0ca65a4960e65374b2c836f012c7d508c", "patch": "@@ -27,6 +27,7 @@ use base::*;\n use common::{\n     self, CrateContext, FunctionContext, SharedCrateContext\n };\n+use adt::MaybeSizedValue;\n use consts;\n use declare;\n use value::Value;\n@@ -364,7 +365,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n \n     // Call the by-ref closure body with `self` in a cleanup scope,\n     // to drop `self` when the body returns, or in case it unwinds.\n-    let self_scope = fcx.schedule_drop_mem(llenv, closure_ty);\n+    let self_scope = fcx.schedule_drop_mem(MaybeSizedValue::sized(llenv), closure_ty);\n \n     let llfn = callee.reify(bcx.ccx);\n     let llret;"}, {"sha": "4e59ea3f6c5ed71664a5bc9078684291ee03fdf7", "filename": "src/librustc_trans/cleanup.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/afc2dcd0ca65a4960e65374b2c836f012c7d508c/src%2Flibrustc_trans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc2dcd0ca65a4960e65374b2c836f012c7d508c/src%2Flibrustc_trans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcleanup.rs?ref=afc2dcd0ca65a4960e65374b2c836f012c7d508c", "patch": "@@ -18,12 +18,12 @@\n //! corresponds to a normal exit from a block (for example, an expression\n //! completing evaluation successfully without panic).\n \n-use llvm::{BasicBlockRef, ValueRef};\n+use llvm::BasicBlockRef;\n use base;\n+use adt::MaybeSizedValue;\n use common::{BlockAndBuilder, FunctionContext, Funclet};\n use glue;\n use type_::Type;\n-use value::Value;\n use rustc::ty::Ty;\n \n pub struct CleanupScope<'tcx> {\n@@ -36,7 +36,7 @@ pub struct CleanupScope<'tcx> {\n \n #[derive(Copy, Clone)]\n pub struct DropValue<'tcx> {\n-    val: ValueRef,\n+    val: MaybeSizedValue,\n     ty: Ty<'tcx>,\n     skip_dtor: bool,\n }\n@@ -94,16 +94,14 @@ impl<'tcx> DropValue<'tcx> {\n \n impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n     /// Schedules a (deep) drop of `val`, which is a pointer to an instance of `ty`\n-    pub fn schedule_drop_mem(&self, val: ValueRef, ty: Ty<'tcx>) -> CleanupScope<'tcx> {\n+    pub fn schedule_drop_mem(&self, val: MaybeSizedValue, ty: Ty<'tcx>) -> CleanupScope<'tcx> {\n         if !self.ccx.shared().type_needs_drop(ty) { return CleanupScope::noop(); }\n         let drop = DropValue {\n             val: val,\n             ty: ty,\n             skip_dtor: false,\n         };\n \n-        debug!(\"schedule_drop_mem(val={:?}, ty={:?}) skip_dtor={}\", Value(val), ty, drop.skip_dtor);\n-\n         CleanupScope::new(self, drop)\n     }\n \n@@ -112,7 +110,8 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n     /// `ty`. The scheduled code handles extracting the discriminant\n     /// and dropping the contents associated with that variant\n     /// *without* executing any associated drop implementation.\n-    pub fn schedule_drop_adt_contents(&self, val: ValueRef, ty: Ty<'tcx>) -> CleanupScope<'tcx> {\n+    pub fn schedule_drop_adt_contents(&self, val: MaybeSizedValue, ty: Ty<'tcx>)\n+        -> CleanupScope<'tcx> {\n         // `if` below could be \"!contents_needs_drop\"; skipping drop\n         // is just an optimization, so sound to be conservative.\n         if !self.ccx.shared().type_needs_drop(ty) { return CleanupScope::noop(); }\n@@ -123,9 +122,6 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n             skip_dtor: true,\n         };\n \n-        debug!(\"schedule_drop_adt_contents(val={:?}, ty={:?}) skip_dtor={}\",\n-               Value(val), ty, drop.skip_dtor);\n-\n         CleanupScope::new(self, drop)\n     }\n }"}, {"sha": "7549f80f94db85f6d9473d4921735e809ac7eda5", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 87, "deletions": 124, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/afc2dcd0ca65a4960e65374b2c836f012c7d508c/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc2dcd0ca65a4960e65374b2c836f012c7d508c/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=afc2dcd0ca65a4960e65374b2c836f012c7d508c", "patch": "@@ -20,7 +20,7 @@ use middle::lang_items::ExchangeFreeFnLangItem;\n use rustc::ty::subst::{Substs};\n use rustc::traits;\n use rustc::ty::{self, AdtKind, Ty, TypeFoldable};\n-use adt;\n+use adt::{self, MaybeSizedValue};\n use base::*;\n use callee::Callee;\n use common::*;\n@@ -107,13 +107,13 @@ pub fn get_drop_glue_type<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>, t: Ty<'t\n     }\n }\n \n-fn drop_ty<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>, v: ValueRef, t: Ty<'tcx>) {\n-    call_drop_glue(bcx, v, t, false, None)\n+fn drop_ty<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>, args: MaybeSizedValue, t: Ty<'tcx>) {\n+    call_drop_glue(bcx, args, t, false, None)\n }\n \n pub fn call_drop_glue<'a, 'tcx>(\n     bcx: &BlockAndBuilder<'a, 'tcx>,\n-    v: ValueRef,\n+    mut args: MaybeSizedValue,\n     t: Ty<'tcx>,\n     skip_dtor: bool,\n     funclet: Option<&'a Funclet>,\n@@ -129,14 +129,13 @@ pub fn call_drop_glue<'a, 'tcx>(\n         };\n         let glue = get_drop_glue_core(ccx, g);\n         let glue_type = get_drop_glue_type(ccx.shared(), t);\n-        let ptr = if glue_type != t {\n-            bcx.pointercast(v, type_of(ccx, glue_type).ptr_to())\n-        } else {\n-            v\n-        };\n+        if glue_type != t {\n+            args.value = bcx.pointercast(args.value, type_of(ccx, glue_type).ptr_to());\n+        }\n \n         // No drop-hint ==> call standard drop glue\n-        bcx.call(glue, &[ptr], funclet.map(|b| b.bundle()));\n+        bcx.call(glue, &[args.value, args.meta][..1 + args.has_meta() as usize],\n+            funclet.map(|b| b.bundle()));\n     }\n }\n \n@@ -189,7 +188,7 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n     let (llfn, _) = ccx.drop_glues().borrow().get(&g).unwrap().clone();\n \n     let fcx = FunctionContext::new(ccx, llfn);\n-    let bcx = fcx.get_entry_block();\n+    let mut bcx = fcx.get_entry_block();\n \n     ccx.stats().n_glues_created.set(ccx.stats().n_glues_created.get() + 1);\n     // All glue functions take values passed *by alias*; this is a\n@@ -205,9 +204,15 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n     // non-null, (and maybe we need to continue doing so), but we now\n     // must definitely check for special bit-patterns corresponding to\n     // the special dtor markings.\n-    let v0 = get_param(llfn, 0);\n     let t = g.ty();\n \n+    let value = get_param(llfn, 0);\n+    let ptr = if ccx.shared().type_is_sized(t) {\n+        MaybeSizedValue::sized(value)\n+    } else {\n+        MaybeSizedValue::unsized_(value, get_param(llfn, 1))\n+    };\n+\n     let skip_dtor = match g {\n         DropGlueKind::Ty(_) => false,\n         DropGlueKind::TyContents(_) => true\n@@ -220,12 +225,9 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n             // a safe-guard, assert TyBox not used with TyContents.\n             assert!(!skip_dtor);\n             if !bcx.ccx.shared().type_is_sized(content_ty) {\n-                let llval = get_dataptr(&bcx, v0);\n-                let llbox = bcx.load(llval);\n-                drop_ty(&bcx, v0, content_ty);\n-                // FIXME(#36457) -- we should pass unsized values to drop glue as two arguments\n-                let info = get_meta(&bcx, v0);\n-                let info = bcx.load(info);\n+                let llbox = bcx.load(get_dataptr(&bcx, ptr.value));\n+                let info = bcx.load(get_meta(&bcx, ptr.value));\n+                drop_ty(&bcx, MaybeSizedValue::unsized_(llbox, info), content_ty);\n                 let (llsize, llalign) = size_and_align_of_dst(&bcx, content_ty, info);\n \n                 // `Box<ZeroSizeType>` does not allocate.\n@@ -241,9 +243,8 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n                     next_cx\n                 }\n             } else {\n-                let llval = v0;\n-                let llbox = bcx.load(llval);\n-                drop_ty(&bcx, llbox, content_ty);\n+                let llbox = bcx.load(ptr.value);\n+                drop_ty(&bcx, MaybeSizedValue::sized(llbox), content_ty);\n                 trans_exchange_free_ty(&bcx, llbox, content_ty);\n                 bcx\n             }\n@@ -252,23 +253,61 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n             // No support in vtable for distinguishing destroying with\n             // versus without calling Drop::drop. Assert caller is\n             // okay with always calling the Drop impl, if any.\n-            // FIXME(#36457) -- we should pass unsized values to drop glue as two arguments\n             assert!(!skip_dtor);\n-            let data_ptr = get_dataptr(&bcx, v0);\n-            let vtable_ptr = bcx.load(get_meta(&bcx, v0));\n-            let dtor = bcx.load(vtable_ptr);\n-            bcx.call(dtor, &[bcx.pointercast(bcx.load(data_ptr), Type::i8p(bcx.ccx))], None);\n+            let dtor = bcx.load(ptr.meta);\n+            bcx.call(dtor, &[ptr.value], None);\n             bcx\n         }\n         ty::TyAdt(def, ..) if def.dtor_kind().is_present() && !skip_dtor => {\n-            trans_custom_dtor(bcx, t, v0, def.is_union())\n+            let shallow_drop = def.is_union();\n+            let tcx = bcx.tcx();\n+\n+            let def = t.ty_adt_def().unwrap();\n+\n+            // Be sure to put the contents into a scope so we can use an invoke\n+            // instruction to call the user destructor but still call the field\n+            // destructors if the user destructor panics.\n+            //\n+            // FIXME (#14875) panic-in-drop semantics might be unsupported; we\n+            // might well consider changing below to more direct code.\n+            // Issue #23611: schedule cleanup of contents, re-inspecting the\n+            // discriminant (if any) in case of variant swap in drop code.\n+            let contents_scope = if !shallow_drop {\n+                bcx.fcx().schedule_drop_adt_contents(ptr, t)\n+            } else {\n+                CleanupScope::noop()\n+            };\n+\n+            let trait_ref = ty::Binder(ty::TraitRef {\n+                def_id: tcx.lang_items.drop_trait().unwrap(),\n+                substs: tcx.mk_substs_trait(t, &[])\n+            });\n+            let vtbl = match fulfill_obligation(bcx.ccx.shared(), DUMMY_SP, trait_ref) {\n+                traits::VtableImpl(data) => data,\n+                _ => bug!(\"dtor for {:?} is not an impl???\", t)\n+            };\n+            let dtor_did = def.destructor().unwrap();\n+            let callee = Callee::def(bcx.ccx, dtor_did, vtbl.substs);\n+            let fn_ty = callee.direct_fn_type(bcx.ccx, &[]);\n+            let llret;\n+            let args = &[ptr.value, ptr.meta][..1 + ptr.has_meta() as usize];\n+            if let Some(landing_pad) = contents_scope.landing_pad {\n+                let normal_bcx = bcx.fcx().build_new_block(\"normal-return\");\n+                llret = bcx.invoke(callee.reify(ccx), args, normal_bcx.llbb(), landing_pad, None);\n+                bcx = normal_bcx;\n+            } else {\n+                llret = bcx.call(callee.reify(bcx.ccx), args, None);\n+            }\n+            fn_ty.apply_attrs_callsite(llret);\n+            contents_scope.trans(&bcx);\n+            bcx\n         }\n         ty::TyAdt(def, ..) if def.is_union() => {\n             bcx\n         }\n         _ => {\n             if bcx.ccx.shared().type_needs_drop(t) {\n-                drop_structural_ty(bcx, v0, t)\n+                drop_structural_ty(bcx, ptr, t)\n             } else {\n                 bcx\n             }\n@@ -277,68 +316,6 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n     bcx.ret_void();\n }\n \n-fn trans_custom_dtor<'a, 'tcx>(mut bcx: BlockAndBuilder<'a, 'tcx>,\n-                               t: Ty<'tcx>,\n-                               v0: ValueRef,\n-                               shallow_drop: bool)\n-                               -> BlockAndBuilder<'a, 'tcx>\n-{\n-    debug!(\"trans_custom_dtor t: {}\", t);\n-    let tcx = bcx.tcx();\n-\n-    let def = t.ty_adt_def().unwrap();\n-\n-    // Be sure to put the contents into a scope so we can use an invoke\n-    // instruction to call the user destructor but still call the field\n-    // destructors if the user destructor panics.\n-    //\n-    // FIXME (#14875) panic-in-drop semantics might be unsupported; we\n-    // might well consider changing below to more direct code.\n-    // Issue #23611: schedule cleanup of contents, re-inspecting the\n-    // discriminant (if any) in case of variant swap in drop code.\n-    let contents_scope = if !shallow_drop {\n-        bcx.fcx().schedule_drop_adt_contents(v0, t)\n-    } else {\n-        CleanupScope::noop()\n-    };\n-\n-    let (sized_args, unsized_args);\n-    let args: &[ValueRef] = if bcx.ccx.shared().type_is_sized(t) {\n-        sized_args = [v0];\n-        &sized_args\n-    } else {\n-        // FIXME(#36457) -- we should pass unsized values to drop glue as two arguments\n-        unsized_args = [\n-            bcx.load(get_dataptr(&bcx, v0)),\n-            bcx.load(get_meta(&bcx, v0))\n-        ];\n-        &unsized_args\n-    };\n-\n-    let trait_ref = ty::Binder(ty::TraitRef {\n-        def_id: tcx.lang_items.drop_trait().unwrap(),\n-        substs: tcx.mk_substs_trait(t, &[])\n-    });\n-    let vtbl = match fulfill_obligation(bcx.ccx.shared(), DUMMY_SP, trait_ref) {\n-        traits::VtableImpl(data) => data,\n-        _ => bug!(\"dtor for {:?} is not an impl???\", t)\n-    };\n-    let dtor_did = def.destructor().unwrap();\n-    let callee = Callee::def(bcx.ccx, dtor_did, vtbl.substs);\n-    let fn_ty = callee.direct_fn_type(bcx.ccx, &[]);\n-    let llret;\n-    if let Some(landing_pad) = contents_scope.landing_pad {\n-        let normal_bcx = bcx.fcx().build_new_block(\"normal-return\");\n-        llret = bcx.invoke(callee.reify(bcx.ccx), args, normal_bcx.llbb(), landing_pad, None);\n-        bcx = normal_bcx;\n-    } else {\n-        llret = bcx.call(callee.reify(bcx.ccx), args, None);\n-    }\n-    fn_ty.apply_attrs_callsite(llret);\n-    contents_scope.trans(&bcx);\n-    bcx\n-}\n-\n pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n                                        t: Ty<'tcx>, info: ValueRef)\n                                        -> (ValueRef, ValueRef) {\n@@ -448,7 +425,7 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n \n // Iterates through the elements of a structural type, dropping them.\n fn drop_structural_ty<'a, 'tcx>(cx: BlockAndBuilder<'a, 'tcx>,\n-                                av: ValueRef,\n+                                ptr: MaybeSizedValue,\n                                 t: Ty<'tcx>)\n                                 -> BlockAndBuilder<'a, 'tcx> {\n     fn iter_variant<'a, 'tcx>(cx: &BlockAndBuilder<'a, 'tcx>,\n@@ -460,60 +437,47 @@ fn drop_structural_ty<'a, 'tcx>(cx: BlockAndBuilder<'a, 'tcx>,\n         for (i, field) in variant.fields.iter().enumerate() {\n             let arg = monomorphize::field_ty(tcx, substs, field);\n             let field_ptr = adt::trans_field_ptr(&cx, t, av, Disr::from(variant.disr_val), i);\n-            drop_ty(&cx, field_ptr, arg);\n+            drop_ty(&cx, MaybeSizedValue::sized(field_ptr), arg);\n         }\n     }\n \n-    let value = if cx.ccx.shared().type_is_sized(t) {\n-        adt::MaybeSizedValue::sized(av)\n-    } else {\n-        // FIXME(#36457) -- we should pass unsized values as two arguments\n-        let data = cx.load(get_dataptr(&cx, av));\n-        let info = cx.load(get_meta(&cx, av));\n-        adt::MaybeSizedValue::unsized_(data, info)\n-    };\n-\n     let mut cx = cx;\n     match t.sty {\n         ty::TyClosure(def_id, substs) => {\n             for (i, upvar_ty) in substs.upvar_tys(def_id, cx.tcx()).enumerate() {\n-                let llupvar = adt::trans_field_ptr(&cx, t, value, Disr(0), i);\n-                drop_ty(&cx, llupvar, upvar_ty);\n+                let llupvar = adt::trans_field_ptr(&cx, t, ptr, Disr(0), i);\n+                drop_ty(&cx, MaybeSizedValue::sized(llupvar), upvar_ty);\n             }\n         }\n         ty::TyArray(_, n) => {\n-            let base = get_dataptr(&cx, value.value);\n+            let base = get_dataptr(&cx, ptr.value);\n             let len = C_uint(cx.ccx, n);\n             let unit_ty = t.sequence_element_type(cx.tcx());\n-            cx = tvec::slice_for_each(&cx, base, unit_ty, len, |bb, vv| drop_ty(bb, vv, unit_ty));\n+            cx = tvec::slice_for_each(&cx, base, unit_ty, len,\n+                |bb, vv| drop_ty(bb, MaybeSizedValue::sized(vv), unit_ty));\n         }\n         ty::TySlice(_) | ty::TyStr => {\n             let unit_ty = t.sequence_element_type(cx.tcx());\n-            cx = tvec::slice_for_each(&cx, value.value, unit_ty, value.meta,\n-                |bb, vv| drop_ty(bb, vv, unit_ty));\n+            cx = tvec::slice_for_each(&cx, ptr.value, unit_ty, ptr.meta,\n+                |bb, vv| drop_ty(bb, MaybeSizedValue::sized(vv), unit_ty));\n         }\n         ty::TyTuple(ref args) => {\n             for (i, arg) in args.iter().enumerate() {\n-                let llfld_a = adt::trans_field_ptr(&cx, t, value, Disr(0), i);\n-                drop_ty(&cx, llfld_a, *arg);\n+                let llfld_a = adt::trans_field_ptr(&cx, t, ptr, Disr(0), i);\n+                drop_ty(&cx, MaybeSizedValue::sized(llfld_a), *arg);\n             }\n         }\n         ty::TyAdt(adt, substs) => match adt.adt_kind() {\n             AdtKind::Struct => {\n                 let VariantInfo { fields, discr } = VariantInfo::from_ty(cx.tcx(), t, None);\n                 for (i, &Field(_, field_ty)) in fields.iter().enumerate() {\n-                    let llfld_a = adt::trans_field_ptr(&cx, t, value, Disr::from(discr), i);\n-\n-                    let val = if cx.ccx.shared().type_is_sized(field_ty) {\n-                        llfld_a\n+                    let llfld_a = adt::trans_field_ptr(&cx, t, ptr, Disr::from(discr), i);\n+                    let ptr = if cx.ccx.shared().type_is_sized(field_ty) {\n+                        MaybeSizedValue::sized(llfld_a)\n                     } else {\n-                        // FIXME(#36457) -- we should pass unsized values as two arguments\n-                        let scratch = alloc_ty(&cx, field_ty, \"__fat_ptr_iter\");\n-                        cx.store(llfld_a, get_dataptr(&cx, scratch));\n-                        cx.store(value.meta, get_meta(&cx, scratch));\n-                        scratch\n+                        MaybeSizedValue::unsized_(llfld_a, ptr.meta)\n                     };\n-                    drop_ty(&cx, val, field_ty);\n+                    drop_ty(&cx, ptr, field_ty);\n                 }\n             }\n             AdtKind::Union => {\n@@ -525,17 +489,16 @@ fn drop_structural_ty<'a, 'tcx>(cx: BlockAndBuilder<'a, 'tcx>,\n                 // NB: we must hit the discriminant first so that structural\n                 // comparison know not to proceed when the discriminants differ.\n \n-                match adt::trans_switch(&cx, t, av, false) {\n+                match adt::trans_switch(&cx, t, ptr.value, false) {\n                     (adt::BranchKind::Single, None) => {\n                         if n_variants != 0 {\n                             assert!(n_variants == 1);\n-                            iter_variant(&cx, t, adt::MaybeSizedValue::sized(av),\n-                                            &adt.variants[0], substs);\n+                            iter_variant(&cx, t, ptr, &adt.variants[0], substs);\n                         }\n                     }\n                     (adt::BranchKind::Switch, Some(lldiscrim_a)) => {\n                         let tcx = cx.tcx();\n-                        drop_ty(&cx, lldiscrim_a, tcx.types.isize);\n+                        drop_ty(&cx, MaybeSizedValue::sized(lldiscrim_a), tcx.types.isize);\n \n                         // Create a fall-through basic block for the \"else\" case of\n                         // the switch instruction we're about to generate. Note that\n@@ -561,7 +524,7 @@ fn drop_structural_ty<'a, 'tcx>(cx: BlockAndBuilder<'a, 'tcx>,\n                             let variant_cx = cx.fcx().build_new_block(&variant_cx_name);\n                             let case_val = adt::trans_case(&cx, t, Disr::from(variant.disr_val));\n                             variant_cx.add_case(llswitch, case_val, variant_cx.llbb());\n-                            iter_variant(&variant_cx, t, value, variant, substs);\n+                            iter_variant(&variant_cx, t, ptr, variant, substs);\n                             variant_cx.br(next_cx.llbb());\n                         }\n                         cx = next_cx;"}, {"sha": "71ac7c0d252048ce818eabb0708251b05c073f72", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 36, "deletions": 85, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/afc2dcd0ca65a4960e65374b2c836f012c7d508c/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc2dcd0ca65a4960e65374b2c836f012c7d508c/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=afc2dcd0ca65a4960e65374b2c836f012c7d508c", "patch": "@@ -14,7 +14,7 @@ use rustc::middle::lang_items;\n use rustc::ty::{self, layout};\n use rustc::mir;\n use abi::{Abi, FnType, ArgType};\n-use adt;\n+use adt::{self, MaybeSizedValue};\n use base::{self, Lifetime};\n use callee::{Callee, CalleeData, Fn, Intrinsic, NamedTupleConstructor, Virtual};\n use common::{self, BlockAndBuilder, Funclet};\n@@ -38,8 +38,6 @@ use super::lvalue::{LvalueRef};\n use super::operand::OperandRef;\n use super::operand::OperandValue::{Pair, Ref, Immediate};\n \n-use std::ptr;\n-\n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn trans_block(&mut self, bb: mir::BasicBlock,\n         funclets: &IndexVec<mir::BasicBlock, Option<Funclet>>) {\n@@ -244,35 +242,27 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let lvalue = self.trans_lvalue(&bcx, location);\n                 let drop_fn = glue::get_drop_glue(bcx.ccx, ty);\n                 let drop_ty = glue::get_drop_glue_type(bcx.ccx.shared(), ty);\n-                let is_sized = bcx.ccx.shared().type_is_sized(ty);\n-                let llvalue = if is_sized {\n-                    if drop_ty != ty {\n+                let ptr = if bcx.ccx.shared().type_is_sized(ty) {\n+                    let value = if drop_ty != ty {\n                         bcx.pointercast(lvalue.llval, type_of::type_of(bcx.ccx, drop_ty).ptr_to())\n                     } else {\n                         lvalue.llval\n-                    }\n+                    };\n+                    MaybeSizedValue::sized(value)\n                 } else {\n-                    // FIXME(#36457) Currently drop glue takes sized\n-                    // values as a `*(data, meta)`, but elsewhere in\n-                    // MIR we pass `(data, meta)` as two separate\n-                    // arguments. It would be better to fix drop glue,\n-                    // but I am shooting for a quick fix to #35546\n-                    // here that can be cleanly backported to beta, so\n-                    // I want to avoid touching all of trans.\n-                    let scratch = base::alloc_ty(&bcx, ty, \"drop\");\n-                    Lifetime::Start.call(&bcx, scratch);\n-                    bcx.store(lvalue.llval, base::get_dataptr(&bcx, scratch));\n-                    bcx.store(lvalue.llextra, base::get_meta(&bcx, scratch));\n-                    scratch\n+                    MaybeSizedValue::unsized_(lvalue.llval, lvalue.llextra)\n                 };\n+                let args = &[ptr.value, ptr.meta][..1 + ptr.has_meta() as usize];\n                 if let Some(unwind) = unwind {\n-                    bcx.invoke(drop_fn,\n-                               &[llvalue],\n-                               self.blocks[target],\n-                               llblock(self, unwind),\n-                               cleanup_bundle);\n+                    bcx.invoke(\n+                        drop_fn,\n+                        args,\n+                        self.blocks[target],\n+                        llblock(self, unwind),\n+                        cleanup_bundle\n+                    );\n                 } else {\n-                    bcx.call(drop_fn, &[llvalue], cleanup_bundle);\n+                    bcx.call(drop_fn, args, cleanup_bundle);\n                     funclet_br(self, bcx, target);\n                 }\n             }\n@@ -429,7 +419,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     }\n                     _ => None\n                 };\n-                let intrinsic = intrinsic.as_ref().map(|s| &s[..]);\n+                let mut intrinsic = intrinsic.as_ref().map(|s| &s[..]);\n \n                 if intrinsic == Some(\"move_val_init\") {\n                     let &(_, target) = destination.as_ref().unwrap();\n@@ -441,65 +431,6 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     return;\n                 }\n \n-                // FIXME: This should proxy to the drop glue in the future when the ABI matches;\n-                // most of the below code was copied from the match arm for TerminatorKind::Drop.\n-                if intrinsic == Some(\"drop_in_place\") {\n-                    let &(_, target) = destination.as_ref().unwrap();\n-                    let ty = if let ty::TyFnDef(_, substs, _) = callee.ty.sty {\n-                        substs.type_at(0)\n-                    } else {\n-                        bug!(\"Unexpected ty: {}\", callee.ty);\n-                    };\n-\n-                    // Double check for necessity to drop\n-                    if !bcx.ccx.shared().type_needs_drop(ty) {\n-                        funclet_br(self, bcx, target);\n-                        return;\n-                    }\n-\n-                    let ptr = self.trans_operand(&bcx, &args[0]);\n-                    let (llval, llextra) = match ptr.val {\n-                        Immediate(llptr) => (llptr, ptr::null_mut()),\n-                        Pair(llptr, llextra) => (llptr, llextra),\n-                        Ref(_) => bug!(\"Deref of by-Ref type {:?}\", ptr.ty)\n-                    };\n-\n-                    let drop_fn = glue::get_drop_glue(bcx.ccx, ty);\n-                    let drop_ty = glue::get_drop_glue_type(bcx.ccx.shared(), ty);\n-                    let is_sized = bcx.ccx.shared().type_is_sized(ty);\n-                    let llvalue = if is_sized {\n-                        if drop_ty != ty {\n-                            bcx.pointercast(llval, type_of::type_of(bcx.ccx, drop_ty).ptr_to())\n-                        } else {\n-                            llval\n-                        }\n-                    } else {\n-                        // FIXME(#36457) Currently drop glue takes sized\n-                        // values as a `*(data, meta)`, but elsewhere in\n-                        // MIR we pass `(data, meta)` as two separate\n-                        // arguments. It would be better to fix drop glue,\n-                        // but I am shooting for a quick fix to #35546\n-                        // here that can be cleanly backported to beta, so\n-                        // I want to avoid touching all of trans.\n-                        let scratch = base::alloc_ty(&bcx, ty, \"drop\");\n-                        Lifetime::Start.call(&bcx, scratch);\n-                        bcx.store(llval, base::get_dataptr(&bcx, scratch));\n-                        bcx.store(llextra, base::get_meta(&bcx, scratch));\n-                        scratch\n-                    };\n-                    if let Some(unwind) = *cleanup {\n-                        bcx.invoke(drop_fn,\n-                            &[llvalue],\n-                            self.blocks[target],\n-                            llblock(self, unwind),\n-                            cleanup_bundle);\n-                    } else {\n-                        bcx.call(drop_fn, &[llvalue], cleanup_bundle);\n-                        funclet_br(self, bcx, target);\n-                    }\n-                    return;\n-                }\n-\n                 if intrinsic == Some(\"transmute\") {\n                     let &(ref dest, target) = destination.as_ref().unwrap();\n                     self.with_lvalue_ref(&bcx, dest, |this, dest| {\n@@ -517,6 +448,26 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 }).collect::<Vec<_>>();\n                 let fn_ty = callee.direct_fn_type(bcx.ccx, &extra_args);\n \n+                if intrinsic == Some(\"drop_in_place\") {\n+                    let &(_, target) = destination.as_ref().unwrap();\n+                    let ty = if let ty::TyFnDef(_, substs, _) = callee.ty.sty {\n+                        substs.type_at(0)\n+                    } else {\n+                        bug!(\"Unexpected ty: {}\", callee.ty);\n+                    };\n+\n+                    // Double check for necessity to drop\n+                    if !bcx.ccx.shared().type_needs_drop(ty) {\n+                        funclet_br(self, bcx, target);\n+                        return;\n+                    }\n+\n+                    let drop_fn = glue::get_drop_glue(bcx.ccx, ty);\n+                    let llty = fn_ty.llvm_type(bcx.ccx).ptr_to();\n+                    callee.data = Fn(bcx.pointercast(drop_fn, llty));\n+                    intrinsic = None;\n+                }\n+\n                 // The arguments we'll be passing. Plus one to account for outptr, if used.\n                 let arg_count = fn_ty.args.len() + fn_ty.ret.is_indirect() as usize;\n                 let mut llargs = Vec::with_capacity(arg_count);"}, {"sha": "6e0d8d08e70421152238c4f8f078733a391f755d", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/afc2dcd0ca65a4960e65374b2c836f012c7d508c/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc2dcd0ca65a4960e65374b2c836f012c7d508c/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=afc2dcd0ca65a4960e65374b2c836f012c7d508c", "patch": "@@ -187,12 +187,11 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         assert_eq!(dg.ty(), glue::get_drop_glue_type(ccx.shared(), dg.ty()));\n         let t = dg.ty();\n \n-        let sig = tcx.mk_fn_sig(iter::once(tcx.mk_mut_ptr(tcx.types.i8)), tcx.mk_nil(), false);\n+        let sig = tcx.mk_fn_sig(iter::once(tcx.mk_mut_ptr(t)), tcx.mk_nil(), false);\n \n-        // Create a FnType for fn(*mut i8) and substitute the real type in\n-        // later - that prevents FnType from splitting fat pointers up.\n-        let mut fn_ty = FnType::new(ccx, Abi::Rust, &sig, &[]);\n-        fn_ty.args[0].original_ty = type_of::type_of(ccx, t).ptr_to();\n+        debug!(\"predefine_drop_glue: sig={}\", sig);\n+\n+        let fn_ty = FnType::new(ccx, Abi::Rust, &sig, &[]);\n         let llfnty = fn_ty.llvm_type(ccx);\n \n         assert!(declare::get_defined_value(ccx, symbol_name).is_none());"}]}