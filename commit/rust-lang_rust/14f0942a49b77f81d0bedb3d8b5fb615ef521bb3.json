{"sha": "14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0ZjA5NDJhNDliNzdmODFkMGJlZGIzZDhiNWZiNjE1ZWY1MjFiYjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-03T14:18:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-03T14:18:03Z"}, "message": "Auto merge of #22532 - pnkfelix:arith-overflow, r=pnkfelix,eddyb\n\nRebase and follow-through on work done by @cmr and @aatch.\r\n\r\nImplements most of rust-lang/rfcs#560. Errors encountered from the checks during building were fixed.\r\n\r\nThe checks for division, remainder and bit-shifting have not been implemented yet.\r\n\r\nSee also PR #20795\r\n\r\ncc @Aatch ; cc @nikomatsakis", "tree": {"sha": "fa3cabf0f4e563a1b4f9e40fafa4855e905fd8e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa3cabf0f4e563a1b4f9e40fafa4855e905fd8e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "html_url": "https://github.com/rust-lang/rust/commit/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38e97b99a6b133cb4c621c68e75b28abc6c617c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/38e97b99a6b133cb4c621c68e75b28abc6c617c1", "html_url": "https://github.com/rust-lang/rust/commit/38e97b99a6b133cb4c621c68e75b28abc6c617c1"}, {"sha": "243c5164ea32b38c4ac44fdd5e0ceb2da45c283f", "url": "https://api.github.com/repos/rust-lang/rust/commits/243c5164ea32b38c4ac44fdd5e0ceb2da45c283f", "html_url": "https://github.com/rust-lang/rust/commit/243c5164ea32b38c4ac44fdd5e0ceb2da45c283f"}], "stats": {"total": 1564, "additions": 1189, "deletions": 375}, "files": [{"sha": "b0490b287ad9a303214f9224be1dc6f9eec574de", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -818,19 +818,19 @@ impl BitVec {\n         let full_value = if value { !0 } else { 0 };\n \n         // Correct the old tail word, setting or clearing formerly unused bits\n-        let old_last_word = blocks_for_bits(self.nbits) - 1;\n+        let num_cur_blocks = blocks_for_bits(self.nbits);\n         if self.nbits % u32::BITS as usize > 0 {\n             let mask = mask_for_bits(self.nbits);\n             if value {\n-                self.storage[old_last_word] |= !mask;\n+                self.storage[num_cur_blocks - 1] |= !mask;\n             } else {\n                 // Extra bits are already zero by invariant.\n             }\n         }\n \n         // Fill in words after the old tail word\n         let stop_idx = cmp::min(self.storage.len(), new_nblocks);\n-        for idx in old_last_word + 1..stop_idx {\n+        for idx in num_cur_blocks..stop_idx {\n             self.storage[idx] = full_value;\n         }\n "}, {"sha": "1fa592ac477a243cf3f9010c51d8b4a6749cb8bd", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -25,7 +25,7 @@ use core::fmt::Debug;\n use core::hash::{Hash, Hasher};\n use core::iter::{Map, FromIterator, IntoIterator};\n use core::ops::{Index, IndexMut};\n-use core::{iter, fmt, mem};\n+use core::{iter, fmt, mem, usize};\n use Bound::{self, Included, Excluded, Unbounded};\n \n use borrow::Borrow;\n@@ -1467,7 +1467,7 @@ macro_rules! range_impl {\n             $Range {\n                 inner: AbsIter {\n                     traversals: traversals,\n-                    size: 0, // unused\n+                    size: usize::MAX, // unused\n                 }\n             }\n         }"}, {"sha": "f2a6910a30252469d22bdafd6d5c6a127a114e44", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -1215,7 +1215,8 @@ impl<K, V> Node<K, V> {\n         ptr::copy(\n             self.edges_mut().as_mut_ptr().offset(index as isize),\n             self.edges().as_ptr().offset(index as isize + 1),\n-            self.len() - index + 1\n+            // index can be == len+1, so do the +1 first to avoid underflow.\n+            (self.len() + 1) - index\n         );\n \n         edge"}, {"sha": "b3706e203523bb510ceab2587b0d234c9f00779c", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -96,6 +96,7 @@ use core::iter::{range_step, MultiplicativeIterator};\n use core::marker::Sized;\n use core::mem::size_of;\n use core::mem;\n+use core::num::wrapping::WrappingOps;\n use core::ops::FnMut;\n use core::option::Option::{self, Some, None};\n use core::ptr::PtrExt;\n@@ -1209,18 +1210,22 @@ struct SizeDirection {\n impl Iterator for ElementSwaps {\n     type Item = (usize, usize);\n \n-    #[inline]\n+    // #[inline]\n     fn next(&mut self) -> Option<(usize, usize)> {\n+        fn new_pos_wrapping(i: usize, s: Direction) -> usize {\n+            i.wrapping_add(match s { Pos => 1, Neg => -1 })\n+        }\n+\n         fn new_pos(i: usize, s: Direction) -> usize {\n-            i + match s { Pos => 1, Neg => -1 }\n+            match s { Pos => i + 1, Neg => i - 1 }\n         }\n \n         // Find the index of the largest mobile element:\n         // The direction should point into the vector, and the\n         // swap should be with a smaller `size` element.\n         let max = self.sdir.iter().cloned().enumerate()\n                            .filter(|&(i, sd)|\n-                                new_pos(i, sd.dir) < self.sdir.len() &&\n+                                new_pos_wrapping(i, sd.dir) < self.sdir.len() &&\n                                 self.sdir[new_pos(i, sd.dir)].size < sd.size)\n                            .max_by(|&(_, sd)| sd.size);\n         match max {"}, {"sha": "551d28b91b4bf02a2f38a30f7ead39f35f143728", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 41, "deletions": 26, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -26,6 +26,7 @@ use core::fmt;\n use core::iter::{self, repeat, FromIterator, IntoIterator, RandomAccessIterator};\n use core::mem;\n use core::num::{Int, UnsignedInt};\n+use core::num::wrapping::WrappingOps;\n use core::ops::{Index, IndexMut};\n use core::ptr::{self, Unique};\n use core::raw::Slice as RawSlice;\n@@ -120,6 +121,20 @@ impl<T> VecDeque<T> {\n     #[inline]\n     fn wrap_index(&self, idx: usize) -> usize { wrap_index(idx, self.cap) }\n \n+    /// Returns the index in the underlying buffer for a given logical element\n+    /// index + addend.\n+    #[inline]\n+    fn wrap_add(&self, idx: usize, addend: usize) -> usize {\n+        wrap_index(idx.wrapping_add(addend), self.cap)\n+    }\n+\n+    /// Returns the index in the underlying buffer for a given logical element\n+    /// index - subtrahend.\n+    #[inline]\n+    fn wrap_sub(&self, idx: usize, subtrahend: usize) -> usize {\n+        wrap_index(idx.wrapping_sub(subtrahend), self.cap)\n+    }\n+\n     /// Copies a contiguous block of memory len long from src to dst\n     #[inline]\n     unsafe fn copy(&self, dst: usize, src: usize, len: usize) {\n@@ -197,7 +212,7 @@ impl<T> VecDeque<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self, i: usize) -> Option<&T> {\n         if i < self.len() {\n-            let idx = self.wrap_index(self.tail + i);\n+            let idx = self.wrap_add(self.tail, i);\n             unsafe { Some(&*self.ptr.offset(idx as isize)) }\n         } else {\n             None\n@@ -227,7 +242,7 @@ impl<T> VecDeque<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut(&mut self, i: usize) -> Option<&mut T> {\n         if i < self.len() {\n-            let idx = self.wrap_index(self.tail + i);\n+            let idx = self.wrap_add(self.tail, i);\n             unsafe { Some(&mut *self.ptr.offset(idx as isize)) }\n         } else {\n             None\n@@ -257,8 +272,8 @@ impl<T> VecDeque<T> {\n     pub fn swap(&mut self, i: usize, j: usize) {\n         assert!(i < self.len());\n         assert!(j < self.len());\n-        let ri = self.wrap_index(self.tail + i);\n-        let rj = self.wrap_index(self.tail + j);\n+        let ri = self.wrap_add(self.tail, i);\n+        let rj = self.wrap_add(self.tail, j);\n         unsafe {\n             ptr::swap(self.ptr.offset(ri as isize), self.ptr.offset(rj as isize))\n         }\n@@ -427,7 +442,7 @@ impl<T> VecDeque<T> {\n                 //   [. . . o o o o o o o . . . . . . ]\n                 //        H T\n                 //   [o o . o o o o o ]\n-                let len = self.wrap_index(self.head - target_cap);\n+                let len = self.wrap_sub(self.head, target_cap);\n                 unsafe {\n                     self.copy_nonoverlapping(0, target_cap, len);\n                 }\n@@ -438,7 +453,7 @@ impl<T> VecDeque<T> {\n                 //   [o o o o o . . . . . . . . . o o ]\n                 //              H T\n                 //   [o o o o o . o o ]\n-                debug_assert!(self.wrap_index(self.head - 1) < target_cap);\n+                debug_assert!(self.wrap_sub(self.head, 1) < target_cap);\n                 let len = self.cap - self.tail;\n                 let new_tail = target_cap - len;\n                 unsafe {\n@@ -775,7 +790,7 @@ impl<T> VecDeque<T> {\n             None\n         } else {\n             let tail = self.tail;\n-            self.tail = self.wrap_index(self.tail + 1);\n+            self.tail = self.wrap_add(self.tail, 1);\n             unsafe { Some(self.buffer_read(tail)) }\n         }\n     }\n@@ -799,7 +814,7 @@ impl<T> VecDeque<T> {\n             debug_assert!(!self.is_full());\n         }\n \n-        self.tail = self.wrap_index(self.tail - 1);\n+        self.tail = self.wrap_sub(self.tail, 1);\n         let tail = self.tail;\n         unsafe { self.buffer_write(tail, t); }\n     }\n@@ -824,7 +839,7 @@ impl<T> VecDeque<T> {\n         }\n \n         let head = self.head;\n-        self.head = self.wrap_index(self.head + 1);\n+        self.head = self.wrap_add(self.head, 1);\n         unsafe { self.buffer_write(head, t) }\n     }\n \n@@ -847,7 +862,7 @@ impl<T> VecDeque<T> {\n         if self.is_empty() {\n             None\n         } else {\n-            self.head = self.wrap_index(self.head - 1);\n+            self.head = self.wrap_sub(self.head, 1);\n             let head = self.head;\n             unsafe { Some(self.buffer_read(head)) }\n         }\n@@ -971,7 +986,7 @@ impl<T> VecDeque<T> {\n         //      A - The element that should be after the insertion point\n         //      M - Indicates element was moved\n \n-        let idx = self.wrap_index(self.tail + i);\n+        let idx = self.wrap_add(self.tail, i);\n \n         let distance_to_tail = i;\n         let distance_to_head = self.len() - i;\n@@ -990,7 +1005,7 @@ impl<T> VecDeque<T> {\n                 //      [A o o o o o o o . . . . . I]\n                 //\n \n-                self.tail = self.wrap_index(self.tail - 1);\n+                self.tail = self.wrap_sub(self.tail, 1);\n             },\n             (true, true, _) => unsafe {\n                 // contiguous, insert closer to tail:\n@@ -1012,7 +1027,7 @@ impl<T> VecDeque<T> {\n                 //      [o I A o o o o o . . . . . . . o]\n                 //       M                             M\n \n-                let new_tail = self.wrap_index(self.tail - 1);\n+                let new_tail = self.wrap_sub(self.tail, 1);\n \n                 self.copy(new_tail, self.tail, 1);\n                 // Already moved the tail, so we only copy `i - 1` elements.\n@@ -1031,7 +1046,7 @@ impl<T> VecDeque<T> {\n                 //                       M M M\n \n                 self.copy(idx + 1, idx, self.head - idx);\n-                self.head = self.wrap_index(self.head + 1);\n+                self.head = self.wrap_add(self.head, 1);\n             },\n             (false, true, true) => unsafe {\n                 // discontiguous, insert closer to tail, tail section:\n@@ -1123,7 +1138,7 @@ impl<T> VecDeque<T> {\n         }\n \n         // tail might've been changed so we need to recalculate\n-        let new_idx = self.wrap_index(self.tail + i);\n+        let new_idx = self.wrap_add(self.tail, i);\n         unsafe {\n             self.buffer_write(new_idx, t);\n         }\n@@ -1170,7 +1185,7 @@ impl<T> VecDeque<T> {\n         //      R - Indicates element that is being removed\n         //      M - Indicates element was moved\n \n-        let idx = self.wrap_index(self.tail + i);\n+        let idx = self.wrap_add(self.tail, i);\n \n         let elem = unsafe {\n             Some(self.buffer_read(idx))\n@@ -1219,7 +1234,7 @@ impl<T> VecDeque<T> {\n                 //                               M M\n \n                 self.copy(self.tail + 1, self.tail, i);\n-                self.tail = self.wrap_index(self.tail + 1);\n+                self.tail = self.wrap_add(self.tail, 1);\n             },\n             (false, false, false) => unsafe {\n                 // discontiguous, remove closer to head, head section:\n@@ -1265,7 +1280,7 @@ impl<T> VecDeque<T> {\n                     self.copy(0, 1, self.head - 1);\n                 }\n \n-                self.head = self.wrap_index(self.head - 1);\n+                self.head = self.wrap_sub(self.head, 1);\n             },\n             (false, true, false) => unsafe {\n                 // discontiguous, remove closer to tail, head section:\n@@ -1286,7 +1301,7 @@ impl<T> VecDeque<T> {\n                 // move elements from tail to end forward, excluding the last one\n                 self.copy(self.tail + 1, self.tail, self.cap - self.tail - 1);\n \n-                self.tail = self.wrap_index(self.tail + 1);\n+                self.tail = self.wrap_add(self.tail, 1);\n             }\n         }\n \n@@ -1354,7 +1369,7 @@ impl<T> VecDeque<T> {\n         }\n \n         // Cleanup where the ends of the buffers are\n-        self.head = self.wrap_index(self.head - other_len);\n+        self.head = self.wrap_sub(self.head, other_len);\n         other.head = other.wrap_index(other_len);\n \n         other\n@@ -1429,7 +1444,7 @@ fn wrap_index(index: usize, size: usize) -> usize {\n #[inline]\n fn count(tail: usize, head: usize, size: usize) -> usize {\n     // size is always a power of 2\n-    (head - tail) & (size - 1)\n+    (head.wrapping_sub(tail)) & (size - 1)\n }\n \n /// `VecDeque` iterator.\n@@ -1461,7 +1476,7 @@ impl<'a, T> Iterator for Iter<'a, T> {\n             return None;\n         }\n         let tail = self.tail;\n-        self.tail = wrap_index(self.tail + 1, self.ring.len());\n+        self.tail = wrap_index(self.tail.wrapping_add(1), self.ring.len());\n         unsafe { Some(self.ring.get_unchecked(tail)) }\n     }\n \n@@ -1479,7 +1494,7 @@ impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n         if self.tail == self.head {\n             return None;\n         }\n-        self.head = wrap_index(self.head - 1, self.ring.len());\n+        self.head = wrap_index(self.head.wrapping_sub(1), self.ring.len());\n         unsafe { Some(self.ring.get_unchecked(self.head)) }\n     }\n }\n@@ -1500,7 +1515,7 @@ impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n         if j >= self.indexable() {\n             None\n         } else {\n-            let idx = wrap_index(self.tail + j, self.ring.len());\n+            let idx = wrap_index(self.tail.wrapping_add(j), self.ring.len());\n             unsafe { Some(self.ring.get_unchecked(idx)) }\n         }\n     }\n@@ -1524,7 +1539,7 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n             return None;\n         }\n         let tail = self.tail;\n-        self.tail = wrap_index(self.tail + 1, self.ring.len());\n+        self.tail = wrap_index(self.tail.wrapping_add(1), self.ring.len());\n \n         unsafe {\n             let elem = self.ring.get_unchecked_mut(tail);\n@@ -1546,7 +1561,7 @@ impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n         if self.tail == self.head {\n             return None;\n         }\n-        self.head = wrap_index(self.head - 1, self.ring.len());\n+        self.head = wrap_index(self.head.wrapping_sub(1), self.ring.len());\n \n         unsafe {\n             let elem = self.ring.get_unchecked_mut(self.head);"}, {"sha": "df0008c500b8e86d94597c81bfe47d0f2d2956dc", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -14,7 +14,7 @@\n \n use prelude::*;\n use default::Default;\n-\n+use num::wrapping::WrappingOps;\n use super::Hasher;\n \n /// An implementation of SipHash 2-4.\n@@ -71,17 +71,17 @@ macro_rules! u8to64_le {\n \n macro_rules! rotl {\n     ($x:expr, $b:expr) =>\n-    (($x << $b) | ($x >> (64 - $b)))\n+    (($x << $b) | ($x >> (64.wrapping_sub($b))))\n }\n \n macro_rules! compress {\n     ($v0:expr, $v1:expr, $v2:expr, $v3:expr) =>\n     ({\n-        $v0 += $v1; $v1 = rotl!($v1, 13); $v1 ^= $v0;\n+        $v0 = $v0.wrapping_add($v1); $v1 = rotl!($v1, 13); $v1 ^= $v0;\n         $v0 = rotl!($v0, 32);\n-        $v2 += $v3; $v3 = rotl!($v3, 16); $v3 ^= $v2;\n-        $v0 += $v3; $v3 = rotl!($v3, 21); $v3 ^= $v0;\n-        $v2 += $v1; $v1 = rotl!($v1, 17); $v1 ^= $v2;\n+        $v2 = $v2.wrapping_add($v3); $v3 = rotl!($v3, 16); $v3 ^= $v2;\n+        $v0 = $v0.wrapping_add($v3); $v3 = rotl!($v3, 21); $v3 ^= $v0;\n+        $v2 = $v2.wrapping_add($v1); $v1 = rotl!($v1, 17); $v1 ^= $v2;\n         $v2 = rotl!($v2, 32);\n     })\n }"}, {"sha": "ed129136091250bec2ed7fcca252c3f66d9851be", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -546,3 +546,14 @@ extern \"rust-intrinsic\" {\n     /// Performs checked `u64` multiplication.\n     pub fn u64_mul_with_overflow(x: u64, y: u64) -> (u64, bool);\n }\n+\n+// SNAP 880fb89\n+#[cfg(not(stage0))]\n+extern \"rust-intrinsic\" {\n+    /// Returns (a + b) mod 2^N, where N is the width of N in bits.\n+    pub fn overflowing_add<T>(a: T, b: T) -> T;\n+    /// Returns (a - b) mod 2^N, where N is the width of N in bits.\n+    pub fn overflowing_sub<T>(a: T, b: T) -> T;\n+    /// Returns (a * b) mod 2^N, where N is the width of N in bits.\n+    pub fn overflowing_mul<T>(a: T, b: T) -> T;\n+}"}, {"sha": "9495bc2e19d6505638f763282adaa2752181c997", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -728,10 +728,11 @@ pub trait IteratorExt: Iterator + Sized {\n         P: FnMut(Self::Item) -> bool,\n         Self: ExactSizeIterator + DoubleEndedIterator\n     {\n-        let mut i = self.len() - 1;\n+        let mut i = self.len();\n+\n         while let Some(v) = self.next_back() {\n             if predicate(v) {\n-                return Some(i);\n+                return Some(i - 1);\n             }\n             i -= 1;\n         }\n@@ -1129,7 +1130,11 @@ impl<I> RandomAccessIterator for Rev<I> where I: DoubleEndedIterator + RandomAcc\n     #[inline]\n     fn idx(&mut self, index: usize) -> Option<<I as Iterator>::Item> {\n         let amt = self.indexable();\n-        self.iter.idx(amt - index - 1)\n+        if amt > index {\n+            self.iter.idx(amt - index - 1)\n+        } else {\n+            None\n+        }\n     }\n }\n "}, {"sha": "94d37cee5b37da7523948750b99ab819fcb20fb6", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -69,6 +69,7 @@\n #![feature(unboxed_closures)]\n #![feature(rustc_attrs)]\n #![feature(optin_builtin_traits)]\n+#![feature(concat_idents)]\n \n #[macro_use]\n mod macros;"}, {"sha": "92cdd84160b7ac1672855c2ce8b159c662829610", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -15,6 +15,8 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n \n+use self::wrapping::{OverflowingOps, WrappingOps};\n+\n use char::CharExt;\n use clone::Clone;\n use cmp::{PartialEq, Eq, PartialOrd, Ord};\n@@ -30,6 +32,9 @@ use option::Option::{self, Some, None};\n use result::Result::{self, Ok, Err};\n use str::{FromStr, StrExt};\n \n+#[unstable(feature = \"core\", reason = \"may be removed or relocated\")]\n+pub mod wrapping;\n+\n /// A built-in signed or unsigned integer.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Int\n@@ -48,6 +53,8 @@ pub trait Int\n     + BitXor<Output=Self>\n     + Shl<uint, Output=Self>\n     + Shr<uint, Output=Self>\n+    + WrappingOps\n+    + OverflowingOps\n {\n     /// Returns the `0` value of this integer type.\n     // FIXME (#5527): Should be an associated constant\n@@ -376,11 +383,23 @@ pub trait Int\n         let mut base = self;\n         let mut acc: Self = Int::one();\n \n+        let mut prev_base = self;\n+        let mut base_oflo = false;\n         while exp > 0 {\n             if (exp & 1) == 1 {\n-                acc = acc * base;\n+                if base_oflo {\n+                    // ensure overflow occurs in the same manner it\n+                    // would have otherwise (i.e. signal any exception\n+                    // it would have otherwise).\n+                    acc = acc * (prev_base * prev_base);\n+                } else {\n+                    acc = acc * base;\n+                }\n             }\n-            base = base * base;\n+            prev_base = base;\n+            let (new_base, new_base_oflo) = base.overflowing_mul(base);\n+            base = new_base;\n+            base_oflo = new_base_oflo;\n             exp /= 2;\n         }\n         acc\n@@ -691,12 +710,12 @@ signed_int_impl! { int }\n \n /// A built-in unsigned integer.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait UnsignedInt: Int {\n+pub trait UnsignedInt: Int + WrappingOps {\n     /// Returns `true` iff `self == 2^k` for some `k`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn is_power_of_two(self) -> bool {\n-        (self - Int::one()) & self == Int::zero() && !(self == Int::zero())\n+        (self.wrapping_sub(Int::one())) & self == Int::zero() && !(self == Int::zero())\n     }\n \n     /// Returns the smallest power of two greater than or equal to `self`.\n@@ -706,7 +725,7 @@ pub trait UnsignedInt: Int {\n     fn next_power_of_two(self) -> Self {\n         let bits = size_of::<Self>() * 8;\n         let one: Self = Int::one();\n-        one << ((bits - (self - one).leading_zeros() as usize) % bits)\n+        one << ((bits - self.wrapping_sub(one).leading_zeros() as usize) % bits)\n     }\n \n     /// Returns the smallest power of two greater than or equal to `n`. If the"}, {"sha": "d0c4885ad00b77ebbfaef418cb230976e6955f21", "filename": "src/libcore/num/uint_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibcore%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibcore%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint_macros.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -20,6 +20,6 @@ pub const BYTES : u32 = ($bits / 8);\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MIN: $T = 0 as $T;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const MAX: $T = 0 as $T - 1 as $T;\n+pub const MAX: $T = !0 as $T;\n \n ) }"}, {"sha": "707e41a948be0d14537cf2f8b567063e81f0ed88", "filename": "src/libcore/num/wrapping.rs", "status": "added", "additions": 300, "deletions": 0, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -0,0 +1,300 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![allow(missing_docs)]\n+\n+use ops::*;\n+\n+#[cfg(not(stage0))]\n+use intrinsics::{overflowing_add, overflowing_sub, overflowing_mul};\n+\n+use intrinsics::{i8_add_with_overflow, u8_add_with_overflow};\n+use intrinsics::{i16_add_with_overflow, u16_add_with_overflow};\n+use intrinsics::{i32_add_with_overflow, u32_add_with_overflow};\n+use intrinsics::{i64_add_with_overflow, u64_add_with_overflow};\n+use intrinsics::{i8_sub_with_overflow, u8_sub_with_overflow};\n+use intrinsics::{i16_sub_with_overflow, u16_sub_with_overflow};\n+use intrinsics::{i32_sub_with_overflow, u32_sub_with_overflow};\n+use intrinsics::{i64_sub_with_overflow, u64_sub_with_overflow};\n+use intrinsics::{i8_mul_with_overflow, u8_mul_with_overflow};\n+use intrinsics::{i16_mul_with_overflow, u16_mul_with_overflow};\n+use intrinsics::{i32_mul_with_overflow, u32_mul_with_overflow};\n+use intrinsics::{i64_mul_with_overflow, u64_mul_with_overflow};\n+\n+pub trait WrappingOps {\n+    fn wrapping_add(self, rhs: Self) -> Self;\n+    fn wrapping_sub(self, rhs: Self) -> Self;\n+    fn wrapping_mul(self, rhs: Self) -> Self;\n+}\n+\n+#[unstable(feature = \"core\", reason = \"may be removed, renamed, or relocated\")]\n+pub trait OverflowingOps {\n+    fn overflowing_add(self, rhs: Self) -> (Self, bool);\n+    fn overflowing_sub(self, rhs: Self) -> (Self, bool);\n+    fn overflowing_mul(self, rhs: Self) -> (Self, bool);\n+}\n+\n+#[cfg(not(stage0))]\n+macro_rules! wrapping_impl {\n+    ($($t:ty)*) => ($(\n+        impl WrappingOps for $t {\n+            #[inline(always)]\n+            fn wrapping_add(self, rhs: $t) -> $t {\n+                unsafe {\n+                    overflowing_add(self, rhs)\n+                }\n+            }\n+            #[inline(always)]\n+            fn wrapping_sub(self, rhs: $t) -> $t {\n+                unsafe {\n+                    overflowing_sub(self, rhs)\n+                }\n+            }\n+            #[inline(always)]\n+            fn wrapping_mul(self, rhs: $t) -> $t {\n+                unsafe {\n+                    overflowing_mul(self, rhs)\n+                }\n+            }\n+        }\n+    )*)\n+}\n+\n+#[cfg(stage0)]\n+macro_rules! wrapping_impl {\n+    ($($t:ty)*) => ($(\n+        impl WrappingOps for $t {\n+            #[inline(always)]\n+            fn wrapping_add(self, rhs: $t) -> $t {\n+                self + rhs\n+            }\n+            #[inline(always)]\n+            fn wrapping_sub(self, rhs: $t) -> $t {\n+                self - rhs\n+            }\n+            #[inline(always)]\n+            fn wrapping_mul(self, rhs: $t) -> $t {\n+                self * rhs\n+            }\n+        }\n+    )*)\n+}\n+\n+wrapping_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n+\n+#[unstable(feature = \"core\", reason = \"may be removed, renamed, or relocated\")]\n+#[derive(PartialEq,Eq,PartialOrd,Ord,Clone,Copy)]\n+pub struct Wrapping<T>(pub T);\n+\n+impl<T:WrappingOps> Add for Wrapping<T> {\n+    type Output = Wrapping<T>;\n+\n+    #[inline(always)]\n+    fn add(self, other: Wrapping<T>) -> Wrapping<T> {\n+        Wrapping(self.0.wrapping_add(other.0))\n+    }\n+}\n+\n+impl<T:WrappingOps> Sub for Wrapping<T> {\n+    type Output = Wrapping<T>;\n+\n+    #[inline(always)]\n+    fn sub(self, other: Wrapping<T>) -> Wrapping<T> {\n+        Wrapping(self.0.wrapping_sub(other.0))\n+    }\n+}\n+\n+impl<T:WrappingOps> Mul for Wrapping<T> {\n+    type Output = Wrapping<T>;\n+\n+    #[inline(always)]\n+    fn mul(self, other: Wrapping<T>) -> Wrapping<T> {\n+        Wrapping(self.0.wrapping_mul(other.0))\n+    }\n+}\n+\n+impl<T:WrappingOps+Not<Output=T>> Not for Wrapping<T> {\n+    type Output = Wrapping<T>;\n+\n+    fn not(self) -> Wrapping<T> {\n+        Wrapping(!self.0)\n+    }\n+}\n+\n+impl<T:WrappingOps+BitXor<Output=T>> BitXor for Wrapping<T> {\n+    type Output = Wrapping<T>;\n+\n+    #[inline(always)]\n+    fn bitxor(self, other: Wrapping<T>) -> Wrapping<T> {\n+        Wrapping(self.0 ^ other.0)\n+    }\n+}\n+\n+impl<T:WrappingOps+BitOr<Output=T>> BitOr for Wrapping<T> {\n+    type Output = Wrapping<T>;\n+\n+    #[inline(always)]\n+    fn bitor(self, other: Wrapping<T>) -> Wrapping<T> {\n+        Wrapping(self.0 | other.0)\n+    }\n+}\n+\n+impl<T:WrappingOps+BitAnd<Output=T>> BitAnd for Wrapping<T> {\n+    type Output = Wrapping<T>;\n+\n+    #[inline(always)]\n+    fn bitand(self, other: Wrapping<T>) -> Wrapping<T> {\n+        Wrapping(self.0 & other.0)\n+    }\n+}\n+\n+impl<T:WrappingOps+Shl<uint,Output=T>> Shl<uint> for Wrapping<T> {\n+    type Output = Wrapping<T>;\n+\n+    #[inline(always)]\n+    fn shl(self, other: uint) -> Wrapping<T> {\n+        Wrapping(self.0 << other)\n+    }\n+}\n+\n+impl<T:WrappingOps+Shr<uint,Output=T>> Shr<uint> for Wrapping<T> {\n+    type Output = Wrapping<T>;\n+\n+    #[inline(always)]\n+    fn shr(self, other: uint) -> Wrapping<T> {\n+        Wrapping(self.0 >> other)\n+    }\n+}\n+\n+macro_rules! overflowing_impl {\n+    ($($t:ident)*) => ($(\n+        impl OverflowingOps for $t {\n+            #[inline(always)]\n+            fn overflowing_add(self, rhs: $t) -> ($t, bool) {\n+                unsafe {\n+                    concat_idents!($t, _add_with_overflow)(self, rhs)\n+                }\n+            }\n+            #[inline(always)]\n+            fn overflowing_sub(self, rhs: $t) -> ($t, bool) {\n+                unsafe {\n+                    concat_idents!($t, _sub_with_overflow)(self, rhs)\n+                }\n+            }\n+            #[inline(always)]\n+            fn overflowing_mul(self, rhs: $t) -> ($t, bool) {\n+                unsafe {\n+                    concat_idents!($t, _mul_with_overflow)(self, rhs)\n+                }\n+            }\n+        }\n+    )*)\n+}\n+\n+overflowing_impl! { u8 u16 u32 u64 i8 i16 i32 i64 }\n+\n+#[cfg(target_pointer_width = \"64\")]\n+impl OverflowingOps for usize {\n+    #[inline(always)]\n+    fn overflowing_add(self, rhs: usize) -> (usize, bool) {\n+        unsafe {\n+            let res = u64_add_with_overflow(self as u64, rhs as u64);\n+            (res.0 as usize, res.1)\n+        }\n+    }\n+    #[inline(always)]\n+    fn overflowing_sub(self, rhs: usize) -> (usize, bool) {\n+        unsafe {\n+            let res = u64_sub_with_overflow(self as u64, rhs as u64);\n+            (res.0 as usize, res.1)\n+        }\n+    }\n+    #[inline(always)]\n+    fn overflowing_mul(self, rhs: usize) -> (usize, bool) {\n+        unsafe {\n+            let res = u64_mul_with_overflow(self as u64, rhs as u64);\n+            (res.0 as usize, res.1)\n+        }\n+    }\n+}\n+\n+#[cfg(target_pointer_width = \"32\")]\n+impl OverflowingOps for usize {\n+    #[inline(always)]\n+    fn overflowing_add(self, rhs: usize) -> (usize, bool) {\n+        unsafe {\n+            let res = u32_add_with_overflow(self as u32, rhs as u32);\n+            (res.0 as usize, res.1)\n+        }\n+    }\n+    #[inline(always)]\n+    fn overflowing_sub(self, rhs: usize) -> (usize, bool) {\n+        unsafe {\n+            let res = u32_sub_with_overflow(self as u32, rhs as u32);\n+            (res.0 as usize, res.1)\n+        }\n+    }\n+    #[inline(always)]\n+    fn overflowing_mul(self, rhs: usize) -> (usize, bool) {\n+        unsafe {\n+            let res = u32_mul_with_overflow(self as u32, rhs as u32);\n+            (res.0 as usize, res.1)\n+        }\n+    }\n+}\n+\n+#[cfg(target_pointer_width = \"64\")]\n+impl OverflowingOps for isize {\n+    #[inline(always)]\n+    fn overflowing_add(self, rhs: isize) -> (isize, bool) {\n+        unsafe {\n+            let res = i64_add_with_overflow(self as i64, rhs as i64);\n+            (res.0 as isize, res.1)\n+        }\n+    }\n+    #[inline(always)]\n+    fn overflowing_sub(self, rhs: isize) -> (isize, bool) {\n+        unsafe {\n+            let res = i64_sub_with_overflow(self as i64, rhs as i64);\n+            (res.0 as isize, res.1)\n+        }\n+    }\n+    #[inline(always)]\n+    fn overflowing_mul(self, rhs: isize) -> (isize, bool) {\n+        unsafe {\n+            let res = i64_mul_with_overflow(self as i64, rhs as i64);\n+            (res.0 as isize, res.1)\n+        }\n+    }\n+}\n+\n+#[cfg(target_pointer_width = \"32\")]\n+impl OverflowingOps for isize {\n+    #[inline(always)]\n+    fn overflowing_add(self, rhs: isize) -> (isize, bool) {\n+        unsafe {\n+            let res = i32_add_with_overflow(self as i32, rhs as i32);\n+            (res.0 as isize, res.1)\n+        }\n+    }\n+    #[inline(always)]\n+    fn overflowing_sub(self, rhs: isize) -> (isize, bool) {\n+        unsafe {\n+            let res = i32_sub_with_overflow(self as i32, rhs as i32);\n+            (res.0 as isize, res.1)\n+        }\n+    }\n+    #[inline(always)]\n+    fn overflowing_mul(self, rhs: isize) -> (isize, bool) {\n+        unsafe {\n+            let res = i32_mul_with_overflow(self as i32, rhs as i32);\n+            (res.0 as isize, res.1)\n+        }\n+    }\n+}"}, {"sha": "4f4164f673b91bd6c27f6829c29e6f62adff63f0", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -841,6 +841,7 @@ impl TwoWaySearcher {\n     #[inline]\n     #[allow(dead_code)]\n     fn maximal_suffix(arr: &[u8], reversed: bool) -> (usize, usize) {\n+        use num::wrapping::WrappingOps;\n         let mut left = -1; // Corresponds to i in the paper\n         let mut right = 0; // Corresponds to j in the paper\n         let mut offset = 1; // Corresponds to k in the paper\n@@ -850,17 +851,17 @@ impl TwoWaySearcher {\n             let a;\n             let b;\n             if reversed {\n-                a = arr[left + offset];\n+                a = arr[left.wrapping_add(offset)];\n                 b = arr[right + offset];\n             } else {\n                 a = arr[right + offset];\n-                b = arr[left + offset];\n+                b = arr[left.wrapping_add(offset)];\n             }\n             if a < b {\n                 // Suffix is smaller, period is entire prefix so far.\n                 right += offset;\n                 offset = 1;\n-                period = right - left;\n+                period = right.wrapping_sub(left);\n             } else if a == b {\n                 // Advance through repetition of the current period.\n                 if offset == period {\n@@ -877,7 +878,7 @@ impl TwoWaySearcher {\n                 period = 1;\n             }\n         }\n-        (left + 1, period)\n+        (left.wrapping_add(1), period)\n     }\n }\n "}, {"sha": "721354b6a44c24ce8202585b38b7043443f23938", "filename": "src/libcoretest/num/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibcoretest%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibcoretest%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fmod.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -92,31 +92,31 @@ mod test {\n         assert_eq!(\"127\".parse::<i8>().ok(), Some(i8_val));\n         assert_eq!(\"128\".parse::<i8>().ok(), None);\n \n-        i8_val += 1 as i8;\n+        i8_val = i8_val.wrapping_add(1);\n         assert_eq!(\"-128\".parse::<i8>().ok(), Some(i8_val));\n         assert_eq!(\"-129\".parse::<i8>().ok(), None);\n \n         let mut i16_val: i16 = 32_767_i16;\n         assert_eq!(\"32767\".parse::<i16>().ok(), Some(i16_val));\n         assert_eq!(\"32768\".parse::<i16>().ok(), None);\n \n-        i16_val += 1 as i16;\n+        i16_val = i16_val.wrapping_add(1);\n         assert_eq!(\"-32768\".parse::<i16>().ok(), Some(i16_val));\n         assert_eq!(\"-32769\".parse::<i16>().ok(), None);\n \n         let mut i32_val: i32 = 2_147_483_647_i32;\n         assert_eq!(\"2147483647\".parse::<i32>().ok(), Some(i32_val));\n         assert_eq!(\"2147483648\".parse::<i32>().ok(), None);\n \n-        i32_val += 1 as i32;\n+        i32_val = i32_val.wrapping_add(1);\n         assert_eq!(\"-2147483648\".parse::<i32>().ok(), Some(i32_val));\n         assert_eq!(\"-2147483649\".parse::<i32>().ok(), None);\n \n         let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n         assert_eq!(\"9223372036854775807\".parse::<i64>().ok(), Some(i64_val));\n         assert_eq!(\"9223372036854775808\".parse::<i64>().ok(), None);\n \n-        i64_val += 1 as i64;\n+        i64_val = i64_val.wrapping_add(1);\n         assert_eq!(\"-9223372036854775808\".parse::<i64>().ok(), Some(i64_val));\n         assert_eq!(\"-9223372036854775809\".parse::<i64>().ok(), None);\n     }"}, {"sha": "71ace016d6b1691b4ec6c36f171fb681a795960f", "filename": "src/librand/chacha.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibrand%2Fchacha.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibrand%2Fchacha.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fchacha.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -12,6 +12,7 @@\n \n use core::prelude::*;\n use core::num::Int;\n+use core::num::wrapping::WrappingOps;\n use {Rng, SeedableRng, Rand};\n \n const KEY_WORDS    : uint =  8; // 8 words for the 256-bit key\n@@ -43,10 +44,10 @@ static EMPTY: ChaChaRng = ChaChaRng {\n \n macro_rules! quarter_round{\n     ($a: expr, $b: expr, $c: expr, $d: expr) => {{\n-        $a += $b; $d ^= $a; $d = $d.rotate_left(16);\n-        $c += $d; $b ^= $c; $b = $b.rotate_left(12);\n-        $a += $b; $d ^= $a; $d = $d.rotate_left( 8);\n-        $c += $d; $b ^= $c; $b = $b.rotate_left( 7);\n+        $a = $a.wrapping_add($b); $d = $d ^ $a; $d = $d.rotate_left(16);\n+        $c = $c.wrapping_add($d); $b = $b ^ $c; $b = $b.rotate_left(12);\n+        $a = $a.wrapping_add($b); $d = $d ^ $a; $d = $d.rotate_left( 8);\n+        $c = $c.wrapping_add($d); $b = $b ^ $c; $b = $b.rotate_left( 7);\n     }}\n }\n \n@@ -74,7 +75,7 @@ fn core(output: &mut [u32; STATE_WORDS], input: &[u32; STATE_WORDS]) {\n     }\n \n     for i in 0..STATE_WORDS {\n-        output[i] += input[i];\n+        output[i] = output[i].wrapping_add(input[i]);\n     }\n }\n "}, {"sha": "fb73a44c2b94510b096a35ea621e537992fcc0b2", "filename": "src/librand/distributions/range.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibrand%2Fdistributions%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibrand%2Fdistributions%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Frange.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -14,6 +14,7 @@\n \n use core::prelude::{PartialOrd};\n use core::num::Int;\n+use core::num::wrapping::WrappingOps;\n \n use Rng;\n use distributions::{Sample, IndependentSample};\n@@ -97,7 +98,7 @@ macro_rules! integer_impl {\n             // bijection.\n \n             fn construct_range(low: $ty, high: $ty) -> Range<$ty> {\n-                let range = high as $unsigned - low as $unsigned;\n+                let range = (high as $unsigned).wrapping_sub(low as $unsigned);\n                 let unsigned_max: $unsigned = Int::max_value();\n \n                 // this is the largest number that fits into $unsigned\n@@ -122,7 +123,7 @@ macro_rules! integer_impl {\n                     // be uniformly distributed)\n                     if v < r.accept_zone as $unsigned {\n                         // and return it, with some adjustments\n-                        return r.low + (v % r.range as $unsigned) as $ty;\n+                        return r.low.wrapping_add((v % r.range as $unsigned) as $ty);\n                     }\n                 }\n             }"}, {"sha": "28f1ea872d7ad4846fbacecdb4cebd3f27ffc161", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 69, "deletions": 67, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -13,6 +13,7 @@\n use core::prelude::*;\n use core::slice;\n use core::iter::{range_step, repeat};\n+use core::num::wrapping::Wrapping;\n \n use {Rng, SeedableRng, Rand};\n \n@@ -60,7 +61,7 @@ impl IsaacRng {\n     /// of `rsl` as a seed, otherwise construct one algorithmically (not\n     /// randomly).\n     fn init(&mut self, use_rsl: bool) {\n-        let mut a = 0x9e3779b9;\n+        let mut a = Wrapping(0x9e3779b9);\n         let mut b = a;\n         let mut c = a;\n         let mut d = a;\n@@ -71,14 +72,14 @@ impl IsaacRng {\n \n         macro_rules! mix {\n             () => {{\n-                a^=b<<11; d+=a; b+=c;\n-                b^=c>>2;  e+=b; c+=d;\n-                c^=d<<8;  f+=c; d+=e;\n-                d^=e>>16; g+=d; e+=f;\n-                e^=f<<10; h+=e; f+=g;\n-                f^=g>>4;  a+=f; g+=h;\n-                g^=h<<8;  b+=g; h+=a;\n-                h^=a>>9;  c+=h; a+=b;\n+                a=a^(b<<11); d=d+a; b=b+c;\n+                b=b^(c>>2);  e=e+b; c=c+d;\n+                c=c^(d<<8);  f=f+c; d=d+e;\n+                d=d^(e>>16); g=g+d; e=e+f;\n+                e=e^(f<<10); h=h+e; f=f+g;\n+                f=f^(g>>4);  a=a+f; g=g+h;\n+                g=g^(h<<8);  b=b+g; h=h+a;\n+                h=h^(a>>9);  c=c+h; a=a+b;\n             }}\n         }\n \n@@ -90,15 +91,15 @@ impl IsaacRng {\n             macro_rules! memloop {\n                 ($arr:expr) => {{\n                     for i in range_step(0, RAND_SIZE as uint, 8) {\n-                        a+=$arr[i  ]; b+=$arr[i+1];\n-                        c+=$arr[i+2]; d+=$arr[i+3];\n-                        e+=$arr[i+4]; f+=$arr[i+5];\n-                        g+=$arr[i+6]; h+=$arr[i+7];\n+                        a=a+Wrapping($arr[i  ]); b=b+Wrapping($arr[i+1]);\n+                        c=c+Wrapping($arr[i+2]); d=d+Wrapping($arr[i+3]);\n+                        e=e+Wrapping($arr[i+4]); f=f+Wrapping($arr[i+5]);\n+                        g=g+Wrapping($arr[i+6]); h=h+Wrapping($arr[i+7]);\n                         mix!();\n-                        self.mem[i  ]=a; self.mem[i+1]=b;\n-                        self.mem[i+2]=c; self.mem[i+3]=d;\n-                        self.mem[i+4]=e; self.mem[i+5]=f;\n-                        self.mem[i+6]=g; self.mem[i+7]=h;\n+                        self.mem[i  ]=a.0; self.mem[i+1]=b.0;\n+                        self.mem[i+2]=c.0; self.mem[i+3]=d.0;\n+                        self.mem[i+4]=e.0; self.mem[i+5]=f.0;\n+                        self.mem[i+6]=g.0; self.mem[i+7]=h.0;\n                     }\n                 }}\n             }\n@@ -108,10 +109,10 @@ impl IsaacRng {\n         } else {\n             for i in range_step(0, RAND_SIZE as uint, 8) {\n                 mix!();\n-                self.mem[i  ]=a; self.mem[i+1]=b;\n-                self.mem[i+2]=c; self.mem[i+3]=d;\n-                self.mem[i+4]=e; self.mem[i+5]=f;\n-                self.mem[i+6]=g; self.mem[i+7]=h;\n+                self.mem[i  ]=a.0; self.mem[i+1]=b.0;\n+                self.mem[i+2]=c.0; self.mem[i+3]=d.0;\n+                self.mem[i+4]=e.0; self.mem[i+5]=f.0;\n+                self.mem[i+6]=g.0; self.mem[i+7]=h.0;\n             }\n         }\n \n@@ -130,7 +131,8 @@ impl IsaacRng {\n         const MIDPOINT: uint = (RAND_SIZE / 2) as uint;\n \n         macro_rules! ind {\n-            ($x:expr) => ( self.mem[(($x >> 2) as uint & ((RAND_SIZE - 1) as uint))] )\n+            ($x:expr) => (Wrapping( self.mem[(($x >> 2) as uint &\n+                                              ((RAND_SIZE - 1) as uint))] ))\n         }\n \n         let r = [(0, MIDPOINT), (MIDPOINT, 0)];\n@@ -142,11 +144,11 @@ impl IsaacRng {\n                     let mix = a << $shift as uint;\n \n                     let x = self.mem[base  + mr_offset];\n-                    a = (a ^ mix) + self.mem[base + m2_offset];\n-                    let y = ind!(x) + a + b;\n-                    self.mem[base + mr_offset] = y;\n+                    a = (Wrapping(a ^ mix) + Wrapping(self.mem[base + m2_offset])).0;\n+                    let y = ind!(x) + Wrapping(a) + Wrapping(b);\n+                    self.mem[base + mr_offset] = y.0;\n \n-                    b = ind!(y >> RAND_SIZE_LEN as uint) + x;\n+                    b = (ind!(y.0 >> RAND_SIZE_LEN as uint) + Wrapping(x)).0;\n                     self.rsl[base + mr_offset] = b;\n                 }}\n             }\n@@ -157,11 +159,11 @@ impl IsaacRng {\n                     let mix = a >> $shift as uint;\n \n                     let x = self.mem[base  + mr_offset];\n-                    a = (a ^ mix) + self.mem[base + m2_offset];\n-                    let y = ind!(x) + a + b;\n-                    self.mem[base + mr_offset] = y;\n+                    a = (Wrapping(a ^ mix) + Wrapping(self.mem[base + m2_offset])).0;\n+                    let y = ind!(x) + Wrapping(a) + Wrapping(b);\n+                    self.mem[base + mr_offset] = y.0;\n \n-                    b = ind!(y >> RAND_SIZE_LEN as uint) + x;\n+                    b = (ind!(y.0 >> RAND_SIZE_LEN as uint) + Wrapping(x)).0;\n                     self.rsl[base + mr_offset] = b;\n                 }}\n             }\n@@ -304,22 +306,22 @@ impl Isaac64Rng {\n     fn init(&mut self, use_rsl: bool) {\n         macro_rules! init {\n             ($var:ident) => (\n-                let mut $var = 0x9e3779b97f4a7c13;\n+                let mut $var = Wrapping(0x9e3779b97f4a7c13);\n             )\n         }\n         init!(a); init!(b); init!(c); init!(d);\n         init!(e); init!(f); init!(g); init!(h);\n \n         macro_rules! mix {\n             () => {{\n-                a-=e; f^=h>>9;  h+=a;\n-                b-=f; g^=a<<9;  a+=b;\n-                c-=g; h^=b>>23; b+=c;\n-                d-=h; a^=c<<15; c+=d;\n-                e-=a; b^=d>>14; d+=e;\n-                f-=b; c^=e<<20; e+=f;\n-                g-=c; d^=f>>17; f+=g;\n-                h-=d; e^=g<<14; g+=h;\n+                a=a-e; f=f^h>>9;  h=h+a;\n+                b=b-f; g=g^a<<9;  a=a+b;\n+                c=c-g; h=h^b>>23; b=b+c;\n+                d=d-h; a=a^c<<15; c=c+d;\n+                e=e-a; b=b^d>>14; d=d+e;\n+                f=f-b; c=c^e<<20; e=e+f;\n+                g=g-c; d=d^f>>17; f=f+g;\n+                h=h-d; e=e^g<<14; g=g+h;\n             }}\n         }\n \n@@ -331,15 +333,15 @@ impl Isaac64Rng {\n             macro_rules! memloop {\n                 ($arr:expr) => {{\n                     for i in (0..RAND_SIZE_64 / 8).map(|i| i * 8) {\n-                        a+=$arr[i  ]; b+=$arr[i+1];\n-                        c+=$arr[i+2]; d+=$arr[i+3];\n-                        e+=$arr[i+4]; f+=$arr[i+5];\n-                        g+=$arr[i+6]; h+=$arr[i+7];\n+                        a=a+Wrapping($arr[i  ]); b=b+Wrapping($arr[i+1]);\n+                        c=c+Wrapping($arr[i+2]); d=d+Wrapping($arr[i+3]);\n+                        e=e+Wrapping($arr[i+4]); f=f+Wrapping($arr[i+5]);\n+                        g=g+Wrapping($arr[i+6]); h=h+Wrapping($arr[i+7]);\n                         mix!();\n-                        self.mem[i  ]=a; self.mem[i+1]=b;\n-                        self.mem[i+2]=c; self.mem[i+3]=d;\n-                        self.mem[i+4]=e; self.mem[i+5]=f;\n-                        self.mem[i+6]=g; self.mem[i+7]=h;\n+                        self.mem[i  ]=a.0; self.mem[i+1]=b.0;\n+                        self.mem[i+2]=c.0; self.mem[i+3]=d.0;\n+                        self.mem[i+4]=e.0; self.mem[i+5]=f.0;\n+                        self.mem[i+6]=g.0; self.mem[i+7]=h.0;\n                     }\n                 }}\n             }\n@@ -349,10 +351,10 @@ impl Isaac64Rng {\n         } else {\n             for i in (0..RAND_SIZE_64 / 8).map(|i| i * 8) {\n                 mix!();\n-                self.mem[i  ]=a; self.mem[i+1]=b;\n-                self.mem[i+2]=c; self.mem[i+3]=d;\n-                self.mem[i+4]=e; self.mem[i+5]=f;\n-                self.mem[i+6]=g; self.mem[i+7]=h;\n+                self.mem[i  ]=a.0; self.mem[i+1]=b.0;\n+                self.mem[i+2]=c.0; self.mem[i+3]=d.0;\n+                self.mem[i+4]=e.0; self.mem[i+5]=f.0;\n+                self.mem[i+6]=g.0; self.mem[i+7]=h.0;\n             }\n         }\n \n@@ -363,8 +365,8 @@ impl Isaac64Rng {\n     fn isaac64(&mut self) {\n         self.c += 1;\n         // abbreviations\n-        let mut a = self.a;\n-        let mut b = self.b + self.c;\n+        let mut a = Wrapping(self.a);\n+        let mut b = Wrapping(self.b) + Wrapping(self.c);\n         const MIDPOINT: uint =  RAND_SIZE_64 / 2;\n         const MP_VEC: [(uint, uint); 2] = [(0,MIDPOINT), (MIDPOINT, 0)];\n         macro_rules! ind {\n@@ -383,13 +385,13 @@ impl Isaac64Rng {\n                         let mix = if $j == 0 {!mix} else {mix};\n \n                         unsafe {\n-                            let x = *self.mem.get_unchecked(base + mr_offset);\n-                            a = mix + *self.mem.get_unchecked(base + m2_offset);\n-                            let y = ind!(x) + a + b;\n-                            *self.mem.get_unchecked_mut(base + mr_offset) = y;\n+                            let x = Wrapping(*self.mem.get_unchecked(base + mr_offset));\n+                            a = mix + Wrapping(*self.mem.get_unchecked(base + m2_offset));\n+                            let y = Wrapping(ind!(x.0)) + a + b;\n+                            *self.mem.get_unchecked_mut(base + mr_offset) = y.0;\n \n-                            b = ind!(y >> RAND_SIZE_64_LEN) + x;\n-                            *self.rsl.get_unchecked_mut(base + mr_offset) = b;\n+                            b = Wrapping(ind!(y.0 >> RAND_SIZE_64_LEN)) + x;\n+                            *self.rsl.get_unchecked_mut(base + mr_offset) = b.0;\n                         }\n                     }}\n                 }\n@@ -401,13 +403,13 @@ impl Isaac64Rng {\n                         let mix = if $j == 0 {!mix} else {mix};\n \n                         unsafe {\n-                            let x = *self.mem.get_unchecked(base + mr_offset);\n-                            a = mix + *self.mem.get_unchecked(base + m2_offset);\n-                            let y = ind!(x) + a + b;\n-                            *self.mem.get_unchecked_mut(base + mr_offset) = y;\n+                            let x = Wrapping(*self.mem.get_unchecked(base + mr_offset));\n+                            a = mix + Wrapping(*self.mem.get_unchecked(base + m2_offset));\n+                            let y = Wrapping(ind!(x.0)) + a + b;\n+                            *self.mem.get_unchecked_mut(base + mr_offset) = y.0;\n \n-                            b = ind!(y >> RAND_SIZE_64_LEN) + x;\n-                            *self.rsl.get_unchecked_mut(base + mr_offset) = b;\n+                            b = Wrapping(ind!(y.0 >> RAND_SIZE_64_LEN)) + x;\n+                            *self.rsl.get_unchecked_mut(base + mr_offset) = b.0;\n                         }\n                     }}\n                 }\n@@ -419,8 +421,8 @@ impl Isaac64Rng {\n             }\n         }\n \n-        self.a = a;\n-        self.b = b;\n+        self.a = a.0;\n+        self.b = b.0;\n         self.cnt = RAND_SIZE_64;\n     }\n }"}, {"sha": "e32fcaec04734b49730de759492641242d8449fc", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -783,7 +783,7 @@ pub fn get_enum_variants<'tcx>(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::Nod\n             _         => { /* empty */ }\n         }\n         let old_disr_val = disr_val;\n-        disr_val += 1;\n+        disr_val = disr_val.wrapping_add(1);\n         Rc::new(ty::VariantInfo {\n             args: arg_tys,\n             arg_names: arg_names,"}, {"sha": "8152a2bf16dd1f773a56d949ef14dfd587dfcecd", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -347,7 +347,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n \n         ecx.tcx.map.with_path(variant.node.id, |path| encode_path(rbml_w, path));\n         rbml_w.end_tag();\n-        disr_val += 1;\n+        disr_val = disr_val.wrapping_add(1);\n         i += 1;\n     }\n }"}, {"sha": "33c0fb8b031ef4e8c05a8c6c414b244fd1b8955d", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -204,7 +204,9 @@ impl<'a, 'b, 'tcx> DecodeContext<'a, 'b, 'tcx> {\n     pub fn tr_id(&self, id: ast::NodeId) -> ast::NodeId {\n         // from_id_range should be non-empty\n         assert!(!self.from_id_range.empty());\n-        (id - self.from_id_range.min + self.to_id_range.min)\n+        // Use wrapping arithmetic because otherwise it introduces control flow.\n+        // Maybe we should just have the control flow? -- aatch\n+        (id.wrapping_sub(self.from_id_range.min).wrapping_add(self.to_id_range.min))\n     }\n \n     /// Translates an EXTERNAL def-id, converting the crate number from the one used in the encoded"}, {"sha": "497022ac6ac49b3eb87ebfccf0a499db4722f8ba", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -307,8 +307,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                             match const_eval::eval_const_expr_partial(self.tcx, ex, None) {\n                                 Ok(_) => {}\n                                 Err(msg) => {\n-                                    span_err!(self.tcx.sess, ex.span, E0020,\n-                                              \"{} in a constant expression\", msg)\n+                                    span_err!(self.tcx.sess, msg.span, E0020,\n+                                              \"{} in a constant expression\",\n+                                              msg.description())\n                                 }\n                             }\n                         }"}, {"sha": "f8a2c507e4204edbc0b80e0de2ba390288f7daa6", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -13,7 +13,8 @@ use self::Usefulness::*;\n use self::WitnessPreference::*;\n \n use middle::const_eval::{compare_const_vals, const_bool, const_float, const_val};\n-use middle::const_eval::{const_expr_to_pat, eval_const_expr, lookup_const_by_id};\n+use middle::const_eval::{eval_const_expr, eval_const_expr_partial};\n+use middle::const_eval::{const_expr_to_pat, lookup_const_by_id};\n use middle::def::*;\n use middle::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, Init};\n use middle::expr_use_visitor::{JustWrite, LoanCause, MutateMode};\n@@ -229,13 +230,6 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n     }\n }\n \n-fn is_expr_const_nan(tcx: &ty::ctxt, expr: &ast::Expr) -> bool {\n-    match eval_const_expr(tcx, expr) {\n-        const_float(f) => f.is_nan(),\n-        _ => false\n-    }\n-}\n-\n fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat) {\n     ast_util::walk_pat(pat, |p| {\n         match p.node {\n@@ -269,13 +263,26 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n // Check that we do not match against a static NaN (#6804)\n fn check_for_static_nan(cx: &MatchCheckCtxt, pat: &Pat) {\n     ast_util::walk_pat(pat, |p| {\n-        match p.node {\n-            ast::PatLit(ref expr) if is_expr_const_nan(cx.tcx, &**expr) => {\n-                span_warn!(cx.tcx.sess, p.span, E0003,\n-                    \"unmatchable NaN in pattern, \\\n-                        use the is_nan method in a guard instead\");\n+        if let ast::PatLit(ref expr) = p.node {\n+            match eval_const_expr_partial(cx.tcx, &**expr, None) {\n+                Ok(const_float(f)) if f.is_nan() => {\n+                    span_warn!(cx.tcx.sess, p.span, E0003,\n+                               \"unmatchable NaN in pattern, \\\n+                                use the is_nan method in a guard instead\");\n+                }\n+                Ok(_) => {}\n+\n+                Err(err) => {\n+                    let subspan = p.span.lo <= err.span.lo && err.span.hi <= p.span.hi;\n+                    cx.tcx.sess.span_err(err.span,\n+                                         &format!(\"constant evaluation error: {}\",\n+                                                  err.description().as_slice()));\n+                    if !subspan {\n+                        cx.tcx.sess.span_note(p.span,\n+                                              \"in pattern here\")\n+                    }\n+                }\n             }\n-            _ => ()\n         }\n         true\n     });"}, {"sha": "9291f175777fa79c8be766b033cd33fcaf000fae", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 214, "deletions": 94, "changes": 308, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -25,6 +25,8 @@ use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n use syntax::{ast_map, ast_util, codemap};\n \n+use std::borrow::{Cow, IntoCow};\n+use std::num::wrapping::OverflowingOps;\n use std::cmp::Ordering;\n use std::collections::hash_map::Entry::Vacant;\n use std::{i8, i16, i32, i64};\n@@ -202,61 +204,179 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<ast::Pat>\n pub fn eval_const_expr(tcx: &ty::ctxt, e: &Expr) -> const_val {\n     match eval_const_expr_partial(tcx, e, None) {\n         Ok(r) => r,\n-        Err(s) => tcx.sess.span_fatal(e.span, &s[..])\n+        Err(s) => tcx.sess.span_fatal(s.span, s.description().as_slice())\n     }\n }\n \n+\n+#[derive(Clone)]\n+pub struct ConstEvalErr {\n+    pub span: Span,\n+    pub kind: ErrKind,\n+}\n+\n+#[derive(Clone)]\n+pub enum ErrKind {\n+    CannotCast,\n+    CannotCastTo(&'static str),\n+    InvalidOpForBools(ast::BinOp_),\n+    InvalidOpForFloats(ast::BinOp_),\n+    InvalidOpForIntUint(ast::BinOp_),\n+    InvalidOpForUintInt(ast::BinOp_),\n+    NegateOnString,\n+    NegateOnBoolean,\n+    NegateOnBinary,\n+    NotOnFloat,\n+    NotOnString,\n+    NotOnBinary,\n+\n+    AddiWithOverflow(i64, i64),\n+    SubiWithOverflow(i64, i64),\n+    MuliWithOverflow(i64, i64),\n+    AdduWithOverflow(u64, u64),\n+    SubuWithOverflow(u64, u64),\n+    MuluWithOverflow(u64, u64),\n+    DivideByZero,\n+    DivideWithOverflow,\n+    ModuloByZero,\n+    ModuloWithOverflow,\n+    MissingStructField,\n+    NonConstPath,\n+    NonConstStruct,\n+    TupleIndexOutOfBounds,\n+\n+    MiscBinaryOp,\n+    MiscCatchAll,\n+}\n+\n+impl ConstEvalErr {\n+    pub fn description(&self) -> Cow<str> {\n+        use self::ErrKind::*;\n+        match self.kind {\n+            CannotCast => \"can't cast this type\".into_cow(),\n+            CannotCastTo(s) => format!(\"can't cast this type to {}\", s).into_cow(),\n+            InvalidOpForBools(_) =>  \"can't do this op on bools\".into_cow(),\n+            InvalidOpForFloats(_) => \"can't do this op on floats\".into_cow(),\n+            InvalidOpForIntUint(..) => \"can't do this op on an int and uint\".into_cow(),\n+            InvalidOpForUintInt(..) => \"can't do this op on a uint and int\".into_cow(),\n+            NegateOnString => \"negate on string\".into_cow(),\n+            NegateOnBoolean => \"negate on boolean\".into_cow(),\n+            NegateOnBinary => \"negate on binary literal\".into_cow(),\n+            NotOnFloat => \"not on float or string\".into_cow(),\n+            NotOnString => \"not on float or string\".into_cow(),\n+            NotOnBinary => \"not on binary literal\".into_cow(),\n+\n+            AddiWithOverflow(..) => \"attempted to add with overflow\".into_cow(),\n+            SubiWithOverflow(..) => \"attempted to sub with overflow\".into_cow(),\n+            MuliWithOverflow(..) => \"attempted to mul with overflow\".into_cow(),\n+            AdduWithOverflow(..) => \"attempted to add with overflow\".into_cow(),\n+            SubuWithOverflow(..) => \"attempted to sub with overflow\".into_cow(),\n+            MuluWithOverflow(..) => \"attempted to mul with overflow\".into_cow(),\n+            DivideByZero         => \"attempted to divide by zero\".into_cow(),\n+            DivideWithOverflow   => \"attempted to divide with overflow\".into_cow(),\n+            ModuloByZero         => \"attempted remainder with a divisor of zero\".into_cow(),\n+            ModuloWithOverflow   => \"attempted remainder with overflow\".into_cow(),\n+            MissingStructField  => \"nonexistent struct field\".into_cow(),\n+            NonConstPath        => \"non-constant path in constant expr\".into_cow(),\n+            NonConstStruct      => \"non-constant struct in constant expr\".into_cow(),\n+            TupleIndexOutOfBounds => \"tuple index out of bounds\".into_cow(),\n+\n+            MiscBinaryOp => \"bad operands for binary\".into_cow(),\n+            MiscCatchAll => \"unsupported constant expr\".into_cow(),\n+        }\n+    }\n+}\n+\n+macro_rules! signal {\n+    ($e:expr, $ctor:ident) => {\n+        return Err(ConstEvalErr { span: $e.span, kind: ErrKind::$ctor })\n+    };\n+\n+    ($e:expr, $ctor:ident($($arg:expr),*)) => {\n+        return Err(ConstEvalErr { span: $e.span, kind: ErrKind::$ctor($($arg),*) })\n+    }\n+}\n+\n+fn checked_add_int(e: &Expr, a: i64, b: i64) -> Result<const_val, ConstEvalErr> {\n+    let (ret, oflo) = a.overflowing_add(b);\n+    if !oflo { Ok(const_int(ret)) } else { signal!(e, AddiWithOverflow(a, b)) }\n+}\n+fn checked_sub_int(e: &Expr, a: i64, b: i64) -> Result<const_val, ConstEvalErr> {\n+    let (ret, oflo) = a.overflowing_sub(b);\n+    if !oflo { Ok(const_int(ret)) } else { signal!(e, SubiWithOverflow(a, b)) }\n+}\n+fn checked_mul_int(e: &Expr, a: i64, b: i64) -> Result<const_val, ConstEvalErr> {\n+    let (ret, oflo) = a.overflowing_mul(b);\n+    if !oflo { Ok(const_int(ret)) } else { signal!(e, MuliWithOverflow(a, b)) }\n+}\n+\n+fn checked_add_uint(e: &Expr, a: u64, b: u64) -> Result<const_val, ConstEvalErr> {\n+    let (ret, oflo) = a.overflowing_add(b);\n+    if !oflo { Ok(const_uint(ret)) } else { signal!(e, AdduWithOverflow(a, b)) }\n+}\n+fn checked_sub_uint(e: &Expr, a: u64, b: u64) -> Result<const_val, ConstEvalErr> {\n+    let (ret, oflo) = a.overflowing_sub(b);\n+    if !oflo { Ok(const_uint(ret)) } else { signal!(e, SubuWithOverflow(a, b)) }\n+}\n+fn checked_mul_uint(e: &Expr, a: u64, b: u64) -> Result<const_val, ConstEvalErr> {\n+    let (ret, oflo) = a.overflowing_mul(b);\n+    if !oflo { Ok(const_uint(ret)) } else { signal!(e, MuluWithOverflow(a, b)) }\n+}\n+\n+\n pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                      e: &Expr,\n                                      ty_hint: Option<Ty<'tcx>>)\n-                                     -> Result<const_val, String> {\n-    fn fromb(b: bool) -> Result<const_val, String> { Ok(const_int(b as i64)) }\n+                                     -> Result<const_val, ConstEvalErr> {\n+    fn fromb(b: bool) -> const_val { const_int(b as i64) }\n \n     let ety = ty_hint.or_else(|| ty::expr_ty_opt(tcx, e));\n \n-    match e.node {\n+    let result = match e.node {\n       ast::ExprUnary(ast::UnNeg, ref inner) => {\n-        match eval_const_expr_partial(tcx, &**inner, ety) {\n-          Ok(const_float(f)) => Ok(const_float(-f)),\n-          Ok(const_int(i)) => Ok(const_int(-i)),\n-          Ok(const_uint(i)) => Ok(const_uint(-i)),\n-          Ok(const_str(_)) => Err(\"negate on string\".to_string()),\n-          Ok(const_bool(_)) => Err(\"negate on boolean\".to_string()),\n-          ref err => ((*err).clone())\n+        match try!(eval_const_expr_partial(tcx, &**inner, ety)) {\n+          const_float(f) => const_float(-f),\n+          const_int(i) => const_int(-i),\n+          const_uint(i) => const_uint(-i),\n+          const_str(_) => signal!(e, NegateOnString),\n+          const_bool(_) => signal!(e, NegateOnBoolean),\n+          const_binary(_) => signal!(e, NegateOnBinary),\n         }\n       }\n       ast::ExprUnary(ast::UnNot, ref inner) => {\n-        match eval_const_expr_partial(tcx, &**inner, ety) {\n-          Ok(const_int(i)) => Ok(const_int(!i)),\n-          Ok(const_uint(i)) => Ok(const_uint(!i)),\n-          Ok(const_bool(b)) => Ok(const_bool(!b)),\n-          _ => Err(\"not on float or string\".to_string())\n+        match try!(eval_const_expr_partial(tcx, &**inner, ety)) {\n+          const_int(i) => const_int(!i),\n+          const_uint(i) => const_uint(!i),\n+          const_bool(b) => const_bool(!b),\n+          const_str(_) => signal!(e, NotOnString),\n+          const_float(_) => signal!(e, NotOnFloat),\n+          const_binary(_) => signal!(e, NotOnBinary),\n         }\n       }\n       ast::ExprBinary(op, ref a, ref b) => {\n         let b_ty = match op.node {\n             ast::BiShl | ast::BiShr => Some(tcx.types.uint),\n             _ => ety\n         };\n-        match (eval_const_expr_partial(tcx, &**a, ety),\n-               eval_const_expr_partial(tcx, &**b, b_ty)) {\n-          (Ok(const_float(a)), Ok(const_float(b))) => {\n+        match (try!(eval_const_expr_partial(tcx, &**a, ety)),\n+               try!(eval_const_expr_partial(tcx, &**b, b_ty))) {\n+          (const_float(a), const_float(b)) => {\n             match op.node {\n-              ast::BiAdd => Ok(const_float(a + b)),\n-              ast::BiSub => Ok(const_float(a - b)),\n-              ast::BiMul => Ok(const_float(a * b)),\n-              ast::BiDiv => Ok(const_float(a / b)),\n-              ast::BiRem => Ok(const_float(a % b)),\n+              ast::BiAdd => const_float(a + b),\n+              ast::BiSub => const_float(a - b),\n+              ast::BiMul => const_float(a * b),\n+              ast::BiDiv => const_float(a / b),\n+              ast::BiRem => const_float(a % b),\n               ast::BiEq => fromb(a == b),\n               ast::BiLt => fromb(a < b),\n               ast::BiLe => fromb(a <= b),\n               ast::BiNe => fromb(a != b),\n               ast::BiGe => fromb(a >= b),\n               ast::BiGt => fromb(a > b),\n-              _ => Err(\"can't do this op on floats\".to_string())\n+              _ => signal!(e, InvalidOpForFloats(op.node))\n             }\n           }\n-          (Ok(const_int(a)), Ok(const_int(b))) => {\n+          (const_int(a), const_int(b)) => {\n             let is_a_min_value = || {\n                 let int_ty = match ty::expr_ty_opt(tcx, e).map(|ty| &ty.sty) {\n                     Some(&ty::ty_int(int_ty)) => int_ty,\n@@ -276,32 +396,32 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                 }\n             };\n             match op.node {\n-              ast::BiAdd => Ok(const_int(a + b)),\n-              ast::BiSub => Ok(const_int(a - b)),\n-              ast::BiMul => Ok(const_int(a * b)),\n+              ast::BiAdd => try!(checked_add_int(e, a, b)),\n+              ast::BiSub => try!(checked_sub_int(e, a, b)),\n+              ast::BiMul => try!(checked_mul_int(e, a, b)),\n               ast::BiDiv => {\n                   if b == 0 {\n-                      Err(\"attempted to divide by zero\".to_string())\n+                      signal!(e, DivideByZero);\n                   } else if b == -1 && is_a_min_value() {\n-                      Err(\"attempted to divide with overflow\".to_string())\n+                      signal!(e, DivideWithOverflow);\n                   } else {\n-                      Ok(const_int(a / b))\n+                      const_int(a / b)\n                   }\n               }\n               ast::BiRem => {\n                   if b == 0 {\n-                      Err(\"attempted remainder with a divisor of zero\".to_string())\n+                      signal!(e, ModuloByZero)\n                   } else if b == -1 && is_a_min_value() {\n-                      Err(\"attempted remainder with overflow\".to_string())\n+                      signal!(e, ModuloWithOverflow)\n                   } else {\n-                      Ok(const_int(a % b))\n+                      const_int(a % b)\n                   }\n               }\n-              ast::BiAnd | ast::BiBitAnd => Ok(const_int(a & b)),\n-              ast::BiOr | ast::BiBitOr => Ok(const_int(a | b)),\n-              ast::BiBitXor => Ok(const_int(a ^ b)),\n-              ast::BiShl => Ok(const_int(a << b as uint)),\n-              ast::BiShr => Ok(const_int(a >> b as uint)),\n+              ast::BiAnd | ast::BiBitAnd => const_int(a & b),\n+              ast::BiOr | ast::BiBitOr => const_int(a | b),\n+              ast::BiBitXor => const_int(a ^ b),\n+              ast::BiShl => const_int(a << b as uint),\n+              ast::BiShr => const_int(a >> b as uint),\n               ast::BiEq => fromb(a == b),\n               ast::BiLt => fromb(a < b),\n               ast::BiLe => fromb(a <= b),\n@@ -310,25 +430,20 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n               ast::BiGt => fromb(a > b)\n             }\n           }\n-          (Ok(const_uint(a)), Ok(const_uint(b))) => {\n+          (const_uint(a), const_uint(b)) => {\n             match op.node {\n-              ast::BiAdd => Ok(const_uint(a + b)),\n-              ast::BiSub => Ok(const_uint(a - b)),\n-              ast::BiMul => Ok(const_uint(a * b)),\n-              ast::BiDiv if b == 0 => {\n-                  Err(\"attempted to divide by zero\".to_string())\n-              }\n-              ast::BiDiv => Ok(const_uint(a / b)),\n-              ast::BiRem if b == 0 => {\n-                  Err(\"attempted remainder with a divisor of \\\n-                       zero\".to_string())\n-              }\n-              ast::BiRem => Ok(const_uint(a % b)),\n-              ast::BiAnd | ast::BiBitAnd => Ok(const_uint(a & b)),\n-              ast::BiOr | ast::BiBitOr => Ok(const_uint(a | b)),\n-              ast::BiBitXor => Ok(const_uint(a ^ b)),\n-              ast::BiShl => Ok(const_uint(a << b as uint)),\n-              ast::BiShr => Ok(const_uint(a >> b as uint)),\n+              ast::BiAdd => try!(checked_add_uint(e, a, b)),\n+              ast::BiSub => try!(checked_sub_uint(e, a, b)),\n+              ast::BiMul => try!(checked_mul_uint(e, a, b)),\n+              ast::BiDiv if b == 0 => signal!(e, DivideByZero),\n+              ast::BiDiv => const_uint(a / b),\n+              ast::BiRem if b == 0 => signal!(e, ModuloByZero),\n+              ast::BiRem => const_uint(a % b),\n+              ast::BiAnd | ast::BiBitAnd => const_uint(a & b),\n+              ast::BiOr | ast::BiBitOr => const_uint(a | b),\n+              ast::BiBitXor => const_uint(a ^ b),\n+              ast::BiShl => const_uint(a << b as uint),\n+              ast::BiShr => const_uint(a >> b as uint),\n               ast::BiEq => fromb(a == b),\n               ast::BiLt => fromb(a < b),\n               ast::BiLe => fromb(a <= b),\n@@ -338,33 +453,34 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n             }\n           }\n           // shifts can have any integral type as their rhs\n-          (Ok(const_int(a)), Ok(const_uint(b))) => {\n+          (const_int(a), const_uint(b)) => {\n             match op.node {\n-              ast::BiShl => Ok(const_int(a << b as uint)),\n-              ast::BiShr => Ok(const_int(a >> b as uint)),\n-              _ => Err(\"can't do this op on an int and uint\".to_string())\n+              ast::BiShl => const_int(a << b as uint),\n+              ast::BiShr => const_int(a >> b as uint),\n+              _ => signal!(e, InvalidOpForIntUint(op.node)),\n             }\n           }\n-          (Ok(const_uint(a)), Ok(const_int(b))) => {\n+          (const_uint(a), const_int(b)) => {\n             match op.node {\n-              ast::BiShl => Ok(const_uint(a << b as uint)),\n-              ast::BiShr => Ok(const_uint(a >> b as uint)),\n-              _ => Err(\"can't do this op on a uint and int\".to_string())\n+              ast::BiShl => const_uint(a << b as uint),\n+              ast::BiShr => const_uint(a >> b as uint),\n+              _ => signal!(e, InvalidOpForUintInt(op.node)),\n             }\n           }\n-          (Ok(const_bool(a)), Ok(const_bool(b))) => {\n-            Ok(const_bool(match op.node {\n+          (const_bool(a), const_bool(b)) => {\n+            const_bool(match op.node {\n               ast::BiAnd => a && b,\n               ast::BiOr => a || b,\n               ast::BiBitXor => a ^ b,\n               ast::BiBitAnd => a & b,\n               ast::BiBitOr => a | b,\n               ast::BiEq => a == b,\n               ast::BiNe => a != b,\n-              _ => return Err(\"can't do this op on bools\".to_string())\n-             }))\n+              _ => signal!(e, InvalidOpForBools(op.node)),\n+             })\n           }\n-          _ => Err(\"bad operands for binary\".to_string())\n+\n+          _ => signal!(e, MiscBinaryOp),\n         }\n       }\n       ast::ExprCast(ref base, ref target_ty) => {\n@@ -379,7 +495,10 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n         // Prefer known type to noop, but always have a type hint.\n         let base_hint = ty::expr_ty_opt(tcx, &**base).unwrap_or(ety);\n         let val = try!(eval_const_expr_partial(tcx, &**base, Some(base_hint)));\n-        cast_const(val, ety)\n+        match cast_const(val, ety) {\n+            Ok(val) => val,\n+            Err(kind) => return Err(ConstEvalErr { span: e.span, kind: kind }),\n+        }\n       }\n       ast::ExprPath(..) => {\n           let opt_def = tcx.def_map.borrow().get(&e.id).map(|d| d.full_def());\n@@ -406,33 +525,33 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n           };\n           let const_expr = match const_expr {\n               Some(actual_e) => actual_e,\n-              None => return Err(\"non-constant path in constant expr\".to_string())\n+              None => signal!(e, NonConstPath)\n           };\n           let ety = ety.or_else(|| const_ty.and_then(|ty| ast_ty_to_prim_ty(tcx, ty)));\n-          eval_const_expr_partial(tcx, const_expr, ety)\n+          try!(eval_const_expr_partial(tcx, const_expr, ety))\n       }\n       ast::ExprLit(ref lit) => {\n-          Ok(lit_to_const(&**lit, ety))\n+          lit_to_const(&**lit, ety)\n       }\n-      ast::ExprParen(ref e)     => eval_const_expr_partial(tcx, &**e, ety),\n+      ast::ExprParen(ref e) => try!(eval_const_expr_partial(tcx, &**e, ety)),\n       ast::ExprBlock(ref block) => {\n         match block.expr {\n-            Some(ref expr) => eval_const_expr_partial(tcx, &**expr, ety),\n-            None => Ok(const_int(0i64))\n+            Some(ref expr) => try!(eval_const_expr_partial(tcx, &**expr, ety)),\n+            None => const_int(0i64)\n         }\n       }\n       ast::ExprTupField(ref base, index) => {\n         // Get the base tuple if it is constant\n         if let Some(&ast::ExprTup(ref fields)) = lookup_const(tcx, &**base).map(|s| &s.node) {\n             // Check that the given index is within bounds and evaluate its value\n             if fields.len() > index.node {\n-                return eval_const_expr_partial(tcx, &*fields[index.node], None)\n+                return eval_const_expr_partial(tcx, &*fields[index.node], None);\n             } else {\n-                return Err(\"tuple index out of bounds\".to_string())\n+                signal!(e, TupleIndexOutOfBounds);\n             }\n         }\n \n-        Err(\"non-constant struct in constant expr\".to_string())\n+        signal!(e, NonConstStruct);\n       }\n       ast::ExprField(ref base, field_name) => {\n         // Get the base expression if it is a struct and it is constant\n@@ -441,19 +560,21 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n             // Check that the given field exists and evaluate it\n             if let Some(f) = fields.iter().find(|f|\n                                            f.ident.node.as_str() == field_name.node.as_str()) {\n-                return eval_const_expr_partial(tcx, &*f.expr, None)\n+                return eval_const_expr_partial(tcx, &*f.expr, None);\n             } else {\n-                return Err(\"nonexistent struct field\".to_string())\n+                signal!(e, MissingStructField);\n             }\n         }\n \n-        Err(\"non-constant struct in constant expr\".to_string())\n+        signal!(e, NonConstStruct);\n       }\n-      _ => Err(\"unsupported constant expr\".to_string())\n-    }\n+      _ => signal!(e, MiscCatchAll)\n+    };\n+\n+    Ok(result)\n }\n \n-fn cast_const(val: const_val, ty: Ty) -> Result<const_val, String> {\n+fn cast_const(val: const_val, ty: Ty) -> Result<const_val, ErrKind> {\n     macro_rules! define_casts {\n         ($($ty_pat:pat => (\n             $intermediate_ty:ty,\n@@ -466,11 +587,10 @@ fn cast_const(val: const_val, ty: Ty) -> Result<const_val, String> {\n                     const_uint(u) => Ok($const_type(u as $intermediate_ty as $target_ty)),\n                     const_int(i) => Ok($const_type(i as $intermediate_ty as $target_ty)),\n                     const_float(f) => Ok($const_type(f as $intermediate_ty as $target_ty)),\n-                    _ => Err(concat!(\"can't cast this type to \",\n-                                     stringify!($const_type)).to_string())\n+                    _ => Err(ErrKind::CannotCastTo(stringify!($const_type))),\n                 }\n             },)*\n-            _ => Err(\"can't cast this type\".to_string())\n+            _ => Err(ErrKind::CannotCast),\n         })\n     }\n \n@@ -544,15 +664,15 @@ pub fn compare_lit_exprs<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                -> Option<Ordering> {\n     let a = match eval_const_expr_partial(tcx, a, ty_hint) {\n         Ok(a) => a,\n-        Err(s) => {\n-            tcx.sess.span_err(a.span, &s[..]);\n+        Err(e) => {\n+            tcx.sess.span_err(a.span, e.description().as_slice());\n             return None;\n         }\n     };\n     let b = match eval_const_expr_partial(tcx, b, ty_hint) {\n         Ok(b) => b,\n-        Err(s) => {\n-            tcx.sess.span_err(b.span, &s[..]);\n+        Err(e) => {\n+            tcx.sess.span_err(b.span, e.description().as_slice());\n             return None;\n         }\n     };"}, {"sha": "36c42b7079547c761c7e9b33cd6b15a48d590367", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -5333,6 +5333,7 @@ pub fn type_is_empty(cx: &ctxt, ty: Ty) -> bool {\n \n pub fn enum_variants<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                            -> Rc<Vec<Rc<VariantInfo<'tcx>>>> {\n+    use std::num::Int; // For checked_add\n     memoized(&cx.enum_var_cache, id, |id: ast::DefId| {\n         if ast::LOCAL_CRATE != id.krate {\n             Rc::new(csearch::get_enum_variants(cx, id))\n@@ -5349,11 +5350,7 @@ pub fn enum_variants<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                             let mut last_discriminant: Option<Disr> = None;\n                             Rc::new(enum_definition.variants.iter().map(|variant| {\n \n-                                let mut discriminant = match last_discriminant {\n-                                    Some(val) => val + 1,\n-                                    None => INITIAL_DISCRIMINANT_VALUE\n-                                };\n-\n+                                let mut discriminant = INITIAL_DISCRIMINANT_VALUE;\n                                 if let Some(ref e) = variant.node.disr_expr {\n                                     // Preserve all values, and prefer signed.\n                                     let ty = Some(cx.types.i64);\n@@ -5369,11 +5366,24 @@ pub fn enum_variants<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                                                       \"expected signed integer constant\");\n                                         }\n                                         Err(err) => {\n-                                            span_err!(cx.sess, e.span, E0305,\n-                                                      \"expected constant: {}\", err);\n+                                            span_err!(cx.sess, err.span, E0305,\n+                                                      \"constant evaluation error: {}\",\n+                                                      err.description().as_slice());\n+                                        }\n+                                    }\n+                                } else {\n+                                    if let Some(val) = last_discriminant {\n+                                        if let Some(v) = val.checked_add(1) {\n+                                            discriminant = v\n+                                        } else {\n+                                            cx.sess.span_err(\n+                                                variant.span,\n+                                                &format!(\"Discriminant overflowed!\"));\n                                         }\n+                                    } else {\n+                                        discriminant = INITIAL_DISCRIMINANT_VALUE;\n                                     }\n-                                };\n+                                }\n \n                                 last_discriminant = Some(discriminant);\n                                 Rc::new(VariantInfo::from_ast_variant(cx, &**variant,"}, {"sha": "536caece21f841f3309b76a39b5ecf2725cd5e3e", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -259,7 +259,6 @@ pub enum CrateType {\n     CrateTypeStaticlib,\n }\n \n-\n #[derive(Clone)]\n pub enum Passes {\n     SomePasses(Vec<String>),\n@@ -349,7 +348,8 @@ macro_rules! options {\n     #[allow(non_upper_case_globals, dead_code)]\n     mod $mod_desc {\n         pub const parse_bool: Option<&'static str> = None;\n-        pub const parse_opt_bool: Option<&'static str> = None;\n+        pub const parse_opt_bool: Option<&'static str> =\n+            Some(\"one of: `y`, `yes`, `on`, `n`, `no`, or `off`\");\n         pub const parse_string: Option<&'static str> = Some(\"a string\");\n         pub const parse_opt_string: Option<&'static str> = Some(\"a string\");\n         pub const parse_list: Option<&'static str> = Some(\"a space-separated list of strings\");\n@@ -380,7 +380,19 @@ macro_rules! options {\n \n         fn parse_opt_bool(slot: &mut Option<bool>, v: Option<&str>) -> bool {\n             match v {\n-                Some(..) => false,\n+                Some(s) => {\n+                    match s {\n+                        \"n\" | \"no\" | \"off\" => {\n+                            *slot = Some(false);\n+                        }\n+                        \"y\" | \"yes\" | \"on\" => {\n+                            *slot = Some(true);\n+                        }\n+                        _ => { return false; }\n+                    }\n+\n+                    true\n+                },\n                 None => { *slot = Some(true); true }\n             }\n         }\n@@ -585,6 +597,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"Adds unstable command line options to rustc interface\"),\n     print_enum_sizes: bool = (false, parse_bool,\n           \"Print the size of enums and their variants\"),\n+    force_overflow_checks: Option<bool> = (None, parse_opt_bool,\n+          \"Force overflow checks on or off\"),\n }\n \n pub fn default_lib_output() -> CrateType {"}, {"sha": "0f69aa941a31e67b51080dd3051068f5f5362aee", "filename": "src/librustc/util/nodemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibrustc%2Futil%2Fnodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibrustc%2Futil%2Fnodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fnodemap.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -57,7 +57,7 @@ impl Hasher for FnvHasher {\n         let FnvHasher(mut hash) = *self;\n         for byte in bytes {\n             hash = hash ^ (*byte as u64);\n-            hash = hash * 0x100000001b3;\n+            hash = hash.wrapping_mul(0x100000001b3);\n         }\n         *self = FnvHasher(hash);\n     }"}, {"sha": "8acb6851f111d752e4755a15afeb9267a6bff913", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -347,17 +347,19 @@ impl Engine256State {\n         // Sha-512 and Sha-256 use basically the same calculations which are implemented\n         // by these macros. Inlining the calculations seems to result in better generated code.\n         macro_rules! schedule_round { ($t:expr) => (\n-                w[$t] = sigma1(w[$t - 2]) + w[$t - 7] + sigma0(w[$t - 15]) + w[$t - 16];\n-                )\n+            w[$t] = sigma1(w[$t - 2]).wrapping_add(w[$t - 7])\n+                .wrapping_add(sigma0(w[$t - 15])).wrapping_add(w[$t - 16]);\n+            )\n         }\n \n         macro_rules! sha2_round {\n             ($A:ident, $B:ident, $C:ident, $D:ident,\n              $E:ident, $F:ident, $G:ident, $H:ident, $K:ident, $t:expr) => (\n                 {\n-                    $H += sum1($E) + ch($E, $F, $G) + $K[$t] + w[$t];\n-                    $D += $H;\n-                    $H += sum0($A) + maj($A, $B, $C);\n+                    $H = $H.wrapping_add(sum1($E)).wrapping_add(ch($E, $F, $G))\n+                        .wrapping_add($K[$t]).wrapping_add(w[$t]);\n+                    $D = $D.wrapping_add($H);\n+                    $H = $H.wrapping_add(sum0($A)).wrapping_add(maj($A, $B, $C));\n                 }\n              )\n         }\n@@ -397,14 +399,14 @@ impl Engine256State {\n             sha2_round!(b, c, d, e, f, g, h, a, K32, t + 7);\n         }\n \n-        self.h0 += a;\n-        self.h1 += b;\n-        self.h2 += c;\n-        self.h3 += d;\n-        self.h4 += e;\n-        self.h5 += f;\n-        self.h6 += g;\n-        self.h7 += h;\n+        self.h0 = self.h0.wrapping_add(a);\n+        self.h1 = self.h1.wrapping_add(b);\n+        self.h2 = self.h2.wrapping_add(c);\n+        self.h3 = self.h3.wrapping_add(d);\n+        self.h4 = self.h4.wrapping_add(e);\n+        self.h5 = self.h5.wrapping_add(f);\n+        self.h6 = self.h6.wrapping_add(g);\n+        self.h7 = self.h7.wrapping_add(h);\n     }\n }\n "}, {"sha": "61214f65c87ea2d60951f044df44de9944aa97d3", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -778,7 +778,9 @@ fn load_discr(bcx: Block, ity: IntType, ptr: ValueRef, min: Disr, max: Disr)\n     assert!(bits <= 64);\n     let  bits = bits as uint;\n     let mask = (-1u64 >> (64 - bits)) as Disr;\n-    if (max + 1) & mask == min & mask {\n+    // For a (max) discr of -1, max will be `-1 as usize`, which overflows.\n+    // However, that is fine here (it would still represent the full range),\n+    if (max.wrapping_add(1)) & mask == min & mask {\n         // i.e., if the range is everything.  The lo==hi case would be\n         // rejected by the LLVM verifier (it would mean either an\n         // empty set, which is impossible, or the entire range of the\n@@ -787,7 +789,7 @@ fn load_discr(bcx: Block, ity: IntType, ptr: ValueRef, min: Disr, max: Disr)\n     } else {\n         // llvm::ConstantRange can deal with ranges that wrap around,\n         // so an overflow on (max + 1) is fine.\n-        LoadRangeAssert(bcx, ptr, min, (max+1), /* signed: */ True)\n+        LoadRangeAssert(bcx, ptr, min, (max.wrapping_add(1)), /* signed: */ True)\n     }\n }\n "}, {"sha": "2c92f11c4e7067cefb695fdce0be16be2abe550a", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -3086,6 +3086,12 @@ pub fn trans_crate<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n     let ty::CrateAnalysis { ty_cx: tcx, export_map, reachable, name, .. } = analysis;\n     let krate = tcx.map.krate();\n \n+    let check_overflow = if let Some(v) = tcx.sess.opts.debugging_opts.force_overflow_checks {\n+        v\n+    } else {\n+        !attr::contains_name(&krate.config, \"ndebug\")\n+    };\n+\n     // Before we touch LLVM, make sure that multithreading is enabled.\n     unsafe {\n         use std::sync::{Once, ONCE_INIT};\n@@ -3113,7 +3119,8 @@ pub fn trans_crate<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n                                              export_map,\n                                              Sha256::new(),\n                                              link_meta.clone(),\n-                                             reachable);\n+                                             reachable,\n+                                             check_overflow);\n \n     {\n         let ccx = shared_ccx.get_ccx(0);"}, {"sha": "a39f5d42b555f470adbc4fcd0a872c0dac3f46ea", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -462,9 +462,9 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n           ast::ExprIndex(ref base, ref index) => {\n               let (bv, bt) = const_expr(cx, &**base, param_substs);\n-              let iv = match const_eval::eval_const_expr(cx.tcx(), &**index) {\n-                  const_eval::const_int(i) => i as u64,\n-                  const_eval::const_uint(u) => u,\n+              let iv = match const_eval::eval_const_expr_partial(cx.tcx(), &**index, None) {\n+                  Ok(const_eval::const_int(i)) => i as u64,\n+                  Ok(const_eval::const_uint(u)) => u,\n                   _ => cx.sess().span_bug(index.span,\n                                           \"index is not an integer-constant expression\")\n               };\n@@ -650,9 +650,9 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n           ast::ExprRepeat(ref elem, ref count) => {\n             let unit_ty = ty::sequence_element_type(cx.tcx(), ety);\n             let llunitty = type_of::type_of(cx, unit_ty);\n-            let n = match const_eval::eval_const_expr(cx.tcx(), &**count) {\n-                const_eval::const_int(i)  => i as uint,\n-                const_eval::const_uint(i) => i as uint,\n+            let n = match const_eval::eval_const_expr_partial(cx.tcx(), &**count, None) {\n+                Ok(const_eval::const_int(i))  => i as uint,\n+                Ok(const_eval::const_uint(i)) => i as uint,\n                 _ => cx.sess().span_bug(count.span, \"count must be integral const expression.\")\n             };\n             let unit_val = const_expr(cx, &**elem, param_substs).0;"}, {"sha": "9777398bddcc324fad4b0a840afe6970cb0e0278", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -69,6 +69,7 @@ pub struct SharedCrateContext<'tcx> {\n     symbol_hasher: RefCell<Sha256>,\n     tcx: ty::ctxt<'tcx>,\n     stats: Stats,\n+    check_overflow: bool,\n \n     available_monomorphizations: RefCell<FnvHashSet<String>>,\n     available_drop_glues: RefCell<FnvHashMap<Ty<'tcx>, String>>,\n@@ -245,7 +246,8 @@ impl<'tcx> SharedCrateContext<'tcx> {\n                export_map: ExportMap,\n                symbol_hasher: Sha256,\n                link_meta: LinkMeta,\n-               reachable: NodeSet)\n+               reachable: NodeSet,\n+               check_overflow: bool)\n                -> SharedCrateContext<'tcx> {\n         let (metadata_llcx, metadata_llmod) = unsafe {\n             create_context_and_module(&tcx.sess, \"metadata\")\n@@ -274,6 +276,7 @@ impl<'tcx> SharedCrateContext<'tcx> {\n                 llvm_insns: RefCell::new(FnvHashMap()),\n                 fn_stats: RefCell::new(Vec::new()),\n             },\n+            check_overflow: check_overflow,\n             available_monomorphizations: RefCell::new(FnvHashSet()),\n             available_drop_glues: RefCell::new(FnvHashMap()),\n         };\n@@ -743,6 +746,10 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n             &format!(\"the type `{}` is too big for the current architecture\",\n                     obj.repr(self.tcx())))\n     }\n+\n+    pub fn check_overflow(&self) -> bool {\n+        self.shared.check_overflow\n+    }\n }\n \n fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef> {"}, {"sha": "60455119d58720963a4253e1eea762161cd09b55", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 121, "deletions": 4, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -82,6 +82,7 @@ use trans::machine::{llsize_of, llsize_of_alloc};\n use trans::type_::Type;\n \n use syntax::{ast, ast_util, codemap};\n+use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n use syntax::parse::token;\n use std::iter::repeat;\n@@ -1709,8 +1710,8 @@ fn trans_eager_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     };\n     let is_float = ty::type_is_fp(intype);\n     let is_signed = ty::type_is_signed(intype);\n-\n     let rhs = base::cast_shift_expr_rhs(bcx, op, lhs, rhs);\n+    let info = expr_info(binop_expr);\n \n     let binop_debug_loc = binop_expr.debug_loc();\n \n@@ -1720,21 +1721,30 @@ fn trans_eager_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         if is_float {\n             FAdd(bcx, lhs, rhs, binop_debug_loc)\n         } else {\n-            Add(bcx, lhs, rhs, binop_debug_loc)\n+            let (newbcx, res) = with_overflow_check(\n+                bcx, OverflowOp::Add, info, lhs_t, lhs, rhs, binop_debug_loc);\n+            bcx = newbcx;\n+            res\n         }\n       }\n       ast::BiSub => {\n         if is_float {\n             FSub(bcx, lhs, rhs, binop_debug_loc)\n         } else {\n-            Sub(bcx, lhs, rhs, binop_debug_loc)\n+            let (newbcx, res) = with_overflow_check(\n+                bcx, OverflowOp::Sub, info, lhs_t, lhs, rhs, binop_debug_loc);\n+            bcx = newbcx;\n+            res\n         }\n       }\n       ast::BiMul => {\n         if is_float {\n             FMul(bcx, lhs, rhs, binop_debug_loc)\n         } else {\n-            Mul(bcx, lhs, rhs, binop_debug_loc)\n+            let (newbcx, res) = with_overflow_check(\n+                bcx, OverflowOp::Mul, info, lhs_t, lhs, rhs, binop_debug_loc);\n+            bcx = newbcx;\n+            res\n         }\n       }\n       ast::BiDiv => {\n@@ -2314,3 +2324,110 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         DatumBlock { bcx: bcx, datum: datum }\n     }\n }\n+\n+enum OverflowOp {\n+    Add,\n+    Sub,\n+    Mul,\n+}\n+\n+impl OverflowOp {\n+    fn to_intrinsic_name(&self, tcx: &ty::ctxt, ty: Ty) -> &'static str {\n+        use syntax::ast::IntTy::*;\n+        use syntax::ast::UintTy::*;\n+        use middle::ty::{ty_int, ty_uint};\n+\n+        let new_sty = match ty.sty {\n+            ty_int(TyIs(_)) => match &tcx.sess.target.target.target_pointer_width[..] {\n+                \"32\" => ty_int(TyI32),\n+                \"64\" => ty_int(TyI64),\n+                _ => panic!(\"unsupported target word size\")\n+            },\n+            ty_uint(TyUs(_)) => match &tcx.sess.target.target.target_pointer_width[..] {\n+                \"32\" => ty_uint(TyU32),\n+                \"64\" => ty_uint(TyU64),\n+                _ => panic!(\"unsupported target word size\")\n+            },\n+            ref t @ ty_uint(_) | ref t @ ty_int(_) => t.clone(),\n+            _ => panic!(\"tried to get overflow intrinsic for non-int type\")\n+        };\n+\n+        match *self {\n+            OverflowOp::Add => match new_sty {\n+                ty_int(TyI8) => \"llvm.sadd.with.overflow.i8\",\n+                ty_int(TyI16) => \"llvm.sadd.with.overflow.i16\",\n+                ty_int(TyI32) => \"llvm.sadd.with.overflow.i32\",\n+                ty_int(TyI64) => \"llvm.sadd.with.overflow.i64\",\n+\n+                ty_uint(TyU8) => \"llvm.uadd.with.overflow.i8\",\n+                ty_uint(TyU16) => \"llvm.uadd.with.overflow.i16\",\n+                ty_uint(TyU32) => \"llvm.uadd.with.overflow.i32\",\n+                ty_uint(TyU64) => \"llvm.uadd.with.overflow.i64\",\n+\n+                _ => unreachable!(),\n+            },\n+            OverflowOp::Sub => match new_sty {\n+                ty_int(TyI8) => \"llvm.ssub.with.overflow.i8\",\n+                ty_int(TyI16) => \"llvm.ssub.with.overflow.i16\",\n+                ty_int(TyI32) => \"llvm.ssub.with.overflow.i32\",\n+                ty_int(TyI64) => \"llvm.ssub.with.overflow.i64\",\n+\n+                ty_uint(TyU8) => \"llvm.usub.with.overflow.i8\",\n+                ty_uint(TyU16) => \"llvm.usub.with.overflow.i16\",\n+                ty_uint(TyU32) => \"llvm.usub.with.overflow.i32\",\n+                ty_uint(TyU64) => \"llvm.usub.with.overflow.i64\",\n+\n+                _ => unreachable!(),\n+            },\n+            OverflowOp::Mul => match new_sty {\n+                ty_int(TyI8) => \"llvm.smul.with.overflow.i8\",\n+                ty_int(TyI16) => \"llvm.smul.with.overflow.i16\",\n+                ty_int(TyI32) => \"llvm.smul.with.overflow.i32\",\n+                ty_int(TyI64) => \"llvm.smul.with.overflow.i64\",\n+\n+                ty_uint(TyU8) => \"llvm.umul.with.overflow.i8\",\n+                ty_uint(TyU16) => \"llvm.umul.with.overflow.i16\",\n+                ty_uint(TyU32) => \"llvm.umul.with.overflow.i32\",\n+                ty_uint(TyU64) => \"llvm.umul.with.overflow.i64\",\n+\n+                _ => unreachable!(),\n+            },\n+        }\n+    }\n+}\n+\n+\n+fn with_overflow_check<'a, 'b>(bcx: Block<'a, 'b>, oop: OverflowOp, info: NodeIdAndSpan,\n+                               lhs_t: Ty, lhs: ValueRef, rhs: ValueRef, binop_debug_loc: DebugLoc)\n+                               -> (Block<'a, 'b>, ValueRef) {\n+    if bcx.unreachable.get() { return (bcx, _Undef(lhs)); }\n+    if bcx.ccx().check_overflow() {\n+        let name = oop.to_intrinsic_name(bcx.tcx(), lhs_t);\n+        let llfn = bcx.ccx().get_intrinsic(&name);\n+\n+        let val = Call(bcx, llfn, &[lhs, rhs], None, binop_debug_loc);\n+        let result = ExtractValue(bcx, val, 0); // iN operation result\n+        let overflow = ExtractValue(bcx, val, 1); // i1 \"did it overflow?\"\n+\n+        let cond = ICmp(bcx, llvm::IntEQ, overflow, C_integral(Type::i1(bcx.ccx()), 1, false),\n+                        binop_debug_loc);\n+\n+        let expect = bcx.ccx().get_intrinsic(&\"llvm.expect.i1\");\n+        Call(bcx, expect, &[cond, C_integral(Type::i1(bcx.ccx()), 0, false)],\n+             None, binop_debug_loc);\n+\n+        let bcx =\n+            base::with_cond(bcx, cond, |bcx|\n+                controlflow::trans_fail(bcx, info,\n+                    InternedString::new(\"arithmetic operation overflowed\")));\n+\n+        (bcx, result)\n+    } else {\n+        let res = match oop {\n+            OverflowOp::Add => Add(bcx, lhs, rhs, binop_debug_loc),\n+            OverflowOp::Sub => Sub(bcx, lhs, rhs, binop_debug_loc),\n+            OverflowOp::Mul => Mul(bcx, lhs, rhs, binop_debug_loc),\n+        };\n+        (bcx, res)\n+    }\n+}"}, {"sha": "916492195c2583fdc6105f15167f90be33a8ac10", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -660,6 +660,11 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                     llargs[0],\n                                     llargs[1],\n                                     call_debug_location),\n+\n+        (_, \"overflowing_add\") => Add(bcx, llargs[0], llargs[1], call_debug_location),\n+        (_, \"overflowing_sub\") => Sub(bcx, llargs[0], llargs[1], call_debug_location),\n+        (_, \"overflowing_mul\") => Mul(bcx, llargs[0], llargs[1], call_debug_location),\n+\n         (_, \"return_address\") => {\n             if !fcx.caller_expects_out_pointer {\n                 tcx.sess.span_err(call_info.span,"}, {"sha": "1e7b90d5a1892707fc4c843fdacda7712d9ffb62", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -205,9 +205,9 @@ pub fn opt_ast_region_to_region<'tcx>(\n \n                                 if len == 2 && i == 0 {\n                                     m.push_str(\" or \");\n-                                } else if i == len - 2 {\n+                                } else if i + 2 == len {\n                                     m.push_str(\", or \");\n-                                } else if i != len - 1 {\n+                                } else if i + 1 != len {\n                                     m.push_str(\", \");\n                                 }\n                             }\n@@ -1233,17 +1233,18 @@ pub fn finish_resolving_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n             if segments.is_empty() {\n                 opt_self_ty.expect(\"missing T in <T>::a::b::c\")\n             } else {\n-                tcx.sess.span_bug(span,\n-                                  &format!(\"found module name used as a type: {}\",\n-                                           tcx.map.node_to_string(id.node)));\n+                span_err!(tcx.sess, span, E0247, \"found module name used as a type: {}\",\n+                          tcx.map.node_to_string(id.node));\n+                return this.tcx().types.err;\n             }\n         }\n         def::DefPrimTy(prim_ty) => {\n             prim_ty_to_ty(tcx, segments, prim_ty)\n         }\n         _ => {\n-            span_fatal!(tcx.sess, span, E0248,\n-                        \"found value name used as a type: {:?}\", *def);\n+            span_err!(tcx.sess, span, E0248,\n+                      \"found value name used as a type: {:?}\", *def);\n+            return this.tcx().types.err;\n         }\n     };\n \n@@ -1278,10 +1279,11 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n     match ast_ty_to_ty_cache.get(&ast_ty.id) {\n         Some(&ty::atttce_resolved(ty)) => return ty,\n         Some(&ty::atttce_unresolved) => {\n-            span_fatal!(tcx.sess, ast_ty.span, E0246,\n+            span_err!(tcx.sess, ast_ty.span, E0246,\n                                 \"illegal recursive type; insert an enum \\\n                                  or struct in the cycle, if this is \\\n                                  desired\");\n+            return this.tcx().types.err;\n         }\n         None => { /* go on */ }\n     }\n@@ -1388,14 +1390,22 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                             ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty),\n                                         Some(i as uint)),\n                         _ => {\n-                            span_fatal!(tcx.sess, ast_ty.span, E0249,\n-                                        \"expected constant expr for array length\");\n+                            span_err!(tcx.sess, ast_ty.span, E0249,\n+                                      \"expected constant expr for array length\");\n+                            this.tcx().types.err\n                         }\n                     }\n                 }\n-                Err(r) => {\n-                    span_fatal!(tcx.sess, ast_ty.span, E0250,\n-                                \"expected constant expr for array length: {}\", r);\n+                Err(ref r) => {\n+                    let subspan  =\n+                        ast_ty.span.lo <= r.span.lo && r.span.hi <= ast_ty.span.hi;\n+                    span_err!(tcx.sess, r.span, E0250,\n+                              \"array length constant evaluation error: {}\",\n+                              r.description().as_slice());\n+                    if !subspan {\n+                        span_note!(tcx.sess, ast_ty.span, \"for array length here\")\n+                    }\n+                    this.tcx().types.err\n                 }\n             }\n         }"}, {"sha": "a12ff04912c4905e15cae18c22968bf638744ba4", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -1363,10 +1363,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         match self.inh.locals.borrow().get(&nid) {\n             Some(&t) => t,\n             None => {\n-                self.tcx().sess.span_bug(\n+                self.tcx().sess.span_err(\n                     span,\n-                    &format!(\"no type for local variable {}\",\n-                            nid));\n+                    &format!(\"no type for local variable {}\", nid));\n+                self.tcx().types.err\n             }\n         }\n     }\n@@ -4554,6 +4554,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                           id: ast::NodeId,\n                           hint: attr::ReprAttr)\n                           -> Vec<Rc<ty::VariantInfo<'tcx>>> {\n+        use std::num::Int;\n \n         let rty = ty::node_id_to_type(ccx.tcx, id);\n         let mut variants: Vec<Rc<ty::VariantInfo>> = Vec::new();\n@@ -4565,7 +4566,13 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n             // If the discriminant value is specified explicitly in the enum check whether the\n             // initialization expression is valid, otherwise use the last value plus one.\n             let mut current_disr_val = match prev_disr_val {\n-                Some(prev_disr_val) => prev_disr_val + 1,\n+                Some(prev_disr_val) => {\n+                    if let Some(v) = prev_disr_val.checked_add(1) {\n+                        v\n+                    } else {\n+                        ty::INITIAL_DISCRIMINANT_VALUE\n+                    }\n+                }\n                 None => ty::INITIAL_DISCRIMINANT_VALUE\n             };\n \n@@ -4597,8 +4604,9 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                 \"expected signed integer constant\");\n                         }\n                         Err(ref err) => {\n-                            span_err!(ccx.tcx.sess, e.span, E0080,\n-                                \"expected constant: {}\", *err);\n+                            span_err!(ccx.tcx.sess, err.span, E0080,\n+                                      \"constant evaluation error: {}\",\n+                                      err.description().as_slice());\n                         }\n                     }\n                 },\n@@ -5491,6 +5499,9 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                 (0, vec!(tcx.types.u64, tcx.types.u64),\n                 ty::mk_tup(tcx, vec!(tcx.types.u64, tcx.types.bool))),\n \n+            \"overflowing_add\" | \"overflowing_sub\" | \"overflowing_mul\" =>\n+                (1, vec![param(ccx, 0), param(ccx, 0)], param(ccx, 0)),\n+\n             \"return_address\" => (0, vec![], ty::mk_imm_ptr(tcx, tcx.types.u8)),\n \n             \"assume\" => (0, vec![tcx.types.bool], ty::mk_nil(tcx)),"}, {"sha": "bf4d006fcfaacbb82ab09b5eb31aafc9d319212a", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -1569,8 +1569,8 @@ impl<T: Iterator<Item=char>> Parser<T> {\n                 while !self.eof() {\n                     match self.ch_or_null() {\n                         c @ '0' ... '9' => {\n-                            accum *= 10;\n-                            accum += (c as u64) - ('0' as u64);\n+                            accum = accum.wrapping_mul(10);\n+                            accum = accum.wrapping_add((c as u64) - ('0' as u64));\n \n                             // Detect overflow by comparing to the last value.\n                             if accum <= last_accum { return self.error(InvalidNumber); }"}, {"sha": "8eb29a8327a52710c6479f026e35bc4a698b516e", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -314,6 +314,13 @@ fn search_hashed<K, V, M, F>(table: M,\n     M: Deref<Target=RawTable<K, V>>,\n     F: FnMut(&K) -> bool,\n {\n+    // This is the only function where capacity can be zero. To avoid\n+    // undefined behaviour when Bucket::new gets the raw bucket in this\n+    // case, immediately return the appropriate search result.\n+    if table.capacity() == 0 {\n+        return TableRef(table);\n+    }\n+\n     let size = table.size();\n     let mut probe = Bucket::new(table, hash);\n     let ib = probe.index();"}, {"sha": "2670cd0c003b5c41bed4d7a4ab068daaf63842e8", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 34, "deletions": 24, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -20,6 +20,7 @@ use marker::{Copy, Send, Sync, Sized, self};\n use mem::{min_align_of, size_of};\n use mem;\n use num::{Int, UnsignedInt};\n+use num::wrapping::{OverflowingOps, WrappingOps};\n use ops::{Deref, DerefMut, Drop};\n use option::Option;\n use option::Option::{Some, None};\n@@ -224,6 +225,9 @@ impl<K, V, M: Deref<Target=RawTable<K, V>>> Bucket<K, V, M> {\n     }\n \n     pub fn at_index(table: M, ib_index: usize) -> Bucket<K, V, M> {\n+        // if capacity is 0, then the RawBucket will be populated with bogus pointers.\n+        // This is an uncommon case though, so avoid it in release builds.\n+        debug_assert!(table.capacity() > 0, \"Table should have capacity at this point\");\n         let ib_index = ib_index & (table.capacity() - 1);\n         Bucket {\n             raw: unsafe {\n@@ -371,7 +375,7 @@ impl<K, V, M: Deref<Target=RawTable<K, V>>> FullBucket<K, V, M> {\n         // Calculates the distance one has to travel when going from\n         // `hash mod capacity` onwards to `idx mod capacity`, wrapping around\n         // if the destination is not reached before the end of the table.\n-        (self.idx - self.hash().inspect() as usize) & (self.table.capacity() - 1)\n+        (self.idx.wrapping_sub(self.hash().inspect() as usize)) & (self.table.capacity() - 1)\n     }\n \n     #[inline]\n@@ -524,40 +528,40 @@ fn test_rounding() {\n fn calculate_offsets(hashes_size: usize,\n                      keys_size: usize, keys_align: usize,\n                      vals_align: usize)\n-                     -> (usize, usize) {\n+                     -> (usize, usize, bool) {\n     let keys_offset = round_up_to_next(hashes_size, keys_align);\n-    let end_of_keys = keys_offset + keys_size;\n+    let (end_of_keys, oflo) = keys_offset.overflowing_add(keys_size);\n \n     let vals_offset = round_up_to_next(end_of_keys, vals_align);\n \n-    (keys_offset, vals_offset)\n+    (keys_offset, vals_offset, oflo)\n }\n \n // Returns a tuple of (minimum required malloc alignment, hash_offset,\n // array_size), from the start of a mallocated array.\n fn calculate_allocation(hash_size: usize, hash_align: usize,\n                         keys_size: usize, keys_align: usize,\n                         vals_size: usize, vals_align: usize)\n-                        -> (usize, usize, usize) {\n+                        -> (usize, usize, usize, bool) {\n     let hash_offset = 0;\n-    let (_, vals_offset) = calculate_offsets(hash_size,\n-                                             keys_size, keys_align,\n-                                                        vals_align);\n-    let end_of_vals = vals_offset + vals_size;\n+    let (_, vals_offset, oflo) = calculate_offsets(hash_size,\n+                                                   keys_size, keys_align,\n+                                                              vals_align);\n+    let (end_of_vals, oflo2) = vals_offset.overflowing_add(vals_size);\n \n     let min_align = cmp::max(hash_align, cmp::max(keys_align, vals_align));\n \n-    (min_align, hash_offset, end_of_vals)\n+    (min_align, hash_offset, end_of_vals, oflo || oflo2)\n }\n \n #[test]\n fn test_offset_calculation() {\n-    assert_eq!(calculate_allocation(128, 8, 15, 1, 4,  4), (8, 0, 148));\n-    assert_eq!(calculate_allocation(3,   1, 2,  1, 1,  1), (1, 0, 6));\n-    assert_eq!(calculate_allocation(6,   2, 12, 4, 24, 8), (8, 0, 48));\n-    assert_eq!(calculate_offsets(128, 15, 1, 4), (128, 144));\n-    assert_eq!(calculate_offsets(3,   2,  1, 1), (3,   5));\n-    assert_eq!(calculate_offsets(6,   12, 4, 8), (8,   24));\n+    assert_eq!(calculate_allocation(128, 8, 15, 1, 4,  4), (8, 0, 148, false));\n+    assert_eq!(calculate_allocation(3,   1, 2,  1, 1,  1), (1, 0, 6, false));\n+    assert_eq!(calculate_allocation(6,   2, 12, 4, 24, 8), (8, 0, 48, false));\n+    assert_eq!(calculate_offsets(128, 15, 1, 4), (128, 144, false));\n+    assert_eq!(calculate_offsets(3,   2,  1, 1), (3,   5, false));\n+    assert_eq!(calculate_offsets(6,   12, 4, 8), (8,   24, false));\n }\n \n impl<K, V> RawTable<K, V> {\n@@ -587,12 +591,14 @@ impl<K, V> RawTable<K, V> {\n         // This is great in theory, but in practice getting the alignment\n         // right is a little subtle. Therefore, calculating offsets has been\n         // factored out into a different function.\n-        let (malloc_alignment, hash_offset, size) =\n+        let (malloc_alignment, hash_offset, size, oflo) =\n             calculate_allocation(\n                 hashes_size, min_align_of::<u64>(),\n                 keys_size,   min_align_of::< K >(),\n                 vals_size,   min_align_of::< V >());\n \n+        assert!(!oflo, \"capacity overflow\");\n+\n         // One check for overflow that covers calculation and rounding of size.\n         let size_of_bucket = size_of::<u64>().checked_add(size_of::<K>()).unwrap()\n                                              .checked_add(size_of::<V>()).unwrap();\n@@ -618,10 +624,11 @@ impl<K, V> RawTable<K, V> {\n         let keys_size = self.capacity * size_of::<K>();\n \n         let buffer = *self.hashes as *mut u8;\n-        let (keys_offset, vals_offset) = calculate_offsets(hashes_size,\n-                                                           keys_size, min_align_of::<K>(),\n-                                                           min_align_of::<V>());\n-\n+        let (keys_offset, vals_offset, oflo) =\n+            calculate_offsets(hashes_size,\n+                              keys_size, min_align_of::<K>(),\n+                              min_align_of::<V>());\n+        debug_assert!(!oflo, \"capacity overflow\");\n         unsafe {\n             RawBucket {\n                 hash: *self.hashes,\n@@ -995,9 +1002,12 @@ impl<K, V> Drop for RawTable<K, V> {\n         let hashes_size = self.capacity * size_of::<u64>();\n         let keys_size = self.capacity * size_of::<K>();\n         let vals_size = self.capacity * size_of::<V>();\n-        let (align, _, size) = calculate_allocation(hashes_size, min_align_of::<u64>(),\n-                                                    keys_size, min_align_of::<K>(),\n-                                                    vals_size, min_align_of::<V>());\n+        let (align, _, size, oflo) =\n+            calculate_allocation(hashes_size, min_align_of::<u64>(),\n+                                 keys_size, min_align_of::<K>(),\n+                                 vals_size, min_align_of::<V>());\n+\n+        debug_assert!(!oflo, \"should be impossible\");\n \n         unsafe {\n             deallocate(*self.hashes as *mut u8, size, align);"}, {"sha": "0bca60ed1a0ae6c86108b862072b1ec2728a0f17", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -30,6 +30,7 @@ pub use core::num::{from_uint, from_u8, from_u16, from_u32, from_u64};\n pub use core::num::{from_f32, from_f64};\n pub use core::num::{FromStrRadix, from_str_radix};\n pub use core::num::{FpCategory, ParseIntError, ParseFloatError};\n+pub use core::num::wrapping;\n \n use option::Option;\n \n@@ -1757,25 +1758,25 @@ mod tests {\n         let mut u8_val: u8 = 255_u8;\n         assert_eq!(u8_val.to_string(), \"255\");\n \n-        u8_val += 1 as u8;\n+        u8_val = u8_val.wrapping_add(1);\n         assert_eq!(u8_val.to_string(), \"0\");\n \n         let mut u16_val: u16 = 65_535_u16;\n         assert_eq!(u16_val.to_string(), \"65535\");\n \n-        u16_val += 1 as u16;\n+        u16_val = u16_val.wrapping_add(1);\n         assert_eq!(u16_val.to_string(), \"0\");\n \n         let mut u32_val: u32 = 4_294_967_295_u32;\n         assert_eq!(u32_val.to_string(), \"4294967295\");\n \n-        u32_val += 1 as u32;\n+        u32_val = u32_val.wrapping_add(1);\n         assert_eq!(u32_val.to_string(), \"0\");\n \n         let mut u64_val: u64 = 18_446_744_073_709_551_615_u64;\n         assert_eq!(u64_val.to_string(), \"18446744073709551615\");\n \n-        u64_val += 1 as u64;\n+        u64_val = u64_val.wrapping_add(1);\n         assert_eq!(u64_val.to_string(), \"0\");\n     }\n \n@@ -1789,31 +1790,31 @@ mod tests {\n         assert_eq!(from_str::<u8>(\"255\"), Some(u8_val));\n         assert_eq!(from_str::<u8>(\"256\"), None);\n \n-        u8_val += 1 as u8;\n+        u8_val = u8_val.wrapping_add(1);\n         assert_eq!(from_str::<u8>(\"0\"), Some(u8_val));\n         assert_eq!(from_str::<u8>(\"-1\"), None);\n \n         let mut u16_val: u16 = 65_535_u16;\n         assert_eq!(from_str::<u16>(\"65535\"), Some(u16_val));\n         assert_eq!(from_str::<u16>(\"65536\"), None);\n \n-        u16_val += 1 as u16;\n+        u16_val = u16_val.wrapping_add(1);\n         assert_eq!(from_str::<u16>(\"0\"), Some(u16_val));\n         assert_eq!(from_str::<u16>(\"-1\"), None);\n \n         let mut u32_val: u32 = 4_294_967_295_u32;\n         assert_eq!(from_str::<u32>(\"4294967295\"), Some(u32_val));\n         assert_eq!(from_str::<u32>(\"4294967296\"), None);\n \n-        u32_val += 1 as u32;\n+        u32_val = u32_val.wrapping_add(1);\n         assert_eq!(from_str::<u32>(\"0\"), Some(u32_val));\n         assert_eq!(from_str::<u32>(\"-1\"), None);\n \n         let mut u64_val: u64 = 18_446_744_073_709_551_615_u64;\n         assert_eq!(from_str::<u64>(\"18446744073709551615\"), Some(u64_val));\n         assert_eq!(from_str::<u64>(\"18446744073709551616\"), None);\n \n-        u64_val += 1 as u64;\n+        u64_val = u64_val.wrapping_add(1);\n         assert_eq!(from_str::<u64>(\"0\"), Some(u64_val));\n         assert_eq!(from_str::<u64>(\"-1\"), None);\n     }"}, {"sha": "b38c52dad1ad10d8ab3abada5d58c5bf9135507e", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -427,32 +427,33 @@ const DIGIT_E_RADIX: u32 = ('e' as u32) - ('a' as u32) + 11;\n \n #[cfg(test)]\n mod tests {\n+    use core::num::wrapping::WrappingOps;\n     use string::ToString;\n \n     #[test]\n     fn test_int_to_str_overflow() {\n         let mut i8_val: i8 = 127_i8;\n         assert_eq!(i8_val.to_string(), \"127\");\n \n-        i8_val += 1 as i8;\n+        i8_val = i8_val.wrapping_add(1);\n         assert_eq!(i8_val.to_string(), \"-128\");\n \n         let mut i16_val: i16 = 32_767_i16;\n         assert_eq!(i16_val.to_string(), \"32767\");\n \n-        i16_val += 1 as i16;\n+        i16_val = i16_val.wrapping_add(1);\n         assert_eq!(i16_val.to_string(), \"-32768\");\n \n         let mut i32_val: i32 = 2_147_483_647_i32;\n         assert_eq!(i32_val.to_string(), \"2147483647\");\n \n-        i32_val += 1 as i32;\n+        i32_val = i32_val.wrapping_add(1);\n         assert_eq!(i32_val.to_string(), \"-2147483648\");\n \n         let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n         assert_eq!(i64_val.to_string(), \"9223372036854775807\");\n \n-        i64_val += 1 as i64;\n+        i64_val = i64_val.wrapping_add(1);\n         assert_eq!(i64_val.to_string(), \"-9223372036854775808\");\n     }\n }"}, {"sha": "60e1354482c8f4626eb1872e3a5fb909afe65cf4", "filename": "src/libstd/prelude/v1.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -58,3 +58,5 @@\n #[doc(no_inline)] pub use old_io::{Buffer, Writer, Reader, Seek, BufferPrelude};\n // NB: remove when range syntax lands\n #[doc(no_inline)] pub use iter::range;\n+\n+#[doc(no_inline)] pub use num::wrapping::{Wrapping, WrappingOps};"}, {"sha": "a49db0128824097ba843f8632c311066e449b51c", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -386,8 +386,8 @@ impl Rng for ThreadRng {\n /// ```\n /// use std::rand;\n ///\n-/// let x = rand::random();\n-/// println!(\"{}\", 2u8 * x);\n+/// let x: u8 = rand::random();\n+/// println!(\"{}\", 2 * x as u16);\n ///\n /// let y = rand::random::<f64>();\n /// println!(\"{}\", y);"}, {"sha": "fe32a51e81c9ac323cab3852cefd967634658e79", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -27,6 +27,7 @@ use marker::Send;\n use ops::FnOnce;\n use sys;\n use thunk::Thunk;\n+use usize;\n \n // Reexport some of our utilities which are expected by other crates.\n pub use self::util::{default_sched_threads, min_stack, running_on_valgrind};\n@@ -78,7 +79,20 @@ fn lang_start(main: *const u8, argc: int, argv: *const *const u8) -> int {\n     // FIXME #11359 we just assume that this thread has a stack of a\n     // certain size, and estimate that there's at most 20KB of stack\n     // frames above our current position.\n-    let my_stack_bottom = my_stack_top + 20000 - OS_DEFAULT_STACK_ESTIMATE;\n+    const TWENTY_KB: uint = 20000;\n+\n+    // saturating-add to sidestep overflow\n+    let top_plus_spill = if usize::MAX - TWENTY_KB < my_stack_top {\n+        usize::MAX\n+    } else {\n+        my_stack_top + TWENTY_KB\n+    };\n+    // saturating-sub to sidestep underflow\n+    let my_stack_bottom = if top_plus_spill < OS_DEFAULT_STACK_ESTIMATE {\n+        0\n+    } else {\n+        top_plus_spill - OS_DEFAULT_STACK_ESTIMATE\n+    };\n \n     let failed = unsafe {\n         // First, make sure we don't trigger any __morestack overflow checks,"}, {"sha": "e7ac6e2cd011c865a44b31653108766e79da8a93", "filename": "src/libstd/sys/unix/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -176,7 +176,7 @@ pub fn write(w: &mut Writer) -> IoResult<()> {\n         let mut ip = unsafe {\n             uw::_Unwind_GetIPInfo(ctx, &mut ip_before_insn) as *mut libc::c_void\n         };\n-        if ip_before_insn == 0 {\n+        if !ip.is_null() && ip_before_insn == 0 {\n             // this is a non-signaling frame, so `ip` refers to the address\n             // after the calling instruction. account for that.\n             ip = (ip as usize - 1) as *mut _;"}, {"sha": "17687534d750ae81376d2f95effc99541e102344", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -181,7 +181,6 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n         Struct(ref fields) => {\n             let emit_struct_field = cx.ident_of(\"emit_struct_field\");\n             let mut stmts = Vec::new();\n-            let last = fields.len() - 1;\n             for (i, &FieldInfo {\n                     name,\n                     ref self_,\n@@ -204,6 +203,7 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                                                  lambda));\n \n                 // last call doesn't need a try!\n+                let last = fields.len() - 1;\n                 let call = if i != last {\n                     cx.expr_try(span, call)\n                 } else {\n@@ -240,25 +240,24 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n             let encoder = cx.expr_ident(trait_span, blkarg);\n             let emit_variant_arg = cx.ident_of(\"emit_enum_variant_arg\");\n             let mut stmts = Vec::new();\n-            let last = fields.len() - 1;\n-            for (i, &FieldInfo { ref self_, span, .. }) in fields.iter().enumerate() {\n-                let enc = cx.expr_method_call(span, self_.clone(),\n-                                              encode, vec!(blkencoder.clone()));\n-                let lambda = cx.lambda_expr_1(span, enc, blkarg);\n-                let call = cx.expr_method_call(span, blkencoder.clone(),\n-                                               emit_variant_arg,\n-                                               vec!(cx.expr_usize(span, i),\n-                                                 lambda));\n-                let call = if i != last {\n-                    cx.expr_try(span, call)\n-                } else {\n-                    cx.expr(span, ExprRet(Some(call)))\n-                };\n-                stmts.push(cx.stmt_expr(call));\n-            }\n-\n-            // enums with no fields need to return Ok()\n-            if stmts.len() == 0 {\n+            if fields.len() > 0 {\n+                let last = fields.len() - 1;\n+                for (i, &FieldInfo { ref self_, span, .. }) in fields.iter().enumerate() {\n+                    let enc = cx.expr_method_call(span, self_.clone(),\n+                                                  encode, vec!(blkencoder.clone()));\n+                    let lambda = cx.lambda_expr_1(span, enc, blkarg);\n+                    let call = cx.expr_method_call(span, blkencoder.clone(),\n+                                                   emit_variant_arg,\n+                                                   vec!(cx.expr_usize(span, i),\n+                                                        lambda));\n+                    let call = if i != last {\n+                        cx.expr_try(span, call)\n+                    } else {\n+                        cx.expr(span, ExprRet(Some(call)))\n+                    };\n+                    stmts.push(cx.stmt_expr(call));\n+                }\n+            } else {\n                 let ret_ok = cx.expr(trait_span,\n                                      ExprRet(Some(cx.expr_ok(trait_span,\n                                                              cx.expr_tuple(trait_span, vec![])))));"}, {"sha": "cd021a0d3b1cb2e2d1a93b419a71dd92049d659a", "filename": "src/test/compile-fail/const-len-underflow-separate-spans.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Ftest%2Fcompile-fail%2Fconst-len-underflow-separate-spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Ftest%2Fcompile-fail%2Fconst-len-underflow-separate-spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-len-underflow-separate-spans.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that an constant-evaluation underflow highlights the correct\n+// spot (where the underflow occurred), while also providing the\n+// overall context for what caused the evaluation.\n+\n+const ONE: usize = 1;\n+const TWO: usize = 2;\n+const LEN: usize = ONE - TWO;\n+//~^ ERROR array length constant evaluation error: attempted to sub with overflow [E0250]\n+\n+fn main() {\n+    let a: [i8; LEN] = unimplemented!();\n+    //~^ NOTE for array length here\n+}"}, {"sha": "a31da114679242b322e65817e77b05afb5ed131d", "filename": "src/test/compile-fail/const-len-underflow-subspans.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Ftest%2Fcompile-fail%2Fconst-len-underflow-subspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Ftest%2Fcompile-fail%2Fconst-len-underflow-subspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-len-underflow-subspans.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that an constant-evaluation underflow highlights the correct\n+// spot (where the underflow occurred).\n+\n+const ONE: usize = 1;\n+const TWO: usize = 2;\n+\n+fn main() {\n+    let a: [i8; ONE - TWO] = unimplemented!();\n+    //~^ ERROR array length constant evaluation error: attempted to sub with overflow [E0250]\n+}"}, {"sha": "ed1327f31185e8d565dd95307800193381e584a5", "filename": "src/test/compile-fail/eval-enum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Ftest%2Fcompile-fail%2Feval-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Ftest%2Fcompile-fail%2Feval-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Feval-enum.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n enum test {\n-    div_zero = 1/0, //~ERROR expected constant: attempted to divide by zero\n-    rem_zero = 1%0  //~ERROR expected constant: attempted remainder with a divisor of zero\n+    div_zero = 1/0, //~ERROR constant evaluation error: attempted to divide by zero\n+    rem_zero = 1%0  //~ERROR constant evaluation error: attempted remainder with a divisor of zero\n }\n \n fn main() {}"}, {"sha": "9065a5b9605b72254319ac592d776f5d6dee923e", "filename": "src/test/compile-fail/issue-18389.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Ftest%2Fcompile-fail%2Fissue-18389.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Ftest%2Fcompile-fail%2Fissue-18389.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18389.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -23,6 +23,7 @@ pub trait Public: Private<\n     <Self as Public>::P,\n //~^ ERROR illegal recursive type; insert an enum or struct in the cycle, if this is desired\n     <Self as Public>::R\n+//~^ ERROR unsupported cyclic reference between types/traits detected\n > {\n     type P;\n     type R;"}, {"sha": "5c11787d46780bf5cf2740ed22ab54b3f1b661ee", "filename": "src/test/compile-fail/issue-19244-1.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Ftest%2Fcompile-fail%2Fissue-19244-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Ftest%2Fcompile-fail%2Fissue-19244-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19244-1.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -12,5 +12,7 @@ const TUP: (usize,) = (42,);\n \n fn main() {\n     let a: [isize; TUP.1];\n-    //~^ ERROR expected constant expr for array length: tuple index out of bounds\n+    //~^ ERROR array length constant evaluation error: tuple index out of bounds\n+    //~| ERROR attempted out-of-bounds tuple index\n+    //~| ERROR attempted out-of-bounds tuple index\n }"}, {"sha": "d896f76865910820a5a4ddb401b650b90f9f6858", "filename": "src/test/compile-fail/issue-19244-2.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Ftest%2Fcompile-fail%2Fissue-19244-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Ftest%2Fcompile-fail%2Fissue-19244-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19244-2.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -13,5 +13,7 @@ const STRUCT: MyStruct = MyStruct { field: 42 };\n \n fn main() {\n     let a: [isize; STRUCT.nonexistent_field];\n-    //~^ ERROR expected constant expr for array length: nonexistent struct field\n+    //~^ ERROR array length constant evaluation error: nonexistent struct field\n+    //~| ERROR attempted access of field `nonexistent_field`\n+    //~| ERROR attempted access of field `nonexistent_field`\n }"}, {"sha": "59e910ec6afdabbca9766d8f5bdaf1368bd94d87", "filename": "src/test/compile-fail/non-constant-expr-for-fixed-len-vec.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-fixed-len-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-fixed-len-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-fixed-len-vec.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -13,6 +13,7 @@\n fn main() {\n     fn bar(n: isize) {\n         let _x: [isize; n];\n-        //~^ ERROR expected constant expr for array length: non-constant path in constant expr\n+        //~^ ERROR no type for local variable\n+        //~| ERROR array length constant evaluation error: non-constant path in constant expr\n     }\n }"}, {"sha": "34a03e5f0080dc258feb18dc780e1d21f552aefc", "filename": "src/test/run-fail/overflowing-add.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Ftest%2Frun-fail%2Foverflowing-add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Ftest%2Frun-fail%2Foverflowing-add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-add.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern:thread '<main>' panicked at 'arithmetic operation overflowed'\n+\n+// (Work around constant-evaluation)\n+fn value() -> u8 { 200 }\n+\n+fn main() {\n+    let _x = value() + value() + value();\n+}"}, {"sha": "b18d99cd232e85ed596e2e67ab827701c7b6b8b8", "filename": "src/test/run-fail/overflowing-mul.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Ftest%2Frun-fail%2Foverflowing-mul.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Ftest%2Frun-fail%2Foverflowing-mul.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-mul.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern:thread '<main>' panicked at 'arithmetic operation overflowed'\n+\n+// (Work around constant-evaluation)\n+fn value() -> u8 { 200 }\n+\n+fn main() {\n+    let x = value() * 4;\n+}"}, {"sha": "ee32291eca6b23062658ffc69fed609c08c9cddb", "filename": "src/test/run-fail/overflowing-sub.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Ftest%2Frun-fail%2Foverflowing-sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Ftest%2Frun-fail%2Foverflowing-sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-sub.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern:thread '<main>' panicked at 'arithmetic operation overflowed'\n+\n+// (Work around constant-evaluation)\n+fn value() -> u8 { 42 }\n+\n+fn main() {\n+    let _x = value() - (value() + 1);\n+}"}, {"sha": "23aadbc70537ebf508f2aea0a853f386bc8dd220", "filename": "src/test/run-pass/backtrace-debuginfo.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -68,7 +68,7 @@ fn dump_filelines(filelines: &[Pos]) {\n }\n \n #[inline(never)]\n-fn inner(counter: &mut u32, main_pos: Pos, outer_pos: Pos) {\n+fn inner(counter: &mut i32, main_pos: Pos, outer_pos: Pos) {\n     check!(counter; main_pos, outer_pos);\n     check!(counter; main_pos, outer_pos);\n     let inner_pos = pos!(); aux::callback(|aux_pos| {\n@@ -80,12 +80,12 @@ fn inner(counter: &mut u32, main_pos: Pos, outer_pos: Pos) {\n }\n \n #[inline(always)]\n-fn inner_inlined(counter: &mut u32, main_pos: Pos, outer_pos: Pos) {\n+fn inner_inlined(counter: &mut i32, main_pos: Pos, outer_pos: Pos) {\n     check!(counter; main_pos, outer_pos);\n     check!(counter; main_pos, outer_pos);\n \n     #[inline(always)]\n-    fn inner_further_inlined(counter: &mut u32, main_pos: Pos, outer_pos: Pos, inner_pos: Pos) {\n+    fn inner_further_inlined(counter: &mut i32, main_pos: Pos, outer_pos: Pos, inner_pos: Pos) {\n         check!(counter; main_pos, outer_pos, inner_pos);\n     }\n     inner_further_inlined(counter, main_pos, outer_pos, pos!());\n@@ -103,7 +103,7 @@ fn inner_inlined(counter: &mut u32, main_pos: Pos, outer_pos: Pos) {\n }\n \n #[inline(never)]\n-fn outer(mut counter: u32, main_pos: Pos) {\n+fn outer(mut counter: i32, main_pos: Pos) {\n     inner(&mut counter, main_pos, pos!());\n     inner_inlined(&mut counter, main_pos, pos!());\n }"}, {"sha": "062ee507864bbdf18eb46050b98369943ebfa295", "filename": "src/test/run-pass/generic-extern-mangle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Ftest%2Frun-pass%2Fgeneric-extern-mangle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14f0942a49b77f81d0bedb3d8b5fb615ef521bb3/src%2Ftest%2Frun-pass%2Fgeneric-extern-mangle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-extern-mangle.rs?ref=14f0942a49b77f81d0bedb3d8b5fb615ef521bb3", "patch": "@@ -10,7 +10,7 @@\n \n use std::num::Int;\n \n-extern \"C\" fn foo<T: Int>(a: T, b: T) -> T { a + b }\n+extern \"C\" fn foo<T: WrappingOps>(a: T, b: T) -> T { a.wrapping_add(b) }\n \n fn main() {\n     assert_eq!(99u8, foo(255u8, 100u8));"}]}