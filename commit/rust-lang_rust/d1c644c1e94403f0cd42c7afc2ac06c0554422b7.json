{"sha": "d1c644c1e94403f0cd42c7afc2ac06c0554422b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxYzY0NGMxZTk0NDAzZjBjZDQyYzdhZmMyYWMwNmMwNTU0NDIyYjc=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2015-12-21T23:46:56Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2016-01-06T11:57:52Z"}, "message": "Merge Call and DivergingCall diffs into CallKind\n\nThis merges two separate Call terminators and uses a separate CallKind sub-enum instead.\n\nA little bit unrelatedly, copying into destination value for a certain kind of invoke, is also\nimplemented here. See the associated comment in code for various details that arise with this\nimplementation.", "tree": {"sha": "fb7d52f1b099afce6e3bd9382da6f01697208c66", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb7d52f1b099afce6e3bd9382da6f01697208c66"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d1c644c1e94403f0cd42c7afc2ac06c0554422b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d1c644c1e94403f0cd42c7afc2ac06c0554422b7", "html_url": "https://github.com/rust-lang/rust/commit/d1c644c1e94403f0cd42c7afc2ac06c0554422b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d1c644c1e94403f0cd42c7afc2ac06c0554422b7/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50107034c08413898392ddf08d13ce1b29b1efac", "url": "https://api.github.com/repos/rust-lang/rust/commits/50107034c08413898392ddf08d13ce1b29b1efac", "html_url": "https://github.com/rust-lang/rust/commit/50107034c08413898392ddf08d13ce1b29b1efac"}], "stats": {"total": 376, "additions": 197, "deletions": 179}, "files": [{"sha": "b97d5939cf3b05857fd39c9c660cd4f6aac4fdb4", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 63, "deletions": 53, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/d1c644c1e94403f0cd42c7afc2ac06c0554422b7/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1c644c1e94403f0cd42c7afc2ac06c0554422b7/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=d1c644c1e94403f0cd42c7afc2ac06c0554422b7", "patch": "@@ -250,51 +250,58 @@ pub enum Terminator<'tcx> {\n         func: Operand<'tcx>,\n         /// Arguments the function is called with\n         args: Vec<Operand<'tcx>>,\n-        /// Location to write the return value into\n-        destination: Lvalue<'tcx>,\n-        targets: CallTargets,\n+        /// The kind of call with associated information\n+        kind: CallKind<'tcx>,\n     },\n-\n-    /// Block ends with a call of a diverging function.\n-    DivergingCall {\n-        /// The function that\u2019s being called\n-        func: Operand<'tcx>,\n-        /// Arguments the function is called with\n-        args: Vec<Operand<'tcx>>,\n-        /// Some, if there\u2019s any cleanup to be done when function unwinds\n-        cleanup: Option<BasicBlock>,\n-    }\n }\n \n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable)]\n-pub enum CallTargets {\n-    /// The only target that should be entered when function returns normally.\n-    Return(BasicBlock),\n-    /// In addition to the normal-return block, function has associated cleanup that should be done\n-    /// when function unwinds.\n-    WithCleanup((BasicBlock, BasicBlock))\n+#[derive(Clone, RustcEncodable, RustcDecodable)]\n+pub enum CallKind<'tcx> {\n+    /// Diverging function without associated cleanup\n+    Diverging,\n+    /// Diverging function with associated cleanup\n+    DivergingCleanup(BasicBlock),\n+    /// Converging function without associated cleanup\n+    Converging {\n+        /// Destination where the call result is written\n+        destination: Lvalue<'tcx>,\n+        /// Block to branch into on successful return\n+        target: BasicBlock,\n+    },\n+    ConvergingCleanup {\n+        /// Destination where the call result is written\n+        destination: Lvalue<'tcx>,\n+        /// First target is branched to on successful return.\n+        /// Second block contains the cleanups to do on unwind.\n+        targets: (BasicBlock, BasicBlock)\n+    }\n }\n \n-impl CallTargets {\n-    pub fn new(ret: BasicBlock, cleanup: Option<BasicBlock>) -> CallTargets {\n-        if let Some(c) = cleanup {\n-            CallTargets::WithCleanup((ret, c))\n-        } else {\n-            CallTargets::Return(ret)\n+impl<'tcx> CallKind<'tcx> {\n+    pub fn successors(&self) -> &[BasicBlock] {\n+        match *self {\n+            CallKind::Diverging => &[],\n+            CallKind::DivergingCleanup(ref b) |\n+            CallKind::Converging { target: ref b, .. } => slice::ref_slice(b),\n+            CallKind::ConvergingCleanup { ref targets, .. } => targets.as_slice(),\n         }\n     }\n \n-    pub fn as_slice(&self) -> &[BasicBlock] {\n+    pub fn successors_mut(&mut self) -> &mut [BasicBlock] {\n         match *self {\n-            CallTargets::Return(ref b) => slice::ref_slice(b),\n-            CallTargets::WithCleanup(ref bs) => bs.as_slice()\n+            CallKind::Diverging => &mut [],\n+            CallKind::DivergingCleanup(ref mut b) |\n+            CallKind::Converging { target: ref mut b, .. } => slice::mut_ref_slice(b),\n+            CallKind::ConvergingCleanup { ref mut targets, .. } => targets.as_mut_slice(),\n         }\n     }\n \n-    pub fn as_mut_slice(&mut self) -> &mut [BasicBlock] {\n+    pub fn destination(&self) -> Option<Lvalue<'tcx>> {\n         match *self {\n-            CallTargets::Return(ref mut b) => slice::mut_ref_slice(b),\n-            CallTargets::WithCleanup(ref mut bs) => bs.as_mut_slice()\n+            CallKind::Converging { ref destination, .. } |\n+            CallKind::ConvergingCleanup { ref destination, .. } => Some(destination.clone()),\n+            CallKind::Diverging |\n+            CallKind::DivergingCleanup(_) => None\n         }\n     }\n }\n@@ -309,12 +316,7 @@ impl<'tcx> Terminator<'tcx> {\n             SwitchInt { targets: ref b, .. } => b,\n             Resume => &[],\n             Return => &[],\n-            Call { targets: ref b, .. } => b.as_slice(),\n-            DivergingCall { cleanup: ref b, .. } => if let Some(b) = b.as_ref() {\n-                slice::ref_slice(b)\n-            } else {\n-                &mut []\n-            },\n+            Call { ref kind, .. } => kind.successors(),\n         }\n     }\n \n@@ -327,12 +329,7 @@ impl<'tcx> Terminator<'tcx> {\n             SwitchInt { targets: ref mut b, .. } => b,\n             Resume => &mut [],\n             Return => &mut [],\n-            Call { targets: ref mut b, .. } => b.as_mut_slice(),\n-            DivergingCall { cleanup: ref mut b, .. } => if let Some(b) = b.as_mut() {\n-                slice::mut_ref_slice(b)\n-            } else {\n-                &mut []\n-            },\n+            Call { ref mut kind, .. } => kind.successors_mut(),\n         }\n     }\n }\n@@ -399,13 +396,18 @@ impl<'tcx> Terminator<'tcx> {\n             SwitchInt { discr: ref lv, .. } => write!(fmt, \"switchInt({:?})\", lv),\n             Return => write!(fmt, \"return\"),\n             Resume => write!(fmt, \"resume\"),\n-            Call { .. } => {\n-                // the author didn\u2019t bother rebasing this\n-                unimplemented!()\n-            },\n-            DivergingCall { .. } => {\n-                // the author didn\u2019t bother rebasing this\n-                unimplemented!()\n+            Call { ref kind, ref func, ref args } => {\n+                if let Some(destination) = kind.destination() {\n+                    try!(write!(fmt, \"{:?} = \", destination));\n+                }\n+                try!(write!(fmt, \"{:?}(\", func));\n+                for (index, arg) in args.iter().enumerate() {\n+                    if index > 0 {\n+                        try!(write!(fmt, \", \"));\n+                    }\n+                    try!(write!(fmt, \"{:?}\", arg));\n+                }\n+                write!(fmt, \")\")\n             }\n         }\n     }\n@@ -417,8 +419,6 @@ impl<'tcx> Terminator<'tcx> {\n             Return | Resume => vec![],\n             Goto { .. } => vec![\"\".into_cow()],\n             If { .. } => vec![\"true\".into_cow(), \"false\".into_cow()],\n-            Call { .. } => vec![\"return\".into_cow(), \"unwind\".into_cow()],\n-            DivergingCall { .. } => vec![\"unwind\".into_cow()],\n             Switch { ref adt_def, .. } => {\n                 adt_def.variants\n                        .iter()\n@@ -435,6 +435,16 @@ impl<'tcx> Terminator<'tcx> {\n                       .chain(iter::once(String::from(\"otherwise\").into_cow()))\n                       .collect()\n             }\n+            Call { ref kind, .. } => match *kind {\n+                CallKind::Diverging =>\n+                    vec![],\n+                CallKind::DivergingCleanup(..) =>\n+                    vec![\"unwind\".into_cow()],\n+                CallKind::Converging { .. } =>\n+                    vec![\"return\".into_cow()],\n+                CallKind::ConvergingCleanup { .. } =>\n+                    vec![\"return\".into_cow(), \"unwind\".into_cow()],\n+            },\n         }\n     }\n }"}, {"sha": "c05e4c83cd4f0fa42959887eaea7a921afa99077", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 8, "deletions": 27, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d1c644c1e94403f0cd42c7afc2ac06c0554422b7/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1c644c1e94403f0cd42c7afc2ac06c0554422b7/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=d1c644c1e94403f0cd42c7afc2ac06c0554422b7", "patch": "@@ -136,23 +136,15 @@ pub trait Visitor<'tcx> {\n             Terminator::Return => {\n             }\n \n-            Terminator::Call { ref func, ref args, ref destination, ref targets } => {\n-                self.visit_lvalue(destination, LvalueContext::Store);\n-                self.visit_operand(func);\n-                for arg in args {\n-                    self.visit_operand(arg);\n-                }\n-                for &target in targets.as_slice() {\n-                    self.visit_branch(block, target);\n+            Terminator::Call { ref func, ref args, ref kind } => {\n+                if let Some(ref destination) = kind.destination() {\n+                    self.visit_lvalue(destination, LvalueContext::Store);\n                 }\n-            }\n-\n-            Terminator::DivergingCall { ref func, ref args, ref cleanup } => {\n                 self.visit_operand(func);\n                 for arg in args {\n                     self.visit_operand(arg);\n                 }\n-                for &target in cleanup.as_ref() {\n+                for &target in kind.successors() {\n                     self.visit_branch(block, target);\n                 }\n             }\n@@ -432,26 +424,15 @@ pub trait MutVisitor<'tcx> {\n             Terminator::Return => {\n             }\n \n-            Terminator::Call { ref mut func,\n-                               ref mut args,\n-                               ref mut destination,\n-                               ref mut targets } => {\n-                self.visit_lvalue(destination, LvalueContext::Store);\n-                self.visit_operand(func);\n-                for arg in args {\n-                    self.visit_operand(arg);\n-                }\n-                for &target in targets.as_slice() {\n-                    self.visit_branch(block, target);\n+            Terminator::Call { ref mut func, ref mut args, ref mut kind } => {\n+                if let Some(ref mut destination) = kind.destination() {\n+                    self.visit_lvalue(destination, LvalueContext::Store);\n                 }\n-            }\n-\n-            Terminator::DivergingCall { ref mut func, ref mut args, ref mut cleanup } => {\n                 self.visit_operand(func);\n                 for arg in args {\n                     self.visit_operand(arg);\n                 }\n-                for &target in cleanup.as_ref() {\n+                for &target in kind.successors() {\n                     self.visit_branch(block, target);\n                 }\n             }"}, {"sha": "44d1d52a06a3466a6dec9a0596f92899af8a9c05", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d1c644c1e94403f0cd42c7afc2ac06c0554422b7/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1c644c1e94403f0cd42c7afc2ac06c0554422b7/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=d1c644c1e94403f0cd42c7afc2ac06c0554422b7", "patch": "@@ -224,17 +224,22 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n \n                 let success = this.cfg.start_new_block();\n                 let cleanup = this.diverge_cleanup();\n-                let term = if diverges {\n-                    Terminator::DivergingCall { func: fun, args: args, cleanup: cleanup }\n-                } else {\n-                    Terminator::Call {\n-                        func: fun,\n-                        args: args,\n-                        destination: destination.clone(),\n-                        targets: CallTargets::new(success, cleanup)\n+                this.cfg.terminate(block, Terminator::Call {\n+                    func: fun,\n+                    args: args,\n+                    kind: match (cleanup, diverges) {\n+                        (None, true) => CallKind::Diverging,\n+                        (Some(c), true) => CallKind::DivergingCleanup(c),\n+                        (None, false) => CallKind::Converging {\n+                            destination: destination.clone(),\n+                            target: success\n+                        },\n+                        (Some(c), false) => CallKind::ConvergingCleanup {\n+                            destination: destination.clone(),\n+                            targets: (success, c)\n+                        }\n                     }\n-                };\n-                this.cfg.terminate(block, term);\n+                });\n                 success.unit()\n             }\n "}, {"sha": "8167ffcff1ee91009a4cf79f23f6d2f830365359", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d1c644c1e94403f0cd42c7afc2ac06c0554422b7/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1c644c1e94403f0cd42c7afc2ac06c0554422b7/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=d1c644c1e94403f0cd42c7afc2ac06c0554422b7", "patch": "@@ -302,7 +302,6 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                              index: Operand<'tcx>,\n                              len: Operand<'tcx>,\n                              span: Span) {\n-        let cleanup = self.diverge_cleanup();\n         let func = self.lang_function(lang_items::PanicBoundsCheckFnLangItem);\n         let str_ty = self.hir.tcx().mk_static_str();\n         let tup_ty = self.hir.tcx().mk_tup(vec![str_ty, self.hir.tcx().types.u32]);\n@@ -316,16 +315,19 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         // FIXME: ReStatic might be wrong here?\n         self.cfg.push_assign(block, DUMMY_SP, &tuple_ref, // tuple_ref = &tuple;\n                              Rvalue::Ref(*ref_region, BorrowKind::Unique, tuple));\n-        self.cfg.terminate(block, Terminator::DivergingCall {\n+        let cleanup = self.diverge_cleanup();\n+        self.cfg.terminate(block, Terminator::Call {\n             func: func,\n             args: vec![Operand::Consume(tuple_ref), index, len],\n-            cleanup: cleanup,\n+            kind: match cleanup {\n+                None => CallKind::Diverging,\n+                Some(c) => CallKind::DivergingCleanup(c)\n+            }\n         });\n     }\n \n     /// Create diverge cleanup and branch to it from `block`.\n     pub fn panic(&mut self, block: BasicBlock, msg: &'static str, span: Span) {\n-        let cleanup = self.diverge_cleanup();\n         let func = self.lang_function(lang_items::PanicFnLangItem);\n \n         let str_ty = self.hir.tcx().mk_static_str();\n@@ -348,11 +350,14 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         // FIXME: ReStatic might be wrong here?\n         self.cfg.push_assign(block, DUMMY_SP, &tuple_ref, // tuple_ref = &tuple;\n                              Rvalue::Ref(*ref_region, BorrowKind::Unique, tuple));\n-\n-        self.cfg.terminate(block, Terminator::DivergingCall {\n+        let cleanup = self.diverge_cleanup();\n+        self.cfg.terminate(block, Terminator::Call {\n             func: func,\n             args: vec![Operand::Consume(tuple_ref)],\n-            cleanup: cleanup,\n+            kind: match cleanup {\n+                None => CallKind::Diverging,\n+                Some(c) => CallKind::DivergingCleanup(c)\n+            }\n         });\n     }\n "}, {"sha": "20a14cf415404feab75ba62affa757bd34727e40", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1c644c1e94403f0cd42c7afc2ac06c0554422b7/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1c644c1e94403f0cd42c7afc2ac06c0554422b7/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=d1c644c1e94403f0cd42c7afc2ac06c0554422b7", "patch": "@@ -93,14 +93,10 @@ impl<'a, 'tcx> EraseRegions<'a, 'tcx> {\n                 self.erase_regions_lvalue(discr);\n                 *switch_ty = self.tcx.erase_regions(switch_ty);\n             },\n-            Terminator::Call { ref mut destination, ref mut func, ref mut args, .. } => {\n-                self.erase_regions_lvalue(destination);\n-                self.erase_regions_operand(func);\n-                for arg in &mut *args {\n-                    self.erase_regions_operand(arg);\n+            Terminator::Call { ref mut func, ref mut args, ref mut kind } => {\n+                if let Some(ref mut destination) = kind.destination() {\n+                    self.erase_regions_lvalue(destination);\n                 }\n-            }\n-            Terminator::DivergingCall { ref mut func, ref mut args, .. } => {\n                 self.erase_regions_operand(func);\n                 for arg in &mut *args {\n                     self.erase_regions_operand(arg);"}, {"sha": "969b9cd19d1a15598d5828cb9f3f06ef0488d3c3", "filename": "src/librustc_trans/trans/mir/block.rs", "status": "modified", "additions": 96, "deletions": 75, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/d1c644c1e94403f0cd42c7afc2ac06c0554422b7/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1c644c1e94403f0cd42c7afc2ac06c0554422b7/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs?ref=d1c644c1e94403f0cd42c7afc2ac06c0554422b7", "patch": "@@ -94,116 +94,137 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 base::build_return_block(bcx.fcx, bcx, return_ty, DebugLoc::None);\n             }\n \n-            mir::Terminator::Call { ref func, ref args, ref destination, ref targets } => {\n-                // The location we'll write the result of the call into.\n-                let call_dest = self.trans_lvalue(bcx, destination);\n-                let ret_ty = call_dest.ty.to_ty(bcx.tcx());\n-                // Create the callee. This will always be a fn\n-                // ptr and hence a kind of scalar.\n+            mir::Terminator::Call { ref func, ref args, ref kind } => {\n+                // Create the callee. This will always be a fn ptr and hence a kind of scalar.\n                 let callee = self.trans_operand(bcx, func);\n+                let attrs = attributes::from_fn_type(bcx.ccx(), callee.ty);\n+                let debugloc = DebugLoc::None;\n+                // The arguments we'll be passing. Plus one to account for outptr, if used.\n+                let mut llargs = Vec::with_capacity(args.len() + 1);\n \n-                // Does the fn use an outptr? If so, we have an extra first argument.\n-                let return_outptr = type_of::return_uses_outptr(bcx.ccx(), ret_ty);\n-                // The arguments we'll be passing.\n-                let mut llargs = if return_outptr {\n-                    let mut vec = Vec::with_capacity(args.len() + 1);\n-                    vec.push(call_dest.llval);\n-                    vec\n+                // Prepare the return value destination\n+                let (ret_dest_ty, must_copy_dest) = if let Some(ref d) = kind.destination() {\n+                    let dest = self.trans_lvalue(bcx, d);\n+                    let ret_ty = dest.ty.to_ty(bcx.tcx());\n+                    if type_of::return_uses_outptr(bcx.ccx(), ret_ty) {\n+                        llargs.push(dest.llval);\n+                        (Some((dest, ret_ty)), false)\n+                    } else {\n+                        (Some((dest, ret_ty)), !common::type_is_zero_size(bcx.ccx(), ret_ty))\n+                    }\n                 } else {\n-                    Vec::with_capacity(args.len())\n+                    (None, false)\n                 };\n \n                 // Process the rest of the args.\n                 for arg in args {\n-                    let arg_op = self.trans_operand(bcx, arg);\n-                    match arg_op.val {\n+                    match self.trans_operand(bcx, arg).val {\n                         Ref(llval) | Immediate(llval) => llargs.push(llval),\n-                        FatPtr(base, extra) => {\n-                            // The two words in a fat ptr are passed separately\n-                            llargs.push(base);\n-                            llargs.push(extra);\n+                        FatPtr(b, e) => {\n+                            llargs.push(b);\n+                            llargs.push(e);\n                         }\n                     }\n                 }\n \n-                let debugloc = DebugLoc::None;\n-                let attrs = attributes::from_fn_type(bcx.ccx(), callee.ty);\n-                match (*targets, base::avoid_invoke(bcx)) {\n-                    (mir::CallTargets::WithCleanup((ret, cleanup)), false) => {\n+                // Many different ways to call a function handled here\n+                match (base::avoid_invoke(bcx), kind) {\n+                    // The two cases below are the only ones to use LLVM\u2019s `invoke`.\n+                    (false, &mir::CallKind::DivergingCleanup(cleanup)) => {\n                         let cleanup = self.bcx(cleanup);\n                         let landingpad = self.make_landing_pad(cleanup);\n                         build::Invoke(bcx,\n                                       callee.immediate(),\n                                       &llargs[..],\n-                                      self.llblock(ret),\n+                                      self.unreachable_block().llbb,\n                                       landingpad.llbb,\n                                       Some(attrs),\n                                       debugloc);\n-                        if !return_outptr && !common::type_is_zero_size(bcx.ccx(), ret_ty) {\n-                            // FIXME: What do we do here?\n-                            unimplemented!()\n+                    },\n+                    (false, &mir::CallKind::ConvergingCleanup { ref targets, .. }) => {\n+                        let cleanup = self.bcx(targets.1);\n+                        let landingpad = self.make_landing_pad(cleanup);\n+                        let (target, postinvoke) = if must_copy_dest {\n+                            (bcx.fcx.new_block(false, \"\", None), Some(self.bcx(targets.0)))\n+                        } else {\n+                            (self.bcx(targets.0), None)\n+                        };\n+                        let invokeret = build::Invoke(bcx,\n+                                                      callee.immediate(),\n+                                                      &llargs[..],\n+                                                      target.llbb,\n+                                                      landingpad.llbb,\n+                                                      Some(attrs),\n+                                                      debugloc);\n+                        if let Some(postinvoketarget) = postinvoke {\n+                            // We translate the copy into a temoprary block. The temporary block is\n+                            // necessary because the current block has already been terminated (by\n+                            // `invoke`) and we cannot really translate into the target block\n+                            // because:\n+                            //  * The target block may have more than a single precedesor;\n+                            //  * Some LLVM insns cannot have a preceeding store insn (phi,\n+                            //    cleanuppad), and adding/prepending the store now may render\n+                            //    those other instructions invalid.\n+                            //\n+                            // NB: This approach still may break some LLVM code. For example if the\n+                            // target block starts with a `phi` (which may only match on immediate\n+                            // precedesors), it cannot know about this temporary block thus\n+                            // resulting in an invalid code:\n+                            //\n+                            // this:\n+                            //     \u2026\n+                            //     %0 = \u2026\n+                            //     %1 = invoke to label %temp \u2026\n+                            // temp:\n+                            //     store ty %1, ty* %dest\n+                            //     br label %actualtargetblock\n+                            // actualtargetblock:            ; preds: %temp, \u2026\n+                            //     phi \u2026 [%this, \u2026], [%0, \u2026] ; ERROR: phi requires to match only on\n+                            //                               ; immediate precedesors\n+                            let (ret_dest, ret_ty) = ret_dest_ty\n+                                .expect(\"return destination and type not set\");\n+                            base::store_ty(target, invokeret, ret_dest.llval, ret_ty);\n+                            build::Br(target, postinvoketarget.llbb, debugloc);\n                         }\n                     },\n-                    (t, _) => {\n-                        let ret = match t {\n-                            mir::CallTargets::Return(ret) => ret,\n-                            mir::CallTargets::WithCleanup((ret, _)) => {\n+                    // Everything else uses the regular `Call`, but we have to be careful to\n+                    // generate landing pads for later, even if we do not use it.\n+                    // FIXME: maybe just change Resume to not panic in that case?\n+                    (_, k@&mir::CallKind::DivergingCleanup(_)) |\n+                    (_, k@&mir::CallKind::Diverging) => {\n+                        if let mir::CallKind::DivergingCleanup(_) = *k {\n+                            // make a landing pad regardless, so it sets the personality slot.\n+                            let block = self.unreachable_block();\n+                            self.make_landing_pad(block);\n+                        }\n+                        build::Call(bcx, callee.immediate(), &llargs[..], Some(attrs), debugloc);\n+                        build::Unreachable(bcx);\n+                    }\n+                    (_, k@&mir::CallKind::ConvergingCleanup { .. }) |\n+                    (_, k@&mir::CallKind::Converging { .. }) => {\n+                        let ret = match *k {\n+                            mir::CallKind::Converging { target, .. } => target,\n+                            mir::CallKind::ConvergingCleanup { targets, .. } => {\n                                 // make a landing pad regardless (so it sets the personality slot.\n                                 let block = self.unreachable_block();\n                                 self.make_landing_pad(block);\n-                                ret\n-                            }\n+                                targets.0\n+                            },\n+                            _ => unreachable!()\n                         };\n                         let llret = build::Call(bcx,\n                                                 callee.immediate(),\n                                                 &llargs[..],\n                                                 Some(attrs),\n                                                 debugloc);\n-                        if !return_outptr && !common::type_is_zero_size(bcx.ccx(), ret_ty) {\n-                            base::store_ty(bcx, llret, call_dest.llval, ret_ty);\n+                        if must_copy_dest {\n+                            let (ret_dest, ret_ty) = ret_dest_ty\n+                                .expect(\"return destination and type not set\");\n+                            base::store_ty(bcx, llret, ret_dest.llval, ret_ty);\n                         }\n                         build::Br(bcx, self.llblock(ret), debugloc)\n                     }\n                 }\n-            },\n-\n-            mir::Terminator::DivergingCall { ref func, ref args, ref cleanup } => {\n-                let callee = self.trans_operand(bcx, func);\n-                let mut llargs = Vec::with_capacity(args.len());\n-                for arg in args {\n-                    match self.trans_operand(bcx, arg).val {\n-                        Ref(llval) | Immediate(llval) => llargs.push(llval),\n-                        FatPtr(b, e) => {\n-                            llargs.push(b);\n-                            llargs.push(e);\n-                        }\n-                    }\n-                }\n-                let debugloc = DebugLoc::None;\n-                let attrs = attributes::from_fn_type(bcx.ccx(), callee.ty);\n-                match (*cleanup, base::avoid_invoke(bcx)) {\n-                    (Some(cleanup), false) => {\n-                        let cleanup = self.bcx(cleanup);\n-                        let landingpad = self.make_landing_pad(cleanup);\n-                        let unreachable = self.unreachable_block();\n-                        build::Invoke(bcx,\n-                                      callee.immediate(),\n-                                      &llargs[..],\n-                                      unreachable.llbb,\n-                                      landingpad.llbb,\n-                                      Some(attrs),\n-                                      debugloc);\n-                    }\n-                    (t, _) => {\n-                        if t.is_some() {\n-                            // make a landing pad regardless, so it sets the personality slot.\n-                            let block = self.unreachable_block();\n-                            self.make_landing_pad(block);\n-                        }\n-                        build::Call(bcx, callee.immediate(), &llargs[..], Some(attrs), debugloc);\n-                        build::Unreachable(bcx);\n-                    }\n-                }\n             }\n         }\n     }"}]}