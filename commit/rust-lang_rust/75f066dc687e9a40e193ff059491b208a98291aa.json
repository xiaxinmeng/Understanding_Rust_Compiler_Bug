{"sha": "75f066dc687e9a40e193ff059491b208a98291aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1ZjA2NmRjNjg3ZTlhNDBlMTkzZmYwNTk0OTFiMjA4YTk4MjkxYWE=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-04-07T20:26:09Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-05-04T16:52:40Z"}, "message": "Handle binop on unbound type param\n\nWhen encountering a binary operation involving a type parameter that has\nno bindings, suggest adding the appropriate bound.", "tree": {"sha": "8acaee23882eb633da58315a281a06bf8834e87b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8acaee23882eb633da58315a281a06bf8834e87b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75f066dc687e9a40e193ff059491b208a98291aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75f066dc687e9a40e193ff059491b208a98291aa", "html_url": "https://github.com/rust-lang/rust/commit/75f066dc687e9a40e193ff059491b208a98291aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75f066dc687e9a40e193ff059491b208a98291aa/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6318d24ad8440fa30428b405be1174478e9536e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/6318d24ad8440fa30428b405be1174478e9536e3", "html_url": "https://github.com/rust-lang/rust/commit/6318d24ad8440fa30428b405be1174478e9536e3"}], "stats": {"total": 126, "additions": 110, "deletions": 16}, "files": [{"sha": "941430afaba86a954e76334813bc78dee2ae1ab2", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/75f066dc687e9a40e193ff059491b208a98291aa/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f066dc687e9a40e193ff059491b208a98291aa/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=75f066dc687e9a40e193ff059491b208a98291aa", "patch": "@@ -2626,8 +2626,38 @@ impl Node<'_> {\n         match self {\n             Node::TraitItem(TraitItem { generics, .. })\n             | Node::ImplItem(ImplItem { generics, .. })\n+            | Node::Item(Item { kind: ItemKind::Trait(_, _, generics, ..), .. })\n+            | Node::Item(Item { kind: ItemKind::Impl { generics, .. }, .. })\n             | Node::Item(Item { kind: ItemKind::Fn(_, generics, _), .. }) => Some(generics),\n             _ => None,\n         }\n     }\n+\n+    pub fn hir_id(&self) -> Option<HirId> {\n+        match self {\n+            Node::Item(Item { hir_id, .. })\n+            | Node::ForeignItem(ForeignItem { hir_id, .. })\n+            | Node::TraitItem(TraitItem { hir_id, .. })\n+            | Node::ImplItem(ImplItem { hir_id, .. })\n+            | Node::Field(StructField { hir_id, .. })\n+            | Node::AnonConst(AnonConst { hir_id, .. })\n+            | Node::Expr(Expr { hir_id, .. })\n+            | Node::Stmt(Stmt { hir_id, .. })\n+            | Node::Ty(Ty { hir_id, .. })\n+            | Node::Binding(Pat { hir_id, .. })\n+            | Node::Pat(Pat { hir_id, .. })\n+            | Node::Arm(Arm { hir_id, .. })\n+            | Node::Block(Block { hir_id, .. })\n+            | Node::Local(Local { hir_id, .. })\n+            | Node::MacroDef(MacroDef { hir_id, .. })\n+            | Node::Lifetime(Lifetime { hir_id, .. })\n+            | Node::Param(Param { hir_id, .. })\n+            | Node::GenericParam(GenericParam { hir_id, .. }) => Some(*hir_id),\n+            Node::TraitRef(TraitRef { hir_ref_id, .. }) => Some(*hir_ref_id),\n+            Node::PathSegment(PathSegment { hir_id, .. }) => *hir_id,\n+            Node::Variant(Variant { id, .. }) => Some(*id),\n+            Node::Ctor(variant) => variant.ctor_hir_id(),\n+            Node::Crate(_) | Node::Visibility(_) => None,\n+        }\n+    }\n }"}, {"sha": "4cc68e7e54deac8511ad2bd1c65505e7ce4decef", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 68, "deletions": 13, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/75f066dc687e9a40e193ff059491b208a98291aa/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75f066dc687e9a40e193ff059491b208a98291aa/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=75f066dc687e9a40e193ff059491b208a98291aa", "patch": "@@ -13,6 +13,7 @@ use rustc_middle::ty::TyKind::{Adt, Array, Char, FnDef, Never, Ref, Str, Tuple,\n use rustc_middle::ty::{self, Ty, TypeFoldable};\n use rustc_span::Span;\n use rustc_trait_selection::infer::InferCtxtExt;\n+use rustc_trait_selection::traits::error_reporting::suggest_constraining_type_param;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Checks a `a <op>= b`\n@@ -253,6 +254,50 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // error types are considered \"builtin\"\n                 if !lhs_ty.references_error() {\n                     let source_map = self.tcx.sess.source_map();\n+\n+                    let suggest_constraining_param =\n+                        |mut err: &mut DiagnosticBuilder<'_>,\n+                         missing_trait: &str,\n+                         p: ty::ParamTy,\n+                         set_output: bool| {\n+                            let hir = self.tcx.hir();\n+                            let msg =\n+                                &format!(\"`{}` might need a bound for `{}`\", lhs_ty, missing_trait);\n+                            if let Some(def_id) = hir\n+                                .find(hir.get_parent_item(expr.hir_id))\n+                                .and_then(|node| node.hir_id())\n+                                .and_then(|hir_id| hir.opt_local_def_id(hir_id))\n+                            {\n+                                let generics = self.tcx.generics_of(def_id);\n+                                let param_def_id = generics.type_param(&p, self.tcx).def_id;\n+                                if let Some(generics) = hir\n+                                    .as_local_hir_id(param_def_id)\n+                                    .and_then(|id| hir.find(hir.get_parent_item(id)))\n+                                    .as_ref()\n+                                    .and_then(|node| node.generics())\n+                                {\n+                                    let output = if set_output {\n+                                        format!(\"<Output = {}>\", rhs_ty)\n+                                    } else {\n+                                        String::new()\n+                                    };\n+                                    suggest_constraining_type_param(\n+                                        self.tcx,\n+                                        generics,\n+                                        &mut err,\n+                                        &format!(\"{}\", lhs_ty),\n+                                        &format!(\"{}{}\", missing_trait, output),\n+                                        None,\n+                                    );\n+                                } else {\n+                                    let span = self.tcx.def_span(param_def_id);\n+                                    err.span_label(span, msg);\n+                                }\n+                            } else {\n+                                err.note(&msg);\n+                            }\n+                        };\n+\n                     match is_assign {\n                         IsAssign::Yes => {\n                             let mut err = struct_span_err!(\n@@ -317,59 +362,65 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     // This has nothing here because it means we did string\n                                     // concatenation (e.g., \"Hello \" += \"World!\"). This means\n                                     // we don't want the note in the else clause to be emitted\n-                                } else if let ty::Param(_) = lhs_ty.kind {\n-                                    // FIXME: point to span of param\n-                                    err.note(&format!(\n-                                        \"`{}` might need a bound for `{}`\",\n-                                        lhs_ty, missing_trait\n-                                    ));\n+                                } else if let ty::Param(p) = lhs_ty.kind {\n+                                    suggest_constraining_param(&mut err, missing_trait, p, false);\n                                 } else if !suggested_deref {\n                                     suggest_impl_missing(&mut err, lhs_ty, &missing_trait);\n                                 }\n                             }\n                             err.emit();\n                         }\n                         IsAssign::No => {\n-                            let (message, missing_trait) = match op.node {\n+                            let (message, missing_trait, use_output) = match op.node {\n                                 hir::BinOpKind::Add => (\n                                     format!(\"cannot add `{}` to `{}`\", rhs_ty, lhs_ty),\n                                     Some(\"std::ops::Add\"),\n+                                    true,\n                                 ),\n                                 hir::BinOpKind::Sub => (\n                                     format!(\"cannot subtract `{}` from `{}`\", rhs_ty, lhs_ty),\n                                     Some(\"std::ops::Sub\"),\n+                                    true,\n                                 ),\n                                 hir::BinOpKind::Mul => (\n                                     format!(\"cannot multiply `{}` to `{}`\", rhs_ty, lhs_ty),\n                                     Some(\"std::ops::Mul\"),\n+                                    true,\n                                 ),\n                                 hir::BinOpKind::Div => (\n                                     format!(\"cannot divide `{}` by `{}`\", lhs_ty, rhs_ty),\n                                     Some(\"std::ops::Div\"),\n+                                    true,\n                                 ),\n                                 hir::BinOpKind::Rem => (\n                                     format!(\"cannot mod `{}` by `{}`\", lhs_ty, rhs_ty),\n                                     Some(\"std::ops::Rem\"),\n+                                    true,\n                                 ),\n                                 hir::BinOpKind::BitAnd => (\n                                     format!(\"no implementation for `{} & {}`\", lhs_ty, rhs_ty),\n                                     Some(\"std::ops::BitAnd\"),\n+                                    true,\n                                 ),\n                                 hir::BinOpKind::BitXor => (\n                                     format!(\"no implementation for `{} ^ {}`\", lhs_ty, rhs_ty),\n                                     Some(\"std::ops::BitXor\"),\n+                                    true,\n                                 ),\n                                 hir::BinOpKind::BitOr => (\n                                     format!(\"no implementation for `{} | {}`\", lhs_ty, rhs_ty),\n                                     Some(\"std::ops::BitOr\"),\n+                                    true,\n                                 ),\n                                 hir::BinOpKind::Shl => (\n                                     format!(\"no implementation for `{} << {}`\", lhs_ty, rhs_ty),\n                                     Some(\"std::ops::Shl\"),\n+                                    true,\n                                 ),\n                                 hir::BinOpKind::Shr => (\n                                     format!(\"no implementation for `{} >> {}`\", lhs_ty, rhs_ty),\n                                     Some(\"std::ops::Shr\"),\n+                                    true,\n                                 ),\n                                 hir::BinOpKind::Eq | hir::BinOpKind::Ne => (\n                                     format!(\n@@ -378,6 +429,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                         lhs_ty\n                                     ),\n                                     Some(\"std::cmp::PartialEq\"),\n+                                    false,\n                                 ),\n                                 hir::BinOpKind::Lt\n                                 | hir::BinOpKind::Le\n@@ -389,6 +441,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                         lhs_ty\n                                     ),\n                                     Some(\"std::cmp::PartialOrd\"),\n+                                    false,\n                                 ),\n                                 _ => (\n                                     format!(\n@@ -397,6 +450,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                         lhs_ty\n                                     ),\n                                     None,\n+                                    false,\n                                 ),\n                             };\n                             let mut err = struct_span_err!(\n@@ -459,12 +513,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     // This has nothing here because it means we did string\n                                     // concatenation (e.g., \"Hello \" + \"World!\"). This means\n                                     // we don't want the note in the else clause to be emitted\n-                                } else if let ty::Param(_) = lhs_ty.kind {\n-                                    // FIXME: point to span of param\n-                                    err.note(&format!(\n-                                        \"`{}` might need a bound for `{}`\",\n-                                        lhs_ty, missing_trait\n-                                    ));\n+                                } else if let ty::Param(p) = lhs_ty.kind {\n+                                    suggest_constraining_param(\n+                                        &mut err,\n+                                        missing_trait,\n+                                        p,\n+                                        use_output,\n+                                    );\n                                 } else if !suggested_deref && !involves_fn {\n                                     suggest_impl_missing(&mut err, lhs_ty, &missing_trait);\n                                 }"}, {"sha": "a428ff7e91faddb04e0a80a4136be4bcf0dfff91", "filename": "src/test/ui/issues/issue-6738.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/75f066dc687e9a40e193ff059491b208a98291aa/src%2Ftest%2Fui%2Fissues%2Fissue-6738.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75f066dc687e9a40e193ff059491b208a98291aa/src%2Ftest%2Fui%2Fissues%2Fissue-6738.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-6738.stderr?ref=75f066dc687e9a40e193ff059491b208a98291aa", "patch": "@@ -6,7 +6,10 @@ LL |         self.x += v.x;\n    |         |\n    |         cannot use `+=` on type `T`\n    |\n-   = note: `T` might need a bound for `std::ops::AddAssign`\n+help: consider restricting type parameter `T`\n+   |\n+LL | impl<T: std::ops::AddAssign> Foo<T> {\n+   |       ^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "30df1261cefa1f56e9f23a3245f57fa400b12627", "filename": "src/test/ui/type/type-check/missing_trait_impl.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/75f066dc687e9a40e193ff059491b208a98291aa/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fmissing_trait_impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75f066dc687e9a40e193ff059491b208a98291aa/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fmissing_trait_impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fmissing_trait_impl.stderr?ref=75f066dc687e9a40e193ff059491b208a98291aa", "patch": "@@ -6,7 +6,10 @@ LL |     let z = x + y;\n    |             |\n    |             T\n    |\n-   = note: `T` might need a bound for `std::ops::Add`\n+help: consider restricting type parameter `T`\n+   |\n+LL | fn foo<T: std::ops::Add<Output = T>>(x: T, y: T) {\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0368]: binary assignment operation `+=` cannot be applied to type `T`\n   --> $DIR/missing_trait_impl.rs:9:5\n@@ -16,7 +19,10 @@ LL |     x += x;\n    |     |\n    |     cannot use `+=` on type `T`\n    |\n-   = note: `T` might need a bound for `std::ops::AddAssign`\n+help: consider restricting type parameter `T`\n+   |\n+LL | fn bar<T: std::ops::AddAssign>(x: T) {\n+   |         ^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}]}