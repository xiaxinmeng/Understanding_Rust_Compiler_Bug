{"sha": "fa94fdad3e880d2d6cbd82c12bd12caefbeb81a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhOTRmZGFkM2U4ODBkMmQ2Y2JkODJjMTJiZDEyY2FlZmJlYjgxYTg=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-10-17T20:39:27Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-11-09T04:40:39Z"}, "message": "Runtime removal: fully remove rtio\n\nThis patch cleans up the remnants of the runtime IO interface.\n\nBecause this eliminates APIs in `libnative` and `librustrt`, it is a:\n\n[breaking-change]\n\nThis functionality is likely to be available publicly, in some form,\nfrom `std` in the future.", "tree": {"sha": "0106666f15341d9d050e99ca73acaf3a2d22d7a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0106666f15341d9d050e99ca73acaf3a2d22d7a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa94fdad3e880d2d6cbd82c12bd12caefbeb81a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa94fdad3e880d2d6cbd82c12bd12caefbeb81a8", "html_url": "https://github.com/rust-lang/rust/commit/fa94fdad3e880d2d6cbd82c12bd12caefbeb81a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa94fdad3e880d2d6cbd82c12bd12caefbeb81a8/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "431dcdc840a27f7c7418b7dff73a329eada8a407", "url": "https://api.github.com/repos/rust-lang/rust/commits/431dcdc840a27f7c7418b7dff73a329eada8a407", "html_url": "https://github.com/rust-lang/rust/commit/431dcdc840a27f7c7418b7dff73a329eada8a407"}], "stats": {"total": 287, "additions": 11, "deletions": 276}, "files": [{"sha": "e2b8eb54ac3aefa15655afca4a259497ff610312", "filename": "src/libgreen/basic.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa94fdad3e880d2d6cbd82c12bd12caefbeb81a8/src%2Flibgreen%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa94fdad3e880d2d6cbd82c12bd12caefbeb81a8/src%2Flibgreen%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fbasic.rs?ref=fa94fdad3e880d2d6cbd82c12bd12caefbeb81a8", "patch": "@@ -18,7 +18,7 @@\n use alloc::arc::Arc;\n use std::sync::atomic;\n use std::mem;\n-use std::rt::rtio::{EventLoop, IoFactory, RemoteCallback};\n+use std::rt::rtio::{EventLoop, RemoteCallback};\n use std::rt::rtio::{PausableIdleCallback, Callback};\n use std::rt::exclusive::Exclusive;\n \n@@ -150,8 +150,6 @@ impl EventLoop for BasicLoop {\n             Box<RemoteCallback + Send>\n     }\n \n-    fn io<'a>(&'a mut self) -> Option<&'a mut IoFactory> { None }\n-\n     fn has_active_io(&self) -> bool { false }\n }\n "}, {"sha": "e26a099c0282561f0a19628f1f0df3cbbdf504f3", "filename": "src/libgreen/simple.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa94fdad3e880d2d6cbd82c12bd12caefbeb81a8/src%2Flibgreen%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa94fdad3e880d2d6cbd82c12bd12caefbeb81a8/src%2Flibgreen%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsimple.rs?ref=fa94fdad3e880d2d6cbd82c12bd12caefbeb81a8", "patch": "@@ -16,7 +16,6 @@ use std::mem;\n use std::rt::Runtime;\n use std::rt::local::Local;\n use std::rt::mutex::NativeMutex;\n-use std::rt::rtio;\n use std::rt::task::{Task, BlockedTask, TaskOpts};\n \n struct SimpleTask {\n@@ -79,9 +78,10 @@ impl Runtime for SimpleTask {\n                      _f: proc():Send) {\n         panic!()\n     }\n-    fn local_io<'a>(&'a mut self) -> Option<rtio::LocalIo<'a>> { None }\n+\n     fn stack_bounds(&self) -> (uint, uint) { panic!() }\n     fn stack_guard(&self) -> Option<uint> { panic!() }\n+\n     fn can_block(&self) -> bool { true }\n     fn wrap(self: Box<SimpleTask>) -> Box<Any+'static> { panic!() }\n }"}, {"sha": "428b64144128b0ccad1c654fe8b27b157e4a8b21", "filename": "src/libgreen/task.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fa94fdad3e880d2d6cbd82c12bd12caefbeb81a8/src%2Flibgreen%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa94fdad3e880d2d6cbd82c12bd12caefbeb81a8/src%2Flibgreen%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Ftask.rs?ref=fa94fdad3e880d2d6cbd82c12bd12caefbeb81a8", "patch": "@@ -24,7 +24,6 @@ use std::raw;\n use std::rt::Runtime;\n use std::rt::local::Local;\n use std::rt::mutex::NativeMutex;\n-use std::rt::rtio;\n use std::rt::stack;\n use std::rt::task::{Task, BlockedTask, TaskOpts};\n use std::rt;\n@@ -468,14 +467,6 @@ impl Runtime for GreenTask {\n         sched.run_task(me, sibling)\n     }\n \n-    // Local I/O is provided by the scheduler's event loop\n-    fn local_io<'a>(&'a mut self) -> Option<rtio::LocalIo<'a>> {\n-        match self.sched.as_mut().unwrap().event_loop.io() {\n-            Some(io) => Some(rtio::LocalIo::new(io)),\n-            None => None,\n-        }\n-    }\n-\n     fn stack_bounds(&self) -> (uint, uint) {\n         let c = self.coroutine.as_ref()\n             .expect(\"GreenTask.stack_bounds called without a coroutine\");"}, {"sha": "8c7751588cef36c4b74e914ff6e3208f342e2985", "filename": "src/libnative/io/mod.rs", "status": "removed", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/431dcdc840a27f7c7418b7dff73a329eada8a407/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/431dcdc840a27f7c7418b7dff73a329eada8a407/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=431dcdc840a27f7c7418b7dff73a329eada8a407", "patch": "@@ -1,102 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Native thread-blocking I/O implementation\n-//!\n-//! This module contains the implementation of native thread-blocking\n-//! implementations of I/O on all platforms. This module is not intended to be\n-//! used directly, but rather the rust runtime will fall back to using it if\n-//! necessary.\n-//!\n-//! Rust code normally runs inside of green tasks with a local scheduler using\n-//! asynchronous I/O to cooperate among tasks. This model is not always\n-//! available, however, and that's where these native implementations come into\n-//! play. The only dependencies of these modules are the normal system libraries\n-//! that you would find on the respective platform.\n-\n-#![allow(non_snake_case)]\n-\n-use libc::{mod, c_int};\n-use std::c_str::CString;\n-use std::os;\n-use std::rt::rtio::{mod, IoResult, IoError};\n-use std::num;\n-\n-#[cfg(windows)]\n-#[path = \"tty_windows.rs\"]\n-mod tty;\n-\n-fn unimpl() -> IoError {\n-    #[cfg(unix)] use libc::ENOSYS as ERROR;\n-    #[cfg(windows)] use libc::ERROR_CALL_NOT_IMPLEMENTED as ERROR;\n-    IoError {\n-        code: ERROR as uint,\n-        extra: 0,\n-        detail: Some(\"not yet supported by the `native` runtime, maybe try `green`.\".to_string()),\n-    }\n-}\n-\n-fn last_error() -> IoError {\n-    let errno = os::errno() as uint;\n-    IoError {\n-        code: os::errno() as uint,\n-        extra: 0,\n-        detail: Some(os::error_string(errno)),\n-    }\n-}\n-\n-#[cfg(windows)]\n-#[inline]\n-fn retry<I> (f: || -> I) -> I { f() } // PR rust-lang/rust/#17020\n-\n-#[cfg(unix)]\n-#[inline]\n-fn retry<I: PartialEq + num::One + Neg<I>> (f: || -> I) -> I {\n-    let minus_one = -num::one::<I>();\n-    loop {\n-        let n = f();\n-        if n == minus_one && os::errno() == libc::EINTR as int { }\n-        else { return n }\n-    }\n-}\n-\n-\n-fn keep_going(data: &[u8], f: |*const u8, uint| -> i64) -> i64 {\n-    let origamt = data.len();\n-    let mut data = data.as_ptr();\n-    let mut amt = origamt;\n-    while amt > 0 {\n-        let ret = retry(|| f(data, amt));\n-        if ret == 0 {\n-            break\n-        } else if ret != -1 {\n-            amt -= ret as uint;\n-            data = unsafe { data.offset(ret as int) };\n-        } else {\n-            return ret;\n-        }\n-    }\n-    return (origamt - amt) as i64;\n-}\n-\n-/// Implementation of rt::rtio's IoFactory trait to generate handles to the\n-/// native I/O functionality.\n-pub struct IoFactory {\n-    _cannot_construct_outside_of_this_module: ()\n-}\n-\n-impl IoFactory {\n-    pub fn new() -> IoFactory {\n-        IoFactory { _cannot_construct_outside_of_this_module: () }\n-    }\n-}\n-\n-impl rtio::IoFactory for IoFactory {\n-}"}, {"sha": "4e25feb9d7531759475d9d06fef9331be7335d1f", "filename": "src/libnative/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fa94fdad3e880d2d6cbd82c12bd12caefbeb81a8/src%2Flibnative%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa94fdad3e880d2d6cbd82c12bd12caefbeb81a8/src%2Flibnative%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Flib.rs?ref=fa94fdad3e880d2d6cbd82c12bd12caefbeb81a8", "patch": "@@ -74,7 +74,6 @@ use std::str;\n \n pub use task::NativeTaskBuilder;\n \n-pub mod io;\n pub mod task;\n \n #[cfg(any(windows, android))]"}, {"sha": "6d640b61b18d3a6dd0c79014d7ecbe6f0ebe6918", "filename": "src/libnative/task.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fa94fdad3e880d2d6cbd82c12bd12caefbeb81a8/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa94fdad3e880d2d6cbd82c12bd12caefbeb81a8/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=fa94fdad3e880d2d6cbd82c12bd12caefbeb81a8", "patch": "@@ -19,13 +19,11 @@ use std::mem;\n use std::rt::bookkeeping;\n use std::rt::local::Local;\n use std::rt::mutex::NativeMutex;\n-use std::rt::rtio;\n use std::rt::stack;\n use std::rt::task::{Task, BlockedTask, TaskOpts};\n use std::rt::thread::Thread;\n use std::rt;\n \n-use io;\n use std::task::{TaskBuilder, Spawner};\n \n /// Creates a new Task which is ready to execute as a 1:1 task.\n@@ -42,7 +40,6 @@ fn ops() -> Box<Ops> {\n     box Ops {\n         lock: unsafe { NativeMutex::new() },\n         awoken: false,\n-        io: io::IoFactory::new(),\n         // these *should* get overwritten\n         stack_bounds: (0, 0),\n         stack_guard: 0\n@@ -112,7 +109,6 @@ impl<S: Spawner> NativeTaskBuilder for TaskBuilder<S> {\n struct Ops {\n     lock: NativeMutex,       // native synchronization\n     awoken: bool,      // used to prevent spurious wakeups\n-    io: io::IoFactory, // local I/O factory\n \n     // This field holds the known bounds of the stack in (lo, hi) form. Not all\n     // native tasks necessarily know their precise bounds, hence this is\n@@ -272,10 +268,6 @@ impl rt::Runtime for Ops {\n \n         NativeSpawner.spawn(opts, f);\n     }\n-\n-    fn local_io<'a>(&'a mut self) -> Option<rtio::LocalIo<'a>> {\n-        Some(rtio::LocalIo::new(&mut self.io as &mut rtio::IoFactory))\n-    }\n }\n \n #[cfg(test)]"}, {"sha": "fee748e29d9e08e6ee6ddda352f18a97b74468a0", "filename": "src/librustrt/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fa94fdad3e880d2d6cbd82c12bd12caefbeb81a8/src%2Flibrustrt%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa94fdad3e880d2d6cbd82c12bd12caefbeb81a8/src%2Flibrustrt%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flib.rs?ref=fa94fdad3e880d2d6cbd82c12bd12caefbeb81a8", "patch": "@@ -90,7 +90,6 @@ pub trait Runtime {\n                      cur_task: Box<Task>,\n                      opts: TaskOpts,\n                      f: proc():Send);\n-    fn local_io<'a>(&'a mut self) -> Option<rtio::LocalIo<'a>>;\n     /// The (low, high) edges of the current stack.\n     fn stack_bounds(&self) -> (uint, uint); // (lo, hi)\n     /// The last writable byte of the stack next to the guard page"}, {"sha": "86de8168189ca77afe962f35ef4f9a7ff1554602", "filename": "src/librustrt/rtio.rs", "status": "modified", "additions": 1, "deletions": 129, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/fa94fdad3e880d2d6cbd82c12bd12caefbeb81a8/src%2Flibrustrt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa94fdad3e880d2d6cbd82c12bd12caefbeb81a8/src%2Flibrustrt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Frtio.rs?ref=fa94fdad3e880d2d6cbd82c12bd12caefbeb81a8", "patch": "@@ -12,12 +12,6 @@\n \n use core::prelude::*;\n use alloc::boxed::Box;\n-use collections::string::String;\n-use core::mem;\n-use libc::c_int;\n-\n-use local::Local;\n-use task::Task;\n \n pub trait EventLoop {\n     fn run(&mut self);\n@@ -27,8 +21,7 @@ pub trait EventLoop {\n     fn remote_callback(&mut self, Box<Callback + Send>)\n                        -> Box<RemoteCallback + Send>;\n \n-    /// The asynchronous I/O services. Not all event loops may provide one.\n-    fn io<'a>(&'a mut self) -> Option<&'a mut IoFactory>;\n+    // last vestige of IoFactory\n     fn has_active_io(&self) -> bool;\n }\n \n@@ -46,128 +39,7 @@ pub trait RemoteCallback {\n     fn fire(&mut self);\n }\n \n-pub struct LocalIo<'a> {\n-    factory: &'a mut IoFactory+'a,\n-}\n-\n-#[unsafe_destructor]\n-impl<'a> Drop for LocalIo<'a> {\n-    fn drop(&mut self) {\n-        // FIXME(pcwalton): Do nothing here for now, but eventually we may want\n-        // something. For now this serves to make `LocalIo` noncopyable.\n-    }\n-}\n-\n-impl<'a> LocalIo<'a> {\n-    /// Returns the local I/O: either the local scheduler's I/O services or\n-    /// the native I/O services.\n-    pub fn borrow() -> Option<LocalIo<'a>> {\n-        // FIXME(#11053): bad\n-        //\n-        // This is currently very unsafely implemented. We don't actually\n-        // *take* the local I/O so there's a very real possibility that we\n-        // can have two borrows at once. Currently there is not a clear way\n-        // to actually borrow the local I/O factory safely because even if\n-        // ownership were transferred down to the functions that the I/O\n-        // factory implements it's just too much of a pain to know when to\n-        // relinquish ownership back into the local task (but that would be\n-        // the safe way of implementing this function).\n-        //\n-        // In order to get around this, we just transmute a copy out of the task\n-        // in order to have what is likely a static lifetime (bad).\n-        let mut t: Box<Task> = match Local::try_take() {\n-            Some(t) => t,\n-            None => return None,\n-        };\n-        let ret = t.local_io().map(|t| {\n-            unsafe { mem::transmute_copy(&t) }\n-        });\n-        Local::put(t);\n-        return ret;\n-    }\n-\n-    pub fn maybe_raise<T>(f: |io: &mut IoFactory| -> IoResult<T>)\n-        -> IoResult<T>\n-    {\n-        #[cfg(unix)] use libc::EINVAL as ERROR;\n-        #[cfg(windows)] use libc::ERROR_CALL_NOT_IMPLEMENTED as ERROR;\n-        match LocalIo::borrow() {\n-            Some(mut io) => f(io.get()),\n-            None => Err(IoError {\n-                code: ERROR as uint,\n-                extra: 0,\n-                detail: None,\n-            }),\n-        }\n-    }\n-\n-    pub fn new<'a>(io: &'a mut IoFactory+'a) -> LocalIo<'a> {\n-        LocalIo { factory: io }\n-    }\n-\n-    /// Returns the underlying I/O factory as a trait reference.\n-    #[inline]\n-    pub fn get<'a>(&'a mut self) -> &'a mut IoFactory {\n-        let f: &'a mut IoFactory = self.factory;\n-        f\n-    }\n-}\n-\n-pub trait IoFactory {\n-    fn timer_init(&mut self) -> IoResult<Box<RtioTimer + Send>>;\n-    fn tty_open(&mut self, fd: c_int, readable: bool)\n-            -> IoResult<Box<RtioTTY + Send>>;\n-}\n-\n-pub trait RtioTimer {\n-    fn sleep(&mut self, msecs: u64);\n-    fn oneshot(&mut self, msecs: u64, cb: Box<Callback + Send>);\n-    fn period(&mut self, msecs: u64, cb: Box<Callback + Send>);\n-}\n-\n-pub trait RtioPipe {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint>;\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()>;\n-    fn clone(&self) -> Box<RtioPipe + Send>;\n-\n-    fn close_write(&mut self) -> IoResult<()>;\n-    fn close_read(&mut self) -> IoResult<()>;\n-    fn set_timeout(&mut self, timeout_ms: Option<u64>);\n-    fn set_read_timeout(&mut self, timeout_ms: Option<u64>);\n-    fn set_write_timeout(&mut self, timeout_ms: Option<u64>);\n-}\n-\n-pub trait RtioUnixListener {\n-    fn listen(self: Box<Self>) -> IoResult<Box<RtioUnixAcceptor + Send>>;\n-}\n-\n-pub trait RtioUnixAcceptor {\n-    fn accept(&mut self) -> IoResult<Box<RtioPipe + Send>>;\n-    fn set_timeout(&mut self, timeout: Option<u64>);\n-    fn clone(&self) -> Box<RtioUnixAcceptor + Send>;\n-    fn close_accept(&mut self) -> IoResult<()>;\n-}\n-\n-pub trait RtioTTY {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint>;\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()>;\n-    fn set_raw(&mut self, raw: bool) -> IoResult<()>;\n-    fn get_winsize(&mut self) -> IoResult<(int, int)>;\n-    fn isatty(&self) -> bool;\n-}\n-\n pub trait PausableIdleCallback {\n     fn pause(&mut self);\n     fn resume(&mut self);\n }\n-\n-pub trait RtioSignal {}\n-\n-#[deriving(Show)]\n-pub struct IoError {\n-    pub code: uint,\n-    pub extra: uint,\n-    pub detail: Option<String>,\n-}\n-\n-pub type IoResult<T> = Result<T, IoError>;"}, {"sha": "554e4784eac51f981a80b3342de5ff8c9d3b2d7d", "filename": "src/librustrt/task.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fa94fdad3e880d2d6cbd82c12bd12caefbeb81a8/src%2Flibrustrt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa94fdad3e880d2d6cbd82c12bd12caefbeb81a8/src%2Flibrustrt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Ftask.rs?ref=fa94fdad3e880d2d6cbd82c12bd12caefbeb81a8", "patch": "@@ -26,7 +26,6 @@ use core::raw;\n use local_data;\n use Runtime;\n use local::Local;\n-use rtio::LocalIo;\n use unwind;\n use unwind::Unwinder;\n use collections::str::SendStr;\n@@ -421,13 +420,6 @@ impl Task {\n         ops.maybe_yield(self);\n     }\n \n-    /// Acquires a handle to the I/O factory that this task contains, normally\n-    /// stored in the task's runtime. This factory may not always be available,\n-    /// which is why the return type is `Option`\n-    pub fn local_io<'a>(&'a mut self) -> Option<LocalIo<'a>> {\n-        self.imp.as_mut().unwrap().local_io()\n-    }\n-\n     /// Returns the stack bounds for this task in (lo, hi) format. The stack\n     /// bounds may not be known for all tasks, so the return value may be\n     /// `None`."}, {"sha": "31eab4363d0aaa869216d7595a34d861bbef2e15", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fa94fdad3e880d2d6cbd82c12bd12caefbeb81a8/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa94fdad3e880d2d6cbd82c12bd12caefbeb81a8/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=fa94fdad3e880d2d6cbd82c12bd12caefbeb81a8", "patch": "@@ -228,15 +228,15 @@ use error::{FromError, Error};\n use fmt;\n use int;\n use iter::Iterator;\n-use libc;\n use mem::transmute;\n use ops::{BitOr, BitXor, BitAnd, Sub, Not};\n use option::{Option, Some, None};\n use os;\n use boxed::Box;\n use result::{Ok, Err, Result};\n-use rt::rtio;\n use sys;\n+use slice::{AsSlice, SlicePrelude};\n+use str::{Str, StrPrelude};\n use str;\n use string::String;\n use uint;\n@@ -328,17 +328,6 @@ impl IoError {\n     pub fn last_error() -> IoError {\n         IoError::from_errno(os::errno() as uint, true)\n     }\n-\n-    fn from_rtio_error(err: rtio::IoError) -> IoError {\n-        let rtio::IoError { code, extra, detail } = err;\n-        let mut ioerr = IoError::from_errno(code, false);\n-        ioerr.detail = detail;\n-        ioerr.kind = match ioerr.kind {\n-            TimedOut if extra > 0 => ShortWrite(extra),\n-            k => k,\n-        };\n-        return ioerr;\n-    }\n }\n \n impl fmt::Show for IoError {"}, {"sha": "d3f55d59534d37c27f6dd9336568150149c66fee", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fa94fdad3e880d2d6cbd82c12bd12caefbeb81a8/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa94fdad3e880d2d6cbd82c12bd12caefbeb81a8/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=fa94fdad3e880d2d6cbd82c12bd12caefbeb81a8", "patch": "@@ -9,6 +9,11 @@\n // except according to those terms.\n \n #![allow(missing_doc)]\n+#![allow(non_camel_case_types)]\n+#![allow(unused_imports)]\n+#![allow(dead_code)]\n+#![allow(unused_unsafe)]\n+#![allow(unused_mut)]\n \n extern crate libc;\n "}]}