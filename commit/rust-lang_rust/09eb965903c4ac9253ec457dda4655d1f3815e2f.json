{"sha": "09eb965903c4ac9253ec457dda4655d1f3815e2f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5ZWI5NjU5MDNjNGFjOTI1M2VjNDU3ZGRhNDY1NWQxZjM4MTVlMmY=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-02-17T12:03:53Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-02-17T12:03:53Z"}, "message": "Rollup merge of #22393 - kmcallister:macros-chapter , r=steveklabnik\n\nThis is a more introductory document, suitable for Part II. The arcane details move to an \"Advanced macros\" chapter in Part III.\n\nConflicts:\n\tsrc/doc/trpl/macros.md", "tree": {"sha": "d0cda5fca3e08c24c9d64fa3f1dbb6aee2afb9c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d0cda5fca3e08c24c9d64fa3f1dbb6aee2afb9c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09eb965903c4ac9253ec457dda4655d1f3815e2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09eb965903c4ac9253ec457dda4655d1f3815e2f", "html_url": "https://github.com/rust-lang/rust/commit/09eb965903c4ac9253ec457dda4655d1f3815e2f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09eb965903c4ac9253ec457dda4655d1f3815e2f/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "020e4e4ad981ce0518bd8e3464ac592717c41143", "url": "https://api.github.com/repos/rust-lang/rust/commits/020e4e4ad981ce0518bd8e3464ac592717c41143", "html_url": "https://github.com/rust-lang/rust/commit/020e4e4ad981ce0518bd8e3464ac592717c41143"}, {"sha": "6cef0e5daed42c68df0f5be58cf73a70690f4d9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/6cef0e5daed42c68df0f5be58cf73a70690f4d9f", "html_url": "https://github.com/rust-lang/rust/commit/6cef0e5daed42c68df0f5be58cf73a70690f4d9f"}], "stats": {"total": 1036, "additions": 512, "deletions": 524}, "files": [{"sha": "d57aff7f4f411fbc9974666127a02150b324301d", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/09eb965903c4ac9253ec457dda4655d1f3815e2f/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/09eb965903c4ac9253ec457dda4655d1f3815e2f/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=09eb965903c4ac9253ec457dda4655d1f3815e2f", "patch": "@@ -28,13 +28,14 @@\n     * [Generics](generics.md)\n     * [Traits](traits.md)\n     * [Static and Dynamic Dispatch](static-and-dynamic-dispatch.md)\n+    * [Macros](macros.md)\n     * [Concurrency](concurrency.md)\n     * [Error Handling](error-handling.md)\n     * [Documentation](documentation.md)\n * [III: Advanced Topics](advanced.md)\n     * [FFI](ffi.md)\n     * [Unsafe Code](unsafe.md)\n-    * [Macros](macros.md)\n+    * [Advanced Macros](advanced-macros.md)\n     * [Compiler Plugins](plugins.md)\n * [Conclusion](conclusion.md)\n * [Glossary](glossary.md)"}, {"sha": "aff365051a4eadfc67819f0e9c45487abd1b70ad", "filename": "src/doc/trpl/advanced-macros.md", "status": "added", "additions": 210, "deletions": 0, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/09eb965903c4ac9253ec457dda4655d1f3815e2f/src%2Fdoc%2Ftrpl%2Fadvanced-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/09eb965903c4ac9253ec457dda4655d1f3815e2f/src%2Fdoc%2Ftrpl%2Fadvanced-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fadvanced-macros.md?ref=09eb965903c4ac9253ec457dda4655d1f3815e2f", "patch": "@@ -0,0 +1,210 @@\n+% Advanced macros\n+\n+This chapter picks up where the [introductory macro chapter](macros.html) left\n+off.\n+\n+# Syntactic requirements\n+\n+Even when Rust code contains un-expanded macros, it can be parsed as a full\n+syntax tree. This property can be very useful for editors and other tools that\n+process code. It also has a few consequences for the design of Rust's macro\n+system.\n+\n+One consequence is that Rust must determine, when it parses a macro invocation,\n+whether the macro stands in for\n+\n+* zero or more items,\n+* zero or more methods,\n+* an expression,\n+* a statement, or\n+* a pattern.\n+\n+A macro invocation within a block could stand for some items, or for an\n+expression / statement. Rust uses a simple rule to resolve this ambiguity. A\n+macro invocation that stands for items must be either\n+\n+* delimited by curly braces, e.g. `foo! { ... }`, or\n+* terminated by a semicolon, e.g. `foo!(...);`\n+\n+Another consequence of pre-expansion parsing is that the macro invocation must\n+consist of valid Rust tokens. Furthermore, parentheses, brackets, and braces\n+must be balanced within a macro invocation. For example, `foo!([)` is\n+forbidden. This allows Rust to know where the macro invocation ends.\n+\n+More formally, the macro invocation body must be a sequence of *token trees*.\n+A token tree is defined recursively as either\n+\n+* a sequence of token trees surrounded by matching `()`, `[]`, or `{}`, or\n+* any other single token.\n+\n+Within a matcher, each metavariable has a *fragment specifier*, identifying\n+which syntactic form it matches.\n+\n+* `ident`: an identifier. Examples: `x`; `foo`.\n+* `path`: a qualified name. Example: `T::SpecialA`.\n+* `expr`: an expression. Examples: `2 + 2`; `if true then { 1 } else { 2 }`; `f(42)`.\n+* `ty`: a type. Examples: `i32`; `Vec<(char, String)>`; `&T`.\n+* `pat`: a pattern. Examples: `Some(t)`; `(17, 'a')`; `_`.\n+* `stmt`: a single statement. Example: `let x = 3`.\n+* `block`: a brace-delimited sequence of statements. Example:\n+  `{ log(error, \"hi\"); return 12; }`.\n+* `item`: an [item][]. Examples: `fn foo() { }`; `struct Bar;`.\n+* `meta`: a \"meta item\", as found in attributes. Example: `cfg(target_os = \"windows\")`.\n+* `tt`: a single token tree.\n+\n+There are additional rules regarding the next token after a metavariable:\n+\n+* `expr` variables must be followed by one of: `=> , ;`\n+* `ty` and `path` variables must be followed by one of: `=> , : = > as`\n+* `pat` variables must be followed by one of: `=> , =`\n+* Other variables may be followed by any token.\n+\n+These rules provide some flexibility for Rust's syntax to evolve without\n+breaking existing macros.\n+\n+The macro system does not deal with parse ambiguity at all. For example, the\n+grammar `$($t:ty)* $e:expr` will always fail to parse, because the parser would\n+be forced to choose between parsing `$t` and parsing `$e`. Changing the\n+invocation syntax to put a distinctive token in front can solve the problem. In\n+this case, you can write `$(T $t:ty)* E $e:exp`.\n+\n+[item]: ../reference.html#items\n+\n+# Scoping and macro import/export\n+\n+Macros are expanded at an early stage in compilation, before name resolution.\n+One downside is that scoping works differently for macros, compared to other\n+constructs in the language.\n+\n+Definition and expansion of macros both happen in a single depth-first,\n+lexical-order traversal of a crate's source. So a macro defined at module scope\n+is visible to any subsequent code in the same module, which includes the body\n+of any subsequent child `mod` items.\n+\n+A macro defined within the body of a single `fn`, or anywhere else not at\n+module scope, is visible only within that item.\n+\n+If a module has the `macro_use` attribute, its macros are also visible in its\n+parent module after the child's `mod` item. If the parent also has `macro_use`\n+then the macros will be visible in the grandparent after the parent's `mod`\n+item, and so forth.\n+\n+The `macro_use` attribute can also appear on `extern crate`. In this context\n+it controls which macros are loaded from the external crate, e.g.\n+\n+```rust,ignore\n+#[macro_use(foo, bar)]\n+extern crate baz;\n+```\n+\n+If the attribute is given simply as `#[macro_use]`, all macros are loaded. If\n+there is no `#[macro_use]` attribute then no macros are loaded. Only macros\n+defined with the `#[macro_export]` attribute may be loaded.\n+\n+To load a crate's macros *without* linking it into the output, use `#[no_link]`\n+as well.\n+\n+An example:\n+\n+```rust\n+macro_rules! m1 { () => (()) }\n+\n+// visible here: m1\n+\n+mod foo {\n+    // visible here: m1\n+\n+    #[macro_export]\n+    macro_rules! m2 { () => (()) }\n+\n+    // visible here: m1, m2\n+}\n+\n+// visible here: m1\n+\n+macro_rules! m3 { () => (()) }\n+\n+// visible here: m1, m3\n+\n+#[macro_use]\n+mod bar {\n+    // visible here: m1, m3\n+\n+    macro_rules! m4 { () => (()) }\n+\n+    // visible here: m1, m3, m4\n+}\n+\n+// visible here: m1, m3, m4\n+# fn main() { }\n+```\n+\n+When this library is loaded with `#[macro_use] extern crate`, only `m2` will\n+be imported.\n+\n+The Rust Reference has a [listing of macro-related\n+attributes](../reference.html#macro--and-plugin-related-attributes).\n+\n+# The variable `$crate`\n+\n+A further difficulty occurs when a macro is used in multiple crates. Say that\n+`mylib` defines\n+\n+```rust\n+pub fn increment(x: u32) -> u32 {\n+    x + 1\n+}\n+\n+#[macro_export]\n+macro_rules! inc_a {\n+    ($x:expr) => ( ::increment($x) )\n+}\n+\n+#[macro_export]\n+macro_rules! inc_b {\n+    ($x:expr) => ( ::mylib::increment($x) )\n+}\n+# fn main() { }\n+```\n+\n+`inc_a` only works within `mylib`, while `inc_b` only works outside the\n+library. Furthermore, `inc_b` will break if the user imports `mylib` under\n+another name.\n+\n+Rust does not (yet) have a hygiene system for crate references, but it does\n+provide a simple workaround for this problem. Within a macro imported from a\n+crate named `foo`, the special macro variable `$crate` will expand to `::foo`.\n+By contrast, when a macro is defined and then used in the same crate, `$crate`\n+will expand to nothing. This means we can write\n+\n+```rust\n+#[macro_export]\n+macro_rules! inc {\n+    ($x:expr) => ( $crate::increment($x) )\n+}\n+# fn main() { }\n+```\n+\n+to define a single macro that works both inside and outside our library. The\n+function name will expand to either `::increment` or `::mylib::increment`.\n+\n+To keep this system simple and correct, `#[macro_use] extern crate ...` may\n+only appear at the root of your crate, not inside `mod`. This ensures that\n+`$crate` is a single identifier.\n+\n+# A final note\n+\n+Macros, as currently implemented, are not for the faint of heart. Even\n+ordinary syntax errors can be more difficult to debug when they occur inside a\n+macro, and errors caused by parse problems in generated code can be very\n+tricky. Invoking the `log_syntax!` macro can help elucidate intermediate\n+states, invoking `trace_macros!(true)` will automatically print those\n+intermediate states out, and passing the flag `--pretty expanded` as a\n+command-line argument to the compiler will show the result of expansion.\n+\n+If Rust's macro system can't do what you need, you may want to write a\n+[compiler plugin](plugins.html) instead. Compared to `macro_rules!`\n+macros, this is significantly more work, the interfaces are much less stable,\n+and the warnings about debugging apply ten-fold. In exchange you get the\n+flexibility of running arbitrary Rust code within the compiler. Syntax\n+extension plugins are sometimes called *procedural macros* for this reason."}, {"sha": "ce6fa3ce949cd7a1f0878ca79bf20358a5127ba1", "filename": "src/doc/trpl/macros.md", "status": "modified", "additions": 300, "deletions": 523, "changes": 823, "blob_url": "https://github.com/rust-lang/rust/blob/09eb965903c4ac9253ec457dda4655d1f3815e2f/src%2Fdoc%2Ftrpl%2Fmacros.md", "raw_url": "https://github.com/rust-lang/rust/raw/09eb965903c4ac9253ec457dda4655d1f3815e2f/src%2Fdoc%2Ftrpl%2Fmacros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmacros.md?ref=09eb965903c4ac9253ec457dda4655d1f3815e2f", "patch": "@@ -1,588 +1,365 @@\n % Macros\n \n-# Introduction\n-\n-Functions are the primary tool that programmers can use to build abstractions.\n-Sometimes, however, programmers want to abstract over compile-time syntax\n-rather than run-time values.\n-Macros provide syntactic abstraction.\n-For an example of how this can be useful, consider the following two code fragments,\n-which both pattern-match on their input and both return early in one case,\n-doing nothing otherwise:\n-\n-~~~~\n-# enum T { SpecialA(u32), SpecialB(u32) }\n-# fn f() -> u32 {\n-# let input_1 = T::SpecialA(0);\n-# let input_2 = T::SpecialA(0);\n-match input_1 {\n-    T::SpecialA(x) => { return x; }\n-    _ => {}\n-}\n-// ...\n-match input_2 {\n-    T::SpecialB(x) => { return x; }\n-    _ => {}\n-}\n-# return 0;\n-# }\n-~~~~\n-\n-This code could become tiresome if repeated many times.\n-However, no function can capture its functionality to make it possible\n-to abstract the repetition away.\n-Rust's macro system, however, can eliminate the repetition. Macros are\n-lightweight custom syntax extensions, themselves defined using the\n-`macro_rules!` syntax extension. The following `early_return` macro captures\n-the pattern in the above code:\n-\n-~~~~\n-# enum T { SpecialA(u32), SpecialB(u32) }\n-# fn f() -> u32 {\n-# let input_1 = T::SpecialA(0);\n-# let input_2 = T::SpecialA(0);\n-macro_rules! early_return {\n-    ($inp:expr, $sp:path) => ( // invoke it like `(input_5, SpecialE)`\n-        match $inp {\n-            $sp(x) => { return x; }\n-            _ => {}\n-        }\n-    );\n-}\n-// ...\n-early_return!(input_1, T::SpecialA);\n-// ...\n-early_return!(input_2, T::SpecialB);\n-# return 0;\n-# }\n-# fn main() {}\n-~~~~\n-\n-Macros are defined in pattern-matching style: in the above example, the text\n-`($inp:expr, $sp:path)` that appears on the left-hand side of the `=>` is the\n-*macro invocation syntax*, a pattern denoting how to write a call to the\n-macro. The text on the right-hand side of the `=>`, beginning with `match\n-$inp`, is the *macro transcription syntax*: what the macro expands to.\n-\n-# Invocation syntax\n-\n-The macro invocation syntax specifies the syntax for the arguments to the\n-macro. It appears on the left-hand side of the `=>` in a macro definition. It\n-conforms to the following rules:\n-\n-1. It must be surrounded by parentheses.\n-2. `$` has special meaning (described below).\n-3. The `()`s, `[]`s, and `{}`s it contains must balance. For example, `([)` is\n-forbidden.\n-4. Some arguments can be followed only by a limited set of separators, to\n-avoid ambiguity (described below).\n-\n-Otherwise, the invocation syntax is free-form.\n-\n-To take a fragment of Rust code as an argument, write `$` followed by a name\n- (for use on the right-hand side), followed by a `:`, followed by a *fragment\n- specifier*. The fragment specifier denotes the sort of fragment to match. The\n- most common fragment specifiers are:\n-\n-* `ident` (an identifier, referring to a variable or item. Examples: `f`, `x`,\n-  `foo`.)\n-* `expr` (an expression. Examples: `2 + 2`; `if true then { 1 } else { 2 }`;\n-  `f(42)`.)\n-* `ty` (a type. Examples: `i32`, `Vec<(char, String)>`, `&T`.)\n-* `path` (a path to struct or enum variant. Example: `T::SpecialA`)\n-* `pat` (a pattern, usually appearing in a `match` or on the left-hand side of\n-  a declaration. Examples: `Some(t)`; `(17, 'a')`; `_`.)\n-* `block` (a sequence of actions. Example: `{ log(error, \"hi\"); return 12; }`)\n-\n-The parser interprets any token that's not preceded by a `$` literally. Rust's usual\n-rules of tokenization apply,\n-\n-So `($x:ident -> (($e:expr)))`, though excessively fancy, would designate a macro\n-that could be invoked like: `my_macro!(i->(( 2+2 )))`.\n-\n-To avoid ambiguity, macro invocation syntax must conform to the following rules:\n-\n-* `expr` must be followed by `=>`, `,` or `;`.\n-* `ty` and `path` must be followed by `=>`, `,`, `:`, `=`, `>` or `as`.\n-* `pat` must be followed by `=>`, `,` or `=`.\n-* `ident` and `block` can be followed by any token.\n-\n-## Invocation location\n-\n-A macro invocation may take the place of (and therefore expand to) an\n-expression, item, statement, or pattern.  The Rust parser will parse the macro\n-invocation as a \"placeholder\" for whichever syntactic form is appropriate for\n-the location.\n-\n-At expansion time, the output of the macro will be parsed as whichever of the\n-three nonterminals it stands in for. This means that a single macro might,\n-for example, expand to an item or an expression, depending on its arguments\n-(and cause a syntax error if it is called with the wrong argument for its\n-location). Although this behavior sounds excessively dynamic, it is known to\n-be useful under some circumstances.\n-\n-\n-# Transcription syntax\n-\n-The right-hand side of the `=>` follows the same rules as the left-hand side,\n-except that a `$` need only be followed by the name of the syntactic fragment\n-to transcribe into the macro expansion; its type need not be repeated.\n-\n-The right-hand side must be enclosed by delimiters, which the transcriber ignores.\n-Therefore `() => ((1,2,3))` is a macro that expands to a tuple expression,\n-`() => (let $x=$val)` is a macro that expands to a statement,\n-and `() => (1,2,3)` is a macro that expands to a syntax error\n-(since the transcriber interprets the parentheses on the right-hand-size as delimiters,\n-and `1,2,3` is not a valid Rust expression on its own).\n-\n-Except for permissibility of `$name` (and `$(...)*`, discussed below), the\n-right-hand side of a macro definition is ordinary Rust syntax. In particular,\n-macro invocations (including invocations of the macro currently being defined)\n-are permitted in expression, statement, and item locations. However, nothing\n-else about the code is examined or executed by the macro system; execution\n-still has to wait until run-time.\n-\n-## Interpolation location\n-\n-The interpolation `$argument_name` may appear in any location consistent with\n-its fragment specifier (i.e., if it is specified as `ident`, it may be used\n-anywhere an identifier is permitted).\n-\n-# Multiplicity\n-\n-## Invocation\n-\n-Going back to the motivating example, recall that `early_return` expanded into\n-a `match` that would `return` if the `match`'s scrutinee matched the\n-\"special case\" identifier provided as the second argument to `early_return`,\n-and do nothing otherwise. Now suppose that we wanted to write a\n-version of `early_return` that could handle a variable number of \"special\"\n-cases.\n-\n-The syntax `$(...)*` on the left-hand side of the `=>` in a macro definition\n-accepts zero or more occurrences of its contents. It works much\n-like the `*` operator in regular expressions. It also supports a\n-separator token (a comma-separated list could be written `$(...),*`), and `+`\n-instead of `*` to mean \"at least one.\"\n-\n-~~~~\n-# enum T { SpecialA(u32), SpecialB(u32), SpecialC(u32), SpecialD(u32) }\n-# fn f() -> u32 {\n-# let input_1 = T::SpecialA(0);\n-# let input_2 = T::SpecialA(0);\n-macro_rules! early_return {\n-    ($inp:expr, [ $($sp:path),+ ]) => (\n-        match $inp {\n+By now you've learned about many of the tools Rust provides for abstracting and\n+reusing code. These units of code reuse have a rich semantic structure. For\n+example, functions have a type signature, type parameters have trait bounds,\n+and overloaded functions must belong to a particular trait.\n+\n+This structure means that Rust's core abstractions have powerful compile-time\n+correctness checking. But this comes at the price of reduced flexibility. If\n+you visually identify a pattern of repeated code, you may find it's difficult\n+or cumbersome to express that pattern as a generic function, a trait, or\n+anything else within Rust's semantics.\n+\n+Macros allow us to abstract at a *syntactic* level. A macro invocation is\n+shorthand for an \"expanded\" syntactic form. This expansion happens early in\n+compilation, before any static checking. As a result, macros can capture many\n+patterns of code reuse that Rust's core abstractions cannot.\n+\n+The drawback is that macro-based code can be harder to understand, because\n+fewer of the built-in rules apply. Like an ordinary function, a well-behaved\n+macro can be used without understanding its implementation. However, it can be\n+difficult to design a well-behaved macro!  Additionally, compiler errors in\n+macro code are harder to interpret, because they describe problems in the\n+expanded code, not the source-level form that developers use.\n+\n+These drawbacks make macros something of a \"feature of last resort\". That's not\n+to say that macros are bad; they are part of Rust because sometimes they're\n+needed for truly concise, well-abstracted code. Just keep this tradeoff in\n+mind.\n+\n+# Defining a macro\n+\n+You may have seen the `vec!` macro, used to initialize a [vector][] with any\n+number of elements.\n+\n+[vector]: arrays-vectors-and-slices.html\n+\n+```rust\n+let x: Vec<u32> = vec![1, 2, 3];\n+# assert_eq!(&[1,2,3], &x);\n+```\n+\n+This can't be an ordinary function, because it takes any number of arguments.\n+But we can imagine it as syntactic shorthand for\n+\n+```rust\n+let x: Vec<u32> = {\n+    let mut temp_vec = Vec::new();\n+    temp_vec.push(1);\n+    temp_vec.push(2);\n+    temp_vec.push(3);\n+    temp_vec\n+};\n+# assert_eq!(&[1,2,3], &x);\n+```\n+\n+We can implement this shorthand, using a macro: [^actual]\n+\n+[^actual]: The actual definition of `vec!` in libcollections differs from the\n+           one presented here, for reasons of efficiency and reusability. Some\n+           of these are mentioned in the [advanced macros chapter][].\n+\n+```rust\n+macro_rules! vec {\n+    ( $( $x:expr ),* ) => {\n+        {\n+            let mut temp_vec = Vec::new();\n             $(\n-                $sp(x) => { return x; }\n-            )+\n-            _ => {}\n+                temp_vec.push($x);\n+            )*\n+            temp_vec\n         }\n-    )\n-}\n-// ...\n-early_return!(input_1, [T::SpecialA,T::SpecialC,T::SpecialD]);\n-// ...\n-early_return!(input_2, [T::SpecialB]);\n-# return 0;\n-# }\n-# fn main() {}\n-~~~~\n-\n-### Transcription\n-\n-As the above example demonstrates, `$(...)*` is also valid on the right-hand\n-side of a macro definition. The behavior of `*` in transcription,\n-especially in cases where multiple `*`s are nested, and multiple different\n-names are involved, can seem somewhat magical and unintuitive at first. The\n-system that interprets them is called \"Macro By Example.\" The two rules to\n-keep in mind are (1) the behavior of `$(...)*` is to walk through one \"layer\"\n-of repetitions for all of the `$name`s it contains in lockstep, and (2) each\n-`$name` must be under at least as many `$(...)*`s as it was matched against.\n-If it is under more, it'll be repeated, as appropriate.\n-\n-## Parsing limitations\n-\n-\n-For technical reasons, there are two limitations to the treatment of syntax\n-fragments by the macro parser:\n-\n-1. The parser will always parse as much as possible of a Rust syntactic\n-fragment. For example, if the comma were omitted from the syntax of\n-`early_return!` above, `input_1 [` would've been interpreted as the beginning\n-of an array index. In fact, invoking the macro would have been impossible.\n-2. The parser must have eliminated all ambiguity by the time it reaches a\n-`$name:fragment_specifier` declaration. This limitation can result in parse\n-errors when declarations occur at the beginning of, or immediately after,\n-a `$(...)*`. For example, the grammar `$($t:ty)* $e:expr` will always fail to\n-parse because the parser would be forced to choose between parsing `t` and\n-parsing `e`. Changing the invocation syntax to require a distinctive token in\n-front can solve the problem. In the above example, `$(T $t:ty)* E $e:exp`\n-solves the problem.\n-\n-# Macro argument pattern matching\n-\n-## Motivation\n-\n-Now consider code like the following:\n-\n-~~~~\n-# enum T1 { Good1(T2, u32), Bad1}\n-# struct T2 { body: T3 }\n-# enum T3 { Good2(u32), Bad2}\n-# fn f(x: T1) -> u32 {\n-match x {\n-    T1::Good1(g1, val) => {\n-        match g1.body {\n-            T3::Good2(result) => {\n-                // complicated stuff goes here\n-                return result + val;\n-            },\n-            _ => panic!(\"Didn't get good_2\")\n-        }\n-    }\n-    _ => return 0 // default value\n+    };\n }\n+# fn main() {\n+#     assert_eq!(&[1,2,3], &vec![1,2,3]);\n # }\n-# fn main() {}\n-~~~~\n-\n-All the complicated stuff is deeply indented, and the error-handling code is\n-separated from matches that fail. We'd like to write a macro that performs\n-a match, but with a syntax that suits the problem better. The following macro\n-can solve the problem:\n-\n-~~~~\n-macro_rules! biased_match {\n-    // special case: `let (x) = ...` is illegal, so use `let x = ...` instead\n-    ( ($e:expr) -> ($p:pat) else $err:stmt ;\n-      binds $bind_res:ident\n-    ) => (\n-        let $bind_res = match $e {\n-            $p => ( $bind_res ),\n-            _ => { $err }\n-        };\n-    );\n-    // more than one name; use a tuple\n-    ( ($e:expr) -> ($p:pat) else $err:stmt ;\n-      binds $( $bind_res:ident ),*\n-    ) => (\n-        let ( $( $bind_res ),* ) = match $e {\n-            $p => ( $( $bind_res ),* ),\n-            _ => { $err }\n-        };\n-    )\n-}\n+```\n \n-# enum T1 { Good1(T2, u32), Bad1}\n-# struct T2 { body: T3 }\n-# enum T3 { Good2(u32), Bad2}\n-# fn f(x: T1) -> u32 {\n-biased_match!((x)       -> (T1::Good1(g1, val)) else { return 0 };\n-              binds g1, val );\n-biased_match!((g1.body) -> (T3::Good2(result) )\n-                  else { panic!(\"Didn't get good_2\") };\n-              binds result );\n-// complicated stuff goes here\n-return result + val;\n-# }\n-# fn main() {}\n-~~~~\n-\n-This solves the indentation problem. But if we have a lot of chained matches\n-like this, we might prefer to write a single macro invocation. The input\n-pattern we want is clear:\n-\n-~~~~\n-# fn main() {}\n-# macro_rules! b {\n-    ( $( ($e:expr) -> ($p:pat) else $err:stmt ; )*\n-      binds $( $bind_res:ident ),*\n-    )\n-# => (0) }\n-~~~~\n-\n-However, it's not possible to directly expand to nested match statements. But\n-there is a solution.\n-\n-## The recursive approach to macro writing\n-\n-A macro may accept multiple different input grammars. The first one to\n-successfully match the actual argument to a macro invocation is the one that\n-\"wins.\"\n-\n-In the case of the example above, we want to write a recursive macro to\n-process the semicolon-terminated lines, one-by-one. So, we want the following\n-input patterns:\n-\n-~~~~\n-# macro_rules! b {\n-    ( binds $( $bind_res:ident ),* )\n-# => (0) }\n-# fn main() {}\n-~~~~\n-\n-...and:\n-\n-~~~~\n-# fn main() {}\n-# macro_rules! b {\n-    (    ($e     :expr) -> ($p     :pat) else $err     :stmt ;\n-      $( ($e_rest:expr) -> ($p_rest:pat) else $err_rest:stmt ; )*\n-      binds  $( $bind_res:ident ),*\n-    )\n-# => (0) }\n-~~~~\n-\n-The resulting macro looks like this. Note that the separation into\n-`biased_match!` and `biased_match_rec!` occurs only because we have an outer\n-piece of syntax (the `let`) which we only want to transcribe once.\n-\n-~~~~\n-# fn main() {\n+Whoa, that's a lot of new syntax! Let's break it down.\n \n-macro_rules! biased_match_rec {\n-    // Handle the first layer\n-    (   ($e     :expr) -> ($p     :pat) else $err     :stmt ;\n-     $( ($e_rest:expr) -> ($p_rest:pat) else $err_rest:stmt ; )*\n-     binds $( $bind_res:ident ),*\n-    ) => (\n-        match $e {\n-            $p => {\n-                // Recursively handle the next layer\n-                biased_match_rec!($( ($e_rest) -> ($p_rest) else $err_rest ; )*\n-                                  binds $( $bind_res ),*\n-                )\n-            }\n-            _ => { $err }\n-        }\n-    );\n-    // Produce the requested values\n-    ( binds $( $bind_res:ident ),* ) => ( ($( $bind_res ),*) )\n-}\n+```ignore\n+macro_rules! vec { ... }\n+```\n \n-// Wrap the whole thing in a `let`.\n-macro_rules! biased_match {\n-    // special case: `let (x) = ...` is illegal, so use `let x = ...` instead\n-    ( $( ($e:expr) -> ($p:pat) else $err:stmt ; )*\n-      binds $bind_res:ident\n-    ) => (\n-        let $bind_res = biased_match_rec!(\n-            $( ($e) -> ($p) else $err ; )*\n-            binds $bind_res\n-        );\n-    );\n-    // more than one name: use a tuple\n-    ( $( ($e:expr) -> ($p:pat) else $err:stmt ; )*\n-      binds  $( $bind_res:ident ),*\n-    ) => (\n-        let ( $( $bind_res ),* ) = biased_match_rec!(\n-            $( ($e) -> ($p) else $err ; )*\n-            binds $( $bind_res ),*\n-        );\n-    )\n-}\n+This says we're defining a macro named `vec`, much as `fn vec` would define a\n+function named `vec`. In prose, we informally write a macro's name with an\n+exclamation point, e.g. `vec!`. The exclamation point is part of the invocation\n+syntax and serves to distinguish a macro from an ordinary function.\n \n+## Matching\n \n-# enum T1 { Good1(T2, u32), Bad1}\n-# struct T2 { body: T3 }\n-# enum T3 { Good2(u32), Bad2}\n-# fn f(x: T1) -> u32 {\n-biased_match!(\n-    (x)       -> (T1::Good1(g1, val)) else { return 0 };\n-    (g1.body) -> (T3::Good2(result) ) else { panic!(\"Didn't get Good2\") };\n-    binds val, result );\n-// complicated stuff goes here\n-return result + val;\n-# }\n-# }\n-~~~~\n-\n-This technique applies to many cases where transcribing a result all at once is not possible.\n-The resulting code resembles ordinary functional programming in some respects,\n-but has some important differences from functional programming.\n-\n-The first difference is important, but also easy to forget: the transcription\n-(right-hand) side of a `macro_rules!` rule is literal syntax, which can only\n-be executed at run-time. If a piece of transcription syntax does not itself\n-appear inside another macro invocation, it will become part of the final\n-program. If it is inside a macro invocation (for example, the recursive\n-invocation of `biased_match_rec!`), it does have the opportunity to affect\n-transcription, but only through the process of attempted pattern matching.\n-\n-The second, related, difference is that the evaluation order of macros feels\n-\"backwards\" compared to ordinary programming. Given an invocation\n-`m1!(m2!())`, the expander first expands `m1!`, giving it as input the literal\n-syntax `m2!()`. If it transcribes its argument unchanged into an appropriate\n-position (in particular, not as an argument to yet another macro invocation),\n-the expander will then proceed to evaluate `m2!()` (along with any other macro\n-invocations `m1!(m2!())` produced).\n+The macro is defined through a series of *rules*, which are pattern-matching\n+cases. Above, we had\n \n-# Hygiene\n+```ignore\n+( $( $x:expr ),* ) => { ... };\n+```\n \n-To prevent clashes, rust implements\n-[hygienic macros](http://en.wikipedia.org/wiki/Hygienic_macro).\n+This is like a `match` expression arm, but the matching happens on Rust syntax\n+trees, at compile time. The semicolon is optional on the last (here, only)\n+case. The \"pattern\" on the left-hand side of `=>` is known as a *matcher*.\n+These have [their own little grammar] within the language.\n \n-As an example, `loop` and `for-loop` labels (discussed in the lifetimes guide)\n-will not clash. The following code will print \"Hello!\" only once:\n+[their own little grammar]: ../reference.html#macros\n \n-~~~\n-macro_rules! loop_x {\n-    ($e: expr) => (\n-        // $e will not interact with this 'x\n-        'x: loop {\n-            println!(\"Hello!\");\n-            $e\n-        }\n-    );\n+The matcher `$x:expr` will match any Rust expression, binding that syntax tree\n+to the *metavariable* `$x`. The identifier `expr` is a *fragment specifier*;\n+the full possibilities are enumerated in the [advanced macros chapter][].\n+Surrounding the matcher with `$(...),*` will match zero or more expressions,\n+separated by commas.\n+\n+Aside from the special matcher syntax, any Rust tokens that appear in a matcher\n+must match exactly. For example,\n+\n+```rust\n+macro_rules! foo {\n+    (x => $e:expr) => (println!(\"mode X: {}\", $e));\n+    (y => $e:expr) => (println!(\"mode Y: {}\", $e));\n }\n \n fn main() {\n-    'x: loop {\n-        loop_x!(break 'x);\n-        println!(\"I am never printed.\");\n-    }\n+    foo!(y => 3);\n }\n-~~~\n+```\n \n-The two `'x` names did not clash, which would have caused the loop\n-to print \"I am never printed\" and to run forever.\n+will print\n \n-# Scoping and macro import/export\n+```text\n+mode Y: 3\n+```\n+\n+With\n \n-Macros are expanded at an early stage in compilation, before name resolution.\n-One downside is that scoping works differently for macros, compared to other\n-constructs in the language.\n+```rust,ignore\n+foo!(z => 3);\n+```\n \n-Definition and expansion of macros both happen in a single depth-first,\n-lexical-order traversal of a crate's source. So a macro defined at module scope\n-is visible to any subsequent code in the same module, which includes the body\n-of any subsequent child `mod` items.\n+we get the compiler error\n \n-A macro defined within the body of a single `fn`, or anywhere else not at\n-module scope, is visible only within that item.\n+```text\n+error: no rules expected the token `z`\n+```\n \n-If a module has the `macro_use` attribute, its macros are also visible in its\n-parent module after the child's `mod` item. If the parent also has `macro_use`\n-then the macros will be visible in the grandparent after the parent's `mod`\n-item, and so forth.\n+## Expansion\n \n-The `macro_use` attribute can also appear on `extern crate`.  In this context\n-it controls which macros are loaded from the external crate, e.g.\n+The right-hand side of a macro rule is ordinary Rust syntax, for the most part.\n+But we can splice in bits of syntax captured by the matcher. From the original\n+example:\n \n-```rust,ignore\n-#[macro_use(foo, bar)]\n-extern crate baz;\n+```ignore\n+$(\n+    temp_vec.push($x);\n+)*\n ```\n \n-If the attribute is given simply as `#[macro_use]`, all macros are loaded.  If\n-there is no `#[macro_use]` attribute then no macros are loaded.  Only macros\n-defined with the `#[macro_export]` attribute may be loaded.\n+Each matched expression `$x` will produce a single `push` statement in the\n+macro expansion. The repetition in the expansion proceeds in \"lockstep\" with\n+repetition in the matcher (more on this in a moment).\n \n-To load a crate's macros *without* linking it into the output, use `#[no_link]`\n-as well.\n+Because `$x` was already declared as matching an expression, we don't repeat\n+`:expr` on the right-hand side. Also, we don't include a separating comma as\n+part of the repetition operator. Instead, we have a terminating semicolon\n+within the repeated block.\n \n-An example:\n+Another detail: the `vec!` macro has *two* pairs of braces on the right-hand\n+side. They are often combined like so:\n \n-```rust\n-macro_rules! m1 { () => (()) }\n+```ignore\n+macro_rules! foo {\n+    () => {{\n+        ...\n+    }}\n+}\n+```\n+\n+The outer braces are part of the syntax of `macro_rules!`. In fact, you can use\n+`()` or `[]` instead. They simply delimit the right-hand side as a whole.\n+\n+The inner braces are part of the expanded syntax. Remember, the `vec!` macro is\n+used in an expression context. To write an expression with multiple statements,\n+including `let`-bindings, we use a block. If your macro expands to a single\n+expression, you don't need this extra layer of braces.\n+\n+Note that we never *declared* that the macro produces an expression. In fact,\n+this is not determined until we use the macro as an expression. With care, you\n+can write a macro whose expansion works in several contexts. For example,\n+shorthand for a data type could be valid as either an expression or a pattern.\n+\n+## Repetition\n \n-// visible here: m1\n+The repetition behavior can seem somewhat magical, especially when multiple\n+names are bound at multiple nested levels of repetition. The two rules to keep\n+in mind are:\n \n-mod foo {\n-    // visible here: m1\n+1. the behavior of `$(...)*` is to walk through one \"layer\" of repetitions, for\n+all of the `$name`s it contains, in lockstep, and\n+2. each `$name` must be under at least as many `$(...)*`s as it was matched\n+against. If it is under more, it'll be duplicated, as appropriate.\n \n-    #[macro_export]\n-    macro_rules! m2 { () => (()) }\n+This baroque macro illustrates the duplication of variables from outer\n+repetition levels.\n+\n+```rust\n+macro_rules! o_O {\n+    (\n+        $(\n+            $x:expr; [ $( $y:expr ),* ]\n+        );*\n+    ) => {\n+        &[ $($( $x + $y ),*),* ]\n+    }\n+}\n+\n+fn main() {\n+    let a: &[i32]\n+        = o_O!(10; [1, 2, 3];\n+               20; [4, 5, 6]);\n \n-    // visible here: m1, m2\n+    assert_eq!(a, [11, 12, 13, 24, 25, 26]);\n }\n+```\n \n-// visible here: m1\n+That's most of the matcher syntax. These examples use `$(...)*`, which is a\n+\"zero or more\" match. Alternatively you can write `$(...)+` for a \"one or\n+more\" match. Both forms optionally include a separator, which can be any token\n+except `+` or `*`.\n \n-macro_rules! m3 { () => (()) }\n+# Hygiene\n \n-// visible here: m1, m3\n+Some languages implement macros using simple text substitution, which leads to\n+various problems. For example, this C program prints `13` instead of the\n+expected `25`.\n \n-#[macro_use]\n-mod bar {\n-    // visible here: m1, m3\n+```text\n+#define FIVE_TIMES(x) 5 * x\n \n-    macro_rules! m4 { () => (()) }\n+int main() {\n+    printf(\"%d\\n\", FIVE_TIMES(2 + 3));\n+    return 0;\n+}\n+```\n \n-    // visible here: m1, m3, m4\n+After expansion we have `5 * 2 + 3`, and multiplication has greater precedence\n+than addition. If you've used C macros a lot, you probably know the standard\n+idioms for avoiding this problem, as well as five or six others. In Rust, we\n+don't have to worry about it.\n+\n+```rust\n+macro_rules! five_times {\n+    ($x:expr) => (5 * $x);\n }\n \n-// visible here: m1, m3, m4\n-# fn main() { }\n+fn main() {\n+    assert_eq!(25, five_times!(2 + 3));\n+}\n+```\n+\n+The metavariable `$x` is parsed as a single expression node, and keeps its\n+place in the syntax tree even after substitution.\n+\n+Another common problem in macro systems is *variable capture*. Here's a C\n+macro, using [a GNU C extension] to emulate Rust's expression blocks.\n+\n+[a GNU C extension]: https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html\n+\n+```text\n+#define LOG(msg) ({ \\\n+    int state = get_log_state(); \\\n+    if (state > 0) { \\\n+        printf(\"log(%d): %s\\n\", state, msg); \\\n+    } \\\n+})\n ```\n \n-When this library is loaded with `#[use_macros] extern crate`, only `m2` will\n-be imported.\n+This looks reasonable, but watch what happens in this example:\n \n-The Rust Reference has a [listing of macro-related\n-attributes](../reference.html#macro--and-plugin-related-attributes).\n+```text\n+const char *state = \"reticulating splines\";\n+LOG(state);\n+```\n+\n+The program will likely segfault, after it tries to execute\n \n-# The variable `$crate`\n+```text\n+printf(\"log(%d): %s\\n\", state, state);\n+```\n \n-A further difficulty occurs when a macro is used in multiple crates.  Say that\n-`mylib` defines\n+The equivalent Rust macro has the desired behavior.\n \n ```rust\n-pub fn increment(x: u32) -> u32 {\n-    x + 1\n+# fn get_log_state() -> i32 { 3 }\n+macro_rules! log {\n+    ($msg:expr) => {{\n+        let state: i32 = get_log_state();\n+        if state > 0 {\n+            println!(\"log({}): {}\", state, $msg);\n+        }\n+    }};\n }\n \n-#[macro_export]\n-macro_rules! inc_a {\n-    ($x:expr) => ( ::increment($x) )\n+fn main() {\n+    let state: &str = \"reticulating splines\";\n+    log!(state);\n }\n+```\n+\n+This works because Rust has a [hygienic macro system][]. Each macro expansion\n+happens in a distinct *syntax context*, and each variable is tagged with the\n+syntax context where it was introduced. It's as though the variable `state`\n+inside `main` is painted a different \"color\" from the variable `state` inside\n+the macro, and therefore they don't conflict.\n \n-#[macro_export]\n-macro_rules! inc_b {\n-    ($x:expr) => ( ::mylib::increment($x) )\n+[hygienic macro system]: http://en.wikipedia.org/wiki/Hygienic_macro\n+\n+This also restricts the ability of macros to introduce new bindings at the\n+invocation site. Code such as the following will not work:\n+\n+```rust,ignore\n+macro_rules! foo {\n+    () => (let x = 3);\n+}\n+\n+fn main() {\n+    foo!();\n+    println!(\"{}\", x);\n }\n-# fn main() { }\n ```\n \n-`inc_a` only works within `mylib`, while `inc_b` only works outside the\n-library.  Furthermore, `inc_b` will break if the user imports `mylib` under\n-another name.\n+Instead you need to pass the variable name into the invocation, so it's tagged\n+with the right syntax context.\n \n-Rust does not (yet) have a hygiene system for crate references, but it does\n-provide a simple workaround for this problem.  Within a macro imported from a\n-crate named `foo`, the special macro variable `$crate` will expand to `::foo`.\n-By contrast, when a macro is defined and then used in the same crate, `$crate`\n-will expand to nothing.  This means we can write\n+```rust\n+macro_rules! foo {\n+    ($v:ident) => (let $v = 3);\n+}\n+\n+fn main() {\n+    foo!(x);\n+    println!(\"{}\", x);\n+}\n+```\n+\n+This holds for `let` bindings and loop labels, but not for [items][].\n+So the following code does compile:\n \n ```rust\n-#[macro_export]\n-macro_rules! inc {\n-    ($x:expr) => ( $crate::increment($x) )\n+macro_rules! foo {\n+    () => (fn x() { });\n+}\n+\n+fn main() {\n+    foo!();\n+    x();\n }\n-# fn main() { }\n ```\n \n-to define a single macro that works both inside and outside our library.  The\n-function name will expand to either `::increment` or `::mylib::increment`.\n-\n-To keep this system simple and correct, `#[macro_use] extern crate ...` may\n-only appear at the root of your crate, not inside `mod`.  This ensures that\n-`$crate` is a single identifier.\n-\n-# A final note\n-\n-Macros, as currently implemented, are not for the faint of heart. Even\n-ordinary syntax errors can be more difficult to debug when they occur inside a\n-macro, and errors caused by parse problems in generated code can be very\n-tricky. Invoking the `log_syntax!` macro can help elucidate intermediate\n-states, invoking `trace_macros!(true)` will automatically print those\n-intermediate states out, and passing the flag `--pretty expanded` as a\n-command-line argument to the compiler will show the result of expansion.\n-\n-If Rust's macro system can't do what you need, you may want to write a\n-[compiler plugin](plugins.html) instead. Compared to `macro_rules!`\n-macros, this is significantly more work, the interfaces are much less stable,\n-and the warnings about debugging apply ten-fold. In exchange you get the\n-flexibility of running arbitrary Rust code within the compiler. Syntax\n-extension plugins are sometimes called *procedural macros* for this reason.\n+[items]: ../reference.html#items\n+\n+# Further reading\n+\n+The [advanced macros chapter][] goes into more detail about macro syntax. It\n+also describes how to share macros between different modules or crates.\n+\n+[advanced macros chapter]: advanced-macros.html"}]}