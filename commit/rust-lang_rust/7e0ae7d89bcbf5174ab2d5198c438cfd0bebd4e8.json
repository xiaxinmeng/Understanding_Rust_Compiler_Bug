{"sha": "7e0ae7d89bcbf5174ab2d5198c438cfd0bebd4e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlMGFlN2Q4OWJjYmY1MTc0YWIyZDUxOThjNDM4Y2ZkMGJlYmQ0ZTg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2020-11-20T10:40:33Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2021-08-19T21:28:24Z"}, "message": "introduce a `Diverging` enum instead of a bool", "tree": {"sha": "b86b0584bd5a1ef7b34e468f08cc4b8113c23c93", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b86b0584bd5a1ef7b34e468f08cc4b8113c23c93"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e0ae7d89bcbf5174ab2d5198c438cfd0bebd4e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e0ae7d89bcbf5174ab2d5198c438cfd0bebd4e8", "html_url": "https://github.com/rust-lang/rust/commit/7e0ae7d89bcbf5174ab2d5198c438cfd0bebd4e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e0ae7d89bcbf5174ab2d5198c438cfd0bebd4e8/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1b4824800597f7ce9831ae27dc994badabc40e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1b4824800597f7ce9831ae27dc994badabc40e3", "html_url": "https://github.com/rust-lang/rust/commit/c1b4824800597f7ce9831ae27dc994badabc40e3"}], "stats": {"total": 139, "additions": 78, "deletions": 61}, "files": [{"sha": "79dc1c4bee63a7abf48a8f0f593f3cd9074f3031", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e0ae7d89bcbf5174ab2d5198c438cfd0bebd4e8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e0ae7d89bcbf5174ab2d5198c438cfd0bebd4e8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=7e0ae7d89bcbf5174ab2d5198c438cfd0bebd4e8", "patch": "@@ -22,14 +22,14 @@\n // is also useful to track which value is the \"expected\" value in\n // terms of error reporting.\n \n-use super::equate::Equate;\n use super::glb::Glb;\n use super::lub::Lub;\n use super::sub::Sub;\n use super::type_variable::TypeVariableValue;\n use super::unify_key::replace_if_possible;\n use super::unify_key::{ConstVarValue, ConstVariableValue};\n use super::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n+use super::{equate::Equate, type_variable::Diverging};\n use super::{InferCtxt, MiscVariable, TypeTrace};\n \n use crate::traits::{Obligation, PredicateObligations};\n@@ -643,7 +643,7 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                                 .inner\n                                 .borrow_mut()\n                                 .type_variables()\n-                                .new_var(self.for_universe, false, origin);\n+                                .new_var(self.for_universe, Diverging::NotDiverging, origin);\n                             let u = self.tcx().mk_ty_var(new_var_id);\n                             debug!(\"generalize: replacing original vid={:?} with new={:?}\", vid, u);\n                             Ok(u)\n@@ -881,7 +881,7 @@ impl TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n                             *self.infcx.inner.borrow_mut().type_variables().var_origin(vid);\n                         let new_var_id = self.infcx.inner.borrow_mut().type_variables().new_var(\n                             self.for_universe,\n-                            false,\n+                            Diverging::NotDiverging,\n                             origin,\n                         );\n                         let u = self.tcx().mk_ty_var(new_var_id);"}, {"sha": "26bee3596e3dd2a2ebd66a277d92edc4f29ecf4c", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7e0ae7d89bcbf5174ab2d5198c438cfd0bebd4e8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e0ae7d89bcbf5174ab2d5198c438cfd0bebd4e8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=7e0ae7d89bcbf5174ab2d5198c438cfd0bebd4e8", "patch": "@@ -46,7 +46,7 @@ use self::region_constraints::{GenericKind, RegionConstraintData, VarInfos, Veri\n use self::region_constraints::{\n     RegionConstraintCollector, RegionConstraintStorage, RegionSnapshot,\n };\n-use self::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use self::type_variable::{Diverging, TypeVariableOrigin, TypeVariableOriginKind};\n \n pub mod at;\n pub mod canonical;\n@@ -679,10 +679,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         t.fold_with(&mut self.freshener())\n     }\n \n-    pub fn type_var_diverges(&'a self, ty: Ty<'_>) -> bool {\n+    pub fn type_var_diverges(&'a self, ty: Ty<'_>) -> Diverging {\n         match *ty.kind() {\n             ty::Infer(ty::TyVar(vid)) => self.inner.borrow_mut().type_variables().var_diverges(vid),\n-            _ => false,\n+            _ => Diverging::NotDiverging,\n         }\n     }\n \n@@ -1020,25 +1020,29 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         })\n     }\n \n-    pub fn next_ty_var_id(&self, diverging: bool, origin: TypeVariableOrigin) -> TyVid {\n+    pub fn next_ty_var_id(&self, diverging: Diverging, origin: TypeVariableOrigin) -> TyVid {\n         self.inner.borrow_mut().type_variables().new_var(self.universe(), diverging, origin)\n     }\n \n     pub fn next_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n-        self.tcx.mk_ty_var(self.next_ty_var_id(false, origin))\n+        self.tcx.mk_ty_var(self.next_ty_var_id(Diverging::NotDiverging, origin))\n     }\n \n     pub fn next_ty_var_in_universe(\n         &self,\n         origin: TypeVariableOrigin,\n         universe: ty::UniverseIndex,\n     ) -> Ty<'tcx> {\n-        let vid = self.inner.borrow_mut().type_variables().new_var(universe, false, origin);\n+        let vid = self.inner.borrow_mut().type_variables().new_var(\n+            universe,\n+            Diverging::NotDiverging,\n+            origin,\n+        );\n         self.tcx.mk_ty_var(vid)\n     }\n \n     pub fn next_diverging_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n-        self.tcx.mk_ty_var(self.next_ty_var_id(true, origin))\n+        self.tcx.mk_ty_var(self.next_ty_var_id(Diverging::Diverges, origin))\n     }\n \n     pub fn next_const_var(\n@@ -1152,7 +1156,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 // as the substitutions for the default, `(T, U)`.\n                 let ty_var_id = self.inner.borrow_mut().type_variables().new_var(\n                     self.universe(),\n-                    false,\n+                    Diverging::NotDiverging,\n                     TypeVariableOrigin {\n                         kind: TypeVariableOriginKind::TypeParameterDefinition(\n                             param.name,"}, {"sha": "261c3471a9829bb7d8f8b69c1140171700047165", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e0ae7d89bcbf5174ab2d5198c438cfd0bebd4e8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e0ae7d89bcbf5174ab2d5198c438cfd0bebd4e8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=7e0ae7d89bcbf5174ab2d5198c438cfd0bebd4e8", "patch": "@@ -22,6 +22,7 @@\n //!   constituents)\n \n use crate::infer::combine::ConstEquateRelation;\n+use crate::infer::type_variable::Diverging;\n use crate::infer::InferCtxt;\n use crate::infer::{ConstVarValue, ConstVariableValue};\n use rustc_data_structures::fx::FxHashMap;\n@@ -920,7 +921,8 @@ where\n                             // Replacing with a new variable in the universe `self.universe`,\n                             // it will be unified later with the original type variable in\n                             // the universe `_universe`.\n-                            let new_var_id = variables.new_var(self.universe, false, origin);\n+                            let new_var_id =\n+                                variables.new_var(self.universe, Diverging::NotDiverging, origin);\n \n                             let u = self.tcx().mk_ty_var(new_var_id);\n                             debug!(\"generalize: replacing original vid={:?} with new={:?}\", vid, u);"}, {"sha": "42e2a0c858698ac0e7a4b7597fc50cdcd9a3cf34", "filename": "compiler/rustc_infer/src/infer/type_variable.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7e0ae7d89bcbf5174ab2d5198c438cfd0bebd4e8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e0ae7d89bcbf5174ab2d5198c438cfd0bebd4e8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs?ref=7e0ae7d89bcbf5174ab2d5198c438cfd0bebd4e8", "patch": "@@ -119,7 +119,13 @@ pub enum TypeVariableOriginKind {\n \n pub(crate) struct TypeVariableData {\n     origin: TypeVariableOrigin,\n-    diverging: bool,\n+    diverging: Diverging,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum Diverging {\n+    NotDiverging,\n+    Diverges,\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -173,7 +179,7 @@ impl<'tcx> TypeVariableTable<'_, 'tcx> {\n     ///\n     /// Note that this function does not return care whether\n     /// `vid` has been unified with something else or not.\n-    pub fn var_diverges(&self, vid: ty::TyVid) -> bool {\n+    pub fn var_diverges(&self, vid: ty::TyVid) -> Diverging {\n         self.storage.values.get(vid.index as usize).diverging\n     }\n \n@@ -238,7 +244,7 @@ impl<'tcx> TypeVariableTable<'_, 'tcx> {\n     pub fn new_var(\n         &mut self,\n         universe: ty::UniverseIndex,\n-        diverging: bool,\n+        diverging: Diverging,\n         origin: TypeVariableOrigin,\n     ) -> ty::TyVid {\n         let eq_key = self.eq_relations().new_key(TypeVariableValue::Unknown { universe });"}, {"sha": "9405b64260c4d60bf339f4b06ee71337e59fda9c", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 51, "deletions": 46, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/7e0ae7d89bcbf5174ab2d5198c438cfd0bebd4e8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e0ae7d89bcbf5174ab2d5198c438cfd0bebd4e8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=7e0ae7d89bcbf5174ab2d5198c438cfd0bebd4e8", "patch": "@@ -17,6 +17,7 @@ use rustc_hir::lang_items::LangItem;\n use rustc_hir::{ExprKind, GenericArg, Node, QPath, TyKind};\n use rustc_infer::infer::canonical::{Canonical, OriginalQueryValues, QueryResponse};\n use rustc_infer::infer::error_reporting::TypeAnnotationNeeded::E0282;\n+use rustc_infer::infer::type_variable::Diverging;\n use rustc_infer::infer::{InferOk, InferResult};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n use rustc_middle::ty::fold::TypeFoldable;\n@@ -656,56 +657,60 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             _ if self.is_tainted_by_errors() => self.tcx().ty_error(),\n             UnconstrainedInt => self.tcx.types.i32,\n             UnconstrainedFloat => self.tcx.types.f64,\n-            Neither if self.type_var_diverges(ty) => self.tcx.mk_diverging_default(),\n-            Neither => {\n-                // This type variable was created from the instantiation of an opaque\n-                // type. The fact that we're attempting to perform fallback for it\n-                // means that the function neither constrained it to a concrete\n-                // type, nor to the opaque type itself.\n-                //\n-                // For example, in this code:\n-                //\n-                //```\n-                // type MyType = impl Copy;\n-                // fn defining_use() -> MyType { true }\n-                // fn other_use() -> MyType { defining_use() }\n-                // ```\n-                //\n-                // `defining_use` will constrain the instantiated inference\n-                // variable to `bool`, while `other_use` will constrain\n-                // the instantiated inference variable to `MyType`.\n-                //\n-                // When we process opaque types during writeback, we\n-                // will handle cases like `other_use`, and not count\n-                // them as defining usages\n-                //\n-                // However, we also need to handle cases like this:\n-                //\n-                // ```rust\n-                // pub type Foo = impl Copy;\n-                // fn produce() -> Option<Foo> {\n-                //     None\n-                //  }\n-                //  ```\n-                //\n-                // In the above snippet, the inference variable created by\n-                // instantiating `Option<Foo>` will be completely unconstrained.\n-                // We treat this as a non-defining use by making the inference\n-                // variable fall back to the opaque type itself.\n-                if let FallbackMode::All = mode {\n-                    if let Some(opaque_ty) = self.infcx.inner.borrow().opaque_types_vars.get(ty) {\n-                        debug!(\n-                            \"fallback_if_possible: falling back opaque type var {:?} to {:?}\",\n-                            ty, opaque_ty\n-                        );\n-                        *opaque_ty\n+            Neither => match self.type_var_diverges(ty) {\n+                Diverging::Diverges => self.tcx.mk_diverging_default(),\n+\n+                Diverging::NotDiverging => {\n+                    // This type variable was created from the instantiation of an opaque\n+                    // type. The fact that we're attempting to perform fallback for it\n+                    // means that the function neither constrained it to a concrete\n+                    // type, nor to the opaque type itself.\n+                    //\n+                    // For example, in this code:\n+                    //\n+                    //```\n+                    // type MyType = impl Copy;\n+                    // fn defining_use() -> MyType { true }\n+                    // fn other_use() -> MyType { defining_use() }\n+                    // ```\n+                    //\n+                    // `defining_use` will constrain the instantiated inference\n+                    // variable to `bool`, while `other_use` will constrain\n+                    // the instantiated inference variable to `MyType`.\n+                    //\n+                    // When we process opaque types during writeback, we\n+                    // will handle cases like `other_use`, and not count\n+                    // them as defining usages\n+                    //\n+                    // However, we also need to handle cases like this:\n+                    //\n+                    // ```rust\n+                    // pub type Foo = impl Copy;\n+                    // fn produce() -> Option<Foo> {\n+                    //     None\n+                    //  }\n+                    //  ```\n+                    //\n+                    // In the above snippet, the inference variable created by\n+                    // instantiating `Option<Foo>` will be completely unconstrained.\n+                    // We treat this as a non-defining use by making the inference\n+                    // variable fall back to the opaque type itself.\n+                    if let FallbackMode::All = mode {\n+                        if let Some(opaque_ty) = self.infcx.inner.borrow().opaque_types_vars.get(ty)\n+                        {\n+                            debug!(\n+                                \"fallback_if_possible: falling back opaque type var {:?} to {:?}\",\n+                                ty, opaque_ty\n+                            );\n+                            *opaque_ty\n+                        } else {\n+                            return false;\n+                        }\n                     } else {\n                         return false;\n                     }\n-                } else {\n-                    return false;\n                 }\n-            }\n+            },\n         };\n         debug!(\"fallback_if_possible: defaulting `{:?}` to `{:?}`\", ty, fallback);\n         self.demand_eqtype(rustc_span::DUMMY_SP, ty, fallback);"}]}