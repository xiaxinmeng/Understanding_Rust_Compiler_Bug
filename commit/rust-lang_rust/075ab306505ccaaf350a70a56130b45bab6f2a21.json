{"sha": "075ab306505ccaaf350a70a56130b45bab6f2a21", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3NWFiMzA2NTA1Y2NhYWYzNTBhNzBhNTYxMzBiNDViYWI2ZjJhMjE=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-04-17T12:06:25Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-04-22T16:06:54Z"}, "message": "rustc: de-@ metadata::cstore.", "tree": {"sha": "cea1e02dcfecd2e966303f60f61d7b888681930e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cea1e02dcfecd2e966303f60f61d7b888681930e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/075ab306505ccaaf350a70a56130b45bab6f2a21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/075ab306505ccaaf350a70a56130b45bab6f2a21", "html_url": "https://github.com/rust-lang/rust/commit/075ab306505ccaaf350a70a56130b45bab6f2a21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/075ab306505ccaaf350a70a56130b45bab6f2a21/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa33012b71de68f5fe2fac0e19a3d467ea1b5727", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa33012b71de68f5fe2fac0e19a3d467ea1b5727", "html_url": "https://github.com/rust-lang/rust/commit/fa33012b71de68f5fe2fac0e19a3d467ea1b5727"}], "stats": {"total": 156, "additions": 83, "deletions": 73}, "files": [{"sha": "efbfce1b2bb86c197314d96cc6f3219d2d28be02", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/075ab306505ccaaf350a70a56130b45bab6f2a21/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/075ab306505ccaaf350a70a56130b45bab6f2a21/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=075ab306505ccaaf350a70a56130b45bab6f2a21", "patch": "@@ -279,7 +279,7 @@ fn resolve_crate<'a>(e: &mut Env,\n                      hash: Option<&Svh>,\n                      should_link: bool,\n                      span: Span)\n-                     -> (ast::CrateNum, @cstore::crate_metadata,\n+                     -> (ast::CrateNum, Rc<cstore::crate_metadata>,\n                          cstore::CrateSource) {\n     match existing_match(e, crate_id, hash) {\n         None => {\n@@ -330,13 +330,13 @@ fn resolve_crate<'a>(e: &mut Env,\n                 -1\n             };\n \n-            let cmeta = @cstore::crate_metadata {\n+            let cmeta = Rc::new(cstore::crate_metadata {\n                 name: load_ctxt.crate_id.name.to_owned(),\n                 data: metadata,\n                 cnum_map: cnum_map,\n                 cnum: cnum,\n                 span: span,\n-            };\n+            });\n \n             let source = cstore::CrateSource {\n                 dylib: dylib,\n@@ -345,7 +345,7 @@ fn resolve_crate<'a>(e: &mut Env,\n             };\n \n             if should_link {\n-                e.sess.cstore.set_crate_data(cnum, cmeta);\n+                e.sess.cstore.set_crate_data(cnum, cmeta.clone());\n                 e.sess.cstore.add_used_crate_source(source.clone());\n             }\n             (cnum, cmeta, source)\n@@ -402,8 +402,8 @@ impl<'a> CrateLoader for Loader<'a> {\n                                                info.ident, &info.crate_id,\n                                                None, info.should_link,\n                                                krate.span);\n-        let macros = decoder::get_exported_macros(data);\n-        let registrar = decoder::get_macro_registrar_fn(data).map(|id| {\n+        let macros = decoder::get_exported_macros(&*data);\n+        let registrar = decoder::get_macro_registrar_fn(&*data).map(|id| {\n             decoder::get_symbol(data.data.as_slice(), id)\n         });\n         MacroCrate {"}, {"sha": "61caa0cf499b12b922eed60d93aa8ca1e624c321", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/075ab306505ccaaf350a70a56130b45bab6f2a21/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/075ab306505ccaaf350a70a56130b45bab6f2a21/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=075ab306505ccaaf350a70a56130b45bab6f2a21", "patch": "@@ -33,8 +33,8 @@ pub struct StaticMethodInfo {\n }\n \n pub fn get_symbol(cstore: &cstore::CStore, def: ast::DefId) -> ~str {\n-    let cdata = cstore.get_crate_data(def.krate).data();\n-    return decoder::get_symbol(cdata, def.node);\n+    let cdata = cstore.get_crate_data(def.krate);\n+    decoder::get_symbol(cdata.data(), def.node)\n }\n \n /// Iterates over all the language items in the given crate.\n@@ -43,7 +43,7 @@ pub fn each_lang_item(cstore: &cstore::CStore,\n                       f: |ast::NodeId, uint| -> bool)\n                       -> bool {\n     let crate_data = cstore.get_crate_data(cnum);\n-    decoder::each_lang_item(crate_data, f)\n+    decoder::each_lang_item(&*crate_data, f)\n }\n \n /// Iterates over each child of the given item.\n@@ -57,7 +57,7 @@ pub fn each_child_of_item(cstore: &cstore::CStore,\n         cstore.get_crate_data(cnum)\n     };\n     decoder::each_child_of_item(cstore.intr.clone(),\n-                                crate_data,\n+                                &*crate_data,\n                                 def_id.node,\n                                 get_crate_data,\n                                 callback)\n@@ -74,15 +74,15 @@ pub fn each_top_level_item_of_crate(cstore: &cstore::CStore,\n         cstore.get_crate_data(cnum)\n     };\n     decoder::each_top_level_item_of_crate(cstore.intr.clone(),\n-                                          crate_data,\n+                                          &*crate_data,\n                                           get_crate_data,\n                                           callback)\n }\n \n pub fn get_item_path(tcx: &ty::ctxt, def: ast::DefId) -> Vec<ast_map::PathElem> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    let path = decoder::get_item_path(cdata, def.node);\n+    let path = decoder::get_item_path(&*cdata, def.node);\n \n     // FIXME #1920: This path is not always correct if the crate is not linked\n     // into the root namespace.\n@@ -103,101 +103,101 @@ pub fn maybe_get_item_ast(tcx: &ty::ctxt, def: ast::DefId,\n                        -> found_ast {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::maybe_get_item_ast(cdata, tcx, def.node, decode_inlined_item)\n+    decoder::maybe_get_item_ast(&*cdata, tcx, def.node, decode_inlined_item)\n }\n \n pub fn get_enum_variants(tcx: &ty::ctxt, def: ast::DefId)\n                       -> Vec<@ty::VariantInfo> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    return decoder::get_enum_variants(cstore.intr.clone(), cdata, def.node, tcx)\n+    return decoder::get_enum_variants(cstore.intr.clone(), &*cdata, def.node, tcx)\n }\n \n /// Returns information about the given implementation.\n pub fn get_impl(tcx: &ty::ctxt, impl_def_id: ast::DefId)\n                 -> ty::Impl {\n     let cdata = tcx.sess.cstore.get_crate_data(impl_def_id.krate);\n-    decoder::get_impl(tcx.sess.cstore.intr.clone(), cdata, impl_def_id.node, tcx)\n+    decoder::get_impl(tcx.sess.cstore.intr.clone(), &*cdata, impl_def_id.node, tcx)\n }\n \n pub fn get_method(tcx: &ty::ctxt, def: ast::DefId) -> ty::Method {\n     let cdata = tcx.sess.cstore.get_crate_data(def.krate);\n-    decoder::get_method(tcx.sess.cstore.intr.clone(), cdata, def.node, tcx)\n+    decoder::get_method(tcx.sess.cstore.intr.clone(), &*cdata, def.node, tcx)\n }\n \n pub fn get_method_name_and_explicit_self(cstore: &cstore::CStore,\n                                          def: ast::DefId)\n                                      -> (ast::Ident, ast::ExplicitSelf_)\n {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_method_name_and_explicit_self(cstore.intr.clone(), cdata, def.node)\n+    decoder::get_method_name_and_explicit_self(cstore.intr.clone(), &*cdata, def.node)\n }\n \n pub fn get_trait_method_def_ids(cstore: &cstore::CStore,\n                                 def: ast::DefId) -> Vec<ast::DefId> {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_trait_method_def_ids(cdata, def.node)\n+    decoder::get_trait_method_def_ids(&*cdata, def.node)\n }\n \n pub fn get_item_variances(cstore: &cstore::CStore,\n                           def: ast::DefId) -> ty::ItemVariances {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_item_variances(cdata, def.node)\n+    decoder::get_item_variances(&*cdata, def.node)\n }\n \n pub fn get_provided_trait_methods(tcx: &ty::ctxt,\n                                   def: ast::DefId)\n                                -> Vec<@ty::Method> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_provided_trait_methods(cstore.intr.clone(), cdata, def.node, tcx)\n+    decoder::get_provided_trait_methods(cstore.intr.clone(), &*cdata, def.node, tcx)\n }\n \n pub fn get_supertraits(tcx: &ty::ctxt, def: ast::DefId) -> Vec<@ty::TraitRef> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_supertraits(cdata, def.node, tcx)\n+    decoder::get_supertraits(&*cdata, def.node, tcx)\n }\n \n pub fn get_type_name_if_impl(cstore: &cstore::CStore, def: ast::DefId)\n                           -> Option<ast::Ident> {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_type_name_if_impl(cdata, def.node)\n+    decoder::get_type_name_if_impl(&*cdata, def.node)\n }\n \n pub fn get_static_methods_if_impl(cstore: &cstore::CStore,\n                                   def: ast::DefId)\n                                -> Option<Vec<StaticMethodInfo> > {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_static_methods_if_impl(cstore.intr.clone(), cdata, def.node)\n+    decoder::get_static_methods_if_impl(cstore.intr.clone(), &*cdata, def.node)\n }\n \n pub fn get_item_attrs(cstore: &cstore::CStore,\n                       def_id: ast::DefId,\n                       f: |Vec<@ast::MetaItem> |) {\n     let cdata = cstore.get_crate_data(def_id.krate);\n-    decoder::get_item_attrs(cdata, def_id.node, f)\n+    decoder::get_item_attrs(&*cdata, def_id.node, f)\n }\n \n pub fn get_struct_fields(cstore: &cstore::CStore,\n                          def: ast::DefId)\n                       -> Vec<ty::field_ty> {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_struct_fields(cstore.intr.clone(), cdata, def.node)\n+    decoder::get_struct_fields(cstore.intr.clone(), &*cdata, def.node)\n }\n \n pub fn get_type(tcx: &ty::ctxt,\n                 def: ast::DefId)\n              -> ty::ty_param_bounds_and_ty {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_type(cdata, def.node, tcx)\n+    decoder::get_type(&*cdata, def.node, tcx)\n }\n \n pub fn get_trait_def(tcx: &ty::ctxt, def: ast::DefId) -> ty::TraitDef {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_trait_def(cdata, def.node, tcx)\n+    decoder::get_trait_def(&*cdata, def.node, tcx)\n }\n \n pub fn get_field_type(tcx: &ty::ctxt, class_id: ast::DefId,\n@@ -213,7 +213,7 @@ pub fn get_field_type(tcx: &ty::ctxt, class_id: ast::DefId,\n         decoder::maybe_find_item(def.node, class_doc),\n         || format!(\"get_field_type: in class {:?}, field ID {:?} not found\",\n                  class_id, def) );\n-    let ty = decoder::item_type(def, the_field, tcx, cdata);\n+    let ty = decoder::item_type(def, the_field, tcx, &*cdata);\n     ty::ty_param_bounds_and_ty {\n         generics: ty::Generics {type_param_defs: Rc::new(Vec::new()),\n                                 region_param_defs: Rc::new(Vec::new())},\n@@ -227,43 +227,43 @@ pub fn get_impl_trait(tcx: &ty::ctxt,\n                       def: ast::DefId) -> Option<@ty::TraitRef> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_impl_trait(cdata, def.node, tcx)\n+    decoder::get_impl_trait(&*cdata, def.node, tcx)\n }\n \n // Given a def_id for an impl, return information about its vtables\n pub fn get_impl_vtables(tcx: &ty::ctxt,\n                         def: ast::DefId) -> typeck::impl_res {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_impl_vtables(cdata, def.node, tcx)\n+    decoder::get_impl_vtables(&*cdata, def.node, tcx)\n }\n \n pub fn get_native_libraries(cstore: &cstore::CStore,\n                             crate_num: ast::CrateNum)\n                                 -> Vec<(cstore::NativeLibaryKind, ~str)> {\n     let cdata = cstore.get_crate_data(crate_num);\n-    decoder::get_native_libraries(cdata)\n+    decoder::get_native_libraries(&*cdata)\n }\n \n pub fn each_impl(cstore: &cstore::CStore,\n                  crate_num: ast::CrateNum,\n                  callback: |ast::DefId|) {\n     let cdata = cstore.get_crate_data(crate_num);\n-    decoder::each_impl(cdata, callback)\n+    decoder::each_impl(&*cdata, callback)\n }\n \n pub fn each_implementation_for_type(cstore: &cstore::CStore,\n                                     def_id: ast::DefId,\n                                     callback: |ast::DefId|) {\n     let cdata = cstore.get_crate_data(def_id.krate);\n-    decoder::each_implementation_for_type(cdata, def_id.node, callback)\n+    decoder::each_implementation_for_type(&*cdata, def_id.node, callback)\n }\n \n pub fn each_implementation_for_trait(cstore: &cstore::CStore,\n                                      def_id: ast::DefId,\n                                      callback: |ast::DefId|) {\n     let cdata = cstore.get_crate_data(def_id.krate);\n-    decoder::each_implementation_for_trait(cdata, def_id.node, callback)\n+    decoder::each_implementation_for_trait(&*cdata, def_id.node, callback)\n }\n \n /// If the given def ID describes a method belonging to a trait (either a\n@@ -274,27 +274,27 @@ pub fn get_trait_of_method(cstore: &cstore::CStore,\n                            tcx: &ty::ctxt)\n                            -> Option<ast::DefId> {\n     let cdata = cstore.get_crate_data(def_id.krate);\n-    decoder::get_trait_of_method(cdata, def_id.node, tcx)\n+    decoder::get_trait_of_method(&*cdata, def_id.node, tcx)\n }\n \n pub fn get_macro_registrar_fn(cstore: &cstore::CStore,\n                               crate_num: ast::CrateNum)\n                               -> Option<ast::NodeId> {\n     let cdata = cstore.get_crate_data(crate_num);\n-    decoder::get_macro_registrar_fn(cdata)\n+    decoder::get_macro_registrar_fn(&*cdata)\n }\n \n pub fn get_exported_macros(cstore: &cstore::CStore,\n                            crate_num: ast::CrateNum)\n                            -> Vec<~str> {\n     let cdata = cstore.get_crate_data(crate_num);\n-    decoder::get_exported_macros(cdata)\n+    decoder::get_exported_macros(&*cdata)\n }\n \n pub fn get_tuple_struct_definition_if_ctor(cstore: &cstore::CStore,\n                                            def_id: ast::DefId)\n     -> Option<ast::DefId>\n {\n     let cdata = cstore.get_crate_data(def_id.krate);\n-    decoder::get_tuple_struct_definition_if_ctor(cdata, def_id.node)\n+    decoder::get_tuple_struct_definition_if_ctor(&*cdata, def_id.node)\n }"}, {"sha": "8e731a98dd7e70abf92b82e62ca490ae6abd1212", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/075ab306505ccaaf350a70a56130b45bab6f2a21/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/075ab306505ccaaf350a70a56130b45bab6f2a21/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=075ab306505ccaaf350a70a56130b45bab6f2a21", "patch": "@@ -68,7 +68,7 @@ pub struct CrateSource {\n }\n \n pub struct CStore {\n-    metas: RefCell<HashMap<ast::CrateNum, @crate_metadata>>,\n+    metas: RefCell<HashMap<ast::CrateNum, Rc<crate_metadata>>>,\n     extern_mod_crate_map: RefCell<extern_mod_crate_map>,\n     used_crate_sources: RefCell<Vec<CrateSource>>,\n     used_libraries: RefCell<Vec<(~str, NativeLibaryKind)>>,\n@@ -95,22 +95,22 @@ impl CStore {\n         self.metas.borrow().len() as ast::CrateNum + 1\n     }\n \n-    pub fn get_crate_data(&self, cnum: ast::CrateNum) -> @crate_metadata {\n-        *self.metas.borrow().get(&cnum)\n+    pub fn get_crate_data(&self, cnum: ast::CrateNum) -> Rc<crate_metadata> {\n+        self.metas.borrow().get(&cnum).clone()\n     }\n \n     pub fn get_crate_hash(&self, cnum: ast::CrateNum) -> Svh {\n         let cdata = self.get_crate_data(cnum);\n         decoder::get_crate_hash(cdata.data())\n     }\n \n-    pub fn set_crate_data(&self, cnum: ast::CrateNum, data: @crate_metadata) {\n+    pub fn set_crate_data(&self, cnum: ast::CrateNum, data: Rc<crate_metadata>) {\n         self.metas.borrow_mut().insert(cnum, data);\n     }\n \n-    pub fn iter_crate_data(&self, i: |ast::CrateNum, @crate_metadata|) {\n-        for (&k, &v) in self.metas.borrow().iter() {\n-            i(k, v);\n+    pub fn iter_crate_data(&self, i: |ast::CrateNum, &crate_metadata|) {\n+        for (&k, v) in self.metas.borrow().iter() {\n+            i(k, &**v);\n         }\n     }\n "}, {"sha": "9751ca3615fc7750ab08738bb61f491175404fb7", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/075ab306505ccaaf350a70a56130b45bab6f2a21/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/075ab306505ccaaf350a70a56130b45bab6f2a21/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=075ab306505ccaaf350a70a56130b45bab6f2a21", "patch": "@@ -45,7 +45,7 @@ use syntax::ast;\n use syntax::codemap;\n use syntax::crateid::CrateId;\n \n-pub type Cmd = @crate_metadata;\n+pub type Cmd<'a> = &'a crate_metadata;\n \n // A function that takes a def_id relative to the crate being searched and\n // returns a def_id relative to the compilation environment, i.e. if we hit a\n@@ -76,8 +76,6 @@ fn lookup_hash<'a>(d: ebml::Doc<'a>, eq_fn: |&[u8]| -> bool,\n     ret\n }\n \n-pub type GetCrateDataCb<'a> = |ast::CrateNum|: 'a -> Cmd;\n-\n pub fn maybe_find_item<'a>(item_id: ast::NodeId,\n                            items: ebml::Doc<'a>) -> Option<ebml::Doc<'a>> {\n     fn eq_item(bytes: &[u8], item_id: ast::NodeId) -> bool {\n@@ -462,6 +460,8 @@ pub fn each_lang_item(cdata: Cmd, f: |ast::NodeId, uint| -> bool) -> bool {\n     })\n }\n \n+pub type GetCrateDataCb<'a> = |ast::CrateNum|: 'a -> Rc<crate_metadata>;\n+\n fn each_child_of_item_or_crate(intr: Rc<IdentInterner>,\n                                cdata: Cmd,\n                                item_doc: ebml::Doc,\n@@ -477,13 +477,18 @@ fn each_child_of_item_or_crate(intr: Rc<IdentInterner>,\n \n         // This item may be in yet another crate if it was the child of a\n         // reexport.\n-        let other_crates_items = if child_def_id.krate == cdata.cnum {\n-            reader::get_doc(reader::Doc(cdata.data()), tag_items)\n+        let crate_data = if child_def_id.krate == cdata.cnum {\n+            None\n         } else {\n-            let crate_data = get_crate_data(child_def_id.krate);\n-            reader::get_doc(reader::Doc(crate_data.data()), tag_items)\n+            Some(get_crate_data(child_def_id.krate))\n+        };\n+        let crate_data = match crate_data {\n+            Some(ref cdata) => &**cdata,\n+            None => cdata\n         };\n \n+        let other_crates_items = reader::get_doc(reader::Doc(crate_data.data()), tag_items);\n+\n         // Get the item.\n         match maybe_find_item(child_def_id.node, other_crates_items) {\n             None => {}\n@@ -565,13 +570,18 @@ fn each_child_of_item_or_crate(intr: Rc<IdentInterner>,\n         let name = name_doc.as_str_slice();\n \n         // This reexport may be in yet another crate.\n-        let other_crates_items = if child_def_id.krate == cdata.cnum {\n-            reader::get_doc(reader::Doc(cdata.data()), tag_items)\n+        let crate_data = if child_def_id.krate == cdata.cnum {\n+            None\n         } else {\n-            let crate_data = get_crate_data(child_def_id.krate);\n-            reader::get_doc(reader::Doc(crate_data.data()), tag_items)\n+            Some(get_crate_data(child_def_id.krate))\n+        };\n+        let crate_data = match crate_data {\n+            Some(ref cdata) => &**cdata,\n+            None => cdata\n         };\n \n+        let other_crates_items = reader::get_doc(reader::Doc(crate_data.data()), tag_items);\n+\n         // Get the item.\n         match maybe_find_item(child_def_id.node, other_crates_items) {\n             None => {}\n@@ -634,7 +644,7 @@ pub fn get_item_path(cdata: Cmd, id: ast::NodeId) -> Vec<ast_map::PathElem> {\n     item_path(lookup_item(id, cdata.data()))\n }\n \n-pub type DecodeInlinedItem<'a> = |cdata: @cstore::crate_metadata,\n+pub type DecodeInlinedItem<'a> = |cdata: Cmd,\n                                   tcx: &ty::ctxt,\n                                   path: Vec<ast_map::PathElem>,\n                                   par_doc: ebml::Doc|: 'a"}, {"sha": "08133a8b69e40f76af295438ad5663b649674000", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/075ab306505ccaaf350a70a56130b45bab6f2a21/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/075ab306505ccaaf350a70a56130b45bab6f2a21/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=075ab306505ccaaf350a70a56130b45bab6f2a21", "patch": "@@ -59,7 +59,7 @@ pub struct Maps {\n }\n \n struct DecodeContext<'a> {\n-    cdata: @cstore::crate_metadata,\n+    cdata: &'a cstore::crate_metadata,\n     tcx: &'a ty::ctxt,\n     maps: &'a Maps\n }\n@@ -110,7 +110,7 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n            ebml_w.writer.tell());\n }\n \n-pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n+pub fn decode_inlined_item(cdata: &cstore::crate_metadata,\n                            tcx: &ty::ctxt,\n                            maps: &Maps,\n                            path: Vec<ast_map::PathElem>,\n@@ -271,7 +271,7 @@ impl<S:serialize::Encoder<E>, E> def_id_encoder_helpers for S {\n trait def_id_decoder_helpers {\n     fn read_def_id(&mut self, xcx: &ExtendedDecodeContext) -> ast::DefId;\n     fn read_def_id_noxcx(&mut self,\n-                         cdata: @cstore::crate_metadata) -> ast::DefId;\n+                         cdata: &cstore::crate_metadata) -> ast::DefId;\n }\n \n impl<D:serialize::Decoder<E>, E> def_id_decoder_helpers for D {\n@@ -281,7 +281,7 @@ impl<D:serialize::Decoder<E>, E> def_id_decoder_helpers for D {\n     }\n \n     fn read_def_id_noxcx(&mut self,\n-                         cdata: @cstore::crate_metadata) -> ast::DefId {\n+                         cdata: &cstore::crate_metadata) -> ast::DefId {\n         let did: ast::DefId = Decodable::decode(self).ok().unwrap();\n         decoder::translate_def_id(cdata, did)\n     }\n@@ -725,23 +725,23 @@ pub fn encode_vtable_origin(ecx: &e::EncodeContext,\n pub trait vtable_decoder_helpers {\n     fn read_vtable_res_with_key(&mut self,\n                                 tcx: &ty::ctxt,\n-                                cdata: @cstore::crate_metadata)\n+                                cdata: &cstore::crate_metadata)\n                                 -> (u32, typeck::vtable_res);\n     fn read_vtable_res(&mut self,\n-                       tcx: &ty::ctxt, cdata: @cstore::crate_metadata)\n+                       tcx: &ty::ctxt, cdata: &cstore::crate_metadata)\n                       -> typeck::vtable_res;\n     fn read_vtable_param_res(&mut self,\n-                       tcx: &ty::ctxt, cdata: @cstore::crate_metadata)\n+                       tcx: &ty::ctxt, cdata: &cstore::crate_metadata)\n                       -> typeck::vtable_param_res;\n     fn read_vtable_origin(&mut self,\n-                          tcx: &ty::ctxt, cdata: @cstore::crate_metadata)\n+                          tcx: &ty::ctxt, cdata: &cstore::crate_metadata)\n                           -> typeck::vtable_origin;\n }\n \n impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n     fn read_vtable_res_with_key(&mut self,\n                                 tcx: &ty::ctxt,\n-                                cdata: @cstore::crate_metadata)\n+                                cdata: &cstore::crate_metadata)\n                                 -> (u32, typeck::vtable_res) {\n         self.read_struct(\"VtableWithKey\", 2, |this| {\n             let autoderef = this.read_struct_field(\"autoderef\", 0, |this| {\n@@ -754,21 +754,21 @@ impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n     }\n \n     fn read_vtable_res(&mut self,\n-                       tcx: &ty::ctxt, cdata: @cstore::crate_metadata)\n+                       tcx: &ty::ctxt, cdata: &cstore::crate_metadata)\n                       -> typeck::vtable_res {\n         self.read_to_vec(|this| Ok(this.read_vtable_param_res(tcx, cdata)))\n              .unwrap().move_iter().collect()\n     }\n \n     fn read_vtable_param_res(&mut self,\n-                             tcx: &ty::ctxt, cdata: @cstore::crate_metadata)\n+                             tcx: &ty::ctxt, cdata: &cstore::crate_metadata)\n                       -> typeck::vtable_param_res {\n         self.read_to_vec(|this| Ok(this.read_vtable_origin(tcx, cdata)))\n              .unwrap().move_iter().collect()\n     }\n \n     fn read_vtable_origin(&mut self,\n-                          tcx: &ty::ctxt, cdata: @cstore::crate_metadata)\n+                          tcx: &ty::ctxt, cdata: &cstore::crate_metadata)\n         -> typeck::vtable_origin {\n         self.read_enum(\"vtable_origin\", |this| {\n             this.read_enum_variant([\"vtable_static\",\n@@ -1140,15 +1140,15 @@ trait ebml_decoder_decoder_helpers {\n     // Versions of the type reading functions that don't need the full\n     // ExtendedDecodeContext.\n     fn read_ty_noxcx(&mut self,\n-                     tcx: &ty::ctxt, cdata: @cstore::crate_metadata) -> ty::t;\n+                     tcx: &ty::ctxt, cdata: &cstore::crate_metadata) -> ty::t;\n     fn read_tys_noxcx(&mut self,\n                       tcx: &ty::ctxt,\n-                      cdata: @cstore::crate_metadata) -> Vec<ty::t>;\n+                      cdata: &cstore::crate_metadata) -> Vec<ty::t>;\n }\n \n impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n     fn read_ty_noxcx(&mut self,\n-                     tcx: &ty::ctxt, cdata: @cstore::crate_metadata) -> ty::t {\n+                     tcx: &ty::ctxt, cdata: &cstore::crate_metadata) -> ty::t {\n         self.read_opaque(|_, doc| {\n             Ok(tydecode::parse_ty_data(\n                 doc.data,\n@@ -1161,7 +1161,7 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n \n     fn read_tys_noxcx(&mut self,\n                       tcx: &ty::ctxt,\n-                      cdata: @cstore::crate_metadata) -> Vec<ty::t> {\n+                      cdata: &cstore::crate_metadata) -> Vec<ty::t> {\n         self.read_to_vec(|this| Ok(this.read_ty_noxcx(tcx, cdata)) )\n             .unwrap()\n             .move_iter()"}]}