{"sha": "e7089a97e79fb550dcd76da47c614b2701963327", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3MDg5YTk3ZTc5ZmI1NTBkY2Q3NmRhNDdjNjE0YjI3MDE5NjMzMjc=", "commit": {"author": {"name": "Ximin Luo", "email": "infinity0@pwned.gg", "date": "2020-07-27T22:22:07Z"}, "committer": {"name": "Ximin Luo", "email": "infinity0@pwned.gg", "date": "2020-07-27T22:22:07Z"}, "message": "rustbuild: refactor how the wrapper deals with exit codes", "tree": {"sha": "7c3eb236f116d9e370da6b3931f966b3e3d3f8b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c3eb236f116d9e370da6b3931f966b3e3d3f8b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7089a97e79fb550dcd76da47c614b2701963327", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7089a97e79fb550dcd76da47c614b2701963327", "html_url": "https://github.com/rust-lang/rust/commit/e7089a97e79fb550dcd76da47c614b2701963327", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7089a97e79fb550dcd76da47c614b2701963327/comments", "author": {"login": "infinity0", "id": 78398, "node_id": "MDQ6VXNlcjc4Mzk4", "avatar_url": "https://avatars.githubusercontent.com/u/78398?v=4", "gravatar_id": "", "url": "https://api.github.com/users/infinity0", "html_url": "https://github.com/infinity0", "followers_url": "https://api.github.com/users/infinity0/followers", "following_url": "https://api.github.com/users/infinity0/following{/other_user}", "gists_url": "https://api.github.com/users/infinity0/gists{/gist_id}", "starred_url": "https://api.github.com/users/infinity0/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/infinity0/subscriptions", "organizations_url": "https://api.github.com/users/infinity0/orgs", "repos_url": "https://api.github.com/users/infinity0/repos", "events_url": "https://api.github.com/users/infinity0/events{/privacy}", "received_events_url": "https://api.github.com/users/infinity0/received_events", "type": "User", "site_admin": false}, "committer": {"login": "infinity0", "id": 78398, "node_id": "MDQ6VXNlcjc4Mzk4", "avatar_url": "https://avatars.githubusercontent.com/u/78398?v=4", "gravatar_id": "", "url": "https://api.github.com/users/infinity0", "html_url": "https://github.com/infinity0", "followers_url": "https://api.github.com/users/infinity0/followers", "following_url": "https://api.github.com/users/infinity0/following{/other_user}", "gists_url": "https://api.github.com/users/infinity0/gists{/gist_id}", "starred_url": "https://api.github.com/users/infinity0/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/infinity0/subscriptions", "organizations_url": "https://api.github.com/users/infinity0/orgs", "repos_url": "https://api.github.com/users/infinity0/repos", "events_url": "https://api.github.com/users/infinity0/events{/privacy}", "received_events_url": "https://api.github.com/users/infinity0/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3dcab2922c4eaaea11a6856fa566bdb7a6d9c1f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/3dcab2922c4eaaea11a6856fa566bdb7a6d9c1f6", "html_url": "https://github.com/rust-lang/rust/commit/3dcab2922c4eaaea11a6856fa566bdb7a6d9c1f6"}], "stats": {"total": 50, "additions": 24, "deletions": 26}, "files": [{"sha": "d6649d0521ca3dbfb2afab883aedb1946113d51d", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 24, "deletions": 26, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/e7089a97e79fb550dcd76da47c614b2701963327/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7089a97e79fb550dcd76da47c614b2701963327/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=e7089a97e79fb550dcd76da47c614b2701963327", "patch": "@@ -16,7 +16,6 @@\n //! never get replaced.\n \n use std::env;\n-use std::io;\n use std::path::PathBuf;\n use std::process::Command;\n use std::str::FromStr;\n@@ -147,22 +146,15 @@ fn main() {\n         eprintln!(\"libdir: {:?}\", libdir);\n     }\n \n-    if let Some(mut on_fail) = on_fail {\n-        let e = match cmd.status() {\n-            Ok(s) => if s.success() { std::process::exit(0) } else { format!(\"Ok({})\", s) },\n-            Err(e) => format!(\"Err({})\", e),\n-        };\n-        println!(\"\\nDid not run successfully: {}\\n{:?}\\n-------------\", e, cmd);\n-        status_code(&mut on_fail).expect(\"could not run the backup command\");\n-        std::process::exit(1);\n-    }\n+    let start = Instant::now();\n+    let status = {\n+        let errmsg = format!(\"\\nFailed to run:\\n{:?}\\n-------------\", cmd);\n+        cmd.status().expect(&errmsg)\n+    };\n \n     if env::var_os(\"RUSTC_PRINT_STEP_TIMINGS\").is_some() {\n         if let Some(crate_name) = crate_name {\n-            let start = Instant::now();\n-            let status = cmd.status().unwrap_or_else(|_| panic!(\"\\n\\n failed to run {:?}\", cmd));\n             let dur = start.elapsed();\n-\n             let is_test = args.iter().any(|a| a == \"--test\");\n             eprintln!(\n                 \"[RUSTC-TIMING] {} test:{} {}.{:03}\",\n@@ -171,21 +163,27 @@ fn main() {\n                 dur.as_secs(),\n                 dur.subsec_millis()\n             );\n-\n-            match status.code() {\n-                Some(i) => std::process::exit(i),\n-                None => {\n-                    eprintln!(\"rustc exited with {}\", status);\n-                    std::process::exit(0xfe);\n-                }\n-            }\n         }\n     }\n \n-    let code = status_code(&mut cmd).unwrap_or_else(|_| panic!(\"\\n\\n failed to run {:?}\", cmd));\n-    std::process::exit(code);\n-}\n+    if status.success() {\n+        std::process::exit(0);\n+        // note: everything below here is unreachable. do not put code that\n+        // should run on success, after this block.\n+    }\n+    println!(\"\\nDid not run successfully: {}\\n{:?}\\n-------------\", status, cmd);\n+\n+    if let Some(mut on_fail) = on_fail {\n+        on_fail.status().expect(\"Could not run the on_fail command\");\n+    }\n \n-fn status_code(cmd: &mut Command) -> io::Result<i32> {\n-    cmd.status().map(|status| status.code().unwrap())\n+    // Preserve the exit code. In case of signal, exit with 0xfe since it's\n+    // awkward to preserve this status in a cross-platform way.\n+    match status.code() {\n+        Some(i) => std::process::exit(i),\n+        None => {\n+            eprintln!(\"rustc exited with {}\", status);\n+            std::process::exit(0xfe);\n+        }\n+    }\n }"}]}