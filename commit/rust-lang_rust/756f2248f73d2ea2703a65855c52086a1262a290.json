{"sha": "756f2248f73d2ea2703a65855c52086a1262a290", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1NmYyMjQ4ZjczZDJlYTI3MDNhNjU4NTVjNTIwODZhMTI2MmEyOTA=", "commit": {"author": {"name": "projektir", "email": "oprojektir@gmail.com", "date": "2017-03-28T03:55:03Z"}, "committer": {"name": "projektir", "email": "oprojektir@gmail.com", "date": "2017-03-28T03:55:03Z"}, "message": "Adding links for Atomics docs #29377", "tree": {"sha": "cb3fa7ea9bf218c03ef89da7ec61e89fc6f86ade", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb3fa7ea9bf218c03ef89da7ec61e89fc6f86ade"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/756f2248f73d2ea2703a65855c52086a1262a290", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/756f2248f73d2ea2703a65855c52086a1262a290", "html_url": "https://github.com/rust-lang/rust/commit/756f2248f73d2ea2703a65855c52086a1262a290", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/756f2248f73d2ea2703a65855c52086a1262a290/comments", "author": {"login": "projektir", "id": 16269746, "node_id": "MDQ6VXNlcjE2MjY5NzQ2", "avatar_url": "https://avatars.githubusercontent.com/u/16269746?v=4", "gravatar_id": "", "url": "https://api.github.com/users/projektir", "html_url": "https://github.com/projektir", "followers_url": "https://api.github.com/users/projektir/followers", "following_url": "https://api.github.com/users/projektir/following{/other_user}", "gists_url": "https://api.github.com/users/projektir/gists{/gist_id}", "starred_url": "https://api.github.com/users/projektir/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/projektir/subscriptions", "organizations_url": "https://api.github.com/users/projektir/orgs", "repos_url": "https://api.github.com/users/projektir/repos", "events_url": "https://api.github.com/users/projektir/events{/privacy}", "received_events_url": "https://api.github.com/users/projektir/received_events", "type": "User", "site_admin": false}, "committer": {"login": "projektir", "id": 16269746, "node_id": "MDQ6VXNlcjE2MjY5NzQ2", "avatar_url": "https://avatars.githubusercontent.com/u/16269746?v=4", "gravatar_id": "", "url": "https://api.github.com/users/projektir", "html_url": "https://github.com/projektir", "followers_url": "https://api.github.com/users/projektir/followers", "following_url": "https://api.github.com/users/projektir/following{/other_user}", "gists_url": "https://api.github.com/users/projektir/gists{/gist_id}", "starred_url": "https://api.github.com/users/projektir/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/projektir/subscriptions", "organizations_url": "https://api.github.com/users/projektir/orgs", "repos_url": "https://api.github.com/users/projektir/repos", "events_url": "https://api.github.com/users/projektir/events{/privacy}", "received_events_url": "https://api.github.com/users/projektir/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7846dbe0c8de17f59cdfc3d2b914d58faad7eade", "url": "https://api.github.com/repos/rust-lang/rust/commits/7846dbe0c8de17f59cdfc3d2b914d58faad7eade", "html_url": "https://github.com/rust-lang/rust/commit/7846dbe0c8de17f59cdfc3d2b914d58faad7eade"}], "stats": {"total": 104, "additions": 66, "deletions": 38}, "files": [{"sha": "c3e7c9b7c989cf013ba0e4cfbe57bcda26d176a5", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 66, "deletions": 38, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/756f2248f73d2ea2703a65855c52086a1262a290/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/756f2248f73d2ea2703a65855c52086a1262a290/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=756f2248f73d2ea2703a65855c52086a1262a290", "patch": "@@ -15,27 +15,37 @@\n //! types.\n //!\n //! This module defines atomic versions of a select number of primitive\n-//! types, including `AtomicBool`, `AtomicIsize`, and `AtomicUsize`.\n+//! types, including [`AtomicBool`], [`AtomicIsize`], and [`AtomicUsize`].\n //! Atomic types present operations that, when used correctly, synchronize\n //! updates between threads.\n //!\n-//! Each method takes an `Ordering` which represents the strength of\n+//! [`AtomicBool`]: struct.AtomicBool.html\n+//! [`AtomicIsize`]: struct.AtomicIsize.html\n+//! [`AtomicUsize`]: struct.AtomicUsize.html\n+//!\n+//! Each method takes an [`Ordering`] which represents the strength of\n //! the memory barrier for that operation. These orderings are the\n //! same as [LLVM atomic orderings][1]. For more information see the [nomicon][2].\n //!\n+//! [`Ordering`]: enum.Ordering.html\n+//!\n //! [1]: http://llvm.org/docs/LangRef.html#memory-model-for-concurrent-operations\n //! [2]: ../../../nomicon/atomics.html\n //!\n-//! Atomic variables are safe to share between threads (they implement `Sync`)\n+//! Atomic variables are safe to share between threads (they implement [`Sync`])\n //! but they do not themselves provide the mechanism for sharing and follow the\n //! [threading model](../../../std/thread/index.html#the-threading-model) of rust.\n-//! The most common way to share an atomic variable is to put it into an `Arc` (an\n+//! The most common way to share an atomic variable is to put it into an [`Arc`][arc] (an\n //! atomically-reference-counted shared pointer).\n //!\n+//! [`Sync`]: ../../marker/trait.Sync.html\n+//! [arc]: ../struct.Arc.html\n+//!\n //! Most atomic types may be stored in static variables, initialized using\n-//! the provided static initializers like `ATOMIC_BOOL_INIT`. Atomic statics\n+//! the provided static initializers like [`ATOMIC_BOOL_INIT`]. Atomic statics\n //! are often used for lazy global initialization.\n //!\n+//! [`ATOMIC_BOOL_INIT`]: constant.ATOMIC_BOOL_INIT.html\n //!\n //! # Examples\n //!\n@@ -149,21 +159,26 @@ unsafe impl<T> Sync for AtomicPtr<T> {}\n #[derive(Copy, Clone, Debug)]\n pub enum Ordering {\n     /// No ordering constraints, only atomic operations. Corresponds to LLVM's\n-    /// `Monotonic` ordering.\n+    /// [`Monotonic`][1] ordering.\n+    /// [1]: http://llvm.org/docs/Atomics.html#monotonic\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Relaxed,\n     /// When coupled with a store, all previous writes become visible\n-    /// to the other threads that perform a load with `Acquire` ordering\n+    /// to the other threads that perform a load with [`Acquire`][1] ordering\n     /// on the same value.\n+    /// [1]: http://llvm.org/docs/Atomics.html#acquire\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Release,\n     /// When coupled with a load, all subsequent loads will see data\n-    /// written before a store with `Release` ordering on the same value\n+    /// written before a store with [`Release`][1] ordering on the same value\n     /// in other threads.\n+    /// [1]: http://llvm.org/docs/Atomics.html#release\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Acquire,\n-    /// When coupled with a load, uses `Acquire` ordering, and with a store\n-    /// `Release` ordering.\n+    /// When coupled with a load, uses [`Acquire`][1] ordering, and with a store\n+    /// [`Release`][2] ordering.\n+    /// [1]: http://llvm.org/docs/Atomics.html#acquire\n+    /// [2]: http://llvm.org/docs/Atomics.html#release\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     AcqRel,\n     /// Like `AcqRel` with the additional guarantee that all threads see all\n@@ -176,7 +191,8 @@ pub enum Ordering {\n     __Nonexhaustive,\n }\n \n-/// An `AtomicBool` initialized to `false`.\n+/// An [`AtomicBool`] initialized to `false`.\n+/// [`AtomicBool`]: struct.AtomicBool.html\n #[cfg(target_has_atomic = \"8\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const ATOMIC_BOOL_INIT: AtomicBool = AtomicBool::new(false);\n@@ -241,7 +257,7 @@ impl AtomicBool {\n \n     /// Loads a value from the bool.\n     ///\n-    /// `load` takes an [`Ordering`] argument which describes the memory ordering\n+    /// `load()` takes an [`Ordering`] argument which describes the memory ordering\n     /// of this operation.\n     ///\n     /// # Panics\n@@ -250,7 +266,7 @@ impl AtomicBool {\n     ///\n     /// [`Ordering`]: enum.Ordering.html\n     /// [`Release`]: enum.Ordering.html#variant.Release\n-    /// [`AcqRel`]: enum.Ordering.html#variant.Release\n+    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n     ///\n     /// # Examples\n     ///\n@@ -269,7 +285,7 @@ impl AtomicBool {\n \n     /// Stores a value into the bool.\n     ///\n-    /// `store` takes an [`Ordering`] argument which describes the memory ordering\n+    /// `store()` takes an [`Ordering`] argument which describes the memory ordering\n     /// of this operation.\n     ///\n     /// [`Ordering`]: enum.Ordering.html\n@@ -287,7 +303,10 @@ impl AtomicBool {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if `order` is `Acquire` or `AcqRel`.\n+    /// Panics if `order` is [`Acquire`] or [`AcqRel`].\n+    ///\n+    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n+    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn store(&self, val: bool, order: Ordering) {\n@@ -298,7 +317,7 @@ impl AtomicBool {\n \n     /// Stores a value into the bool, returning the old value.\n     ///\n-    /// `swap` takes an [`Ordering`] argument which describes the memory ordering\n+    /// `swap()` takes an [`Ordering`] argument which describes the memory ordering\n     /// of this operation.\n     ///\n     /// [`Ordering`]: enum.Ordering.html\n@@ -324,7 +343,7 @@ impl AtomicBool {\n     /// The return value is always the previous value. If it is equal to `current`, then the value\n     /// was updated.\n     ///\n-    /// `compare_and_swap` also takes an [`Ordering`] argument which describes the memory\n+    /// `compare_and_swap()` also takes an [`Ordering`] argument which describes the memory\n     /// ordering of this operation.\n     ///\n     /// [`Ordering`]: enum.Ordering.html\n@@ -356,7 +375,7 @@ impl AtomicBool {\n     /// The return value is a result indicating whether the new value was written and containing\n     /// the previous value. On success this value is guaranteed to be equal to `current`.\n     ///\n-    /// `compare_exchange` takes two [`Ordering`] arguments to describe the memory\n+    /// `compare_exchange()` takes two [`Ordering`] arguments to describe the memory\n     /// ordering of this operation. The first describes the required ordering if the\n     /// operation succeeds while the second describes the required ordering when the\n     /// operation fails. The failure ordering can't be [`Release`] or [`AcqRel`] and must\n@@ -404,17 +423,18 @@ impl AtomicBool {\n \n     /// Stores a value into the `bool` if the current value is the same as the `current` value.\n     ///\n-    /// Unlike `compare_exchange`, this function is allowed to spuriously fail even when the\n+    /// Unlike [`compare_exchange()`], this function is allowed to spuriously fail even when the\n     /// comparison succeeds, which can result in more efficient code on some platforms. The\n     /// return value is a result indicating whether the new value was written and containing the\n     /// previous value.\n     ///\n-    /// `compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n+    /// `compare_exchange_weak()` takes two [`Ordering`] arguments to describe the memory\n     /// ordering of this operation. The first describes the required ordering if the operation\n     /// succeeds while the second describes the required ordering when the operation fails. The\n     /// failure ordering can't be [`Release`] or [`AcqRel`] and must be equivalent or\n     /// weaker than the success ordering.\n     ///\n+    /// [`compare_exchange()`]: #method.compare_exchange\n     /// [`Ordering`]: enum.Ordering.html\n     /// [`Release`]: enum.Ordering.html#variant.Release\n     /// [`AcqRel`]: enum.Ordering.html#variant.Release\n@@ -645,7 +665,7 @@ impl<T> AtomicPtr<T> {\n \n     /// Loads a value from the pointer.\n     ///\n-    /// `load` takes an [`Ordering`] argument which describes the memory ordering\n+    /// `load()` takes an [`Ordering`] argument which describes the memory ordering\n     /// of this operation.\n     ///\n     /// # Panics\n@@ -674,7 +694,7 @@ impl<T> AtomicPtr<T> {\n \n     /// Stores a value into the pointer.\n     ///\n-    /// `store` takes an [`Ordering`] argument which describes the memory ordering\n+    /// `store()` takes an [`Ordering`] argument which describes the memory ordering\n     /// of this operation.\n     ///\n     /// [`Ordering`]: enum.Ordering.html\n@@ -694,7 +714,11 @@ impl<T> AtomicPtr<T> {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if `order` is `Acquire` or `AcqRel`.\n+    /// Panics if `order` is [`Acquire`] or [`AcqRel`].\n+    ///\n+    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n+    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n+    ///\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn store(&self, ptr: *mut T, order: Ordering) {\n@@ -705,7 +729,7 @@ impl<T> AtomicPtr<T> {\n \n     /// Stores a value into the pointer, returning the old value.\n     ///\n-    /// `swap` takes an [`Ordering`] argument which describes the memory ordering\n+    /// `swap()` takes an [`Ordering`] argument which describes the memory ordering\n     /// of this operation.\n     ///\n     /// [`Ordering`]: enum.Ordering.html\n@@ -733,7 +757,7 @@ impl<T> AtomicPtr<T> {\n     /// The return value is always the previous value. If it is equal to `current`, then the value\n     /// was updated.\n     ///\n-    /// `compare_and_swap` also takes an [`Ordering`] argument which describes the memory\n+    /// `compare_and_swap()` also takes an [`Ordering`] argument which describes the memory\n     /// ordering of this operation.\n     ///\n     /// [`Ordering`]: enum.Ordering.html\n@@ -765,7 +789,7 @@ impl<T> AtomicPtr<T> {\n     /// The return value is a result indicating whether the new value was written and containing\n     /// the previous value. On success this value is guaranteed to be equal to `current`.\n     ///\n-    /// `compare_exchange` takes two [`Ordering`] arguments to describe the memory\n+    /// `compare_exchange()` takes two [`Ordering`] arguments to describe the memory\n     /// ordering of this operation. The first describes the required ordering if\n     /// the operation succeeds while the second describes the required ordering when\n     /// the operation fails. The failure ordering can't be [`Release`] or [`AcqRel`]\n@@ -812,18 +836,18 @@ impl<T> AtomicPtr<T> {\n \n     /// Stores a value into the pointer if the current value is the same as the `current` value.\n     ///\n-    /// Unlike [`compare_exchange`], this function is allowed to spuriously fail even when the\n+    /// Unlike [`compare_exchange()`], this function is allowed to spuriously fail even when the\n     /// comparison succeeds, which can result in more efficient code on some platforms. The\n     /// return value is a result indicating whether the new value was written and containing the\n     /// previous value.\n     ///\n-    /// `compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n+    /// `compare_exchange_weak()` takes two [`Ordering`] arguments to describe the memory\n     /// ordering of this operation. The first describes the required ordering if the operation\n     /// succeeds while the second describes the required ordering when the operation fails. The\n     /// failure ordering can't be [`Release`] or [`AcqRel`] and must be equivalent or\n     /// weaker than the success ordering.\n     ///\n-    /// [`compare_exchange`]: #method.compare_exchange\n+    /// [`compare_exchange()`]: #method.compare_exchange\n     /// [`Ordering`]: enum.Ordering.html\n     /// [`Release`]: enum.Ordering.html#variant.Release\n     /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n@@ -962,7 +986,7 @@ macro_rules! atomic_int {\n \n             /// Loads a value from the atomic integer.\n             ///\n-            /// `load` takes an [`Ordering`] argument which describes the memory ordering of this\n+            /// `load()` takes an [`Ordering`] argument which describes the memory ordering of this\n             /// operation.\n             ///\n             /// # Panics\n@@ -990,7 +1014,7 @@ macro_rules! atomic_int {\n \n             /// Stores a value into the atomic integer.\n             ///\n-            /// `store` takes an [`Ordering`] argument which describes the memory ordering of this\n+            /// `store()` takes an [`Ordering`] argument which describes the memory ordering of this\n             /// operation.\n             ///\n             /// [`Ordering`]: enum.Ordering.html\n@@ -1008,7 +1032,11 @@ macro_rules! atomic_int {\n             ///\n             /// # Panics\n             ///\n-            /// Panics if `order` is `Acquire` or `AcqRel`.\n+            /// Panics if `order` is [`Acquire`] or [`AcqRel`].\n+            ///\n+            /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n+            /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n+            ///\n             #[inline]\n             #[$stable]\n             pub fn store(&self, val: $int_type, order: Ordering) {\n@@ -1017,7 +1045,7 @@ macro_rules! atomic_int {\n \n             /// Stores a value into the atomic integer, returning the old value.\n             ///\n-            /// `swap` takes an [`Ordering`] argument which describes the memory ordering of this\n+            /// `swap()` takes an [`Ordering`] argument which describes the memory ordering of this\n             /// operation.\n             ///\n             /// [`Ordering`]: enum.Ordering.html\n@@ -1043,7 +1071,7 @@ macro_rules! atomic_int {\n             /// The return value is always the previous value. If it is equal to `current`, then the\n             /// value was updated.\n             ///\n-            /// `compare_and_swap` also takes an [`Ordering`] argument which describes the memory\n+            /// `compare_and_swap()` also takes an [`Ordering`] argument which describes the memory\n             /// ordering of this operation.\n             ///\n             /// [`Ordering`]: enum.Ordering.html\n@@ -1083,7 +1111,7 @@ macro_rules! atomic_int {\n             /// containing the previous value. On success this value is guaranteed to be equal to\n             /// `current`.\n             ///\n-            /// `compare_exchange` takes two [`Ordering`] arguments to describe the memory\n+            /// `compare_exchange()` takes two [`Ordering`] arguments to describe the memory\n             /// ordering of this operation. The first describes the required ordering if\n             /// the operation succeeds while the second describes the required ordering when\n             /// the operation fails. The failure ordering can't be [`Release`] or [`AcqRel`] and\n@@ -1125,18 +1153,18 @@ macro_rules! atomic_int {\n             /// Stores a value into the atomic integer if the current value is the same as the\n             /// `current` value.\n             ///\n-            /// Unlike [`compare_exchange`], this function is allowed to spuriously fail even\n+            /// Unlike [`compare_exchange()`], this function is allowed to spuriously fail even\n             /// when the comparison succeeds, which can result in more efficient code on some\n             /// platforms. The return value is a result indicating whether the new value was\n             /// written and containing the previous value.\n             ///\n-            /// `compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n+            /// `compare_exchange_weak()` takes two [`Ordering`] arguments to describe the memory\n             /// ordering of this operation. The first describes the required ordering if the\n             /// operation succeeds while the second describes the required ordering when the\n             /// operation fails. The failure ordering can't be [`Release`] or [`AcqRel`] and\n             /// must be equivalent or weaker than the success ordering.\n             ///\n-            /// [`compare_exchange`]: #method.compare_exchange\n+            /// [`compare_exchange()`]: #method.compare_exchange\n             /// [`Ordering`]: enum.Ordering.html\n             /// [`Release`]: enum.Ordering.html#variant.Release\n             /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel"}]}