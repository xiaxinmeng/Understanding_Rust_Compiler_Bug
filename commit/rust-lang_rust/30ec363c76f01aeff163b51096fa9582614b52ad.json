{"sha": "30ec363c76f01aeff163b51096fa9582614b52ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwZWMzNjNjNzZmMDFhZWZmMTYzYjUxMDk2ZmE5NTgyNjE0YjUyYWQ=", "commit": {"author": {"name": "Dylan McKay", "email": "dylanmckay34@gmail.com", "date": "2015-08-15T06:43:39Z"}, "committer": {"name": "Dylan McKay", "email": "dylanmckay34@gmail.com", "date": "2015-08-15T08:04:21Z"}, "message": "Reduce rustc::trans's dependence on pointer width", "tree": {"sha": "b810ccdcc91a508caa421ec8a42cb2987055081a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b810ccdcc91a508caa421ec8a42cb2987055081a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30ec363c76f01aeff163b51096fa9582614b52ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30ec363c76f01aeff163b51096fa9582614b52ad", "html_url": "https://github.com/rust-lang/rust/commit/30ec363c76f01aeff163b51096fa9582614b52ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30ec363c76f01aeff163b51096fa9582614b52ad/comments", "author": null, "committer": null, "parents": [{"sha": "7ebc5e5134b6a0094a197d27423f9a80dbb38598", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ebc5e5134b6a0094a197d27423f9a80dbb38598", "html_url": "https://github.com/rust-lang/rust/commit/7ebc5e5134b6a0094a197d27423f9a80dbb38598"}], "stats": {"total": 73, "additions": 32, "deletions": 41}, "files": [{"sha": "1982f04195f0b3739dbad3fbcef7c8848669bfdc", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/30ec363c76f01aeff163b51096fa9582614b52ad/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30ec363c76f01aeff163b51096fa9582614b52ad/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=30ec363c76f01aeff163b51096fa9582614b52ad", "patch": "@@ -943,11 +943,8 @@ pub fn call_lifetime_end(cx: Block, ptr: ValueRef) {\n pub fn call_memcpy(cx: Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, align: u32) {\n     let _icx = push_ctxt(\"call_memcpy\");\n     let ccx = cx.ccx();\n-    let key = match &ccx.sess().target.target.target_pointer_width[..] {\n-        \"32\" => \"llvm.memcpy.p0i8.p0i8.i32\",\n-        \"64\" => \"llvm.memcpy.p0i8.p0i8.i64\",\n-        tws => panic!(\"Unsupported target word size for memcpy: {}\", tws),\n-    };\n+    let ptr_width = &ccx.sess().target.target.target_pointer_width[..];\n+    let key = format!(\"llvm.memcpy.p0i8.p0i8.i{}\", ptr_width);\n     let memcpy = ccx.get_intrinsic(&key);\n     let src_ptr = PointerCast(cx, src, Type::i8p(ccx));\n     let dst_ptr = PointerCast(cx, dst, Type::i8p(ccx));\n@@ -996,12 +993,8 @@ fn memfill<'a, 'tcx>(b: &Builder<'a, 'tcx>, llptr: ValueRef, ty: Ty<'tcx>, byte:\n     let ccx = b.ccx;\n \n     let llty = type_of::type_of(ccx, ty);\n-\n-    let intrinsic_key = match &ccx.sess().target.target.target_pointer_width[..] {\n-        \"32\" => \"llvm.memset.p0i8.i32\",\n-        \"64\" => \"llvm.memset.p0i8.i64\",\n-        tws => panic!(\"Unsupported target word size for memset: {}\", tws),\n-    };\n+    let ptr_width = &ccx.sess().target.target.target_pointer_width[..];\n+    let intrinsic_key = format!(\"llvm.memset.p0i8.i{}\", ptr_width);\n \n     let llintrinsicfn = ccx.get_intrinsic(&intrinsic_key);\n     let llptr = b.pointercast(llptr, Type::i8(ccx).ptr_to());"}, {"sha": "5707566b047277705c3dd12ac3a8de3361769490", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/30ec363c76f01aeff163b51096fa9582614b52ad/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30ec363c76f01aeff163b51096fa9582614b52ad/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=30ec363c76f01aeff163b51096fa9582614b52ad", "patch": "@@ -833,10 +833,11 @@ pub fn C_u64(ccx: &CrateContext, i: u64) -> ValueRef {\n pub fn C_int<I: AsI64>(ccx: &CrateContext, i: I) -> ValueRef {\n     let v = i.as_i64();\n \n-    match machine::llbitsize_of_real(ccx, ccx.int_type()) {\n-        32 => assert!(v < (1<<31) && v >= -(1<<31)),\n-        64 => {},\n-        n => panic!(\"unsupported target size: {}\", n)\n+    let bit_size = machine::llbitsize_of_real(ccx, ccx.int_type());\n+\n+    if bit_size < 64 {\n+        // make sure it doesn't overflow\n+        assert!(v < (1<<(bit_size-1)) && v >= -(1<<(bit_size-1)));\n     }\n \n     C_integral(ccx.int_type(), v as u64, true)\n@@ -845,10 +846,11 @@ pub fn C_int<I: AsI64>(ccx: &CrateContext, i: I) -> ValueRef {\n pub fn C_uint<I: AsU64>(ccx: &CrateContext, i: I) -> ValueRef {\n     let v = i.as_u64();\n \n-    match machine::llbitsize_of_real(ccx, ccx.int_type()) {\n-        32 => assert!(v < (1<<32)),\n-        64 => {},\n-        n => panic!(\"unsupported target size: {}\", n)\n+    let bit_size = machine::llbitsize_of_real(ccx, ccx.int_type());\n+\n+    if bit_size < 64 {\n+        // make sure it doesn't overflow\n+        assert!(v < (1<<bit_size));\n     }\n \n     C_integral(ccx.int_type(), v, false)"}, {"sha": "bd13667ac082482d4b87cb7e459b084427b3d6f4", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/30ec363c76f01aeff163b51096fa9582614b52ad/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30ec363c76f01aeff163b51096fa9582614b52ad/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=30ec363c76f01aeff163b51096fa9582614b52ad", "patch": "@@ -560,7 +560,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.local.builder.b\n     }\n \n-    pub fn get_intrinsic(&self, key: & &'static str) -> ValueRef {\n+    pub fn get_intrinsic(&self, key: &str) -> ValueRef {\n         if let Some(v) = self.intrinsics().borrow().get(key).cloned() {\n             return v;\n         }\n@@ -791,18 +791,18 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n }\n \n /// Declare any llvm intrinsics that you might need\n-fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef> {\n+fn declare_intrinsic(ccx: &CrateContext, key: &str) -> Option<ValueRef> {\n     macro_rules! ifn {\n         ($name:expr, fn() -> $ret:expr) => (\n-            if *key == $name {\n+            if key == $name {\n                 let f = declare::declare_cfn(ccx, $name, Type::func(&[], &$ret),\n                                              ccx.tcx().mk_nil());\n                 ccx.intrinsics().borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n         );\n         ($name:expr, fn($($arg:expr),*) -> $ret:expr) => (\n-            if *key == $name {\n+            if key == $name {\n                 let f = declare::declare_cfn(ccx, $name, Type::func(&[$($arg),*], &$ret),\n                                              ccx.tcx().mk_nil());\n                 ccx.intrinsics().borrow_mut().insert($name, f.clone());\n@@ -824,10 +824,13 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n     let t_f32 = Type::f32(ccx);\n     let t_f64 = Type::f64(ccx);\n \n+    ifn!(\"llvm.memcpy.p0i8.p0i8.i16\", fn(i8p, i8p, t_i16, t_i32, i1) -> void);\n     ifn!(\"llvm.memcpy.p0i8.p0i8.i32\", fn(i8p, i8p, t_i32, t_i32, i1) -> void);\n     ifn!(\"llvm.memcpy.p0i8.p0i8.i64\", fn(i8p, i8p, t_i64, t_i32, i1) -> void);\n+    ifn!(\"llvm.memmove.p0i8.p0i8.i16\", fn(i8p, i8p, t_i16, t_i32, i1) -> void);\n     ifn!(\"llvm.memmove.p0i8.p0i8.i32\", fn(i8p, i8p, t_i32, t_i32, i1) -> void);\n     ifn!(\"llvm.memmove.p0i8.p0i8.i64\", fn(i8p, i8p, t_i64, t_i32, i1) -> void);\n+    ifn!(\"llvm.memset.p0i8.i16\", fn(i8p, t_i8, t_i16, t_i32, i1) -> void);\n     ifn!(\"llvm.memset.p0i8.i32\", fn(i8p, t_i8, t_i32, t_i32, i1) -> void);\n     ifn!(\"llvm.memset.p0i8.i64\", fn(i8p, t_i8, t_i64, t_i32, i1) -> void);\n \n@@ -942,7 +945,7 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n             if unsafe { llvm::LLVMVersionMinor() >= $llvm_version } {\n                 // The `if key == $name` is already in ifn!\n                 ifn!($name, fn($($arg),*) -> void);\n-            } else if *key == $name {\n+            } else if key == $name {\n                 let f = declare::declare_cfn(ccx, stringify!($cname),\n                                              Type::func(&[$($arg),*], &void),\n                                              ccx.tcx().mk_nil());\n@@ -965,7 +968,7 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n             if unsafe { llvm::LLVMVersionMinor() >= $llvm_version } {\n                 // The `if key == $name` is already in ifn!\n                 ifn!($name, fn($($arg),*) -> $ret);\n-            } else if *key == $name {\n+            } else if key == $name {\n                 let f = declare::declare_cfn(ccx, stringify!($cname),\n                                              Type::func(&[$($arg),*], &$ret),\n                                              ccx.tcx().mk_nil());"}, {"sha": "33e5d814eb186a12787eb1b8c548bad8605a3d5d", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/30ec363c76f01aeff163b51096fa9582614b52ad/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30ec363c76f01aeff163b51096fa9582614b52ad/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=30ec363c76f01aeff163b51096fa9582614b52ad", "patch": "@@ -932,20 +932,15 @@ fn copy_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let align = C_i32(ccx, type_of::align_of(ccx, tp_ty) as i32);\n     let size = machine::llsize_of(ccx, lltp_ty);\n     let int_size = machine::llbitsize_of_real(ccx, ccx.int_type());\n-    let name = if allow_overlap {\n-        if int_size == 32 {\n-            \"llvm.memmove.p0i8.p0i8.i32\"\n-        } else {\n-            \"llvm.memmove.p0i8.p0i8.i64\"\n-        }\n+\n+    let operation = if allow_overlap {\n+        \"memmove\"\n     } else {\n-        if int_size == 32 {\n-            \"llvm.memcpy.p0i8.p0i8.i32\"\n-        } else {\n-            \"llvm.memcpy.p0i8.p0i8.i64\"\n-        }\n+        \"memcpy\"\n     };\n \n+    let name = format!(\"llvm.{}.p0i8.p0i8.i{}\", operation, int_size);\n+\n     let dst_ptr = PointerCast(bcx, dst, Type::i8p(ccx));\n     let src_ptr = PointerCast(bcx, src, Type::i8p(ccx));\n     let llfn = ccx.get_intrinsic(&name);\n@@ -973,11 +968,9 @@ fn memset_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let lltp_ty = type_of::type_of(ccx, tp_ty);\n     let align = C_i32(ccx, type_of::align_of(ccx, tp_ty) as i32);\n     let size = machine::llsize_of(ccx, lltp_ty);\n-    let name = if machine::llbitsize_of_real(ccx, ccx.int_type()) == 32 {\n-        \"llvm.memset.p0i8.i32\"\n-    } else {\n-        \"llvm.memset.p0i8.i64\"\n-    };\n+    let int_size = machine::llbitsize_of_real(ccx, ccx.int_type());\n+\n+    let name = format!(\"llvm.memset.p0i8.i{}\", int_size);\n \n     let dst_ptr = PointerCast(bcx, dst, Type::i8p(ccx));\n     let llfn = ccx.get_intrinsic(&name);"}]}