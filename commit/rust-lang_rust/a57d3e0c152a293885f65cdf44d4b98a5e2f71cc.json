{"sha": "a57d3e0c152a293885f65cdf44d4b98a5e2f71cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1N2QzZTBjMTUyYTI5Mzg4NWY2NWNkZjQ0ZDRiOThhNWUyZjcxY2M=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-15T18:11:39Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-15T18:11:39Z"}, "message": "Fix :broadcast_heavy in condvars.", "tree": {"sha": "8211270887fb516830de9e383a132a4a28600282", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8211270887fb516830de9e383a132a4a28600282"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a57d3e0c152a293885f65cdf44d4b98a5e2f71cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a57d3e0c152a293885f65cdf44d4b98a5e2f71cc", "html_url": "https://github.com/rust-lang/rust/commit/a57d3e0c152a293885f65cdf44d4b98a5e2f71cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a57d3e0c152a293885f65cdf44d4b98a5e2f71cc/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f64d5df339a4794d19d5be0f5291f6bfef38ec1", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f64d5df339a4794d19d5be0f5291f6bfef38ec1", "html_url": "https://github.com/rust-lang/rust/commit/5f64d5df339a4794d19d5be0f5291f6bfef38ec1"}], "stats": {"total": 48, "additions": 27, "deletions": 21}, "files": [{"sha": "bf44e3f25ea65ca11221037aa48e8f18d4479fab", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 27, "deletions": 21, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a57d3e0c152a293885f65cdf44d4b98a5e2f71cc/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a57d3e0c152a293885f65cdf44d4b98a5e2f71cc/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=a57d3e0c152a293885f65cdf44d4b98a5e2f71cc", "patch": "@@ -28,6 +28,11 @@ type signal_end = pipes::chan_one<()>;\n struct waitqueue { head: pipes::port<signal_end>;\n                    tail: pipes::chan<signal_end>; }\n \n+fn new_waitqueue() -> waitqueue {\n+    let (block_tail, block_head) = pipes::stream();\n+    waitqueue { head: block_head, tail: block_tail }\n+}\n+\n // Signals one live task from the queue.\n #[doc(hidden)]\n fn signal_waitqueue(q: &waitqueue) -> bool {\n@@ -70,18 +75,15 @@ enum sem<Q: send> = Exclusive<sem_inner<Q>>;\n \n #[doc(hidden)]\n fn new_sem<Q: send>(count: int, +q: Q) -> sem<Q> {\n-    let (wait_tail, wait_head)  = pipes::stream();\n     sem(exclusive(sem_inner {\n-        mut count: count,\n-        waiters: waitqueue { head: wait_head, tail: wait_tail },\n-        blocked: q }))\n+        mut count: count, waiters: new_waitqueue(), blocked: q }))\n }\n #[doc(hidden)]\n-fn new_sem_and_signal(count: int, num_condvars: uint) -> sem<~[waitqueue]> {\n-    let mut queues = ~[];\n+fn new_sem_and_signal(count: int, num_condvars: uint)\n+        -> sem<~[mut waitqueue]> {\n+    let mut queues = ~[mut];\n     for num_condvars.times {\n-        let (block_tail, block_head) = pipes::stream();\n-        vec::push(queues, waitqueue { head: block_head, tail: block_tail });\n+        vec::push(queues, new_waitqueue());\n     }\n     new_sem(count, queues)\n }\n@@ -136,7 +138,7 @@ impl &sem<()> {\n     }\n }\n #[doc(hidden)]\n-impl &sem<~[waitqueue]> {\n+impl &sem<~[mut waitqueue]> {\n     fn access<U>(blk: fn() -> U) -> U {\n         let mut release = none;\n         unsafe {\n@@ -158,13 +160,13 @@ struct sem_release {\n }\n #[doc(hidden)]\n struct sem_and_signal_release {\n-    sem: &sem<~[waitqueue]>;\n-    new(sem: &sem<~[waitqueue]>) { self.sem = sem; }\n+    sem: &sem<~[mut waitqueue]>;\n+    new(sem: &sem<~[mut waitqueue]>) { self.sem = sem; }\n     drop { self.sem.release(); }\n }\n \n /// A mechanism for atomic-unlock-and-deschedule blocking and signalling.\n-struct condvar { priv sem: &sem<~[waitqueue]>; drop { } }\n+struct condvar { priv sem: &sem<~[mut waitqueue]>; drop { } }\n \n impl &condvar {\n     /**\n@@ -232,8 +234,8 @@ impl &condvar {\n         // mutex during unwinding. As long as the wrapper (mutex, etc) is\n         // bounded in when it gets released, this shouldn't hang forever.\n         struct sem_and_signal_reacquire {\n-            sem: &sem<~[waitqueue]>;\n-            new(sem: &sem<~[waitqueue]>) { self.sem = sem; }\n+            sem: &sem<~[mut waitqueue]>;\n+            new(sem: &sem<~[mut waitqueue]>) { self.sem = sem; }\n             drop unsafe {\n                 // Needs to succeed, instead of itself dying.\n                 do task::unkillable {\n@@ -268,19 +270,23 @@ impl &condvar {\n     /// As broadcast, but with a specified condvar_id. See wait_on.\n     fn broadcast_on(condvar_id: uint) -> uint {\n         let mut out_of_bounds = none;\n-        let mut result = 0;\n+        let mut queue = none;\n         unsafe {\n             do (**self.sem).with |state| {\n                 if condvar_id < vec::len(state.blocked) {\n-                    // FIXME(#3145) fix :broadcast_heavy\n-                    result = broadcast_waitqueue(&state.blocked[condvar_id])\n+                    // To avoid :broadcast_heavy, we make a new waitqueue,\n+                    // swap it out with the old one, and broadcast on the\n+                    // old one outside of the little-lock.\n+                    queue = some(util::replace(&mut state.blocked[condvar_id],\n+                                               new_waitqueue()));\n                 } else {\n                     out_of_bounds = some(vec::len(state.blocked));\n                 }\n             }\n         }\n         do check_cvar_bounds(out_of_bounds, condvar_id, \"cond.signal_on()\") {\n-            result\n+            let queue = option::swap_unwrap(&mut queue);\n+            broadcast_waitqueue(&queue)\n         }\n     }\n }\n@@ -303,7 +309,7 @@ fn check_cvar_bounds<U>(out_of_bounds: option<uint>, id: uint, act: &str,\n }\n \n #[doc(hidden)]\n-impl &sem<~[waitqueue]> {\n+impl &sem<~[mut waitqueue]> {\n     // The only other place that condvars get built is rwlock_write_mode.\n     fn access_cond<U>(blk: fn(c: &condvar) -> U) -> U {\n         do self.access { blk(&condvar { sem: self }) }\n@@ -354,7 +360,7 @@ impl &semaphore {\n  * A task which fails while holding a mutex will unlock the mutex as it\n  * unwinds.\n  */\n-struct mutex { priv sem: sem<~[waitqueue]>; }\n+struct mutex { priv sem: sem<~[mut waitqueue]>; }\n \n /// Create a new mutex, with one associated condvar.\n fn mutex() -> mutex { mutex_with_condvars(1) }\n@@ -402,7 +408,7 @@ struct rwlock_inner {\n  */\n struct rwlock {\n     /* priv */ order_lock:  semaphore;\n-    /* priv */ access_lock: sem<~[waitqueue]>;\n+    /* priv */ access_lock: sem<~[mut waitqueue]>;\n     /* priv */ state:       Exclusive<rwlock_inner>;\n }\n "}]}