{"sha": "61360fdfec981eadef1eefb595c8b32c951771e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxMzYwZmRmZWM5ODFlYWRlZjFlZWZiNTk1YzhiMzJjOTUxNzcxZTg=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-12-14T17:20:07Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-12-14T17:24:51Z"}, "message": "Fix original_source find order", "tree": {"sha": "08e89aa372dd4680569ee4a7788019196d65b375", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08e89aa372dd4680569ee4a7788019196d65b375"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61360fdfec981eadef1eefb595c8b32c951771e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61360fdfec981eadef1eefb595c8b32c951771e8", "html_url": "https://github.com/rust-lang/rust/commit/61360fdfec981eadef1eefb595c8b32c951771e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61360fdfec981eadef1eefb595c8b32c951771e8/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7238037de42a2fd88434930c521b926d7b0026da", "url": "https://api.github.com/repos/rust-lang/rust/commits/7238037de42a2fd88434930c521b926d7b0026da", "html_url": "https://github.com/rust-lang/rust/commit/7238037de42a2fd88434930c521b926d7b0026da"}], "stats": {"total": 164, "additions": 109, "deletions": 55}, "files": [{"sha": "2bf729b6d651a6268854c20dd9947d6c50e4b5c4", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/61360fdfec981eadef1eefb595c8b32c951771e8/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61360fdfec981eadef1eefb595c8b32c951771e8/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=61360fdfec981eadef1eefb595c8b32c951771e8", "patch": "@@ -58,6 +58,7 @@ pub use hir_def::{\n     type_ref::Mutability,\n };\n pub use hir_expand::{\n-    name::Name, HirFileId, InFile, MacroCallId, MacroCallLoc, MacroDefId, MacroFile,\n+    name::Name, ExpansionOrigin, HirFileId, InFile, MacroCallId, MacroCallLoc, MacroDefId,\n+    MacroFile,\n };\n pub use hir_ty::{display::HirDisplay, CallableDef};"}, {"sha": "d1a43fe6cf34b5c37a346988c22c2a78d8cc45b4", "filename": "crates/ra_hir_expand/src/lib.rs", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/61360fdfec981eadef1eefb595c8b32c951771e8/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61360fdfec981eadef1eefb595c8b32c951771e8/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Flib.rs?ref=61360fdfec981eadef1eefb595c8b32c951771e8", "patch": "@@ -214,7 +214,17 @@ pub struct ExpansionInfo {\n     exp_map: Arc<mbe::TokenMap>,\n }\n \n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum ExpansionOrigin {\n+    Call,\n+    Def,\n+}\n+\n impl ExpansionInfo {\n+    pub fn call_node(&self) -> Option<InFile<SyntaxNode>> {\n+        Some(self.arg.with_value(self.arg.value.parent()?))\n+    }\n+\n     pub fn map_token_down(&self, token: InFile<&SyntaxToken>) -> Option<InFile<SyntaxToken>> {\n         assert_eq!(token.file_id, self.arg.file_id);\n         let range = token.value.text_range().checked_sub(self.arg.value.text_range().start())?;\n@@ -228,21 +238,26 @@ impl ExpansionInfo {\n         Some(self.expanded.with_value(token))\n     }\n \n-    pub fn map_token_up(&self, token: InFile<&SyntaxToken>) -> Option<InFile<SyntaxToken>> {\n+    pub fn map_token_up(\n+        &self,\n+        token: InFile<&SyntaxToken>,\n+    ) -> Option<(InFile<SyntaxToken>, ExpansionOrigin)> {\n         let token_id = self.exp_map.token_by_range(token.value.text_range())?;\n \n         let (token_id, origin) = self.macro_def.0.map_id_up(token_id);\n-        let (token_map, tt) = match origin {\n-            mbe::Origin::Call => (&self.macro_arg.1, self.arg.clone()),\n-            mbe::Origin::Def => {\n-                (&self.macro_def.1, self.def.as_ref().map(|tt| tt.syntax().clone()))\n-            }\n+        let (token_map, tt, origin) = match origin {\n+            mbe::Origin::Call => (&self.macro_arg.1, self.arg.clone(), ExpansionOrigin::Call),\n+            mbe::Origin::Def => (\n+                &self.macro_def.1,\n+                self.def.as_ref().map(|tt| tt.syntax().clone()),\n+                ExpansionOrigin::Def,\n+            ),\n         };\n \n         let range = token_map.range_by_token(token_id)?;\n         let token = algo::find_covering_element(&tt.value, range + tt.value.text_range().start())\n             .into_token()?;\n-        Some(tt.with_value(token))\n+        Some((tt.with_value(token), origin))\n     }\n }\n "}, {"sha": "6a2bf7273117e4a5a6df8030b3bf2c87bb418cb7", "filename": "crates/ra_ide/src/display/navigation_target.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/61360fdfec981eadef1eefb595c8b32c951771e8/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61360fdfec981eadef1eefb595c8b32c951771e8/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fnavigation_target.rs?ref=61360fdfec981eadef1eefb595c8b32c951771e8", "patch": "@@ -7,10 +7,14 @@ use ra_syntax::{\n     ast::{self, DocCommentsOwner, NameOwner},\n     match_ast, AstNode, SmolStr,\n     SyntaxKind::{self, BIND_PAT, TYPE_PARAM},\n-    TextRange,\n+    SyntaxNode, TextRange,\n };\n \n-use crate::{db::RootDatabase, expand::original_range, FileSymbol};\n+use crate::{\n+    db::RootDatabase,\n+    expand::{original_range_by_kind, OriginalRangeKind},\n+    FileRange, FileSymbol,\n+};\n \n use super::short_label::ShortLabel;\n \n@@ -416,3 +420,14 @@ pub(crate) fn description_from_symbol(db: &RootDatabase, symbol: &FileSymbol) ->\n         }\n     }\n }\n+\n+fn original_range(db: &RootDatabase, node: InFile<&SyntaxNode>) -> FileRange {\n+    if let Some(range) = original_range_by_kind(db, node, OriginalRangeKind::CallToken) {\n+        return range;\n+    }\n+    if let Some(range) = original_range_by_kind(db, node, OriginalRangeKind::WholeCall) {\n+        return range;\n+    }\n+\n+    FileRange { file_id: node.file_id.original_file(db), range: node.value.text_range() }\n+}"}, {"sha": "327393dbbec680698fc9d2bcfa05dbd8119abb34", "filename": "crates/ra_ide/src/expand.rs", "status": "modified", "additions": 42, "deletions": 37, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/61360fdfec981eadef1eefb595c8b32c951771e8/crates%2Fra_ide%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61360fdfec981eadef1eefb595c8b32c951771e8/crates%2Fra_ide%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fexpand.rs?ref=61360fdfec981eadef1eefb595c8b32c951771e8", "patch": "@@ -1,57 +1,62 @@\n //! Utilities to work with files, produced by macros.\n use std::iter::successors;\n \n-use hir::InFile;\n+use hir::{ExpansionOrigin, InFile};\n use ra_db::FileId;\n use ra_syntax::{ast, AstNode, SyntaxNode, SyntaxToken, TextRange};\n \n use crate::{db::RootDatabase, FileRange};\n \n-pub(crate) fn original_range(db: &RootDatabase, node: InFile<&SyntaxNode>) -> FileRange {\n-    let expansion = match node.file_id.expansion_info(db) {\n-        None => {\n-            return FileRange {\n-                file_id: node.file_id.original_file(db),\n-                range: node.value.text_range(),\n-            }\n-        }\n-        Some(it) => it,\n-    };\n+#[derive(Debug, PartialEq, Eq)]\n+pub(crate) enum OriginalRangeKind {\n+    /// Return range if any token is matched\n+    #[allow(dead_code)]\n+    Any,\n+    /// Return range if token is inside macro_call\n+    CallToken,\n+    /// Return whole macro call range if matched\n+    WholeCall,\n+}\n+\n+pub(crate) fn original_range_by_kind(\n+    db: &RootDatabase,\n+    node: InFile<&SyntaxNode>,\n+    kind: OriginalRangeKind,\n+) -> Option<FileRange> {\n+    let expansion = node.file_id.expansion_info(db)?;\n+\n+    // the input node has only one token ?\n+    let single = node.value.first_token()? == node.value.last_token()?;\n+\n     // FIXME: We should handle recurside macro expansions\n+    let range = match kind {\n+        OriginalRangeKind::WholeCall => expansion.call_node()?.map(|node| node.text_range()),\n+        _ => node.value.descendants().find_map(|it| {\n+            let first = it.first_token()?;\n+            let last = it.last_token()?;\n \n-    let range = node.value.descendants_with_tokens().find_map(|it| {\n-        match it.as_token() {\n-            // FIXME: Remove this branch after all `tt::TokenTree`s have a proper `TokenId`,\n-            // and return the range of the overall macro expansions if mapping first and last tokens fails.\n-            Some(token) => {\n-                let token = expansion.map_token_up(node.with_value(&token))?;\n-                Some(token.with_value(token.value.text_range()))\n+            if !single && first == last {\n+                return None;\n             }\n-            None => {\n-                // Try to map first and last tokens of node, and, if success, return the union range of mapped tokens\n-                let n = it.into_node()?;\n-                let first = expansion.map_token_up(node.with_value(&n.first_token()?))?;\n-                let last = expansion.map_token_up(node.with_value(&n.last_token()?))?;\n \n-                // FIXME: Is is possible ?\n-                if first.file_id != last.file_id {\n-                    return None;\n-                }\n+            // Try to map first and last tokens of node, and, if success, return the union range of mapped tokens\n+            let (first, first_origin) = expansion.map_token_up(node.with_value(&first))?;\n+            let (last, last_origin) = expansion.map_token_up(node.with_value(&last))?;\n \n-                // FIXME: Add union method in TextRange\n-                let range = union_range(first.value.text_range(), last.value.text_range());\n-                Some(first.with_value(range))\n+            if first.file_id != last.file_id\n+                || first_origin != last_origin\n+                || (kind == OriginalRangeKind::CallToken && first_origin != ExpansionOrigin::Call)\n+            {\n+                return None;\n             }\n-        }\n-    });\n \n-    return match range {\n-        Some(it) => FileRange { file_id: it.file_id.original_file(db), range: it.value },\n-        None => {\n-            FileRange { file_id: node.file_id.original_file(db), range: node.value.text_range() }\n-        }\n+            // FIXME: Add union method in TextRange\n+            Some(first.with_value(union_range(first.value.text_range(), last.value.text_range())))\n+        })?,\n     };\n \n+    return Some(FileRange { file_id: range.file_id.original_file(db), range: range.value });\n+\n     fn union_range(a: TextRange, b: TextRange) -> TextRange {\n         let start = a.start().min(b.start());\n         let end = a.end().max(b.end());"}, {"sha": "2c634990da3a8958a518ef3733c35189df7aa818", "filename": "crates/ra_ide/src/goto_definition.rs", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/61360fdfec981eadef1eefb595c8b32c951771e8/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61360fdfec981eadef1eefb595c8b32c951771e8/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs?ref=61360fdfec981eadef1eefb595c8b32c951771e8", "patch": "@@ -209,7 +209,7 @@ fn named_target(db: &RootDatabase, node: InFile<&SyntaxNode>) -> Option<Navigati\n \n #[cfg(test)]\n mod tests {\n-    use test_utils::covers;\n+    use test_utils::{assert_eq_text, covers};\n \n     use crate::mock_analysis::analysis_and_position;\n \n@@ -222,6 +222,24 @@ mod tests {\n         nav.assert_match(expected);\n     }\n \n+    fn check_goto_with_range_content(fixture: &str, expected: &str, expected_range: &str) {\n+        let (analysis, pos) = analysis_and_position(fixture);\n+\n+        let mut navs = analysis.goto_definition(pos).unwrap().unwrap().info;\n+        assert_eq!(navs.len(), 1);\n+        let nav = navs.pop().unwrap();\n+        let file_text = analysis.file_text(pos.file_id).unwrap();\n+\n+        let actual_full_range = &file_text[nav.full_range()];\n+        let actual_range = &file_text[nav.range()];\n+\n+        test_utils::assert_eq_text!(\n+            &format!(\"{}|{}\", actual_full_range, actual_range),\n+            expected_range\n+        );\n+        nav.assert_match(expected);\n+    }\n+\n     #[test]\n     fn goto_definition_works_in_items() {\n         check_goto(\n@@ -339,28 +357,27 @@ mod tests {\n \n     #[test]\n     fn goto_definition_works_for_macro_defined_fn_with_arg() {\n-        check_goto(\n+        check_goto_with_range_content(\n             \"\n             //- /lib.rs\n             macro_rules! define_fn {\n                 ($name:ident) => (fn $name() {})\n             }\n \n-            define_fn!(\n-                foo\n-            )\n+            define_fn!(foo);\n \n             fn bar() {\n                <|>foo();\n             }\n             \",\n-            \"foo FN_DEF FileId(1) [80; 83) [80; 83)\",\n+            \"foo FN_DEF FileId(1) [64; 80) [75; 78)\",\n+            \"define_fn!(foo);|foo\",\n         );\n     }\n \n     #[test]\n     fn goto_definition_works_for_macro_defined_fn_no_arg() {\n-        check_goto(\n+        check_goto_with_range_content(\n             \"\n             //- /lib.rs\n             macro_rules! define_fn {\n@@ -373,7 +390,8 @@ mod tests {\n                <|>foo();\n             }\n             \",\n-            \"foo FN_DEF FileId(1) [39; 42) [39; 42)\",\n+            \"foo FN_DEF FileId(1) [51; 64) [51; 64)\",\n+            \"define_fn!();|define_fn!();\",\n         );\n     }\n "}]}