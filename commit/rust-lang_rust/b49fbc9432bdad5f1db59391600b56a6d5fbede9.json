{"sha": "b49fbc9432bdad5f1db59391600b56a6d5fbede9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0OWZiYzk0MzJiZGFkNWYxZGI1OTM5MTYwMGI1NmE2ZDVmYmVkZTk=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-11-14T11:47:14Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-11-19T16:25:20Z"}, "message": "expand: Tell built-in macros whether we are currently in forced expansion mode", "tree": {"sha": "4a6eb40c550fa35e7ac91f752f6bf378da0d882d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a6eb40c550fa35e7ac91f752f6bf378da0d882d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b49fbc9432bdad5f1db59391600b56a6d5fbede9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b49fbc9432bdad5f1db59391600b56a6d5fbede9", "html_url": "https://github.com/rust-lang/rust/commit/b49fbc9432bdad5f1db59391600b56a6d5fbede9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b49fbc9432bdad5f1db59391600b56a6d5fbede9/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e2032390cf34f3ffa726b7bd890141e2684ba63", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e2032390cf34f3ffa726b7bd890141e2684ba63", "html_url": "https://github.com/rust-lang/rust/commit/7e2032390cf34f3ffa726b7bd890141e2684ba63"}], "stats": {"total": 82, "additions": 42, "deletions": 40}, "files": [{"sha": "09ed1af345675befdf9ed2678922cbeeafb30153", "filename": "compiler/rustc_builtin_macros/src/cfg_accessible.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b49fbc9432bdad5f1db59391600b56a6d5fbede9/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49fbc9432bdad5f1db59391600b56a6d5fbede9/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs?ref=b49fbc9432bdad5f1db59391600b56a6d5fbede9", "patch": "@@ -1,7 +1,7 @@\n //! Implementation of the `#[cfg_accessible(path)]` attribute macro.\n \n use rustc_ast as ast;\n-use rustc_expand::base::{Annotatable, ExpandResult, ExtCtxt, MultiItemModifier};\n+use rustc_expand::base::{Annotatable, ExpandResult, ExtCtxt, Indeterminate, MultiItemModifier};\n use rustc_feature::AttributeTemplate;\n use rustc_parse::validate_attr;\n use rustc_span::symbol::sym;\n@@ -31,7 +31,7 @@ impl MultiItemModifier for Expander {\n     fn expand(\n         &self,\n         ecx: &mut ExtCtxt<'_>,\n-        _span: Span,\n+        span: Span,\n         meta_item: &ast::MetaItem,\n         item: Annotatable,\n     ) -> ExpandResult<Vec<Annotatable>, Annotatable> {\n@@ -49,11 +49,14 @@ impl MultiItemModifier for Expander {\n             None => return ExpandResult::Ready(Vec::new()),\n         };\n \n-        let failure_msg = \"cannot determine whether the path is accessible or not\";\n         match ecx.resolver.cfg_accessible(ecx.current_expansion.id, path) {\n             Ok(true) => ExpandResult::Ready(vec![item]),\n             Ok(false) => ExpandResult::Ready(Vec::new()),\n-            Err(_) => ExpandResult::Retry(item, failure_msg.into()),\n+            Err(Indeterminate) if ecx.force_mode => {\n+                ecx.span_err(span, \"cannot determine whether the path is accessible or not\");\n+                ExpandResult::Ready(vec![item])\n+            }\n+            Err(Indeterminate) => ExpandResult::Retry(item),\n         }\n     }\n }"}, {"sha": "91617f2df9cb746de43917e1a7ac5e3c7de94a65", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b49fbc9432bdad5f1db59391600b56a6d5fbede9/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49fbc9432bdad5f1db59391600b56a6d5fbede9/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=b49fbc9432bdad5f1db59391600b56a6d5fbede9", "patch": "@@ -251,8 +251,7 @@ pub enum ExpandResult<T, U> {\n     /// Expansion produced a result (possibly dummy).\n     Ready(T),\n     /// Expansion could not produce a result and needs to be retried.\n-    /// The string is an explanation that will be printed if we are stuck in an infinite retry loop.\n-    Retry(U, String),\n+    Retry(U),\n }\n \n // `meta_item` is the attribute, and `item` is the item being modified.\n@@ -919,6 +918,9 @@ pub struct ExtCtxt<'a> {\n     pub root_path: PathBuf,\n     pub resolver: &'a mut dyn ResolverExpand,\n     pub current_expansion: ExpansionData,\n+    /// Error recovery mode entered when expansion is stuck\n+    /// (or during eager expansion, but that's a hack).\n+    pub force_mode: bool,\n     pub expansions: FxHashMap<Span, Vec<String>>,\n     /// Called directly after having parsed an external `mod foo;` in expansion.\n     pub(super) extern_mod_loaded: Option<&'a dyn Fn(&ast::Crate)>,\n@@ -945,6 +947,7 @@ impl<'a> ExtCtxt<'a> {\n                 directory_ownership: DirectoryOwnership::Owned { relative: None },\n                 prior_type_ascription: None,\n             },\n+            force_mode: false,\n             expansions: FxHashMap::default(),\n         }\n     }"}, {"sha": "a0ecc41661799096ba4165667c389069c5b5d64d", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b49fbc9432bdad5f1db59391600b56a6d5fbede9/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49fbc9432bdad5f1db59391600b56a6d5fbede9/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=b49fbc9432bdad5f1db59391600b56a6d5fbede9", "patch": "@@ -404,6 +404,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     // Recursively expand all macro invocations in this AST fragment.\n     pub fn fully_expand_fragment(&mut self, input_fragment: AstFragment) -> AstFragment {\n         let orig_expansion_data = self.cx.current_expansion.clone();\n+        let orig_force_mode = self.cx.force_mode;\n         self.cx.current_expansion.depth = 0;\n \n         // Collect all macro invocations and replace them with placeholders.\n@@ -432,6 +433,12 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 }\n                 invocations = mem::take(&mut undetermined_invocations);\n                 force = !mem::replace(&mut progress, false);\n+                if force && self.monotonic {\n+                    self.cx.sess.delay_span_bug(\n+                        invocations.last().unwrap().0.span(),\n+                        \"expansion entered force mode without producing any errors\",\n+                    );\n+                }\n                 continue;\n             };\n \n@@ -460,18 +467,18 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n             let ExpansionData { depth, id: expn_id, .. } = invoc.expansion_data;\n             self.cx.current_expansion = invoc.expansion_data.clone();\n+            self.cx.force_mode = force;\n \n             // FIXME(jseyfried): Refactor out the following logic\n             let (expanded_fragment, new_invocations) = match res {\n                 InvocationRes::Single(ext) => match self.expand_invoc(invoc, &ext.kind) {\n                     ExpandResult::Ready(fragment) => self.collect_invocations(fragment, &[]),\n-                    ExpandResult::Retry(invoc, explanation) => {\n+                    ExpandResult::Retry(invoc) => {\n                         if force {\n-                            // We are stuck, stop retrying and produce a dummy fragment.\n-                            let span = invoc.span();\n-                            self.cx.span_err(span, &explanation);\n-                            let fragment = invoc.fragment_kind.dummy(span);\n-                            self.collect_invocations(fragment, &[])\n+                            self.cx.span_bug(\n+                                invoc.span(),\n+                                \"expansion entered force mode but is still stuck\",\n+                            );\n                         } else {\n                             // Cannot expand, will retry this invocation later.\n                             undetermined_invocations\n@@ -526,6 +533,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n \n         self.cx.current_expansion = orig_expansion_data;\n+        self.cx.force_mode = orig_force_mode;\n \n         // Finally incorporate all the expanded macros into the input AST fragment.\n         let mut placeholder_expander = PlaceholderExpander::new(self.cx, self.monotonic);\n@@ -735,20 +743,17 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         Ok(meta) => {\n                             let items = match expander.expand(self.cx, span, &meta, item) {\n                                 ExpandResult::Ready(items) => items,\n-                                ExpandResult::Retry(item, explanation) => {\n+                                ExpandResult::Retry(item) => {\n                                     // Reassemble the original invocation for retrying.\n-                                    return ExpandResult::Retry(\n-                                        Invocation {\n-                                            kind: InvocationKind::Attr {\n-                                                attr,\n-                                                item,\n-                                                derives,\n-                                                after_derive,\n-                                            },\n-                                            ..invoc\n+                                    return ExpandResult::Retry(Invocation {\n+                                        kind: InvocationKind::Attr {\n+                                            attr,\n+                                            item,\n+                                            derives,\n+                                            after_derive,\n                                         },\n-                                        explanation,\n-                                    );\n+                                        ..invoc\n+                                    });\n                                 }\n                             };\n                             fragment_kind.expect_from_annotatables(items)\n@@ -781,15 +786,12 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     let meta = ast::MetaItem { kind: ast::MetaItemKind::Word, span, path };\n                     let items = match expander.expand(self.cx, span, &meta, item) {\n                         ExpandResult::Ready(items) => items,\n-                        ExpandResult::Retry(item, explanation) => {\n+                        ExpandResult::Retry(item) => {\n                             // Reassemble the original invocation for retrying.\n-                            return ExpandResult::Retry(\n-                                Invocation {\n-                                    kind: InvocationKind::Derive { path: meta.path, item },\n-                                    ..invoc\n-                                },\n-                                explanation,\n-                            );\n+                            return ExpandResult::Retry(Invocation {\n+                                kind: InvocationKind::Derive { path: meta.path, item },\n+                                ..invoc\n+                            });\n                         }\n                     };\n                     fragment_kind.expect_from_annotatables(items)"}, {"sha": "50504a44c95183b78de472e16b1bd886fb5869ed", "filename": "src/test/ui/conditional-compilation/cfg_accessible-stuck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b49fbc9432bdad5f1db59391600b56a6d5fbede9/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-stuck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49fbc9432bdad5f1db59391600b56a6d5fbede9/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-stuck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-stuck.rs?ref=b49fbc9432bdad5f1db59391600b56a6d5fbede9", "patch": "@@ -1,6 +1,6 @@\n #![feature(cfg_accessible)]\n \n-#[cfg_accessible(Z)] //~ ERROR cannot determine whether the path is accessible or not\n+#[cfg_accessible(Z)] // OK, recovered after the other `cfg_accessible` produces an error.\n struct S;\n \n #[cfg_accessible(S)] //~ ERROR cannot determine whether the path is accessible or not"}, {"sha": "33af7d62548ec2687b4bb0bb58459f0df6a86763", "filename": "src/test/ui/conditional-compilation/cfg_accessible-stuck.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b49fbc9432bdad5f1db59391600b56a6d5fbede9/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-stuck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b49fbc9432bdad5f1db59391600b56a6d5fbede9/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-stuck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-stuck.stderr?ref=b49fbc9432bdad5f1db59391600b56a6d5fbede9", "patch": "@@ -4,11 +4,5 @@ error: cannot determine whether the path is accessible or not\n LL | #[cfg_accessible(S)]\n    | ^^^^^^^^^^^^^^^^^^^^\n \n-error: cannot determine whether the path is accessible or not\n-  --> $DIR/cfg_accessible-stuck.rs:3:1\n-   |\n-LL | #[cfg_accessible(Z)]\n-   | ^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n "}]}