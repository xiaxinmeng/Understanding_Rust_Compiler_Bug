{"sha": "ab7f4e19eb4264b19fb769682bdd5a37ee68c7c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiN2Y0ZTE5ZWI0MjY0YjE5ZmI3Njk2ODJiZGQ1YTM3ZWU2OGM3YzQ=", "commit": {"author": {"name": "St\u00e9phane Campinas", "email": "stephane.campinas@gmail.com", "date": "2018-12-01T22:28:08Z"}, "committer": {"name": "St\u00e9phane Campinas", "email": "stephane.campinas@gmail.com", "date": "2018-12-01T23:22:36Z"}, "message": "rewrite_comment: fix block fallback when failing to rewrite an itemized block\n\nClose #3224", "tree": {"sha": "1f870644b98a9e9249e82cceef5d58baa1fe9852", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f870644b98a9e9249e82cceef5d58baa1fe9852"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab7f4e19eb4264b19fb769682bdd5a37ee68c7c4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQEzBAABCgAdFiEEipi5pnt+pUplKNfibVYg2QghATMFAlwDF8UACgkQbVYg2Qgh\nATPLeQf+IH7+ZFIPdJxPNKcGXVsrGZRkdImZi9VzM/3mRwH5tiUJEDIzlsN0pD+T\n6Jbw+lxN7WP0zYK+VErEUtJnZSaJG248+g5AQ138c3lreWK41a5alpFkAw0pLZqo\nllzFxHoYr09nTGg+sYXOgW4yvZ0BMm7up0xYwQFBHjrChuHfZKMbl7olkIpHiMOG\nBWxNBCcb5srtUjrFDyepRCpNLCdb2BG27jxci1b/XyFJjjYaIctL9/RecwaFZ19d\nUNSv0nH21LEbpUInWz4Hw6SeM4bvGW6B/7QyA6mY/tkJIeJrkz2dEcF4l3beE5Zx\npF4MF9sWbHcvP30HEUeF0MDdC5nGjg==\n=azy+\n-----END PGP SIGNATURE-----", "payload": "tree 1f870644b98a9e9249e82cceef5d58baa1fe9852\nparent 43206f41625b8ad670d65bcad37686b40a1c7c48\nauthor St\u00e9phane Campinas <stephane.campinas@gmail.com> 1543703288 +0100\ncommitter St\u00e9phane Campinas <stephane.campinas@gmail.com> 1543706556 +0100\n\nrewrite_comment: fix block fallback when failing to rewrite an itemized block\n\nClose #3224\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab7f4e19eb4264b19fb769682bdd5a37ee68c7c4", "html_url": "https://github.com/rust-lang/rust/commit/ab7f4e19eb4264b19fb769682bdd5a37ee68c7c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab7f4e19eb4264b19fb769682bdd5a37ee68c7c4/comments", "author": {"login": "scampi", "id": 795879, "node_id": "MDQ6VXNlcjc5NTg3OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/795879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scampi", "html_url": "https://github.com/scampi", "followers_url": "https://api.github.com/users/scampi/followers", "following_url": "https://api.github.com/users/scampi/following{/other_user}", "gists_url": "https://api.github.com/users/scampi/gists{/gist_id}", "starred_url": "https://api.github.com/users/scampi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scampi/subscriptions", "organizations_url": "https://api.github.com/users/scampi/orgs", "repos_url": "https://api.github.com/users/scampi/repos", "events_url": "https://api.github.com/users/scampi/events{/privacy}", "received_events_url": "https://api.github.com/users/scampi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scampi", "id": 795879, "node_id": "MDQ6VXNlcjc5NTg3OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/795879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scampi", "html_url": "https://github.com/scampi", "followers_url": "https://api.github.com/users/scampi/followers", "following_url": "https://api.github.com/users/scampi/following{/other_user}", "gists_url": "https://api.github.com/users/scampi/gists{/gist_id}", "starred_url": "https://api.github.com/users/scampi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scampi/subscriptions", "organizations_url": "https://api.github.com/users/scampi/orgs", "repos_url": "https://api.github.com/users/scampi/repos", "events_url": "https://api.github.com/users/scampi/events{/privacy}", "received_events_url": "https://api.github.com/users/scampi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43206f41625b8ad670d65bcad37686b40a1c7c48", "url": "https://api.github.com/repos/rust-lang/rust/commits/43206f41625b8ad670d65bcad37686b40a1c7c48", "html_url": "https://github.com/rust-lang/rust/commit/43206f41625b8ad670d65bcad37686b40a1c7c48"}], "stats": {"total": 55, "additions": 35, "deletions": 20}, "files": [{"sha": "2a4db512091406a83f99bc663da7130afc793d58", "filename": "src/comment.rs", "status": "modified", "additions": 35, "deletions": 20, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/ab7f4e19eb4264b19fb769682bdd5a37ee68c7c4/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7f4e19eb4264b19fb769682bdd5a37ee68c7c4/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=ab7f4e19eb4264b19fb769682bdd5a37ee68c7c4", "patch": "@@ -416,6 +416,8 @@ impl CodeBlockAttribute {\n /// An item starts with either a star `*` or a dash `-`. Different level of indentation are\n /// handled by shrinking the shape accordingly.\n struct ItemizedBlock {\n+    /// the lines that are identified as part of an itemized block\n+    lines: Vec<String>,\n     /// the number of whitespaces up to the item sigil\n     indent: usize,\n     /// the string that marks the start of an item\n@@ -437,6 +439,7 @@ impl ItemizedBlock {\n         let space_to_sigil = line.chars().take_while(|c| c.is_whitespace()).count();\n         let indent = space_to_sigil + 2;\n         ItemizedBlock {\n+            lines: vec![line[indent..].to_string()],\n             indent,\n             opener: line[..indent].to_string(),\n             line_start: \" \".repeat(indent),\n@@ -456,10 +459,32 @@ impl ItemizedBlock {\n         }\n     }\n \n-    /// Returns true if the line is part of the current itemized block\n-    fn in_block(&self, line: &str) -> bool {\n-        !ItemizedBlock::is_itemized_line(line)\n+    /// Returns true if the line is part of the current itemized block.\n+    /// If it is, then it is added to the internal lines vec.\n+    fn add_line(&mut self, line: &str) -> bool {\n+        if !ItemizedBlock::is_itemized_line(line)\n             && self.indent <= line.chars().take_while(|c| c.is_whitespace()).count()\n+        {\n+            self.lines.push(line.to_string());\n+            return true;\n+        }\n+        false\n+    }\n+\n+    /// Returns the block as a string, with each line trimmed at the start.\n+    fn trimmed_block_as_string(&self) -> String {\n+        self.lines\n+            .iter()\n+            .map(|line| format!(\"{} \", line.trim_start()))\n+            .collect::<String>()\n+    }\n+\n+    /// Returns the block as a string under its original form\n+    fn original_block_as_string(&self) -> String {\n+        self.lines\n+            .iter()\n+            .map(|line| format!(\"{}\\n\", line))\n+            .collect::<String>()\n     }\n }\n \n@@ -468,7 +493,6 @@ struct CommentRewrite<'a> {\n     code_block_buffer: String,\n     is_prev_line_multi_line: bool,\n     code_block_attr: Option<CodeBlockAttribute>,\n-    item_block_buffer: String,\n     item_block: Option<ItemizedBlock>,\n     comment_line_separator: String,\n     indent_str: String,\n@@ -506,7 +530,6 @@ impl<'a> CommentRewrite<'a> {\n             code_block_buffer: String::with_capacity(128),\n             is_prev_line_multi_line: false,\n             code_block_attr: None,\n-            item_block_buffer: String::with_capacity(128),\n             item_block: None,\n             comment_line_separator: format!(\"{}{}\", indent_str, line_start),\n             max_chars,\n@@ -556,17 +579,14 @@ impl<'a> CommentRewrite<'a> {\n             ));\n         }\n \n-        if !self.item_block_buffer.is_empty() {\n+        if let Some(ref ib) = self.item_block {\n             // the last few lines are part of an itemized block\n             self.fmt.shape = Shape::legacy(self.max_chars, self.fmt_indent);\n-            let mut ib = None;\n-            ::std::mem::swap(&mut ib, &mut self.item_block);\n-            let ib = ib.unwrap();\n             let item_fmt = ib.create_string_format(&self.fmt);\n             self.result.push_str(&self.comment_line_separator);\n             self.result.push_str(&ib.opener);\n             match rewrite_string(\n-                &self.item_block_buffer.replace(\"\\n\", \" \"),\n+                &ib.trimmed_block_as_string(),\n                 &item_fmt,\n                 self.max_chars.saturating_sub(ib.indent),\n             ) {\n@@ -575,7 +595,7 @@ impl<'a> CommentRewrite<'a> {\n                     &format!(\"{}{}\", &self.comment_line_separator, ib.line_start),\n                 )),\n                 None => self.result.push_str(&Self::join_block(\n-                    &self.item_block_buffer,\n+                    &ib.original_block_as_string(),\n                     &self.comment_line_separator,\n                 )),\n             };\n@@ -599,10 +619,8 @@ impl<'a> CommentRewrite<'a> {\n     ) -> bool {\n         let is_last = i == count_newlines(orig);\n \n-        if let Some(ref ib) = self.item_block {\n-            if ib.in_block(&line) {\n-                self.item_block_buffer.push_str(line.trim_start());\n-                self.item_block_buffer.push('\\n');\n+        if let Some(ref mut ib) = self.item_block {\n+            if ib.add_line(&line) {\n                 return false;\n             }\n             self.is_prev_line_multi_line = false;\n@@ -611,7 +629,7 @@ impl<'a> CommentRewrite<'a> {\n             self.result.push_str(&self.comment_line_separator);\n             self.result.push_str(&ib.opener);\n             match rewrite_string(\n-                &self.item_block_buffer.replace(\"\\n\", \" \"),\n+                &ib.trimmed_block_as_string(),\n                 &item_fmt,\n                 self.max_chars.saturating_sub(ib.indent),\n             ) {\n@@ -620,11 +638,10 @@ impl<'a> CommentRewrite<'a> {\n                     &format!(\"{}{}\", &self.comment_line_separator, ib.line_start),\n                 )),\n                 None => self.result.push_str(&Self::join_block(\n-                    &self.item_block_buffer,\n+                    &ib.original_block_as_string(),\n                     &self.comment_line_separator,\n                 )),\n             };\n-            self.item_block_buffer.clear();\n         } else if self.code_block_attr.is_some() {\n             if line.starts_with(\"```\") {\n                 let code_block = match self.code_block_attr.as_ref().unwrap() {\n@@ -664,8 +681,6 @@ impl<'a> CommentRewrite<'a> {\n             self.code_block_attr = Some(CodeBlockAttribute::new(&line[3..]))\n         } else if self.fmt.config.wrap_comments() && ItemizedBlock::is_itemized_line(&line) {\n             let ib = ItemizedBlock::new(&line);\n-            self.item_block_buffer.push_str(&line[ib.indent..]);\n-            self.item_block_buffer.push('\\n');\n             self.item_block = Some(ib);\n             return false;\n         }"}]}