{"sha": "ec897f9156332a1d1bb39975bfcfc32a3ea8e473", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjODk3ZjkxNTYzMzJhMWQxYmIzOTk3NWJmY2ZjMzJhM2VhOGU0NzM=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-07-22T14:35:39Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-07-22T14:35:39Z"}, "message": "don't allow runtime-aligning of memory", "tree": {"sha": "1d54002e90b29f21698cfe8ba82e639a86e8a150", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d54002e90b29f21698cfe8ba82e639a86e8a150"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec897f9156332a1d1bb39975bfcfc32a3ea8e473", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJXki87AAoJEFbW7qD8Z6xGwdYQAJuJtMroc+dnSUbu+BNdvMS4\nd6PBhTfyD3rdWSKBo2Uf31SZKYizUV3vc8nRMG9gW57RXlAlnZmV+iKQnhOKqrku\nRqXfFvua1qfxW4RA3i5ZVHhbobhes7yosFdjAM3VqPbIbkGfCkd0dwWGivBcvfKy\nzIaBGCMY8G2e+uqCqZ+uYU+ixFkCt55YamwSEIm2yFABvCJtSFTxWcZcxhNcC1VV\ndRoZXI9cWzENzKRjWksYZwj6zlzFGPPPDOcXU2pwiNZmrnYkEXto3MoHXepHNj+F\nrpARfAq6V983PpEWd5CMrzMNppQ5ZwGovxnNPe9ZTUDErTP6irnr5s/lM09dbos1\naZlfL5dnlEf/I2olKC/++SY53l+A028H0bN/3udvGjwCOnQTP3Uxfc51lRWyForL\nVxledWq1pr2Y7DhC4/wDagyN5JT20IgwctDJs34vKL4CjOPO19SvGAWThCQjGFHO\nB5uS21p3L82GDB6+7j5GT+lm1ckyPqalQWi0uPUUT6OWsDrnSnfYFg+fmgxEKEfn\nPSELylDg0IsrEsc2LkSrIGdlzx4MjiSBTTCJVn68L1Ewz3tQUdSwchIHOLIuRD6G\nyWpGV1Q7g9GxHEBMHa/m0fqt/QYgzf+Qb7YaMIAQEAxivah0yAC1DR3DoWLJ2XLr\nFKscqS+EmFUfIA4ZM+oH\n=/YDE\n-----END PGP SIGNATURE-----", "payload": "tree 1d54002e90b29f21698cfe8ba82e639a86e8a150\nparent 613d15c672b3a857521ebd15daef384e2ae997f3\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1469198139 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1469198139 +0200\n\ndon't allow runtime-aligning of memory"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec897f9156332a1d1bb39975bfcfc32a3ea8e473", "html_url": "https://github.com/rust-lang/rust/commit/ec897f9156332a1d1bb39975bfcfc32a3ea8e473", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec897f9156332a1d1bb39975bfcfc32a3ea8e473/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "613d15c672b3a857521ebd15daef384e2ae997f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/613d15c672b3a857521ebd15daef384e2ae997f3", "html_url": "https://github.com/rust-lang/rust/commit/613d15c672b3a857521ebd15daef384e2ae997f3"}], "stats": {"total": 166, "additions": 79, "deletions": 87}, "files": [{"sha": "c1e1fff999fd3a74395888077e69eb2ee06743d0", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ec897f9156332a1d1bb39975bfcfc32a3ea8e473/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec897f9156332a1d1bb39975bfcfc32a3ea8e473/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=ec897f9156332a1d1bb39975bfcfc32a3ea8e473", "patch": "@@ -535,11 +535,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 };\n \n                 let src = self.eval_operand(operand)?;\n-                src.check_align(elem_align)?;\n-                dest.check_align(elem_align)?;\n                 for i in 0..length {\n                     let elem_dest = dest.offset((i * elem_size) as isize);\n-                    self.memory.copy(src, elem_dest, elem_size)?;\n+                    self.memory.copy(src, elem_dest, elem_size, elem_align)?;\n                 }\n             }\n \n@@ -603,17 +601,17 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         let src = self.eval_operand(operand)?;\n                         let src_ty = self.operand_ty(operand);\n                         // FIXME(solson): Wrong for almost everything.\n-                        // FIXME: check alignment\n                         warn!(\"misc cast from {:?} to {:?}\", src_ty, dest_ty);\n                         let dest_size = self.type_size(dest_ty);\n                         let src_size = self.type_size(src_ty);\n+                        let dest_align = self.type_align(dest_ty);\n \n                         // Hack to support fat pointer -> thin pointer casts to keep tests for\n                         // other things passing for now.\n                         let is_fat_ptr_cast = pointee_type(src_ty).map_or(false, |ty| !self.type_is_sized(ty));\n \n                         if dest_size == src_size || is_fat_ptr_cast {\n-                            self.memory.copy(src, dest, dest_size)?;\n+                            self.memory.copy(src, dest, dest_size, dest_align)?;\n                         } else {\n                             return Err(EvalError::Unimplemented(format!(\"can't handle cast: {:?}\", rvalue)));\n                         }\n@@ -858,9 +856,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     fn move_(&mut self, src: Pointer, dest: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, ()> {\n         let size = self.type_size(ty);\n         let align = self.type_align(ty);\n-        src.check_align(align)?;\n-        dest.check_align(align)?;\n-        self.memory.copy(src, dest, size)?;\n+        self.memory.copy(src, dest, size, align)?;\n         Ok(())\n     }\n "}, {"sha": "568d8358f0874d6c3a93cf80610c909669896e3c", "filename": "src/interpreter/terminator.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec897f9156332a1d1bb39975bfcfc32a3ea8e473/src%2Finterpreter%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec897f9156332a1d1bb39975bfcfc32a3ea8e473/src%2Finterpreter%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator.rs?ref=ec897f9156332a1d1bb39975bfcfc32a3ea8e473", "patch": "@@ -291,11 +291,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let elem_size = self.type_size(elem_ty);\n                 let elem_align = self.type_align(elem_ty);\n                 let src = self.memory.read_ptr(args_ptrs[0])?;\n-                src.check_align(elem_align)?;\n                 let dest = self.memory.read_ptr(args_ptrs[1])?;\n-                dest.check_align(elem_align)?;\n                 let count = self.memory.read_isize(args_ptrs[2])?;\n-                self.memory.copy(src, dest, count as usize * elem_size)?;\n+                self.memory.copy(src, dest, count as usize * elem_size, elem_align)?;\n             }\n \n             \"discriminant_value\" => {"}, {"sha": "91ae90da8b6f6b767709b3764b9a2810b355c1f4", "filename": "src/memory.rs", "status": "modified", "additions": 70, "deletions": 72, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/ec897f9156332a1d1bb39975bfcfc32a3ea8e473/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec897f9156332a1d1bb39975bfcfc32a3ea8e473/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=ec897f9156332a1d1bb39975bfcfc32a3ea8e473", "patch": "@@ -51,25 +51,6 @@ impl Pointer {\n             offset: 0,\n         }\n     }\n-    pub fn is_aligned_to(&self, align: usize) -> bool {\n-        self.offset % align == 0\n-    }\n-    pub fn check_align(&self, align: usize) -> EvalResult<'static, ()> {\n-        if self.is_aligned_to(align) {\n-            Ok(())\n-        } else {\n-            let mut best = self.offset;\n-            let mut i = 1;\n-            while best > 0 && (best & 1 == 0) {\n-                best >>= 1;\n-                i <<= 1;\n-            }\n-            Err(EvalError::AlignmentCheckFailed {\n-                required: align,\n-                has: i,\n-            })\n-        }\n-    }\n }\n \n #[derive(Debug, Copy, Clone, Hash, Eq, PartialEq)]\n@@ -118,11 +99,11 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             bytes: Vec::new(),\n             relocations: BTreeMap::new(),\n             undef_mask: UndefMask::new(0),\n-            align: 0,\n+            align: 1,\n         };\n         mem.alloc_map.insert(ZST_ALLOC_ID, alloc);\n         // check that additional zst allocs work\n-        debug_assert!(mem.allocate(0, 0).unwrap().points_to_zst());\n+        debug_assert!(mem.allocate(0, 1).unwrap().points_to_zst());\n         debug_assert!(mem.get(ZST_ALLOC_ID).is_ok());\n         mem\n     }\n@@ -155,40 +136,38 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     }\n \n     pub fn allocate(&mut self, size: usize, align: usize) -> EvalResult<'tcx, Pointer> {\n+        assert!(align != 0);\n         if size == 0 {\n             return Ok(Pointer::zst_ptr());\n         }\n-        // make sure we can offset the result pointer by the worst possible alignment\n-        // this allows cheaply checking for alignment directly in the pointer\n-        let least_aligned_size = size + align;\n         if self.memory_size - self.memory_usage < size {\n             return Err(EvalError::OutOfMemory {\n-                allocation_size: least_aligned_size,\n+                allocation_size: size,\n                 memory_size: self.memory_size,\n                 memory_usage: self.memory_usage,\n             });\n         }\n         self.memory_usage += size;\n         let alloc = Allocation {\n-            bytes: vec![0; least_aligned_size],\n+            bytes: vec![0; size],\n             relocations: BTreeMap::new(),\n-            undef_mask: UndefMask::new(least_aligned_size),\n+            undef_mask: UndefMask::new(size),\n             align: align,\n         };\n         let id = self.next_id;\n         self.next_id.0 += 1;\n         self.alloc_map.insert(id, alloc);\n         Ok(Pointer {\n             alloc_id: id,\n-            // offset by the alignment, so larger accesses will fail\n-            offset: align,\n+            offset: 0,\n         })\n     }\n \n     // TODO(solson): Track which allocations were returned from __rust_allocate and report an error\n     // when reallocating/deallocating any others.\n     pub fn reallocate(&mut self, ptr: Pointer, new_size: usize, align: usize) -> EvalResult<'tcx, Pointer> {\n-        if ptr.offset != self.get(ptr.alloc_id)?.align {\n+        // TODO(solson): Report error about non-__rust_allocate'd pointer.\n+        if ptr.offset != 0 {\n             // TODO(solson): Report error about non-__rust_allocate'd pointer.\n             return Err(EvalError::Unimplemented(format!(\"bad pointer offset: {}\", ptr.offset)));\n         }\n@@ -197,27 +176,26 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n \n         let size = self.get(ptr.alloc_id)?.bytes.len();\n-        let least_aligned_size = new_size + align;\n \n-        if least_aligned_size > size {\n-            let amount = least_aligned_size - size;\n+        if new_size > size {\n+            let amount = new_size - size;\n             self.memory_usage += amount;\n             let alloc = self.get_mut(ptr.alloc_id)?;\n             alloc.bytes.extend(iter::repeat(0).take(amount));\n             alloc.undef_mask.grow(amount, false);\n-        } else if size > least_aligned_size {\n+        } else if size > new_size {\n             // it's possible to cause miri to use arbitrary amounts of memory that aren't detectable\n             // through the memory_usage value, by allocating a lot and reallocating to zero\n-            self.memory_usage -= size - least_aligned_size;\n-            self.clear_relocations(ptr.offset(least_aligned_size as isize), size - least_aligned_size)?;\n+            self.memory_usage -= size - new_size;\n+            self.clear_relocations(ptr.offset(new_size as isize), size - new_size)?;\n             let alloc = self.get_mut(ptr.alloc_id)?;\n-            alloc.bytes.truncate(least_aligned_size);\n-            alloc.undef_mask.truncate(least_aligned_size);\n+            alloc.bytes.truncate(new_size);\n+            alloc.undef_mask.truncate(new_size);\n         }\n \n         Ok(Pointer {\n             alloc_id: ptr.alloc_id,\n-            offset: align,\n+            offset: 0,\n         })\n     }\n \n@@ -226,7 +204,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         if ptr.points_to_zst() {\n             return Ok(());\n         }\n-        if ptr.offset != self.get(ptr.alloc_id)?.align {\n+        if ptr.offset != 0 {\n             // TODO(solson): Report error about non-__rust_allocate'd pointer.\n             return Err(EvalError::Unimplemented(format!(\"bad pointer offset: {}\", ptr.offset)));\n         }\n@@ -251,6 +229,24 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     pub fn endianess(&self) -> layout::Endian {\n         self.layout.endian\n     }\n+\n+    pub fn check_align(&self, ptr: Pointer, align: usize) -> EvalResult<'tcx, ()> {\n+        let alloc = self.get(ptr.alloc_id)?;\n+        if alloc.align < align {\n+            return Err(EvalError::AlignmentCheckFailed {\n+                has: alloc.align,\n+                required: align,\n+            });\n+        }\n+        if ptr.offset % align == 0 {\n+            Ok(())\n+        } else {\n+            Err(EvalError::AlignmentCheckFailed {\n+                has: ptr.offset % align,\n+                required: align,\n+            })\n+        }\n+    }\n }\n \n /// Allocation accessors\n@@ -368,15 +364,17 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(&mut alloc.bytes[ptr.offset..ptr.offset + size])\n     }\n \n-    fn get_bytes(&self, ptr: Pointer, size: usize) -> EvalResult<'tcx, &[u8]> {\n+    fn get_bytes(&self, ptr: Pointer, size: usize, align: usize) -> EvalResult<'tcx, &[u8]> {\n+        self.check_align(ptr, align)?;\n         if self.relocations(ptr, size)?.count() != 0 {\n             return Err(EvalError::ReadPointerAsBytes);\n         }\n         self.check_defined(ptr, size)?;\n         self.get_bytes_unchecked(ptr, size)\n     }\n \n-    fn get_bytes_mut(&mut self, ptr: Pointer, size: usize) -> EvalResult<'tcx, &mut [u8]> {\n+    fn get_bytes_mut(&mut self, ptr: Pointer, size: usize, align: usize) -> EvalResult<'tcx, &mut [u8]> {\n+        self.check_align(ptr, align)?;\n         self.clear_relocations(ptr, size)?;\n         self.mark_definedness(ptr, size, true)?;\n         self.get_bytes_unchecked_mut(ptr, size)\n@@ -385,11 +383,11 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n /// Reading and writing\n impl<'a, 'tcx> Memory<'a, 'tcx> {\n-    pub fn copy(&mut self, src: Pointer, dest: Pointer, size: usize) -> EvalResult<'tcx, ()> {\n+    pub fn copy(&mut self, src: Pointer, dest: Pointer, size: usize, align: usize) -> EvalResult<'tcx, ()> {\n         self.check_relocation_edges(src, size)?;\n \n         let src_bytes = self.get_bytes_unchecked_mut(src, size)?.as_mut_ptr();\n-        let dest_bytes = self.get_bytes_mut(dest, size)?.as_mut_ptr();\n+        let dest_bytes = self.get_bytes_mut(dest, size, align)?.as_mut_ptr();\n \n         // SAFE: The above indexing would have panicked if there weren't at least `size` bytes\n         // behind `src` and `dest`. Also, we use the overlapping-safe `ptr::copy` if `src` and\n@@ -409,17 +407,17 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     }\n \n     pub fn read_bytes(&self, ptr: Pointer, size: usize) -> EvalResult<'tcx, &[u8]> {\n-        self.get_bytes(ptr, size)\n+        self.get_bytes(ptr, size, 1)\n     }\n \n     pub fn write_bytes(&mut self, ptr: Pointer, src: &[u8]) -> EvalResult<'tcx, ()> {\n-        let bytes = self.get_bytes_mut(ptr, src.len())?;\n+        let bytes = self.get_bytes_mut(ptr, src.len(), 1)?;\n         bytes.clone_from_slice(src);\n         Ok(())\n     }\n \n     pub fn write_repeat(&mut self, ptr: Pointer, val: u8, count: usize) -> EvalResult<'tcx, ()> {\n-        let bytes = self.get_bytes_mut(ptr, count)?;\n+        let bytes = self.get_bytes_mut(ptr, count, 1)?;\n         for b in bytes { *b = val; }\n         Ok(())\n     }\n@@ -465,8 +463,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     }\n \n     pub fn read_bool(&self, ptr: Pointer) -> EvalResult<'tcx, bool> {\n-        ptr.check_align(self.layout.i1_align.abi() as usize)?;\n-        let bytes = self.get_bytes(ptr, 1)?;\n+        let bytes = self.get_bytes(ptr, 1, self.layout.i1_align.abi() as usize)?;\n         match bytes[0] {\n             0 => Ok(false),\n             1 => Ok(true),\n@@ -475,42 +472,43 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     }\n \n     pub fn write_bool(&mut self, ptr: Pointer, b: bool) -> EvalResult<'tcx, ()> {\n-        ptr.check_align(self.layout.i1_align.abi() as usize)?;\n-        self.get_bytes_mut(ptr, 1).map(|bytes| bytes[0] = b as u8)\n+        let align = self.layout.i1_align.abi() as usize;\n+        self.get_bytes_mut(ptr, 1, align)\n+            .map(|bytes| bytes[0] = b as u8)\n     }\n \n-    fn check_int_align(&self, ptr: Pointer, size: usize) -> EvalResult<'tcx, ()> {\n+    fn int_align(&self, size: usize) -> EvalResult<'tcx, usize> {\n         match size {\n-            1 => ptr.check_align(self.layout.i8_align.abi() as usize),\n-            2 => ptr.check_align(self.layout.i16_align.abi() as usize),\n-            4 => ptr.check_align(self.layout.i32_align.abi() as usize),\n-            8 => ptr.check_align(self.layout.i64_align.abi() as usize),\n+            1 => Ok(self.layout.i8_align.abi() as usize),\n+            2 => Ok(self.layout.i16_align.abi() as usize),\n+            4 => Ok(self.layout.i32_align.abi() as usize),\n+            8 => Ok(self.layout.i64_align.abi() as usize),\n             _ => panic!(\"bad integer size\"),\n         }\n     }\n \n     pub fn read_int(&self, ptr: Pointer, size: usize) -> EvalResult<'tcx, i64> {\n-        self.check_int_align(ptr, size)?;\n-        self.get_bytes(ptr, size).map(|b| read_target_int(self.endianess(), b).unwrap())\n+        let align = self.int_align(size)?;\n+        self.get_bytes(ptr, size, align).map(|b| read_target_int(self.endianess(), b).unwrap())\n     }\n \n     pub fn write_int(&mut self, ptr: Pointer, n: i64, size: usize) -> EvalResult<'tcx, ()> {\n-        self.check_int_align(ptr, size)?;\n+        let align = self.int_align(size)?;\n         let endianess = self.endianess();\n-        let b = self.get_bytes_mut(ptr, size)?;\n+        let b = self.get_bytes_mut(ptr, size, align)?;\n         write_target_int(endianess, b, n).unwrap();\n         Ok(())\n     }\n \n     pub fn read_uint(&self, ptr: Pointer, size: usize) -> EvalResult<'tcx, u64> {\n-        self.check_int_align(ptr, size)?;\n-        self.get_bytes(ptr, size).map(|b| read_target_uint(self.endianess(), b).unwrap())\n+        let align = self.int_align(size)?;\n+        self.get_bytes(ptr, size, align).map(|b| read_target_uint(self.endianess(), b).unwrap())\n     }\n \n     pub fn write_uint(&mut self, ptr: Pointer, n: u64, size: usize) -> EvalResult<'tcx, ()> {\n-        self.check_int_align(ptr, size)?;\n+        let align = self.int_align(size)?;\n         let endianess = self.endianess();\n-        let b = self.get_bytes_mut(ptr, size)?;\n+        let b = self.get_bytes_mut(ptr, size, align)?;\n         write_target_uint(endianess, b, n).unwrap();\n         Ok(())\n     }\n@@ -534,29 +532,29 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     }\n \n     pub fn write_f32(&mut self, ptr: Pointer, f: f32) -> EvalResult<'tcx, ()> {\n-        ptr.check_align(self.layout.f32_align.abi() as usize)?;\n         let endianess = self.endianess();\n-        let b = self.get_bytes_mut(ptr, 4)?;\n+        let align = self.layout.f32_align.abi() as usize;\n+        let b = self.get_bytes_mut(ptr, 4, align)?;\n         write_target_f32(endianess, b, f).unwrap();\n         Ok(())\n     }\n \n     pub fn write_f64(&mut self, ptr: Pointer, f: f64) -> EvalResult<'tcx, ()> {\n-        ptr.check_align(self.layout.f64_align.abi() as usize)?;\n         let endianess = self.endianess();\n-        let b = self.get_bytes_mut(ptr, 8)?;\n+        let align = self.layout.f64_align.abi() as usize;\n+        let b = self.get_bytes_mut(ptr, 8, align)?;\n         write_target_f64(endianess, b, f).unwrap();\n         Ok(())\n     }\n \n     pub fn read_f32(&self, ptr: Pointer) -> EvalResult<'tcx, f32> {\n-        ptr.check_align(self.layout.f32_align.abi() as usize)?;\n-        self.get_bytes(ptr, 4).map(|b| read_target_f32(self.endianess(), b).unwrap())\n+        self.get_bytes(ptr, 4, self.layout.f32_align.abi() as usize)\n+            .map(|b| read_target_f32(self.endianess(), b).unwrap())\n     }\n \n     pub fn read_f64(&self, ptr: Pointer) -> EvalResult<'tcx, f64> {\n-        ptr.check_align(self.layout.f64_align.abi() as usize)?;\n-        self.get_bytes(ptr, 8).map(|b| read_target_f64(self.endianess(), b).unwrap())\n+        self.get_bytes(ptr, 8, self.layout.f64_align.abi() as usize)\n+            .map(|b| read_target_f64(self.endianess(), b).unwrap())\n     }\n }\n "}, {"sha": "83109a77e62016961643d2434aac5178dc05f023", "filename": "tests/compile-fail/oom.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec897f9156332a1d1bb39975bfcfc32a3ea8e473/tests%2Fcompile-fail%2Foom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec897f9156332a1d1bb39975bfcfc32a3ea8e473/tests%2Fcompile-fail%2Foom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Foom.rs?ref=ec897f9156332a1d1bb39975bfcfc32a3ea8e473", "patch": "@@ -6,6 +6,6 @@ fn bar() {\n     assert_eq!(x, 6);\n }\n \n-fn main() { //~ ERROR tried to allocate 8 more bytes, but only 0 bytes are free of the 0 byte memory\n+fn main() { //~ ERROR tried to allocate 4 more bytes, but only 0 bytes are free of the 0 byte memory\n     bar();\n }"}, {"sha": "63c51dbaa7d2689cef85d3ee94a14272d7a241aa", "filename": "tests/compile-fail/oom2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec897f9156332a1d1bb39975bfcfc32a3ea8e473/tests%2Fcompile-fail%2Foom2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec897f9156332a1d1bb39975bfcfc32a3ea8e473/tests%2Fcompile-fail%2Foom2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Foom2.rs?ref=ec897f9156332a1d1bb39975bfcfc32a3ea8e473", "patch": "@@ -3,7 +3,7 @@\n \n fn bar(i: i32) {\n     if i < 1000 {\n-        bar(i + 1) //~ ERROR tried to allocate 8 more bytes, but only 1 bytes are free of the 1000 byte memory\n+        bar(i + 1) //~ ERROR tried to allocate 4 more bytes, but only 1 bytes are free of the 1000 byte memory\n         //~^NOTE inside call to bar\n         //~|NOTE inside call to bar\n         //~|NOTE inside call to bar"}, {"sha": "f6a305840c241be8213fbad1c5c11532e3f27a35", "filename": "tests/compile-fail/out_of_bounds_read.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec897f9156332a1d1bb39975bfcfc32a3ea8e473/tests%2Fcompile-fail%2Fout_of_bounds_read.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec897f9156332a1d1bb39975bfcfc32a3ea8e473/tests%2Fcompile-fail%2Fout_of_bounds_read.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fout_of_bounds_read.rs?ref=ec897f9156332a1d1bb39975bfcfc32a3ea8e473", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n     let v: Vec<u8> = vec![1, 2];\n-    let x = unsafe { *v.get_unchecked(5) }; //~ ERROR: which has size 3\n+    let x = unsafe { *v.get_unchecked(5) }; //~ ERROR: which has size 2\n     panic!(\"this should never print: {}\", x);\n }"}, {"sha": "5509a8346e552b323f16fb755ab46cd8aff3ce9c", "filename": "tests/compile-fail/out_of_bounds_read2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec897f9156332a1d1bb39975bfcfc32a3ea8e473/tests%2Fcompile-fail%2Fout_of_bounds_read2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec897f9156332a1d1bb39975bfcfc32a3ea8e473/tests%2Fcompile-fail%2Fout_of_bounds_read2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fout_of_bounds_read2.rs?ref=ec897f9156332a1d1bb39975bfcfc32a3ea8e473", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n     let v: Vec<u8> = vec![1, 2];\n-    let x = unsafe { *v.get_unchecked(5) }; //~ ERROR: memory access of 6..7 outside bounds of allocation\n+    let x = unsafe { *v.get_unchecked(5) }; //~ ERROR: memory access of 5..6 outside bounds of allocation\n     panic!(\"this should never print: {}\", x);\n }"}]}