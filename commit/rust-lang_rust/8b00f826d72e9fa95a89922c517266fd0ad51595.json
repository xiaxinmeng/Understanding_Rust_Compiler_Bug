{"sha": "8b00f826d72e9fa95a89922c517266fd0ad51595", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiMDBmODI2ZDcyZTlmYTk1YTg5OTIyYzUxNzI2NmZkMGFkNTE1OTU=", "commit": {"author": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2017-06-11T23:25:26Z"}, "committer": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2017-06-11T23:25:26Z"}, "message": "Merge branch 'master' into never_loop", "tree": {"sha": "a471264010ca7b636d2cbaa14bb622dc7d4ed028", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a471264010ca7b636d2cbaa14bb622dc7d4ed028"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b00f826d72e9fa95a89922c517266fd0ad51595", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b00f826d72e9fa95a89922c517266fd0ad51595", "html_url": "https://github.com/rust-lang/rust/commit/8b00f826d72e9fa95a89922c517266fd0ad51595", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b00f826d72e9fa95a89922c517266fd0ad51595/comments", "author": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f374824b187b7d013e958593f45c7943e36949e", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f374824b187b7d013e958593f45c7943e36949e", "html_url": "https://github.com/rust-lang/rust/commit/4f374824b187b7d013e958593f45c7943e36949e"}, {"sha": "55cb63adfe08a22efcb668d4f7dd02c89eb5835f", "url": "https://api.github.com/repos/rust-lang/rust/commits/55cb63adfe08a22efcb668d4f7dd02c89eb5835f", "html_url": "https://github.com/rust-lang/rust/commit/55cb63adfe08a22efcb668d4f7dd02c89eb5835f"}], "stats": {"total": 835, "additions": 427, "deletions": 408}, "files": [{"sha": "837f160f770d325ed64a203dc0fa88b4dfbed7f4", "filename": "CHANGELOG.md", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -1,25 +1,36 @@\n # Change Log\n All notable changes to this project will be documented in this file.\n \n-## 0.0.136 - 2017-05-26\n+## 0.0.139 \u2014 2017-06-10\n+* Update to *rustc 1.19.0-nightly (4bf5c99af 2017-06-10)*\n+* Fix bugs with for loop desugaring\n+* Check for AsRef/AsMut arguments in wrong_self_convention\n+\n+## 0.0.138 \u2014 2017-06-05\n+* Update to *rustc 1.19.0-nightly (0418fa9d3 2017-06-04)*\n+\n+## 0.0.137 \u2014 2017-06-05\n+* Update to *rustc 1.19.0-nightly (6684d176c 2017-06-03)*\n+\n+## 0.0.136 \u2014 2017\u201405\u201426\n * Update to *rustc 1.19.0-nightly (557967766 2017-05-26)*\n \n-## 0.0.135 - 2017-05-24\n+## 0.0.135 \u2014 2017\u201405\u201424\n * Update to *rustc 1.19.0-nightly (5b13bff52 2017-05-23)*\n \n-## 0.0.134 - 2017-05-19\n+## 0.0.134 \u2014 2017\u201405\u201419\n * Update to *rustc 1.19.0-nightly (0ed1ec9f9 2017-05-18)*\n \n-## 0.0.133 - 2017-05-14\n+## 0.0.133 \u2014 2017\u201405\u201414\n * Update to *rustc 1.19.0-nightly (826d8f385 2017-05-13)*\n \n-## 0.0.132 - 2017-05-05\n+## 0.0.132 \u2014 2017\u201405\u201405\n * Fix various bugs and some ices\n \n-## 0.0.131 - 2017-05-04\n+## 0.0.131 \u2014 2017\u201405\u201404\n * Update to *rustc 1.19.0-nightly (2d4ed8e0c 2017-05-03)*\n \n-## 0.0.130 - 2017-05-03\n+## 0.0.130 \u2014 2017\u201405\u201403\n * Update to *rustc 1.19.0-nightly (6a5fc9eec 2017-05-02)*\n \n ## 0.0.129 \u2014 2017-05-01"}, {"sha": "51778cd38713965bf4a0aea6d365e1305b39909f", "filename": "Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy\"\n-version = \"0.0.136\"\n+version = \"0.0.139\"\n authors = [\n \t\"Manish Goregaokar <manishsmail@gmail.com>\",\n \t\"Andre Bogus <bogusandre@gmail.com>\",\n@@ -31,7 +31,7 @@ test = false\n \n [dependencies]\n # begin automatic update\n-clippy_lints = { version = \"0.0.136\", path = \"clippy_lints\" }\n+clippy_lints = { version = \"0.0.139\", path = \"clippy_lints\" }\n # end automatic update\n cargo_metadata = \"0.2\"\n "}, {"sha": "1a32116b73e2d65a932c5f1b779cb799880da340", "filename": "clippy_lints/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2FCargo.toml?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -1,7 +1,7 @@\n [package]\n name = \"clippy_lints\"\n # begin automatic update\n-version = \"0.0.136\"\n+version = \"0.0.139\"\n # end automatic update\n authors = [\n \t\"Manish Goregaokar <manishsmail@gmail.com>\","}, {"sha": "07d838bef2ede9eb9899882cb9c5a83c3ccca73a", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -82,14 +82,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                 if let hir::ExprBinary(binop, ref l, ref r) = rhs.node {\n                     if op.node == binop.node {\n                         let lint = |assignee: &hir::Expr, rhs: &hir::Expr| {\n-                            let ty = cx.tables.expr_ty(assignee);\n-                            if ty.walk_shallow().next().is_some() {\n-                                return; // implements_trait does not work with generics\n-                            }\n-                            let rty = cx.tables.expr_ty(rhs);\n-                            if rty.walk_shallow().next().is_some() {\n-                                return; // implements_trait does not work with generics\n-                            }\n                             span_lint_and_then(cx,\n                                                MISREFACTORED_ASSIGN_OP,\n                                                expr.span,\n@@ -120,13 +112,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                     #[allow(cyclomatic_complexity)]\n                     let lint = |assignee: &hir::Expr, rhs: &hir::Expr| {\n                         let ty = cx.tables.expr_ty(assignee);\n-                        if ty.walk_shallow().next().is_some() {\n-                            return; // implements_trait does not work with generics\n-                        }\n                         let rty = cx.tables.expr_ty(rhs);\n-                        if rty.walk_shallow().next().is_some() {\n-                            return; // implements_trait does not work with generics\n-                        }\n                         macro_rules! ops {\n                             ($op:expr,\n                              $cx:expr,\n@@ -152,7 +138,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                                             let hir::Item_::ItemImpl(_, _, _, _, Some(ref trait_ref), _, _) = item.node,\n                                             trait_ref.path.def.def_id() == trait_id\n                                         ], { return; }}\n-                                        implements_trait($cx, $ty, trait_id, &[$rty], None)\n+                                        implements_trait($cx, $ty, trait_id, &[$rty])\n                                     },)*\n                                     _ => false,\n                                 }"}, {"sha": "88f0ef0955c387495b12b383684b80fae1627357", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -3,7 +3,7 @@\n use reexport::*;\n use rustc::lint::*;\n use rustc::hir::*;\n-use rustc::ty;\n+use rustc::ty::{self, TyCtxt};\n use semver::Version;\n use syntax::ast::{Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem, NestedMetaItemKind};\n use syntax::codemap::Span;\n@@ -158,22 +158,22 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AttrPass {\n     }\n }\n \n-fn is_relevant_item(tcx: ty::TyCtxt, item: &Item) -> bool {\n+fn is_relevant_item(tcx: TyCtxt, item: &Item) -> bool {\n     if let ItemFn(_, _, _, _, _, eid) = item.node {\n         is_relevant_expr(tcx, tcx.body_tables(eid), &tcx.hir.body(eid).value)\n     } else {\n         false\n     }\n }\n \n-fn is_relevant_impl(tcx: ty::TyCtxt, item: &ImplItem) -> bool {\n+fn is_relevant_impl(tcx: TyCtxt, item: &ImplItem) -> bool {\n     match item.node {\n         ImplItemKind::Method(_, eid) => is_relevant_expr(tcx, tcx.body_tables(eid), &tcx.hir.body(eid).value),\n         _ => false,\n     }\n }\n \n-fn is_relevant_trait(tcx: ty::TyCtxt, item: &TraitItem) -> bool {\n+fn is_relevant_trait(tcx: TyCtxt, item: &TraitItem) -> bool {\n     match item.node {\n         TraitItemKind::Method(_, TraitMethod::Required(_)) => true,\n         TraitItemKind::Method(_, TraitMethod::Provided(eid)) => {\n@@ -183,7 +183,7 @@ fn is_relevant_trait(tcx: ty::TyCtxt, item: &TraitItem) -> bool {\n     }\n }\n \n-fn is_relevant_block(tcx: ty::TyCtxt, tables: &ty::TypeckTables, block: &Block) -> bool {\n+fn is_relevant_block(tcx: TyCtxt, tables: &ty::TypeckTables, block: &Block) -> bool {\n     if let Some(stmt) = block.stmts.first() {\n         match stmt.node {\n             StmtDecl(_, _) => true,\n@@ -195,7 +195,7 @@ fn is_relevant_block(tcx: ty::TyCtxt, tables: &ty::TypeckTables, block: &Block)\n     }\n }\n \n-fn is_relevant_expr(tcx: ty::TyCtxt, tables: &ty::TypeckTables, expr: &Expr) -> bool {\n+fn is_relevant_expr(tcx: TyCtxt, tables: &ty::TypeckTables, expr: &Expr) -> bool {\n     match expr.node {\n         ExprBlock(ref block) => is_relevant_block(tcx, tables, block),\n         ExprRet(Some(ref e)) => is_relevant_expr(tcx, tables, e),"}, {"sha": "c338189cefe040c2feb59a16c2c91391ea39fa65", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -385,10 +385,12 @@ impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n                                    e.span,\n                                    \"this boolean expression can be simplified\",\n                                    |db| {\n-                                       db.span_suggestions(e.span, \"try\", improvements.into_iter().map(|suggestion| {\n-                                           suggest(self.cx, suggestion, &h2q.terminals)\n-                                       }).collect());\n-                                   });\n+                    db.span_suggestions(e.span,\n+                                        \"try\",\n+                                        improvements.into_iter()\n+                                            .map(|suggestion| suggest(self.cx, suggestion, &h2q.terminals))\n+                                            .collect());\n+                });\n             }\n         }\n     }"}, {"sha": "c68642da3b6217dc15dd09d81c5b4401695a4795", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -5,7 +5,7 @@ use rustc::hir::def::Def;\n use rustc_const_eval::lookup_const_by_id;\n use rustc_const_math::ConstInt;\n use rustc::hir::*;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, TyCtxt, Ty};\n use rustc::ty::subst::{Substs, Subst};\n use std::cmp::Ordering::{self, Equal};\n use std::cmp::PartialOrd;\n@@ -161,7 +161,7 @@ impl PartialOrd for Constant {\n \n /// parse a `LitKind` to a `Constant`\n #[allow(cast_possible_wrap)]\n-pub fn lit_to_constant<'a, 'tcx>(lit: &LitKind, tcx: TyCtxt<'a, 'tcx, 'tcx>, mut ty: ty::Ty<'tcx>) -> Constant {\n+pub fn lit_to_constant<'a, 'tcx>(lit: &LitKind, tcx: TyCtxt<'a, 'tcx, 'tcx>, mut ty: Ty<'tcx>) -> Constant {\n     use syntax::ast::*;\n     use syntax::ast::LitIntType::*;\n     use rustc::ty::util::IntTypeExt;\n@@ -286,9 +286,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n         match def {\n             Def::Const(def_id) |\n             Def::AssociatedConst(def_id) => {\n-                let substs = self.tables\n-                    .node_id_item_substs(id)\n-                    .unwrap_or_else(|| self.tcx.intern_substs(&[]));\n+                let substs = self.tables.node_substs(id);\n                 let substs = if self.substs.is_empty() {\n                     substs\n                 } else {"}, {"sha": "8f8bdf472a5c665e0af1d780bfa207aec63df74d", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -1,5 +1,5 @@\n use rustc::lint::*;\n-use rustc::ty;\n+use rustc::ty::Ty;\n use rustc::hir::*;\n use std::collections::HashMap;\n use std::collections::hash_map::Entry;\n@@ -251,12 +251,8 @@ fn if_sequence(mut expr: &Expr) -> (SmallVector<&Expr>, SmallVector<&Block>) {\n }\n \n /// Return the list of bindings in a pattern.\n-fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat) -> HashMap<InternedString, ty::Ty<'tcx>> {\n-    fn bindings_impl<'a, 'tcx>(\n-        cx: &LateContext<'a, 'tcx>,\n-        pat: &Pat,\n-        map: &mut HashMap<InternedString, ty::Ty<'tcx>>\n-    ) {\n+fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat) -> HashMap<InternedString, Ty<'tcx>> {\n+    fn bindings_impl<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat, map: &mut HashMap<InternedString, Ty<'tcx>>) {\n         match pat.node {\n             PatKind::Box(ref pat) |\n             PatKind::Ref(ref pat, _) => bindings_impl(cx, pat, map),"}, {"sha": "f6642db8fec2e33a64ad93ecbf2cc80527eea144", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -1,6 +1,5 @@\n use rustc::lint::*;\n-use rustc::ty::TypeVariants;\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n use rustc::hir::*;\n use syntax::codemap::Span;\n use utils::paths;\n@@ -89,7 +88,7 @@ fn check_hash_peq<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n     span: Span,\n     trait_ref: &TraitRef,\n-    ty: ty::Ty<'tcx>,\n+    ty: Ty<'tcx>,\n     hash_is_automatically_derived: bool\n ) {\n     if_let_chain! {[\n@@ -134,28 +133,27 @@ fn check_hash_peq<'a, 'tcx>(\n }\n \n /// Implementation of the `EXPL_IMPL_CLONE_ON_COPY` lint.\n-fn check_copy_clone<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, item: &Item, trait_ref: &TraitRef, ty: ty::Ty<'tcx>) {\n+fn check_copy_clone<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, item: &Item, trait_ref: &TraitRef, ty: Ty<'tcx>) {\n     if match_path_old(&trait_ref.path, &paths::CLONE_TRAIT) {\n-        let def_id = cx.tcx.hir.local_def_id(item.id);\n-        if !is_copy(cx, ty, def_id) {\n+        if !is_copy(cx, ty) {\n             return;\n         }\n \n         match ty.sty {\n-            TypeVariants::TyAdt(def, _) if def.is_union() => return,\n+            ty::TyAdt(def, _) if def.is_union() => return,\n \n             // Some types are not Clone by default but could be cloned \u201cby hand\u201d if necessary\n-            TypeVariants::TyAdt(def, substs) => {\n+            ty::TyAdt(def, substs) => {\n                 for variant in &def.variants {\n                     for field in &variant.fields {\n                         match field.ty(cx.tcx, substs).sty {\n-                            TypeVariants::TyArray(_, size) if size > 32 => {\n+                            ty::TyArray(_, size) if size > 32 => {\n                                 return;\n                             },\n-                            TypeVariants::TyFnPtr(..) => {\n+                            ty::TyFnPtr(..) => {\n                                 return;\n                             },\n-                            TypeVariants::TyTuple(tys, _) if tys.len() > 12 => {\n+                            ty::TyTuple(tys, _) if tys.len() > 12 => {\n                                 return;\n                             },\n                             _ => (),"}, {"sha": "6112aec7cb6ad2a6d902a7b1402a147b937e8489", "filename": "clippy_lints/src/drop_forget_ref.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -135,8 +135,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                                    expr.span,\n                                    &msg,\n                                    arg.span,\n-                                   &format!(\"argument has type {}\", arg_ty.sty));\n-            } else if is_copy(cx, arg_ty, cx.tcx.hir.local_def_id(cx.tcx.hir.get_parent(arg.id))) {\n+                                   &format!(\"argument has type {}\", arg_ty));\n+            } else if is_copy(cx, arg_ty) {\n                 if match_def_path(cx.tcx, def_id, &paths::DROP) {\n                     lint = DROP_COPY;\n                     msg = DROP_COPY_SUMMARY.to_string();\n@@ -151,7 +151,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                                    expr.span,\n                                    &msg,\n                                    arg.span,\n-                                   &format!(\"argument has type {}\", arg_ty.sty));\n+                                   &format!(\"argument has type {}\", arg_ty));\n             }\n         }}\n     }"}, {"sha": "12b588967f8a66e7a47de052ebd15ea6aaa6abc7", "filename": "clippy_lints/src/enum_glob_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_glob_use.rs?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -36,7 +36,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EnumGlobUse {\n     fn check_mod(&mut self, cx: &LateContext<'a, 'tcx>, m: &'tcx Mod, _: Span, _: NodeId) {\n         // only check top level `use` statements\n         for item in &m.item_ids {\n-            self.lint_item(cx, cx.krate.item(item.id));\n+            self.lint_item(cx, cx.tcx.hir.expect_item(item.id));\n         }\n     }\n }"}, {"sha": "10e5f2ba7c05dff64283a9bc58622f269c4cd40c", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -75,8 +75,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                 BiNe | BiEq => (cx.tcx.lang_items.eq_trait(), true),\n                 BiLt | BiLe | BiGe | BiGt => (cx.tcx.lang_items.ord_trait(), true),\n             };\n-            let parent = cx.tcx.hir.get_parent(e.id);\n-            let parent = cx.tcx.hir.local_def_id(parent);\n             if let Some(trait_id) = trait_id {\n                 #[allow(match_same_arms)]\n                 match (&left.node, &right.node) {\n@@ -87,10 +85,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                     (&ExprAddrOf(_, ref l), &ExprAddrOf(_, ref r)) => {\n                         let lty = cx.tables.expr_ty(l);\n                         let rty = cx.tables.expr_ty(r);\n-                        let lcpy = is_copy(cx, lty, parent);\n-                        let rcpy = is_copy(cx, rty, parent);\n+                        let lcpy = is_copy(cx, lty);\n+                        let rcpy = is_copy(cx, rty);\n                         // either operator autorefs or both args are copyable\n-                        if (requires_ref || (lcpy && rcpy)) && implements_trait(cx, lty, trait_id, &[rty], None) {\n+                        if (requires_ref || (lcpy && rcpy)) && implements_trait(cx, lty, trait_id, &[rty]) {\n                             span_lint_and_then(cx,\n                                                OP_REF,\n                                                e.span,\n@@ -100,17 +98,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                                 let rsnip = snippet(cx, r.span, \"...\").to_string();\n                                 multispan_sugg(db,\n                                                \"use the values directly\".to_string(),\n-                                               vec![(left.span, lsnip),\n-                                                    (right.span, rsnip)]);\n+                                               vec![(left.span, lsnip), (right.span, rsnip)]);\n                             })\n-                        } else if lcpy && !rcpy &&\n-                                  implements_trait(cx, lty, trait_id, &[cx.tables.expr_ty(right)], None) {\n+                        } else if lcpy && !rcpy && implements_trait(cx, lty, trait_id, &[cx.tables.expr_ty(right)]) {\n                             span_lint_and_then(cx, OP_REF, e.span, \"needlessly taken reference of left operand\", |db| {\n                                 let lsnip = snippet(cx, l.span, \"...\").to_string();\n                                 db.span_suggestion(left.span, \"use the left value directly\", lsnip);\n                             })\n-                        } else if !lcpy && rcpy &&\n-                                  implements_trait(cx, cx.tables.expr_ty(left), trait_id, &[rty], None) {\n+                        } else if !lcpy && rcpy && implements_trait(cx, cx.tables.expr_ty(left), trait_id, &[rty]) {\n                             span_lint_and_then(cx,\n                                                OP_REF,\n                                                e.span,\n@@ -124,9 +119,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                     // &foo == bar\n                     (&ExprAddrOf(_, ref l), _) => {\n                         let lty = cx.tables.expr_ty(l);\n-                        let lcpy = is_copy(cx, lty, parent);\n-                        if (requires_ref || lcpy) &&\n-                           implements_trait(cx, lty, trait_id, &[cx.tables.expr_ty(right)], None) {\n+                        let lcpy = is_copy(cx, lty);\n+                        if (requires_ref || lcpy) && implements_trait(cx, lty, trait_id, &[cx.tables.expr_ty(right)]) {\n                             span_lint_and_then(cx, OP_REF, e.span, \"needlessly taken reference of left operand\", |db| {\n                                 let lsnip = snippet(cx, l.span, \"...\").to_string();\n                                 db.span_suggestion(left.span, \"use the left value directly\", lsnip);\n@@ -136,9 +130,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                     // foo == &bar\n                     (_, &ExprAddrOf(_, ref r)) => {\n                         let rty = cx.tables.expr_ty(r);\n-                        let rcpy = is_copy(cx, rty, parent);\n-                        if (requires_ref || rcpy) &&\n-                           implements_trait(cx, cx.tables.expr_ty(left), trait_id, &[rty], None) {\n+                        let rcpy = is_copy(cx, rty);\n+                        if (requires_ref || rcpy) && implements_trait(cx, cx.tables.expr_ty(left), trait_id, &[rty]) {\n                             span_lint_and_then(cx, OP_REF, e.span, \"taken reference of right operand\", |db| {\n                                 let rsnip = snippet(cx, r.span, \"...\").to_string();\n                                 db.span_suggestion(right.span, \"use the right value directly\", rsnip);"}, {"sha": "c3a3f37fab59cdff48224a603c7f9b7121aa586c", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 29, "deletions": 76, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -4,13 +4,11 @@ use rustc::hir::map::Node::{NodeExpr, NodeStmt};\n use rustc::lint::*;\n use rustc::middle::expr_use_visitor::*;\n use rustc::middle::mem_categorization::{cmt, Categorization};\n-use rustc::ty;\n-use rustc::ty::layout::TargetDataLayout;\n-use rustc::traits::Reveal;\n+use rustc::ty::{self, Ty};\n use rustc::util::nodemap::NodeSet;\n use syntax::ast::NodeId;\n use syntax::codemap::Span;\n-use utils::span_lint;\n+use utils::{span_lint, type_size};\n \n pub struct Pass {\n     pub too_large_for_stack: u64,\n@@ -39,15 +37,13 @@ declare_lint! {\n     \"using `Box<T>` where unnecessary\"\n }\n \n-fn is_non_trait_box(ty: ty::Ty) -> bool {\n+fn is_non_trait_box(ty: Ty) -> bool {\n     ty.is_box() && !ty.boxed_ty().is_trait()\n }\n \n struct EscapeDelegate<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>,\n     set: NodeSet,\n-    tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n-    tables: &'a ty::TypeckTables<'tcx>,\n-    target: TargetDataLayout,\n     too_large_for_stack: u64,\n }\n \n@@ -67,23 +63,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         _: Span,\n         node_id: NodeId\n     ) {\n-        // we store the infcx because it is expensive to recreate\n-        // the context each time.\n+        let fn_def_id = cx.tcx.hir.local_def_id(node_id);\n         let mut v = EscapeDelegate {\n+            cx: cx,\n             set: NodeSet(),\n-            tcx: cx.tcx,\n-            tables: cx.tables,\n-            target: TargetDataLayout::parse(cx.sess()),\n             too_large_for_stack: self.too_large_for_stack,\n         };\n \n-        let infcx = cx.tcx.borrowck_fake_infer_ctxt(body.id());\n-        let fn_def_id = cx.tcx.hir.local_def_id(node_id);\n         let region_maps = &cx.tcx.region_maps(fn_def_id);\n-        {\n-            let mut vis = ExprUseVisitor::new(&mut v, region_maps, &infcx);\n-            vis.consume_body(body);\n-        }\n+        ExprUseVisitor::new(&mut v, cx.tcx, cx.param_env, region_maps, cx.tables).consume_body(body);\n \n         for node in v.set {\n             span_lint(cx,\n@@ -94,20 +82,18 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     }\n }\n \n-impl<'a, 'tcx: 'a> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n+impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n     fn consume(&mut self, _: NodeId, _: Span, cmt: cmt<'tcx>, mode: ConsumeMode) {\n         if let Categorization::Local(lid) = cmt.cat {\n-            if self.set.contains(&lid) {\n-                if let Move(DirectRefMove) = mode {\n-                    // moved out or in. clearly can't be localized\n-                    self.set.remove(&lid);\n-                }\n+            if let Move(DirectRefMove) = mode {\n+                // moved out or in. clearly can't be localized\n+                self.set.remove(&lid);\n             }\n         }\n     }\n     fn matched_pat(&mut self, _: &Pat, _: cmt<'tcx>, _: MatchMode) {}\n     fn consume_pat(&mut self, consume_pat: &Pat, cmt: cmt<'tcx>, _: ConsumeMode) {\n-        let map = &self.tcx.hir;\n+        let map = &self.cx.tcx.hir;\n         if map.is_argument(consume_pat.id) {\n             // Skip closure arguments\n             if let Some(NodeExpr(..)) = map.find(map.get_parent_node(consume_pat.id)) {\n@@ -147,70 +133,37 @@ impl<'a, 'tcx: 'a> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n         }\n \n     }\n-    fn borrow(\n-        &mut self,\n-        borrow_id: NodeId,\n-        _: Span,\n-        cmt: cmt<'tcx>,\n-        _: ty::Region,\n-        _: ty::BorrowKind,\n-        loan_cause: LoanCause\n-    ) {\n-        use rustc::ty::adjustment::Adjust;\n-\n+    fn borrow(&mut self, _: NodeId, _: Span, cmt: cmt<'tcx>, _: ty::Region, _: ty::BorrowKind, loan_cause: LoanCause) {\n         if let Categorization::Local(lid) = cmt.cat {\n-            if self.set.contains(&lid) {\n-                if let Some(&Adjust::DerefRef { autoderefs, .. }) =\n-                    self.tables\n-                        .adjustments\n-                        .get(&borrow_id)\n-                        .map(|a| &a.kind) {\n-                    if LoanCause::AutoRef == loan_cause {\n-                        // x.foo()\n-                        if autoderefs == 0 {\n-                            self.set.remove(&lid); // Used without autodereffing (i.e. x.clone())\n-                        }\n-                    } else {\n-                        span_bug!(cmt.span, \"Unknown adjusted AutoRef\");\n-                    }\n-                } else if LoanCause::AddrOf == loan_cause {\n-                    // &x\n-                    if let Some(&Adjust::DerefRef { autoderefs, .. }) =\n-                        self.tables\n-                            .adjustments\n-                            .get(&self.tcx\n-                                .hir\n-                                .get_parent_node(borrow_id))\n-                            .map(|a| &a.kind) {\n-                        if autoderefs <= 1 {\n-                            // foo(&x) where no extra autoreffing is happening\n-                            self.set.remove(&lid);\n-                        }\n-                    }\n+            match loan_cause {\n+                // x.foo()\n+                // Used without autodereffing (i.e. x.clone())\n+                LoanCause::AutoRef |\n+\n+                // &x\n+                // foo(&x) where no extra autoreffing is happening\n+                LoanCause::AddrOf |\n \n-                } else if LoanCause::MatchDiscriminant == loan_cause {\n-                    self.set.remove(&lid); // `match x` can move\n+                // `match x` can move\n+                LoanCause::MatchDiscriminant => {\n+                    self.set.remove(&lid);\n                 }\n+\n                 // do nothing for matches, etc. These can't escape\n+                _ => {}\n             }\n         }\n     }\n     fn decl_without_init(&mut self, _: NodeId, _: Span) {}\n     fn mutate(&mut self, _: NodeId, _: Span, _: cmt<'tcx>, _: MutateMode) {}\n }\n \n-impl<'a, 'tcx: 'a> EscapeDelegate<'a, 'tcx> {\n-    fn is_large_box(&self, ty: ty::Ty<'tcx>) -> bool {\n+impl<'a, 'tcx> EscapeDelegate<'a, 'tcx> {\n+    fn is_large_box(&self, ty: Ty<'tcx>) -> bool {\n         // Large types need to be boxed to avoid stack\n         // overflows.\n         if ty.is_box() {\n-            let inner = ty.boxed_ty();\n-            self.tcx.infer_ctxt((), Reveal::All).enter(|infcx| if let Ok(layout) = inner.layout(&infcx) {\n-                let size = layout.size(&self.target);\n-                size.bytes() > self.too_large_for_stack\n-            } else {\n-                false\n-            })\n+            type_size(self.cx, ty.boxed_ty()).unwrap_or(0) > self.too_large_for_stack\n         } else {\n             false\n         }"}, {"sha": "36cae6968d444e12095ab889c704634cdb0be5e3", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -137,11 +137,8 @@ impl<'a, 'tcx> Visitor<'tcx> for DivergenceVisitor<'a, 'tcx> {\n                 }\n             },\n             ExprMethodCall(..) => {\n-                let method_call = ty::MethodCall::expr(e.id);\n                 let borrowed_table = self.cx.tables;\n-                let method_type = borrowed_table.method_map.get(&method_call).expect(\"This should never happen.\");\n-                let result_ty = method_type.ty.fn_ret();\n-                if let ty::TyNever = self.cx.tcx.erase_late_bound_regions(&result_ty).sty {\n+                if borrowed_table.expr_ty(e).is_never() {\n                     self.report_diverging_sub_expr(e);\n                 }\n             },"}, {"sha": "e7dbc3250f78f75afc2ab5fd772fcf09076d5395", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -1,7 +1,7 @@\n use rustc::hir::*;\n use rustc::hir::map::Node::NodeItem;\n use rustc::lint::*;\n-use rustc::ty::TypeVariants;\n+use rustc::ty;\n use syntax::ast::LitKind;\n use syntax::symbol::InternedString;\n use utils::paths;\n@@ -132,7 +132,7 @@ fn check_arg_is_display(cx: &LateContext, expr: &Expr) -> bool {\n     ], {\n         let ty = walk_ptrs_ty(cx.tables.pat_ty(&pat[0]));\n \n-        return ty.sty == TypeVariants::TyStr || match_type(cx, ty, &paths::STRING);\n+        return ty.sty == ty::TyStr || match_type(cx, ty, &paths::STRING);\n     }}\n \n     false"}, {"sha": "463358c99b4672d8f00765cc8f28033e5d0e9738", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -1,6 +1,5 @@\n use rustc::hir::intravisit;\n use rustc::hir;\n-use rustc::ty;\n use rustc::lint::*;\n use std::collections::HashSet;\n use syntax::ast;\n@@ -184,8 +183,8 @@ impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n                 }\n             },\n             hir::ExprMethodCall(_, _, ref args) => {\n-                let method_call = ty::MethodCall::expr(expr.id);\n-                let base_type = self.cx.tables.method_map[&method_call].ty;\n+                let def_id = self.cx.tables.type_dependent_defs[&expr.id].def_id();\n+                let base_type = self.cx.tcx.type_of(def_id);\n \n                 if type_is_unsafe_function(base_type) {\n                     for arg in args {"}, {"sha": "7bac29f6808fa10cf8fb7ff6d9368bbac0aab24e", "filename": "clippy_lints/src/identity_op.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_op.rs?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -58,14 +58,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityOp {\n     }\n }\n \n-\n+#[allow(cast_possible_wrap)]\n fn check(cx: &LateContext, e: &Expr, m: i8, span: Span, arg: Span) {\n     if let Some(Constant::Int(v)) = constant_simple(cx, e) {\n         if match m {\n             0 => v.to_u128_unchecked() == 0,\n-            -1 => match v.int_type() {\n-                SignedInt(_) => #[allow(cast_possible_wrap)] (v.to_u128_unchecked() as i128  == -1),\n-                UnsignedInt(_) =>  false\n+            -1 => {\n+                match v.int_type() {\n+                    SignedInt(_) => (v.to_u128_unchecked() as i128 == -1),\n+                    UnsignedInt(_) => false,\n+                }\n             },\n             1 => v.to_u128_unchecked() == 1,\n             _ => unreachable!(),"}, {"sha": "611987ae163013d5bcefd949401f650366ece4a0", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -95,7 +95,7 @@ fn check_trait_items(cx: &LateContext, item: &Item, trait_items: &[TraitItemRef]\n             {\n                 let did = cx.tcx.hir.local_def_id(item.id.node_id);\n                 let impl_ty = cx.tcx.type_of(did);\n-                impl_ty.fn_args().skip_binder().len() == 1\n+                impl_ty.fn_sig().inputs().skip_binder().len() == 1\n             }\n         } else {\n             false\n@@ -122,7 +122,7 @@ fn check_impl_items(cx: &LateContext, item: &Item, impl_items: &[ImplItemRef]) {\n             {\n                 let did = cx.tcx.hir.local_def_id(item.id.node_id);\n                 let impl_ty = cx.tcx.type_of(did);\n-                impl_ty.fn_args().skip_binder().len() == 1\n+                impl_ty.fn_sig().inputs().skip_binder().len() == 1\n             }\n         } else {\n             false"}, {"sha": "fc9bcbab73af690e815e6f772746f2d781b24370", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -7,7 +7,8 @@ use rustc::hir::map::Node::NodeBlock;\n use rustc::lint::*;\n use rustc::middle::const_val::ConstVal;\n use rustc::middle::region::CodeExtent;\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n+use rustc::ty::subst::Subst;\n use rustc_const_eval::ConstContext;\n use std::collections::HashMap;\n use syntax::ast;\n@@ -739,13 +740,11 @@ fn check_for_loop_arg(cx: &LateContext, pat: &Pat, arg: &Expr, expr: &Expr) {\n                     lint_iter_method(cx, args, arg, &method_name);\n                 }\n             } else if method_name == \"into_iter\" && match_trait_method(cx, arg, &paths::INTO_ITERATOR) {\n-                let method_call = ty::MethodCall::expr(arg.id);\n-                let fn_ty = cx.tables\n-                    .method_map\n-                    .get(&method_call)\n-                    .map(|method_callee| method_callee.ty)\n-                    .expect(\"method calls need an entry in the method map\");\n-                let fn_arg_tys = fn_ty.fn_args();\n+                let def_id = cx.tables.type_dependent_defs[&arg.id].def_id();\n+                let substs = cx.tables.node_substs(arg.id);\n+                let method_type = cx.tcx.type_of(def_id).subst(cx.tcx, substs);\n+\n+                let fn_arg_tys = method_type.fn_sig().inputs();\n                 assert_eq!(fn_arg_tys.skip_binder().len(), 1);\n                 if fn_arg_tys.skip_binder()[0].is_region_ptr() {\n                     lint_iter_method(cx, args, arg, &method_name);\n@@ -1049,7 +1048,7 @@ fn is_ref_iterable_type(cx: &LateContext, e: &Expr) -> bool {\n     match_type(cx, ty, &paths::BTREESET)\n }\n \n-fn is_iterable_array(ty: ty::Ty) -> bool {\n+fn is_iterable_array(ty: Ty) -> bool {\n     // IntoIterator is currently only implemented for array sizes <= 32 in rustc\n     match ty.sty {\n         ty::TyArray(_, 0...32) => true,"}, {"sha": "ba4d24b1d62bdd6017b40ef799738ef9e53e9247", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -2,8 +2,8 @@ use rustc::lint::*;\n use rustc::hir::*;\n use rustc::ty;\n use syntax::ast;\n-use utils::{is_adjusted, match_path, match_trait_method, match_type, remove_blocks, paths, snippet, span_help_and_lint,\n-            walk_ptrs_ty, walk_ptrs_ty_depth, iter_input_pats};\n+use utils::{is_adjusted, match_path, match_trait_method, match_type, remove_blocks, paths, snippet,\n+            span_help_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, iter_input_pats};\n \n /// **What it does:** Checks for mapping `clone()` over an iterator.\n ///"}, {"sha": "3e9e2d06d054aba3f782b5bbbab85aca710eb5ce", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -1,7 +1,7 @@\n use rustc::hir::*;\n use rustc::lint::*;\n use rustc::middle::const_val::ConstVal;\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n use rustc_const_eval::ConstContext;\n use rustc_const_math::ConstInt;\n use std::cmp::Ordering;\n@@ -226,14 +226,7 @@ fn report_single_match_single_pattern(cx: &LateContext, ex: &Expr, arms: &[Arm],\n     });\n }\n \n-fn check_single_match_opt_like(\n-    cx: &LateContext,\n-    ex: &Expr,\n-    arms: &[Arm],\n-    expr: &Expr,\n-    ty: ty::Ty,\n-    els: Option<&Expr>\n-) {\n+fn check_single_match_opt_like(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr, ty: Ty, els: Option<&Expr>) {\n     // list of candidate Enums we know will never get any more members\n     let candidates = &[(&paths::COW, \"Borrowed\"),\n                        (&paths::COW, \"Cow::Borrowed\"),"}, {"sha": "08400600bb42844dc83f16c67f25fb6b3ee0ba0c", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 66, "deletions": 18, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -1,7 +1,7 @@\n use rustc::hir;\n use rustc::lint::*;\n use rustc::middle::const_val::ConstVal;\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n use rustc::hir::def::Def;\n use rustc_const_eval::ConstContext;\n use std::borrow::Cow;\n@@ -10,7 +10,7 @@ use syntax::codemap::Span;\n use utils::{get_trait_def_id, implements_trait, in_external_macro, in_macro, is_copy, match_path, match_trait_method,\n             match_type, method_chain_args, return_ty, same_tys, snippet, span_lint, span_lint_and_then,\n             span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, last_path_segment, single_segment_path,\n-            match_def_path, is_self, is_self_ty, iter_input_pats};\n+            match_def_path, is_self, is_self_ty, iter_input_pats, match_path_old};\n use utils::paths;\n use utils::sugg;\n \n@@ -649,7 +649,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                 if name == method_name &&\n                    sig.decl.inputs.len() == n_args &&\n                    out_type.matches(&sig.decl.output) &&\n-                   self_kind.matches(first_arg_ty, first_arg, self_ty, false) {\n+                   self_kind.matches(first_arg_ty, first_arg, self_ty, false, &sig.generics) {\n                     span_lint(cx, SHOULD_IMPLEMENT_TRAIT, implitem.span, &format!(\n                         \"defining a method called `{}` on this type; consider implementing \\\n                          the `{}` trait or choosing a less ambiguous name\", name, trait_name));\n@@ -659,11 +659,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             // check conventions w.r.t. conversion method names and predicates\n             let def_id = cx.tcx.hir.local_def_id(item.id);\n             let ty = cx.tcx.type_of(def_id);\n-            let is_copy = is_copy(cx, ty, def_id);\n+            let is_copy = is_copy(cx, ty);\n             for &(ref conv, self_kinds) in &CONVENTIONS {\n                 if_let_chain! {[\n                     conv.check(&name.as_str()),\n-                    !self_kinds.iter().any(|k| k.matches(first_arg_ty, first_arg, self_ty, is_copy)),\n+                    !self_kinds.iter().any(|k| k.matches(first_arg_ty, first_arg, self_ty, is_copy, &sig.generics)),\n                 ], {\n                     let lint = if item.vis == hir::Visibility::Public {\n                         WRONG_PUB_SELF_CONVENTION\n@@ -684,9 +684,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             }\n \n             let ret_ty = return_ty(cx, implitem.id);\n-            let implitem_defid = cx.tcx.hir.local_def_id(implitem.id);\n             if name == \"new\" &&\n-               !ret_ty.walk().any(|t| same_tys(cx, t, ty, implitem_defid)) {\n+               !ret_ty.walk().any(|t| same_tys(cx, t, ty)) {\n                 span_lint(cx,\n                           NEW_RET_NO_SELF,\n                           implitem.span,\n@@ -725,7 +724,7 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[hir:\n                         return false;\n                     };\n \n-                    if implements_trait(cx, arg_ty, default_trait_id, &[], None) {\n+                    if implements_trait(cx, arg_ty, default_trait_id, &[]) {\n                         span_lint_and_then(cx,\n                                            OR_FUN_CALL,\n                                            span,\n@@ -820,9 +819,8 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[hir:\n }\n \n /// Checks for the `CLONE_ON_COPY` lint.\n-fn lint_clone_on_copy(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr, arg_ty: ty::Ty) {\n+fn lint_clone_on_copy(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr, arg_ty: Ty) {\n     let ty = cx.tables.expr_ty(expr);\n-    let parent = cx.tcx.hir.get_parent(expr.id);\n     if let ty::TyRef(_, ty::TypeAndMut { ty: inner, .. }) = arg_ty.sty {\n         if let ty::TyRef(..) = inner.sty {\n             span_lint_and_then(cx,\n@@ -839,7 +837,7 @@ fn lint_clone_on_copy(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr, arg_t\n         }\n     }\n \n-    if is_copy(cx, ty, cx.tcx.hir.local_def_id(parent)) {\n+    if is_copy(cx, ty) {\n         span_lint_and_then(cx,\n                            CLONE_ON_COPY,\n                            expr.span,\n@@ -979,8 +977,8 @@ fn lint_iter_skip_next(cx: &LateContext, expr: &hir::Expr) {\n     }\n }\n \n-fn derefs_to_slice(cx: &LateContext, expr: &hir::Expr, ty: ty::Ty) -> Option<sugg::Sugg<'static>> {\n-    fn may_slice(cx: &LateContext, ty: ty::Ty) -> bool {\n+fn derefs_to_slice(cx: &LateContext, expr: &hir::Expr, ty: Ty) -> Option<sugg::Sugg<'static>> {\n+    fn may_slice(cx: &LateContext, ty: Ty) -> bool {\n         match ty.sty {\n             ty::TySlice(_) => true,\n             ty::TyAdt(def, _) if def.is_box() => may_slice(cx, ty.boxed_ty()),\n@@ -1253,7 +1251,7 @@ fn lint_single_char_pattern(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr)\n }\n \n /// Given a `Result<T, E>` type, return its error type (`E`).\n-fn get_error_type<'a>(cx: &LateContext, ty: ty::Ty<'a>) -> Option<ty::Ty<'a>> {\n+fn get_error_type<'a>(cx: &LateContext, ty: Ty<'a>) -> Option<Ty<'a>> {\n     if let ty::TyAdt(_, substs) = ty.sty {\n         if match_type(cx, ty, &paths::RESULT) {\n             substs.types().nth(1)\n@@ -1266,9 +1264,9 @@ fn get_error_type<'a>(cx: &LateContext, ty: ty::Ty<'a>) -> Option<ty::Ty<'a>> {\n }\n \n /// This checks whether a given type is known to implement Debug.\n-fn has_debug_impl<'a, 'b>(ty: ty::Ty<'a>, cx: &LateContext<'b, 'a>) -> bool {\n+fn has_debug_impl<'a, 'b>(ty: Ty<'a>, cx: &LateContext<'b, 'a>) -> bool {\n     match cx.tcx.lang_items.debug_trait() {\n-        Some(debug) => implements_trait(cx, ty, debug, &[], None),\n+        Some(debug) => implements_trait(cx, ty, debug, &[]),\n         None => false,\n     }\n }\n@@ -1353,7 +1351,14 @@ enum SelfKind {\n }\n \n impl SelfKind {\n-    fn matches(self, ty: &hir::Ty, arg: &hir::Arg, self_ty: &hir::Ty, allow_value_for_ref: bool) -> bool {\n+    fn matches(\n+        self,\n+        ty: &hir::Ty,\n+        arg: &hir::Arg,\n+        self_ty: &hir::Ty,\n+        allow_value_for_ref: bool,\n+        generics: &hir::Generics\n+    ) -> bool {\n         // Self types in the HIR are desugared to explicit self types. So it will always be `self:\n         // SomeType`,\n         // where SomeType can be `Self` or an explicit impl self type (e.g. `Foo` if the impl is on `Foo`)\n@@ -1384,7 +1389,12 @@ impl SelfKind {\n                 _ => false,\n             }\n         } else {\n-            self == SelfKind::No\n+            match self {\n+                SelfKind::Value => false,\n+                SelfKind::Ref => is_as_ref_or_mut_trait(ty, self_ty, generics, &paths::ASREF_TRAIT),\n+                SelfKind::RefMut => is_as_ref_or_mut_trait(ty, self_ty, generics, &paths::ASMUT_TRAIT),\n+                SelfKind::No => true,\n+            }\n         }\n     }\n \n@@ -1398,6 +1408,44 @@ impl SelfKind {\n     }\n }\n \n+fn is_as_ref_or_mut_trait(ty: &hir::Ty, self_ty: &hir::Ty, generics: &hir::Generics, name: &[&str]) -> bool {\n+    single_segment_ty(ty).map_or(false, |seg| {\n+        generics.ty_params.iter().any(|param| {\n+            param.name == seg.name &&\n+            param.bounds.iter().any(|bound| if let hir::TyParamBound::TraitTyParamBound(ref ptr, ..) = *bound {\n+                let path = &ptr.trait_ref.path;\n+                match_path_old(path, name) &&\n+                path.segments.last().map_or(false, |s| if let hir::PathParameters::AngleBracketedParameters(ref data) =\n+                    s.parameters {\n+                    data.types.len() == 1 && (is_self_ty(&data.types[0]) || is_ty(&*data.types[0], self_ty))\n+                } else {\n+                    false\n+                })\n+            } else {\n+                false\n+            })\n+        })\n+    })\n+}\n+\n+fn is_ty(ty: &hir::Ty, self_ty: &hir::Ty) -> bool {\n+    match (&ty.node, &self_ty.node) {\n+        (&hir::TyPath(hir::QPath::Resolved(_, ref ty_path)),\n+         &hir::TyPath(hir::QPath::Resolved(_, ref self_ty_path))) => {\n+            ty_path.segments.iter().map(|seg| seg.name).eq(self_ty_path.segments.iter().map(|seg| seg.name))\n+        },\n+        _ => false,\n+    }\n+}\n+\n+fn single_segment_ty(ty: &hir::Ty) -> Option<&hir::PathSegment> {\n+    if let hir::TyPath(ref path) = ty.node {\n+        single_segment_path(path)\n+    } else {\n+        None\n+    }\n+}\n+\n impl Convention {\n     fn check(&self, other: &str) -> bool {\n         match *self {"}, {"sha": "02ccdb2d79b80d135385a0c4dd3e7dd2bd6ac118", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -455,13 +455,13 @@ fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr) {\n     // *arg impls PartialEq<other>\n     if !arg_ty\n         .builtin_deref(true, ty::LvaluePreference::NoPreference)\n-        .map_or(false, |tam| implements_trait(cx, tam.ty, partial_eq_trait_id, &[other_ty], None))\n+        .map_or(false, |tam| implements_trait(cx, tam.ty, partial_eq_trait_id, &[other_ty]))\n         // arg impls PartialEq<*other>\n         && !other_ty\n         .builtin_deref(true, ty::LvaluePreference::NoPreference)\n-        .map_or(false, |tam| implements_trait(cx, arg_ty, partial_eq_trait_id, &[tam.ty], None))\n+        .map_or(false, |tam| implements_trait(cx, arg_ty, partial_eq_trait_id, &[tam.ty]))\n         // arg impls PartialEq<other>\n-        && !implements_trait(cx, arg_ty, partial_eq_trait_id, &[other_ty], None) {\n+        && !implements_trait(cx, arg_ty, partial_eq_trait_id, &[other_ty]) {\n         return;\n     }\n \n@@ -514,13 +514,13 @@ fn in_attributes_expansion(expr: &Expr) -> bool {\n /// Test whether `def` is a variable defined outside a macro.\n fn non_macro_local(cx: &LateContext, def: &def::Def) -> bool {\n     match *def {\n-        def::Def::Local(id) |\n-        def::Def::Upvar(id, _, _) => {\n-            if let Some(span) = cx.tcx.hir.span_if_local(id) {\n-                !in_macro(span)\n-            } else {\n-                true\n-            }\n+        def::Def::Local(def_id) |\n+        def::Def::Upvar(def_id, _, _) => {\n+            let id = cx.tcx\n+                .hir\n+                .as_local_node_id(def_id)\n+                .expect(\"local variables should be found in the same crate\");\n+            !in_macro(cx.tcx.hir.span(id))\n         },\n         _ => false,\n     }"}, {"sha": "fc3107c3068d8cee621786a4be06734591e428e2", "filename": "clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_mut.rs?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -1,7 +1,7 @@\n use rustc::hir;\n use rustc::hir::intravisit;\n use rustc::lint::*;\n-use rustc::ty::{TypeAndMut, TyRef};\n+use rustc::ty;\n use utils::{higher, in_external_macro, span_lint};\n \n /// **What it does:** Checks for instances of `mut mut` references.\n@@ -68,7 +68,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {\n                           MUT_MUT,\n                           expr.span,\n                           \"generally you want to avoid `&mut &mut _` if possible\");\n-            } else if let TyRef(_, TypeAndMut { mutbl: hir::MutMutable, .. }) = self.cx.tables.expr_ty(e).sty {\n+            } else if let ty::TyRef(_, ty::TypeAndMut { mutbl: hir::MutMutable, .. }) = self.cx.tables.expr_ty(e).sty {\n                 span_lint(self.cx,\n                           MUT_MUT,\n                           expr.span,"}, {"sha": "034e49a016c09a1ed08da904bf36d984ac2b6357", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -1,5 +1,6 @@\n use rustc::lint::*;\n-use rustc::ty::{TypeAndMut, TypeVariants, MethodCall, TyS};\n+use rustc::ty::{self, Ty};\n+use rustc::ty::subst::Subst;\n use rustc::hir::*;\n use utils::span_lint;\n \n@@ -34,44 +35,40 @@ impl LintPass for UnnecessaryMutPassed {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnecessaryMutPassed {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        let borrowed_table = cx.tables;\n         match e.node {\n             ExprCall(ref fn_expr, ref arguments) => {\n-                let function_type = borrowed_table.node_types\n-                    .get(&fn_expr.id)\n-                    .expect(\"A function with an unknown type is called. If this happened, the compiler would have \\\n-                             aborted the compilation long ago\");\n                 if let ExprPath(ref path) = fn_expr.node {\n                     check_arguments(cx,\n                                     arguments,\n-                                    function_type,\n+                                    cx.tables.expr_ty(fn_expr),\n                                     &print::to_string(print::NO_ANN, |s| s.print_qpath(path, false)));\n                 }\n             },\n             ExprMethodCall(ref name, _, ref arguments) => {\n-                let method_call = MethodCall::expr(e.id);\n-                let method_type = borrowed_table.method_map.get(&method_call).expect(\"This should never happen.\");\n-                check_arguments(cx, arguments, method_type.ty, &name.node.as_str())\n+                let def_id = cx.tables.type_dependent_defs[&e.id].def_id();\n+                let substs = cx.tables.node_substs(e.id);\n+                let method_type = cx.tcx.type_of(def_id).subst(cx.tcx, substs);\n+                check_arguments(cx, arguments, method_type, &name.node.as_str())\n             },\n             _ => (),\n         }\n     }\n }\n \n-fn check_arguments(cx: &LateContext, arguments: &[Expr], type_definition: &TyS, name: &str) {\n+fn check_arguments(cx: &LateContext, arguments: &[Expr], type_definition: Ty, name: &str) {\n     match type_definition.sty {\n-        TypeVariants::TyFnDef(_, _, fn_type) |\n-        TypeVariants::TyFnPtr(fn_type) => {\n+        ty::TyFnDef(_, _, fn_type) |\n+        ty::TyFnPtr(fn_type) => {\n             let parameters = fn_type.skip_binder().inputs();\n             for (argument, parameter) in arguments.iter().zip(parameters.iter()) {\n                 match parameter.sty {\n-                    TypeVariants::TyRef(_, TypeAndMut { mutbl: MutImmutable, .. }) |\n-                    TypeVariants::TyRawPtr(TypeAndMut { mutbl: MutImmutable, .. }) => {\n+                    ty::TyRef(_, ty::TypeAndMut { mutbl: MutImmutable, .. }) |\n+                    ty::TyRawPtr(ty::TypeAndMut { mutbl: MutImmutable, .. }) => {\n                         if let ExprAddrOf(MutMutable, _) = argument.node {\n                             span_lint(cx,\n                                       UNNECESSARY_MUT_PASSED,\n                                       argument.span,\n-                                      &format!(\"The function/method \\\"{}\\\" doesn't need a mutable reference\", name));\n+                                      &format!(\"The function/method `{}` doesn't need a mutable reference\", name));\n                         }\n                     },\n                     _ => (),"}, {"sha": "085067935a09d3df4daee209d3bfcf555a77d391", "filename": "clippy_lints/src/mutex_atomic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutex_atomic.rs?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -3,7 +3,7 @@\n //! This lint is **warn** by default\n \n use rustc::lint::{LintPass, LintArray, LateLintPass, LateContext};\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n use rustc::hir::Expr;\n use syntax::ast;\n use utils::{match_type, paths, span_lint};\n@@ -59,12 +59,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutexAtomic {\n         let ty = cx.tables.expr_ty(expr);\n         if let ty::TyAdt(_, subst) = ty.sty {\n             if match_type(cx, ty, &paths::MUTEX) {\n-                let mutex_param = &subst.type_at(0).sty;\n+                let mutex_param = subst.type_at(0);\n                 if let Some(atomic_name) = get_atomic_name(mutex_param) {\n                     let msg = format!(\"Consider using an {} instead of a Mutex here. If you just want the locking \\\n                                        behaviour and not the internal type, consider using Mutex<()>.\",\n                                       atomic_name);\n-                    match *mutex_param {\n+                    match mutex_param.sty {\n                         ty::TyUint(t) if t != ast::UintTy::Us => span_lint(cx, MUTEX_INTEGER, expr.span, &msg),\n                         ty::TyInt(t) if t != ast::IntTy::Is => span_lint(cx, MUTEX_INTEGER, expr.span, &msg),\n                         _ => span_lint(cx, MUTEX_ATOMIC, expr.span, &msg),\n@@ -75,8 +75,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutexAtomic {\n     }\n }\n \n-fn get_atomic_name(ty: &ty::TypeVariants) -> Option<(&'static str)> {\n-    match *ty {\n+fn get_atomic_name(ty: Ty) -> Option<(&'static str)> {\n+    match ty.sty {\n         ty::TyBool => Some(\"AtomicBool\"),\n         ty::TyUint(_) => Some(\"AtomicUsize\"),\n         ty::TyInt(_) => Some(\"AtomicIsize\"),"}, {"sha": "c1965be2c04893a7a55be35ebc3c68a82e0c97a5", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -5,6 +5,7 @@\n use rustc::lint::*;\n use rustc::hir::{ExprAddrOf, Expr, MutImmutable, Pat, PatKind, BindingMode};\n use rustc::ty;\n+use rustc::ty::adjustment::{Adjustment, Adjust};\n use utils::{span_lint, in_macro};\n \n /// **What it does:** Checks for address of operations (`&`) that are going to\n@@ -41,9 +42,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBorrow {\n         }\n         if let ExprAddrOf(MutImmutable, ref inner) = e.node {\n             if let ty::TyRef(..) = cx.tables.expr_ty(inner).sty {\n-                if let Some(&ty::adjustment::Adjust::DerefRef { autoderefs, autoref, .. }) =\n-                    cx.tables.adjustments.get(&e.id).map(|a| &a.kind) {\n-                    if autoderefs > 1 && autoref.is_some() {\n+                for adj3 in cx.tables.expr_adjustments(e).windows(3) {\n+                    if let [\n+                        Adjustment { kind: Adjust::Deref(_), .. },\n+                        Adjustment { kind: Adjust::Deref(_), .. },\n+                        Adjustment { kind: Adjust::Borrow(_), .. }\n+                    ] = *adj3 {\n                         span_lint(cx,\n                                   NEEDLESS_BORROW,\n                                   e.span,"}, {"sha": "b8aacb3b41833feda9c09f6bbb91512cfd507b75", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -82,21 +82,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n         let fn_def_id = cx.tcx.hir.local_def_id(node_id);\n \n         let preds: Vec<ty::Predicate> = {\n-            let parameter_env = cx.tcx.param_env(fn_def_id);\n-            traits::elaborate_predicates(cx.tcx, parameter_env.caller_bounds.to_vec())\n+            traits::elaborate_predicates(cx.tcx, cx.param_env.caller_bounds.to_vec())\n                 .filter(|p| !p.is_global())\n                 .collect()\n         };\n \n         // Collect moved variables and spans which will need dereferencings from the function body.\n         let MovedVariablesCtxt { moved_vars, spans_need_deref, .. } = {\n             let mut ctx = MovedVariablesCtxt::new(cx);\n-            let infcx = cx.tcx.borrowck_fake_infer_ctxt(body.id());\n             let region_maps = &cx.tcx.region_maps(fn_def_id);\n-            {\n-                let mut v = euv::ExprUseVisitor::new(&mut ctx, region_maps, &infcx);\n-                v.consume_body(body);\n-            }\n+            euv::ExprUseVisitor::new(&mut ctx, cx.tcx, cx.param_env, region_maps, cx.tables).consume_body(body);\n             ctx\n         };\n \n@@ -119,9 +114,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n             if_let_chain! {[\n                 !is_self(arg),\n                 !ty.is_mutable_pointer(),\n-                !is_copy(cx, ty, fn_def_id),\n-                !implements_trait(cx, ty, fn_trait, &[], Some(node_id)),\n-                !implements_trait(cx, ty, asref_trait, &[], Some(node_id)),\n+                !is_copy(cx, ty),\n+                !implements_trait(cx, ty, fn_trait, &[]),\n+                !implements_trait(cx, ty, asref_trait, &[]),\n                 !implements_borrow_trait,\n \n                 let PatKind::Binding(mode, defid, ..) = arg.pat.node,\n@@ -190,7 +185,7 @@ struct MovedVariablesCtxt<'a, 'tcx: 'a> {\n     spans_need_deref: HashMap<DefId, HashSet<Span>>,\n }\n \n-impl<'a, 'tcx: 'a> MovedVariablesCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> MovedVariablesCtxt<'a, 'tcx> {\n     fn new(cx: &'a LateContext<'a, 'tcx>) -> Self {\n         MovedVariablesCtxt {\n             cx: cx,\n@@ -262,7 +257,7 @@ impl<'a, 'tcx: 'a> MovedVariablesCtxt<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx: 'a> euv::Delegate<'tcx> for MovedVariablesCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> euv::Delegate<'tcx> for MovedVariablesCtxt<'a, 'tcx> {\n     fn consume(&mut self, consume_id: NodeId, consume_span: Span, cmt: mc::cmt<'tcx>, mode: euv::ConsumeMode) {\n         if let euv::ConsumeMode::Move(_) = mode {\n             self.move_common(consume_id, consume_span, cmt);"}, {"sha": "da6f635e34ef74408a23945e0d3ffed0c2775773", "filename": "clippy_lints/src/needless_update.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_update.rs?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -1,5 +1,5 @@\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use rustc::ty::TyAdt;\n+use rustc::ty;\n use rustc::hir::{Expr, ExprStruct};\n use utils::span_lint;\n \n@@ -34,7 +34,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprStruct(_, ref fields, Some(ref base)) = expr.node {\n             let ty = cx.tables.expr_ty(expr);\n-            if let TyAdt(def, _) = ty.sty {\n+            if let ty::TyAdt(def, _) = ty.sty {\n                 if fields.len() == def.struct_variant().fields.len() {\n                     span_lint(cx,\n                               NEEDLESS_UPDATE,"}, {"sha": "34f467184f3b9ed4cd865bdba2eee9db28bc16a0", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -2,7 +2,7 @@ use rustc::hir::intravisit::FnKind;\n use rustc::hir::def_id::DefId;\n use rustc::hir;\n use rustc::lint::*;\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n use syntax::ast;\n use syntax::codemap::Span;\n use utils::paths;\n@@ -108,15 +108,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n                 // can't be implemented by default\n                 return;\n             }\n-            let def_id = cx.tcx.hir.local_def_id(id);\n             if decl.inputs.is_empty() && name == \"new\" && cx.access_levels.is_reachable(id) {\n                 let self_ty = cx.tcx\n                     .type_of(cx.tcx.hir.local_def_id(cx.tcx.hir.get_parent(id)));\n                 if_let_chain!{[\n-                    self_ty.walk_shallow().next().is_none(), // implements_trait does not work with generics\n-                    same_tys(cx, self_ty, return_ty(cx, id), def_id),\n+                    same_tys(cx, self_ty, return_ty(cx, id)),\n                     let Some(default_trait_id) = get_trait_def_id(cx, &paths::DEFAULT_TRAIT),\n-                    !implements_trait(cx, self_ty, default_trait_id, &[], None)\n+                    !implements_trait(cx, self_ty, default_trait_id, &[])\n                 ], {\n                     if let Some(sp) = can_derive_default(self_ty, cx, default_trait_id) {\n                         span_lint_and_then(cx,\n@@ -152,16 +150,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n     }\n }\n \n-fn can_derive_default<'t, 'c>(ty: ty::Ty<'t>, cx: &LateContext<'c, 't>, default_trait_id: DefId) -> Option<Span> {\n+fn can_derive_default<'t, 'c>(ty: Ty<'t>, cx: &LateContext<'c, 't>, default_trait_id: DefId) -> Option<Span> {\n     match ty.sty {\n         ty::TyAdt(adt_def, substs) if adt_def.is_struct() => {\n             for field in adt_def.all_fields() {\n                 let f_ty = field.ty(cx.tcx, substs);\n-                if !implements_trait(cx, f_ty, default_trait_id, &[], None) {\n+                if !implements_trait(cx, f_ty, default_trait_id, &[]) {\n                     return None;\n                 }\n             }\n-            cx.tcx.hir.span_if_local(adt_def.did)\n+            Some(cx.tcx.def_span(adt_def.did))\n         },\n         _ => None,\n     }"}, {"sha": "ea79a77877a0ecb61a7ffac19a59f9a5a1c8110b", "filename": "clippy_lints/src/should_assert_eq.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fshould_assert_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fshould_assert_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshould_assert_eq.rs?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -49,10 +49,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ShouldAssertEq {\n             let ty1 = cx.tables.expr_ty(expr1);\n             let ty2 = cx.tables.expr_ty(expr2);\n \n-            let parent = cx.tcx.hir.get_parent(e.id);\n-\n-            if implements_trait(cx, ty1, debug_trait, &[], Some(parent)) &&\n-                implements_trait(cx, ty2, debug_trait, &[], Some(parent)) {\n+            if implements_trait(cx, ty1, debug_trait, &[]) &&\n+                implements_trait(cx, ty2, debug_trait, &[]) {\n                 span_lint(cx, SHOULD_ASSERT_EQ, e.span, &format!(\"use `{}{}` for better reporting\", debug, sugg));\n             }\n         }}"}, {"sha": "1d67e06f811828d4386fbb99a40e5cb24d494292", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -1,6 +1,5 @@\n use rustc::lint::*;\n-use rustc::ty::TypeVariants::{TyRawPtr, TyRef};\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n use rustc::hir::*;\n use utils::{match_def_path, paths, span_lint, span_lint_and_then, snippet, last_path_segment};\n use utils::sugg;\n@@ -101,7 +100,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                                       e.span,\n                                       &format!(\"transmute from a type (`{}`) to itself\", from_ty))\n                         },\n-                        (&TyRef(_, rty), &TyRawPtr(ptr_ty)) => {\n+                        (&ty::TyRef(_, rty), &ty::TyRawPtr(ptr_ty)) => {\n                             span_lint_and_then(cx,\n                                                USELESS_TRANSMUTE,\n                                                e.span,\n@@ -116,8 +115,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                                                    db.span_suggestion(e.span, \"try\", sugg.to_string());\n                                                })\n                         },\n-                        (&ty::TyInt(_), &TyRawPtr(_)) |\n-                        (&ty::TyUint(_), &TyRawPtr(_)) => {\n+                        (&ty::TyInt(_), &ty::TyRawPtr(_)) |\n+                        (&ty::TyUint(_), &ty::TyRawPtr(_)) => {\n                             span_lint_and_then(cx,\n                                                USELESS_TRANSMUTE,\n                                                e.span,\n@@ -128,32 +127,32 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                                                                       arg.as_ty(&to_ty.to_string()).to_string());\n                                                })\n                         },\n-                        (&ty::TyFloat(_), &TyRef(..)) |\n-                        (&ty::TyFloat(_), &TyRawPtr(_)) |\n-                        (&ty::TyChar, &TyRef(..)) |\n-                        (&ty::TyChar, &TyRawPtr(_)) => {\n+                        (&ty::TyFloat(_), &ty::TyRef(..)) |\n+                        (&ty::TyFloat(_), &ty::TyRawPtr(_)) |\n+                        (&ty::TyChar, &ty::TyRef(..)) |\n+                        (&ty::TyChar, &ty::TyRawPtr(_)) => {\n                             span_lint(cx,\n                                       WRONG_TRANSMUTE,\n                                       e.span,\n                                       &format!(\"transmute from a `{}` to a pointer\", from_ty))\n                         },\n-                        (&TyRawPtr(from_ptr), _) if from_ptr.ty == to_ty => {\n+                        (&ty::TyRawPtr(from_ptr), _) if from_ptr.ty == to_ty => {\n                             span_lint(cx,\n                                       CROSSPOINTER_TRANSMUTE,\n                                       e.span,\n                                       &format!(\"transmute from a type (`{}`) to the type that it points to (`{}`)\",\n                                                from_ty,\n                                                to_ty))\n                         },\n-                        (_, &TyRawPtr(to_ptr)) if to_ptr.ty == from_ty => {\n+                        (_, &ty::TyRawPtr(to_ptr)) if to_ptr.ty == from_ty => {\n                             span_lint(cx,\n                                       CROSSPOINTER_TRANSMUTE,\n                                       e.span,\n                                       &format!(\"transmute from a type (`{}`) to a pointer to that type (`{}`)\",\n                                                from_ty,\n                                                to_ty))\n                         },\n-                        (&TyRawPtr(from_pty), &TyRef(_, to_rty)) => {\n+                        (&ty::TyRawPtr(from_pty), &ty::TyRef(_, to_rty)) => {\n                             span_lint_and_then(cx,\n                                                TRANSMUTE_PTR_TO_REF,\n                                                e.span,\n@@ -189,7 +188,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n /// Get the snippet of `Bar` in `\u2026::transmute<Foo, &Bar>`. If that snippet is not available , use\n /// the type's `ToString` implementation. In weird cases it could lead to types with invalid `'_`\n /// lifetime, but it should be rare.\n-fn get_type_snippet(cx: &LateContext, path: &QPath, to_rty: ty::Ty) -> String {\n+fn get_type_snippet(cx: &LateContext, path: &QPath, to_rty: Ty) -> String {\n     let seg = last_path_segment(path);\n     if_let_chain!{[\n         let PathParameters::AngleBracketedParameters(ref ang) = seg.parameters,"}, {"sha": "f608c7808a0be84302bd2481bd7f98c57ac21ec3", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -1,8 +1,9 @@\n use reexport::*;\n+use rustc::hir;\n use rustc::hir::*;\n use rustc::hir::intravisit::{FnKind, Visitor, walk_ty, NestedVisitorMap};\n use rustc::lint::*;\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n use std::cmp::Ordering;\n use syntax::ast::{IntTy, UintTy, FloatTy};\n use syntax::attr::IntType;\n@@ -106,7 +107,7 @@ fn check_fn_decl(cx: &LateContext, decl: &FnDecl) {\n     }\n }\n \n-fn check_ty(cx: &LateContext, ast_ty: &Ty) {\n+fn check_ty(cx: &LateContext, ast_ty: &hir::Ty) {\n     if in_macro(ast_ty.span) {\n         return;\n     }\n@@ -196,8 +197,7 @@ declare_lint! {\n \n fn check_let_unit(cx: &LateContext, decl: &Decl) {\n     if let DeclLocal(ref local) = decl.node {\n-        let bindtype = &cx.tables.pat_ty(&local.pat).sty;\n-        match *bindtype {\n+        match cx.tables.pat_ty(&local.pat).sty {\n             ty::TyTuple(slice, _) if slice.is_empty() => {\n                 if in_external_macro(cx, decl.span) || in_macro(local.pat.span) {\n                     return;\n@@ -267,8 +267,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitCmp {\n         if let ExprBinary(ref cmp, ref left, _) = expr.node {\n             let op = cmp.node;\n             if op.is_comparison() {\n-                let sty = &cx.tables.expr_ty(left).sty;\n-                match *sty {\n+                match cx.tables.expr_ty(left).sty {\n                     ty::TyTuple(slice, _) if slice.is_empty() => {\n                         let result = match op {\n                             BiEq | BiLe | BiGe => \"true\",\n@@ -398,7 +397,7 @@ declare_lint! {\n \n /// Returns the size in bits of an integral type.\n /// Will return 0 if the type is not an int or uint variant\n-fn int_ty_to_nbits(typ: &ty::TyS) -> usize {\n+fn int_ty_to_nbits(typ: Ty) -> usize {\n     let n = match typ.sty {\n         ty::TyInt(i) => 4 << (i as usize),\n         ty::TyUint(u) => 4 << (u as usize),\n@@ -412,15 +411,15 @@ fn int_ty_to_nbits(typ: &ty::TyS) -> usize {\n     }\n }\n \n-fn is_isize_or_usize(typ: &ty::TyS) -> bool {\n+fn is_isize_or_usize(typ: Ty) -> bool {\n     match typ.sty {\n         ty::TyInt(IntTy::Is) |\n         ty::TyUint(UintTy::Us) => true,\n         _ => false,\n     }\n }\n \n-fn span_precision_loss_lint(cx: &LateContext, expr: &Expr, cast_from: &ty::TyS, cast_to_f64: bool) {\n+fn span_precision_loss_lint(cx: &LateContext, expr: &Expr, cast_from: Ty, cast_to_f64: bool) {\n     let mantissa_nbits = if cast_to_f64 { 52 } else { 23 };\n     let arch_dependent = is_isize_or_usize(cast_from) && cast_to_f64;\n     let arch_dependent_str = \"on targets with 64-bit wide pointers \";\n@@ -453,7 +452,7 @@ enum ArchSuffix {\n     None,\n }\n \n-fn check_truncation_and_wrapping(cx: &LateContext, expr: &Expr, cast_from: &ty::TyS, cast_to: &ty::TyS) {\n+fn check_truncation_and_wrapping(cx: &LateContext, expr: &Expr, cast_from: Ty, cast_to: Ty) {\n     let arch_64_suffix = \" on targets with 64-bit wide pointers\";\n     let arch_32_suffix = \" on targets with 32-bit wide pointers\";\n     let cast_unsigned_to_signed = !cast_from.is_signed() && cast_to.is_signed();\n@@ -693,7 +692,7 @@ impl<'a, 'tcx> TypeComplexityPass {\n         }\n     }\n \n-    fn check_type(&self, cx: &LateContext, ty: &Ty) {\n+    fn check_type(&self, cx: &LateContext, ty: &hir::Ty) {\n         if in_macro(ty.span) {\n             return;\n         }\n@@ -724,7 +723,7 @@ struct TypeComplexityVisitor {\n }\n \n impl<'tcx> Visitor<'tcx> for TypeComplexityVisitor {\n-    fn visit_ty(&mut self, ty: &'tcx Ty) {\n+    fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         let (add_score, sub_nest) = match ty.node {\n             // _, &x and *x have only small overhead; don't mess with nesting level\n             TyInfer | TyPtr(..) | TyRptr(..) => (1, 0),\n@@ -909,9 +908,9 @@ fn detect_extreme_expr<'a>(cx: &LateContext, expr: &'a Expr) -> Option<ExtremeEx\n     use rustc_const_eval::*;\n     use types::ExtremeType::*;\n \n-    let ty = &cx.tables.expr_ty(expr).sty;\n+    let ty = cx.tables.expr_ty(expr);\n \n-    match *ty {\n+    match ty.sty {\n         ty::TyBool | ty::TyInt(_) | ty::TyUint(_) => (),\n         _ => return None,\n     };\n@@ -921,7 +920,7 @@ fn detect_extreme_expr<'a>(cx: &LateContext, expr: &'a Expr) -> Option<ExtremeEx\n         Err(_) => return None,\n     };\n \n-    let which = match (ty, cv) {\n+    let which = match (&ty.sty, cv) {\n         (&ty::TyBool, Bool(false)) |\n         (&ty::TyInt(IntTy::Is), Integral(Isize(Is32(::std::i32::MIN)))) |\n         (&ty::TyInt(IntTy::Is), Integral(Isize(Is64(::std::i64::MIN)))) |\n@@ -1070,7 +1069,6 @@ impl Ord for FullInt {\n \n \n fn numeric_cast_precast_bounds<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(FullInt, FullInt)> {\n-    use rustc::ty::TypeVariants::{TyInt, TyUint};\n     use syntax::ast::{IntTy, UintTy};\n     use std::*;\n \n@@ -1082,7 +1080,7 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(\n             return None;\n         }\n         match pre_cast_ty.sty {\n-            TyInt(int_ty) => {\n+            ty::TyInt(int_ty) => {\n                 Some(match int_ty {\n                     IntTy::I8 => (FullInt::S(i8::min_value() as i128), FullInt::S(i8::max_value() as i128)),\n                     IntTy::I16 => (FullInt::S(i16::min_value() as i128), FullInt::S(i16::max_value() as i128)),\n@@ -1092,7 +1090,7 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(\n                     IntTy::Is => (FullInt::S(isize::min_value() as i128), FullInt::S(isize::max_value() as i128)),\n                 })\n             },\n-            TyUint(uint_ty) => {\n+            ty::TyUint(uint_ty) => {\n                 Some(match uint_ty {\n                     UintTy::U8 => (FullInt::U(u8::min_value() as u128), FullInt::U(u8::max_value() as u128)),\n                     UintTy::U16 => (FullInt::U(u16::min_value() as u128), FullInt::U(u16::max_value() as u128)),\n@@ -1109,6 +1107,7 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(\n     }\n }\n \n+#[allow(cast_possible_wrap)]\n fn node_as_const_fullint(cx: &LateContext, expr: &Expr) -> Option<FullInt> {\n     use rustc::middle::const_val::ConstVal::*;\n     use rustc_const_eval::ConstContext;\n@@ -1117,7 +1116,7 @@ fn node_as_const_fullint(cx: &LateContext, expr: &Expr) -> Option<FullInt> {\n         Ok(val) => {\n             if let Integral(const_int) = val {\n                 match const_int.int_type() {\n-                    IntType::SignedInt(_) => #[allow(cast_possible_wrap)] Some(FullInt::S(const_int.to_u128_unchecked() as i128)),\n+                    IntType::SignedInt(_) => Some(FullInt::S(const_int.to_u128_unchecked() as i128)),\n                     IntType::UnsignedInt(_) => Some(FullInt::U(const_int.to_u128_unchecked())),\n                 }\n             } else {"}, {"sha": "1f19e454857292f42172f6ad4ed444d15629fd7a", "filename": "clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_io_amount.rs?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -46,7 +46,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedIoAmount {\n             hir::ExprMatch(ref res, _, _) if is_try(expr).is_some() => {\n                 if let hir::ExprCall(ref func, ref args) = res.node {\n                     if let hir::ExprPath(ref path) = func.node {\n-                        if match_path(path, &paths::CARRIER_TRANSLATE) && args.len() == 1 {\n+                        if match_path(path, &paths::TRY_INTO_RESULT) && args.len() == 1 {\n                             check_method_call(cx, &args[0], expr);\n                         }\n                     }"}, {"sha": "7c7b3b57a11420b23267a8b713e0cf25b4da7b6e", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -76,8 +76,7 @@ pub fn range(expr: &hir::Expr) -> Option<Range> {\n                     end: None,\n                     limits: ast::RangeLimits::HalfOpen,\n                 })\n-            } else if match_path(path, &paths::RANGE_INCLUSIVE_STD) ||\n-                      match_path(path, &paths::RANGE_INCLUSIVE) {\n+            } else if match_path(path, &paths::RANGE_INCLUSIVE_STD) || match_path(path, &paths::RANGE_INCLUSIVE) {\n                 Some(Range {\n                     start: get_field(\"start\", fields),\n                     end: get_field(\"end\", fields),\n@@ -125,20 +124,17 @@ pub fn is_from_for_desugar(decl: &hir::Decl) -> bool {\n /// `for pat in arg { body }` becomes `(pat, arg, body)`.\n pub fn for_loop(expr: &hir::Expr) -> Option<(&hir::Pat, &hir::Expr, &hir::Expr)> {\n     if_let_chain! {[\n-        let hir::ExprMatch(ref iterexpr, ref arms, _) = expr.node,\n+        let hir::ExprMatch(ref iterexpr, ref arms, hir::MatchSource::ForLoopDesugar) = expr.node,\n         let hir::ExprCall(_, ref iterargs) = iterexpr.node,\n         iterargs.len() == 1 && arms.len() == 1 && arms[0].guard.is_none(),\n         let hir::ExprLoop(ref block, _, _) = arms[0].body.node,\n-        block.stmts.is_empty(),\n-        let Some(ref loopexpr) = block.expr,\n-        let hir::ExprMatch(_, ref innerarms, hir::MatchSource::ForLoopDesugar) = loopexpr.node,\n-        innerarms.len() == 2 && innerarms[0].pats.len() == 1,\n-        let hir::PatKind::TupleStruct(_, ref somepats, _) = innerarms[0].pats[0].node,\n-        somepats.len() == 1\n+        block.expr.is_none(),\n+        let [ ref let_stmt, ref body ] = *block.stmts,\n+        let hir::StmtDecl(ref decl, _) = let_stmt.node,\n+        let hir::DeclLocal(ref decl) = decl.node,\n+        let hir::StmtExpr(ref expr, _) = body.node,\n     ], {\n-        return Some((&somepats[0],\n-                     &iterargs[0],\n-                     &innerarms[0].body));\n+        return Some((&*decl.pat, &iterargs[0], expr));\n     }}\n     None\n }"}, {"sha": "5820f600434883a74962746d2d596cad202be9ca", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "previous_filename": "clippy_lints/src/utils/hir.rs"}, {"sha": "c2cbd4d4cd0328d0d9042956b2d38b1c4efc8544", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 39, "deletions": 64, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -1,15 +1,13 @@\n use reexport::*;\n+use rustc::hir;\n use rustc::hir::*;\n use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc::hir::def::Def;\n use rustc::hir::map::Node;\n use rustc::lint::{LintContext, LateContext, Level, Lint};\n use rustc::session::Session;\n-use rustc::traits::Reveal;\n use rustc::traits;\n-use rustc::ty::subst::{Subst, Substs};\n-use rustc::ty;\n-use rustc::ty::layout::TargetDataLayout;\n+use rustc::ty::{self, TyCtxt, Ty};\n use rustc::mir::transform::MirSource;\n use rustc_errors;\n use std::borrow::Cow;\n@@ -26,12 +24,12 @@ use syntax::symbol::keywords;\n pub mod comparisons;\n pub mod conf;\n pub mod constants;\n-mod hir;\n+mod hir_utils;\n pub mod paths;\n pub mod sugg;\n pub mod inspector;\n pub mod internal_lints;\n-pub use self::hir::{SpanlessEq, SpanlessHash};\n+pub use self::hir_utils::{SpanlessEq, SpanlessHash};\n \n pub type MethodArgs = HirVec<P<Expr>>;\n \n@@ -149,7 +147,7 @@ pub fn in_external_macro<'a, T: LintContext<'a>>(cx: &T, span: Span) -> bool {\n /// ```\n ///\n /// See also the `paths` module.\n-pub fn match_def_path(tcx: ty::TyCtxt, def_id: DefId, path: &[&str]) -> bool {\n+pub fn match_def_path(tcx: TyCtxt, def_id: DefId, path: &[&str]) -> bool {\n     use syntax::symbol;\n \n     struct AbsolutePathBuffer {\n@@ -175,7 +173,7 @@ pub fn match_def_path(tcx: ty::TyCtxt, def_id: DefId, path: &[&str]) -> bool {\n }\n \n /// Check if type is struct, enum or union type with given def path.\n-pub fn match_type(cx: &LateContext, ty: ty::Ty, path: &[&str]) -> bool {\n+pub fn match_type(cx: &LateContext, ty: Ty, path: &[&str]) -> bool {\n     match ty.sty {\n         ty::TyAdt(adt, _) => match_def_path(cx.tcx, adt.did, path),\n         _ => false,\n@@ -184,12 +182,8 @@ pub fn match_type(cx: &LateContext, ty: ty::Ty, path: &[&str]) -> bool {\n \n /// Check if the method call given in `expr` belongs to given type.\n pub fn match_impl_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool {\n-    let method_call = ty::MethodCall::expr(expr.id);\n-\n-    let trt_id = cx.tables\n-        .method_map\n-        .get(&method_call)\n-        .and_then(|callee| cx.tcx.impl_of_method(callee.def_id));\n+    let method_call = cx.tables.type_dependent_defs[&expr.id];\n+    let trt_id = cx.tcx.impl_of_method(method_call.def_id());\n     if let Some(trt_id) = trt_id {\n         match_def_path(cx.tcx, trt_id, path)\n     } else {\n@@ -199,12 +193,8 @@ pub fn match_impl_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool {\n \n /// Check if the method call given in `expr` belongs to given trait.\n pub fn match_trait_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool {\n-    let method_call = ty::MethodCall::expr(expr.id);\n-\n-    let trt_id = cx.tables\n-        .method_map\n-        .get(&method_call)\n-        .and_then(|callee| cx.tcx.trait_of_item(callee.def_id));\n+    let method_call = cx.tables.type_dependent_defs[&expr.id];\n+    let trt_id = cx.tcx.trait_of_item(method_call.def_id());\n     if let Some(trt_id) = trt_id {\n         match_def_path(cx.tcx, trt_id, path)\n     } else {\n@@ -267,7 +257,6 @@ pub fn match_path_ast(path: &ast::Path, segments: &[&str]) -> bool {\n }\n \n /// Get the definition associated to a path.\n-/// TODO: investigate if there is something more efficient for that.\n pub fn path_to_def(cx: &LateContext, path: &[&str]) -> Option<def::Def> {\n     let cstore = &cx.tcx.sess.cstore;\n \n@@ -278,7 +267,7 @@ pub fn path_to_def(cx: &LateContext, path: &[&str]) -> Option<def::Def> {\n             krate: *krate,\n             index: CRATE_DEF_INDEX,\n         };\n-        let mut items = cstore.item_children(krate);\n+        let mut items = cstore.item_children(krate, cx.tcx.sess);\n         let mut path_it = path.iter().skip(1).peekable();\n \n         loop {\n@@ -293,7 +282,7 @@ pub fn path_to_def(cx: &LateContext, path: &[&str]) -> Option<def::Def> {\n                         return Some(item.def);\n                     }\n \n-                    items = cstore.item_children(item.def.def_id());\n+                    items = cstore.item_children(item.def.def_id(), cx.tcx.sess);\n                     break;\n                 }\n             }\n@@ -320,22 +309,16 @@ pub fn get_trait_def_id(cx: &LateContext, path: &[&str]) -> Option<DefId> {\n /// See also `get_trait_def_id`.\n pub fn implements_trait<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    ty: ty::Ty<'tcx>,\n+    ty: Ty<'tcx>,\n     trait_id: DefId,\n-    ty_params: &[ty::Ty<'tcx>],\n-    parent_node_id: Option<NodeId>\n+    ty_params: &[Ty<'tcx>]\n ) -> bool {\n     let ty = cx.tcx.erase_regions(&ty);\n-    let mut b = if let Some(id) = parent_node_id {\n-        cx.tcx.infer_ctxt(BodyId { node_id: id }, Reveal::All)\n-    } else {\n-        cx.tcx.infer_ctxt((), Reveal::All)\n-    };\n-    b.enter(|infcx| {\n-        let obligation = cx.tcx.predicate_for_trait_def(traits::ObligationCause::dummy(), trait_id, 0, ty, ty_params);\n-\n-        traits::SelectionContext::new(&infcx).evaluate_obligation_conservatively(&obligation)\n-    })\n+    let obligation = cx.tcx\n+        .predicate_for_trait_def(cx.param_env, traits::ObligationCause::dummy(), trait_id, 0, ty, ty_params);\n+    cx.tcx\n+        .infer_ctxt()\n+        .enter(|infcx| traits::SelectionContext::new(&infcx).evaluate_obligation_conservatively(&obligation))\n }\n \n /// Resolve the definition of a node from its `NodeId`.\n@@ -592,23 +575,30 @@ pub fn span_lint_and_sugg<'a, 'tcx: 'a, T: LintContext<'tcx>>(\n /// replacement. In human-readable format though, it only appears once before the whole suggestion.\n pub fn multispan_sugg(db: &mut DiagnosticBuilder, help_msg: String, sugg: Vec<(Span, String)>) {\n     let sugg = rustc_errors::CodeSuggestion {\n-        substitution_parts: sugg.into_iter().map(|(span, sub)| rustc_errors::Substitution { span, substitutions: vec![sub] }).collect(),\n+        substitution_parts: sugg.into_iter()\n+            .map(|(span, sub)| {\n+                rustc_errors::Substitution {\n+                    span: span,\n+                    substitutions: vec![sub],\n+                }\n+            })\n+            .collect(),\n         msg: help_msg,\n     };\n     db.suggestions.push(sugg);\n }\n \n /// Return the base type for references and raw pointers.\n-pub fn walk_ptrs_ty(ty: ty::Ty) -> ty::Ty {\n+pub fn walk_ptrs_ty(ty: Ty) -> Ty {\n     match ty.sty {\n         ty::TyRef(_, ref tm) => walk_ptrs_ty(tm.ty),\n         _ => ty,\n     }\n }\n \n /// Return the base type for references and raw pointers, and count reference depth.\n-pub fn walk_ptrs_ty_depth(ty: ty::Ty) -> (ty::Ty, usize) {\n-    fn inner(ty: ty::Ty, depth: usize) -> (ty::Ty, usize) {\n+pub fn walk_ptrs_ty_depth(ty: Ty) -> (Ty, usize) {\n+    fn inner(ty: Ty, depth: usize) -> (Ty, usize) {\n         match ty.sty {\n             ty::TyRef(_, ref tm) => inner(tm.ty, depth + 1),\n             _ => (ty, depth),\n@@ -772,7 +762,7 @@ pub fn camel_case_from(s: &str) -> usize {\n }\n \n /// Convenience function to get the return type of a function\n-pub fn return_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, fn_item: NodeId) -> ty::Ty<'tcx> {\n+pub fn return_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, fn_item: NodeId) -> Ty<'tcx> {\n     let fn_def_id = cx.tcx.hir.local_def_id(fn_item);\n     let ret_ty = cx.tcx.type_of(fn_def_id).fn_sig().output();\n     cx.tcx.erase_late_bound_regions(&ret_ty)\n@@ -781,34 +771,21 @@ pub fn return_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, fn_item: NodeId) -> ty::T\n /// Check if two types are the same.\n // FIXME: this works correctly for lifetimes bounds (`for <'a> Foo<'a>` == `for <'b> Foo<'b>` but\n // not for type parameters.\n-pub fn same_tys<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n-    a: ty::Ty<'tcx>,\n-    b: ty::Ty<'tcx>,\n-    parameter_item: DefId\n-) -> bool {\n-    let parameter_env = cx.tcx.param_env(parameter_item);\n-    cx.tcx.infer_ctxt(parameter_env, Reveal::All).enter(|infcx| {\n-        let substs = Substs::identity_for_item(cx.tcx, parameter_item);\n-        let new_a = a.subst(infcx.tcx, substs);\n-        let new_b = b.subst(infcx.tcx, substs);\n-        infcx.can_equate(&new_a, &new_b).is_ok()\n-    })\n+pub fn same_tys<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n+    cx.tcx.infer_ctxt().enter(|infcx| infcx.can_eq(cx.param_env, a, b).is_ok())\n }\n \n /// Return whether the given type is an `unsafe` function.\n-pub fn type_is_unsafe_function(ty: ty::Ty) -> bool {\n+pub fn type_is_unsafe_function(ty: Ty) -> bool {\n     match ty.sty {\n         ty::TyFnDef(_, _, f) |\n         ty::TyFnPtr(f) => f.unsafety() == Unsafety::Unsafe,\n         _ => false,\n     }\n }\n \n-pub fn is_copy<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: ty::Ty<'tcx>, env: DefId) -> bool {\n-    let substs = Substs::identity_for_item(cx.tcx, env);\n-    let env = cx.tcx.param_env(env);\n-    !ty.subst(cx.tcx, substs).moves_by_default(cx.tcx.global_tcx(), env, DUMMY_SP)\n+pub fn is_copy<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n+    !ty.moves_by_default(cx.tcx.global_tcx(), cx.param_env, DUMMY_SP)\n }\n \n /// Return whether a pattern is refutable.\n@@ -910,7 +887,7 @@ pub fn is_self(slf: &Arg) -> bool {\n     }\n }\n \n-pub fn is_self_ty(slf: &Ty) -> bool {\n+pub fn is_self_ty(slf: &hir::Ty) -> bool {\n     if_let_chain! {[\n         let TyPath(ref qp) = slf.node,\n         let QPath::Resolved(None, ref path) = *qp,\n@@ -969,8 +946,6 @@ pub fn is_try(expr: &Expr) -> Option<&Expr> {\n     None\n }\n \n-pub fn type_size<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: ty::Ty<'tcx>) -> Option<u64> {\n-    cx.tcx\n-        .infer_ctxt((), Reveal::All)\n-        .enter(|infcx| ty.layout(&infcx).ok().map(|lay| lay.size(&TargetDataLayout::parse(cx.sess())).bytes()))\n+pub fn type_size<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>) -> Option<u64> {\n+    ty.layout(cx.tcx, cx.param_env).ok().map(|layout| layout.size(cx.tcx).bytes())\n }"}, {"sha": "eb9979343948b5110891187f3546320cf6e45f9e", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -1,5 +1,6 @@\n //! This module contains paths to types and functions Clippy needs to know about.\n \n+pub const ASMUT_TRAIT: [&'static str; 3] = [\"core\", \"convert\", \"AsMut\"];\n pub const ASREF_TRAIT: [&'static str; 3] = [\"core\", \"convert\", \"AsRef\"];\n pub const BEGIN_PANIC: [&'static str; 3] = [\"std\", \"panicking\", \"begin_panic\"];\n pub const BINARY_HEAP: [&'static str; 3] = [\"collections\", \"binary_heap\", \"BinaryHeap\"];\n@@ -9,7 +10,6 @@ pub const BOX_NEW: [&'static str; 4] = [\"std\", \"boxed\", \"Box\", \"new\"];\n pub const BTREEMAP: [&'static str; 4] = [\"collections\", \"btree\", \"map\", \"BTreeMap\"];\n pub const BTREEMAP_ENTRY: [&'static str; 4] = [\"collections\", \"btree\", \"map\", \"Entry\"];\n pub const BTREESET: [&'static str; 4] = [\"collections\", \"btree\", \"set\", \"BTreeSet\"];\n-pub const CARRIER_TRANSLATE: [&'static str; 4] = [\"std\", \"ops\", \"Carrier\", \"translate\"];\n pub const CLONE: [&'static str; 4] = [\"core\", \"clone\", \"Clone\", \"clone\"];\n pub const CLONE_TRAIT: [&'static str; 3] = [\"core\", \"clone\", \"Clone\"];\n pub const CMP_MAX: [&'static str; 3] = [\"core\", \"cmp\", \"max\"];\n@@ -72,6 +72,7 @@ pub const STRING: [&'static str; 3] = [\"collections\", \"string\", \"String\"];\n pub const TO_OWNED: [&'static str; 3] = [\"collections\", \"borrow\", \"ToOwned\"];\n pub const TO_STRING: [&'static str; 3] = [\"collections\", \"string\", \"ToString\"];\n pub const TRANSMUTE: [&'static str; 4] = [\"core\", \"intrinsics\", \"\", \"transmute\"];\n+pub const TRY_INTO_RESULT: [&'static str; 4] = [\"std\", \"ops\", \"Try\", \"into_result\"];\n pub const VEC: [&'static str; 3] = [\"collections\", \"vec\", \"Vec\"];\n pub const VEC_DEQUE: [&'static str; 3] = [\"collections\", \"vec_deque\", \"VecDeque\"];\n pub const VEC_FROM_ELEM: [&'static str; 3] = [\"collections\", \"vec\", \"from_elem\"];"}, {"sha": "3c672b22ee606b6011def88d1b84c743d908ed65", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -1,6 +1,6 @@\n use rustc::hir::*;\n use rustc::lint::*;\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n use rustc_const_eval::ConstContext;\n use syntax::codemap::Span;\n use utils::{higher, is_copy, snippet, span_lint_and_then};\n@@ -35,8 +35,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         // search for `&vec![_]` expressions where the adjusted type is `&[_]`\n         if_let_chain!{[\n-            let ty::TypeVariants::TyRef(_, ref ty) = cx.tables.expr_ty_adjusted(expr).sty,\n-            let ty::TypeVariants::TySlice(..) = ty.ty.sty,\n+            let ty::TyRef(_, ref ty) = cx.tables.expr_ty_adjusted(expr).sty,\n+            let ty::TySlice(..) = ty.ty.sty,\n             let ExprAddrOf(_, ref addressee) = expr.node,\n             let Some(vec_args) = higher::vec_macro(cx, addressee),\n         ], {\n@@ -47,7 +47,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         if_let_chain!{[\n             let Some((_, arg, _)) = higher::for_loop(expr),\n             let Some(vec_args) = higher::vec_macro(cx, arg),\n-            is_copy(cx, vec_type(cx.tables.expr_ty_adjusted(arg)), cx.tcx.hir.local_def_id(cx.tcx.hir.get_parent(expr.id))),\n+            is_copy(cx, vec_type(cx.tables.expr_ty_adjusted(arg))),\n         ], {\n             // report the error around the `vec!` not inside `<std macros>:`\n             let span = arg.span.ctxt.outer().expn_info().map(|info| info.call_site).expect(\"unable to get call_site\");\n@@ -88,7 +88,7 @@ fn check_vec_macro(cx: &LateContext, vec_args: &higher::VecArgs, span: Span) {\n }\n \n /// Return the item type of the vector (ie. the `T` in `Vec<T>`).\n-fn vec_type(ty: ty::Ty) -> ty::Ty {\n+fn vec_type(ty: Ty) -> Ty {\n     if let ty::TyAdt(_, substs) = ty.sty {\n         substs.type_at(0)\n     } else {"}, {"sha": "8e399b90d9d2244a4775a70387e3d5c590a38b25", "filename": "clippy_tests/examples/assign_ops.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_tests%2Fexamples%2Fassign_ops.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_tests%2Fexamples%2Fassign_ops.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_tests%2Fexamples%2Fassign_ops.stderr?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -166,6 +166,14 @@ error: manual implementation of an assign operation\n    |\n    = note: `-D assign-op-pattern` implied by `-D warnings`\n \n+error: manual implementation of an assign operation\n+  --> assign_ops.rs:40:5\n+   |\n+40 |     s = s + \"bla\";\n+   |     ^^^^^^^^^^^^^ help: replace it with `s += \"bla\"`\n+   |\n+   = note: `-D assign-op-pattern` implied by `-D warnings`\n+\n error: aborting due to previous error(s)\n \n error: Could not compile `clippy_tests`."}, {"sha": "e752ffd2362ca6b83d44b3b3172255ad567b095e", "filename": "clippy_tests/examples/for_loop.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_tests%2Fexamples%2Ffor_loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_tests%2Fexamples%2Ffor_loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_tests%2Fexamples%2Ffor_loop.stderr?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -317,6 +317,14 @@ error: this range is empty so this for loop will never run\n     |\n     = note: `-D reverse-range-loop` implied by `-D warnings`\n \n+error: use of deprecated item: replaced by `Iterator::step_by`\n+   --> for_loop.rs:192:22\n+    |\n+192 |     for i in (10..8).step_by(-1) {\n+    |                      ^^^^^^^\n+    |\n+    = note: `-D deprecated` implied by `-D warnings`\n+\n error: it is more idiomatic to loop over references to containers instead of using explicit iteration methods\n    --> for_loop.rs:207:15\n     |"}, {"sha": "c8f606db0e170e3928e2a19e4b743cd8e5b4b5a5", "filename": "clippy_tests/examples/mut_reference.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_tests%2Fexamples%2Fmut_reference.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_tests%2Fexamples%2Fmut_reference.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_tests%2Fexamples%2Fmut_reference.stderr?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -1,20 +1,20 @@\n-error: The function/method \"takes_an_immutable_reference\" doesn't need a mutable reference\n+error: The function/method `takes_an_immutable_reference` doesn't need a mutable reference\n   --> mut_reference.rs:22:34\n    |\n 22 |     takes_an_immutable_reference(&mut 42);\n    |                                  ^^^^^^^\n    |\n    = note: `-D unnecessary-mut-passed` implied by `-D warnings`\n \n-error: The function/method \"as_ptr\" doesn't need a mutable reference\n+error: The function/method `as_ptr` doesn't need a mutable reference\n   --> mut_reference.rs:24:12\n    |\n 24 |     as_ptr(&mut 42);\n    |            ^^^^^^^\n    |\n    = note: `-D unnecessary-mut-passed` implied by `-D warnings`\n \n-error: The function/method \"takes_an_immutable_reference\" doesn't need a mutable reference\n+error: The function/method `takes_an_immutable_reference` doesn't need a mutable reference\n   --> mut_reference.rs:28:44\n    |\n 28 |     my_struct.takes_an_immutable_reference(&mut 42);"}, {"sha": "2f3aa7971d0160d47095bc1b9fac3f0adb448beb", "filename": "clippy_tests/examples/range.stderr", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_tests%2Fexamples%2Frange.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_tests%2Fexamples%2Frange.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_tests%2Fexamples%2Frange.stderr?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -6,6 +6,22 @@ error: Range::step_by(0) produces an infinite iterator. Consider using `std::ite\n    |\n    = note: `-D range-step-by-zero` implied by `-D warnings`\n \n+error: use of deprecated item: replaced by `Iterator::step_by`\n+  --> range.rs:13:12\n+   |\n+13 |     (0..1).step_by(0);\n+   |            ^^^^^^^\n+   |\n+   = note: `-D deprecated` implied by `-D warnings`\n+\n+error: use of deprecated item: replaced by `Iterator::step_by`\n+  --> range.rs:15:12\n+   |\n+15 |     (0..1).step_by(1);\n+   |            ^^^^^^^\n+   |\n+   = note: `-D deprecated` implied by `-D warnings`\n+\n error: Range::step_by(0) produces an infinite iterator. Consider using `std::iter::repeat()` instead\n   --> range.rs:17:5\n    |\n@@ -14,6 +30,14 @@ error: Range::step_by(0) produces an infinite iterator. Consider using `std::ite\n    |\n    = note: `-D range-step-by-zero` implied by `-D warnings`\n \n+error: use of deprecated item: replaced by `Iterator::step_by`\n+  --> range.rs:17:11\n+   |\n+17 |     (1..).step_by(0);\n+   |           ^^^^^^^\n+   |\n+   = note: `-D deprecated` implied by `-D warnings`\n+\n error: Range::step_by(0) produces an infinite iterator. Consider using `std::iter::repeat()` instead\n   --> range.rs:18:5\n    |\n@@ -22,6 +46,14 @@ error: Range::step_by(0) produces an infinite iterator. Consider using `std::ite\n    |\n    = note: `-D range-step-by-zero` implied by `-D warnings`\n \n+error: use of deprecated item: replaced by `Iterator::step_by`\n+  --> range.rs:18:13\n+   |\n+18 |     (1...2).step_by(0);\n+   |             ^^^^^^^\n+   |\n+   = note: `-D deprecated` implied by `-D warnings`\n+\n error: Range::step_by(0) produces an infinite iterator. Consider using `std::iter::repeat()` instead\n   --> range.rs:21:5\n    |\n@@ -30,6 +62,14 @@ error: Range::step_by(0) produces an infinite iterator. Consider using `std::ite\n    |\n    = note: `-D range-step-by-zero` implied by `-D warnings`\n \n+error: use of deprecated item: replaced by `Iterator::step_by`\n+  --> range.rs:21:7\n+   |\n+21 |     x.step_by(0);\n+   |       ^^^^^^^\n+   |\n+   = note: `-D deprecated` implied by `-D warnings`\n+\n error: It is more idiomatic to use v1.iter().enumerate()\n   --> range.rs:29:14\n    |"}, {"sha": "2b0e4dcdf1b34ffd951de509b7735579d6db9504", "filename": "clippy_tests/examples/strings.stderr", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_tests%2Fexamples%2Fstrings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_tests%2Fexamples%2Fstrings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_tests%2Fexamples%2Fstrings.stderr?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -1,3 +1,11 @@\n+error: manual implementation of an assign operation\n+  --> strings.rs:10:9\n+   |\n+10 |         x = x + \".\";\n+   |         ^^^^^^^^^^^ help: replace it with `x += \".\"`\n+   |\n+   = note: `-D assign-op-pattern` implied by `-D warnings`\n+\n error: you added something to a string. Consider using `String::push_str()` instead\n   --> strings.rs:10:13\n    |\n@@ -22,6 +30,14 @@ error: you assigned the result of adding something to this string. Consider usin\n    |\n    = note: `-D string-add-assign` implied by `-D warnings`\n \n+error: manual implementation of an assign operation\n+  --> strings.rs:24:9\n+   |\n+24 |         x = x + \".\";\n+   |         ^^^^^^^^^^^ help: replace it with `x += \".\"`\n+   |\n+   = note: `-D assign-op-pattern` implied by `-D warnings`\n+\n error: you assigned the result of adding something to this string. Consider using `String::push_str()` instead\n   --> strings.rs:38:9\n    |\n@@ -30,6 +46,14 @@ error: you assigned the result of adding something to this string. Consider usin\n    |\n    = note: `-D string-add-assign` implied by `-D warnings`\n \n+error: manual implementation of an assign operation\n+  --> strings.rs:38:9\n+   |\n+38 |         x = x + \".\";\n+   |         ^^^^^^^^^^^ help: replace it with `x += \".\"`\n+   |\n+   = note: `-D assign-op-pattern` implied by `-D warnings`\n+\n error: you added something to a string. Consider using `String::push_str()` instead\n   --> strings.rs:42:13\n    |"}, {"sha": "91b60c8faaa23c9a7e591579dda6080f2110c8a6", "filename": "clippy_tests/examples/wrong_self_convention.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_tests%2Fexamples%2Fwrong_self_convention.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_tests%2Fexamples%2Fwrong_self_convention.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_tests%2Fexamples%2Fwrong_self_convention.rs?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -29,6 +29,8 @@ impl Foo {\n     #[allow(wrong_self_convention)]\n     pub fn from_cake(self) {}\n \n+    fn as_x<F: AsRef<Self>>(_: F) { }\n+    fn as_y<F: AsRef<Foo>>(_: F) { }\n }\n \n struct Bar;"}, {"sha": "91ed88dd4afa85d806e97fd06eebd8c1c29d0863", "filename": "clippy_tests/examples/wrong_self_convention.stderr", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_tests%2Fexamples%2Fwrong_self_convention.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8b00f826d72e9fa95a89922c517266fd0ad51595/clippy_tests%2Fexamples%2Fwrong_self_convention.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_tests%2Fexamples%2Fwrong_self_convention.stderr?ref=8b00f826d72e9fa95a89922c517266fd0ad51595", "patch": "@@ -15,81 +15,81 @@ error: methods called `from_*` usually take no self; consider choosing a less am\n    = note: `-D wrong-self-convention` implied by `-D warnings`\n \n error: methods called `as_*` usually take self by reference or self by mutable reference; consider choosing a less ambiguous name\n-  --> wrong_self_convention.rs:38:15\n+  --> wrong_self_convention.rs:40:15\n    |\n-38 |     fn as_i32(self) {}\n+40 |     fn as_i32(self) {}\n    |               ^^^^\n    |\n    = note: `-D wrong-self-convention` implied by `-D warnings`\n \n error: methods called `into_*` usually take self by value; consider choosing a less ambiguous name\n-  --> wrong_self_convention.rs:40:17\n+  --> wrong_self_convention.rs:42:17\n    |\n-40 |     fn into_i32(&self) {}\n+42 |     fn into_i32(&self) {}\n    |                 ^^^^^\n    |\n    = note: `-D wrong-self-convention` implied by `-D warnings`\n \n error: methods called `is_*` usually take self by reference or no self; consider choosing a less ambiguous name\n-  --> wrong_self_convention.rs:42:15\n+  --> wrong_self_convention.rs:44:15\n    |\n-42 |     fn is_i32(self) {}\n+44 |     fn is_i32(self) {}\n    |               ^^^^\n    |\n    = note: `-D wrong-self-convention` implied by `-D warnings`\n \n error: methods called `to_*` usually take self by reference; consider choosing a less ambiguous name\n-  --> wrong_self_convention.rs:44:15\n+  --> wrong_self_convention.rs:46:15\n    |\n-44 |     fn to_i32(self) {}\n+46 |     fn to_i32(self) {}\n    |               ^^^^\n    |\n    = note: `-D wrong-self-convention` implied by `-D warnings`\n \n error: methods called `from_*` usually take no self; consider choosing a less ambiguous name\n-  --> wrong_self_convention.rs:46:17\n+  --> wrong_self_convention.rs:48:17\n    |\n-46 |     fn from_i32(self) {}\n+48 |     fn from_i32(self) {}\n    |                 ^^^^\n    |\n    = note: `-D wrong-self-convention` implied by `-D warnings`\n \n error: methods called `as_*` usually take self by reference or self by mutable reference; consider choosing a less ambiguous name\n-  --> wrong_self_convention.rs:48:19\n+  --> wrong_self_convention.rs:50:19\n    |\n-48 |     pub fn as_i64(self) {}\n+50 |     pub fn as_i64(self) {}\n    |                   ^^^^\n    |\n    = note: `-D wrong-self-convention` implied by `-D warnings`\n \n error: methods called `into_*` usually take self by value; consider choosing a less ambiguous name\n-  --> wrong_self_convention.rs:49:21\n+  --> wrong_self_convention.rs:51:21\n    |\n-49 |     pub fn into_i64(&self) {}\n+51 |     pub fn into_i64(&self) {}\n    |                     ^^^^^\n    |\n    = note: `-D wrong-self-convention` implied by `-D warnings`\n \n error: methods called `is_*` usually take self by reference or no self; consider choosing a less ambiguous name\n-  --> wrong_self_convention.rs:50:19\n+  --> wrong_self_convention.rs:52:19\n    |\n-50 |     pub fn is_i64(self) {}\n+52 |     pub fn is_i64(self) {}\n    |                   ^^^^\n    |\n    = note: `-D wrong-self-convention` implied by `-D warnings`\n \n error: methods called `to_*` usually take self by reference; consider choosing a less ambiguous name\n-  --> wrong_self_convention.rs:51:19\n+  --> wrong_self_convention.rs:53:19\n    |\n-51 |     pub fn to_i64(self) {}\n+53 |     pub fn to_i64(self) {}\n    |                   ^^^^\n    |\n    = note: `-D wrong-self-convention` implied by `-D warnings`\n \n error: methods called `from_*` usually take no self; consider choosing a less ambiguous name\n-  --> wrong_self_convention.rs:52:21\n+  --> wrong_self_convention.rs:54:21\n    |\n-52 |     pub fn from_i64(self) {}\n+54 |     pub fn from_i64(self) {}\n    |                     ^^^^\n    |\n    = note: `-D wrong-self-convention` implied by `-D warnings`"}]}