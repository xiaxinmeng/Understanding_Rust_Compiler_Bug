{"sha": "7a546490ecb93b9da1cd888086f00a69ebd8d0aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhNTQ2NDkwZWNiOTNiOWRhMWNkODg4MDg2ZjAwYTY5ZWJkOGQwYWE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-03-31T14:30:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-31T14:30:24Z"}, "message": "Merge #3738\n\n3738: Implement ra_proc_macro client logic r=matklad a=edwin0cheng\n\nThis PR add the actual client logic for `ra_proc_macro` crate:\r\n\r\n1. Define all necessary rpc serialization data structure, which include `ra_tt` related data and some task messages. Although adding `Serialize` and `Deserialize` trait to ra_tt directly seem to be much easier,   we deliberately duplicate the `ra_tt` struct with `#[serde(with = \"XXDef\")]` for separation of  code responsibility. \r\n2. Define a simplified version of lsp base protocol for rpc, which basically copy from lsp-server code base. \r\n3. Implement the actual `IO` for the client side progress spawning and message passing.\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>", "tree": {"sha": "18c25777f7f0fad8f60f58bf7187db45fe3307fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18c25777f7f0fad8f60f58bf7187db45fe3307fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a546490ecb93b9da1cd888086f00a69ebd8d0aa", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeg1QACRBK7hj4Ov3rIwAAdHIIABn89pk56YwOpGN30QSvCAFs\nWH/5DtjLH9J3zeK52Pv4aM3LmwldWmxg0IWP1Oj0B3jI1CHszPH2sZwG/R3daP6o\nQolGFa/M4IC9aoKnuoczNQOiyOWz3SuuGmC7DGRnJ2aOAWqVdiB2LcEW/cWvLVDx\nPv5cMaKfHWwMDhrVudpZd/vRfZ5S89EeAVLKFhVJQjRQqinstvM3/UCg7rfHD206\neyvsS9KxIVx4wIDfAFw6v/KQJeNbjBrBq56xug7iASBQnqfyQEFuoCKqszJDYDa9\nyu9ANxCrkhhXoS8VZx1y+MjkBTGI3PfzyRQNfM97slBQCj5gdU65Xgzz0Yhouhc=\n=gI8g\n-----END PGP SIGNATURE-----\n", "payload": "tree 18c25777f7f0fad8f60f58bf7187db45fe3307fd\nparent fa3c7742af9fbfe5146f4158a6119fa727dcc87a\nparent 207903a1c33961c2014010f5678b1c6807e7f6d6\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1585665024 +0000\ncommitter GitHub <noreply@github.com> 1585665024 +0000\n\nMerge #3738\n\n3738: Implement ra_proc_macro client logic r=matklad a=edwin0cheng\n\nThis PR add the actual client logic for `ra_proc_macro` crate:\r\n\r\n1. Define all necessary rpc serialization data structure, which include `ra_tt` related data and some task messages. Although adding `Serialize` and `Deserialize` trait to ra_tt directly seem to be much easier,   we deliberately duplicate the `ra_tt` struct with `#[serde(with = \"XXDef\")]` for separation of  code responsibility. \r\n2. Define a simplified version of lsp base protocol for rpc, which basically copy from lsp-server code base. \r\n3. Implement the actual `IO` for the client side progress spawning and message passing.\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a546490ecb93b9da1cd888086f00a69ebd8d0aa", "html_url": "https://github.com/rust-lang/rust/commit/7a546490ecb93b9da1cd888086f00a69ebd8d0aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a546490ecb93b9da1cd888086f00a69ebd8d0aa/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa3c7742af9fbfe5146f4158a6119fa727dcc87a", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa3c7742af9fbfe5146f4158a6119fa727dcc87a", "html_url": "https://github.com/rust-lang/rust/commit/fa3c7742af9fbfe5146f4158a6119fa727dcc87a"}, {"sha": "207903a1c33961c2014010f5678b1c6807e7f6d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/207903a1c33961c2014010f5678b1c6807e7f6d6", "html_url": "https://github.com/rust-lang/rust/commit/207903a1c33961c2014010f5678b1c6807e7f6d6"}], "stats": {"total": 719, "additions": 696, "deletions": 23}, "files": [{"sha": "f618fcc3db137b77f24a9a035e20badb9ae4aa8a", "filename": "Cargo.lock", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7a546490ecb93b9da1cd888086f00a69ebd8d0aa/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7a546490ecb93b9da1cd888086f00a69ebd8d0aa/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=7a546490ecb93b9da1cd888086f00a69ebd8d0aa", "patch": "@@ -1075,7 +1075,12 @@ dependencies = [\n name = \"ra_proc_macro\"\n version = \"0.1.0\"\n dependencies = [\n+ \"crossbeam-channel\",\n+ \"jod-thread\",\n+ \"log\",\n  \"ra_tt\",\n+ \"serde\",\n+ \"serde_json\",\n ]\n \n [[package]]"}, {"sha": "97d1208ec6b7be18dd9e6dc998b32fe4380803c9", "filename": "crates/ra_hir_expand/src/proc_macro.rs", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7a546490ecb93b9da1cd888086f00a69ebd8d0aa/crates%2Fra_hir_expand%2Fsrc%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a546490ecb93b9da1cd888086f00a69ebd8d0aa/crates%2Fra_hir_expand%2Fsrc%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fproc_macro.rs?ref=7a546490ecb93b9da1cd888086f00a69ebd8d0aa", "patch": "@@ -9,6 +9,15 @@ pub struct ProcMacroExpander {\n     proc_macro_id: ProcMacroId,\n }\n \n+macro_rules! err {\n+    ($fmt:literal, $($tt:tt),*) => {\n+        mbe::ExpandError::ProcMacroError(tt::ExpansionError::Unknown(format!($fmt, $($tt),*)))\n+    };\n+    ($fmt:literal) => {\n+        mbe::ExpandError::ProcMacroError(tt::ExpansionError::Unknown($fmt.to_string()))\n+    }\n+}\n+\n impl ProcMacroExpander {\n     pub fn new(krate: CrateId, proc_macro_id: ProcMacroId) -> ProcMacroExpander {\n         ProcMacroExpander { krate, proc_macro_id }\n@@ -25,8 +34,24 @@ impl ProcMacroExpander {\n             .proc_macro\n             .get(self.proc_macro_id.0 as usize)\n             .clone()\n-            .ok_or_else(|| mbe::ExpandError::ConversionError)?;\n+            .ok_or_else(|| err!(\"No derive macro found.\"))?;\n+\n+        let tt = remove_derive_atr(tt, &proc_macro.name)\n+            .ok_or_else(|| err!(\"Fail to remove derive for custom derive\"))?;\n \n         proc_macro.expander.expand(&tt, None).map_err(mbe::ExpandError::from)\n     }\n }\n+\n+fn remove_derive_atr(tt: &tt::Subtree, _name: &str) -> Option<tt::Subtree> {\n+    // FIXME: proper handle the remove derive\n+    // We assume the first 2 tokens are #[derive(name)]\n+    if tt.token_trees.len() > 2 {\n+        let mut tt = tt.clone();\n+        tt.token_trees.remove(0);\n+        tt.token_trees.remove(0);\n+        return Some(tt);\n+    }\n+\n+    None\n+}"}, {"sha": "d009ceb82e53283c4655a7ce982a3807ef0c9b25", "filename": "crates/ra_proc_macro/Cargo.toml", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7a546490ecb93b9da1cd888086f00a69ebd8d0aa/crates%2Fra_proc_macro%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7a546490ecb93b9da1cd888086f00a69ebd8d0aa/crates%2Fra_proc_macro%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro%2FCargo.toml?ref=7a546490ecb93b9da1cd888086f00a69ebd8d0aa", "patch": "@@ -10,3 +10,8 @@ doctest = false\n \n [dependencies]\n ra_tt = { path = \"../ra_tt\" }\n+serde = { version = \"1.0\", features = [\"derive\"] }\n+serde_json = \"1.0\"\n+log = \"0.4.8\"\n+crossbeam-channel = \"0.4.0\"\n+jod-thread = \"0.1.1\""}, {"sha": "51fbb046a973fe12f3728e074ca93b5675c70a78", "filename": "crates/ra_proc_macro/src/lib.rs", "status": "modified", "additions": 67, "deletions": 18, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/7a546490ecb93b9da1cd888086f00a69ebd8d0aa/crates%2Fra_proc_macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a546490ecb93b9da1cd888086f00a69ebd8d0aa/crates%2Fra_proc_macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro%2Fsrc%2Flib.rs?ref=7a546490ecb93b9da1cd888086f00a69ebd8d0aa", "patch": "@@ -5,55 +5,104 @@\n //! is used to provide basic infrastructure  for communication between two\n //! processes: Client (RA itself), Server (the external program)\n \n+mod rpc;\n+mod process;\n+pub mod msg;\n+\n+use process::{ProcMacroProcessSrv, ProcMacroProcessThread};\n use ra_tt::{SmolStr, Subtree};\n+use rpc::ProcMacroKind;\n use std::{\n     path::{Path, PathBuf},\n     sync::Arc,\n };\n \n-#[derive(Debug, Clone, PartialEq, Eq)]\n+pub use rpc::{ExpansionResult, ExpansionTask};\n+\n+#[derive(Debug, Clone)]\n pub struct ProcMacroProcessExpander {\n     process: Arc<ProcMacroProcessSrv>,\n+    dylib_path: PathBuf,\n     name: SmolStr,\n }\n \n+impl Eq for ProcMacroProcessExpander {}\n+impl PartialEq for ProcMacroProcessExpander {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.name == other.name\n+            && self.dylib_path == other.dylib_path\n+            && Arc::ptr_eq(&self.process, &other.process)\n+    }\n+}\n+\n impl ra_tt::TokenExpander for ProcMacroProcessExpander {\n     fn expand(\n         &self,\n-        _subtree: &Subtree,\n+        subtree: &Subtree,\n         _attr: Option<&Subtree>,\n     ) -> Result<Subtree, ra_tt::ExpansionError> {\n-        // FIXME: do nothing for now\n-        Ok(Subtree::default())\n+        self.process.custom_derive(&self.dylib_path, subtree, &self.name)\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct ProcMacroProcessSrv {\n-    path: PathBuf,\n+#[derive(Debug)]\n+enum ProcMacroClientKind {\n+    Process { process: Arc<ProcMacroProcessSrv>, thread: ProcMacroProcessThread },\n+    Dummy,\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub enum ProcMacroClient {\n-    Process { process: Arc<ProcMacroProcessSrv> },\n-    Dummy,\n+#[derive(Debug)]\n+pub struct ProcMacroClient {\n+    kind: ProcMacroClientKind,\n }\n \n impl ProcMacroClient {\n-    pub fn extern_process(process_path: &Path) -> ProcMacroClient {\n-        let process = ProcMacroProcessSrv { path: process_path.into() };\n-        ProcMacroClient::Process { process: Arc::new(process) }\n+    pub fn extern_process(process_path: &Path) -> Result<ProcMacroClient, std::io::Error> {\n+        let (thread, process) = ProcMacroProcessSrv::run(process_path)?;\n+        Ok(ProcMacroClient {\n+            kind: ProcMacroClientKind::Process { process: Arc::new(process), thread },\n+        })\n     }\n \n     pub fn dummy() -> ProcMacroClient {\n-        ProcMacroClient::Dummy\n+        ProcMacroClient { kind: ProcMacroClientKind::Dummy }\n     }\n \n     pub fn by_dylib_path(\n         &self,\n-        _dylib_path: &Path,\n+        dylib_path: &Path,\n     ) -> Vec<(SmolStr, Arc<dyn ra_tt::TokenExpander>)> {\n-        // FIXME: return empty for now\n-        vec![]\n+        match &self.kind {\n+            ProcMacroClientKind::Dummy => vec![],\n+            ProcMacroClientKind::Process { process, .. } => {\n+                let macros = match process.find_proc_macros(dylib_path) {\n+                    Err(err) => {\n+                        eprintln!(\"Fail to find proc macro. Error: {:#?}\", err);\n+                        return vec![];\n+                    }\n+                    Ok(macros) => macros,\n+                };\n+\n+                macros\n+                    .into_iter()\n+                    .filter_map(|(name, kind)| {\n+                        // FIXME: Support custom derive only for now.\n+                        match kind {\n+                            ProcMacroKind::CustomDerive => {\n+                                let name = SmolStr::new(&name);\n+                                let expander: Arc<dyn ra_tt::TokenExpander> =\n+                                    Arc::new(ProcMacroProcessExpander {\n+                                        process: process.clone(),\n+                                        name: name.clone(),\n+                                        dylib_path: dylib_path.into(),\n+                                    });\n+                                Some((name, expander))\n+                            }\n+                            _ => None,\n+                        }\n+                    })\n+                    .collect()\n+            }\n+        }\n     }\n }"}, {"sha": "aa95bcc8f7bc5d5d5537d2dbf4e541dddd6af887", "filename": "crates/ra_proc_macro/src/msg.rs", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/7a546490ecb93b9da1cd888086f00a69ebd8d0aa/crates%2Fra_proc_macro%2Fsrc%2Fmsg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a546490ecb93b9da1cd888086f00a69ebd8d0aa/crates%2Fra_proc_macro%2Fsrc%2Fmsg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro%2Fsrc%2Fmsg.rs?ref=7a546490ecb93b9da1cd888086f00a69ebd8d0aa", "patch": "@@ -0,0 +1,93 @@\n+//! Defines messages for cross-process message based on `ndjson` wire protocol\n+\n+use std::{\n+    convert::TryFrom,\n+    io::{self, BufRead, Write},\n+};\n+\n+use crate::{\n+    rpc::{ListMacrosResult, ListMacrosTask},\n+    ExpansionResult, ExpansionTask,\n+};\n+use serde::{de::DeserializeOwned, Deserialize, Serialize};\n+\n+#[derive(Debug, Serialize, Deserialize, Clone)]\n+pub enum Request {\n+    ListMacro(ListMacrosTask),\n+    ExpansionMacro(ExpansionTask),\n+}\n+\n+#[derive(Debug, Serialize, Deserialize, Clone)]\n+pub enum Response {\n+    Error(ResponseError),\n+    ListMacro(ListMacrosResult),\n+    ExpansionMacro(ExpansionResult),\n+}\n+\n+macro_rules! impl_try_from_response {\n+    ($ty:ty, $tag:ident) => {\n+        impl TryFrom<Response> for $ty {\n+            type Error = &'static str;\n+            fn try_from(value: Response) -> Result<Self, Self::Error> {\n+                match value {\n+                    Response::$tag(res) => Ok(res),\n+                    _ => Err(\"Fail to convert from response\"),\n+                }\n+            }\n+        }\n+    };\n+}\n+\n+impl_try_from_response!(ListMacrosResult, ListMacro);\n+impl_try_from_response!(ExpansionResult, ExpansionMacro);\n+\n+#[derive(Debug, Serialize, Deserialize, Clone)]\n+pub struct ResponseError {\n+    pub code: ErrorCode,\n+    pub message: String,\n+}\n+\n+#[derive(Debug, Serialize, Deserialize, Clone)]\n+pub enum ErrorCode {\n+    ServerErrorEnd,\n+    ExpansionError,\n+}\n+\n+pub trait Message: Sized + Serialize + DeserializeOwned {\n+    fn read(r: &mut impl BufRead) -> io::Result<Option<Self>> {\n+        let text = match read_json(r)? {\n+            None => return Ok(None),\n+            Some(text) => text,\n+        };\n+        let msg = serde_json::from_str(&text)?;\n+        Ok(Some(msg))\n+    }\n+    fn write(self, w: &mut impl Write) -> io::Result<()> {\n+        let text = serde_json::to_string(&self)?;\n+        write_json(w, &text)\n+    }\n+}\n+\n+impl Message for Request {}\n+impl Message for Response {}\n+\n+fn read_json(inp: &mut impl BufRead) -> io::Result<Option<String>> {\n+    let mut buf = String::new();\n+    if inp.read_line(&mut buf)? == 0 {\n+        return Ok(None);\n+    }\n+    // Remove ending '\\n'\n+    let buf = &buf[..buf.len() - 1];\n+    if buf.is_empty() {\n+        return Ok(None);\n+    }\n+    Ok(Some(buf.to_string()))\n+}\n+\n+fn write_json(out: &mut impl Write, msg: &str) -> io::Result<()> {\n+    log::debug!(\"> {}\", msg);\n+    out.write_all(msg.as_bytes())?;\n+    out.write_all(b\"\\n\")?;\n+    out.flush()?;\n+    Ok(())\n+}"}, {"sha": "e8c85be38ae739fb97ea5b2c515960bfaad9f984", "filename": "crates/ra_proc_macro/src/process.rs", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/7a546490ecb93b9da1cd888086f00a69ebd8d0aa/crates%2Fra_proc_macro%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a546490ecb93b9da1cd888086f00a69ebd8d0aa/crates%2Fra_proc_macro%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro%2Fsrc%2Fprocess.rs?ref=7a546490ecb93b9da1cd888086f00a69ebd8d0aa", "patch": "@@ -0,0 +1,196 @@\n+//! Handle process life-time and message passing for proc-macro client\n+\n+use crossbeam_channel::{bounded, Receiver, Sender};\n+use ra_tt::Subtree;\n+\n+use crate::msg::{ErrorCode, Message, Request, Response, ResponseError};\n+use crate::rpc::{ExpansionResult, ExpansionTask, ListMacrosResult, ListMacrosTask, ProcMacroKind};\n+\n+use io::{BufRead, BufReader};\n+use std::{\n+    convert::{TryFrom, TryInto},\n+    io::{self, Write},\n+    path::{Path, PathBuf},\n+    process::{Child, Command, Stdio},\n+    sync::{Arc, Weak},\n+};\n+\n+#[derive(Debug, Default)]\n+pub(crate) struct ProcMacroProcessSrv {\n+    inner: Option<Weak<Sender<Task>>>,\n+}\n+\n+#[derive(Debug)]\n+pub(crate) struct ProcMacroProcessThread {\n+    // XXX: drop order is significant\n+    sender: Arc<Sender<Task>>,\n+    handle: jod_thread::JoinHandle<()>,\n+}\n+\n+struct Task {\n+    req: Request,\n+    result_tx: Sender<Option<Response>>,\n+}\n+\n+struct Process {\n+    path: PathBuf,\n+    child: Child,\n+}\n+\n+impl Drop for Process {\n+    fn drop(&mut self) {\n+        let _ = self.child.kill();\n+    }\n+}\n+\n+impl Process {\n+    fn run(process_path: &Path) -> Result<Process, io::Error> {\n+        let child = Command::new(process_path.clone())\n+            .stdin(Stdio::piped())\n+            .stdout(Stdio::piped())\n+            .stderr(Stdio::null())\n+            .spawn()?;\n+\n+        Ok(Process { path: process_path.into(), child })\n+    }\n+\n+    fn restart(&mut self) -> Result<(), io::Error> {\n+        let _ = self.child.kill();\n+        self.child = Command::new(self.path.clone())\n+            .stdin(Stdio::piped())\n+            .stdout(Stdio::piped())\n+            .stderr(Stdio::null())\n+            .spawn()?;\n+        Ok(())\n+    }\n+\n+    fn stdio(&mut self) -> Option<(impl Write, impl BufRead)> {\n+        let stdin = self.child.stdin.take()?;\n+        let stdout = self.child.stdout.take()?;\n+        let read = BufReader::new(stdout);\n+\n+        Some((stdin, read))\n+    }\n+}\n+\n+impl ProcMacroProcessSrv {\n+    pub fn run(\n+        process_path: &Path,\n+    ) -> Result<(ProcMacroProcessThread, ProcMacroProcessSrv), io::Error> {\n+        let process = Process::run(process_path)?;\n+\n+        let (task_tx, task_rx) = bounded(0);\n+        let handle = jod_thread::spawn(move || {\n+            client_loop(task_rx, process);\n+        });\n+\n+        let task_tx = Arc::new(task_tx);\n+        let srv = ProcMacroProcessSrv { inner: Some(Arc::downgrade(&task_tx)) };\n+        let thread = ProcMacroProcessThread { handle, sender: task_tx };\n+\n+        Ok((thread, srv))\n+    }\n+\n+    pub fn find_proc_macros(\n+        &self,\n+        dylib_path: &Path,\n+    ) -> Result<Vec<(String, ProcMacroKind)>, ra_tt::ExpansionError> {\n+        let task = ListMacrosTask { lib: dylib_path.to_path_buf() };\n+\n+        let result: ListMacrosResult = self.send_task(Request::ListMacro(task))?;\n+        Ok(result.macros)\n+    }\n+\n+    pub fn custom_derive(\n+        &self,\n+        dylib_path: &Path,\n+        subtree: &Subtree,\n+        derive_name: &str,\n+    ) -> Result<Subtree, ra_tt::ExpansionError> {\n+        let task = ExpansionTask {\n+            macro_body: subtree.clone(),\n+            macro_name: derive_name.to_string(),\n+            attributes: None,\n+            lib: dylib_path.to_path_buf(),\n+        };\n+\n+        let result: ExpansionResult = self.send_task(Request::ExpansionMacro(task))?;\n+        Ok(result.expansion)\n+    }\n+\n+    pub fn send_task<R>(&self, req: Request) -> Result<R, ra_tt::ExpansionError>\n+    where\n+        R: TryFrom<Response, Error = &'static str>,\n+    {\n+        let sender = match &self.inner {\n+            None => return Err(ra_tt::ExpansionError::Unknown(\"No sender is found.\".to_string())),\n+            Some(it) => it,\n+        };\n+\n+        let (result_tx, result_rx) = bounded(0);\n+        let sender = match sender.upgrade() {\n+            None => {\n+                return Err(ra_tt::ExpansionError::Unknown(\"Proc macro process is closed.\".into()))\n+            }\n+            Some(it) => it,\n+        };\n+        sender.send(Task { req: req.into(), result_tx }).unwrap();\n+        let res = result_rx\n+            .recv()\n+            .map_err(|_| ra_tt::ExpansionError::Unknown(\"Proc macro thread is closed.\".into()))?;\n+\n+        match res {\n+            Some(Response::Error(err)) => {\n+                return Err(ra_tt::ExpansionError::ExpansionError(err.message));\n+            }\n+            Some(res) => Ok(res.try_into().map_err(|err| {\n+                ra_tt::ExpansionError::Unknown(format!(\n+                    \"Fail to get response, reason : {:#?} \",\n+                    err\n+                ))\n+            })?),\n+            None => Err(ra_tt::ExpansionError::Unknown(\"Empty result\".into())),\n+        }\n+    }\n+}\n+\n+fn client_loop(task_rx: Receiver<Task>, mut process: Process) {\n+    let (mut stdin, mut stdout) = match process.stdio() {\n+        None => return,\n+        Some(it) => it,\n+    };\n+\n+    for task in task_rx {\n+        let Task { req, result_tx } = task;\n+\n+        match send_request(&mut stdin, &mut stdout, req) {\n+            Ok(res) => result_tx.send(res).unwrap(),\n+            Err(_err) => {\n+                let res = Response::Error(ResponseError {\n+                    code: ErrorCode::ServerErrorEnd,\n+                    message: \"Server closed\".into(),\n+                });\n+                result_tx.send(res.into()).unwrap();\n+                // Restart the process\n+                if process.restart().is_err() {\n+                    break;\n+                }\n+                let stdio = match process.stdio() {\n+                    None => break,\n+                    Some(it) => it,\n+                };\n+                stdin = stdio.0;\n+                stdout = stdio.1;\n+            }\n+        }\n+    }\n+}\n+\n+fn send_request(\n+    mut writer: &mut impl Write,\n+    mut reader: &mut impl BufRead,\n+    req: Request,\n+) -> Result<Option<Response>, io::Error> {\n+    req.write(&mut writer)?;\n+    Ok(Response::read(&mut reader)?)\n+}"}, {"sha": "66b3f55db3708ac84aac0b643da6e9d1b67dfa61", "filename": "crates/ra_proc_macro/src/rpc.rs", "status": "added", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/7a546490ecb93b9da1cd888086f00a69ebd8d0aa/crates%2Fra_proc_macro%2Fsrc%2Frpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a546490ecb93b9da1cd888086f00a69ebd8d0aa/crates%2Fra_proc_macro%2Fsrc%2Frpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro%2Fsrc%2Frpc.rs?ref=7a546490ecb93b9da1cd888086f00a69ebd8d0aa", "patch": "@@ -0,0 +1,266 @@\n+//! Data struture serialization related stuffs for RPC\n+//!\n+//! Define all necessary rpc serialization data structure,\n+//! which include ra_tt related data and some task messages.\n+//! Although adding Serialize and Deserialize trait to ra_tt directly seem to be much easier,\n+//! we deliberately duplicate the ra_tt struct with #[serde(with = \"XXDef\")]\n+//! for separation of code responsibility.\n+\n+use ra_tt::{\n+    Delimiter, DelimiterKind, Ident, Leaf, Literal, Punct, SmolStr, Spacing, Subtree, TokenId,\n+    TokenTree,\n+};\n+use serde::{Deserialize, Serialize};\n+use std::path::PathBuf;\n+\n+#[derive(Clone, Eq, PartialEq, Debug, Serialize, Deserialize)]\n+pub struct ListMacrosTask {\n+    pub lib: PathBuf,\n+}\n+\n+#[derive(Clone, Eq, PartialEq, Debug, Serialize, Deserialize)]\n+pub enum ProcMacroKind {\n+    CustomDerive,\n+    FuncLike,\n+    Attr,\n+}\n+\n+#[derive(Clone, Eq, PartialEq, Debug, Default, Serialize, Deserialize)]\n+pub struct ListMacrosResult {\n+    pub macros: Vec<(String, ProcMacroKind)>,\n+}\n+\n+#[derive(Clone, Eq, PartialEq, Debug, Serialize, Deserialize)]\n+pub struct ExpansionTask {\n+    /// Argument of macro call.\n+    ///\n+    /// In custom derive that would be a struct or enum; in attribute-like macro - underlying\n+    /// item; in function-like macro - the macro body.\n+    #[serde(with = \"SubtreeDef\")]\n+    pub macro_body: Subtree,\n+\n+    /// Names of macros to expand.\n+    ///\n+    /// In custom derive those are names of derived traits (`Serialize`, `Getters`, etc.). In\n+    /// attribute-like and functiona-like macros - single name of macro itself (`show_streams`).\n+    pub macro_name: String,\n+\n+    /// Possible attributes for the attribute-like macros.\n+    #[serde(with = \"opt_subtree_def\")]\n+    pub attributes: Option<Subtree>,\n+\n+    pub lib: PathBuf,\n+}\n+\n+#[derive(Clone, Eq, PartialEq, Debug, Default, Serialize, Deserialize)]\n+pub struct ExpansionResult {\n+    #[serde(with = \"SubtreeDef\")]\n+    pub expansion: Subtree,\n+}\n+\n+#[derive(Serialize, Deserialize)]\n+#[serde(remote = \"DelimiterKind\")]\n+enum DelimiterKindDef {\n+    Parenthesis,\n+    Brace,\n+    Bracket,\n+}\n+\n+#[derive(Serialize, Deserialize)]\n+#[serde(remote = \"TokenId\")]\n+struct TokenIdDef(u32);\n+\n+#[derive(Serialize, Deserialize)]\n+#[serde(remote = \"Delimiter\")]\n+struct DelimiterDef {\n+    #[serde(with = \"TokenIdDef\")]\n+    pub id: TokenId,\n+    #[serde(with = \"DelimiterKindDef\")]\n+    pub kind: DelimiterKind,\n+}\n+\n+#[derive(Serialize, Deserialize)]\n+#[serde(remote = \"Subtree\")]\n+struct SubtreeDef {\n+    #[serde(default, with = \"opt_delimiter_def\")]\n+    pub delimiter: Option<Delimiter>,\n+    #[serde(with = \"vec_token_tree\")]\n+    pub token_trees: Vec<TokenTree>,\n+}\n+\n+#[derive(Serialize, Deserialize)]\n+#[serde(remote = \"TokenTree\")]\n+enum TokenTreeDef {\n+    #[serde(with = \"LeafDef\")]\n+    Leaf(Leaf),\n+    #[serde(with = \"SubtreeDef\")]\n+    Subtree(Subtree),\n+}\n+\n+#[derive(Serialize, Deserialize)]\n+#[serde(remote = \"Leaf\")]\n+enum LeafDef {\n+    #[serde(with = \"LiteralDef\")]\n+    Literal(Literal),\n+    #[serde(with = \"PunctDef\")]\n+    Punct(Punct),\n+    #[serde(with = \"IdentDef\")]\n+    Ident(Ident),\n+}\n+\n+#[derive(Serialize, Deserialize)]\n+#[serde(remote = \"Literal\")]\n+struct LiteralDef {\n+    pub text: SmolStr,\n+    #[serde(with = \"TokenIdDef\")]\n+    pub id: TokenId,\n+}\n+\n+#[derive(Serialize, Deserialize)]\n+#[serde(remote = \"Punct\")]\n+struct PunctDef {\n+    pub char: char,\n+    #[serde(with = \"SpacingDef\")]\n+    pub spacing: Spacing,\n+    #[serde(with = \"TokenIdDef\")]\n+    pub id: TokenId,\n+}\n+\n+#[derive(Serialize, Deserialize)]\n+#[serde(remote = \"Spacing\")]\n+enum SpacingDef {\n+    Alone,\n+    Joint,\n+}\n+\n+#[derive(Serialize, Deserialize)]\n+#[serde(remote = \"Ident\")]\n+struct IdentDef {\n+    pub text: SmolStr,\n+    #[serde(with = \"TokenIdDef\")]\n+    pub id: TokenId,\n+}\n+\n+mod opt_delimiter_def {\n+    use super::{Delimiter, DelimiterDef};\n+    use serde::{Deserialize, Deserializer, Serialize, Serializer};\n+\n+    pub fn serialize<S>(value: &Option<Delimiter>, serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: Serializer,\n+    {\n+        #[derive(Serialize)]\n+        struct Helper<'a>(#[serde(with = \"DelimiterDef\")] &'a Delimiter);\n+        value.as_ref().map(Helper).serialize(serializer)\n+    }\n+\n+    pub fn deserialize<'de, D>(deserializer: D) -> Result<Option<Delimiter>, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        #[derive(Deserialize)]\n+        struct Helper(#[serde(with = \"DelimiterDef\")] Delimiter);\n+        let helper = Option::deserialize(deserializer)?;\n+        Ok(helper.map(|Helper(external)| external))\n+    }\n+}\n+\n+mod opt_subtree_def {\n+    use super::{Subtree, SubtreeDef};\n+    use serde::{Deserialize, Deserializer, Serialize, Serializer};\n+\n+    pub fn serialize<S>(value: &Option<Subtree>, serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: Serializer,\n+    {\n+        #[derive(Serialize)]\n+        struct Helper<'a>(#[serde(with = \"SubtreeDef\")] &'a Subtree);\n+        value.as_ref().map(Helper).serialize(serializer)\n+    }\n+\n+    pub fn deserialize<'de, D>(deserializer: D) -> Result<Option<Subtree>, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        #[derive(Deserialize)]\n+        struct Helper(#[serde(with = \"SubtreeDef\")] Subtree);\n+        let helper = Option::deserialize(deserializer)?;\n+        Ok(helper.map(|Helper(external)| external))\n+    }\n+}\n+\n+mod vec_token_tree {\n+    use super::{TokenTree, TokenTreeDef};\n+    use serde::{ser::SerializeSeq, Deserialize, Deserializer, Serialize, Serializer};\n+\n+    pub fn serialize<S>(value: &Vec<TokenTree>, serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: Serializer,\n+    {\n+        #[derive(Serialize)]\n+        struct Helper<'a>(#[serde(with = \"TokenTreeDef\")] &'a TokenTree);\n+\n+        let items: Vec<_> = value.iter().map(Helper).collect();\n+        let mut seq = serializer.serialize_seq(Some(items.len()))?;\n+        for element in items {\n+            seq.serialize_element(&element)?;\n+        }\n+        seq.end()\n+    }\n+\n+    pub fn deserialize<'de, D>(deserializer: D) -> Result<Vec<TokenTree>, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        #[derive(Deserialize)]\n+        struct Helper(#[serde(with = \"TokenTreeDef\")] TokenTree);\n+\n+        let helper = Vec::deserialize(deserializer)?;\n+        Ok(helper.into_iter().map(|Helper(external)| external).collect())\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    fn fixture_token_tree() -> Subtree {\n+        let mut subtree = Subtree::default();\n+        subtree\n+            .token_trees\n+            .push(TokenTree::Leaf(Ident { text: \"struct\".into(), id: TokenId(0) }.into()));\n+        subtree\n+            .token_trees\n+            .push(TokenTree::Leaf(Ident { text: \"Foo\".into(), id: TokenId(1) }.into()));\n+        subtree.token_trees.push(TokenTree::Subtree(\n+            Subtree {\n+                delimiter: Some(Delimiter { id: TokenId(2), kind: DelimiterKind::Brace }),\n+                token_trees: vec![],\n+            }\n+            .into(),\n+        ));\n+        subtree\n+    }\n+\n+    #[test]\n+    fn test_proc_macro_rpc_works() {\n+        let tt = fixture_token_tree();\n+        let task = ExpansionTask {\n+            macro_body: tt.clone(),\n+            macro_name: Default::default(),\n+            attributes: None,\n+            lib: Default::default(),\n+        };\n+\n+        let json = serde_json::to_string(&task).unwrap();\n+        let back: ExpansionTask = serde_json::from_str(&json).unwrap();\n+\n+        assert_eq!(task.macro_body, back.macro_body);\n+\n+        let result = ExpansionResult { expansion: tt.clone() };\n+        let json = serde_json::to_string(&result).unwrap();\n+        let back: ExpansionResult = serde_json::from_str(&json).unwrap();\n+\n+        assert_eq!(result, back);\n+    }\n+}"}, {"sha": "0aea01d8331e652923f87a848fcab43c2c92d35d", "filename": "crates/ra_project_model/src/cargo_workspace.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7a546490ecb93b9da1cd888086f00a69ebd8d0aa/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a546490ecb93b9da1cd888086f00a69ebd8d0aa/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs?ref=7a546490ecb93b9da1cd888086f00a69ebd8d0aa", "patch": "@@ -1,6 +1,7 @@\n //! FIXME: write short doc here\n \n use std::{\n+    ffi::OsStr,\n     ops,\n     path::{Path, PathBuf},\n };\n@@ -299,7 +300,10 @@ pub fn load_extern_resources(cargo_toml: &Path, cargo_features: &CargoFeatures)\n             Message::CompilerArtifact(message) => {\n                 if message.target.kind.contains(&\"proc-macro\".to_string()) {\n                     let package_id = message.package_id;\n-                    if let Some(filename) = message.filenames.get(0) {\n+                    // Skip rmeta file\n+                    if let Some(filename) =\n+                        message.filenames.iter().filter(|name| is_dylib(name)).next()\n+                    {\n                         acc.proc_dylib_paths.insert(package_id, filename.clone());\n                     }\n                 }\n@@ -316,3 +320,11 @@ pub fn load_extern_resources(cargo_toml: &Path, cargo_features: &CargoFeatures)\n \n     acc\n }\n+\n+// FIXME: File a better way to know if it is a dylib\n+fn is_dylib(path: &Path) -> bool {\n+    match path.extension().and_then(OsStr::to_str).map(|it| it.to_string().to_lowercase()) {\n+        None => false,\n+        Some(ext) => matches!(ext.as_str(), \"dll\" | \"dylib\" | \"so\"),\n+    }\n+}"}, {"sha": "bd484aa30a04e94b274dc3f5acf2cb2964f49b6f", "filename": "crates/ra_tt/src/lib.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7a546490ecb93b9da1cd888086f00a69ebd8d0aa/crates%2Fra_tt%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a546490ecb93b9da1cd888086f00a69ebd8d0aa/crates%2Fra_tt%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_tt%2Fsrc%2Flib.rs?ref=7a546490ecb93b9da1cd888086f00a69ebd8d0aa", "patch": "@@ -189,7 +189,12 @@ impl Subtree {\n pub mod buffer;\n \n #[derive(Debug, PartialEq, Eq)]\n-pub enum ExpansionError {}\n+pub enum ExpansionError {\n+    IOError(String),\n+    JsonError(String),\n+    Unknown(String),\n+    ExpansionError(String),\n+}\n \n pub trait TokenExpander: Debug + Send + Sync + RefUnwindSafe {\n     fn expand(&self, subtree: &Subtree, attrs: Option<&Subtree>)"}, {"sha": "9fd56860164671755c79c42900c3b4e4e2fcf06b", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a546490ecb93b9da1cd888086f00a69ebd8d0aa/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a546490ecb93b9da1cd888086f00a69ebd8d0aa/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=7a546490ecb93b9da1cd888086f00a69ebd8d0aa", "patch": "@@ -109,6 +109,7 @@ fn get_config(\n         },\n         rustfmt_args: config.rustfmt_args.clone(),\n         vscode_lldb: config.vscode_lldb,\n+        proc_macro_srv: None, // FIXME: get this from config\n     }\n }\n "}, {"sha": "4e2ddcb8bb470aa8559bd0a804af3946c588c762", "filename": "crates/rust-analyzer/src/world.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7a546490ecb93b9da1cd888086f00a69ebd8d0aa/crates%2Frust-analyzer%2Fsrc%2Fworld.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a546490ecb93b9da1cd888086f00a69ebd8d0aa/crates%2Frust-analyzer%2Fsrc%2Fworld.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fworld.rs?ref=7a546490ecb93b9da1cd888086f00a69ebd8d0aa", "patch": "@@ -58,6 +58,7 @@ pub struct Config {\n     pub rustfmt_args: Vec<String>,\n     pub check: CheckConfig,\n     pub vscode_lldb: bool,\n+    pub proc_macro_srv: Option<String>,\n }\n \n /// `WorldState` is the primary mutable state of the language server\n@@ -167,8 +168,23 @@ impl WorldState {\n             vfs_file.map(|f| FileId(f.0))\n         };\n \n-        let proc_macro_client =\n-            ProcMacroClient::extern_process(std::path::Path::new(\"ra_proc_macro_srv\"));\n+        let proc_macro_client = match &config.proc_macro_srv {\n+            None => ProcMacroClient::dummy(),\n+            Some(srv) => {\n+                let path = Path::new(&srv);\n+                match ProcMacroClient::extern_process(path) {\n+                    Ok(it) => it,\n+                    Err(err) => {\n+                        log::error!(\n+                            \"Fail to run ra_proc_macro_srv from path {}, error : {}\",\n+                            path.to_string_lossy(),\n+                            err\n+                        );\n+                        ProcMacroClient::dummy()\n+                    }\n+                }\n+            }\n+        };\n \n         workspaces\n             .iter()"}]}