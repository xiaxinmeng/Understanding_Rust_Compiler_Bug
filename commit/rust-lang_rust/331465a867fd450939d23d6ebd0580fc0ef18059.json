{"sha": "331465a867fd450939d23d6ebd0580fc0ef18059", "node_id": "C_kwDOAAsO6NoAKDMzMTQ2NWE4NjdmZDQ1MDkzOWQyM2Q2ZWJkMDU4MGZjMGVmMTgwNTk", "commit": {"author": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2021-11-19T22:51:45Z"}, "committer": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2021-11-19T22:55:40Z"}, "message": "rustdoc: Pass DocContext to `Cache::populate`\n\nThis will allow removing `Crate.externs`.", "tree": {"sha": "d2c353a71d28b2365a22f20d9cf961f8faf6491d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d2c353a71d28b2365a22f20d9cf961f8faf6491d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/331465a867fd450939d23d6ebd0580fc0ef18059", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/331465a867fd450939d23d6ebd0580fc0ef18059", "html_url": "https://github.com/rust-lang/rust/commit/331465a867fd450939d23d6ebd0580fc0ef18059", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/331465a867fd450939d23d6ebd0580fc0ef18059/comments", "author": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "548c1088eff51fd92ad94d56b8c5b2d48b7088f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/548c1088eff51fd92ad94d56b8c5b2d48b7088f0", "html_url": "https://github.com/rust-lang/rust/commit/548c1088eff51fd92ad94d56b8c5b2d48b7088f0"}], "stats": {"total": 39, "additions": 18, "deletions": 21}, "files": [{"sha": "c58310947d2825e934acdbb9148a10c41f968482", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/331465a867fd450939d23d6ebd0580fc0ef18059/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/331465a867fd450939d23d6ebd0580fc0ef18059/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=331465a867fd450939d23d6ebd0580fc0ef18059", "patch": "@@ -508,14 +508,12 @@ crate fn run_global_ctxt(\n         rustc_errors::FatalError.raise();\n     }\n \n-    let render_options = ctxt.render_options;\n-    let mut cache = ctxt.cache;\n-    krate = tcx.sess.time(\"create_format_cache\", || cache.populate(krate, tcx, &render_options));\n+    krate = tcx.sess.time(\"create_format_cache\", || Cache::populate(&mut ctxt, krate));\n \n     // The main crate doc comments are always collapsed.\n     krate.collapsed = true;\n \n-    (krate, render_options, cache)\n+    (krate, ctxt.render_options, ctxt.cache)\n }\n \n /// Due to <https://github.com/rust-lang/rust/pull/73566>,"}, {"sha": "b6808732ad0437f15278e3e02c4909fdb5d1867b", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/331465a867fd450939d23d6ebd0580fc0ef18059/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/331465a867fd450939d23d6ebd0580fc0ef18059/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=331465a867fd450939d23d6ebd0580fc0ef18059", "patch": "@@ -8,6 +8,7 @@ use rustc_span::symbol::sym;\n \n use crate::clean::{self, ItemId, PrimitiveType};\n use crate::config::RenderOptions;\n+use crate::core::DocContext;\n use crate::fold::DocFolder;\n use crate::formats::item_type::ItemType;\n use crate::formats::Impl;\n@@ -136,15 +137,13 @@ impl Cache {\n \n     /// Populates the `Cache` with more data. The returned `Crate` will be missing some data that was\n     /// in `krate` due to the data being moved into the `Cache`.\n-    crate fn populate(\n-        &mut self,\n-        mut krate: clean::Crate,\n-        tcx: TyCtxt<'_>,\n-        render_options: &RenderOptions,\n-    ) -> clean::Crate {\n+    crate fn populate(cx: &mut DocContext<'_>, mut krate: clean::Crate) -> clean::Crate {\n+        let tcx = cx.tcx;\n+        let render_options = &cx.render_options;\n+\n         // Crawl the crate to build various caches used for the output\n-        debug!(?self.crate_version);\n-        self.traits = krate.external_traits.take();\n+        debug!(?cx.cache.crate_version);\n+        cx.cache.traits = krate.external_traits.take();\n         let RenderOptions { extern_html_root_takes_precedence, output: dst, .. } = render_options;\n \n         // Cache where all our extern crates are located\n@@ -154,28 +153,28 @@ impl Cache {\n             let extern_url =\n                 render_options.extern_html_root_urls.get(&*name.as_str()).map(|u| &**u);\n             let location = e.location(extern_url, *extern_html_root_takes_precedence, dst, tcx);\n-            self.extern_locations.insert(e.crate_num, location);\n-            self.external_paths.insert(e.def_id(), (vec![name.to_string()], ItemType::Module));\n+            cx.cache.extern_locations.insert(e.crate_num, location);\n+            cx.cache.external_paths.insert(e.def_id(), (vec![name.to_string()], ItemType::Module));\n         }\n \n         // FIXME: avoid this clone (requires implementing Default manually)\n-        self.primitive_locations = PrimitiveType::primitive_locations(tcx).clone();\n-        for (prim, &def_id) in &self.primitive_locations {\n+        cx.cache.primitive_locations = PrimitiveType::primitive_locations(tcx).clone();\n+        for (prim, &def_id) in &cx.cache.primitive_locations {\n             let crate_name = tcx.crate_name(def_id.krate);\n             // Recall that we only allow primitive modules to be at the root-level of the crate.\n             // If that restriction is ever lifted, this will have to include the relative paths instead.\n-            self.external_paths.insert(\n+            cx.cache.external_paths.insert(\n                 def_id,\n                 (vec![crate_name.to_string(), prim.as_sym().to_string()], ItemType::Primitive),\n             );\n         }\n \n-        krate = CacheBuilder { tcx, cache: self }.fold_crate(krate);\n+        krate = CacheBuilder { tcx, cache: &mut cx.cache }.fold_crate(krate);\n \n-        for (trait_did, dids, impl_) in self.orphan_trait_impls.drain(..) {\n-            if self.traits.contains_key(&trait_did) {\n+        for (trait_did, dids, impl_) in cx.cache.orphan_trait_impls.drain(..) {\n+            if cx.cache.traits.contains_key(&trait_did) {\n                 for did in dids {\n-                    self.impls.entry(did).or_default().push(impl_.clone());\n+                    cx.cache.impls.entry(did).or_default().push(impl_.clone());\n                 }\n             }\n         }"}]}