{"sha": "5acc998ed9b76d9c00849e007101f9c33b17c6c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhY2M5OThlZDliNzZkOWMwMDg0OWUwMDcxMDFmOWMzM2IxN2M2YzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-08T13:01:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-08T13:01:30Z"}, "message": "auto merge of #12098 : kballard/rust/from_utf8_lossy_tweak, r=huonw\n\nMaybeOwned allows from_utf8_lossy to avoid allocation if there are no\r\ninvalid bytes in the input.\r\n\r\nBefore:\r\n```\r\ntest str::bench::from_utf8_lossy_100_ascii                      ... bench:       183 ns/iter (+/- 5)\r\ntest str::bench::from_utf8_lossy_100_invalid                    ... bench:       341 ns/iter (+/- 15)\r\ntest str::bench::from_utf8_lossy_100_multibyte                  ... bench:       227 ns/iter (+/- 13)\r\ntest str::bench::from_utf8_lossy_invalid                        ... bench:       102 ns/iter (+/- 4)\r\ntest str::bench::is_utf8_100_ascii                              ... bench:         2 ns/iter (+/- 0)\r\ntest str::bench::is_utf8_100_multibyte                          ... bench:         2 ns/iter (+/- 0)\r\n```\r\n\r\nNow:\r\n```\r\ntest str::bench::from_utf8_lossy_100_ascii                      ... bench:        96 ns/iter (+/- 4)\r\ntest str::bench::from_utf8_lossy_100_invalid                    ... bench:       318 ns/iter (+/- 10)\r\ntest str::bench::from_utf8_lossy_100_multibyte                  ... bench:       105 ns/iter (+/- 2)\r\ntest str::bench::from_utf8_lossy_invalid                        ... bench:       105 ns/iter (+/- 2)\r\ntest str::bench::is_utf8_100_ascii                              ... bench:         2 ns/iter (+/- 0)\r\ntest str::bench::is_utf8_100_multibyte                          ... bench:         2 ns/iter (+/- 0)\r\n```", "tree": {"sha": "1f1a5ad2080acda5446285f9da7077938cddd9df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f1a5ad2080acda5446285f9da7077938cddd9df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5acc998ed9b76d9c00849e007101f9c33b17c6c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5acc998ed9b76d9c00849e007101f9c33b17c6c4", "html_url": "https://github.com/rust-lang/rust/commit/5acc998ed9b76d9c00849e007101f9c33b17c6c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5acc998ed9b76d9c00849e007101f9c33b17c6c4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "548b8cec199c28c102fd98d6dd2833d3a171e7d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/548b8cec199c28c102fd98d6dd2833d3a171e7d0", "html_url": "https://github.com/rust-lang/rust/commit/548b8cec199c28c102fd98d6dd2833d3a171e7d0"}, {"sha": "1d17c2129ec696d81e6c6caee8b1740dd9509090", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d17c2129ec696d81e6c6caee8b1740dd9509090", "html_url": "https://github.com/rust-lang/rust/commit/1d17c2129ec696d81e6c6caee8b1740dd9509090"}], "stats": {"total": 819, "additions": 398, "deletions": 421}, "files": [{"sha": "8edd923390af4fed74c542de94885ecd1d303c2c", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5acc998ed9b76d9c00849e007101f9c33b17c6c4/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5acc998ed9b76d9c00849e007101f9c33b17c6c4/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=5acc998ed9b76d9c00849e007101f9c33b17c6c4", "patch": "@@ -442,9 +442,7 @@ fn check_error_patterns(props: &TestProps,\n                         testfile: &Path,\n                         ProcRes: &ProcRes) {\n     if props.error_patterns.is_empty() {\n-        testfile.display().with_str(|s| {\n-            fatal(~\"no error pattern specified in \" + s);\n-        })\n+        fatal(~\"no error pattern specified in \" + testfile.display().as_maybe_owned().as_slice());\n     }\n \n     if ProcRes.status.success() {"}, {"sha": "9aa76cad83e27dbf0ab6315e1b92cff1696b72bd", "filename": "src/etc/vim/syntax/rust.vim", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5acc998ed9b76d9c00849e007101f9c33b17c6c4/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/5acc998ed9b76d9c00849e007101f9c33b17c6c4/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim?ref=5acc998ed9b76d9c00849e007101f9c33b17c6c4", "patch": "@@ -87,8 +87,7 @@ syn keyword rustTrait Primitive Int Float ToStrRadix ToPrimitive FromPrimitive\n syn keyword rustTrait GenericPath Path PosixPath WindowsPath\n syn keyword rustTrait RawPtr\n syn keyword rustTrait Buffer Writer Reader Seek\n-syn keyword rustTrait SendStr SendStrOwned SendStrStatic IntoSendStr\n-syn keyword rustTrait Str StrVector StrSlice OwnedStr\n+syn keyword rustTrait Str StrVector StrSlice OwnedStr IntoMaybeOwned\n syn keyword rustTrait IterBytes\n syn keyword rustTrait ToStr IntoStr\n syn keyword rustTrait CloneableTuple ImmutableTuple"}, {"sha": "2d52a59c8365a5dcff7b50cd7e020392c025b6c0", "filename": "src/libextra/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5acc998ed9b76d9c00849e007101f9c33b17c6c4/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5acc998ed9b76d9c00849e007101f9c33b17c6c4/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=5acc998ed9b76d9c00849e007101f9c33b17c6c4", "patch": "@@ -893,8 +893,8 @@ pub fn run_test(force_ignore: bool,\n         spawn(proc() {\n             let mut task = task::task();\n             task.name(match desc.name {\n-                DynTestName(ref name) => SendStrOwned(name.clone()),\n-                StaticTestName(name) => SendStrStatic(name),\n+                DynTestName(ref name) => name.to_owned().into_maybe_owned(),\n+                StaticTestName(name) => name.into_maybe_owned()\n             });\n             let result_future = task.future_result();\n             task.spawn(testfn);"}, {"sha": "c5b221d22724bbc555eabd675033fefaf2b8f242", "filename": "src/libgreen/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5acc998ed9b76d9c00849e007101f9c33b17c6c4/src%2Flibgreen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5acc998ed9b76d9c00849e007101f9c33b17c6c4/src%2Flibgreen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Flib.rs?ref=5acc998ed9b76d9c00849e007101f9c33b17c6c4", "patch": "@@ -257,7 +257,7 @@ pub fn run(main: proc()) -> int {\n     let (port, chan) = Chan::new();\n     let mut opts = TaskOpts::new();\n     opts.notify_chan = Some(chan);\n-    opts.name = Some(SendStrStatic(\"<main>\"));\n+    opts.name = Some(\"<main>\".into_maybe_owned());\n     pool.spawn(opts, main);\n \n     // Wait for the main task to return, and set the process error code"}, {"sha": "e492acb4468fd143356839536103da474e33f576", "filename": "src/libgreen/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5acc998ed9b76d9c00849e007101f9c33b17c6c4/src%2Flibgreen%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5acc998ed9b76d9c00849e007101f9c33b17c6c4/src%2Flibgreen%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Ftask.rs?ref=5acc998ed9b76d9c00849e007101f9c33b17c6c4", "patch": "@@ -510,7 +510,7 @@ mod tests {\n     #[test]\n     fn smoke_opts() {\n         let mut opts = TaskOpts::new();\n-        opts.name = Some(SendStrStatic(\"test\"));\n+        opts.name = Some(\"test\".into_maybe_owned());\n         opts.stack_size = Some(20 * 4096);\n         let (p, c) = Chan::new();\n         opts.notify_chan = Some(c);"}, {"sha": "d0ca8364aa7d9a021741d7b2e199135de0418c8b", "filename": "src/libnative/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5acc998ed9b76d9c00849e007101f9c33b17c6c4/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5acc998ed9b76d9c00849e007101f9c33b17c6c4/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=5acc998ed9b76d9c00849e007101f9c33b17c6c4", "patch": "@@ -294,7 +294,7 @@ mod tests {\n     #[test]\n     fn smoke_opts() {\n         let mut opts = TaskOpts::new();\n-        opts.name = Some(SendStrStatic(\"test\"));\n+        opts.name = Some(\"test\".into_maybe_owned());\n         opts.stack_size = Some(20 * 4096);\n         let (p, c) = Chan::new();\n         opts.notify_chan = Some(c);"}, {"sha": "606cb445262e9997cb602d1a63270af185d094f3", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5acc998ed9b76d9c00849e007101f9c33b17c6c4/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5acc998ed9b76d9c00849e007101f9c33b17c6c4/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=5acc998ed9b76d9c00849e007101f9c33b17c6c4", "patch": "@@ -436,7 +436,7 @@ impl<'a> SourceCollector<'a> {\n         cur.push(p.filename().expect(\"source has no filename\") + bytes!(\".html\"));\n         let mut w = BufferedWriter::new(if_ok!(File::create(&cur)));\n \n-        let title = cur.filename_display().with_str(|s| format!(\"{} -- source\", s));\n+        let title = format!(\"{} -- source\", cur.filename_display());\n         let page = layout::Page {\n             title: title,\n             ty: \"source\","}, {"sha": "7b574d68e78004cc0fb9bd94272ccbd9d3d94bad", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5acc998ed9b76d9c00849e007101f9c33b17c6c4/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5acc998ed9b76d9c00849e007101f9c33b17c6c4/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=5acc998ed9b76d9c00849e007101f9c33b17c6c4", "patch": "@@ -117,7 +117,6 @@ pub mod vec_ng;\n pub mod str;\n \n pub mod ascii;\n-pub mod send_str;\n \n pub mod ptr;\n pub mod owned;"}, {"sha": "ed0ce20175086028e921520fc944b5b47ae0208e", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 29, "deletions": 20, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/5acc998ed9b76d9c00849e007101f9c33b17c6c4/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5acc998ed9b76d9c00849e007101f9c33b17c6c4/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=5acc998ed9b76d9c00849e007101f9c33b17c6c4", "patch": "@@ -70,7 +70,7 @@ use fmt;\n use iter::Iterator;\n use option::{Option, None, Some};\n use str;\n-use str::{OwnedStr, Str, StrSlice};\n+use str::{MaybeOwned, OwnedStr, Str, StrSlice, from_utf8_lossy};\n use to_str::ToStr;\n use vec;\n use vec::{CloneableVector, OwnedCloneableVector, OwnedVector, Vector};\n@@ -495,7 +495,7 @@ pub struct Display<'a, P> {\n \n impl<'a, P: GenericPath> fmt::Show for Display<'a, P> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.with_str(|s| f.pad(s))\n+        self.as_maybe_owned().as_slice().fmt(f)\n     }\n }\n \n@@ -505,33 +505,25 @@ impl<'a, P: GenericPath> ToStr for Display<'a, P> {\n     /// If the path is not UTF-8, invalid sequences with be replaced with the\n     /// unicode replacement char. This involves allocation.\n     fn to_str(&self) -> ~str {\n-        if self.filename {\n-            match self.path.filename() {\n-                None => ~\"\",\n-                Some(v) => str::from_utf8_lossy(v)\n-            }\n-        } else {\n-            str::from_utf8_lossy(self.path.as_vec())\n-        }\n+        self.as_maybe_owned().into_owned()\n     }\n }\n \n impl<'a, P: GenericPath> Display<'a, P> {\n-    /// Provides the path as a string to a closure\n+    /// Returns the path as a possibly-owned string.\n     ///\n     /// If the path is not UTF-8, invalid sequences will be replaced with the\n     /// unicode replacement char. This involves allocation.\n     #[inline]\n-    pub fn with_str<T>(&self, f: |&str| -> T) -> T {\n-        let opt = if self.filename { self.path.filename_str() }\n-                  else { self.path.as_str() };\n-        match opt {\n-            Some(s) => f(s),\n-            None => {\n-                let s = self.to_str();\n-                f(s.as_slice())\n+    pub fn as_maybe_owned(&self) -> MaybeOwned<'a> {\n+        from_utf8_lossy(if self.filename {\n+            match self.path.filename() {\n+                None => &[],\n+                Some(v) => v\n             }\n-        }\n+        } else {\n+            self.path.as_vec()\n+        })\n     }\n }\n \n@@ -591,6 +583,23 @@ impl BytesContainer for CString {\n     }\n }\n \n+impl<'a> BytesContainer for str::MaybeOwned<'a> {\n+    #[inline]\n+    fn container_as_bytes<'b>(&'b self) -> &'b [u8] {\n+        self.as_slice().as_bytes()\n+    }\n+    #[inline]\n+    fn container_into_owned_bytes(self) -> ~[u8] {\n+        self.into_owned().into_bytes()\n+    }\n+    #[inline]\n+    fn container_as_str<'b>(&'b self) -> Option<&'b str> {\n+        Some(self.as_slice())\n+    }\n+    #[inline]\n+    fn is_str(_: Option<str::MaybeOwned>) -> bool { true }\n+}\n+\n #[inline(always)]\n fn contains_nul(v: &[u8]) -> bool {\n     v.iter().any(|&x| x == 0)"}, {"sha": "f8e9d0ae344047304060d44552ce82066f41b7fc", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5acc998ed9b76d9c00849e007101f9c33b17c6c4/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5acc998ed9b76d9c00849e007101f9c33b17c6c4/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=5acc998ed9b76d9c00849e007101f9c33b17c6c4", "patch": "@@ -564,24 +564,16 @@ mod tests {\n         macro_rules! t(\n             ($path:expr, $exp:expr) => (\n                 {\n-                    let mut called = false;\n                     let path = Path::new($path);\n-                    path.display().with_str(|s| {\n-                        assert_eq!(s, $exp);\n-                        called = true;\n-                    });\n-                    assert!(called);\n+                    let mo = path.display().as_maybe_owned();\n+                    assert_eq!(mo.as_slice(), $exp);\n                 }\n             );\n             ($path:expr, $exp:expr, filename) => (\n                 {\n-                    let mut called = false;\n                     let path = Path::new($path);\n-                    path.filename_display().with_str(|s| {\n-                        assert_eq!(s, $exp);\n-                        called = true;\n-                    });\n-                    assert!(called);\n+                    let mo = path.filename_display().as_maybe_owned();\n+                    assert_eq!(mo.as_slice(), $exp);\n                 }\n             )\n         )"}, {"sha": "972b7d178a111f5a83be46559a6206ba75376eac", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5acc998ed9b76d9c00849e007101f9c33b17c6c4/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5acc998ed9b76d9c00849e007101f9c33b17c6c4/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=5acc998ed9b76d9c00849e007101f9c33b17c6c4", "patch": "@@ -1278,20 +1278,12 @@ mod tests {\n         let path = Path::new(b!(\"\\\\\"));\n         assert_eq!(path.filename_display().to_str(), ~\"\");\n \n-        let mut called = false;\n         let path = Path::new(\"foo\");\n-        path.display().with_str(|s| {\n-            assert_eq!(s, \"foo\");\n-            called = true;\n-        });\n-        assert!(called);\n-        called = false;\n+        let mo = path.display().as_maybe_owned();\n+        assert_eq!(mo.as_slice(), \"foo\");\n         let path = Path::new(b!(\"\\\\\"));\n-        path.filename_display().with_str(|s| {\n-            assert_eq!(s, \"\");\n-            called = true;\n-        });\n-        assert!(called);\n+        let mo = path.filename_display().as_maybe_owned();\n+        assert_eq!(mo.as_slice(), \"\");\n     }\n \n     #[test]"}, {"sha": "f113b2f17ebe6a74c2f70d412220ce2376e206bf", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5acc998ed9b76d9c00849e007101f9c33b17c6c4/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5acc998ed9b76d9c00849e007101f9c33b17c6c4/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=5acc998ed9b76d9c00849e007101f9c33b17c6c4", "patch": "@@ -63,8 +63,7 @@ pub use num::{Primitive, Int, Float, ToStrRadix, ToPrimitive, FromPrimitive};\n pub use path::{GenericPath, Path, PosixPath, WindowsPath};\n pub use ptr::RawPtr;\n pub use io::{Buffer, Writer, Reader, Seek};\n-pub use send_str::{SendStr, SendStrOwned, SendStrStatic, IntoSendStr};\n-pub use str::{Str, StrVector, StrSlice, OwnedStr};\n+pub use str::{Str, StrVector, StrSlice, OwnedStr, IntoMaybeOwned};\n pub use to_bytes::IterBytes;\n pub use to_str::{ToStr, IntoStr};\n pub use tuple::{CloneableTuple, ImmutableTuple};"}, {"sha": "a7648dd2d19dffbc47da317da8d83fdeca3bd9d4", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5acc998ed9b76d9c00849e007101f9c33b17c6c4/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5acc998ed9b76d9c00849e007101f9c33b17c6c4/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=5acc998ed9b76d9c00849e007101f9c33b17c6c4", "patch": "@@ -30,7 +30,7 @@ use rt::local::Local;\n use rt::local_heap::LocalHeap;\n use rt::rtio::LocalIo;\n use rt::unwind::Unwinder;\n-use send_str::SendStr;\n+use str::SendStr;\n use sync::arc::UnsafeArc;\n use sync::atomics::{AtomicUint, SeqCst};\n use task::{TaskResult, TaskOpts};"}, {"sha": "b075b75b70acce849634e1f7895e2974a316ee55", "filename": "src/libstd/send_str.rs", "status": "removed", "additions": 0, "deletions": 246, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/548b8cec199c28c102fd98d6dd2833d3a171e7d0/src%2Flibstd%2Fsend_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/548b8cec199c28c102fd98d6dd2833d3a171e7d0/src%2Flibstd%2Fsend_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsend_str.rs?ref=548b8cec199c28c102fd98d6dd2833d3a171e7d0", "patch": "@@ -1,246 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! The `SendStr` trait for optionally static strings\n-\n-use clone::{Clone, DeepClone};\n-use cmp::{Eq, TotalEq, Ord, TotalOrd, Equiv};\n-use cmp::Ordering;\n-use container::Container;\n-use default::Default;\n-use str::{Str, StrSlice};\n-use to_str::ToStr;\n-use to_bytes::{IterBytes, Cb};\n-\n-/// A SendStr is a string that can hold either a ~str or a &'static str.\n-/// This can be useful as an optimization when an allocation is sometimes\n-/// needed but the common case is statically known.\n-#[allow(missing_doc)]\n-pub enum SendStr {\n-    SendStrOwned(~str),\n-    SendStrStatic(&'static str)\n-}\n-\n-impl SendStr {\n-    /// Returns `true` if this `SendStr` wraps an owned string\n-    #[inline]\n-    pub fn is_owned(&self) -> bool {\n-        match *self {\n-            SendStrOwned(_) => true,\n-            SendStrStatic(_) => false\n-        }\n-    }\n-\n-    /// Returns `true` if this `SendStr` wraps a static string\n-    #[inline]\n-    pub fn is_static(&self) -> bool {\n-        match *self {\n-            SendStrOwned(_) => false,\n-            SendStrStatic(_) => true\n-        }\n-    }\n-}\n-\n-/// Trait for moving into an `SendStr`\n-pub trait IntoSendStr {\n-    /// Moves self into an `SendStr`\n-    fn into_send_str(self) -> SendStr;\n-}\n-\n-impl IntoSendStr for ~str {\n-    #[inline]\n-    fn into_send_str(self) -> SendStr { SendStrOwned(self) }\n-}\n-\n-impl IntoSendStr for &'static str {\n-    #[inline]\n-    fn into_send_str(self) -> SendStr { SendStrStatic(self) }\n-}\n-\n-impl IntoSendStr for SendStr {\n-    #[inline]\n-    fn into_send_str(self) -> SendStr { self }\n-}\n-\n-/*\n-Section: String trait impls.\n-`SendStr` should behave like a normal string, so we don't derive.\n-*/\n-\n-impl ToStr for SendStr {\n-    #[inline]\n-    fn to_str(&self) -> ~str { self.as_slice().to_owned() }\n-}\n-\n-impl Eq for SendStr {\n-    #[inline]\n-    fn eq(&self, other: &SendStr) -> bool {\n-        self.as_slice().equals(&other.as_slice())\n-    }\n-}\n-\n-impl TotalEq for SendStr {\n-    #[inline]\n-    fn equals(&self, other: &SendStr) -> bool {\n-        self.as_slice().equals(&other.as_slice())\n-    }\n-}\n-\n-impl Ord for SendStr {\n-    #[inline]\n-    fn lt(&self, other: &SendStr) -> bool {\n-        self.as_slice().lt(&other.as_slice())\n-    }\n-}\n-\n-impl TotalOrd for SendStr {\n-    #[inline]\n-    fn cmp(&self, other: &SendStr) -> Ordering {\n-        self.as_slice().cmp(&other.as_slice())\n-    }\n-}\n-\n-impl<'a, S: Str> Equiv<S> for SendStr {\n-    #[inline]\n-    fn equiv(&self, other: &S) -> bool {\n-        self.as_slice().equals(&other.as_slice())\n-    }\n-}\n-\n-impl Str for SendStr {\n-    #[inline]\n-    fn as_slice<'r>(&'r self) -> &'r str {\n-        match *self {\n-            SendStrOwned(ref s) => s.as_slice(),\n-            // FIXME: Borrowchecker doesn't recognize lifetime as static unless prompted\n-            // SendStrStatic(s) => s.as_slice()\n-            SendStrStatic(s)    => {let tmp: &'static str = s; tmp}\n-        }\n-    }\n-\n-    #[inline]\n-    fn into_owned(self) -> ~str {\n-        match self {\n-            SendStrOwned(s)  => s,\n-            SendStrStatic(s) => s.to_owned()\n-        }\n-    }\n-}\n-\n-impl Container for SendStr {\n-    #[inline]\n-    fn len(&self) -> uint { self.as_slice().len() }\n-}\n-\n-impl Clone for SendStr {\n-    #[inline]\n-    fn clone(&self) -> SendStr {\n-        match *self {\n-            SendStrOwned(ref s) => SendStrOwned(s.to_owned()),\n-            SendStrStatic(s)    => SendStrStatic(s)\n-        }\n-    }\n-}\n-\n-impl DeepClone for SendStr {\n-    #[inline]\n-    fn deep_clone(&self) -> SendStr {\n-        match *self {\n-            SendStrOwned(ref s) => SendStrOwned(s.to_owned()),\n-            SendStrStatic(s)    => SendStrStatic(s)\n-        }\n-    }\n-}\n-\n-impl Default for SendStr {\n-    #[inline]\n-    fn default() -> SendStr { SendStrStatic(\"\") }\n-}\n-\n-impl IterBytes for SendStr {\n-    #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n-        match *self {\n-            SendStrOwned(ref s) => s.iter_bytes(lsb0, f),\n-            SendStrStatic(s)    => s.iter_bytes(lsb0, f)\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::*;\n-    use send_str::{SendStrOwned, SendStrStatic};\n-\n-    #[test]\n-    fn test_send_str_traits() {\n-        let s = SendStrStatic(\"abcde\");\n-        assert_eq!(s.len(), 5);\n-        assert_eq!(s.as_slice(), \"abcde\");\n-        assert_eq!(s.to_str(), ~\"abcde\");\n-        assert!(s.lt(&SendStrOwned(~\"bcdef\")));\n-        assert_eq!(SendStrStatic(\"\"), Default::default());\n-\n-        let o = SendStrOwned(~\"abcde\");\n-        assert_eq!(o.len(), 5);\n-        assert_eq!(o.as_slice(), \"abcde\");\n-        assert_eq!(o.to_str(), ~\"abcde\");\n-        assert!(o.lt(&SendStrStatic(\"bcdef\")));\n-        assert_eq!(SendStrOwned(~\"\"), Default::default());\n-\n-        assert_eq!(s.cmp(&o), Equal);\n-        assert!(s.equals(&o));\n-        assert!(s.equiv(&o));\n-\n-        assert_eq!(o.cmp(&s), Equal);\n-        assert!(o.equals(&s));\n-        assert!(o.equiv(&s));\n-    }\n-\n-    #[test]\n-    fn test_send_str_methods() {\n-        let s = SendStrStatic(\"abcde\");\n-        assert!(s.is_static());\n-        assert!(!s.is_owned());\n-\n-        let o = SendStrOwned(~\"abcde\");\n-        assert!(!o.is_static());\n-        assert!(o.is_owned());\n-    }\n-\n-    #[test]\n-    fn test_send_str_clone() {\n-        assert_eq!(SendStrOwned(~\"abcde\"), SendStrStatic(\"abcde\").clone());\n-        assert_eq!(SendStrOwned(~\"abcde\"), SendStrStatic(\"abcde\").deep_clone());\n-\n-        assert_eq!(SendStrOwned(~\"abcde\"), SendStrOwned(~\"abcde\").clone());\n-        assert_eq!(SendStrOwned(~\"abcde\"), SendStrOwned(~\"abcde\").deep_clone());\n-\n-        assert_eq!(SendStrStatic(\"abcde\"), SendStrStatic(\"abcde\").clone());\n-        assert_eq!(SendStrStatic(\"abcde\"), SendStrStatic(\"abcde\").deep_clone());\n-\n-        assert_eq!(SendStrStatic(\"abcde\"), SendStrOwned(~\"abcde\").clone());\n-        assert_eq!(SendStrStatic(\"abcde\"), SendStrOwned(~\"abcde\").deep_clone());\n-    }\n-\n-    #[test]\n-    fn test_send_str_into_owned() {\n-        assert_eq!(SendStrStatic(\"abcde\").into_owned(), ~\"abcde\");\n-        assert_eq!(SendStrOwned(~\"abcde\").into_owned(), ~\"abcde\");\n-    }\n-\n-    #[test]\n-    fn test_into_send_str() {\n-        assert_eq!(\"abcde\".into_send_str(), SendStrStatic(\"abcde\"));\n-        assert_eq!((~\"abcde\").into_send_str(), SendStrStatic(\"abcde\"));\n-        assert_eq!(\"abcde\".into_send_str(), SendStrOwned(~\"abcde\"));\n-        assert_eq!((~\"abcde\").into_send_str(), SendStrOwned(~\"abcde\"));\n-    }\n-}"}, {"sha": "3225bb3a6789c30f180627ea675c748ccadde76b", "filename": "src/libstd/str.rs", "status": "modified", "additions": 281, "deletions": 43, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/5acc998ed9b76d9c00849e007101f9c33b17c6c4/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5acc998ed9b76d9c00849e007101f9c33b17c6c4/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=5acc998ed9b76d9c00849e007101f9c33b17c6c4", "patch": "@@ -86,7 +86,9 @@ use cast::transmute;\n use char;\n use char::Char;\n use clone::{Clone, DeepClone};\n+use cmp::{Eq, TotalEq, Ord, TotalOrd, Equiv, Ordering};\n use container::{Container, Mutable};\n+use fmt;\n use iter::{Iterator, FromIterator, Extendable, range};\n use iter::{Filter, AdditiveIterator, Map};\n use iter::{Rev, DoubleEndedIterator, ExactSize};\n@@ -100,7 +102,7 @@ use from_str::FromStr;\n use vec;\n use vec::{OwnedVector, OwnedCloneableVector, ImmutableVector, MutableVector};\n use default::Default;\n-use send_str::{SendStr, SendStrOwned};\n+use to_bytes::{IterBytes, Cb};\n use unstable::raw::Repr;\n \n /*\n@@ -729,6 +731,11 @@ Section: Misc\n \n /// Determines if a vector of bytes contains valid UTF-8\n pub fn is_utf8(v: &[u8]) -> bool {\n+    first_non_utf8_index(v).is_none()\n+}\n+\n+#[inline(always)]\n+fn first_non_utf8_index(v: &[u8]) -> Option<uint> {\n     let mut i = 0u;\n     let total = v.len();\n     fn unsafe_get(xs: &[u8], i: uint) -> u8 {\n@@ -740,10 +747,10 @@ pub fn is_utf8(v: &[u8]) -> bool {\n             i += 1u;\n         } else {\n             let w = utf8_char_width(v_i);\n-            if w == 0u { return false; }\n+            if w == 0u { return Some(i); }\n \n             let nexti = i + w;\n-            if nexti > total { return false; }\n+            if nexti > total { return Some(i); }\n \n             // 2-byte encoding is for codepoints  \\u0080 to  \\u07ff\n             //        first  C2 80        last DF BF\n@@ -766,7 +773,7 @@ pub fn is_utf8(v: &[u8]) -> bool {\n             // UTF8-tail   = %x80-BF\n             match w {\n                 2 => if unsafe_get(v, i + 1) & 192u8 != TAG_CONT_U8 {\n-                    return false\n+                    return Some(i)\n                 },\n                 3 => match (v_i,\n                             unsafe_get(v, i + 1),\n@@ -775,7 +782,7 @@ pub fn is_utf8(v: &[u8]) -> bool {\n                     (0xE1 .. 0xEC, 0x80 .. 0xBF, TAG_CONT_U8) => (),\n                     (0xED        , 0x80 .. 0x9F, TAG_CONT_U8) => (),\n                     (0xEE .. 0xEF, 0x80 .. 0xBF, TAG_CONT_U8) => (),\n-                    _ => return false,\n+                    _ => return Some(i),\n                 },\n                 _ => match (v_i,\n                             unsafe_get(v, i + 1),\n@@ -784,14 +791,14 @@ pub fn is_utf8(v: &[u8]) -> bool {\n                     (0xF0        , 0x90 .. 0xBF, TAG_CONT_U8, TAG_CONT_U8) => (),\n                     (0xF1 .. 0xF3, 0x80 .. 0xBF, TAG_CONT_U8, TAG_CONT_U8) => (),\n                     (0xF4        , 0x80 .. 0x8F, TAG_CONT_U8, TAG_CONT_U8) => (),\n-                    _ => return false,\n+                    _ => return Some(i)\n                 },\n             }\n \n             i = nexti;\n         }\n     }\n-    true\n+    None\n }\n \n /// Determines if a vector of `u16` contains valid UTF-16\n@@ -918,12 +925,16 @@ static TAG_CONT_U8: u8 = 128u8;\n /// ```rust\n /// let input = bytes!(\"Hello \", 0xF0, 0x90, 0x80, \"World\");\n /// let output = std::str::from_utf8_lossy(input);\n-/// assert_eq!(output, ~\"Hello \\uFFFDWorld\");\n+/// assert_eq!(output.as_slice(), \"Hello \\uFFFDWorld\");\n /// ```\n-pub fn from_utf8_lossy(v: &[u8]) -> ~str {\n+pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> MaybeOwned<'a> {\n+    let firstbad = match first_non_utf8_index(v) {\n+        None => return Slice(unsafe { cast::transmute(v) }),\n+        Some(i) => i\n+    };\n+\n     static REPLACEMENT: &'static [u8] = bytes!(0xEF, 0xBF, 0xBD); // U+FFFD in UTF-8\n-    let mut i = 0u;\n-    let mut lastgood = 0u;\n+    let mut i = firstbad;\n     let total = v.len();\n     fn unsafe_get(xs: &[u8], i: uint) -> u8 {\n         unsafe { *xs.unsafe_ref(i) }\n@@ -937,23 +948,32 @@ pub fn from_utf8_lossy(v: &[u8]) -> ~str {\n     }\n     let mut res = with_capacity(total);\n \n+    if i > 0 {\n+        unsafe { raw::push_bytes(&mut res, v.slice_to(i)) };\n+    }\n+\n+    // subseqidx is the index of the first byte of the subsequence we're looking at.\n+    // It's used to copy a bunch of contiguous good codepoints at once instead of copying\n+    // them one by one.\n+    let mut subseqidx = firstbad;\n+\n     while i < total {\n         let i_ = i;\n         let byte = unsafe_get(v, i);\n         i += 1;\n \n-        macro_rules! error(() => {\n+        macro_rules! error(() => ({\n             unsafe {\n-                if lastgood != i_ {\n-                    raw::push_bytes(&mut res, v.slice(lastgood, i_));\n+                if subseqidx != i_ {\n+                    raw::push_bytes(&mut res, v.slice(subseqidx, i_));\n                 }\n-                lastgood = i;\n+                subseqidx = i;\n                 raw::push_bytes(&mut res, REPLACEMENT);\n             }\n-        })\n+        }))\n \n         if byte < 128u8 {\n-            // lastgood handles this\n+            // subseqidx handles this\n         } else {\n             let w = utf8_char_width(byte);\n \n@@ -1012,8 +1032,176 @@ pub fn from_utf8_lossy(v: &[u8]) -> ~str {\n             }\n         }\n     }\n-    unsafe { raw::push_bytes(&mut res, v.slice(lastgood, total)) };\n-    res\n+    if subseqidx < total {\n+        unsafe { raw::push_bytes(&mut res, v.slice(subseqidx, total)) };\n+    }\n+    Owned(res)\n+}\n+\n+/*\n+Section: MaybeOwned\n+*/\n+\n+/// A MaybeOwned is a string that can hold either a ~str or a &str.\n+/// This can be useful as an optimization when an allocation is sometimes\n+/// needed but not always.\n+pub enum MaybeOwned<'a> {\n+    /// A borrowed string\n+    Slice(&'a str),\n+    /// An owned string\n+    Owned(~str)\n+}\n+\n+/// SendStr is a specialization of `MaybeOwned` to be sendable\n+pub type SendStr = MaybeOwned<'static>;\n+\n+impl<'a> MaybeOwned<'a> {\n+    /// Returns `true` if this `MaybeOwned` wraps an owned string\n+    #[inline]\n+    pub fn is_owned(&self) -> bool {\n+        match *self {\n+            Slice(_) => false,\n+            Owned(_) => true\n+        }\n+    }\n+\n+    /// Returns `true` if this `MaybeOwned` wraps a borrowed string\n+    #[inline]\n+    pub fn is_slice(&self) -> bool {\n+        match *self {\n+            Slice(_) => true,\n+            Owned(_) => false\n+        }\n+    }\n+}\n+\n+/// Trait for moving into a `MaybeOwned`\n+pub trait IntoMaybeOwned<'a> {\n+    /// Moves self into a `MaybeOwned`\n+    fn into_maybe_owned(self) -> MaybeOwned<'a>;\n+}\n+\n+impl<'a> IntoMaybeOwned<'a> for ~str {\n+    #[inline]\n+    fn into_maybe_owned(self) -> MaybeOwned<'a> { Owned(self) }\n+}\n+\n+impl<'a> IntoMaybeOwned<'a> for &'a str {\n+    #[inline]\n+    fn into_maybe_owned(self) -> MaybeOwned<'a> { Slice(self) }\n+}\n+\n+impl<'a> IntoMaybeOwned<'a> for MaybeOwned<'a> {\n+    #[inline]\n+    fn into_maybe_owned(self) -> MaybeOwned<'a> { self }\n+}\n+\n+impl<'a> ToStr for MaybeOwned<'a> {\n+    #[inline]\n+    fn to_str(&self) -> ~str { self.as_slice().to_owned() }\n+}\n+\n+impl<'a> Eq for MaybeOwned<'a> {\n+    #[inline]\n+    fn eq(&self, other: &MaybeOwned) -> bool {\n+        self.as_slice().equals(&other.as_slice())\n+    }\n+}\n+\n+impl<'a> TotalEq for MaybeOwned<'a> {\n+    #[inline]\n+    fn equals(&self, other: &MaybeOwned) -> bool {\n+        self.as_slice().equals(&other.as_slice())\n+    }\n+}\n+\n+impl<'a> Ord for MaybeOwned<'a> {\n+    #[inline]\n+    fn lt(&self, other: &MaybeOwned) -> bool {\n+        self.as_slice().lt(&other.as_slice())\n+    }\n+}\n+\n+impl<'a> TotalOrd for MaybeOwned<'a> {\n+    #[inline]\n+    fn cmp(&self, other: &MaybeOwned) -> Ordering {\n+        self.as_slice().cmp(&other.as_slice())\n+    }\n+}\n+\n+impl<'a, S: Str> Equiv<S> for MaybeOwned<'a> {\n+    #[inline]\n+    fn equiv(&self, other: &S) -> bool {\n+        self.as_slice().equals(&other.as_slice())\n+    }\n+}\n+\n+impl<'a> Str for MaybeOwned<'a> {\n+    #[inline]\n+    fn as_slice<'b>(&'b self) -> &'b str {\n+        match *self {\n+            Slice(s) => s,\n+            Owned(ref s) => s.as_slice()\n+        }\n+    }\n+\n+    #[inline]\n+    fn into_owned(self) -> ~str {\n+        match self {\n+            Slice(s) => s.to_owned(),\n+            Owned(s) => s\n+        }\n+    }\n+}\n+\n+impl<'a> Container for MaybeOwned<'a> {\n+    #[inline]\n+    fn len(&self) -> uint { self.as_slice().len() }\n+}\n+\n+impl<'a> Clone for MaybeOwned<'a> {\n+    #[inline]\n+    fn clone(&self) -> MaybeOwned<'a> {\n+        match *self {\n+            Slice(s) => Slice(s),\n+            Owned(ref s) => Owned(s.to_owned())\n+        }\n+    }\n+}\n+\n+impl<'a> DeepClone for MaybeOwned<'a> {\n+    #[inline]\n+    fn deep_clone(&self) -> MaybeOwned<'a> {\n+        match *self {\n+            Slice(s) => Slice(s),\n+            Owned(ref s) => Owned(s.to_owned())\n+        }\n+    }\n+}\n+\n+impl<'a> Default for MaybeOwned<'a> {\n+    #[inline]\n+    fn default() -> MaybeOwned<'a> { Slice(\"\") }\n+}\n+\n+impl<'a> IterBytes for MaybeOwned<'a> {\n+    #[inline]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        match *self {\n+            Slice(s) => s.iter_bytes(lsb0, f),\n+            Owned(ref s) => s.iter_bytes(lsb0, f)\n+        }\n+    }\n+}\n+\n+impl<'a> fmt::Show for MaybeOwned<'a> {\n+    #[inline]\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            Slice(ref s) => s.fmt(f),\n+            Owned(ref s) => s.fmt(f)\n+        }\n+    }\n }\n \n /// Unsafe operations\n@@ -1770,9 +1958,6 @@ pub trait StrSlice<'a> {\n     /// Converts to a vector of `u16` encoded as UTF-16.\n     fn to_utf16(&self) -> ~[u16];\n \n-    /// Copy a slice into a new `SendStr`.\n-    fn to_send_str(&self) -> SendStr;\n-\n     /// Check that `index`-th byte lies at the start and/or end of a\n     /// UTF-8 code point sequence.\n     ///\n@@ -2297,11 +2482,6 @@ impl<'a> StrSlice<'a> for &'a str {\n         u\n     }\n \n-    #[inline]\n-    fn to_send_str(&self) -> SendStr {\n-        SendStrOwned(self.to_owned())\n-    }\n-\n     #[inline]\n     fn is_char_boundary(&self, index: uint) -> bool {\n         if index == self.len() { return true; }\n@@ -2741,7 +2921,6 @@ mod tests {\n     use prelude::*;\n     use ptr;\n     use str::*;\n-    use send_str::{SendStrOwned, SendStrStatic};\n \n     #[test]\n     fn test_eq() {\n@@ -3943,45 +4122,104 @@ mod tests {\n     #[test]\n     fn test_str_from_utf8_lossy() {\n         let xs = bytes!(\"hello\");\n-        assert_eq!(from_utf8_lossy(xs), ~\"hello\");\n+        assert_eq!(from_utf8_lossy(xs), Slice(\"hello\"));\n \n         let xs = bytes!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n-        assert_eq!(from_utf8_lossy(xs), ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n+        assert_eq!(from_utf8_lossy(xs), Slice(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n \n         let xs = bytes!(\"Hello\", 0xC2, \" There\", 0xFF, \" Goodbye\");\n-        assert_eq!(from_utf8_lossy(xs), ~\"Hello\\uFFFD There\\uFFFD Goodbye\");\n+        assert_eq!(from_utf8_lossy(xs), Owned(~\"Hello\\uFFFD There\\uFFFD Goodbye\"));\n \n         let xs = bytes!(\"Hello\", 0xC0, 0x80, \" There\", 0xE6, 0x83, \" Goodbye\");\n-        assert_eq!(from_utf8_lossy(xs), ~\"Hello\\uFFFD\\uFFFD There\\uFFFD Goodbye\");\n+        assert_eq!(from_utf8_lossy(xs), Owned(~\"Hello\\uFFFD\\uFFFD There\\uFFFD Goodbye\"));\n \n         let xs = bytes!(0xF5, \"foo\", 0xF5, 0x80, \"bar\");\n-        assert_eq!(from_utf8_lossy(xs), ~\"\\uFFFDfoo\\uFFFD\\uFFFDbar\");\n+        assert_eq!(from_utf8_lossy(xs), Owned(~\"\\uFFFDfoo\\uFFFD\\uFFFDbar\"));\n \n         let xs = bytes!(0xF1, \"foo\", 0xF1, 0x80, \"bar\", 0xF1, 0x80, 0x80, \"baz\");\n-        assert_eq!(from_utf8_lossy(xs), ~\"\\uFFFDfoo\\uFFFDbar\\uFFFDbaz\");\n+        assert_eq!(from_utf8_lossy(xs), Owned(~\"\\uFFFDfoo\\uFFFDbar\\uFFFDbaz\"));\n \n         let xs = bytes!(0xF4, \"foo\", 0xF4, 0x80, \"bar\", 0xF4, 0xBF, \"baz\");\n-        assert_eq!(from_utf8_lossy(xs), ~\"\\uFFFDfoo\\uFFFDbar\\uFFFD\\uFFFDbaz\");\n+        assert_eq!(from_utf8_lossy(xs), Owned(~\"\\uFFFDfoo\\uFFFDbar\\uFFFD\\uFFFDbaz\"));\n \n         let xs = bytes!(0xF0, 0x80, 0x80, 0x80, \"foo\", 0xF0, 0x90, 0x80, 0x80, \"bar\");\n-        assert_eq!(from_utf8_lossy(xs), ~\"\\uFFFD\\uFFFD\\uFFFD\\uFFFDfoo\\U00010000bar\");\n+        assert_eq!(from_utf8_lossy(xs), Owned(~\"\\uFFFD\\uFFFD\\uFFFD\\uFFFDfoo\\U00010000bar\"));\n \n         // surrogates\n         let xs = bytes!(0xED, 0xA0, 0x80, \"foo\", 0xED, 0xBF, 0xBF, \"bar\");\n-        assert_eq!(from_utf8_lossy(xs), ~\"\\uFFFD\\uFFFD\\uFFFDfoo\\uFFFD\\uFFFD\\uFFFDbar\");\n-    }\n-\n-    #[test]\n-    fn test_to_send_str() {\n-        assert_eq!(\"abcde\".to_send_str(), SendStrStatic(\"abcde\"));\n-        assert_eq!(\"abcde\".to_send_str(), SendStrOwned(~\"abcde\"));\n+        assert_eq!(from_utf8_lossy(xs), Owned(~\"\\uFFFD\\uFFFD\\uFFFDfoo\\uFFFD\\uFFFD\\uFFFDbar\"));\n     }\n \n     #[test]\n     fn test_from_str() {\n       let owned: Option<~str> = from_str(&\"string\");\n       assert_eq!(owned, Some(~\"string\"));\n     }\n+\n+    #[test]\n+    fn test_maybe_owned_traits() {\n+        let s = Slice(\"abcde\");\n+        assert_eq!(s.len(), 5);\n+        assert_eq!(s.as_slice(), \"abcde\");\n+        assert_eq!(s.to_str(), ~\"abcde\");\n+        assert!(s.lt(&Owned(~\"bcdef\")));\n+        assert_eq!(Slice(\"\"), Default::default());\n+\n+        let o = Owned(~\"abcde\");\n+        assert_eq!(o.len(), 5);\n+        assert_eq!(o.as_slice(), \"abcde\");\n+        assert_eq!(o.to_str(), ~\"abcde\");\n+        assert!(o.lt(&Slice(\"bcdef\")));\n+        assert_eq!(Owned(~\"\"), Default::default());\n+\n+        assert_eq!(s.cmp(&o), Equal);\n+        assert!(s.equals(&o));\n+        assert!(s.equiv(&o));\n+\n+        assert_eq!(o.cmp(&s), Equal);\n+        assert!(o.equals(&s));\n+        assert!(o.equiv(&s));\n+    }\n+\n+    #[test]\n+    fn test_maybe_owned_methods() {\n+        let s = Slice(\"abcde\");\n+        assert!(s.is_slice());\n+        assert!(!s.is_owned());\n+\n+        let o = Owned(~\"abcde\");\n+        assert!(!o.is_slice());\n+        assert!(o.is_owned());\n+    }\n+\n+    #[test]\n+    fn test_maybe_owned_clone() {\n+        assert_eq!(Owned(~\"abcde\"), Slice(\"abcde\").clone());\n+        assert_eq!(Owned(~\"abcde\"), Slice(\"abcde\").deep_clone());\n+\n+        assert_eq!(Owned(~\"abcde\"), Owned(~\"abcde\").clone());\n+        assert_eq!(Owned(~\"abcde\"), Owned(~\"abcde\").deep_clone());\n+\n+        assert_eq!(Slice(\"abcde\"), Slice(\"abcde\").clone());\n+        assert_eq!(Slice(\"abcde\"), Slice(\"abcde\").deep_clone());\n+\n+        assert_eq!(Slice(\"abcde\"), Owned(~\"abcde\").clone());\n+        assert_eq!(Slice(\"abcde\"), Owned(~\"abcde\").deep_clone());\n+    }\n+\n+    #[test]\n+    fn test_maybe_owned_into_owned() {\n+        assert_eq!(Slice(\"abcde\").into_owned(), ~\"abcde\");\n+        assert_eq!(Owned(~\"abcde\").into_owned(), ~\"abcde\");\n+    }\n+\n+    #[test]\n+    fn test_into_maybe_owned() {\n+        assert_eq!(\"abcde\".into_maybe_owned(), Slice(\"abcde\"));\n+        assert_eq!((~\"abcde\").into_maybe_owned(), Slice(\"abcde\"));\n+        assert_eq!(\"abcde\".into_maybe_owned(), Owned(~\"abcde\"));\n+        assert_eq!((~\"abcde\").into_maybe_owned(), Owned(~\"abcde\"));\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "921d0feaa8b195e65bf58dffd95f2f18b9b1e2af", "filename": "src/libstd/task.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5acc998ed9b76d9c00849e007101f9c33b17c6c4/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5acc998ed9b76d9c00849e007101f9c33b17c6c4/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=5acc998ed9b76d9c00849e007101f9c33b17c6c4", "patch": "@@ -62,8 +62,7 @@ use option::{None, Some, Option};\n use result::{Result, Ok, Err};\n use rt::local::Local;\n use rt::task::Task;\n-use send_str::{SendStr, IntoSendStr};\n-use str::Str;\n+use str::{Str, SendStr, IntoMaybeOwned};\n \n #[cfg(test)] use any::{AnyOwnExt, AnyRefExt};\n #[cfg(test)] use comm::SharedChan;\n@@ -190,8 +189,8 @@ impl TaskBuilder {\n \n     /// Name the task-to-be. Currently the name is used for identification\n     /// only in failure messages.\n-    pub fn name<S: IntoSendStr>(&mut self, name: S) {\n-        self.opts.name = Some(name.into_send_str());\n+    pub fn name<S: IntoMaybeOwned<'static>>(&mut self, name: S) {\n+        self.opts.name = Some(name.into_maybe_owned());\n     }\n \n     /**\n@@ -396,7 +395,7 @@ fn test_static_named_task() {\n #[test]\n fn test_send_named_task() {\n     let mut t = task();\n-    t.name(\"ada lovelace\".into_send_str());\n+    t.name(\"ada lovelace\".into_maybe_owned());\n     t.spawn(proc() {\n         with_task_name(|name| {\n             assert!(name.unwrap() == \"ada lovelace\");"}, {"sha": "93574f4d858506727526ac38ad7e5a9928c1dd91", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5acc998ed9b76d9c00849e007101f9c33b17c6c4/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5acc998ed9b76d9c00849e007101f9c33b17c6c4/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=5acc998ed9b76d9c00849e007101f9c33b17c6c4", "patch": "@@ -4200,10 +4200,10 @@ impl Parser {\n                     let mut err = ~\"circular modules: \";\n                     let len = included_mod_stack.get().len();\n                     for p in included_mod_stack.get().slice(i, len).iter() {\n-                        p.display().with_str(|s| err.push_str(s));\n+                        err.push_str(p.display().as_maybe_owned().as_slice());\n                         err.push_str(\" -> \");\n                     }\n-                    path.display().with_str(|s| err.push_str(s));\n+                    err.push_str(path.display().as_maybe_owned().as_slice());\n                     self.span_fatal(id_sp, err);\n                 }\n                 None => ()"}, {"sha": "ea530fe9f69d2019af64317fcf052e3a8087e42d", "filename": "src/test/run-fail/fail-task-name-send-str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5acc998ed9b76d9c00849e007101f9c33b17c6c4/src%2Ftest%2Frun-fail%2Ffail-task-name-send-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5acc998ed9b76d9c00849e007101f9c33b17c6c4/src%2Ftest%2Frun-fail%2Ffail-task-name-send-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffail-task-name-send-str.rs?ref=5acc998ed9b76d9c00849e007101f9c33b17c6c4", "patch": "@@ -12,7 +12,7 @@\n \n fn main() {\n     let mut t = ::std::task::task();\n-    t.name(\"send name\".to_send_str());\n+    t.name(\"send name\".into_maybe_owned());\n     t.try(proc() {\n         fail!(\"test\");\n         3"}, {"sha": "8599f9d383605504f99d8a482b64823435662971", "filename": "src/test/run-pass/send_str_hashmap.rs", "status": "modified", "additions": 31, "deletions": 32, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/5acc998ed9b76d9c00849e007101f9c33b17c6c4/src%2Ftest%2Frun-pass%2Fsend_str_hashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5acc998ed9b76d9c00849e007101f9c33b17c6c4/src%2Ftest%2Frun-pass%2Fsend_str_hashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend_str_hashmap.rs?ref=5acc998ed9b76d9c00849e007101f9c33b17c6c4", "patch": "@@ -13,45 +13,44 @@ use std::cmp::{TotalEq, Ord, TotalOrd, Equiv};\n use std::cmp::Equal;\n use std::container::{Container, Map, MutableMap};\n use std::default::Default;\n-use std::send_str::{SendStr, SendStrOwned, SendStrStatic};\n-use std::str::Str;\n+use std::str::{Str, SendStr, Owned, Slice};\n use std::to_str::ToStr;\n use std::hashmap::HashMap;\n use std::option::Some;\n \n pub fn main() {\n     let mut map: HashMap<SendStr, uint> = HashMap::new();\n-    assert!(map.insert(SendStrStatic(\"foo\"), 42));\n-    assert!(!map.insert(SendStrOwned(~\"foo\"), 42));\n-    assert!(!map.insert(SendStrStatic(\"foo\"), 42));\n-    assert!(!map.insert(SendStrOwned(~\"foo\"), 42));\n+    assert!(map.insert(Slice(\"foo\"), 42));\n+    assert!(!map.insert(Owned(~\"foo\"), 42));\n+    assert!(!map.insert(Slice(\"foo\"), 42));\n+    assert!(!map.insert(Owned(~\"foo\"), 42));\n \n-    assert!(!map.insert(SendStrStatic(\"foo\"), 43));\n-    assert!(!map.insert(SendStrOwned(~\"foo\"), 44));\n-    assert!(!map.insert(SendStrStatic(\"foo\"), 45));\n-    assert!(!map.insert(SendStrOwned(~\"foo\"), 46));\n+    assert!(!map.insert(Slice(\"foo\"), 43));\n+    assert!(!map.insert(Owned(~\"foo\"), 44));\n+    assert!(!map.insert(Slice(\"foo\"), 45));\n+    assert!(!map.insert(Owned(~\"foo\"), 46));\n \n     let v = 46;\n \n-    assert_eq!(map.find(&SendStrOwned(~\"foo\")), Some(&v));\n-    assert_eq!(map.find(&SendStrStatic(\"foo\")), Some(&v));\n+    assert_eq!(map.find(&Owned(~\"foo\")), Some(&v));\n+    assert_eq!(map.find(&Slice(\"foo\")), Some(&v));\n \n     let (a, b, c, d) = (50, 51, 52, 53);\n \n-    assert!(map.insert(SendStrStatic(\"abc\"), a));\n-    assert!(map.insert(SendStrOwned(~\"bcd\"), b));\n-    assert!(map.insert(SendStrStatic(\"cde\"), c));\n-    assert!(map.insert(SendStrOwned(~\"def\"), d));\n+    assert!(map.insert(Slice(\"abc\"), a));\n+    assert!(map.insert(Owned(~\"bcd\"), b));\n+    assert!(map.insert(Slice(\"cde\"), c));\n+    assert!(map.insert(Owned(~\"def\"), d));\n \n-    assert!(!map.insert(SendStrStatic(\"abc\"), a));\n-    assert!(!map.insert(SendStrOwned(~\"bcd\"), b));\n-    assert!(!map.insert(SendStrStatic(\"cde\"), c));\n-    assert!(!map.insert(SendStrOwned(~\"def\"), d));\n+    assert!(!map.insert(Slice(\"abc\"), a));\n+    assert!(!map.insert(Owned(~\"bcd\"), b));\n+    assert!(!map.insert(Slice(\"cde\"), c));\n+    assert!(!map.insert(Owned(~\"def\"), d));\n \n-    assert!(!map.insert(SendStrOwned(~\"abc\"), a));\n-    assert!(!map.insert(SendStrStatic(\"bcd\"), b));\n-    assert!(!map.insert(SendStrOwned(~\"cde\"), c));\n-    assert!(!map.insert(SendStrStatic(\"def\"), d));\n+    assert!(!map.insert(Owned(~\"abc\"), a));\n+    assert!(!map.insert(Slice(\"bcd\"), b));\n+    assert!(!map.insert(Owned(~\"cde\"), c));\n+    assert!(!map.insert(Slice(\"def\"), d));\n \n     assert_eq!(map.find_equiv(&(\"abc\")), Some(&a));\n     assert_eq!(map.find_equiv(&(\"bcd\")), Some(&b));\n@@ -63,13 +62,13 @@ pub fn main() {\n     assert_eq!(map.find_equiv(&(~\"cde\")), Some(&c));\n     assert_eq!(map.find_equiv(&(~\"def\")), Some(&d));\n \n-    assert_eq!(map.find_equiv(&SendStrStatic(\"abc\")), Some(&a));\n-    assert_eq!(map.find_equiv(&SendStrStatic(\"bcd\")), Some(&b));\n-    assert_eq!(map.find_equiv(&SendStrStatic(\"cde\")), Some(&c));\n-    assert_eq!(map.find_equiv(&SendStrStatic(\"def\")), Some(&d));\n+    assert_eq!(map.find_equiv(&Slice(\"abc\")), Some(&a));\n+    assert_eq!(map.find_equiv(&Slice(\"bcd\")), Some(&b));\n+    assert_eq!(map.find_equiv(&Slice(\"cde\")), Some(&c));\n+    assert_eq!(map.find_equiv(&Slice(\"def\")), Some(&d));\n \n-    assert_eq!(map.find_equiv(&SendStrOwned(~\"abc\")), Some(&a));\n-    assert_eq!(map.find_equiv(&SendStrOwned(~\"bcd\")), Some(&b));\n-    assert_eq!(map.find_equiv(&SendStrOwned(~\"cde\")), Some(&c));\n-    assert_eq!(map.find_equiv(&SendStrOwned(~\"def\")), Some(&d));\n+    assert_eq!(map.find_equiv(&Owned(~\"abc\")), Some(&a));\n+    assert_eq!(map.find_equiv(&Owned(~\"bcd\")), Some(&b));\n+    assert_eq!(map.find_equiv(&Owned(~\"cde\")), Some(&c));\n+    assert_eq!(map.find_equiv(&Owned(~\"def\")), Some(&d));\n }"}, {"sha": "1b7d7bf0b4b570d51f81e9b0973eab844545f4c6", "filename": "src/test/run-pass/send_str_treemap.rs", "status": "modified", "additions": 32, "deletions": 33, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/5acc998ed9b76d9c00849e007101f9c33b17c6c4/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5acc998ed9b76d9c00849e007101f9c33b17c6c4/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs?ref=5acc998ed9b76d9c00849e007101f9c33b17c6c4", "patch": "@@ -15,57 +15,56 @@ use std::cmp::{TotalEq, Ord, TotalOrd, Equiv};\n use std::cmp::Equal;\n use std::container::{Container, Map, MutableMap};\n use std::default::Default;\n-use std::send_str::{SendStr, SendStrOwned, SendStrStatic};\n-use std::str::Str;\n+use std::str::{Str, SendStr, Owned, Slice};\n use std::to_str::ToStr;\n use self::collections::TreeMap;\n use std::option::Some;\n \n pub fn main() {\n     let mut map: TreeMap<SendStr, uint> = TreeMap::new();\n-    assert!(map.insert(SendStrStatic(\"foo\"), 42));\n-    assert!(!map.insert(SendStrOwned(~\"foo\"), 42));\n-    assert!(!map.insert(SendStrStatic(\"foo\"), 42));\n-    assert!(!map.insert(SendStrOwned(~\"foo\"), 42));\n+    assert!(map.insert(Slice(\"foo\"), 42));\n+    assert!(!map.insert(Owned(~\"foo\"), 42));\n+    assert!(!map.insert(Slice(\"foo\"), 42));\n+    assert!(!map.insert(Owned(~\"foo\"), 42));\n \n-    assert!(!map.insert(SendStrStatic(\"foo\"), 43));\n-    assert!(!map.insert(SendStrOwned(~\"foo\"), 44));\n-    assert!(!map.insert(SendStrStatic(\"foo\"), 45));\n-    assert!(!map.insert(SendStrOwned(~\"foo\"), 46));\n+    assert!(!map.insert(Slice(\"foo\"), 43));\n+    assert!(!map.insert(Owned(~\"foo\"), 44));\n+    assert!(!map.insert(Slice(\"foo\"), 45));\n+    assert!(!map.insert(Owned(~\"foo\"), 46));\n \n     let v = 46;\n \n-    assert_eq!(map.find(&SendStrOwned(~\"foo\")), Some(&v));\n-    assert_eq!(map.find(&SendStrStatic(\"foo\")), Some(&v));\n+    assert_eq!(map.find(&Owned(~\"foo\")), Some(&v));\n+    assert_eq!(map.find(&Slice(\"foo\")), Some(&v));\n \n     let (a, b, c, d) = (50, 51, 52, 53);\n \n-    assert!(map.insert(SendStrStatic(\"abc\"), a));\n-    assert!(map.insert(SendStrOwned(~\"bcd\"), b));\n-    assert!(map.insert(SendStrStatic(\"cde\"), c));\n-    assert!(map.insert(SendStrOwned(~\"def\"), d));\n+    assert!(map.insert(Slice(\"abc\"), a));\n+    assert!(map.insert(Owned(~\"bcd\"), b));\n+    assert!(map.insert(Slice(\"cde\"), c));\n+    assert!(map.insert(Owned(~\"def\"), d));\n \n-    assert!(!map.insert(SendStrStatic(\"abc\"), a));\n-    assert!(!map.insert(SendStrOwned(~\"bcd\"), b));\n-    assert!(!map.insert(SendStrStatic(\"cde\"), c));\n-    assert!(!map.insert(SendStrOwned(~\"def\"), d));\n+    assert!(!map.insert(Slice(\"abc\"), a));\n+    assert!(!map.insert(Owned(~\"bcd\"), b));\n+    assert!(!map.insert(Slice(\"cde\"), c));\n+    assert!(!map.insert(Owned(~\"def\"), d));\n \n-    assert!(!map.insert(SendStrOwned(~\"abc\"), a));\n-    assert!(!map.insert(SendStrStatic(\"bcd\"), b));\n-    assert!(!map.insert(SendStrOwned(~\"cde\"), c));\n-    assert!(!map.insert(SendStrStatic(\"def\"), d));\n+    assert!(!map.insert(Owned(~\"abc\"), a));\n+    assert!(!map.insert(Slice(\"bcd\"), b));\n+    assert!(!map.insert(Owned(~\"cde\"), c));\n+    assert!(!map.insert(Slice(\"def\"), d));\n \n-    assert_eq!(map.find(&SendStrStatic(\"abc\")), Some(&a));\n-    assert_eq!(map.find(&SendStrStatic(\"bcd\")), Some(&b));\n-    assert_eq!(map.find(&SendStrStatic(\"cde\")), Some(&c));\n-    assert_eq!(map.find(&SendStrStatic(\"def\")), Some(&d));\n+    assert_eq!(map.find(&Slice(\"abc\")), Some(&a));\n+    assert_eq!(map.find(&Slice(\"bcd\")), Some(&b));\n+    assert_eq!(map.find(&Slice(\"cde\")), Some(&c));\n+    assert_eq!(map.find(&Slice(\"def\")), Some(&d));\n \n-    assert_eq!(map.find(&SendStrOwned(~\"abc\")), Some(&a));\n-    assert_eq!(map.find(&SendStrOwned(~\"bcd\")), Some(&b));\n-    assert_eq!(map.find(&SendStrOwned(~\"cde\")), Some(&c));\n-    assert_eq!(map.find(&SendStrOwned(~\"def\")), Some(&d));\n+    assert_eq!(map.find(&Owned(~\"abc\")), Some(&a));\n+    assert_eq!(map.find(&Owned(~\"bcd\")), Some(&b));\n+    assert_eq!(map.find(&Owned(~\"cde\")), Some(&c));\n+    assert_eq!(map.find(&Owned(~\"def\")), Some(&d));\n \n-    assert!(map.pop(&SendStrStatic(\"foo\")).is_some());\n+    assert!(map.pop(&Slice(\"foo\")).is_some());\n     assert_eq!(map.move_iter().map(|(k, v)| k.to_str() + v.to_str())\n                               .to_owned_vec()\n                               .concat(),"}]}