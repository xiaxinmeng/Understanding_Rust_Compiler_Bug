{"sha": "cc38176793e9e13bb7b70dde4b951d9371017662", "node_id": "C_kwDOAAsO6NoAKGNjMzgxNzY3OTNlOWUxM2JiN2I3MGRkZTRiOTUxZDkzNzEwMTc2NjI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-08T22:33:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-08T22:33:05Z"}, "message": "Auto merge of #93783 - oli-obk:lazy_tait_regression_fix, r=jackh726\n\nFix regression from lazy opaque types\n\nThe breakage was found in https://github.com/rust-lang/rust/pull/92007#issuecomment-1032203011 and has not hit nightly yet.", "tree": {"sha": "cdec181da68a6a6849e1b1e3edb98e6a24035143", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cdec181da68a6a6849e1b1e3edb98e6a24035143"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc38176793e9e13bb7b70dde4b951d9371017662", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc38176793e9e13bb7b70dde4b951d9371017662", "html_url": "https://github.com/rust-lang/rust/commit/cc38176793e9e13bb7b70dde4b951d9371017662", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc38176793e9e13bb7b70dde4b951d9371017662/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c292c9667f1b202a9150d58bdd2e89e3e803996", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c292c9667f1b202a9150d58bdd2e89e3e803996", "html_url": "https://github.com/rust-lang/rust/commit/0c292c9667f1b202a9150d58bdd2e89e3e803996"}, {"sha": "239f1e716dcb1e145b5df5f9439524c817d123b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/239f1e716dcb1e145b5df5f9439524c817d123b2", "html_url": "https://github.com/rust-lang/rust/commit/239f1e716dcb1e145b5df5f9439524c817d123b2"}], "stats": {"total": 136, "additions": 126, "deletions": 10}, "files": [{"sha": "c3deab0938d3b5beabd9851d2bb851f8fc7bb490", "filename": "compiler/rustc_typeck/src/check/closure.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cc38176793e9e13bb7b70dde4b951d9371017662/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc38176793e9e13bb7b70dde4b951d9371017662/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs?ref=cc38176793e9e13bb7b70dde4b951d9371017662", "patch": "@@ -259,22 +259,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// The `cause_span` should be the span that caused us to\n     /// have this expected signature, or `None` if we can't readily\n     /// know that.\n+    #[instrument(level = \"debug\", skip(self, cause_span))]\n     fn deduce_sig_from_projection(\n         &self,\n         cause_span: Option<Span>,\n         projection: ty::PolyProjectionPredicate<'tcx>,\n     ) -> Option<ExpectedSig<'tcx>> {\n         let tcx = self.tcx;\n \n-        debug!(\"deduce_sig_from_projection({:?})\", projection);\n-\n         let trait_def_id = projection.trait_def_id(tcx);\n \n         let is_fn = tcx.fn_trait_kind_from_lang_item(trait_def_id).is_some();\n         let gen_trait = tcx.require_lang_item(LangItem::Generator, cause_span);\n         let is_gen = gen_trait == trait_def_id;\n         if !is_fn && !is_gen {\n-            debug!(\"deduce_sig_from_projection: not fn or generator\");\n+            debug!(\"not fn or generator\");\n             return None;\n         }\n \n@@ -283,15 +282,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // associated item and not yield.\n             let return_assoc_item = self.tcx.associated_item_def_ids(gen_trait)[1];\n             if return_assoc_item != projection.projection_def_id() {\n-                debug!(\"deduce_sig_from_projection: not return assoc item of generator\");\n+                debug!(\"not return assoc item of generator\");\n                 return None;\n             }\n         }\n \n         let input_tys = if is_fn {\n             let arg_param_ty = projection.skip_binder().projection_ty.substs.type_at(1);\n             let arg_param_ty = self.resolve_vars_if_possible(arg_param_ty);\n-            debug!(\"deduce_sig_from_projection: arg_param_ty={:?}\", arg_param_ty);\n+            debug!(?arg_param_ty);\n \n             match arg_param_ty.kind() {\n                 ty::Tuple(tys) => tys.into_iter().map(|k| k.expect_ty()).collect::<Vec<_>>(),\n@@ -306,7 +305,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Since this is a return parameter type it is safe to unwrap.\n         let ret_param_ty = projection.skip_binder().term.ty().unwrap();\n         let ret_param_ty = self.resolve_vars_if_possible(ret_param_ty);\n-        debug!(\"deduce_sig_from_projection: ret_param_ty={:?}\", ret_param_ty);\n+        debug!(?ret_param_ty);\n \n         let sig = projection.rebind(self.tcx.mk_fn_sig(\n             input_tys.iter(),\n@@ -315,7 +314,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             hir::Unsafety::Normal,\n             Abi::Rust,\n         ));\n-        debug!(\"deduce_sig_from_projection: sig={:?}\", sig);\n+        debug!(?sig);\n \n         Some(ExpectedSig { cause_span, sig })\n     }"}, {"sha": "52db15b69a37572915cdbfc8049197eb8e69de6c", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cc38176793e9e13bb7b70dde4b951d9371017662/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc38176793e9e13bb7b70dde4b951d9371017662/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=cc38176793e9e13bb7b70dde4b951d9371017662", "patch": "@@ -730,7 +730,32 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> Vec<Ty<'tcx>> {\n         let formal_ret = self.resolve_vars_with_obligations(formal_ret);\n         let ret_ty = match expected_ret.only_has_type(self) {\n-            Some(ret) => ret,\n+            Some(ret) => {\n+                // HACK(oli-obk): This is a backwards compatibility hack. Without it, the inference\n+                // variable will get instantiated with the opaque type. The inference variable often\n+                // has various helpful obligations registered for it that help closures figure out their\n+                // signature. If we infer the inference var to the opaque type, the closure won't be able\n+                // to find those obligations anymore, and it can't necessarily find them from the opaque\n+                // type itself. We could be more powerful with inference if we *combined* the obligations\n+                // so that we got both the obligations from the opaque type and the ones from the inference\n+                // variable. That will accept more code than we do right now, so we need to carefully consider\n+                // the implications.\n+                // Note: this check is pessimistic, as the inference type could be matched with something other\n+                // than the opaque type, but then we need a new `TypeRelation` just for this specific case and\n+                // can't re-use `sup` below.\n+                if formal_ret.has_infer_types() {\n+                    for ty in ret.walk() {\n+                        if let ty::subst::GenericArgKind::Type(ty) = ty.unpack() {\n+                            if let ty::Opaque(def_id, _) = *ty.kind() {\n+                                if self.infcx.opaque_type_origin(def_id, DUMMY_SP).is_some() {\n+                                    return Vec::new();\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                ret\n+            }\n             None => return Vec::new(),\n         };\n         let expect_args = self"}, {"sha": "1b65685a6c06f4af67d34568ccc56ce259f0ec29", "filename": "src/test/ui/impl-trait/hidden-type-is-opaque-2.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cc38176793e9e13bb7b70dde4b951d9371017662/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-type-is-opaque-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc38176793e9e13bb7b70dde4b951d9371017662/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-type-is-opaque-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-type-is-opaque-2.rs?ref=cc38176793e9e13bb7b70dde4b951d9371017662", "patch": "@@ -0,0 +1,34 @@\n+// This doesn't work, because we don't flow information from opaque types\n+// into function arguments via the function's generic parameters\n+// FIXME(oli-obk): make `expected_inputs_for_expected_output` support this\n+\n+fn reify_as() -> Thunk<impl FnOnce(Continuation) -> Continuation> {\n+    Thunk::new(|mut cont| { //~ ERROR type annotations needed\n+        cont.reify_as();\n+        cont\n+    })\n+}\n+\n+#[must_use]\n+struct Thunk<F>(F);\n+\n+impl<F> Thunk<F> {\n+    fn new(f: F) -> Self\n+    where\n+        F: ContFn,\n+    {\n+        Thunk(f)\n+    }\n+}\n+\n+trait ContFn {}\n+\n+impl<F: FnOnce(Continuation) -> Continuation> ContFn for F {}\n+\n+struct Continuation;\n+\n+impl Continuation {\n+    fn reify_as(&mut self) {}\n+}\n+\n+fn main() {}"}, {"sha": "e538aaeb4c5ed9bb485f5274eb8ccc7c7b4f1232", "filename": "src/test/ui/impl-trait/hidden-type-is-opaque-2.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cc38176793e9e13bb7b70dde4b951d9371017662/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-type-is-opaque-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cc38176793e9e13bb7b70dde4b951d9371017662/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-type-is-opaque-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-type-is-opaque-2.stderr?ref=cc38176793e9e13bb7b70dde4b951d9371017662", "patch": "@@ -0,0 +1,11 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/hidden-type-is-opaque-2.rs:6:17\n+   |\n+LL |     Thunk::new(|mut cont| {\n+   |                 ^^^^^^^^ consider giving this closure parameter a type\n+   |\n+   = note: type must be known at this point\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "b302ae36ef42cee38b1955875ed662432f9d4c35", "filename": "src/test/ui/impl-trait/hidden-type-is-opaque.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/cc38176793e9e13bb7b70dde4b951d9371017662/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-type-is-opaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc38176793e9e13bb7b70dde4b951d9371017662/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-type-is-opaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-type-is-opaque.rs?ref=cc38176793e9e13bb7b70dde4b951d9371017662", "patch": "@@ -0,0 +1,32 @@\n+// check-pass\n+\n+fn reify_as() -> Thunk<impl ContFn> {\n+    Thunk::new(|mut cont| {\n+        cont.reify_as();\n+        cont\n+    })\n+}\n+\n+#[must_use]\n+struct Thunk<F>(F);\n+\n+impl<F> Thunk<F> {\n+    fn new(f: F) -> Self\n+    where\n+        F: FnOnce(Continuation) -> Continuation,\n+    {\n+        Thunk(f)\n+    }\n+}\n+\n+trait ContFn {}\n+\n+impl<F: FnOnce(Continuation) -> Continuation> ContFn for F {}\n+\n+struct Continuation;\n+\n+impl Continuation {\n+    fn reify_as(&mut self) {}\n+}\n+\n+fn main() {}"}, {"sha": "1a86fa00ed1a0a3832e4d0e6f3f59eb7ffdc87d7", "filename": "src/test/ui/impl-trait/issues/issue-70877.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc38176793e9e13bb7b70dde4b951d9371017662/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-70877.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc38176793e9e13bb7b70dde4b951d9371017662/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-70877.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-70877.rs?ref=cc38176793e9e13bb7b70dde4b951d9371017662", "patch": "@@ -13,7 +13,7 @@ impl Iterator for Bar {\n     type Item = FooItem;\n \n     fn next(&mut self) -> Option<Self::Item> {\n-        Some(Box::new(quux))\n+        Some(Box::new(quux)) //~ ERROR mismatched types\n     }\n }\n "}, {"sha": "7cbd58bdabf2f7b9521cb5f6a85f4d6b8d1b8904", "filename": "src/test/ui/impl-trait/issues/issue-70877.stderr", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cc38176793e9e13bb7b70dde4b951d9371017662/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-70877.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cc38176793e9e13bb7b70dde4b951d9371017662/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-70877.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-70877.stderr?ref=cc38176793e9e13bb7b70dde4b951d9371017662", "patch": "@@ -1,3 +1,17 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-70877.rs:16:9\n+   |\n+LL | type FooRet = impl std::fmt::Debug;\n+   |               -------------------- the expected opaque type\n+...\n+LL |     fn next(&mut self) -> Option<Self::Item> {\n+   |                           ------------------ expected `Option<Box<(dyn for<'r> Fn(&'r (dyn ToString + 'r)) -> FooRet + 'static)>>` because of return type\n+LL |         Some(Box::new(quux))\n+   |         ^^^^^^^^^^^^^^^^^^^^ expected trait object `dyn Fn`, found fn item\n+   |\n+   = note: expected enum `Option<Box<(dyn for<'r> Fn(&'r (dyn ToString + 'r)) -> FooRet + 'static)>>`\n+              found enum `Option<Box<for<'r> fn(&'r (dyn ToString + 'r)) -> FooRet {quux}>>`\n+\n error: opaque type's hidden type cannot be another opaque type from the same scope\n   --> $DIR/issue-70877.rs:31:12\n    |\n@@ -15,5 +29,6 @@ note: opaque type being used as hidden type\n LL | type FooRet = impl std::fmt::Debug;\n    |               ^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0308`."}]}