{"sha": "800ba8f8e862d72707200f77a51981de62f38b3a", "node_id": "C_kwDOAAsO6NoAKDgwMGJhOGY4ZTg2MmQ3MjcwNzIwMGY3N2E1MTk4MWRlNjJmMzhiM2E", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-01-05T06:15:44Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-01-07T06:41:22Z"}, "message": "expand: Refactor `InvocationCollector` visitor for better code reuse", "tree": {"sha": "470cbcadfdfb2cd03e73bd04d2fa76fc7f3b56f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/470cbcadfdfb2cd03e73bd04d2fa76fc7f3b56f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/800ba8f8e862d72707200f77a51981de62f38b3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/800ba8f8e862d72707200f77a51981de62f38b3a", "html_url": "https://github.com/rust-lang/rust/commit/800ba8f8e862d72707200f77a51981de62f38b3a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/800ba8f8e862d72707200f77a51981de62f38b3a/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4fd23350cdd871196d2fd925e3f8d1e0df9f1c10", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fd23350cdd871196d2fd925e3f8d1e0df9f1c10", "html_url": "https://github.com/rust-lang/rust/commit/4fd23350cdd871196d2fd925e3f8d1e0df9f1c10"}], "stats": {"total": 1224, "additions": 724, "deletions": 500}, "files": [{"sha": "9a24158ba35d9e76a8c0e700cfb914737eb440eb", "filename": "compiler/rustc_ast/src/ast_like.rs", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/800ba8f8e862d72707200f77a51981de62f38b3a/compiler%2Frustc_ast%2Fsrc%2Fast_like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800ba8f8e862d72707200f77a51981de62f38b3a/compiler%2Frustc_ast%2Fsrc%2Fast_like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast_like.rs?ref=800ba8f8e862d72707200f77a51981de62f38b3a", "patch": "@@ -6,12 +6,13 @@ use super::{AssocItem, Expr, ForeignItem, Item, Local, MacCallStmt};\n use super::{AttrItem, AttrKind, Block, Pat, Path, Ty, Visibility};\n use super::{AttrVec, Attribute, Stmt, StmtKind};\n \n-use std::fmt::Debug;\n+use std::fmt;\n+use std::marker::PhantomData;\n \n /// An `AstLike` represents an AST node (or some wrapper around\n /// and AST node) which stores some combination of attributes\n /// and tokens.\n-pub trait AstLike: Sized + Debug {\n+pub trait AstLike: Sized + fmt::Debug {\n     /// This is `true` if this `AstLike` might support 'custom' (proc-macro) inner\n     /// attributes. Attributes like `#![cfg]` and `#![cfg_attr]` are not\n     /// considered 'custom' attributes\n@@ -285,3 +286,37 @@ derive_has_attrs_no_tokens! {\n derive_has_tokens_no_attrs! {\n     Ty, Block, AttrItem, Pat, Path, Visibility\n }\n+\n+/// A newtype around an `AstLike` node that implements `AstLike` itself.\n+pub struct AstLikeWrapper<Wrapped, Tag> {\n+    pub wrapped: Wrapped,\n+    pub tag: PhantomData<Tag>,\n+}\n+\n+impl<Wrapped, Tag> AstLikeWrapper<Wrapped, Tag> {\n+    pub fn new(wrapped: Wrapped, _tag: Tag) -> AstLikeWrapper<Wrapped, Tag> {\n+        AstLikeWrapper { wrapped, tag: Default::default() }\n+    }\n+}\n+\n+impl<Wrapped: fmt::Debug, Tag> fmt::Debug for AstLikeWrapper<Wrapped, Tag> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"AstLikeWrapper\")\n+            .field(\"wrapped\", &self.wrapped)\n+            .field(\"tag\", &self.tag)\n+            .finish()\n+    }\n+}\n+\n+impl<Wrapped: AstLike, Tag> AstLike for AstLikeWrapper<Wrapped, Tag> {\n+    const SUPPORTS_CUSTOM_INNER_ATTRS: bool = Wrapped::SUPPORTS_CUSTOM_INNER_ATTRS;\n+    fn attrs(&self) -> &[Attribute] {\n+        self.wrapped.attrs()\n+    }\n+    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+        self.wrapped.visit_attrs(f)\n+    }\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+        self.wrapped.tokens_mut()\n+    }\n+}"}, {"sha": "84fe9ad26720ee9ad459fe725cdebf46735833e8", "filename": "compiler/rustc_ast/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/800ba8f8e862d72707200f77a51981de62f38b3a/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800ba8f8e862d72707200f77a51981de62f38b3a/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Flib.rs?ref=800ba8f8e862d72707200f77a51981de62f38b3a", "patch": "@@ -41,7 +41,7 @@ pub mod tokenstream;\n pub mod visit;\n \n pub use self::ast::*;\n-pub use self::ast_like::AstLike;\n+pub use self::ast_like::{AstLike, AstLikeWrapper};\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n "}, {"sha": "4c50685d5f3348fd09b97ef4cd1e979f9d9dda65", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 684, "deletions": 497, "changes": 1181, "blob_url": "https://github.com/rust-lang/rust/blob/800ba8f8e862d72707200f77a51981de62f38b3a/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800ba8f8e862d72707200f77a51981de62f38b3a/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=800ba8f8e862d72707200f77a51981de62f38b3a", "patch": "@@ -1,6 +1,5 @@\n use crate::base::*;\n use crate::config::StripUnconfigured;\n-use crate::configure;\n use crate::hygiene::SyntaxContext;\n use crate::mbe::macro_rules::annotate_err_with_kind;\n use crate::module::{mod_dir_path, parse_external_mod, DirOwnership, ParsedExternalMod};\n@@ -12,13 +11,12 @@ use rustc_ast::ptr::P;\n use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n-use rustc_ast::{AstLike, Block, Inline, ItemKind, MacArgs, MacCall};\n+use rustc_ast::{AstLike, AstLikeWrapper, Block, Inline, ItemKind, MacArgs, MacCall};\n use rustc_ast::{MacCallStmt, MacStmtStyle, MetaItemKind, ModKind, NestedMetaItem};\n-use rustc_ast::{NodeId, PatKind, Path, StmtKind};\n+use rustc_ast::{NodeId, Path, StmtKind};\n use rustc_ast_pretty::pprust;\n use rustc_attr::is_builtin_attr;\n use rustc_data_structures::map_in_place::MapInPlace;\n-use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, PResult};\n use rustc_feature::Features;\n@@ -34,7 +32,7 @@ use rustc_span::symbol::{sym, Ident};\n use rustc_span::{FileName, LocalExpnId, Span};\n \n use smallvec::SmallVec;\n-use std::ops::DerefMut;\n+use std::ops::Deref;\n use std::path::PathBuf;\n use std::rc::Rc;\n use std::{iter, mem};\n@@ -109,6 +107,10 @@ macro_rules! ast_fragments {\n                 }\n             })*\n \n+            fn make_ast<T: InvocationCollectorNode>(self) -> T::OutputTy {\n+                T::fragment_to_output(self)\n+            }\n+\n             pub fn mut_visit_with<F: MutVisitor>(&mut self, vis: &mut F) {\n                 match self {\n                     AstFragment::OptExpr(opt_expr) => {\n@@ -961,6 +963,568 @@ pub fn ensure_complete_parse<'a>(\n     }\n }\n \n+/// Wraps a call to `noop_visit_*` / `noop_flat_map_*`\n+/// for an AST node that supports attributes\n+/// (see the `Annotatable` enum)\n+/// This method assigns a `NodeId`, and sets that `NodeId`\n+/// as our current 'lint node id'. If a macro call is found\n+/// inside this AST node, we will use this AST node's `NodeId`\n+/// to emit lints associated with that macro (allowing\n+/// `#[allow]` / `#[deny]` to be applied close to\n+/// the macro invocation).\n+///\n+/// Do *not* call this for a macro AST node\n+/// (e.g. `ExprKind::MacCall`) - we cannot emit lints\n+/// at these AST nodes, since they are removed and\n+/// replaced with the result of macro expansion.\n+///\n+/// All other `NodeId`s are assigned by `visit_id`.\n+/// * `self` is the 'self' parameter for the current method,\n+/// * `id` is a mutable reference to the `NodeId` field\n+///    of the current AST node.\n+/// * `closure` is a closure that executes the\n+///   `noop_visit_*` / `noop_flat_map_*` method\n+///   for the current AST node.\n+macro_rules! assign_id {\n+    ($self:ident, $id:expr, $closure:expr) => {{\n+        let old_id = $self.cx.current_expansion.lint_node_id;\n+        if $self.monotonic {\n+            debug_assert_eq!(*$id, ast::DUMMY_NODE_ID);\n+            let new_id = $self.cx.resolver.next_node_id();\n+            *$id = new_id;\n+            $self.cx.current_expansion.lint_node_id = new_id;\n+        }\n+        let ret = ($closure)();\n+        $self.cx.current_expansion.lint_node_id = old_id;\n+        ret\n+    }};\n+}\n+\n+enum AddSemicolon {\n+    Yes,\n+    No,\n+}\n+\n+/// A trait implemented for all `AstFragment` nodes and providing all pieces\n+/// of functionality used by `InvocationCollector`.\n+trait InvocationCollectorNode: AstLike {\n+    type OutputTy = SmallVec<[Self; 1]>;\n+    type AttrsTy: Deref<Target = [ast::Attribute]> = Vec<ast::Attribute>;\n+    const KIND: AstFragmentKind;\n+    fn to_annotatable(self) -> Annotatable;\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy;\n+    fn id(&mut self) -> &mut NodeId;\n+    fn noop_flat_map<V: MutVisitor>(self, _visitor: &mut V) -> Self::OutputTy {\n+        unreachable!()\n+    }\n+    fn noop_visit<V: MutVisitor>(&mut self, _visitor: &mut V) {\n+        unreachable!()\n+    }\n+    fn is_mac_call(&self) -> bool {\n+        false\n+    }\n+    fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n+        unreachable!()\n+    }\n+    fn pre_flat_map_node_collect_attr(_cfg: &StripUnconfigured<'_>, _attr: &ast::Attribute) {}\n+    fn post_flat_map_node_collect_bang(_output: &mut Self::OutputTy, _add_semicolon: AddSemicolon) {\n+    }\n+    fn wrap_flat_map_node_noop_flat_map(\n+        node: Self,\n+        collector: &mut InvocationCollector<'_, '_>,\n+        noop_flat_map: impl FnOnce(Self, &mut InvocationCollector<'_, '_>) -> Self::OutputTy,\n+    ) -> Result<Self::OutputTy, Self> {\n+        Ok(noop_flat_map(node, collector))\n+    }\n+}\n+\n+impl InvocationCollectorNode for P<ast::Item> {\n+    const KIND: AstFragmentKind = AstFragmentKind::Items;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::Item(self)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_items()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.id\n+    }\n+    fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n+        noop_flat_map_item(self, visitor)\n+    }\n+    fn is_mac_call(&self) -> bool {\n+        matches!(self.kind, ast::ItemKind::MacCall(..))\n+    }\n+    fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n+        let node = self.into_inner();\n+        match node.kind {\n+            ast::ItemKind::MacCall(mac) => (mac, node.attrs, AddSemicolon::No),\n+            _ => unreachable!(),\n+        }\n+    }\n+    fn wrap_flat_map_node_noop_flat_map(\n+        mut node: Self,\n+        collector: &mut InvocationCollector<'_, '_>,\n+        noop_flat_map: impl FnOnce(Self, &mut InvocationCollector<'_, '_>) -> Self::OutputTy,\n+    ) -> Result<Self::OutputTy, Self> {\n+        if !matches!(node.kind, ast::ItemKind::Mod(..)) {\n+            return Ok(noop_flat_map(node, collector));\n+        }\n+\n+        // Work around borrow checker not seeing through `P`'s deref.\n+        let (ident, span, mut attrs) = (node.ident, node.span, mem::take(&mut node.attrs));\n+        let ast::ItemKind::Mod(_, mod_kind) = &mut node.kind else {\n+            unreachable!()\n+        };\n+\n+        let ecx = &mut collector.cx;\n+        let (file_path, dir_path, dir_ownership) = match mod_kind {\n+            ModKind::Loaded(_, inline, _) => {\n+                // Inline `mod foo { ... }`, but we still need to push directories.\n+                let (dir_path, dir_ownership) = mod_dir_path(\n+                    &ecx.sess,\n+                    ident,\n+                    &attrs,\n+                    &ecx.current_expansion.module,\n+                    ecx.current_expansion.dir_ownership,\n+                    *inline,\n+                );\n+                node.attrs = attrs;\n+                (None, dir_path, dir_ownership)\n+            }\n+            ModKind::Unloaded => {\n+                // We have an outline `mod foo;` so we need to parse the file.\n+                let old_attrs_len = attrs.len();\n+                let ParsedExternalMod { mut items, inner_span, file_path, dir_path, dir_ownership } =\n+                    parse_external_mod(\n+                        &ecx.sess,\n+                        ident,\n+                        span,\n+                        &ecx.current_expansion.module,\n+                        ecx.current_expansion.dir_ownership,\n+                        &mut attrs,\n+                    );\n+\n+                if let Some(extern_mod_loaded) = ecx.extern_mod_loaded {\n+                    (attrs, items) = extern_mod_loaded(ident, attrs, items, inner_span);\n+                }\n+\n+                *mod_kind = ModKind::Loaded(items, Inline::No, inner_span);\n+                node.attrs = attrs;\n+                if node.attrs.len() > old_attrs_len {\n+                    // If we loaded an out-of-line module and added some inner attributes,\n+                    // then we need to re-configure it and re-collect attributes for\n+                    // resolution and expansion.\n+                    return Err(node);\n+                }\n+                (Some(file_path), dir_path, dir_ownership)\n+            }\n+        };\n+\n+        // Set the module info before we flat map.\n+        let mut module = ecx.current_expansion.module.with_dir_path(dir_path);\n+        module.mod_path.push(ident);\n+        if let Some(file_path) = file_path {\n+            module.file_path_stack.push(file_path);\n+        }\n+\n+        let orig_module = mem::replace(&mut ecx.current_expansion.module, Rc::new(module));\n+        let orig_dir_ownership =\n+            mem::replace(&mut ecx.current_expansion.dir_ownership, dir_ownership);\n+\n+        let res = Ok(noop_flat_map(node, collector));\n+\n+        collector.cx.current_expansion.dir_ownership = orig_dir_ownership;\n+        collector.cx.current_expansion.module = orig_module;\n+        res\n+    }\n+}\n+\n+struct TraitItemTag;\n+impl InvocationCollectorNode for AstLikeWrapper<P<ast::AssocItem>, TraitItemTag> {\n+    type OutputTy = SmallVec<[P<ast::AssocItem>; 1]>;\n+    const KIND: AstFragmentKind = AstFragmentKind::TraitItems;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::TraitItem(self.wrapped)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_trait_items()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.wrapped.id\n+    }\n+    fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n+        noop_flat_map_assoc_item(self.wrapped, visitor)\n+    }\n+    fn is_mac_call(&self) -> bool {\n+        matches!(self.wrapped.kind, ast::AssocItemKind::MacCall(..))\n+    }\n+    fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n+        let item = self.wrapped.into_inner();\n+        match item.kind {\n+            ast::AssocItemKind::MacCall(mac) => (mac, item.attrs, AddSemicolon::No),\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n+struct ImplItemTag;\n+impl InvocationCollectorNode for AstLikeWrapper<P<ast::AssocItem>, ImplItemTag> {\n+    type OutputTy = SmallVec<[P<ast::AssocItem>; 1]>;\n+    const KIND: AstFragmentKind = AstFragmentKind::ImplItems;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::ImplItem(self.wrapped)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_impl_items()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.wrapped.id\n+    }\n+    fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n+        noop_flat_map_assoc_item(self.wrapped, visitor)\n+    }\n+    fn is_mac_call(&self) -> bool {\n+        matches!(self.wrapped.kind, ast::AssocItemKind::MacCall(..))\n+    }\n+    fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n+        let item = self.wrapped.into_inner();\n+        match item.kind {\n+            ast::AssocItemKind::MacCall(mac) => (mac, item.attrs, AddSemicolon::No),\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n+impl InvocationCollectorNode for P<ast::ForeignItem> {\n+    const KIND: AstFragmentKind = AstFragmentKind::ForeignItems;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::ForeignItem(self)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_foreign_items()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.id\n+    }\n+    fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n+        noop_flat_map_foreign_item(self, visitor)\n+    }\n+    fn is_mac_call(&self) -> bool {\n+        matches!(self.kind, ast::ForeignItemKind::MacCall(..))\n+    }\n+    fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n+        let node = self.into_inner();\n+        match node.kind {\n+            ast::ForeignItemKind::MacCall(mac) => (mac, node.attrs, AddSemicolon::No),\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n+impl InvocationCollectorNode for ast::Variant {\n+    const KIND: AstFragmentKind = AstFragmentKind::Variants;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::Variant(self)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_variants()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.id\n+    }\n+    fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n+        noop_flat_map_variant(self, visitor)\n+    }\n+}\n+\n+impl InvocationCollectorNode for ast::FieldDef {\n+    const KIND: AstFragmentKind = AstFragmentKind::FieldDefs;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::FieldDef(self)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_field_defs()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.id\n+    }\n+    fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n+        noop_flat_map_field_def(self, visitor)\n+    }\n+}\n+\n+impl InvocationCollectorNode for ast::PatField {\n+    const KIND: AstFragmentKind = AstFragmentKind::PatFields;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::PatField(self)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_pat_fields()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.id\n+    }\n+    fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n+        noop_flat_map_pat_field(self, visitor)\n+    }\n+}\n+\n+impl InvocationCollectorNode for ast::ExprField {\n+    const KIND: AstFragmentKind = AstFragmentKind::ExprFields;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::ExprField(self)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_expr_fields()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.id\n+    }\n+    fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n+        noop_flat_map_expr_field(self, visitor)\n+    }\n+}\n+\n+impl InvocationCollectorNode for ast::Param {\n+    const KIND: AstFragmentKind = AstFragmentKind::Params;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::Param(self)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_params()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.id\n+    }\n+    fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n+        noop_flat_map_param(self, visitor)\n+    }\n+}\n+\n+impl InvocationCollectorNode for ast::GenericParam {\n+    const KIND: AstFragmentKind = AstFragmentKind::GenericParams;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::GenericParam(self)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_generic_params()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.id\n+    }\n+    fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n+        noop_flat_map_generic_param(self, visitor)\n+    }\n+}\n+\n+impl InvocationCollectorNode for ast::Arm {\n+    const KIND: AstFragmentKind = AstFragmentKind::Arms;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::Arm(self)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_arms()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.id\n+    }\n+    fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n+        noop_flat_map_arm(self, visitor)\n+    }\n+}\n+\n+impl InvocationCollectorNode for ast::Stmt {\n+    type AttrsTy = ast::AttrVec;\n+    const KIND: AstFragmentKind = AstFragmentKind::Stmts;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::Stmt(P(self))\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_stmts()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.id\n+    }\n+    fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n+        noop_flat_map_stmt(self, visitor)\n+    }\n+    fn is_mac_call(&self) -> bool {\n+        match &self.kind {\n+            StmtKind::MacCall(..) => true,\n+            StmtKind::Item(item) => matches!(item.kind, ItemKind::MacCall(..)),\n+            StmtKind::Semi(expr) => matches!(expr.kind, ast::ExprKind::MacCall(..)),\n+            StmtKind::Expr(..) => unreachable!(),\n+            StmtKind::Local(..) | StmtKind::Empty => false,\n+        }\n+    }\n+    fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n+        // We pull macro invocations (both attributes and fn-like macro calls) out of their\n+        // `StmtKind`s and treat them as statement macro invocations, not as items or expressions.\n+        let (add_semicolon, mac, attrs) = match self.kind {\n+            StmtKind::MacCall(mac) => {\n+                let MacCallStmt { mac, style, attrs, .. } = mac.into_inner();\n+                (style == MacStmtStyle::Semicolon, mac, attrs)\n+            }\n+            StmtKind::Item(item) => match item.into_inner() {\n+                ast::Item { kind: ItemKind::MacCall(mac), attrs, .. } => {\n+                    (mac.args.need_semicolon(), mac, attrs.into())\n+                }\n+                _ => unreachable!(),\n+            },\n+            StmtKind::Semi(expr) => match expr.into_inner() {\n+                ast::Expr { kind: ast::ExprKind::MacCall(mac), attrs, .. } => {\n+                    (mac.args.need_semicolon(), mac, attrs)\n+                }\n+                _ => unreachable!(),\n+            },\n+            _ => unreachable!(),\n+        };\n+        (mac, attrs, if add_semicolon { AddSemicolon::Yes } else { AddSemicolon::No })\n+    }\n+    fn post_flat_map_node_collect_bang(stmts: &mut Self::OutputTy, add_semicolon: AddSemicolon) {\n+        // If this is a macro invocation with a semicolon, then apply that\n+        // semicolon to the final statement produced by expansion.\n+        if matches!(add_semicolon, AddSemicolon::Yes) {\n+            if let Some(stmt) = stmts.pop() {\n+                stmts.push(stmt.add_trailing_semicolon());\n+            }\n+        }\n+    }\n+}\n+\n+impl InvocationCollectorNode for ast::Crate {\n+    type OutputTy = ast::Crate;\n+    const KIND: AstFragmentKind = AstFragmentKind::Crate;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::Crate(self)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_crate()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.id\n+    }\n+    fn noop_visit<V: MutVisitor>(&mut self, visitor: &mut V) {\n+        noop_visit_crate(self, visitor)\n+    }\n+}\n+\n+impl InvocationCollectorNode for P<ast::Ty> {\n+    type OutputTy = P<ast::Ty>;\n+    const KIND: AstFragmentKind = AstFragmentKind::Ty;\n+    fn to_annotatable(self) -> Annotatable {\n+        unreachable!()\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_ty()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.id\n+    }\n+    fn noop_visit<V: MutVisitor>(&mut self, visitor: &mut V) {\n+        noop_visit_ty(self, visitor)\n+    }\n+    fn is_mac_call(&self) -> bool {\n+        matches!(self.kind, ast::TyKind::MacCall(..))\n+    }\n+    fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n+        let node = self.into_inner();\n+        match node.kind {\n+            ast::TyKind::MacCall(mac) => (mac, Vec::new(), AddSemicolon::No),\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n+impl InvocationCollectorNode for P<ast::Pat> {\n+    type OutputTy = P<ast::Pat>;\n+    const KIND: AstFragmentKind = AstFragmentKind::Pat;\n+    fn to_annotatable(self) -> Annotatable {\n+        unreachable!()\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_pat()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.id\n+    }\n+    fn noop_visit<V: MutVisitor>(&mut self, visitor: &mut V) {\n+        noop_visit_pat(self, visitor)\n+    }\n+    fn is_mac_call(&self) -> bool {\n+        matches!(self.kind, ast::PatKind::MacCall(..))\n+    }\n+    fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n+        let node = self.into_inner();\n+        match node.kind {\n+            ast::PatKind::MacCall(mac) => (mac, Vec::new(), AddSemicolon::No),\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n+impl InvocationCollectorNode for P<ast::Expr> {\n+    type OutputTy = P<ast::Expr>;\n+    type AttrsTy = ast::AttrVec;\n+    const KIND: AstFragmentKind = AstFragmentKind::Expr;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::Expr(self)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_expr()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.id\n+    }\n+    fn noop_visit<V: MutVisitor>(&mut self, visitor: &mut V) {\n+        noop_visit_expr(self, visitor)\n+    }\n+    fn is_mac_call(&self) -> bool {\n+        matches!(self.kind, ast::ExprKind::MacCall(..))\n+    }\n+    fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n+        let node = self.into_inner();\n+        match node.kind {\n+            ast::ExprKind::MacCall(mac) => (mac, node.attrs, AddSemicolon::No),\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n+struct OptExprTag;\n+impl InvocationCollectorNode for AstLikeWrapper<P<ast::Expr>, OptExprTag> {\n+    type OutputTy = Option<P<ast::Expr>>;\n+    type AttrsTy = ast::AttrVec;\n+    const KIND: AstFragmentKind = AstFragmentKind::OptExpr;\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::Expr(self.wrapped)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        fragment.make_opt_expr()\n+    }\n+    fn id(&mut self) -> &mut NodeId {\n+        &mut self.wrapped.id\n+    }\n+    fn noop_flat_map<V: MutVisitor>(mut self, visitor: &mut V) -> Self::OutputTy {\n+        noop_visit_expr(&mut self.wrapped, visitor);\n+        Some(self.wrapped)\n+    }\n+    fn is_mac_call(&self) -> bool {\n+        matches!(self.wrapped.kind, ast::ExprKind::MacCall(..))\n+    }\n+    fn take_mac_call(self) -> (ast::MacCall, Self::AttrsTy, AddSemicolon) {\n+        let node = self.wrapped.into_inner();\n+        match node.kind {\n+            ast::ExprKind::MacCall(mac) => (mac, node.attrs, AddSemicolon::No),\n+            _ => unreachable!(),\n+        }\n+    }\n+    fn pre_flat_map_node_collect_attr(cfg: &StripUnconfigured<'_>, attr: &ast::Attribute) {\n+        cfg.maybe_emit_expr_attr_err(&attr);\n+    }\n+}\n+\n struct InvocationCollector<'a, 'b> {\n     cx: &'a mut ExtCtxt<'b>,\n     cfg: StripUnconfigured<'a>,\n@@ -1039,39 +1603,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n         attr\n     }\n \n-    fn take_stmt_bang(\n-        &self,\n-        stmt: ast::Stmt,\n-    ) -> Result<(bool, MacCall, Vec<ast::Attribute>), ast::Stmt> {\n-        match stmt.kind {\n-            StmtKind::MacCall(mac) => {\n-                let MacCallStmt { mac, style, attrs, .. } = mac.into_inner();\n-                Ok((style == MacStmtStyle::Semicolon, mac, attrs.into()))\n-            }\n-            StmtKind::Item(item) if matches!(item.kind, ItemKind::MacCall(..)) => {\n-                match item.into_inner() {\n-                    ast::Item { kind: ItemKind::MacCall(mac), attrs, .. } => {\n-                        Ok((mac.args.need_semicolon(), mac, attrs))\n-                    }\n-                    _ => unreachable!(),\n-                }\n-            }\n-            StmtKind::Semi(expr) if matches!(expr.kind, ast::ExprKind::MacCall(..)) => {\n-                match expr.into_inner() {\n-                    ast::Expr { kind: ast::ExprKind::MacCall(mac), attrs, .. } => {\n-                        Ok((mac.args.need_semicolon(), mac, attrs.into()))\n-                    }\n-                    _ => unreachable!(),\n-                }\n-            }\n-            StmtKind::Local(..) | StmtKind::Empty | StmtKind::Item(..) | StmtKind::Semi(..) => {\n-                Err(stmt)\n-            }\n-            StmtKind::Expr(..) => unreachable!(),\n-        }\n-    }\n-\n-    fn configure<T: AstLike>(&self, node: T) -> Option<T> {\n+    fn configure<T: AstLike>(&mut self, node: T) -> Option<T> {\n         self.cfg.configure(node)\n     }\n \n@@ -1120,507 +1652,162 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n             }\n         }\n     }\n-}\n \n-/// Wraps a call to `noop_visit_*` / `noop_flat_map_*`\n-/// for an AST node that supports attributes\n-/// (see the `Annotatable` enum)\n-/// This method assigns a `NodeId`, and sets that `NodeId`\n-/// as our current 'lint node id'. If a macro call is found\n-/// inside this AST node, we will use this AST node's `NodeId`\n-/// to emit lints associated with that macro (allowing\n-/// `#[allow]` / `#[deny]` to be applied close to\n-/// the macro invocation).\n-///\n-/// Do *not* call this for a macro AST node\n-/// (e.g. `ExprKind::MacCall`) - we cannot emit lints\n-/// at these AST nodes, since they are removed and\n-/// replaced with the result of macro expansion.\n-///\n-/// All other `NodeId`s are assigned by `visit_id`.\n-/// * `self` is the 'self' parameter for the current method,\n-/// * `id` is a mutable reference to the `NodeId` field\n-///    of the current AST node.\n-/// * `closure` is a closure that executes the\n-///   `noop_visit_*` / `noop_flat_map_*` method\n-///   for the current AST node.\n-macro_rules! assign_id {\n-    ($self:ident, $id:expr, $closure:expr) => {{\n-        let old_id = $self.cx.current_expansion.lint_node_id;\n-        if $self.monotonic {\n-            debug_assert_eq!(*$id, ast::DUMMY_NODE_ID);\n-            let new_id = $self.cx.resolver.next_node_id();\n-            *$id = new_id;\n-            $self.cx.current_expansion.lint_node_id = new_id;\n+    fn flat_map_node<Node: InvocationCollectorNode<OutputTy: Default>>(\n+        &mut self,\n+        node: Node,\n+    ) -> Node::OutputTy {\n+        let mut node = configure!(self, node);\n+\n+        if let Some(attr) = self.take_first_attr(&mut node) {\n+            Node::pre_flat_map_node_collect_attr(&self.cfg, &attr.0);\n+            self.collect_attr(attr, node.to_annotatable(), Node::KIND).make_ast::<Node>()\n+        } else if node.is_mac_call() {\n+            let (mac, attrs, add_semicolon) = node.take_mac_call();\n+            self.check_attributes(&attrs, &mac);\n+            let mut res = self.collect_bang(mac, Node::KIND).make_ast::<Node>();\n+            Node::post_flat_map_node_collect_bang(&mut res, add_semicolon);\n+            res\n+        } else {\n+            match Node::wrap_flat_map_node_noop_flat_map(node, self, |mut node, this| {\n+                assign_id!(this, node.id(), || node.noop_flat_map(this))\n+            }) {\n+                Ok(output) => output,\n+                Err(node) => self.flat_map_node(node),\n+            }\n         }\n-        let ret = ($closure)();\n-        $self.cx.current_expansion.lint_node_id = old_id;\n-        ret\n-    }};\n+    }\n+\n+    fn visit_node<Node: InvocationCollectorNode<OutputTy = Node> + DummyAstNode>(\n+        &mut self,\n+        node: &mut Node,\n+    ) {\n+        if let Some(attr) = self.take_first_attr(node) {\n+            visit_clobber(node, |node| {\n+                self.collect_attr(attr, node.to_annotatable(), Node::KIND).make_ast::<Node>()\n+            })\n+        } else if node.is_mac_call() {\n+            visit_clobber(node, |node| {\n+                // Do not clobber unless it's actually a macro (uncommon case).\n+                let (mac, attrs, _) = node.take_mac_call();\n+                self.check_attributes(&attrs, &mac);\n+                self.collect_bang(mac, Node::KIND).make_ast::<Node>()\n+            })\n+        } else {\n+            assign_id!(self, node.id(), || node.noop_visit(self))\n+        }\n+    }\n }\n \n impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n-    fn visit_crate(&mut self, krate: &mut ast::Crate) {\n-        visit_clobber(krate, |krate| {\n-            let span = krate.span;\n-            let mut krate = match self.configure(krate) {\n-                Some(krate) => krate,\n-                None => {\n-                    return ast::Crate {\n-                        attrs: Vec::new(),\n-                        items: Vec::new(),\n-                        span,\n-                        id: self.cx.resolver.next_node_id(),\n-                        is_placeholder: false,\n-                    };\n-                }\n-            };\n-\n-            if let Some(attr) = self.take_first_attr(&mut krate) {\n-                return self\n-                    .collect_attr(attr, Annotatable::Crate(krate), AstFragmentKind::Crate)\n-                    .make_crate();\n-            }\n-\n-            assign_id!(self, &mut krate.id, || noop_visit_crate(&mut krate, self));\n-            krate\n-        })\n+    fn flat_map_item(&mut self, node: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n+        self.flat_map_node(node)\n     }\n \n-    fn visit_expr(&mut self, expr: &mut P<ast::Expr>) {\n-        self.cfg.configure_expr(expr);\n-        visit_clobber(expr.deref_mut(), |mut expr| {\n-            if let Some(attr) = self.take_first_attr(&mut expr) {\n-                // Collect the invoc regardless of whether or not attributes are permitted here\n-                // expansion will eat the attribute so it won't error later.\n-                self.cfg.maybe_emit_expr_attr_err(&attr.0);\n-\n-                // AstFragmentKind::Expr requires the macro to emit an expression.\n-                return self\n-                    .collect_attr(attr, Annotatable::Expr(P(expr)), AstFragmentKind::Expr)\n-                    .make_expr()\n-                    .into_inner();\n-            }\n-\n-            if let ast::ExprKind::MacCall(mac) = expr.kind {\n-                self.check_attributes(&expr.attrs, &mac);\n-                self.collect_bang(mac, AstFragmentKind::Expr).make_expr().into_inner()\n-            } else {\n-                assign_id!(self, &mut expr.id, || {\n-                    ensure_sufficient_stack(|| noop_visit_expr(&mut expr, self));\n-                });\n-                expr\n-            }\n-        });\n+    fn flat_map_trait_item(&mut self, node: P<ast::AssocItem>) -> SmallVec<[P<ast::AssocItem>; 1]> {\n+        self.flat_map_node(AstLikeWrapper::new(node, TraitItemTag))\n     }\n \n-    fn flat_map_arm(&mut self, arm: ast::Arm) -> SmallVec<[ast::Arm; 1]> {\n-        let mut arm = configure!(self, arm);\n-\n-        if let Some(attr) = self.take_first_attr(&mut arm) {\n-            return self\n-                .collect_attr(attr, Annotatable::Arm(arm), AstFragmentKind::Arms)\n-                .make_arms();\n-        }\n-\n-        assign_id!(self, &mut arm.id, || noop_flat_map_arm(arm, self))\n+    fn flat_map_impl_item(&mut self, node: P<ast::AssocItem>) -> SmallVec<[P<ast::AssocItem>; 1]> {\n+        self.flat_map_node(AstLikeWrapper::new(node, ImplItemTag))\n     }\n \n-    fn flat_map_expr_field(&mut self, field: ast::ExprField) -> SmallVec<[ast::ExprField; 1]> {\n-        let mut field = configure!(self, field);\n-\n-        if let Some(attr) = self.take_first_attr(&mut field) {\n-            return self\n-                .collect_attr(attr, Annotatable::ExprField(field), AstFragmentKind::ExprFields)\n-                .make_expr_fields();\n-        }\n-\n-        assign_id!(self, &mut field.id, || noop_flat_map_expr_field(field, self))\n+    fn flat_map_foreign_item(\n+        &mut self,\n+        node: P<ast::ForeignItem>,\n+    ) -> SmallVec<[P<ast::ForeignItem>; 1]> {\n+        self.flat_map_node(node)\n     }\n \n-    fn flat_map_pat_field(&mut self, fp: ast::PatField) -> SmallVec<[ast::PatField; 1]> {\n-        let mut fp = configure!(self, fp);\n-\n-        if let Some(attr) = self.take_first_attr(&mut fp) {\n-            return self\n-                .collect_attr(attr, Annotatable::PatField(fp), AstFragmentKind::PatFields)\n-                .make_pat_fields();\n-        }\n-\n-        assign_id!(self, &mut fp.id, || noop_flat_map_pat_field(fp, self))\n+    fn flat_map_variant(&mut self, node: ast::Variant) -> SmallVec<[ast::Variant; 1]> {\n+        self.flat_map_node(node)\n     }\n \n-    fn flat_map_param(&mut self, p: ast::Param) -> SmallVec<[ast::Param; 1]> {\n-        let mut p = configure!(self, p);\n-\n-        if let Some(attr) = self.take_first_attr(&mut p) {\n-            return self\n-                .collect_attr(attr, Annotatable::Param(p), AstFragmentKind::Params)\n-                .make_params();\n-        }\n-\n-        assign_id!(self, &mut p.id, || noop_flat_map_param(p, self))\n+    fn flat_map_field_def(&mut self, node: ast::FieldDef) -> SmallVec<[ast::FieldDef; 1]> {\n+        self.flat_map_node(node)\n     }\n \n-    fn flat_map_field_def(&mut self, sf: ast::FieldDef) -> SmallVec<[ast::FieldDef; 1]> {\n-        let mut sf = configure!(self, sf);\n-\n-        if let Some(attr) = self.take_first_attr(&mut sf) {\n-            return self\n-                .collect_attr(attr, Annotatable::FieldDef(sf), AstFragmentKind::FieldDefs)\n-                .make_field_defs();\n-        }\n-\n-        assign_id!(self, &mut sf.id, || noop_flat_map_field_def(sf, self))\n+    fn flat_map_pat_field(&mut self, node: ast::PatField) -> SmallVec<[ast::PatField; 1]> {\n+        self.flat_map_node(node)\n     }\n \n-    fn flat_map_variant(&mut self, variant: ast::Variant) -> SmallVec<[ast::Variant; 1]> {\n-        let mut variant = configure!(self, variant);\n-\n-        if let Some(attr) = self.take_first_attr(&mut variant) {\n-            return self\n-                .collect_attr(attr, Annotatable::Variant(variant), AstFragmentKind::Variants)\n-                .make_variants();\n-        }\n-\n-        assign_id!(self, &mut variant.id, || noop_flat_map_variant(variant, self))\n+    fn flat_map_expr_field(&mut self, node: ast::ExprField) -> SmallVec<[ast::ExprField; 1]> {\n+        self.flat_map_node(node)\n     }\n \n-    fn filter_map_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n-        let expr = configure!(self, expr);\n-        expr.filter_map(|mut expr| {\n-            if let Some(attr) = self.take_first_attr(&mut expr) {\n-                self.cfg.maybe_emit_expr_attr_err(&attr.0);\n-\n-                return self\n-                    .collect_attr(attr, Annotatable::Expr(P(expr)), AstFragmentKind::OptExpr)\n-                    .make_opt_expr()\n-                    .map(|expr| expr.into_inner());\n-            }\n-\n-            if let ast::ExprKind::MacCall(mac) = expr.kind {\n-                self.check_attributes(&expr.attrs, &mac);\n-                self.collect_bang(mac, AstFragmentKind::OptExpr)\n-                    .make_opt_expr()\n-                    .map(|expr| expr.into_inner())\n-            } else {\n-                assign_id!(self, &mut expr.id, || {\n-                    Some({\n-                        noop_visit_expr(&mut expr, self);\n-                        expr\n-                    })\n-                })\n-            }\n-        })\n+    fn flat_map_param(&mut self, node: ast::Param) -> SmallVec<[ast::Param; 1]> {\n+        self.flat_map_node(node)\n     }\n \n-    fn visit_pat(&mut self, pat: &mut P<ast::Pat>) {\n-        match pat.kind {\n-            PatKind::MacCall(_) => {}\n-            _ => return noop_visit_pat(pat, self),\n-        }\n-\n-        visit_clobber(pat, |mut pat| match mem::replace(&mut pat.kind, PatKind::Wild) {\n-            PatKind::MacCall(mac) => self.collect_bang(mac, AstFragmentKind::Pat).make_pat(),\n-            _ => unreachable!(),\n-        });\n+    fn flat_map_generic_param(\n+        &mut self,\n+        node: ast::GenericParam,\n+    ) -> SmallVec<[ast::GenericParam; 1]> {\n+        self.flat_map_node(node)\n     }\n \n-    fn flat_map_stmt(&mut self, stmt: ast::Stmt) -> SmallVec<[ast::Stmt; 1]> {\n-        let mut stmt = configure!(self, stmt);\n+    fn flat_map_arm(&mut self, node: ast::Arm) -> SmallVec<[ast::Arm; 1]> {\n+        self.flat_map_node(node)\n+    }\n \n-        // We pull macro invocations (both attributes and fn-like macro calls) out of their\n-        // `StmtKind`s and treat them as statement macro invocations, not as items or expressions.\n+    fn flat_map_stmt(&mut self, node: ast::Stmt) -> SmallVec<[ast::Stmt; 1]> {\n         // FIXME: invocations in semicolon-less expressions positions are expanded as expressions,\n         // changing that requires some compatibility measures.\n-        let mut stmt = if !stmt.is_expr() {\n-            if let Some(attr) = self.take_first_attr(&mut stmt) {\n-                return self\n-                    .collect_attr(attr, Annotatable::Stmt(P(stmt)), AstFragmentKind::Stmts)\n-                    .make_stmts();\n-            }\n-\n-            match self.take_stmt_bang(stmt) {\n-                Ok((add_semicolon, mac, attrs)) => {\n-                    self.check_attributes(&attrs, &mac);\n-                    let mut stmts = self.collect_bang(mac, AstFragmentKind::Stmts).make_stmts();\n-\n-                    // If this is a macro invocation with a semicolon, then apply that\n-                    // semicolon to the final statement produced by expansion.\n-                    if add_semicolon {\n-                        if let Some(stmt) = stmts.pop() {\n-                            stmts.push(stmt.add_trailing_semicolon());\n-                        }\n-                    }\n-\n-                    return stmts;\n+        if node.is_expr() {\n+            // The only way that we can end up with a `MacCall` expression statement,\n+            // (as opposed to a `StmtKind::MacCall`) is if we have a macro as the\n+            // traiing expression in a block (e.g. `fn foo() { my_macro!() }`).\n+            // Record this information, so that we can report a more specific\n+            // `SEMICOLON_IN_EXPRESSIONS_FROM_MACROS` lint if needed.\n+            // See #78991 for an investigation of treating macros in this position\n+            // as statements, rather than expressions, during parsing.\n+            let mut node = configure!(self, node);\n+            return match &node.kind {\n+                StmtKind::Expr(expr)\n+                    if matches!(**expr, ast::Expr { kind: ast::ExprKind::MacCall(..), .. }) =>\n+                {\n+                    self.cx.current_expansion.is_trailing_mac = true;\n+                    // Don't use `assign_id` for this statement - it may get removed\n+                    // entirely due to a `#[cfg]` on the contained expression\n+                    let res = noop_flat_map_stmt(node, self);\n+                    self.cx.current_expansion.is_trailing_mac = false;\n+                    res\n                 }\n-                Err(stmt) => stmt,\n-            }\n-        } else {\n-            stmt\n-        };\n-\n-        // The only way that we can end up with a `MacCall` expression statement,\n-        // (as opposed to a `StmtKind::MacCall`) is if we have a macro as the\n-        // traiing expression in a block (e.g. `fn foo() { my_macro!() }`).\n-        // Record this information, so that we can report a more specific\n-        // `SEMICOLON_IN_EXPRESSIONS_FROM_MACROS` lint if needed.\n-        // See #78991 for an investigation of treating macros in this position\n-        // as statements, rather than expressions, during parsing.\n-        let res = match &stmt.kind {\n-            StmtKind::Expr(expr)\n-                if matches!(**expr, ast::Expr { kind: ast::ExprKind::MacCall(..), .. }) =>\n-            {\n-                self.cx.current_expansion.is_trailing_mac = true;\n-                // Don't use `assign_id` for this statement - it may get removed\n-                // entirely due to a `#[cfg]` on the contained expression\n-                noop_flat_map_stmt(stmt, self)\n-            }\n-            _ => assign_id!(self, &mut stmt.id, || noop_flat_map_stmt(stmt, self)),\n-        };\n-        self.cx.current_expansion.is_trailing_mac = false;\n-        res\n-    }\n-\n-    fn visit_block(&mut self, block: &mut P<Block>) {\n-        let orig_dir_ownership = mem::replace(\n-            &mut self.cx.current_expansion.dir_ownership,\n-            DirOwnership::UnownedViaBlock,\n-        );\n-        noop_visit_block(block, self);\n-        self.cx.current_expansion.dir_ownership = orig_dir_ownership;\n-    }\n-\n-    fn flat_map_item(&mut self, item: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n-        let mut item = configure!(self, item);\n-\n-        if let Some(attr) = self.take_first_attr(&mut item) {\n-            return self\n-                .collect_attr(attr, Annotatable::Item(item), AstFragmentKind::Items)\n-                .make_items();\n+                _ => assign_id!(self, &mut node.id, || noop_flat_map_stmt(node, self)),\n+            };\n         }\n \n-        let mut attrs = mem::take(&mut item.attrs); // We do this to please borrowck.\n-        let ident = item.ident;\n-        let span = item.span;\n-\n-        match item.kind {\n-            ast::ItemKind::MacCall(ref mac) => {\n-                self.check_attributes(&attrs, &mac);\n-                item.attrs = attrs;\n-                item.and_then(|item| match item.kind {\n-                    ItemKind::MacCall(mac) => {\n-                        self.collect_bang(mac, AstFragmentKind::Items).make_items()\n-                    }\n-                    _ => unreachable!(),\n-                })\n-            }\n-            ast::ItemKind::Mod(_, ref mut mod_kind) if ident != Ident::empty() => {\n-                let (file_path, dir_path, dir_ownership) = match mod_kind {\n-                    ModKind::Loaded(_, inline, _) => {\n-                        // Inline `mod foo { ... }`, but we still need to push directories.\n-                        let (dir_path, dir_ownership) = mod_dir_path(\n-                            &self.cx.sess,\n-                            ident,\n-                            &attrs,\n-                            &self.cx.current_expansion.module,\n-                            self.cx.current_expansion.dir_ownership,\n-                            *inline,\n-                        );\n-                        item.attrs = attrs;\n-                        (None, dir_path, dir_ownership)\n-                    }\n-                    ModKind::Unloaded => {\n-                        // We have an outline `mod foo;` so we need to parse the file.\n-                        let old_attrs_len = attrs.len();\n-                        let ParsedExternalMod {\n-                            mut items,\n-                            inner_span,\n-                            file_path,\n-                            dir_path,\n-                            dir_ownership,\n-                        } = parse_external_mod(\n-                            &self.cx.sess,\n-                            ident,\n-                            span,\n-                            &self.cx.current_expansion.module,\n-                            self.cx.current_expansion.dir_ownership,\n-                            &mut attrs,\n-                        );\n-\n-                        if let Some(extern_mod_loaded) = self.cx.extern_mod_loaded {\n-                            (attrs, items) = extern_mod_loaded(ident, attrs, items, inner_span);\n-                        }\n-\n-                        *mod_kind = ModKind::Loaded(items, Inline::No, inner_span);\n-                        item.attrs = attrs;\n-                        if item.attrs.len() > old_attrs_len {\n-                            // If we loaded an out-of-line module and added some inner attributes,\n-                            // then we need to re-configure it and re-collect attributes for\n-                            // resolution and expansion.\n-                            item = configure!(self, item);\n-\n-                            if let Some(attr) = self.take_first_attr(&mut item) {\n-                                return self\n-                                    .collect_attr(\n-                                        attr,\n-                                        Annotatable::Item(item),\n-                                        AstFragmentKind::Items,\n-                                    )\n-                                    .make_items();\n-                            }\n-                        }\n-                        (Some(file_path), dir_path, dir_ownership)\n-                    }\n-                };\n-\n-                // Set the module info before we flat map.\n-                let mut module = self.cx.current_expansion.module.with_dir_path(dir_path);\n-                module.mod_path.push(ident);\n-                if let Some(file_path) = file_path {\n-                    module.file_path_stack.push(file_path);\n-                }\n-\n-                let orig_module =\n-                    mem::replace(&mut self.cx.current_expansion.module, Rc::new(module));\n-                let orig_dir_ownership =\n-                    mem::replace(&mut self.cx.current_expansion.dir_ownership, dir_ownership);\n-\n-                let result = assign_id!(self, &mut item.id, || noop_flat_map_item(item, self));\n-\n-                // Restore the module info.\n-                self.cx.current_expansion.dir_ownership = orig_dir_ownership;\n-                self.cx.current_expansion.module = orig_module;\n-\n-                result\n-            }\n-            _ => {\n-                item.attrs = attrs;\n-                // The crate root is special - don't assign an ID to it.\n-                if !(matches!(item.kind, ast::ItemKind::Mod(..)) && ident == Ident::empty()) {\n-                    assign_id!(self, &mut item.id, || noop_flat_map_item(item, self))\n-                } else {\n-                    noop_flat_map_item(item, self)\n-                }\n-            }\n-        }\n+        self.flat_map_node(node)\n     }\n \n-    fn flat_map_trait_item(&mut self, item: P<ast::AssocItem>) -> SmallVec<[P<ast::AssocItem>; 1]> {\n-        let mut item = configure!(self, item);\n-\n-        if let Some(attr) = self.take_first_attr(&mut item) {\n-            return self\n-                .collect_attr(attr, Annotatable::TraitItem(item), AstFragmentKind::TraitItems)\n-                .make_trait_items();\n-        }\n-\n-        match item.kind {\n-            ast::AssocItemKind::MacCall(ref mac) => {\n-                self.check_attributes(&item.attrs, &mac);\n-                item.and_then(|item| match item.kind {\n-                    ast::AssocItemKind::MacCall(mac) => {\n-                        self.collect_bang(mac, AstFragmentKind::TraitItems).make_trait_items()\n-                    }\n-                    _ => unreachable!(),\n-                })\n-            }\n-            _ => {\n-                assign_id!(self, &mut item.id, || noop_flat_map_assoc_item(item, self))\n-            }\n-        }\n+    fn visit_crate(&mut self, node: &mut ast::Crate) {\n+        self.visit_node(node)\n     }\n \n-    fn flat_map_impl_item(&mut self, item: P<ast::AssocItem>) -> SmallVec<[P<ast::AssocItem>; 1]> {\n-        let mut item = configure!(self, item);\n-\n-        if let Some(attr) = self.take_first_attr(&mut item) {\n-            return self\n-                .collect_attr(attr, Annotatable::ImplItem(item), AstFragmentKind::ImplItems)\n-                .make_impl_items();\n-        }\n-\n-        match item.kind {\n-            ast::AssocItemKind::MacCall(ref mac) => {\n-                self.check_attributes(&item.attrs, &mac);\n-                item.and_then(|item| match item.kind {\n-                    ast::AssocItemKind::MacCall(mac) => {\n-                        self.collect_bang(mac, AstFragmentKind::ImplItems).make_impl_items()\n-                    }\n-                    _ => unreachable!(),\n-                })\n-            }\n-            _ => {\n-                assign_id!(self, &mut item.id, || noop_flat_map_assoc_item(item, self))\n-            }\n-        }\n+    fn visit_ty(&mut self, node: &mut P<ast::Ty>) {\n+        self.visit_node(node)\n     }\n \n-    fn visit_ty(&mut self, ty: &mut P<ast::Ty>) {\n-        match ty.kind {\n-            ast::TyKind::MacCall(_) => {}\n-            _ => return noop_visit_ty(ty, self),\n-        };\n-\n-        visit_clobber(ty, |mut ty| match mem::replace(&mut ty.kind, ast::TyKind::Err) {\n-            ast::TyKind::MacCall(mac) => self.collect_bang(mac, AstFragmentKind::Ty).make_ty(),\n-            _ => unreachable!(),\n-        });\n+    fn visit_pat(&mut self, node: &mut P<ast::Pat>) {\n+        self.visit_node(node)\n     }\n \n-    fn flat_map_foreign_item(\n-        &mut self,\n-        foreign_item: P<ast::ForeignItem>,\n-    ) -> SmallVec<[P<ast::ForeignItem>; 1]> {\n-        let mut foreign_item = configure!(self, foreign_item);\n-\n-        if let Some(attr) = self.take_first_attr(&mut foreign_item) {\n-            return self\n-                .collect_attr(\n-                    attr,\n-                    Annotatable::ForeignItem(foreign_item),\n-                    AstFragmentKind::ForeignItems,\n-                )\n-                .make_foreign_items();\n-        }\n-\n-        match foreign_item.kind {\n-            ast::ForeignItemKind::MacCall(ref mac) => {\n-                self.check_attributes(&foreign_item.attrs, &mac);\n-                foreign_item.and_then(|item| match item.kind {\n-                    ast::ForeignItemKind::MacCall(mac) => {\n-                        self.collect_bang(mac, AstFragmentKind::ForeignItems).make_foreign_items()\n-                    }\n-                    _ => unreachable!(),\n-                })\n-            }\n-            _ => {\n-                assign_id!(self, &mut foreign_item.id, || noop_flat_map_foreign_item(\n-                    foreign_item,\n-                    self\n-                ))\n-            }\n-        }\n+    fn visit_expr(&mut self, node: &mut P<ast::Expr>) {\n+        self.cfg.configure_expr(node);\n+        self.visit_node(node)\n     }\n \n-    fn flat_map_generic_param(\n-        &mut self,\n-        param: ast::GenericParam,\n-    ) -> SmallVec<[ast::GenericParam; 1]> {\n-        let mut param = configure!(self, param);\n-\n-        if let Some(attr) = self.take_first_attr(&mut param) {\n-            return self\n-                .collect_attr(\n-                    attr,\n-                    Annotatable::GenericParam(param),\n-                    AstFragmentKind::GenericParams,\n-                )\n-                .make_generic_params();\n-        }\n+    fn filter_map_expr(&mut self, node: P<ast::Expr>) -> Option<P<ast::Expr>> {\n+        self.flat_map_node(AstLikeWrapper::new(node, OptExprTag))\n+    }\n \n-        assign_id!(self, &mut param.id, || noop_flat_map_generic_param(param, self))\n+    fn visit_block(&mut self, node: &mut P<Block>) {\n+        let orig_dir_ownership = mem::replace(\n+            &mut self.cx.current_expansion.dir_ownership,\n+            DirOwnership::UnownedViaBlock,\n+        );\n+        noop_visit_block(node, self);\n+        self.cx.current_expansion.dir_ownership = orig_dir_ownership;\n     }\n \n     fn visit_id(&mut self, id: &mut ast::NodeId) {"}, {"sha": "5599c1df6d9de3c0011d353075a39d8b4f252412", "filename": "compiler/rustc_expand/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/800ba8f8e862d72707200f77a51981de62f38b3a/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800ba8f8e862d72707200f77a51981de62f38b3a/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Flib.rs?ref=800ba8f8e862d72707200f77a51981de62f38b3a", "patch": "@@ -1,3 +1,5 @@\n+#![feature(associated_type_bounds)]\n+#![feature(associated_type_defaults)]\n #![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]\n #![cfg_attr(bootstrap, feature(destructuring_assignment))]"}]}