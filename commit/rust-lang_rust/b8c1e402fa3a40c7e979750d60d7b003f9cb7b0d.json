{"sha": "b8c1e402fa3a40c7e979750d60d7b003f9cb7b0d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4YzFlNDAyZmEzYTQwYzdlOTc5NzUwZDYwZDdiMDAzZjljYjdiMGQ=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-09-03T11:10:00Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-09-03T12:00:35Z"}, "message": "Make type walking infrastructure a bit nicer\n\nIf/when we switch to using Chalk's Ty, we'll need to replace this by its `Fold`\ntrait, but I didn't want to import the whole thing just yet.", "tree": {"sha": "ddd1737a8e3f46fb8757bad1d8024469d3bf0a89", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ddd1737a8e3f46fb8757bad1d8024469d3bf0a89"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8c1e402fa3a40c7e979750d60d7b003f9cb7b0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8c1e402fa3a40c7e979750d60d7b003f9cb7b0d", "html_url": "https://github.com/rust-lang/rust/commit/b8c1e402fa3a40c7e979750d60d7b003f9cb7b0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8c1e402fa3a40c7e979750d60d7b003f9cb7b0d/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4fcfa2b0d516b9790fa8abdf96bb2308657d60a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4fcfa2b0d516b9790fa8abdf96bb2308657d60a", "html_url": "https://github.com/rust-lang/rust/commit/c4fcfa2b0d516b9790fa8abdf96bb2308657d60a"}], "stats": {"total": 269, "additions": 134, "deletions": 135}, "files": [{"sha": "1fad5b23393f810723f942186fd299fbf007a887", "filename": "crates/ra_cli/src/analysis_stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8c1e402fa3a40c7e979750d60d7b003f9cb7b0d/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c1e402fa3a40c7e979750d60d7b003f9cb7b0d/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs?ref=b8c1e402fa3a40c7e979750d60d7b003f9cb7b0d", "patch": "@@ -1,7 +1,7 @@\n use std::{collections::HashSet, fmt::Write, path::Path, time::Instant};\n \n use ra_db::SourceDatabase;\n-use ra_hir::{Crate, HasBodySource, HasSource, HirDisplay, ImplItem, ModuleDef, Ty};\n+use ra_hir::{Crate, HasBodySource, HasSource, HirDisplay, ImplItem, ModuleDef, Ty, TypeWalk};\n use ra_syntax::AstNode;\n \n use crate::Result;"}, {"sha": "c3e5899216fce23213d731a46f5a57806cbb3f0d", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8c1e402fa3a40c7e979750d60d7b003f9cb7b0d/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c1e402fa3a40c7e979750d60d7b003f9cb7b0d/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=b8c1e402fa3a40c7e979750d60d7b003f9cb7b0d", "patch": "@@ -69,7 +69,9 @@ pub use self::{\n     resolve::Resolution,\n     source_binder::{PathResolution, ScopeEntryWithSyntax, SourceAnalyzer},\n     source_id::{AstIdMap, ErasedFileAstId},\n-    ty::{display::HirDisplay, ApplicationTy, CallableDef, Substs, TraitRef, Ty, TypeCtor},\n+    ty::{\n+        display::HirDisplay, ApplicationTy, CallableDef, Substs, TraitRef, Ty, TypeCtor, TypeWalk,\n+    },\n     type_ref::Mutability,\n };\n "}, {"sha": "a3df0882783653533416c1fe0d0613c31599dd04", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 120, "deletions": 113, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/b8c1e402fa3a40c7e979750d60d7b003f9cb7b0d/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c1e402fa3a40c7e979750d60d7b003f9cb7b0d/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=b8c1e402fa3a40c7e979750d60d7b003f9cb7b0d", "patch": "@@ -130,12 +130,14 @@ impl ProjectionTy {\n             substs: self.parameters.clone(),\n         }\n     }\n+}\n \n-    pub fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+impl TypeWalk for ProjectionTy {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n         self.parameters.walk(f);\n     }\n \n-    pub fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n+    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n         self.parameters.walk_mut(f);\n     }\n }\n@@ -146,12 +148,12 @@ pub struct UnselectedProjectionTy {\n     pub parameters: Substs,\n }\n \n-impl UnselectedProjectionTy {\n-    pub fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+impl TypeWalk for UnselectedProjectionTy {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n         self.parameters.walk(f);\n     }\n \n-    pub fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n+    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n         self.parameters.walk_mut(f);\n     }\n }\n@@ -312,20 +314,14 @@ impl TraitRef {\n     pub fn self_ty(&self) -> &Ty {\n         &self.substs[0]\n     }\n+}\n \n-    pub fn subst(mut self, substs: &Substs) -> TraitRef {\n-        self.substs.walk_mut(&mut |ty_mut| {\n-            let ty = mem::replace(ty_mut, Ty::Unknown);\n-            *ty_mut = ty.subst(substs);\n-        });\n-        self\n-    }\n-\n-    pub fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+impl TypeWalk for TraitRef {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n         self.substs.walk(f);\n     }\n \n-    pub fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n+    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n         self.substs.walk_mut(f);\n     }\n }\n@@ -365,28 +361,18 @@ impl GenericPredicate {\n             GenericPredicate::Error => None,\n         }\n     }\n+}\n \n-    pub fn subst(self, substs: &Substs) -> GenericPredicate {\n-        match self {\n-            GenericPredicate::Implemented(trait_ref) => {\n-                GenericPredicate::Implemented(trait_ref.subst(substs))\n-            }\n-            GenericPredicate::Projection(projection_predicate) => {\n-                GenericPredicate::Projection(projection_predicate.subst(substs))\n-            }\n-            GenericPredicate::Error => self,\n-        }\n-    }\n-\n-    pub fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+impl TypeWalk for GenericPredicate {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n         match self {\n             GenericPredicate::Implemented(trait_ref) => trait_ref.walk(f),\n             GenericPredicate::Projection(projection_pred) => projection_pred.walk(f),\n             GenericPredicate::Error => {}\n         }\n     }\n \n-    pub fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n+    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n         match self {\n             GenericPredicate::Implemented(trait_ref) => trait_ref.walk_mut(f),\n             GenericPredicate::Projection(projection_pred) => projection_pred.walk_mut(f),\n@@ -430,16 +416,16 @@ impl FnSig {\n     pub fn ret(&self) -> &Ty {\n         &self.params_and_return[self.params_and_return.len() - 1]\n     }\n+}\n \n-    /// Applies the given substitutions to all types in this signature and\n-    /// returns the result.\n-    pub fn subst(&self, substs: &Substs) -> FnSig {\n-        let result: Vec<_> =\n-            self.params_and_return.iter().map(|ty| ty.clone().subst(substs)).collect();\n-        FnSig { params_and_return: result.into() }\n+impl TypeWalk for FnSig {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        for t in self.params_and_return.iter() {\n+            t.walk(f);\n+        }\n     }\n \n-    pub fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n+    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n         // Without an Arc::make_mut_slice, we can't avoid the clone here:\n         let mut v: Vec<_> = self.params_and_return.iter().cloned().collect();\n         for t in &mut v {\n@@ -463,64 +449,6 @@ impl Ty {\n         Ty::apply(TypeCtor::Tuple { cardinality: 0 }, Substs::empty())\n     }\n \n-    pub fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        match self {\n-            Ty::Apply(a_ty) => {\n-                for t in a_ty.parameters.iter() {\n-                    t.walk(f);\n-                }\n-            }\n-            Ty::Projection(p_ty) => {\n-                for t in p_ty.parameters.iter() {\n-                    t.walk(f);\n-                }\n-            }\n-            Ty::UnselectedProjection(p_ty) => {\n-                for t in p_ty.parameters.iter() {\n-                    t.walk(f);\n-                }\n-            }\n-            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n-                for p in predicates.iter() {\n-                    p.walk(f);\n-                }\n-            }\n-            Ty::Param { .. } | Ty::Bound(_) | Ty::Infer(_) | Ty::Unknown => {}\n-        }\n-        f(self);\n-    }\n-\n-    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n-        match self {\n-            Ty::Apply(a_ty) => {\n-                a_ty.parameters.walk_mut(f);\n-            }\n-            Ty::Projection(p_ty) => {\n-                p_ty.parameters.walk_mut(f);\n-            }\n-            Ty::UnselectedProjection(p_ty) => {\n-                p_ty.parameters.walk_mut(f);\n-            }\n-            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n-                let mut v: Vec<_> = predicates.iter().cloned().collect();\n-                for p in &mut v {\n-                    p.walk_mut(f);\n-                }\n-                *predicates = v.into();\n-            }\n-            Ty::Param { .. } | Ty::Bound(_) | Ty::Infer(_) | Ty::Unknown => {}\n-        }\n-        f(self);\n-    }\n-\n-    fn fold(mut self, f: &mut impl FnMut(Ty) -> Ty) -> Ty {\n-        self.walk_mut(&mut |ty_mut| {\n-            let ty = mem::replace(ty_mut, Ty::Unknown);\n-            *ty_mut = f(ty);\n-        });\n-        self\n-    }\n-\n     pub fn as_reference(&self) -> Option<(&Ty, Mutability)> {\n         match self {\n             Ty::Apply(ApplicationTy { ctor: TypeCtor::Ref(mutability), parameters }) => {\n@@ -596,10 +524,53 @@ impl Ty {\n         }\n     }\n \n+    /// Returns the type parameters of this type if it has some (i.e. is an ADT\n+    /// or function); so if `self` is `Option<u32>`, this returns the `u32`.\n+    pub fn substs(&self) -> Option<Substs> {\n+        match self {\n+            Ty::Apply(ApplicationTy { parameters, .. }) => Some(parameters.clone()),\n+            _ => None,\n+        }\n+    }\n+\n+    /// If this is an `impl Trait` or `dyn Trait`, returns that trait.\n+    pub fn inherent_trait(&self) -> Option<Trait> {\n+        match self {\n+            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n+                predicates.iter().find_map(|pred| match pred {\n+                    GenericPredicate::Implemented(tr) => Some(tr.trait_),\n+                    _ => None,\n+                })\n+            }\n+            _ => None,\n+        }\n+    }\n+}\n+\n+/// This allows walking structures that contain types to do something with those\n+/// types, similar to Chalk's `Fold` trait.\n+pub trait TypeWalk {\n+    fn walk(&self, f: &mut impl FnMut(&Ty));\n+    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty));\n+\n+    fn fold(mut self, f: &mut impl FnMut(Ty) -> Ty) -> Self\n+    where\n+        Self: Sized,\n+    {\n+        self.walk_mut(&mut |ty_mut| {\n+            let ty = mem::replace(ty_mut, Ty::Unknown);\n+            *ty_mut = f(ty);\n+        });\n+        self\n+    }\n+\n     /// Replaces type parameters in this type using the given `Substs`. (So e.g.\n     /// if `self` is `&[T]`, where type parameter T has index 0, and the\n     /// `Substs` contain `u32` at index 0, we'll have `&[u32]` afterwards.)\n-    pub fn subst(self, substs: &Substs) -> Ty {\n+    fn subst(self, substs: &Substs) -> Self\n+    where\n+        Self: Sized,\n+    {\n         self.fold(&mut |ty| match ty {\n             Ty::Param { idx, name } => {\n                 substs.get(idx as usize).cloned().unwrap_or(Ty::Param { idx, name })\n@@ -609,24 +580,21 @@ impl Ty {\n     }\n \n     /// Substitutes `Ty::Bound` vars (as opposed to type parameters).\n-    pub fn subst_bound_vars(self, substs: &Substs) -> Ty {\n+    fn subst_bound_vars(self, substs: &Substs) -> Self\n+    where\n+        Self: Sized,\n+    {\n         self.fold(&mut |ty| match ty {\n             Ty::Bound(idx) => substs.get(idx as usize).cloned().unwrap_or_else(|| Ty::Bound(idx)),\n             ty => ty,\n         })\n     }\n \n-    /// Returns the type parameters of this type if it has some (i.e. is an ADT\n-    /// or function); so if `self` is `Option<u32>`, this returns the `u32`.\n-    pub fn substs(&self) -> Option<Substs> {\n-        match self {\n-            Ty::Apply(ApplicationTy { parameters, .. }) => Some(parameters.clone()),\n-            _ => None,\n-        }\n-    }\n-\n     /// Shifts up `Ty::Bound` vars by `n`.\n-    pub fn shift_bound_vars(self, n: i32) -> Ty {\n+    fn shift_bound_vars(self, n: i32) -> Self\n+    where\n+        Self: Sized,\n+    {\n         self.fold(&mut |ty| match ty {\n             Ty::Bound(idx) => {\n                 assert!(idx as i32 >= -n);\n@@ -635,18 +603,57 @@ impl Ty {\n             ty => ty,\n         })\n     }\n+}\n \n-    /// If this is an `impl Trait` or `dyn Trait`, returns that trait.\n-    pub fn inherent_trait(&self) -> Option<Trait> {\n+impl TypeWalk for Ty {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n         match self {\n+            Ty::Apply(a_ty) => {\n+                for t in a_ty.parameters.iter() {\n+                    t.walk(f);\n+                }\n+            }\n+            Ty::Projection(p_ty) => {\n+                for t in p_ty.parameters.iter() {\n+                    t.walk(f);\n+                }\n+            }\n+            Ty::UnselectedProjection(p_ty) => {\n+                for t in p_ty.parameters.iter() {\n+                    t.walk(f);\n+                }\n+            }\n             Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n-                predicates.iter().find_map(|pred| match pred {\n-                    GenericPredicate::Implemented(tr) => Some(tr.trait_),\n-                    _ => None,\n-                })\n+                for p in predicates.iter() {\n+                    p.walk(f);\n+                }\n             }\n-            _ => None,\n+            Ty::Param { .. } | Ty::Bound(_) | Ty::Infer(_) | Ty::Unknown => {}\n+        }\n+        f(self);\n+    }\n+\n+    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n+        match self {\n+            Ty::Apply(a_ty) => {\n+                a_ty.parameters.walk_mut(f);\n+            }\n+            Ty::Projection(p_ty) => {\n+                p_ty.parameters.walk_mut(f);\n+            }\n+            Ty::UnselectedProjection(p_ty) => {\n+                p_ty.parameters.walk_mut(f);\n+            }\n+            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n+                let mut v: Vec<_> = predicates.iter().cloned().collect();\n+                for p in &mut v {\n+                    p.walk_mut(f);\n+                }\n+                *predicates = v.into();\n+            }\n+            Ty::Param { .. } | Ty::Bound(_) | Ty::Infer(_) | Ty::Unknown => {}\n         }\n+        f(self);\n     }\n }\n "}, {"sha": "08f52a53bc0627f3298de2be009116cd2c4d467c", "filename": "crates/ra_hir/src/ty/autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8c1e402fa3a40c7e979750d60d7b003f9cb7b0d/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c1e402fa3a40c7e979750d60d7b003f9cb7b0d/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs?ref=b8c1e402fa3a40c7e979750d60d7b003f9cb7b0d", "patch": "@@ -7,7 +7,7 @@ use std::iter::successors;\n \n use log::{info, warn};\n \n-use super::{traits::Solution, Canonical, Ty};\n+use super::{traits::Solution, Canonical, Ty, TypeWalk};\n use crate::{HasGenericParams, HirDatabase, Name, Resolver};\n \n const AUTODEREF_RECURSION_LIMIT: usize = 10;"}, {"sha": "ec3b7ffefff79fb2978c53b11d0df1286cc07c6c", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8c1e402fa3a40c7e979750d60d7b003f9cb7b0d/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c1e402fa3a40c7e979750d60d7b003f9cb7b0d/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=b8c1e402fa3a40c7e979750d60d7b003f9cb7b0d", "patch": "@@ -30,7 +30,7 @@ use super::{\n     autoderef, lower, method_resolution, op, primitive,\n     traits::{Guidance, Obligation, ProjectionPredicate, Solution},\n     ApplicationTy, CallableDef, InEnvironment, ProjectionTy, Substs, TraitEnvironment, TraitRef,\n-    Ty, TypableDef, TypeCtor,\n+    Ty, TypableDef, TypeCtor, TypeWalk,\n };\n use crate::{\n     adt::VariantDef,"}, {"sha": "9a0d2d8f9ca50626fc91001b79169351f79e941a", "filename": "crates/ra_hir/src/ty/infer/unify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8c1e402fa3a40c7e979750d60d7b003f9cb7b0d/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c1e402fa3a40c7e979750d60d7b003f9cb7b0d/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs?ref=b8c1e402fa3a40c7e979750d60d7b003f9cb7b0d", "patch": "@@ -3,7 +3,7 @@\n use super::{InferenceContext, Obligation};\n use crate::db::HirDatabase;\n use crate::ty::{\n-    Canonical, InEnvironment, InferTy, ProjectionPredicate, ProjectionTy, TraitRef, Ty,\n+    Canonical, InEnvironment, InferTy, ProjectionPredicate, ProjectionTy, TraitRef, Ty, TypeWalk,\n };\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {"}, {"sha": "f6f0137cffa3bf1747a25aed5e84be00368d6a84", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8c1e402fa3a40c7e979750d60d7b003f9cb7b0d/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c1e402fa3a40c7e979750d60d7b003f9cb7b0d/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=b8c1e402fa3a40c7e979750d60d7b003f9cb7b0d", "patch": "@@ -10,6 +10,7 @@ use std::sync::Arc;\n \n use super::{\n     FnSig, GenericPredicate, ProjectionPredicate, ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n+    TypeWalk,\n };\n use crate::{\n     adt::VariantDef,"}, {"sha": "6e0271a9666c03821742299f29ddda89217c6682", "filename": "crates/ra_hir/src/ty/traits.rs", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b8c1e402fa3a40c7e979750d60d7b003f9cb7b0d/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c1e402fa3a40c7e979750d60d7b003f9cb7b0d/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs?ref=b8c1e402fa3a40c7e979750d60d7b003f9cb7b0d", "patch": "@@ -8,7 +8,7 @@ use ra_db::salsa;\n use ra_prof::profile;\n use rustc_hash::FxHashSet;\n \n-use super::{Canonical, GenericPredicate, HirDisplay, ProjectionTy, TraitRef, Ty};\n+use super::{Canonical, GenericPredicate, HirDisplay, ProjectionTy, TraitRef, Ty, TypeWalk};\n use crate::{db::HirDatabase, Crate, ImplBlock, Trait};\n \n use self::chalk::{from_chalk, ToChalk};\n@@ -138,25 +138,13 @@ pub struct ProjectionPredicate {\n     pub ty: Ty,\n }\n \n-impl ProjectionPredicate {\n-    pub fn subst(mut self, substs: &super::Substs) -> ProjectionPredicate {\n-        self.walk_mut(&mut |ty| match ty {\n-            Ty::Param { idx, .. } => {\n-                if let Some(t) = substs.get(*idx as usize).cloned() {\n-                    *ty = t;\n-                }\n-            }\n-            _ => {}\n-        });\n-        self\n-    }\n-\n-    pub fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+impl TypeWalk for ProjectionPredicate {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n         self.projection_ty.walk(f);\n         self.ty.walk(f);\n     }\n \n-    pub fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n+    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n         self.projection_ty.walk_mut(f);\n         self.ty.walk_mut(f);\n     }"}, {"sha": "c201c5e50e751cb15a5026c75096ae53a92b21c7", "filename": "crates/ra_hir/src/ty/traits/chalk.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8c1e402fa3a40c7e979750d60d7b003f9cb7b0d/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c1e402fa3a40c7e979750d60d7b003f9cb7b0d/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs?ref=b8c1e402fa3a40c7e979750d60d7b003f9cb7b0d", "patch": "@@ -19,6 +19,7 @@ use crate::{\n     ty::display::HirDisplay,\n     ty::{\n         ApplicationTy, CallableDef, GenericPredicate, ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n+        TypeWalk,\n     },\n     Crate, HasGenericParams, ImplBlock, ImplItem, Trait, TypeAlias,\n };"}, {"sha": "db7e8348e1e1a4edb0cd26e600abe169ae8c06e3", "filename": "crates/ra_ide_api/src/completion/presentation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8c1e402fa3a40c7e979750d60d7b003f9cb7b0d/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fpresentation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c1e402fa3a40c7e979750d60d7b003f9cb7b0d/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fpresentation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fpresentation.rs?ref=b8c1e402fa3a40c7e979750d60d7b003f9cb7b0d", "patch": "@@ -1,5 +1,5 @@\n //! This modules takes care of rendering various defenitions as completion items.\n-use hir::{Docs, HasSource, HirDisplay, PerNs, Resolution, Ty};\n+use hir::{Docs, HasSource, HirDisplay, PerNs, Resolution, Ty, TypeWalk};\n use join_to_string::join;\n use ra_syntax::ast::NameOwner;\n use test_utils::tested_by;"}]}