{"sha": "54f6bf57e69153dc1bd0b2a5f6a09892ba35f036", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0ZjZiZjU3ZTY5MTUzZGMxYmQwYjJhNWY2YTA5ODkyYmEzNWYwMzY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-01-18T04:59:49Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-01-19T01:20:46Z"}, "message": "remove align_mode and rewrite GEP_tup_like to align correctly\n\nAlthough the old version of GEP_tup_like was incorrect in some\ncases, I do not believe we ever used it in an incorrect fashion.\nIn particular, it could go wrong with extended index sequences\nlike [0, 1, 3], but as near as I can tell we only ever use it\nwith short sequences like [0, i].", "tree": {"sha": "448cb7c32fa9e3af0a6fc01d3f88a39a59c96a26", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/448cb7c32fa9e3af0a6fc01d3f88a39a59c96a26"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54f6bf57e69153dc1bd0b2a5f6a09892ba35f036", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54f6bf57e69153dc1bd0b2a5f6a09892ba35f036", "html_url": "https://github.com/rust-lang/rust/commit/54f6bf57e69153dc1bd0b2a5f6a09892ba35f036", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54f6bf57e69153dc1bd0b2a5f6a09892ba35f036/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da828747e6d291f92046b6333ba2bca71ca58752", "url": "https://api.github.com/repos/rust-lang/rust/commits/da828747e6d291f92046b6333ba2bca71ca58752", "html_url": "https://github.com/rust-lang/rust/commit/da828747e6d291f92046b6333ba2bca71ca58752"}], "stats": {"total": 179, "additions": 82, "deletions": 97}, "files": [{"sha": "a4fbb78e1144ab360f414d458f23387811269a83", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/54f6bf57e69153dc1bd0b2a5f6a09892ba35f036/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f6bf57e69153dc1bd0b2a5f6a09892ba35f036/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=54f6bf57e69153dc1bd0b2a5f6a09892ba35f036", "patch": "@@ -505,9 +505,9 @@ fn gen_tag_shapes(ccx: @crate_ctxt) -> ValueRef {\n     let info_sz = 0u16;\n     for did_: ast::def_id in ccx.shape_cx.tag_order {\n         let did = did_; // Satisfy alias checker.\n-        let variants = ty::tag_variants(ccx.tcx, did);\n+        let num_variants = vec::len(*ty::tag_variants(ccx.tcx, did)) as u16;\n         add_u16(header, header_sz + info_sz);\n-        info_sz += 2u16 * ((vec::len(*variants) as u16) + 2u16) + 3u16;\n+        info_sz += 2u16 * (num_variants + 2u16) + 3u16;\n     }\n \n     // Construct the info tables, which contain offsets to the shape of each"}, {"sha": "13d17eecb8347b54b3e0e1492b25494a6cd42102", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 57, "deletions": 91, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/54f6bf57e69153dc1bd0b2a5f6a09892ba35f036/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f6bf57e69153dc1bd0b2a5f6a09892ba35f036/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=54f6bf57e69153dc1bd0b2a5f6a09892ba35f036", "patch": "@@ -412,20 +412,15 @@ fn llalign_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n }\n \n fn size_of(cx: @block_ctxt, t: ty::t) -> result {\n-    size_of_(cx, t, align_total)\n+    size_of_(cx, t)\n }\n \n-tag align_mode {\n-    align_total;\n-    align_next(ty::t);\n-}\n-\n-fn size_of_(cx: @block_ctxt, t: ty::t, mode: align_mode) -> result {\n+fn size_of_(cx: @block_ctxt, t: ty::t) -> result {\n     let ccx = bcx_ccx(cx);\n     if check type_has_static_size(ccx, t) {\n         let sp = cx.sp;\n         rslt(cx, llsize_of(bcx_ccx(cx), type_of(ccx, sp, t)))\n-    } else { dynamic_size_of(cx, t, mode) }\n+    } else { dynamic_size_of(cx, t) }\n }\n \n fn align_of(cx: @block_ctxt, t: ty::t) -> result {\n@@ -536,9 +531,8 @@ fn static_size_of_tag(cx: @crate_ctxt, sp: span, t: ty::t)\n     }\n }\n \n-fn dynamic_size_of(cx: @block_ctxt, t: ty::t, mode: align_mode) -> result {\n-    fn align_elements(cx: @block_ctxt, elts: [ty::t],\n-                      mode: align_mode) -> result {\n+fn dynamic_size_of(cx: @block_ctxt, t: ty::t) -> result {\n+    fn align_elements(cx: @block_ctxt, elts: [ty::t]) -> result {\n         //\n         // C padding rules:\n         //\n@@ -560,15 +554,16 @@ fn dynamic_size_of(cx: @block_ctxt, t: ty::t, mode: align_mode) -> result {\n             off = Add(bcx, aligned_off, elt_size.val);\n             max_align = umax(bcx, max_align, elt_align.val);\n         }\n-        off = alt mode {\n-          align_total. {\n-            align_to(bcx, off, max_align)\n-          }\n-          align_next(t) {\n-            let {bcx, val: align} = align_of(bcx, t);\n-            align_to(bcx, off, align)\n-          }\n-        };\n+        off = align_to(bcx, off, max_align);\n+        //off = alt mode {\n+        //  align_total. {\n+        //    align_to(bcx, off, max_align)\n+        //  }\n+        //  align_next(t) {\n+        //    let {bcx, val: align} = align_of(bcx, t);\n+        //    align_to(bcx, off, align)\n+        //  }\n+        //};\n         ret rslt(bcx, off);\n     }\n     alt ty::struct(bcx_tcx(cx), t) {\n@@ -579,12 +574,12 @@ fn dynamic_size_of(cx: @block_ctxt, t: ty::t, mode: align_mode) -> result {\n       ty::ty_rec(flds) {\n         let tys: [ty::t] = [];\n         for f: ty::field in flds { tys += [f.mt.ty]; }\n-        ret align_elements(cx, tys, mode);\n+        ret align_elements(cx, tys);\n       }\n       ty::ty_tup(elts) {\n         let tys = [];\n         for tp in elts { tys += [tp]; }\n-        ret align_elements(cx, tys, mode);\n+        ret align_elements(cx, tys);\n       }\n       ty::ty_tag(tid, tps) {\n         let bcx = cx;\n@@ -603,7 +598,7 @@ fn dynamic_size_of(cx: @block_ctxt, t: ty::t, mode: align_mode) -> result {\n                 let t = ty::substitute_type_params(bcx_tcx(cx), tps, raw_ty);\n                 tys += [t];\n             }\n-            let rslt = align_elements(bcx, tys, mode);\n+            let rslt = align_elements(bcx, tys);\n             bcx = rslt.bcx;\n             let this_size = rslt.val;\n             let old_max_size = Load(bcx, max_size);\n@@ -689,84 +684,55 @@ fn GEP_tup_like_1(cx: @block_ctxt, t: ty::t, base: ValueRef, ixs: [int])\n // above.\n fn GEP_tup_like(bcx: @block_ctxt, t: ty::t, base: ValueRef, ixs: [int])\n     : type_is_tup_like(bcx, t) -> result {\n-    // It might be a static-known type. Handle this.\n-    if !ty::type_has_dynamic_size(bcx_tcx(bcx), t) {\n-        #debug[\"GEP_tup_like t=%? ixs=%? -> static\",\n-               ty_to_str(bcx_tcx(bcx), t), ixs];\n \n-        ret rslt(bcx, GEPi(bcx, base, ixs));\n-    }\n-    // It is a dynamic-containing type that, if we convert directly to an LLVM\n-    // TypeRef, will be all wrong; there's no proper LLVM type to represent\n-    // it, and the lowering function will stick in i8* values for each\n-    // ty_param, which is not right; the ty_params are all of some dynamic\n-    // size.\n-    //\n-    // What we must do instead is sadder. We must look through the indices\n-    // manually and split the input type into a prefix and a target. We then\n-    // measure the prefix size, bump the input pointer by that amount, and\n-    // cast to a pointer-to-target type.\n-\n-    // Given a type, an index vector and an element number N in that vector,\n-    // calculate index X and the type that results by taking the first X-1\n-    // elements of the type and splitting the Xth off. Return the prefix as\n-    // well as the innermost Xth type.\n-\n-    fn split_type(ccx: @crate_ctxt, t: ty::t, ixs: [int], n: uint) ->\n-       {prefix: [ty::t], target: ty::t} {\n-        let len: uint = vec::len::<int>(ixs);\n-        // We don't support 0-index or 1-index GEPs: The former is nonsense\n-        // and the latter would only be meaningful if we supported non-0\n-        // values for the 0th index (we don't).\n-\n-        assert (len > 1u);\n-        if n == 0u {\n-            // Since we're starting from a value that's a pointer to a\n-            // *single* structure, the first index (in GEP-ese) should just be\n-            // 0, to yield the pointee.\n-\n-            assert (ixs[n] == 0);\n-            ret split_type(ccx, t, ixs, n + 1u);\n+    fn compute_off(bcx: @block_ctxt,\n+                   off: ValueRef,\n+                   t: ty::t,\n+                   ixs: [int],\n+                   n: uint) -> (@block_ctxt, ValueRef, ty::t) {\n+        if n == vec::len(ixs) {\n+            ret (bcx, off, t);\n         }\n-        assert (n < len);\n-        let ix: int = ixs[n];\n-        let prefix: [ty::t] = [];\n-        let i: int = 0;\n-        while i < ix {\n-            prefix += [ty::get_element_type(ccx.tcx, t, i as uint)];\n-            i += 1;\n+\n+        let tcx = bcx_tcx(bcx);\n+        let ix = ixs[n];\n+        let bcx = bcx, off = off;\n+        int::range(0, ix) {|i|\n+            let comp_t = ty::get_element_type(tcx, t, i as uint);\n+            let align = align_of(bcx, comp_t);\n+            bcx = align.bcx;\n+            off = align_to(bcx, off, align.val);\n+            let sz = size_of(bcx, comp_t);\n+            bcx = sz.bcx;\n+            off = Add(bcx, off, sz.val);\n         }\n-        let selected = ty::get_element_type(ccx.tcx, t, i as uint);\n-        if n == len - 1u {\n-            // We are at the innermost index.\n \n-            ret {prefix: prefix, target: selected};\n-        } else {\n-            // Not the innermost index; call self recursively to dig deeper.\n-            // Once we get an inner result, append it current prefix and\n-            // return to caller.\n+        let comp_t = ty::get_element_type(tcx, t, ix as uint);\n+        let align = align_of(bcx, comp_t);\n+        bcx = align.bcx;\n+        off = align_to(bcx, off, align.val);\n \n-            let inner = split_type(ccx, selected, ixs, n + 1u);\n-            prefix += inner.prefix;\n-            ret {prefix: prefix with inner};\n-        }\n+        be compute_off(bcx, off, comp_t, ixs, n+1u);\n     }\n-    // We make a fake prefix tuple-type here; luckily for measuring sizes\n-    // the tuple parens are associative so it doesn't matter that we've\n-    // flattened the incoming structure.\n \n-    let s = split_type(bcx_ccx(bcx), t, ixs, 0u);\n+    if !ty::type_has_dynamic_size(bcx_tcx(bcx), t) {\n+        ret rslt(bcx, GEPi(bcx, base, ixs));\n+    }\n \n-    let args = [];\n-    for typ: ty::t in s.prefix { args += [typ]; }\n-    let prefix_ty = ty::mk_tup(bcx_tcx(bcx), args);\n+    #debug[\"GEP_tup_like(t=%s,base=%s,ixs=%?)\",\n+           ty_to_str(bcx_tcx(bcx), t),\n+           val_str(bcx_ccx(bcx).tn, base),\n+           ixs];\n \n-    #debug[\"GEP_tup_like t=%? ixs=%? prefix_ty=%?\",\n-           ty_to_str(bcx_tcx(bcx), t), ixs,\n-           ty_to_str(bcx_tcx(bcx), prefix_ty)];\n+    // We require that ixs start with 0 and we expect the input to be a\n+    // pointer to an instance of type t, so we can safely ignore ixs[0],\n+    // basically.\n+    assert ixs[0] == 0;\n \n-    let sz = size_of_(bcx, prefix_ty, align_next(s.target));\n-    ret rslt(sz.bcx, bump_ptr(sz.bcx, s.target, base, sz.val));\n+    let (bcx, off, tar_t) = {\n+        compute_off(bcx, C_int(bcx_ccx(bcx), 0), t, ixs, 1u)\n+    };\n+    ret rslt(bcx, bump_ptr(bcx, tar_t, base, off));\n }\n \n "}, {"sha": "fe7752994cf2c0ffd57c79bd141dcef42bd907a7", "filename": "src/comp/middle/trans_closure.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/54f6bf57e69153dc1bd0b2a5f6a09892ba35f036/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f6bf57e69153dc1bd0b2a5f6a09892ba35f036/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs?ref=54f6bf57e69153dc1bd0b2a5f6a09892ba35f036", "patch": "@@ -361,7 +361,8 @@ fn store_environment(\n         }\n \n         let bound_data = GEP_tup_like_1(bcx, cbox_ty, llbox,\n-                                        [0, abi::cbox_elt_bindings, i as int]);\n+                                        [0, abi::cbox_elt_bindings,\n+                                         i as int]);\n         bcx = bound_data.bcx;\n         let bound_data = bound_data.val;\n         alt bv {"}, {"sha": "88a25126168fe689967e16c91f4f6bff1054d57a", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/54f6bf57e69153dc1bd0b2a5f6a09892ba35f036/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f6bf57e69153dc1bd0b2a5f6a09892ba35f036/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=54f6bf57e69153dc1bd0b2a5f6a09892ba35f036", "patch": "@@ -869,8 +869,9 @@ fn get_element_type(cx: ctxt, ty: t, i: uint) -> t {\n       ty_rec(flds) { ret flds[i].mt.ty; }\n       ty_tup(ts) { ret ts[i]; }\n       _ {\n-        cx.sess.bug(\"get_element_type called on type \" + ty_to_str(cx, ty) +\n-                        \" - expected a tuple or record\");\n+        cx.sess.bug(\n+            #fmt[\"get_element_type called on invalid type %s with index %u\",\n+                 ty_to_str(cx, ty), i]);\n       }\n     }\n }"}, {"sha": "22acbf9882428cc135464a484c4925572de00b66", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/54f6bf57e69153dc1bd0b2a5f6a09892ba35f036/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/54f6bf57e69153dc1bd0b2a5f6a09892ba35f036/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=54f6bf57e69153dc1bd0b2a5f6a09892ba35f036", "patch": "@@ -142,5 +142,4 @@ mod lib {\n // indent-tabs-mode: nil\n // c-basic-offset: 4\n // buffer-file-coding-system: utf-8-unix\n-// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n // End:"}, {"sha": "5fa3f7facc6a4e90df0b87685aa447909a5d8036", "filename": "src/test/run-pass/close-over-big-then-small-data.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/54f6bf57e69153dc1bd0b2a5f6a09892ba35f036/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f6bf57e69153dc1bd0b2a5f6a09892ba35f036/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs?ref=54f6bf57e69153dc1bd0b2a5f6a09892ba35f036", "patch": "@@ -0,0 +1,18 @@\n+// If we use GEPi rathern than GEP_tup_like when\n+// storing closure data (as we used to do), the u64 would\n+// overwrite the u16.\n+\n+type pair<A,B> = {\n+    a: A, b: B\n+};\n+\n+fn f<A:copy>(a: A, b: u16) -> fn@() -> (A, u16) {\n+    fn@() -> (A, u16) { (a, b) }\n+}\n+\n+fn main() {\n+    let (a, b) = f(22_u64, 44u16)();\n+    #debug[\"a=%? b=%?\", a, b];\n+    assert a == 22u64;\n+    assert b == 44u16;\n+}"}]}