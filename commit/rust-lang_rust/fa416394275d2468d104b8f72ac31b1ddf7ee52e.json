{"sha": "fa416394275d2468d104b8f72ac31b1ddf7ee52e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhNDE2Mzk0Mjc1ZDI0NjhkMTA0YjhmNzJhYzMxYjFkZGY3ZWU1MmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-14T16:41:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-14T16:41:14Z"}, "message": "Auto merge of #77618 - fusion-engineering-forks:windows-parker, r=Amanieu\n\nAdd fast futex-based thread parker for Windows.\n\nThis adds a fast futex-based thread parker for Windows. It either uses WaitOnAddress+WakeByAddressSingle or NT Keyed Events (NtWaitForKeyedEvent+NtReleaseKeyedEvent), depending on which is available. Together, this makes this thread parker work for Windows XP and up. Before this change, park()/unpark() did not work on Windows XP: it needs condition variables, which only exist since Windows Vista.\n\n---\n\nUnfortunately, NT Keyed Events are an undocumented Windows API. However:\n- This API is relatively simple with obvious behaviour, and there are several (unofficial) articles documenting the details. [1]\n- parking_lot has been using this API for years (on Windows versions before Windows 8). [2] Many big projects extensively use parking_lot, such as servo and the Rust compiler itself.\n- It is the underlying API used by Windows SRW locks and Windows critical sections. [3] [4]\n- The source code of the implementations of Wine, ReactOs, and Windows XP are available and match the expected behaviour.\n- The main risk with an undocumented API is that it might change in the future. But since we only use it for older versions of Windows, that's not a problem.\n- Even if these functions do not block or wake as we expect (which is unlikely, see all previous points), this implementation would still be memory safe. The NT Keyed Events API is only used to sleep/block in the right place.\n\n[1]\\: http://www.locklessinc.com/articles/keyed_events/\n[2]\\: https://github.com/Amanieu/parking_lot/commit/43abbc964e\n[3]\\: https://docs.microsoft.com/en-us/archive/msdn-magazine/2012/november/windows-with-c-the-evolution-of-synchronization-in-windows-and-c\n[4]\\: Windows Internals, Part 1, ISBN 9780735671300\n\n---\n\nThe choice of fallback API is inspired by parking_lot(_core), but the implementation of this thread parker is different. While parking_lot has no use for a fast path (park() directly returning if unpark() was already called), this implementation has a fast path that returns without even checking which waiting/waking API to use, as the same atomic variable with compatible states is used in all cases.", "tree": {"sha": "2c0e46da09d2569e89b60b040760bdfc1f673082", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c0e46da09d2569e89b60b040760bdfc1f673082"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa416394275d2468d104b8f72ac31b1ddf7ee52e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa416394275d2468d104b8f72ac31b1ddf7ee52e", "html_url": "https://github.com/rust-lang/rust/commit/fa416394275d2468d104b8f72ac31b1ddf7ee52e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa416394275d2468d104b8f72ac31b1ddf7ee52e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f7762b4fcf47d36bf0718d5265a5c6ca7f33687", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f7762b4fcf47d36bf0718d5265a5c6ca7f33687", "html_url": "https://github.com/rust-lang/rust/commit/1f7762b4fcf47d36bf0718d5265a5c6ca7f33687"}, {"sha": "03fb61cfefc1436ac9dc50d3fa7d7e60146beadd", "url": "https://api.github.com/repos/rust-lang/rust/commits/03fb61cfefc1436ac9dc50d3fa7d7e60146beadd", "html_url": "https://github.com/rust-lang/rust/commit/03fb61cfefc1436ac9dc50d3fa7d7e60146beadd"}], "stats": {"total": 301, "additions": 301, "deletions": 0}, "files": [{"sha": "2b1bc92dc84ae34680ff51c19605150eb18ede84", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/fa416394275d2468d104b8f72ac31b1ddf7ee52e/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa416394275d2468d104b8f72ac31b1ddf7ee52e/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=fa416394275d2468d104b8f72ac31b1ddf7ee52e", "patch": "@@ -31,6 +31,8 @@ pub type WORD = u16;\n pub type CHAR = c_char;\n pub type ULONG_PTR = usize;\n pub type ULONG = c_ulong;\n+pub type NTSTATUS = LONG;\n+pub type ACCESS_MASK = DWORD;\n \n pub type LPBOOL = *mut BOOL;\n pub type LPBYTE = *mut BYTE;\n@@ -285,6 +287,8 @@ pub const STACK_SIZE_PARAM_IS_A_RESERVATION: DWORD = 0x00010000;\n \n pub const HEAP_ZERO_MEMORY: DWORD = 0x00000008;\n \n+pub const STATUS_SUCCESS: NTSTATUS = 0x00000000;\n+\n #[repr(C)]\n #[cfg(not(target_pointer_width = \"64\"))]\n pub struct WSADATA {\n@@ -1085,3 +1089,46 @@ compat_fn! {\n         panic!(\"rwlocks not available\")\n     }\n }\n+compat_fn! {\n+    \"api-ms-win-core-synch-l1-2-0\":\n+    pub fn WaitOnAddress(\n+        Address: LPVOID,\n+        CompareAddress: LPVOID,\n+        AddressSize: SIZE_T,\n+        dwMilliseconds: DWORD\n+    ) -> BOOL {\n+        panic!(\"WaitOnAddress not available\")\n+    }\n+    pub fn WakeByAddressSingle(Address: LPVOID) -> () {\n+        // If this api is unavailable, there cannot be anything waiting, because\n+        // WaitOnAddress would've panicked. So it's fine to do nothing here.\n+    }\n+}\n+\n+compat_fn! {\n+    \"ntdll\":\n+    pub fn NtCreateKeyedEvent(\n+        KeyedEventHandle: LPHANDLE,\n+        DesiredAccess: ACCESS_MASK,\n+        ObjectAttributes: LPVOID,\n+        Flags: ULONG\n+    ) -> NTSTATUS {\n+        panic!(\"keyed events not available\")\n+    }\n+    pub fn NtReleaseKeyedEvent(\n+        EventHandle: HANDLE,\n+        Key: LPVOID,\n+        Alertable: BOOLEAN,\n+        Timeout: PLARGE_INTEGER\n+    ) -> NTSTATUS {\n+        panic!(\"keyed events not available\")\n+    }\n+    pub fn NtWaitForKeyedEvent(\n+        EventHandle: HANDLE,\n+        Key: LPVOID,\n+        Alertable: BOOLEAN,\n+        Timeout: PLARGE_INTEGER\n+    ) -> NTSTATUS {\n+        panic!(\"keyed events not available\")\n+    }\n+}"}, {"sha": "e9588e297582535b7fa44353027a36e8f01b960f", "filename": "library/std/src/sys/windows/compat.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fa416394275d2468d104b8f72ac31b1ddf7ee52e/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa416394275d2468d104b8f72ac31b1ddf7ee52e/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs?ref=fa416394275d2468d104b8f72ac31b1ddf7ee52e", "patch": "@@ -34,6 +34,7 @@ macro_rules! compat_fn {\n     )*) => ($(\n         $(#[$meta])*\n         pub mod $symbol {\n+            #[allow(unused_imports)]\n             use super::*;\n             use crate::sync::atomic::{AtomicUsize, Ordering};\n             use crate::mem;"}, {"sha": "fcbff59dec0070bf94d40df9ec157d47528e83b2", "filename": "library/std/src/sys/windows/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fa416394275d2468d104b8f72ac31b1ddf7ee52e/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa416394275d2468d104b8f72ac31b1ddf7ee52e/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs?ref=fa416394275d2468d104b8f72ac31b1ddf7ee52e", "patch": "@@ -35,6 +35,7 @@ pub mod rwlock;\n pub mod thread;\n pub mod thread_local_dtor;\n pub mod thread_local_key;\n+pub mod thread_parker;\n pub mod time;\n cfg_if::cfg_if! {\n     if #[cfg(not(target_vendor = \"uwp\"))] {"}, {"sha": "701c6e2e9bec7ccac6fc2f3ec0c392e23e072fd7", "filename": "library/std/src/sys/windows/thread_parker.rs", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/fa416394275d2468d104b8f72ac31b1ddf7ee52e/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa416394275d2468d104b8f72ac31b1ddf7ee52e/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parker.rs?ref=fa416394275d2468d104b8f72ac31b1ddf7ee52e", "patch": "@@ -0,0 +1,250 @@\n+// Thread parker implementation for Windows.\n+//\n+// This uses WaitOnAddress and WakeByAddressSingle if available (Windows 8+).\n+// This modern API is exactly the same as the futex syscalls the Linux thread\n+// parker uses. When These APIs are available, the implementation of this\n+// thread parker matches the Linux thread parker exactly.\n+//\n+// However, when the modern API is not available, this implementation falls\n+// back to NT Keyed Events, which are similar, but have some important\n+// differences. These are available since Windows XP.\n+//\n+// WaitOnAddress first checks the state of the thread parker to make sure it no\n+// WakeByAddressSingle calls can be missed between updating the parker state\n+// and calling the function.\n+//\n+// NtWaitForKeyedEvent does not have this option, and unconditionally blocks\n+// without checking the parker state first. Instead, NtReleaseKeyedEvent\n+// (unlike WakeByAddressSingle) *blocks* until it woke up a thread waiting for\n+// it by NtWaitForKeyedEvent. This way, we can be sure no events are missed,\n+// but we need to be careful not to block unpark() if park_timeout() was woken\n+// up by a timeout instead of unpark().\n+//\n+// Unlike WaitOnAddress, NtWaitForKeyedEvent/NtReleaseKeyedEvent operate on a\n+// HANDLE (created with NtCreateKeyedEvent). This means that we can be sure\n+// a succesfully awoken park() was awoken by unpark() and not a\n+// NtReleaseKeyedEvent call from some other code, as these events are not only\n+// matched by the key (address of the parker (state)), but also by this HANDLE.\n+// We lazily allocate this handle the first time it is needed.\n+//\n+// The fast path (calling park() after unpark() was already called) and the\n+// possible states are the same for both implementations. This is used here to\n+// make sure the fast path does not even check which API to use, but can return\n+// right away, independent of the used API. Only the slow paths (which will\n+// actually block/wake a thread) check which API is available and have\n+// different implementations.\n+//\n+// Unfortunately, NT Keyed Events are an undocumented Windows API. However:\n+// - This API is relatively simple with obvious behaviour, and there are\n+//   several (unofficial) articles documenting the details. [1]\n+// - `parking_lot` has been using this API for years (on Windows versions\n+//   before Windows 8). [2] Many big projects extensively use parking_lot,\n+//   such as servo and the Rust compiler itself.\n+// - It is the underlying API used by Windows SRW locks and Windows critical\n+//   sections. [3] [4]\n+// - The source code of the implementations of Wine, ReactOs, and Windows XP\n+//   are available and match the expected behaviour.\n+// - The main risk with an undocumented API is that it might change in the\n+//   future. But since we only use it for older versions of Windows, that's not\n+//   a problem.\n+// - Even if these functions do not block or wake as we expect (which is\n+//   unlikely, see all previous points), this implementation would still be\n+//   memory safe. The NT Keyed Events API is only used to sleep/block in the\n+//   right place.\n+//\n+// [1]: http://www.locklessinc.com/articles/keyed_events/\n+// [2]: https://github.com/Amanieu/parking_lot/commit/43abbc964e\n+// [3]: https://docs.microsoft.com/en-us/archive/msdn-magazine/2012/november/windows-with-c-the-evolution-of-synchronization-in-windows-and-c\n+// [4]: Windows Internals, Part 1, ISBN 9780735671300\n+\n+use crate::convert::TryFrom;\n+use crate::ptr;\n+use crate::sync::atomic::{\n+    AtomicI8, AtomicUsize,\n+    Ordering::{Acquire, Relaxed, Release},\n+};\n+use crate::sys::{c, dur2timeout};\n+use crate::time::Duration;\n+\n+pub struct Parker {\n+    state: AtomicI8,\n+}\n+\n+const PARKED: i8 = -1;\n+const EMPTY: i8 = 0;\n+const NOTIFIED: i8 = 1;\n+\n+// Notes about memory ordering:\n+//\n+// Memory ordering is only relevant for the relative ordering of operations\n+// between different variables. Even Ordering::Relaxed guarantees a\n+// monotonic/consistent order when looking at just a single atomic variable.\n+//\n+// So, since this parker is just a single atomic variable, we only need to look\n+// at the ordering guarantees we need to provide to the 'outside world'.\n+//\n+// The only memory ordering guarantee that parking and unparking provide, is\n+// that things which happened before unpark() are visible on the thread\n+// returning from park() afterwards. Otherwise, it was effectively unparked\n+// before unpark() was called while still consuming the 'token'.\n+//\n+// In other words, unpark() needs to synchronize with the part of park() that\n+// consumes the token and returns.\n+//\n+// This is done with a release-acquire synchronization, by using\n+// Ordering::Release when writing NOTIFIED (the 'token') in unpark(), and using\n+// Ordering::Acquire when reading this state in park() after waking up.\n+impl Parker {\n+    pub fn new() -> Self {\n+        Self { state: AtomicI8::new(EMPTY) }\n+    }\n+\n+    // Assumes this is only called by the thread that owns the Parker,\n+    // which means that `self.state != PARKED`.\n+    pub unsafe fn park(&self) {\n+        // Change NOTIFIED=>EMPTY or EMPTY=>PARKED, and directly return in the\n+        // first case.\n+        if self.state.fetch_sub(1, Acquire) == NOTIFIED {\n+            return;\n+        }\n+\n+        if c::WaitOnAddress::is_available() {\n+            loop {\n+                // Wait for something to happen, assuming it's still set to PARKED.\n+                c::WaitOnAddress(self.ptr(), &PARKED as *const _ as c::LPVOID, 1, c::INFINITE);\n+                // Change NOTIFIED=>EMPTY but leave PARKED alone.\n+                if self.state.compare_and_swap(NOTIFIED, EMPTY, Acquire) == NOTIFIED {\n+                    // Actually woken up by unpark().\n+                    return;\n+                } else {\n+                    // Spurious wake up. We loop to try again.\n+                }\n+            }\n+        } else {\n+            // Wait for unpark() to produce this event.\n+            c::NtWaitForKeyedEvent(keyed_event_handle(), self.ptr(), 0, ptr::null_mut());\n+            // Set the state back to EMPTY (from either PARKED or NOTIFIED).\n+            // Note that we don't just write EMPTY, but use swap() to also\n+            // include an acquire-ordered read to synchronize with unpark()'s\n+            // release-ordered write.\n+            self.state.swap(EMPTY, Acquire);\n+        }\n+    }\n+\n+    // Assumes this is only called by the thread that owns the Parker,\n+    // which means that `self.state != PARKED`.\n+    pub unsafe fn park_timeout(&self, timeout: Duration) {\n+        // Change NOTIFIED=>EMPTY or EMPTY=>PARKED, and directly return in the\n+        // first case.\n+        if self.state.fetch_sub(1, Acquire) == NOTIFIED {\n+            return;\n+        }\n+\n+        if c::WaitOnAddress::is_available() {\n+            // Wait for something to happen, assuming it's still set to PARKED.\n+            c::WaitOnAddress(self.ptr(), &PARKED as *const _ as c::LPVOID, 1, dur2timeout(timeout));\n+            // Set the state back to EMPTY (from either PARKED or NOTIFIED).\n+            // Note that we don't just write EMPTY, but use swap() to also\n+            // include an acquire-ordered read to synchronize with unpark()'s\n+            // release-ordered write.\n+            if self.state.swap(EMPTY, Acquire) == NOTIFIED {\n+                // Actually woken up by unpark().\n+            } else {\n+                // Timeout or spurious wake up.\n+                // We return either way, because we can't easily tell if it was the\n+                // timeout or not.\n+            }\n+        } else {\n+            // Need to wait for unpark() using NtWaitForKeyedEvent.\n+            let handle = keyed_event_handle();\n+\n+            // NtWaitForKeyedEvent uses a unit of 100ns, and uses negative\n+            // values to indicate a relative time on the monotonic clock.\n+            // This is documented here for the underlying KeWaitForSingleObject function:\n+            // https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-kewaitforsingleobject\n+            let mut timeout = match i64::try_from((timeout.as_nanos() + 99) / 100) {\n+                Ok(t) => -t,\n+                Err(_) => i64::MIN,\n+            };\n+\n+            // Wait for unpark() to produce this event.\n+            let unparked =\n+                c::NtWaitForKeyedEvent(handle, self.ptr(), 0, &mut timeout) == c::STATUS_SUCCESS;\n+\n+            // Set the state back to EMPTY (from either PARKED or NOTIFIED).\n+            let prev_state = self.state.swap(EMPTY, Acquire);\n+\n+            if !unparked && prev_state == NOTIFIED {\n+                // We were awoken by a timeout, not by unpark(), but the state\n+                // was set to NOTIFIED, which means we *just* missed an\n+                // unpark(), which is now blocked on us to wait for it.\n+                // Wait for it to consume the event and unblock that thread.\n+                c::NtWaitForKeyedEvent(handle, self.ptr(), 0, ptr::null_mut());\n+            }\n+        }\n+    }\n+\n+    pub fn unpark(&self) {\n+        // Change PARKED=>NOTIFIED, EMPTY=>NOTIFIED, or NOTIFIED=>NOTIFIED, and\n+        // wake the thread in the first case.\n+        //\n+        // Note that even NOTIFIED=>NOTIFIED results in a write. This is on\n+        // purpose, to make sure every unpark() has a release-acquire ordering\n+        // with park().\n+        if self.state.swap(NOTIFIED, Release) == PARKED {\n+            if c::WakeByAddressSingle::is_available() {\n+                unsafe {\n+                    c::WakeByAddressSingle(self.ptr());\n+                }\n+            } else {\n+                // If we run NtReleaseKeyedEvent before the waiting thread runs\n+                // NtWaitForKeyedEvent, this (shortly) blocks until we can wake it up.\n+                // If the waiting thread wakes up before we run NtReleaseKeyedEvent\n+                // (e.g. due to a timeout), this blocks until we do wake up a thread.\n+                // To prevent this thread from blocking indefinitely in that case,\n+                // park_impl() will, after seeing the state set to NOTIFIED after\n+                // waking up, call NtWaitForKeyedEvent again to unblock us.\n+                unsafe {\n+                    c::NtReleaseKeyedEvent(keyed_event_handle(), self.ptr(), 0, ptr::null_mut());\n+                }\n+            }\n+        }\n+    }\n+\n+    fn ptr(&self) -> c::LPVOID {\n+        &self.state as *const _ as c::LPVOID\n+    }\n+}\n+\n+fn keyed_event_handle() -> c::HANDLE {\n+    const INVALID: usize = !0;\n+    static HANDLE: AtomicUsize = AtomicUsize::new(INVALID);\n+    match HANDLE.load(Relaxed) {\n+        INVALID => {\n+            let mut handle = c::INVALID_HANDLE_VALUE;\n+            unsafe {\n+                match c::NtCreateKeyedEvent(\n+                    &mut handle,\n+                    c::GENERIC_READ | c::GENERIC_WRITE,\n+                    ptr::null_mut(),\n+                    0,\n+                ) {\n+                    c::STATUS_SUCCESS => {}\n+                    r => panic!(\"Unable to create keyed event handle: error {}\", r),\n+                }\n+            }\n+            match HANDLE.compare_exchange(INVALID, handle as usize, Relaxed, Relaxed) {\n+                Ok(_) => handle,\n+                Err(h) => {\n+                    // Lost the race to another thread initializing HANDLE before we did.\n+                    // Closing our handle and using theirs instead.\n+                    unsafe {\n+                        c::CloseHandle(handle);\n+                    }\n+                    h as c::HANDLE\n+                }\n+            }\n+        }\n+        handle => handle as c::HANDLE,\n+    }\n+}"}, {"sha": "ba896bd676b673820fda276334377e85543ba8d9", "filename": "library/std/src/sys_common/thread_parker/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa416394275d2468d104b8f72ac31b1ddf7ee52e/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa416394275d2468d104b8f72ac31b1ddf7ee52e/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fmod.rs?ref=fa416394275d2468d104b8f72ac31b1ddf7ee52e", "patch": "@@ -6,6 +6,8 @@ cfg_if::cfg_if! {\n     ))] {\n         mod futex;\n         pub use futex::Parker;\n+    } else if #[cfg(windows)] {\n+        pub use crate::sys::thread_parker::Parker;\n     } else {\n         mod generic;\n         pub use generic::Parker;"}]}