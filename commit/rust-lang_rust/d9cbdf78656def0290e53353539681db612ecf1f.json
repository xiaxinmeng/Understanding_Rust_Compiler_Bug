{"sha": "d9cbdf78656def0290e53353539681db612ecf1f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5Y2JkZjc4NjU2ZGVmMDI5MGU1MzM1MzUzOTY4MWRiNjEyZWNmMWY=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lindsey@rockstargirl.org", "date": "2012-07-23T02:12:51Z"}, "committer": {"name": "Lindsey Kuper", "email": "lindsey@rockstargirl.org", "date": "2012-07-23T02:12:51Z"}, "message": "Tutorial revisions (among other things, closes #2990).", "tree": {"sha": "d2993251a64279ceaa2fdaedb6daf08d83712f9b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d2993251a64279ceaa2fdaedb6daf08d83712f9b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9cbdf78656def0290e53353539681db612ecf1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9cbdf78656def0290e53353539681db612ecf1f", "html_url": "https://github.com/rust-lang/rust/commit/d9cbdf78656def0290e53353539681db612ecf1f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9cbdf78656def0290e53353539681db612ecf1f/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9849c78c8eab60ec13dccf67198dc8a2f0ad9e3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/9849c78c8eab60ec13dccf67198dc8a2f0ad9e3a", "html_url": "https://github.com/rust-lang/rust/commit/9849c78c8eab60ec13dccf67198dc8a2f0ad9e3a"}], "stats": {"total": 148, "additions": 75, "deletions": 73}, "files": [{"sha": "559faffed3d557d0b5c78b55a776d98c2931a8db", "filename": "doc/tutorial.md", "status": "modified", "additions": 75, "deletions": 73, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/d9cbdf78656def0290e53353539681db612ecf1f/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/d9cbdf78656def0290e53353539681db612ecf1f/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=d9cbdf78656def0290e53353539681db612ecf1f", "patch": "@@ -15,28 +15,31 @@ the whole language, though not with the depth and precision of the\n \n Rust is a systems programming language with a focus on type safety,\n memory safety, concurrency and performance. It is intended for writing\n-large, high performance applications while preventing several classes\n+large, high-performance applications while preventing several classes\n of errors commonly found in languages like C++. Rust has a\n-sophisticated memory model that enables many of the efficient data\n-structures used in C++ while disallowing invalid memory access that\n-would otherwise cause segmentation faults. Like other systems\n-languages it is statically typed and compiled ahead of time.\n+sophisticated memory model that makes possible many of the efficient\n+data structures used in C++, while disallowing invalid memory accesses\n+that would otherwise cause segmentation faults. Like other systems\n+languages, it is statically typed and compiled ahead of time.\n \n-As a multi-paradigm language it has strong support for writing code in\n-procedural, functional and object-oriented styles. Some of it's nice\n+As a multi-paradigm language, Rust supports writing code in\n+procedural, functional and object-oriented styles. Some of its nice\n high-level features include:\n \n-* Pattern matching and algebraic data types (enums) - common in functional\n-  languages, pattern matching on ADTs provides a compact and expressive\n-  way to encode program logic\n-* Task-based concurrency - Rust uses lightweight tasks that do not share\n-  memory\n-* Higher-order functions - Closures in Rust are very powerful and used\n-  pervasively\n-* Polymorphism - Rust's type system features a unique combination of\n-  Java-style interfaces and Haskell-style typeclasses\n-* Generics - Functions and types can be parameterized over generic\n-  types with optional type constraints\n+* ***Pattern matching and algebraic data types (enums).*** Common in\n+  functional languages, pattern matching on ADTs provides a compact\n+  and expressive way to encode program logic.\n+* ***Task-based concurrency.*** Rust uses lightweight tasks that do\n+  not share memory.\n+* ***Higher-order functions.*** Rust functions may take closures as\n+  arguments or return closures as return values.  Closures in Rust are\n+  very powerful and used pervasively.\n+* ***Interface polymorphism.*** Rust's type system features a unique\n+  combination of Java-style interfaces and Haskell-style typeclasses.\n+* ***Parametric polymorphism (generics).*** Functions and types can be\n+  parameterized over type variables with optional type constraints.\n+* ***Type inference.*** Type annotations on local variable\n+  declarations can be omitted.\n \n ## First impressions\n \n@@ -229,7 +232,7 @@ into an error.\n \n ## Anatomy of a Rust program\n \n-In its simplest form, a Rust program is simply a `.rs` file with some\n+In its simplest form, a Rust program is a `.rs` file with some\n types and functions defined in it. If it has a `main` function, it can\n be compiled to an executable. Rust does not allow code that's not a\n declaration to appear at the top level of the file\u2014all statements must\n@@ -1181,61 +1184,60 @@ several of Rust's unique features as we encounter them.\n \n Rust has three competing goals that inform its view of memory:\n \n-* Memory safety - memory that is managed by and is accessible to\n-  the Rust language must be guaranteed to be valid. Under normal\n-  circumstances it is impossible for Rust to trigger a segmentation\n-  fault or leak memory\n-* Performance - high-performance low-level code tends to employ\n-  a number of allocation strategies. low-performance high-level\n-  code often uses a single, GC-based, heap allocation strategy\n-* Concurrency - Rust must maintain memory safety guarantees even\n-  for code running in parallel\n+* Memory safety: memory that is managed by and is accessible to the\n+  Rust language must be guaranteed to be valid; under normal\n+  circumstances it must be impossible for Rust to trigger a\n+  segmentation fault or leak memory\n+* Performance: high-performance low-level code must be able to employ\n+  a number of allocation strategies; low-performance high-level code\n+  must be able to employ a single, garbage-collection-based, heap\n+  allocation strategy\n+* Concurrency: Rust must maintain memory safety guarantees, even for\n+  code running in parallel\n \n ## How performance considerations influence the memory model\n \n-Many languages that ofter the kinds of memory safety guarentees that\n+Many languages that offer the kinds of memory safety guarantees that\n Rust does have a single allocation strategy: objects live on the heap,\n-live for as long as they are needed, and are periodically garbage\n-collected. This is very straightforword both conceptually and in\n-implementation, but has very significant costs. Such languages tend to\n-aggressively pursue ways to ameliorate allocation costs (think the\n-Java virtual machine). Rust supports this strategy with _shared\n-boxes_, memory allocated on the heap that may be referred to (shared)\n-by multiple variables.\n-\n-In comparison, languages like C++ offer a very precise control over\n-where objects are allocated. In particular, it is common to put\n-them directly on the stack, avoiding expensive heap allocation. In\n-Rust this is possible as well, and the compiler will use a clever\n-lifetime analysis to ensure that no variable can refer to stack\n+live for as long as they are needed, and are periodically\n+garbage-collected. This approach is straightforward both in concept\n+and in implementation, but has significant costs. Languages that take\n+this approach tend to aggressively pursue ways to ameliorate\n+allocation costs (think the Java Virtual Machine). Rust supports this\n+strategy with _shared boxes_: memory allocated on the heap that may be\n+referred to (shared) by multiple variables.\n+\n+By comparison, languages like C++ offer very precise control over\n+where objects are allocated. In particular, it is common to put them\n+directly on the stack, avoiding expensive heap allocation. In Rust\n+this is possible as well, and the compiler will use a clever _pointer\n+lifetime analysis_ to ensure that no variable can refer to stack\n objects after they are destroyed.\n \n ## How concurrency considerations influence the memory model\n \n-Memory safety in a concurrent environment tends to mean avoiding race\n+Memory safety in a concurrent environment involves avoiding race\n conditions between two threads of execution accessing the same\n-memory. Even high-level languages frequently avoid solving this\n-problem, requiring programmers to correctly employ locking to unsure\n-their program is free of races.\n-\n-Rust starts from the position that memory simply cannot be shared\n-between tasks. Experience in other languages has proven that isolating\n-each tasks' heap from each other is a reliable strategy and one that\n-is easy for programmers to reason about. Having isolated heaps\n-additionally means that garbage collection must only be done\n-per-heap. Rust never 'stops the world' to garbage collect memory.\n-\n-If Rust tasks have completely isolated heaps then that seems to imply\n-that any data transferred between them must be copied. While this\n-is a fine and useful way to implement communication between tasks,\n-it is also very inefficient for large data structures.\n-\n-Because of this Rust also introduces a global \"exchange heap\". Objects\n-allocated here have _ownership semantics_, meaning that there is only\n-a single variable that refers to them. For this reason they are\n-refered to as _unique boxes_. All tasks may allocate objects on this\n-heap, then transfer ownership of those allocations to other tasks,\n-avoiding expensive copies.\n+memory. Even high-level languages often require programmers to\n+correctly employ locking to ensure that a program is free of races.\n+\n+Rust starts from the position that memory cannot be shared between\n+tasks. Experience in other languages has proven that isolating each\n+task's heap from the others is a reliable strategy and one that is\n+easy for programmers to reason about. Heap isolation has the\n+additional benefit that garbage collection must only be done\n+per-heap. Rust never \"stops the world\" to garbage-collect memory.\n+\n+Complete isolation of heaps between tasks implies that any data\n+transferred between tasks must be copied. While this is a fine and\n+useful way to implement communication between tasks, it is also very\n+inefficient for large data structures.  Because of this, Rust also\n+employs a global _exchange heap_. Objects allocated in the exchange\n+heap have _ownership semantics_, meaning that there is only a single\n+variable that refers to them. For this reason, they are referred to as\n+_unique boxes_. All tasks may allocate objects on the exchange heap,\n+then transfer ownership of those objects to other tasks, avoiding\n+expensive copies.\n \n ## What to be aware of\n \n@@ -1249,11 +1251,11 @@ of each is key to using Rust effectively.\n # Boxes and pointers\n \n In contrast to a lot of modern languages, aggregate types like records\n-and enums are not represented as pointers to allocated memory. They\n-are, like in C and C++, represented directly. This means that if you\n-`let x = {x: 1f, y: 1f};`, you are creating a record on the stack. If\n-you then copy it into a data structure, the whole record is copied,\n-not just a pointer.\n+and enums are _not_ represented as pointers to allocated memory in\n+Rust. They are, as in C and C++, represented directly. This means that\n+if you `let x = {x: 1f, y: 1f};`, you are creating a record on the\n+stack. If you then copy it into a data structure, the whole record is\n+copied, not just a pointer.\n \n For small records like `point`, this is usually more efficient than\n allocating memory and going through a pointer. But for big records, or\n@@ -1859,7 +1861,7 @@ like methods named 'new' and 'drop', but without 'fn', and without arguments\n for drop.\n \n In the constructor, the compiler will enforce that all fields are initialized\n-before doing anything which might allow them to be accessed. This includes\n+before doing anything that might allow them to be accessed. This includes\n returning from the constructor, calling any method on 'self', calling any\n function with 'self' as an argument, or taking a reference to 'self'. Mutation\n of immutable fields is possible only in the constructor, and only before doing\n@@ -2959,9 +2961,9 @@ other. The function `task::spawn_listener()` supports this pattern. We'll look\n briefly at how it is used.\n \n To see how `spawn_listener()` works, we will create a child task\n-which receives `uint` messages, converts them to a string, and sends\n+that receives `uint` messages, converts them to a string, and sends\n the string in response.  The child terminates when `0` is received.\n-Here is the function which implements the child task:\n+Here is the function that implements the child task:\n \n ~~~~\n # import comm::{port, chan, methods};"}]}