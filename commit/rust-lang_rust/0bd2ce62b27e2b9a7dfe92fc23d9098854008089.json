{"sha": "0bd2ce62b27e2b9a7dfe92fc23d9098854008089", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiZDJjZTYyYjI3ZTJiOWE3ZGZlOTJmYzIzZDkwOTg4NTQwMDgwODk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-11-19T22:39:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-19T22:39:25Z"}, "message": "Auto merge of #37831 - rkruppe:llvm-attr-fwdcompat, r=eddyb\n\n[LLVM 4.0] Use llvm::Attribute APIs instead of \"raw value\" APIs\n\nThe latter will be removed in LLVM 4.0 (see https://github.com/llvm-mirror/llvm/commit/4a6fc8bacf11d8066da72cf8481467167877ed16).\n\nThe librustc_llvm API remains mostly unchanged, except that llvm::Attribute is no longer a bitflag but represents only a *single* attribute.\nThe ability to store many attributes in a small number of bits and modify them without interacting with LLVM is only used in rustc_trans::abi and closely related modules, and only attributes for function arguments are considered there.\nThus rustc_trans::abi now has its own bit-packed representation of argument attributes, which are translated to rustc_llvm::Attribute when applying the attributes.\n\ncc #37609", "tree": {"sha": "86d6fdcf938c5eadf071a2e03890f72047481d5d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86d6fdcf938c5eadf071a2e03890f72047481d5d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0bd2ce62b27e2b9a7dfe92fc23d9098854008089", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0bd2ce62b27e2b9a7dfe92fc23d9098854008089", "html_url": "https://github.com/rust-lang/rust/commit/0bd2ce62b27e2b9a7dfe92fc23d9098854008089", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0bd2ce62b27e2b9a7dfe92fc23d9098854008089/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bfa709a38a8c607e1c13ee5635fbfd1940eb18b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/bfa709a38a8c607e1c13ee5635fbfd1940eb18b1", "html_url": "https://github.com/rust-lang/rust/commit/bfa709a38a8c607e1c13ee5635fbfd1940eb18b1"}, {"sha": "30daedf60355d105d92ad011b9e115b01350593e", "url": "https://api.github.com/repos/rust-lang/rust/commits/30daedf60355d105d92ad011b9e115b01350593e", "html_url": "https://github.com/rust-lang/rust/commit/30daedf60355d105d92ad011b9e115b01350593e"}], "stats": {"total": 463, "additions": 264, "deletions": 199}, "files": [{"sha": "ab1c1c453dd23df68258c3b1da50fb72139167d1", "filename": "src/Cargo.lock", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bd2ce62b27e2b9a7dfe92fc23d9098854008089/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0bd2ce62b27e2b9a7dfe92fc23d9098854008089/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=0bd2ce62b27e2b9a7dfe92fc23d9098854008089", "patch": "@@ -409,7 +409,6 @@ version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n  \"gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc_bitflags 0.0.0\",\n ]\n \n [[package]]\n@@ -520,6 +519,7 @@ dependencies = [\n  \"log 0.0.0\",\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n+ \"rustc_bitflags 0.0.0\",\n  \"rustc_const_eval 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\","}, {"sha": "88f8c0553adca4ead988b7914ec7e8b425436c3b", "filename": "src/librustc_llvm/Cargo.toml", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0bd2ce62b27e2b9a7dfe92fc23d9098854008089/src%2Flibrustc_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0bd2ce62b27e2b9a7dfe92fc23d9098854008089/src%2Flibrustc_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2FCargo.toml?ref=0bd2ce62b27e2b9a7dfe92fc23d9098854008089", "patch": "@@ -12,9 +12,6 @@ crate-type = [\"dylib\"]\n [features]\n static-libstdcpp = []\n \n-[dependencies]\n-rustc_bitflags = { path = \"../librustc_bitflags\" }\n-\n [build-dependencies]\n build_helper = { path = \"../build_helper\" }\n gcc = \"0.3.27\""}, {"sha": "50bc3e7b6243f8d8743cb0da1a07398724b918e2", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0bd2ce62b27e2b9a7dfe92fc23d9098854008089/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bd2ce62b27e2b9a7dfe92fc23d9098854008089/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=0bd2ce62b27e2b9a7dfe92fc23d9098854008089", "patch": "@@ -145,6 +145,9 @@ fn main() {\n         cfg.flag(\"-DLLVM_RUSTLLVM\");\n     }\n \n+    println!(\"cargo:rerun-if-changed=../rustllvm/PassWrapper.cpp\");\n+    println!(\"cargo:rerun-if-changed=../rustllvm/RustWrapper.cpp\");\n+    println!(\"cargo:rerun-if-changed=../rustllvm/ArchiveWrapper.cpp\");\n     cfg.file(\"../rustllvm/PassWrapper.cpp\")\n        .file(\"../rustllvm/RustWrapper.cpp\")\n        .file(\"../rustllvm/ArchiveWrapper.cpp\")"}, {"sha": "ebd75be7bba0bb0cf192c955ca66c11e2eedb212", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 38, "deletions": 63, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/0bd2ce62b27e2b9a7dfe92fc23d9098854008089/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bd2ce62b27e2b9a7dfe92fc23d9098854008089/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=0bd2ce62b27e2b9a7dfe92fc23d9098854008089", "patch": "@@ -83,59 +83,31 @@ pub enum DLLStorageClass {\n     DllExport = 2, // Function to be accessible from DLL.\n }\n \n-bitflags! {\n-    #[derive(Default, Debug)]\n-    flags Attribute : u64 {\n-        const ZExt            = 1 << 0,\n-        const SExt            = 1 << 1,\n-        const NoReturn        = 1 << 2,\n-        const InReg           = 1 << 3,\n-        const StructRet       = 1 << 4,\n-        const NoUnwind        = 1 << 5,\n-        const NoAlias         = 1 << 6,\n-        const ByVal           = 1 << 7,\n-        const Nest            = 1 << 8,\n-        const ReadNone        = 1 << 9,\n-        const ReadOnly        = 1 << 10,\n-        const NoInline        = 1 << 11,\n-        const AlwaysInline    = 1 << 12,\n-        const OptimizeForSize = 1 << 13,\n-        const StackProtect    = 1 << 14,\n-        const StackProtectReq = 1 << 15,\n-        const NoCapture       = 1 << 21,\n-        const NoRedZone       = 1 << 22,\n-        const NoImplicitFloat = 1 << 23,\n-        const Naked           = 1 << 24,\n-        const InlineHint      = 1 << 25,\n-        const ReturnsTwice    = 1 << 29,\n-        const UWTable         = 1 << 30,\n-        const NonLazyBind     = 1 << 31,\n-\n-        // Some of these are missing from the LLVM C API, the rest are\n-        // present, but commented out, and preceded by the following warning:\n-        // FIXME: These attributes are currently not included in the C API as\n-        // a temporary measure until the API/ABI impact to the C API is understood\n-        // and the path forward agreed upon.\n-        const SanitizeAddress = 1 << 32,\n-        const MinSize         = 1 << 33,\n-        const NoDuplicate     = 1 << 34,\n-        const StackProtectStrong = 1 << 35,\n-        const SanitizeThread  = 1 << 36,\n-        const SanitizeMemory  = 1 << 37,\n-        const NoBuiltin       = 1 << 38,\n-        const Returned        = 1 << 39,\n-        const Cold            = 1 << 40,\n-        const Builtin         = 1 << 41,\n-        const OptimizeNone    = 1 << 42,\n-        const InAlloca        = 1 << 43,\n-        const NonNull         = 1 << 44,\n-        const JumpTable       = 1 << 45,\n-        const Convergent      = 1 << 46,\n-        const SafeStack       = 1 << 47,\n-        const NoRecurse       = 1 << 48,\n-        const InaccessibleMemOnly         = 1 << 49,\n-        const InaccessibleMemOrArgMemOnly = 1 << 50,\n-    }\n+/// Matches LLVMRustAttribute in rustllvm.h\n+/// Semantically a subset of the C++ enum llvm::Attribute::AttrKind,\n+/// though it is not ABI compatible (since it's a C++ enum)\n+#[repr(C)]\n+#[derive(Copy, Clone, Debug)]\n+pub enum Attribute {\n+    AlwaysInline    = 0,\n+    ByVal           = 1,\n+    Cold            = 2,\n+    InlineHint      = 3,\n+    MinSize         = 4,\n+    Naked           = 5,\n+    NoAlias         = 6,\n+    NoCapture       = 7,\n+    NoInline        = 8,\n+    NonNull         = 9,\n+    NoRedZone       = 10,\n+    NoReturn        = 11,\n+    NoUnwind        = 12,\n+    OptimizeForSize = 13,\n+    ReadOnly        = 14,\n+    SExt            = 15,\n+    StructRet       = 16,\n+    UWTable         = 17,\n+    ZExt            = 18,\n }\n \n /// LLVMIntPredicate\n@@ -423,6 +395,9 @@ pub type RustArchiveMemberRef = *mut RustArchiveMember_opaque;\n #[allow(missing_copy_implementations)]\n pub enum OperandBundleDef_opaque {}\n pub type OperandBundleDefRef = *mut OperandBundleDef_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum Attribute_opaque {}\n+pub type AttributeRef = *mut Attribute_opaque;\n \n pub type DiagnosticHandler = unsafe extern \"C\" fn(DiagnosticInfoRef, *mut c_void);\n pub type InlineAsmDiagHandler = unsafe extern \"C\" fn(SMDiagnosticRef, *const c_void, c_uint);\n@@ -530,6 +505,9 @@ extern \"C\" {\n     /// See llvm::LLVMType::getContext.\n     pub fn LLVMGetTypeContext(Ty: TypeRef) -> ContextRef;\n \n+    /// See llvm::Value::getContext\n+    pub fn LLVMRustGetValueContext(V: ValueRef) -> ContextRef;\n+\n     // Operations on integer types\n     pub fn LLVMInt1TypeInContext(C: ContextRef) -> TypeRef;\n     pub fn LLVMInt8TypeInContext(C: ContextRef) -> TypeRef;\n@@ -792,6 +770,8 @@ extern \"C\" {\n                         Name: *const c_char)\n                         -> ValueRef;\n \n+    pub fn LLVMRustCreateAttribute(C: ContextRef, kind: Attribute, val: u64) -> AttributeRef;\n+\n     // Operations on functions\n     pub fn LLVMAddFunction(M: ModuleRef, Name: *const c_char, FunctionTy: TypeRef) -> ValueRef;\n     pub fn LLVMGetNamedFunction(M: ModuleRef, Name: *const c_char) -> ValueRef;\n@@ -810,16 +790,12 @@ extern \"C\" {\n     pub fn LLVMGetGC(Fn: ValueRef) -> *const c_char;\n     pub fn LLVMSetGC(Fn: ValueRef, Name: *const c_char);\n     pub fn LLVMRustAddDereferenceableAttr(Fn: ValueRef, index: c_uint, bytes: u64);\n-    pub fn LLVMRustAddFunctionAttribute(Fn: ValueRef, index: c_uint, PA: u64);\n-    pub fn LLVMRustAddFunctionAttrString(Fn: ValueRef, index: c_uint, Name: *const c_char);\n+    pub fn LLVMRustAddFunctionAttribute(Fn: ValueRef, index: c_uint, attr: AttributeRef);\n     pub fn LLVMRustAddFunctionAttrStringValue(Fn: ValueRef,\n                                               index: c_uint,\n                                               Name: *const c_char,\n                                               Value: *const c_char);\n-    pub fn LLVMRustRemoveFunctionAttributes(Fn: ValueRef, index: c_uint, attr: u64);\n-    pub fn LLVMRustRemoveFunctionAttrString(Fn: ValueRef, index: c_uint, Name: *const c_char);\n-    pub fn LLVMGetFunctionAttr(Fn: ValueRef) -> c_uint;\n-    pub fn LLVMRemoveFunctionAttr(Fn: ValueRef, val: c_uint);\n+    pub fn LLVMRustRemoveFunctionAttributes(Fn: ValueRef, index: c_uint, attr: AttributeRef);\n \n     // Operations on parameters\n     pub fn LLVMCountParams(Fn: ValueRef) -> c_uint;\n@@ -830,9 +806,8 @@ extern \"C\" {\n     pub fn LLVMGetLastParam(Fn: ValueRef) -> ValueRef;\n     pub fn LLVMGetNextParam(Arg: ValueRef) -> ValueRef;\n     pub fn LLVMGetPreviousParam(Arg: ValueRef) -> ValueRef;\n-    pub fn LLVMAddAttribute(Arg: ValueRef, PA: c_uint);\n-    pub fn LLVMRemoveAttribute(Arg: ValueRef, PA: c_uint);\n-    pub fn LLVMGetAttribute(Arg: ValueRef) -> c_uint;\n+    pub fn LLVMAddAttribute(Arg: ValueRef, attr: AttributeRef);\n+    pub fn LLVMRemoveAttribute(Arg: ValueRef, attr: AttributeRef);\n     pub fn LLVMSetParamAlignment(Arg: ValueRef, align: c_uint);\n \n     // Operations on basic blocks\n@@ -876,7 +851,7 @@ extern \"C\" {\n     pub fn LLVMAddInstrAttribute(Instr: ValueRef, index: c_uint, IA: c_uint);\n     pub fn LLVMRemoveInstrAttribute(Instr: ValueRef, index: c_uint, IA: c_uint);\n     pub fn LLVMSetInstrParamAlignment(Instr: ValueRef, index: c_uint, align: c_uint);\n-    pub fn LLVMRustAddCallSiteAttribute(Instr: ValueRef, index: c_uint, Val: u64);\n+    pub fn LLVMRustAddCallSiteAttribute(Instr: ValueRef, index: c_uint, attr: AttributeRef);\n     pub fn LLVMRustAddDereferenceableCallSiteAttr(Instr: ValueRef, index: c_uint, bytes: u64);\n \n     // Operations on call instructions (only)"}, {"sha": "c81d3b48aa969b1f62598ec91d5a1b10e5092996", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 8, "deletions": 56, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/0bd2ce62b27e2b9a7dfe92fc23d9098854008089/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bd2ce62b27e2b9a7dfe92fc23d9098854008089/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=0bd2ce62b27e2b9a7dfe92fc23d9098854008089", "patch": "@@ -29,12 +29,8 @@\n #![feature(staged_api)]\n #![feature(linked_from)]\n #![feature(concat_idents)]\n-#![cfg_attr(not(stage0), feature(rustc_private))]\n \n extern crate libc;\n-#[macro_use]\n-#[no_link]\n-extern crate rustc_bitflags;\n \n pub use self::IntPredicate::*;\n pub use self::RealPredicate::*;\n@@ -68,54 +64,6 @@ impl LLVMRustResult {\n     }\n }\n \n-#[derive(Copy, Clone, Default, Debug)]\n-pub struct Attributes {\n-    regular: Attribute,\n-    dereferenceable_bytes: u64,\n-}\n-\n-impl Attributes {\n-    pub fn set(&mut self, attr: Attribute) -> &mut Self {\n-        self.regular = self.regular | attr;\n-        self\n-    }\n-\n-    pub fn unset(&mut self, attr: Attribute) -> &mut Self {\n-        self.regular = self.regular - attr;\n-        self\n-    }\n-\n-    pub fn set_dereferenceable(&mut self, bytes: u64) -> &mut Self {\n-        self.dereferenceable_bytes = bytes;\n-        self\n-    }\n-\n-    pub fn unset_dereferenceable(&mut self) -> &mut Self {\n-        self.dereferenceable_bytes = 0;\n-        self\n-    }\n-\n-    pub fn apply_llfn(&self, idx: AttributePlace, llfn: ValueRef) {\n-        unsafe {\n-            self.regular.apply_llfn(idx, llfn);\n-            if self.dereferenceable_bytes != 0 {\n-                LLVMRustAddDereferenceableAttr(llfn, idx.as_uint(), self.dereferenceable_bytes);\n-            }\n-        }\n-    }\n-\n-    pub fn apply_callsite(&self, idx: AttributePlace, callsite: ValueRef) {\n-        unsafe {\n-            self.regular.apply_callsite(idx, callsite);\n-            if self.dereferenceable_bytes != 0 {\n-                LLVMRustAddDereferenceableCallSiteAttr(callsite,\n-                                                       idx.as_uint(),\n-                                                       self.dereferenceable_bytes);\n-            }\n-        }\n-    }\n-}\n-\n pub fn AddFunctionAttrStringValue(llfn: ValueRef,\n                                   idx: AttributePlace,\n                                   attr: &'static str,\n@@ -140,7 +88,7 @@ impl AttributePlace {\n         AttributePlace::Argument(0)\n     }\n \n-    fn as_uint(self) -> c_uint {\n+    pub fn as_uint(self) -> c_uint {\n         match self {\n             AttributePlace::Function => !0,\n             AttributePlace::Argument(i) => i,\n@@ -228,16 +176,20 @@ pub fn set_thread_local(global: ValueRef, is_thread_local: bool) {\n }\n \n impl Attribute {\n+    fn as_object(&self, value: ValueRef) -> AttributeRef {\n+        unsafe { LLVMRustCreateAttribute(LLVMRustGetValueContext(value), *self, 0) }\n+    }\n+\n     pub fn apply_llfn(&self, idx: AttributePlace, llfn: ValueRef) {\n-        unsafe { LLVMRustAddFunctionAttribute(llfn, idx.as_uint(), self.bits()) }\n+        unsafe { LLVMRustAddFunctionAttribute(llfn, idx.as_uint(), self.as_object(llfn)) }\n     }\n \n     pub fn apply_callsite(&self, idx: AttributePlace, callsite: ValueRef) {\n-        unsafe { LLVMRustAddCallSiteAttribute(callsite, idx.as_uint(), self.bits()) }\n+        unsafe { LLVMRustAddCallSiteAttribute(callsite, idx.as_uint(), self.as_object(callsite)) }\n     }\n \n     pub fn unapply_llfn(&self, idx: AttributePlace, llfn: ValueRef) {\n-        unsafe { LLVMRustRemoveFunctionAttributes(llfn, idx.as_uint(), self.bits()) }\n+        unsafe { LLVMRustRemoveFunctionAttributes(llfn, idx.as_uint(), self.as_object(llfn)) }\n     }\n \n     pub fn toggle_llfn(&self, idx: AttributePlace, llfn: ValueRef, set: bool) {"}, {"sha": "796a80d0809441044c6d7ecf9c455166560da55e", "filename": "src/librustc_trans/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0bd2ce62b27e2b9a7dfe92fc23d9098854008089/src%2Flibrustc_trans%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0bd2ce62b27e2b9a7dfe92fc23d9098854008089/src%2Flibrustc_trans%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FCargo.toml?ref=0bd2ce62b27e2b9a7dfe92fc23d9098854008089", "patch": "@@ -16,6 +16,7 @@ graphviz = { path = \"../libgraphviz\" }\n log = { path = \"../liblog\" }\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n+rustc_bitflags = { path = \"../librustc_bitflags\" }\n rustc_const_eval = { path = \"../librustc_const_eval\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "07f53466b4975e1769fc0a01beacfd5c0c9caff6", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 105, "deletions": 18, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/0bd2ce62b27e2b9a7dfe92fc23d9098854008089/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bd2ce62b27e2b9a7dfe92fc23d9098854008089/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=0bd2ce62b27e2b9a7dfe92fc23d9098854008089", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::{self, ValueRef, Integer, Pointer, Float, Double, Struct, Array, Vector};\n+use llvm::{self, ValueRef, Integer, Pointer, Float, Double, Struct, Array, Vector, AttributePlace};\n use base;\n use build::AllocaFcx;\n use common::{type_is_fat_ptr, BlockAndBuilder, C_uint};\n@@ -50,6 +50,93 @@ enum ArgKind {\n     Ignore,\n }\n \n+// Hack to disable non_upper_case_globals only for the bitflags! and not for the rest\n+// of this module\n+pub use self::attr_impl::ArgAttribute;\n+\n+#[allow(non_upper_case_globals)]\n+mod attr_impl {\n+    // The subset of llvm::Attribute needed for arguments, packed into a bitfield.\n+    bitflags! {\n+        #[derive(Default, Debug)]\n+        flags ArgAttribute : u8 {\n+            const ByVal     = 1 << 0,\n+            const NoAlias   = 1 << 1,\n+            const NoCapture = 1 << 2,\n+            const NonNull   = 1 << 3,\n+            const ReadOnly  = 1 << 4,\n+            const SExt      = 1 << 5,\n+            const StructRet = 1 << 6,\n+            const ZExt      = 1 << 7,\n+        }\n+    }\n+}\n+\n+macro_rules! for_each_kind {\n+    ($flags: ident, $f: ident, $($kind: ident),+) => ({\n+        $(if $flags.contains(ArgAttribute::$kind) { $f(llvm::Attribute::$kind) })+\n+    })\n+}\n+\n+impl ArgAttribute {\n+    fn for_each_kind<F>(&self, mut f: F) where F: FnMut(llvm::Attribute) {\n+        for_each_kind!(self, f,\n+                       ByVal, NoAlias, NoCapture, NonNull, ReadOnly, SExt, StructRet, ZExt)\n+    }\n+}\n+\n+/// A compact representation of LLVM attributes (at least those relevant for this module)\n+/// that can be manipulated without interacting with LLVM's Attribute machinery.\n+#[derive(Copy, Clone, Debug, Default)]\n+pub struct ArgAttributes {\n+    regular: ArgAttribute,\n+    dereferenceable_bytes: u64,\n+}\n+\n+impl ArgAttributes {\n+    pub fn set(&mut self, attr: ArgAttribute) -> &mut Self {\n+        self.regular = self.regular | attr;\n+        self\n+    }\n+\n+    pub fn unset(&mut self, attr: ArgAttribute) -> &mut Self {\n+        self.regular = self.regular - attr;\n+        self\n+    }\n+\n+    pub fn set_dereferenceable(&mut self, bytes: u64) -> &mut Self {\n+        self.dereferenceable_bytes = bytes;\n+        self\n+    }\n+\n+    pub fn unset_dereferenceable(&mut self) -> &mut Self {\n+        self.dereferenceable_bytes = 0;\n+        self\n+    }\n+\n+    pub fn apply_llfn(&self, idx: AttributePlace, llfn: ValueRef) {\n+        unsafe {\n+            self.regular.for_each_kind(|attr| attr.apply_llfn(idx, llfn));\n+            if self.dereferenceable_bytes != 0 {\n+                llvm::LLVMRustAddDereferenceableAttr(llfn,\n+                                                     idx.as_uint(),\n+                                                     self.dereferenceable_bytes);\n+            }\n+        }\n+    }\n+\n+    pub fn apply_callsite(&self, idx: AttributePlace, callsite: ValueRef) {\n+        unsafe {\n+            self.regular.for_each_kind(|attr| attr.apply_callsite(idx, callsite));\n+            if self.dereferenceable_bytes != 0 {\n+                llvm::LLVMRustAddDereferenceableCallSiteAttr(callsite,\n+                                                             idx.as_uint(),\n+                                                             self.dereferenceable_bytes);\n+            }\n+        }\n+    }\n+}\n+\n /// Information about how a specific C type\n /// should be passed to or returned from a function\n ///\n@@ -81,7 +168,7 @@ pub struct ArgType {\n     /// Dummy argument, which is emitted before the real argument\n     pub pad: Option<Type>,\n     /// LLVM attributes of argument\n-    pub attrs: llvm::Attributes\n+    pub attrs: ArgAttributes\n }\n \n impl ArgType {\n@@ -93,23 +180,23 @@ impl ArgType {\n             signedness: None,\n             cast: None,\n             pad: None,\n-            attrs: llvm::Attributes::default()\n+            attrs: ArgAttributes::default()\n         }\n     }\n \n     pub fn make_indirect(&mut self, ccx: &CrateContext) {\n         assert_eq!(self.kind, ArgKind::Direct);\n \n         // Wipe old attributes, likely not valid through indirection.\n-        self.attrs = llvm::Attributes::default();\n+        self.attrs = ArgAttributes::default();\n \n         let llarg_sz = llsize_of_alloc(ccx, self.ty);\n \n         // For non-immediate arguments the callee gets its own copy of\n         // the value on the stack, so there are no aliases. It's also\n         // program-invisible so can't possibly capture\n-        self.attrs.set(llvm::Attribute::NoAlias)\n-                  .set(llvm::Attribute::NoCapture)\n+        self.attrs.set(ArgAttribute::NoAlias)\n+                  .set(ArgAttribute::NoCapture)\n                   .set_dereferenceable(llarg_sz);\n \n         self.kind = ArgKind::Indirect;\n@@ -125,9 +212,9 @@ impl ArgType {\n         if let Some(signed) = self.signedness {\n             if self.ty.int_width() < bits {\n                 self.attrs.set(if signed {\n-                    llvm::Attribute::SExt\n+                    ArgAttribute::SExt\n                 } else {\n-                    llvm::Attribute::ZExt\n+                    ArgAttribute::ZExt\n                 });\n             }\n         }\n@@ -315,7 +402,7 @@ impl FnType {\n             if ty.is_bool() {\n                 let llty = Type::i1(ccx);\n                 let mut arg = ArgType::new(llty, llty);\n-                arg.attrs.set(llvm::Attribute::ZExt);\n+                arg.attrs.set(ArgAttribute::ZExt);\n                 arg\n             } else {\n                 let mut arg = ArgType::new(type_of::type_of(ccx, ty),\n@@ -350,7 +437,7 @@ impl FnType {\n             if let ty::TyBox(_) = ret_ty.sty {\n                 // `Box` pointer return values never alias because ownership\n                 // is transferred\n-                ret.attrs.set(llvm::Attribute::NoAlias);\n+                ret.attrs.set(ArgAttribute::NoAlias);\n             }\n \n             // We can also mark the return value as `dereferenceable` in certain cases\n@@ -372,7 +459,7 @@ impl FnType {\n         let rust_ptr_attrs = |ty: Ty<'tcx>, arg: &mut ArgType| match ty.sty {\n             // `Box` pointer parameters never alias because ownership is transferred\n             ty::TyBox(inner) => {\n-                arg.attrs.set(llvm::Attribute::NoAlias);\n+                arg.attrs.set(ArgAttribute::NoAlias);\n                 Some(inner)\n             }\n \n@@ -387,18 +474,18 @@ impl FnType {\n                 let interior_unsafe = mt.ty.type_contents(ccx.tcx()).interior_unsafe();\n \n                 if mt.mutbl != hir::MutMutable && !interior_unsafe {\n-                    arg.attrs.set(llvm::Attribute::NoAlias);\n+                    arg.attrs.set(ArgAttribute::NoAlias);\n                 }\n \n                 if mt.mutbl == hir::MutImmutable && !interior_unsafe {\n-                    arg.attrs.set(llvm::Attribute::ReadOnly);\n+                    arg.attrs.set(ArgAttribute::ReadOnly);\n                 }\n \n                 // When a reference in an argument has no named lifetime, it's\n                 // impossible for that reference to escape this function\n                 // (returned or stored beyond the call by a closure).\n                 if let ReLateBound(_, BrAnon(_)) = *b {\n-                    arg.attrs.set(llvm::Attribute::NoCapture);\n+                    arg.attrs.set(ArgAttribute::NoCapture);\n                 }\n \n                 Some(mt.ty)\n@@ -418,9 +505,9 @@ impl FnType {\n                 let mut info = ArgType::new(original_tys[1], sizing_tys[1]);\n \n                 if let Some(inner) = rust_ptr_attrs(ty, &mut data) {\n-                    data.attrs.set(llvm::Attribute::NonNull);\n+                    data.attrs.set(ArgAttribute::NonNull);\n                     if ccx.tcx().struct_tail(inner).is_trait() {\n-                        info.attrs.set(llvm::Attribute::NonNull);\n+                        info.attrs.set(ArgAttribute::NonNull);\n                     }\n                 }\n                 args.push(data);\n@@ -491,7 +578,7 @@ impl FnType {\n                 fixup(arg);\n             }\n             if self.ret.is_indirect() {\n-                self.ret.attrs.set(llvm::Attribute::StructRet);\n+                self.ret.attrs.set(ArgAttribute::StructRet);\n             }\n             return;\n         }\n@@ -526,7 +613,7 @@ impl FnType {\n         }\n \n         if self.ret.is_indirect() {\n-            self.ret.attrs.set(llvm::Attribute::StructRet);\n+            self.ret.attrs.set(ArgAttribute::StructRet);\n         }\n     }\n "}, {"sha": "f1e90419a49e2070508781b2f55821458598f295", "filename": "src/librustc_trans/attributes.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0bd2ce62b27e2b9a7dfe92fc23d9098854008089/src%2Flibrustc_trans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bd2ce62b27e2b9a7dfe92fc23d9098854008089/src%2Flibrustc_trans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fattributes.rs?ref=0bd2ce62b27e2b9a7dfe92fc23d9098854008089", "patch": "@@ -24,10 +24,9 @@ pub fn inline(val: ValueRef, inline: InlineAttr) {\n         Always => Attribute::AlwaysInline.apply_llfn(Function, val),\n         Never  => Attribute::NoInline.apply_llfn(Function, val),\n         None   => {\n-            let attr = Attribute::InlineHint |\n-                       Attribute::AlwaysInline |\n-                       Attribute::NoInline;\n-            attr.unapply_llfn(Function, val)\n+            Attribute::InlineHint.unapply_llfn(Function, val);\n+            Attribute::AlwaysInline.unapply_llfn(Function, val);\n+            Attribute::NoInline.unapply_llfn(Function, val);\n         },\n     };\n }"}, {"sha": "f410627400c34ec4c2b1018d4188cdb3da48c941", "filename": "src/librustc_trans/cabi_asmjs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0bd2ce62b27e2b9a7dfe92fc23d9098854008089/src%2Flibrustc_trans%2Fcabi_asmjs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bd2ce62b27e2b9a7dfe92fc23d9098854008089/src%2Flibrustc_trans%2Fcabi_asmjs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_asmjs.rs?ref=0bd2ce62b27e2b9a7dfe92fc23d9098854008089", "patch": "@@ -10,8 +10,8 @@\n \n #![allow(non_upper_case_globals)]\n \n-use llvm::{Struct, Array, Attribute};\n-use abi::{FnType, ArgType};\n+use llvm::{Struct, Array};\n+use abi::{FnType, ArgType, ArgAttribute};\n use context::CrateContext;\n \n // Data layout: e-p:32:32-i64:64-v128:32:128-n32-S128\n@@ -39,7 +39,7 @@ fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType) {\n     if arg.ty.is_aggregate() {\n         arg.make_indirect(ccx);\n-        arg.attrs.set(Attribute::ByVal);\n+        arg.attrs.set(ArgAttribute::ByVal);\n     }\n }\n "}, {"sha": "5377b49a2b441c8bf787e9627e686949cf9d9a21", "filename": "src/librustc_trans/cabi_x86.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0bd2ce62b27e2b9a7dfe92fc23d9098854008089/src%2Flibrustc_trans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bd2ce62b27e2b9a7dfe92fc23d9098854008089/src%2Flibrustc_trans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86.rs?ref=0bd2ce62b27e2b9a7dfe92fc23d9098854008089", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use llvm::*;\n-use abi::FnType;\n+use abi::{ArgAttribute, FnType};\n use type_::Type;\n use super::common::*;\n use super::machine::*;\n@@ -45,7 +45,7 @@ pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n         if arg.is_ignore() { continue; }\n         if arg.ty.kind() == Struct {\n             arg.make_indirect(ccx);\n-            arg.attrs.set(Attribute::ByVal);\n+            arg.attrs.set(ArgAttribute::ByVal);\n         } else {\n             arg.extend_integer_width_to(32);\n         }"}, {"sha": "7f2fdbf000b651fd62acfab2cb256881e55375a5", "filename": "src/librustc_trans/cabi_x86_64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0bd2ce62b27e2b9a7dfe92fc23d9098854008089/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bd2ce62b27e2b9a7dfe92fc23d9098854008089/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_64.rs?ref=0bd2ce62b27e2b9a7dfe92fc23d9098854008089", "patch": "@@ -15,8 +15,8 @@\n use self::RegClass::*;\n \n use llvm::{Integer, Pointer, Float, Double};\n-use llvm::{Struct, Array, Attribute, Vector};\n-use abi::{self, ArgType, FnType};\n+use llvm::{Struct, Array, Vector};\n+use abi::{self, ArgType, ArgAttribute, FnType};\n use context::CrateContext;\n use type_::Type;\n \n@@ -334,7 +334,7 @@ pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n     fn x86_64_ty<F>(ccx: &CrateContext,\n                     arg: &mut ArgType,\n                     is_mem_cls: F,\n-                    ind_attr: Option<Attribute>)\n+                    ind_attr: Option<ArgAttribute>)\n         where F: FnOnce(&[RegClass]) -> bool\n     {\n         if !arg.ty.is_reg_ty() {\n@@ -384,7 +384,7 @@ pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n                 sse_regs -= needed_sse;\n             }\n             in_mem\n-        }, Some(Attribute::ByVal));\n+        }, Some(ArgAttribute::ByVal));\n \n         // An integer, pointer, double or float parameter\n         // thus the above closure passed to `x86_64_ty` won't"}, {"sha": "d0cb302e1ab1fdb48bc649b77ecc436880289792", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0bd2ce62b27e2b9a7dfe92fc23d9098854008089/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bd2ce62b27e2b9a7dfe92fc23d9098854008089/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=0bd2ce62b27e2b9a7dfe92fc23d9098854008089", "patch": "@@ -23,6 +23,7 @@\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![cfg_attr(not(stage0), deny(warnings))]\n \n+#![feature(associated_consts)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(cell_extras)]\n@@ -55,6 +56,9 @@ extern crate rustc_platform_intrinsics as intrinsics;\n extern crate serialize;\n extern crate rustc_const_math;\n extern crate rustc_const_eval;\n+#[macro_use]\n+#[no_link]\n+extern crate rustc_bitflags;\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;"}, {"sha": "7f0c7e2e5c9fa83eecbbb645fc702394f15b5a34", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 70, "deletions": 45, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/0bd2ce62b27e2b9a7dfe92fc23d9098854008089/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/0bd2ce62b27e2b9a7dfe92fc23d9098854008089/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=0bd2ce62b27e2b9a7dfe92fc23d9098854008089", "patch": "@@ -109,37 +109,84 @@ extern \"C\" LLVMTypeRef LLVMRustMetadataTypeInContext(LLVMContextRef C) {\n   return wrap(Type::getMetadataTy(*unwrap(C)));\n }\n \n-extern \"C\" void LLVMRustAddCallSiteAttribute(LLVMValueRef Instr, unsigned index, uint64_t Val) {\n+static Attribute::AttrKind\n+from_rust(LLVMRustAttribute kind) {\n+  switch (kind) {\n+    case AlwaysInline:\n+      return Attribute::AlwaysInline;\n+    case ByVal:\n+      return Attribute::ByVal;\n+    case Cold:\n+      return Attribute::Cold;\n+    case InlineHint:\n+      return Attribute::InlineHint;\n+    case MinSize:\n+      return Attribute::MinSize;\n+    case Naked:\n+      return Attribute::Naked;\n+    case NoAlias:\n+      return Attribute::NoAlias;\n+    case NoCapture:\n+      return Attribute::NoCapture;\n+    case NoInline:\n+      return Attribute::NoInline;\n+    case NonNull:\n+      return Attribute::NonNull;\n+    case NoRedZone:\n+      return Attribute::NoRedZone;\n+    case NoReturn:\n+      return Attribute::NoReturn;\n+    case NoUnwind:\n+      return Attribute::NoUnwind;\n+    case OptimizeForSize:\n+      return Attribute::OptimizeForSize;\n+    case ReadOnly:\n+      return Attribute::ReadOnly;\n+    case SExt:\n+      return Attribute::SExt;\n+    case StructRet:\n+      return Attribute::StructRet;\n+    case UWTable:\n+      return Attribute::UWTable;\n+    case ZExt:\n+      return Attribute::ZExt;\n+    default:\n+      llvm_unreachable(\"bad AttributeKind\");\n+  }\n+}\n+\n+extern \"C\" LLVMAttributeRef LLVMRustCreateAttribute(LLVMContextRef C, LLVMRustAttribute Kind, uint64_t Val) {\n+  return wrap(Attribute::get(*unwrap(C), from_rust(Kind), Val));\n+}\n+\n+extern \"C\" void LLVMRustAddCallSiteAttribute(LLVMValueRef Instr, unsigned index, LLVMAttributeRef attr) {\n   CallSite Call = CallSite(unwrap<Instruction>(Instr));\n-  AttrBuilder B;\n-  B.addRawValue(Val);\n+  AttrBuilder B(unwrap(attr));\n   Call.setAttributes(\n     Call.getAttributes().addAttributes(Call->getContext(), index,\n                                        AttributeSet::get(Call->getContext(),\n                                                          index, B)));\n }\n \n-\n extern \"C\" void LLVMRustAddDereferenceableCallSiteAttr(LLVMValueRef Instr,\n-\t\t\t\t\t\t       unsigned idx,\n-\t\t\t\t\t\t       uint64_t b)\n+                                                      unsigned index,\n+                                                      uint64_t bytes)\n {\n   CallSite Call = CallSite(unwrap<Instruction>(Instr));\n   AttrBuilder B;\n-  B.addDereferenceableAttr(b);\n+  B.addDereferenceableAttr(bytes);\n   Call.setAttributes(\n-    Call.getAttributes().addAttributes(Call->getContext(), idx,\n+    Call.getAttributes().addAttributes(Call->getContext(), index,\n                                        AttributeSet::get(Call->getContext(),\n-                                                         idx, B)));\n+                                                         index, B)));\n }\n \n extern \"C\" void LLVMRustAddFunctionAttribute(LLVMValueRef Fn,\n \t\t\t\t\t     unsigned index,\n-\t\t\t\t\t     uint64_t Val)\n+\t\t\t\t\t     LLVMAttributeRef attr)\n {\n   Function *A = unwrap<Function>(Fn);\n-  AttrBuilder B;\n-  B.addRawValue(Val);\n+  AttrBuilder B(unwrap(attr));\n   A->addAttributes(index, AttributeSet::get(A->getContext(), index, B));\n }\n \n@@ -153,16 +200,6 @@ extern \"C\" void LLVMRustAddDereferenceableAttr(LLVMValueRef Fn,\n   A->addAttributes(index, AttributeSet::get(A->getContext(), index, B));\n }\n \n-extern \"C\" void LLVMRustAddFunctionAttrString(LLVMValueRef Fn,\n-\t\t\t\t\t      unsigned index,\n-\t\t\t\t\t      const char *Name)\n-{\n-  Function *F = unwrap<Function>(Fn);\n-  AttrBuilder B;\n-  B.addAttribute(Name);\n-  F->addAttributes(index, AttributeSet::get(F->getContext(), index, B));\n-}\n-\n extern \"C\" void LLVMRustAddFunctionAttrStringValue(LLVMValueRef Fn,\n \t\t\t\t\t\t   unsigned index,\n \t\t\t\t\t\t   const char *Name,\n@@ -175,31 +212,15 @@ extern \"C\" void LLVMRustAddFunctionAttrStringValue(LLVMValueRef Fn,\n \n extern \"C\" void LLVMRustRemoveFunctionAttributes(LLVMValueRef Fn,\n \t\t\t\t\t\t unsigned index,\n-\t\t\t\t\t\t uint64_t Val)\n+\t\t\t\t\t\t LLVMAttributeRef attr)\n {\n-  Function *A = unwrap<Function>(Fn);\n-  const AttributeSet PAL = A->getAttributes();\n-  AttrBuilder B(Val);\n+  Function *F = unwrap<Function>(Fn);\n+  const AttributeSet PAL = F->getAttributes();\n+  AttrBuilder B(unwrap(attr));\n   const AttributeSet PALnew =\n-    PAL.removeAttributes(A->getContext(), index,\n-                         AttributeSet::get(A->getContext(), index, B));\n-  A->setAttributes(PALnew);\n-}\n-\n-extern \"C\" void LLVMRustRemoveFunctionAttrString(LLVMValueRef fn,\n-\t\t\t\t\t\t unsigned index,\n-\t\t\t\t\t\t const char *Name)\n-{\n-  Function *f = unwrap<Function>(fn);\n-  LLVMContext &C = f->getContext();\n-  AttrBuilder B;\n-  B.addAttribute(Name);\n-  AttributeSet to_remove = AttributeSet::get(C, index, B);\n-\n-  AttributeSet attrs = f->getAttributes();\n-  f->setAttributes(attrs.removeAttributes(f->getContext(),\n-                                          index,\n-                                          to_remove));\n+    PAL.removeAttributes(F->getContext(), index,\n+                         AttributeSet::get(F->getContext(), index, B));\n+  F->setAttributes(PALnew);\n }\n \n // enable fpmath flag UnsafeAlgebra\n@@ -1293,3 +1314,7 @@ extern \"C\" LLVMRustLinkage LLVMRustGetLinkage(LLVMValueRef V) {\n extern \"C\" void LLVMRustSetLinkage(LLVMValueRef V, LLVMRustLinkage RustLinkage) {\n     LLVMSetLinkage(V, from_rust(RustLinkage));\n }\n+\n+extern \"C\" LLVMContextRef LLVMRustGetValueContext(LLVMValueRef V) {\n+    return wrap(&unwrap(V)->getContext());\n+}"}, {"sha": "346153d578c4a8afab4c24c50aed475f2fce557f", "filename": "src/rustllvm/rustllvm.h", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0bd2ce62b27e2b9a7dfe92fc23d9098854008089/src%2Frustllvm%2Frustllvm.h", "raw_url": "https://github.com/rust-lang/rust/raw/0bd2ce62b27e2b9a7dfe92fc23d9098854008089/src%2Frustllvm%2Frustllvm.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.h?ref=0bd2ce62b27e2b9a7dfe92fc23d9098854008089", "patch": "@@ -72,6 +72,28 @@ enum class LLVMRustResult {\n     Failure\n };\n \n+enum LLVMRustAttribute {\n+    AlwaysInline    = 0,\n+    ByVal           = 1,\n+    Cold            = 2,\n+    InlineHint      = 3,\n+    MinSize         = 4,\n+    Naked           = 5,\n+    NoAlias         = 6,\n+    NoCapture       = 7,\n+    NoInline        = 8,\n+    NonNull         = 9,\n+    NoRedZone       = 10,\n+    NoReturn        = 11,\n+    NoUnwind        = 12,\n+    OptimizeForSize = 13,\n+    ReadOnly        = 14,\n+    SExt            = 15,\n+    StructRet       = 16,\n+    UWTable         = 17,\n+    ZExt            = 18,\n+};\n+\n typedef struct OpaqueRustString *RustStringRef;\n typedef struct LLVMOpaqueTwine *LLVMTwineRef;\n typedef struct LLVMOpaqueDebugLoc *LLVMDebugLocRef;"}]}