{"sha": "cc8086a045abf1aaac29c3d33b1a18a9ae67a58d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjODA4NmEwNDVhYmYxYWFhYzI5YzNkMzNiMWExOGE5YWU2N2E1OGQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-07-25T13:41:56Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-07-25T16:19:02Z"}, "message": "add new deprecated_mode lint pass\n\nIt will warn you if you use the default mode for something that\nis expensive to copy, and it will warn you if you use any explicit\nmode other than copy.  So you should migrate over to using the\ndefault mode for most things (and borrowed pointers when you don't\nwant to copy) and copy mode for things you really wanted to copy.", "tree": {"sha": "1338e5a4c286b8b9b160ded47de1a969bbc8387a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1338e5a4c286b8b9b160ded47de1a969bbc8387a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc8086a045abf1aaac29c3d33b1a18a9ae67a58d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc8086a045abf1aaac29c3d33b1a18a9ae67a58d", "html_url": "https://github.com/rust-lang/rust/commit/cc8086a045abf1aaac29c3d33b1a18a9ae67a58d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc8086a045abf1aaac29c3d33b1a18a9ae67a58d/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99674dc52b45a22b49f13242be9d931009b4f276", "url": "https://api.github.com/repos/rust-lang/rust/commits/99674dc52b45a22b49f13242be9d931009b4f276", "html_url": "https://github.com/rust-lang/rust/commit/99674dc52b45a22b49f13242be9d931009b4f276"}], "stats": {"total": 182, "additions": 161, "deletions": 21}, "files": [{"sha": "7de4c0f73b2354ef1b4d976faf037475c0440e4e", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 56, "deletions": 3, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/cc8086a045abf1aaac29c3d33b1a18a9ae67a58d/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc8086a045abf1aaac29c3d33b1a18a9ae67a58d/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=cc8086a045abf1aaac29c3d33b1a18a9ae67a58d", "patch": "@@ -7,7 +7,8 @@ import syntax::codemap::span;\n import std::map::{map,hashmap,int_hash,hash_from_strs};\n import std::smallintmap::{map,smallintmap};\n import io::writer_util;\n-import syntax::print::pprust::expr_to_str;\n+import util::ppaux::{ty_to_str};\n+import syntax::print::pprust::{expr_to_str, mode_to_str};\n export lint, ctypes, unused_imports, while_true, path_statement, old_vecs;\n export unrecognized_warning, non_implicitly_copyable_typarams;\n export vecs_not_implicitly_copyable, implicit_copies;\n@@ -47,6 +48,7 @@ enum lint {\n     unrecognized_warning,\n     non_implicitly_copyable_typarams,\n     vecs_not_implicitly_copyable,\n+    deprecated_mode,\n }\n \n // This is pretty unfortunate. We really want some sort of \"deriving Enum\"\n@@ -61,6 +63,7 @@ fn int_to_lint(i: int) -> lint {\n       5 { unrecognized_warning }\n       6 { non_implicitly_copyable_typarams }\n       7 { vecs_not_implicitly_copyable }\n+      8 { deprecated_mode }\n     }\n }\n \n@@ -119,8 +122,12 @@ fn get_lint_dict() -> lint_dict {\n         (~\"implicit_copies\",\n          @{lint: implicit_copies,\n            desc: ~\"implicit copies of non implicitly copyable data\",\n-           default: warn})\n+           default: warn}),\n \n+        (~\"deprecated_mode\",\n+         @{lint: deprecated_mode,\n+           desc: ~\"warn about deprecated uses of modes\",\n+           default: ignore})\n     ];\n     hash_from_strs(v)\n }\n@@ -411,10 +418,56 @@ fn check_item_path_statement(cx: ty::ctxt, it: @ast::item) {\n     visit::visit_item(it, (), visit);\n }\n \n+fn check_fn(tcx: ty::ctxt, fk: visit::fn_kind, decl: ast::fn_decl,\n+            _body: ast::blk, span: span, id: ast::node_id) {\n+    #debug[\"lint check_fn fk=%? id=%?\", fk, id];\n+    let fn_ty = ty::node_id_to_type(tcx, id);\n+    alt check ty::get(fn_ty).struct {\n+      ty::ty_fn(fn_ty) {\n+        let mut counter = 0;\n+        do vec::iter2(fn_ty.inputs, decl.inputs) |arg_ty, arg_ast| {\n+            counter += 1;\n+            #debug[\"arg %d, ty=%s, mode=%s\",\n+                   counter,\n+                   ty_to_str(tcx, arg_ty.ty),\n+                   mode_to_str(arg_ast.mode)];\n+            alt arg_ast.mode {\n+              ast::expl(ast::by_copy) => {\n+                /* always allow by-copy */\n+              }\n+\n+              ast::expl(_) => {\n+                tcx.sess.span_lint(\n+                    deprecated_mode, id, id,\n+                    span,\n+                    #fmt[\"argument %d uses an explicit mode\", counter]);\n+              }\n+\n+              ast::infer(_) {\n+                let kind = ty::type_kind(tcx, arg_ty.ty);\n+                if !ty::kind_is_safe_for_default_mode(kind) {\n+                    tcx.sess.span_lint(\n+                        deprecated_mode, id, id,\n+                        span,\n+                        #fmt[\"argument %d uses the default mode \\\n+                              but shouldn't\",\n+                             counter]);\n+                }\n+              }\n+            }\n+        }\n+      }\n+    }\n+}\n+\n fn check_crate(tcx: ty::ctxt, crate: @ast::crate) {\n \n     let v = visit::mk_simple_visitor(@{\n-        visit_item: fn@(it: @ast::item) { check_item(it, tcx); }\n+        visit_item:\n+            |it| check_item(it, tcx),\n+        visit_fn:\n+            |fk, decl, body, span, id| check_fn(tcx, fk, decl, body,\n+                                                span, id),\n         with *visit::default_simple_visitor()\n     });\n     visit::visit_crate(*crate, (), v);"}, {"sha": "b6b1873b1dc237b2bc636b8d0f9846c53cdffbad", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 105, "deletions": 18, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/cc8086a045abf1aaac29c3d33b1a18a9ae67a58d/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc8086a045abf1aaac29c3d33b1a18a9ae67a58d/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=cc8086a045abf1aaac29c3d33b1a18a9ae67a58d", "patch": "@@ -110,6 +110,7 @@ export ty_fn_args;\n export kind, kind_implicitly_copyable, kind_send_copy, kind_copyable;\n export kind_noncopyable, kind_const;\n export kind_can_be_copied, kind_can_be_sent, kind_can_be_implicitly_copied;\n+export kind_is_safe_for_default_mode;\n export kind_is_owned;\n export proto_kind, kind_lteq, type_kind;\n export operators;\n@@ -1371,19 +1372,22 @@ fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n enum kind { kind_(u32) }\n \n /// can be copied (implicitly or explicitly)\n-const KIND_MASK_COPY     : u32 = 0b00000000000000000000000000000001_u32;\n+const KIND_MASK_COPY         : u32 = 0b000000000000000000000000001_u32;\n \n /// can be sent: no shared box, borrowed ptr (must imply OWNED)\n-const KIND_MASK_SEND     : u32 = 0b00000000000000000000000000000010_u32;\n+const KIND_MASK_SEND         : u32 = 0b000000000000000000000000010_u32;\n \n /// is owned (no borrowed ptrs)\n-const KIND_MASK_OWNED    : u32 = 0b00000000000000000000000000000100_u32;\n+const KIND_MASK_OWNED        : u32 = 0b000000000000000000000000100_u32;\n \n /// is deeply immutable\n-const KIND_MASK_CONST    : u32 = 0b00000000000000000000000000001000_u32;\n+const KIND_MASK_CONST        : u32 = 0b000000000000000000000001000_u32;\n \n /// can be implicitly copied (must imply COPY)\n-const KIND_MASK_IMPLICIT : u32 = 0b00000000000000000000000000010000_u32;\n+const KIND_MASK_IMPLICIT     : u32 = 0b000000000000000000000010000_u32;\n+\n+/// safe for default mode (subset of KIND_MASK_IMPLICIT)\n+const KIND_MASK_DEFAULT_MODE : u32 = 0b000000000000000000000100000_u32;\n \n fn kind_noncopyable() -> kind {\n     kind_(0u32)\n@@ -1397,10 +1401,22 @@ fn kind_implicitly_copyable() -> kind {\n     kind_(KIND_MASK_IMPLICIT | KIND_MASK_COPY)\n }\n \n+fn kind_safe_for_default_mode() -> kind {\n+    // similar to implicit copy, but always includes vectors and strings\n+    kind_(KIND_MASK_DEFAULT_MODE | KIND_MASK_IMPLICIT | KIND_MASK_COPY)\n+}\n+\n fn kind_implicitly_sendable() -> kind {\n     kind_(KIND_MASK_IMPLICIT | KIND_MASK_COPY | KIND_MASK_SEND)\n }\n \n+fn kind_safe_for_default_mode_send() -> kind {\n+    // similar to implicit copy, but always includes vectors and strings\n+    kind_(KIND_MASK_DEFAULT_MODE | KIND_MASK_IMPLICIT |\n+          KIND_MASK_COPY | KIND_MASK_SEND)\n+}\n+\n+\n fn kind_send_copy() -> kind {\n     kind_(KIND_MASK_COPY | KIND_MASK_SEND)\n }\n@@ -1426,7 +1442,7 @@ fn remove_const(k: kind) -> kind {\n }\n \n fn remove_implicit(k: kind) -> kind {\n-    k - kind_(KIND_MASK_IMPLICIT)\n+    k - kind_(KIND_MASK_IMPLICIT | KIND_MASK_DEFAULT_MODE)\n }\n \n fn remove_send(k: kind) -> kind {\n@@ -1462,6 +1478,10 @@ pure fn kind_can_be_implicitly_copied(k: kind) -> bool {\n     *k & KIND_MASK_IMPLICIT == KIND_MASK_IMPLICIT\n }\n \n+pure fn kind_is_safe_for_default_mode(k: kind) -> bool {\n+    *k & KIND_MASK_DEFAULT_MODE == KIND_MASK_DEFAULT_MODE\n+}\n+\n pure fn kind_can_be_copied(k: kind) -> bool {\n     *k & KIND_MASK_COPY == KIND_MASK_COPY\n }\n@@ -1478,9 +1498,9 @@ fn proto_kind(p: proto) -> kind {\n     alt p {\n       ast::proto_any { kind_noncopyable() }\n       ast::proto_block { kind_noncopyable() }\n-      ast::proto_box { kind_implicitly_copyable() | kind_owned() }\n+      ast::proto_box { kind_safe_for_default_mode() | kind_owned() }\n       ast::proto_uniq { kind_send_copy() | kind_owned() }\n-      ast::proto_bare { kind_implicitly_sendable() | kind_const() |\n+      ast::proto_bare { kind_safe_for_default_mode_send() | kind_const() |\n                            kind_owned() }\n     }\n }\n@@ -1539,11 +1559,11 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n     // Insert a default in case we loop back on self recursively.\n     cx.kind_cache.insert(ty, kind_top());\n \n-    let result = alt get(ty).struct {\n+    let mut result = alt get(ty).struct {\n       // Scalar and unique types are sendable, constant, and owned\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n       ty_ptr(_) {\n-        kind_implicitly_sendable() | kind_const() | kind_owned()\n+        kind_safe_for_default_mode_send() | kind_const() | kind_owned()\n       }\n \n       // Implicit copyability of strs is configurable\n@@ -1561,14 +1581,14 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n       // Those with refcounts raise noncopyable to copyable,\n       // lower sendable to copyable. Therefore just set result to copyable.\n       ty_box(tm) {\n-        remove_send(mutable_type_kind(cx, tm) | kind_implicitly_copyable())\n+        remove_send(mutable_type_kind(cx, tm) | kind_safe_for_default_mode())\n       }\n \n       // Iface instances are (for now) like shared boxes, basically\n-      ty_trait(_, _) { kind_implicitly_copyable() | kind_owned() }\n+      ty_trait(_, _) { kind_safe_for_default_mode() | kind_owned() }\n \n       // Region pointers are copyable but NOT owned nor sendable\n-      ty_rptr(_, _) { kind_implicitly_copyable() }\n+      ty_rptr(_, _) { kind_safe_for_default_mode() }\n \n       // Unique boxes and vecs have the kind of their contained type,\n       // but unique boxes can't be implicitly copyable.\n@@ -1587,10 +1607,10 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n       // contained type, but aren't implicitly copyable.  Fixed vectors have\n       // the kind of the element they contain, taking mutability into account.\n       ty_evec(tm, vstore_box) {\n-        remove_send(kind_implicitly_copyable() | mutable_type_kind(cx, tm))\n+        remove_send(kind_safe_for_default_mode() | mutable_type_kind(cx, tm))\n       }\n       ty_evec(tm, vstore_slice(_)) {\n-        remove_owned_send(kind_implicitly_copyable() |\n+        remove_owned_send(kind_safe_for_default_mode() |\n                           mutable_type_kind(cx, tm))\n       }\n       ty_evec(tm, vstore_fixed(_)) {\n@@ -1599,13 +1619,13 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n \n       // All estrs are copyable; uniques and interiors are sendable.\n       ty_estr(vstore_box) {\n-        kind_implicitly_copyable() | kind_const() | kind_owned()\n+        kind_safe_for_default_mode() | kind_const() | kind_owned()\n       }\n       ty_estr(vstore_slice(_)) {\n-        kind_implicitly_copyable() | kind_const()\n+        kind_safe_for_default_mode() | kind_const()\n       }\n       ty_estr(vstore_fixed(_)) {\n-        kind_implicitly_sendable() | kind_const() | kind_owned()\n+        kind_safe_for_default_mode_send() | kind_const() | kind_owned()\n       }\n \n       // Records lower to the lowest of their members.\n@@ -1676,10 +1696,77 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n       }\n     };\n \n+    // arbitrary threshold to prevent by-value copying of big records\n+    if kind_is_safe_for_default_mode(result) {\n+        if type_size(cx, ty) > 4 {\n+            result -= kind_(KIND_MASK_DEFAULT_MODE);\n+        }\n+    }\n+\n     cx.kind_cache.insert(ty, result);\n     ret result;\n }\n \n+/// gives a rough estimate of how much space it takes to represent\n+/// an instance of `ty`.  Used for the mode transition.\n+fn type_size(cx: ctxt, ty: t) -> uint {\n+    alt get(ty).struct {\n+      ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n+      ty_ptr(_) | ty_box(_) | ty_uniq(_) | ty_estr(vstore_uniq) |\n+      ty_trait(*) | ty_rptr(*) | ty_evec(_, vstore_uniq) |\n+      ty_evec(_, vstore_box) | ty_estr(vstore_box) => {\n+        1\n+      }\n+\n+      ty_evec(_, vstore_slice(_)) |\n+      ty_estr(vstore_slice(_)) |\n+      ty_fn(_) => {\n+        2\n+      }\n+\n+      ty_evec(t, vstore_fixed(n)) => {\n+        type_size(cx, t.ty) * n\n+      }\n+\n+      ty_estr(vstore_fixed(n)) => {\n+        n\n+      }\n+\n+      ty_rec(flds) => {\n+        flds.foldl(0, |s, f| s + type_size(cx, f.mt.ty))\n+      }\n+\n+      ty_class(did, substs) {\n+        let flds = class_items_as_fields(cx, did, substs);\n+        flds.foldl(0, |s, f| s + type_size(cx, f.mt.ty))\n+      }\n+\n+      ty_tup(tys) {\n+        tys.foldl(0, |s, t| s + type_size(cx, t))\n+      }\n+\n+      ty_enum(did, substs) {\n+        let variants = substd_enum_variants(cx, did, substs);\n+        variants.foldl( // find max size of any variant\n+            0,\n+            |m, v| uint::max(m,\n+                             // find size of this variant:\n+                             v.args.foldl(0, |s, a| s + type_size(cx, a))))\n+      }\n+\n+      ty_param(_) | ty_self {\n+        1\n+      }\n+\n+      ty_var(_) | ty_var_integral(_) {\n+        cx.sess.bug(~\"Asked to compute kind of a type variable\");\n+      }\n+      ty_type | ty_opaque_closure_ptr(_) | ty_opaque_box | ty_unboxed_vec(_) {\n+        cx.sess.bug(~\"Asked to compute kind of fictitious type\");\n+      }\n+    }\n+}\n+\n // True if instantiating an instance of `r_ty` requires an instance of `r_ty`.\n fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n "}]}