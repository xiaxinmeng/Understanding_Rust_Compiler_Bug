{"sha": "8bba5ad3098e3f20ab3c506e5a421df5da010df9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiYmE1YWQzMDk4ZTNmMjBhYjNjNTA2ZTVhNDIxZGY1ZGEwMTBkZjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-12T08:45:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-12T08:45:39Z"}, "message": "Auto merge of #43107 - michaelwoerister:less-span-info-in-debug, r=nikomatsakis\n\nincr.comp.: Don't include span information in the ICH of type definitions\n\nThis should improve some of the `regex` tests on perf.rlo. Not including spans into the ICH is harmless until we also cache warnings. To really solve the problem, we need to do more refactoring (see #43088).\n\nr? @nikomatsakis", "tree": {"sha": "e50c4401ababda50cef8c60b9d9b9fc1a52556c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e50c4401ababda50cef8c60b9d9b9fc1a52556c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8bba5ad3098e3f20ab3c506e5a421df5da010df9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8bba5ad3098e3f20ab3c506e5a421df5da010df9", "html_url": "https://github.com/rust-lang/rust/commit/8bba5ad3098e3f20ab3c506e5a421df5da010df9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8bba5ad3098e3f20ab3c506e5a421df5da010df9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ac29bdd110b7f09b6ca6c0a1917d81285d64b3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ac29bdd110b7f09b6ca6c0a1917d81285d64b3a", "html_url": "https://github.com/rust-lang/rust/commit/8ac29bdd110b7f09b6ca6c0a1917d81285d64b3a"}, {"sha": "bca857021efb4fe5288f596f2553878dd4bed241", "url": "https://api.github.com/repos/rust-lang/rust/commits/bca857021efb4fe5288f596f2553878dd4bed241", "html_url": "https://github.com/rust-lang/rust/commit/bca857021efb4fe5288f596f2553878dd4bed241"}], "stats": {"total": 148, "additions": 101, "deletions": 47}, "files": [{"sha": "7805029a67ff78d086f94b259cbbb9d59ba4bf91", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/8bba5ad3098e3f20ab3c506e5a421df5da010df9/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bba5ad3098e3f20ab3c506e5a421df5da010df9/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=8bba5ad3098e3f20ab3c506e5a421df5da010df9", "patch": "@@ -895,25 +895,28 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::I\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n-        let node_id_hashing_mode = match self.node {\n-            hir::ItemExternCrate(..) |\n+        let (node_id_hashing_mode, hash_spans) = match self.node {\n             hir::ItemStatic(..)      |\n             hir::ItemConst(..)       |\n-            hir::ItemFn(..)          |\n-            hir::ItemMod(..)         |\n+            hir::ItemFn(..)          => {\n+                (NodeIdHashingMode::Ignore, hcx.hash_spans())\n+            }\n+            hir::ItemUse(..) => {\n+                (NodeIdHashingMode::HashTraitsInScope, false)\n+            }\n+\n+            hir::ItemExternCrate(..) |\n             hir::ItemForeignMod(..)  |\n             hir::ItemGlobalAsm(..)   |\n+            hir::ItemMod(..)         |\n+            hir::ItemDefaultImpl(..) |\n+            hir::ItemTrait(..)       |\n+            hir::ItemImpl(..)        |\n             hir::ItemTy(..)          |\n             hir::ItemEnum(..)        |\n             hir::ItemStruct(..)      |\n-            hir::ItemUnion(..)       |\n-            hir::ItemTrait(..)       |\n-            hir::ItemDefaultImpl(..) |\n-            hir::ItemImpl(..)        => {\n-                NodeIdHashingMode::Ignore\n-            }\n-            hir::ItemUse(..) => {\n-                NodeIdHashingMode::HashTraitsInScope\n+            hir::ItemUnion(..)       => {\n+                (NodeIdHashingMode::Ignore, false)\n             }\n         };\n \n@@ -927,14 +930,16 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::I\n         } = *self;\n \n         hcx.hash_hir_item_like(attrs, |hcx| {\n-            hcx.with_node_id_hashing_mode(node_id_hashing_mode, |hcx| {\n-                id.hash_stable(hcx, hasher);\n+            hcx.while_hashing_spans(hash_spans, |hcx| {\n+                hcx.with_node_id_hashing_mode(node_id_hashing_mode, |hcx| {\n+                    id.hash_stable(hcx, hasher);\n+                });\n+                name.hash_stable(hcx, hasher);\n+                attrs.hash_stable(hcx, hasher);\n+                node.hash_stable(hcx, hasher);\n+                vis.hash_stable(hcx, hasher);\n+                span.hash_stable(hcx, hasher);\n             });\n-            name.hash_stable(hcx, hasher);\n-            attrs.hash_stable(hcx, hasher);\n-            node.hash_stable(hcx, hasher);\n-            vis.hash_stable(hcx, hasher);\n-            span.hash_stable(hcx, hasher);\n         });\n     }\n }"}, {"sha": "61204b88e130ef715d518f0a72e6d077c895d837", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8bba5ad3098e3f20ab3c506e5a421df5da010df9/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bba5ad3098e3f20ab3c506e5a421df5da010df9/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=8bba5ad3098e3f20ab3c506e5a421df5da010df9", "patch": "@@ -14,7 +14,7 @@ use self::MemberDescriptionFactory::*;\n use self::EnumDiscriminantInfo::*;\n \n use super::utils::{debug_context, DIB, span_start, bytes_to_bits, size_and_align_of,\n-                   get_namespace_and_span_for_item, create_DIArray, is_node_local_to_unit};\n+                   get_namespace_for_item, create_DIArray, is_node_local_to_unit};\n use super::namespace::mangled_name_of_item;\n use super::type_names::compute_debuginfo_type_name;\n use super::{CrateDebugContext};\n@@ -421,7 +421,7 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let containing_scope = match trait_type.sty {\n         ty::TyDynamic(ref data, ..) => if let Some(principal) = data.principal() {\n             let def_id = principal.def_id();\n-            get_namespace_and_span_for_item(cx, def_id).0\n+            get_namespace_for_item(cx, def_id)\n         } else {\n             NO_SCOPE_METADATA\n         },\n@@ -971,7 +971,7 @@ fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         _ => bug!(\"prepare_struct_metadata on a non-ADT\")\n     };\n \n-    let (containing_scope, _) = get_namespace_and_span_for_item(cx, struct_def_id);\n+    let containing_scope = get_namespace_for_item(cx, struct_def_id);\n \n     let struct_metadata_stub = create_struct_stub(cx,\n                                                   struct_llvm_type,\n@@ -1096,7 +1096,7 @@ fn prepare_union_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         _ => bug!(\"prepare_union_metadata on a non-ADT\")\n     };\n \n-    let (containing_scope, _) = get_namespace_and_span_for_item(cx, union_def_id);\n+    let containing_scope = get_namespace_for_item(cx, union_def_id);\n \n     let union_metadata_stub = create_union_stub(cx,\n                                                 union_llvm_type,\n@@ -1483,7 +1483,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                    -> RecursiveTypeDescription<'tcx> {\n     let enum_name = compute_debuginfo_type_name(cx, enum_type, false);\n \n-    let (containing_scope, _) = get_namespace_and_span_for_item(cx, enum_def_id);\n+    let containing_scope = get_namespace_for_item(cx, enum_def_id);\n     // FIXME: This should emit actual file metadata for the enum, but we\n     // currently can't get the necessary information when it comes to types\n     // imported from other crates. Formerly we violated the ODR when performing\n@@ -1781,7 +1781,8 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     let tcx = cx.tcx();\n \n     let node_def_id = tcx.hir.local_def_id(node_id);\n-    let (var_scope, span) = get_namespace_and_span_for_item(cx, node_def_id);\n+    let var_scope = get_namespace_for_item(cx, node_def_id);\n+    let span = cx.tcx().def_span(node_def_id);\n \n     let (file_metadata, line_number) = if span != syntax_pos::DUMMY_SP {\n         let loc = span_start(cx, span);"}, {"sha": "d4dd112f3027f2d72816edd13af97fb766670264", "filename": "src/librustc_trans/debuginfo/namespace.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8bba5ad3098e3f20ab3c506e5a421df5da010df9/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bba5ad3098e3f20ab3c506e5a421df5da010df9/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs?ref=8bba5ad3098e3f20ab3c506e5a421df5da010df9", "patch": "@@ -10,19 +10,17 @@\n \n // Namespace Handling.\n \n-use super::metadata::{file_metadata, unknown_file_metadata, UNKNOWN_LINE_NUMBER};\n-use super::utils::{DIB, debug_context, span_start};\n+use super::metadata::{unknown_file_metadata, UNKNOWN_LINE_NUMBER};\n+use super::utils::{DIB, debug_context};\n \n use llvm;\n use llvm::debuginfo::DIScope;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;\n use common::CrateContext;\n \n-use libc::c_uint;\n use std::ffi::CString;\n use std::ptr;\n-use syntax_pos::DUMMY_SP;\n \n pub fn mangled_name_of_item(ccx: &CrateContext, def_id: DefId, extra: &str) -> String {\n     fn fill_nested(ccx: &CrateContext, def_id: DefId, extra: &str, output: &mut String) {\n@@ -69,21 +67,14 @@ pub fn item_namespace(ccx: &CrateContext, def_id: DefId) -> DIScope {\n     };\n \n     let namespace_name = CString::new(namespace_name.as_bytes()).unwrap();\n-    let span = ccx.tcx().def_span(def_id);\n-    let (file, line) = if span != DUMMY_SP {\n-        let loc = span_start(ccx, span);\n-        (file_metadata(ccx, &loc.file.name, def_id.krate), loc.line as c_uint)\n-    } else {\n-        (unknown_file_metadata(ccx), UNKNOWN_LINE_NUMBER)\n-    };\n \n     let scope = unsafe {\n         llvm::LLVMRustDIBuilderCreateNameSpace(\n             DIB(ccx),\n             parent_scope,\n             namespace_name.as_ptr(),\n-            file,\n-            line as c_uint)\n+            unknown_file_metadata(ccx),\n+            UNKNOWN_LINE_NUMBER)\n     };\n \n     debug_context(ccx).namespace_map.borrow_mut().insert(def_id, scope);"}, {"sha": "0555714d623e6dc706cb1839cea3be20a047554e", "filename": "src/librustc_trans/debuginfo/utils.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8bba5ad3098e3f20ab3c506e5a421df5da010df9/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bba5ad3098e3f20ab3c506e5a421df5da010df9/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs?ref=8bba5ad3098e3f20ab3c506e5a421df5da010df9", "patch": "@@ -73,13 +73,7 @@ pub fn DIB(cx: &CrateContext) -> DIBuilderRef {\n     cx.dbg_cx().as_ref().unwrap().builder\n }\n \n-pub fn get_namespace_and_span_for_item(cx: &CrateContext, def_id: DefId)\n-                                   -> (DIScope, Span) {\n-    let containing_scope = item_namespace(cx, cx.tcx().parent(def_id)\n-        .expect(\"get_namespace_and_span_for_item: missing parent?\"));\n-\n-    // Try to get some span information, if we have an inlined item.\n-    let definition_span = cx.tcx().def_span(def_id);\n-\n-    (containing_scope, definition_span)\n+pub fn get_namespace_for_item(cx: &CrateContext, def_id: DefId) -> DIScope {\n+    item_namespace(cx, cx.tcx().parent(def_id)\n+        .expect(\"get_namespace_for_item: missing parent?\"))\n }"}, {"sha": "7d8e6c9d9d7efd283eef2ecb0ecb760a8c189e5f", "filename": "src/test/incremental/spans_in_type_debuginfo.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/8bba5ad3098e3f20ab3c506e5a421df5da010df9/src%2Ftest%2Fincremental%2Fspans_in_type_debuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bba5ad3098e3f20ab3c506e5a421df5da010df9/src%2Ftest%2Fincremental%2Fspans_in_type_debuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fspans_in_type_debuginfo.rs?ref=8bba5ad3098e3f20ab3c506e5a421df5da010df9", "patch": "@@ -0,0 +1,63 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that moving a type definition within a source file does not affect\n+// re-compilation.\n+\n+// revisions:rpass1 rpass2\n+// compile-flags: -Z query-dep-graph -g\n+\n+#![rustc_partition_reused(module=\"spans_in_type_debuginfo\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"spans_in_type_debuginfo-structs\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"spans_in_type_debuginfo-enums\", cfg=\"rpass2\")]\n+\n+#![feature(rustc_attrs)]\n+\n+mod structs {\n+    #[cfg(rpass1)]\n+    pub struct X {\n+        pub x: u32,\n+    }\n+\n+    #[cfg(rpass2)]\n+    pub struct X {\n+        pub x: u32,\n+    }\n+\n+    pub fn foo(x: X) -> u32 {\n+        x.x\n+    }\n+}\n+\n+mod enums {\n+    #[cfg(rpass1)]\n+    pub enum X {\n+        A { x: u32 },\n+        B(u32),\n+    }\n+\n+    #[cfg(rpass2)]\n+    pub enum X {\n+        A { x: u32 },\n+        B(u32),\n+    }\n+\n+    pub fn foo(x: X) -> u32 {\n+        match x {\n+            X::A { x } => x,\n+            X::B(x) => x,\n+        }\n+    }\n+}\n+\n+pub fn main() {\n+    let _ = structs::foo(structs::X { x: 1 });\n+    let _ = enums::foo(enums::X::A { x: 2 });\n+}"}]}