{"sha": "cc2a1c7bd8e3271919dad8719e53c9d3ff007e2a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjMmExYzdiZDhlMzI3MTkxOWRhZDg3MTllNTNjOWQzZmYwMDdlMmE=", "commit": {"author": {"name": "Paul Faria", "email": "Nashenas88@gmail.com", "date": "2017-10-10T02:16:57Z"}, "committer": {"name": "Paul Daniel Faria", "email": "pfaria@localhost.localdomain", "date": "2017-10-13T12:42:54Z"}, "message": "Initial attempt at implementation of inference layout for nll", "tree": {"sha": "ca3f0e8275007842d82d506cb52255787a0af87c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca3f0e8275007842d82d506cb52255787a0af87c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc2a1c7bd8e3271919dad8719e53c9d3ff007e2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc2a1c7bd8e3271919dad8719e53c9d3ff007e2a", "html_url": "https://github.com/rust-lang/rust/commit/cc2a1c7bd8e3271919dad8719e53c9d3ff007e2a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc2a1c7bd8e3271919dad8719e53c9d3ff007e2a/comments", "author": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "43d95e2ce9e23940759dc529d6ea76c06ce27d4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/43d95e2ce9e23940759dc529d6ea76c06ce27d4d", "html_url": "https://github.com/rust-lang/rust/commit/43d95e2ce9e23940759dc529d6ea76c06ce27d4d"}], "stats": {"total": 229, "additions": 224, "deletions": 5}, "files": [{"sha": "e5d8b2e1379977e5af0da67a41c156d16ae1e3ec", "filename": "src/librustc_mir/transform/nll/infer.rs", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/cc2a1c7bd8e3271919dad8719e53c9d3ff007e2a/src%2Flibrustc_mir%2Ftransform%2Fnll%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc2a1c7bd8e3271919dad8719e53c9d3ff007e2a/src%2Flibrustc_mir%2Ftransform%2Fnll%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Finfer.rs?ref=cc2a1c7bd8e3271919dad8719e53c9d3ff007e2a", "patch": "@@ -0,0 +1,206 @@\n+use super::{Region, RegionIndex};\n+use std::mem;\n+use rustc::infer::InferCtxt;\n+use rustc::mir::{Location, Mir};\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use rustc_data_structures::fx::FxHashSet;\n+\n+pub struct InferenceContext {\n+    definitions: IndexVec<RegionIndex, VarDefinition>,\n+    constraints: IndexVec<ConstraintIndex, Constraint>,\n+    errors: IndexVec<InferenceErrorIndex, InferenceError>,\n+}\n+\n+pub struct InferenceError {\n+    pub constraint_point: Location,\n+    pub name: (), // TODO(nashenas88) RegionName\n+}\n+\n+newtype_index!(InferenceErrorIndex);\n+\n+struct VarDefinition {\n+    name: (), // TODO(nashenas88) RegionName\n+    value: Region,\n+    capped: bool,\n+}\n+\n+impl VarDefinition {\n+    pub fn new(value: Region) -> Self {\n+        Self {\n+            name: (),\n+            value,\n+            capped: false,\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct Constraint {\n+    sub: RegionIndex,\n+    sup: RegionIndex,\n+    point: Location,\n+}\n+\n+newtype_index!(ConstraintIndex);\n+\n+impl InferenceContext {\n+    pub fn new(values: IndexVec<RegionIndex, Region>) -> Self {\n+        Self {\n+            definitions: values.into_iter().map(VarDefinition::new).collect(),\n+            constraints: IndexVec::new(),\n+            errors: IndexVec::new(),\n+        }\n+    }\n+\n+    pub fn cap_var(&mut self, v: RegionIndex) {\n+        self.definitions[v].capped = true;\n+    }\n+\n+    pub fn add_live_point(&mut self, v: RegionIndex, point: Location) {\n+        debug!(\"add_live_point({:?}, {:?})\", v, point);\n+        let definition = &mut self.definitions[v];\n+        if definition.value.add_point(point) {\n+            if definition.capped {\n+                self.errors.push(InferenceError {\n+                    constraint_point: point,\n+                    name: definition.name,\n+                });\n+            }\n+        }\n+    }\n+\n+    pub fn add_outlives(&mut self, sup: RegionIndex, sub: RegionIndex, point: Location) {\n+        debug!(\"add_outlives({:?}: {:?} @ {:?}\", sup, sub, point);\n+        self.constraints.push(Constraint { sup, sub, point });\n+    }\n+\n+    pub fn region(&self, v: RegionIndex) -> &Region {\n+        &self.definitions[v].value\n+    }\n+\n+    pub fn solve<'a, 'gcx, 'tcx>(\n+        &mut self,\n+        infcx: InferCtxt<'a, 'gcx, 'tcx>,\n+        mir: &'a Mir<'tcx>,\n+    ) -> IndexVec<InferenceErrorIndex, InferenceError>\n+    where\n+        'gcx: 'tcx + 'a,\n+        'tcx: 'a,\n+    {\n+        let mut changed = true;\n+        let mut dfs = Dfs::new(infcx, mir);\n+        while changed {\n+            changed = false;\n+            for constraint in &self.constraints {\n+                let sub = &self.definitions[constraint.sub].value.clone();\n+                let sup_def = &self.definitions[constraint.sup];\n+                debug!(\"constraint: {:?}\", constraint);\n+                debug!(\"    sub (before): {:?}\", sub);\n+                debug!(\"    sup (before): {:?}\", sup_def.value);\n+\n+                if dfs.copy(sub, &mut sup_def.value, constraint.point) {\n+                    changed = true;\n+                    if sup_def.capped {\n+                        // This is kind of a hack, but when we add a\n+                        // constraint, the \"point\" is always the point\n+                        // AFTER the action that induced the\n+                        // constraint. So report the error on the\n+                        // action BEFORE that.\n+                        assert!(constraint.point.statement_index > 0);\n+                        let p = Location {\n+                            block: constraint.point.block,\n+                            statement_index: constraint.point.statement_index - 1,\n+                        };\n+\n+                        self.errors.push(InferenceError {\n+                            constraint_point: p,\n+                            name: sup_def.name,\n+                        });\n+                    }\n+                }\n+\n+                debug!(\"    sup (after) : {:?}\", sup_def.value);\n+                debug!(\"    changed     : {:?}\", changed);\n+            }\n+            debug!(\"\\n\");\n+        }\n+\n+        mem::replace(&mut self.errors, IndexVec::new())\n+    }\n+}\n+\n+struct Dfs<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> {\n+    infcx: InferCtxt<'a, 'gcx, 'tcx>,\n+    mir: &'a Mir<'tcx>,\n+}\n+\n+impl<'a, 'gcx: 'tcx, 'tcx: 'a> Dfs<'a, 'gcx, 'tcx> {\n+    fn new(infcx: InferCtxt<'a, 'gcx, 'tcx>, mir: &'a Mir<'tcx>) -> Self {\n+        Self { infcx, mir }\n+    }\n+\n+    fn copy(\n+        &mut self,\n+        from_region: &Region,\n+        to_region: &mut Region,\n+        start_point: Location,\n+    ) -> bool {\n+        let mut changed = false;\n+\n+        let mut stack = vec![];\n+        let mut visited = FxHashSet();\n+\n+        stack.push(start_point);\n+        while let Some(p) = stack.pop() {\n+            debug!(\"        dfs: p={:?}\", p);\n+\n+            if !from_region.may_contain(p) {\n+                debug!(\"            not in from-region\");\n+                continue;\n+            }\n+\n+            if !visited.insert(p) {\n+                debug!(\"            already visited\");\n+                continue;\n+            }\n+\n+            changed |= to_region.add_point(p);\n+\n+            let block_data = self.mir[p.block];\n+            let successor_points = if p.statement_index < block_data.statements.len() {\n+                vec![Location {\n+                    statement_index: p.statement_index + 1,\n+                    ..p\n+                }]\n+            } else {\n+                block_data.terminator()\n+                    .successors()\n+                    .iter()\n+                    .map(|&basic_block| Location {\n+                        statement_index: 0,\n+                        block: basic_block,\n+                    })\n+                    .collect::<Vec<_>>()\n+            };\n+\n+            if successor_points.is_empty() {\n+                // If we reach the END point in the graph, then copy\n+                // over any skolemized end points in the `from_region`\n+                // and make sure they are included in the `to_region`.\n+                for region_decl in self.infcx.tcx.tables.borrow().free_region_map() {\n+                    // TODO(nashenas88) figure out skolemized_end points\n+                    let block = self.env.graph.skolemized_end(region_decl.name);\n+                    let skolemized_end_point = Location {\n+                        block,\n+                        statement_index: 0,\n+                    };\n+                    changed |= to_region.add_point(skolemized_end_point);\n+                }\n+            } else {\n+                stack.extend(successor_points);\n+            }\n+        }\n+\n+        changed\n+    }\n+}"}, {"sha": "ab3e16e4ebb69545b9fe873a1f3e0a3340f5e6fc", "filename": "src/librustc_mir/transform/nll/mod.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cc2a1c7bd8e3271919dad8719e53c9d3ff007e2a/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc2a1c7bd8e3271919dad8719e53c9d3ff007e2a/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs?ref=cc2a1c7bd8e3271919dad8719e53c9d3ff007e2a", "patch": "@@ -8,13 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use self::infer::InferenceContext;\n use rustc::ty::TypeFoldable;\n use rustc::ty::subst::{Kind, Substs};\n use rustc::ty::{Ty, TyCtxt, ClosureSubsts, RegionVid, RegionKind};\n use rustc::mir::{Mir, Location, Rvalue, BasicBlock, Statement, StatementKind};\n use rustc::mir::visit::{MutVisitor, Lookup};\n use rustc::mir::transform::{MirPass, MirSource};\n-use rustc::infer::{self, InferCtxt};\n+use rustc::infer::{self as rustc_infer, InferCtxt};\n use rustc::util::nodemap::FxHashSet;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use syntax_pos::DUMMY_SP;\n@@ -24,6 +25,8 @@ use std::fmt;\n use util as mir_util;\n use self::mir_util::PassWhere;\n \n+mod infer;\n+\n #[allow(dead_code)]\n struct NLLVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     lookup_map: HashMap<RegionVid, Lookup>,\n@@ -40,14 +43,14 @@ impl<'a, 'gcx, 'tcx> NLLVisitor<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn into_results(self) -> HashMap<RegionVid, Lookup> {\n-        self.lookup_map\n+    pub fn into_results(self) -> (HashMap<RegionVid, Lookup>, IndexVec<RegionIndex, Region>) {\n+        (self.lookup_map, self.regions)\n     }\n \n     fn renumber_regions<T>(&mut self, value: &T) -> T where T: TypeFoldable<'tcx> {\n         self.infcx.tcx.fold_regions(value, &mut false, |_region, _depth| {\n             self.regions.push(Region::default());\n-            self.infcx.next_region_var(infer::MiscVariable(DUMMY_SP))\n+            self.infcx.next_region_var(rustc_infer::MiscVariable(DUMMY_SP))\n         })\n     }\n \n@@ -157,7 +160,9 @@ impl MirPass for NLL {\n                 }\n                 Ok(())\n             });\n-            let _results = visitor.into_results();\n+            let (_lookup_map, regions) = visitor.into_results();\n+            let inference_context = InferenceContext::new(regions);\n+            inference_context.solve(infcx, &renumbered_mir);\n         })\n     }\n }\n@@ -173,6 +178,14 @@ impl fmt::Debug for Region {\n     }\n }\n \n+impl Region {\n+    pub fn add_point(&mut self, point: Location) -> bool {\n+        self.points.insert(point)\n+    }\n \n+    pub fn may_contain(&self, point: Location) -> bool {\n+        self.points.contains(&point)\n+    }\n+}\n \n newtype_index!(RegionIndex);"}]}