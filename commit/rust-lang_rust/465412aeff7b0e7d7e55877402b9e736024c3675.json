{"sha": "465412aeff7b0e7d7e55877402b9e736024c3675", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2NTQxMmFlZmY3YjBlN2Q3ZTU1ODc3NDAyYjllNzM2MDI0YzM2NzU=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-05-05T16:30:56Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-05-23T05:29:16Z"}, "message": "std: first-pass at a tcp server API, with a basic (non-robust) test\n\nalso whitespace cleanup\n\n.. for now, the test just spins up the server and listens for messages,\nechoing them back to an output port. there's a \"kill\" msg that it will\nlisten for. need to point the tcp client and server test impls at each\nother for a loopback server/client test, like how its done in uv::ll\n\nonce ipv6 parse/format lands, i can add another test using the entirely\nsame codebase, but substituting an ip_addr ipv6 varient for the ipv4\nvarient used in the existing code\n\nstill need some other plumbing to get the client/server tests to work\ntogether.", "tree": {"sha": "1b2aafa4c1ebc56d85fdbfc9405d89f4bfa78b72", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b2aafa4c1ebc56d85fdbfc9405d89f4bfa78b72"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/465412aeff7b0e7d7e55877402b9e736024c3675", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/465412aeff7b0e7d7e55877402b9e736024c3675", "html_url": "https://github.com/rust-lang/rust/commit/465412aeff7b0e7d7e55877402b9e736024c3675", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/465412aeff7b0e7d7e55877402b9e736024c3675/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f2fd3bcf1740dfb1c8802ef0586b1c38ab171caa", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2fd3bcf1740dfb1c8802ef0586b1c38ab171caa", "html_url": "https://github.com/rust-lang/rust/commit/f2fd3bcf1740dfb1c8802ef0586b1c38ab171caa"}], "stats": {"total": 416, "additions": 396, "deletions": 20}, "files": [{"sha": "11425c2b61233d0f580dd9c02a22abbea300ae06", "filename": "src/libstd/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/465412aeff7b0e7d7e55877402b9e736024c3675/src%2Flibstd%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/465412aeff7b0e7d7e55877402b9e736024c3675/src%2Flibstd%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet.rs?ref=465412aeff7b0e7d7e55877402b9e736024c3675", "patch": "@@ -6,4 +6,4 @@ import tcp = net_tcp;\n export tcp;\n \n import ip = net_ip;\n-export ip; \n+export ip;"}, {"sha": "a43ff0c8152d1f2cdccffc22bdc8a1feb675c335", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 395, "deletions": 19, "changes": 414, "blob_url": "https://github.com/rust-lang/rust/blob/465412aeff7b0e7d7e55877402b9e736024c3675/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/465412aeff7b0e7d7e55877402b9e736024c3675/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=465412aeff7b0e7d7e55877402b9e736024c3675", "patch": "@@ -5,7 +5,7 @@ High-level interface to libuv's TCP functionality\n import ip = net_ip;\n \n export tcp_socket, tcp_err_data;\n-export connect, write, read_start, read_stop;\n+export connect, write, read_start, read_stop, listen, accept;\n \n #[doc=\"\n Encapsulates an open TCP/IP connection through libuv\n@@ -279,8 +279,246 @@ fn read_stop(sock: tcp_socket) ->\n     }\n }\n \n+#[doc=\"\n+Bind to a given IP/port and listen for new connections\n+\n+# Arguments\n+\n+* `host_ip` - a `net::ip::ip_addr` representing a unique IP\n+(versions 4 or 6)\n+* `port` - a uint representing the port to listen on\n+* `backlog` - a uint representing the number of incoming connections\n+to cache in memory\n+* `new_connect_cb` - a callback to be evaluated, on the libuv thread,\n+whenever a client attempts to conect on the provided ip/port\n+\"]\n+fn listen(host_ip: ip::ip_addr, port: uint, backlog: uint,\n+          new_connect_cb: fn~(tcp_new_connection,\n+                              comm::chan<option<tcp_err_data>>))\n+    -> result::result<(), tcp_err_data> unsafe {\n+    let stream_closed_po = comm::port::<()>();\n+    let kill_po = comm::port::<option<tcp_err_data>>();\n+    let server_stream = uv::ll::tcp_t();\n+    let server_stream_ptr = ptr::addr_of(server_stream);\n+    let hl_loop = uv::global_loop::get();\n+    let server_data = {\n+        server_stream_ptr: server_stream_ptr,\n+        stream_closed_ch: comm::chan(stream_closed_po),\n+        kill_ch: comm::chan(kill_po),\n+        new_connect_cb: new_connect_cb,\n+        hl_loop: hl_loop,\n+        mut active: true\n+    };\n+    let server_data_ptr = ptr::addr_of(server_data);\n+\n+    let setup_po = comm::port::<option<tcp_err_data>>();\n+    let setup_ch = comm::chan(setup_po);\n+    uv::hl::interact(hl_loop) {|loop_ptr|\n+        let tcp_addr = ipv4_ip_addr_to_sockaddr_in(host_ip,\n+                                                   port);\n+        alt uv::ll::tcp_init(loop_ptr, server_stream_ptr) {\n+          0i32 {\n+            alt uv::ll::tcp_bind(server_stream_ptr,\n+                                 ptr::addr_of(tcp_addr)) {\n+              0i32 {\n+                alt uv::ll::listen(server_stream_ptr,\n+                                   backlog as libc::c_int,\n+                                   tcp_listen_on_connection_cb) {\n+                  0i32 {\n+                    uv::ll::set_data_for_uv_handle(\n+                        server_stream_ptr,\n+                        server_data_ptr);\n+                    comm::send(setup_ch, none);\n+                  }\n+                  _ {\n+                    log(debug, \"failure to uv_listen()\");\n+                    let err_data = uv::ll::get_last_err_data(loop_ptr);\n+                    comm::send(setup_ch, some(err_data));\n+                  }\n+                }\n+              }\n+              _ {\n+                log(debug, \"failure to uv_tcp_bind\");\n+                let err_data = uv::ll::get_last_err_data(loop_ptr);\n+                comm::send(setup_ch, some(err_data));\n+              }\n+            }\n+          }\n+          _ {\n+            log(debug, \"failure to uv_tcp_init\");\n+            let err_data = uv::ll::get_last_err_data(loop_ptr);\n+            comm::send(setup_ch, some(err_data));\n+          }\n+        }\n+    };\n+    let mut kill_result: option<tcp_err_data> = none;\n+    alt comm::recv(setup_po) {\n+      some(err_data) {\n+        // we failed to bind/list w/ libuv\n+        result::err(err_data.to_tcp_err())\n+      }\n+      none {\n+        kill_result = comm::recv(kill_po);\n+        uv::hl::interact(hl_loop) {|loop_ptr|\n+            log(debug, #fmt(\"tcp::listen post-kill recv hl interact %?\",\n+                            loop_ptr));\n+            (*server_data_ptr).active = false;\n+            uv::ll::close(server_stream_ptr, tcp_listen_close_cb);\n+        };\n+        comm::recv(stream_closed_po);\n+        alt kill_result {\n+          // some failure post bind/listen\n+          some(err_data) {\n+            result::err(err_data)\n+          }\n+          // clean exit\n+          none {\n+            result::ok(())\n+          }\n+        }\n+      }\n+    }\n+}\n+\n+#[doc=\"\n+Bind an incoming client connection to a `net::tcp::tcp_socket`\n+\n+# Notes\n+\n+It is safe to call `net::tcp::accept` _only_ within the callback\n+provided as the final argument of the `net::tcp::listen` function.\n+\n+The `new_conn` opaque value provided _only_ as the first argument to the\n+`new_connect_cb`. It can be safely sent to another task but it _must_ be\n+used (via `net::tcp::accept`) before the `new_connect_cb` call it was\n+provided within returns.\n+\n+This means that a port/chan pair must be used to make sure that the\n+`new_connect_cb` call blocks until an attempt to create a\n+`net::tcp::tcp_socket` is completed.\n+\n+# Arguments\n+\n+* `new_conn` - an opaque value used to create a new `tcp_socket`\n+\n+# Returns\n+\n+* Success\n+  * On success, this function will return a `net::tcp::tcp_socket` as the\n+  `ok` variant of a `result`. The `net::tcp::tcp_socket` is anchored within\n+  the task that `accept` was called within for its lifetime.\n+* Failure\n+  * On failure, this function will return a `net::tcp::tcp_err_data` record\n+  as the `err` variant of a `result`.\n+\"]\n+fn accept(new_conn: tcp_new_connection)\n+    -> result::result<tcp_socket, tcp_err_data> unsafe {\n+\n+    alt new_conn{\n+      new_tcp_conn(server_handle_ptr) {\n+        let server_data_ptr = uv::ll::get_data_for_uv_handle(\n+            server_handle_ptr) as *tcp_server_data;\n+        let hl_loop = (*server_data_ptr).hl_loop;// FIXME\n+        let reader_po = comm::port::<result::result<[u8], tcp_err_data>>();\n+        let client_socket_data = @{\n+            reader_po: reader_po,\n+            reader_ch: comm::chan(reader_po),\n+            stream_handle : uv::ll::tcp_t(),\n+            connect_req : uv::ll::connect_t(),\n+            write_req : uv::ll::write_t(),\n+            hl_loop: hl_loop\n+        };\n+        let client_socket_data_ptr = ptr::addr_of(*client_socket_data);\n+        let client_stream_handle_ptr = ptr::addr_of(\n+            (*client_socket_data_ptr).stream_handle);\n+\n+        let result_po = comm::port::<option<tcp_err_data>>();\n+        let result_ch = comm::chan(result_po);\n+        uv::hl::interact(hl_loop) {|loop_ptr|\n+            log(debug, \"in interact cb for tcp::accept\");\n+            alt uv::ll::tcp_init(loop_ptr, client_stream_handle_ptr) {\n+              0i32 {\n+                log(debug, \"uv_tcp_init successful for client stream\");\n+                alt uv::ll::accept(server_handle_ptr,\n+                                   client_stream_handle_ptr) {\n+                  0i32 {\n+                    log(debug, \"successfully accepted client connection\");\n+                    comm::send(result_ch, none);\n+                  }\n+                  _ {\n+                    log(debug, \"failed to accept client conn\");\n+                    comm::send(result_ch, some(\n+                        uv::ll::get_last_err_data(loop_ptr).to_tcp_err()));\n+                  }\n+                }\n+              }\n+              _ {\n+                log(debug, \"failed to init client stream\");\n+                comm::send(result_ch, some(\n+                    uv::ll::get_last_err_data(loop_ptr).to_tcp_err()));\n+              }\n+            }\n+        };\n+        alt comm::recv(result_po) {\n+          some(err_data) {\n+            result::err(err_data)\n+          }\n+          none {\n+            result::ok(tcp_socket(client_socket_data))\n+          }\n+        }\n+      }\n+    }\n+}\n+\n // INTERNAL API\n \n+enum tcp_new_connection {\n+    new_tcp_conn(*uv::ll::uv_tcp_t)\n+}\n+\n+type tcp_server_data = {\n+    server_stream_ptr: *uv::ll::uv_tcp_t,\n+    stream_closed_ch: comm::chan<()>,\n+    kill_ch: comm::chan<option<tcp_err_data>>,\n+    new_connect_cb: fn~(tcp_new_connection,\n+                        comm::chan<option<tcp_err_data>>),\n+    hl_loop: uv::hl::high_level_loop,\n+    mut active: bool\n+};\n+\n+crust fn tcp_listen_close_cb(handle: *uv::ll::uv_tcp_t) unsafe {\n+    let server_data_ptr = uv::ll::get_data_for_uv_handle(\n+        handle) as *tcp_server_data;\n+    comm::send((*server_data_ptr).stream_closed_ch, ());\n+}\n+\n+crust fn tcp_listen_on_connection_cb(handle: *uv::ll::uv_tcp_t,\n+                                     status: libc::c_int) unsafe {\n+    let server_data_ptr = uv::ll::get_data_for_uv_handle(handle)\n+        as *tcp_server_data;\n+    let kill_ch = (*server_data_ptr).kill_ch;\n+    alt (*server_data_ptr).active {\n+      true {\n+        alt status {\n+          0i32 {\n+            let new_conn = new_tcp_conn(handle);\n+            (*server_data_ptr).new_connect_cb(new_conn, kill_ch);\n+          }\n+          _ {\n+            let loop_ptr = uv::ll::get_loop_for_uv_handle(handle);\n+            comm::send(kill_ch,\n+                       some(uv::ll::get_last_err_data(loop_ptr)\n+                            .to_tcp_err()));\n+            (*server_data_ptr).active = false;\n+          }\n+        }\n+      }\n+      _ {\n+      }\n+    }\n+}\n+\n enum tcp_connect_result {\n     tcp_connected(tcp_socket),\n     tcp_connect_error(tcp_err_data)\n@@ -315,6 +553,7 @@ impl of to_tcp_err_iface for uv::ll::uv_err_data {\n crust fn on_tcp_read_cb(stream: *uv::ll::uv_stream_t,\n                     nread: libc::ssize_t,\n                     ++buf: uv::ll::uv_buf_t) unsafe {\n+    log(debug, \"entering on_tcp_read_cb\");\n     let loop_ptr = uv::ll::get_loop_for_uv_handle(stream);\n     let socket_data_ptr = uv::ll::get_data_for_uv_handle(stream)\n         as *tcp_socket_data;\n@@ -338,6 +577,7 @@ crust fn on_tcp_read_cb(stream: *uv::ll::uv_stream_t,\n       }\n     }\n     uv::ll::free_base_of_buf(buf);\n+    log(debug, \"exiting on_tcp_read_cb\");\n }\n \n crust fn on_alloc_cb(handle: *libc::c_void,\n@@ -447,27 +687,108 @@ type tcp_socket_data = {\n };\n \n // convert rust ip_addr to libuv's native representation\n-fn ipv4_ip_addr_to_sockaddr_in(input: ip::ip_addr,\n+fn ipv4_ip_addr_to_sockaddr_in(input_ip: ip::ip_addr,\n                                port: uint) -> uv::ll::sockaddr_in unsafe {\n-    uv::ll::ip4_addr(ip::format_addr(input), port as int)\n+    // FIXME ipv6\n+    alt input_ip {\n+      ip::ipv4(_,_,_,_) {\n+        uv::ll::ip4_addr(ip::format_addr(input_ip), port as int)\n+      }\n+      _ {\n+        fail \"FIXME ipv6 not yet supported\";\n+      }\n+    }\n }\n \n //#[cfg(test)]\n mod test {\n     #[test]\n-    fn test_gl_tcp_ipv4_request() {\n-        impl_gl_tcp_ipv4_request();\n-    }\n-    fn impl_gl_tcp_ipv4_request() {\n-        // pre-connection/input data\n+    fn test_gl_tcp_ipv4_client() {\n         let ip_str = \"173.194.79.99\";\n         let port = 80u;\n-        let expected_read_msg = \"foo\";\n-        let actual_write_msg = \"GET / HTTP/1.1\\r\\n\\r\\n\";\n-        let host_ip = ip::v4::parse_addr(ip_str);\n+        let write_input = \"GET / HTTP/1.1\\r\\n\\r\\n\";\n+        let read_output =\n+            impl_gl_tcp_ipv4_client(ip_str, port, write_input);\n+        log(debug, \"DATA RECEIVED: \"+read_output);\n+    }\n+\n+    #[test]\n+    fn test_gl_tcp_ipv4_server() {\n+        let server_ip = \"127.0.0.1\";\n+        let server_port = 8888u;\n+        let kill_str = \"asdf\";\n+        let resp_str = \"hw\";\n+\n+        let result_po = comm::port::<str>();\n+        let result_ch = comm::chan(result_po);\n+        task::spawn_sched(task::manual_threads(4u)) {||\n+            let inner_result_po = comm::port::<str>();\n+            let inner_result_ch = comm::chan(inner_result_po);\n+\n+            impl_gl_tcp_ipv4_server(server_ip, server_port,\n+                                    kill_str, resp_str,\n+                                    inner_result_ch);\n+            let result_str = comm::recv(inner_result_po);\n+            comm::send(result_ch, result_str);\n+        };\n+        let output = comm::recv(result_po);\n+        log(debug, #fmt(\"RECEIVED REQ %? FROM USER\", output));\n+    }\n \n-        let data_po = comm::port::<[u8]>();\n-        let data_ch = comm::chan(data_po);\n+    fn impl_gl_tcp_ipv4_server(host_str: str, port: uint,\n+                               kill_str: str, resp_str: str,\n+                              output_ch: comm::chan<str>) {\n+        let host_ip = ip::v4::parse_addr(host_str);\n+        log(debug, \"about to enter listen() call for test server\");\n+        listen(host_ip, port, 128u) {|new_conn, kill_ch|\n+            // this is a callback that is going to be invoked on the\n+            // loop's thread (can't be avoided).\n+            let cont_po = comm::port::<()>();\n+            let cont_ch = comm::chan(cont_po);\n+            task::spawn {||\n+                log(debug, \"starting worker for incoming req\");\n+\n+                // work loop\n+                let accept_result = accept(new_conn);\n+                if result::is_failure(accept_result) {\n+                    // accept failed..\n+                    log(debug,\"accept in worker task failed\");\n+                    comm::send(kill_ch,\n+                               some(result::get_err(accept_result)\n+                                    .to_tcp_err()));\n+                }\n+                // accept() succeeded, let the task that is\n+                // listen()'ing know so it can continue and\n+                // unblock libuv..\n+                comm::send(cont_ch, ());\n+\n+                // our precious sock.. from here on out, things\n+                // match the tcp request/client api, as they're\n+                // both on tcp_sockets at this point..\n+                let sock = result::unwrap(accept_result);\n+                let req_bytes = single_read_bytes_from(sock);\n+                let req_str = str::from_bytes(req_bytes);\n+                if str::contains(req_str, kill_str) {\n+                    // our signal to shut down the tcp\n+                    // server was received. shut it down.\n+                    comm::send(kill_ch, none);\n+                }\n+                write_single_str(sock, resp_str);\n+\n+                comm::send(output_ch, req_str);\n+                // work's complete, let socket close..\n+                log(debug, \"exiting worker\");\n+            };\n+\n+            comm::recv(cont_po);\n+        };\n+        log(debug, \"exiting listen() block for test server\");\n+    }\n+\n+    fn impl_gl_tcp_ipv4_client(ip_str: str, port: uint,\n+                               write_input: str) -> str {\n+        // pre-connection/input data\n+        let host_ip = ip::v4::parse_addr(ip_str);\n \n         // connect to remote host\n         let connect_result = connect(host_ip, port);\n@@ -486,7 +807,7 @@ mod test {\n         log(debug, \"successful tcp connect\");\n \n         // set up write data\n-        let write_data = [str::as_bytes(actual_write_msg) {|str_bytes|\n+        let write_data = [str::as_bytes(write_input) {|str_bytes|\n             str_bytes\n         }];\n \n@@ -538,9 +859,64 @@ mod test {\n             }\n             break;\n         }\n-        comm::send(data_ch, total_read_data);\n-        let actual_data = comm::recv(data_po);\n-        let resp = str::from_bytes(actual_data);\n-        log(debug, \"DATA RECEIVED: \"+resp);\n+        str::from_bytes(total_read_data)\n+    }\n+\n+    fn single_read_bytes_from(sock: tcp_socket) -> [u8] {\n+        let mut total_read_data: [u8] = [];\n+        let read_start_result = read_start(sock);\n+        if result::is_failure(read_start_result) {\n+            let err_data = result::get_err(read_start_result);\n+            log(debug, \"srbf tcp read_start err received..\");\n+            log(debug, #fmt(\"srbf read_start error: %? %?\",\n+                            err_data.err_name,\n+                           err_data.err_msg));\n+            assert false;\n+        }\n+        let reader_po = result::get(read_start_result);\n+\n+        let read_data_result = comm::recv(reader_po);\n+        if result::is_failure(read_data_result) {\n+            let err_data = result::get_err(read_data_result);\n+            log(debug, \"srbf read error data recv'd\");\n+            log(debug, #fmt(\"srbf read error: %? %?\",\n+                            err_data.err_name,\n+                            err_data.err_msg));\n+            assert false;\n+        }\n+        let new_data = result::unwrap(read_data_result);\n+        total_read_data += new_data;\n+        // theoretically, we could keep iterating, if\n+        // we expect the server on the other end to keep\n+        // streaming/chunking data to us, but..\n+        let read_stop_result = read_stop(sock);\n+        if result::is_failure(read_stop_result) {\n+            let err_data = result::get_err(read_stop_result);\n+            log(debug, \"srbf error while calling read_stop\");\n+            log(debug, #fmt(\"srbf read_stop error: %? %?\",\n+                            err_data.err_name,\n+                            err_data.err_msg));\n+            assert false;\n+        }\n+        total_read_data\n+    }\n+\n+    fn write_single_str(sock: tcp_socket, write_input: str) {\n+        // set up write data\n+        let write_data = [str::as_bytes(write_input) {|str_bytes|\n+            str_bytes\n+        }];\n+\n+        // write data to tcp socket\n+        let write_result = write(sock, write_data);\n+        if result::is_failure(write_result) {\n+            let err_data = result::get_err(write_result);\n+            log(debug, \"wss tcp_write_error received..\");\n+            log(debug, #fmt(\"wss tcp write error: %? %?\",\n+                            err_data.err_name,\n+                            err_data.err_msg));\n+            assert false;\n+        }\n+        log(debug, \"wss tcp::write successful\");\n     }\n-}\n\\ No newline at end of file\n+}"}]}