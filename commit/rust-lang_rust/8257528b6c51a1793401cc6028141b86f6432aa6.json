{"sha": "8257528b6c51a1793401cc6028141b86f6432aa6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyNTc1MjhiNmM1MWExNzkzNDAxY2M2MDI4MTQxYjg2ZjY0MzJhYTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-16T01:16:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-16T01:16:51Z"}, "message": "auto merge of #6502 : huonw/rust/no-auto-code, r=graydon\n\nReplace all instances of #[auto_*code] with the appropriate #[deriving] attribute\r\nand remove the majority of the actual auto_* code, leaving stubs to refer the user to\r\nthe new syntax.\r\n\r\nAlso, moves the useful contents of auto_encode.rs to more appropriate spots: tests and comments to deriving/encodable.rs, and the ExtCtxtMethods trait to build.rs (unused so far, but the method syntax might be nicer than using the mk_* fns in many instances).", "tree": {"sha": "39e6fbb833768f5be5c4d6fee6603750caf138af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39e6fbb833768f5be5c4d6fee6603750caf138af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8257528b6c51a1793401cc6028141b86f6432aa6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8257528b6c51a1793401cc6028141b86f6432aa6", "html_url": "https://github.com/rust-lang/rust/commit/8257528b6c51a1793401cc6028141b86f6432aa6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8257528b6c51a1793401cc6028141b86f6432aa6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c18e44ba17c227522836e4ddfcfc095448d0938c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c18e44ba17c227522836e4ddfcfc095448d0938c", "html_url": "https://github.com/rust-lang/rust/commit/c18e44ba17c227522836e4ddfcfc095448d0938c"}, {"sha": "5dc5efefd47527067ab5b7862d89a99da4824f49", "url": "https://api.github.com/repos/rust-lang/rust/commits/5dc5efefd47527067ab5b7862d89a99da4824f49", "html_url": "https://github.com/rust-lang/rust/commit/5dc5efefd47527067ab5b7862d89a99da4824f49"}], "stats": {"total": 2550, "additions": 752, "deletions": 1798}, "files": [{"sha": "872ad83b7391cf7a945166d0581b5522fdb87710", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8257528b6c51a1793401cc6028141b86f6432aa6/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8257528b6c51a1793401cc6028141b86f6432aa6/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=8257528b6c51a1793401cc6028141b86f6432aa6", "patch": "@@ -20,8 +20,7 @@ use syntax::{ast, ast_util, visit};\n \n // A vector of defs representing the free variables referred to in a function.\n // (The def_upvar will already have been stripped).\n-#[auto_encode]\n-#[auto_decode]\n+#[deriving(Encodable, Decodable)]\n pub struct freevar_entry {\n     def: ast::def, //< The variable being accessed free.\n     span: span     //< First span where it is accessed (there can be multiple)"}, {"sha": "e81a9d6b78fcd5ef799b600979daf0cfa7ea8e77", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8257528b6c51a1793401cc6028141b86f6432aa6/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8257528b6c51a1793401cc6028141b86f6432aa6/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=8257528b6c51a1793401cc6028141b86f6432aa6", "patch": "@@ -221,16 +221,14 @@ use syntax::visit::vt;\n use syntax::print::pprust;\n use syntax::codemap::span;\n \n-#[auto_encode]\n-#[auto_decode]\n+#[deriving(Encodable, Decodable)]\n pub enum CaptureMode {\n     CapCopy, // Copy the value into the closure.\n     CapMove, // Move the value into the closure.\n     CapRef,  // Reference directly from parent stack frame (used by `&fn()`).\n }\n \n-#[auto_encode]\n-#[auto_decode]\n+#[deriving(Encodable, Decodable)]\n pub struct CaptureVar {\n     def: def,         // Variable being accessed free\n     span: span,       // Location of an access to this variable"}, {"sha": "e85c7d00c58e04aa1aa56b291e10aeeda691f105", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 12, "deletions": 32, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/8257528b6c51a1793401cc6028141b86f6432aa6/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8257528b6c51a1793401cc6028141b86f6432aa6/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=8257528b6c51a1793401cc6028141b86f6432aa6", "patch": "@@ -96,19 +96,15 @@ pub struct mt {\n     mutbl: ast::mutability,\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub enum vstore {\n     vstore_fixed(uint),\n     vstore_uniq,\n     vstore_box,\n     vstore_slice(Region)\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq, IterBytes)]\n+#[deriving(Eq, IterBytes, Encodable, Decodable)]\n pub enum TraitStore {\n     BoxTraitStore,              // @Trait\n     UniqTraitStore,             // ~Trait\n@@ -117,9 +113,7 @@ pub enum TraitStore {\n \n // XXX: This should probably go away at some point. Maybe after destructors\n // do?\n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub enum SelfMode {\n     ByCopy,\n     ByRef,\n@@ -197,27 +191,22 @@ pub enum ast_ty_to_ty_cache_entry {\n \n pub type opt_region_variance = Option<region_variance>;\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Decodable, Encodable)]\n pub enum region_variance { rv_covariant, rv_invariant, rv_contravariant }\n \n-#[auto_encode]\n-#[auto_decode]\n+#[deriving(Decodable, Encodable)]\n pub enum AutoAdjustment {\n     AutoAddEnv(ty::Region, ast::Sigil),\n     AutoDerefRef(AutoDerefRef)\n }\n \n-#[auto_encode]\n-#[auto_decode]\n+#[deriving(Decodable, Encodable)]\n pub struct AutoDerefRef {\n     autoderefs: uint,\n     autoref: Option<AutoRef>\n }\n \n-#[auto_encode]\n-#[auto_decode]\n+#[deriving(Decodable, Encodable)]\n pub enum AutoRef {\n     /// Convert from T to &T\n     AutoPtr(Region, ast::mutability),\n@@ -453,9 +442,7 @@ pub struct param_ty {\n }\n \n /// Representation of regions:\n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq, IterBytes)]\n+#[deriving(Eq, IterBytes, Encodable, Decodable)]\n pub enum Region {\n     /// Bound regions are found (primarily) in function types.  They indicate\n     /// region parameters that have yet to be replaced with actual regions\n@@ -501,17 +488,13 @@ pub impl Region {\n     }\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq, IterBytes)]\n+#[deriving(Eq, IterBytes, Encodable, Decodable)]\n pub struct FreeRegion {\n     scope_id: node_id,\n     bound_region: bound_region\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq, IterBytes)]\n+#[deriving(Eq, IterBytes, Encodable, Decodable)]\n pub enum bound_region {\n     /// The self region for structs, impls (&T in a type defn or &'self T)\n     br_self,\n@@ -742,9 +725,7 @@ pub struct IntVid(uint);\n #[deriving(Eq)]\n pub struct FloatVid(uint);\n \n-#[deriving(Eq)]\n-#[auto_encode]\n-#[auto_decode]\n+#[deriving(Eq, Encodable, Decodable)]\n pub struct RegionVid {\n     id: uint\n }\n@@ -777,8 +758,7 @@ impl to_bytes::IterBytes for InferTy {\n     }\n }\n \n-#[auto_encode]\n-#[auto_decode]\n+#[deriving(Encodable, Decodable)]\n pub enum InferRegion {\n     ReVar(RegionVid),\n     ReSkolemized(uint, bound_region)"}, {"sha": "dd313c54efb922647fa25128f2a96fbf934b954f", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8257528b6c51a1793401cc6028141b86f6432aa6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8257528b6c51a1793401cc6028141b86f6432aa6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=8257528b6c51a1793401cc6028141b86f6432aa6", "patch": "@@ -73,8 +73,7 @@ pub mod infer;\n pub mod collect;\n pub mod coherence;\n \n-#[auto_encode]\n-#[auto_decode]\n+#[deriving(Encodable, Decodable)]\n pub enum method_origin {\n     // supertrait method invoked on \"self\" inside a default method\n     // first field is supertrait ID;\n@@ -98,8 +97,7 @@ pub enum method_origin {\n \n // details for a method invoked with a receiver whose type is a type parameter\n // with a bounded trait.\n-#[auto_encode]\n-#[auto_decode]\n+#[deriving(Encodable, Decodable)]\n pub struct method_param {\n     // the trait containing the method to be invoked\n     trait_id: ast::def_id,"}, {"sha": "270cf675c878a4ae2e43f381bf3eed409a1557f8", "filename": "src/libstd/json.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8257528b6c51a1793401cc6028141b86f6432aa6/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8257528b6c51a1793401cc6028141b86f6432aa6/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=8257528b6c51a1793401cc6028141b86f6432aa6", "patch": "@@ -1331,26 +1331,20 @@ mod tests {\n \n     use std::serialize::Decodable;\n \n-    #[auto_encode]\n-    #[auto_decode]\n-    #[deriving(Eq)]\n+    #[deriving(Eq, Encodable, Decodable)]\n     enum Animal {\n         Dog,\n         Frog(~str, int)\n     }\n \n-    #[auto_encode]\n-    #[auto_decode]\n-    #[deriving(Eq)]\n+    #[deriving(Eq, Encodable, Decodable)]\n     struct Inner {\n         a: (),\n         b: uint,\n         c: ~[~str],\n     }\n \n-    #[auto_encode]\n-    #[auto_decode]\n-    #[deriving(Eq)]\n+    #[deriving(Eq, Encodable, Decodable)]\n     struct Outer {\n         inner: ~[Inner],\n     }"}, {"sha": "202b96f9797aab8b582be66fe4f49ff062708271", "filename": "src/libstd/time.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8257528b6c51a1793401cc6028141b86f6432aa6/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8257528b6c51a1793401cc6028141b86f6432aa6/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=8257528b6c51a1793401cc6028141b86f6432aa6", "patch": "@@ -29,9 +29,7 @@ pub mod rustrt {\n }\n \n /// A record specifying a time value in seconds and nanoseconds.\n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub struct Timespec { sec: i64, nsec: i32 }\n \n /*\n@@ -100,9 +98,7 @@ pub fn tzset() {\n     }\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub struct Tm {\n     tm_sec: i32, // seconds after the minute ~[0-60]\n     tm_min: i32, // minutes after the hour ~[0-59]"}, {"sha": "f173df60df893195c48f3970dfaefc23a93bf935", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8257528b6c51a1793401cc6028141b86f6432aa6/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8257528b6c51a1793401cc6028141b86f6432aa6/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=8257528b6c51a1793401cc6028141b86f6432aa6", "patch": "@@ -92,9 +92,7 @@ use core::util::replace;\n *\n */\n \n-#[deriving(Eq)]\n-#[auto_encode]\n-#[auto_decode]\n+#[deriving(Eq, Encodable, Decodable)]\n struct WorkKey {\n     kind: ~str,\n     name: ~str"}, {"sha": "1b166dcf3661898730eccbce81f874854925e085", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8257528b6c51a1793401cc6028141b86f6432aa6/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8257528b6c51a1793401cc6028141b86f6432aa6/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=8257528b6c51a1793401cc6028141b86f6432aa6", "patch": "@@ -58,9 +58,7 @@ enum AbiArchitecture {\n     Archs(u32)  // Multiple architectures (bitset)\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub struct AbiSet {\n     priv bits: u32   // each bit represents one of the abis below\n }"}, {"sha": "4a3ae7d94ad761532a69982a890b44f45c827d58", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 78, "deletions": 234, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/8257528b6c51a1793401cc6028141b86f6432aa6/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8257528b6c51a1793401cc6028141b86f6432aa6/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=8257528b6c51a1793401cc6028141b86f6432aa6", "patch": "@@ -47,9 +47,7 @@ pub type SyntaxContext = uint;\n pub type SCTable = ~[SyntaxContext_];\n pub static empty_ctxt : uint = 0;\n \n-#[deriving(Eq)]\n-#[auto_encode]\n-#[auto_decode]\n+#[deriving(Eq, Encodable, Decodable)]\n pub enum SyntaxContext_ {\n     EmptyCtxt,\n     Mark (Mrk,SyntaxContext),\n@@ -115,9 +113,7 @@ impl to_bytes::IterBytes for ident {\n // Functions may or may not have names.\n pub type fn_ident = Option<ident>;\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub struct Lifetime {\n     id: node_id,\n     span: span,\n@@ -142,9 +138,7 @@ impl to_bytes::IterBytes for Lifetime {\n // for instance: core::cmp::Eq  .  It's represented\n // as a sequence of identifiers, along with a bunch\n // of supporting information.\n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub struct Path {\n     span: span,\n     global: bool,\n@@ -157,9 +151,7 @@ pub type crate_num = int;\n \n pub type node_id = int;\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub struct def_id {\n     crate: crate_num,\n     node: node_id,\n@@ -168,9 +160,7 @@ pub struct def_id {\n pub static local_crate: crate_num = 0;\n pub static crate_node_id: node_id = 0;\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n // The AST represents all type param bounds as types.\n // typeck::collect::compute_bounds matches these against\n // the \"special\" built-in traits (see middle::lang_items) and\n@@ -180,18 +170,14 @@ pub enum TyParamBound {\n     RegionTyParamBound\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub struct TyParam {\n     ident: ident,\n     id: node_id,\n     bounds: @OptVec<TyParamBound>\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub struct Generics {\n     lifetimes: OptVec<Lifetime>,\n     ty_params: OptVec<TyParam>\n@@ -209,9 +195,7 @@ pub impl Generics {\n     }\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub enum def {\n     def_fn(def_id, purity),\n     def_static_method(/* method */ def_id,\n@@ -248,9 +232,7 @@ pub type crate_cfg = ~[@meta_item];\n \n pub type crate = spanned<crate_>;\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub struct crate_ {\n     module: _mod,\n     attrs: ~[attribute],\n@@ -259,9 +241,7 @@ pub struct crate_ {\n \n pub type meta_item = spanned<meta_item_>;\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub enum meta_item_ {\n     meta_word(@~str),\n     meta_list(@~str, ~[@meta_item]),\n@@ -270,9 +250,7 @@ pub enum meta_item_ {\n \n pub type blk = spanned<blk_>;\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub struct blk_ {\n     view_items: ~[@view_item],\n     stmts: ~[@stmt],\n@@ -281,26 +259,20 @@ pub struct blk_ {\n     rules: blk_check_mode,\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub struct pat {\n     id: node_id,\n     node: pat_,\n     span: span,\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub struct field_pat {\n     ident: ident,\n     pat: @pat,\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub enum binding_mode {\n     bind_by_copy,\n     bind_by_ref(mutability),\n@@ -334,9 +306,7 @@ impl to_bytes::IterBytes for binding_mode {\n     }\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub enum pat_ {\n     pat_wild,\n     // A pat_ident may either be a new bound variable,\n@@ -361,9 +331,7 @@ pub enum pat_ {\n     pat_vec(~[@pat], Option<@pat>, ~[@pat])\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub enum mutability { m_mutbl, m_imm, m_const, }\n \n #[cfg(stage0)]\n@@ -379,9 +347,7 @@ impl to_bytes::IterBytes for mutability {\n     }\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub enum Sigil {\n     BorrowedSigil,\n     OwnedSigil,\n@@ -411,9 +377,7 @@ impl ToStr for Sigil {\n     }\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub enum vstore {\n     // FIXME (#3469): Change uint to @expr (actually only constant exprs)\n     vstore_fixed(Option<uint>),     // [1,2,3,4]\n@@ -422,9 +386,7 @@ pub enum vstore {\n     vstore_slice(Option<@Lifetime>) // &'foo? [1,2,3,4]\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub enum expr_vstore {\n     expr_vstore_uniq,                  // ~[1,2,3,4]\n     expr_vstore_box,                   // @[1,2,3,4]\n@@ -433,9 +395,7 @@ pub enum expr_vstore {\n     expr_vstore_mut_slice,             // &mut [1,2,3,4]\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub enum binop {\n     add,\n     subtract,\n@@ -457,9 +417,7 @@ pub enum binop {\n     gt,\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub enum unop {\n     box(mutability),\n     uniq(mutability),\n@@ -470,9 +428,7 @@ pub enum unop {\n \n pub type stmt = spanned<stmt_>;\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub enum stmt_ {\n     stmt_decl(@decl, node_id),\n \n@@ -488,9 +444,7 @@ pub enum stmt_ {\n \n // FIXME (pending discussion of #1697, #2178...): local should really be\n // a refinement on pat.\n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub struct local_ {\n     is_mutbl: bool,\n     ty: @Ty,\n@@ -503,23 +457,17 @@ pub type local = spanned<local_>;\n \n pub type decl = spanned<decl_>;\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub enum decl_ { decl_local(~[@local]), decl_item(@item), }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub struct arm {\n     pats: ~[@pat],\n     guard: Option<@expr>,\n     body: blk,\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub struct field_ {\n     mutbl: mutability,\n     ident: ident,\n@@ -528,14 +476,10 @@ pub struct field_ {\n \n pub type field = spanned<field_>;\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub enum blk_check_mode { default_blk, unsafe_blk, }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub struct expr {\n     id: node_id,\n     // Extra node ID is only used for index, assign_op, unary, binary, method\n@@ -545,18 +489,14 @@ pub struct expr {\n     span: span,\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub enum CallSugar {\n     NoSugar,\n     DoSugar,\n     ForSugar\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub enum expr_ {\n     expr_vstore(@expr, expr_vstore),\n     expr_vec(~[@expr], mutability),\n@@ -627,9 +567,7 @@ pub enum expr_ {\n // else knows what to do with them, so you'll probably get a syntax\n // error.\n //\n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n #[doc=\"For macro invocations; parsing is delegated to the macro\"]\n pub enum token_tree {\n     // a single token\n@@ -702,9 +640,7 @@ pub enum token_tree {\n //\n pub type matcher = spanned<matcher_>;\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub enum matcher_ {\n     // match one token\n     match_tok(::parse::token::Token),\n@@ -717,18 +653,14 @@ pub enum matcher_ {\n \n pub type mac = spanned<mac_>;\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub enum mac_ {\n     mac_invoc_tt(@Path,~[token_tree]),   // new macro-invocation\n }\n \n pub type lit = spanned<lit_>;\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub enum lit_ {\n     lit_str(@~str),\n     lit_int(i64, int_ty),\n@@ -742,27 +674,21 @@ pub enum lit_ {\n \n // NB: If you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub struct mt {\n     ty: @Ty,\n     mutbl: mutability,\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub struct ty_field_ {\n     ident: ident,\n     mt: mt,\n }\n \n pub type ty_field = spanned<ty_field_>;\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub struct ty_method {\n     ident: ident,\n     attrs: ~[attribute],\n@@ -774,9 +700,7 @@ pub struct ty_method {\n     span: span,\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n // A trait method is either required (meaning it doesn't have an\n // implementation, just a signature) or provided (meaning it has a default\n // implementation).\n@@ -785,9 +709,7 @@ pub enum trait_method {\n     provided(@method),\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub enum int_ty { ty_i, ty_char, ty_i8, ty_i16, ty_i32, ty_i64, }\n \n impl ToStr for int_ty {\n@@ -809,9 +731,7 @@ impl to_bytes::IterBytes for int_ty {\n     }\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub enum uint_ty { ty_u, ty_u8, ty_u16, ty_u32, ty_u64, }\n \n impl ToStr for uint_ty {\n@@ -833,9 +753,7 @@ impl to_bytes::IterBytes for uint_ty {\n     }\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub enum float_ty { ty_f, ty_f32, ty_f64, }\n \n impl ToStr for float_ty {\n@@ -858,19 +776,15 @@ impl to_bytes::IterBytes for float_ty {\n }\n \n // NB Eq method appears below.\n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub struct Ty {\n     id: node_id,\n     node: ty_,\n     span: span,\n }\n \n // Not represented directly in the AST, referred to by name through a ty_path.\n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub enum prim_ty {\n     ty_int(int_ty),\n     ty_uint(uint_ty),\n@@ -879,9 +793,7 @@ pub enum prim_ty {\n     ty_bool,\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub enum Onceness {\n     Once,\n     Many\n@@ -909,9 +821,7 @@ impl to_bytes::IterBytes for Onceness {\n     }\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub struct TyClosure {\n     sigil: Sigil,\n     region: Option<@Lifetime>,\n@@ -921,19 +831,15 @@ pub struct TyClosure {\n     decl: fn_decl\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub struct TyBareFn {\n     purity: purity,\n     abis: AbiSet,\n     lifetimes: OptVec<Lifetime>,\n     decl: fn_decl\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub enum ty_ {\n     ty_nil,\n     ty_bot, /* bottom type */\n@@ -967,17 +873,13 @@ impl to_bytes::IterBytes for Ty {\n     }\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub enum asm_dialect {\n     asm_att,\n     asm_intel\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub struct inline_asm {\n     asm: @~str,\n     clobbers: @~str,\n@@ -988,28 +890,22 @@ pub struct inline_asm {\n     dialect: asm_dialect\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub struct arg {\n     is_mutbl: bool,\n     ty: @Ty,\n     pat: @pat,\n     id: node_id,\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub struct fn_decl {\n     inputs: ~[arg],\n     output: @Ty,\n     cf: ret_style,\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub enum purity {\n     pure_fn, // declared with \"pure fn\"\n     unsafe_fn, // declared with \"unsafe fn\"\n@@ -1041,9 +937,7 @@ impl to_bytes::IterBytes for purity {\n     }\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub enum ret_style {\n     noreturn, // functions with return type _|_ that always\n               // raise an error or exit (i.e. never return to the caller)\n@@ -1063,9 +957,7 @@ impl to_bytes::IterBytes for ret_style {\n     }\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub enum explicit_self_ {\n     sty_static,                                // no self\n     sty_value,                                 // `self`\n@@ -1102,9 +994,7 @@ impl to_bytes::IterBytes for explicit_self_ {\n \n pub type explicit_self = spanned<explicit_self_>;\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub struct method {\n     ident: ident,\n     attrs: ~[attribute],\n@@ -1119,56 +1009,42 @@ pub struct method {\n     vis: visibility,\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub struct _mod {\n     view_items: ~[@view_item],\n     items: ~[@item],\n }\n \n // Foreign mods can be named or anonymous\n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub enum foreign_mod_sort { named, anonymous }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub struct foreign_mod {\n     sort: foreign_mod_sort,\n     abis: AbiSet,\n     view_items: ~[@view_item],\n     items: ~[@foreign_item],\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub struct variant_arg {\n     ty: @Ty,\n     id: node_id,\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub enum variant_kind {\n     tuple_variant_kind(~[variant_arg]),\n     struct_variant_kind(@struct_def),\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub struct enum_def {\n     variants: ~[variant],\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub struct variant_ {\n     name: ident,\n     attrs: ~[attribute],\n@@ -1180,9 +1056,7 @@ pub struct variant_ {\n \n pub type variant = spanned<variant_>;\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub struct path_list_ident_ {\n     name: ident,\n     id: node_id,\n@@ -1192,9 +1066,7 @@ pub type path_list_ident = spanned<path_list_ident_>;\n \n pub type view_path = spanned<view_path_>;\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub enum view_path_ {\n \n     // quux = foo::bar::baz\n@@ -1211,19 +1083,15 @@ pub enum view_path_ {\n     view_path_list(@Path, ~[path_list_ident], node_id)\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub struct view_item {\n     node: view_item_,\n     attrs: ~[attribute],\n     vis: visibility,\n     span: span,\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub enum view_item_ {\n     view_item_extern_mod(ident, ~[@meta_item], node_id),\n     view_item_use(~[@view_path]),\n@@ -1235,15 +1103,11 @@ pub type attribute = spanned<attribute_>;\n // Distinguishes between attributes that decorate items and attributes that\n // are contained as statements within items. These two cases need to be\n // distinguished for pretty-printing.\n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub enum attr_style { attr_outer, attr_inner, }\n \n // doc-comments are promoted to attributes that have is_sugared_doc = true\n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub struct attribute_ {\n     style: attr_style,\n     value: @meta_item,\n@@ -1257,17 +1121,13 @@ pub struct attribute_ {\n   If this impl is an item_impl, the impl_id is redundant (it could be the\n   same as the impl's node id).\n  */\n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub struct trait_ref {\n     path: @Path,\n     ref_id: node_id,\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub enum visibility { public, private, inherited }\n \n impl visibility {\n@@ -1279,9 +1139,7 @@ impl visibility {\n     }\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub struct struct_field_ {\n     kind: struct_field_kind,\n     id: node_id,\n@@ -1291,17 +1149,13 @@ pub struct struct_field_ {\n \n pub type struct_field = spanned<struct_field_>;\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub enum struct_field_kind {\n     named_field(ident, visibility),\n     unnamed_field   // element of a tuple-like struct\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub struct struct_def {\n     fields: ~[@struct_field], /* fields, not including ctor */\n     /* ID of the constructor. This is only used for tuple- or enum-like\n@@ -1313,9 +1167,7 @@ pub struct struct_def {\n   FIXME (#3300): Should allow items to be anonymous. Right now\n   we just use dummy names for anon items.\n  */\n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub struct item {\n     ident: ident,\n     attrs: ~[attribute],\n@@ -1325,9 +1177,7 @@ pub struct item {\n     span: span,\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub enum item_ {\n     item_const(@Ty, @expr),\n     item_fn(fn_decl, purity, AbiSet, Generics, blk),\n@@ -1345,9 +1195,7 @@ pub enum item_ {\n     item_mac(mac),\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub struct foreign_item {\n     ident: ident,\n     attrs: ~[attribute],\n@@ -1357,9 +1205,7 @@ pub struct foreign_item {\n     vis: visibility,\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub enum foreign_item_ {\n     foreign_item_fn(fn_decl, purity, Generics),\n     foreign_item_const(@Ty)\n@@ -1368,9 +1214,7 @@ pub enum foreign_item_ {\n // The data we save and restore about an inlined item or method.  This is not\n // part of the AST that we parse from a file, but it becomes part of the tree\n // that we trans.\n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub enum inlined_item {\n     ii_item(@item),\n     ii_method(def_id /* impl id */, @method),"}, {"sha": "aa1ee7cd27eb8ee4369790f8043dd34efedbb951", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8257528b6c51a1793401cc6028141b86f6432aa6/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8257528b6c51a1793401cc6028141b86f6432aa6/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=8257528b6c51a1793401cc6028141b86f6432aa6", "patch": "@@ -370,8 +370,7 @@ pub fn empty_generics() -> Generics {\n // ______________________________________________________________________\n // Enumerating the IDs which appear in an AST\n \n-#[auto_encode]\n-#[auto_decode]\n+#[deriving(Encodable, Decodable)]\n pub struct id_range {\n     min: node_id,\n     max: node_id,"}, {"sha": "44a368738fd1640f6f041cc10ab3a36bb389bf9b", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8257528b6c51a1793401cc6028141b86f6432aa6/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8257528b6c51a1793401cc6028141b86f6432aa6/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=8257528b6c51a1793401cc6028141b86f6432aa6", "patch": "@@ -127,9 +127,7 @@ pub struct span {\n     expn_info: Option<@ExpnInfo>\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub struct spanned<T> { node: T, span: span }\n \n impl cmp::Eq for span {"}, {"sha": "6bb3ac5eba4cd8ee74004bd9729a89ca8a0a16f9", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 5, "deletions": 1481, "changes": 1486, "blob_url": "https://github.com/rust-lang/rust/blob/8257528b6c51a1793401cc6028141b86f6432aa6/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8257528b6c51a1793401cc6028141b86f6432aa6/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=8257528b6c51a1793401cc6028141b86f6432aa6", "patch": "@@ -8,156 +8,20 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*!\n-\n-The compiler code necessary to implement the #[auto_encode] and\n-#[auto_decode] extension.  The idea here is that type-defining items may\n-be tagged with #[auto_encode] and #[auto_decode], which will cause\n-us to generate a little companion module with the same name as the item.\n-\n-For example, a type like:\n-\n-    #[auto_encode]\n-    #[auto_decode]\n-    struct Node {id: uint}\n-\n-would generate two implementations like:\n-\n-impl<S:std::serialize::Encoder> Encodable<S> for Node {\n-    fn encode(&self, s: &S) {\n-        do s.emit_struct(\"Node\", 1) {\n-            s.emit_field(\"id\", 0, || s.emit_uint(self.id))\n-        }\n-    }\n-}\n-\n-impl<D:Decoder> Decodable for node_id {\n-    fn decode(d: &D) -> Node {\n-        do d.read_struct(\"Node\", 1) {\n-            Node {\n-                id: d.read_field(~\"x\", 0, || decode(d))\n-            }\n-        }\n-    }\n-}\n-\n-Other interesting scenarios are whe the item has type parameters or\n-references other non-built-in types.  A type definition like:\n-\n-    #[auto_encode]\n-    #[auto_decode]\n-    struct spanned<T> {node: T, span: span}\n-\n-would yield functions like:\n-\n-    impl<\n-        S: Encoder,\n-        T: Encodable<S>\n-    > spanned<T>: Encodable<S> {\n-        fn encode<S:Encoder>(s: &S) {\n-            do s.emit_rec {\n-                s.emit_field(\"node\", 0, || self.node.encode(s));\n-                s.emit_field(\"span\", 1, || self.span.encode(s));\n-            }\n-        }\n-    }\n-\n-    impl<\n-        D: Decoder,\n-        T: Decodable<D>\n-    > spanned<T>: Decodable<D> {\n-        fn decode(d: &D) -> spanned<T> {\n-            do d.read_rec {\n-                {\n-                    node: d.read_field(~\"node\", 0, || decode(d)),\n-                    span: d.read_field(~\"span\", 1, || decode(d)),\n-                }\n-            }\n-        }\n-    }\n-\n-FIXME (#2810)--Hygiene. Search for \"__\" strings.  We also assume \"std\" is the\n-standard library.\n-\n-Misc notes:\n------------\n-\n-I use move mode arguments for ast nodes that will get inserted as is\n-into the tree.  This is intended to prevent us from inserting the same\n-node twice.\n-\n-*/\n+/// Deprecated #[auto_encode] and #[auto_decode] syntax extensions\n \n use ast;\n-use ast_util;\n-use attr;\n-use codemap;\n use codemap::span;\n use ext::base::*;\n-use parse;\n-use opt_vec;\n-use opt_vec::OptVec;\n-use ext::build;\n-\n-// Transitional reexports so qquote can find the paths it is looking for\n-mod syntax {\n-    pub use ext;\n-    pub use parse;\n-}\n \n pub fn expand_auto_encode(\n     cx: @ext_ctxt,\n     span: span,\n     _mitem: @ast::meta_item,\n     in_items: ~[@ast::item]\n ) -> ~[@ast::item] {\n-    fn is_auto_encode(a: &ast::attribute) -> bool {\n-        *attr::get_attr_name(a) == ~\"auto_encode\"\n-    }\n-\n-    fn filter_attrs(item: @ast::item) -> @ast::item {\n-        @ast::item {\n-            attrs: item.attrs.filtered(|a| !is_auto_encode(a)),\n-            .. copy *item\n-        }\n-    }\n-\n-    do vec::flat_map(in_items) |item| {\n-        if item.attrs.any(is_auto_encode) {\n-            match item.node {\n-                ast::item_struct(ref struct_def, ref generics) => {\n-                    let ser_impl = mk_struct_ser_impl(\n-                        cx,\n-                        item.span,\n-                        item.ident,\n-                        struct_def.fields,\n-                        generics\n-                    );\n-\n-                    ~[filter_attrs(*item), ser_impl]\n-                },\n-                ast::item_enum(ref enum_def, ref generics) => {\n-                    let ser_impl = mk_enum_ser_impl(\n-                        cx,\n-                        item.span,\n-                        item.ident,\n-                        copy *enum_def,\n-                        generics\n-                    );\n-\n-                    ~[filter_attrs(*item), ser_impl]\n-                },\n-                _ => {\n-                    cx.span_err(span, ~\"#[auto_encode] can only be \\\n-                                        applied to structs, record types, \\\n-                                        and enum definitions\");\n-                    ~[*item]\n-                }\n-            }\n-        } else {\n-            ~[*item]\n-        }\n-    }\n+    cx.span_err(span, \"`#[auto_encode]` is deprecated, use `#[deriving(Encodable)]` instead\");\n+    in_items\n }\n \n pub fn expand_auto_decode(\n@@ -166,1346 +30,6 @@ pub fn expand_auto_decode(\n     _mitem: @ast::meta_item,\n     in_items: ~[@ast::item]\n ) -> ~[@ast::item] {\n-    fn is_auto_decode(a: &ast::attribute) -> bool {\n-        *attr::get_attr_name(a) == ~\"auto_decode\"\n-    }\n-\n-    fn filter_attrs(item: @ast::item) -> @ast::item {\n-        @ast::item {\n-            attrs: item.attrs.filtered(|a| !is_auto_decode(a)),\n-            .. copy *item\n-        }\n-    }\n-\n-    do vec::flat_map(in_items) |item| {\n-        if item.attrs.any(is_auto_decode) {\n-            match item.node {\n-                ast::item_struct(ref struct_def, ref generics) => {\n-                    let deser_impl = mk_struct_deser_impl(\n-                        cx,\n-                        item.span,\n-                        item.ident,\n-                        struct_def.fields,\n-                        generics\n-                    );\n-\n-                    ~[filter_attrs(*item), deser_impl]\n-                },\n-                ast::item_enum(ref enum_def, ref generics) => {\n-                    let deser_impl = mk_enum_deser_impl(\n-                        cx,\n-                        item.span,\n-                        item.ident,\n-                        copy *enum_def,\n-                        generics\n-                    );\n-\n-                    ~[filter_attrs(*item), deser_impl]\n-                },\n-                _ => {\n-                    cx.span_err(span, ~\"#[auto_decode] can only be \\\n-                                        applied to structs, record types, \\\n-                                        and enum definitions\");\n-                    ~[*item]\n-                }\n-            }\n-        } else {\n-            ~[*item]\n-        }\n-    }\n-}\n-\n-trait ExtCtxtMethods {\n-    fn bind_path(&self,\n-                 span: span,\n-                 ident: ast::ident,\n-                 path: @ast::Path,\n-                 bounds: @OptVec<ast::TyParamBound>)\n-                 -> ast::TyParam;\n-    fn expr(&self, span: span, node: ast::expr_) -> @ast::expr;\n-    fn path(&self, span: span, strs: ~[ast::ident]) -> @ast::Path;\n-    fn path_global(&self, span: span, strs: ~[ast::ident]) -> @ast::Path;\n-    fn path_tps(&self, span: span, strs: ~[ast::ident], tps: ~[@ast::Ty])\n-                -> @ast::Path;\n-    fn path_tps_global(&self,\n-                       span: span,\n-                       strs: ~[ast::ident],\n-                       tps: ~[@ast::Ty])\n-                       -> @ast::Path;\n-    fn ty_path(&self, span: span, strs: ~[ast::ident], tps: ~[@ast::Ty])\n-               -> @ast::Ty;\n-    fn binder_pat(&self, span: span, nm: ast::ident) -> @ast::pat;\n-    fn stmt(&self, expr: @ast::expr) -> @ast::stmt;\n-    fn lit_str(&self, span: span, s: @~str) -> @ast::expr;\n-    fn lit_uint(&self, span: span, i: uint) -> @ast::expr;\n-    fn lambda0(&self, blk: ast::blk) -> @ast::expr;\n-    fn lambda1(&self, blk: ast::blk, ident: ast::ident) -> @ast::expr;\n-    fn blk(&self, span: span, stmts: ~[@ast::stmt]) -> ast::blk;\n-    fn expr_blk(&self, expr: @ast::expr) -> ast::blk;\n-    fn expr_path(&self, span: span, strs: ~[ast::ident]) -> @ast::expr;\n-    fn expr_path_global(&self, span: span, strs: ~[ast::ident]) -> @ast::expr;\n-    fn expr_var(&self, span: span, var: &str) -> @ast::expr;\n-    fn expr_self(&self, span: span) -> @ast::expr;\n-    fn expr_field(&self, span: span, expr: @ast::expr, ident: ast::ident)\n-                  -> @ast::expr;\n-    fn expr_call(&self, span: span, expr: @ast::expr, args: ~[@ast::expr])\n-                 -> @ast::expr;\n-    fn expr_method_call(&self,\n-                        span: span,\n-                        expr: @ast::expr,\n-                        ident: ast::ident,\n-                        args: ~[@ast::expr])\n-                        -> @ast::expr;\n-    fn lambda_expr_0(&self, expr: @ast::expr) -> @ast::expr;\n-    fn lambda_expr_1(&self, expr: @ast::expr, ident: ast::ident)\n-                    -> @ast::expr;\n-    fn lambda_stmts_0(&self, span: span, stmts: ~[@ast::stmt]) -> @ast::expr;\n-    fn lambda_stmts_1(&self,\n-                      span: span,\n-                      stmts: ~[@ast::stmt],\n-                      ident: ast::ident)\n-                      -> @ast::expr;\n-}\n-\n-impl ExtCtxtMethods for @ext_ctxt {\n-    fn bind_path(\n-        &self,\n-        _span: span,\n-        ident: ast::ident,\n-        path: @ast::Path,\n-        bounds: @OptVec<ast::TyParamBound>\n-    ) -> ast::TyParam {\n-        let bound = ast::TraitTyParamBound(@ast::trait_ref {\n-            ref_id: self.next_id(),\n-            path: path\n-        });\n-\n-        ast::TyParam {\n-            ident: ident,\n-            id: self.next_id(),\n-            bounds: @bounds.prepend(bound)\n-        }\n-    }\n-\n-    fn expr(&self, span: span, node: ast::expr_) -> @ast::expr {\n-        @ast::expr {\n-            id: self.next_id(),\n-            callee_id: self.next_id(),\n-            node: node,\n-            span: span,\n-        }\n-    }\n-\n-    fn path(&self, span: span, strs: ~[ast::ident]) -> @ast::Path {\n-        @ast::Path {\n-            span: span,\n-            global: false,\n-            idents: strs,\n-            rp: None,\n-            types: ~[]\n-        }\n-    }\n-\n-    fn path_global(&self, span: span, strs: ~[ast::ident]) -> @ast::Path {\n-        @ast::Path {\n-            span: span,\n-            global: true,\n-            idents: strs,\n-            rp: None,\n-            types: ~[]\n-        }\n-    }\n-\n-    fn path_tps(\n-        &self,\n-        span: span,\n-        strs: ~[ast::ident],\n-        tps: ~[@ast::Ty]\n-    ) -> @ast::Path {\n-        @ast::Path {\n-            span: span,\n-            global: false,\n-            idents: strs,\n-            rp: None,\n-            types: tps\n-        }\n-    }\n-\n-    fn path_tps_global(\n-        &self,\n-        span: span,\n-        strs: ~[ast::ident],\n-        tps: ~[@ast::Ty]\n-    ) -> @ast::Path {\n-        @ast::Path {\n-            span: span,\n-            global: true,\n-            idents: strs,\n-            rp: None,\n-            types: tps\n-        }\n-    }\n-\n-    fn ty_path(\n-        &self,\n-        span: span,\n-        strs: ~[ast::ident],\n-        tps: ~[@ast::Ty]\n-    ) -> @ast::Ty {\n-        @ast::Ty {\n-            id: self.next_id(),\n-            node: ast::ty_path(\n-                self.path_tps(span, strs, tps),\n-                self.next_id()),\n-            span: span,\n-        }\n-    }\n-\n-    fn binder_pat(&self, span: span, nm: ast::ident) -> @ast::pat {\n-        @ast::pat {\n-            id: self.next_id(),\n-            node: ast::pat_ident(\n-                ast::bind_by_ref(ast::m_imm),\n-                self.path(span, ~[nm]),\n-                None),\n-            span: span,\n-        }\n-    }\n-\n-    fn stmt(&self, expr: @ast::expr) -> @ast::stmt {\n-        @codemap::spanned { node: ast::stmt_semi(expr, self.next_id()),\n-                       span: expr.span }\n-    }\n-\n-    fn lit_str(&self, span: span, s: @~str) -> @ast::expr {\n-        self.expr(\n-            span,\n-            ast::expr_vstore(\n-                self.expr(\n-                    span,\n-                    ast::expr_lit(\n-                        @codemap::spanned { node: ast::lit_str(s),\n-                                        span: span})),\n-                ast::expr_vstore_uniq))\n-    }\n-\n-    fn lit_uint(&self, span: span, i: uint) -> @ast::expr {\n-        self.expr(\n-            span,\n-            ast::expr_lit(\n-                @codemap::spanned { node: ast::lit_uint(i as u64, ast::ty_u),\n-                                span: span}))\n-    }\n-\n-    fn lambda0(&self, blk: ast::blk) -> @ast::expr {\n-        let ext_cx = *self;\n-        let blk_e = self.expr(copy blk.span, ast::expr_block(copy blk));\n-        quote_expr!( || $blk_e )\n-    }\n-\n-    fn lambda1(&self, blk: ast::blk, ident: ast::ident) -> @ast::expr {\n-        let ext_cx = *self;\n-        let blk_e = self.expr(copy blk.span, ast::expr_block(copy blk));\n-        quote_expr!( |$ident| $blk_e )\n-    }\n-\n-    fn blk(&self, span: span, stmts: ~[@ast::stmt]) -> ast::blk {\n-        codemap::spanned {\n-            node: ast::blk_ {\n-                view_items: ~[],\n-                stmts: stmts,\n-                expr: None,\n-                id: self.next_id(),\n-                rules: ast::default_blk,\n-            },\n-            span: span,\n-        }\n-    }\n-\n-    fn expr_blk(&self, expr: @ast::expr) -> ast::blk {\n-        codemap::spanned {\n-            node: ast::blk_ {\n-                view_items: ~[],\n-                stmts: ~[],\n-                expr: Some(expr),\n-                id: self.next_id(),\n-                rules: ast::default_blk,\n-            },\n-            span: expr.span,\n-        }\n-    }\n-\n-    fn expr_path(&self, span: span, strs: ~[ast::ident]) -> @ast::expr {\n-        self.expr(span, ast::expr_path(self.path(span, strs)))\n-    }\n-\n-    fn expr_path_global(\n-        &self,\n-        span: span,\n-        strs: ~[ast::ident]\n-    ) -> @ast::expr {\n-        self.expr(span, ast::expr_path(self.path_global(span, strs)))\n-    }\n-\n-    fn expr_var(&self, span: span, var: &str) -> @ast::expr {\n-        self.expr_path(span, ~[self.ident_of(var)])\n-    }\n-\n-    fn expr_self(&self, span: span) -> @ast::expr {\n-        self.expr(span, ast::expr_self)\n-    }\n-\n-    fn expr_field(\n-        &self,\n-        span: span,\n-        expr: @ast::expr,\n-        ident: ast::ident\n-    ) -> @ast::expr {\n-        self.expr(span, ast::expr_field(expr, ident, ~[]))\n-    }\n-\n-    fn expr_call(\n-        &self,\n-        span: span,\n-        expr: @ast::expr,\n-        args: ~[@ast::expr]\n-    ) -> @ast::expr {\n-        self.expr(span, ast::expr_call(expr, args, ast::NoSugar))\n-    }\n-\n-    fn expr_method_call(\n-        &self,\n-        span: span,\n-        expr: @ast::expr,\n-        ident: ast::ident,\n-        args: ~[@ast::expr]\n-    ) -> @ast::expr {\n-        self.expr(span,\n-                  ast::expr_method_call(expr, ident, ~[], args, ast::NoSugar))\n-    }\n-\n-    fn lambda_expr_0(&self, expr: @ast::expr) -> @ast::expr {\n-        self.lambda0(self.expr_blk(expr))\n-    }\n-\n-    fn lambda_expr_1(&self, expr: @ast::expr, ident: ast::ident)\n-                    -> @ast::expr {\n-        self.lambda1(self.expr_blk(expr), ident)\n-    }\n-\n-    fn lambda_stmts_0(&self, span: span, stmts: ~[@ast::stmt]) -> @ast::expr {\n-        self.lambda0(self.blk(span, stmts))\n-    }\n-\n-    fn lambda_stmts_1(&self,\n-                      span: span,\n-                      stmts: ~[@ast::stmt],\n-                      ident: ast::ident)\n-                      -> @ast::expr {\n-        self.lambda1(self.blk(span, stmts), ident)\n-    }\n-}\n-\n-fn mk_impl(\n-    cx: @ext_ctxt,\n-    span: span,\n-    ident: ast::ident,\n-    ty_param: ast::TyParam,\n-    path: @ast::Path,\n-    generics: &ast::Generics,\n-    f: &fn(@ast::Ty) -> @ast::method\n-) -> @ast::item {\n-    /*!\n-     *\n-     * Given that we are deriving auto-encode a type `T<'a, ...,\n-     * 'z, A, ..., Z>`, creates an impl like:\n-     *\n-     *      impl<'a, ..., 'z, A:Tr, ..., Z:Tr> Tr for T<A, ..., Z> { ... }\n-     *\n-     * where Tr is either Serializable and Deserialize.\n-     *\n-     * FIXME(#5090): Remove code duplication between this and the code\n-     * in deriving.rs\n-     */\n-\n-\n-    // Copy the lifetimes\n-    let impl_lifetimes = generics.lifetimes.map(|l| {\n-        build::mk_lifetime(cx, l.span, l.ident)\n-    });\n-\n-    // All the type parameters need to bound to the trait.\n-    let mut impl_tps = opt_vec::with(ty_param);\n-    for generics.ty_params.each |tp| {\n-        let t_bound = ast::TraitTyParamBound(@ast::trait_ref {\n-            path: path,\n-            ref_id: cx.next_id(),\n-        });\n-\n-        impl_tps.push(ast::TyParam {\n-            ident: tp.ident,\n-            id: cx.next_id(),\n-            bounds: @tp.bounds.prepend(t_bound)\n-        })\n-    }\n-\n-    let opt_trait = Some(@ast::trait_ref {\n-        path: path,\n-        ref_id: cx.next_id(),\n-    });\n-\n-    let ty = cx.ty_path(\n-        span,\n-        ~[ident],\n-        opt_vec::take_vec(generics.ty_params.map(\n-            |tp| cx.ty_path(span, ~[tp.ident], ~[])))\n-    );\n-\n-    let generics = ast::Generics {\n-        lifetimes: impl_lifetimes,\n-        ty_params: impl_tps\n-    };\n-\n-    @ast::item {\n-        // This is a new-style impl declaration.\n-        // XXX: clownshoes\n-        ident: parse::token::special_idents::clownshoes_extensions,\n-        attrs: ~[],\n-        id: cx.next_id(),\n-        node: ast::item_impl(generics, opt_trait, ty, ~[f(ty)]),\n-        vis: ast::public,\n-        span: span,\n-    }\n-}\n-\n-fn mk_ser_impl(\n-    cx: @ext_ctxt,\n-    span: span,\n-    ident: ast::ident,\n-    generics: &ast::Generics,\n-    body: @ast::expr\n-) -> @ast::item {\n-    // Make a path to the std::serialize::Encodable typaram.\n-    let ty_param = cx.bind_path(\n-        span,\n-        cx.ident_of(\"__S\"),\n-        cx.path_global(\n-            span,\n-            ~[\n-                cx.ident_of(\"std\"),\n-                cx.ident_of(\"serialize\"),\n-                cx.ident_of(\"Encoder\"),\n-            ]\n-        ),\n-        @opt_vec::Empty\n-    );\n-\n-    // Make a path to the std::serialize::Encodable trait.\n-    let path = cx.path_tps_global(\n-        span,\n-        ~[\n-            cx.ident_of(\"std\"),\n-            cx.ident_of(\"serialize\"),\n-            cx.ident_of(\"Encodable\"),\n-        ],\n-        ~[cx.ty_path(span, ~[cx.ident_of(\"__S\")], ~[])]\n-    );\n-\n-    mk_impl(\n-        cx,\n-        span,\n-        ident,\n-        ty_param,\n-        path,\n-        generics,\n-        |_ty| mk_ser_method(cx, span, cx.expr_blk(body))\n-    )\n-}\n-\n-fn mk_deser_impl(\n-    cx: @ext_ctxt,\n-    span: span,\n-    ident: ast::ident,\n-    generics: &ast::Generics,\n-    body: @ast::expr\n-) -> @ast::item {\n-    // Make a path to the std::serialize::Decodable typaram.\n-    let ty_param = cx.bind_path(\n-        span,\n-        cx.ident_of(\"__D\"),\n-        cx.path_global(\n-            span,\n-            ~[\n-                cx.ident_of(\"std\"),\n-                cx.ident_of(\"serialize\"),\n-                cx.ident_of(\"Decoder\"),\n-            ]\n-        ),\n-        @opt_vec::Empty\n-    );\n-\n-    // Make a path to the std::serialize::Decodable trait.\n-    let path = cx.path_tps_global(\n-        span,\n-        ~[\n-            cx.ident_of(\"std\"),\n-            cx.ident_of(\"serialize\"),\n-            cx.ident_of(\"Decodable\"),\n-        ],\n-        ~[cx.ty_path(span, ~[cx.ident_of(\"__D\")], ~[])]\n-    );\n-\n-    mk_impl(\n-        cx,\n-        span,\n-        ident,\n-        ty_param,\n-        path,\n-        generics,\n-        |ty| mk_deser_method(cx, span, ty, cx.expr_blk(body))\n-    )\n-}\n-\n-fn mk_ser_method(\n-    cx: @ext_ctxt,\n-    span: span,\n-    ser_body: ast::blk\n-) -> @ast::method {\n-    let ty_s = @ast::Ty {\n-        id: cx.next_id(),\n-        node: ast::ty_rptr(\n-            None,\n-            ast::mt {\n-                ty: cx.ty_path(span, ~[cx.ident_of(\"__S\")], ~[]),\n-                mutbl: ast::m_mutbl\n-            }\n-        ),\n-        span: span,\n-    };\n-\n-    let ser_inputs = ~[ast::arg {\n-        is_mutbl: false,\n-        ty: ty_s,\n-        pat: @ast::pat {\n-            id: cx.next_id(),\n-            node: ast::pat_ident(\n-                ast::bind_by_copy,\n-                ast_util::ident_to_path(span, cx.ident_of(\"__s\")),\n-                None),\n-            span: span,\n-        },\n-        id: cx.next_id(),\n-    }];\n-\n-    let ser_output = @ast::Ty {\n-        id: cx.next_id(),\n-        node: ast::ty_nil,\n-        span: span,\n-    };\n-\n-    let ser_decl = ast::fn_decl {\n-        inputs: ser_inputs,\n-        output: ser_output,\n-        cf: ast::return_val,\n-    };\n-\n-    @ast::method {\n-        ident: cx.ident_of(\"encode\"),\n-        attrs: ~[],\n-        generics: ast_util::empty_generics(),\n-        explicit_self: codemap::spanned {\n-            node: ast::sty_region(None, ast::m_imm),\n-            span: span\n-        },\n-        purity: ast::impure_fn,\n-        decl: ser_decl,\n-        body: ser_body,\n-        id: cx.next_id(),\n-        span: span,\n-        self_id: cx.next_id(),\n-        vis: ast::public,\n-    }\n-}\n-\n-fn mk_deser_method(\n-    cx: @ext_ctxt,\n-    span: span,\n-    ty: @ast::Ty,\n-    deser_body: ast::blk\n-) -> @ast::method {\n-    let ty_d = @ast::Ty {\n-        id: cx.next_id(),\n-        node: ast::ty_rptr(\n-            None,\n-            ast::mt {\n-                ty: cx.ty_path(span, ~[cx.ident_of(\"__D\")], ~[]),\n-                mutbl: ast::m_mutbl\n-            }\n-        ),\n-        span: span,\n-    };\n-\n-    let deser_inputs = ~[\n-        ast::arg {\n-            is_mutbl: false,\n-            ty: ty_d,\n-            pat: @ast::pat {\n-                id: cx.next_id(),\n-                node: ast::pat_ident(ast::bind_by_copy,\n-                                     ast_util::ident_to_path(span,\n-                                                             cx.ident_of(\n-                                                                \"__d\")),\n-                                     None),\n-                span: span,\n-            },\n-            id: cx.next_id(),\n-        }\n-    ];\n-\n-    let deser_decl = ast::fn_decl {\n-        inputs: deser_inputs,\n-        output: ty,\n-        cf: ast::return_val,\n-    };\n-\n-    @ast::method {\n-        ident: cx.ident_of(\"decode\"),\n-        attrs: ~[],\n-        generics: ast_util::empty_generics(),\n-        explicit_self: codemap::spanned { node: ast::sty_static, span: span },\n-        purity: ast::impure_fn,\n-        decl: deser_decl,\n-        body: deser_body,\n-        id: cx.next_id(),\n-        span: span,\n-        self_id: cx.next_id(),\n-        vis: ast::public,\n-    }\n-}\n-\n-fn mk_struct_ser_impl(\n-    cx: @ext_ctxt,\n-    span: span,\n-    ident: ast::ident,\n-    fields: &[@ast::struct_field],\n-    generics: &ast::Generics\n-) -> @ast::item {\n-    let fields = do mk_struct_fields(fields).mapi |idx, field| {\n-        // ast for `|__s| self.$(name).encode(__s)`\n-        let expr_lambda = cx.lambda_expr_1(\n-            cx.expr_method_call(\n-                span,\n-                cx.expr_field(span, cx.expr_self(span), field.ident),\n-                cx.ident_of(~\"encode\"),\n-                ~[cx.expr_var(span, \"__s\")]\n-            ),\n-            cx.ident_of(\"__s\")\n-        );\n-\n-        // ast for `__s.emit_struct_field($(name), $(idx), $(expr_lambda))`\n-        cx.stmt(\n-            cx.expr_method_call(\n-                span,\n-                cx.expr_var(span, \"__s\"),\n-                cx.ident_of(\"emit_struct_field\"),\n-                ~[\n-                    cx.lit_str(span, @cx.str_of(field.ident)),\n-                    cx.lit_uint(span, idx),\n-                    expr_lambda,\n-                ]\n-            )\n-        )\n-    };\n-\n-    // ast for `__s.emit_struct($(name), |__s| $(fields))`\n-    let ser_body = cx.expr_method_call(\n-        span,\n-        cx.expr_var(span, \"__s\"),\n-        cx.ident_of(\"emit_struct\"),\n-        ~[\n-            cx.lit_str(span, @cx.str_of(ident)),\n-            cx.lit_uint(span, fields.len()),\n-            cx.lambda_stmts_1(span, fields, cx.ident_of(\"__s\")),\n-        ]\n-    );\n-\n-    mk_ser_impl(cx, span, ident, generics, ser_body)\n-}\n-\n-fn mk_struct_deser_impl(\n-    cx: @ext_ctxt,\n-    span: span,\n-    ident: ast::ident,\n-    fields: &[@ast::struct_field],\n-    generics: &ast::Generics\n-) -> @ast::item {\n-    let fields = do mk_struct_fields(fields).mapi |idx, field| {\n-        // ast for `|__d| std::serialize::decode(__d)`\n-        let expr_lambda = cx.lambda1(\n-            cx.expr_blk(\n-                cx.expr_call(\n-                    span,\n-                    cx.expr_path_global(span, ~[\n-                        cx.ident_of(\"std\"),\n-                        cx.ident_of(\"serialize\"),\n-                        cx.ident_of(\"Decodable\"),\n-                        cx.ident_of(\"decode\"),\n-                    ]),\n-                    ~[cx.expr_var(span, \"__d\")]\n-                )\n-            ),\n-            cx.ident_of(\"__d\")\n-        );\n-\n-        // ast for `__d.read_struct_field($(name), $(idx), $(expr_lambda))`\n-        let expr: @ast::expr = cx.expr_method_call(\n-            span,\n-            cx.expr_var(span, \"__d\"),\n-            cx.ident_of(\"read_struct_field\"),\n-            ~[\n-                cx.lit_str(span, @cx.str_of(field.ident)),\n-                cx.lit_uint(span, idx),\n-                expr_lambda,\n-            ]\n-        );\n-\n-        codemap::spanned {\n-            node: ast::field_ {\n-                mutbl: field.mutbl,\n-                ident: field.ident,\n-                expr: expr,\n-            },\n-            span: span,\n-        }\n-    };\n-\n-    // ast for `read_struct($(name), |__d| $(fields))`\n-    let body = cx.expr_method_call(\n-        span,\n-        cx.expr_var(span, \"__d\"),\n-        cx.ident_of(\"read_struct\"),\n-        ~[\n-            cx.lit_str(span, @cx.str_of(ident)),\n-            cx.lit_uint(span, fields.len()),\n-            cx.lambda_expr_1(\n-                cx.expr(\n-                    span,\n-                    ast::expr_struct(\n-                        cx.path(span, ~[ident]),\n-                        fields,\n-                        None\n-                    )\n-                ),\n-                cx.ident_of(\"__d\")\n-            ),\n-        ]\n-    );\n-\n-    mk_deser_impl(cx, span, ident, generics, body)\n-}\n-\n-// Records and structs don't have the same fields types, but they share enough\n-// that if we extract the right subfields out we can share the code\n-// generator code.\n-struct field {\n-    span: span,\n-    ident: ast::ident,\n-    mutbl: ast::mutability,\n-}\n-\n-fn mk_struct_fields(fields: &[@ast::struct_field]) -> ~[field] {\n-    do fields.map |field| {\n-        let ident = match field.node.kind {\n-            ast::named_field(ident, _) => ident,\n-            _ => fail!(\"[auto_encode] does not support unnamed fields\")\n-        };\n-\n-        field {\n-            span: field.span,\n-            ident: ident,\n-            mutbl: ast::m_imm,\n-        }\n-    }\n-}\n-\n-fn mk_enum_ser_impl(\n-    cx: @ext_ctxt,\n-    span: span,\n-    ident: ast::ident,\n-    enum_def: ast::enum_def,\n-    generics: &ast::Generics\n-) -> @ast::item {\n-    let body = mk_enum_ser_body(\n-        cx,\n-        span,\n-        ident,\n-        copy enum_def.variants\n-    );\n-\n-    mk_ser_impl(cx, span, ident, generics, body)\n-}\n-\n-fn mk_enum_deser_impl(\n-    cx: @ext_ctxt,\n-    span: span,\n-    ident: ast::ident,\n-    enum_def: ast::enum_def,\n-    generics: &ast::Generics\n-) -> @ast::item {\n-    let body = mk_enum_deser_body(\n-        cx,\n-        span,\n-        ident,\n-        enum_def.variants\n-    );\n-\n-    mk_deser_impl(cx, span, ident, generics, body)\n-}\n-\n-fn ser_variant(\n-    cx: @ext_ctxt,\n-    span: span,\n-    v_name: ast::ident,\n-    v_idx: uint,\n-    args: ~[ast::variant_arg]\n-) -> ast::arm {\n-    // Name the variant arguments.\n-    let names = args.mapi(|i, _arg| cx.ident_of(fmt!(\"__v%u\", i)));\n-\n-    // Bind the names to the variant argument type.\n-    let pats = args.mapi(|i, arg| cx.binder_pat(arg.ty.span, names[i]));\n-\n-    let pat_node = if pats.is_empty() {\n-        ast::pat_ident(\n-            ast::bind_infer,\n-            cx.path(span, ~[v_name]),\n-            None\n-        )\n-    } else {\n-        ast::pat_enum(\n-            cx.path(span, ~[v_name]),\n-            Some(pats)\n-        )\n-    };\n-\n-    let pat = @ast::pat {\n-        id: cx.next_id(),\n-        node: pat_node,\n-        span: span,\n-    };\n-\n-    let stmts = do args.mapi |a_idx, _arg| {\n-        // ast for `__s.emit_enum_variant_arg`\n-        let expr_emit = cx.expr_field(\n-            span,\n-            cx.expr_var(span, \"__s\"),\n-            cx.ident_of(\"emit_enum_variant_arg\")\n-        );\n-\n-        // ast for `|__s| $(v).encode(__s)`\n-        let expr_encode = cx.lambda_expr_1(\n-            cx.expr_method_call(\n-                span,\n-                 cx.expr_path(span, ~[names[a_idx]]),\n-                 cx.ident_of(\"encode\"),\n-                ~[cx.expr_var(span, \"__s\")]\n-            ),\n-            cx.ident_of(\"__s\")\n-        );\n-\n-        // ast for `$(expr_emit)($(a_idx), $(expr_encode))`\n-        cx.stmt(\n-            cx.expr_call(\n-                span,\n-                expr_emit,\n-                ~[cx.lit_uint(span, a_idx), expr_encode]\n-            )\n-        )\n-    };\n-\n-    // ast for `__s.emit_enum_variant($(name), $(idx), $(sz), $(lambda))`\n-    let body = cx.expr_method_call(\n-        span,\n-        cx.expr_var(span, \"__s\"),\n-        cx.ident_of(\"emit_enum_variant\"),\n-        ~[\n-            cx.lit_str(span, @cx.str_of(v_name)),\n-            cx.lit_uint(span, v_idx),\n-            cx.lit_uint(span, stmts.len()),\n-            cx.lambda_stmts_1(span, stmts, cx.ident_of(\"__s\")),\n-        ]\n-    );\n-\n-    ast::arm { pats: ~[pat], guard: None, body: cx.expr_blk(body) }\n-}\n-\n-fn mk_enum_ser_body(\n-    cx: @ext_ctxt,\n-    span: span,\n-    name: ast::ident,\n-    variants: ~[ast::variant]\n-) -> @ast::expr {\n-    let arms = do variants.mapi |v_idx, variant| {\n-        match variant.node.kind {\n-            ast::tuple_variant_kind(ref args) =>\n-                ser_variant(\n-                    cx,\n-                    span,\n-                    variant.node.name,\n-                    v_idx,\n-                    /*bad*/ copy *args\n-                ),\n-            ast::struct_variant_kind(*) =>\n-                fail!(\"struct variants unimplemented\"),\n-        }\n-    };\n-\n-    // ast for `match *self { $(arms) }`\n-    let match_expr = cx.expr(\n-        span,\n-        ast::expr_match(cx.expr(span,\n-                                ast::expr_unary(ast::deref,\n-                                                cx.expr_self(span))),\n-                        arms)\n-    );\n-\n-    // ast for `__s.emit_enum($(name), || $(match_expr))`\n-    cx.expr_method_call(\n-        span,\n-        cx.expr_var(span, \"__s\"),\n-        cx.ident_of(\"emit_enum\"),\n-        ~[\n-            cx.lit_str(span, @cx.str_of(name)),\n-            cx.lambda_expr_1(match_expr, cx.ident_of(\"__s\")),\n-        ]\n-    )\n-}\n-\n-fn mk_enum_deser_variant_nary(\n-    cx: @ext_ctxt,\n-    span: span,\n-    name: ast::ident,\n-    args: ~[ast::variant_arg]\n-) -> @ast::expr {\n-    let args = do args.mapi |idx, _arg| {\n-        // ast for `|__s| std::serialize::decode(__d)`\n-        let expr_lambda = cx.lambda_expr_1(\n-            cx.expr_call(\n-                span,\n-                cx.expr_path_global(span, ~[\n-                    cx.ident_of(\"std\"),\n-                    cx.ident_of(\"serialize\"),\n-                    cx.ident_of(\"Decodable\"),\n-                    cx.ident_of(\"decode\"),\n-                ]),\n-                ~[cx.expr_var(span, \"__d\")]\n-            ),\n-            cx.ident_of(\"__d\")\n-        );\n-\n-        // ast for `__d.read_enum_variant_arg($(a_idx), $(expr_lambda))`\n-        cx.expr_method_call(\n-            span,\n-            cx.expr_var(span, \"__d\"),\n-            cx.ident_of(\"read_enum_variant_arg\"),\n-            ~[cx.lit_uint(span, idx), expr_lambda]\n-        )\n-    };\n-\n-    // ast for `$(name)($(args))`\n-    cx.expr_call(span, cx.expr_path(span, ~[name]), args)\n-}\n-\n-fn mk_enum_deser_body(\n-    ext_cx: @ext_ctxt,\n-    span: span,\n-    name: ast::ident,\n-    variants: &[ast::variant]\n-) -> @ast::expr {\n-    let expr_arm_names = build::mk_base_vec_e(\n-        ext_cx,\n-        span,\n-         do variants.map |variant| {\n-            build::mk_base_str(\n-                ext_cx,\n-                span,\n-                ext_cx.str_of(variant.node.name)\n-            )\n-        }\n-    );\n-\n-    let mut arms = do variants.mapi |v_idx, variant| {\n-        let body = match variant.node.kind {\n-            ast::tuple_variant_kind(ref args) => {\n-                if args.is_empty() {\n-                    // for a nullary variant v, do \"v\"\n-                    ext_cx.expr_path(span, ~[variant.node.name])\n-                } else {\n-                    // for an n-ary variant v, do \"v(a_1, ..., a_n)\"\n-                    mk_enum_deser_variant_nary(\n-                        ext_cx,\n-                        span,\n-                        variant.node.name,\n-                        copy *args\n-                    )\n-                }\n-            },\n-            ast::struct_variant_kind(*) =>\n-                fail!(\"struct variants unimplemented\"),\n-        };\n-\n-        let pat = @ast::pat {\n-            id: ext_cx.next_id(),\n-            node: ast::pat_lit(ext_cx.lit_uint(span, v_idx)),\n-            span: span,\n-        };\n-\n-        ast::arm {\n-            pats: ~[pat],\n-            guard: None,\n-            body: ext_cx.expr_blk(body),\n-        }\n-    };\n-\n-    let quoted_expr = copy quote_expr!(\n-      ::core::sys::FailWithCause::fail_with(\"explicit failure\", \"empty\", 1);\n-    ).node;\n-\n-    let impossible_case = ast::arm {\n-        pats: ~[@ast::pat {\n-            id: ext_cx.next_id(),\n-            node: ast::pat_wild,\n-            span: span,\n-        }],\n-        guard: None,\n-\n-        // FIXME(#3198): proper error message\n-        body: ext_cx.expr_blk(ext_cx.expr(span, quoted_expr)),\n-    };\n-\n-    arms.push(impossible_case);\n-\n-    // ast for `|i| { match i { $(arms) } }`\n-    let expr_lambda = ext_cx.expr(\n-        span,\n-        ast::expr_fn_block(\n-            ast::fn_decl {\n-                inputs: ~[\n-                    ast::arg {\n-                        is_mutbl: false,\n-                        ty: @ast::Ty {\n-                            id: ext_cx.next_id(),\n-                            node: ast::ty_infer,\n-                            span: span\n-                        },\n-                        pat: @ast::pat {\n-                            id: ext_cx.next_id(),\n-                            node: ast::pat_ident(\n-                                ast::bind_by_copy,\n-                                ast_util::ident_to_path(span,\n-                                    ext_cx.ident_of(\"__d\")),\n-                                None),\n-                            span: span,\n-                        },\n-                        id: ext_cx.next_id(),\n-                    },\n-                    ast::arg {\n-                        is_mutbl: false,\n-                        ty: @ast::Ty {\n-                            id: ext_cx.next_id(),\n-                            node: ast::ty_infer,\n-                            span: span\n-                        },\n-                        pat: @ast::pat {\n-                            id: ext_cx.next_id(),\n-                            node: ast::pat_ident(\n-                                ast::bind_by_copy,\n-                                ast_util::ident_to_path(span,\n-                                    ext_cx.ident_of(\"i\")),\n-                                None),\n-                            span: span,\n-                        },\n-                        id: ext_cx.next_id(),\n-                    }\n-                ],\n-                output: @ast::Ty {\n-                    id: ext_cx.next_id(),\n-                    node: ast::ty_infer,\n-                    span: span,\n-                },\n-                cf: ast::return_val,\n-            },\n-            ext_cx.expr_blk(\n-                ext_cx.expr(\n-                    span,\n-                    ast::expr_match(ext_cx.expr_var(span, \"i\"), arms)\n-                )\n-            )\n-        )\n-    );\n-\n-    // ast for `__d.read_enum_variant($expr_arm_names, $(expr_lambda))`\n-    let expr_lambda = ext_cx.lambda_expr_1(\n-        ext_cx.expr_method_call(\n-            span,\n-            ext_cx.expr_var(span, \"__d\"),\n-            ext_cx.ident_of(\"read_enum_variant\"),\n-            ~[expr_arm_names, expr_lambda]\n-        ),\n-        ext_cx.ident_of(\"__d\")\n-    );\n-\n-    // ast for `__d.read_enum($(e_name), $(expr_lambda))`\n-    ext_cx.expr_method_call(\n-        span,\n-        ext_cx.expr_var(span, \"__d\"),\n-        ext_cx.ident_of(\"read_enum\"),\n-        ~[\n-            ext_cx.lit_str(span, @ext_cx.str_of(name)),\n-            expr_lambda\n-        ]\n-    )\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use core::option::{None, Some};\n-    use std::serialize::Encodable;\n-    use std::serialize::Encoder;\n-\n-    // just adding the ones I want to test, for now:\n-    #[deriving(Eq)]\n-    pub enum call {\n-        CallToEmitEnum(~str),\n-        CallToEmitEnumVariant(~str, uint, uint),\n-        CallToEmitEnumVariantArg(uint),\n-        CallToEmitUint(uint),\n-        CallToEmitNil,\n-        CallToEmitStruct(~str,uint),\n-        CallToEmitField(~str,uint),\n-        CallToEmitOption,\n-        CallToEmitOptionNone,\n-        CallToEmitOptionSome,\n-        // all of the ones I was too lazy to handle:\n-        CallToOther\n-    }\n-    // using `@mut` rather than changing the\n-    // type of self in every method of every encoder everywhere.\n-    pub struct TestEncoder {call_log : @mut ~[call]}\n-\n-    pub impl TestEncoder {\n-        // these self's should be &mut self's, as well....\n-        fn add_to_log (&self, c : call) {\n-            self.call_log.push(copy c);\n-        }\n-        fn add_unknown_to_log (&self) {\n-            self.add_to_log (CallToOther)\n-        }\n-    }\n-\n-    impl Encoder for TestEncoder {\n-        fn emit_nil(&mut self) { self.add_to_log(CallToEmitNil) }\n-\n-        fn emit_uint(&mut self, v: uint) {\n-            self.add_to_log(CallToEmitUint(v));\n-        }\n-        fn emit_u64(&mut self, _v: u64) { self.add_unknown_to_log(); }\n-        fn emit_u32(&mut self, _v: u32) { self.add_unknown_to_log(); }\n-        fn emit_u16(&mut self, _v: u16) { self.add_unknown_to_log(); }\n-        fn emit_u8(&mut self, _v: u8)   { self.add_unknown_to_log(); }\n-\n-        fn emit_int(&mut self, _v: int) { self.add_unknown_to_log(); }\n-        fn emit_i64(&mut self, _v: i64) { self.add_unknown_to_log(); }\n-        fn emit_i32(&mut self, _v: i32) { self.add_unknown_to_log(); }\n-        fn emit_i16(&mut self, _v: i16) { self.add_unknown_to_log(); }\n-        fn emit_i8(&mut self, _v: i8)   { self.add_unknown_to_log(); }\n-\n-        fn emit_bool(&mut self, _v: bool) { self.add_unknown_to_log(); }\n-\n-        fn emit_f64(&mut self, _v: f64) { self.add_unknown_to_log(); }\n-        fn emit_f32(&mut self, _v: f32) { self.add_unknown_to_log(); }\n-        fn emit_float(&mut self, _v: float) { self.add_unknown_to_log(); }\n-\n-        fn emit_char(&mut self, _v: char) { self.add_unknown_to_log(); }\n-        fn emit_str(&mut self, _v: &str) { self.add_unknown_to_log(); }\n-\n-        fn emit_enum(&mut self, name: &str, f: &fn(&mut TestEncoder)) {\n-            self.add_to_log(CallToEmitEnum(name.to_str()));\n-            f(self);\n-        }\n-\n-        fn emit_enum_variant(&mut self,\n-                             name: &str,\n-                             id: uint,\n-                             cnt: uint,\n-                             f: &fn(&mut TestEncoder)) {\n-            self.add_to_log(CallToEmitEnumVariant(name.to_str(), id, cnt));\n-            f(self);\n-        }\n-\n-        fn emit_enum_variant_arg(&mut self,\n-                                 idx: uint,\n-                                 f: &fn(&mut TestEncoder)) {\n-            self.add_to_log(CallToEmitEnumVariantArg(idx));\n-            f(self);\n-        }\n-\n-        fn emit_enum_struct_variant(&mut self,\n-                                    name: &str,\n-                                    id: uint,\n-                                    cnt: uint,\n-                                    f: &fn(&mut TestEncoder)) {\n-            self.emit_enum_variant(name, id, cnt, f)\n-        }\n-\n-        fn emit_enum_struct_variant_field(&mut self,\n-                                          _name: &str,\n-                                          idx: uint,\n-                                          f: &fn(&mut TestEncoder)) {\n-            self.emit_enum_variant_arg(idx, f)\n-        }\n-\n-        fn emit_struct(&mut self,\n-                       name: &str,\n-                       len: uint,\n-                       f: &fn(&mut TestEncoder)) {\n-            self.add_to_log(CallToEmitStruct (name.to_str(),len));\n-            f(self);\n-        }\n-        fn emit_struct_field(&mut self,\n-                             name: &str,\n-                             idx: uint,\n-                             f: &fn(&mut TestEncoder)) {\n-            self.add_to_log(CallToEmitField (name.to_str(),idx));\n-            f(self);\n-        }\n-\n-        fn emit_tuple(&mut self, _len: uint, f: &fn(&mut TestEncoder)) {\n-            self.add_unknown_to_log();\n-            f(self);\n-        }\n-        fn emit_tuple_arg(&mut self, _idx: uint, f: &fn(&mut TestEncoder)) {\n-            self.add_unknown_to_log();\n-            f(self);\n-        }\n-\n-        fn emit_tuple_struct(&mut self,\n-                             _name: &str,\n-                             _len: uint,\n-                             f: &fn(&mut TestEncoder)) {\n-            self.add_unknown_to_log();\n-            f(self);\n-        }\n-\n-        fn emit_tuple_struct_arg(&mut self,\n-                                 _idx: uint,\n-                                 f: &fn(&mut TestEncoder)) {\n-            self.add_unknown_to_log();\n-            f(self);\n-        }\n-\n-        fn emit_option(&mut self, f: &fn(&mut TestEncoder)) {\n-            self.add_to_log(CallToEmitOption);\n-            f(self);\n-        }\n-        fn emit_option_none(&mut self) {\n-            self.add_to_log(CallToEmitOptionNone);\n-        }\n-        fn emit_option_some(&mut self, f: &fn(&mut TestEncoder)) {\n-            self.add_to_log(CallToEmitOptionSome);\n-            f(self);\n-        }\n-\n-        fn emit_seq(&mut self, _len: uint, f: &fn(&mut TestEncoder)) {\n-            self.add_unknown_to_log();\n-            f(self);\n-        }\n-        fn emit_seq_elt(&mut self, _idx: uint, f: &fn(&mut TestEncoder)) {\n-            self.add_unknown_to_log();\n-            f(self);\n-        }\n-\n-        fn emit_map(&mut self, _len: uint, f: &fn(&mut TestEncoder)) {\n-            self.add_unknown_to_log();\n-            f(self);\n-        }\n-        fn emit_map_elt_key(&mut self, _idx: uint, f: &fn(&mut TestEncoder)) {\n-            self.add_unknown_to_log();\n-            f(self);\n-        }\n-        fn emit_map_elt_val(&mut self, _idx: uint, f: &fn(&mut TestEncoder)) {\n-            self.add_unknown_to_log();\n-            f(self);\n-        }\n-    }\n-\n-\n-    fn to_call_log<E:Encodable<TestEncoder>>(val: E) -> ~[call] {\n-        let mut te = TestEncoder {\n-            call_log: @mut ~[]\n-        };\n-        val.encode(&mut te);\n-        copy *te.call_log\n-    }\n-\n-    #[auto_encode]\n-    enum Written {\n-        Book(uint,uint),\n-        Magazine(~str)\n-    }\n-\n-    #[test]\n-    fn test_encode_enum() {\n-        assert_eq!(\n-            to_call_log(Book(34,44)),\n-            ~[\n-                CallToEmitEnum(~\"Written\"),\n-                CallToEmitEnumVariant(~\"Book\",0,2),\n-                CallToEmitEnumVariantArg(0),\n-                CallToEmitUint(34),\n-                CallToEmitEnumVariantArg(1),\n-                CallToEmitUint(44),\n-            ]\n-        );\n-    }\n-\n-    pub struct BPos(uint);\n-\n-    #[auto_encode]\n-    pub struct HasPos { pos : BPos }\n-\n-    #[test]\n-    fn test_encode_newtype() {\n-        assert_eq!(\n-            to_call_log(HasPos { pos:BPos(48) }),\n-            ~[\n-                CallToEmitStruct(~\"HasPos\",1),\n-                CallToEmitField(~\"pos\",0),\n-                CallToEmitUint(48),\n-            ]\n-        );\n-    }\n-\n-    #[test]\n-    fn test_encode_option() {\n-        let mut v = None;\n-\n-        assert_eq!(\n-            to_call_log(v),\n-            ~[\n-                CallToEmitOption,\n-                CallToEmitOptionNone,\n-            ]\n-        );\n-\n-        v = Some(54u);\n-        assert_eq!(\n-            to_call_log(v),\n-            ~[\n-                CallToEmitOption,\n-                CallToEmitOptionSome,\n-                CallToEmitUint(54)\n-            ]\n-        );\n-    }\n+    cx.span_err(span, \"`#[auto_decode]` is deprecated, use `#[deriving(Decodable)]` instead\");\n+    in_items\n }"}, {"sha": "01b37a1196cdaf43a4c8fa5d768026eef9c7638a", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 298, "deletions": 0, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/8257528b6c51a1793401cc6028141b86f6432aa6/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8257528b6c51a1793401cc6028141b86f6432aa6/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=8257528b6c51a1793401cc6028141b86f6432aa6", "patch": "@@ -538,3 +538,301 @@ pub fn duplicate_expr(cx: @ext_ctxt, expr: @ast::expr) -> @ast::expr {\n     folder.fold_expr(expr)\n }\n \n+\n+\n+// Transitional reexports so qquote can find the paths it is looking for\n+mod syntax {\n+    pub use ext;\n+    pub use parse;\n+}\n+\n+trait ExtCtxtMethods {\n+    fn bind_path(&self,\n+                 span: span,\n+                 ident: ast::ident,\n+                 path: @ast::Path,\n+                 bounds: @OptVec<ast::TyParamBound>)\n+                 -> ast::TyParam;\n+    fn expr(&self, span: span, node: ast::expr_) -> @ast::expr;\n+    fn path(&self, span: span, strs: ~[ast::ident]) -> @ast::Path;\n+    fn path_global(&self, span: span, strs: ~[ast::ident]) -> @ast::Path;\n+    fn path_tps(&self, span: span, strs: ~[ast::ident], tps: ~[@ast::Ty])\n+                -> @ast::Path;\n+    fn path_tps_global(&self,\n+                       span: span,\n+                       strs: ~[ast::ident],\n+                       tps: ~[@ast::Ty])\n+                       -> @ast::Path;\n+    fn ty_path(&self, span: span, strs: ~[ast::ident], tps: ~[@ast::Ty])\n+               -> @ast::Ty;\n+    fn binder_pat(&self, span: span, nm: ast::ident) -> @ast::pat;\n+    fn stmt(&self, expr: @ast::expr) -> @ast::stmt;\n+    fn lit_str(&self, span: span, s: @~str) -> @ast::expr;\n+    fn lit_uint(&self, span: span, i: uint) -> @ast::expr;\n+    fn lambda0(&self, blk: ast::blk) -> @ast::expr;\n+    fn lambda1(&self, blk: ast::blk, ident: ast::ident) -> @ast::expr;\n+    fn blk(&self, span: span, stmts: ~[@ast::stmt]) -> ast::blk;\n+    fn expr_blk(&self, expr: @ast::expr) -> ast::blk;\n+    fn expr_path(&self, span: span, strs: ~[ast::ident]) -> @ast::expr;\n+    fn expr_path_global(&self, span: span, strs: ~[ast::ident]) -> @ast::expr;\n+    fn expr_var(&self, span: span, var: &str) -> @ast::expr;\n+    fn expr_self(&self, span: span) -> @ast::expr;\n+    fn expr_field(&self, span: span, expr: @ast::expr, ident: ast::ident)\n+                  -> @ast::expr;\n+    fn expr_call(&self, span: span, expr: @ast::expr, args: ~[@ast::expr])\n+                 -> @ast::expr;\n+    fn expr_method_call(&self,\n+                        span: span,\n+                        expr: @ast::expr,\n+                        ident: ast::ident,\n+                        args: ~[@ast::expr])\n+                        -> @ast::expr;\n+    fn lambda_expr_0(&self, expr: @ast::expr) -> @ast::expr;\n+    fn lambda_expr_1(&self, expr: @ast::expr, ident: ast::ident)\n+                    -> @ast::expr;\n+    fn lambda_stmts_0(&self, span: span, stmts: ~[@ast::stmt]) -> @ast::expr;\n+    fn lambda_stmts_1(&self,\n+                      span: span,\n+                      stmts: ~[@ast::stmt],\n+                      ident: ast::ident)\n+                      -> @ast::expr;\n+}\n+\n+impl ExtCtxtMethods for @ext_ctxt {\n+    fn bind_path(\n+        &self,\n+        _span: span,\n+        ident: ast::ident,\n+        path: @ast::Path,\n+        bounds: @OptVec<ast::TyParamBound>\n+    ) -> ast::TyParam {\n+        let bound = ast::TraitTyParamBound(@ast::trait_ref {\n+            ref_id: self.next_id(),\n+            path: path\n+        });\n+\n+        ast::TyParam {\n+            ident: ident,\n+            id: self.next_id(),\n+            bounds: @bounds.prepend(bound)\n+        }\n+    }\n+\n+    fn expr(&self, span: span, node: ast::expr_) -> @ast::expr {\n+        @ast::expr {\n+            id: self.next_id(),\n+            callee_id: self.next_id(),\n+            node: node,\n+            span: span,\n+        }\n+    }\n+\n+    fn path(&self, span: span, strs: ~[ast::ident]) -> @ast::Path {\n+        @ast::Path {\n+            span: span,\n+            global: false,\n+            idents: strs,\n+            rp: None,\n+            types: ~[]\n+        }\n+    }\n+\n+    fn path_global(&self, span: span, strs: ~[ast::ident]) -> @ast::Path {\n+        @ast::Path {\n+            span: span,\n+            global: true,\n+            idents: strs,\n+            rp: None,\n+            types: ~[]\n+        }\n+    }\n+\n+    fn path_tps(\n+        &self,\n+        span: span,\n+        strs: ~[ast::ident],\n+        tps: ~[@ast::Ty]\n+    ) -> @ast::Path {\n+        @ast::Path {\n+            span: span,\n+            global: false,\n+            idents: strs,\n+            rp: None,\n+            types: tps\n+        }\n+    }\n+\n+    fn path_tps_global(\n+        &self,\n+        span: span,\n+        strs: ~[ast::ident],\n+        tps: ~[@ast::Ty]\n+    ) -> @ast::Path {\n+        @ast::Path {\n+            span: span,\n+            global: true,\n+            idents: strs,\n+            rp: None,\n+            types: tps\n+        }\n+    }\n+\n+    fn ty_path(\n+        &self,\n+        span: span,\n+        strs: ~[ast::ident],\n+        tps: ~[@ast::Ty]\n+    ) -> @ast::Ty {\n+        @ast::Ty {\n+            id: self.next_id(),\n+            node: ast::ty_path(\n+                self.path_tps(span, strs, tps),\n+                self.next_id()),\n+            span: span,\n+        }\n+    }\n+\n+    fn binder_pat(&self, span: span, nm: ast::ident) -> @ast::pat {\n+        @ast::pat {\n+            id: self.next_id(),\n+            node: ast::pat_ident(\n+                ast::bind_by_ref(ast::m_imm),\n+                self.path(span, ~[nm]),\n+                None),\n+            span: span,\n+        }\n+    }\n+\n+    fn stmt(&self, expr: @ast::expr) -> @ast::stmt {\n+        @codemap::spanned { node: ast::stmt_semi(expr, self.next_id()),\n+                       span: expr.span }\n+    }\n+\n+    fn lit_str(&self, span: span, s: @~str) -> @ast::expr {\n+        self.expr(\n+            span,\n+            ast::expr_vstore(\n+                self.expr(\n+                    span,\n+                    ast::expr_lit(\n+                        @codemap::spanned { node: ast::lit_str(s),\n+                                        span: span})),\n+                ast::expr_vstore_uniq))\n+    }\n+\n+    fn lit_uint(&self, span: span, i: uint) -> @ast::expr {\n+        self.expr(\n+            span,\n+            ast::expr_lit(\n+                @codemap::spanned { node: ast::lit_uint(i as u64, ast::ty_u),\n+                                span: span}))\n+    }\n+\n+    fn lambda0(&self, blk: ast::blk) -> @ast::expr {\n+        let ext_cx = *self;\n+        let blk_e = self.expr(copy blk.span, ast::expr_block(copy blk));\n+        quote_expr!( || $blk_e )\n+    }\n+\n+    fn lambda1(&self, blk: ast::blk, ident: ast::ident) -> @ast::expr {\n+        let ext_cx = *self;\n+        let blk_e = self.expr(copy blk.span, ast::expr_block(copy blk));\n+        quote_expr!( |$ident| $blk_e )\n+    }\n+\n+    fn blk(&self, span: span, stmts: ~[@ast::stmt]) -> ast::blk {\n+        codemap::spanned {\n+            node: ast::blk_ {\n+                view_items: ~[],\n+                stmts: stmts,\n+                expr: None,\n+                id: self.next_id(),\n+                rules: ast::default_blk,\n+            },\n+            span: span,\n+        }\n+    }\n+\n+    fn expr_blk(&self, expr: @ast::expr) -> ast::blk {\n+        codemap::spanned {\n+            node: ast::blk_ {\n+                view_items: ~[],\n+                stmts: ~[],\n+                expr: Some(expr),\n+                id: self.next_id(),\n+                rules: ast::default_blk,\n+            },\n+            span: expr.span,\n+        }\n+    }\n+\n+    fn expr_path(&self, span: span, strs: ~[ast::ident]) -> @ast::expr {\n+        self.expr(span, ast::expr_path(self.path(span, strs)))\n+    }\n+\n+    fn expr_path_global(\n+        &self,\n+        span: span,\n+        strs: ~[ast::ident]\n+    ) -> @ast::expr {\n+        self.expr(span, ast::expr_path(self.path_global(span, strs)))\n+    }\n+\n+    fn expr_var(&self, span: span, var: &str) -> @ast::expr {\n+        self.expr_path(span, ~[self.ident_of(var)])\n+    }\n+\n+    fn expr_self(&self, span: span) -> @ast::expr {\n+        self.expr(span, ast::expr_self)\n+    }\n+\n+    fn expr_field(\n+        &self,\n+        span: span,\n+        expr: @ast::expr,\n+        ident: ast::ident\n+    ) -> @ast::expr {\n+        self.expr(span, ast::expr_field(expr, ident, ~[]))\n+    }\n+\n+    fn expr_call(\n+        &self,\n+        span: span,\n+        expr: @ast::expr,\n+        args: ~[@ast::expr]\n+    ) -> @ast::expr {\n+        self.expr(span, ast::expr_call(expr, args, ast::NoSugar))\n+    }\n+\n+    fn expr_method_call(\n+        &self,\n+        span: span,\n+        expr: @ast::expr,\n+        ident: ast::ident,\n+        args: ~[@ast::expr]\n+    ) -> @ast::expr {\n+        self.expr(span,\n+                  ast::expr_method_call(expr, ident, ~[], args, ast::NoSugar))\n+    }\n+\n+    fn lambda_expr_0(&self, expr: @ast::expr) -> @ast::expr {\n+        self.lambda0(self.expr_blk(expr))\n+    }\n+\n+    fn lambda_expr_1(&self, expr: @ast::expr, ident: ast::ident)\n+                    -> @ast::expr {\n+        self.lambda1(self.expr_blk(expr), ident)\n+    }\n+\n+    fn lambda_stmts_0(&self, span: span, stmts: ~[@ast::stmt]) -> @ast::expr {\n+        self.lambda0(self.blk(span, stmts))\n+    }\n+\n+    fn lambda_stmts_1(&self,\n+                      span: span,\n+                      stmts: ~[@ast::stmt],\n+                      ident: ast::ident)\n+                      -> @ast::expr {\n+        self.lambda1(self.blk(span, stmts), ident)\n+    }\n+}"}, {"sha": "2e2f382a7687bfcfcca7fabb682e60e0f6e77813", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8257528b6c51a1793401cc6028141b86f6432aa6/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8257528b6c51a1793401cc6028141b86f6432aa6/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=8257528b6c51a1793401cc6028141b86f6432aa6", "patch": "@@ -8,6 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+/*!\n+The compiler code necessary for #[deriving(Decodable)]. See\n+encodable.rs for more.\n+*/\n+\n use ast;\n use ast::*;\n use ext::base::ext_ctxt;"}, {"sha": "8a1c3933f51277e0f1cbaeccb4a02050252a0cb8", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 312, "deletions": 0, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/8257528b6c51a1793401cc6028141b86f6432aa6/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8257528b6c51a1793401cc6028141b86f6432aa6/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=8257528b6c51a1793401cc6028141b86f6432aa6", "patch": "@@ -8,6 +8,74 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+/*!\n+\n+The compiler code necessary to implement the #[deriving(Encodable)]\n+(and Decodable, in decodable.rs) extension.  The idea here is that\n+type-defining items may be tagged with #[deriving(Encodable,\n+Decodable)].\n+\n+For example, a type like:\n+\n+    #[deriving(Encodable, Decodable)]\n+    struct Node {id: uint}\n+\n+would generate two implementations like:\n+\n+impl<S:std::serialize::Encoder> Encodable<S> for Node {\n+    fn encode(&self, s: &S) {\n+        do s.emit_struct(\"Node\", 1) {\n+            s.emit_field(\"id\", 0, || s.emit_uint(self.id))\n+        }\n+    }\n+}\n+\n+impl<D:Decoder> Decodable for node_id {\n+    fn decode(d: &D) -> Node {\n+        do d.read_struct(\"Node\", 1) {\n+            Node {\n+                id: d.read_field(~\"x\", 0, || decode(d))\n+            }\n+        }\n+    }\n+}\n+\n+Other interesting scenarios are whe the item has type parameters or\n+references other non-built-in types.  A type definition like:\n+\n+    #[deriving(Encodable, Decodable)]\n+    struct spanned<T> {node: T, span: span}\n+\n+would yield functions like:\n+\n+    impl<\n+        S: Encoder,\n+        T: Encodable<S>\n+    > spanned<T>: Encodable<S> {\n+        fn encode<S:Encoder>(s: &S) {\n+            do s.emit_rec {\n+                s.emit_field(\"node\", 0, || self.node.encode(s));\n+                s.emit_field(\"span\", 1, || self.span.encode(s));\n+            }\n+        }\n+    }\n+\n+    impl<\n+        D: Decoder,\n+        T: Decodable<D>\n+    > spanned<T>: Decodable<D> {\n+        fn decode(d: &D) -> spanned<T> {\n+            do d.read_rec {\n+                {\n+                    node: d.read_field(~\"node\", 0, || decode(d)),\n+                    span: d.read_field(~\"span\", 1, || decode(d)),\n+                }\n+            }\n+        }\n+    }\n+*/\n+\n+\n use ast;\n use ast::*;\n use ext::base::ext_ctxt;\n@@ -403,3 +471,247 @@ fn expand_deriving_encodable_enum_method(\n     // Create the method.\n     create_encode_method(cx, span, ~[stmt])\n }\n+\n+#[cfg(test)]\n+mod test {\n+    extern mod std;\n+    use core::option::{None, Some};\n+    use std::serialize::Encodable;\n+    use std::serialize::Encoder;\n+\n+    // just adding the ones I want to test, for now:\n+    #[deriving(Eq)]\n+    pub enum call {\n+        CallToEmitEnum(~str),\n+        CallToEmitEnumVariant(~str, uint, uint),\n+        CallToEmitEnumVariantArg(uint),\n+        CallToEmitUint(uint),\n+        CallToEmitNil,\n+        CallToEmitStruct(~str,uint),\n+        CallToEmitField(~str,uint),\n+        CallToEmitOption,\n+        CallToEmitOptionNone,\n+        CallToEmitOptionSome,\n+        // all of the ones I was too lazy to handle:\n+        CallToOther\n+    }\n+    // using `@mut` rather than changing the\n+    // type of self in every method of every encoder everywhere.\n+    pub struct TestEncoder {call_log : @mut ~[call]}\n+\n+    pub impl TestEncoder {\n+        // these self's should be &mut self's, as well....\n+        fn add_to_log (&self, c : call) {\n+            self.call_log.push(copy c);\n+        }\n+        fn add_unknown_to_log (&self) {\n+            self.add_to_log (CallToOther)\n+        }\n+    }\n+\n+    impl Encoder for TestEncoder {\n+        fn emit_nil(&mut self) { self.add_to_log(CallToEmitNil) }\n+\n+        fn emit_uint(&mut self, v: uint) {\n+            self.add_to_log(CallToEmitUint(v));\n+        }\n+        fn emit_u64(&mut self, _v: u64) { self.add_unknown_to_log(); }\n+        fn emit_u32(&mut self, _v: u32) { self.add_unknown_to_log(); }\n+        fn emit_u16(&mut self, _v: u16) { self.add_unknown_to_log(); }\n+        fn emit_u8(&mut self, _v: u8)   { self.add_unknown_to_log(); }\n+\n+        fn emit_int(&mut self, _v: int) { self.add_unknown_to_log(); }\n+        fn emit_i64(&mut self, _v: i64) { self.add_unknown_to_log(); }\n+        fn emit_i32(&mut self, _v: i32) { self.add_unknown_to_log(); }\n+        fn emit_i16(&mut self, _v: i16) { self.add_unknown_to_log(); }\n+        fn emit_i8(&mut self, _v: i8)   { self.add_unknown_to_log(); }\n+\n+        fn emit_bool(&mut self, _v: bool) { self.add_unknown_to_log(); }\n+\n+        fn emit_f64(&mut self, _v: f64) { self.add_unknown_to_log(); }\n+        fn emit_f32(&mut self, _v: f32) { self.add_unknown_to_log(); }\n+        fn emit_float(&mut self, _v: float) { self.add_unknown_to_log(); }\n+\n+        fn emit_char(&mut self, _v: char) { self.add_unknown_to_log(); }\n+        fn emit_str(&mut self, _v: &str) { self.add_unknown_to_log(); }\n+\n+        fn emit_enum(&mut self, name: &str, f: &fn(&mut TestEncoder)) {\n+            self.add_to_log(CallToEmitEnum(name.to_str()));\n+            f(self);\n+        }\n+\n+        fn emit_enum_variant(&mut self,\n+                             name: &str,\n+                             id: uint,\n+                             cnt: uint,\n+                             f: &fn(&mut TestEncoder)) {\n+            self.add_to_log(CallToEmitEnumVariant(name.to_str(), id, cnt));\n+            f(self);\n+        }\n+\n+        fn emit_enum_variant_arg(&mut self,\n+                                 idx: uint,\n+                                 f: &fn(&mut TestEncoder)) {\n+            self.add_to_log(CallToEmitEnumVariantArg(idx));\n+            f(self);\n+        }\n+\n+        fn emit_enum_struct_variant(&mut self,\n+                                    name: &str,\n+                                    id: uint,\n+                                    cnt: uint,\n+                                    f: &fn(&mut TestEncoder)) {\n+            self.emit_enum_variant(name, id, cnt, f)\n+        }\n+\n+        fn emit_enum_struct_variant_field(&mut self,\n+                                          _name: &str,\n+                                          idx: uint,\n+                                          f: &fn(&mut TestEncoder)) {\n+            self.emit_enum_variant_arg(idx, f)\n+        }\n+\n+        fn emit_struct(&mut self,\n+                       name: &str,\n+                       len: uint,\n+                       f: &fn(&mut TestEncoder)) {\n+            self.add_to_log(CallToEmitStruct (name.to_str(),len));\n+            f(self);\n+        }\n+        fn emit_struct_field(&mut self,\n+                             name: &str,\n+                             idx: uint,\n+                             f: &fn(&mut TestEncoder)) {\n+            self.add_to_log(CallToEmitField (name.to_str(),idx));\n+            f(self);\n+        }\n+\n+        fn emit_tuple(&mut self, _len: uint, f: &fn(&mut TestEncoder)) {\n+            self.add_unknown_to_log();\n+            f(self);\n+        }\n+        fn emit_tuple_arg(&mut self, _idx: uint, f: &fn(&mut TestEncoder)) {\n+            self.add_unknown_to_log();\n+            f(self);\n+        }\n+\n+        fn emit_tuple_struct(&mut self,\n+                             _name: &str,\n+                             _len: uint,\n+                             f: &fn(&mut TestEncoder)) {\n+            self.add_unknown_to_log();\n+            f(self);\n+        }\n+\n+        fn emit_tuple_struct_arg(&mut self,\n+                                 _idx: uint,\n+                                 f: &fn(&mut TestEncoder)) {\n+            self.add_unknown_to_log();\n+            f(self);\n+        }\n+\n+        fn emit_option(&mut self, f: &fn(&mut TestEncoder)) {\n+            self.add_to_log(CallToEmitOption);\n+            f(self);\n+        }\n+        fn emit_option_none(&mut self) {\n+            self.add_to_log(CallToEmitOptionNone);\n+        }\n+        fn emit_option_some(&mut self, f: &fn(&mut TestEncoder)) {\n+            self.add_to_log(CallToEmitOptionSome);\n+            f(self);\n+        }\n+\n+        fn emit_seq(&mut self, _len: uint, f: &fn(&mut TestEncoder)) {\n+            self.add_unknown_to_log();\n+            f(self);\n+        }\n+        fn emit_seq_elt(&mut self, _idx: uint, f: &fn(&mut TestEncoder)) {\n+            self.add_unknown_to_log();\n+            f(self);\n+        }\n+\n+        fn emit_map(&mut self, _len: uint, f: &fn(&mut TestEncoder)) {\n+            self.add_unknown_to_log();\n+            f(self);\n+        }\n+        fn emit_map_elt_key(&mut self, _idx: uint, f: &fn(&mut TestEncoder)) {\n+            self.add_unknown_to_log();\n+            f(self);\n+        }\n+        fn emit_map_elt_val(&mut self, _idx: uint, f: &fn(&mut TestEncoder)) {\n+            self.add_unknown_to_log();\n+            f(self);\n+        }\n+    }\n+\n+\n+    fn to_call_log<E:Encodable<TestEncoder>>(val: E) -> ~[call] {\n+        let mut te = TestEncoder {\n+            call_log: @mut ~[]\n+        };\n+        val.encode(&mut te);\n+        copy *te.call_log\n+    }\n+\n+    #[deriving(Encodable)]\n+    enum Written {\n+        Book(uint,uint),\n+        Magazine(~str)\n+    }\n+\n+    #[test]\n+    fn test_encode_enum() {\n+        assert_eq!(\n+            to_call_log(Book(34,44)),\n+            ~[\n+                CallToEmitEnum(~\"Written\"),\n+                CallToEmitEnumVariant(~\"Book\",0,2),\n+                CallToEmitEnumVariantArg(0),\n+                CallToEmitUint(34),\n+                CallToEmitEnumVariantArg(1),\n+                CallToEmitUint(44),\n+            ]\n+        );\n+    }\n+\n+    pub struct BPos(uint);\n+\n+    #[deriving(Encodable)]\n+    pub struct HasPos { pos : BPos }\n+\n+    #[test]\n+    fn test_encode_newtype() {\n+        assert_eq!(\n+            to_call_log(HasPos { pos:BPos(48) }),\n+            ~[\n+                CallToEmitStruct(~\"HasPos\",1),\n+                CallToEmitField(~\"pos\",0),\n+                CallToEmitUint(48),\n+            ]\n+        );\n+    }\n+\n+    #[test]\n+    fn test_encode_option() {\n+        let mut v = None;\n+\n+        assert_eq!(\n+            to_call_log(v),\n+            ~[\n+                CallToEmitOption,\n+                CallToEmitOptionNone,\n+            ]\n+        );\n+\n+        v = Some(54u);\n+        assert_eq!(\n+            to_call_log(v),\n+            ~[\n+                CallToEmitOption,\n+                CallToEmitOptionSome,\n+                CallToEmitUint(54)\n+            ]\n+        );\n+    }\n+}"}, {"sha": "99785d55761a37c84dae56d7641340fdd7b9b630", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8257528b6c51a1793401cc6028141b86f6432aa6/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8257528b6c51a1793401cc6028141b86f6432aa6/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=8257528b6c51a1793401cc6028141b86f6432aa6", "patch": "@@ -8,8 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/// The compiler code necessary to implement the #[deriving(Eq)] and\n-/// #[deriving(IterBytes)] extensions.\n+/*!\n+The compiler code necessary to implement the #[deriving] extensions.\n+\n+\n+FIXME (#2810)--Hygiene. Search for \"__\" strings (in other files too).\n+We also assume \"std\" is the standard library, and \"core\" is the core\n+library.\n+\n+*/\n \n use ast;\n use ast::{Ty, enum_def, expr, ident, item, Generics, meta_item, struct_def};\n@@ -203,8 +210,6 @@ pub fn create_derived_impl(cx: @ext_ctxt,\n      *\n      * where B1, B2, ... are the bounds given by `bounds_paths`.\n      *\n-     * FIXME(#5090): Remove code duplication between this and the\n-     * code in auto_encode.rs\n      */\n \n     // Copy the lifetimes"}, {"sha": "fb3622396c951310d64d8d460cee27a812738675", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8257528b6c51a1793401cc6028141b86f6432aa6/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8257528b6c51a1793401cc6028141b86f6432aa6/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=8257528b6c51a1793401cc6028141b86f6432aa6", "patch": "@@ -20,8 +20,7 @@ use core::prelude::*;\n use core::old_iter;\n use core::old_iter::BaseIter;\n \n-#[auto_encode]\n-#[auto_decode]\n+#[deriving(Encodable, Decodable)]\n pub enum OptVec<T> {\n     Empty,\n     Vec(~[T])"}, {"sha": "36f241b64279a61371ff1036c6415fa3ef68b0c8", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8257528b6c51a1793401cc6028141b86f6432aa6/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8257528b6c51a1793401cc6028141b86f6432aa6/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=8257528b6c51a1793401cc6028141b86f6432aa6", "patch": "@@ -18,9 +18,7 @@ use core::cmp::Equiv;\n use core::hashmap::HashSet;\n use core::to_bytes;\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Encodable, Decodable, Eq)]\n pub enum binop {\n     PLUS,\n     MINUS,\n@@ -34,9 +32,7 @@ pub enum binop {\n     SHR,\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Encodable, Decodable, Eq)]\n pub enum Token {\n     /* Expression-operator symbols. */\n     EQ,\n@@ -97,9 +93,7 @@ pub enum Token {\n     EOF,\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Encodable, Decodable, Eq)]\n /// For interpolation during macro expansion.\n pub enum nonterminal {\n     nt_item(@ast::item),"}, {"sha": "1f7cbfe98078288953fbfe7ebdd10e4b09892dd5", "filename": "src/test/compile-fail/deprecated-auto-code.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8257528b6c51a1793401cc6028141b86f6432aa6/src%2Ftest%2Fcompile-fail%2Fdeprecated-auto-code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8257528b6c51a1793401cc6028141b86f6432aa6/src%2Ftest%2Fcompile-fail%2Fdeprecated-auto-code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdeprecated-auto-code.rs?ref=8257528b6c51a1793401cc6028141b86f6432aa6", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[auto_encode] //~ ERROR: `#[auto_encode]` is deprecated\n+#[auto_decode] //~ ERROR: `#[auto_decode]` is deprecated\n+struct A;\n+\n+fn main() {}\n\\ No newline at end of file"}]}