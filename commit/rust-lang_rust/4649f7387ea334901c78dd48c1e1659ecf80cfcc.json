{"sha": "4649f7387ea334901c78dd48c1e1659ecf80cfcc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2NDlmNzM4N2VhMzM0OTAxYzc4ZGQ0OGMxZTE2NTllY2Y4MGNmY2M=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-10-03T23:19:40Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-02-25T15:07:59Z"}, "message": "rustc_typeck: lift CrateCtxt to TyCtxt.", "tree": {"sha": "99261bc24e0a8ba2128f654f9caf352883fb6e24", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99261bc24e0a8ba2128f654f9caf352883fb6e24"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4649f7387ea334901c78dd48c1e1659ecf80cfcc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4649f7387ea334901c78dd48c1e1659ecf80cfcc", "html_url": "https://github.com/rust-lang/rust/commit/4649f7387ea334901c78dd48c1e1659ecf80cfcc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4649f7387ea334901c78dd48c1e1659ecf80cfcc/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "374ea14412fbb35ca344b7d7cbe67405d63e0e42", "url": "https://api.github.com/repos/rust-lang/rust/commits/374ea14412fbb35ca344b7d7cbe67405d63e0e42", "html_url": "https://github.com/rust-lang/rust/commit/374ea14412fbb35ca344b7d7cbe67405d63e0e42"}], "stats": {"total": 1408, "additions": 651, "deletions": 757}, "files": [{"sha": "38af6c3d0da545e25bc0b4375154e1a8b5db22c6", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=4649f7387ea334901c78dd48c1e1659ecf80cfcc", "patch": "@@ -525,6 +525,20 @@ pub struct GlobalCtxt<'tcx> {\n     stability_interner: RefCell<FxHashSet<&'tcx attr::Stability>>,\n \n     layout_interner: RefCell<FxHashSet<&'tcx Layout>>,\n+\n+    /// A vector of every trait accessible in the whole crate\n+    /// (i.e. including those from subcrates). This is used only for\n+    /// error reporting, and so is lazily initialised and generally\n+    /// shouldn't taint the common path (hence the RefCell).\n+    pub all_traits: RefCell<Option<Vec<DefId>>>,\n+\n+    /// Obligations which will have to be checked at the end of\n+    /// type-checking, after all functions have been inferred.\n+    /// The key is the NodeId of the item the obligations were from.\n+    pub deferred_obligations: RefCell<NodeMap<Vec<traits::DeferredObligation<'tcx>>>>,\n+\n+    /// HIR Ty -> Ty lowering cache.\n+    pub ast_ty_to_ty_cache: RefCell<NodeMap<Ty<'tcx>>>,\n }\n \n impl<'tcx> GlobalCtxt<'tcx> {\n@@ -720,6 +734,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             layout_depth: Cell::new(0),\n             derive_macros: RefCell::new(NodeMap()),\n             stability_interner: RefCell::new(FxHashSet()),\n+            all_traits: RefCell::new(None),\n+            deferred_obligations: RefCell::new(NodeMap()),\n+            ast_ty_to_ty_cache: RefCell::new(NodeMap()),\n        }, f)\n     }\n }"}, {"sha": "aeb7a207c447e07b22da587a18eedb1a92a88a77", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=4649f7387ea334901c78dd48c1e1659ecf80cfcc", "patch": "@@ -37,6 +37,7 @@ macro_rules! define_maps {\n        pub $name:ident: $node:ident($K:ty) -> $V:ty),*) => {\n         pub struct Maps<$tcx> {\n             providers: IndexVec<CrateNum, Providers<$tcx>>,\n+            pub query_stack: RefCell<Vec<Query>>,\n             $($(#[$attr])* pub $name: RefCell<DepTrackingMap<queries::$name<$tcx>>>),*\n         }\n \n@@ -46,11 +47,18 @@ macro_rules! define_maps {\n                        -> Self {\n                 Maps {\n                     providers,\n+                    query_stack: RefCell::new(vec![]),\n                     $($name: RefCell::new(DepTrackingMap::new(dep_graph.clone()))),*\n                 }\n             }\n         }\n \n+        #[allow(bad_style)]\n+        #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+        pub enum Query {\n+            $($(#[$attr])* $name($K)),*\n+        }\n+\n         pub mod queries {\n             use std::marker::PhantomData;\n \n@@ -119,6 +127,11 @@ define_maps! { <'tcx>\n     /// additional acyclicity requirements).\n     pub super_predicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx>,\n \n+    /// To avoid cycles within the predicates of a single item we compute\n+    /// per-type-parameter predicates for resolving `T::AssocTy`.\n+    pub type_param_predicates: ItemSignature(DefId)\n+        -> ty::GenericPredicates<'tcx>,\n+\n     pub trait_def: ItemSignature(DefId) -> &'tcx ty::TraitDef,\n     pub adt_def: ItemSignature(DefId) -> &'tcx ty::AdtDef,\n     pub adt_sized_constraint: SizedConstraint(DefId) -> Ty<'tcx>,"}, {"sha": "97476489a8adb8b36a58a586bd0f3ec864c8a97e", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=4649f7387ea334901c78dd48c1e1659ecf80cfcc", "patch": "@@ -31,7 +31,7 @@ use ty::subst::{Subst, Substs};\n use ty::util::IntTypeExt;\n use ty::walk::TypeWalker;\n use util::common::MemoizationMap;\n-use util::nodemap::{NodeSet, NodeMap, FxHashMap};\n+use util::nodemap::{NodeSet, FxHashMap};\n \n use serialize::{self, Encodable, Encoder};\n use std::borrow::Cow;\n@@ -104,13 +104,12 @@ mod sty;\n /// The complete set of all analyses described in this module. This is\n /// produced by the driver and fed to trans and later passes.\n #[derive(Clone)]\n-pub struct CrateAnalysis<'tcx> {\n+pub struct CrateAnalysis {\n     pub export_map: ExportMap,\n     pub access_levels: middle::privacy::AccessLevels,\n     pub reachable: NodeSet,\n     pub name: String,\n     pub glob_map: Option<hir::GlobMap>,\n-    pub hir_ty_to_ty: NodeMap<Ty<'tcx>>,\n }\n \n #[derive(Clone)]\n@@ -1383,7 +1382,7 @@ pub struct ReprOptions {\n }\n \n impl ReprOptions {\n-    pub fn new<'a, 'gcx, 'tcx>(tcx: &TyCtxt<'a, 'gcx, 'tcx>, did: DefId) -> ReprOptions {\n+    pub fn new(tcx: TyCtxt, did: DefId) -> ReprOptions {\n         let mut ret = ReprOptions::default();\n         let attrs = tcx.lookup_repr_hints(did);\n         for r in attrs.iter() {\n@@ -1400,7 +1399,7 @@ impl ReprOptions {\n }\n \n impl<'a, 'gcx, 'tcx> AdtDef {\n-    fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    fn new(tcx: TyCtxt,\n            did: DefId,\n            kind: AdtKind,\n            variants: Vec<VariantDef>,"}, {"sha": "b80402a15f67d0e2bcd8c5f010bb1073c4b643ed", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=4649f7387ea334901c78dd48c1e1659ecf80cfcc", "patch": "@@ -21,7 +21,7 @@ use rustc::middle::{self, dependency_format, stability, reachable};\n use rustc::middle::privacy::AccessLevels;\n use rustc::ty::{self, TyCtxt, Resolutions, GlobalArenas};\n use rustc::util::common::time;\n-use rustc::util::nodemap::{NodeSet, NodeMap};\n+use rustc::util::nodemap::NodeSet;\n use rustc::util::fs::rename_or_copy_remove;\n use rustc_borrowck as borrowck;\n use rustc_incremental::{self, IncrementalHashesMap};\n@@ -343,7 +343,7 @@ pub struct CompileState<'a, 'tcx: 'a> {\n     pub hir_crate: Option<&'a hir::Crate>,\n     pub hir_map: Option<&'a hir_map::Map<'tcx>>,\n     pub resolutions: Option<&'a Resolutions>,\n-    pub analysis: Option<&'a ty::CrateAnalysis<'tcx>>,\n+    pub analysis: Option<&'a ty::CrateAnalysis>,\n     pub tcx: Option<TyCtxt<'a, 'tcx, 'tcx>>,\n     pub trans: Option<&'a trans::CrateTranslation>,\n }\n@@ -417,7 +417,7 @@ impl<'a, 'tcx> CompileState<'a, 'tcx> {\n                                 arenas: &'tcx GlobalArenas<'tcx>,\n                                 cstore: &'a CStore,\n                                 hir_map: &'a hir_map::Map<'tcx>,\n-                                analysis: &'a ty::CrateAnalysis<'static>,\n+                                analysis: &'a ty::CrateAnalysis,\n                                 resolutions: &'a Resolutions,\n                                 krate: &'a ast::Crate,\n                                 hir_crate: &'a hir::Crate,\n@@ -444,7 +444,7 @@ impl<'a, 'tcx> CompileState<'a, 'tcx> {\n                             out_file: &'a Option<PathBuf>,\n                             krate: Option<&'a ast::Crate>,\n                             hir_crate: &'a hir::Crate,\n-                            analysis: &'a ty::CrateAnalysis<'tcx>,\n+                            analysis: &'a ty::CrateAnalysis,\n                             tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             crate_name: &'a str)\n                             -> Self {\n@@ -534,7 +534,7 @@ fn count_nodes(krate: &ast::Crate) -> usize {\n pub struct ExpansionResult {\n     pub expanded_crate: ast::Crate,\n     pub defs: hir_map::Definitions,\n-    pub analysis: ty::CrateAnalysis<'static>,\n+    pub analysis: ty::CrateAnalysis,\n     pub resolutions: Resolutions,\n     pub hir_forest: hir_map::Forest,\n }\n@@ -797,7 +797,6 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n             reachable: NodeSet(),\n             name: crate_name.to_string(),\n             glob_map: if resolver.make_glob_map { Some(resolver.glob_map) } else { None },\n-            hir_ty_to_ty: NodeMap(),\n         },\n         resolutions: Resolutions {\n             freevars: resolver.freevars,\n@@ -813,15 +812,15 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n /// structures carrying the results of the analysis.\n pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                                                hir_map: hir_map::Map<'tcx>,\n-                                               mut analysis: ty::CrateAnalysis<'tcx>,\n+                                               mut analysis: ty::CrateAnalysis,\n                                                resolutions: Resolutions,\n                                                arena: &'tcx DroplessArena,\n                                                arenas: &'tcx GlobalArenas<'tcx>,\n                                                name: &str,\n                                                f: F)\n                                                -> Result<R, usize>\n     where F: for<'a> FnOnce(TyCtxt<'a, 'tcx, 'tcx>,\n-                            ty::CrateAnalysis<'tcx>,\n+                            ty::CrateAnalysis,\n                             IncrementalHashesMap,\n                             CompileResult) -> R\n {\n@@ -908,8 +907,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n              || stability::check_unstable_api_usage(tcx));\n \n         // passes are timed inside typeck\n-        analysis.hir_ty_to_ty =\n-            try_with_f!(typeck::check_crate(tcx), (tcx, analysis, incremental_hashes_map));\n+        try_with_f!(typeck::check_crate(tcx), (tcx, analysis, incremental_hashes_map));\n \n         time(time_passes,\n              \"const checking\","}, {"sha": "064c4982ef00eb87adcbd828b18ac8701898e3e0", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=4649f7387ea334901c78dd48c1e1659ecf80cfcc", "patch": "@@ -201,7 +201,7 @@ impl PpSourceMode {\n     fn call_with_pp_support_hir<'tcx, A, B, F>(&self,\n                                                sess: &'tcx Session,\n                                                hir_map: &hir_map::Map<'tcx>,\n-                                               analysis: &ty::CrateAnalysis<'tcx>,\n+                                               analysis: &ty::CrateAnalysis,\n                                                resolutions: &Resolutions,\n                                                arena: &'tcx DroplessArena,\n                                                arenas: &'tcx GlobalArenas<'tcx>,\n@@ -838,7 +838,7 @@ pub fn print_after_parsing(sess: &Session,\n \n pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n                                                 hir_map: &hir_map::Map<'tcx>,\n-                                                analysis: &ty::CrateAnalysis<'tcx>,\n+                                                analysis: &ty::CrateAnalysis,\n                                                 resolutions: &Resolutions,\n                                                 input: &Input,\n                                                 krate: &ast::Crate,\n@@ -958,7 +958,7 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n // Instead, we call that function ourselves.\n fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n                                        hir_map: &hir_map::Map<'tcx>,\n-                                       analysis: &ty::CrateAnalysis<'tcx>,\n+                                       analysis: &ty::CrateAnalysis,\n                                        resolutions: &Resolutions,\n                                        crate_name: &str,\n                                        arena: &'tcx DroplessArena,"}, {"sha": "b1e435dcc751c40b1bdff58ed027eb1f212f1a84", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=4649f7387ea334901c78dd48c1e1659ecf80cfcc", "patch": "@@ -85,7 +85,7 @@ pub mod recorder {\n pub struct SaveContext<'l, 'tcx: 'l> {\n     tcx: TyCtxt<'l, 'tcx, 'tcx>,\n     tables: &'l ty::TypeckTables<'tcx>,\n-    analysis: &'l ty::CrateAnalysis<'tcx>,\n+    analysis: &'l ty::CrateAnalysis,\n     span_utils: SpanUtils<'tcx>,\n }\n \n@@ -550,7 +550,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 match *qpath {\n                     hir::QPath::Resolved(_, ref path) => path.def,\n                     hir::QPath::TypeRelative(..) => {\n-                        if let Some(ty) = self.analysis.hir_ty_to_ty.get(&id) {\n+                        if let Some(ty) = self.tcx.ast_ty_to_ty_cache.borrow().get(&id) {\n                             if let ty::TyProjection(proj) = ty.sty {\n                                 for item in self.tcx.associated_items(proj.trait_ref.def_id) {\n                                     if item.kind == ty::AssociatedKind::Type {\n@@ -854,7 +854,7 @@ impl Format {\n \n pub fn process_crate<'l, 'tcx>(tcx: TyCtxt<'l, 'tcx, 'tcx>,\n                                krate: &ast::Crate,\n-                               analysis: &'l ty::CrateAnalysis<'tcx>,\n+                               analysis: &'l ty::CrateAnalysis,\n                                cratename: &str,\n                                odir: Option<&Path>,\n                                format: Format) {"}, {"sha": "cf93ef21f5d4a0dec70dc01693c2ff41b8de4011", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=4649f7387ea334901c78dd48c1e1659ecf80cfcc", "patch": "@@ -897,7 +897,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 // FIXME: Self type is not always computed when we are here because type parameter\n                 // bounds may affect Self type and have to be converted before it.\n                 let trait_ref = if impl_def_id.is_local() {\n-                    tcx.impl_trait_refs.borrow().get(&impl_def_id).cloned().and_then(|x| x)\n+                    tcx.maps.impl_trait_ref.borrow().get(&impl_def_id)\n+                       .cloned().and_then(|x| x)\n                 } else {\n                     tcx.impl_trait_ref(impl_def_id)\n                 };"}, {"sha": "8f1135adbb4548bfac1f1ba6a2b77d9f23fbc1b1", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=4649f7387ea334901c78dd48c1e1659ecf80cfcc", "patch": "@@ -10,11 +10,10 @@\n \n use super::{DeferredCallResolution, Expectation, FnCtxt, TupleArgumentsFlag};\n \n-use CrateCtxt;\n use hir::def::Def;\n use hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::{infer, traits};\n-use rustc::ty::{self, LvaluePreference, Ty};\n+use rustc::ty::{self, TyCtxt, LvaluePreference, Ty};\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n@@ -23,12 +22,9 @@ use rustc::hir;\n /// Check that it is legal to call methods of the trait corresponding\n /// to `trait_id` (this only cares about the trait, not the specific\n /// method that is called)\n-pub fn check_legal_trait_for_method_call(ccx: &CrateCtxt, span: Span, trait_id: DefId) {\n-    if ccx.tcx.lang_items.drop_trait() == Some(trait_id) {\n-        struct_span_err!(ccx.tcx.sess,\n-                         span,\n-                         E0040,\n-                         \"explicit use of destructor method\")\n+pub fn check_legal_trait_for_method_call(tcx: TyCtxt, span: Span, trait_id: DefId) {\n+    if tcx.lang_items.drop_trait() == Some(trait_id) {\n+        struct_span_err!(tcx.sess, span, E0040, \"explicit use of destructor method\")\n             .span_label(span, &format!(\"explicit destructor calls not allowed\"))\n             .emit();\n     }"}, {"sha": "2d4749331c08ad36a64703539426a68b4ab93862", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 15, "deletions": 22, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=4649f7387ea334901c78dd48c1e1659ecf80cfcc", "patch": "@@ -11,7 +11,7 @@\n use rustc::hir::{self, ImplItemKind, TraitItemKind};\n use rustc::infer::{self, InferOk};\n use rustc::middle::free_region::FreeRegionMap;\n-use rustc::ty;\n+use rustc::ty::{self, TyCtxt};\n use rustc::traits::{self, ObligationCause, ObligationCauseCode, Reveal};\n use rustc::ty::error::{ExpectedFound, TypeError};\n use rustc::ty::subst::{Subst, Substs};\n@@ -20,7 +20,6 @@ use rustc::util::common::ErrorReported;\n use syntax::ast;\n use syntax_pos::Span;\n \n-use CrateCtxt;\n use super::assoc;\n use super::{Inherited, FnCtxt};\n use astconv::ExplicitSelf;\n@@ -36,7 +35,7 @@ use astconv::ExplicitSelf;\n /// - trait_m: the method in the trait\n /// - impl_trait_ref: the TraitRef corresponding to the trait implementation\n \n-pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+pub fn compare_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      impl_m: &ty::AssociatedItem,\n                                      impl_m_span: Span,\n                                      impl_m_body_id: ast::NodeId,\n@@ -47,31 +46,31 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     debug!(\"compare_impl_method(impl_trait_ref={:?})\",\n            impl_trait_ref);\n \n-    if let Err(ErrorReported) = compare_self_type(ccx,\n+    if let Err(ErrorReported) = compare_self_type(tcx,\n                                                   impl_m,\n                                                   impl_m_span,\n                                                   trait_m,\n                                                   impl_trait_ref) {\n         return;\n     }\n \n-    if let Err(ErrorReported) = compare_number_of_generics(ccx,\n+    if let Err(ErrorReported) = compare_number_of_generics(tcx,\n                                                            impl_m,\n                                                            impl_m_span,\n                                                            trait_m,\n                                                            trait_item_span) {\n         return;\n     }\n \n-    if let Err(ErrorReported) = compare_number_of_method_arguments(ccx,\n+    if let Err(ErrorReported) = compare_number_of_method_arguments(tcx,\n                                                                    impl_m,\n                                                                    impl_m_span,\n                                                                    trait_m,\n                                                                    trait_item_span) {\n         return;\n     }\n \n-    if let Err(ErrorReported) = compare_predicate_entailment(ccx,\n+    if let Err(ErrorReported) = compare_predicate_entailment(tcx,\n                                                              impl_m,\n                                                              impl_m_span,\n                                                              impl_m_body_id,\n@@ -82,16 +81,14 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                           impl_m: &ty::AssociatedItem,\n                                           impl_m_span: Span,\n                                           impl_m_body_id: ast::NodeId,\n                                           trait_m: &ty::AssociatedItem,\n                                           impl_trait_ref: ty::TraitRef<'tcx>,\n                                           old_broken_mode: bool)\n                                           -> Result<(), ErrorReported> {\n-    let tcx = ccx.tcx;\n-\n     let trait_to_impl_substs = impl_trait_ref.substs;\n \n     let cause = ObligationCause {\n@@ -190,7 +187,7 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let trait_m_predicates = tcx.item_predicates(trait_m.def_id);\n \n     // Check region bounds.\n-    check_region_bounds_on_impl_method(ccx,\n+    check_region_bounds_on_impl_method(tcx,\n                                        impl_m_span,\n                                        impl_m,\n                                        &trait_m_generics,\n@@ -228,7 +225,7 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                                normalize_cause.clone());\n \n     tcx.infer_ctxt(trait_param_env, Reveal::NotSpecializable).enter(|infcx| {\n-        let inh = Inherited::new(ccx, infcx);\n+        let inh = Inherited::new(infcx);\n         let infcx = &inh.infcx;\n         let fulfillment_cx = &inh.fulfillment_cx;\n \n@@ -383,7 +380,7 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     })\n }\n \n-fn check_region_bounds_on_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn check_region_bounds_on_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                 span: Span,\n                                                 impl_m: &ty::AssociatedItem,\n                                                 trait_generics: &ty::Generics,\n@@ -414,7 +411,7 @@ fn check_region_bounds_on_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // are zero. Since I don't quite know how to phrase things at\n     // the moment, give a kind of vague error message.\n     if trait_params.len() != impl_params.len() {\n-        struct_span_err!(ccx.tcx.sess,\n+        struct_span_err!(tcx.sess,\n                          span,\n                          E0195,\n                          \"lifetime parameters or bounds on method `{}` do not match the \\\n@@ -510,14 +507,13 @@ fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a\n     }\n }\n \n-fn compare_self_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn compare_self_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                impl_m: &ty::AssociatedItem,\n                                impl_m_span: Span,\n                                trait_m: &ty::AssociatedItem,\n                                impl_trait_ref: ty::TraitRef<'tcx>)\n                                -> Result<(), ErrorReported>\n {\n-    let tcx = ccx.tcx;\n     // Try to give more informative error messages about self typing\n     // mismatches.  Note that any mismatch will also be detected\n     // below, where we construct a canonical function type that\n@@ -583,13 +579,12 @@ fn compare_self_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     Ok(())\n }\n \n-fn compare_number_of_generics<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn compare_number_of_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         impl_m: &ty::AssociatedItem,\n                                         impl_m_span: Span,\n                                         trait_m: &ty::AssociatedItem,\n                                         trait_item_span: Option<Span>)\n                                         -> Result<(), ErrorReported> {\n-    let tcx = ccx.tcx;\n     let impl_m_generics = tcx.item_generics(impl_m.def_id);\n     let trait_m_generics = tcx.item_generics(trait_m.def_id);\n     let num_impl_m_type_params = impl_m_generics.types.len();\n@@ -653,13 +648,12 @@ fn compare_number_of_generics<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     Ok(())\n }\n \n-fn compare_number_of_method_arguments<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn compare_number_of_method_arguments<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                 impl_m: &ty::AssociatedItem,\n                                                 impl_m_span: Span,\n                                                 trait_m: &ty::AssociatedItem,\n                                                 trait_item_span: Option<Span>)\n                                                 -> Result<(), ErrorReported> {\n-    let tcx = ccx.tcx;\n     let m_fty = |method: &ty::AssociatedItem| {\n         match tcx.item_type(method.def_id).sty {\n             ty::TyFnDef(_, _, f) => f,\n@@ -739,14 +733,13 @@ fn compare_number_of_method_arguments<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     Ok(())\n }\n \n-pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                     impl_c: &ty::AssociatedItem,\n                                     impl_c_span: Span,\n                                     trait_c: &ty::AssociatedItem,\n                                     impl_trait_ref: ty::TraitRef<'tcx>) {\n     debug!(\"compare_const_impl(impl_trait_ref={:?})\", impl_trait_ref);\n \n-    let tcx = ccx.tcx;\n     tcx.infer_ctxt((), Reveal::NotSpecializable).enter(|infcx| {\n         let mut fulfillment_cx = traits::FulfillmentContext::new();\n "}, {"sha": "385ea7d52e1cef51ab839b3e6ff855368e507795", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=4649f7387ea334901c78dd48c1e1659ecf80cfcc", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use CrateCtxt;\n use check::regionck::RegionCtxt;\n \n use hir::def_id::DefId;\n@@ -40,17 +39,18 @@ use syntax_pos::Span;\n ///    struct/enum definition for the nominal type itself (i.e.\n ///    cannot do `struct S<T>; impl<T:Clone> Drop for S<T> { ... }`).\n ///\n-pub fn check_drop_impl(ccx: &CrateCtxt, drop_impl_did: DefId) -> Result<(), ()> {\n-    let dtor_self_type = ccx.tcx.item_type(drop_impl_did);\n-    let dtor_predicates = ccx.tcx.item_predicates(drop_impl_did);\n+pub fn check_drop_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                 drop_impl_did: DefId) -> Result<(), ()> {\n+    let dtor_self_type = tcx.item_type(drop_impl_did);\n+    let dtor_predicates = tcx.item_predicates(drop_impl_did);\n     match dtor_self_type.sty {\n         ty::TyAdt(adt_def, self_to_impl_substs) => {\n-            ensure_drop_params_and_item_params_correspond(ccx,\n+            ensure_drop_params_and_item_params_correspond(tcx,\n                                                           drop_impl_did,\n                                                           dtor_self_type,\n                                                           adt_def.did)?;\n \n-            ensure_drop_predicates_are_implied_by_item_defn(ccx,\n+            ensure_drop_predicates_are_implied_by_item_defn(tcx,\n                                                             drop_impl_did,\n                                                             &dtor_predicates,\n                                                             adt_def.did,\n@@ -59,7 +59,7 @@ pub fn check_drop_impl(ccx: &CrateCtxt, drop_impl_did: DefId) -> Result<(), ()>\n         _ => {\n             // Destructors only work on nominal types.  This was\n             // already checked by coherence, so we can panic here.\n-            let span = ccx.tcx.def_span(drop_impl_did);\n+            let span = tcx.def_span(drop_impl_did);\n             span_bug!(span,\n                       \"should have been rejected by coherence check: {}\",\n                       dtor_self_type);\n@@ -68,13 +68,12 @@ pub fn check_drop_impl(ccx: &CrateCtxt, drop_impl_did: DefId) -> Result<(), ()>\n }\n \n fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n-    ccx: &CrateCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     drop_impl_did: DefId,\n     drop_impl_ty: Ty<'tcx>,\n     self_type_did: DefId)\n     -> Result<(), ()>\n {\n-    let tcx = ccx.tcx;\n     let drop_impl_node_id = tcx.hir.as_local_node_id(drop_impl_did).unwrap();\n     let self_type_node_id = tcx.hir.as_local_node_id(self_type_did).unwrap();\n \n@@ -126,7 +125,7 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n /// Confirms that every predicate imposed by dtor_predicates is\n /// implied by assuming the predicates attached to self_type_did.\n fn ensure_drop_predicates_are_implied_by_item_defn<'a, 'tcx>(\n-    ccx: &CrateCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     drop_impl_did: DefId,\n     dtor_predicates: &ty::GenericPredicates<'tcx>,\n     self_type_did: DefId,\n@@ -169,8 +168,6 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'a, 'tcx>(\n     // absent. So we report an error that the Drop impl injected a\n     // predicate that is not present on the struct definition.\n \n-    let tcx = ccx.tcx;\n-\n     let self_type_node_id = tcx.hir.as_local_node_id(self_type_did).unwrap();\n \n     let drop_impl_span = tcx.def_span(drop_impl_did);"}, {"sha": "4d4e312dab37c1b3e35dc45653ca4aa0b67c914c", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 62, "deletions": 68, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=4649f7387ea334901c78dd48c1e1659ecf80cfcc", "patch": "@@ -14,9 +14,9 @@\n use intrinsics;\n use rustc::traits::{ObligationCause, ObligationCauseCode};\n use rustc::ty::subst::Substs;\n-use rustc::ty::{self, Ty};\n+use rustc::ty::{self, TyCtxt, Ty};\n use rustc::util::nodemap::FxHashMap;\n-use {CrateCtxt, require_same_types};\n+use require_same_types;\n \n use syntax::abi::Abi;\n use syntax::ast;\n@@ -27,13 +27,12 @@ use rustc::hir;\n \n use std::iter;\n \n-fn equate_intrinsic_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn equate_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                    it: &hir::ForeignItem,\n                                    n_tps: usize,\n                                    abi: Abi,\n                                    inputs: Vec<Ty<'tcx>>,\n                                    output: Ty<'tcx>) {\n-    let tcx = ccx.tcx;\n     let def_id = tcx.hir.local_def_id(it.id);\n \n     let substs = Substs::for_item(tcx, def_id,\n@@ -59,7 +58,7 @@ fn equate_intrinsic_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             .span_label(span, &format!(\"expected {} type parameter\", n_tps))\n             .emit();\n     } else {\n-        require_same_types(ccx,\n+        require_same_types(tcx,\n                            &ObligationCause::new(it.span,\n                                                  it.id,\n                                                  ObligationCauseCode::IntrinsicType),\n@@ -70,33 +69,29 @@ fn equate_intrinsic_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n /// Remember to add all intrinsics here, in librustc_trans/trans/intrinsic.rs,\n /// and in libcore/intrinsics.rs\n-pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n-    fn param<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, n: u32) -> Ty<'tcx> {\n-        let name = Symbol::intern(&format!(\"P{}\", n));\n-        ccx.tcx.mk_param(n, name)\n-    }\n-\n-    let tcx = ccx.tcx;\n+pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                      it: &hir::ForeignItem) {\n+    let param = |n| tcx.mk_param(n, Symbol::intern(&format!(\"P{}\", n)));\n     let name = it.name.as_str();\n     let (n_tps, inputs, output) = if name.starts_with(\"atomic_\") {\n         let split : Vec<&str> = name.split('_').collect();\n         assert!(split.len() >= 2, \"Atomic intrinsic not correct format\");\n \n         //We only care about the operation here\n         let (n_tps, inputs, output) = match split[1] {\n-            \"cxchg\" | \"cxchgweak\" => (1, vec![tcx.mk_mut_ptr(param(ccx, 0)),\n-                                              param(ccx, 0),\n-                                              param(ccx, 0)],\n-                                      tcx.intern_tup(&[param(ccx, 0), tcx.types.bool], false)),\n-            \"load\" => (1, vec![tcx.mk_imm_ptr(param(ccx, 0))],\n-                       param(ccx, 0)),\n-            \"store\" => (1, vec![tcx.mk_mut_ptr(param(ccx, 0)), param(ccx, 0)],\n+            \"cxchg\" | \"cxchgweak\" => (1, vec![tcx.mk_mut_ptr(param(0)),\n+                                              param(0),\n+                                              param(0)],\n+                                      tcx.intern_tup(&[param(0), tcx.types.bool], false)),\n+            \"load\" => (1, vec![tcx.mk_imm_ptr(param(0))],\n+                       param(0)),\n+            \"store\" => (1, vec![tcx.mk_mut_ptr(param(0)), param(0)],\n                         tcx.mk_nil()),\n \n             \"xchg\" | \"xadd\" | \"xsub\" | \"and\"  | \"nand\" | \"or\" | \"xor\" | \"max\" |\n             \"min\"  | \"umax\" | \"umin\" => {\n-                (1, vec![tcx.mk_mut_ptr(param(ccx, 0)), param(ccx, 0)],\n-                 param(ccx, 0))\n+                (1, vec![tcx.mk_mut_ptr(param(0)), param(0)],\n+                 param(0))\n             }\n             \"fence\" | \"singlethreadfence\" => {\n                 (0, Vec::new(), tcx.mk_nil())\n@@ -116,57 +111,57 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n         let (n_tps, inputs, output) = match &name[..] {\n             \"breakpoint\" => (0, Vec::new(), tcx.mk_nil()),\n             \"size_of\" |\n-            \"pref_align_of\" | \"min_align_of\" => (1, Vec::new(), ccx.tcx.types.usize),\n+            \"pref_align_of\" | \"min_align_of\" => (1, Vec::new(), tcx.types.usize),\n             \"size_of_val\" |  \"min_align_of_val\" => {\n                 (1, vec![\n                     tcx.mk_imm_ref(tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1),\n                                                                   ty::BrAnon(0))),\n-                                    param(ccx, 0))\n-                 ], ccx.tcx.types.usize)\n+                                    param(0))\n+                 ], tcx.types.usize)\n             }\n-            \"rustc_peek\" => (1, vec![param(ccx, 0)], param(ccx, 0)),\n-            \"init\" => (1, Vec::new(), param(ccx, 0)),\n-            \"uninit\" => (1, Vec::new(), param(ccx, 0)),\n-            \"forget\" => (1, vec![ param(ccx, 0) ], tcx.mk_nil()),\n-            \"transmute\" => (2, vec![ param(ccx, 0) ], param(ccx, 1)),\n+            \"rustc_peek\" => (1, vec![param(0)], param(0)),\n+            \"init\" => (1, Vec::new(), param(0)),\n+            \"uninit\" => (1, Vec::new(), param(0)),\n+            \"forget\" => (1, vec![ param(0) ], tcx.mk_nil()),\n+            \"transmute\" => (2, vec![ param(0) ], param(1)),\n             \"move_val_init\" => {\n                 (1,\n                  vec![\n-                    tcx.mk_mut_ptr(param(ccx, 0)),\n-                    param(ccx, 0)\n+                    tcx.mk_mut_ptr(param(0)),\n+                    param(0)\n                   ],\n                tcx.mk_nil())\n             }\n             \"drop_in_place\" => {\n-                (1, vec![tcx.mk_mut_ptr(param(ccx, 0))], tcx.mk_nil())\n+                (1, vec![tcx.mk_mut_ptr(param(0))], tcx.mk_nil())\n             }\n-            \"needs_drop\" => (1, Vec::new(), ccx.tcx.types.bool),\n+            \"needs_drop\" => (1, Vec::new(), tcx.types.bool),\n \n             \"type_name\" => (1, Vec::new(), tcx.mk_static_str()),\n-            \"type_id\" => (1, Vec::new(), ccx.tcx.types.u64),\n+            \"type_id\" => (1, Vec::new(), tcx.types.u64),\n             \"offset\" | \"arith_offset\" => {\n               (1,\n                vec![\n                   tcx.mk_ptr(ty::TypeAndMut {\n-                      ty: param(ccx, 0),\n+                      ty: param(0),\n                       mutbl: hir::MutImmutable\n                   }),\n-                  ccx.tcx.types.isize\n+                  tcx.types.isize\n                ],\n                tcx.mk_ptr(ty::TypeAndMut {\n-                   ty: param(ccx, 0),\n+                   ty: param(0),\n                    mutbl: hir::MutImmutable\n                }))\n             }\n             \"copy\" | \"copy_nonoverlapping\" => {\n               (1,\n                vec![\n                   tcx.mk_ptr(ty::TypeAndMut {\n-                      ty: param(ccx, 0),\n+                      ty: param(0),\n                       mutbl: hir::MutImmutable\n                   }),\n                   tcx.mk_ptr(ty::TypeAndMut {\n-                      ty: param(ccx, 0),\n+                      ty: param(0),\n                       mutbl: hir::MutMutable\n                   }),\n                   tcx.types.usize,\n@@ -177,11 +172,11 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n               (1,\n                vec![\n                   tcx.mk_ptr(ty::TypeAndMut {\n-                      ty: param(ccx, 0),\n+                      ty: param(0),\n                       mutbl: hir::MutMutable\n                   }),\n                   tcx.mk_ptr(ty::TypeAndMut {\n-                      ty: param(ccx, 0),\n+                      ty: param(0),\n                       mutbl: hir::MutImmutable\n                   }),\n                   tcx.types.usize,\n@@ -192,7 +187,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n               (1,\n                vec![\n                   tcx.mk_ptr(ty::TypeAndMut {\n-                      ty: param(ccx, 0),\n+                      ty: param(0),\n                       mutbl: hir::MutMutable\n                   }),\n                   tcx.types.u8,\n@@ -264,23 +259,23 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n             \"roundf64\"     => (0, vec![ tcx.types.f64 ], tcx.types.f64),\n \n             \"volatile_load\" =>\n-                (1, vec![ tcx.mk_imm_ptr(param(ccx, 0)) ], param(ccx, 0)),\n+                (1, vec![ tcx.mk_imm_ptr(param(0)) ], param(0)),\n             \"volatile_store\" =>\n-                (1, vec![ tcx.mk_mut_ptr(param(ccx, 0)), param(ccx, 0) ], tcx.mk_nil()),\n+                (1, vec![ tcx.mk_mut_ptr(param(0)), param(0) ], tcx.mk_nil()),\n \n-            \"ctpop\" | \"ctlz\" | \"cttz\" | \"bswap\" => (1, vec![param(ccx, 0)], param(ccx, 0)),\n+            \"ctpop\" | \"ctlz\" | \"cttz\" | \"bswap\" => (1, vec![param(0)], param(0)),\n \n             \"add_with_overflow\" | \"sub_with_overflow\"  | \"mul_with_overflow\" =>\n-                (1, vec![param(ccx, 0), param(ccx, 0)],\n-                tcx.intern_tup(&[param(ccx, 0), tcx.types.bool], false)),\n+                (1, vec![param(0), param(0)],\n+                tcx.intern_tup(&[param(0), tcx.types.bool], false)),\n \n             \"unchecked_div\" | \"unchecked_rem\" =>\n-                (1, vec![param(ccx, 0), param(ccx, 0)], param(ccx, 0)),\n+                (1, vec![param(0), param(0)], param(0)),\n \n             \"overflowing_add\" | \"overflowing_sub\" | \"overflowing_mul\" =>\n-                (1, vec![param(ccx, 0), param(ccx, 0)], param(ccx, 0)),\n+                (1, vec![param(0), param(0)], param(0)),\n             \"fadd_fast\" | \"fsub_fast\" | \"fmul_fast\" | \"fdiv_fast\" | \"frem_fast\" =>\n-                (1, vec![param(ccx, 0), param(ccx, 0)], param(ccx, 0)),\n+                (1, vec![param(0), param(0)], param(0)),\n \n             \"assume\" => (0, vec![tcx.types.bool], tcx.mk_nil()),\n             \"likely\" => (0, vec![tcx.types.bool], tcx.types.bool),\n@@ -289,7 +284,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n             \"discriminant_value\" => (1, vec![\n                     tcx.mk_imm_ref(tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1),\n                                                                   ty::BrAnon(0))),\n-                                   param(ccx, 0))], tcx.types.u64),\n+                                   param(0))], tcx.types.u64),\n \n             \"try\" => {\n                 let mut_u8 = tcx.mk_mut_ptr(tcx.types.u8);\n@@ -312,18 +307,17 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n         };\n         (n_tps, inputs, output)\n     };\n-    equate_intrinsic_type(ccx, it, n_tps, Abi::RustIntrinsic, inputs, output)\n+    equate_intrinsic_type(tcx, it, n_tps, Abi::RustIntrinsic, inputs, output)\n }\n \n /// Type-check `extern \"platform-intrinsic\" { ... }` functions.\n-pub fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n-                                     it: &hir::ForeignItem) {\n+pub fn check_platform_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                               it: &hir::ForeignItem) {\n     let param = |n| {\n         let name = Symbol::intern(&format!(\"P{}\", n));\n-        ccx.tcx.mk_param(n, name)\n+        tcx.mk_param(n, name)\n     };\n \n-    let tcx = ccx.tcx;\n     let def_id = tcx.hir.local_def_id(it.id);\n     let i_n_tps = tcx.item_generics(def_id).types.len();\n     let name = it.name.as_str();\n@@ -379,10 +373,10 @@ pub fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n                     }\n                     let input_pairs = intr.inputs.iter().zip(sig.inputs());\n                     for (i, (expected_arg, arg)) in input_pairs.enumerate() {\n-                        match_intrinsic_type_to_type(ccx, &format!(\"argument {}\", i + 1), it.span,\n+                        match_intrinsic_type_to_type(tcx, &format!(\"argument {}\", i + 1), it.span,\n                                                      &mut structural_to_nomimal, expected_arg, arg);\n                     }\n-                    match_intrinsic_type_to_type(ccx, \"return value\", it.span,\n+                    match_intrinsic_type_to_type(tcx, \"return value\", it.span,\n                                                  &mut structural_to_nomimal,\n                                                  &intr.output, sig.output());\n                     return\n@@ -396,15 +390,15 @@ pub fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n         }\n     };\n \n-    equate_intrinsic_type(ccx, it, n_tps, Abi::PlatformIntrinsic,\n+    equate_intrinsic_type(tcx, it, n_tps, Abi::PlatformIntrinsic,\n                           inputs, output)\n }\n \n // walk the expected type and the actual type in lock step, checking they're\n // the same, in a kinda-structural way, i.e. `Vector`s have to be simd structs with\n // exactly the right element type\n-fn match_intrinsic_type_to_type<'tcx, 'a>(\n-        ccx: &CrateCtxt<'a, 'tcx>,\n+fn match_intrinsic_type_to_type<'a, 'tcx>(\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         position: &str,\n         span: Span,\n         structural_to_nominal: &mut FxHashMap<&'a intrinsics::Type, ty::Ty<'tcx>>,\n@@ -413,7 +407,7 @@ fn match_intrinsic_type_to_type<'tcx, 'a>(\n     use intrinsics::Type::*;\n \n     let simple_error = |real: &str, expected: &str| {\n-        span_err!(ccx.tcx.sess, span, E0442,\n+        span_err!(tcx.sess, span, E0442,\n                   \"intrinsic {} has wrong type: found {}, expected {}\",\n                   position, real, expected)\n     };\n@@ -453,7 +447,7 @@ fn match_intrinsic_type_to_type<'tcx, 'a>(\n                         simple_error(&format!(\"`{}`\", t),\n                                      if const_ {\"const pointer\"} else {\"mut pointer\"})\n                     }\n-                    match_intrinsic_type_to_type(ccx, position, span, structural_to_nominal,\n+                    match_intrinsic_type_to_type(tcx, position, span, structural_to_nominal,\n                                                  inner_expected, ty)\n                 }\n                 _ => simple_error(&format!(\"`{}`\", t), \"raw pointer\"),\n@@ -464,19 +458,19 @@ fn match_intrinsic_type_to_type<'tcx, 'a>(\n                 simple_error(&format!(\"non-simd type `{}`\", t), \"simd type\");\n                 return;\n             }\n-            let t_len = t.simd_size(ccx.tcx);\n+            let t_len = t.simd_size(tcx);\n             if len as usize != t_len {\n                 simple_error(&format!(\"vector with length {}\", t_len),\n                              &format!(\"length {}\", len));\n                 return;\n             }\n-            let t_ty = t.simd_type(ccx.tcx);\n+            let t_ty = t.simd_type(tcx);\n             {\n                 // check that a given structural type always has the same an intrinsic definition\n                 let previous = structural_to_nominal.entry(expected).or_insert(t);\n                 if *previous != t {\n                     // this gets its own error code because it is non-trivial\n-                    span_err!(ccx.tcx.sess, span, E0443,\n+                    span_err!(tcx.sess, span, E0443,\n                               \"intrinsic {} has wrong type: found `{}`, expected `{}` which \\\n                                was used for this vector type previously in this signature\",\n                               position,\n@@ -485,7 +479,7 @@ fn match_intrinsic_type_to_type<'tcx, 'a>(\n                     return;\n                 }\n             }\n-            match_intrinsic_type_to_type(ccx,\n+            match_intrinsic_type_to_type(tcx,\n                                          position,\n                                          span,\n                                          structural_to_nominal,\n@@ -501,7 +495,7 @@ fn match_intrinsic_type_to_type<'tcx, 'a>(\n                         return\n                     }\n                     for (e, c) in expected_contents.iter().zip(contents) {\n-                        match_intrinsic_type_to_type(ccx, position, span, structural_to_nominal,\n+                        match_intrinsic_type_to_type(tcx, position, span, structural_to_nominal,\n                                                      e, c)\n                     }\n                 }"}, {"sha": "917607aab6b5ab3f0bf4cf75f336ae97cad7e72d", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=4649f7387ea334901c78dd48c1e1659ecf80cfcc", "patch": "@@ -566,7 +566,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         // Disallow calls to the method `drop` defined in the `Drop` trait.\n         match pick.item.container {\n             ty::TraitContainer(trait_def_id) => {\n-                callee::check_legal_trait_for_method_call(self.ccx, self.span, trait_def_id)\n+                callee::check_legal_trait_for_method_call(self.tcx, self.span, trait_def_id)\n             }\n             ty::ImplContainer(..) => {}\n         }"}, {"sha": "b6071d01ff1cf682090f1f8e934cea5bd1e6b8af", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=4649f7387ea334901c78dd48c1e1659ecf80cfcc", "patch": "@@ -653,7 +653,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n     fn assemble_extension_candidates_for_all_traits(&mut self) -> Result<(), MethodError<'tcx>> {\n         let mut duplicates = FxHashSet();\n-        for trait_info in suggest::all_traits(self.ccx) {\n+        for trait_info in suggest::all_traits(self.tcx) {\n             if duplicates.insert(trait_info.def_id) {\n                 self.assemble_extension_candidates_for_trait(None, trait_info.def_id)?;\n             }"}, {"sha": "6ce50d91124d445002769b6dfb0ad775dbecd867", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=4649f7387ea334901c78dd48c1e1659ecf80cfcc", "patch": "@@ -11,11 +11,9 @@\n //! Give useful errors and suggestions to users when an item can't be\n //! found or is otherwise invalid.\n \n-use CrateCtxt;\n-\n use check::FnCtxt;\n use rustc::hir::map as hir_map;\n-use rustc::ty::{self, Ty, ToPolyTraitRef, ToPredicate, TypeFoldable};\n+use rustc::ty::{self, Ty, TyCtxt, ToPolyTraitRef, ToPredicate, TypeFoldable};\n use hir::def::Def;\n use hir::def_id::{CRATE_DEF_INDEX, DefId};\n use middle::lang_items::FnOnceTraitLangItem;\n@@ -343,7 +341,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // there's no implemented traits, so lets suggest some traits to\n         // implement, by finding ones that have the item name, and are\n         // legal to implement.\n-        let mut candidates = all_traits(self.ccx)\n+        let mut candidates = all_traits(self.tcx)\n             .filter(|info| {\n                 // we approximate the coherence rules to only suggest\n                 // traits that are legal to implement by requiring that\n@@ -423,7 +421,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-pub type AllTraitsVec = Vec<TraitInfo>;\n+pub type AllTraitsVec = Vec<DefId>;\n \n #[derive(Copy, Clone)]\n pub struct TraitInfo {\n@@ -458,8 +456,8 @@ impl Ord for TraitInfo {\n }\n \n /// Retrieve all traits in this crate and any dependent crates.\n-pub fn all_traits<'a>(ccx: &'a CrateCtxt) -> AllTraits<'a> {\n-    if ccx.all_traits.borrow().is_none() {\n+pub fn all_traits<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> AllTraits<'a> {\n+    if tcx.all_traits.borrow().is_none() {\n         use rustc::hir::itemlikevisit;\n \n         let mut traits = vec![];\n@@ -476,7 +474,7 @@ pub fn all_traits<'a>(ccx: &'a CrateCtxt) -> AllTraits<'a> {\n                 match i.node {\n                     hir::ItemTrait(..) => {\n                         let def_id = self.map.local_def_id(i.id);\n-                        self.traits.push(TraitInfo::new(def_id));\n+                        self.traits.push(def_id);\n                     }\n                     _ => {}\n                 }\n@@ -488,45 +486,45 @@ pub fn all_traits<'a>(ccx: &'a CrateCtxt) -> AllTraits<'a> {\n             fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n             }\n         }\n-        ccx.tcx.hir.krate().visit_all_item_likes(&mut Visitor {\n-            map: &ccx.tcx.hir,\n+        tcx.hir.krate().visit_all_item_likes(&mut Visitor {\n+            map: &tcx.hir,\n             traits: &mut traits,\n         });\n \n         // Cross-crate:\n         let mut external_mods = FxHashSet();\n-        fn handle_external_def(ccx: &CrateCtxt,\n+        fn handle_external_def(tcx: TyCtxt,\n                                traits: &mut AllTraitsVec,\n                                external_mods: &mut FxHashSet<DefId>,\n                                def: Def) {\n             let def_id = def.def_id();\n             match def {\n                 Def::Trait(..) => {\n-                    traits.push(TraitInfo::new(def_id));\n+                    traits.push(def_id);\n                 }\n                 Def::Mod(..) => {\n                     if !external_mods.insert(def_id) {\n                         return;\n                     }\n-                    for child in ccx.tcx.sess.cstore.item_children(def_id) {\n-                        handle_external_def(ccx, traits, external_mods, child.def)\n+                    for child in tcx.sess.cstore.item_children(def_id) {\n+                        handle_external_def(tcx, traits, external_mods, child.def)\n                     }\n                 }\n                 _ => {}\n             }\n         }\n-        for cnum in ccx.tcx.sess.cstore.crates() {\n+        for cnum in tcx.sess.cstore.crates() {\n             let def_id = DefId {\n                 krate: cnum,\n                 index: CRATE_DEF_INDEX,\n             };\n-            handle_external_def(ccx, &mut traits, &mut external_mods, Def::Mod(def_id));\n+            handle_external_def(tcx, &mut traits, &mut external_mods, Def::Mod(def_id));\n         }\n \n-        *ccx.all_traits.borrow_mut() = Some(traits);\n+        *tcx.all_traits.borrow_mut() = Some(traits);\n     }\n \n-    let borrow = ccx.all_traits.borrow();\n+    let borrow = tcx.all_traits.borrow();\n     assert!(borrow.is_some());\n     AllTraits {\n         borrow: borrow,\n@@ -547,7 +545,7 @@ impl<'a> Iterator for AllTraits<'a> {\n         // ugh.\n         borrow.as_ref().unwrap().get(*idx).map(|info| {\n             *idx += 1;\n-            *info\n+            TraitInfo::new(*info)\n         })\n     }\n }"}, {"sha": "d52516e0ae50053c40c865bc3b53c71a9c423a42", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 129, "deletions": 141, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4649f7387ea334901c78dd48c1e1659ecf80cfcc", "patch": "@@ -56,7 +56,7 @@ stored in `fcx.node_types` and `fcx.item_substs`.  These types\n may contain unresolved type variables.  After type checking is\n complete, the functions in the writeback module are used to take the\n types from this table, resolve them, and then write them into their\n-permanent home in the type context `ccx.tcx`.\n+permanent home in the type context `tcx`.\n \n This means that during inferencing you should use `fcx.write_ty()`\n and `fcx.expr_ty()` / `fcx.node_ty()` to write/obtain the types of\n@@ -98,7 +98,6 @@ use rustc::ty::fold::{BottomUpFolder, TypeFoldable};\n use rustc::ty::util::{Representability, IntTypeExt};\n use require_c_abi_if_variadic;\n use session::{Session, CompileResult};\n-use CrateCtxt;\n use TypeAndSubsts;\n use lint;\n use util::common::{ErrorReported, indenter};\n@@ -154,8 +153,8 @@ mod op;\n /// `bar()` will each have their own `FnCtxt`, but they will\n /// share the inherited fields.\n pub struct Inherited<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    ccx: &'a CrateCtxt<'a, 'gcx>,\n     infcx: InferCtxt<'a, 'gcx, 'tcx>,\n+\n     locals: RefCell<NodeMap<Ty<'tcx>>>,\n \n     fulfillment_cx: RefCell<traits::FulfillmentContext<'tcx>>,\n@@ -474,22 +473,20 @@ impl<'a, 'gcx, 'tcx> Deref for FnCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-/// Helper type of a temporary returned by ccx.inherited(...).\n+/// Helper type of a temporary returned by Inherited::build(...).\n /// Necessary because we can't write the following bound:\n /// F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(Inherited<'b, 'gcx, 'tcx>).\n pub struct InheritedBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    ccx: &'a CrateCtxt<'a, 'gcx>,\n     infcx: infer::InferCtxtBuilder<'a, 'gcx, 'tcx>\n }\n \n-impl<'a, 'gcx, 'tcx> CrateCtxt<'a, 'gcx> {\n-    pub fn inherited(&'a self, id: ast::NodeId)\n-                     -> InheritedBuilder<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n+    pub fn build(tcx: TyCtxt<'a, 'gcx, 'gcx>, id: ast::NodeId)\n+                 -> InheritedBuilder<'a, 'gcx, 'tcx> {\n         let tables = ty::TypeckTables::empty();\n-        let param_env = ParameterEnvironment::for_item(self.tcx, id);\n+        let param_env = ParameterEnvironment::for_item(tcx, id);\n         InheritedBuilder {\n-            ccx: self,\n-            infcx: self.tcx.infer_ctxt((tables, param_env), Reveal::NotSpecializable)\n+            infcx: tcx.infer_ctxt((tables, param_env), Reveal::NotSpecializable)\n         }\n     }\n }\n@@ -498,17 +495,13 @@ impl<'a, 'gcx, 'tcx> InheritedBuilder<'a, 'gcx, 'tcx> {\n     fn enter<F, R>(&'tcx mut self, f: F) -> R\n         where F: for<'b> FnOnce(Inherited<'b, 'gcx, 'tcx>) -> R\n     {\n-        let ccx = self.ccx;\n-        self.infcx.enter(|infcx| f(Inherited::new(ccx, infcx)))\n+        self.infcx.enter(|infcx| f(Inherited::new(infcx)))\n     }\n }\n \n impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n-    pub fn new(ccx: &'a CrateCtxt<'a, 'gcx>,\n-               infcx: InferCtxt<'a, 'gcx, 'tcx>)\n-               -> Self {\n+    pub fn new(infcx: InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n         Inherited {\n-            ccx: ccx,\n             infcx: infcx,\n             fulfillment_cx: RefCell::new(traits::FulfillmentContext::new()),\n             locals: RefCell::new(NodeMap()),\n@@ -536,23 +529,23 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n \n }\n \n-struct CheckItemTypesVisitor<'a, 'tcx: 'a> { ccx: &'a CrateCtxt<'a, 'tcx> }\n-struct CheckItemBodiesVisitor<'a, 'tcx: 'a> { ccx: &'a CrateCtxt<'a, 'tcx> }\n+struct CheckItemTypesVisitor<'a, 'tcx: 'a> { tcx: TyCtxt<'a, 'tcx, 'tcx> }\n+struct CheckItemBodiesVisitor<'a, 'tcx: 'a> { tcx: TyCtxt<'a, 'tcx, 'tcx> }\n \n impl<'a, 'tcx> Visitor<'tcx> for CheckItemTypesVisitor<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.ccx.tcx.hir)\n+        NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n     }\n \n     fn visit_item(&mut self, i: &'tcx hir::Item) {\n-        check_item_type(self.ccx, i);\n+        check_item_type(self.tcx, i);\n         intravisit::walk_item(self, i);\n     }\n \n     fn visit_ty(&mut self, t: &'tcx hir::Ty) {\n         match t.node {\n             hir::TyArray(_, length) => {\n-                check_const_with_type(self.ccx, length, self.ccx.tcx.types.usize, length.node_id);\n+                check_const_with_type(self.tcx, length, self.tcx.types.usize, length.node_id);\n             }\n             _ => {}\n         }\n@@ -563,7 +556,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckItemTypesVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, e: &'tcx hir::Expr) {\n         match e.node {\n             hir::ExprRepeat(_, count) => {\n-                check_const_with_type(self.ccx, count, self.ccx.tcx.types.usize, count.node_id);\n+                check_const_with_type(self.tcx, count, self.tcx.types.usize, count.node_id);\n             }\n             _ => {}\n         }\n@@ -576,7 +569,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CheckItemBodiesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         match item.node {\n             hir::ItemFn(ref decl, .., body_id) => {\n-                check_bare_fn(self.ccx, &decl, body_id, item.id, item.span);\n+                check_bare_fn(self.tcx, &decl, body_id, item.id, item.span);\n             }\n             _ => { }\n         }\n@@ -585,10 +578,10 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CheckItemBodiesVisitor<'a, 'tcx> {\n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n         match trait_item.node {\n             hir::TraitItemKind::Const(_, Some(expr)) => {\n-                check_const(self.ccx, expr, trait_item.id)\n+                check_const(self.tcx, expr, trait_item.id)\n             }\n             hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Provided(body_id)) => {\n-                check_bare_fn(self.ccx, &sig.decl, body_id, trait_item.id, trait_item.span);\n+                check_bare_fn(self.tcx, &sig.decl, body_id, trait_item.id, trait_item.span);\n             }\n             hir::TraitItemKind::Method(_, hir::TraitMethod::Required(_)) |\n             hir::TraitItemKind::Const(_, None) |\n@@ -601,10 +594,10 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CheckItemBodiesVisitor<'a, 'tcx> {\n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n         match impl_item.node {\n             hir::ImplItemKind::Const(_, expr) => {\n-                check_const(self.ccx, expr, impl_item.id)\n+                check_const(self.tcx, expr, impl_item.id)\n             }\n             hir::ImplItemKind::Method(ref sig, body_id) => {\n-                check_bare_fn(self.ccx, &sig.decl, body_id, impl_item.id, impl_item.span);\n+                check_bare_fn(self.tcx, &sig.decl, body_id, impl_item.id, impl_item.span);\n             }\n             hir::ImplItemKind::Type(_) => {\n                 // Nothing to do here.\n@@ -613,35 +606,35 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CheckItemBodiesVisitor<'a, 'tcx> {\n     }\n }\n \n-pub fn check_wf_new(ccx: &CrateCtxt) -> CompileResult {\n-    ccx.tcx.sess.track_errors(|| {\n-        let mut visit = wfcheck::CheckTypeWellFormedVisitor::new(ccx);\n-        ccx.tcx.visit_all_item_likes_in_krate(DepNode::WfCheck, &mut visit.as_deep_visitor());\n+pub fn check_wf_new<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> CompileResult {\n+    tcx.sess.track_errors(|| {\n+        let mut visit = wfcheck::CheckTypeWellFormedVisitor::new(tcx);\n+        tcx.visit_all_item_likes_in_krate(DepNode::WfCheck, &mut visit.as_deep_visitor());\n     })\n }\n \n-pub fn check_item_types(ccx: &CrateCtxt) -> CompileResult {\n-    ccx.tcx.sess.track_errors(|| {\n-        let mut visit = CheckItemTypesVisitor { ccx: ccx };\n-        ccx.tcx.visit_all_item_likes_in_krate(DepNode::TypeckItemType,\n+pub fn check_item_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> CompileResult {\n+    tcx.sess.track_errors(|| {\n+        let mut visit = CheckItemTypesVisitor { tcx: tcx };\n+        tcx.visit_all_item_likes_in_krate(DepNode::TypeckItemType,\n                                               &mut visit.as_deep_visitor());\n     })\n }\n \n-pub fn check_item_bodies(ccx: &CrateCtxt) -> CompileResult {\n-    ccx.tcx.sess.track_errors(|| {\n-        let mut visit = CheckItemBodiesVisitor { ccx: ccx };\n-        ccx.tcx.visit_all_item_likes_in_krate(DepNode::TypeckTables, &mut visit);\n+pub fn check_item_bodies<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> CompileResult {\n+    tcx.sess.track_errors(|| {\n+        let mut visit = CheckItemBodiesVisitor { tcx: tcx };\n+        tcx.visit_all_item_likes_in_krate(DepNode::TypeckTables, &mut visit);\n \n         // Process deferred obligations, now that all functions\n         // bodies have been fully inferred.\n-        for (&item_id, obligations) in ccx.deferred_obligations.borrow().iter() {\n+        for (&item_id, obligations) in tcx.deferred_obligations.borrow().iter() {\n             // Use the same DepNode as for the body of the original function/item.\n-            let def_id = ccx.tcx.hir.local_def_id(item_id);\n-            let _task = ccx.tcx.dep_graph.in_task(DepNode::TypeckTables(def_id));\n+            let def_id = tcx.hir.local_def_id(item_id);\n+            let _task = tcx.dep_graph.in_task(DepNode::TypeckTables(def_id));\n \n-            let param_env = ParameterEnvironment::for_item(ccx.tcx, item_id);\n-            ccx.tcx.infer_ctxt(param_env, Reveal::NotSpecializable).enter(|infcx| {\n+            let param_env = ParameterEnvironment::for_item(tcx, item_id);\n+            tcx.infer_ctxt(param_env, Reveal::NotSpecializable).enter(|infcx| {\n                 let mut fulfillment_cx = traits::FulfillmentContext::new();\n                 for obligation in obligations.iter().map(|o| o.to_obligation()) {\n                     fulfillment_cx.register_predicate_obligation(&infcx, obligation);\n@@ -655,42 +648,42 @@ pub fn check_item_bodies(ccx: &CrateCtxt) -> CompileResult {\n     })\n }\n \n-pub fn check_drop_impls(ccx: &CrateCtxt) -> CompileResult {\n-    ccx.tcx.sess.track_errors(|| {\n-        let _task = ccx.tcx.dep_graph.in_task(DepNode::Dropck);\n-        let drop_trait = match ccx.tcx.lang_items.drop_trait() {\n-            Some(id) => ccx.tcx.lookup_trait_def(id), None => { return }\n+pub fn check_drop_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> CompileResult {\n+    tcx.sess.track_errors(|| {\n+        let _task = tcx.dep_graph.in_task(DepNode::Dropck);\n+        let drop_trait = match tcx.lang_items.drop_trait() {\n+            Some(id) => tcx.lookup_trait_def(id), None => { return }\n         };\n-        drop_trait.for_each_impl(ccx.tcx, |drop_impl_did| {\n-            let _task = ccx.tcx.dep_graph.in_task(DepNode::DropckImpl(drop_impl_did));\n+        drop_trait.for_each_impl(tcx, |drop_impl_did| {\n+            let _task = tcx.dep_graph.in_task(DepNode::DropckImpl(drop_impl_did));\n             if drop_impl_did.is_local() {\n-                match dropck::check_drop_impl(ccx, drop_impl_did) {\n+                match dropck::check_drop_impl(tcx, drop_impl_did) {\n                     Ok(()) => {}\n                     Err(()) => {\n-                        assert!(ccx.tcx.sess.has_errors());\n+                        assert!(tcx.sess.has_errors());\n                     }\n                 }\n             }\n         });\n     })\n }\n \n-fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn check_bare_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            decl: &'tcx hir::FnDecl,\n                            body_id: hir::BodyId,\n                            fn_id: ast::NodeId,\n                            span: Span) {\n-    let body = ccx.tcx.hir.body(body_id);\n+    let body = tcx.hir.body(body_id);\n \n-    let raw_fty = ccx.tcx.item_type(ccx.tcx.hir.local_def_id(fn_id));\n+    let raw_fty = tcx.item_type(tcx.hir.local_def_id(fn_id));\n     let fn_ty = match raw_fty.sty {\n         ty::TyFnDef(.., f) => f,\n         _ => span_bug!(body.value.span, \"check_bare_fn: function type expected\")\n     };\n \n-    check_abi(ccx, span, fn_ty.abi);\n+    check_abi(tcx, span, fn_ty.abi);\n \n-    ccx.inherited(fn_id).enter(|inh| {\n+    Inherited::build(tcx, fn_id).enter(|inh| {\n         // Compute the fty from point of view of inside fn.\n         let fn_scope = inh.tcx.region_maps.call_site_extent(fn_id, body_id.node_id);\n         let fn_sig =\n@@ -713,9 +706,9 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     });\n }\n \n-fn check_abi<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, span: Span, abi: Abi) {\n-    if !ccx.tcx.sess.target.target.is_abi_supported(abi) {\n-        struct_span_err!(ccx.tcx.sess, span, E0570,\n+fn check_abi<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span: Span, abi: Abi) {\n+    if !tcx.sess.target.target.is_abi_supported(abi) {\n+        struct_span_err!(tcx.sess, span, E0570,\n             \"The ABI `{}` is not supported for the current target\", abi).emit()\n     }\n }\n@@ -837,79 +830,83 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     fcx\n }\n \n-fn check_struct(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n-    let def_id = ccx.tcx.hir.local_def_id(id);\n-    check_representable(ccx.tcx, span, def_id);\n+fn check_struct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          id: ast::NodeId,\n+                          span: Span) {\n+    let def_id = tcx.hir.local_def_id(id);\n+    check_representable(tcx, span, def_id);\n \n-    if ccx.tcx.lookup_simd(def_id) {\n-        check_simd(ccx.tcx, span, def_id);\n+    if tcx.lookup_simd(def_id) {\n+        check_simd(tcx, span, def_id);\n     }\n }\n \n-fn check_union(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n-    check_representable(ccx.tcx, span, ccx.tcx.hir.local_def_id(id));\n+fn check_union<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                         id: ast::NodeId,\n+                         span: Span) {\n+    check_representable(tcx, span, tcx.hir.local_def_id(id));\n }\n \n-pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n+pub fn check_item_type<'a,'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &'tcx hir::Item) {\n     debug!(\"check_item_type(it.id={}, it.name={})\",\n            it.id,\n-           ccx.tcx.item_path_str(ccx.tcx.hir.local_def_id(it.id)));\n+           tcx.item_path_str(tcx.hir.local_def_id(it.id)));\n     let _indenter = indenter();\n     match it.node {\n       // Consts can play a role in type-checking, so they are included here.\n       hir::ItemStatic(.., e) |\n-      hir::ItemConst(_, e) => check_const(ccx, e, it.id),\n+      hir::ItemConst(_, e) => check_const(tcx, e, it.id),\n       hir::ItemEnum(ref enum_definition, _) => {\n-        check_enum_variants(ccx,\n+        check_enum_variants(tcx,\n                             it.span,\n                             &enum_definition.variants,\n                             it.id);\n       }\n       hir::ItemFn(..) => {} // entirely within check_item_body\n       hir::ItemImpl(.., ref impl_item_refs) => {\n           debug!(\"ItemImpl {} with id {}\", it.name, it.id);\n-          let impl_def_id = ccx.tcx.hir.local_def_id(it.id);\n-          if let Some(impl_trait_ref) = ccx.tcx.impl_trait_ref(impl_def_id) {\n-              check_impl_items_against_trait(ccx,\n+          let impl_def_id = tcx.hir.local_def_id(it.id);\n+          if let Some(impl_trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n+              check_impl_items_against_trait(tcx,\n                                              it.span,\n                                              impl_def_id,\n                                              impl_trait_ref,\n                                              impl_item_refs);\n               let trait_def_id = impl_trait_ref.def_id;\n-              check_on_unimplemented(ccx, trait_def_id, it);\n+              check_on_unimplemented(tcx, trait_def_id, it);\n           }\n       }\n       hir::ItemTrait(..) => {\n-        let def_id = ccx.tcx.hir.local_def_id(it.id);\n-        check_on_unimplemented(ccx, def_id, it);\n+        let def_id = tcx.hir.local_def_id(it.id);\n+        check_on_unimplemented(tcx, def_id, it);\n       }\n       hir::ItemStruct(..) => {\n-        check_struct(ccx, it.id, it.span);\n+        check_struct(tcx, it.id, it.span);\n       }\n       hir::ItemUnion(..) => {\n-        check_union(ccx, it.id, it.span);\n+        check_union(tcx, it.id, it.span);\n       }\n       hir::ItemTy(_, ref generics) => {\n-        let def_id = ccx.tcx.hir.local_def_id(it.id);\n-        let pty_ty = ccx.tcx.item_type(def_id);\n-        check_bounds_are_used(ccx, generics, pty_ty);\n+        let def_id = tcx.hir.local_def_id(it.id);\n+        let pty_ty = tcx.item_type(def_id);\n+        check_bounds_are_used(tcx, generics, pty_ty);\n       }\n       hir::ItemForeignMod(ref m) => {\n-        check_abi(ccx, it.span, m.abi);\n+        check_abi(tcx, it.span, m.abi);\n \n         if m.abi == Abi::RustIntrinsic {\n             for item in &m.items {\n-                intrinsic::check_intrinsic_type(ccx, item);\n+                intrinsic::check_intrinsic_type(tcx, item);\n             }\n         } else if m.abi == Abi::PlatformIntrinsic {\n             for item in &m.items {\n-                intrinsic::check_platform_intrinsic_type(ccx, item);\n+                intrinsic::check_platform_intrinsic_type(tcx, item);\n             }\n         } else {\n             for item in &m.items {\n-                let generics = ccx.tcx.item_generics(ccx.tcx.hir.local_def_id(item.id));\n+                let generics = tcx.item_generics(tcx.hir.local_def_id(item.id));\n                 if !generics.types.is_empty() {\n-                    let mut err = struct_span_err!(ccx.tcx.sess, item.span, E0044,\n+                    let mut err = struct_span_err!(tcx.sess, item.span, E0044,\n                         \"foreign items may not have type parameters\");\n                     span_help!(&mut err, item.span,\n                         \"consider using specialization instead of \\\n@@ -918,7 +915,7 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n                 }\n \n                 if let hir::ForeignItemFn(ref fn_decl, _, _) = item.node {\n-                    require_c_abi_if_variadic(ccx.tcx, fn_decl, m.abi, item.span);\n+                    require_c_abi_if_variadic(tcx, fn_decl, m.abi, item.span);\n                 }\n             }\n         }\n@@ -927,10 +924,10 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n     }\n }\n \n-fn check_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn check_on_unimplemented<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                     def_id: DefId,\n                                     item: &hir::Item) {\n-    let generics = ccx.tcx.item_generics(def_id);\n+    let generics = tcx.item_generics(def_id);\n     if let Some(ref attr) = item.attrs.iter().find(|a| {\n         a.check_name(\"rustc_on_unimplemented\")\n     }) {\n@@ -950,16 +947,16 @@ fn check_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         }) {\n                             Some(_) => (),\n                             None => {\n-                                let name = ccx.tcx.item_name(def_id);\n-                                span_err!(ccx.tcx.sess, attr.span, E0230,\n+                                let name = tcx.item_name(def_id);\n+                                span_err!(tcx.sess, attr.span, E0230,\n                                                  \"there is no type parameter \\\n                                                           {} on trait {}\",\n                                                            s, name);\n                             }\n                         },\n                         // `{:1}` and `{}` are not to be used\n                         Position::ArgumentIs(_) => {\n-                            span_err!(ccx.tcx.sess, attr.span, E0231,\n+                            span_err!(tcx.sess, attr.span, E0231,\n                                                   \"only named substitution \\\n                                                    parameters are allowed\");\n                         }\n@@ -968,7 +965,7 @@ fn check_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             }\n         } else {\n             struct_span_err!(\n-                ccx.tcx.sess, attr.span, E0232,\n+                tcx.sess, attr.span, E0232,\n                 \"this attribute must have a value\")\n                 .span_label(attr.span, &format!(\"attribute requires a value\"))\n                 .note(&format!(\"eg `#[rustc_on_unimplemented = \\\"foo\\\"]`\"))\n@@ -1026,7 +1023,7 @@ fn check_specialization_validity<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n }\n \n-fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                             impl_span: Span,\n                                             impl_id: DefId,\n                                             impl_trait_ref: ty::TraitRef<'tcx>,\n@@ -1037,11 +1034,10 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     if impl_trait_ref.references_error() { return; }\n \n     // Locate trait definition and items\n-    let tcx = ccx.tcx;\n     let trait_def = tcx.lookup_trait_def(impl_trait_ref.def_id);\n     let mut overridden_associated_type = None;\n \n-    let impl_items = || impl_item_refs.iter().map(|iiref| ccx.tcx.hir.impl_item(iiref.id));\n+    let impl_items = || impl_item_refs.iter().map(|iiref| tcx.hir.impl_item(iiref.id));\n \n     // Check existing impl methods to see if they are both present in trait\n     // and compatible with trait signature\n@@ -1056,7 +1052,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 hir::ImplItemKind::Const(..) => {\n                     // Find associated const definition.\n                     if ty_trait_item.kind == ty::AssociatedKind::Const {\n-                        compare_const_impl(ccx,\n+                        compare_const_impl(tcx,\n                                            &ty_impl_item,\n                                            impl_item.span,\n                                            &ty_trait_item,\n@@ -1080,7 +1076,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     let trait_span = tcx.hir.span_if_local(ty_trait_item.def_id);\n                     if ty_trait_item.kind == ty::AssociatedKind::Method {\n                         let err_count = tcx.sess.err_count();\n-                        compare_impl_method(ccx,\n+                        compare_impl_method(tcx,\n                                             &ty_impl_item,\n                                             impl_item.span,\n                                             body_id.node_id,\n@@ -1090,7 +1086,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                             true); // start with old-broken-mode\n                         if err_count == tcx.sess.err_count() {\n                             // old broken mode did not report an error. Try with the new mode.\n-                            compare_impl_method(ccx,\n+                            compare_impl_method(tcx,\n                                                 &ty_impl_item,\n                                                 impl_item.span,\n                                                 body_id.node_id,\n@@ -1203,12 +1199,12 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n }\n \n /// Checks a constant with a given type.\n-fn check_const_with_type<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n+fn check_const_with_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                    body: hir::BodyId,\n                                    expected_type: Ty<'tcx>,\n                                    id: ast::NodeId) {\n-    let body = ccx.tcx.hir.body(body);\n-    ccx.inherited(id).enter(|inh| {\n+    let body = tcx.hir.body(body);\n+    Inherited::build(tcx, id).enter(|inh| {\n         let fcx = FnCtxt::new(&inh, None, body.value.id);\n         fcx.require_type_is_sized(expected_type, body.value.span, traits::ConstSized);\n \n@@ -1231,11 +1227,11 @@ fn check_const_with_type<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n     });\n }\n \n-fn check_const<'a, 'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n+fn check_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                          body: hir::BodyId,\n                          id: ast::NodeId) {\n-    let decl_ty = ccx.tcx.item_type(ccx.tcx.hir.local_def_id(id));\n-    check_const_with_type(ccx, body, decl_ty, id);\n+    let decl_ty = tcx.item_type(tcx.hir.local_def_id(id));\n+    check_const_with_type(tcx, body, decl_ty, id);\n }\n \n /// Checks whether a type can be represented in memory. In particular, it\n@@ -1293,53 +1289,53 @@ pub fn check_simd<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: DefId\n }\n \n #[allow(trivial_numeric_casts)]\n-pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                                    sp: Span,\n-                                    vs: &'tcx [hir::Variant],\n-                                    id: ast::NodeId) {\n-    let def_id = ccx.tcx.hir.local_def_id(id);\n-    let hint = *ccx.tcx.lookup_repr_hints(def_id).get(0).unwrap_or(&attr::ReprAny);\n+pub fn check_enum_variants<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                     sp: Span,\n+                                     vs: &'tcx [hir::Variant],\n+                                     id: ast::NodeId) {\n+    let def_id = tcx.hir.local_def_id(id);\n+    let hint = *tcx.lookup_repr_hints(def_id).get(0).unwrap_or(&attr::ReprAny);\n \n     if hint != attr::ReprAny && vs.is_empty() {\n         struct_span_err!(\n-            ccx.tcx.sess, sp, E0084,\n+            tcx.sess, sp, E0084,\n             \"unsupported representation for zero-variant enum\")\n             .span_label(sp, &format!(\"unsupported enum representation\"))\n             .emit();\n     }\n \n-    let repr_type_ty = ccx.tcx.enum_repr_type(Some(&hint)).to_ty(ccx.tcx);\n-    if repr_type_ty == ccx.tcx.types.i128 || repr_type_ty == ccx.tcx.types.u128 {\n-        if !ccx.tcx.sess.features.borrow().i128_type {\n-            emit_feature_err(&ccx.tcx.sess.parse_sess,\n+    let repr_type_ty = tcx.enum_repr_type(Some(&hint)).to_ty(tcx);\n+    if repr_type_ty == tcx.types.i128 || repr_type_ty == tcx.types.u128 {\n+        if !tcx.sess.features.borrow().i128_type {\n+            emit_feature_err(&tcx.sess.parse_sess,\n                              \"i128_type\", sp, GateIssue::Language, \"128-bit type is unstable\");\n         }\n     }\n \n     for v in vs {\n         if let Some(e) = v.node.disr_expr {\n-            check_const_with_type(ccx, e, repr_type_ty, e.node_id);\n+            check_const_with_type(tcx, e, repr_type_ty, e.node_id);\n         }\n     }\n \n-    let def_id = ccx.tcx.hir.local_def_id(id);\n+    let def_id = tcx.hir.local_def_id(id);\n \n-    let def = ccx.tcx.lookup_adt_def(def_id);\n+    let def = tcx.lookup_adt_def(def_id);\n     let mut disr_vals: Vec<ConstInt> = Vec::new();\n-    for (discr, v) in def.discriminants(ccx.tcx).zip(vs) {\n+    for (discr, v) in def.discriminants(tcx).zip(vs) {\n         // Check for duplicate discriminant values\n         if let Some(i) = disr_vals.iter().position(|&x| x == discr) {\n-            let variant_i_node_id = ccx.tcx.hir.as_local_node_id(def.variants[i].did).unwrap();\n-            let variant_i = ccx.tcx.hir.expect_variant(variant_i_node_id);\n+            let variant_i_node_id = tcx.hir.as_local_node_id(def.variants[i].did).unwrap();\n+            let variant_i = tcx.hir.expect_variant(variant_i_node_id);\n             let i_span = match variant_i.node.disr_expr {\n-                Some(expr) => ccx.tcx.hir.span(expr.node_id),\n-                None => ccx.tcx.hir.span(variant_i_node_id)\n+                Some(expr) => tcx.hir.span(expr.node_id),\n+                None => tcx.hir.span(variant_i_node_id)\n             };\n             let span = match v.node.disr_expr {\n-                Some(expr) => ccx.tcx.hir.span(expr.node_id),\n+                Some(expr) => tcx.hir.span(expr.node_id),\n                 None => v.span\n             };\n-            struct_span_err!(ccx.tcx.sess, span, E0081,\n+            struct_span_err!(tcx.sess, span, E0081,\n                              \"discriminant value `{}` already exists\", disr_vals[i])\n                 .span_label(i_span, &format!(\"first use of `{}`\", disr_vals[i]))\n                 .span_label(span , &format!(\"enum already has `{}`\", disr_vals[i]))\n@@ -1348,7 +1344,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         disr_vals.push(discr);\n     }\n \n-    check_representable(ccx.tcx, sp, def_id);\n+    check_representable(tcx, sp, def_id);\n }\n \n impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n@@ -1504,10 +1500,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn param_env(&self) -> &ty::ParameterEnvironment<'gcx> {\n-        &self.parameter_environment\n-    }\n-\n     pub fn sess(&self) -> &Session {\n         &self.tcx.sess\n     }\n@@ -1754,10 +1746,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.write_ty(node_id, self.tcx.mk_nil());\n     }\n \n-    pub fn write_never(&self, node_id: ast::NodeId) {\n-        self.write_ty(node_id, self.tcx.types.never);\n-    }\n-\n     pub fn write_error(&self, node_id: ast::NodeId) {\n         self.write_ty(node_id, self.tcx.types.err);\n     }\n@@ -4303,7 +4291,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let container = self.tcx.associated_item(def_id).container;\n                 match container {\n                     ty::TraitContainer(trait_did) => {\n-                        callee::check_legal_trait_for_method_call(self.ccx, span, trait_did)\n+                        callee::check_legal_trait_for_method_call(self.tcx, span, trait_did)\n                     }\n                     ty::ImplContainer(_) => {}\n                 }\n@@ -4624,7 +4612,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+pub fn check_bounds_are_used<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                        generics: &hir::Generics,\n                                        ty: Ty<'tcx>) {\n     debug!(\"check_bounds_are_used(n_tps={}, ty={:?})\",\n@@ -4643,7 +4631,7 @@ pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     for (&used, param) in tps_used.iter().zip(&generics.ty_params) {\n         if !used {\n-            struct_span_err!(ccx.tcx.sess, param.span, E0091,\n+            struct_span_err!(tcx.sess, param.span, E0091,\n                 \"type parameter `{}` is unused\",\n                 param.name)\n                 .span_label(param.span, &format!(\"unused type parameter\"))"}, {"sha": "a120e3c343155ec81a24e48a1f77cfb1a5ad08e9", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=4649f7387ea334901c78dd48c1e1659ecf80cfcc", "patch": "@@ -102,8 +102,6 @@ use syntax_pos::Span;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::{self, PatKind};\n \n-use self::SubjectNode::Subject;\n-\n // a variation on try that just returns unit\n macro_rules! ignore_err {\n     ($e:expr) => (match $e { Ok(e) => e, Err(_) => return () })\n@@ -183,7 +181,7 @@ pub struct RegionCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     repeating_scope: ast::NodeId,\n \n     // id of AST node being analyzed (the subject of the analysis).\n-    subject: SubjectNode,\n+    subject: ast::NodeId,\n \n }\n \n@@ -195,14 +193,13 @@ impl<'a, 'gcx, 'tcx> Deref for RegionCtxt<'a, 'gcx, 'tcx> {\n }\n \n pub struct RepeatingScope(ast::NodeId);\n-pub enum SubjectNode { Subject(ast::NodeId), None }\n+pub struct Subject(ast::NodeId);\n \n impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     pub fn new(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n-               initial_repeating_scope: RepeatingScope,\n+               RepeatingScope(initial_repeating_scope): RepeatingScope,\n                initial_body_id: ast::NodeId,\n-               subject: SubjectNode) -> RegionCtxt<'a, 'gcx, 'tcx> {\n-        let RepeatingScope(initial_repeating_scope) = initial_repeating_scope;\n+               Subject(subject): Subject) -> RegionCtxt<'a, 'gcx, 'tcx> {\n         RegionCtxt {\n             fcx: fcx,\n             repeating_scope: initial_repeating_scope,\n@@ -416,13 +413,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn resolve_regions_and_report_errors(&self) {\n-        let subject_node_id = match self.subject {\n-            Subject(s) => s,\n-            SubjectNode::None => {\n-                bug!(\"cannot resolve_regions_and_report_errors \\\n-                      without subject node\");\n-            }\n-        };\n+        let subject_node_id = self.subject;\n \n         self.fcx.resolve_regions_and_report_errors(&self.free_region_map,\n                                                    subject_node_id);"}, {"sha": "533223546ad56c2a7a2e57b638f8b85514fcabbf", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 40, "deletions": 45, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=4649f7387ea334901c78dd48c1e1659ecf80cfcc", "patch": "@@ -9,9 +9,8 @@\n // except according to those terms.\n \n use astconv::ExplicitSelf;\n-use check::FnCtxt;\n+use check::{Inherited, FnCtxt};\n use constrained_type_params::{identify_constrained_type_params, Parameter};\n-use CrateCtxt;\n \n use hir::def_id::DefId;\n use middle::region::{CodeExtent};\n@@ -27,8 +26,8 @@ use errors::DiagnosticBuilder;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir;\n \n-pub struct CheckTypeWellFormedVisitor<'ccx, 'tcx:'ccx> {\n-    ccx: &'ccx CrateCtxt<'ccx, 'tcx>,\n+pub struct CheckTypeWellFormedVisitor<'a, 'tcx:'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     code: ObligationCauseCode<'tcx>,\n }\n \n@@ -51,9 +50,9 @@ impl<'a, 'gcx, 'tcx> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n         let id = self.id;\n         let span = self.span;\n         self.inherited.enter(|inh| {\n-            let fcx = FnCtxt::new(&inh, Some(inh.ccx.tcx.types.never), id);\n+            let fcx = FnCtxt::new(&inh, None, id);\n             let wf_tys = f(&fcx, &mut CheckTypeWellFormedVisitor {\n-                ccx: fcx.ccx,\n+                tcx: fcx.tcx.global_tcx(),\n                 code: code\n             });\n             fcx.select_all_obligations_or_error();\n@@ -62,19 +61,15 @@ impl<'a, 'gcx, 'tcx> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n-    pub fn new(ccx: &'ccx CrateCtxt<'ccx, 'gcx>)\n-               -> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n+impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'gcx>)\n+               -> CheckTypeWellFormedVisitor<'a, 'gcx> {\n         CheckTypeWellFormedVisitor {\n-            ccx: ccx,\n+            tcx: tcx,\n             code: ObligationCauseCode::MiscObligation\n         }\n     }\n \n-    fn tcx(&self) -> TyCtxt<'ccx, 'gcx, 'gcx> {\n-        self.ccx.tcx\n-    }\n-\n     /// Checks that the field types (in a struct def'n) or argument types (in an enum def'n) are\n     /// well-formed, meaning that they do not require any constraints not declared in the struct\n     /// definition itself. For example, this definition would be illegal:\n@@ -87,10 +82,10 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n     /// not included it frequently leads to confusing errors in fn bodies. So it's better to check\n     /// the types first.\n     fn check_item_well_formed(&mut self, item: &hir::Item) {\n-        let ccx = self.ccx;\n+        let tcx = self.tcx;\n         debug!(\"check_item_well_formed(it.id={}, it.name={})\",\n                item.id,\n-               ccx.tcx.item_path_str(ccx.tcx.hir.local_def_id(item.id)));\n+               tcx.item_path_str(tcx.hir.local_def_id(item.id)));\n \n         match item.node {\n             /// Right now we check that every default trait implementation\n@@ -117,9 +112,9 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n             hir::ItemImpl(_, hir::ImplPolarity::Negative, _, Some(_), ..) => {\n                 // FIXME(#27579) what amount of WF checking do we need for neg impls?\n \n-                let trait_ref = ccx.tcx.impl_trait_ref(ccx.tcx.hir.local_def_id(item.id)).unwrap();\n-                if !ccx.tcx.trait_has_default_impl(trait_ref.def_id) {\n-                    error_192(ccx, item.span);\n+                let trait_ref = tcx.impl_trait_ref(tcx.hir.local_def_id(item.id)).unwrap();\n+                if !tcx.trait_has_default_impl(trait_ref.def_id) {\n+                    error_192(tcx, item.span);\n                 }\n             }\n             hir::ItemFn(.., body_id) => {\n@@ -211,14 +206,14 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n     }\n \n     fn for_item<'tcx>(&self, item: &hir::Item)\n-                      -> CheckWfFcxBuilder<'ccx, 'gcx, 'tcx> {\n+                      -> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n         self.for_id(item.id, item.span)\n     }\n \n     fn for_id<'tcx>(&self, id: ast::NodeId, span: Span)\n-                    -> CheckWfFcxBuilder<'ccx, 'gcx, 'tcx> {\n+                    -> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n         CheckWfFcxBuilder {\n-            inherited: self.ccx.inherited(id),\n+            inherited: Inherited::build(self.tcx, id),\n             code: self.code.clone(),\n             id: id,\n             span: span\n@@ -270,7 +265,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n         //\n         // 3) that the trait definition does not have any type parameters\n \n-        let predicates = self.tcx().item_predicates(trait_def_id);\n+        let predicates = self.tcx.item_predicates(trait_def_id);\n \n         // We must exclude the Self : Trait predicate contained by all\n         // traits.\n@@ -285,7 +280,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                 }\n             });\n \n-        let has_ty_params = self.tcx().item_generics(trait_def_id).types.len() > 1;\n+        let has_ty_params = self.tcx.item_generics(trait_def_id).types.len() > 1;\n \n         // We use an if-else here, since the generics will also trigger\n         // an extraneous error message when we find predicates like\n@@ -296,14 +291,14 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n         // extraneous predicates created by things like\n         // an associated type inside the trait.\n         let mut err = None;\n-        if !self.tcx().associated_item_def_ids(trait_def_id).is_empty() {\n-            error_380(self.ccx, span);\n+        if !self.tcx.associated_item_def_ids(trait_def_id).is_empty() {\n+            error_380(self.tcx, span);\n         } else if has_ty_params {\n-            err = Some(struct_span_err!(self.tcx().sess, span, E0567,\n+            err = Some(struct_span_err!(self.tcx.sess, span, E0567,\n                 \"traits with auto impls (`e.g. impl \\\n                     Trait for ..`) can not have type parameters\"));\n         } else if has_predicates {\n-            err = Some(struct_span_err!(self.tcx().sess, span, E0568,\n+            err = Some(struct_span_err!(self.tcx.sess, span, E0568,\n                 \"traits with auto impls (`e.g. impl \\\n                     Trait for ..`) cannot have predicates\"));\n         }\n@@ -321,9 +316,9 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n     }\n \n     fn check_trait(&mut self, item: &hir::Item) {\n-        let trait_def_id = self.tcx().hir.local_def_id(item.id);\n+        let trait_def_id = self.tcx.hir.local_def_id(item.id);\n \n-        if self.tcx().trait_has_default_impl(trait_def_id) {\n+        if self.tcx.trait_has_default_impl(trait_def_id) {\n             self.check_auto_trait(trait_def_id, item.span);\n         }\n \n@@ -514,15 +509,15 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                                      item: &hir::Item,\n                                      ast_generics: &hir::Generics)\n     {\n-        let item_def_id = self.tcx().hir.local_def_id(item.id);\n-        let ty = self.tcx().item_type(item_def_id);\n-        if self.tcx().has_error_field(ty) {\n+        let item_def_id = self.tcx.hir.local_def_id(item.id);\n+        let ty = self.tcx.item_type(item_def_id);\n+        if self.tcx.has_error_field(ty) {\n             return;\n         }\n \n-        let ty_predicates = self.tcx().item_predicates(item_def_id);\n+        let ty_predicates = self.tcx.item_predicates(item_def_id);\n         assert_eq!(ty_predicates.parent, None);\n-        let variances = self.tcx().item_variances(item_def_id);\n+        let variances = self.tcx.item_variances(item_def_id);\n \n         let mut constrained_parameters: FxHashSet<_> =\n             variances.iter().enumerate()\n@@ -555,15 +550,15 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                          span: Span,\n                          param_name: ast::Name)\n     {\n-        let mut err = error_392(self.ccx, span, param_name);\n+        let mut err = error_392(self.tcx, span, param_name);\n \n-        let suggested_marker_id = self.tcx().lang_items.phantom_data();\n+        let suggested_marker_id = self.tcx.lang_items.phantom_data();\n         match suggested_marker_id {\n             Some(def_id) => {\n                 err.help(\n                     &format!(\"consider removing `{}` or using a marker such as `{}`\",\n                              param_name,\n-                             self.tcx().item_path_str(def_id)));\n+                             self.tcx.item_path_str(def_id)));\n             }\n             None => {\n                 // no lang items, no help!\n@@ -595,7 +590,7 @@ fn reject_shadowing_type_parameters(tcx: TyCtxt, def_id: DefId) {\n     }\n }\n \n-impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n+impl<'a, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'v> {\n         NestedVisitorMap::None\n     }\n@@ -681,21 +676,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-fn error_192(ccx: &CrateCtxt, span: Span) {\n-    span_err!(ccx.tcx.sess, span, E0192,\n+fn error_192(tcx: TyCtxt, span: Span) {\n+    span_err!(tcx.sess, span, E0192,\n               \"negative impls are only allowed for traits with \\\n                default impls (e.g., `Send` and `Sync`)\")\n }\n \n-fn error_380(ccx: &CrateCtxt, span: Span) {\n-    span_err!(ccx.tcx.sess, span, E0380,\n+fn error_380(tcx: TyCtxt, span: Span) {\n+    span_err!(tcx.sess, span, E0380,\n               \"traits with default impls (`e.g. impl \\\n                Trait for ..`) must have no methods or associated items\")\n }\n \n-fn error_392<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, span: Span, param_name: ast::Name)\n+fn error_392<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span: Span, param_name: ast::Name)\n                        -> DiagnosticBuilder<'tcx> {\n-    let mut err = struct_span_err!(ccx.tcx.sess, span, E0392,\n+    let mut err = struct_span_err!(tcx.sess, span, E0392,\n                   \"parameter `{}` is never used\", param_name);\n     err.span_label(span, &format!(\"unused type parameter\"));\n     err"}, {"sha": "f7f004fbaef129d185a3f4da0b395bc1d10c8143", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=4649f7387ea334901c78dd48c1e1659ecf80cfcc", "patch": "@@ -491,15 +491,15 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }).collect();\n \n         if !obligations.is_empty() {\n-            assert!(self.fcx.ccx.deferred_obligations.borrow_mut()\n+            assert!(self.fcx.tcx.deferred_obligations.borrow_mut()\n                                 .insert(item_id, obligations).is_none());\n         }\n     }\n \n     fn visit_type_nodes(&self) {\n         for (&id, ty) in self.fcx.ast_ty_to_ty_cache.borrow().iter() {\n             let ty = self.resolve(ty, ResolvingTyNode(id));\n-            self.fcx.ccx.ast_ty_to_ty_cache.borrow_mut().insert(id, ty);\n+            self.fcx.tcx.ast_ty_to_ty_cache.borrow_mut().insert(id, ty);\n         }\n     }\n "}, {"sha": "ed5ca79a706619ab0dd8f8f6c76fd9a12d85087a", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=4649f7387ea334901c78dd48c1e1659ecf80cfcc", "patch": "@@ -24,7 +24,6 @@ use rustc::ty::{TyRef, TyAdt, TyDynamic, TyNever, TyTuple};\n use rustc::ty::{TyStr, TyArray, TySlice, TyFloat, TyInfer, TyInt};\n use rustc::ty::{TyUint, TyClosure, TyFnDef, TyFnPtr};\n use rustc::ty::{TyProjection, TyAnon};\n-use CrateCtxt;\n use syntax_pos::Span;\n use rustc::dep_graph::DepNode;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n@@ -176,12 +175,12 @@ fn enforce_trait_manually_implementable(tcx: TyCtxt, sp: Span, trait_def_id: Def\n     err.emit();\n }\n \n-pub fn check_coherence(ccx: &CrateCtxt) {\n-    CoherenceCollect::check(ccx.tcx);\n+pub fn check_coherence<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    CoherenceCollect::check(tcx);\n \n-    let _task = ccx.tcx.dep_graph.in_task(DepNode::Coherence);\n-    unsafety::check(ccx.tcx);\n-    orphan::check(ccx.tcx);\n-    overlap::check(ccx.tcx);\n-    builtin::check(ccx.tcx);\n+    let _task = tcx.dep_graph.in_task(DepNode::Coherence);\n+    unsafety::check(tcx);\n+    orphan::check(tcx);\n+    overlap::check(tcx);\n+    builtin::check(tcx);\n }"}, {"sha": "95fd123b7df4ce493ce1caffe6e7e7d2597a96b9", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 259, "deletions": 303, "changes": 562, "blob_url": "https://github.com/rust-lang/rust/blob/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=4649f7387ea334901c78dd48c1e1659ecf80cfcc", "patch": "@@ -72,7 +72,6 @@ use rustc::ty::util::IntTypeExt;\n use rustc::dep_graph::DepNode;\n use util::common::{ErrorReported, MemoizationMap};\n use util::nodemap::{NodeMap, FxHashMap};\n-use CrateCtxt;\n \n use rustc_const_math::ConstInt;\n \n@@ -91,9 +90,9 @@ use rustc::hir::def_id::DefId;\n ///////////////////////////////////////////////////////////////////////////\n // Main entry point\n \n-pub fn collect_item_types(ccx: &CrateCtxt) {\n-    let mut visitor = CollectItemTypesVisitor { ccx: ccx };\n-    ccx.tcx.visit_all_item_likes_in_krate(DepNode::CollectItem, &mut visitor.as_deep_visitor());\n+pub fn collect_item_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    let mut visitor = CollectItemTypesVisitor { tcx: tcx };\n+    tcx.visit_all_item_likes_in_krate(DepNode::CollectItem, &mut visitor.as_deep_visitor());\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -108,21 +107,14 @@ pub fn collect_item_types(ccx: &CrateCtxt) {\n /// `get_type_parameter_bounds` requests, drawing the information from\n /// the AST (`hir::Generics`), recursively.\n struct ItemCtxt<'a,'tcx:'a> {\n-    ccx: &'a CrateCtxt<'a,'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     item_def_id: DefId,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq)]\n-pub enum AstConvRequest {\n-    GetItemType(DefId),\n-    EnsureSuperPredicates(DefId),\n-    GetTypeParameterBounds(ast::NodeId),\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n \n struct CollectItemTypesVisitor<'a, 'tcx: 'a> {\n-    ccx: &'a CrateCtxt<'a, 'tcx>\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>\n }\n \n impl<'a, 'tcx> CollectItemTypesVisitor<'a, 'tcx> {\n@@ -166,61 +158,61 @@ impl<'a, 'tcx> CollectItemTypesVisitor<'a, 'tcx> {\n     fn with_collect_item_sig<OP>(&self, id: ast::NodeId, op: OP)\n         where OP: FnOnce()\n     {\n-        let def_id = self.ccx.tcx.hir.local_def_id(id);\n-        self.ccx.tcx.dep_graph.with_task(DepNode::CollectItemSig(def_id), || {\n-            self.ccx.tcx.hir.read(id);\n+        let def_id = self.tcx.hir.local_def_id(id);\n+        self.tcx.dep_graph.with_task(DepNode::CollectItemSig(def_id), || {\n+            self.tcx.hir.read(id);\n             op();\n         });\n     }\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.ccx.tcx.hir)\n+        NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        self.with_collect_item_sig(item.id, || convert_item(self.ccx, item));\n+        self.with_collect_item_sig(item.id, || convert_item(self.tcx, item));\n         intravisit::walk_item(self, item);\n     }\n \n     fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n         for param in &generics.ty_params {\n             if param.default.is_some() {\n-                let def_id = self.ccx.tcx.hir.local_def_id(param.id);\n-                type_of_def_id(self.ccx, def_id);\n+                let def_id = self.tcx.hir.local_def_id(param.id);\n+                type_of_def_id(self.tcx, def_id);\n             }\n         }\n         intravisit::walk_generics(self, generics);\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         if let hir::ExprClosure(..) = expr.node {\n-            let def_id = self.ccx.tcx.hir.local_def_id(expr.id);\n-            generics_of_def_id(self.ccx, def_id);\n-            type_of_def_id(self.ccx, def_id);\n+            let def_id = self.tcx.hir.local_def_id(expr.id);\n+            generics_of_def_id(self.tcx, def_id);\n+            type_of_def_id(self.tcx, def_id);\n         }\n         intravisit::walk_expr(self, expr);\n     }\n \n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         if let hir::TyImplTrait(..) = ty.node {\n-            let def_id = self.ccx.tcx.hir.local_def_id(ty.id);\n-            generics_of_def_id(self.ccx, def_id);\n+            let def_id = self.tcx.hir.local_def_id(ty.id);\n+            generics_of_def_id(self.tcx, def_id);\n         }\n         intravisit::walk_ty(self, ty);\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n         self.with_collect_item_sig(trait_item.id, || {\n-            convert_trait_item(self.ccx, trait_item)\n+            convert_trait_item(self.tcx, trait_item)\n         });\n         intravisit::walk_trait_item(self, trait_item);\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n         self.with_collect_item_sig(impl_item.id, || {\n-            convert_impl_item(self.ccx, impl_item)\n+            convert_impl_item(self.tcx, impl_item)\n         });\n         intravisit::walk_impl_item(self, impl_item);\n     }\n@@ -229,127 +221,100 @@ impl<'a, 'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'a, 'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // Utility types and common code for the above passes.\n \n-impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n-    fn icx(&'a self, item_def_id: DefId) -> ItemCtxt<'a,'tcx> {\n+impl<'a, 'tcx> ItemCtxt<'a, 'tcx> {\n+    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_def_id: DefId)\n+           -> ItemCtxt<'a,'tcx> {\n         ItemCtxt {\n-            ccx: self,\n+            tcx: tcx,\n             item_def_id: item_def_id,\n         }\n     }\n+}\n \n-    fn cycle_check<F,R>(&self,\n+    fn cycle_check<F,R>(tcx: TyCtxt,\n                         span: Span,\n-                        request: AstConvRequest,\n+                        query: ty::maps::Query,\n                         code: F)\n                         -> Result<R,ErrorReported>\n         where F: FnOnce() -> Result<R,ErrorReported>\n     {\n         {\n-            let mut stack = self.stack.borrow_mut();\n-            if let Some((i, _)) = stack.iter().enumerate().rev().find(|&(_, r)| *r == request) {\n+            let mut stack = tcx.maps.query_stack.borrow_mut();\n+            if let Some((i, _)) = stack.iter().enumerate().rev().find(|&(_, q)| *q == query) {\n                 let cycle = &stack[i..];\n-                self.report_cycle(span, cycle);\n+                report_cycle(tcx, span, cycle);\n                 return Err(ErrorReported);\n             }\n-            stack.push(request);\n+            stack.push(query);\n         }\n \n         let result = code();\n \n-        self.stack.borrow_mut().pop();\n+        tcx.maps.query_stack.borrow_mut().pop();\n         result\n     }\n \n-    fn report_cycle(&self,\n+    fn report_cycle(tcx: TyCtxt,\n                     span: Span,\n-                    cycle: &[AstConvRequest])\n+                    cycle: &[ty::maps::Query])\n     {\n         assert!(!cycle.is_empty());\n-        let tcx = self.tcx;\n \n         let mut err = struct_span_err!(tcx.sess, span, E0391,\n             \"unsupported cyclic reference between types/traits detected\");\n         err.span_label(span, &format!(\"cyclic reference\"));\n \n-        match cycle[0] {\n-            AstConvRequest::GetItemType(def_id) => {\n-                err.note(\n-                    &format!(\"the cycle begins when processing `{}`...\",\n-                             tcx.item_path_str(def_id)));\n-            }\n-            AstConvRequest::EnsureSuperPredicates(def_id) => {\n-                err.note(\n-                    &format!(\"the cycle begins when computing the supertraits of `{}`...\",\n-                             tcx.item_path_str(def_id)));\n-            }\n-            AstConvRequest::GetTypeParameterBounds(id) => {\n-                err.note(\n-                    &format!(\"the cycle begins when computing the bounds \\\n-                              for type parameter `{}`...\",\n-                             ::ty_param_name(tcx, id)));\n-            }\n-        }\n-\n-        for request in &cycle[1..] {\n-            match *request {\n-                AstConvRequest::GetItemType(def_id) => {\n-                    err.note(\n-                        &format!(\"...which then requires processing `{}`...\",\n-                                 tcx.item_path_str(def_id)));\n+        let describe = |query: ty::maps::Query| {\n+            match query {\n+                ty::maps::Query::ty(def_id) => {\n+                    format!(\"processing `{}`\", tcx.item_path_str(def_id))\n                 }\n-                AstConvRequest::EnsureSuperPredicates(def_id) => {\n-                    err.note(\n-                        &format!(\"...which then requires computing the supertraits of `{}`...\",\n-                                 tcx.item_path_str(def_id)));\n+                ty::maps::Query::super_predicates(def_id) => {\n+                    format!(\"computing the supertraits of `{}`\",\n+                            tcx.item_path_str(def_id))\n                 }\n-                AstConvRequest::GetTypeParameterBounds(id) => {\n-                    err.note(\n-                        &format!(\"...which then requires computing the bounds \\\n-                                  for type parameter `{}`...\",\n-                                 ::ty_param_name(tcx, id)));\n+                ty::maps::Query::type_param_predicates(def_id) => {\n+                    let id = tcx.hir.as_local_node_id(def_id).unwrap();\n+                    format!(\"the cycle begins when computing the bounds \\\n+                             for type parameter `{}`\",\n+                            ::ty_param_name(tcx, id))\n                 }\n+                query => span_bug!(span, \"unexpected `{:?}`\", query)\n             }\n-        }\n+        };\n \n-        match cycle[0] {\n-            AstConvRequest::GetItemType(def_id) => {\n-                err.note(\n-                    &format!(\"...which then again requires processing `{}`, completing the cycle.\",\n-                             tcx.item_path_str(def_id)));\n-            }\n-            AstConvRequest::EnsureSuperPredicates(def_id) => {\n-                err.note(\n-                    &format!(\"...which then again requires computing the supertraits of `{}`, \\\n-                              completing the cycle.\",\n-                             tcx.item_path_str(def_id)));\n-            }\n-            AstConvRequest::GetTypeParameterBounds(id) => {\n-                err.note(\n-                    &format!(\"...which then again requires computing the bounds \\\n-                              for type parameter `{}`, completing the cycle.\",\n-                             ::ty_param_name(tcx, id)));\n-            }\n+        err.note(&format!(\"the cycle begins when {}...\",\n+                          describe(cycle[0])));\n+\n+        for &query in &cycle[1..] {\n+            err.note(&format!(\"...which then requires {}...\",\n+                              describe(query)));\n         }\n+\n+        err.note(&format!(\"...which then again requires {}, completing the cycle.\",\n+                          describe(cycle[0])));\n+\n         err.emit();\n     }\n \n     /// Ensure that the (transitive) super predicates for\n     /// `trait_def_id` are available. This will report a cycle error\n     /// if a trait `X` (transitively) extends itself in some form.\n-    fn ensure_super_predicates(&self, span: Span, trait_def_id: DefId)\n-                               -> Result<(), ErrorReported>\n+    fn ensure_super_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                         span: Span,\n+                                         trait_def_id: DefId)\n+                                         -> Result<(), ErrorReported>\n     {\n-        self.cycle_check(span, AstConvRequest::EnsureSuperPredicates(trait_def_id), || {\n-            let def_ids = ensure_super_predicates_step(self, trait_def_id);\n+        cycle_check(tcx, span, ty::maps::Query::super_predicates(trait_def_id), || {\n+            let def_ids = ensure_super_predicates_step(tcx, trait_def_id);\n \n             for def_id in def_ids {\n-                self.ensure_super_predicates(span, def_id)?;\n+                ensure_super_predicates(tcx, span, def_id)?;\n             }\n \n             Ok(())\n         })\n     }\n-}\n \n impl<'a,'tcx> ItemCtxt<'a,'tcx> {\n     fn to_ty(&self, ast_ty: &hir::Ty) -> Ty<'tcx> {\n@@ -358,27 +323,27 @@ impl<'a,'tcx> ItemCtxt<'a,'tcx> {\n }\n \n impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> { self.ccx.tcx }\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> { self.tcx }\n \n     fn ast_ty_to_ty_cache(&self) -> &RefCell<NodeMap<Ty<'tcx>>> {\n-        &self.ccx.ast_ty_to_ty_cache\n+        &self.tcx.ast_ty_to_ty_cache\n     }\n \n     fn get_generics(&self, id: DefId) -> &'tcx ty::Generics {\n-        generics_of_def_id(self.ccx, id)\n+        generics_of_def_id(self.tcx, id)\n     }\n \n     fn get_item_type(&self, span: Span, id: DefId) -> Ty<'tcx> {\n-        self.ccx.cycle_check(span, AstConvRequest::GetItemType(id), || {\n-            Ok(type_of_def_id(self.ccx, id))\n-        }).unwrap_or(self.ccx.tcx.types.err)\n+        cycle_check(self.tcx, span, ty::maps::Query::ty(id), || {\n+            Ok(type_of_def_id(self.tcx, id))\n+        }).unwrap_or(self.tcx.types.err)\n     }\n \n     fn get_trait_def(&self, def_id: DefId) -> &'tcx ty::TraitDef {\n-        let tcx = self.ccx.tcx;\n+        let tcx = self.tcx;\n \n         if let Some(trait_id) = tcx.hir.as_local_node_id(def_id) {\n-            trait_def_of_item(self.ccx, tcx.hir.expect_item(trait_id))\n+            trait_def_of_item(self.tcx, tcx.hir.expect_item(trait_id))\n         } else {\n             tcx.lookup_trait_def(def_id)\n         }\n@@ -392,16 +357,17 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n         debug!(\"ensure_super_predicates(trait_def_id={:?})\",\n                trait_def_id);\n \n-        self.ccx.ensure_super_predicates(span, trait_def_id)\n+        ensure_super_predicates(self.tcx, span, trait_def_id)\n     }\n \n     fn get_type_parameter_bounds(&self,\n                                  span: Span,\n                                  node_id: ast::NodeId)\n                                  -> Result<Vec<ty::PolyTraitRef<'tcx>>, ErrorReported>\n     {\n-        self.ccx.cycle_check(span, AstConvRequest::GetTypeParameterBounds(node_id), || {\n-            let v = self.ccx.get_type_parameter_bounds(self.item_def_id, node_id)\n+        let def_id = self.tcx.hir.local_def_id(node_id);\n+        cycle_check(self.tcx, span, ty::maps::Query::type_param_predicates(def_id), || {\n+            let v = get_type_parameter_bounds(self.tcx, self.item_def_id, node_id)\n                             .into_iter()\n                             .filter_map(|p| p.to_opt_poly_trait_ref())\n                             .collect();\n@@ -460,11 +426,10 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> CrateCtxt<'a, 'tcx> {\n-    fn get_type_parameter_bounds(&self,\n-                                 item_def_id: DefId,\n-                                 param_id: ast::NodeId)\n-                                 -> Vec<ty::Predicate<'tcx>>\n+    fn get_type_parameter_bounds<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                           item_def_id: DefId,\n+                                           param_id: ast::NodeId)\n+                                           -> Vec<ty::Predicate<'tcx>>\n     {\n         use rustc::hir::map::*;\n         use rustc::hir::*;\n@@ -473,21 +438,20 @@ impl<'a, 'tcx> CrateCtxt<'a, 'tcx> {\n         // written inline like `<T:Foo>` or in a where clause like\n         // `where T:Foo`.\n \n-        let tcx = self.tcx;\n         let param_owner_def_id = tcx.hir.local_def_id(::ty_param_owner(tcx, param_id));\n-        let generics = generics_of_def_id(self, param_owner_def_id);\n+        let generics = generics_of_def_id(tcx, param_owner_def_id);\n         let index = generics.type_param_to_index[&tcx.hir.local_def_id(param_id).index];\n         let ty = tcx.mk_param(index, ::ty_param_name(tcx, param_id));\n \n         // Don't look for bounds where the type parameter isn't in scope.\n         let parent = if item_def_id == param_owner_def_id {\n             None\n         } else {\n-            generics_of_def_id(self, item_def_id).parent\n+            generics_of_def_id(tcx, item_def_id).parent\n         };\n \n         let mut results = parent.map_or(vec![], |def_id| {\n-            self.get_type_parameter_bounds(def_id, param_id)\n+            get_type_parameter_bounds(tcx, def_id, param_id)\n         });\n \n         let item_node_id = tcx.hir.as_local_node_id(item_def_id).unwrap();\n@@ -519,7 +483,7 @@ impl<'a, 'tcx> CrateCtxt<'a, 'tcx> {\n                         if param_id == item_node_id {\n                             results.push(ty::TraitRef {\n                                 def_id: item_def_id,\n-                                substs: mk_item_substs(self, item_def_id)\n+                                substs: mk_item_substs(tcx, item_def_id)\n                             }.to_predicate());\n                         }\n                         generics\n@@ -538,11 +502,10 @@ impl<'a, 'tcx> CrateCtxt<'a, 'tcx> {\n             _ => return results\n         };\n \n-        let icx = self.icx(item_def_id);\n+        let icx = ItemCtxt::new(tcx, item_def_id);\n         results.extend(icx.type_parameter_bounds_in_generics(ast_generics, param_id, ty));\n         results\n     }\n-}\n \n impl<'a, 'tcx> ItemCtxt<'a, 'tcx> {\n     /// Find bounds from hir::Generics. This requires scanning through the\n@@ -570,7 +533,7 @@ impl<'a, 'tcx> ItemCtxt<'a, 'tcx> {\n                     hir::WherePredicate::BoundPredicate(ref bp) => Some(bp),\n                     _ => None\n                 })\n-                .filter(|bp| is_param(self.ccx.tcx, &bp.bounded_ty, param_id))\n+                .filter(|bp| is_param(self.tcx, &bp.bounded_ty, param_id))\n                 .flat_map(|bp| bp.bounds.iter())\n                 .flat_map(|b| predicates_from_bound(self, ty, b));\n \n@@ -600,31 +563,33 @@ fn is_param<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn convert_field<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            field: &hir::StructField,\n                            ty_f: &'tcx ty::FieldDef)\n {\n-    generics_of_def_id(ccx, ty_f.did);\n-    let tt = ccx.icx(ty_f.did).to_ty(&field.ty);\n-    ccx.tcx.maps.ty.borrow_mut().insert(ty_f.did, tt);\n-    ccx.tcx.maps.predicates.borrow_mut().insert(ty_f.did, ty::GenericPredicates {\n-        parent: Some(ccx.tcx.hir.get_parent_did(field.id)),\n+    generics_of_def_id(tcx, ty_f.did);\n+    let tt = ItemCtxt::new(tcx, ty_f.did).to_ty(&field.ty);\n+    tcx.maps.ty.borrow_mut().insert(ty_f.did, tt);\n+    tcx.maps.predicates.borrow_mut().insert(ty_f.did, ty::GenericPredicates {\n+        parent: Some(tcx.hir.get_parent_did(field.id)),\n         predicates: vec![]\n     });\n }\n \n-fn convert_method(ccx: &CrateCtxt, id: ast::NodeId, sig: &hir::MethodSig) {\n-    let def_id = ccx.tcx.hir.local_def_id(id);\n+fn convert_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            id: ast::NodeId,\n+                            sig: &hir::MethodSig) {\n+    let def_id = tcx.hir.local_def_id(id);\n \n-    let fty = AstConv::ty_of_fn(&ccx.icx(def_id), sig.unsafety, sig.abi, &sig.decl);\n-    let substs = mk_item_substs(ccx, def_id);\n-    let fty = ccx.tcx.mk_fn_def(def_id, substs, fty);\n-    ccx.tcx.maps.ty.borrow_mut().insert(def_id, fty);\n+    let fty = AstConv::ty_of_fn(&ItemCtxt::new(tcx, def_id), sig.unsafety, sig.abi, &sig.decl);\n+    let substs = mk_item_substs(tcx, def_id);\n+    let fty = tcx.mk_fn_def(def_id, substs, fty);\n+    tcx.maps.ty.borrow_mut().insert(def_id, fty);\n \n-    ty_generic_predicates(ccx, def_id, &sig.generics);\n+    ty_generic_predicates(tcx, def_id, &sig.generics);\n }\n \n-fn convert_associated_const<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn convert_associated_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                       container: AssociatedItemContainer,\n                                       id: ast::NodeId,\n                                       ty: ty::Ty<'tcx>)\n@@ -633,12 +598,12 @@ fn convert_associated_const<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         parent: Some(container.id()),\n         predicates: vec![]\n     };\n-    let def_id = ccx.tcx.hir.local_def_id(id);\n-    ccx.tcx.maps.predicates.borrow_mut().insert(def_id, predicates);\n-    ccx.tcx.maps.ty.borrow_mut().insert(def_id, ty);\n+    let def_id = tcx.hir.local_def_id(id);\n+    tcx.maps.predicates.borrow_mut().insert(def_id, predicates);\n+    tcx.maps.ty.borrow_mut().insert(def_id, ty);\n }\n \n-fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn convert_associated_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      container: AssociatedItemContainer,\n                                      id: ast::NodeId,\n                                      ty: Option<Ty<'tcx>>)\n@@ -647,18 +612,18 @@ fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         parent: Some(container.id()),\n         predicates: vec![]\n     };\n-    let def_id = ccx.tcx.hir.local_def_id(id);\n-    ccx.tcx.maps.predicates.borrow_mut().insert(def_id, predicates);\n+    let def_id = tcx.hir.local_def_id(id);\n+    tcx.maps.predicates.borrow_mut().insert(def_id, predicates);\n \n     if let Some(ty) = ty {\n-        ccx.tcx.maps.ty.borrow_mut().insert(def_id, ty);\n+        tcx.maps.ty.borrow_mut().insert(def_id, ty);\n     }\n }\n \n-fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n-                                 span: Span,\n-                                 generics: &hir::Generics,\n-                                 thing: &'static str) {\n+fn ensure_no_ty_param_bounds(tcx: TyCtxt,\n+                             span: Span,\n+                             generics: &hir::Generics,\n+                             thing: &'static str) {\n     let mut warn = false;\n \n     for ty_param in generics.ty_params.iter() {\n@@ -687,33 +652,32 @@ fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n         // eventually accept these, but it will not be\n         // part of this PR. Still, convert to warning to\n         // make bootstrapping easier.\n-        span_warn!(ccx.tcx.sess, span, E0122,\n+        span_warn!(tcx.sess, span, E0122,\n                    \"trait bounds are not (yet) enforced \\\n                    in {} definitions\",\n                    thing);\n     }\n }\n \n-fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n-    let tcx = ccx.tcx;\n+fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &hir::Item) {\n     debug!(\"convert: item {} with id {}\", it.name, it.id);\n-    let def_id = ccx.tcx.hir.local_def_id(it.id);\n-    let icx = ccx.icx(def_id);\n+    let def_id = tcx.hir.local_def_id(it.id);\n+    let icx = ItemCtxt::new(tcx, def_id);\n     match it.node {\n         // These don't define types.\n         hir::ItemExternCrate(_) | hir::ItemUse(..) | hir::ItemMod(_) => {\n         }\n         hir::ItemForeignMod(ref foreign_mod) => {\n             for item in &foreign_mod.items {\n-                convert_foreign_item(ccx, item);\n+                convert_foreign_item(tcx, item);\n             }\n         }\n         hir::ItemEnum(ref enum_definition, _) => {\n-            generics_of_def_id(ccx, def_id);\n-            predicates_of_item(ccx, it);\n-            let ty = type_of_def_id(ccx, def_id);\n-            convert_enum_variant_types(ccx,\n-                                       tcx.lookup_adt_def(ccx.tcx.hir.local_def_id(it.id)),\n+            generics_of_def_id(tcx, def_id);\n+            predicates_of_item(tcx, it);\n+            let ty = type_of_def_id(tcx, def_id);\n+            convert_enum_variant_types(tcx,\n+                                       tcx.lookup_adt_def(tcx.hir.local_def_id(it.id)),\n                                        ty,\n                                        &enum_definition.variants);\n         },\n@@ -725,157 +689,151 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n \n             tcx.record_trait_has_default_impl(trait_ref.def_id);\n \n-            tcx.maps.impl_trait_ref.borrow_mut().insert(ccx.tcx.hir.local_def_id(it.id),\n+            tcx.maps.impl_trait_ref.borrow_mut().insert(tcx.hir.local_def_id(it.id),\n                                                          Some(trait_ref));\n         }\n         hir::ItemImpl(.., ref opt_trait_ref, _, _) => {\n-            generics_of_def_id(ccx, def_id);\n-            let selfty = type_of_def_id(ccx, def_id);\n+            generics_of_def_id(tcx, def_id);\n+            let selfty = type_of_def_id(tcx, def_id);\n \n             let trait_ref = opt_trait_ref.as_ref().map(|ast_trait_ref| {\n                 AstConv::instantiate_mono_trait_ref(&icx, ast_trait_ref, selfty)\n             });\n             tcx.maps.impl_trait_ref.borrow_mut().insert(def_id, trait_ref);\n \n-            predicates_of_item(ccx, it);\n+            predicates_of_item(tcx, it);\n         },\n         hir::ItemTrait(..) => {\n-            generics_of_def_id(ccx, def_id);\n-            trait_def_of_item(ccx, it);\n+            generics_of_def_id(tcx, def_id);\n+            trait_def_of_item(tcx, it);\n             let _: Result<(), ErrorReported> = // any error is already reported, can ignore\n-                ccx.ensure_super_predicates(it.span, def_id);\n-            predicates_of_item(ccx, it);\n+                ensure_super_predicates(tcx, it.span, def_id);\n+            predicates_of_item(tcx, it);\n         },\n         hir::ItemStruct(ref struct_def, _) |\n         hir::ItemUnion(ref struct_def, _) => {\n-            generics_of_def_id(ccx, def_id);\n-            predicates_of_item(ccx, it);\n-            let ty = type_of_def_id(ccx, def_id);\n+            generics_of_def_id(tcx, def_id);\n+            predicates_of_item(tcx, it);\n+            let ty = type_of_def_id(tcx, def_id);\n \n             let variant = tcx.lookup_adt_def(def_id).struct_variant();\n \n             for (f, ty_f) in struct_def.fields().iter().zip(variant.fields.iter()) {\n-                convert_field(ccx, f, ty_f)\n+                convert_field(tcx, f, ty_f)\n             }\n \n             if !struct_def.is_struct() {\n-                convert_variant_ctor(ccx, struct_def.id(), variant, ty);\n+                convert_variant_ctor(tcx, struct_def.id(), variant, ty);\n             }\n         },\n         hir::ItemTy(_, ref generics) => {\n-            ensure_no_ty_param_bounds(ccx, it.span, generics, \"type\");\n-            generics_of_def_id(ccx, def_id);\n-            predicates_of_item(ccx, it);\n-            type_of_def_id(ccx, def_id);\n+            ensure_no_ty_param_bounds(tcx, it.span, generics, \"type\");\n+            generics_of_def_id(tcx, def_id);\n+            predicates_of_item(tcx, it);\n+            type_of_def_id(tcx, def_id);\n         },\n         _ => {\n-            generics_of_def_id(ccx, def_id);\n-            predicates_of_item(ccx, it);\n-            type_of_def_id(ccx, def_id);\n+            generics_of_def_id(tcx, def_id);\n+            predicates_of_item(tcx, it);\n+            type_of_def_id(tcx, def_id);\n         },\n     }\n }\n \n-fn convert_trait_item(ccx: &CrateCtxt, trait_item: &hir::TraitItem) {\n-    let tcx = ccx.tcx;\n-\n+fn convert_trait_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_item: &hir::TraitItem) {\n     // we can lookup details about the trait because items are visited\n     // before trait-items\n     let trait_def_id = tcx.hir.get_parent_did(trait_item.id);\n \n-    let def_id = ccx.tcx.hir.local_def_id(trait_item.id);\n+    let def_id = tcx.hir.local_def_id(trait_item.id);\n     match trait_item.node {\n         hir::TraitItemKind::Const(ref ty, _) => {\n-            generics_of_def_id(ccx, def_id);\n-            let ty = ccx.icx(def_id).to_ty(&ty);\n-            convert_associated_const(ccx,\n+            generics_of_def_id(tcx, def_id);\n+            let ty = ItemCtxt::new(tcx, def_id).to_ty(&ty);\n+            convert_associated_const(tcx,\n                                      TraitContainer(trait_def_id),\n                                      trait_item.id,\n                                      ty);\n         }\n \n         hir::TraitItemKind::Type(_, ref opt_ty) => {\n-            generics_of_def_id(ccx, def_id);\n+            generics_of_def_id(tcx, def_id);\n \n-            let typ = opt_ty.as_ref().map(|ty| ccx.icx(def_id).to_ty(&ty));\n+            let typ = opt_ty.as_ref().map(|ty| ItemCtxt::new(tcx, def_id).to_ty(&ty));\n \n-            convert_associated_type(ccx, TraitContainer(trait_def_id), trait_item.id, typ);\n+            convert_associated_type(tcx, TraitContainer(trait_def_id), trait_item.id, typ);\n         }\n \n         hir::TraitItemKind::Method(ref sig, _) => {\n-            convert_method(ccx, trait_item.id, sig);\n+            convert_method(tcx, trait_item.id, sig);\n         }\n     }\n }\n \n-fn convert_impl_item(ccx: &CrateCtxt, impl_item: &hir::ImplItem) {\n-    let tcx = ccx.tcx;\n-\n+fn convert_impl_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_item: &hir::ImplItem) {\n     // we can lookup details about the impl because items are visited\n     // before impl-items\n     let impl_def_id = tcx.hir.get_parent_did(impl_item.id);\n \n-    let def_id = ccx.tcx.hir.local_def_id(impl_item.id);\n+    let def_id = tcx.hir.local_def_id(impl_item.id);\n     match impl_item.node {\n         hir::ImplItemKind::Const(ref ty, _) => {\n-            generics_of_def_id(ccx, def_id);\n-            let ty = ccx.icx(def_id).to_ty(&ty);\n-            convert_associated_const(ccx,\n+            generics_of_def_id(tcx, def_id);\n+            let ty = ItemCtxt::new(tcx, def_id).to_ty(&ty);\n+            convert_associated_const(tcx,\n                                      ImplContainer(impl_def_id),\n                                      impl_item.id,\n                                      ty);\n         }\n \n         hir::ImplItemKind::Type(ref ty) => {\n-            generics_of_def_id(ccx, def_id);\n+            generics_of_def_id(tcx, def_id);\n \n             if tcx.impl_trait_ref(impl_def_id).is_none() {\n                 span_err!(tcx.sess, impl_item.span, E0202,\n                           \"associated types are not allowed in inherent impls\");\n             }\n \n-            let typ = ccx.icx(def_id).to_ty(ty);\n+            let typ = ItemCtxt::new(tcx, def_id).to_ty(ty);\n \n-            convert_associated_type(ccx, ImplContainer(impl_def_id), impl_item.id, Some(typ));\n+            convert_associated_type(tcx, ImplContainer(impl_def_id), impl_item.id, Some(typ));\n         }\n \n         hir::ImplItemKind::Method(ref sig, _) => {\n-            convert_method(ccx, impl_item.id, sig);\n+            convert_method(tcx, impl_item.id, sig);\n         }\n     }\n }\n \n-fn convert_variant_ctor<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn convert_variant_ctor<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   ctor_id: ast::NodeId,\n                                   variant: &'tcx ty::VariantDef,\n                                   ty: Ty<'tcx>) {\n-    let tcx = ccx.tcx;\n     let def_id = tcx.hir.local_def_id(ctor_id);\n-    generics_of_def_id(ccx, def_id);\n+    generics_of_def_id(tcx, def_id);\n     let ctor_ty = match variant.ctor_kind {\n         CtorKind::Fictive | CtorKind::Const => ty,\n         CtorKind::Fn => {\n             let inputs = variant.fields.iter().map(|field| tcx.item_type(field.did));\n-            let substs = mk_item_substs(ccx, def_id);\n+            let substs = mk_item_substs(tcx, def_id);\n             tcx.mk_fn_def(def_id, substs, tcx.mk_bare_fn(ty::BareFnTy {\n                 unsafety: hir::Unsafety::Normal,\n                 abi: abi::Abi::Rust,\n-                sig: ty::Binder(ccx.tcx.mk_fn_sig(inputs, ty, false))\n+                sig: ty::Binder(tcx.mk_fn_sig(inputs, ty, false))\n             }))\n         }\n     };\n     tcx.maps.ty.borrow_mut().insert(def_id, ctor_ty);\n     tcx.maps.predicates.borrow_mut().insert(def_id, ty::GenericPredicates {\n-        parent: Some(ccx.tcx.hir.get_parent_did(ctor_id)),\n+        parent: Some(tcx.hir.get_parent_did(ctor_id)),\n         predicates: vec![]\n     });\n }\n \n-fn convert_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn convert_enum_variant_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         def: &'tcx ty::AdtDef,\n                                         ty: Ty<'tcx>,\n                                         variants: &[hir::Variant]) {\n-    let tcx = ccx.tcx;\n     let repr_hints = tcx.lookup_repr_hints(def.did);\n     let repr_type = tcx.enum_repr_type(repr_hints.get(0));\n     let initial = repr_type.initial_discriminant(tcx);\n@@ -885,7 +843,7 @@ fn convert_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     for (variant, ty_variant) in variants.iter().zip(def.variants.iter()) {\n         let wrapped_discr = prev_discr.map_or(initial, |d| d.wrap_incr());\n         prev_discr = Some(if let Some(e) = variant.node.disr_expr {\n-            let result = evaluate_disr_expr(ccx, repr_type, e);\n+            let result = evaluate_disr_expr(tcx, repr_type, e);\n \n             let expr_did = tcx.hir.local_def_id(e.node_id);\n             tcx.maps.monomorphic_const_eval.borrow_mut()\n@@ -906,28 +864,28 @@ fn convert_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         }.unwrap_or(wrapped_discr));\n \n         for (f, ty_f) in variant.node.data.fields().iter().zip(ty_variant.fields.iter()) {\n-            convert_field(ccx, f, ty_f)\n+            convert_field(tcx, f, ty_f)\n         }\n \n         // Convert the ctor, if any. This also registers the variant as\n         // an item.\n-        convert_variant_ctor(ccx, variant.node.data.id(), ty_variant, ty);\n+        convert_variant_ctor(tcx, variant.node.data.id(), ty_variant, ty);\n     }\n }\n \n-fn convert_struct_variant<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn convert_struct_variant<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                     did: DefId,\n                                     name: ast::Name,\n                                     discr: ty::VariantDiscr,\n                                     def: &hir::VariantData)\n                                     -> ty::VariantDef {\n     let mut seen_fields: FxHashMap<ast::Name, Span> = FxHashMap();\n-    let node_id = ccx.tcx.hir.as_local_node_id(did).unwrap();\n+    let node_id = tcx.hir.as_local_node_id(did).unwrap();\n     let fields = def.fields().iter().map(|f| {\n-        let fid = ccx.tcx.hir.local_def_id(f.id);\n+        let fid = tcx.hir.local_def_id(f.id);\n         let dup_span = seen_fields.get(&f.name).cloned();\n         if let Some(prev_span) = dup_span {\n-            struct_span_err!(ccx.tcx.sess, f.span, E0124,\n+            struct_span_err!(tcx.sess, f.span, E0124,\n                              \"field `{}` is already declared\",\n                              f.name)\n                 .span_label(f.span, &\"field already declared\")\n@@ -940,7 +898,7 @@ fn convert_struct_variant<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         ty::FieldDef {\n             did: fid,\n             name: f.name,\n-            vis: ty::Visibility::from_hir(&f.vis, node_id, ccx.tcx)\n+            vis: ty::Visibility::from_hir(&f.vis, node_id, tcx)\n         }\n     }).collect();\n     ty::VariantDef {\n@@ -952,56 +910,58 @@ fn convert_struct_variant<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-fn convert_struct_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn convert_struct_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 it: &hir::Item,\n                                 def: &hir::VariantData)\n                                 -> &'tcx ty::AdtDef\n {\n-    let did = ccx.tcx.hir.local_def_id(it.id);\n+    let did = tcx.hir.local_def_id(it.id);\n     // Use separate constructor id for unit/tuple structs and reuse did for braced structs.\n-    let ctor_id = if !def.is_struct() { Some(ccx.tcx.hir.local_def_id(def.id())) } else { None };\n-    let variants = vec![convert_struct_variant(ccx, ctor_id.unwrap_or(did), it.name,\n+    let ctor_id = if !def.is_struct() { Some(tcx.hir.local_def_id(def.id())) } else { None };\n+    let variants = vec![convert_struct_variant(tcx, ctor_id.unwrap_or(did), it.name,\n                                                ty::VariantDiscr::Relative(0), def)];\n-    let adt = ccx.tcx.alloc_adt_def(did, AdtKind::Struct, variants,\n-        ReprOptions::new(&ccx.tcx, did));\n+    let adt = tcx.alloc_adt_def(did, AdtKind::Struct, variants,\n+        ReprOptions::new(tcx, did));\n     if let Some(ctor_id) = ctor_id {\n         // Make adt definition available through constructor id as well.\n-        ccx.tcx.maps.adt_def.borrow_mut().insert(ctor_id, adt);\n+        tcx.maps.adt_def.borrow_mut().insert(ctor_id, adt);\n     }\n \n-    ccx.tcx.maps.adt_def.borrow_mut().insert(did, adt);\n+    tcx.maps.adt_def.borrow_mut().insert(did, adt);\n     adt\n }\n \n-fn convert_union_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn convert_union_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 it: &hir::Item,\n                                 def: &hir::VariantData)\n                                 -> &'tcx ty::AdtDef\n {\n-    let did = ccx.tcx.hir.local_def_id(it.id);\n-    let variants = vec![convert_struct_variant(ccx, did, it.name,\n+    let did = tcx.hir.local_def_id(it.id);\n+    let variants = vec![convert_struct_variant(tcx, did, it.name,\n                                                ty::VariantDiscr::Relative(0), def)];\n \n-    let adt = ccx.tcx.alloc_adt_def(did, AdtKind::Union, variants, ReprOptions::new(&ccx.tcx, did));\n-    ccx.tcx.maps.adt_def.borrow_mut().insert(did, adt);\n+    let adt = tcx.alloc_adt_def(did, AdtKind::Union, variants, ReprOptions::new(tcx, did));\n+    tcx.maps.adt_def.borrow_mut().insert(did, adt);\n     adt\n }\n \n-fn evaluate_disr_expr(ccx: &CrateCtxt, repr_ty: attr::IntType, body: hir::BodyId)\n+fn evaluate_disr_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                repr_ty: attr::IntType,\n+                                body: hir::BodyId)\n                       -> Result<ConstInt, ()> {\n-    let e = &ccx.tcx.hir.body(body).value;\n-    debug!(\"disr expr, checking {}\", ccx.tcx.hir.node_to_pretty_string(e.id));\n+    let e = &tcx.hir.body(body).value;\n+    debug!(\"disr expr, checking {}\", tcx.hir.node_to_pretty_string(e.id));\n \n-    let ty_hint = repr_ty.to_ty(ccx.tcx);\n+    let ty_hint = repr_ty.to_ty(tcx);\n     let print_err = |cv: ConstVal| {\n-        struct_span_err!(ccx.tcx.sess, e.span, E0079, \"mismatched types\")\n+        struct_span_err!(tcx.sess, e.span, E0079, \"mismatched types\")\n             .note_expected_found(&\"type\", &ty_hint, &format!(\"{}\", cv.description()))\n             .span_label(e.span, &format!(\"expected '{}' type\", ty_hint))\n             .emit();\n     };\n \n     let hint = UncheckedExprHint(ty_hint);\n-    match ConstContext::new(ccx.tcx, body).eval(e, hint) {\n+    match ConstContext::new(tcx, body).eval(e, hint) {\n         Ok(ConstVal::Integral(i)) => {\n             // FIXME: eval should return an error if the hint does not match the type of the body.\n             // i.e. eventually the match below would not exist.\n@@ -1032,19 +992,18 @@ fn evaluate_disr_expr(ccx: &CrateCtxt, repr_ty: attr::IntType, body: hir::BodyId\n         // so we need to report the real error\n         Err(err) => {\n             let mut diag = report_const_eval_err(\n-                ccx.tcx, &err, e.span, \"enum discriminant\");\n+                tcx, &err, e.span, \"enum discriminant\");\n             diag.emit();\n             Err(())\n         }\n     }\n }\n \n-fn convert_enum_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn convert_enum_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               it: &hir::Item,\n                               def: &hir::EnumDef)\n                               -> &'tcx ty::AdtDef\n {\n-    let tcx = ccx.tcx;\n     let mut distance_from_explicit = 0;\n     let variants = def.variants.iter().map(|v| {\n         let did = tcx.hir.local_def_id(v.node.data.id());\n@@ -1056,11 +1015,11 @@ fn convert_enum_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         };\n         distance_from_explicit += 1;\n \n-        convert_struct_variant(ccx, did, v.node.name, discr, &v.node.data)\n+        convert_struct_variant(tcx, did, v.node.name, discr, &v.node.data)\n     }).collect();\n \n     let did = tcx.hir.local_def_id(it.id);\n-    let adt = tcx.alloc_adt_def(did, AdtKind::Enum, variants, ReprOptions::new(&ccx.tcx, did));\n+    let adt = tcx.alloc_adt_def(did, AdtKind::Enum, variants, ReprOptions::new(tcx, did));\n     tcx.maps.adt_def.borrow_mut().insert(did, adt);\n     adt\n }\n@@ -1072,12 +1031,10 @@ fn convert_enum_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n /// above. Returns a list of trait def-ids that must be ensured as\n /// well to guarantee that the transitive superpredicates are\n /// converted.\n-fn ensure_super_predicates_step(ccx: &CrateCtxt,\n-                                trait_def_id: DefId)\n-                                -> Vec<DefId>\n+fn ensure_super_predicates_step<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                          trait_def_id: DefId)\n+                                          -> Vec<DefId>\n {\n-    let tcx = ccx.tcx;\n-\n     debug!(\"ensure_super_predicates_step(trait_def_id={:?})\", trait_def_id);\n \n     let trait_node_id = if let Some(n) = tcx.hir.as_local_node_id(trait_def_id) {\n@@ -1093,7 +1050,7 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n \n     let superpredicates = tcx.maps.super_predicates.borrow().get(&trait_def_id).cloned();\n     let superpredicates = superpredicates.unwrap_or_else(|| {\n-        let item = match ccx.tcx.hir.get(trait_node_id) {\n+        let item = match tcx.hir.get(trait_node_id) {\n             hir_map::NodeItem(item) => item,\n             _ => bug!(\"trait_node_id {} is not an item\", trait_node_id)\n         };\n@@ -1104,7 +1061,7 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n                            \"ensure_super_predicates_step invoked on non-trait\"),\n         };\n \n-        let icx = ccx.icx(trait_def_id);\n+        let icx = ItemCtxt::new(tcx, trait_def_id);\n \n         // Convert the bounds that follow the colon, e.g. `Bar+Zed` in `trait Foo : Bar+Zed`.\n         let self_param_ty = tcx.mk_self_type();\n@@ -1146,8 +1103,7 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n     def_ids\n }\n \n-fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item) -> &'tcx ty::TraitDef {\n-    let tcx = ccx.tcx;\n+fn trait_def_of_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &hir::Item) -> &'tcx ty::TraitDef {\n     let def_id = tcx.hir.local_def_id(it.id);\n \n     tcx.maps.trait_def.memoize(def_id, || {\n@@ -1173,10 +1129,9 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item) -> &'t\n     })\n }\n \n-fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn generics_of_def_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 def_id: DefId)\n                                 -> &'tcx ty::Generics {\n-    let tcx = ccx.tcx;\n     let node_id = if let Some(id) = tcx.hir.as_local_node_id(def_id) {\n         id\n     } else {\n@@ -1284,7 +1239,7 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         let mut parent_has_self = false;\n         let mut own_start = has_self as u32;\n         let (parent_regions, parent_types) = parent_def_id.map_or((0, 0), |def_id| {\n-            let generics = generics_of_def_id(ccx, def_id);\n+            let generics = generics_of_def_id(tcx, def_id);\n             assert_eq!(has_self, false);\n             parent_has_self = generics.has_self;\n             own_start = generics.count() as u32;\n@@ -1294,7 +1249,7 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n         let early_lifetimes = early_bound_lifetimes_from_generics(tcx, ast_generics);\n         let regions = early_lifetimes.enumerate().map(|(i, l)| {\n-            let issue_32330 = ccx.tcx.named_region_map.issue_32330\n+            let issue_32330 = tcx.named_region_map.issue_32330\n                                                       .get(&l.lifetime.id)\n                                                       .cloned();\n             ty::RegionParameterDef {\n@@ -1372,24 +1327,24 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     })\n }\n \n-fn type_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn type_of_def_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             def_id: DefId)\n                             -> Ty<'tcx> {\n-    let node_id = if let Some(id) = ccx.tcx.hir.as_local_node_id(def_id) {\n+    let node_id = if let Some(id) = tcx.hir.as_local_node_id(def_id) {\n         id\n     } else {\n-        return ccx.tcx.item_type(def_id);\n+        return tcx.item_type(def_id);\n     };\n-    ccx.tcx.maps.ty.memoize(def_id, || {\n+    tcx.maps.ty.memoize(def_id, || {\n         use rustc::hir::map::*;\n         use rustc::hir::*;\n \n         // Alway bring in generics, as computing the type needs them.\n-        generics_of_def_id(ccx, def_id);\n+        generics_of_def_id(tcx, def_id);\n \n-        let icx = ccx.icx(def_id);\n+        let icx = ItemCtxt::new(tcx, def_id);\n \n-        match ccx.tcx.hir.get(node_id) {\n+        match tcx.hir.get(node_id) {\n             NodeItem(item) => {\n                 match item.node {\n                     ItemStatic(ref t, ..) | ItemConst(ref t, _) |\n@@ -1398,23 +1353,23 @@ fn type_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     }\n                     ItemFn(ref decl, unsafety, _, abi, _, _) => {\n                         let tofd = AstConv::ty_of_fn(&icx, unsafety, abi, &decl);\n-                        let substs = mk_item_substs(ccx, def_id);\n-                        ccx.tcx.mk_fn_def(def_id, substs, tofd)\n+                        let substs = mk_item_substs(tcx, def_id);\n+                        tcx.mk_fn_def(def_id, substs, tofd)\n                     }\n                     ItemEnum(ref ei, _) => {\n-                        let def = convert_enum_def(ccx, item, ei);\n-                        let substs = mk_item_substs(ccx, def_id);\n-                        ccx.tcx.mk_adt(def, substs)\n+                        let def = convert_enum_def(tcx, item, ei);\n+                        let substs = mk_item_substs(tcx, def_id);\n+                        tcx.mk_adt(def, substs)\n                     }\n                     ItemStruct(ref si, _) => {\n-                        let def = convert_struct_def(ccx, item, si);\n-                        let substs = mk_item_substs(ccx, def_id);\n-                        ccx.tcx.mk_adt(def, substs)\n+                        let def = convert_struct_def(tcx, item, si);\n+                        let substs = mk_item_substs(tcx, def_id);\n+                        tcx.mk_adt(def, substs)\n                     }\n                     ItemUnion(ref un, _) => {\n-                        let def = convert_union_def(ccx, item, un);\n-                        let substs = mk_item_substs(ccx, def_id);\n-                        ccx.tcx.mk_adt(def, substs)\n+                        let def = convert_union_def(tcx, item, un);\n+                        let substs = mk_item_substs(tcx, def_id);\n+                        tcx.mk_adt(def, substs)\n                     }\n                     ItemDefaultImpl(..) |\n                     ItemTrait(..) |\n@@ -1430,23 +1385,23 @@ fn type_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 }\n             }\n             NodeForeignItem(foreign_item) => {\n-                let abi = ccx.tcx.hir.get_foreign_abi(node_id);\n+                let abi = tcx.hir.get_foreign_abi(node_id);\n \n                 match foreign_item.node {\n                     ForeignItemFn(ref fn_decl, _, _) => {\n-                        compute_type_of_foreign_fn_decl(ccx, def_id, fn_decl, abi)\n+                        compute_type_of_foreign_fn_decl(tcx, def_id, fn_decl, abi)\n                     }\n                     ForeignItemStatic(ref t, _) => icx.to_ty(t)\n                 }\n             }\n             NodeExpr(&hir::Expr { node: hir::ExprClosure(..), .. }) => {\n-                ccx.tcx.mk_closure(def_id, Substs::for_item(\n-                    ccx.tcx, def_id,\n+                tcx.mk_closure(def_id, Substs::for_item(\n+                    tcx, def_id,\n                     |def, _| {\n                         let region = def.to_early_bound_region_data();\n-                        ccx.tcx.mk_region(ty::ReEarlyBound(region))\n+                        tcx.mk_region(ty::ReEarlyBound(region))\n                     },\n-                    |def, _| ccx.tcx.mk_param_from_def(def)\n+                    |def, _| tcx.mk_param_from_def(def)\n                 ))\n             }\n             NodeTyParam(&hir::TyParam { default: Some(ref ty), .. }) => {\n@@ -1459,8 +1414,8 @@ fn type_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     })\n }\n \n-fn predicates_of_item(ccx: &CrateCtxt, it: &hir::Item) {\n-    let def_id = ccx.tcx.hir.local_def_id(it.id);\n+fn predicates_of_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &hir::Item) {\n+    let def_id = tcx.hir.local_def_id(it.id);\n \n     let no_generics = hir::Generics::empty();\n     let generics = match it.node {\n@@ -1474,27 +1429,27 @@ fn predicates_of_item(ccx: &CrateCtxt, it: &hir::Item) {\n         _ => &no_generics\n     };\n \n-    ty_generic_predicates(ccx, def_id, generics);\n+    ty_generic_predicates(tcx, def_id, generics);\n }\n \n-fn convert_foreign_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn convert_foreign_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   it: &hir::ForeignItem)\n {\n     // For reasons I cannot fully articulate, I do so hate the AST\n     // map, and I regard each time that I use it as a personal and\n     // moral failing, but at the moment it seems like the only\n     // convenient way to extract the ABI. - ndm\n-    let def_id = ccx.tcx.hir.local_def_id(it.id);\n-    generics_of_def_id(ccx, def_id);\n-    type_of_def_id(ccx, def_id);\n+    let def_id = tcx.hir.local_def_id(it.id);\n+    generics_of_def_id(tcx, def_id);\n+    type_of_def_id(tcx, def_id);\n \n     let no_generics = hir::Generics::empty();\n     let generics = match it.node {\n         hir::ForeignItemFn(_, _, ref generics) => generics,\n         hir::ForeignItemStatic(..) => &no_generics\n     };\n \n-    ty_generic_predicates(ccx, def_id, generics);\n+    ty_generic_predicates(tcx, def_id, generics);\n }\n \n // Is it marked with ?Sized\n@@ -1557,10 +1512,11 @@ fn early_bound_lifetimes_from_generics<'a, 'tcx>(\n         .filter(move |l| !tcx.named_region_map.late_bound.contains(&l.lifetime.id))\n }\n \n-fn ty_generic_predicates(ccx: &CrateCtxt, def_id: DefId, ast_generics: &hir::Generics) {\n-    let tcx = ccx.tcx;\n-    let icx = ccx.icx(def_id);\n-    let generics = generics_of_def_id(ccx, def_id);\n+fn ty_generic_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                   def_id: DefId,\n+                                   ast_generics: &hir::Generics) {\n+    let icx = ItemCtxt::new(tcx, def_id);\n+    let generics = generics_of_def_id(tcx, def_id);\n     let parent_count = generics.parent_count() as u32;\n     let has_own_self = generics.has_self && parent_count == 0;\n \n@@ -1573,11 +1529,11 @@ fn ty_generic_predicates(ccx: &CrateCtxt, def_id: DefId, ast_generics: &hir::Gen\n                 hir::ItemTrait(.., ref items) => {\n                     (Some((ty::TraitRef {\n                         def_id: def_id,\n-                        substs: mk_item_substs(ccx, def_id)\n+                        substs: mk_item_substs(tcx, def_id)\n                     }, items)), None)\n                 }\n                 hir::ItemImpl(..) => {\n-                    let self_ty = type_of_def_id(ccx, def_id);\n+                    let self_ty = type_of_def_id(tcx, def_id);\n                     let trait_ref = tcx.impl_trait_ref(def_id);\n                     (None, Some((self_ty, trait_ref)))\n                 }\n@@ -1695,7 +1651,7 @@ fn ty_generic_predicates(ccx: &CrateCtxt, def_id: DefId, ast_generics: &hir::Gen\n \n             let assoc_ty = tcx.mk_projection(self_trait_ref, trait_item.name);\n \n-            let bounds = compute_bounds(&ccx.icx(def_id),\n+            let bounds = compute_bounds(&ItemCtxt::new(tcx, def_id),\n                                         assoc_ty,\n                                         bounds,\n                                         SizedByDefault::Yes,\n@@ -1809,24 +1765,24 @@ fn predicates_from_bound<'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n }\n \n fn compute_type_of_foreign_fn_decl<'a, 'tcx>(\n-    ccx: &CrateCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     def_id: DefId,\n     decl: &hir::FnDecl,\n     abi: abi::Abi)\n     -> Ty<'tcx>\n {\n-    let fty = AstConv::ty_of_fn(&ccx.icx(def_id), hir::Unsafety::Unsafe, abi, decl);\n+    let fty = AstConv::ty_of_fn(&ItemCtxt::new(tcx, def_id), hir::Unsafety::Unsafe, abi, decl);\n \n     // feature gate SIMD types in FFI, since I (huonw) am not sure the\n     // ABIs are handled at all correctly.\n     if abi != abi::Abi::RustIntrinsic && abi != abi::Abi::PlatformIntrinsic\n-            && !ccx.tcx.sess.features.borrow().simd_ffi {\n+            && !tcx.sess.features.borrow().simd_ffi {\n         let check = |ast_ty: &hir::Ty, ty: ty::Ty| {\n             if ty.is_simd() {\n-                ccx.tcx.sess.struct_span_err(ast_ty.span,\n+                tcx.sess.struct_span_err(ast_ty.span,\n                               &format!(\"use of SIMD type `{}` in FFI is highly experimental and \\\n                                         may result in invalid code\",\n-                                       ccx.tcx.hir.node_to_pretty_string(ast_ty.id)))\n+                                       tcx.hir.node_to_pretty_string(ast_ty.id)))\n                     .help(\"add #![feature(simd_ffi)] to the crate attributes to enable\")\n                     .emit();\n             }\n@@ -1839,15 +1795,15 @@ fn compute_type_of_foreign_fn_decl<'a, 'tcx>(\n         }\n     }\n \n-    let substs = mk_item_substs(ccx, def_id);\n-    ccx.tcx.mk_fn_def(def_id, substs, fty)\n+    let substs = mk_item_substs(tcx, def_id);\n+    tcx.mk_fn_def(def_id, substs, fty)\n }\n \n-fn mk_item_substs<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn mk_item_substs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             def_id: DefId)\n                             -> &'tcx Substs<'tcx> {\n     // FIXME(eddyb) Do this request from Substs::for_item in librustc.\n-    generics_of_def_id(ccx, def_id);\n+    generics_of_def_id(tcx, def_id);\n \n-    Substs::identity_for_item(ccx.tcx, def_id)\n+    Substs::identity_for_item(tcx, def_id)\n }"}, {"sha": "3df25825a71f66328f1a313d2969cd472cc3376b", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=4649f7387ea334901c78dd48c1e1659ecf80cfcc", "patch": "@@ -23,14 +23,12 @@ use rustc::dep_graph::DepNode;\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::def_id::DefId;\n-use rustc::ty;\n+use rustc::ty::{self, TyCtxt};\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n \n use syntax_pos::Span;\n \n-use CrateCtxt;\n-\n /// Checks that all the type/lifetime parameters on an impl also\n /// appear in the trait ref or self-type (or are constrained by a\n /// where-clause). These rules are needed to ensure that, given a\n@@ -61,27 +59,27 @@ use CrateCtxt;\n /// impl<'a> Trait<Foo> for Bar { type X = &'a i32; }\n ///      ^ 'a is unused and appears in assoc type, error\n /// ```\n-pub fn impl_wf_check<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>) {\n+pub fn impl_wf_check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     // We will tag this as part of the WF check -- logically, it is,\n     // but it's one that we must perform earlier than the rest of\n     // WfCheck.\n-    ccx.tcx.visit_all_item_likes_in_krate(DepNode::WfCheck, &mut ImplWfCheck { ccx: ccx });\n+    tcx.visit_all_item_likes_in_krate(DepNode::WfCheck, &mut ImplWfCheck { tcx: tcx });\n }\n \n struct ImplWfCheck<'a, 'tcx: 'a> {\n-    ccx: &'a CrateCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n impl<'a, 'tcx> ItemLikeVisitor<'tcx> for ImplWfCheck<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         match item.node {\n             hir::ItemImpl(.., ref generics, _, _, ref impl_item_refs) => {\n-                let impl_def_id = self.ccx.tcx.hir.local_def_id(item.id);\n-                enforce_impl_params_are_constrained(self.ccx,\n+                let impl_def_id = self.tcx.hir.local_def_id(item.id);\n+                enforce_impl_params_are_constrained(self.tcx,\n                                                     generics,\n                                                     impl_def_id,\n                                                     impl_item_refs);\n-                enforce_impl_items_are_distinct(self.ccx, impl_item_refs);\n+                enforce_impl_items_are_distinct(self.tcx, impl_item_refs);\n             }\n             _ => { }\n         }\n@@ -92,16 +90,16 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for ImplWfCheck<'a, 'tcx> {\n     fn visit_impl_item(&mut self, _impl_item: &'tcx hir::ImplItem) { }\n }\n \n-fn enforce_impl_params_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn enforce_impl_params_are_constrained<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                  impl_hir_generics: &hir::Generics,\n                                                  impl_def_id: DefId,\n                                                  impl_item_refs: &[hir::ImplItemRef])\n {\n     // Every lifetime used in an associated type must be constrained.\n-    let impl_self_ty = ccx.tcx.item_type(impl_def_id);\n-    let impl_generics = ccx.tcx.item_generics(impl_def_id);\n-    let impl_predicates = ccx.tcx.item_predicates(impl_def_id);\n-    let impl_trait_ref = ccx.tcx.impl_trait_ref(impl_def_id);\n+    let impl_self_ty = tcx.item_type(impl_def_id);\n+    let impl_generics = tcx.item_generics(impl_def_id);\n+    let impl_predicates = tcx.item_predicates(impl_def_id);\n+    let impl_trait_ref = tcx.impl_trait_ref(impl_def_id);\n \n     let mut input_parameters = ctp::parameters_for_impl(impl_self_ty, impl_trait_ref);\n     ctp::identify_constrained_type_params(\n@@ -111,19 +109,19 @@ fn enforce_impl_params_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     for (ty_param, param) in impl_generics.types.iter().zip(&impl_hir_generics.ty_params) {\n         let param_ty = ty::ParamTy::for_def(ty_param);\n         if !input_parameters.contains(&ctp::Parameter::from(param_ty)) {\n-            report_unused_parameter(ccx, param.span, \"type\", &param_ty.to_string());\n+            report_unused_parameter(tcx, param.span, \"type\", &param_ty.to_string());\n         }\n     }\n \n     // Disallow unconstrained lifetimes, but only if they appear in assoc types.\n     let lifetimes_in_associated_types: FxHashSet<_> = impl_item_refs.iter()\n-        .map(|item_ref|  ccx.tcx.hir.local_def_id(item_ref.id.node_id))\n+        .map(|item_ref|  tcx.hir.local_def_id(item_ref.id.node_id))\n         .filter(|&def_id| {\n-            let item = ccx.tcx.associated_item(def_id);\n+            let item = tcx.associated_item(def_id);\n             item.kind == ty::AssociatedKind::Type && item.defaultness.has_value()\n         })\n         .flat_map(|def_id| {\n-            ctp::parameters_for(&ccx.tcx.item_type(def_id), true)\n+            ctp::parameters_for(&tcx.item_type(def_id), true)\n         }).collect();\n     for (ty_lifetime, lifetime) in impl_generics.regions.iter()\n         .zip(&impl_hir_generics.lifetimes)\n@@ -134,7 +132,7 @@ fn enforce_impl_params_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             lifetimes_in_associated_types.contains(&param) && // (*)\n             !input_parameters.contains(&param)\n         {\n-            report_unused_parameter(ccx, lifetime.lifetime.span,\n+            report_unused_parameter(tcx, lifetime.lifetime.span,\n                                     \"lifetime\", &lifetime.lifetime.name.to_string());\n         }\n     }\n@@ -159,13 +157,13 @@ fn enforce_impl_params_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // used elsewhere are not projected back out.\n }\n \n-fn report_unused_parameter(ccx: &CrateCtxt,\n+fn report_unused_parameter(tcx: TyCtxt,\n                            span: Span,\n                            kind: &str,\n                            name: &str)\n {\n     struct_span_err!(\n-        ccx.tcx.sess, span, E0207,\n+        tcx.sess, span, E0207,\n         \"the {} parameter `{}` is not constrained by the \\\n         impl trait, self type, or predicates\",\n         kind, name)\n@@ -174,10 +172,9 @@ fn report_unused_parameter(ccx: &CrateCtxt,\n }\n \n /// Enforce that we do not have two items in an impl with the same name.\n-fn enforce_impl_items_are_distinct<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn enforce_impl_items_are_distinct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                              impl_item_refs: &[hir::ImplItemRef])\n {\n-    let tcx = ccx.tcx;\n     let mut seen_type_items = FxHashMap();\n     let mut seen_value_items = FxHashMap();\n     for impl_item_ref in impl_item_refs {"}, {"sha": "ddd8d9259cc99830ae249b44c804745af1b2c6ba", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 26, "deletions": 60, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=4649f7387ea334901c78dd48c1e1659ecf80cfcc", "patch": "@@ -110,7 +110,7 @@ use hir::map as hir_map;\n use rustc::infer::InferOk;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::traits::{self, ObligationCause, ObligationCauseCode, Reveal};\n+use rustc::traits::{ObligationCause, ObligationCauseCode, Reveal};\n use session::config;\n use util::common::time;\n \n@@ -120,9 +120,6 @@ use syntax::symbol::keywords;\n use syntax_pos::Span;\n \n use std::iter;\n-use std::cell::RefCell;\n-use util::nodemap::NodeMap;\n-\n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used.\n pub mod diagnostics;\n@@ -141,27 +138,6 @@ pub struct TypeAndSubsts<'tcx> {\n     pub ty: Ty<'tcx>,\n }\n \n-pub struct CrateCtxt<'a, 'tcx: 'a> {\n-    ast_ty_to_ty_cache: RefCell<NodeMap<Ty<'tcx>>>,\n-\n-    /// A vector of every trait accessible in the whole crate\n-    /// (i.e. including those from subcrates). This is used only for\n-    /// error reporting, and so is lazily initialised and generally\n-    /// shouldn't taint the common path (hence the RefCell).\n-    pub all_traits: RefCell<Option<check::method::AllTraitsVec>>,\n-\n-    /// This stack is used to identify cycles in the user's source.\n-    /// Note that these cycles can cross multiple items.\n-    pub stack: RefCell<Vec<collect::AstConvRequest>>,\n-\n-    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-\n-    /// Obligations which will have to be checked at the end of\n-    /// type-checking, after all functions have been inferred.\n-    /// The key is the NodeId of the item the obligations were from.\n-    pub deferred_obligations: RefCell<NodeMap<Vec<traits::DeferredObligation<'tcx>>>>,\n-}\n-\n fn require_c_abi_if_variadic(tcx: TyCtxt,\n                              decl: &hir::FnDecl,\n                              abi: Abi,\n@@ -174,12 +150,12 @@ fn require_c_abi_if_variadic(tcx: TyCtxt,\n     }\n }\n \n-fn require_same_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn require_same_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 cause: &ObligationCause<'tcx>,\n                                 expected: Ty<'tcx>,\n                                 actual: Ty<'tcx>)\n                                 -> bool {\n-    ccx.tcx.infer_ctxt((), Reveal::NotSpecializable).enter(|infcx| {\n+    tcx.infer_ctxt((), Reveal::NotSpecializable).enter(|infcx| {\n         match infcx.eq_types(false, &cause, expected, actual) {\n             Ok(InferOk { obligations, .. }) => {\n                 // FIXME(#32730) propagate obligations\n@@ -218,10 +194,9 @@ fn ty_param_name(tcx: TyCtxt, id: ast::NodeId) -> ast::Name {\n     }\n }\n \n-fn check_main_fn_ty(ccx: &CrateCtxt,\n-                    main_id: ast::NodeId,\n-                    main_span: Span) {\n-    let tcx = ccx.tcx;\n+fn check_main_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                              main_id: ast::NodeId,\n+                              main_span: Span) {\n     let main_def_id = tcx.hir.local_def_id(main_id);\n     let main_t = tcx.item_type(main_def_id);\n     match main_t.sty {\n@@ -231,7 +206,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                     match it.node {\n                         hir::ItemFn(.., ref generics, _) => {\n                             if generics.is_parameterized() {\n-                                struct_span_err!(ccx.tcx.sess, generics.span, E0131,\n+                                struct_span_err!(tcx.sess, generics.span, E0131,\n                                          \"main function is not allowed to have type parameters\")\n                                     .span_label(generics.span,\n                                                 &format!(\"main cannot have type parameters\"))\n@@ -253,7 +228,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n             }));\n \n             require_same_types(\n-                ccx,\n+                tcx,\n                 &ObligationCause::new(main_span, main_id, ObligationCauseCode::MainFunctionType),\n                 se_ty,\n                 main_t);\n@@ -266,11 +241,10 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n     }\n }\n \n-fn check_start_fn_ty(ccx: &CrateCtxt,\n-                     start_id: ast::NodeId,\n-                     start_span: Span) {\n-    let tcx = ccx.tcx;\n-    let start_def_id = ccx.tcx.hir.local_def_id(start_id);\n+fn check_start_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                               start_id: ast::NodeId,\n+                               start_span: Span) {\n+    let start_def_id = tcx.hir.local_def_id(start_id);\n     let start_t = tcx.item_type(start_def_id);\n     match start_t.sty {\n         ty::TyFnDef(..) => {\n@@ -308,7 +282,7 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n             }));\n \n             require_same_types(\n-                ccx,\n+                tcx,\n                 &ObligationCause::new(start_span, start_id, ObligationCauseCode::StartFunctionType),\n                 se_ty,\n                 start_t);\n@@ -321,35 +295,27 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n     }\n }\n \n-fn check_for_entry_fn(ccx: &CrateCtxt) {\n-    let tcx = ccx.tcx;\n+fn check_for_entry_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let _task = tcx.dep_graph.in_task(DepNode::CheckEntryFn);\n     if let Some((id, sp)) = *tcx.sess.entry_fn.borrow() {\n         match tcx.sess.entry_type.get() {\n-            Some(config::EntryMain) => check_main_fn_ty(ccx, id, sp),\n-            Some(config::EntryStart) => check_start_fn_ty(ccx, id, sp),\n+            Some(config::EntryMain) => check_main_fn_ty(tcx, id, sp),\n+            Some(config::EntryStart) => check_start_fn_ty(tcx, id, sp),\n             Some(config::EntryNone) => {}\n             None => bug!(\"entry function without a type\")\n         }\n     }\n }\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                             -> Result<NodeMap<Ty<'tcx>>, usize> {\n+                             -> Result<(), usize> {\n     let time_passes = tcx.sess.time_passes();\n-    let ccx = CrateCtxt {\n-        ast_ty_to_ty_cache: RefCell::new(NodeMap()),\n-        all_traits: RefCell::new(None),\n-        stack: RefCell::new(Vec::new()),\n-        tcx: tcx,\n-        deferred_obligations: RefCell::new(NodeMap()),\n-    };\n \n     // this ensures that later parts of type checking can assume that items\n     // have valid types and not error\n     tcx.sess.track_errors(|| {\n         time(time_passes, \"type collecting\", ||\n-             collect::collect_item_types(&ccx));\n+             collect::collect_item_types(tcx));\n \n     })?;\n \n@@ -358,28 +324,28 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n \n     tcx.sess.track_errors(|| {\n         time(time_passes, \"impl wf inference\", ||\n-             impl_wf_check::impl_wf_check(&ccx));\n+             impl_wf_check::impl_wf_check(tcx));\n     })?;\n \n     tcx.sess.track_errors(|| {\n       time(time_passes, \"coherence checking\", ||\n-          coherence::check_coherence(&ccx));\n+          coherence::check_coherence(tcx));\n     })?;\n \n-    time(time_passes, \"wf checking\", || check::check_wf_new(&ccx))?;\n+    time(time_passes, \"wf checking\", || check::check_wf_new(tcx))?;\n \n-    time(time_passes, \"item-types checking\", || check::check_item_types(&ccx))?;\n+    time(time_passes, \"item-types checking\", || check::check_item_types(tcx))?;\n \n-    time(time_passes, \"item-bodies checking\", || check::check_item_bodies(&ccx))?;\n+    time(time_passes, \"item-bodies checking\", || check::check_item_bodies(tcx))?;\n \n-    time(time_passes, \"drop-impl checking\", || check::check_drop_impls(&ccx))?;\n+    time(time_passes, \"drop-impl checking\", || check::check_drop_impls(tcx))?;\n \n     check_unused::check_crate(tcx);\n-    check_for_entry_fn(&ccx);\n+    check_for_entry_fn(tcx);\n \n     let err_count = tcx.sess.err_count();\n     if err_count == 0 {\n-        Ok(ccx.ast_ty_to_ty_cache.into_inner())\n+        Ok(())\n     } else {\n         Err(err_count)\n     }"}, {"sha": "cd94e3fd14a504bbacf849995017c1e660a5c848", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=4649f7387ea334901c78dd48c1e1659ecf80cfcc", "patch": "@@ -1772,7 +1772,7 @@ impl Clean<Type> for hir::Ty {\n             }\n             TyPath(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n                 let mut def = Def::Err;\n-                if let Some(ty) = cx.hir_ty_to_ty.get(&self.id) {\n+                if let Some(ty) = cx.tcx.ast_ty_to_ty_cache.borrow().get(&self.id) {\n                     if let ty::TyProjection(proj) = ty.sty {\n                         def = Def::Trait(proj.trait_ref.def_id);\n                     }"}, {"sha": "0a9db2c26464ce6370b4c4c573742e469bf55959", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4649f7387ea334901c78dd48c1e1659ecf80cfcc/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=4649f7387ea334901c78dd48c1e1659ecf80cfcc", "patch": "@@ -15,10 +15,10 @@ use rustc::session::{self, config};\n use rustc::hir::def_id::DefId;\n use rustc::hir::def::{Def, ExportMap};\n use rustc::middle::privacy::AccessLevels;\n-use rustc::ty::{self, TyCtxt, GlobalArenas, Ty};\n+use rustc::ty::{self, TyCtxt, GlobalArenas};\n use rustc::hir::map as hir_map;\n use rustc::lint;\n-use rustc::util::nodemap::{FxHashMap, NodeMap};\n+use rustc::util::nodemap::FxHashMap;\n use rustc_trans::back::link;\n use rustc_resolve as resolve;\n use rustc_metadata::cstore::CStore;\n@@ -65,9 +65,6 @@ pub struct DocContext<'a, 'tcx: 'a> {\n     /// Table node id of lifetime parameter definition -> substituted lifetime\n     pub lt_substs: RefCell<FxHashMap<ast::NodeId, clean::Lifetime>>,\n     pub export_map: ExportMap,\n-\n-    /// Table from HIR Ty nodes to their resolved Ty.\n-    pub hir_ty_to_ty: NodeMap<Ty<'tcx>>,\n }\n \n impl<'a, 'tcx> DocContext<'a, 'tcx> {\n@@ -183,7 +180,7 @@ pub fn run_core(search_paths: SearchPaths,\n             sess.fatal(\"Compilation failed, aborting rustdoc\");\n         }\n \n-        let ty::CrateAnalysis { access_levels, export_map, hir_ty_to_ty, .. } = analysis;\n+        let ty::CrateAnalysis { access_levels, export_map, .. } = analysis;\n \n         // Convert from a NodeId set to a DefId set since we don't always have easy access\n         // to the map from defid -> nodeid\n@@ -202,7 +199,6 @@ pub fn run_core(search_paths: SearchPaths,\n             ty_substs: Default::default(),\n             lt_substs: Default::default(),\n             export_map: export_map,\n-            hir_ty_to_ty: hir_ty_to_ty,\n         };\n         debug!(\"crate: {:?}\", tcx.hir.krate());\n "}]}