{"sha": "3e827cc21e0734edd26170e8d1481f0d66a1426b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlODI3Y2MyMWUwNzM0ZWRkMjYxNzBlOGQxNDgxZjBkNjZhMTQyNmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-19T10:11:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-19T10:11:28Z"}, "message": "Auto merge of #85376 - RalfJung:ptrless-allocs, r=oli-obk\n\nCTFE core engine allocation & memory API improvemenets\n\nThis is a first step towards https://github.com/rust-lang/miri/issues/841.\n- make `Allocation` API offset-based (no more making up `Pointer`s just to access an `Allocation`)\n- make `Memory` API higher-level (combine checking for access and getting access into one operation)\n\nThe Miri-side PR is at https://github.com/rust-lang/miri/pull/1804.\nr? `@oli-obk`", "tree": {"sha": "98297cd293fca399b0d254d8967bd0e7cdf17ab2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98297cd293fca399b0d254d8967bd0e7cdf17ab2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e827cc21e0734edd26170e8d1481f0d66a1426b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e827cc21e0734edd26170e8d1481f0d66a1426b", "html_url": "https://github.com/rust-lang/rust/commit/3e827cc21e0734edd26170e8d1481f0d66a1426b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e827cc21e0734edd26170e8d1481f0d66a1426b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be8450eec8fa635a9132f799012fed83ba59121e", "url": "https://api.github.com/repos/rust-lang/rust/commits/be8450eec8fa635a9132f799012fed83ba59121e", "html_url": "https://github.com/rust-lang/rust/commit/be8450eec8fa635a9132f799012fed83ba59121e"}, {"sha": "d5ccf68a1076f0ec14e86cfbacb6cbe7f5fc923a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5ccf68a1076f0ec14e86cfbacb6cbe7f5fc923a", "html_url": "https://github.com/rust-lang/rust/commit/d5ccf68a1076f0ec14e86cfbacb6cbe7f5fc923a"}], "stats": {"total": 1107, "additions": 597, "deletions": 510}, "files": [{"sha": "c0f2920652f612592cd869dd496cc0d347a11e4e", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e827cc21e0734edd26170e8d1481f0d66a1426b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e827cc21e0734edd26170e8d1481f0d66a1426b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=3e827cc21e0734edd26170e8d1481f0d66a1426b", "patch": "@@ -6,7 +6,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::ErrorReported;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir::interpret::{\n-    read_target_uint, AllocId, Allocation, ConstValue, ErrorHandled, GlobalAlloc, Pointer, Scalar,\n+    alloc_range, read_target_uint, AllocId, Allocation, ConstValue, ErrorHandled, GlobalAlloc, Scalar,\n };\n use rustc_middle::ty::ConstKind;\n \n@@ -176,8 +176,7 @@ pub(crate) fn codegen_const_value<'tcx>(\n                     std::iter::repeat(0).take(size.bytes_usize()).collect::<Vec<u8>>(),\n                     align,\n                 );\n-                let ptr = Pointer::new(AllocId(!0), Size::ZERO); // The alloc id is never used\n-                alloc.write_scalar(fx, ptr, x.into(), size).unwrap();\n+                alloc.write_scalar(fx, alloc_range(Size::ZERO, size), x.into()).unwrap();\n                 let alloc = fx.tcx.intern_const_alloc(alloc);\n                 return CValue::by_ref(pointer_for_allocation(fx, alloc), layout);\n             }"}, {"sha": "c2f469fa021e15ab0703f65b6bc1596de4c80a20", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/simd.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3e827cc21e0734edd26170e8d1481f0d66a1426b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e827cc21e0734edd26170e8d1481f0d66a1426b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs?ref=3e827cc21e0734edd26170e8d1481f0d66a1426b", "patch": "@@ -86,9 +86,8 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n \n                 let idx_bytes = match idx_const {\n                     ConstValue::ByRef { alloc, offset } => {\n-                        let ptr = Pointer::new(AllocId(0 /* dummy */), offset);\n                         let size = Size::from_bytes(4 * ret_lane_count /* size_of([u32; ret_lane_count]) */);\n-                        alloc.get_bytes(fx, ptr, size).unwrap()\n+                        alloc.get_bytes(fx, alloc_range(offset, size)).unwrap()\n                     }\n                     _ => unreachable!(\"{:?}\", idx_const),\n                 };"}, {"sha": "622eaf575789299edc56d684d67cf1dad72e1841", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 137, "deletions": 210, "changes": 347, "blob_url": "https://github.com/rust-lang/rust/blob/3e827cc21e0734edd26170e8d1481f0d66a1426b/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e827cc21e0734edd26170e8d1481f0d66a1426b/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=3e827cc21e0734edd26170e8d1481f0d66a1426b", "patch": "@@ -4,16 +4,22 @@ use std::borrow::Cow;\n use std::convert::TryFrom;\n use std::iter;\n use std::ops::{Deref, DerefMut, Range};\n+use std::ptr;\n \n use rustc_ast::Mutability;\n use rustc_data_structures::sorted_map::SortedMap;\n use rustc_target::abi::{Align, HasDataLayout, Size};\n \n use super::{\n-    read_target_uint, write_target_uint, AllocId, InterpResult, Pointer, Scalar, ScalarMaybeUninit,\n-    UninitBytesAccess,\n+    read_target_uint, write_target_uint, AllocId, InterpError, Pointer, Scalar, ScalarMaybeUninit,\n+    UndefinedBehaviorInfo, UninitBytesAccess, UnsupportedOpInfo,\n };\n \n+/// This type represents an Allocation in the Miri/CTFE core engine.\n+///\n+/// Its public API is rather low-level, working directly with allocation offsets and a custom error\n+/// type to account for the lack of an AllocId on this level. The Miri/CTFE core engine `memory`\n+/// module provides higher-level access.\n #[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n pub struct Allocation<Tag = (), Extra = ()> {\n@@ -38,50 +44,59 @@ pub struct Allocation<Tag = (), Extra = ()> {\n     pub extra: Extra,\n }\n \n-pub trait AllocationExtra<Tag>: std::fmt::Debug + Clone {\n-    // There is no constructor in here because the constructor's type depends\n-    // on `MemoryKind`, and making things sufficiently generic leads to painful\n-    // inference failure.\n+/// We have our own error type that does not know about the `AllocId`; that information\n+/// is added when converting to `InterpError`.\n+#[derive(Debug)]\n+pub enum AllocError {\n+    /// Encountered a pointer where we needed raw bytes.\n+    ReadPointerAsBytes,\n+    /// Using uninitialized data where it is not allowed.\n+    InvalidUninitBytes(Option<UninitBytesAccess>),\n+}\n+pub type AllocResult<T = ()> = Result<T, AllocError>;\n \n-    /// Hook for performing extra checks on a memory read access.\n-    ///\n-    /// Takes read-only access to the allocation so we can keep all the memory read\n-    /// operations take `&self`. Use a `RefCell` in `AllocExtra` if you\n-    /// need to mutate.\n-    #[inline(always)]\n-    fn memory_read(\n-        _alloc: &Allocation<Tag, Self>,\n-        _ptr: Pointer<Tag>,\n-        _size: Size,\n-    ) -> InterpResult<'tcx> {\n-        Ok(())\n+impl AllocError {\n+    pub fn to_interp_error<'tcx>(self, alloc_id: AllocId) -> InterpError<'tcx> {\n+        match self {\n+            AllocError::ReadPointerAsBytes => {\n+                InterpError::Unsupported(UnsupportedOpInfo::ReadPointerAsBytes)\n+            }\n+            AllocError::InvalidUninitBytes(info) => InterpError::UndefinedBehavior(\n+                UndefinedBehaviorInfo::InvalidUninitBytes(info.map(|b| (alloc_id, b))),\n+            ),\n+        }\n     }\n+}\n+\n+/// The information that makes up a memory access: offset and size.\n+#[derive(Copy, Clone, Debug)]\n+pub struct AllocRange {\n+    pub start: Size,\n+    pub size: Size,\n+}\n+\n+/// Free-starting constructor for less syntactic overhead.\n+#[inline(always)]\n+pub fn alloc_range(start: Size, size: Size) -> AllocRange {\n+    AllocRange { start, size }\n+}\n \n-    /// Hook for performing extra checks on a memory write access.\n+impl AllocRange {\n     #[inline(always)]\n-    fn memory_written(\n-        _alloc: &mut Allocation<Tag, Self>,\n-        _ptr: Pointer<Tag>,\n-        _size: Size,\n-    ) -> InterpResult<'tcx> {\n-        Ok(())\n+    pub fn end(self) -> Size {\n+        self.start + self.size // This does overflow checking.\n     }\n \n-    /// Hook for performing extra checks on a memory deallocation.\n-    /// `size` will be the size of the allocation.\n-    #[inline(always)]\n-    fn memory_deallocated(\n-        _alloc: &mut Allocation<Tag, Self>,\n-        _ptr: Pointer<Tag>,\n-        _size: Size,\n-    ) -> InterpResult<'tcx> {\n-        Ok(())\n+    /// Returns the `subrange` within this range; panics if it is not a subrange.\n+    #[inline]\n+    pub fn subrange(self, subrange: AllocRange) -> AllocRange {\n+        let sub_start = self.start + subrange.start;\n+        let range = alloc_range(sub_start, subrange.size);\n+        assert!(range.end() <= self.end(), \"access outside the bounds for given AllocRange\");\n+        range\n     }\n }\n \n-// For `Tag = ()` and no extra state, we have a trivial implementation.\n-impl AllocationExtra<()> for () {}\n-\n // The constructors are all without extra; the extra gets added by a machine hook later.\n impl<Tag> Allocation<Tag> {\n     /// Creates a read-only allocation initialized by the given bytes\n@@ -99,7 +114,7 @@ impl<Tag> Allocation<Tag> {\n     }\n \n     pub fn from_byte_aligned_bytes<'a>(slice: impl Into<Cow<'a, [u8]>>) -> Self {\n-        Allocation::from_bytes(slice, Align::from_bytes(1).unwrap())\n+        Allocation::from_bytes(slice, Align::ONE)\n     }\n \n     pub fn uninit(size: Size, align: Align) -> Self {\n@@ -114,7 +129,7 @@ impl<Tag> Allocation<Tag> {\n     }\n }\n \n-impl Allocation<(), ()> {\n+impl Allocation<()> {\n     /// Add Tag and Extra fields\n     pub fn with_tags_and_extra<T, E>(\n         self,\n@@ -154,7 +169,7 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n \n     /// Looks at a slice which may describe uninitialized bytes or describe a relocation. This differs\n     /// from `get_bytes_with_uninit_and_ptr` in that it does no relocation checks (even on the\n-    /// edges) at all. It further ignores `AllocationExtra` callbacks.\n+    /// edges) at all.\n     /// This must not be used for reads affecting the interpreter execution.\n     pub fn inspect_with_uninit_and_ptr_outside_interpreter(&self, range: Range<usize>) -> &[u8] {\n         &self.bytes[range]\n@@ -172,23 +187,7 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n }\n \n /// Byte accessors.\n-impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n-    /// Just a small local helper function to avoid a bit of code repetition.\n-    /// Returns the range of this allocation that was meant.\n-    #[inline]\n-    fn check_bounds(&self, offset: Size, size: Size) -> Range<usize> {\n-        let end = offset + size; // This does overflow checking.\n-        let end = usize::try_from(end.bytes()).expect(\"access too big for this host architecture\");\n-        assert!(\n-            end <= self.len(),\n-            \"Out-of-bounds access at offset {}, size {} in allocation of size {}\",\n-            offset.bytes(),\n-            size.bytes(),\n-            self.len()\n-        );\n-        offset.bytes_usize()..end\n-    }\n-\n+impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n     /// The last argument controls whether we error out when there are uninitialized\n     /// or pointer bytes. You should never call this, call `get_bytes` or\n     /// `get_bytes_with_uninit_and_ptr` instead,\n@@ -201,23 +200,18 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     fn get_bytes_internal(\n         &self,\n         cx: &impl HasDataLayout,\n-        ptr: Pointer<Tag>,\n-        size: Size,\n+        range: AllocRange,\n         check_init_and_ptr: bool,\n-    ) -> InterpResult<'tcx, &[u8]> {\n-        let range = self.check_bounds(ptr.offset, size);\n-\n+    ) -> AllocResult<&[u8]> {\n         if check_init_and_ptr {\n-            self.check_init(ptr, size)?;\n-            self.check_relocations(cx, ptr, size)?;\n+            self.check_init(range)?;\n+            self.check_relocations(cx, range)?;\n         } else {\n             // We still don't want relocations on the *edges*.\n-            self.check_relocation_edges(cx, ptr, size)?;\n+            self.check_relocation_edges(cx, range)?;\n         }\n \n-        AllocationExtra::memory_read(self, ptr, size)?;\n-\n-        Ok(&self.bytes[range])\n+        Ok(&self.bytes[range.start.bytes_usize()..range.end().bytes_usize()])\n     }\n \n     /// Checks that these bytes are initialized and not pointer bytes, and then return them\n@@ -227,13 +221,8 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// Most likely, you want to use the `PlaceTy` and `OperandTy`-based methods\n     /// on `InterpCx` instead.\n     #[inline]\n-    pub fn get_bytes(\n-        &self,\n-        cx: &impl HasDataLayout,\n-        ptr: Pointer<Tag>,\n-        size: Size,\n-    ) -> InterpResult<'tcx, &[u8]> {\n-        self.get_bytes_internal(cx, ptr, size, true)\n+    pub fn get_bytes(&self, cx: &impl HasDataLayout, range: AllocRange) -> AllocResult<&[u8]> {\n+        self.get_bytes_internal(cx, range, true)\n     }\n \n     /// It is the caller's responsibility to handle uninitialized and pointer bytes.\n@@ -244,10 +233,9 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     pub fn get_bytes_with_uninit_and_ptr(\n         &self,\n         cx: &impl HasDataLayout,\n-        ptr: Pointer<Tag>,\n-        size: Size,\n-    ) -> InterpResult<'tcx, &[u8]> {\n-        self.get_bytes_internal(cx, ptr, size, false)\n+        range: AllocRange,\n+    ) -> AllocResult<&[u8]> {\n+        self.get_bytes_internal(cx, range, false)\n     }\n \n     /// Just calling this already marks everything as defined and removes relocations,\n@@ -256,69 +244,46 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n     /// Most likely, you want to use the `PlaceTy` and `OperandTy`-based methods\n     /// on `InterpCx` instead.\n-    pub fn get_bytes_mut(\n-        &mut self,\n-        cx: &impl HasDataLayout,\n-        ptr: Pointer<Tag>,\n-        size: Size,\n-    ) -> InterpResult<'tcx, &mut [u8]> {\n-        let range = self.check_bounds(ptr.offset, size);\n+    pub fn get_bytes_mut(&mut self, cx: &impl HasDataLayout, range: AllocRange) -> &mut [u8] {\n+        self.mark_init(range, true);\n+        self.clear_relocations(cx, range);\n \n-        self.mark_init(ptr, size, true);\n-        self.clear_relocations(cx, ptr, size);\n+        &mut self.bytes[range.start.bytes_usize()..range.end().bytes_usize()]\n+    }\n \n-        AllocationExtra::memory_written(self, ptr, size)?;\n+    /// A raw pointer variant of `get_bytes_mut` that avoids invalidating existing aliases into this memory.\n+    pub fn get_bytes_mut_ptr(&mut self, cx: &impl HasDataLayout, range: AllocRange) -> *mut [u8] {\n+        self.mark_init(range, true);\n+        self.clear_relocations(cx, range);\n \n-        Ok(&mut self.bytes[range])\n+        assert!(range.end().bytes_usize() <= self.bytes.len()); // need to do our own bounds-check\n+        let begin_ptr = self.bytes.as_mut_ptr().wrapping_add(range.start.bytes_usize());\n+        let len = range.end().bytes_usize() - range.start.bytes_usize();\n+        ptr::slice_from_raw_parts_mut(begin_ptr, len)\n     }\n }\n \n /// Reading and writing.\n-impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n+impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n     /// Validates that `ptr.offset` and `ptr.offset + size` do not point to the middle of a\n     /// relocation. If `allow_uninit_and_ptr` is `false`, also enforces that the memory in the\n     /// given range contains neither relocations nor uninitialized bytes.\n     pub fn check_bytes(\n         &self,\n         cx: &impl HasDataLayout,\n-        ptr: Pointer<Tag>,\n-        size: Size,\n+        range: AllocRange,\n         allow_uninit_and_ptr: bool,\n-    ) -> InterpResult<'tcx> {\n+    ) -> AllocResult {\n         // Check bounds and relocations on the edges.\n-        self.get_bytes_with_uninit_and_ptr(cx, ptr, size)?;\n+        self.get_bytes_with_uninit_and_ptr(cx, range)?;\n         // Check uninit and ptr.\n         if !allow_uninit_and_ptr {\n-            self.check_init(ptr, size)?;\n-            self.check_relocations(cx, ptr, size)?;\n+            self.check_init(range)?;\n+            self.check_relocations(cx, range)?;\n         }\n         Ok(())\n     }\n \n-    /// Writes `src` to the memory starting at `ptr.offset`.\n-    ///\n-    /// It is the caller's responsibility to check bounds and alignment beforehand.\n-    /// Most likely, you want to call `Memory::write_bytes` instead of this method.\n-    pub fn write_bytes(\n-        &mut self,\n-        cx: &impl HasDataLayout,\n-        ptr: Pointer<Tag>,\n-        src: impl IntoIterator<Item = u8>,\n-    ) -> InterpResult<'tcx> {\n-        let mut src = src.into_iter();\n-        let (lower, upper) = src.size_hint();\n-        let len = upper.expect(\"can only write bounded iterators\");\n-        assert_eq!(lower, len, \"can only write iterators with a precise length\");\n-        let bytes = self.get_bytes_mut(cx, ptr, Size::from_bytes(len))?;\n-        // `zip` would stop when the first iterator ends; we want to definitely\n-        // cover all of `bytes`.\n-        for dest in bytes {\n-            *dest = src.next().expect(\"iterator was shorter than it said it would be\");\n-        }\n-        assert_matches!(src.next(), None, \"iterator was longer than it said it would be\");\n-        Ok(())\n-    }\n-\n     /// Reads a *non-ZST* scalar.\n     ///\n     /// ZSTs can't be read because in order to obtain a `Pointer`, we need to check\n@@ -329,44 +294,33 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     pub fn read_scalar(\n         &self,\n         cx: &impl HasDataLayout,\n-        ptr: Pointer<Tag>,\n-        size: Size,\n-    ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n+        range: AllocRange,\n+    ) -> AllocResult<ScalarMaybeUninit<Tag>> {\n         // `get_bytes_unchecked` tests relocation edges.\n-        let bytes = self.get_bytes_with_uninit_and_ptr(cx, ptr, size)?;\n+        let bytes = self.get_bytes_with_uninit_and_ptr(cx, range)?;\n         // Uninit check happens *after* we established that the alignment is correct.\n         // We must not return `Ok()` for unaligned pointers!\n-        if self.is_init(ptr, size).is_err() {\n+        if self.is_init(range).is_err() {\n             // This inflates uninitialized bytes to the entire scalar, even if only a few\n             // bytes are uninitialized.\n             return Ok(ScalarMaybeUninit::Uninit);\n         }\n         // Now we do the actual reading.\n         let bits = read_target_uint(cx.data_layout().endian, bytes).unwrap();\n         // See if we got a pointer.\n-        if size != cx.data_layout().pointer_size {\n+        if range.size != cx.data_layout().pointer_size {\n+            // Not a pointer.\n             // *Now*, we better make sure that the inside is free of relocations too.\n-            self.check_relocations(cx, ptr, size)?;\n+            self.check_relocations(cx, range)?;\n         } else {\n-            if let Some(&(tag, alloc_id)) = self.relocations.get(&ptr.offset) {\n+            // Maybe a pointer.\n+            if let Some(&(tag, alloc_id)) = self.relocations.get(&range.start) {\n                 let ptr = Pointer::new_with_tag(alloc_id, Size::from_bytes(bits), tag);\n                 return Ok(ScalarMaybeUninit::Scalar(ptr.into()));\n             }\n         }\n         // We don't. Just return the bits.\n-        Ok(ScalarMaybeUninit::Scalar(Scalar::from_uint(bits, size)))\n-    }\n-\n-    /// Reads a pointer-sized scalar.\n-    ///\n-    /// It is the caller's responsibility to check bounds and alignment beforehand.\n-    /// Most likely, you want to call `InterpCx::read_scalar` instead of this method.\n-    pub fn read_ptr_sized(\n-        &self,\n-        cx: &impl HasDataLayout,\n-        ptr: Pointer<Tag>,\n-    ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n-        self.read_scalar(cx, ptr, cx.data_layout().pointer_size)\n+        Ok(ScalarMaybeUninit::Scalar(Scalar::from_uint(bits, range.size)))\n     }\n \n     /// Writes a *non-ZST* scalar.\n@@ -379,78 +333,56 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     pub fn write_scalar(\n         &mut self,\n         cx: &impl HasDataLayout,\n-        ptr: Pointer<Tag>,\n+        range: AllocRange,\n         val: ScalarMaybeUninit<Tag>,\n-        type_size: Size,\n-    ) -> InterpResult<'tcx> {\n+    ) -> AllocResult {\n         let val = match val {\n             ScalarMaybeUninit::Scalar(scalar) => scalar,\n             ScalarMaybeUninit::Uninit => {\n-                self.mark_init(ptr, type_size, false);\n+                self.mark_init(range, false);\n                 return Ok(());\n             }\n         };\n \n-        let bytes = match val.to_bits_or_ptr(type_size, cx) {\n+        let bytes = match val.to_bits_or_ptr(range.size, cx) {\n             Err(val) => u128::from(val.offset.bytes()),\n             Ok(data) => data,\n         };\n \n         let endian = cx.data_layout().endian;\n-        let dst = self.get_bytes_mut(cx, ptr, type_size)?;\n+        let dst = self.get_bytes_mut(cx, range);\n         write_target_uint(endian, dst, bytes).unwrap();\n \n         // See if we have to also write a relocation.\n         if let Scalar::Ptr(val) = val {\n-            self.relocations.insert(ptr.offset, (val.tag, val.alloc_id));\n+            self.relocations.insert(range.start, (val.tag, val.alloc_id));\n         }\n \n         Ok(())\n     }\n-\n-    /// Writes a pointer-sized scalar.\n-    ///\n-    /// It is the caller's responsibility to check bounds and alignment beforehand.\n-    /// Most likely, you want to call `InterpCx::write_scalar` instead of this method.\n-    pub fn write_ptr_sized(\n-        &mut self,\n-        cx: &impl HasDataLayout,\n-        ptr: Pointer<Tag>,\n-        val: ScalarMaybeUninit<Tag>,\n-    ) -> InterpResult<'tcx> {\n-        let ptr_size = cx.data_layout().pointer_size;\n-        self.write_scalar(cx, ptr, val, ptr_size)\n-    }\n }\n \n /// Relocations.\n-impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n+impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n     /// Returns all relocations overlapping with the given pointer-offset pair.\n     pub fn get_relocations(\n         &self,\n         cx: &impl HasDataLayout,\n-        ptr: Pointer<Tag>,\n-        size: Size,\n+        range: AllocRange,\n     ) -> &[(Size, (Tag, AllocId))] {\n         // We have to go back `pointer_size - 1` bytes, as that one would still overlap with\n         // the beginning of this range.\n-        let start = ptr.offset.bytes().saturating_sub(cx.data_layout().pointer_size.bytes() - 1);\n-        let end = ptr.offset + size; // This does overflow checking.\n-        self.relocations.range(Size::from_bytes(start)..end)\n+        let start = range.start.bytes().saturating_sub(cx.data_layout().pointer_size.bytes() - 1);\n+        self.relocations.range(Size::from_bytes(start)..range.end())\n     }\n \n     /// Checks that there are no relocations overlapping with the given range.\n     #[inline(always)]\n-    fn check_relocations(\n-        &self,\n-        cx: &impl HasDataLayout,\n-        ptr: Pointer<Tag>,\n-        size: Size,\n-    ) -> InterpResult<'tcx> {\n-        if self.get_relocations(cx, ptr, size).is_empty() {\n+    fn check_relocations(&self, cx: &impl HasDataLayout, range: AllocRange) -> AllocResult {\n+        if self.get_relocations(cx, range).is_empty() {\n             Ok(())\n         } else {\n-            throw_unsup!(ReadPointerAsBytes)\n+            Err(AllocError::ReadPointerAsBytes)\n         }\n     }\n \n@@ -460,11 +392,11 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n     /// uninitialized. This is a somewhat odd \"spooky action at a distance\",\n     /// but it allows strictly more code to run than if we would just error\n     /// immediately in that case.\n-    fn clear_relocations(&mut self, cx: &impl HasDataLayout, ptr: Pointer<Tag>, size: Size) {\n+    fn clear_relocations(&mut self, cx: &impl HasDataLayout, range: AllocRange) {\n         // Find the start and end of the given range and its outermost relocations.\n         let (first, last) = {\n             // Find all relocations overlapping the given range.\n-            let relocations = self.get_relocations(cx, ptr, size);\n+            let relocations = self.get_relocations(cx, range);\n             if relocations.is_empty() {\n                 return;\n             }\n@@ -474,8 +406,8 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n                 relocations.last().unwrap().0 + cx.data_layout().pointer_size,\n             )\n         };\n-        let start = ptr.offset;\n-        let end = start + size; // `Size` addition\n+        let start = range.start;\n+        let end = range.end();\n \n         // Mark parts of the outermost relocations as uninitialized if they partially fall outside the\n         // given range.\n@@ -493,46 +425,41 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n     /// Errors if there are relocations overlapping with the edges of the\n     /// given memory range.\n     #[inline]\n-    fn check_relocation_edges(\n-        &self,\n-        cx: &impl HasDataLayout,\n-        ptr: Pointer<Tag>,\n-        size: Size,\n-    ) -> InterpResult<'tcx> {\n-        self.check_relocations(cx, ptr, Size::ZERO)?;\n-        self.check_relocations(cx, ptr.offset(size, cx)?, Size::ZERO)?;\n+    fn check_relocation_edges(&self, cx: &impl HasDataLayout, range: AllocRange) -> AllocResult {\n+        self.check_relocations(cx, alloc_range(range.start, Size::ZERO))?;\n+        self.check_relocations(cx, alloc_range(range.end(), Size::ZERO))?;\n         Ok(())\n     }\n }\n \n /// Uninitialized bytes.\n-impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n+impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n     /// Checks whether the given range  is entirely initialized.\n     ///\n     /// Returns `Ok(())` if it's initialized. Otherwise returns the range of byte\n     /// indexes of the first contiguous uninitialized access.\n-    fn is_init(&self, ptr: Pointer<Tag>, size: Size) -> Result<(), Range<Size>> {\n-        self.init_mask.is_range_initialized(ptr.offset, ptr.offset + size) // `Size` addition\n+    fn is_init(&self, range: AllocRange) -> Result<(), Range<Size>> {\n+        self.init_mask.is_range_initialized(range.start, range.end()) // `Size` addition\n     }\n \n     /// Checks that a range of bytes is initialized. If not, returns the `InvalidUninitBytes`\n     /// error which will report the first range of bytes which is uninitialized.\n-    fn check_init(&self, ptr: Pointer<Tag>, size: Size) -> InterpResult<'tcx> {\n-        self.is_init(ptr, size).or_else(|idx_range| {\n-            throw_ub!(InvalidUninitBytes(Some(UninitBytesAccess {\n-                access_ptr: ptr.erase_tag(),\n-                access_size: size,\n-                uninit_ptr: Pointer::new(ptr.alloc_id, idx_range.start),\n+    fn check_init(&self, range: AllocRange) -> AllocResult {\n+        self.is_init(range).or_else(|idx_range| {\n+            Err(AllocError::InvalidUninitBytes(Some(UninitBytesAccess {\n+                access_offset: range.start,\n+                access_size: range.size,\n+                uninit_offset: idx_range.start,\n                 uninit_size: idx_range.end - idx_range.start, // `Size` subtraction\n             })))\n         })\n     }\n \n-    pub fn mark_init(&mut self, ptr: Pointer<Tag>, size: Size, is_init: bool) {\n-        if size.bytes() == 0 {\n+    pub fn mark_init(&mut self, range: AllocRange, is_init: bool) {\n+        if range.size.bytes() == 0 {\n             return;\n         }\n-        self.init_mask.set_range(ptr.offset, ptr.offset + size, is_init);\n+        self.init_mask.set_range(range.start, range.end(), is_init);\n     }\n }\n \n@@ -667,25 +594,25 @@ impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n     pub fn prepare_relocation_copy(\n         &self,\n         cx: &impl HasDataLayout,\n-        src: Pointer<Tag>,\n-        size: Size,\n-        dest: Pointer<Tag>,\n-        length: u64,\n+        src: AllocRange,\n+        dest: Size,\n+        count: u64,\n     ) -> AllocationRelocations<Tag> {\n-        let relocations = self.get_relocations(cx, src, size);\n+        let relocations = self.get_relocations(cx, src);\n         if relocations.is_empty() {\n             return AllocationRelocations { relative_relocations: Vec::new() };\n         }\n \n-        let mut new_relocations = Vec::with_capacity(relocations.len() * (length as usize));\n+        let size = src.size;\n+        let mut new_relocations = Vec::with_capacity(relocations.len() * (count as usize));\n \n-        for i in 0..length {\n+        for i in 0..count {\n             new_relocations.extend(relocations.iter().map(|&(offset, reloc)| {\n                 // compute offset for current repetition\n-                let dest_offset = dest.offset + size * i; // `Size` operations\n+                let dest_offset = dest + size * i; // `Size` operations\n                 (\n                     // shift offsets from source allocation to destination allocation\n-                    (offset + dest_offset) - src.offset, // `Size` operations\n+                    (offset + dest_offset) - src.start, // `Size` operations\n                     reloc,\n                 )\n             }));"}, {"sha": "7282e65f3f88a3c07027997d7ed64d4efe82eaea", "filename": "compiler/rustc_middle/src/mir/interpret/error.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3e827cc21e0734edd26170e8d1481f0d66a1426b/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e827cc21e0734edd26170e8d1481f0d66a1426b/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs?ref=3e827cc21e0734edd26170e8d1481f0d66a1426b", "patch": "@@ -198,11 +198,11 @@ impl fmt::Display for CheckInAllocMsg {\n #[derive(Debug)]\n pub struct UninitBytesAccess {\n     /// Location of the original memory access.\n-    pub access_ptr: Pointer,\n+    pub access_offset: Size,\n     /// Size of the original memory access.\n     pub access_size: Size,\n     /// Location of the first uninitialized byte that was accessed.\n-    pub uninit_ptr: Pointer,\n+    pub uninit_offset: Size,\n     /// Number of consecutive uninitialized bytes that were accessed.\n     pub uninit_size: Size,\n }\n@@ -264,7 +264,7 @@ pub enum UndefinedBehaviorInfo<'tcx> {\n     /// Using a string that is not valid UTF-8,\n     InvalidStr(std::str::Utf8Error),\n     /// Using uninitialized data where it is not allowed.\n-    InvalidUninitBytes(Option<UninitBytesAccess>),\n+    InvalidUninitBytes(Option<(AllocId, UninitBytesAccess)>),\n     /// Working with a local that is not currently live.\n     DeadLocal,\n     /// Data size is not equal to target size.\n@@ -335,18 +335,18 @@ impl fmt::Display for UndefinedBehaviorInfo<'_> {\n                 write!(f, \"using {} as function pointer but it does not point to a function\", p)\n             }\n             InvalidStr(err) => write!(f, \"this string is not valid UTF-8: {}\", err),\n-            InvalidUninitBytes(Some(access)) => write!(\n+            InvalidUninitBytes(Some((alloc, access))) => write!(\n                 f,\n                 \"reading {} byte{} of memory starting at {}, \\\n                  but {} byte{} {} uninitialized starting at {}, \\\n                  and this operation requires initialized memory\",\n                 access.access_size.bytes(),\n                 pluralize!(access.access_size.bytes()),\n-                access.access_ptr,\n+                Pointer::new(*alloc, access.access_offset),\n                 access.uninit_size.bytes(),\n                 pluralize!(access.uninit_size.bytes()),\n                 if access.uninit_size.bytes() != 1 { \"are\" } else { \"is\" },\n-                access.uninit_ptr,\n+                Pointer::new(*alloc, access.uninit_offset),\n             ),\n             InvalidUninitBytes(None) => write!(\n                 f,\n@@ -446,7 +446,7 @@ impl dyn MachineStopType {\n }\n \n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-static_assert_size!(InterpError<'_>, 72);\n+static_assert_size!(InterpError<'_>, 64);\n \n pub enum InterpError<'tcx> {\n     /// The program caused undefined behavior."}, {"sha": "d03a7421ca7fa9070f5e080b02268d3d9d151c02", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e827cc21e0734edd26170e8d1481f0d66a1426b/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e827cc21e0734edd26170e8d1481f0d66a1426b/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=3e827cc21e0734edd26170e8d1481f0d66a1426b", "patch": "@@ -125,7 +125,7 @@ pub use self::error::{\n \n pub use self::value::{get_slice_bytes, ConstAlloc, ConstValue, Scalar, ScalarMaybeUninit};\n \n-pub use self::allocation::{Allocation, AllocationExtra, InitMask, Relocations};\n+pub use self::allocation::{alloc_range, AllocRange, Allocation, InitMask, Relocations};\n \n pub use self::pointer::{Pointer, PointerArithmetic};\n "}, {"sha": "66ff6990e8cdbed6ccd0dc9d61185db968b8c1f9", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e827cc21e0734edd26170e8d1481f0d66a1426b/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e827cc21e0734edd26170e8d1481f0d66a1426b/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=3e827cc21e0734edd26170e8d1481f0d66a1426b", "patch": "@@ -10,7 +10,7 @@ use rustc_target::abi::{HasDataLayout, Size, TargetDataLayout};\n \n use crate::ty::{Lift, ParamEnv, ScalarInt, Ty, TyCtxt};\n \n-use super::{AllocId, Allocation, InterpResult, Pointer, PointerArithmetic};\n+use super::{AllocId, AllocRange, Allocation, InterpResult, Pointer, PointerArithmetic};\n \n /// Represents the result of const evaluation via the `eval_to_allocation` query.\n #[derive(Copy, Clone, HashStable, TyEncodable, TyDecodable, Debug, Hash, Eq, PartialEq)]\n@@ -661,9 +661,7 @@ pub fn get_slice_bytes<'tcx>(cx: &impl HasDataLayout, val: ConstValue<'tcx>) ->\n         let len = end - start;\n         data.get_bytes(\n             cx,\n-            // invent a pointer, only the offset is relevant anyway\n-            Pointer::new(AllocId(0), Size::from_bytes(start)),\n-            Size::from_bytes(len),\n+            AllocRange { start: Size::from_bytes(start), size: Size::from_bytes(len) },\n         )\n         .unwrap_or_else(|err| bug!(\"const slice is invalid: {:?}\", err))\n     } else {"}, {"sha": "f514278a11c932188f418c39fa652ad8aae62bd6", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3e827cc21e0734edd26170e8d1481f0d66a1426b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e827cc21e0734edd26170e8d1481f0d66a1426b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=3e827cc21e0734edd26170e8d1481f0d66a1426b", "patch": "@@ -1,5 +1,5 @@\n use crate::middle::cstore::{ExternCrate, ExternCrateSource};\n-use crate::mir::interpret::{AllocId, ConstValue, GlobalAlloc, Pointer, Scalar};\n+use crate::mir::interpret::{AllocRange, ConstValue, GlobalAlloc, Pointer, Scalar};\n use crate::ty::subst::{GenericArg, GenericArgKind, Subst};\n use crate::ty::{self, ConstInt, DefIdTree, ParamConst, ScalarInt, Ty, TyCtxt, TypeFoldable};\n use rustc_apfloat::ieee::{Double, Single};\n@@ -1004,9 +1004,9 @@ pub trait PrettyPrinter<'tcx>:\n                 _,\n             ) => match self.tcx().get_global_alloc(ptr.alloc_id) {\n                 Some(GlobalAlloc::Memory(alloc)) => {\n-                    let bytes = int.assert_bits(self.tcx().data_layout.pointer_size);\n-                    let size = Size::from_bytes(bytes);\n-                    if let Ok(byte_str) = alloc.get_bytes(&self.tcx(), ptr, size) {\n+                    let len = int.assert_bits(self.tcx().data_layout.pointer_size);\n+                    let range = AllocRange { start: ptr.offset, size: Size::from_bytes(len) };\n+                    if let Ok(byte_str) = alloc.get_bytes(&self.tcx(), range) {\n                         p!(pretty_print_byte_str(byte_str))\n                     } else {\n                         p!(\"<too short allocation>\")\n@@ -1181,10 +1181,9 @@ pub trait PrettyPrinter<'tcx>:\n             (ConstValue::ByRef { alloc, offset }, ty::Array(t, n)) if *t == u8_type => {\n                 let n = n.val.try_to_bits(self.tcx().data_layout.pointer_size).unwrap();\n                 // cast is ok because we already checked for pointer size (32 or 64 bit) above\n-                let n = Size::from_bytes(n);\n-                let ptr = Pointer::new(AllocId(0), offset);\n+                let range = AllocRange { start: offset, size: Size::from_bytes(n) };\n \n-                let byte_str = alloc.get_bytes(&self.tcx(), ptr, n).unwrap();\n+                let byte_str = alloc.get_bytes(&self.tcx(), range).unwrap();\n                 p!(\"*\");\n                 p!(pretty_print_byte_str(byte_str));\n                 Ok(self)"}, {"sha": "6a514e9f62fce655b5aa56822f1e595cc1d67df0", "filename": "compiler/rustc_mir/src/const_eval/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e827cc21e0734edd26170e8d1481f0d66a1426b/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e827cc21e0734edd26170e8d1481f0d66a1426b/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs?ref=3e827cc21e0734edd26170e8d1481f0d66a1426b", "patch": "@@ -181,7 +181,7 @@ pub(crate) fn deref_const<'tcx>(\n     let mplace = ecx.deref_operand(&op).unwrap();\n     if let Scalar::Ptr(ptr) = mplace.ptr {\n         assert_eq!(\n-            ecx.memory.get_raw(ptr.alloc_id).unwrap().mutability,\n+            tcx.get_global_alloc(ptr.alloc_id).unwrap().unwrap_memory().mutability,\n             Mutability::Not,\n             \"deref_const cannot be used with mutable allocations as \\\n             that could allow pattern matching to observe mutable statics\","}, {"sha": "99622fb310aaf48ce748366f17760e91d3efbb33", "filename": "compiler/rustc_mir/src/interpret/intrinsics.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3e827cc21e0734edd26170e8d1481f0d66a1426b/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e827cc21e0734edd26170e8d1481f0d66a1426b/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=3e827cc21e0734edd26170e8d1481f0d66a1426b", "patch": "@@ -14,7 +14,7 @@ use rustc_middle::ty;\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{Ty, TyCtxt};\n use rustc_span::symbol::{sym, Symbol};\n-use rustc_target::abi::{Abi, LayoutOf as _, Primitive, Size};\n+use rustc_target::abi::{Abi, Align, LayoutOf as _, Primitive, Size};\n \n use super::{\n     util::ensure_monomorphic_enough, CheckInAllocMsg, ImmTy, InterpCx, Machine, OpTy, PlaceTy,\n@@ -525,7 +525,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         self.memory.check_ptr_access_align(\n             min_ptr,\n             Size::from_bytes(size),\n-            None,\n+            Align::ONE,\n             CheckInAllocMsg::PointerArithmeticTest,\n         )?;\n         Ok(offset_ptr)\n@@ -549,17 +549,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             )\n         })?;\n \n-        // Make sure we check both pointers for an access of the total size and aligment,\n-        // *even if* the total size is 0.\n-        let src =\n-            self.memory.check_ptr_access(self.read_scalar(&src)?.check_init()?, size, align)?;\n+        let src = self.read_scalar(&src)?.check_init()?;\n+        let dst = self.read_scalar(&dst)?.check_init()?;\n \n-        let dst =\n-            self.memory.check_ptr_access(self.read_scalar(&dst)?.check_init()?, size, align)?;\n-\n-        if let (Some(src), Some(dst)) = (src, dst) {\n-            self.memory.copy(src, dst, size, nonoverlapping)?;\n-        }\n-        Ok(())\n+        self.memory.copy(src, align, dst, align, size, nonoverlapping)\n     }\n }"}, {"sha": "e6b3b1daf5a7945e124ef5d688b8081fc86bf4df", "filename": "compiler/rustc_mir/src/interpret/machine.rs", "status": "modified", "additions": 35, "deletions": 7, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3e827cc21e0734edd26170e8d1481f0d66a1426b/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e827cc21e0734edd26170e8d1481f0d66a1426b/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmachine.rs?ref=3e827cc21e0734edd26170e8d1481f0d66a1426b", "patch": "@@ -13,8 +13,8 @@ use rustc_target::abi::Size;\n use rustc_target::spec::abi::Abi;\n \n use super::{\n-    AllocId, Allocation, AllocationExtra, CheckInAllocMsg, Frame, ImmTy, InterpCx, InterpResult,\n-    LocalValue, MemPlace, Memory, MemoryKind, OpTy, Operand, PlaceTy, Pointer, Scalar,\n+    AllocId, Allocation, CheckInAllocMsg, Frame, ImmTy, InterpCx, InterpResult, LocalValue,\n+    MemPlace, Memory, MemoryKind, OpTy, Operand, PlaceTy, Pointer, Scalar,\n };\n \n /// Data returned by Machine::stack_pop,\n@@ -105,7 +105,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     type MemoryExtra;\n \n     /// Extra data stored in every allocation.\n-    type AllocExtra: AllocationExtra<Self::PointerTag> + 'static;\n+    type AllocExtra: Debug + Clone + 'static;\n \n     /// Memory's allocation map\n     type MemoryMap: AllocMap<\n@@ -305,10 +305,38 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         kind: Option<MemoryKind<Self::MemoryKind>>,\n     ) -> (Cow<'b, Allocation<Self::PointerTag, Self::AllocExtra>>, Self::PointerTag);\n \n-    /// Called to notify the machine before a deallocation occurs.\n-    fn before_deallocation(\n+    /// Hook for performing extra checks on a memory read access.\n+    ///\n+    /// Takes read-only access to the allocation so we can keep all the memory read\n+    /// operations take `&self`. Use a `RefCell` in `AllocExtra` if you\n+    /// need to mutate.\n+    #[inline(always)]\n+    fn memory_read(\n+        _memory_extra: &Self::MemoryExtra,\n+        _alloc: &Allocation<Self::PointerTag, Self::AllocExtra>,\n+        _ptr: Pointer<Self::PointerTag>,\n+        _size: Size,\n+    ) -> InterpResult<'tcx> {\n+        Ok(())\n+    }\n+\n+    /// Hook for performing extra checks on a memory write access.\n+    #[inline(always)]\n+    fn memory_written(\n         _memory_extra: &mut Self::MemoryExtra,\n-        _id: AllocId,\n+        _alloc: &mut Allocation<Self::PointerTag, Self::AllocExtra>,\n+        _ptr: Pointer<Self::PointerTag>,\n+        _size: Size,\n+    ) -> InterpResult<'tcx> {\n+        Ok(())\n+    }\n+\n+    /// Hook for performing extra operations on a memory deallocation.\n+    #[inline(always)]\n+    fn memory_deallocated(\n+        _memory_extra: &mut Self::MemoryExtra,\n+        _alloc: &mut Allocation<Self::PointerTag, Self::AllocExtra>,\n+        _ptr: Pointer<Self::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         Ok(())\n     }\n@@ -322,7 +350,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         Ok(())\n     }\n \n-    /// Executes a retagging operation\n+    /// Executes a retagging operation.\n     #[inline]\n     fn retag(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,"}, {"sha": "37aaa834aff1cb4a06c417f5d0b36dad8ba44c47", "filename": "compiler/rustc_mir/src/interpret/memory.rs", "status": "modified", "additions": 268, "deletions": 90, "changes": 358, "blob_url": "https://github.com/rust-lang/rust/blob/3e827cc21e0734edd26170e8d1481f0d66a1426b/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e827cc21e0734edd26170e8d1481f0d66a1426b/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs?ref=3e827cc21e0734edd26170e8d1481f0d66a1426b", "patch": "@@ -18,8 +18,8 @@ use rustc_middle::ty::{Instance, ParamEnv, TyCtxt};\n use rustc_target::abi::{Align, HasDataLayout, Size, TargetDataLayout};\n \n use super::{\n-    AllocId, AllocMap, Allocation, AllocationExtra, CheckInAllocMsg, GlobalAlloc, InterpResult,\n-    Machine, MayLeak, Pointer, PointerArithmetic, Scalar,\n+    alloc_range, AllocId, AllocMap, AllocRange, Allocation, CheckInAllocMsg, GlobalAlloc,\n+    InterpResult, Machine, MayLeak, Pointer, PointerArithmetic, Scalar, ScalarMaybeUninit,\n };\n use crate::util::pretty;\n \n@@ -125,6 +125,24 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for Memory<'mir, 'tcx, M>\n     }\n }\n \n+/// A reference to some allocation that was already bounds-checked for the given region\n+/// and had the on-access machine hooks run.\n+#[derive(Copy, Clone)]\n+pub struct AllocRef<'a, 'tcx, Tag, Extra> {\n+    alloc: &'a Allocation<Tag, Extra>,\n+    range: AllocRange,\n+    tcx: TyCtxt<'tcx>,\n+    alloc_id: AllocId,\n+}\n+/// A reference to some allocation that was already bounds-checked for the given region\n+/// and had the on-access machine hooks run.\n+pub struct AllocRefMut<'a, 'tcx, Tag, Extra> {\n+    alloc: &'a mut Allocation<Tag, Extra>,\n+    range: AllocRange,\n+    tcx: TyCtxt<'tcx>,\n+    alloc_id: AllocId,\n+}\n+\n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     pub fn new(tcx: TyCtxt<'tcx>, extra: M::MemoryExtra) -> Self {\n         Memory {\n@@ -246,7 +264,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             Some((size, _align)) => size,\n             None => self.get_raw(ptr.alloc_id)?.size(),\n         };\n-        self.copy(ptr, new_ptr, old_size.min(new_size), /*nonoverlapping*/ true)?;\n+        // This will also call the access hooks.\n+        self.copy(\n+            ptr.into(),\n+            Align::ONE,\n+            new_ptr.into(),\n+            Align::ONE,\n+            old_size.min(new_size),\n+            /*nonoverlapping*/ true,\n+        )?;\n         self.deallocate(ptr, old_size_and_align, kind)?;\n \n         Ok(new_ptr)\n@@ -278,8 +304,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             );\n         }\n \n-        M::before_deallocation(&mut self.extra, ptr.alloc_id)?;\n-\n         let (alloc_kind, mut alloc) = match self.alloc_map.remove(&ptr.alloc_id) {\n             Some(alloc) => alloc,\n             None => {\n@@ -319,8 +343,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         }\n \n         // Let the machine take some extra action\n-        let size = alloc.size();\n-        AllocationExtra::memory_deallocated(&mut alloc, ptr, size)?;\n+        M::memory_deallocated(&mut self.extra, &mut alloc, ptr)?;\n \n         // Don't forget to remember size and align of this now-dead allocation\n         let old = self.dead_alloc_map.insert(ptr.alloc_id, (alloc.size(), alloc.align));\n@@ -331,40 +354,53 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    /// Check if the given scalar is allowed to do a memory access of given `size`\n-    /// and `align`. On success, returns `None` for zero-sized accesses (where\n-    /// nothing else is left to do) and a `Pointer` to use for the actual access otherwise.\n-    /// Crucially, if the input is a `Pointer`, we will test it for liveness\n-    /// *even if* the size is 0.\n-    ///\n-    /// Everyone accessing memory based on a `Scalar` should use this method to get the\n-    /// `Pointer` they need. And even if you already have a `Pointer`, call this method\n-    /// to make sure it is sufficiently aligned and not dangling.  Not doing that may\n-    /// cause ICEs.\n-    ///\n-    /// Most of the time you should use `check_mplace_access`, but when you just have a pointer,\n-    /// this method is still appropriate.\n+    /// Internal helper function for APIs that offer memory access based on `Scalar` pointers.\n     #[inline(always)]\n-    pub fn check_ptr_access(\n+    pub(super) fn check_ptr_access(\n         &self,\n         sptr: Scalar<M::PointerTag>,\n         size: Size,\n         align: Align,\n     ) -> InterpResult<'tcx, Option<Pointer<M::PointerTag>>> {\n         let align = M::enforce_alignment(&self.extra).then_some(align);\n-        self.check_ptr_access_align(sptr, size, align, CheckInAllocMsg::MemoryAccessTest)\n+        self.check_and_deref_ptr(sptr, size, align, CheckInAllocMsg::MemoryAccessTest, |ptr| {\n+            let (size, align) =\n+                self.get_size_and_align(ptr.alloc_id, AllocCheck::Dereferenceable)?;\n+            Ok((size, align, ptr))\n+        })\n     }\n \n-    /// Like `check_ptr_access`, but *definitely* checks alignment when `align`\n-    /// is `Some` (overriding `M::enforce_alignment`). Also lets the caller control\n-    /// the error message for the out-of-bounds case.\n+    /// Check if the given scalar is allowed to do a memory access of given `size` and `align`\n+    /// (ignoring `M::enforce_alignment`). The caller can control the error message for the\n+    /// out-of-bounds case.\n+    #[inline(always)]\n     pub fn check_ptr_access_align(\n+        &self,\n+        sptr: Scalar<M::PointerTag>,\n+        size: Size,\n+        align: Align,\n+        msg: CheckInAllocMsg,\n+    ) -> InterpResult<'tcx> {\n+        self.check_and_deref_ptr(sptr, size, Some(align), msg, |ptr| {\n+            let (size, align) =\n+                self.get_size_and_align(ptr.alloc_id, AllocCheck::Dereferenceable)?;\n+            Ok((size, align, ()))\n+        })?;\n+        Ok(())\n+    }\n+\n+    /// Low-level helper function to check if a ptr is in-bounds and potentially return a reference\n+    /// to the allocation it points to. Supports both shared and mutable references, to the actual\n+    /// checking is offloaded to a helper closure. `align` defines whether and which alignment check\n+    /// is done. Returns `None` for size 0, and otherwise `Some` of what `alloc_size` returned.\n+    fn check_and_deref_ptr<T>(\n         &self,\n         sptr: Scalar<M::PointerTag>,\n         size: Size,\n         align: Option<Align>,\n         msg: CheckInAllocMsg,\n-    ) -> InterpResult<'tcx, Option<Pointer<M::PointerTag>>> {\n+        alloc_size: impl FnOnce(Pointer<M::PointerTag>) -> InterpResult<'tcx, (Size, Align, T)>,\n+    ) -> InterpResult<'tcx, Option<T>> {\n         fn check_offset_align(offset: u64, align: Align) -> InterpResult<'static> {\n             if offset % align.bytes() == 0 {\n                 Ok(())\n@@ -402,8 +438,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 None\n             }\n             Err(ptr) => {\n-                let (allocation_size, alloc_align) =\n-                    self.get_size_and_align(ptr.alloc_id, AllocCheck::Dereferenceable)?;\n+                let (allocation_size, alloc_align, ret_val) = alloc_size(ptr)?;\n                 // Test bounds. This also ensures non-null.\n                 // It is sufficient to check this for the end pointer. The addition\n                 // checks for overflow.\n@@ -431,7 +466,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n                 // We can still be zero-sized in this branch, in which case we have to\n                 // return `None`.\n-                if size.bytes() == 0 { None } else { Some(ptr) }\n+                if size.bytes() == 0 { None } else { Some(ret_val) }\n             }\n         })\n     }\n@@ -502,8 +537,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     }\n \n     /// Gives raw access to the `Allocation`, without bounds or alignment checks.\n-    /// Use the higher-level, `PlaceTy`- and `OpTy`-based APIs in `InterpCx` instead!\n-    pub fn get_raw(\n+    /// The caller is responsible for calling the access hooks!\n+    fn get_raw(\n         &self,\n         id: AllocId,\n     ) -> InterpResult<'tcx, &Allocation<M::PointerTag, M::AllocExtra>> {\n@@ -537,14 +572,54 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         }\n     }\n \n+    /// \"Safe\" (bounds and align-checked) allocation access.\n+    pub fn get<'a>(\n+        &'a self,\n+        sptr: Scalar<M::PointerTag>,\n+        size: Size,\n+        align: Align,\n+    ) -> InterpResult<'tcx, Option<AllocRef<'a, 'tcx, M::PointerTag, M::AllocExtra>>> {\n+        let align = M::enforce_alignment(&self.extra).then_some(align);\n+        let ptr_and_alloc = self.check_and_deref_ptr(\n+            sptr,\n+            size,\n+            align,\n+            CheckInAllocMsg::MemoryAccessTest,\n+            |ptr| {\n+                let alloc = self.get_raw(ptr.alloc_id)?;\n+                Ok((alloc.size(), alloc.align, (ptr, alloc)))\n+            },\n+        )?;\n+        if let Some((ptr, alloc)) = ptr_and_alloc {\n+            M::memory_read(&self.extra, alloc, ptr, size)?;\n+            let range = alloc_range(ptr.offset, size);\n+            Ok(Some(AllocRef { alloc, range, tcx: self.tcx, alloc_id: ptr.alloc_id }))\n+        } else {\n+            // Even in this branch we have to be sure that we actually access the allocation, in\n+            // order to ensure that `static FOO: Type = FOO;` causes a cycle error instead of\n+            // magically pulling *any* ZST value from the ether. However, the `get_raw` above is\n+            // always called when `sptr` is truly a `Pointer`, so we are good.\n+            Ok(None)\n+        }\n+    }\n+\n+    /// Return the `extra` field of the given allocation.\n+    pub fn get_alloc_extra<'a>(&'a self, id: AllocId) -> InterpResult<'tcx, &'a M::AllocExtra> {\n+        Ok(&self.get_raw(id)?.extra)\n+    }\n+\n     /// Gives raw mutable access to the `Allocation`, without bounds or alignment checks.\n-    /// Use the higher-level, `PlaceTy`- and `OpTy`-based APIs in `InterpCx` instead!\n-    pub fn get_raw_mut(\n+    /// The caller is responsible for calling the access hooks!\n+    ///\n+    /// Also returns a ptr to `self.extra` so that the caller can use it in parallel with the\n+    /// allocation.\n+    fn get_raw_mut(\n         &mut self,\n         id: AllocId,\n-    ) -> InterpResult<'tcx, &mut Allocation<M::PointerTag, M::AllocExtra>> {\n+    ) -> InterpResult<'tcx, (&mut Allocation<M::PointerTag, M::AllocExtra>, &mut M::MemoryExtra)>\n+    {\n         let tcx = self.tcx;\n-        let memory_extra = &self.extra;\n+        let memory_extra = &mut self.extra;\n         let a = self.alloc_map.get_mut_or(id, || {\n             // Need to make a copy, even if `get_global_alloc` is able\n             // to give us a cheap reference.\n@@ -567,11 +642,40 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 if a.mutability == Mutability::Not {\n                     throw_ub!(WriteToReadOnly(id))\n                 }\n-                Ok(a)\n+                Ok((a, memory_extra))\n             }\n         }\n     }\n \n+    /// \"Safe\" (bounds and align-checked) allocation access.\n+    pub fn get_mut<'a>(\n+        &'a mut self,\n+        sptr: Scalar<M::PointerTag>,\n+        size: Size,\n+        align: Align,\n+    ) -> InterpResult<'tcx, Option<AllocRefMut<'a, 'tcx, M::PointerTag, M::AllocExtra>>> {\n+        let ptr = self.check_ptr_access(sptr, size, align)?;\n+        if let Some(ptr) = ptr {\n+            let tcx = self.tcx;\n+            // FIXME: can we somehow avoid looking up the allocation twice here?\n+            // We cannot call `get_raw_mut` inside `check_and_deref_ptr` as that would duplicate `&mut self`.\n+            let (alloc, extra) = self.get_raw_mut(ptr.alloc_id)?;\n+            M::memory_written(extra, alloc, ptr, size)?;\n+            let range = alloc_range(ptr.offset, size);\n+            Ok(Some(AllocRefMut { alloc, range, tcx, alloc_id: ptr.alloc_id }))\n+        } else {\n+            Ok(None)\n+        }\n+    }\n+\n+    /// Return the `extra` field of the given allocation.\n+    pub fn get_alloc_extra_mut<'a>(\n+        &'a mut self,\n+        id: AllocId,\n+    ) -> InterpResult<'tcx, &'a mut M::AllocExtra> {\n+        Ok(&mut self.get_raw_mut(id)?.0.extra)\n+    }\n+\n     /// Obtain the size and alignment of an allocation, even if that allocation has\n     /// been deallocated.\n     ///\n@@ -596,7 +700,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 // The caller requested no function pointers.\n                 throw_ub!(DerefFunctionPointer(id))\n             } else {\n-                Ok((Size::ZERO, Align::from_bytes(1).unwrap()))\n+                Ok((Size::ZERO, Align::ONE))\n             };\n         }\n \n@@ -658,7 +762,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     }\n \n     pub fn mark_immutable(&mut self, id: AllocId) -> InterpResult<'tcx> {\n-        self.get_raw_mut(id)?.mutability = Mutability::Not;\n+        self.get_raw_mut(id)?.0.mutability = Mutability::Not;\n         Ok(())\n     }\n \n@@ -792,31 +896,80 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> std::fmt::Debug for DumpAllocs<'a,\n }\n \n /// Reading and writing.\n+impl<'tcx, 'a, Tag: Copy, Extra> AllocRefMut<'a, 'tcx, Tag, Extra> {\n+    pub fn write_scalar(\n+        &mut self,\n+        range: AllocRange,\n+        val: ScalarMaybeUninit<Tag>,\n+    ) -> InterpResult<'tcx> {\n+        Ok(self\n+            .alloc\n+            .write_scalar(&self.tcx, self.range.subrange(range), val)\n+            .map_err(|e| e.to_interp_error(self.alloc_id))?)\n+    }\n+\n+    pub fn write_ptr_sized(\n+        &mut self,\n+        offset: Size,\n+        val: ScalarMaybeUninit<Tag>,\n+    ) -> InterpResult<'tcx> {\n+        self.write_scalar(alloc_range(offset, self.tcx.data_layout().pointer_size), val)\n+    }\n+}\n+\n+impl<'tcx, 'a, Tag: Copy, Extra> AllocRef<'a, 'tcx, Tag, Extra> {\n+    pub fn read_scalar(&self, range: AllocRange) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n+        Ok(self\n+            .alloc\n+            .read_scalar(&self.tcx, self.range.subrange(range))\n+            .map_err(|e| e.to_interp_error(self.alloc_id))?)\n+    }\n+\n+    pub fn read_ptr_sized(&self, offset: Size) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n+        self.read_scalar(alloc_range(offset, self.tcx.data_layout().pointer_size))\n+    }\n+\n+    pub fn check_bytes(&self, range: AllocRange, allow_uninit_and_ptr: bool) -> InterpResult<'tcx> {\n+        Ok(self\n+            .alloc\n+            .check_bytes(&self.tcx, self.range.subrange(range), allow_uninit_and_ptr)\n+            .map_err(|e| e.to_interp_error(self.alloc_id))?)\n+    }\n+}\n+\n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     /// Reads the given number of bytes from memory. Returns them as a slice.\n     ///\n     /// Performs appropriate bounds checks.\n-    pub fn read_bytes(&self, ptr: Scalar<M::PointerTag>, size: Size) -> InterpResult<'tcx, &[u8]> {\n-        let ptr = match self.check_ptr_access(ptr, size, Align::from_bytes(1).unwrap())? {\n-            Some(ptr) => ptr,\n+    pub fn read_bytes(&self, sptr: Scalar<M::PointerTag>, size: Size) -> InterpResult<'tcx, &[u8]> {\n+        let alloc_ref = match self.get(sptr, size, Align::ONE)? {\n+            Some(a) => a,\n             None => return Ok(&[]), // zero-sized access\n         };\n-        self.get_raw(ptr.alloc_id)?.get_bytes(self, ptr, size)\n+        // Side-step AllocRef and directly access the underlying bytes more efficiently.\n+        // (We are staying inside the bounds here so all is good.)\n+        Ok(alloc_ref\n+            .alloc\n+            .get_bytes(&alloc_ref.tcx, alloc_ref.range)\n+            .map_err(|e| e.to_interp_error(alloc_ref.alloc_id))?)\n     }\n \n     /// Writes the given stream of bytes into memory.\n     ///\n     /// Performs appropriate bounds checks.\n     pub fn write_bytes(\n         &mut self,\n-        ptr: Scalar<M::PointerTag>,\n+        sptr: Scalar<M::PointerTag>,\n         src: impl IntoIterator<Item = u8>,\n     ) -> InterpResult<'tcx> {\n         let mut src = src.into_iter();\n-        let size = Size::from_bytes(src.size_hint().0);\n-        // `write_bytes` checks that this lower bound `size` matches the upper bound and reality.\n-        let ptr = match self.check_ptr_access(ptr, size, Align::from_bytes(1).unwrap())? {\n-            Some(ptr) => ptr,\n+        let (lower, upper) = src.size_hint();\n+        let len = upper.expect(\"can only write bounded iterators\");\n+        assert_eq!(lower, len, \"can only write iterators with a precise length\");\n+\n+        let size = Size::from_bytes(len);\n+        let alloc_ref = match self.get_mut(sptr, size, Align::ONE)? {\n+            Some(alloc_ref) => alloc_ref,\n             None => {\n                 // zero-sized access\n                 assert_matches!(\n@@ -827,56 +980,88 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 return Ok(());\n             }\n         };\n-        let tcx = self.tcx;\n-        self.get_raw_mut(ptr.alloc_id)?.write_bytes(&tcx, ptr, src)\n+\n+        // Side-step AllocRef and directly access the underlying bytes more efficiently.\n+        // (We are staying inside the bounds here so all is good.)\n+        let bytes = alloc_ref.alloc.get_bytes_mut(&alloc_ref.tcx, alloc_ref.range);\n+        // `zip` would stop when the first iterator ends; we want to definitely\n+        // cover all of `bytes`.\n+        for dest in bytes {\n+            *dest = src.next().expect(\"iterator was shorter than it said it would be\");\n+        }\n+        assert_matches!(src.next(), None, \"iterator was longer than it said it would be\");\n+        Ok(())\n     }\n \n-    /// Expects the caller to have checked bounds and alignment.\n     pub fn copy(\n         &mut self,\n-        src: Pointer<M::PointerTag>,\n-        dest: Pointer<M::PointerTag>,\n+        src: Scalar<M::PointerTag>,\n+        src_align: Align,\n+        dest: Scalar<M::PointerTag>,\n+        dest_align: Align,\n         size: Size,\n         nonoverlapping: bool,\n     ) -> InterpResult<'tcx> {\n-        self.copy_repeatedly(src, dest, size, 1, nonoverlapping)\n+        self.copy_repeatedly(src, src_align, dest, dest_align, size, 1, nonoverlapping)\n     }\n \n-    /// Expects the caller to have checked bounds and alignment.\n     pub fn copy_repeatedly(\n         &mut self,\n-        src: Pointer<M::PointerTag>,\n-        dest: Pointer<M::PointerTag>,\n+        src: Scalar<M::PointerTag>,\n+        src_align: Align,\n+        dest: Scalar<M::PointerTag>,\n+        dest_align: Align,\n         size: Size,\n-        length: u64,\n+        num_copies: u64,\n         nonoverlapping: bool,\n     ) -> InterpResult<'tcx> {\n+        let tcx = self.tcx;\n+        // We need to do our own bounds-checks.\n+        let src = self.check_ptr_access(src, size, src_align)?;\n+        let dest = self.check_ptr_access(dest, size * num_copies, dest_align)?; // `Size` multiplication\n+\n+        // FIXME: we look up both allocations twice here, once ebfore for the `check_ptr_access`\n+        // and once below to get the underlying `&[mut] Allocation`.\n+\n+        // Source alloc preparations and access hooks.\n+        let src = match src {\n+            None => return Ok(()), // Zero-sized *source*, that means dst is also zero-sized and we have nothing to do.\n+            Some(src_ptr) => src_ptr,\n+        };\n+        let src_alloc = self.get_raw(src.alloc_id)?;\n+        M::memory_read(&self.extra, src_alloc, src, size)?;\n+        // We need the `dest` ptr for the next operation, so we get it now.\n+        // We already did the source checks and called the hooks so we are good to return early.\n+        let dest = match dest {\n+            None => return Ok(()), // Zero-sized *destiantion*.\n+            Some(dest_ptr) => dest_ptr,\n+        };\n+\n         // first copy the relocations to a temporary buffer, because\n         // `get_bytes_mut` will clear the relocations, which is correct,\n         // since we don't want to keep any relocations at the target.\n         // (`get_bytes_with_uninit_and_ptr` below checks that there are no\n         // relocations overlapping the edges; those would not be handled correctly).\n-        let relocations =\n-            self.get_raw(src.alloc_id)?.prepare_relocation_copy(self, src, size, dest, length);\n-\n-        let tcx = self.tcx;\n-\n-        // This checks relocation edges on the src.\n-        let src_bytes =\n-            self.get_raw(src.alloc_id)?.get_bytes_with_uninit_and_ptr(&tcx, src, size)?.as_ptr();\n-        let dest_bytes =\n-            self.get_raw_mut(dest.alloc_id)?.get_bytes_mut(&tcx, dest, size * length)?; // `Size` multiplication\n-\n-        // If `dest_bytes` is empty we just optimize to not run anything for zsts.\n-        // See #67539\n-        if dest_bytes.is_empty() {\n-            return Ok(());\n-        }\n-\n-        let dest_bytes = dest_bytes.as_mut_ptr();\n-\n+        let relocations = src_alloc.prepare_relocation_copy(\n+            self,\n+            alloc_range(src.offset, size),\n+            dest.offset,\n+            num_copies,\n+        );\n         // Prepare a copy of the initialization mask.\n-        let compressed = self.get_raw(src.alloc_id)?.compress_uninit_range(src, size);\n+        let compressed = src_alloc.compress_uninit_range(src, size);\n+        // This checks relocation edges on the src.\n+        let src_bytes = src_alloc\n+            .get_bytes_with_uninit_and_ptr(&tcx, alloc_range(src.offset, size))\n+            .map_err(|e| e.to_interp_error(src.alloc_id))?\n+            .as_ptr(); // raw ptr, so we can also get a ptr to the destination allocation\n+\n+        // Destination alloc preparations and access hooks.\n+        let (dest_alloc, extra) = self.get_raw_mut(dest.alloc_id)?;\n+        M::memory_written(extra, dest_alloc, dest, size * num_copies)?;\n+        let dest_bytes = dest_alloc\n+            .get_bytes_mut_ptr(&tcx, alloc_range(dest.offset, size * num_copies))\n+            .as_mut_ptr();\n \n         if compressed.no_bytes_init() {\n             // Fast path: If all bytes are `uninit` then there is nothing to copy. The target range\n@@ -885,8 +1070,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             // This also avoids writing to the target bytes so that the backing allocation is never\n             // touched if the bytes stay uninitialized for the whole interpreter execution. On contemporary\n             // operating system this can avoid physically allocating the page.\n-            let dest_alloc = self.get_raw_mut(dest.alloc_id)?;\n-            dest_alloc.mark_init(dest, size * length, false); // `Size` multiplication\n+            dest_alloc.mark_init(alloc_range(dest.offset, size * num_copies), false); // `Size` multiplication\n             dest_alloc.mark_relocation_range(relocations);\n             return Ok(());\n         }\n@@ -907,15 +1091,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                     }\n                 }\n \n-                for i in 0..length {\n+                for i in 0..num_copies {\n                     ptr::copy(\n                         src_bytes,\n                         dest_bytes.add((size * i).bytes_usize()), // `Size` multiplication\n                         size.bytes_usize(),\n                     );\n                 }\n             } else {\n-                for i in 0..length {\n+                for i in 0..num_copies {\n                     ptr::copy_nonoverlapping(\n                         src_bytes,\n                         dest_bytes.add((size * i).bytes_usize()), // `Size` multiplication\n@@ -925,16 +1109,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             }\n         }\n \n-        // now fill in all the data\n-        self.get_raw_mut(dest.alloc_id)?.mark_compressed_init_range(\n-            &compressed,\n-            dest,\n-            size,\n-            length,\n-        );\n-\n+        // now fill in all the \"init\" data\n+        dest_alloc.mark_compressed_init_range(&compressed, dest, size, num_copies);\n         // copy the relocations to the destination\n-        self.get_raw_mut(dest.alloc_id)?.mark_relocation_range(relocations);\n+        dest_alloc.mark_relocation_range(relocations);\n \n         Ok(())\n     }"}, {"sha": "9b95f691167e55b87fbee8efe055199f75e49f51", "filename": "compiler/rustc_mir/src/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e827cc21e0734edd26170e8d1481f0d66a1426b/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e827cc21e0734edd26170e8d1481f0d66a1426b/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmod.rs?ref=3e827cc21e0734edd26170e8d1481f0d66a1426b", "patch": "@@ -21,7 +21,7 @@ pub use rustc_middle::mir::interpret::*; // have all the `interpret` symbols in\n pub use self::eval_context::{Frame, FrameInfo, InterpCx, LocalState, LocalValue, StackPopCleanup};\n pub use self::intern::{intern_const_alloc_recursive, InternKind};\n pub use self::machine::{compile_time_machine, AllocMap, Machine, MayLeak, StackPopJump};\n-pub use self::memory::{AllocCheck, FnVal, Memory, MemoryKind};\n+pub use self::memory::{AllocCheck, AllocRef, AllocRefMut, FnVal, Memory, MemoryKind};\n pub use self::operand::{ImmTy, Immediate, OpTy, Operand};\n pub use self::place::{MPlaceTy, MemPlace, MemPlaceMeta, Place, PlaceTy};\n pub use self::validity::{CtfeValidationMode, RefTracking};"}, {"sha": "06432a8b9024b341f7f2e42495f7510f100614bb", "filename": "compiler/rustc_mir/src/interpret/operand.rs", "status": "modified", "additions": 6, "deletions": 20, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3e827cc21e0734edd26170e8d1481f0d66a1426b/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e827cc21e0734edd26170e8d1481f0d66a1426b/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs?ref=3e827cc21e0734edd26170e8d1481f0d66a1426b", "patch": "@@ -15,8 +15,8 @@ use rustc_target::abi::{Abi, HasDataLayout, LayoutOf, Size, TagEncoding};\n use rustc_target::abi::{VariantIdx, Variants};\n \n use super::{\n-    from_known_layout, mir_assign_valid_types, ConstValue, GlobalId, InterpCx, InterpResult,\n-    MPlaceTy, Machine, MemPlace, Place, PlaceTy, Pointer, Scalar, ScalarMaybeUninit,\n+    alloc_range, from_known_layout, mir_assign_valid_types, ConstValue, GlobalId, InterpCx,\n+    InterpResult, MPlaceTy, Machine, MemPlace, Place, PlaceTy, Pointer, Scalar, ScalarMaybeUninit,\n };\n \n /// An `Immediate` represents a single immediate self-contained Rust value.\n@@ -249,19 +249,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             return Ok(None);\n         }\n \n-        let ptr = match self\n-            .check_mplace_access(mplace, None)\n-            .expect(\"places should be checked on creation\")\n-        {\n+        let alloc = match self.get_alloc(mplace)? {\n             Some(ptr) => ptr,\n             None => {\n-                if let Scalar::Ptr(ptr) = mplace.ptr {\n-                    // We may be reading from a static.\n-                    // In order to ensure that `static FOO: Type = FOO;` causes a cycle error\n-                    // instead of magically pulling *any* ZST value from the ether, we need to\n-                    // actually access the referenced allocation.\n-                    self.memory.get_raw(ptr.alloc_id)?;\n-                }\n                 return Ok(Some(ImmTy {\n                     // zero-sized type\n                     imm: Scalar::ZST.into(),\n@@ -270,11 +260,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n         };\n \n-        let alloc = self.memory.get_raw(ptr.alloc_id)?;\n-\n         match mplace.layout.abi {\n             Abi::Scalar(..) => {\n-                let scalar = alloc.read_scalar(self, ptr, mplace.layout.size)?;\n+                let scalar = alloc.read_scalar(alloc_range(Size::ZERO, mplace.layout.size))?;\n                 Ok(Some(ImmTy { imm: scalar.into(), layout: mplace.layout }))\n             }\n             Abi::ScalarPair(ref a, ref b) => {\n@@ -283,12 +271,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // which `ptr.offset(b_offset)` cannot possibly fail to satisfy.\n                 let (a, b) = (&a.value, &b.value);\n                 let (a_size, b_size) = (a.size(self), b.size(self));\n-                let a_ptr = ptr;\n                 let b_offset = a_size.align_to(b.align(self).abi);\n                 assert!(b_offset.bytes() > 0); // we later use the offset to tell apart the fields\n-                let b_ptr = ptr.offset(b_offset, self)?;\n-                let a_val = alloc.read_scalar(self, a_ptr, a_size)?;\n-                let b_val = alloc.read_scalar(self, b_ptr, b_size)?;\n+                let a_val = alloc.read_scalar(alloc_range(Size::ZERO, a_size))?;\n+                let b_val = alloc.read_scalar(alloc_range(b_offset, b_size))?;\n                 Ok(Some(ImmTy { imm: Immediate::ScalarPair(a_val, b_val), layout: mplace.layout }))\n             }\n             _ => Ok(None),"}, {"sha": "ef603b51554c249c622d9b4099e17ffd12b47547", "filename": "compiler/rustc_mir/src/interpret/place.rs", "status": "modified", "additions": 36, "deletions": 54, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/3e827cc21e0734edd26170e8d1481f0d66a1426b/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e827cc21e0734edd26170e8d1481f0d66a1426b/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs?ref=3e827cc21e0734edd26170e8d1481f0d66a1426b", "patch": "@@ -14,9 +14,9 @@ use rustc_target::abi::{Abi, Align, FieldsShape, TagEncoding};\n use rustc_target::abi::{HasDataLayout, LayoutOf, Size, VariantIdx, Variants};\n \n use super::{\n-    mir_assign_valid_types, AllocId, AllocMap, Allocation, AllocationExtra, ConstAlloc, ImmTy,\n-    Immediate, InterpCx, InterpResult, LocalValue, Machine, MemoryKind, OpTy, Operand, Pointer,\n-    PointerArithmetic, Scalar, ScalarMaybeUninit,\n+    alloc_range, mir_assign_valid_types, AllocId, AllocMap, AllocRef, AllocRefMut, Allocation,\n+    ConstAlloc, ImmTy, Immediate, InterpCx, InterpResult, LocalValue, Machine, MemoryKind, OpTy,\n+    Operand, Pointer, PointerArithmetic, Scalar, ScalarMaybeUninit,\n };\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable)]\n@@ -293,7 +293,6 @@ where\n     M: Machine<'mir, 'tcx, PointerTag = Tag>,\n     // FIXME: Working around https://github.com/rust-lang/rust/issues/24159\n     M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKind>, Allocation<Tag, M::AllocExtra>)>,\n-    M::AllocExtra: AllocationExtra<Tag>,\n {\n     /// Take a value, which represents a (thin or wide) reference, and make it a place.\n     /// Alignment is just based on the type.  This is the inverse of `MemPlace::to_ref()`.\n@@ -339,24 +338,26 @@ where\n         self.mplace_access_checked(place, None)\n     }\n \n-    /// Check if the given place is good for memory access with the given\n-    /// size, falling back to the layout's size if `None` (in the latter case,\n-    /// this must be a statically sized type).\n-    ///\n-    /// On success, returns `None` for zero-sized accesses (where nothing else is\n-    /// left to do) and a `Pointer` to use for the actual access otherwise.\n     #[inline]\n-    pub(super) fn check_mplace_access(\n+    pub(super) fn get_alloc(\n         &self,\n         place: &MPlaceTy<'tcx, M::PointerTag>,\n-        size: Option<Size>,\n-    ) -> InterpResult<'tcx, Option<Pointer<M::PointerTag>>> {\n-        let size = size.unwrap_or_else(|| {\n-            assert!(!place.layout.is_unsized());\n-            assert!(!place.meta.has_meta());\n-            place.layout.size\n-        });\n-        self.memory.check_ptr_access(place.ptr, size, place.align)\n+    ) -> InterpResult<'tcx, Option<AllocRef<'_, 'tcx, M::PointerTag, M::AllocExtra>>> {\n+        assert!(!place.layout.is_unsized());\n+        assert!(!place.meta.has_meta());\n+        let size = place.layout.size;\n+        self.memory.get(place.ptr, size, place.align)\n+    }\n+\n+    #[inline]\n+    pub(super) fn get_alloc_mut(\n+        &mut self,\n+        place: &MPlaceTy<'tcx, M::PointerTag>,\n+    ) -> InterpResult<'tcx, Option<AllocRefMut<'_, 'tcx, M::PointerTag, M::AllocExtra>>> {\n+        assert!(!place.layout.is_unsized());\n+        assert!(!place.meta.has_meta());\n+        let size = place.layout.size;\n+        self.memory.get_mut(place.ptr, size, place.align)\n     }\n \n     /// Return the \"access-checked\" version of this `MPlace`, where for non-ZST\n@@ -373,10 +374,11 @@ where\n             .size_and_align_of_mplace(&place)?\n             .unwrap_or((place.layout.size, place.layout.align.abi));\n         assert!(place.mplace.align <= align, \"dynamic alignment less strict than static one?\");\n-        // Check (stricter) dynamic alignment, unless forced otherwise.\n-        place.mplace.align = force_align.unwrap_or(align);\n+        let align = force_align.unwrap_or(align);\n+        // Record new (stricter, unless forced) alignment requirement in place.\n+        place.mplace.align = align;\n         // When dereferencing a pointer, it must be non-null, aligned, and live.\n-        if let Some(ptr) = self.check_mplace_access(&place, Some(size))? {\n+        if let Some(ptr) = self.memory.check_ptr_access(place.ptr, size, align)? {\n             place.mplace.ptr = ptr.into();\n         }\n         Ok(place)\n@@ -786,12 +788,12 @@ where\n         // wrong type.\n \n         // Invalid places are a thing: the return place of a diverging function\n-        let ptr = match self.check_mplace_access(dest, None)? {\n-            Some(ptr) => ptr,\n+        let tcx = *self.tcx;\n+        let mut alloc = match self.get_alloc_mut(dest)? {\n+            Some(a) => a,\n             None => return Ok(()), // zero-sized access\n         };\n \n-        let tcx = *self.tcx;\n         // FIXME: We should check that there are dest.layout.size many bytes available in\n         // memory.  The code below is not sufficient, with enough padding it might not\n         // cover all the bytes!\n@@ -805,12 +807,7 @@ where\n                         dest.layout\n                     ),\n                 }\n-                self.memory.get_raw_mut(ptr.alloc_id)?.write_scalar(\n-                    &tcx,\n-                    ptr,\n-                    scalar,\n-                    dest.layout.size,\n-                )\n+                alloc.write_scalar(alloc_range(Size::ZERO, dest.layout.size), scalar)\n             }\n             Immediate::ScalarPair(a_val, b_val) => {\n                 // We checked `ptr_align` above, so all fields will have the alignment they need.\n@@ -824,16 +821,15 @@ where\n                         dest.layout\n                     ),\n                 };\n-                let (a_size, b_size) = (a.size(self), b.size(self));\n-                let b_offset = a_size.align_to(b.align(self).abi);\n-                let b_ptr = ptr.offset(b_offset, self)?;\n+                let (a_size, b_size) = (a.size(&tcx), b.size(&tcx));\n+                let b_offset = a_size.align_to(b.align(&tcx).abi);\n \n                 // It is tempting to verify `b_offset` against `layout.fields.offset(1)`,\n                 // but that does not work: We could be a newtype around a pair, then the\n                 // fields do not match the `ScalarPair` components.\n \n-                self.memory.get_raw_mut(ptr.alloc_id)?.write_scalar(&tcx, ptr, a_val, a_size)?;\n-                self.memory.get_raw_mut(b_ptr.alloc_id)?.write_scalar(&tcx, b_ptr, b_val, b_size)\n+                alloc.write_scalar(alloc_range(Size::ZERO, a_size), a_val)?;\n+                alloc.write_scalar(alloc_range(b_offset, b_size), b_val)\n             }\n         }\n     }\n@@ -902,19 +898,8 @@ where\n         });\n         assert_eq!(src.meta, dest.meta, \"Can only copy between equally-sized instances\");\n \n-        let src = self\n-            .check_mplace_access(&src, Some(size))\n-            .expect(\"places should be checked on creation\");\n-        let dest = self\n-            .check_mplace_access(&dest, Some(size))\n-            .expect(\"places should be checked on creation\");\n-        let (src_ptr, dest_ptr) = match (src, dest) {\n-            (Some(src_ptr), Some(dest_ptr)) => (src_ptr, dest_ptr),\n-            (None, None) => return Ok(()), // zero-sized copy\n-            _ => bug!(\"The pointers should both be Some or both None\"),\n-        };\n-\n-        self.memory.copy(src_ptr, dest_ptr, size, /*nonoverlapping*/ true)\n+        self.memory\n+            .copy(src.ptr, src.align, dest.ptr, dest.align, size, /*nonoverlapping*/ true)\n     }\n \n     /// Copies the data from an operand to a place. The layouts may disagree, but they must\n@@ -1047,11 +1032,8 @@ where\n     ) -> MPlaceTy<'tcx, M::PointerTag> {\n         let ptr = self.memory.allocate_bytes(str.as_bytes(), kind);\n         let meta = Scalar::from_machine_usize(u64::try_from(str.len()).unwrap(), self);\n-        let mplace = MemPlace {\n-            ptr: ptr.into(),\n-            align: Align::from_bytes(1).unwrap(),\n-            meta: MemPlaceMeta::Meta(meta),\n-        };\n+        let mplace =\n+            MemPlace { ptr: ptr.into(), align: Align::ONE, meta: MemPlaceMeta::Meta(meta) };\n \n         let layout = self.layout_of(self.tcx.mk_static_str()).unwrap();\n         MPlaceTy { mplace, layout }"}, {"sha": "129dd8f8e01255f2ed36a3415e9d888df64ea148", "filename": "compiler/rustc_mir/src/interpret/step.rs", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3e827cc21e0734edd26170e8d1481f0d66a1426b/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e827cc21e0734edd26170e8d1481f0d66a1426b/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fstep.rs?ref=3e827cc21e0734edd26170e8d1481f0d66a1426b", "patch": "@@ -222,28 +222,34 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n \n             Repeat(ref operand, _) => {\n-                let op = self.eval_operand(operand, None)?;\n+                let src = self.eval_operand(operand, None)?;\n+                assert!(!src.layout.is_unsized());\n                 let dest = self.force_allocation(&dest)?;\n                 let length = dest.len(self)?;\n \n-                if let Some(first_ptr) = self.check_mplace_access(&dest, None)? {\n-                    // Write the first.\n+                if length == 0 {\n+                    // Nothing to copy... but let's still make sure that `dest` as a place is valid.\n+                    self.get_alloc_mut(&dest)?;\n+                } else {\n+                    // Write the src to the first element.\n                     let first = self.mplace_field(&dest, 0)?;\n-                    self.copy_op(&op, &first.into())?;\n-\n-                    if length > 1 {\n-                        let elem_size = first.layout.size;\n-                        // Copy the rest. This is performance-sensitive code\n-                        // for big static/const arrays!\n-                        let rest_ptr = first_ptr.offset(elem_size, self)?;\n-                        self.memory.copy_repeatedly(\n-                            first_ptr,\n-                            rest_ptr,\n-                            elem_size,\n-                            length - 1,\n-                            /*nonoverlapping:*/ true,\n-                        )?;\n-                    }\n+                    self.copy_op(&src, &first.into())?;\n+\n+                    // This is performance-sensitive code for big static/const arrays! So we\n+                    // avoid writing each operand individually and instead just make many copies\n+                    // of the first element.\n+                    let elem_size = first.layout.size;\n+                    let first_ptr = first.ptr;\n+                    let rest_ptr = first_ptr.ptr_offset(elem_size, self)?;\n+                    self.memory.copy_repeatedly(\n+                        first_ptr,\n+                        first.align,\n+                        rest_ptr,\n+                        first.align,\n+                        elem_size,\n+                        length - 1,\n+                        /*nonoverlapping:*/ true,\n+                    )?;\n                 }\n             }\n "}, {"sha": "11f8d388820e84de951e8fa7085424fa8e42a5a7", "filename": "compiler/rustc_mir/src/interpret/traits.rs", "status": "modified", "additions": 30, "deletions": 41, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/3e827cc21e0734edd26170e8d1481f0d66a1426b/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e827cc21e0734edd26170e8d1481f0d66a1426b/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Ftraits.rs?ref=3e827cc21e0734edd26170e8d1481f0d66a1426b", "patch": "@@ -62,32 +62,32 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let drop = Instance::resolve_drop_in_place(tcx, ty);\n         let drop = self.memory.create_fn_alloc(FnVal::Instance(drop));\n \n+        // Prepare the fn ptrs we will write into the vtable later.\n+        let fn_ptrs = methods\n+            .iter()\n+            .enumerate() // remember the original position\n+            .filter_map(|(i, method)| {\n+                if let Some((def_id, substs)) = method { Some((i, def_id, substs)) } else { None }\n+            })\n+            .map(|(i, def_id, substs)| {\n+                let instance =\n+                    ty::Instance::resolve_for_vtable(tcx, self.param_env, *def_id, substs)\n+                        .ok_or_else(|| err_inval!(TooGeneric))?;\n+                Ok((i, self.memory.create_fn_alloc(FnVal::Instance(instance))))\n+            })\n+            .collect::<InterpResult<'tcx, Vec<(usize, Pointer<M::PointerTag>)>>>()?;\n+\n         // No need to do any alignment checks on the memory accesses below, because we know the\n         // allocation is correctly aligned as we created it above. Also we're only offsetting by\n         // multiples of `ptr_align`, which means that it will stay aligned to `ptr_align`.\n-        let vtable_alloc = self.memory.get_raw_mut(vtable.alloc_id)?;\n-        vtable_alloc.write_ptr_sized(&tcx, vtable, drop.into())?;\n-\n-        let size_ptr = vtable.offset(ptr_size, &tcx)?;\n-        vtable_alloc.write_ptr_sized(&tcx, size_ptr, Scalar::from_uint(size, ptr_size).into())?;\n-        let align_ptr = vtable.offset(ptr_size * 2, &tcx)?;\n-        vtable_alloc.write_ptr_sized(&tcx, align_ptr, Scalar::from_uint(align, ptr_size).into())?;\n-\n-        for (i, method) in methods.iter().enumerate() {\n-            if let Some((def_id, substs)) = *method {\n-                // resolve for vtable: insert shims where needed\n-                let instance =\n-                    ty::Instance::resolve_for_vtable(tcx, self.param_env, def_id, substs)\n-                        .ok_or_else(|| err_inval!(TooGeneric))?;\n-                let fn_ptr = self.memory.create_fn_alloc(FnVal::Instance(instance));\n-                // We cannot use `vtable_allic` as we are creating fn ptrs in this loop.\n-                let method_ptr = vtable.offset(ptr_size * (3 + i as u64), &tcx)?;\n-                self.memory.get_raw_mut(vtable.alloc_id)?.write_ptr_sized(\n-                    &tcx,\n-                    method_ptr,\n-                    fn_ptr.into(),\n-                )?;\n-            }\n+        let mut vtable_alloc =\n+            self.memory.get_mut(vtable.into(), vtable_size, ptr_align)?.expect(\"not a ZST\");\n+        vtable_alloc.write_ptr_sized(ptr_size * 0, drop.into())?;\n+        vtable_alloc.write_ptr_sized(ptr_size * 1, Scalar::from_uint(size, ptr_size).into())?;\n+        vtable_alloc.write_ptr_sized(ptr_size * 2, Scalar::from_uint(align, ptr_size).into())?;\n+\n+        for (i, fn_ptr) in fn_ptrs.into_iter() {\n+            vtable_alloc.write_ptr_sized(ptr_size * (3 + i as u64), fn_ptr.into())?;\n         }\n \n         M::after_static_mem_initialized(self, vtable, vtable_size)?;\n@@ -111,13 +111,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let vtable_slot = vtable.ptr_offset(ptr_size * idx.checked_add(3).unwrap(), self)?;\n         let vtable_slot = self\n             .memory\n-            .check_ptr_access(vtable_slot, ptr_size, self.tcx.data_layout.pointer_align.abi)?\n+            .get(vtable_slot, ptr_size, self.tcx.data_layout.pointer_align.abi)?\n             .expect(\"cannot be a ZST\");\n-        let fn_ptr = self\n-            .memory\n-            .get_raw(vtable_slot.alloc_id)?\n-            .read_ptr_sized(self, vtable_slot)?\n-            .check_init()?;\n+        let fn_ptr = vtable_slot.read_ptr_sized(Size::ZERO)?.check_init()?;\n         self.memory.get_fn(fn_ptr)\n     }\n \n@@ -129,14 +125,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // We don't care about the pointee type; we just want a pointer.\n         let vtable = self\n             .memory\n-            .check_ptr_access(\n-                vtable,\n-                self.tcx.data_layout.pointer_size,\n-                self.tcx.data_layout.pointer_align.abi,\n-            )?\n+            .get(vtable, self.tcx.data_layout.pointer_size, self.tcx.data_layout.pointer_align.abi)?\n             .expect(\"cannot be a ZST\");\n-        let drop_fn =\n-            self.memory.get_raw(vtable.alloc_id)?.read_ptr_sized(self, vtable)?.check_init()?;\n+        let drop_fn = vtable.read_ptr_sized(Size::ZERO)?.check_init()?;\n         // We *need* an instance here, no other kind of function value, to be able\n         // to determine the type.\n         let drop_instance = self.memory.get_fn(drop_fn)?.as_instance()?;\n@@ -161,13 +152,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // the size, and the align (which we read below).\n         let vtable = self\n             .memory\n-            .check_ptr_access(vtable, 3 * pointer_size, self.tcx.data_layout.pointer_align.abi)?\n+            .get(vtable, 3 * pointer_size, self.tcx.data_layout.pointer_align.abi)?\n             .expect(\"cannot be a ZST\");\n-        let alloc = self.memory.get_raw(vtable.alloc_id)?;\n-        let size = alloc.read_ptr_sized(self, vtable.offset(pointer_size, self)?)?.check_init()?;\n+        let size = vtable.read_ptr_sized(pointer_size)?.check_init()?;\n         let size = u64::try_from(self.force_bits(size, pointer_size)?).unwrap();\n-        let align =\n-            alloc.read_ptr_sized(self, vtable.offset(pointer_size * 2, self)?)?.check_init()?;\n+        let align = vtable.read_ptr_sized(pointer_size * 2)?.check_init()?;\n         let align = u64::try_from(self.force_bits(align, pointer_size)?).unwrap();\n \n         if size >= self.tcx.data_layout.obj_size_bound() {"}, {"sha": "fb165a991bceba5ae6e5cef17472e64b511162ff", "filename": "compiler/rustc_mir/src/interpret/validity.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/3e827cc21e0734edd26170e8d1481f0d66a1426b/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e827cc21e0734edd26170e8d1481f0d66a1426b/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs?ref=3e827cc21e0734edd26170e8d1481f0d66a1426b", "patch": "@@ -15,13 +15,13 @@ use rustc_middle::mir::interpret::InterpError;\n use rustc_middle::ty;\n use rustc_middle::ty::layout::TyAndLayout;\n use rustc_span::symbol::{sym, Symbol};\n-use rustc_target::abi::{Abi, LayoutOf, Scalar, Size, VariantIdx, Variants};\n+use rustc_target::abi::{Abi, LayoutOf, Scalar as ScalarAbi, Size, VariantIdx, Variants};\n \n use std::hash::Hash;\n \n use super::{\n-    CheckInAllocMsg, GlobalAlloc, InterpCx, InterpResult, MPlaceTy, Machine, MemPlaceMeta, OpTy,\n-    ScalarMaybeUninit, ValueVisitor,\n+    alloc_range, CheckInAllocMsg, GlobalAlloc, InterpCx, InterpResult, MPlaceTy, Machine,\n+    MemPlaceMeta, OpTy, Scalar, ScalarMaybeUninit, ValueVisitor,\n };\n \n macro_rules! throw_validation_failure {\n@@ -329,7 +329,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                     self.ecx.memory.check_ptr_access_align(\n                         vtable,\n                         3 * self.ecx.tcx.data_layout.pointer_size, // drop, size, align\n-                        Some(self.ecx.tcx.data_layout.pointer_align.abi),\n+                        self.ecx.tcx.data_layout.pointer_align.abi,\n                         CheckInAllocMsg::InboundsTest, // will anyway be replaced by validity message\n                     ),\n                     self.path,\n@@ -411,11 +411,11 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n             // alignment should take attributes into account).\n             .unwrap_or_else(|| (place.layout.size, place.layout.align.abi));\n         // Direct call to `check_ptr_access_align` checks alignment even on CTFE machines.\n-        let ptr: Option<_> = try_validation!(\n+        try_validation!(\n             self.ecx.memory.check_ptr_access_align(\n                 place.ptr,\n                 size,\n-                Some(align),\n+                align,\n                 CheckInAllocMsg::InboundsTest, // will anyway be replaced by validity message\n             ),\n             self.path,\n@@ -441,9 +441,18 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         );\n         // Recursive checking\n         if let Some(ref mut ref_tracking) = self.ref_tracking {\n-            if let Some(ptr) = ptr {\n+            // Proceed recursively even for ZST, no reason to skip them!\n+            // `!` is a ZST and we want to validate it.\n+            // Normalize before handing `place` to tracking because that will\n+            // check for duplicates.\n+            let place = if size.bytes() > 0 {\n+                self.ecx.force_mplace_ptr(place).expect(\"we already bounds-checked\")\n+            } else {\n+                place\n+            };\n+            // Skip validation entirely for some external statics\n+            if let Scalar::Ptr(ptr) = place.ptr {\n                 // not a ZST\n-                // Skip validation entirely for some external statics\n                 let alloc_kind = self.ecx.tcx.get_global_alloc(ptr.alloc_id);\n                 if let Some(GlobalAlloc::Static(did)) = alloc_kind {\n                     assert!(!self.ecx.tcx.is_thread_local_static(did));\n@@ -473,15 +482,6 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                     return Ok(());\n                 }\n             }\n-            // Proceed recursively even for ZST, no reason to skip them!\n-            // `!` is a ZST and we want to validate it.\n-            // Normalize before handing `place` to tracking because that will\n-            // check for duplicates.\n-            let place = if size.bytes() > 0 {\n-                self.ecx.force_mplace_ptr(place).expect(\"we already bounds-checked\")\n-            } else {\n-                place\n-            };\n             let path = &self.path;\n             ref_tracking.track(place, || {\n                 // We need to clone the path anyway, make sure it gets created\n@@ -638,7 +638,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n     fn visit_scalar(\n         &mut self,\n         op: &OpTy<'tcx, M::PointerTag>,\n-        scalar_layout: &Scalar,\n+        scalar_layout: &ScalarAbi,\n     ) -> InterpResult<'tcx> {\n         let value = self.read_scalar(op)?;\n         let valid_range = &scalar_layout.valid_range;\n@@ -851,16 +851,10 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 let mplace = op.assert_mem_place(self.ecx);\n                 // This is the length of the array/slice.\n                 let len = mplace.len(self.ecx)?;\n-                // Zero length slices have nothing to be checked.\n-                if len == 0 {\n-                    return Ok(());\n-                }\n                 // This is the element type size.\n                 let layout = self.ecx.layout_of(tys)?;\n                 // This is the size in bytes of the whole array. (This checks for overflow.)\n                 let size = layout.size * len;\n-                // Size is not 0, get a pointer.\n-                let ptr = self.ecx.force_ptr(mplace.ptr)?;\n \n                 // Optimization: we just check the entire range at once.\n                 // NOTE: Keep this in sync with the handling of integer and float\n@@ -872,10 +866,16 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 // to reject those pointers, we just do not have the machinery to\n                 // talk about parts of a pointer.\n                 // We also accept uninit, for consistency with the slow path.\n-                match self.ecx.memory.get_raw(ptr.alloc_id)?.check_bytes(\n-                    self.ecx,\n-                    ptr,\n-                    size,\n+                let alloc = match self.ecx.memory.get(mplace.ptr, size, mplace.align)? {\n+                    Some(a) => a,\n+                    None => {\n+                        // Size 0, nothing more to check.\n+                        return Ok(());\n+                    }\n+                };\n+\n+                match alloc.check_bytes(\n+                    alloc_range(Size::ZERO, size),\n                     /*allow_uninit_and_ptr*/ self.ctfe_mode.is_none(),\n                 ) {\n                     // In the happy case, we needn't check anything else.\n@@ -885,12 +885,12 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                         // For some errors we might be able to provide extra information.\n                         // (This custom logic does not fit the `try_validation!` macro.)\n                         match err.kind() {\n-                            err_ub!(InvalidUninitBytes(Some(access))) => {\n+                            err_ub!(InvalidUninitBytes(Some((_alloc_id, access)))) => {\n                                 // Some byte was uninitialized, determine which\n                                 // element that byte belongs to so we can\n                                 // provide an index.\n                                 let i = usize::try_from(\n-                                    access.uninit_ptr.offset.bytes() / layout.size.bytes(),\n+                                    access.uninit_offset.bytes() / layout.size.bytes(),\n                                 )\n                                 .unwrap();\n                                 self.path.push(PathElem::ArrayElem(i));"}, {"sha": "69585979d41761d31305ede144f61627f80646e8", "filename": "compiler/rustc_mir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e827cc21e0734edd26170e8d1481f0d66a1426b/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e827cc21e0734edd26170e8d1481f0d66a1426b/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Flib.rs?ref=3e827cc21e0734edd26170e8d1481f0d66a1426b", "patch": "@@ -21,6 +21,8 @@ Rust MIR: a lowered representation of Rust.\n #![feature(never_type)]\n #![feature(map_try_insert)]\n #![feature(min_specialization)]\n+#![feature(slice_ptr_len)]\n+#![feature(slice_ptr_get)]\n #![feature(trusted_len)]\n #![feature(try_blocks)]\n #![feature(associated_type_defaults)]"}, {"sha": "dae72e1b2c821432447ba201367b8b975fb1e3e2", "filename": "compiler/rustc_target/src/abi/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e827cc21e0734edd26170e8d1481f0d66a1426b/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e827cc21e0734edd26170e8d1481f0d66a1426b/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs?ref=3e827cc21e0734edd26170e8d1481f0d66a1426b", "patch": "@@ -441,6 +441,8 @@ pub struct Align {\n }\n \n impl Align {\n+    pub const ONE: Align = Align { pow2: 0 };\n+\n     #[inline]\n     pub fn from_bits(bits: u64) -> Result<Align, String> {\n         Align::from_bytes(Size::from_bits(bits).bytes())\n@@ -450,7 +452,7 @@ impl Align {\n     pub fn from_bytes(align: u64) -> Result<Align, String> {\n         // Treat an alignment of 0 bytes like 1-byte alignment.\n         if align == 0 {\n-            return Ok(Align { pow2: 0 });\n+            return Ok(Align::ONE);\n         }\n \n         #[cold]"}]}