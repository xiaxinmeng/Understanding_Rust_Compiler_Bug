{"sha": "5dc896e9e737f3661c229ca96ab4297081fb5069", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkYzg5NmU5ZTczN2YzNjYxYzIyOWNhOTZhYjQyOTcwODFmYjUwNjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-19T01:13:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-19T01:13:29Z"}, "message": "Auto merge of #50048 - glandium:issue50041, r=eddyb\n\nrustc_trans: also check dominators for SSA values in mir::analyze\n\nFixes #50041", "tree": {"sha": "76807e8d8891711fd78aad5313c0d226c809d8a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76807e8d8891711fd78aad5313c0d226c809d8a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5dc896e9e737f3661c229ca96ab4297081fb5069", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5dc896e9e737f3661c229ca96ab4297081fb5069", "html_url": "https://github.com/rust-lang/rust/commit/5dc896e9e737f3661c229ca96ab4297081fb5069", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5dc896e9e737f3661c229ca96ab4297081fb5069/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0f9b32357cc6549aa173ae92c9b971a2ab49672", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0f9b32357cc6549aa173ae92c9b971a2ab49672", "html_url": "https://github.com/rust-lang/rust/commit/e0f9b32357cc6549aa173ae92c9b971a2ab49672"}, {"sha": "45fd7416a4fd53635887810315a1d94f2b841b03", "url": "https://api.github.com/repos/rust-lang/rust/commits/45fd7416a4fd53635887810315a1d94f2b841b03", "html_url": "https://github.com/rust-lang/rust/commit/45fd7416a4fd53635887810315a1d94f2b841b03"}], "stats": {"total": 87, "additions": 60, "deletions": 27}, "files": [{"sha": "0fe7163da7a02d2457b1b37d1f3cb3feb433def2", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 59, "deletions": 26, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/5dc896e9e737f3661c229ca96ab4297081fb5069/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dc896e9e737f3661c229ca96ab4297081fb5069/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=5dc896e9e737f3661c229ca96ab4297081fb5069", "patch": "@@ -12,6 +12,7 @@\n //! which do not.\n \n use rustc_data_structures::bitvec::BitVector;\n+use rustc_data_structures::control_flow_graph::dominators::Dominators;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc::mir::{self, Location, TerminatorKind};\n use rustc::mir::visit::{Visitor, PlaceContext};\n@@ -21,7 +22,7 @@ use rustc::ty::layout::LayoutOf;\n use type_of::LayoutLlvmExt;\n use super::FunctionCx;\n \n-pub fn memory_locals<'a, 'tcx>(fx: &FunctionCx<'a, 'tcx>) -> BitVector {\n+pub fn non_ssa_locals<'a, 'tcx>(fx: &FunctionCx<'a, 'tcx>) -> BitVector {\n     let mir = fx.mir;\n     let mut analyzer = LocalAnalyzer::new(fx);\n \n@@ -43,43 +44,60 @@ pub fn memory_locals<'a, 'tcx>(fx: &FunctionCx<'a, 'tcx>) -> BitVector {\n             // (e.g. structs) into an alloca unconditionally, just so\n             // that we don't have to deal with having two pathways\n             // (gep vs extractvalue etc).\n-            analyzer.mark_as_memory(mir::Local::new(index));\n+            analyzer.not_ssa(mir::Local::new(index));\n         }\n     }\n \n-    analyzer.memory_locals\n+    analyzer.non_ssa_locals\n }\n \n struct LocalAnalyzer<'mir, 'a: 'mir, 'tcx: 'a> {\n     fx: &'mir FunctionCx<'a, 'tcx>,\n-    memory_locals: BitVector,\n-    seen_assigned: BitVector\n+    dominators: Dominators<mir::BasicBlock>,\n+    non_ssa_locals: BitVector,\n+    // The location of the first visited direct assignment to each\n+    // local, or an invalid location (out of bounds `block` index).\n+    first_assignment: IndexVec<mir::Local, Location>\n }\n \n impl<'mir, 'a, 'tcx> LocalAnalyzer<'mir, 'a, 'tcx> {\n     fn new(fx: &'mir FunctionCx<'a, 'tcx>) -> LocalAnalyzer<'mir, 'a, 'tcx> {\n+        let invalid_location =\n+            mir::BasicBlock::new(fx.mir.basic_blocks().len()).start_location();\n         let mut analyzer = LocalAnalyzer {\n             fx,\n-            memory_locals: BitVector::new(fx.mir.local_decls.len()),\n-            seen_assigned: BitVector::new(fx.mir.local_decls.len())\n+            dominators: fx.mir.dominators(),\n+            non_ssa_locals: BitVector::new(fx.mir.local_decls.len()),\n+            first_assignment: IndexVec::from_elem(invalid_location, &fx.mir.local_decls)\n         };\n \n         // Arguments get assigned to by means of the function being called\n-        for idx in 0..fx.mir.arg_count {\n-            analyzer.seen_assigned.insert(idx + 1);\n+        for arg in fx.mir.args_iter() {\n+            analyzer.first_assignment[arg] = mir::START_BLOCK.start_location();\n         }\n \n         analyzer\n     }\n \n-    fn mark_as_memory(&mut self, local: mir::Local) {\n-        debug!(\"marking {:?} as memory\", local);\n-        self.memory_locals.insert(local.index());\n+    fn first_assignment(&self, local: mir::Local) -> Option<Location> {\n+        let location = self.first_assignment[local];\n+        if location.block.index() < self.fx.mir.basic_blocks().len() {\n+            Some(location)\n+        } else {\n+            None\n+        }\n     }\n \n-    fn mark_assigned(&mut self, local: mir::Local) {\n-        if !self.seen_assigned.insert(local.index()) {\n-            self.mark_as_memory(local);\n+    fn not_ssa(&mut self, local: mir::Local) {\n+        debug!(\"marking {:?} as non-SSA\", local);\n+        self.non_ssa_locals.insert(local.index());\n+    }\n+\n+    fn assign(&mut self, local: mir::Local, location: Location) {\n+        if self.first_assignment(local).is_some() {\n+            self.not_ssa(local);\n+        } else {\n+            self.first_assignment[local] = location;\n         }\n     }\n }\n@@ -93,9 +111,9 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n         debug!(\"visit_assign(block={:?}, place={:?}, rvalue={:?})\", block, place, rvalue);\n \n         if let mir::Place::Local(index) = *place {\n-            self.mark_assigned(index);\n+            self.assign(index, location);\n             if !self.fx.rvalue_creates_operand(rvalue) {\n-                self.mark_as_memory(index);\n+                self.not_ssa(index);\n             }\n         } else {\n             self.visit_place(place, PlaceContext::Store, location);\n@@ -161,7 +179,7 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n                     if layout.is_llvm_immediate() || layout.is_llvm_scalar_pair() {\n                         // Recurse with the same context, instead of `Projection`,\n                         // potentially stopping at non-operand projections,\n-                        // which would trigger `mark_as_memory` on locals.\n+                        // which would trigger `not_ssa` on locals.\n                         self.visit_place(&proj.base, context, location);\n                         return;\n                     }\n@@ -178,35 +196,50 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n     }\n \n     fn visit_local(&mut self,\n-                   &index: &mir::Local,\n+                   &local: &mir::Local,\n                    context: PlaceContext<'tcx>,\n-                   _: Location) {\n+                   location: Location) {\n         match context {\n             PlaceContext::Call => {\n-                self.mark_assigned(index);\n+                self.assign(local, location);\n             }\n \n             PlaceContext::StorageLive |\n             PlaceContext::StorageDead |\n-            PlaceContext::Validate |\n+            PlaceContext::Validate => {}\n+\n             PlaceContext::Copy |\n-            PlaceContext::Move => {}\n+            PlaceContext::Move => {\n+                // Reads from uninitialized variables (e.g. in dead code, after\n+                // optimizations) require locals to be in (uninitialized) memory.\n+                // NB: there can be uninitialized reads of a local visited after\n+                // an assignment to that local, if they happen on disjoint paths.\n+                let ssa_read = match self.first_assignment(local) {\n+                    Some(assignment_location) => {\n+                        assignment_location.dominates(location, &self.dominators)\n+                    }\n+                    None => false\n+                };\n+                if !ssa_read {\n+                    self.not_ssa(local);\n+                }\n+            }\n \n             PlaceContext::Inspect |\n             PlaceContext::Store |\n             PlaceContext::AsmOutput |\n             PlaceContext::Borrow { .. } |\n             PlaceContext::Projection(..) => {\n-                self.mark_as_memory(index);\n+                self.not_ssa(local);\n             }\n \n             PlaceContext::Drop => {\n-                let ty = mir::Place::Local(index).ty(self.fx.mir, self.fx.cx.tcx);\n+                let ty = mir::Place::Local(local).ty(self.fx.mir, self.fx.cx.tcx);\n                 let ty = self.fx.monomorphize(&ty.to_ty(self.fx.cx.tcx));\n \n                 // Only need the place if we're actually dropping it.\n                 if self.fx.cx.type_needs_drop(ty) {\n-                    self.mark_as_memory(index);\n+                    self.not_ssa(local);\n                 }\n             }\n         }"}, {"sha": "c55836919a97fa0a010e84cdd85c53397fdc56a9", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5dc896e9e737f3661c229ca96ab4297081fb5069/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dc896e9e737f3661c229ca96ab4297081fb5069/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=5dc896e9e737f3661c229ca96ab4297081fb5069", "patch": "@@ -252,7 +252,7 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n         },\n     };\n \n-    let memory_locals = analyze::memory_locals(&fx);\n+    let memory_locals = analyze::non_ssa_locals(&fx);\n \n     // Allocate variable and temp allocas\n     fx.locals = {"}]}