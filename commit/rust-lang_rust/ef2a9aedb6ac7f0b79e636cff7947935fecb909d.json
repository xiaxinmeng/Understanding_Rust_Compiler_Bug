{"sha": "ef2a9aedb6ac7f0b79e636cff7947935fecb909d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmMmE5YWVkYjZhYzdmMGI3OWU2MzZjZmY3OTQ3OTM1ZmVjYjkwOWQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-11-11T10:53:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-11T10:53:24Z"}, "message": "Merge #2205\n\n2205: Implement bulitin line! macro r=matklad a=edwin0cheng\n\nThis PR implements bulitin macro `line!` and add basic infra-structure for other bulitin macros:\r\n\r\n1. Extend `MacroDefId` to support builtin macros\r\n2. Add a `quote!` macro for simple quasi quoting.\r\n\r\nNote that for support others builtin macros, eager macro expansion have to be supported first, this PR not try to handle it. :)\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>", "tree": {"sha": "a603361f9e6c02d90c0ae8cdfd0902370677f71d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a603361f9e6c02d90c0ae8cdfd0902370677f71d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef2a9aedb6ac7f0b79e636cff7947935fecb909d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdyT2kCRBK7hj4Ov3rIwAAdHIIAIDmg3k0qianb3nRTBGJmCK9\nh5nd22+L0dmkHpgdZnBF9PwPj5dDmAntcijgfoLmcQNSZGmus027jZwM2I4QFfW8\n33qBms0ux11u6hOgtYKoOksgziB3qXuW1OSu6XN8FSFGegZpSEZscwcZbGLUaiQ+\noUO29OsRLF5wsjc+QB869gNpmF3Xipv+ddBvg2zXU4c9eiFLvgwpZLz7BjjsksEn\nZNKXCiLw1eAWE6Z5WBmFIWLorrDyX/cu1/WiQfB0HQq2rl1CMn0FKv7LK/VZHabH\nqWkOzE5Adwprapa4PwyQSn23eq8u5MKwc+v6dYH7LKPd+Kisi9Q2Hy0BdFxZT/A=\n=6fjo\n-----END PGP SIGNATURE-----\n", "payload": "tree a603361f9e6c02d90c0ae8cdfd0902370677f71d\nparent 5ac4ffbc121c8231fe3ea5c2bb918f7aae60f197\nparent 4f7df2aac107c0de2cab851f2a4f1ab369511fc8\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1573469604 +0000\ncommitter GitHub <noreply@github.com> 1573469604 +0000\n\nMerge #2205\n\n2205: Implement bulitin line! macro r=matklad a=edwin0cheng\n\nThis PR implements bulitin macro `line!` and add basic infra-structure for other bulitin macros:\r\n\r\n1. Extend `MacroDefId` to support builtin macros\r\n2. Add a `quote!` macro for simple quasi quoting.\r\n\r\nNote that for support others builtin macros, eager macro expansion have to be supported first, this PR not try to handle it. :)\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef2a9aedb6ac7f0b79e636cff7947935fecb909d", "html_url": "https://github.com/rust-lang/rust/commit/ef2a9aedb6ac7f0b79e636cff7947935fecb909d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef2a9aedb6ac7f0b79e636cff7947935fecb909d/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ac4ffbc121c8231fe3ea5c2bb918f7aae60f197", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ac4ffbc121c8231fe3ea5c2bb918f7aae60f197", "html_url": "https://github.com/rust-lang/rust/commit/5ac4ffbc121c8231fe3ea5c2bb918f7aae60f197"}, {"sha": "4f7df2aac107c0de2cab851f2a4f1ab369511fc8", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f7df2aac107c0de2cab851f2a4f1ab369511fc8", "html_url": "https://github.com/rust-lang/rust/commit/4f7df2aac107c0de2cab851f2a4f1ab369511fc8"}], "stats": {"total": 480, "additions": 458, "deletions": 22}, "files": [{"sha": "896bf2924b905146b525b55bc76b85a63b7cbab0", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ef2a9aedb6ac7f0b79e636cff7947935fecb909d/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2a9aedb6ac7f0b79e636cff7947935fecb909d/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=ef2a9aedb6ac7f0b79e636cff7947935fecb909d", "patch": "@@ -4810,3 +4810,22 @@ fn no_such_field_diagnostics() {\n     \"###\n     );\n }\n+\n+#[test]\n+fn infer_builtin_macros_line() {\n+    assert_snapshot!(\n+        infer(r#\"\n+#[rustc_builtin_macro]\n+macro_rules! line {() => {}}\n+\n+fn main() {\n+    let x = line!();\n+}\n+\"#),\n+        @r###\"\n+        ![0; 1) '6': i32\n+        [64; 88) '{     ...!(); }': ()\n+        [74; 75) 'x': i32        \n+    \"###\n+    );\n+}"}, {"sha": "37d0f30936ff164a84eff065c590fb3cdce4053b", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ef2a9aedb6ac7f0b79e636cff7947935fecb909d/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2a9aedb6ac7f0b79e636cff7947935fecb909d/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=ef2a9aedb6ac7f0b79e636cff7947935fecb909d", "patch": "@@ -1,8 +1,9 @@\n //! FIXME: write short doc here\n \n use hir_expand::{\n+    builtin_macro::find_builtin_macro,\n     name::{self, AsName, Name},\n-    HirFileId, MacroCallId, MacroCallLoc, MacroDefId, MacroFileKind,\n+    HirFileId, MacroCallId, MacroCallLoc, MacroDefId, MacroDefKind, MacroFileKind,\n };\n use ra_cfg::CfgOptions;\n use ra_db::{CrateId, FileId};\n@@ -692,10 +693,30 @@ where\n     fn collect_macro(&mut self, mac: &raw::MacroData) {\n         let ast_id = AstId::new(self.file_id, mac.ast_id);\n \n+        // Case 0: builtin macros\n+        if mac.builtin {\n+            if let Some(name) = &mac.name {\n+                let krate = self.def_collector.def_map.krate;\n+                if let Some(macro_id) = find_builtin_macro(name, krate, ast_id) {\n+                    self.def_collector.define_macro(\n+                        self.module_id,\n+                        name.clone(),\n+                        macro_id,\n+                        mac.export,\n+                    );\n+                    return;\n+                }\n+            }\n+        }\n+\n         // Case 1: macro rules, define a macro in crate-global mutable scope\n         if is_macro_rules(&mac.path) {\n             if let Some(name) = &mac.name {\n-                let macro_id = MacroDefId { ast_id, krate: self.def_collector.def_map.krate };\n+                let macro_id = MacroDefId {\n+                    ast_id,\n+                    krate: self.def_collector.def_map.krate,\n+                    kind: MacroDefKind::Declarative,\n+                };\n                 self.def_collector.define_macro(self.module_id, name.clone(), macro_id, mac.export);\n             }\n             return;"}, {"sha": "f52002bc0b74d9d9a55002f1f3b8e8bd92dded32", "filename": "crates/ra_hir_def/src/nameres/raw.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ef2a9aedb6ac7f0b79e636cff7947935fecb909d/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2a9aedb6ac7f0b79e636cff7947935fecb909d/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs?ref=ef2a9aedb6ac7f0b79e636cff7947935fecb909d", "patch": "@@ -200,6 +200,7 @@ pub(super) struct MacroData {\n     pub(super) path: Path,\n     pub(super) name: Option<Name>,\n     pub(super) export: bool,\n+    pub(super) builtin: bool,\n }\n \n struct RawItemsCollector {\n@@ -367,7 +368,11 @@ impl RawItemsCollector {\n         // FIXME: cfg_attr\n         let export = m.attrs().filter_map(|x| x.simple_name()).any(|name| name == \"macro_export\");\n \n-        let m = self.raw_items.macros.alloc(MacroData { ast_id, path, name, export });\n+        // FIXME: cfg_attr\n+        let builtin =\n+            m.attrs().filter_map(|x| x.simple_name()).any(|name| name == \"rustc_builtin_macro\");\n+\n+        let m = self.raw_items.macros.alloc(MacroData { ast_id, path, name, export, builtin });\n         self.push_item(current_module, attrs, RawItemKind::Macro(m));\n     }\n "}, {"sha": "97fb0cb552193abea9500a678b3c8c608baeedbb", "filename": "crates/ra_hir_expand/src/builtin_macro.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/ef2a9aedb6ac7f0b79e636cff7947935fecb909d/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2a9aedb6ac7f0b79e636cff7947935fecb909d/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs?ref=ef2a9aedb6ac7f0b79e636cff7947935fecb909d", "patch": "@@ -0,0 +1,80 @@\n+//! Builtin macro\n+use crate::db::AstDatabase;\n+use crate::{\n+    ast::{self, AstNode},\n+    name, AstId, CrateId, HirFileId, MacroCallId, MacroDefId, MacroDefKind, MacroFileKind,\n+    TextUnit,\n+};\n+\n+use crate::quote;\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub enum BuiltinExpander {\n+    Line,\n+}\n+\n+impl BuiltinExpander {\n+    pub fn expand(\n+        &self,\n+        db: &dyn AstDatabase,\n+        id: MacroCallId,\n+        tt: &tt::Subtree,\n+    ) -> Result<tt::Subtree, mbe::ExpandError> {\n+        match self {\n+            BuiltinExpander::Line => line_expand(db, id, tt),\n+        }\n+    }\n+}\n+\n+pub fn find_builtin_macro(\n+    ident: &name::Name,\n+    krate: CrateId,\n+    ast_id: AstId<ast::MacroCall>,\n+) -> Option<MacroDefId> {\n+    // FIXME: Better registering method\n+    if ident == &name::LINE_MACRO {\n+        Some(MacroDefId { krate, ast_id, kind: MacroDefKind::BuiltIn(BuiltinExpander::Line) })\n+    } else {\n+        None\n+    }\n+}\n+\n+fn to_line_number(db: &dyn AstDatabase, file: HirFileId, pos: TextUnit) -> usize {\n+    // FIXME: Use expansion info\n+    let file_id = file.original_file(db);\n+    let text = db.file_text(file_id);\n+    let mut line_num = 1;\n+\n+    // Count line end\n+    for (i, c) in text.chars().enumerate() {\n+        if i == pos.to_usize() {\n+            break;\n+        }\n+        if c == '\\n' {\n+            line_num += 1;\n+        }\n+    }\n+\n+    line_num\n+}\n+\n+fn line_expand(\n+    db: &dyn AstDatabase,\n+    id: MacroCallId,\n+    _tt: &tt::Subtree,\n+) -> Result<tt::Subtree, mbe::ExpandError> {\n+    let loc = db.lookup_intern_macro(id);\n+    let macro_call = loc.ast_id.to_node(db);\n+\n+    let arg = macro_call.token_tree().ok_or_else(|| mbe::ExpandError::UnexpectedToken)?;\n+    let arg_start = arg.syntax().text_range().start();\n+\n+    let file = id.as_file(MacroFileKind::Expr);\n+    let line_num = to_line_number(db, file, arg_start);\n+\n+    let expanded = quote! {\n+        #line_num\n+    };\n+\n+    Ok(expanded)\n+}"}, {"sha": "5eadee9c28cc64954014645b0348d11fbc1145a4", "filename": "crates/ra_hir_expand/src/db.rs", "status": "modified", "additions": 50, "deletions": 16, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/ef2a9aedb6ac7f0b79e636cff7947935fecb909d/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2a9aedb6ac7f0b79e636cff7947935fecb909d/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs?ref=ef2a9aedb6ac7f0b79e636cff7947935fecb909d", "patch": "@@ -9,10 +9,37 @@ use ra_prof::profile;\n use ra_syntax::{AstNode, Parse, SyntaxNode};\n \n use crate::{\n-    ast_id_map::AstIdMap, HirFileId, HirFileIdRepr, MacroCallId, MacroCallLoc, MacroDefId,\n-    MacroFile, MacroFileKind,\n+    ast_id_map::AstIdMap, BuiltinExpander, HirFileId, HirFileIdRepr, MacroCallId, MacroCallLoc,\n+    MacroDefId, MacroDefKind, MacroFile, MacroFileKind,\n };\n \n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub enum TokenExpander {\n+    MacroRules(mbe::MacroRules),\n+    Builtin(BuiltinExpander),\n+}\n+\n+impl TokenExpander {\n+    pub fn expand(\n+        &self,\n+        db: &dyn AstDatabase,\n+        id: MacroCallId,\n+        tt: &tt::Subtree,\n+    ) -> Result<tt::Subtree, mbe::ExpandError> {\n+        match self {\n+            TokenExpander::MacroRules(it) => it.expand(tt),\n+            TokenExpander::Builtin(it) => it.expand(db, id, tt),\n+        }\n+    }\n+\n+    pub fn shift(&self) -> u32 {\n+        match self {\n+            TokenExpander::MacroRules(it) => it.shift(),\n+            TokenExpander::Builtin(_) => 0,\n+        }\n+    }\n+}\n+\n // FIXME: rename to ExpandDatabase\n #[salsa::query_group(AstDatabaseStorage)]\n pub trait AstDatabase: SourceDatabase {\n@@ -24,7 +51,7 @@ pub trait AstDatabase: SourceDatabase {\n     #[salsa::interned]\n     fn intern_macro(&self, macro_call: MacroCallLoc) -> MacroCallId;\n     fn macro_arg(&self, id: MacroCallId) -> Option<Arc<(tt::Subtree, mbe::TokenMap)>>;\n-    fn macro_def(&self, id: MacroDefId) -> Option<Arc<(mbe::MacroRules, mbe::TokenMap)>>;\n+    fn macro_def(&self, id: MacroDefId) -> Option<Arc<(TokenExpander, mbe::TokenMap)>>;\n     fn parse_macro(\n         &self,\n         macro_file: MacroFile,\n@@ -41,18 +68,25 @@ pub(crate) fn ast_id_map(db: &dyn AstDatabase, file_id: HirFileId) -> Arc<AstIdM\n pub(crate) fn macro_def(\n     db: &dyn AstDatabase,\n     id: MacroDefId,\n-) -> Option<Arc<(mbe::MacroRules, mbe::TokenMap)>> {\n-    let macro_call = id.ast_id.to_node(db);\n-    let arg = macro_call.token_tree()?;\n-    let (tt, tmap) = mbe::ast_to_token_tree(&arg).or_else(|| {\n-        log::warn!(\"fail on macro_def to token tree: {:#?}\", arg);\n-        None\n-    })?;\n-    let rules = MacroRules::parse(&tt).ok().or_else(|| {\n-        log::warn!(\"fail on macro_def parse: {:#?}\", tt);\n-        None\n-    })?;\n-    Some(Arc::new((rules, tmap)))\n+) -> Option<Arc<(TokenExpander, mbe::TokenMap)>> {\n+    match id.kind {\n+        MacroDefKind::Declarative => {\n+            let macro_call = id.ast_id.to_node(db);\n+            let arg = macro_call.token_tree()?;\n+            let (tt, tmap) = mbe::ast_to_token_tree(&arg).or_else(|| {\n+                log::warn!(\"fail on macro_def to token tree: {:#?}\", arg);\n+                None\n+            })?;\n+            let rules = MacroRules::parse(&tt).ok().or_else(|| {\n+                log::warn!(\"fail on macro_def parse: {:#?}\", tt);\n+                None\n+            })?;\n+            Some(Arc::new((TokenExpander::MacroRules(rules), tmap)))\n+        }\n+        MacroDefKind::BuiltIn(expander) => {\n+            Some(Arc::new((TokenExpander::Builtin(expander.clone()), mbe::TokenMap::default())))\n+        }\n+    }\n }\n \n pub(crate) fn macro_arg(\n@@ -74,7 +108,7 @@ pub(crate) fn macro_expand(\n     let macro_arg = db.macro_arg(id).ok_or(\"Fail to args in to tt::TokenTree\")?;\n \n     let macro_rules = db.macro_def(loc.def).ok_or(\"Fail to find macro definition\")?;\n-    let tt = macro_rules.0.expand(&macro_arg.0).map_err(|err| format!(\"{:?}\", err))?;\n+    let tt = macro_rules.0.expand(db, id, &macro_arg.0).map_err(|err| format!(\"{:?}\", err))?;\n     // Set a hard limit for the expanded tt\n     let count = tt.count();\n     if count > 65536 {"}, {"sha": "379562a2c14c542f5e5ebc1b4a0ec4e36703eae5", "filename": "crates/ra_hir_expand/src/hygiene.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ef2a9aedb6ac7f0b79e636cff7947935fecb909d/crates%2Fra_hir_expand%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2a9aedb6ac7f0b79e636cff7947935fecb909d/crates%2Fra_hir_expand%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fhygiene.rs?ref=ef2a9aedb6ac7f0b79e636cff7947935fecb909d", "patch": "@@ -9,7 +9,7 @@ use crate::{\n     db::AstDatabase,\n     either::Either,\n     name::{AsName, Name},\n-    HirFileId, HirFileIdRepr,\n+    HirFileId, HirFileIdRepr, MacroDefKind,\n };\n \n #[derive(Debug)]\n@@ -24,7 +24,10 @@ impl Hygiene {\n             HirFileIdRepr::FileId(_) => None,\n             HirFileIdRepr::MacroFile(macro_file) => {\n                 let loc = db.lookup_intern_macro(macro_file.macro_call_id);\n-                Some(loc.def.krate)\n+                match loc.def.kind {\n+                    MacroDefKind::Declarative => Some(loc.def.krate),\n+                    MacroDefKind::BuiltIn(_) => None,\n+                }\n             }\n         };\n         Hygiene { def_crate }"}, {"sha": "c6ffa2c6f2f0aa08c780c0a0407ccc581bfb4997", "filename": "crates/ra_hir_expand/src/lib.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ef2a9aedb6ac7f0b79e636cff7947935fecb909d/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2a9aedb6ac7f0b79e636cff7947935fecb909d/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Flib.rs?ref=ef2a9aedb6ac7f0b79e636cff7947935fecb909d", "patch": "@@ -10,6 +10,8 @@ pub mod either;\n pub mod name;\n pub mod hygiene;\n pub mod diagnostics;\n+pub mod builtin_macro;\n+pub mod quote;\n \n use std::hash::{Hash, Hasher};\n use std::sync::Arc;\n@@ -21,6 +23,7 @@ use ra_syntax::{\n };\n \n use crate::ast_id_map::FileAstId;\n+use crate::builtin_macro::BuiltinExpander;\n \n /// Input to the analyzer is a set of files, where each file is identified by\n /// `FileId` and contains source code. However, another source of source code in\n@@ -122,6 +125,13 @@ impl salsa::InternKey for MacroCallId {\n pub struct MacroDefId {\n     pub krate: CrateId,\n     pub ast_id: AstId<ast::MacroCall>,\n+    pub kind: MacroDefKind,\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub enum MacroDefKind {\n+    Declarative,\n+    BuiltIn(BuiltinExpander),\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -144,7 +154,7 @@ pub struct ExpansionInfo {\n     pub(crate) def_start: (HirFileId, TextUnit),\n     pub(crate) shift: u32,\n \n-    pub(crate) macro_def: Arc<(mbe::MacroRules, mbe::TokenMap)>,\n+    pub(crate) macro_def: Arc<(db::TokenExpander, mbe::TokenMap)>,\n     pub(crate) macro_arg: Arc<(tt::Subtree, mbe::TokenMap)>,\n     pub(crate) exp_map: Arc<mbe::RevTokenMap>,\n }"}, {"sha": "1bf17d12b5b5818e5c119486cba39d4088fd5c08", "filename": "crates/ra_hir_expand/src/name.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ef2a9aedb6ac7f0b79e636cff7947935fecb909d/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2a9aedb6ac7f0b79e636cff7947935fecb909d/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fname.rs?ref=ef2a9aedb6ac7f0b79e636cff7947935fecb909d", "patch": "@@ -140,3 +140,6 @@ pub const RESULT_TYPE: Name = Name::new_inline_ascii(6, b\"Result\");\n pub const OUTPUT_TYPE: Name = Name::new_inline_ascii(6, b\"Output\");\n pub const TARGET_TYPE: Name = Name::new_inline_ascii(6, b\"Target\");\n pub const BOX_TYPE: Name = Name::new_inline_ascii(3, b\"Box\");\n+\n+// Builtin Macros\n+pub const LINE_MACRO: Name = Name::new_inline_ascii(4, b\"line\");"}, {"sha": "9cd17f0e35453d83c9933da7673b3eb311dc5739", "filename": "crates/ra_hir_expand/src/quote.rs", "status": "added", "additions": 261, "deletions": 0, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/ef2a9aedb6ac7f0b79e636cff7947935fecb909d/crates%2Fra_hir_expand%2Fsrc%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef2a9aedb6ac7f0b79e636cff7947935fecb909d/crates%2Fra_hir_expand%2Fsrc%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fquote.rs?ref=ef2a9aedb6ac7f0b79e636cff7947935fecb909d", "patch": "@@ -0,0 +1,261 @@\n+//! A simplified version of quote-crate like quasi quote macro\n+\n+// A helper macro quote macro\n+// FIXME:\n+// 1. Not all puncts are handled\n+// 2. #()* pattern repetition not supported now\n+//    * But we can do it manually, see `test_quote_derive_copy_hack`\n+#[doc(hidden)]\n+#[macro_export]\n+macro_rules! __quote {\n+    () => {\n+        Vec::<tt::TokenTree>::new()\n+    };\n+\n+    ( @SUBTREE $delim:ident $($tt:tt)* ) => {\n+        {\n+            let children = $crate::__quote!($($tt)*);\n+            let subtree = tt::Subtree {\n+                delimiter: tt::Delimiter::$delim,\n+                token_trees: $crate::quote::IntoTt::to_tokens(children),\n+            };\n+            subtree\n+        }\n+    };\n+\n+    ( @PUNCT $first:literal ) => {\n+        {\n+            vec![\n+                tt::Leaf::Punct(tt::Punct {\n+                    char: $first,\n+                    spacing: tt::Spacing::Alone,\n+                }).into()\n+            ]\n+        }\n+    };\n+\n+    ( @PUNCT $first:literal, $sec:literal ) => {\n+        {\n+            vec![\n+                tt::Leaf::Punct(tt::Punct {\n+                    char: $first,\n+                    spacing: tt::Spacing::Joint,\n+                }).into(),\n+                tt::Leaf::Punct(tt::Punct {\n+                    char: $sec,\n+                    spacing: tt::Spacing::Alone,\n+                }).into()\n+            ]\n+        }\n+    };\n+\n+    // hash variable\n+    ( # $first:ident $($tail:tt)* ) => {\n+        {\n+            let token = $crate::quote::ToTokenTree::to_token($first);\n+            let mut tokens = vec![token.into()];\n+            let mut tail_tokens = $crate::quote::IntoTt::to_tokens($crate::__quote!($($tail)*));\n+            tokens.append(&mut tail_tokens);\n+            tokens\n+        }\n+    };\n+\n+    // Brace\n+    ( { $($tt:tt)* } ) => { $crate::__quote!(@SUBTREE Brace $($tt)*) };\n+    // Bracket\n+    ( [ $($tt:tt)* ] ) => { $crate::__quote!(@SUBTREE Bracket $($tt)*) };\n+    // Parenthesis\n+    ( ( $($tt:tt)* ) ) => { $crate::__quote!(@SUBTREE Parenthesis $($tt)*) };\n+\n+    // Literal\n+    ( $tt:literal ) => { vec![$crate::quote::ToTokenTree::to_token($tt).into()] };\n+    // Ident\n+    ( $tt:ident ) => {\n+        vec![ {\n+            tt::Leaf::Ident(tt::Ident {\n+                text: stringify!($tt).into(),\n+                id: tt::TokenId::unspecified(),\n+            }).into()\n+        }]\n+    };\n+\n+    // Puncts\n+    // FIXME: Not all puncts are handled\n+    ( -> ) => {$crate::__quote!(@PUNCT '-', '>')};\n+    ( & ) => {$crate::__quote!(@PUNCT '&')};\n+    ( , ) => {$crate::__quote!(@PUNCT ',')};\n+    ( : ) => {$crate::__quote!(@PUNCT ':')};\n+    ( . ) => {$crate::__quote!(@PUNCT '.')};\n+\n+    ( $first:tt $($tail:tt)+ ) => {\n+        {\n+            let mut tokens = $crate::quote::IntoTt::to_tokens($crate::__quote!($first));\n+            let mut tail_tokens = $crate::quote::IntoTt::to_tokens($crate::__quote!($($tail)*));\n+\n+            tokens.append(&mut tail_tokens);\n+            tokens\n+        }\n+    };\n+}\n+\n+/// FIXME:\n+/// It probably should implement in proc-macro\n+#[macro_export]\n+macro_rules! quote {\n+    ( $($tt:tt)* ) => {\n+        $crate::quote::IntoTt::to_subtree($crate::__quote!($($tt)*))\n+    }\n+}\n+\n+pub(crate) trait IntoTt {\n+    fn to_subtree(self) -> tt::Subtree;\n+    fn to_tokens(self) -> Vec<tt::TokenTree>;\n+}\n+\n+impl IntoTt for Vec<tt::TokenTree> {\n+    fn to_subtree(self) -> tt::Subtree {\n+        tt::Subtree { delimiter: tt::Delimiter::None, token_trees: self }\n+    }\n+\n+    fn to_tokens(self) -> Vec<tt::TokenTree> {\n+        self\n+    }\n+}\n+\n+impl IntoTt for tt::Subtree {\n+    fn to_subtree(self) -> tt::Subtree {\n+        self\n+    }\n+\n+    fn to_tokens(self) -> Vec<tt::TokenTree> {\n+        vec![tt::TokenTree::Subtree(self)]\n+    }\n+}\n+\n+pub(crate) trait ToTokenTree {\n+    fn to_token(self) -> tt::TokenTree;\n+}\n+\n+impl ToTokenTree for tt::TokenTree {\n+    fn to_token(self) -> tt::TokenTree {\n+        self\n+    }\n+}\n+\n+impl ToTokenTree for tt::Subtree {\n+    fn to_token(self) -> tt::TokenTree {\n+        self.into()\n+    }\n+}\n+\n+macro_rules! impl_to_to_tokentrees {\n+    ($($ty:ty => $this:ident $im:block);*) => {\n+        $(\n+            impl ToTokenTree for $ty {\n+                fn to_token($this) -> tt::TokenTree {\n+                    let leaf: tt::Leaf = $im.into();\n+                    leaf.into()\n+                }\n+            }\n+\n+            impl ToTokenTree for &$ty {\n+                fn to_token($this) -> tt::TokenTree {\n+                    let leaf: tt::Leaf = $im.clone().into();\n+                    leaf.into()\n+                }\n+            }\n+        )*\n+    }\n+}\n+\n+impl_to_to_tokentrees! {\n+    u32 => self { tt::Literal{text: self.to_string().into()} };\n+    usize => self { tt::Literal{text: self.to_string().into()}};\n+    i32 => self { tt::Literal{text: self.to_string().into()}};\n+    &str => self { tt::Literal{text: self.to_string().into()}};\n+    String => self { tt::Literal{text: self.into()}};\n+    tt::Leaf => self { self };\n+    tt::Literal => self { self };\n+    tt::Ident => self { self };\n+    tt::Punct => self { self }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    #[test]\n+    fn test_quote_delimiters() {\n+        assert_eq!(quote!({}).to_string(), \"{}\");\n+        assert_eq!(quote!(()).to_string(), \"()\");\n+        assert_eq!(quote!([]).to_string(), \"[]\");\n+    }\n+\n+    #[test]\n+    fn test_quote_idents() {\n+        assert_eq!(quote!(32).to_string(), \"32\");\n+        assert_eq!(quote!(struct).to_string(), \"struct\");\n+    }\n+\n+    #[test]\n+    fn test_quote_hash_simple_literal() {\n+        let a = 20;\n+        assert_eq!(quote!(#a).to_string(), \"20\");\n+        let s: String = \"hello\".into();\n+        assert_eq!(quote!(#s).to_string(), \"hello\");\n+    }\n+\n+    fn mk_ident(name: &str) -> tt::Ident {\n+        tt::Ident { text: name.into(), id: tt::TokenId::unspecified() }\n+    }\n+\n+    #[test]\n+    fn test_quote_hash_token_tree() {\n+        let a = mk_ident(\"hello\");\n+\n+        let quoted = quote!(#a);\n+        assert_eq!(quoted.to_string(), \"hello\");\n+        let t = format!(\"{:?}\", quoted);\n+        assert_eq!(t, \"Subtree { delimiter: None, token_trees: [Leaf(Ident(Ident { text: \\\"hello\\\", id: TokenId(4294967295) }))] }\");\n+    }\n+\n+    #[test]\n+    fn test_quote_simple_derive_copy() {\n+        let name = mk_ident(\"Foo\");\n+\n+        let quoted = quote! {\n+            impl Clone for #name {\n+                fn clone(&self) -> Self {\n+                    Self {}\n+                }\n+            }\n+        };\n+\n+        assert_eq!(quoted.to_string(), \"impl Clone for Foo {fn clone (& self) -> Self {Self {}}}\");\n+    }\n+\n+    #[test]\n+    fn test_quote_derive_copy_hack() {\n+        // Assume the given struct is:\n+        // struct Foo {\n+        //  name: String,\n+        //  id: u32,\n+        // }\n+        let struct_name = mk_ident(\"Foo\");\n+        let fields = [mk_ident(\"name\"), mk_ident(\"id\")];\n+        let fields = fields\n+            .into_iter()\n+            .map(|it| quote!(#it: self.#it.clone(), ).token_trees.clone())\n+            .flatten();\n+\n+        let list = tt::Subtree { delimiter: tt::Delimiter::Brace, token_trees: fields.collect() };\n+\n+        let quoted = quote! {\n+            impl Clone for #struct_name {\n+                fn clone(&self) -> Self {\n+                    Self #list\n+                }\n+            }\n+        };\n+\n+        assert_eq!(quoted.to_string(), \"impl Clone for Foo {fn clone (& self) -> Self {Self {name : self . name . clone () , id : self . id . clone () ,}}}\");\n+    }\n+}"}]}