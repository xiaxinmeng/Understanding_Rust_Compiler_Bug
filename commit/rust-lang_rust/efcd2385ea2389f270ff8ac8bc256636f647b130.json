{"sha": "efcd2385ea2389f270ff8ac8bc256636f647b130", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmY2QyMzg1ZWEyMzg5ZjI3MGZmOGFjOGJjMjU2NjM2ZjY0N2IxMzA=", "commit": {"author": {"name": "Simon BD", "email": "simon@server", "date": "2012-10-04T02:47:09Z"}, "committer": {"name": "Simon BD", "email": "simon@server", "date": "2012-10-04T02:47:09Z"}, "message": "Merge remote-tracking branch 'original/incoming' into incoming\n\nConflicts:\n\tsrc/libstd/json.rs\n\tsrc/libstd/sort.rs", "tree": {"sha": "7e142ef709bc907a34ab1cb252eef6dcc0e83b91", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e142ef709bc907a34ab1cb252eef6dcc0e83b91"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/efcd2385ea2389f270ff8ac8bc256636f647b130", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/efcd2385ea2389f270ff8ac8bc256636f647b130", "html_url": "https://github.com/rust-lang/rust/commit/efcd2385ea2389f270ff8ac8bc256636f647b130", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/efcd2385ea2389f270ff8ac8bc256636f647b130/comments", "author": {"login": "14427", "id": 2423611, "node_id": "MDQ6VXNlcjI0MjM2MTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2423611?v=4", "gravatar_id": "", "url": "https://api.github.com/users/14427", "html_url": "https://github.com/14427", "followers_url": "https://api.github.com/users/14427/followers", "following_url": "https://api.github.com/users/14427/following{/other_user}", "gists_url": "https://api.github.com/users/14427/gists{/gist_id}", "starred_url": "https://api.github.com/users/14427/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/14427/subscriptions", "organizations_url": "https://api.github.com/users/14427/orgs", "repos_url": "https://api.github.com/users/14427/repos", "events_url": "https://api.github.com/users/14427/events{/privacy}", "received_events_url": "https://api.github.com/users/14427/received_events", "type": "User", "site_admin": false}, "committer": {"login": "14427", "id": 2423611, "node_id": "MDQ6VXNlcjI0MjM2MTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2423611?v=4", "gravatar_id": "", "url": "https://api.github.com/users/14427", "html_url": "https://github.com/14427", "followers_url": "https://api.github.com/users/14427/followers", "following_url": "https://api.github.com/users/14427/following{/other_user}", "gists_url": "https://api.github.com/users/14427/gists{/gist_id}", "starred_url": "https://api.github.com/users/14427/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/14427/subscriptions", "organizations_url": "https://api.github.com/users/14427/orgs", "repos_url": "https://api.github.com/users/14427/repos", "events_url": "https://api.github.com/users/14427/events{/privacy}", "received_events_url": "https://api.github.com/users/14427/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44f8a4401ab37a45ba49db56611d77807bcbce35", "url": "https://api.github.com/repos/rust-lang/rust/commits/44f8a4401ab37a45ba49db56611d77807bcbce35", "html_url": "https://github.com/rust-lang/rust/commit/44f8a4401ab37a45ba49db56611d77807bcbce35"}, {"sha": "3ccf6f5932d8223fd6c5cbf7c6ac429ca9e8912a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ccf6f5932d8223fd6c5cbf7c6ac429ca9e8912a", "html_url": "https://github.com/rust-lang/rust/commit/3ccf6f5932d8223fd6c5cbf7c6ac429ca9e8912a"}], "stats": {"total": 20072, "additions": 11529, "deletions": 8543}, "files": [{"sha": "e7fa662c603f909241b77569d64acad93c3f7f9f", "filename": "AUTHORS.txt", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/AUTHORS.txt", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/AUTHORS.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/AUTHORS.txt?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -17,6 +17,7 @@ Ben Striegel <ben.striegel@gmail.com>\n Benjamin Herr <ben@0x539.de>\n Benjamin Jackman <ben@jackman.biz>\n Benjamin Kircher <benjamin.kircher@gmail.com>\n+Benjamin Peterson <benjamin@python.org>\n Brendan Eich <brendan@mozilla.org>\n Brian Anderson <banderson@mozilla.com>\n Brian J. Burg <burg@cs.washington.edu>\n@@ -66,6 +67,7 @@ Kevin Atkinson <kevina@cs.utah.edu>\n Kevin Cantu <me@kevincantu.org>\n Lennart Kudling\n Lindsey Kuper <lindsey@rockstargirl.org>\n+Luca Bruno <lucab@debian.org>\n Magnus Auvinen <magnus.auvinen@gmail.com>\n Margaret Meyerhofer <mmeyerho@andrew.cmu.edu>\n Marijn Haverbeke <marijnh@gmail.com>\n@@ -76,6 +78,7 @@ Michael Bebenita <mbebenita@mozilla.com>\n Michael Sullivan <sully@msully.net>\n Niko Matsakis <niko@alum.mit.edu>\n Or Brostovski <tohava@gmail.com>\n+Orph\u00e9e Lafond-Lummis <o@orftz.com>\n Patrick Walton <pwalton@mozilla.com>\n Patrik K\u00e5rlin <patrik.karlin@gmail.com>\n Paul Stansifer <paul.stansifer@gmail.com>"}, {"sha": "a7594261c295e39f489aeeb2890bdfde0c1831ed", "filename": "Makefile.in", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -357,6 +357,15 @@ EXTRAFLAGS_STAGE$(1) = $$(RUSTFLAGS_STAGE$(1))\n \n CFGFLAG$(1)_T_$(2)_H_$(3) = stage$(1)\n \n+# Pass --cfg stage0 only for the build->host part of stage0;\n+# if you're building a cross config, the host->* parts are\n+# effectively stage1, since it uses the just-built stage0.\n+ifeq ($(1),0)\n+ifneq ($(strip $(CFG_HOST_TRIPLE)),$(strip $(3)))\n+CFGFLAG$(1)_T_$(2)_H_$(3) = stage1\n+endif\n+endif\n+\n STAGE$(1)_T_$(2)_H_$(3) := \t\t\t\t\t\t\\\n \t$$(Q)$$(call CFG_RUN_TARG,$(1),\t\t\t\t\\\n \t\t$$(CFG_VALGRIND_COMPILE$(1)) \t\t\t\\\n@@ -528,8 +537,8 @@ endif\n \n ifneq ($(findstring install,$(MAKECMDGOALS)),)\n   ifdef DESTDIR\n-    CFG_INFO := $(info cfg: setting CFG_PREFIX via DESTDIR, $(DESTDIR))\n-    CFG_PREFIX:=$(DESTDIR)\n+    CFG_INFO := $(info cfg: setting CFG_PREFIX via DESTDIR, $(DESTDIR)/$(CFG_PREFIX))\n+    CFG_PREFIX:=$(DESTDIR)/$(CFG_PREFIX)\n     export CFG_PREFIX\n   endif\n "}, {"sha": "8d8f9179f6f70923304fe364e3bef492cb5445b0", "filename": "RELEASES.txt", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/RELEASES.txt", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/RELEASES.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.txt?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -1,5 +1,5 @@\n-Version 0.4 (September 2012)\n-----------------------------\n+Version 0.4 (October 2012)\n+--------------------------\n \n    * ~1500 changes, numerous bugfixes\n \n@@ -8,13 +8,14 @@ Version 0.4 (September 2012)\n       * Keyword removal: 'again', 'import', 'check', 'new', 'owned', 'send',\n         'of', 'with', 'to', 'class'.\n       * Classes are replaced with simpler structs\n-      * Method self types\n+      * Explicit method self types\n       * `ret` became `return` and `alt` became `match`\n       * `import` is now `use`; `use is now `extern mod`\n       * `extern mod { ... }` is now `extern { ... }`\n       * `use mod` is the recommended way to import modules\n       * `pub` and `priv` replace deprecated export lists\n       * The syntax of `match` pattern arms now uses fat arrow (=>)\n+      * `main` no longer accepts an args vector; use `os::args` instead\n \n    * Semantics\n       * Trait implementations are now coherent, ala Haskell typeclasses\n@@ -25,15 +26,13 @@ Version 0.4 (September 2012)\n       * Typestate was removed\n       * Resolution rewritten to be more reliable\n       * Support for 'dual-mode' data structures (freezing and thawing)\n-      * Last-use analysis is only used for warnings now. Moves must be explicit\n-        for lvalues (TODO: confirm)\n \n    * Libraries\n       * Most binary operators can now be overloaded via the traits in\n         `core::ops'\n       * `std::net::url` for representing URLs\n       * Sendable hash maps in `core::send_map`\n-      * `core::task' gained a (currently very unsafe) task-local storage API\n+      * `core::task' gained a (currently unsafe) task-local storage API\n \n    * Concurrency\n       * An efficient new intertask communication primitive called the pipe,\n@@ -52,8 +51,7 @@ Version 0.4 (September 2012)\n       * Extensive architectural improvements to rustc\n       * Begun a transition away from buggy C++-based reflection (shape) code to\n         Rust-based (visitor) code\n-      * Hash functions improved across the codebase (TODO: need details)\n-      * New lint checks (TODO: which?)\n+      * All hash functions and tables converted to secure, randomized SipHash\n \n Version 0.3  (July 2012)\n ------------------------"}, {"sha": "c49b0fee67cebc9a8dd1d4a0cd328b5184ef403b", "filename": "doc/rust.css", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/doc%2Frust.css", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/doc%2Frust.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.css?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -1,9 +1,11 @@\n body {\n   padding: 1em;\n   margin: 0;\n+  margin-bottom: 4em;\n   font-family: \"Helvetica Neue\", Helvetica, sans-serif;\n   background-color: white;\n   color: black;\n+  line-height: 1.6em;\n }\n \n body {\n@@ -12,12 +14,16 @@ body {\n }\n \n h1 {\n-  font-size: 22pt;\n+  font-size: 20pt;\n   margin-top: 2em;\n-  border-bottom: 2px solid silver;\n+  border-bottom: 1px solid silver;\n+  line-height: 1.6em;\n }\n-h2 { font-size: 17pt; }\n-h3 { font-size: 14pt; }\n+h2 {\n+    font-size: 15pt;\n+    margin-top: 2em;\n+}\n+h3 { font-size: 13pt; }\n \n pre {\n   margin: 1.1em 0;\n@@ -27,7 +33,7 @@ pre {\n \n a, a:visited, a:link {\n   text-decoration: none;\n-  color: #00438a;\n+  color: rgb(0, 105, 214);\n }\n \n h1 a:link, h1 a:visited, h2 a:link, h2 a:visited,\n@@ -54,20 +60,12 @@ h3 a:link, h3 a:visited { color: black; }\n .cm-s-default span.cm-tag {color: #170;}\n .cm-s-default span.cm-attribute {color: #00c;}\n \n-h1.title {\n-  background-image: url('http://www.rust-lang.org/logos/rust-logo-32x32-blk.png');\n-  background-repeat: no-repeat;\n-  background-position: right;\n-}\n-\n #versioninfo {\n   position: fixed;\n   bottom: 0px;\n   right: 0px;\n \n   background-color: white;\n-  border-left: solid 1px black;\n-  border-top: solid 1px black;\n   padding: 0.5em;\n }\n \n@@ -99,3 +97,8 @@ td {\n #TOC ul ul {\n     display: none;\n }\n+\n+#TOC ul {\n+    list-style: none;\n+    padding-left: 0px;\n+}\n\\ No newline at end of file"}, {"sha": "5fd9622046ad965db457d9415e5f495ec12f040e", "filename": "doc/rust.md", "status": "modified", "additions": 52, "deletions": 134, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -15,17 +15,16 @@ provides three kinds of material:\n \n This document does not serve as a tutorial introduction to the\n language. Background familiarity with the language is assumed. A separate\n-tutorial document is available at <http://doc.rust-lang.org/doc/tutorial.html>\n-to help acquire such background familiarity.\n+[tutorial] document is available to help acquire such background familiarity.\n \n-This document also does not serve as a reference to the core or standard\n+This document also does not serve as a reference to the [core] or [standard]\n libraries included in the language distribution. Those libraries are\n documented separately by extracting documentation attributes from their\n-source code. Formatted documentation can be found at the following\n-locations:\n+source code.\n \n-  - Core library: <http://doc.rust-lang.org/doc/core>\n-  - Standard library: <http://doc.rust-lang.org/doc/std>\n+[tutorial]: tutorial.html\n+[core]: core/index.html\n+[standard]: std/index.html\n \n ## Disclaimer\n \n@@ -42,14 +41,17 @@ If you have suggestions to make, please try to focus them on *reductions* to\n the language: possible features that can be combined or omitted. We aim to\n keep the size and complexity of the language under control.\n \n-**Note on grammar:** The grammar for Rust given in this document is rough and\n-very incomplete; only a modest number of sections have accompanying grammar\n-rules. Formalizing the grammar accepted by the Rust parser is ongoing work,\n-but future versions of this document will contain a complete\n-grammar. Moreover, we hope that this grammar will be extracted and verified\n-as LL(1) by an automated grammar-analysis tool, and further tested against the\n-Rust sources. Preliminary versions of this automation exist, but are not yet\n-complete.\n+> **Note:** This manual is very out of date. The best source of Rust\n+> documentation is currently the tutorial.\n+\n+> **Note:** The grammar for Rust given in this document is rough and\n+> very incomplete; only a modest number of sections have accompanying grammar\n+> rules. Formalizing the grammar accepted by the Rust parser is ongoing work,\n+> but future versions of this document will contain a complete\n+> grammar. Moreover, we hope that this grammar will be extracted and verified\n+> as LL(1) by an automated grammar-analysis tool, and further tested against the\n+> Rust sources. Preliminary versions of this automation exist, but are not yet\n+> complete.\n \n # Notation\n \n@@ -118,19 +120,16 @@ production. See [tokens](#tokens) for more information.\n \n ## Input format\n \n-Rust input is interpreted as a sequence of Unicode codepoints encoded in\n-UTF-8. No normalization is performed during input processing. Most Rust\n-grammar rules are defined in terms of printable ASCII-range codepoints, but\n-a small number are defined in terms of Unicode properties or explicit\n-codepoint lists. ^[Surrogate definitions for the special Unicode productions\n-are provided to the grammar verifier, restricted to ASCII range, when\n-verifying the grammar in this document.]\n+Rust input is interpreted as a sequence of Unicode codepoints encoded in UTF-8,\n+normalized to Unicode normalization form NFKC.\n+Most Rust grammar rules are defined in terms of printable ASCII-range codepoints,\n+but a small number are defined in terms of Unicode properties or explicit codepoint lists.\n+^[Substitute definitions for the special Unicode productions are provided to the grammar verifier, restricted to ASCII range, when verifying the grammar in this document.]\n \n ## Special Unicode Productions\n \n-The following productions in the Rust grammar are defined in terms of\n-Unicode properties: `ident`, `non_null`, `non_star`, `non_eol`, `non_slash`,\n-`non_single_quote` and `non_double_quote`.\n+The following productions in the Rust grammar are defined in terms of Unicode properties:\n+`ident`, `non_null`, `non_star`, `non_eol`, `non_slash`, `non_single_quote` and `non_double_quote`.\n \n ### Identifiers\n \n@@ -203,26 +202,26 @@ grammar as double-quoted strings. Other tokens have exact rules given.\n The keywords in [crate files](#crate-files) are the following strings:\n \n ~~~~~~~~ {.keyword}\n-export use mod\n+mod priv pub use\n ~~~~~~~~\n \n The keywords in [source files](#source-files) are the following strings:\n \n ~~~~~~~~ {.keyword}\n-again assert\n+as assert\n break\n-check const copy\n-drop\n-else enum export extern\n+const copy\n+do drop\n+else enum extern\n fail false fn for\n if impl\n let log loop\n-match mod mut\n-pure\n-return\n-struct\n+match mod move mut\n+priv pub pure\n+ref return\n+self static struct\n true trait type\n-unsafe\n+unsafe use\n while\n ~~~~~~~~\n \n@@ -619,7 +618,7 @@ or a *configuration* in Mesa.] A crate file describes:\n   and copyright. These are used for linking, versioning and distributing\n   crates.\n * The source-file and directory modules that make up the crate.\n-* Any `use`, `extern mod` or `export` [view items](#view-items) that apply to\n+* Any `use` or `extern mod` [view items](#view-items) that apply to\n   the anonymous module at the top-level of the crate's module tree.\n \n An example of a crate file:\n@@ -767,7 +766,7 @@ mod math {\n #### View items\n \n ~~~~~~~~ {.ebnf .gram}\n-view_item : extern_mod_decl | use_decl | export_decl ;\n+view_item : extern_mod_decl | use_decl ;\n ~~~~~~~~\n \n A view item manages the namespace of a module; it does not define new items\n@@ -776,7 +775,6 @@ view item:\n \n  * [extern mod declarations](#extern-mod-declarations)\n  * [use declarations](#use-declarations)\n- * [export declarations](#export-declarations)\n \n ##### Extern mod declarations\n \n@@ -786,9 +784,8 @@ link_attrs : link_attr [ ',' link_attrs ] + ;\n link_attr : ident '=' literal ;\n ~~~~~~~~\n \n-An _extern mod declaration_ specifies a dependency on an external crate. The\n-external crate is then imported into the declaring scope as the `ident`\n-provided in the `extern_mod_decl`.\n+An _extern mod declaration_ specifies a dependency on an external crate.\n+The external crate is then bound into the declaring scope as the `ident` provided in the `extern_mod_decl`.\n \n The external crate is resolved to a specific `soname` at compile time, and a\n runtime linkage requirement to that `soname` is passed to the linker for\n@@ -828,16 +825,16 @@ linkage-dependency with external crates. Linkage dependencies are\n independently declared with\n [`extern mod` declarations](#extern-mod-declarations).\n \n-Imports support a number of \"convenience\" notations:\n+Use declarations support a number of \"convenience\" notations:\n \n-  * Importing as a different name than the imported name, using the\n+  * Rebinding the target name as a new local name, using the\n     syntax `use x = p::q::r;`.\n-  * Importing a list of paths differing only in final element, using\n-    the glob-like brace syntax `use a::b::{c,d,e,f};`\n-  * Importing all paths matching a given prefix, using the glob-like\n-    asterisk syntax `use a::b::*;`\n+  * Simultaneously binding a list of paths differing only in final element,\n+    using the glob-like brace syntax `use a::b::{c,d,e,f};`\n+  * Binding all paths matching a given prefix,\n+    using the glob-like asterisk syntax `use a::b::*;`\n \n-An example of imports:\n+An example of `use` declarations:\n \n ~~~~\n use foo = core::info;\n@@ -858,82 +855,11 @@ fn main() {\n }\n ~~~~\n \n-##### Export declarations\n-\n-~~~~~~~~ {.ebnf .gram}\n-export_decl : \"export\" ident [ ',' ident ] *\n-            | \"export\" ident \"::{}\"\n-            | \"export\" ident '{' ident [ ',' ident ] * '}' ;\n-~~~~~~~~\n-\n-An _export declaration_ restricts the set of local names within a module that\n-can be accessed from code outside the module. By default, all _local items_ in\n-a module are exported; imported paths are not automatically re-exported by\n-default. If a module contains an explicit `export` declaration, this\n-declaration replaces the default export with the export specified.\n-\n-An example of an export:\n-\n-~~~~~~~~\n-pub mod foo {\n-\t#[legacy_exports];\n-    export primary;\n-\n-    fn primary() {\n-        helper(1, 2);\n-        helper(3, 4);\n-    }\n-\n-    fn helper(x: int, y: int) {\n-        ...\n-    }\n-}\n-\n-fn main() {\n-    foo::primary();  // Will compile.\n-}\n-~~~~~~~~\n-\n-If, instead of calling `foo::primary` in main, you were to call `foo::helper`\n-then it would fail to compile:\n-\n-~~~~~~~~{.ignore}\n-    foo::helper(2,3) // ERROR: will not compile.\n-~~~~~~~~\n-\n-Multiple names may be exported from a single export declaration:\n-\n-~~~~~~~~\n-mod foo {\n-    export primary, secondary;\n-\n-    fn primary() {\n-        helper(1, 2);\n-        helper(3, 4);\n-    }\n-\n-    fn secondary() {\n-        ...\n-    }\n-\n-    fn helper(x: int, y: int) {\n-        ...\n-    }\n-}\n-~~~~~~~~\n-\n-When exporting the name of an `enum` type `t`, by default, the module does\n-*not* implicitly export any of `t`'s constructors. For example:\n-\n-~~~~~~~~\n-mod foo {\n-    export t;\n-\n-    enum t {a, b, c}\n-}\n-~~~~~~~~\n-\n-Here, `foo` imports `t`, but not `a`, `b`, and `c`.\n+Like items, `use` declarations are private to the containing module, by default.\n+Also like items, a `use` declaration can be public, if qualified by the `pub` keyword.\n+A public `use` declaration can therefore be used to _redirect_ some public name to a different target definition,\n+even a definition with a private canonical path, inside a different module.\n+If a sequence of such redirections form a cycle or cannot be unambiguously resolved, they represent a compile-time error.\n \n ### Functions\n \n@@ -1076,7 +1002,7 @@ pure fn pure_length<T>(ls: List<T>) -> uint {\n Despite its name, `pure_foldl` is a `fn`, not a `pure fn`, because there is no\n way in Rust to specify that the higher-order function argument `f` is a pure\n function. So, to use `foldl` in a pure list length function that a pure function\n-could then use, we must use an `unchecked` block wrapped around the call to\n+could then use, we must use an `unsafe` block wrapped around the call to\n `pure_foldl` in the definition of `pure_length`.\n \n #### Generic functions\n@@ -1092,7 +1018,7 @@ fn iter<T>(seq: ~[T], f: fn(T)) {\n }\n fn map<T, U>(seq: ~[T], f: fn(T) -> U) -> ~[U] {\n     let mut acc = ~[];\n-    for seq.each |elt| { vec::push(acc, f(elt)); }\n+    for seq.each |elt| { acc.push(f(elt)); }\n     acc\n }\n ~~~~\n@@ -1300,14 +1226,6 @@ impl circle: shape {\n }\n ~~~~\n \n-This defines an implementation named `circle_shape` of trait\n-`shape` for type `circle`. The name of the implementation is the name\n-by which it is imported and exported, but has no further significance.\n-It may be omitted to default to the name of the trait that was\n-implemented. Implementation names do not conflict the way other names\n-do: multiple implementations with the same name may exist in a scope at\n-the same time.\n-\n It is possible to define an implementation without referring to a\n trait.  The methods in such an implementation can only be used\n statically (as direct calls on the values of the type that the"}, {"sha": "8b264a9d609d1778884ae79209010058b59fdf0b", "filename": "doc/tutorial-borrowed-ptr.md", "status": "modified", "additions": 234, "deletions": 202, "changes": 436, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/doc%2Ftutorial-borrowed-ptr.md", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/doc%2Ftutorial-borrowed-ptr.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-borrowed-ptr.md?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -4,7 +4,7 @@\n \n Borrowed pointers are one of the more flexible and powerful tools\n available in Rust. A borrowed pointer can be used to point anywhere:\n-into the shared and exchange heaps, into the stack, and even into the\n+into the managed and exchange heaps, into the stack, and even into the\n interior of another data structure. With regard to flexibility, it is\n comparable to a C pointer or C++ reference. However, unlike C and C++,\n the Rust compiler includes special checks that ensure that borrowed\n@@ -29,21 +29,21 @@ a limit duration. Borrowed pointers never claim any kind of ownership\n over the data that they point at: instead, they are used for cases\n where you like to make use of data for a short time.\n \n-As an example, consider a simple record type `point`:\n+As an example, consider a simple struct type `Point`:\n \n ~~~\n-type point = {x: float, y: float};\n+struct Point {x: float, y: float}\n ~~~\n \n We can use this simple definition to allocate points in many ways. For\n example, in this code, each of these three local variables contains a\n point, but allocated in a different place:\n \n ~~~\n-# type point = {x: float, y: float};\n-let on_the_stack : point  =  {x: 3.0, y: 4.0};\n-let shared_box   : @point = @{x: 5.0, y: 1.0};\n-let unique_box   : ~point = ~{x: 7.0, y: 9.0};\n+# struct Point {x: float, y: float}\n+let on_the_stack :  Point =  Point {x: 3.0, y: 4.0};\n+let shared_box   : @Point = @Point {x: 5.0, y: 1.0};\n+let unique_box   : ~Point = ~Point {x: 7.0, y: 9.0};\n ~~~\n \n Suppose we wanted to write a procedure that computed the distance\n@@ -59,9 +59,9 @@ define a function that takes the points by pointer. We can use\n borrowed pointers to do this:\n \n ~~~\n-# type point = {x: float, y: float};\n+# struct Point {x: float, y: float}\n # fn sqrt(f: float) -> float { 0f }\n-fn compute_distance(p1: &point, p2: &point) -> float {\n+fn compute_distance(p1: &Point, p2: &Point) -> float {\n     let x_d = p1.x - p2.x;\n     let y_d = p1.y - p2.y;\n     sqrt(x_d * x_d + y_d * y_d)\n@@ -71,26 +71,26 @@ fn compute_distance(p1: &point, p2: &point) -> float {\n Now we can call `compute_distance()` in various ways:\n \n ~~~\n-# type point = {x: float, y: float};\n-# let on_the_stack : point  =  {x: 3.0, y: 4.0};\n-# let shared_box   : @point = @{x: 5.0, y: 1.0};\n-# let unique_box   : ~point = ~{x: 7.0, y: 9.0};\n-# fn compute_distance(p1: &point, p2: &point) -> float { 0f }\n+# struct Point {x: float, y: float}\n+# let on_the_stack :  Point =  Point{x: 3.0, y: 4.0};\n+# let shared_box   : @Point = @Point{x: 5.0, y: 1.0};\n+# let unique_box   : ~Point = ~Point{x: 7.0, y: 9.0};\n+# fn compute_distance(p1: &Point, p2: &Point) -> float { 0f }\n compute_distance(&on_the_stack, shared_box);\n compute_distance(shared_box, unique_box);\n ~~~\n \n Here the `&` operator is used to take the address of the variable\n-`on_the_stack`; this is because `on_the_stack` has the type `point`\n-(that is, a record value) and we have to take its address to get a\n+`on_the_stack`; this is because `on_the_stack` has the type `Point`\n+(that is, a struct value) and we have to take its address to get a\n value. We also call this _borrowing_ the local variable\n `on_the_stack`, because we are created an alias: that is, another\n route to the same data.\n \n In the case of the boxes `shared_box` and `unique_box`, however, no\n explicit action is necessary. The compiler will automatically convert\n-a box like `@point` or `~point` to a borrowed pointer like\n-`&point`. This is another form of borrowing; in this case, the\n+a box like `@Point` or `~Point` to a borrowed pointer like\n+`&Point`. This is another form of borrowing; in this case, the\n contents of the shared/unique box is being lent out.\n \n Whenever a value is borrowed, there are some limitations on what you\n@@ -108,8 +108,8 @@ it again.\n In the previous example, the value `on_the_stack` was defined like so:\n \n ~~~\n-# type point = {x: float, y: float};\n-let on_the_stack : point = {x: 3.0, y: 4.0};\n+# struct Point {x: float, y: float}\n+let on_the_stack: Point = Point {x: 3.0, y: 4.0};\n ~~~\n \n This results in a by-value variable. As a consequence, we had to\n@@ -118,60 +118,66 @@ pointer. Sometimes however it is more convenient to move the &\n operator into the definition of `on_the_stack`:\n \n ~~~\n-# type point = {x: float, y: float};\n-let on_the_stack2 : &point = &{x: 3.0, y: 4.0};\n+# struct Point {x: float, y: float}\n+let on_the_stack2: &Point = &Point {x: 3.0, y: 4.0};\n ~~~\n \n Applying `&` to an rvalue (non-assignable location) is just a convenient\n shorthand for creating a temporary and taking its address:\n \n ~~~\n-# type point = {x: float, y: float};\n-let tmp = {x: 3.0, y: 4.0};\n-let on_the_stack2 : &point = &tmp;\n+# struct Point {x: float, y: float}\n+let tmp = Point {x: 3.0, y: 4.0};\n+let on_the_stack2 : &Point = &tmp;\n ~~~\n \n-Taking the address of fields\n+# Taking the address of fields\n \n As in C, the `&` operator is not limited to taking the address of\n local variables. It can also be used to take the address of fields or\n individual array elements. For example, consider this type definition\n for `rectangle`:\n \n ~~~\n-type point = {x: float, y: float}; // as before\n-type size = {w: float, h: float}; // as before\n-type rectangle = {origin: point, size: size};\n+struct Point {x: float, y: float} // as before\n+struct Size {w: float, h: float} // as before\n+struct Rectangle {origin: Point, size: Size}\n ~~~\n \n Now again I can define rectangles in a few different ways:\n \n ~~~\n-let rect_stack  = &{origin: {x: 1f, y: 2f}, size: {w: 3f, h: 4f}};\n-let rect_shared = @{origin: {x: 3f, y: 4f}, size: {w: 3f, h: 4f}};\n-let rect_unique = ~{origin: {x: 5f, y: 6f}, size: {w: 3f, h: 4f}};\n+# struct Point {x: float, y: float}\n+# struct Size {w: float, h: float} // as before\n+# struct Rectangle {origin: Point, size: Size}\n+let rect_stack   = &Rectangle {origin: Point {x: 1f, y: 2f},\n+                               size: Size {w: 3f, h: 4f}};\n+let rect_managed = @Rectangle {origin: Point {x: 3f, y: 4f},\n+                               size: Size {w: 3f, h: 4f}};\n+let rect_unique  = ~Rectangle {origin: Point {x: 5f, y: 6f},\n+                               size: Size {w: 3f, h: 4f}};\n ~~~\n \n In each case I can use the `&` operator to extact out individual\n subcomponents. For example, I could write:\n \n ~~~\n-# type point = {x: float, y: float};\n-# type size = {w: float, h: float}; // as before\n-# type rectangle = {origin: point, size: size};\n-# let rect_stack  = &{origin: {x: 1f, y: 2f}, size: {w: 3f, h: 4f}};\n-# let rect_shared = @{origin: {x: 3f, y: 4f}, size: {w: 3f, h: 4f}};\n-# let rect_unique = ~{origin: {x: 5f, y: 6f}, size: {w: 3f, h: 4f}};\n-# fn compute_distance(p1: &point, p2: &point) -> float { 0f }\n-compute_distance(&rect_stack.origin, &rect_shared.origin);\n+# struct Point {x: float, y: float} // as before\n+# struct Size {w: float, h: float} // as before\n+# struct Rectangle {origin: Point, size: Size}\n+# let rect_stack  = &{origin: Point {x: 1f, y: 2f}, size: Size {w: 3f, h: 4f}};\n+# let rect_managed = @{origin: Point {x: 3f, y: 4f}, size: Size {w: 3f, h: 4f}};\n+# let rect_unique = ~{origin: Point {x: 5f, y: 6f}, size: Size {w: 3f, h: 4f}};\n+# fn compute_distance(p1: &Point, p2: &Point) -> float { 0f }\n+compute_distance(&rect_stack.origin, &rect_managed.origin);\n ~~~\n \n which would borrow the field `origin` from the rectangle on the stack\n-from the shared box and then compute the distance between them.\n+from the managed box and then compute the distance between them.\n \n-# Borrowing shared boxes and rooting\n+# Borrowing managed boxes and rooting\n \n-We\u2019ve seen a few examples so far where heap boxes (both shared and\n+We\u2019ve seen a few examples so far where heap boxes (both managed and\n unique) are borrowed. Up till this point, we\u2019ve glossed over issues of\n safety. As stated in the introduction, at runtime a borrowed pointer\n is simply a pointer, nothing more. Therefore, if we wish to avoid the\n@@ -192,8 +198,9 @@ relatively easy, such as when taking the address of a local variable\n or a field that is stored on the stack:\n \n ~~~\n+struct X { f: int }\n fn example1() {\n-    let mut x = {f: 3};\n+    let mut x = X { f: 3 };\n     let y = &mut x.f;  // -+ L\n     ...                //  |\n }                      // -+\n@@ -207,8 +214,9 @@ The situation gets more complex when borrowing data that resides in\n heap boxes:\n \n ~~~\n+# struct X { f: int }\n fn example2() {\n-    let mut x = @{f: 3};\n+    let mut x = @X { f: 3 };\n     let y = &x.f;      // -+ L\n     ...                //  |\n }                      // -+\n@@ -218,40 +226,41 @@ In this example, the value `x` is in fact a heap box, and `y` is\n therefore a pointer into that heap box. Again the lifetime of `y` will\n be L, the remainder of the function body. But there is a crucial\n difference: suppose `x` were reassigned during the lifetime L? If\n-we\u2019re not careful, that could mean that the shared box would become\n+we\u2019re not careful, that could mean that the managed box would become\n unrooted and therefore be subject to garbage collection\n \n > ***Note:***In our current implementation, the garbage collector is\n > implemented using reference counting and cycle detection.\n \n-For this reason, whenever the interior of a shared box stored in a\n+For this reason, whenever the interior of a managed box stored in a\n mutable location is borrowed, the compiler will insert a temporary\n-that ensures that the shared box remains live for the entire\n+that ensures that the managed box remains live for the entire\n lifetime. So, the above example would be compiled as:\n \n ~~~\n+# struct X { f: int }\n fn example2() {\n-    let mut x = @{f: 3};\n+    let mut x = @X {f: 3};\n     let x1 = x;\n     let y = &x1.f;     // -+ L\n     ...                //  |\n }                      // -+\n ~~~\n \n Now if `x` is reassigned, the pointer `y` will still remain valid. This\n-process is called \u201crooting\u201d.\n+process is called *rooting*.\n \n # Borrowing unique boxes\n \n-The previous example demonstrated `rooting`, the process by which the\n-compiler ensures that shared boxes remain live for the duration of a\n+The previous example demonstrated *rooting*, the process by which the\n+compiler ensures that managed boxes remain live for the duration of a\n borrow. Unfortunately, rooting does not work if the data being\n borrowed is a unique box, as it is not possible to have two references\n to a unique box.\n \n-For unique boxes, therefore, the compiler will only allow a borrow `if\n+For unique boxes, therefore, the compiler will only allow a borrow *if\n the compiler can guarantee that the unique box will not be reassigned\n-or moved for the lifetime of the pointer`. This does not necessarily\n+or moved for the lifetime of the pointer*. This does not necessarily\n mean that the unique box is stored in immutable memory. For example,\n the following function is legal:\n \n@@ -283,7 +292,7 @@ rejected by the compiler):\n \n ~~~ {.xfail-test}\n fn example3() -> int {\n-    let mut x = ~{f: 3};\n+    let mut x = ~X {f: 3};\n     let y = &x.f;\n     x = ~{f: 4};  // Error reported here.\n     *y\n@@ -325,15 +334,18 @@ which has been freed.\n In fact, the compiler can apply this same kind of reasoning can be\n applied to any memory which is _(uniquely) owned by the stack\n frame_. So we could modify the previous example to introduce\n-additional unique pointers and records, and the compiler will still be\n+additional unique pointers and structs, and the compiler will still be\n able to detect possible mutations:\n \n ~~~ {.xfail-test}\n fn example3() -> int {\n-    let mut x = ~{mut f: ~{g: 3}};\n+    struct R { g: int }\n+    struct S { mut f: ~R }\n+\n+    let mut x = ~S {mut f: ~R {g: 3}};\n     let y = &x.f.g;\n-    x = ~{mut f: ~{g: 4}}; // Error reported here.\n-    x.f = ~{g: 5};         // Error reported here.\n+    x = ~S {mut f: ~R {g: 4}}; // Error reported here.\n+    x.f = ~R {g: 5};           // Error reported here.\n     *y\n }\n ~~~\n@@ -346,17 +358,20 @@ Things get tricker when the unique box is not uniquely owned by the\n stack frame (or when the compiler doesn\u2019t know who the owner\n is). Consider a program like this:\n \n-~~~ {.xfail-test}\n-fn example5a(x: @{mut f: ~{g: int}} ...) -> int {\n+~~~\n+struct R { g: int }\n+struct S { mut f: ~R }\n+fn example5a(x: @S ...) -> int {\n     let y = &x.f.g;   // Error reported here.\n     ...\n+#   return 0;\n }\n ~~~\n \n Here the heap looks something like:\n \n ~~~ {.notrust}\n-     Stack            Shared Heap       Exchange Heap\n+     Stack            Managed Heap       Exchange Heap\n \n   x +------+        +-------------+       +------+\n     | @... | ---->  | mut f: ~... | --+-> | g: 3 |\n@@ -368,7 +383,7 @@ Here the heap looks something like:\n In this case, the owning reference to the value being borrowed is in\n fact `x.f`. Moreover, `x.f` is both mutable and aliasable. Aliasable\n means that it is possible that there are other pointers to that same\n-shared box, so even if the compiler were to prevent `x.f` from being\n+managed box, so even if the compiler were to prevent `x.f` from being\n mutated, the field might still be changed through some alias of\n `x`. Therefore, to be safe, the compiler only accepts pure actions\n during the lifetime of `y`. We\u2019ll have a final example on purity but\n@@ -379,7 +394,9 @@ unique found in aliasable memory is to ensure that it is stored within\n unique fields, as in the following example:\n \n ~~~\n-fn example5b(x: @{f: ~{g: int}}) -> int {\n+struct R { g: int }\n+struct S { f: ~R }\n+fn example5b(x: @S) -> int {\n     let y = &x.f.g;\n     ...\n # return 0;\n@@ -394,21 +411,32 @@ If you do have a unique box in a mutable field, and you wish to borrow\n it, one option is to use the swap operator to bring that unique box\n onto your stack:\n \n-~~~ {.xfail-test}\n-fn example5c(x: @{mut f: ~int}) -> int {\n-    let mut v = ~0;\n+~~~\n+struct R { g: int }\n+struct S { mut f: ~R }\n+fn example5c(x: @S) -> int {\n+    let mut v = ~R {g: 0};\n     v <-> x.f;         // Swap v and x.f\n-    let y = &v;\n-    ...\n+    { // Block constrains the scope of `y`:\n+        let y = &v.g;\n+        ...\n+    }\n     x.f <- v;          // Replace x.f\n     ...\n # return 0;\n }\n ~~~\n \n-Of course, this has the side effect of modifying your shared box for\n-the duration of the borrow, so it works best when you know that you\n-won\u2019t be accessing that same box again.\n+Of course, this has the side effect of modifying your managed box for\n+the duration of the borrow, so it only works when you know that you\n+won\u2019t be accessing that same box for the duration of the loan.  Note\n+also that sometimes it is necessary to introduce additional blocks to\n+constrain the scope of the loan.  In this example, the borrowed\n+pointer `y` would still be in scope when you moved the value `v` back\n+into `x.f`, and hence moving `v` would be considered illegal.  You\n+cannot move values if they are outstanding loans which are still\n+valid.  By introducing the block, the scope of `y` is restricted and so\n+the move is legal.\n \n # Borrowing and enums\n \n@@ -422,11 +450,11 @@ As an example, let\u2019s look at the following `shape` type that can\n represent both rectangles and circles:\n \n ~~~\n-type point = {x: float, y: float}; // as before\n-type size = {w: float, h: float}; // as before\n-enum shape {\n-    circle(point, float),   // origin, radius\n-    rectangle(point, size)  // upper-left, dimensions\n+struct Point {x: float, y: float}; // as before\n+struct Size {w: float, h: float}; // as before\n+enum Shape {\n+    Circle(Point, float),   // origin, radius\n+    Rectangle(Point, Size)  // upper-left, dimensions\n }\n ~~~\n \n@@ -435,17 +463,17 @@ function takes a borrowed pointer to a shape to avoid the need of\n copying them.\n \n ~~~\n-# type point = {x: float, y: float}; // as before\n-# type size = {w: float, h: float}; // as before\n-# enum shape {\n-#     circle(point, float),   // origin, radius\n-#     rectangle(point, size)  // upper-left, dimensions\n+# struct Point {x: float, y: float}; // as before\n+# struct Size {w: float, h: float}; // as before\n+# enum Shape {\n+#     Circle(Point, float),   // origin, radius\n+#     Rectangle(Point, Size)  // upper-left, dimensions\n # }\n # const tau: float = 6.28f;\n-fn compute_area(shape: &shape) -> float {\n+fn compute_area(shape: &Shape) -> float {\n     match *shape {\n-        circle(_, radius) => 0.5 * tau * radius * radius,\n-        rectangle(_, ref size) => size.w * size.h\n+        Circle(_, radius) => 0.5 * tau * radius * radius,\n+        Rectangle(_, ref size) => size.w * size.h\n     }\n }\n ~~~\n@@ -504,75 +532,82 @@ Stack             Memory\n ~~~\n \n As you can see, the `size` pointer would not be pointing at a `float` and\n-not a record. This is not good.\n+not a struct. This is not good.\n \n So, in fact, for every `ref` binding, the compiler will impose the\n same rules as the ones we saw for borrowing the interior of a unique\n box: it must be able to guarantee that the enum will not be\n overwritten for the duration of the borrow.  In fact, the example I\n gave earlier would be considered safe. This is because the shape\n-pointer has type `&shape`, which means \u201cborrowed pointer to immutable\n+pointer has type `&Shape`, which means \u201cborrowed pointer to immutable\n memory containing a shape\u201d. If however the type of that pointer were\n-`&const shape` or `&mut shape`, then the ref binding would not be\n+`&const Shape` or `&mut Shape`, then the ref binding would not be\n permitted. Just as with unique boxes, the compiler will permit ref\n bindings into data owned by the stack frame even if it is mutable, but\n otherwise it requires that the data reside in immutable memory.\n \n-> ***Note:*** Right now, all pattern bindings are by-reference. We\n-> expect this to change so that copies are the default and references\n-> must be noted explicitly.\n+> ***Note:*** Right now, pattern bindings not explicitly annotated\n+> with `ref` or `copy` use a special mode of \"implicit by reference\".\n+> This is changing as soon as we finish updating all the existing code\n+> in the compiler that relies on the current settings.\n \n # Returning borrowed pointers\n \n So far, all of the examples we\u2019ve looked at use borrowed pointers in a\n \u201cdownward\u201d direction. That is, the borrowed pointer is created and\n-then used during the method or code block which created it. In some\n-cases, it is also possible to return borrowed pointers to the caller,\n-but as we\u2019ll see this is more limited.\n+then used during the method or code block which created it. It is also\n+possible to return borrowed pointers to the caller, but as we'll see\n+this requires some explicit annotation.\n \n For example, we could write a subroutine like this:\n \n-~~~ {.xfail-test}\n-type point = {x: float, y: float};\n-fn get_x(p: &point) -> &float { &p.x }\n+~~~\n+struct Point {x: float, y: float}\n+fn get_x(p: &r/Point) -> &r/float { &p.x }\n ~~~\n \n Here, the function `get_x()` returns a pointer into the structure it was\n-given. You\u2019ll note that _both_ the parameter and the return value are\n-borrowed pointers; this is important. In general, it is only possible\n-to return borrowed pointers if they are derived from a borrowed\n-pointer which was given as input to the procedure.\n-\n-In the example, `get_x()` took a borrowed pointer to a `point` as\n-input. In general, for all borrowed pointers that appear in the\n-signature of a function (such as the parameter and return types), the\n-compiler assigns the same symbolic lifetime L (we will see later that\n-there are ways to differentiate the lifetimes of different parameters\n-if that should be necessary). This means that, from the compiler\u2019s\n-point of view, `get_x()` takes and returns two pointers with the same\n-lifetime. Now, unlike other lifetimes, this lifetime is a bit\n-abstract: it doesn\u2019t refer to a specific expression within `get_x()`,\n-but rather to some expression within the caller. This is called a\n-_lifetime parameter_, because the lifetime L is effectively defined by\n-the caller to `get_x()`, just as the value for the parameter `p` is\n-defined by the caller.\n-\n-In any case, whatever the lifetime L is, the pointer produced by\n+given. The type of the parameter (`&r/Point`) and return type (`&r/float`) both\n+make use of a new syntactic form that we have not seen so far.  Here the identifier `r`\n+serves as an explicit name for the lifetime of the pointer.  So in effect\n+this function is declaring that it takes in a pointer with lifetime `r` and returns\n+a pointer with that same lifetime.\n+\n+In general, it is only possible to return borrowed pointers if they\n+are derived from a borrowed pointer which was given as input to the\n+procedure.  In that case, they will always have the same lifetime as\n+one of the parameters; named lifetimes are used to indicate which\n+parameter that is.\n+\n+In the examples before, function parameter types did not include a\n+lifetime name.  In this case, the compiler simply creates a new,\n+anonymous name, meaning that the parameter is assumed to have a\n+distinct lifetime from all other parameters.\n+\n+Named lifetimes that appear in function signatures are conceptually\n+the same as the other lifetimes we've seen before, but they are a bit\n+abstract: they don\u2019t refer to a specific expression within `get_x()`,\n+but rather to some expression within the *caller of `get_x()`*.  The\n+lifetime `r` is actually a kind of *lifetime parameter*: it is defined\n+by the caller to `get_x()`, just as the value for the parameter `p` is\n+defined by that caller.\n+\n+In any case, whatever the lifetime `r` is, the pointer produced by\n `&p.x` always has the same lifetime as `p` itself, as a pointer to a\n-field of a record is valid as long as the record is valid. Therefore,\n+field of a struct is valid as long as the struct is valid. Therefore,\n the compiler is satisfied with the function `get_x()`.\n \n To drill in this point, let\u2019s look at a variation on the example, this\n time one which does not compile:\n \n ~~~ {.xfail-test}\n-type point = {x: float, y: float};\n-fn get_x_sh(p: @point) -> &float {\n+struct Point {x: float, y: float}\n+fn get_x_sh(p: @Point) -> &float {\n     &p.x // Error reported here\n }\n ~~~\n \n-Here, the function `get_x_sh()` takes a shared box as input and\n+Here, the function `get_x_sh()` takes a managed box as input and\n returns a borrowed pointer. As before, the lifetime of the borrowed\n pointer that will be returned is a parameter (specified by the\n caller). That means that effectively `get_x_sh()` is promising to\n@@ -582,121 +617,114 @@ promised to return a pointer that was valid for as long as the pointer\n it was given.\n \n Within `get_x_sh()`, we see the expression `&p.x` which takes the\n-address of a field of a shared box. This implies that the compiler\n+address of a field of a managed box. This implies that the compiler\n must guarantee that, so long as the resulting pointer is valid, the\n-shared box will not be reclaimed by the garbage collector. But recall\n-that get_x_sh() also promised to return a pointer that was valid for\n+managed box will not be reclaimed by the garbage collector. But recall\n+that `get_x_sh()` also promised to return a pointer that was valid for\n as long as the caller wanted it to be. Clearly, `get_x_sh()` is not in\n a position to make both of these guarantees; in fact, it cannot\n guarantee that the pointer will remain valid at all once it returns,\n as the parameter `p` may or may not be live in the caller. Therefore,\n the compiler will report an error here.\n \n-In general, if you borrow a shared (or unique) box to create a\n+In general, if you borrow a managed (or unique) box to create a\n borrowed pointer, the pointer will only be valid within the function\n-and cannot be returned. Generally, the only way to return borrowed\n-pointers is to take borrowed pointers as input.\n+and cannot be returned. This is why the typical way to return borrowed\n+pointers is to take borrowed pointers as input (the only other case in\n+which it can be legal to return a borrowed pointer is if the pointer\n+points at a static constant).\n \n # Named lifetimes\n \n-So far we have always used the notation `&T` for a borrowed\n-pointer. However, sometimes if a function takes many parameters, it is\n-useful to be able to group those parameters by lifetime. For example,\n-consider this function:\n+Let's look at named lifetimes in more detail.  In effect, the use of\n+named lifetimes allows you to group parameters by lifetime.  For\n+example, consider this function:\n \n-~~~ {.xfail-test}\n-# type point = {x: float, y: float}; // as before\n-# type size = {w: float, h: float}; // as before\n-# enum shape {\n-#     circle(point, float),   // origin, radius\n-#     rectangle(point, size)  // upper-left, dimensions\n+~~~\n+# struct Point {x: float, y: float}; // as before\n+# struct Size {w: float, h: float}; // as before\n+# enum Shape {\n+#     Circle(Point, float),   // origin, radius\n+#     Rectangle(Point, Size)  // upper-left, dimensions\n # }\n-# fn compute_area(shape: &shape) -> float { 0f }\n-fn select<T>(shape: &shape, threshold: float,\n-             a: &T, b: &T) -> &T {\n+# fn compute_area(shape: &Shape) -> float { 0f }\n+fn select<T>(shape: &r/Shape, threshold: float,\n+             a: &r/T, b: &r/T) -> &r/T {\n     if compute_area(shape) > threshold {a} else {b}\n }\n ~~~\n \n-This function takes three borrowed pointers. Because of the way that\n-the system works, each will be assigned the same lifetime: the default\n-lifetime parameter. In practice, this means that, in the caller, the\n-lifetime of the returned value will be the intersection of the\n-lifetime of the three region parameters. This may be overloy\n-conservative, as in this example:\n+This function takes three borrowed pointers and assigns each the same\n+lifetime `r`.  In practice, this means that, in the caller, the\n+lifetime `r` will be the *intersection of the lifetime of the three\n+region parameters*. This may be overly conservative, as in this\n+example:\n \n-~~~ {.xfail-test}\n-# type point = {x: float, y: float}; // as before\n-# type size = {w: float, h: float}; // as before\n-# enum shape {\n-#     circle(point, float),   // origin, radius\n-#     rectangle(point, size)  // upper-left, dimensions\n+~~~\n+# struct Point {x: float, y: float}; // as before\n+# struct Size {w: float, h: float}; // as before\n+# enum Shape {\n+#     Circle(Point, float),   // origin, radius\n+#     Rectangle(Point, Size)  // upper-left, dimensions\n # }\n-# fn compute_area(shape: &shape) -> float { 0f }\n-# fn select<T>(shape: &shape, threshold: float,\n-#              a: &T, b: &T) -> &T {\n+# fn compute_area(shape: &Shape) -> float { 0f }\n+# fn select<T>(shape: &Shape, threshold: float,\n+#              a: &r/T, b: &r/T) -> &r/T {\n #     if compute_area(shape) > threshold {a} else {b}\n # }\n-\n-                                              // -+ L\n-fn select_based_on_unit_circle<T>(            //  |-+ B\n-    threshold: float, a: &T, b: &T) -> &T {   //  | |\n-                                              //  | |\n-    let shape = circle({x: 0, y: 0}, 1);      //  | |\n-    select(&shape, threshold, a, b)           //  | |\n-}                                             //  |-+\n-                                              // -+\n+                                                  // -+ r\n+fn select_based_on_unit_circle<T>(                //  |-+ B\n+    threshold: float, a: &r/T, b: &r/T) -> &r/T { //  | |\n+                                                  //  | |\n+    let shape = Circle(Point {x: 0., y: 0.}, 1.); //  | |\n+    select(&shape, threshold, a, b)               //  | |\n+}                                                 //  |-+\n+                                                  // -+\n ~~~\n \n In this call to `select()`, the lifetime of the first parameter shape\n is B, the function body. Both of the second two parameters `a` and `b`\n-share the same lifetime, L, which is the lifetime parameter of\n+share the same lifetime, `r`, which is a lifetime parameter of\n `select_based_on_unit_circle()`. The caller will infer the\n-intersection of these three lifetimes as the lifetime of the returned\n+intersection of these two lifetimes as the lifetime of the returned\n value, and hence the return value of `shape()` will be assigned a\n-return value of B. This will in turn lead to a compilation error,\n-because `select_based_on_unit_circle()` is supposed to return a value\n-with the lifetime L.\n+lifetime of B. This will in turn lead to a compilation error, because\n+`select_based_on_unit_circle()` is supposed to return a value with the\n+lifetime `r`.\n \n-To address this, we could modify the definition of `select()` to\n+To address this, we can modify the definition of `select()` to\n distinguish the lifetime of the first parameter from the lifetime of\n the latter two. After all, the first parameter is not being\n-returned. To do so, we make use of the notation `&lt/T`, which is a\n-borrowed pointer with an explicit lifetime. This effectively creates a\n-second lifetime parameter for the function; named lifetime parameters\n-do not need to be declared, you just use them. Here is how the new\n-`select()` might look:\n+returned. Here is how the new `select()` might look:\n \n-~~~ {.xfail-test}\n-# type point = {x: float, y: float}; // as before\n-# type size = {w: float, h: float}; // as before\n-# enum shape {\n-#     circle(point, float),   // origin, radius\n-#     rectangle(point, size)  // upper-left, dimensions\n+~~~\n+# struct Point {x: float, y: float}; // as before\n+# struct Size {w: float, h: float}; // as before\n+# enum Shape {\n+#     Circle(Point, float),   // origin, radius\n+#     Rectangle(Point, Size)  // upper-left, dimensions\n # }\n-# fn compute_area(shape: &shape) -> float { 0f }\n-fn select<T>(shape: &tmp/shape, threshold: float,\n-             a: &T, b: &T) -> &T {\n+# fn compute_area(shape: &Shape) -> float { 0f }\n+fn select<T>(shape: &tmp/Shape, threshold: float,\n+             a: &r/T, b: &r/T) -> &r/T {\n     if compute_area(shape) > threshold {a} else {b}\n }\n ~~~\n \n Here you can see the lifetime of shape is now being called `tmp`. The\n-parameters `a`, `b`, and the return value all remain with the default\n-lifetime parameter.\n-\n-You could also write `select()` using all named lifetime parameters,\n-which might look like:\n+parameters `a`, `b`, and the return value are all given the lifetime\n+`r`.  However, since the lifetime `tmp` is not returned, it would be shorter\n+to just omit the named lifetime for `shape` altogether:\n \n-~~~ {.xfail-test}\n-# type point = {x: float, y: float}; // as before\n-# type size = {w: float, h: float}; // as before\n-# enum shape {\n-#     circle(point, float),   // origin, radius\n-#     rectangle(point, size)  // upper-left, dimensions\n+~~~\n+# struct Point {x: float, y: float}; // as before\n+# struct Size {w: float, h: float}; // as before\n+# enum Shape {\n+#     Circle(Point, float),   // origin, radius\n+#     Rectangle(Point, Size)  // upper-left, dimensions\n # }\n-# fn compute_area(shape: &shape) -> float { 0f }\n-fn select<T>(shape: &tmp/shape, threshold: float,\n+# fn compute_area(shape: &Shape) -> float { 0f }\n+fn select<T>(shape: &Shape, threshold: float,\n              a: &r/T, b: &r/T) -> &r/T {\n     if compute_area(shape) > threshold {a} else {b}\n }\n@@ -721,7 +749,9 @@ a unique box found in an aliasable, mutable location, only now we\u2019ve\n replaced the `...` with some specific code:\n \n ~~~\n-fn example5a(x: @{mut f: ~{g: int}} ...) -> int {\n+struct R { g: int }\n+struct S { mut f: ~R }\n+fn example5a(x: @S ...) -> int {\n     let y = &x.f.g;   // Unsafe\n     *y + 1        \n }\n@@ -739,9 +769,11 @@ fn add_one(x: &int) -> int { *x + 1 }\n \n We can now update `example5a()` to use `add_one()`:\n \n-~~~ {.xfail-test}\n-# fn add_one(x: &int) -> int { *x + 1 }\n-fn example5a(x: @{mut f: ~{g: int}} ...) -> int {\n+~~~\n+# struct R { g: int }\n+# struct S { mut f: ~R }\n+# pure fn add_one(x: &int) -> int { *x + 1 }\n+fn example5a(x: @S ...) -> int {\n     let y = &x.f.g;\n     add_one(y)        // Error reported here\n }\n@@ -763,4 +795,4 @@ With this change, the modified version of `example5a()` will again compile.\n So there you have it. A (relatively) brief tour of borrowed pointer\n system. For more details, I refer to the (yet to be written) reference\n document on borrowed pointers, which will explain the full notation\n-and give more examples.\n\\ No newline at end of file\n+and give more examples."}, {"sha": "463bd4746feec9deb68732ee7e50727021967a5a", "filename": "doc/tutorial-ffi.md", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/doc%2Ftutorial-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/doc%2Ftutorial-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-ffi.md?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -1,4 +1,6 @@\n-# Interacting with foreign code\n+% Rust Foreign Function Interface Tutorial\n+\n+# Introduction\n \n One of Rust's aims, as a system programming language, is to\n interoperate well with C code.\n@@ -38,7 +40,7 @@ fn main(args: ~[~str]) {\n }\n ~~~~\n \n-## Foreign modules\n+# Foreign modules\n \n Before we can call `SHA1`, we have to declare it. That is what this\n part of the program is responsible for:\n@@ -68,7 +70,7 @@ extern mod something {\n }\n ~~~~\n \n-## Foreign calling conventions\n+# Foreign calling conventions\n \n Most foreign code will be C code, which usually uses the `cdecl` calling\n convention, so that is what Rust uses by default when calling foreign\n@@ -88,7 +90,7 @@ The `\"abi\"` attribute applies to a foreign module (it can not be applied\n to a single function within a module), and must be either `\"cdecl\"`\n or `\"stdcall\"`. Other conventions may be defined in the future.\n \n-## Unsafe pointers\n+# Unsafe pointers\n \n The foreign `SHA1` function is declared to take three arguments, and\n return a pointer.\n@@ -118,7 +120,7 @@ caution\u2014unlike Rust's other pointer types, unsafe pointers are\n completely unmanaged, so they might point at invalid memory, or be\n null pointers.\n \n-## Unsafe blocks\n+# Unsafe blocks\n \n The `sha1` function is the most obscure part of the program.\n \n@@ -159,7 +161,7 @@ unsafe fn kaboom() { ~\"I'm harmless!\"; }\n This function can only be called from an unsafe block or another\n unsafe function.\n \n-## Pointer fiddling\n+# Pointer fiddling\n \n The standard library defines a number of helper functions for dealing\n with unsafe data, casting between types, and generally subverting\n@@ -202,10 +204,10 @@ unsafe pointer that was returned by `SHA1`. SHA1 digests are always\n twenty bytes long, so we can pass `20u` for the length of the new\n vector.\n \n-## Passing structures\n+# Passing structures\n \n C functions often take pointers to structs as arguments. Since Rust\n-records are binary-compatible with C structs, Rust programs can call\n+structs are binary-compatible with C structs, Rust programs can call\n such functions directly.\n \n This program uses the POSIX function `gettimeofday` to get a\n@@ -215,15 +217,21 @@ microsecond-resolution timer.\n extern mod std;\n use libc::c_ulonglong;\n \n-type timeval = {mut tv_sec: c_ulonglong,\n-                mut tv_usec: c_ulonglong};\n+struct timeval {\n+    mut tv_sec: c_ulonglong,\n+    mut tv_usec: c_ulonglong\n+}\n+\n #[nolink]\n extern mod lib_c {\n     fn gettimeofday(tv: *timeval, tz: *()) -> i32;\n }\n fn unix_time_in_microseconds() -> u64 unsafe {\n-    let x = {mut tv_sec: 0 as c_ulonglong, mut tv_usec: 0 as c_ulonglong};\n-    lib_c::gettimeofday(ptr::addr_of(x), ptr::null());\n+    let x = timeval {\n+        mut tv_sec: 0 as c_ulonglong,\n+        mut tv_usec: 0 as c_ulonglong\n+    };\n+    lib_c::gettimeofday(ptr::addr_of(&x), ptr::null());\n     return (x.tv_sec as u64) * 1000_000_u64 + (x.tv_usec as u64);\n }\n \n@@ -234,8 +242,8 @@ The `#[nolink]` attribute indicates that there's no foreign library to\n link in. The standard C library is already linked with Rust programs.\n \n A `timeval`, in C, is a struct with two 32-bit integers. Thus, we\n-define a record type with the same contents, and declare\n-`gettimeofday` to take a pointer to such a record.\n+define a struct type with the same contents, and declare\n+`gettimeofday` to take a pointer to such a struct.\n \n The second argument to `gettimeofday` (the time zone) is not used by\n this program, so it simply declares it to be a pointer to the nil"}, {"sha": "5cd5d79bd29795c29f7a2b71bf7ed5034ea6816d", "filename": "doc/tutorial-macros.md", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/doc%2Ftutorial-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/doc%2Ftutorial-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-macros.md?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -1,4 +1,6 @@\n-# Macros\n+% Rust Macros Tutorial\n+\n+# Introduction\n \n Functions are the programmer's primary tool of abstraction, but there are\n cases in which they are insufficient, because the programmer wants to\n@@ -50,7 +52,7 @@ early_return!(input_2 special_b);\n \n Macros are defined in pattern-matching style:\n \n-## Invocation syntax\n+# Invocation syntax\n \n On the left-hand-side of the `=>` is the macro invocation syntax. It is\n free-form, excepting the following rules:\n@@ -69,7 +71,7 @@ rules of tokenization apply,\n So `($x:ident => (($e:expr)))`, though excessively fancy, would create a macro\n that could be invoked like `my_macro!(i=>(( 2+2 )))`.\n \n-## Transcription syntax\n+# Transcription syntax\n \n The right-hand side of the `=>` follows the same rules as the left-hand side,\n except that `$` need only be followed by the name of the syntactic fragment\n@@ -80,9 +82,9 @@ an expression; currently, user-defined macros can only be invoked in\n expression position (even though `macro_rules!` itself can be in item\n position).\n \n-## Multiplicity\n+# Multiplicity\n \n-### Invocation\n+## Invocation\n \n Going back to the motivating example, suppose that we wanted each invocation\n of `early_return` to potentially accept multiple \"special\" identifiers. The"}, {"sha": "405f4ac73478afac496a37232bfdf480501e371f", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 409, "deletions": 52, "changes": 461, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -1,52 +1,165 @@\n-% Tasks and communication in Rust\n+% Rust Tasks and Communication Tutorial\n+\n+# Introduction\n+\n+The Rust language is designed from the ground up to support pervasive\n+and safe concurrency through lightweight, memory-isolated tasks and\n+message passing.\n+\n+Rust tasks are not the same as traditional threads - they are what are\n+often referred to as _green threads_, cooperatively scheduled by the\n+Rust runtime onto a small number of operating system threads.  Being\n+significantly cheaper to create than traditional threads, Rust can\n+create hundreds of thousands of concurrent tasks on a typical 32-bit\n+system.\n+\n+Tasks provide failure isolation and recovery. When an exception occurs\n+in rust code (either by calling `fail` explicitly or by otherwise performing\n+an invalid operation) the entire task is destroyed - there is no way\n+to `catch` an exception as in other languages. Instead tasks may monitor\n+each other to detect when failure has occurred.\n+\n+Rust tasks have dynamically sized stacks. When a task is first created\n+it starts off with a small amount of stack (currently in the low\n+thousands of bytes, depending on platform) and more stack is acquired as\n+needed. A Rust task will never run off the end of the stack as is\n+possible in many other languages, but they do have a stack budget, and\n+if a Rust task exceeds its stack budget then it will fail safely.\n+\n+Tasks make use of Rust's type system to provide strong memory safety\n+guarantees, disallowing shared mutable state. Communication between\n+tasks is facilitated by the transfer of _owned_ data through the\n+global _exchange heap_.\n+\n+This tutorial will explain the basics of tasks and communication in Rust,\n+explore some typical patterns in concurrent Rust code, and finally\n+discuss some of the more exotic synchronization types in the standard\n+library.\n+\n+## A note about the libraries\n+\n+While Rust's type system provides the building blocks needed for safe\n+and efficient tasks, all of the task functionality itself is implemented\n+in the core and standard libraries, which are still under development\n+and do not always present a consistent interface.\n+\n+In particular, there are currently two independent modules that provide\n+a message passing interface to Rust code: `core::comm` and `core::pipes`.\n+`core::comm` is an older, less efficient system that is being phased out\n+in favor of `pipes`. At some point the existing `core::comm` API will\n+be romoved and the user-facing portions of `core::pipes` will be moved\n+to `core::comm`. In this tutorial we will discuss `pipes` and ignore\n+the `comm` API.\n+\n+For your reference, these are the standard modules involved in Rust\n+concurrency at the moment.\n+\n+* [`core::task`] - All code relating to tasks and task scheduling\n+* [`core::comm`] - The deprecated message passing API\n+* [`core::pipes`] - The new message passing infrastructure and API\n+* [`std::comm`] - Higher level messaging types based on `core::pipes`\n+* [`std::sync`] - More exotic synchronization tools, including locks \n+* [`std::arc`] - The ARC type, for safely sharing immutable data\n+* [`std::par`] - Some basic tools for implementing parallel algorithms\n+\n+[`core::task`]: core/task.html\n+[`core::comm`]: core/comm.html\n+[`core::pipes`]: core/pipes.html\n+[`std::comm`]: std/comm.html\n+[`std::sync`]: std/sync.html\n+[`std::arc`]: std/arc.html\n+[`std::par`]: std/par.html\n+\n+# Basics\n+\n+The programming interface for creating and managing tasks is contained\n+in the `task` module of the `core` library, making it available to all\n+Rust code by default. At it's simplest, creating a task is a matter of\n+calling the `spawn` function, passing a closure to run in the new\n+task.\n \n-Rust supports a system of lightweight tasks, similar to what is found\n-in Erlang or other actor systems. Rust tasks communicate via messages\n-and do not share data. However, it is possible to send data without\n-copying it by making use of [the exchange heap](#unique-boxes), which\n-allow the sending task to release ownership of a value, so that the\n-receiving task can keep on using it.\n-\n-> ***Note:*** As Rust evolves, we expect the task API to grow and\n-> change somewhat.  The tutorial documents the API as it exists today.\n+~~~~\n+# use io::println;\n+use task::spawn;\n \n-# Spawning a task\n+// Print something profound in a different task using a named function\n+fn print_message() { println(\"I am running in a different task!\"); }\n+spawn(print_message);\n \n-Spawning a task is done using the various spawn functions in the\n-module `task`.  Let's begin with the simplest one, `task::spawn()`:\n+// Print something more profound in a different task using a lambda expression\n+spawn( || println(\"I am also running in a different task!\") );\n \n+// The canonical way to spawn is using `do` notation\n+do spawn {\n+    println(\"I too am running in a different task!\");\n+}\n ~~~~\n-use task::spawn;\n-use io::println;\n \n-let some_value = 22;\n+In Rust, there is nothing special about creating tasks - the language\n+itself doesn't know what a 'task' is. Instead, Rust provides in the\n+type system all the tools necessary to implement safe concurrency,\n+_owned types_ in particular, and leaves the dirty work up to the\n+core library.\n+\n+The `spawn` function has a very simple type signature: `fn spawn(f:\n+~fn())`. Because it accepts only owned closures, and owned closures\n+contained only owned data, `spawn` can safely move the entire closure\n+and all its associated state into an entirely different task for\n+execution. Like any closure, the function passed to spawn may capture\n+an environment that it carries across tasks.\n+\n+~~~\n+# use io::println;\n+# use task::spawn;\n+# fn generate_task_number() -> int { 0 }\n+// Generate some state locally\n+let child_task_number = generate_task_number();\n \n do spawn {\n-    println(~\"This executes in the child task.\");\n-    println(fmt!(\"%d\", some_value));\n+   // Capture it in the remote task\n+   println(fmt!(\"I am child number %d\", child_task_number));\n }\n-~~~~\n+~~~\n \n-The argument to `task::spawn()` is a [unique\n-closure](#unique-closures) of type `fn~()`, meaning that it takes no\n-arguments and generates no return value. The effect of `task::spawn()`\n-is to fire up a child task that will execute the closure in parallel\n-with the creator.\n+By default tasks will be multiplexed across the available cores, running\n+in parallel, thus on a multicore machine, running the following code\n+should interleave the output in vaguely random order.\n \n-# Communication\n+~~~\n+# use io::print;\n+# use task::spawn;\n \n-Now that we have spawned a child task, it would be nice if we could\n-communicate with it. This is done using *pipes*. Pipes are simply a\n-pair of endpoints, with one for sending messages and another for\n-receiving messages. The easiest way to create a pipe is to use\n-`pipes::stream`.  Imagine we wish to perform two expensive\n-computations in parallel.  We might write something like:\n+for int::range(0, 20) |child_task_number| {\n+    do spawn {\n+       print(fmt!(\"I am child number %d\\n\", child_task_number));\n+    }\n+}\n+~~~\n+\n+## Communication\n+\n+Now that we have spawned a new task, it would be nice if we could\n+communicate with it. Recall that Rust does not have shared mutable\n+state, so one task may not manipulate variables owned by another task.\n+Instead we use *pipes*.\n+\n+Pipes are simply a pair of endpoints, with one for sending messages\n+and another for receiving messages. Pipes are low-level communication\n+building-blocks and so come in a variety of forms, appropriate for\n+different use cases, but there are just a few varieties that are most\n+commonly used, which we will cover presently.\n+\n+The simplest way to create a pipe is to use the `pipes::stream`\n+function to create a `(Chan, Port)` pair. In Rust parlance a 'channel'\n+is a sending endpoint of a pipe, and a 'port' is the recieving\n+endpoint. Consider the following example of performing two calculations\n+concurrently.\n \n ~~~~\n use task::spawn;\n use pipes::{stream, Port, Chan};\n \n-let (chan, port) = stream();\n+let (chan, port): (Chan<int>, Port<int>) = stream();\n \n do spawn {\n     let result = some_expensive_computation();\n@@ -55,43 +168,45 @@ do spawn {\n \n some_other_expensive_computation();\n let result = port.recv();\n-\n # fn some_expensive_computation() -> int { 42 }\n # fn some_other_expensive_computation() {}\n ~~~~\n \n-Let's walk through this code line-by-line.  The first line creates a\n-stream for sending and receiving integers:\n+Let's examine this example in detail. The `let` statement first creates a\n+stream for sending and receiving integers (recall that `let` can be\n+used for destructuring patterns, in this case separating a tuple into\n+its component parts).\n \n-~~~~ {.ignore}\n-# use pipes::stream;\n-let (chan, port) = stream();\n+~~~~\n+# use pipes::{stream, Chan, Port};\n+let (chan, port): (Chan<int>, Port<int>) = stream();\n ~~~~\n \n-This port is where we will receive the message from the child task\n-once it is complete.  The channel will be used by the child to send a\n-message to the port.  The next statement actually spawns the child:\n+The channel will be used by the child task to send data to the parent task,\n+which will wait to recieve the data on the port. The next statement\n+spawns the child task.\n \n ~~~~\n # use task::{spawn};\n-# use comm::{Port, Chan};\n+# use task::spawn;\n+# use pipes::{stream, Port, Chan};\n # fn some_expensive_computation() -> int { 42 }\n-# let port = Port();\n-# let chan = port.chan();\n+# let (chan, port) = stream();\n do spawn {\n     let result = some_expensive_computation();\n     chan.send(result);\n }\n ~~~~\n \n-This child will perform the expensive computation send the result\n-over the channel.  (Under the hood, `chan` was captured by the\n-closure that forms the body of the child task.  This capture is\n-allowed because channels are sendable.)\n+Notice that `chan` was transferred to the child task implicitly by\n+capturing it in the task closure. Both `Chan` and `Port` are sendable\n+types and may be captured into tasks or otherwise transferred between\n+them. In the example, the child task performs an expensive computation\n+then sends the result over the captured channel.\n \n-Finally, the parent continues by performing\n-some other expensive computation and then waiting for the child's result\n-to arrive on the port:\n+Finally, the parent continues by performing some other expensive\n+computation and then waiting for the child's result to arrive on the\n+port:\n \n ~~~~\n # use pipes::{stream, Port, Chan};\n@@ -102,7 +217,248 @@ some_other_expensive_computation();\n let result = port.recv();\n ~~~~\n \n-# Creating a task with a bi-directional communication path\n+The `Port` and `Chan` pair created by `stream` enable efficient\n+communication between a single sender and a single receiver, but\n+multiple senders cannot use a single `Chan`, nor can multiple\n+receivers use a single `Port`.  What if our example needed to perform\n+multiple computations across a number of tasks? The following cannot\n+be written:\n+\n+~~~ {.xfail-test}\n+# use task::{spawn};\n+# use pipes::{stream, Port, Chan};\n+# fn some_expensive_computation() -> int { 42 }\n+let (chan, port) = stream();\n+\n+do spawn {\n+    chan.send(some_expensive_computation());\n+}\n+\n+// ERROR! The previous spawn statement already owns the channel,\n+// so the compiler will not allow it to be captured again\n+do spawn {\n+    chan.send(some_expensive_computation());\n+}\n+~~~\n+\n+Instead we can use a `SharedChan`, a type that allows a single\n+`Chan` to be shared by multiple senders.\n+\n+~~~\n+# use task::spawn;\n+use pipes::{stream, SharedChan};\n+\n+let (chan, port) = stream();\n+let chan = SharedChan(move chan);\n+\n+for uint::range(0, 3) |init_val| {\n+    // Create a new channel handle to distribute to the child task\n+    let child_chan = chan.clone();\n+    do spawn {\n+        child_chan.send(some_expensive_computation(init_val));\n+    }\n+}\n+\n+let result = port.recv() + port.recv() + port.recv();\n+# fn some_expensive_computation(_i: uint) -> int { 42 }\n+~~~\n+\n+Here we transfer ownership of the channel into a new `SharedChan`\n+value.  Like `Chan`, `SharedChan` is a non-copyable, owned type\n+(sometimes also referred to as an 'affine' or 'linear' type). Unlike\n+`Chan` though, `SharedChan` may be duplicated with the `clone()`\n+method.  A cloned `SharedChan` produces a new handle to the same\n+channel, allowing multiple tasks to send data to a single port.\n+Between `spawn`, `stream` and `SharedChan` we have enough tools\n+to implement many useful concurrency patterns.\n+\n+Note that the above `SharedChan` example is somewhat contrived since\n+you could also simply use three `stream` pairs, but it serves to\n+illustrate the point. For reference, written with multiple streams it\n+might look like the example below.\n+\n+~~~\n+# use task::spawn;\n+# use pipes::{stream, Port, Chan};\n+\n+// Create a vector of ports, one for each child task\n+let ports = do vec::from_fn(3) |init_val| {\n+    let (chan, port) = stream();\n+    do spawn {\n+        chan.send(some_expensive_computation(init_val));\n+    }\n+    port\n+};\n+\n+// Wait on each port, accumulating the results\n+let result = ports.foldl(0, |accum, port| *accum + port.recv() );\n+# fn some_expensive_computation(_i: uint) -> int { 42 }\n+~~~\n+\n+# TODO\n+\n+# Handling task failure\n+\n+Rust has a built-in mechanism for raising exceptions, written `fail`\n+(or `fail ~\"reason\"`, or sometimes `assert expr`), and it causes the\n+task to unwind its stack, running destructors and freeing memory along\n+the way, and then exit itself. Unlike C++, exceptions in Rust are\n+unrecoverable within a single task - once a task fails there is no way\n+to \"catch\" the exception.\n+\n+All tasks are, by default, _linked_ to each other, meaning their fate\n+is interwined, and if one fails so do all of them.\n+\n+~~~\n+# use task::spawn;\n+# fn do_some_work() { loop { task::yield() } }\n+# do task::try {\n+// Create a child task that fails\n+do spawn { fail }\n+\n+// This will also fail because the task we spawned failed\n+do_some_work();\n+# };\n+~~~\n+\n+While it isn't possible for a task to recover from failure,\n+tasks may be notified when _other_ tasks fail. The simplest way\n+of handling task failure is with the `try` function, which is\n+similar to spawn, but immediately blocks waiting for the child\n+task to finish.\n+\n+~~~\n+# fn some_condition() -> bool { false }\n+# fn calculate_result() -> int { 0 }\n+let result: Result<int, ()> = do task::try {\n+    if some_condition() {\n+        calculate_result()\n+    } else {\n+        fail ~\"oops!\";\n+    }\n+};\n+assert result.is_err();\n+~~~\n+\n+Unlike `spawn`, the function spawned using `try` may return a value,\n+which `try` will dutifully propagate back to the caller in a [`Result`]\n+enum. If the child task terminates successfully, `try` will\n+return an `Ok` result; if the child task fails, `try` will return\n+an `Error` result.\n+\n+[`Result`]: core/result.html\n+\n+> ***Note:*** A failed task does not currently produce a useful error\n+> value (all error results from `try` are equal to `Err(())`). In the\n+> future it may be possible for tasks to intercept the value passed to\n+> `fail`.\n+\n+TODO: Need discussion of `future_result` in order to make failure\n+modes useful.\n+\n+But not all failure is created equal. In some cases you might need to\n+abort the entire program (perhaps you're writing an assert which, if\n+it trips, indicates an unrecoverable logic error); in other cases you\n+might want to contain the failure at a certain boundary (perhaps a\n+small piece of input from the outside world, which you happen to be\n+processing in parallel, is malformed and its processing task can't\n+proceed). Hence the need for different _linked failure modes_.\n+\n+## Failure modes\n+\n+By default, task failure is _bidirectionally linked_, which means if\n+either task dies, it kills the other one.\n+\n+~~~\n+# fn sleep_forever() { loop { task::yield() } }\n+# do task::try {\n+do task::spawn {\n+    do task::spawn {\n+        fail;  // All three tasks will die.\n+    }\n+    sleep_forever();  // Will get woken up by force, then fail\n+}\n+sleep_forever();  // Will get woken up by force, then fail\n+# };\n+~~~\n+\n+If you want parent tasks to kill their children, but not for a child\n+task's failure to kill the parent, you can call\n+`task::spawn_supervised` for _unidirectionally linked_ failure. The\n+function `task::try`, which we saw previously, uses `spawn_supervised`\n+internally, with additional logic to wait for the child task to finish\n+before returning. Hence:\n+\n+~~~\n+# use pipes::{stream, Chan, Port};\n+# use task::{spawn, try};\n+# fn sleep_forever() { loop { task::yield() } }\n+# do task::try {\n+let (sender, receiver): (Chan<int>, Port<int>) = stream();\n+do spawn {  // Bidirectionally linked\n+    // Wait for the supervised child task to exist.\n+    let message = receiver.recv();\n+    // Kill both it and the parent task.\n+    assert message != 42;\n+}\n+do try {  // Unidirectionally linked\n+    sender.send(42);\n+    sleep_forever();  // Will get woken up by force\n+}\n+// Flow never reaches here -- parent task was killed too.\n+# };\n+~~~\n+\n+Supervised failure is useful in any situation where one task manages\n+multiple fallible child tasks, and the parent task can recover\n+if any child files. On the other hand, if the _parent_ (supervisor) fails\n+then there is nothing the children can do to recover, so they should\n+also fail.\n+\n+Supervised task failure propagates across multiple generations even if\n+an intermediate generation has already exited:\n+\n+~~~\n+# fn sleep_forever() { loop { task::yield() } }\n+# fn wait_for_a_while() { for 1000.times { task::yield() } }\n+# do task::try::<int> {\n+do task::spawn_supervised {\n+    do task::spawn_supervised {\n+        sleep_forever();  // Will get woken up by force, then fail\n+    }\n+    // Intermediate task immediately exits\n+}\n+wait_for_a_while();\n+fail;  // Will kill grandchild even if child has already exited\n+# };\n+~~~\n+\n+Finally, tasks can be configured to not propagate failure to each\n+other at all, using `task::spawn_unlinked` for _isolated failure_.\n+\n+~~~\n+# fn random() -> int { 100 }\n+# fn sleep_for(i: int) { for i.times { task::yield() } }\n+# do task::try::<()> {\n+let (time1, time2) = (random(), random());\n+do task::spawn_unlinked {\n+    sleep_for(time2);  // Won't get forced awake\n+    fail;\n+}\n+sleep_for(time1);  // Won't get forced awake\n+fail;\n+// It will take MAX(time1,time2) for the program to finish.\n+# };\n+~~~\n+\n+\n+# Unfinished notes\n+\n+## Actor patterns\n+\n+## Linearity, option dancing, owned closures\n+\n+## Creating a task with a bi-directional communication path\n \n A very common thing to do is to spawn a child task where the parent\n and child both need to exchange messages with each other. The\n@@ -171,3 +527,4 @@ assert from_child.recv() == ~\"0\";\n \n The parent task first calls `DuplexStream` to create a pair of bidirectional endpoints. It then uses `task::spawn` to create the child task, which captures one end of the communication channel.  As a result, both parent\n and child can send and receive data to and from the other.\n+"}, {"sha": "7f60492e06ff36173702da40e80f920a6ebc2e21", "filename": "doc/tutorial.md", "status": "modified", "additions": 58, "deletions": 70, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -82,7 +82,7 @@ supported build environments that are most likely to work.\n \n > ***Note:*** Windows users should read the detailed\n > [getting started][wiki-start] notes on the wiki. Even when using\n-> the binary installer the windows build requires a MinGW installation,\n+> the binary installer the Windows build requires a MinGW installation,\n > the precise details of which are not discussed in this tutorial.\n \n To build from source you will also need the following prerequisite\n@@ -111,12 +111,9 @@ can be adjusted by passing a `--prefix` argument to\n `configure`. Various other options are also supported, pass `--help`\n for more information on them.\n \n-When complete, `make install` will place the following programs into\n-`/usr/local/bin`:\n-\n-  * `rustc`, the Rust compiler\n-  * `rustdoc`, the API-documentation tool\n-  * `cargo`, the Rust package manager\n+When complete, `make install` will place several programs into\n+`/usr/local/bin`: `rustc`, the Rust compiler; `rustdoc`, the\n+API-documentation tool, and `cargo`, the Rust package manager.\n \n [wiki-start]: https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust\n [tarball]: http://dl.rust-lang.org/dist/rust-0.4.tar.gz\n@@ -216,8 +213,8 @@ fn main() {\n }\n ~~~~\n \n-The `let` keyword, introduces a local variable. By default, variables\n-are immutable. `let mut` can be used to introduce a local variable\n+The `let` keyword introduces a local variable. Variables are immutable\n+by default, so `let mut` can be used to introduce a local variable\n that can be reassigned.\n \n ~~~~\n@@ -232,14 +229,17 @@ while count < 10 {\n \n Although Rust can almost always infer the types of local variables, it\n can help readability to specify a variable's type by following it with\n-a colon, then the type name. Local variables may shadow earlier\n-declarations, making the earlier variables inaccessible.\n+a colon, then the type name. \n \n ~~~~\n let my_favorite_value: float = 57.8;\n let my_favorite_value: int = my_favorite_value as int;\n ~~~~\n \n+Local variables may shadow earlier declarations, as in the previous\n+example in which `my_favorite_value` is first declared as a `float`\n+then a second `my_favorite_value` is declared as an int.\n+\n Rust identifiers follow the same rules as C; they start with an alphabetic\n character or an underscore, and after that may contain any sequence of\n alphabetic characters, numbers, or underscores. The preferred style is to\n@@ -371,7 +371,7 @@ more detail later on (the `T`s here stand for any other type):\n `[T * N]`                 Vector (like an array in other languages) with N elements\n `[mut T * N]`             Mutable vector with N elements\n `(T1, T2)`                Tuple type. Any arity above 1 is supported\n-`@T`, `~T`, `&T`          [Pointer types](#boxes-and-pointers)\n+`&T`, `~T`, `@T`          [Pointer types](#boxes-and-pointers)\n ------------------------- -----------------------------------------------\n \n Some types can only be manipulated by pointer, never directly. For instance,\n@@ -421,7 +421,7 @@ Rust will assume that an unsuffixed integer literal has type\n ~~~~\n let a = 1;       // a is an int\n let b = 10i;     // b is an int, due to the 'i' suffix\n-let c = 100u;    // c as a uint\n+let c = 100u;    // c is a uint\n let d = 1000i32; // d is an i32\n ~~~~\n \n@@ -619,7 +619,7 @@ literals and most enum variants.\n \n `while` produces a loop that runs as long as its given condition\n (which must have type `bool`) evaluates to true. Inside a loop, the\n-keyword `break` can be used to abort the loop, and `again` can be used\n+keyword `break` can be used to abort the loop, and `loop` can be used\n to abort the current iteration and continue with the next.\n \n ~~~~\n@@ -713,16 +713,16 @@ enum Shape {\n }\n ~~~~\n \n-A value of this type is either a Circle, in which case it contains a\n-point struct and a float, or a Rectangle, in which case it contains\n-two point records. The run-time representation of such a value\n+A value of this type is either a `Circle`, in which case it contains a\n+`Point` struct and a float, or a `Rectangle`, in which case it contains\n+two `Point` structs. The run-time representation of such a value\n includes an identifier of the actual form that it holds, much like the\n 'tagged union' pattern in C, but with better ergonomics.\n \n-The above declaration will define a type `shape` that can be used to\n-refer to such shapes, and two functions, `circle` and `rectangle`,\n+The above declaration will define a type `Shape` that can be used to\n+refer to such shapes, and two functions, `Circle` and `Rectangle`,\n which can be used to construct values of the type (taking arguments of\n-the specified types). So `circle({x: 0f, y: 0f}, 10f)` is the way to\n+the specified types). So `Circle(Point {x: 0f, y: 0f}, 10f)` is the way to\n create a new circle.\n \n Enum variants need not have type parameters. This, for example, is\n@@ -820,7 +820,7 @@ fn point_from_direction(dir: Direction) -> Point {\n \n ## Tuples\n \n-Tuples in Rust behave exactly like records, except that their fields\n+Tuples in Rust behave exactly like structs, except that their fields\n do not have names (and can thus not be accessed with dot notation).\n Tuples can have any arity except for 0 or 1 (though you may consider\n nil, `()`, as the empty tuple if you like).\n@@ -957,7 +957,7 @@ Rust has three competing goals that inform its view of memory:\n Most languages that offer strong memory safety guarantees rely upon a\n garbage-collected heap to manage all of the objects. This approach is\n straightforward both in concept and in implementation, but has\n-significant costs. Languages that take this approach tend to\n+significant costs. Languages that follow this path tend to\n aggressively pursue ways to ameliorate allocation costs (think the\n Java Virtual Machine). Rust supports this strategy with _managed\n boxes_: memory allocated on the heap whose lifetime is managed\n@@ -982,7 +982,7 @@ tasks. Experience in other languages has proven that isolating each\n task's heap from the others is a reliable strategy and one that is\n easy for programmers to reason about. Heap isolation has the\n additional benefit that garbage collection must only be done\n-per-heap. Rust never \"stops the world\" to garbage-collect memory.\n+per-heap. Rust never \"stops the world\" to reclaim memory.\n \n Complete isolation of heaps between tasks implies that any data\n transferred between tasks must be copied. While this is a fine and\n@@ -995,27 +995,18 @@ _owned boxes_. All tasks may allocate objects on the exchange heap,\n then transfer ownership of those objects to other tasks, avoiding\n expensive copies.\n \n-## What to be aware of\n-\n-Rust has three \"realms\" in which objects can be allocated: the stack,\n-the local heap, and the exchange heap. These realms have corresponding\n-pointer types: the borrowed pointer (`&T`), the managed box (`@T`),\n-and the owned box (`~T`). These three sigils will appear\n-repeatedly as we explore the language. Learning the appropriate role\n-of each is key to using Rust effectively.\n-\n # Boxes and pointers\n \n-In contrast to a lot of modern languages, aggregate types like records\n+In contrast to a lot of modern languages, aggregate types like structs\n and enums are _not_ represented as pointers to allocated memory in\n Rust. They are, as in C and C++, represented directly. This means that\n-if you `let x = {x: 1f, y: 1f};`, you are creating a record on the\n-stack. If you then copy it into a data structure, the whole record is\n+if you `let x = Point {x: 1f, y: 1f};`, you are creating a struct on the\n+stack. If you then copy it into a data structure, the whole struct is\n copied, not just a pointer.\n \n-For small records like `point`, this is usually more efficient than\n-allocating memory and going through a pointer. But for big records, or\n-records with mutable fields, it can be useful to have a single copy on\n+For small structs like `Point`, this is usually more efficient than\n+allocating memory and going through a pointer. But for big structs, or\n+those with mutable fields, it can be useful to have a single copy on\n the heap, and refer to that through a pointer.\n \n Rust supports several types of pointers. The safe pointer types are\n@@ -1191,8 +1182,8 @@ compute_distance(shared_box, unique_box);\n ~~~\n \n Here the `&` operator is used to take the address of the variable\n-`on_the_stack`; this is because `on_the_stack` has the type `point`\n-(that is, a record value) and we have to take its address to get a\n+`on_the_stack`; this is because `on_the_stack` has the type `Point`\n+(that is, a struct value) and we have to take its address to get a\n value. We also call this _borrowing_ the local variable\n `on_the_stack`, because we are created an alias: that is, another\n route to the same data.\n@@ -1517,7 +1508,7 @@ fn each(v: &[int], op: fn(v: &int)) {\n The reason we pass in a *pointer* to an integer rather than the\n integer itself is that this is how the actual `each()` function for\n vectors works.  Using a pointer means that the function can be used\n-for vectors of any type, even large records that would be impractical\n+for vectors of any type, even large structs that would be impractical\n to copy out of the vector on each iteration.  As a caller, if we use a\n closure to provide the final operator argument, we can write it in a\n way that has a pleasant, block-like structure.\n@@ -1576,7 +1567,7 @@ Empty argument lists can be omitted from `do` expressions.\n \n Most iteration in Rust is done with `for` loops. Like `do`,\n `for` is a nice syntax for doing control flow with closures.\n-Additionally, within a `for` loop, `break`, `again`, and `return`\n+Additionally, within a `for` loop, `break`, `loop`, and `return`\n work just as they do with `while` and `loop`.\n \n Consider again our `each` function, this time improved to\n@@ -1611,7 +1602,7 @@ With `for`, functions like `each` can be treated more\n like builtin looping structures. When calling `each`\n in a `for` loop, instead of returning `false` to break\n out of the loop, you just write `break`. To skip ahead\n-to the next iteration, write `again`.\n+to the next iteration, write `loop`.\n \n ~~~~\n # use each = vec::each;\n@@ -1644,14 +1635,15 @@ fn contains(v: &[int], elt: int) -> bool {\n # Generics\n \n Throughout this tutorial, we've been defining functions that act only on\n-single data types. With type parameters we can also define functions that\n-may be invoked on multiple types.\n+specific data types. With type parameters we can also define functions whose\n+arguments represent generic types, and which can be invoked with a variety\n+of types. Consider a generic `map` function.\n \n ~~~~\n fn map<T, U>(vector: &[T], function: fn(v: &T) -> U) -> ~[U] {\n     let mut accumulator = ~[];\n     for vec::each(vector) |element| {\n-        vec::push(accumulator, function(element));\n+        accumulator.push(function(element));\n     }\n     return accumulator;\n }\n@@ -1665,7 +1657,7 @@ each other.\n Inside a generic function, the names of the type parameters\n (capitalized by convention) stand for opaque types. You can't look\n inside them, but you can pass them around.  Note that instances of\n-generic types are almost always passed by pointer.  For example, the\n+generic types are often passed by pointer.  For example, the\n parameter `function()` is supplied with a pointer to a value of type\n `T` and not a value of type `T` itself.  This ensures that the\n function works with the broadest set of types possible, since some\n@@ -1691,11 +1683,11 @@ These declarations produce valid types like `Set<int>`, `Stack<int>`\n and `Maybe<int>`.\n \n Generic functions in Rust are compiled to very efficient runtime code\n-through a process called _monomorphisation_. This big word just means\n-that, for each generic function you call, the compiler generates a\n-specialized version that is optimized specifically for the argument\n-types. In this respect Rust's generics have similar performance\n-characteristics to C++ templates.\n+through a process called _monomorphisation_. This is a fancy way of\n+saying that, for each generic function you call, the compiler\n+generates a specialized version that is optimized specifically for the\n+argument types. In this respect Rust's generics have similar\n+performance characteristics to C++ templates.\n \n ## Traits\n \n@@ -1760,23 +1752,23 @@ types by the compiler, and may not be overridden:\n \n ## Declaring and implementing traits\n \n-A trait consists of a set of methods, or may be empty, as is the case\n-with `Copy`, `Send`, and `Const`. A method is a function that\n-can be applied to a `self` value and a number of arguments, using the\n-dot notation: `self.foo(arg1, arg2)`.\n-\n-For example, we could declare the trait `Printable` for things that\n-can be printed to the console, with a single method:\n+A trait consists of a set of methods, without bodies, or may be empty,\n+as is the case with `Copy`, `Send`, and `Const`. For example, we could\n+declare the trait `Printable` for things that can be printed to the\n+console, with a single method:\n \n ~~~~\n trait Printable {\n     fn print();\n }\n ~~~~\n \n-To actually implement a trait for a given type, the `impl` form is\n-used. This defines implementations of `Printable` for the `int` and\n-`~str` types.\n+Traits may be implemented for specific types with [impls]. An impl\n+that implements a trait includes the name of the trait at the start of \n+the definition, as in the following impls of `Printable` for `int`\n+and `~str`.\n+\n+[impls]: #functions-and-methods\n \n ~~~~\n # trait Printable { fn print(); }\n@@ -1792,14 +1784,10 @@ impl ~str: Printable {\n # (~\"foo\").print();\n ~~~~\n \n-Given these, we may call `1.print()` to print `\"1\"`, or\n-`(~\"foo\").print()` to print `\"foo\"` again, as with . This is basically a form of\n-static overloading\u2014when the Rust compiler sees the `print` method\n-call, it looks for an implementation that matches the type with a\n-method that matches the name, and simply calls that.\n-\n-Traits may themselves contain type parameters. A trait for\n-generalized sequence types might look like the following:\n+Methods defined in an implementation of a trait may be called just as\n+any other method, using dot notation, as in `1.print()`. Traits may\n+themselves contain type parameters. A trait for generalized sequence\n+types might look like the following:\n \n ~~~~\n trait Seq<T> {"}, {"sha": "f5888015944a5a3d0a211fb2663a0e79364027e8", "filename": "man/rustc.1", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/man%2Frustc.1", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/man%2Frustc.1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/man%2Frustc.1?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -75,10 +75,7 @@ Write intermediate files (.bc, .opt.bc, .o)\n in addition to normal output\n .TP\n \\fB\\-\\-static\\fR\n-Use or produce static libraries or binaries\n-.TP\n-\\fB\\-\\-stats\\fR\n-Print compilation statistics\n+Use or produce static libraries or binaries (experimental)\n .TP\n \\fB\\-\\-sysroot\\fR <path>\n Override the system root\n@@ -87,10 +84,9 @@ Override the system root\n Build a test harness\n .TP\n \\fB\\-\\-target\\fR <triple>\n-Target cpu\\-manufacturer\\-kernel[\\-os] to compile for\n-(default: host triple)\n-(see http://sources.redhat.com/autobook/autobook/\n-autobook_17.html for detail)\n+Target cpu\\-manufacturer\\-kernel[\\-os] to compile for (default: host triple)\n+(see <\\fBhttp://sources.redhat.com/autobook/autobook/autobook_17.html\\fR> for\n+detail)\n .TP\n \\fB\\-W\\fR <foo>\n enable warning <foo>\n@@ -121,7 +117,7 @@ To build either with a crate (.rc) file:\n     $ rustc hello.rc\n \n .SH \"BUGS\"\n-See \\fBhttps://github.com/mozilla/rust/issues\\fR for a list of known bugs.\n+See <\\fBhttps://github.com/mozilla/rust/issues\\fR> for a list of known bugs.\n \n .SH \"AUTHOR\"\n See \\fBAUTHORS.txt\\fR in the rust source distribution. Graydon Hoare"}, {"sha": "17ddacfd7eb778d3d120a3c56acae93ca0d6ce66", "filename": "src/cargo/cargo.rc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Fcargo%2Fcargo.rc", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Fcargo%2Fcargo.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rc?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -24,6 +24,8 @@\n #[allow(vecs_implicitly_copyable,\n         non_implicitly_copyable_typarams)];\n #[allow(non_camel_case_types)];\n+#[allow(deprecated_mode)];\n+#[allow(deprecated_pattern)];\n \n extern mod core(vers = \"0.4\");\n extern mod std(vers = \"0.4\");"}, {"sha": "211b048de7a3b481d095759eb12fd79f8ec8ed0d", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 138, "deletions": 146, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -11,13 +11,14 @@ use syntax::diagnostic;\n \n use result::{Ok, Err};\n use io::WriterUtil;\n+use send_map::linear::LinearMap;\n use std::{map, json, tempfile, term, sort, getopts};\n use map::HashMap;\n use to_str::to_str;\n use getopts::{optflag, optopt, opt_present};\n use dvec::DVec;\n \n-type package = {\n+struct Package {\n     name: ~str,\n     uuid: ~str,\n     url: ~str,\n@@ -26,10 +27,10 @@ type package = {\n     reference: Option<~str>,\n     tags: ~[~str],\n     versions: ~[(~str, ~str)]\n-};\n+}\n \n-impl package : cmp::Ord {\n-    pure fn lt(other: &package) -> bool {\n+impl Package : cmp::Ord {\n+    pure fn lt(other: &Package) -> bool {\n         if self.name.lt(&(*other).name) { return true; }\n         if (*other).name.lt(&self.name) { return false; }\n         if self.uuid.lt(&(*other).uuid) { return true; }\n@@ -45,65 +46,58 @@ impl package : cmp::Ord {\n         if self.versions.lt(&(*other).versions) { return true; }\n         return false;\n     }\n-    pure fn le(other: &package) -> bool { !(*other).lt(&self) }\n-    pure fn ge(other: &package) -> bool { !self.lt(other)     }\n-    pure fn gt(other: &package) -> bool { (*other).lt(&self)  }\n+    pure fn le(other: &Package) -> bool { !(*other).lt(&self) }\n+    pure fn ge(other: &Package) -> bool { !self.lt(other)     }\n+    pure fn gt(other: &Package) -> bool { (*other).lt(&self)  }\n }\n \n-type local_package = {\n-    name: ~str,\n-    metaname: ~str,\n-    version: ~str,\n-    files: ~[~str]\n-};\n-\n-type source = @{\n+struct Source {\n     name: ~str,\n     mut url: ~str,\n     mut method: ~str,\n     mut key: Option<~str>,\n     mut keyfp: Option<~str>,\n-    packages: DVec<package>\n-};\n+    packages: DVec<Package>\n+}\n \n-type cargo = {\n+struct Cargo {\n     pgp: bool,\n     root: Path,\n     installdir: Path,\n     bindir: Path,\n     libdir: Path,\n     workdir: Path,\n     sourcedir: Path,\n-    sources: map::HashMap<~str, source>,\n+    sources: map::HashMap<~str, @Source>,\n     mut current_install: ~str,\n     dep_cache: map::HashMap<~str, bool>,\n-    opts: options\n-};\n+    opts: Options\n+}\n \n-type crate = {\n+struct Crate {\n     name: ~str,\n     vers: ~str,\n     uuid: ~str,\n     desc: Option<~str>,\n     sigs: Option<~str>,\n     crate_type: Option<~str>,\n     deps: ~[~str]\n-};\n+}\n \n-type options = {\n+struct Options {\n     test: bool,\n-    mode: mode,\n+    mode: Mode,\n     free: ~[~str],\n     help: bool,\n-};\n+}\n \n-enum mode { system_mode, user_mode, local_mode }\n+enum Mode { SystemMode, UserMode, LocalMode }\n \n-impl mode : cmp::Eq {\n-    pure fn eq(other: &mode) -> bool {\n+impl Mode : cmp::Eq {\n+    pure fn eq(other: &Mode) -> bool {\n         (self as uint) == ((*other) as uint)\n     }\n-    pure fn ne(other: &mode) -> bool { !self.eq(other) }\n+    pure fn ne(other: &Mode) -> bool { !self.eq(other) }\n }\n \n fn opts() -> ~[getopts::Opt] {\n@@ -150,7 +144,7 @@ fn is_uuid(id: ~str) -> bool {\n     if vec::len(parts) == 5u {\n         let mut correct = 0u;\n         for vec::eachi(parts) |i, part| {\n-            fn is_hex_digit(ch: char) -> bool {\n+            fn is_hex_digit(+ch: char) -> bool {\n                 ('0' <= ch && ch <= '9') ||\n                 ('a' <= ch && ch <= 'f') ||\n                 ('A' <= ch && ch <= 'F')\n@@ -270,7 +264,7 @@ fn load_link(mis: ~[@ast::meta_item]) -> (Option<~str>,\n     (name, vers, uuid)\n }\n \n-fn load_crate(filename: &Path) -> Option<crate> {\n+fn load_crate(filename: &Path) -> Option<Crate> {\n     let sess = parse::new_parse_sess(None);\n     let c = parse::parse_crate_from_crate_file(filename, ~[], sess);\n \n@@ -351,7 +345,7 @@ fn load_crate(filename: &Path) -> Option<crate> {\n \n                 match *ps.interner.get(attr_name) {\n                     ~\"std\" | ~\"core\" => (),\n-                    _ => vec::push(e.deps, query)\n+                    _ => e.deps.push(query)\n                 }\n             }\n             _ => ()\n@@ -375,7 +369,7 @@ fn load_crate(filename: &Path) -> Option<crate> {\n \n     match (name, vers, uuid) {\n         (Some(name0), Some(vers0), Some(uuid0)) => {\n-            Some({\n+            Some(Crate {\n                 name: name0,\n                 vers: vers0,\n                 uuid: uuid0,\n@@ -407,8 +401,8 @@ fn need_dir(s: &Path) {\n     }\n }\n \n-fn valid_pkg_name(s: ~str) -> bool {\n-    fn is_valid_digit(c: char) -> bool {\n+fn valid_pkg_name(s: &str) -> bool {\n+    fn is_valid_digit(+c: char) -> bool {\n         ('0' <= c && c <= '9') ||\n         ('a' <= c && c <= 'z') ||\n         ('A' <= c && c <= 'Z') ||\n@@ -419,33 +413,33 @@ fn valid_pkg_name(s: ~str) -> bool {\n     s.all(is_valid_digit)\n }\n \n-fn parse_source(name: ~str, j: json::Json) -> source {\n+fn parse_source(name: ~str, j: &json::Json) -> @Source {\n     if !valid_pkg_name(name) {\n         fail fmt!(\"'%s' is an invalid source name\", name);\n     }\n \n-    match j {\n-        json::Dict(j) => {\n-            let mut url = match j.find(~\"url\") {\n-                Some(json::String(u)) => *u,\n+    match *j {\n+        json::Object(j) => {\n+            let mut url = match j.find(&~\"url\") {\n+                Some(json::String(u)) => u,\n                 _ => fail ~\"needed 'url' field in source\"\n             };\n-            let method = match j.find(~\"method\") {\n-                Some(json::String(u)) => *u,\n+            let method = match j.find(&~\"method\") {\n+                Some(json::String(u)) => u,\n                 _ => assume_source_method(url)\n             };\n-            let key = match j.find(~\"key\") {\n-                Some(json::String(u)) => Some(*u),\n+            let key = match j.find(&~\"key\") {\n+                Some(json::String(u)) => Some(u),\n                 _ => None\n             };\n-            let keyfp = match j.find(~\"keyfp\") {\n-                Some(json::String(u)) => Some(*u),\n+            let keyfp = match j.find(&~\"keyfp\") {\n+                Some(json::String(u)) => Some(u),\n                 _ => None\n             };\n             if method == ~\"file\" {\n                 url = os::make_absolute(&Path(url)).to_str();\n             }\n-            return @{\n+            return @Source {\n                 name: name,\n                 mut url: url,\n                 mut method: method,\n@@ -457,100 +451,100 @@ fn parse_source(name: ~str, j: json::Json) -> source {\n     };\n }\n \n-fn try_parse_sources(filename: &Path, sources: map::HashMap<~str, source>) {\n+fn try_parse_sources(filename: &Path, sources: map::HashMap<~str, @Source>) {\n     if !os::path_exists(filename)  { return; }\n     let c = io::read_whole_file_str(filename);\n-    match json::from_str(result::get(c)) {\n-        Ok(json::Dict(j)) => {\n-          for j.each |k, v| {\n-                sources.insert(k, parse_source(k, v));\n-                debug!(\"source: %s\", k);\n+    match json::from_str(c.get()) {\n+        Ok(json::Object(j)) => {\n+            for j.each |k, v| {\n+                sources.insert(copy *k, parse_source(*k, v));\n+                debug!(\"source: %s\", *k);\n             }\n         }\n         Ok(_) => fail ~\"malformed sources.json\",\n         Err(e) => fail fmt!(\"%s:%s\", filename.to_str(), e.to_str())\n     }\n }\n \n-fn load_one_source_package(src: source, p: map::HashMap<~str, json::Json>) {\n-    let name = match p.find(~\"name\") {\n+fn load_one_source_package(src: @Source, p: &json::Object) {\n+    let name = match p.find(&~\"name\") {\n         Some(json::String(n)) => {\n-            if !valid_pkg_name(*n) {\n+            if !valid_pkg_name(n) {\n                 warn(~\"malformed source json: \"\n-                     + src.name + ~\", '\" + *n + ~\"'\"+\n+                     + src.name + ~\", '\" + n + ~\"'\"+\n                      ~\" is an invalid name (alphanumeric, underscores and\" +\n                      ~\" dashes only)\");\n                 return;\n             }\n-            *n\n+            n\n         }\n         _ => {\n             warn(~\"malformed source json: \" + src.name + ~\" (missing name)\");\n             return;\n         }\n     };\n \n-    let uuid = match p.find(~\"uuid\") {\n+    let uuid = match p.find(&~\"uuid\") {\n         Some(json::String(n)) => {\n-            if !is_uuid(*n) {\n+            if !is_uuid(n) {\n                 warn(~\"malformed source json: \"\n-                     + src.name + ~\", '\" + *n + ~\"'\"+\n+                     + src.name + ~\", '\" + n + ~\"'\"+\n                      ~\" is an invalid uuid\");\n                 return;\n             }\n-            *n\n+            n\n         }\n         _ => {\n             warn(~\"malformed source json: \" + src.name + ~\" (missing uuid)\");\n             return;\n         }\n     };\n \n-    let url = match p.find(~\"url\") {\n-        Some(json::String(n)) => *n,\n+    let url = match p.find(&~\"url\") {\n+        Some(json::String(n)) => n,\n         _ => {\n             warn(~\"malformed source json: \" + src.name + ~\" (missing url)\");\n             return;\n         }\n     };\n \n-    let method = match p.find(~\"method\") {\n-        Some(json::String(n)) => *n,\n+    let method = match p.find(&~\"method\") {\n+        Some(json::String(n)) => n,\n         _ => {\n             warn(~\"malformed source json: \"\n                  + src.name + ~\" (missing method)\");\n             return;\n         }\n     };\n \n-    let reference = match p.find(~\"ref\") {\n-        Some(json::String(n)) => Some(*n),\n+    let reference = match p.find(&~\"ref\") {\n+        Some(json::String(n)) => Some(n),\n         _ => None\n     };\n \n     let mut tags = ~[];\n-    match p.find(~\"tags\") {\n+    match p.find(&~\"tags\") {\n         Some(json::List(js)) => {\n-          for (*js).each |j| {\n+          for js.each |j| {\n                 match *j {\n-                    json::String(j) => vec::grow(tags, 1u, *j),\n+                    json::String(ref j) => tags.grow(1u, j),\n                     _ => ()\n                 }\n             }\n         }\n         _ => ()\n     }\n \n-    let description = match p.find(~\"description\") {\n-        Some(json::String(n)) => *n,\n+    let description = match p.find(&~\"description\") {\n+        Some(json::String(n)) => n,\n         _ => {\n             warn(~\"malformed source json: \" + src.name\n                  + ~\" (missing description)\");\n             return;\n         }\n     };\n \n-    let newpkg = {\n+    let newpkg = Package {\n         name: name,\n         uuid: uuid,\n         url: url,\n@@ -574,14 +568,14 @@ fn load_one_source_package(src: source, p: map::HashMap<~str, json::Json>) {\n     log(debug, ~\"  loaded package: \" + src.name + ~\"/\" + name);\n }\n \n-fn load_source_info(c: &cargo, src: source) {\n+fn load_source_info(c: &Cargo, src: @Source) {\n     let dir = c.sourcedir.push(src.name);\n     let srcfile = dir.push(\"source.json\");\n     if !os::path_exists(&srcfile) { return; }\n     let srcstr = io::read_whole_file_str(&srcfile);\n-    match json::from_str(result::get(srcstr)) {\n-        Ok(json::Dict(s)) => {\n-            let o = parse_source(src.name, json::Dict(s));\n+    match json::from_str(srcstr.get()) {\n+        Ok(ref json @ json::Object(_)) => {\n+            let o = parse_source(src.name, json);\n \n             src.key = o.key;\n             src.keyfp = o.keyfp;\n@@ -595,17 +589,17 @@ fn load_source_info(c: &cargo, src: source) {\n         }\n     };\n }\n-fn load_source_packages(c: &cargo, src: source) {\n+fn load_source_packages(c: &Cargo, src: @Source) {\n     log(debug, ~\"loading source: \" + src.name);\n     let dir = c.sourcedir.push(src.name);\n     let pkgfile = dir.push(\"packages.json\");\n     if !os::path_exists(&pkgfile) { return; }\n     let pkgstr = io::read_whole_file_str(&pkgfile);\n-    match json::from_str(result::get(pkgstr)) {\n+    match json::from_str(pkgstr.get()) {\n         Ok(json::List(js)) => {\n-          for (*js).each |j| {\n+          for js.each |j| {\n                 match *j {\n-                    json::Dict(p) => {\n+                    json::Object(p) => {\n                         load_one_source_package(src, p);\n                     }\n                     _ => {\n@@ -625,7 +619,7 @@ fn load_source_packages(c: &cargo, src: source) {\n     };\n }\n \n-fn build_cargo_options(argv: ~[~str]) -> options {\n+fn build_cargo_options(argv: ~[~str]) -> Options {\n     let matches = match getopts::getopts(argv, opts()) {\n         result::Ok(m) => m,\n         result::Err(f) => {\n@@ -649,34 +643,34 @@ fn build_cargo_options(argv: ~[~str]) -> options {\n     }\n \n     let mode =\n-        if (!is_install && !is_uninstall) || g { user_mode }\n-        else if G { system_mode }\n-        else { local_mode };\n+        if (!is_install && !is_uninstall) || g { UserMode }\n+        else if G { SystemMode }\n+        else { LocalMode };\n \n-    {test: test, mode: mode, free: matches.free, help: help}\n+    Options {test: test, mode: mode, free: matches.free, help: help}\n }\n \n-fn configure(opts: options) -> cargo {\n+fn configure(opts: Options) -> Cargo {\n     let home = match get_cargo_root() {\n         Ok(home) => home,\n-        Err(_err) => result::get(get_cargo_sysroot())\n+        Err(_err) => get_cargo_sysroot().get()\n     };\n \n     let get_cargo_dir = match opts.mode {\n-        system_mode => get_cargo_sysroot,\n-        user_mode => get_cargo_root,\n-        local_mode => get_cargo_root_nearest\n+        SystemMode => get_cargo_sysroot,\n+        UserMode => get_cargo_root,\n+        LocalMode => get_cargo_root_nearest\n     };\n \n-    let p = result::get(get_cargo_dir());\n+    let p = get_cargo_dir().get();\n \n-    let sources = map::HashMap();\n+    let sources = HashMap();\n     try_parse_sources(&home.push(\"sources.json\"), sources);\n     try_parse_sources(&home.push(\"local-sources.json\"), sources);\n \n-    let dep_cache = map::HashMap();\n+    let dep_cache = HashMap();\n \n-    let mut c = {\n+    let mut c = Cargo {\n         pgp: pgp::supported(),\n         root: home,\n         installdir: p,\n@@ -714,10 +708,10 @@ fn configure(opts: options) -> cargo {\n     c\n }\n \n-fn for_each_package(c: &cargo, b: fn(source, package)) {\n+fn for_each_package(c: &Cargo, b: fn(s: @Source, p: &Package)) {\n     for c.sources.each_value |v| {\n         for v.packages.each |p| {\n-            b(v, *p);\n+            b(v, p);\n         }\n     }\n }\n@@ -748,7 +742,7 @@ fn run_in_buildpath(what: &str, path: &Path, subdir: &Path, cf: &Path,\n     Some(buildpath)\n }\n \n-fn test_one_crate(_c: &cargo, path: &Path, cf: &Path) {\n+fn test_one_crate(_c: &Cargo, path: &Path, cf: &Path) {\n     let buildpath = match run_in_buildpath(~\"testing\", path,\n                                            &Path(\"test\"),\n                                            cf,\n@@ -759,7 +753,7 @@ fn test_one_crate(_c: &cargo, path: &Path, cf: &Path) {\n   run_programs(&buildpath);\n }\n \n-fn install_one_crate(c: &cargo, path: &Path, cf: &Path) {\n+fn install_one_crate(c: &Cargo, path: &Path, cf: &Path) {\n     let buildpath = match run_in_buildpath(~\"installing\", path,\n                                            &Path(\"build\"),\n                                            cf, ~[]) {\n@@ -776,7 +770,7 @@ fn install_one_crate(c: &cargo, path: &Path, cf: &Path) {\n                                ~\"lib\")) {\n             debug!(\"  bin: %s\", ct.to_str());\n             install_to_dir(*ct, &c.bindir);\n-            if c.opts.mode == system_mode {\n+            if c.opts.mode == SystemMode {\n                 // FIXME (#2662): Put this file in PATH / symlink it so it can\n                 // be used as a generic executable\n                 // `cargo install -G rustray` and `rustray file.obj`\n@@ -800,14 +794,14 @@ fn rustc_sysroot() -> ~str {\n     }\n }\n \n-fn install_source(c: &cargo, path: &Path) {\n+fn install_source(c: &Cargo, path: &Path) {\n     debug!(\"source: %s\", path.to_str());\n     os::change_dir(path);\n \n     let mut cratefiles = ~[];\n     for os::walk_dir(&Path(\".\")) |p| {\n         if p.filetype() == Some(~\".rc\") {\n-            vec::push(cratefiles, *p);\n+            cratefiles.push(*p);\n         }\n     }\n \n@@ -839,7 +833,7 @@ fn install_source(c: &cargo, path: &Path) {\n     }\n }\n \n-fn install_git(c: &cargo, wd: &Path, url: ~str, reference: Option<~str>) {\n+fn install_git(c: &Cargo, wd: &Path, url: ~str, reference: Option<~str>) {\n     run::program_output(~\"git\", ~[~\"clone\", url, wd.to_str()]);\n     if reference.is_some() {\n         let r = reference.get();\n@@ -850,7 +844,7 @@ fn install_git(c: &cargo, wd: &Path, url: ~str, reference: Option<~str>) {\n     install_source(c, wd);\n }\n \n-fn install_curl(c: &cargo, wd: &Path, url: ~str) {\n+fn install_curl(c: &Cargo, wd: &Path, url: ~str) {\n     let tarpath = wd.push(\"pkg.tar\");\n     let p = run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\", ~\"-o\",\n                                          tarpath.to_str(), url]);\n@@ -863,14 +857,14 @@ fn install_curl(c: &cargo, wd: &Path, url: ~str) {\n     install_source(c, wd);\n }\n \n-fn install_file(c: &cargo, wd: &Path, path: &Path) {\n+fn install_file(c: &Cargo, wd: &Path, path: &Path) {\n     run::program_output(~\"tar\", ~[~\"-x\", ~\"--strip-components=1\",\n                                   ~\"-C\", wd.to_str(),\n                                   ~\"-f\", path.to_str()]);\n     install_source(c, wd);\n }\n \n-fn install_package(c: &cargo, src: ~str, wd: &Path, pkg: package) {\n+fn install_package(c: &Cargo, src: ~str, wd: &Path, pkg: Package) {\n     let url = copy pkg.url;\n     let method = match pkg.method {\n         ~\"git\" => ~\"git\",\n@@ -883,12 +877,12 @@ fn install_package(c: &cargo, src: ~str, wd: &Path, pkg: package) {\n     match method {\n         ~\"git\" => install_git(c, wd, url, copy pkg.reference),\n         ~\"file\" => install_file(c, wd, &Path(url)),\n-        ~\"curl\" => install_curl(c, wd, copy url),\n+        ~\"curl\" => install_curl(c, wd, url),\n         _ => ()\n     }\n }\n \n-fn cargo_suggestion(c: &cargo, fallback: fn())\n+fn cargo_suggestion(c: &Cargo, fallback: fn())\n {\n     if c.sources.size() == 0u {\n         error(~\"no sources defined - you may wish to run \" +\n@@ -898,11 +892,11 @@ fn cargo_suggestion(c: &cargo, fallback: fn())\n     fallback();\n }\n \n-fn install_uuid(c: &cargo, wd: &Path, uuid: ~str) {\n+fn install_uuid(c: &Cargo, wd: &Path, uuid: ~str) {\n     let mut ps = ~[];\n     for_each_package(c, |s, p| {\n         if p.uuid == uuid {\n-            vec::grow(ps, 1u, (s.name, copy p));\n+            vec::push(&mut ps, (s.name, copy *p));\n         }\n     });\n     if vec::len(ps) == 1u {\n@@ -922,11 +916,11 @@ fn install_uuid(c: &cargo, wd: &Path, uuid: ~str) {\n     }\n }\n \n-fn install_named(c: &cargo, wd: &Path, name: ~str) {\n+fn install_named(c: &Cargo, wd: &Path, name: ~str) {\n     let mut ps = ~[];\n     for_each_package(c, |s, p| {\n         if p.name == name {\n-            vec::grow(ps, 1u, (s.name, copy p));\n+            vec::push(&mut ps, (s.name, copy *p));\n         }\n     });\n     if vec::len(ps) == 1u {\n@@ -946,7 +940,7 @@ fn install_named(c: &cargo, wd: &Path, name: ~str) {\n     }\n }\n \n-fn install_uuid_specific(c: &cargo, wd: &Path, src: ~str, uuid: ~str) {\n+fn install_uuid_specific(c: &Cargo, wd: &Path, src: ~str, uuid: ~str) {\n     match c.sources.find(src) {\n         Some(s) => {\n             for s.packages.each |p| {\n@@ -961,7 +955,7 @@ fn install_uuid_specific(c: &cargo, wd: &Path, src: ~str, uuid: ~str) {\n     error(~\"can't find package: \" + src + ~\"/\" + uuid);\n }\n \n-fn install_named_specific(c: &cargo, wd: &Path, src: ~str, name: ~str) {\n+fn install_named_specific(c: &Cargo, wd: &Path, src: ~str, name: ~str) {\n     match c.sources.find(src) {\n         Some(s) => {\n             for s.packages.each |p| {\n@@ -976,7 +970,7 @@ fn install_named_specific(c: &cargo, wd: &Path, src: ~str, name: ~str) {\n     error(~\"can't find package: \" + src + ~\"/\" + name);\n }\n \n-fn cmd_uninstall(c: &cargo) {\n+fn cmd_uninstall(c: &Cargo) {\n     if vec::len(c.opts.free) < 3u {\n         cmd_usage();\n         return;\n@@ -1028,7 +1022,7 @@ fn cmd_uninstall(c: &cargo) {\n     }\n }\n \n-fn install_query(c: &cargo, wd: &Path, target: ~str) {\n+fn install_query(c: &Cargo, wd: &Path, target: ~str) {\n     match c.dep_cache.find(target) {\n         Some(inst) => {\n             if inst {\n@@ -1088,15 +1082,15 @@ fn install_query(c: &cargo, wd: &Path, target: ~str) {\n     }\n }\n \n-fn get_temp_workdir(c: &cargo) -> Path {\n+fn get_temp_workdir(c: &Cargo) -> Path {\n     match tempfile::mkdtemp(&c.workdir, \"cargo\") {\n       Some(wd) => wd,\n       None => fail fmt!(\"needed temp dir: %s\",\n                         c.workdir.to_str())\n     }\n }\n \n-fn cmd_install(c: &cargo) unsafe {\n+fn cmd_install(c: &Cargo) unsafe {\n     let wd = get_temp_workdir(c);\n \n     if vec::len(c.opts.free) == 2u {\n@@ -1120,15 +1114,15 @@ fn cmd_install(c: &cargo) unsafe {\n     install_query(c, &wd, query);\n }\n \n-fn sync(c: &cargo) {\n+fn sync(c: &Cargo) {\n     for c.sources.each_key |k| {\n         let mut s = c.sources.get(k);\n         sync_one(c, s);\n         c.sources.insert(k, s);\n     }\n }\n \n-fn sync_one_file(c: &cargo, dir: &Path, src: source) -> bool {\n+fn sync_one_file(c: &Cargo, dir: &Path, src: @Source) -> bool {\n     let name = src.name;\n     let srcfile = dir.push(\"source.json.new\");\n     let destsrcfile = dir.push(\"source.json\");\n@@ -1206,7 +1200,7 @@ fn sync_one_file(c: &cargo, dir: &Path, src: source) -> bool {\n     return true;\n }\n \n-fn sync_one_git(c: &cargo, dir: &Path, src: source) -> bool {\n+fn sync_one_git(c: &Cargo, dir: &Path, src: @Source) -> bool {\n     let name = src.name;\n     let srcfile = dir.push(\"source.json\");\n     let pkgfile = dir.push(\"packages.json\");\n@@ -1309,7 +1303,7 @@ fn sync_one_git(c: &cargo, dir: &Path, src: source) -> bool {\n     return true;\n }\n \n-fn sync_one_curl(c: &cargo, dir: &Path, src: source) -> bool {\n+fn sync_one_curl(c: &Cargo, dir: &Path, src: @Source) -> bool {\n     let name = src.name;\n     let srcfile = dir.push(\"source.json.new\");\n     let destsrcfile = dir.push(\"source.json\");\n@@ -1425,7 +1419,7 @@ fn sync_one_curl(c: &cargo, dir: &Path, src: source) -> bool {\n     return true;\n }\n \n-fn sync_one(c: &cargo, src: source) {\n+fn sync_one(c: &Cargo, src: @Source) {\n     let name = src.name;\n     let dir = c.sourcedir.push(name);\n \n@@ -1445,7 +1439,7 @@ fn sync_one(c: &cargo, src: source) {\n     }\n }\n \n-fn cmd_init(c: &cargo) {\n+fn cmd_init(c: &Cargo) {\n     let srcurl = ~\"http://www.rust-lang.org/cargo/sources.json\";\n     let sigurl = ~\"http://www.rust-lang.org/cargo/sources.json.sig\";\n \n@@ -1484,7 +1478,7 @@ fn cmd_init(c: &cargo) {\n     info(fmt!(\"initialized .cargo in %s\", c.root.to_str()));\n }\n \n-fn print_pkg(s: source, p: package) {\n+fn print_pkg(s: @Source, p: &Package) {\n     let mut m = s.name + ~\"/\" + p.name + ~\" (\" + p.uuid + ~\")\";\n     if vec::len(p.tags) > 0u {\n         m = m + ~\" [\" + str::connect(p.tags, ~\", \") + ~\"]\";\n@@ -1495,7 +1489,7 @@ fn print_pkg(s: source, p: package) {\n     }\n }\n \n-fn print_source(s: source) {\n+fn print_source(s: @Source) {\n     info(s.name + ~\" (\" + s.url + ~\")\");\n \n     let pks = sort::merge_sort(s.packages.get(), sys::shape_lt);\n@@ -1516,7 +1510,7 @@ fn print_source(s: source) {\n     }));\n }\n \n-fn cmd_list(c: &cargo) {\n+fn cmd_list(c: &Cargo) {\n     sync(c);\n \n     if vec::len(c.opts.free) >= 3u {\n@@ -1542,7 +1536,7 @@ fn cmd_list(c: &cargo) {\n     }\n }\n \n-fn cmd_search(c: &cargo) {\n+fn cmd_search(c: &Cargo) {\n     if vec::len(c.opts.free) < 3u {\n         cmd_usage();\n         return;\n@@ -1575,17 +1569,17 @@ fn install_to_dir(srcfile: &Path, destdir: &Path) {\n     }\n }\n \n-fn dump_cache(c: &cargo) {\n+fn dump_cache(c: &Cargo) {\n     need_dir(&c.root);\n \n     let out = c.root.push(\"cache.json\");\n-    let _root = json::Dict(map::HashMap());\n+    let _root = json::Object(~LinearMap());\n \n     if os::path_exists(&out) {\n         copy_warn(&out, &c.root.push(\"cache.json.old\"));\n     }\n }\n-fn dump_sources(c: &cargo) {\n+fn dump_sources(c: &Cargo) {\n     if c.sources.size() < 1u {\n         return;\n     }\n@@ -1600,33 +1594,31 @@ fn dump_sources(c: &cargo) {\n \n     match io::buffered_file_writer(&out) {\n         result::Ok(writer) => {\n-            let hash = map::HashMap();\n-            let root = json::Dict(hash);\n+            let mut hash = ~LinearMap();\n \n-          for c.sources.each |k, v| {\n-                let chash = map::HashMap();\n-                let child = json::Dict(chash);\n+            for c.sources.each |k, v| {\n+                let mut chash = ~LinearMap();\n \n-                chash.insert(~\"url\", json::String(@v.url));\n-                chash.insert(~\"method\", json::String(@v.method));\n+                chash.insert(~\"url\", json::String(v.url));\n+                chash.insert(~\"method\", json::String(v.method));\n \n                 match copy v.key {\n                     Some(key) => {\n-                        chash.insert(~\"key\", json::String(@key));\n+                        chash.insert(~\"key\", json::String(copy key));\n                     }\n                     _ => ()\n                 }\n                 match copy v.keyfp {\n                     Some(keyfp) => {\n-                        chash.insert(~\"keyfp\", json::String(@keyfp));\n+                        chash.insert(~\"keyfp\", json::String(copy keyfp));\n                     }\n                     _ => ()\n                 }\n \n-                hash.insert(k, child);\n+                hash.insert(copy k, json::Object(chash));\n             }\n \n-            writer.write_str(json::to_str(root));\n+            json::to_writer(writer, &json::Object(hash))\n         }\n         result::Err(e) => {\n             error(fmt!(\"could not dump sources: %s\", e));\n@@ -1641,7 +1633,7 @@ fn copy_warn(srcfile: &Path, destfile: &Path) {\n     }\n }\n \n-fn cmd_sources(c: &cargo) {\n+fn cmd_sources(c: &Cargo) {\n     if vec::len(c.opts.free) < 3u {\n         for c.sources.each_value |v| {\n             info(fmt!(\"%s (%s) via %s\",\n@@ -1677,7 +1669,7 @@ fn cmd_sources(c: &cargo) {\n             if c.sources.contains_key(name) {\n                 error(fmt!(\"source already exists: %s\", name));\n             } else {\n-                c.sources.insert(name, @{\n+                c.sources.insert(name, @Source {\n                     name: name,\n                     mut url: url,\n                     mut method: assume_source_method(url),"}, {"sha": "991d2d2cb0e3a3b962f809a68724fb677959d8c5", "filename": "src/compiletest/compiletest.rc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Fcompiletest%2Fcompiletest.rc", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Fcompiletest%2Fcompiletest.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rc?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -5,6 +5,8 @@\n \n #[allow(vecs_implicitly_copyable)];\n #[allow(non_camel_case_types)];\n+#[allow(deprecated_mode)];\n+#[allow(deprecated_pattern)];\n \n extern mod core(vers = \"0.4\");\n extern mod std(vers = \"0.4\");"}, {"sha": "264ee61018bf15ae5850744ce79bed295ecdc2b6", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -58,7 +58,7 @@ fn parse_config(args: ~[~str]) -> config {\n              } else { option::None },\n          logfile: option::map(&getopts::opt_maybe_str(matches,\n                                                      ~\"logfile\"),\n-                              |s| Path(s)),\n+                              |s| Path(*s)),\n          runtool: getopts::opt_maybe_str(matches, ~\"runtool\"),\n          rustcflags: getopts::opt_maybe_str(matches, ~\"rustcflags\"),\n          jit: getopts::opt_present(matches, ~\"jit\"),\n@@ -141,7 +141,7 @@ fn make_tests(config: config) -> ~[test::TestDesc] {\n         let file = copy *file;\n         debug!(\"inspecting file %s\", file.to_str());\n         if is_test(config, file) {\n-            vec::push(tests, make_test(config, file))\n+            tests.push(make_test(config, file))\n         }\n     }\n     return tests;"}, {"sha": "a8b69201a2250031de7e31eb79af685012234b98", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -9,7 +9,7 @@ type expected_error = { line: uint, kind: ~str, msg: ~str };\n // Load any test directives embedded in the file\n fn load_errors(testfile: &Path) -> ~[expected_error] {\n     let mut error_patterns = ~[];\n-    let rdr = result::get(io::file_reader(testfile));\n+    let rdr = io::file_reader(testfile).get();\n     let mut line_num = 1u;\n     while !rdr.eof() {\n         let ln = rdr.read_line();"}, {"sha": "3071c9a70a1e7b0874a022dadb824aac3048e721", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -28,7 +28,7 @@ fn load_props(testfile: &Path) -> test_props {\n     let mut pp_exact = option::None;\n     for iter_header(testfile) |ln| {\n         match parse_error_pattern(ln) {\n-          option::Some(ep) => vec::push(error_patterns, ep),\n+          option::Some(ep) => error_patterns.push(ep),\n           option::None => ()\n         };\n \n@@ -41,11 +41,11 @@ fn load_props(testfile: &Path) -> test_props {\n         }\n \n         do parse_aux_build(ln).iter |ab| {\n-            vec::push(aux_builds, ab);\n+            aux_builds.push(*ab);\n         }\n \n         do parse_exec_env(ln).iter |ee| {\n-            vec::push(exec_env, ee);\n+            exec_env.push(*ee);\n         }\n     };\n     return {\n@@ -73,7 +73,7 @@ fn is_test_ignored(config: config, testfile: &Path) -> bool {\n }\n \n fn iter_header(testfile: &Path, it: fn(~str) -> bool) -> bool {\n-    let rdr = result::get(io::file_reader(testfile));\n+    let rdr = io::file_reader(testfile).get();\n     while !rdr.eof() {\n         let ln = rdr.read_line();\n \n@@ -103,7 +103,7 @@ fn parse_compile_flags(line: ~str) -> Option<~str> {\n fn parse_exec_env(line: ~str) -> Option<(~str, ~str)> {\n     do parse_name_value_directive(line, ~\"exec-env\").map |nv| {\n         // nv is either FOO or FOO=BAR\n-        let strs = str::splitn_char(nv, '=', 1u);\n+        let strs = str::splitn_char(*nv, '=', 1u);\n         match strs.len() {\n           1u => (strs[0], ~\"\"),\n           2u => (strs[0], strs[1]),"}, {"sha": "b03c3bbf42fadbe1791a82b947289a752e214275", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -14,12 +14,12 @@ fn target_env(lib_path: ~str, prog: ~str) -> ~[(~str,~str)] {\n     let aux_path = prog.slice(0u, prog.len() - 4u) + ~\".libaux\";\n \n     env = do vec::map(env) |pair| {\n-        let (k,v) = pair;\n+        let (k,v) = *pair;\n         if k == ~\"PATH\" { (~\"PATH\", v + ~\";\" + lib_path + ~\";\" + aux_path) }\n         else { (k,v) }\n     };\n     if str::ends_with(prog, ~\"rustc.exe\") {\n-        vec::push(env, (~\"RUST_THREADS\", ~\"1\"));\n+        env.push((~\"RUST_THREADS\", ~\"1\"));\n     }\n     return env;\n }"}, {"sha": "ff695f64088f2fa40b59bde47c0e14c897513d9a", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -109,7 +109,7 @@ fn run_pretty_test(config: config, props: test_props, testfile: &Path) {\n     let rounds =\n         match props.pp_exact { option::Some(_) => 1, option::None => 2 };\n \n-    let mut srcs = ~[result::get(io::read_whole_file_str(testfile))];\n+    let mut srcs = ~[io::read_whole_file_str(testfile).get()];\n \n     let mut round = 0;\n     while round < rounds {\n@@ -121,15 +121,15 @@ fn run_pretty_test(config: config, props: test_props, testfile: &Path) {\n                           procres);\n         }\n \n-        vec::push(srcs, procres.stdout);\n+        srcs.push(procres.stdout);\n         round += 1;\n     }\n \n     let mut expected =\n         match props.pp_exact {\n           option::Some(file) => {\n             let filepath = testfile.dir_path().push_rel(&file);\n-            result::get(io::read_whole_file_str(&filepath))\n+            io::read_whole_file_str(&filepath).get()\n           }\n           option::None => { srcs[vec::len(srcs) - 2u] }\n         };\n@@ -503,10 +503,7 @@ fn make_run_args(config: config, _props: test_props, testfile: &Path) ->\n \n fn split_maybe_args(argstr: Option<~str>) -> ~[~str] {\n     fn rm_whitespace(v: ~[~str]) -> ~[~str] {\n-        fn flt(&&s: ~str) -> Option<~str> {\n-          if !str::is_whitespace(s) { option::Some(s) } else { option::None }\n-        }\n-        vec::filter_map(v, flt)\n+        vec::filter(v, |s| !str::is_whitespace(*s))\n     }\n \n     match argstr {\n@@ -561,8 +558,8 @@ fn dump_output(config: config, testfile: &Path, out: ~str, err: ~str) {\n fn dump_output_file(config: config, testfile: &Path,\n                     out: ~str, extension: ~str) {\n     let outfile = make_out_name(config, testfile, extension);\n-    let writer = result::get(\n-        io::file_writer(&outfile, ~[io::Create, io::Truncate]));\n+    let writer =\n+        io::file_writer(&outfile, ~[io::Create, io::Truncate]).get();\n     writer.write_str(out);\n }\n "}, {"sha": "7016713f2fee2fad45480aa155bd0e2b88c54f08", "filename": "src/etc/combine-tests.py", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Fetc%2Fcombine-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Fetc%2Fcombine-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcombine-tests.py?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -30,7 +30,7 @@ def scrub(b):\n                 \"xfail-fast\" in s or\n                 \"xfail-win32\" in s):\n             stage2_tests.append(t)\n-            if \"main(args: ~[~str])\" in s:\n+            if \"fn main(args:\" in s or \"fn main(++args:\" in s:\n                 take_args[t] = True\n         f.close()\n \n@@ -39,11 +39,13 @@ def scrub(b):\n c = open(\"tmp/run_pass_stage2.rc\", \"w\")\n i = 0\n c.write(\"// AUTO-GENERATED FILE: DO NOT EDIT\\n\")\n+c.write(\"#[legacy_exports];\\n\")\n c.write(\"#[link(name=\\\"run_pass_stage2\\\", vers=\\\"0.1\\\")];\\n\")\n for t in stage2_tests:\n     p = os.path.join(run_pass, t)\n     p = p.replace(\"\\\\\", \"\\\\\\\\\")\n     c.write(\"#[path = \\\"%s\\\"]\" % p);\n+    c.write(\"#[legacy_exports]\");\n     c.write(\"mod t_%d;\\n\" % i)\n     i += 1\n c.close()"}, {"sha": "d9ee135ac47b855031365f570043908cc5396e9a", "filename": "src/etc/emacs/rust-mode.el", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Fetc%2Femacs%2Frust-mode.el", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Fetc%2Femacs%2Frust-mode.el", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Femacs%2Frust-mode.el?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -70,7 +70,7 @@\n                     \"let\" \"log\" \"loop\"\n                     \"move\" \"new\"\n                     \"pure\" \"pub\" \"priv\"\n-                    \"return\" \"static\"\n+                    \"ref\" \"return\" \"static\"\n                     \"unchecked\" \"unsafe\"\n                     \"while\"))\n       (puthash word t table))"}, {"sha": "ec263ead954f57cee3adf6bb711d05f1aabd2fd7", "filename": "src/fuzzer/cycles.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ffuzzer%2Fcycles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ffuzzer%2Fcycles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Fcycles.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -62,7 +62,7 @@ fn test_cycles(r : rand::rng, k: uint, n: uint)\n \n     // Create a graph with no edges\n     range(0u, vlen) {|_i|\n-        vec::push(v, empty_pointy());\n+        v.push(empty_pointy());\n     }\n \n     // Fill in the graph with random edges, with density k/n\n@@ -77,7 +77,7 @@ fn test_cycles(r : rand::rng, k: uint, n: uint)\n           // https://github.com/mozilla/rust/issues/1899\n \n         if (likelihood(r, k, n)) { v[i].m = [p(choice(r, v))]; }\n-        if (likelihood(r, k, n)) { vec::push(v[i].n, mut p(choice(r, v))); }\n+        if (likelihood(r, k, n)) { v[i].n.push(mut p(choice(r, v))); }\n         if (likelihood(r, k, n)) { v[i].o = {x: 0, y: p(choice(r, v))}; }\n     }\n "}, {"sha": "640bcccc7a8927d0474b0d48b165dfc05d342fb9", "filename": "src/fuzzer/fuzzer.rc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ffuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ffuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rc?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -9,6 +9,8 @@\n \n #[allow(vecs_implicitly_copyable)];\n #[allow(non_camel_case_types)];\n+#[allow(deprecated_mode)];\n+#[allow(deprecated_pattern)];\n \n extern mod core(vers = \"0.4\");\n extern mod std(vers = \"0.4\");"}, {"sha": "cd312362d6a4fcd96f645a434509bf5af319ab4b", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -19,7 +19,7 @@ impl test_mode : cmp::Eq {\n \n fn write_file(filename: &Path, content: ~str) {\n     result::get(\n-        io::file_writer(filename, ~[io::Create, io::Truncate]))\n+        &io::file_writer(filename, ~[io::Create, io::Truncate]))\n         .write_str(content);\n }\n \n@@ -30,7 +30,7 @@ fn contains(haystack: ~str, needle: ~str) -> bool {\n fn find_rust_files(files: &mut ~[Path], path: &Path) {\n     if path.filetype() == Some(~\".rs\") && !contains(path.to_str(), ~\"utf8\") {\n         // ignoring \"utf8\" tests because something is broken\n-        vec::push(*files, *path);\n+        files.push(*path);\n     } else if os::path_is_dir(path)\n         && !contains(path.to_str(), ~\"compile-fail\")\n         && !contains(path.to_str(), ~\"build\") {\n@@ -124,7 +124,7 @@ fn stash_ty_if(c: fn@(@ast::ty, test_mode)->bool,\n                e: @ast::ty,\n                tm: test_mode) {\n     if c(e, tm) {\n-        vec::push(*es,*e);\n+        es.push(*e);\n     } else {/* now my indices are wrong :( */ }\n }\n \n@@ -221,15 +221,15 @@ fn under(n: uint, it: fn(uint)) {\n     while i < n { it(i); i += 1u; }\n }\n \n-fn as_str(f: fn@(io::Writer)) -> ~str {\n+fn as_str(f: fn@(+x: io::Writer)) -> ~str {\n     io::with_str_writer(f)\n }\n \n fn check_variants_of_ast(crate: ast::crate, codemap: codemap::codemap,\n                          filename: &Path, cx: context) {\n     let stolen = steal(crate, cx.mode);\n     let extra_exprs = vec::filter(common_exprs(),\n-                                  |a| safe_to_use_expr(a, cx.mode) );\n+                                  |a| safe_to_use_expr(*a, cx.mode) );\n     check_variants_T(crate, codemap, filename, ~\"expr\",\n                      extra_exprs + stolen.exprs, pprust::expr_to_str,\n                      replace_expr_in_crate, cx);\n@@ -243,7 +243,7 @@ fn check_variants_T<T: Copy>(\n   filename: &Path,\n   thing_label: ~str,\n   things: ~[T],\n-  stringifier: fn@(@T, syntax::parse::token::ident_interner) -> ~str,\n+  stringifier: fn@(@T, @syntax::parse::token::ident_interner) -> ~str,\n   replacer: fn@(ast::crate, uint, T, test_mode) -> ast::crate,\n   cx: context\n   ) {\n@@ -543,7 +543,7 @@ fn check_convergence(files: &[Path]) {\n     error!(\"pp convergence tests: %u files\", vec::len(files));\n     for files.each |file| {\n         if !file_might_not_converge(file) {\n-            let s = @result::get(io::read_whole_file_str(file));\n+            let s = @result::get(&io::read_whole_file_str(file));\n             if !content_might_not_converge(*s) {\n                 error!(\"pp converge: %s\", file.to_str());\n                 // Change from 7u to 2u once\n@@ -563,7 +563,7 @@ fn check_variants(files: &[Path], cx: context) {\n             loop;\n         }\n \n-        let s = @result::get(io::read_whole_file_str(file));\n+        let s = @result::get(&io::read_whole_file_str(file));\n         if contains(*s, ~\"#\") {\n             loop; // Macros are confusing\n         }"}, {"sha": "49d34e7699253eeeacdf925b6174c224e7d98e31", "filename": "src/fuzzer/ivec_fuzz.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ffuzzer%2Fivec_fuzz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ffuzzer%2Fivec_fuzz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Fivec_fuzz.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -55,11 +55,11 @@ fn vec_edits<T: copy>(v: ~[T], xs: ~[T]) -> ~[~[T]] {\n \n     if Lv != 1u {\n         // When Lv == 1u, this is redundant with omit.\n-        vec::push(edits, ~[]);\n+        edits.push(~[]);\n     }\n     if Lv >= 3u {\n         // When Lv == 2u, this is redundant with swap.\n-        vec::push(edits, vec::reversed(v));\n+        edits.push(vec::reversed(v));\n     }\n     ix(0u, 1u, Lv) {|i| edits += ~[vec_omit(v, i)]; }\n     ix(0u, 1u, Lv) {|i| edits += ~[vec_dup(v, i)]; }\n@@ -69,10 +69,10 @@ fn vec_edits<T: copy>(v: ~[T], xs: ~[T]) -> ~[~[T]] {\n \n     ix(0u, 1u, len(xs)) {|j|\n         ix(0u, 1u, Lv) {|i|\n-            vec::push(edits, vec_poke(v, i, xs[j]));\n+            edits.push(vec_poke(v, i, xs[j]));\n         }\n         ix(0u, 0u, Lv) {|i|\n-            vec::push(edits, vec_insert(v, i, xs[j]));\n+            edits.push(vec_insert(v, i, xs[j]));\n         }\n     }\n "}, {"sha": "6745805e2d8879e6911ff06df9c35ea18826b92d", "filename": "src/fuzzer/rand_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ffuzzer%2Frand_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ffuzzer%2Frand_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Frand_util.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -61,7 +61,7 @@ fn weighted_vec<T: copy>(v : ~[weighted<T>]) -> ~[T] {\n     for {weight: weight, item: item} in v {\n         let i = 0u;\n         while i < weight {\n-            vec::push(r, item);\n+            r.push(item);\n             i += 1u;\n         }\n     }"}, {"sha": "7d410c0337add1532b467aa7d6c5a45d976864d7", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 42, "deletions": 47, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -1,14 +1,11 @@\n //! Managed vectors\n \n-use ptr::addr_of;\n+// NB: transitionary, de-mode-ing.\n+// tjc: re-forbid deprecated modes after snapshot\n+#[forbid(deprecated_pattern)];\n \n-export init_op;\n-export capacity;\n-export build_sized, build, build_sized_opt;\n-export map;\n-export from_fn, from_elem;\n-export raw;\n-export traits;\n+use cast::transmute;\n+use ptr::addr_of;\n \n /// Code for dealing with @-vectors. This is pretty incomplete, and\n /// contains a bunch of duplication from the code for ~-vectors.\n@@ -29,10 +26,10 @@ extern mod rusti {\n \n /// Returns the number of elements the vector can hold without reallocating\n #[inline(always)]\n-pure fn capacity<T>(&&v: @[const T]) -> uint {\n+pub pure fn capacity<T>(v: @[const T]) -> uint {\n     unsafe {\n         let repr: **raw::VecRepr =\n-            ::cast::reinterpret_cast(&addr_of(v));\n+            ::cast::reinterpret_cast(&addr_of(&v));\n         (**repr).unboxed.alloc / sys::size_of::<T>()\n     }\n }\n@@ -50,12 +47,12 @@ pure fn capacity<T>(&&v: @[const T]) -> uint {\n  *             onto the vector being constructed.\n  */\n #[inline(always)]\n-pure fn build_sized<A>(size: uint,\n-                       builder: fn(push: pure fn(+v: A))) -> @[A] {\n-    let mut vec = @[];\n-    unsafe { raw::reserve(vec, size); }\n-    builder(|+x| unsafe { raw::push(vec, move x) });\n-    return vec;\n+pub pure fn build_sized<A>(size: uint,\n+                           builder: &fn(push: pure fn(v: A))) -> @[A] {\n+    let mut vec: @[const A] = @[];\n+    unsafe { raw::reserve(&mut vec, size); }\n+    builder(|+x| unsafe { raw::push(&mut vec, move x) });\n+    return unsafe { transmute(vec) };\n }\n \n /**\n@@ -69,7 +66,7 @@ pure fn build_sized<A>(size: uint,\n  *             onto the vector being constructed.\n  */\n #[inline(always)]\n-pure fn build<A>(builder: fn(push: pure fn(+v: A))) -> @[A] {\n+pub pure fn build<A>(builder: &fn(push: pure fn(v: A))) -> @[A] {\n     build_sized(4, builder)\n }\n \n@@ -86,14 +83,14 @@ pure fn build<A>(builder: fn(push: pure fn(+v: A))) -> @[A] {\n  *             onto the vector being constructed.\n  */\n #[inline(always)]\n-pure fn build_sized_opt<A>(size: Option<uint>,\n-                           builder: fn(push: pure fn(+v: A))) -> @[A] {\n+pub pure fn build_sized_opt<A>(size: Option<uint>,\n+                               builder: &fn(push: pure fn(v: A))) -> @[A] {\n     build_sized(size.get_default(4), builder)\n }\n \n // Appending\n #[inline(always)]\n-pure fn append<T: Copy>(lhs: @[T], rhs: &[const T]) -> @[T] {\n+pub pure fn append<T: Copy>(lhs: @[T], rhs: &[const T]) -> @[T] {\n     do build_sized(lhs.len() + rhs.len()) |push| {\n         for vec::each(lhs) |x| { push(*x); }\n         for uint::range(0, rhs.len()) |i| { push(rhs[i]); }\n@@ -102,10 +99,10 @@ pure fn append<T: Copy>(lhs: @[T], rhs: &[const T]) -> @[T] {\n \n \n /// Apply a function to each element of a vector and return the results\n-pure fn map<T, U>(v: &[T], f: fn(T) -> U) -> @[U] {\n+pub pure fn map<T, U>(v: &[T], f: &fn(x: &T) -> U) -> @[U] {\n     do build_sized(v.len()) |push| {\n         for vec::each(v) |elem| {\n-            push(f(*elem));\n+            push(f(elem));\n         }\n     }\n }\n@@ -116,7 +113,7 @@ pure fn map<T, U>(v: &[T], f: fn(T) -> U) -> @[U] {\n  * Creates an immutable vector of size `n_elts` and initializes the elements\n  * to the value returned by the function `op`.\n  */\n-pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> @[T] {\n+pub pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> @[T] {\n     do build_sized(n_elts) |push| {\n         let mut i: uint = 0u;\n         while i < n_elts { push(op(i)); i += 1u; }\n@@ -129,17 +126,17 @@ pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> @[T] {\n  * Creates an immutable vector of size `n_elts` and initializes the elements\n  * to the value `t`.\n  */\n-pure fn from_elem<T: Copy>(n_elts: uint, t: T) -> @[T] {\n+pub pure fn from_elem<T: Copy>(n_elts: uint, t: T) -> @[T] {\n     do build_sized(n_elts) |push| {\n         let mut i: uint = 0u;\n-        while i < n_elts { push(t); i += 1u; }\n+        while i < n_elts { push(copy t); i += 1u; }\n     }\n }\n \n #[cfg(notest)]\n-mod traits {\n+pub mod traits {\n     #[legacy_exports];\n-    impl<T: Copy> @[T] : Add<&[const T],@[T]> {\n+    pub impl<T: Copy> @[T] : Add<&[const T],@[T]> {\n         #[inline(always)]\n         pure fn add(rhs: & &[const T]) -> @[T] {\n             append(self, (*rhs))\n@@ -148,13 +145,12 @@ mod traits {\n }\n \n #[cfg(test)]\n-mod traits {\n+pub mod traits {\n     #[legacy_exports];}\n \n-mod raw {\n-    #[legacy_exports];\n-    type VecRepr = vec::raw::VecRepr;\n-    type SliceRepr = vec::raw::SliceRepr;\n+pub mod raw {\n+    pub type VecRepr = vec::raw::VecRepr;\n+    pub type SliceRepr = vec::raw::SliceRepr;\n \n     /**\n      * Sets the length of a vector\n@@ -164,14 +160,14 @@ mod raw {\n      * the vector is actually the specified size.\n      */\n     #[inline(always)]\n-    unsafe fn set_len<T>(&&v: @[const T], new_len: uint) {\n-        let repr: **VecRepr = ::cast::reinterpret_cast(&addr_of(v));\n+    pub unsafe fn set_len<T>(v: @[const T], new_len: uint) {\n+        let repr: **VecRepr = ::cast::reinterpret_cast(&addr_of(&v));\n         (**repr).unboxed.fill = new_len * sys::size_of::<T>();\n     }\n \n     #[inline(always)]\n-    unsafe fn push<T>(&v: @[const T], +initval: T) {\n-        let repr: **VecRepr = ::cast::reinterpret_cast(&addr_of(v));\n+    pub unsafe fn push<T>(v: &mut @[const T], initval: T) {\n+        let repr: **VecRepr = ::cast::reinterpret_cast(&v);\n         let fill = (**repr).unboxed.fill;\n         if (**repr).unboxed.alloc > fill {\n             push_fast(v, move initval);\n@@ -182,16 +178,16 @@ mod raw {\n     }\n     // This doesn't bother to make sure we have space.\n     #[inline(always)] // really pretty please\n-    unsafe fn push_fast<T>(&v: @[const T], +initval: T) {\n-        let repr: **VecRepr = ::cast::reinterpret_cast(&addr_of(v));\n+    pub unsafe fn push_fast<T>(v: &mut @[const T], initval: T) {\n+        let repr: **VecRepr = ::cast::reinterpret_cast(&v);\n         let fill = (**repr).unboxed.fill;\n         (**repr).unboxed.fill += sys::size_of::<T>();\n-        let p = ptr::addr_of((**repr).unboxed.data);\n+        let p = addr_of(&((**repr).unboxed.data));\n         let p = ptr::offset(p, fill) as *mut T;\n         rusti::move_val_init(*p, move initval);\n     }\n \n-    unsafe fn push_slow<T>(&v: @[const T], +initval: T) {\n+    pub unsafe fn push_slow<T>(v: &mut @[const T], initval: T) {\n         reserve_at_least(v, v.len() + 1u);\n         push_fast(v, move initval);\n     }\n@@ -207,10 +203,10 @@ mod raw {\n      * * v - A vector\n      * * n - The number of elements to reserve space for\n      */\n-    unsafe fn reserve<T>(&v: @[const T], n: uint) {\n+    pub unsafe fn reserve<T>(v: &mut @[const T], n: uint) {\n         // Only make the (slow) call into the runtime if we have to\n-        if capacity(v) < n {\n-            let ptr = addr_of(v) as **VecRepr;\n+        if capacity(*v) < n {\n+            let ptr: **VecRepr = transmute(copy v);\n             rustrt::vec_reserve_shared_actual(sys::get_type_desc::<T>(),\n                                               ptr, n as libc::size_t);\n         }\n@@ -231,14 +227,14 @@ mod raw {\n      * * v - A vector\n      * * n - The number of elements to reserve space for\n      */\n-    unsafe fn reserve_at_least<T>(&v: @[const T], n: uint) {\n+    pub unsafe fn reserve_at_least<T>(v: &mut @[const T], n: uint) {\n         reserve(v, uint::next_power_of_two(n));\n     }\n \n }\n \n #[test]\n-fn test() {\n+pub fn test() {\n     // Some code that could use that, then:\n     fn seq_range(lo: uint, hi: uint) -> @[uint] {\n         do build |push| {\n@@ -254,7 +250,6 @@ fn test() {\n }\n \n #[test]\n-fn append_test() {\n+pub fn append_test() {\n     assert @[1,2,3] + @[4,5,6] == @[1,2,3,4,5,6];\n }\n-"}, {"sha": "9e7e257ee307ae3be31649b2427d61e1b4e28c89", "filename": "src/libcore/bool.rs", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -8,43 +8,39 @@\n \n use cmp::Eq;\n \n-export not, and, or, xor, implies;\n-export eq, ne, is_true, is_false;\n-export from_str, to_str, all_values, to_bit;\n-\n /// Negation / inverse\n-pure fn not(v: bool) -> bool { !v }\n+pub pure fn not(v: bool) -> bool { !v }\n \n /// Conjunction\n-pure fn and(a: bool, b: bool) -> bool { a && b }\n+pub pure fn and(a: bool, b: bool) -> bool { a && b }\n \n /// Disjunction\n-pure fn or(a: bool, b: bool) -> bool { a || b }\n+pub pure fn or(a: bool, b: bool) -> bool { a || b }\n \n /**\n  * Exclusive or\n  *\n  * Identical to `or(and(a, not(b)), and(not(a), b))`\n  */\n-pure fn xor(a: bool, b: bool) -> bool { (a && !b) || (!a && b) }\n+pub pure fn xor(a: bool, b: bool) -> bool { (a && !b) || (!a && b) }\n \n /// Implication in the logic, i.e. from `a` follows `b`\n-pure fn implies(a: bool, b: bool) -> bool { !a || b }\n+pub pure fn implies(a: bool, b: bool) -> bool { !a || b }\n \n /// true if truth values `a` and `b` are indistinguishable in the logic\n-pure fn eq(a: bool, b: bool) -> bool { a == b }\n+pub pure fn eq(a: bool, b: bool) -> bool { a == b }\n \n /// true if truth values `a` and `b` are distinguishable in the logic\n-pure fn ne(a: bool, b: bool) -> bool { a != b }\n+pub pure fn ne(a: bool, b: bool) -> bool { a != b }\n \n /// true if `v` represents truth in the logic\n-pure fn is_true(v: bool) -> bool { v }\n+pub pure fn is_true(v: bool) -> bool { v }\n \n /// true if `v` represents falsehood in the logic\n-pure fn is_false(v: bool) -> bool { !v }\n+pub pure fn is_false(v: bool) -> bool { !v }\n \n /// Parse logic value from `s`\n-pure fn from_str(s: &str) -> Option<bool> {\n+pub pure fn from_str(s: &str) -> Option<bool> {\n     if s == \"true\" {\n         Some(true)\n     } else if s == \"false\" {\n@@ -55,40 +51,40 @@ pure fn from_str(s: &str) -> Option<bool> {\n }\n \n /// Convert `v` into a string\n-pure fn to_str(v: bool) -> ~str { if v { ~\"true\" } else { ~\"false\" } }\n+pub pure fn to_str(v: bool) -> ~str { if v { ~\"true\" } else { ~\"false\" } }\n \n /**\n  * Iterates over all truth values by passing them to `blk` in an unspecified\n  * order\n  */\n-fn all_values(blk: fn(v: bool)) {\n+pub fn all_values(blk: fn(v: bool)) {\n     blk(true);\n     blk(false);\n }\n \n /// converts truth value to an 8 bit byte\n-pure fn to_bit(v: bool) -> u8 { if v { 1u8 } else { 0u8 } }\n+pub pure fn to_bit(v: bool) -> u8 { if v { 1u8 } else { 0u8 } }\n \n impl bool : cmp::Eq {\n     pure fn eq(other: &bool) -> bool { self == (*other) }\n     pure fn ne(other: &bool) -> bool { self != (*other) }\n }\n \n #[test]\n-fn test_bool_from_str() {\n+pub fn test_bool_from_str() {\n     do all_values |v| {\n         assert Some(v) == from_str(bool::to_str(v))\n     }\n }\n \n #[test]\n-fn test_bool_to_str() {\n+pub fn test_bool_to_str() {\n     assert to_str(false) == ~\"false\";\n     assert to_str(true) == ~\"true\";\n }\n \n #[test]\n-fn test_bool_to_bit() {\n+pub fn test_bool_to_bit() {\n     do all_values |v| {\n         assert to_bit(v) == if is_true(v) { 1u8 } else { 0u8 };\n     }"}, {"sha": "d34679f2bd75ea01910acc9f22fff57c3611c705", "filename": "src/libcore/box.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbox.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -7,28 +7,24 @@\n use cmp::{Eq, Ord};\n use intrinsic::TyDesc;\n \n-export ptr_eq, raw;\n-\n-mod raw {\n-    #[legacy_exports];\n-\n-    struct BoxHeaderRepr {\n+pub mod raw {\n+    pub struct BoxHeaderRepr {\n         ref_count: uint,\n         type_desc: *TyDesc,\n         prev: *BoxRepr,\n         next: *BoxRepr,\n     }\n \n-    struct BoxRepr {\n+    pub struct BoxRepr {\n         header: BoxHeaderRepr,\n         data: u8\n     }\n \n }\n \n-pure fn ptr_eq<T>(a: @T, b: @T) -> bool {\n+pub pure fn ptr_eq<T>(a: @T, b: @T) -> bool {\n     //! Determine if two shared boxes point to the same object\n-    unsafe { ptr::addr_of(*a) == ptr::addr_of(*b) }\n+    unsafe { ptr::addr_of(&(*a)) == ptr::addr_of(&(*b)) }\n }\n \n impl<T:Eq> @const T : Eq {"}, {"sha": "f4f0d7b61044c7ad8345825a0cc26ebcfcdd44d3", "filename": "src/libcore/cast.rs", "status": "modified", "additions": 24, "deletions": 27, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcast.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -1,21 +1,14 @@\n //! Unsafe operations\n \n-export reinterpret_cast, forget, bump_box_refcount, transmute;\n-export transmute_mut, transmute_immut, transmute_region, transmute_mut_region;\n-export transmute_mut_unsafe, transmute_immut_unsafe;\n-\n-export copy_lifetime, copy_lifetime_vec;\n-\n #[abi = \"rust-intrinsic\"]\n extern mod rusti {\n-    #[legacy_exports];\n     fn forget<T>(-x: T);\n-    fn reinterpret_cast<T, U>(e: T) -> U;\n+    fn reinterpret_cast<T, U>(&&e: T) -> U;\n }\n \n /// Casts the value at `src` to U. The two types must have the same length.\n #[inline(always)]\n-unsafe fn reinterpret_cast<T, U>(src: &T) -> U {\n+pub unsafe fn reinterpret_cast<T, U>(src: &T) -> U {\n     rusti::reinterpret_cast(*src)\n }\n \n@@ -28,15 +21,15 @@ unsafe fn reinterpret_cast<T, U>(src: &T) -> U {\n  * reinterpret_cast on managed pointer types.\n  */\n #[inline(always)]\n-unsafe fn forget<T>(-thing: T) { rusti::forget(move thing); }\n+pub unsafe fn forget<T>(thing: T) { rusti::forget(move thing); }\n \n /**\n  * Force-increment the reference count on a shared box. If used\n  * carelessly, this can leak the box. Use this in conjunction with transmute\n  * and/or reinterpret_cast when such calls would otherwise scramble a box's\n  * reference count\n  */\n-unsafe fn bump_box_refcount<T>(+t: @T) { forget(move t); }\n+pub unsafe fn bump_box_refcount<T>(t: @T) { forget(move t); }\n \n /**\n  * Transform a value of one type into a value of another type.\n@@ -47,47 +40,53 @@ unsafe fn bump_box_refcount<T>(+t: @T) { forget(move t); }\n  *     assert transmute(\"L\") == ~[76u8, 0u8];\n  */\n #[inline(always)]\n-unsafe fn transmute<L, G>(-thing: L) -> G {\n+pub unsafe fn transmute<L, G>(thing: L) -> G {\n     let newthing: G = reinterpret_cast(&thing);\n     forget(move thing);\n     move newthing\n }\n \n /// Coerce an immutable reference to be mutable.\n #[inline(always)]\n-unsafe fn transmute_mut<T>(+ptr: &a/T) -> &a/mut T { transmute(move ptr) }\n+pub unsafe fn transmute_mut<T>(ptr: &a/T) -> &a/mut T { transmute(move ptr) }\n \n /// Coerce a mutable reference to be immutable.\n #[inline(always)]\n-unsafe fn transmute_immut<T>(+ptr: &a/mut T) -> &a/T { transmute(move ptr) }\n+pub unsafe fn transmute_immut<T>(ptr: &a/mut T) -> &a/T {\n+    transmute(move ptr)\n+}\n \n /// Coerce a borrowed pointer to have an arbitrary associated region.\n #[inline(always)]\n-unsafe fn transmute_region<T>(+ptr: &a/T) -> &b/T { transmute(move ptr) }\n+pub unsafe fn transmute_region<T>(ptr: &a/T) -> &b/T { transmute(move ptr) }\n \n /// Coerce an immutable reference to be mutable.\n #[inline(always)]\n-unsafe fn transmute_mut_unsafe<T>(+ptr: *const T) -> *mut T { transmute(ptr) }\n+pub unsafe fn transmute_mut_unsafe<T>(ptr: *const T) -> *mut T {\n+    transmute(ptr)\n+}\n \n /// Coerce an immutable reference to be mutable.\n #[inline(always)]\n-unsafe fn transmute_immut_unsafe<T>(+ptr: *const T) -> *T { transmute(ptr) }\n+pub unsafe fn transmute_immut_unsafe<T>(ptr: *const T) -> *T {\n+    transmute(ptr)\n+}\n \n /// Coerce a borrowed mutable pointer to have an arbitrary associated region.\n #[inline(always)]\n-unsafe fn transmute_mut_region<T>(+ptr: &a/mut T) -> &b/mut T {\n+pub unsafe fn transmute_mut_region<T>(ptr: &a/mut T) -> &b/mut T {\n     transmute(move ptr)\n }\n \n /// Transforms lifetime of the second pointer to match the first.\n #[inline(always)]\n-unsafe fn copy_lifetime<S,T>(_ptr: &a/S, ptr: &T) -> &a/T {\n+pub unsafe fn copy_lifetime<S,T>(_ptr: &a/S, ptr: &T) -> &a/T {\n     transmute_region(ptr)\n }\n \n /// Transforms lifetime of the second pointer to match the first.\n #[inline(always)]\n-unsafe fn copy_lifetime_vec<S,T>(_ptr: &a/[S], ptr: &T) -> &a/T {\n+pub unsafe fn copy_lifetime_vec<S,T>(_ptr: &a/[S], ptr: &T) -> &a/T {\n     transmute_region(ptr)\n }\n \n@@ -97,16 +96,14 @@ unsafe fn copy_lifetime_vec<S,T>(_ptr: &a/[S], ptr: &T) -> &a/T {\n  ****************************************************************************/\n \n #[cfg(test)]\n-mod tests {\n-    #[legacy_exports];\n-\n+pub mod tests {\n     #[test]\n-    fn test_reinterpret_cast() {\n+    pub fn test_reinterpret_cast() {\n         assert 1u == unsafe { reinterpret_cast(&1) };\n     }\n \n     #[test]\n-    fn test_bump_box_refcount() {\n+    pub fn test_bump_box_refcount() {\n         unsafe {\n             let box = @~\"box box box\";       // refcount 1\n             bump_box_refcount(box);         // refcount 2\n@@ -121,7 +118,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_transmute() {\n+    pub fn test_transmute() {\n         unsafe {\n             let x = @1;\n             let x: *int = transmute(x);\n@@ -131,7 +128,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_transmute2() {\n+    pub fn test_transmute2() {\n         unsafe {\n             assert ~[76u8, 0u8] == transmute(~\"L\");\n         }"}, {"sha": "b76571864e070cdd7d1a99b2913f79838eedef72", "filename": "src/libcore/char.rs", "status": "modified", "additions": 13, "deletions": 21, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -39,32 +39,24 @@ use cmp::Eq;\n     Cn  Unassigned  a reserved unassigned code point or a noncharacter\n */\n \n-export is_alphabetic,\n-       is_XID_start, is_XID_continue,\n-       is_lowercase, is_uppercase,\n-       is_whitespace, is_alphanumeric,\n-       is_ascii, is_digit,\n-       to_digit, cmp,\n-       escape_default, escape_unicode;\n-\n-use is_alphabetic = unicode::derived_property::Alphabetic;\n-use is_XID_start = unicode::derived_property::XID_Start;\n-use is_XID_continue = unicode::derived_property::XID_Continue;\n+pub use is_alphabetic = unicode::derived_property::Alphabetic;\n+pub use is_XID_start = unicode::derived_property::XID_Start;\n+pub use is_XID_continue = unicode::derived_property::XID_Continue;\n \n \n /**\n  * Indicates whether a character is in lower case, defined\n  * in terms of the Unicode General Category 'Ll'\n  */\n-pure fn is_lowercase(c: char) -> bool {\n+pub pure fn is_lowercase(c: char) -> bool {\n     return unicode::general_category::Ll(c);\n }\n \n /**\n  * Indicates whether a character is in upper case, defined\n  * in terms of the Unicode General Category 'Lu'.\n  */\n-pure fn is_uppercase(c: char) -> bool {\n+pub pure fn is_uppercase(c: char) -> bool {\n     return unicode::general_category::Lu(c);\n }\n \n@@ -73,7 +65,7 @@ pure fn is_uppercase(c: char) -> bool {\n  * terms of the Unicode General Categories 'Zs', 'Zl', 'Zp'\n  * additional 'Cc'-category control codes in the range [0x09, 0x0d]\n  */\n-pure fn is_whitespace(c: char) -> bool {\n+pub pure fn is_whitespace(c: char) -> bool {\n     return ('\\x09' <= c && c <= '\\x0d')\n         || unicode::general_category::Zs(c)\n         || unicode::general_category::Zl(c)\n@@ -85,20 +77,20 @@ pure fn is_whitespace(c: char) -> bool {\n  * defined in terms of the Unicode General Categories 'Nd', 'Nl', 'No'\n  * and the Derived Core Property 'Alphabetic'.\n  */\n-pure fn is_alphanumeric(c: char) -> bool {\n+pub pure fn is_alphanumeric(c: char) -> bool {\n     return unicode::derived_property::Alphabetic(c) ||\n         unicode::general_category::Nd(c) ||\n         unicode::general_category::Nl(c) ||\n         unicode::general_category::No(c);\n }\n \n /// Indicates whether the character is an ASCII character\n-pure fn is_ascii(c: char) -> bool {\n+pub pure fn is_ascii(c: char) -> bool {\n    c - ('\\x7F' & c) == '\\x00'\n }\n \n /// Indicates whether the character is numeric (Nd, Nl, or No)\n-pure fn is_digit(c: char) -> bool {\n+pub pure fn is_digit(c: char) -> bool {\n     return unicode::general_category::Nd(c) ||\n         unicode::general_category::Nl(c) ||\n         unicode::general_category::No(c);\n@@ -114,7 +106,7 @@ pure fn is_digit(c: char) -> bool {\n  * 'b' or 'B', 11, etc. Returns none if the char does not\n  * refer to a digit in the given radix.\n  */\n-pure fn to_digit(c: char, radix: uint) -> Option<uint> {\n+pub pure fn to_digit(c: char, radix: uint) -> Option<uint> {\n     let val = match c {\n       '0' .. '9' => c as uint - ('0' as uint),\n       'a' .. 'z' => c as uint + 10u - ('a' as uint),\n@@ -134,7 +126,7 @@ pure fn to_digit(c: char, radix: uint) -> Option<uint> {\n  *   - chars in [0x100,0xffff] get 4-digit escapes: `\\\\uNNNN`\n  *   - chars above 0x10000 get 8-digit escapes: `\\\\UNNNNNNNN`\n  */\n-fn escape_unicode(c: char) -> ~str {\n+pub fn escape_unicode(c: char) -> ~str {\n     let s = u32::to_str(c as u32, 16u);\n     let (c, pad) = (if c <= '\\xff' { ('x', 2u) }\n                     else if c <= '\\uffff' { ('u', 4u) }\n@@ -159,7 +151,7 @@ fn escape_unicode(c: char) -> ~str {\n  *   - Any other chars in the range [0x20,0x7e] are not escaped.\n  *   - Any other chars are given hex unicode escapes; see `escape_unicode`.\n  */\n-fn escape_default(c: char) -> ~str {\n+pub fn escape_default(c: char) -> ~str {\n     match c {\n       '\\t' => ~\"\\\\t\",\n       '\\r' => ~\"\\\\r\",\n@@ -179,7 +171,7 @@ fn escape_default(c: char) -> ~str {\n  *\n  * -1 if a < b, 0 if a == b, +1 if a > b\n  */\n-pure fn cmp(a: char, b: char) -> int {\n+pub pure fn cmp(a: char, b: char) -> int {\n     return  if b > a { -1 }\n     else if b < a { 1 }\n     else { 0 }"}, {"sha": "df6074e32009d5b09abe182a42731268bede3dd3", "filename": "src/libcore/cleanup.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcleanup.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -10,8 +10,6 @@ use repr::BoxRepr;\n use sys::TypeDesc;\n use cast::transmute;\n \n-export annihilate;\n-\n /**\n  * Runtime structures\n  *"}, {"sha": "9a9a7cb3112114f08d1760106096eb730f905174", "filename": "src/libcore/cmath.rs", "status": "modified", "additions": 50, "deletions": 58, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmath.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -3,10 +3,6 @@\n #[forbid(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n \n-// uncomment once #1433 is fixed\n-// FIXME (#1433): export c_float_math_consts;\n-// FIXME (#1433): export c_double_math_consts;\n-\n use libc::c_int;\n use libc::c_float;\n use libc::c_double;\n@@ -193,66 +189,62 @@ pub mod c_double_targ_consts {\n \n FIXME use these once they can be parsed (see Issue #1433)\n \n-mod c_float_math_consts {\n-    #[legacy_exports];\n-    const pi: c_float = 0x1.921fb6p+1_f32;\n-    const div_1_pi: c_float = 0x1.45f306p-2_f32;\n-    const div_2_pi: c_float = 0x1.45f306p-1_f32;\n-    const div_pi_2: c_float = 0x1.921fb6p+0_f32;\n-    const div_pi_4: c_float = 0x1.921fb6p-1_f32;\n-    const div_2_sqrtpi: c_float = 0x1.20dd76p+0_f32;\n-    const e: c_float = 0x1.5bf0a8p+1_f32;\n-    const log2_e: c_float = 0x1.715476p+0_f32;\n-    const log10_e: c_float = 0x1.bcb7b2p-2_f32;\n-    const ln_2: c_float = 0x1.62e43p-1_f32;\n-    const ln_10: c_float = 0x1.26bb1cp+1_f32;\n-    const sqrt2: c_float = 0x1.6a09e6p+0_f32;\n-    const div_1_sqrt2: c_float = 0x1.6a09e6p-1_f32;\n+pub mod c_float_math_consts {\n+    pub const pi: c_float = 0x1.921fb6p+1_f32;\n+    pub const div_1_pi: c_float = 0x1.45f306p-2_f32;\n+    pub const div_2_pi: c_float = 0x1.45f306p-1_f32;\n+    pub const div_pi_2: c_float = 0x1.921fb6p+0_f32;\n+    pub const div_pi_4: c_float = 0x1.921fb6p-1_f32;\n+    pub const div_2_sqrtpi: c_float = 0x1.20dd76p+0_f32;\n+    pub const e: c_float = 0x1.5bf0a8p+1_f32;\n+    pub const log2_e: c_float = 0x1.715476p+0_f32;\n+    pub const log10_e: c_float = 0x1.bcb7b2p-2_f32;\n+    pub const ln_2: c_float = 0x1.62e43p-1_f32;\n+    pub const ln_10: c_float = 0x1.26bb1cp+1_f32;\n+    pub const sqrt2: c_float = 0x1.6a09e6p+0_f32;\n+    pub const div_1_sqrt2: c_float = 0x1.6a09e6p-1_f32;\n }\n \n-mod c_double_math_consts {\n-    #[legacy_exports];\n-    const pi: c_double = 0x1.921fb54442d18p+1_f64;\n-    const div_1_pi: c_double = 0x1.45f306dc9c883p-2_f64;\n-    const div_2_pi: c_double = 0x1.45f306dc9c883p-1_f64;\n-    const div_pi_2: c_double = 0x1.921fb54442d18p+0_f64;\n-    const div_pi_4: c_double = 0x1.921fb54442d18p-1_f64;\n-    const div_2_sqrtpi: c_double = 0x1.20dd750429b6dp+0_f64;\n-    const e: c_double = 0x1.5bf0a8b145769p+1_f64;\n-    const log2_e: c_double = 0x1.71547652b82fep+0_f64;\n-    const log10_e: c_double = 0x1.bcb7b1526e50ep-2_f64;\n-    const ln_2: c_double = 0x1.62e42fefa39efp-1_f64;\n-    const ln_10: c_double = 0x1.26bb1bbb55516p+1_f64;\n-    const sqrt2: c_double = 0x1.6a09e667f3bcdp+0_f64;\n-    const div_1_sqrt2: c_double = 0x1.6a09e667f3bcdp-1_f64;\n+pub mod c_double_math_consts {\n+    pub const pi: c_double = 0x1.921fb54442d18p+1_f64;\n+    pub const div_1_pi: c_double = 0x1.45f306dc9c883p-2_f64;\n+    pub const div_2_pi: c_double = 0x1.45f306dc9c883p-1_f64;\n+    pub const div_pi_2: c_double = 0x1.921fb54442d18p+0_f64;\n+    pub const div_pi_4: c_double = 0x1.921fb54442d18p-1_f64;\n+    pub const div_2_sqrtpi: c_double = 0x1.20dd750429b6dp+0_f64;\n+    pub const e: c_double = 0x1.5bf0a8b145769p+1_f64;\n+    pub const log2_e: c_double = 0x1.71547652b82fep+0_f64;\n+    pub const log10_e: c_double = 0x1.bcb7b1526e50ep-2_f64;\n+    pub const ln_2: c_double = 0x1.62e42fefa39efp-1_f64;\n+    pub const ln_10: c_double = 0x1.26bb1bbb55516p+1_f64;\n+    pub const sqrt2: c_double = 0x1.6a09e667f3bcdp+0_f64;\n+    pub const div_1_sqrt2: c_double = 0x1.6a09e667f3bcdp-1_f64;\n }\n \n-mod c_float_targ_consts {\n-    #[legacy_exports];\n-    const radix: uint = 2u;\n-    const mantissa_digits: uint = 24u;\n-    const digits: uint = 6u;\n-    const min_exp: int = -125;\n-    const max_exp: int = 128;\n-    const min_10_exp: int = -37;\n-    const max_10_exp: int = 38;\n-    const min_value: c_float = 0x1p-126_f32;\n-    const max_value: c_float = 0x1.fffffep+127_f32;\n-    const epsilon: c_float = 0x1p-23_f32;\n+pub mod c_float_targ_consts {\n+    pub const radix: uint = 2u;\n+    pub const mantissa_digits: uint = 24u;\n+    pub const digits: uint = 6u;\n+    pub const min_exp: int = -125;\n+    pub const max_exp: int = 128;\n+    pub const min_10_exp: int = -37;\n+    pub const max_10_exp: int = 38;\n+    pub const min_value: c_float = 0x1p-126_f32;\n+    pub const max_value: c_float = 0x1.fffffep+127_f32;\n+    pub const epsilon: c_float = 0x1p-23_f32;\n }\n \n-mod c_double_targ_consts {\n-    #[legacy_exports];\n-    const radix: uint = 2u;\n-    const mantissa_digits: uint = 53u;\n-    const digits: uint = 15u;\n-    const min_exp: int = -1021;\n-    const max_exp: int = 1024;\n-    const min_10_exp: int = -307;\n-    const max_10_exp: int = 308;\n-    const min_value: c_double = 0x1p-1022_f64;\n-    const max_value: c_double = 0x1.fffffffffffffp+1023_f64;\n-    const epsilon: c_double = 0x1p-52_f64;\n+pub mod c_double_targ_consts {\n+    pub const radix: uint = 2u;\n+    pub const mantissa_digits: uint = 53u;\n+    pub const digits: uint = 15u;\n+    pub const min_exp: int = -1021;\n+    pub const max_exp: int = 1024;\n+    pub const min_10_exp: int = -307;\n+    pub const max_10_exp: int = 308;\n+    pub const min_value: c_double = 0x1p-1022_f64;\n+    pub const max_value: c_double = 0x1.fffffffffffffp+1023_f64;\n+    pub const epsilon: c_double = 0x1p-52_f64;\n }\n \n */"}, {"sha": "c3630e9f857c5d7c51a220d85055bfc026f892b6", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -14,17 +14,14 @@ and `Eq` to overload the `==` and `!=` operators.\n #[forbid(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n \n-use nounittest::*;\n-use unittest::*;\n-export Ord;\n-export Eq;\n+pub use nounittest::*;\n+pub use unittest::*;\n \n /// Interfaces used for comparison.\n \n // Awful hack to work around duplicate lang items in core test.\n #[cfg(notest)]\n mod nounittest {\n-    #[legacy_exports];\n     /**\n      * Trait for values that can be compared for a sort-order.\n      *\n@@ -33,7 +30,7 @@ mod nounittest {\n      * default implementations.\n      */\n     #[lang=\"ord\"]\n-    trait Ord {\n+    pub trait Ord {\n         pure fn lt(other: &self) -> bool;\n         pure fn le(other: &self) -> bool;\n         pure fn ge(other: &self) -> bool;\n@@ -50,7 +47,7 @@ mod nounittest {\n      * a default implementation.\n      */\n     #[lang=\"eq\"]\n-    trait Eq {\n+    pub trait Eq {\n         pure fn eq(other: &self) -> bool;\n         pure fn ne(other: &self) -> bool;\n     }\n@@ -63,14 +60,14 @@ mod nounittest {\n #[cfg(test)]\n mod unittest {\n     #[legacy_exports];\n-    trait Ord {\n+    pub trait Ord {\n         pure fn lt(other: &self) -> bool;\n         pure fn le(other: &self) -> bool;\n         pure fn ge(other: &self) -> bool;\n         pure fn gt(other: &self) -> bool;\n     }\n \n-    trait Eq {\n+    pub trait Eq {\n         pure fn eq(other: &self) -> bool;\n         pure fn ne(other: &self) -> bool;\n     }\n@@ -80,27 +77,27 @@ mod unittest {\n mod unittest {\n     #[legacy_exports];}\n \n-pure fn lt<T: Ord>(v1: &T, v2: &T) -> bool {\n+pub pure fn lt<T: Ord>(v1: &T, v2: &T) -> bool {\n     (*v1).lt(v2)\n }\n \n-pure fn le<T: Ord Eq>(v1: &T, v2: &T) -> bool {\n+pub pure fn le<T: Ord Eq>(v1: &T, v2: &T) -> bool {\n     (*v1).lt(v2) || (*v1).eq(v2)\n }\n \n-pure fn eq<T: Eq>(v1: &T, v2: &T) -> bool {\n+pub pure fn eq<T: Eq>(v1: &T, v2: &T) -> bool {\n     (*v1).eq(v2)\n }\n \n-pure fn ne<T: Eq>(v1: &T, v2: &T) -> bool {\n+pub pure fn ne<T: Eq>(v1: &T, v2: &T) -> bool {\n     (*v1).ne(v2)\n }\n \n-pure fn ge<T: Ord>(v1: &T, v2: &T) -> bool {\n+pub pure fn ge<T: Ord>(v1: &T, v2: &T) -> bool {\n     (*v1).ge(v2)\n }\n \n-pure fn gt<T: Ord>(v1: &T, v2: &T) -> bool {\n+pub pure fn gt<T: Ord>(v1: &T, v2: &T) -> bool {\n     (*v1).gt(v2)\n }\n "}, {"sha": "64c38d13e4934b11ee92a7eb0f9dc7a6df8bbd5b", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -32,14 +32,13 @@ will once again be the preferred module for intertask communication.\n \n */\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n+// NB: transitionary, de-mode-ing\n+// tjc: re-forbid deprecated modes after snapshot\n #[forbid(deprecated_pattern)];\n \n use either::Either;\n use libc::size_t;\n-\n-\n+// After snapshot, change p2::addr_of => addr_of\n \n /**\n  * A communication endpoint that can receive messages\n@@ -76,7 +75,7 @@ pub fn Port<T: Send>() -> Port<T> {\n impl<T: Send> Port<T> {\n \n     fn chan() -> Chan<T> { Chan(self) }\n-    fn send(+v: T) { self.chan().send(move v) }\n+    fn send(v: T) { self.chan().send(move v) }\n     fn recv() -> T { recv(self) }\n     fn peek() -> bool { peek(self) }\n \n@@ -85,7 +84,7 @@ impl<T: Send> Port<T> {\n impl<T: Send> Chan<T> {\n \n     fn chan() -> Chan<T> { self }\n-    fn send(+v: T) { send(self, move v) }\n+    fn send(v: T) { send(self, move v) }\n     fn recv() -> T { recv_chan(self) }\n     fn peek() -> bool { peek_chan(self) }\n \n@@ -104,7 +103,7 @@ struct PortPtr<T:Send> {\n         // Once the port is detached it's guaranteed not to receive further\n         // messages\n         let yield = 0;\n-        let yieldp = ptr::addr_of(yield);\n+        let yieldp = ptr::addr_of(&yield);\n         rustrt::rust_port_begin_detach(self.po, yieldp);\n         if yield != 0 {\n             // Need to wait for the port to be detached\n@@ -167,17 +166,17 @@ fn as_raw_port<T: Send, U>(ch: comm::Chan<T>, f: fn(*rust_port) -> U) -> U {\n  * Constructs a channel. The channel is bound to the port used to\n  * construct it.\n  */\n-pub fn Chan<T: Send>(p: Port<T>) -> Chan<T> {\n+pub fn Chan<T: Send>(&&p: Port<T>) -> Chan<T> {\n     Chan_(rustrt::get_port_id((**p).po))\n }\n \n /**\n  * Sends data over a channel. The sent data is moved into the channel,\n  * whereupon the caller loses access to it.\n  */\n-pub fn send<T: Send>(ch: Chan<T>, +data: T) {\n+pub fn send<T: Send>(ch: Chan<T>, data: T) {\n     let Chan_(p) = ch;\n-    let data_ptr = ptr::addr_of(data) as *();\n+    let data_ptr = ptr::addr_of(&data) as *();\n     let res = rustrt::rust_port_id_send(p, data_ptr);\n     if res != 0 unsafe {\n         // Data sent successfully\n@@ -207,10 +206,10 @@ fn peek_chan<T: Send>(ch: comm::Chan<T>) -> bool {\n /// Receive on a raw port pointer\n fn recv_<T: Send>(p: *rust_port) -> T {\n     let yield = 0;\n-    let yieldp = ptr::addr_of(yield);\n+    let yieldp = ptr::addr_of(&yield);\n     let mut res;\n     res = rusti::init::<T>();\n-    rustrt::port_recv(ptr::addr_of(res) as *uint, p, yieldp);\n+    rustrt::port_recv(ptr::addr_of(&res) as *uint, p, yieldp);\n \n     if yield != 0 {\n         // Data isn't available yet, so res has not been initialized.\n@@ -234,12 +233,12 @@ fn peek_(p: *rust_port) -> bool {\n pub fn select2<A: Send, B: Send>(p_a: Port<A>, p_b: Port<B>)\n     -> Either<A, B> {\n     let ports = ~[(**p_a).po, (**p_b).po];\n-    let yield = 0, yieldp = ptr::addr_of(yield);\n+    let yield = 0, yieldp = ptr::addr_of(&yield);\n \n     let mut resport: *rust_port;\n     resport = rusti::init::<*rust_port>();\n     do vec::as_imm_buf(ports) |ports, n_ports| {\n-        rustrt::rust_port_select(ptr::addr_of(resport), ports,\n+        rustrt::rust_port_select(ptr::addr_of(&resport), ports,\n                                  n_ports as size_t, yieldp);\n     }\n \n@@ -275,7 +274,6 @@ type port_id = int;\n \n #[abi = \"cdecl\"]\n extern mod rustrt {\n-    #[legacy_exports];\n     fn rust_port_id_send(target_port: port_id, data: *()) -> libc::uintptr_t;\n \n     fn new_port(unit_sz: libc::size_t) -> *rust_port;\n@@ -298,7 +296,6 @@ extern mod rustrt {\n \n #[abi = \"rust-intrinsic\"]\n extern mod rusti {\n-    #[legacy_exports];\n     fn init<T>() -> T;\n }\n \n@@ -459,7 +456,7 @@ fn test_recv_chan_wrong_task() {\n     let po = Port();\n     let ch = Chan(po);\n     send(ch, ~\"flower\");\n-    assert result::is_err(task::try(||\n+    assert result::is_err(&task::try(||\n         recv_chan(ch)\n     ))\n }"}, {"sha": "818e1e890ec9beba406f23e668e491fd9e577d1e", "filename": "src/libcore/core.rc", "status": "modified", "additions": 10, "deletions": 93, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -36,7 +36,10 @@ Implicitly, all crates behave as if they included the following prologue:\n // Don't link to core. We are core.\n #[no_core];\n \n-#[legacy_modes];\n+#[legacy_exports];\n+\n+#[warn(deprecated_mode)];\n+#[warn(deprecated_pattern)];\n \n #[warn(vecs_implicitly_copyable)];\n #[deny(non_camel_case_types)];\n@@ -85,242 +88,158 @@ export private;\n /// Operations and constants for `int`\n #[path = \"int-template\"]\n mod int {\n-    #[legacy_exports];\n-    use inst::{ pow };\n-    export pow;\n+    pub use inst::{ pow };\n     #[path = \"int.rs\"]\n-    #[legacy_exports]\n     mod inst;\n }\n \n /// Operations and constants for `i8`\n #[path = \"int-template\"]\n mod i8 {\n-    #[legacy_exports];\n     #[path = \"i8.rs\"]\n-    #[legacy_exports]\n     mod inst;\n }\n \n /// Operations and constants for `i16`\n #[path = \"int-template\"]\n mod i16 {\n-    #[legacy_exports];\n     #[path = \"i16.rs\"]\n-    #[legacy_exports]\n     mod inst;\n }\n \n /// Operations and constants for `i32`\n #[path = \"int-template\"]\n mod i32 {\n-    #[legacy_exports];\n     #[path = \"i32.rs\"]\n-    #[legacy_exports]\n     mod inst;\n }\n \n /// Operations and constants for `i64`\n #[path = \"int-template\"]\n mod i64 {\n-    #[legacy_exports];\n     #[path = \"i64.rs\"]\n-    #[legacy_exports]\n     mod inst;\n }\n \n /// Operations and constants for `uint`\n #[path = \"uint-template\"]\n mod uint {\n-    #[legacy_exports];\n-    use inst::{\n+    pub use inst::{\n         div_ceil, div_round, div_floor, iterate,\n         next_power_of_two\n     };\n-    export div_ceil, div_round, div_floor, iterate,\n-    next_power_of_two;\n-\n     #[path = \"uint.rs\"]\n-    #[legacy_exports]\n     mod inst;\n }\n \n /// Operations and constants for `u8`\n #[path = \"uint-template\"]\n mod u8 {\n-    #[legacy_exports];\n-    use inst::is_ascii;\n-    export is_ascii;\n-\n+    pub use inst::is_ascii;\n     #[path = \"u8.rs\"]\n-    #[legacy_exports]\n     mod inst;\n }\n \n /// Operations and constants for `u16`\n #[path = \"uint-template\"]\n mod u16 {\n-    #[legacy_exports];\n     #[path = \"u16.rs\"]\n-    #[legacy_exports]\n     mod inst;\n }\n \n /// Operations and constants for `u32`\n #[path = \"uint-template\"]\n mod u32 {\n-    #[legacy_exports];\n     #[path = \"u32.rs\"]\n-    #[legacy_exports]\n     mod inst;\n }\n \n /// Operations and constants for `u64`\n #[path = \"uint-template\"]\n mod u64 {\n-    #[legacy_exports];\n     #[path = \"u64.rs\"]\n-    #[legacy_exports]\n     mod inst;\n }\n \n \n-#[legacy_exports]\n mod box;\n-#[legacy_exports]\n mod char;\n-#[legacy_exports]\n mod float;\n-#[legacy_exports]\n mod f32;\n-#[legacy_exports]\n mod f64;\n-#[legacy_exports]\n mod str;\n-#[legacy_exports]\n mod ptr;\n-#[legacy_exports]\n mod vec;\n-#[legacy_exports]\n mod at_vec;\n-#[legacy_exports]\n mod bool;\n-#[legacy_exports]\n mod tuple;\n-#[legacy_exports]\n mod unit;\n-#[legacy_exports]\n mod uniq;\n \n // Ubiquitous-utility-type modules\n \n #[cfg(notest)]\n-#[legacy_exports]\n mod ops;\n-#[legacy_exports]\n mod cmp;\n-#[legacy_exports]\n mod num;\n-#[legacy_exports]\n mod hash;\n-#[legacy_exports]\n mod either;\n-#[legacy_exports]\n mod iter;\n-#[legacy_exports]\n mod logging;\n-#[legacy_exports]\n mod option;\n #[path=\"iter-trait\"]\n mod option_iter {\n-    #[legacy_exports];\n     #[path = \"option.rs\"]\n-    #[legacy_exports]\n     mod inst;\n }\n-#[legacy_exports]\n mod result;\n-#[legacy_exports]\n mod to_str;\n-#[legacy_exports]\n mod to_bytes;\n-#[legacy_exports]\n mod from_str;\n-#[legacy_exports]\n mod util;\n \n // Data structure modules\n \n-#[legacy_exports]\n mod dvec;\n #[path=\"iter-trait\"]\n mod dvec_iter {\n-    #[legacy_exports];\n     #[path = \"dvec.rs\"]\n-    #[legacy_exports]\n     mod inst;\n }\n-#[legacy_exports]\n mod dlist;\n #[path=\"iter-trait\"]\n mod dlist_iter {\n-    #[legacy_exports];\n     #[path =\"dlist.rs\"]\n-    #[legacy_exports]\n     mod inst;\n }\n-#[legacy_exports]\n mod send_map;\n \n // Concurrency\n-#[legacy_exports]\n mod comm;\n-#[legacy_exports]\n mod task {\n-    #[legacy_exports];\n-    #[legacy_exports]\n-    mod local_data;\n-    #[legacy_exports]\n+    pub mod local_data;\n     mod local_data_priv;\n-    #[legacy_exports]\n-    mod spawn;\n-    #[legacy_exports]\n-    mod rt;\n+    pub mod spawn;\n+    pub mod rt;\n }\n-#[legacy_exports]\n mod future;\n-#[legacy_exports]\n mod pipes;\n \n // Runtime and language-primitive support\n \n-#[legacy_exports]\n mod gc;\n-#[legacy_exports]\n mod io;\n-#[legacy_exports]\n mod libc;\n-#[legacy_exports]\n mod os;\n-#[legacy_exports]\n mod path;\n-#[legacy_exports]\n mod rand;\n-#[legacy_exports]\n mod run;\n-#[legacy_exports]\n mod sys;\n-#[legacy_exports]\n mod cast;\n-#[legacy_exports]\n mod mutable;\n-#[legacy_exports]\n mod flate;\n-#[legacy_exports]\n mod repr;\n-#[legacy_exports]\n mod cleanup;\n-#[legacy_exports]\n mod reflect;\n \n // Modules supporting compiler-generated code\n@@ -336,9 +255,7 @@ mod rt;\n \n // For internal use, not exported\n \n-#[legacy_exports]\n mod unicode;\n-#[legacy_exports]\n mod private;\n mod cmath;\n mod stackwalk;"}, {"sha": "c7261aa8c29c00aa2a7be4dc894fb57d4ac744ad", "filename": "src/libcore/core.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -2,8 +2,6 @@\n \n // Export various ubiquitous types, constructors, methods.\n \n-#[legacy_exports];\n-\n use option::{Some, None};\n use Option = option::Option;\n use result::{Result, Ok, Err};\n@@ -17,6 +15,7 @@ use tuple::{TupleOps, ExtendedTupleOps};\n use str::{StrSlice, UniqueStr};\n use vec::{ConstVector, CopyableVector, ImmutableVector};\n use vec::{ImmutableEqVector, ImmutableCopyableVector};\n+use vec::{MutableVector, MutableCopyableVector};\n use iter::{BaseIter, ExtendedIter, EqIter, CopyableIter};\n use iter::{CopyableOrderedIter, Times, TimesIx};\n use num::Num;\n@@ -33,6 +32,7 @@ export Num, Times, TimesIx;\n export StrSlice, UniqueStr;\n export ConstVector, CopyableVector, ImmutableVector;\n export ImmutableEqVector, ImmutableCopyableVector, IterTraitExtensions;\n+export MutableVector, MutableCopyableVector;\n export BaseIter, CopyableIter, CopyableOrderedIter, ExtendedIter, EqIter;\n export TupleOps, ExtendedTupleOps;\n export Ptr;"}, {"sha": "17ddd6ea73b7c6ce260e39f444535703e308d6c1", "filename": "src/libcore/dlist.rs", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -9,12 +9,9 @@ Do not use ==, !=, <, etc on doubly-linked lists -- it may not terminate.\n */\n \n // NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n+// tjc: re-forbid deprecated modes after snapshot\n #[forbid(deprecated_pattern)];\n \n-export DList;\n-export new_dlist, from_elem, from_vec, extensions;\n-\n type DListLink<T> = Option<DListNode<T>>;\n \n enum DListNode<T> = @{\n@@ -24,7 +21,7 @@ enum DListNode<T> = @{\n     mut next: DListLink<T>\n };\n \n-enum DList<T> {\n+pub enum DList<T> {\n     DList_(@{\n         mut size: uint,\n         mut hd:   DListLink<T>,\n@@ -83,7 +80,7 @@ impl<T> DListNode<T> {\n }\n \n /// Creates a new dlist node with the given data.\n-pure fn new_dlist_node<T>(+data: T) -> DListNode<T> {\n+pure fn new_dlist_node<T>(data: T) -> DListNode<T> {\n     DListNode(@{data: move data, mut linked: false,\n                  mut prev: None, mut next: None})\n }\n@@ -94,15 +91,15 @@ pure fn DList<T>() -> DList<T> {\n }\n \n /// Creates a new dlist with a single element\n-pure fn from_elem<T>(+data: T) -> DList<T> {\n+pub pure fn from_elem<T>(data: T) -> DList<T> {\n     let list = DList();\n     unsafe { list.push(move data); }\n     list\n }\n \n-fn from_vec<T: Copy>(+vec: &[T]) -> DList<T> {\n+pub fn from_vec<T: Copy>(vec: &[T]) -> DList<T> {\n     do vec::foldl(DList(), vec) |list,data| {\n-        list.push(data); // Iterating left-to-right -- add newly to the tail.\n+        list.push(*data); // Iterating left-to-right -- add newly to the tail.\n         list\n     }\n }\n@@ -118,7 +115,7 @@ fn concat<T>(lists: DList<DList<T>>) -> DList<T> {\n }\n \n priv impl<T> DList<T> {\n-    pure fn new_link(-data: T) -> DListLink<T> {\n+    pure fn new_link(data: T) -> DListLink<T> {\n         Some(DListNode(@{data: move data, mut linked: true,\n                           mut prev: None, mut next: None}))\n     }\n@@ -145,7 +142,7 @@ priv impl<T> DList<T> {\n     // Link two nodes together. If either of them are 'none', also sets\n     // the head and/or tail pointers appropriately.\n     #[inline(always)]\n-    fn link(+before: DListLink<T>, +after: DListLink<T>) {\n+    fn link(before: DListLink<T>, after: DListLink<T>) {\n         match before {\n             Some(neighbour) => neighbour.next = after,\n             None            => self.hd        = after\n@@ -166,12 +163,12 @@ priv impl<T> DList<T> {\n         self.size -= 1;\n     }\n \n-    fn add_head(+nobe: DListLink<T>) {\n+    fn add_head(nobe: DListLink<T>) {\n         self.link(nobe, self.hd); // Might set tail too.\n         self.hd = nobe;\n         self.size += 1;\n     }\n-    fn add_tail(+nobe: DListLink<T>) {\n+    fn add_tail(nobe: DListLink<T>) {\n         self.link(self.tl, nobe); // Might set head too.\n         self.tl = nobe;\n         self.size += 1;\n@@ -201,27 +198,27 @@ impl<T> DList<T> {\n     pure fn is_not_empty() -> bool { self.len() != 0 }\n \n     /// Add data to the head of the list. O(1).\n-    fn push_head(+data: T) {\n+    fn push_head(data: T) {\n         self.add_head(self.new_link(move data));\n     }\n     /**\n      * Add data to the head of the list, and get the new containing\n      * node. O(1).\n      */\n-    fn push_head_n(+data: T) -> DListNode<T> {\n+    fn push_head_n(data: T) -> DListNode<T> {\n         let mut nobe = self.new_link(move data);\n         self.add_head(nobe);\n         option::get(&nobe)\n     }\n     /// Add data to the tail of the list. O(1).\n-    fn push(+data: T) {\n+    fn push(data: T) {\n         self.add_tail(self.new_link(move data));\n     }\n     /**\n      * Add data to the tail of the list, and get the new containing\n      * node. O(1).\n      */\n-    fn push_n(+data: T) -> DListNode<T> {\n+    fn push_n(data: T) -> DListNode<T> {\n         let mut nobe = self.new_link(move data);\n         self.add_tail(nobe);\n         option::get(&nobe)\n@@ -230,7 +227,7 @@ impl<T> DList<T> {\n      * Insert data into the middle of the list, left of the given node.\n      * O(1).\n      */\n-    fn insert_before(+data: T, neighbour: DListNode<T>) {\n+    fn insert_before(data: T, neighbour: DListNode<T>) {\n         self.insert_left(self.new_link(move data), neighbour);\n     }\n     /**\n@@ -245,7 +242,7 @@ impl<T> DList<T> {\n      * Insert data in the middle of the list, left of the given node,\n      * and get its containing node. O(1).\n      */\n-    fn insert_before_n(+data: T, neighbour: DListNode<T>) -> DListNode<T> {\n+    fn insert_before_n(data: T, neighbour: DListNode<T>) -> DListNode<T> {\n         let mut nobe = self.new_link(move data);\n         self.insert_left(nobe, neighbour);\n         option::get(&nobe)\n@@ -254,7 +251,7 @@ impl<T> DList<T> {\n      * Insert data into the middle of the list, right of the given node.\n      * O(1).\n      */\n-    fn insert_after(+data: T, neighbour: DListNode<T>) {\n+    fn insert_after(data: T, neighbour: DListNode<T>) {\n         self.insert_right(neighbour, self.new_link(move data));\n     }\n     /**\n@@ -269,7 +266,7 @@ impl<T> DList<T> {\n      * Insert data in the middle of the list, right of the given node,\n      * and get its containing node. O(1).\n      */\n-    fn insert_after_n(+data: T, neighbour: DListNode<T>) -> DListNode<T> {\n+    fn insert_after_n(data: T, neighbour: DListNode<T>) -> DListNode<T> {\n         let mut nobe = self.new_link(move data);\n         self.insert_right(neighbour, nobe);\n         option::get(&nobe)\n@@ -278,13 +275,13 @@ impl<T> DList<T> {\n     /// Remove a node from the head of the list. O(1).\n     fn pop_n() -> Option<DListNode<T>> {\n         let hd = self.peek_n();\n-        hd.map(|nobe| self.unlink(nobe));\n+        hd.map(|nobe| self.unlink(*nobe));\n         hd\n     }\n     /// Remove a node from the tail of the list. O(1).\n     fn pop_tail_n() -> Option<DListNode<T>> {\n         let tl = self.peek_tail_n();\n-        tl.map(|nobe| self.unlink(nobe));\n+        tl.map(|nobe| self.unlink(*nobe));\n         tl\n     }\n     /// Get the node at the list's head. O(1).\n@@ -678,7 +675,7 @@ mod tests {\n     #[test]\n     fn test_dlist_foldl() {\n         let l = from_vec(vec::from_fn(101, |x|x));\n-        assert iter::foldl(l, 0, |accum,elem| accum+elem) == 5050;\n+        assert iter::foldl(&l, 0, |accum,elem| *accum+*elem) == 5050;\n     }\n     #[test]\n     fn test_dlist_break_early() {"}, {"sha": "a2a709087971f52022720dcddb7903b566157a8d", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 24, "deletions": 30, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -10,18 +10,12 @@ Note that recursive use is not permitted.\n */\n \n // NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n+// tjc: re-forbid deprecated modes after snapshot\n #[forbid(deprecated_pattern)];\n \n use cast::reinterpret_cast;\n use ptr::null;\n \n-export DVec;\n-export from_elem;\n-export from_vec;\n-export extensions;\n-export unwrap;\n-\n /**\n  * A growable, modifiable vector type that accumulates elements into a\n  * unique vector.\n@@ -57,27 +51,27 @@ type DVec_<A> = {\n     mut data: ~[A]\n };\n \n-enum DVec<A> {\n+pub enum DVec<A> {\n     DVec_(DVec_<A>)\n }\n \n /// Creates a new, empty dvec\n-fn DVec<A>() -> DVec<A> {\n+pub fn DVec<A>() -> DVec<A> {\n     DVec_({mut data: ~[]})\n }\n \n /// Creates a new dvec with a single element\n-fn from_elem<A>(+e: A) -> DVec<A> {\n+pub fn from_elem<A>(e: A) -> DVec<A> {\n     DVec_({mut data: ~[move e]})\n }\n \n /// Creates a new dvec with the contents of a vector\n-fn from_vec<A>(+v: ~[A]) -> DVec<A> {\n+pub fn from_vec<A>(v: ~[A]) -> DVec<A> {\n     DVec_({mut data: move v})\n }\n \n /// Consumes the vector and returns its contents\n-fn unwrap<A>(+d: DVec<A>) -> ~[A] {\n+pub fn unwrap<A>(d: DVec<A>) -> ~[A] {\n     let DVec_({data: v}) <- d;\n     move v\n }\n@@ -93,7 +87,7 @@ priv impl<A> DVec<A> {\n     }\n \n     #[inline(always)]\n-    fn check_out<B>(f: fn(-v: ~[A]) -> B) -> B {\n+    fn check_out<B>(f: &fn(v: ~[A]) -> B) -> B {\n         unsafe {\n             let mut data = cast::reinterpret_cast(&null::<()>());\n             data <-> self.data;\n@@ -104,7 +98,7 @@ priv impl<A> DVec<A> {\n     }\n \n     #[inline(always)]\n-    fn give_back(+data: ~[A]) {\n+    fn give_back(data: ~[A]) {\n         unsafe {\n             self.data = move data;\n         }\n@@ -126,7 +120,7 @@ impl<A> DVec<A> {\n      * and return a new vector to replace it with.\n      */\n     #[inline(always)]\n-    fn swap(f: fn(-v: ~[A]) -> ~[A]) {\n+    fn swap(f: &fn(v: ~[A]) -> ~[A]) {\n         self.check_out(|v| self.give_back(f(move v)))\n     }\n \n@@ -136,7 +130,7 @@ impl<A> DVec<A> {\n      * and return a new vector to replace it with.\n      */\n     #[inline(always)]\n-    fn swap_mut(f: fn(-v: ~[mut A]) -> ~[mut A]) {\n+    fn swap_mut(f: &fn(v: ~[mut A]) -> ~[mut A]) {\n         do self.swap |v| {\n             vec::from_mut(f(vec::to_mut(move v)))\n         }\n@@ -154,7 +148,7 @@ impl<A> DVec<A> {\n     }\n \n     /// Overwrite the current contents\n-    fn set(+w: ~[A]) {\n+    fn set(w: ~[A]) {\n         self.check_not_borrowed();\n         self.data <- w;\n     }\n@@ -163,37 +157,37 @@ impl<A> DVec<A> {\n     fn pop() -> A {\n         do self.check_out |v| {\n             let mut v <- v;\n-            let result = vec::pop(v);\n+            let result = v.pop();\n             self.give_back(move v);\n             move result\n         }\n     }\n \n     /// Insert a single item at the front of the list\n-    fn unshift(-t: A) {\n+    fn unshift(t: A) {\n         unsafe {\n             let mut data = cast::reinterpret_cast(&null::<()>());\n             data <-> self.data;\n             let data_ptr: *() = cast::reinterpret_cast(&data);\n             if data_ptr.is_null() { fail ~\"Recursive use of dvec\"; }\n             log(error, ~\"a\");\n             self.data <- ~[move t];\n-            vec::push_all_move(self.data, move data);\n+            self.data.push_all_move(move data);\n             log(error, ~\"b\");\n         }\n     }\n \n     /// Append a single item to the end of the list\n-    fn push(+t: A) {\n+    fn push(t: A) {\n         self.check_not_borrowed();\n-        vec::push(self.data, move t);\n+        self.data.push(move t);\n     }\n \n     /// Remove and return the first element\n     fn shift() -> A {\n         do self.check_out |v| {\n             let mut v = move v;\n-            let result = vec::shift(v);\n+            let result = v.shift();\n             self.give_back(move v);\n             move result\n         }\n@@ -246,7 +240,7 @@ impl<A: Copy> DVec<A> {\n             vec::reserve(&mut v, new_len);\n             let mut i = from_idx;\n             while i < to_idx {\n-                vec::push(v, ts[i]);\n+                v.push(ts[i]);\n                 i += 1u;\n             }\n             move v\n@@ -272,7 +266,7 @@ impl<A: Copy> DVec<A> {\n             }\n            };\n \n-        for ts.each |t| { vec::push(v, *t) };\n+        for ts.each |t| { v.push(*t) };\n            v\n         }\n     }\n@@ -311,10 +305,10 @@ impl<A: Copy> DVec<A> {\n      * growing the vector if necessary.  New elements will be initialized\n      * with `initval`\n      */\n-    fn grow_set_elt(idx: uint, initval: A, val: A) {\n+    fn grow_set_elt(idx: uint, initval: &A, val: A) {\n         do self.swap |v| {\n             let mut v = move v;\n-            vec::grow_set(v, idx, initval, val);\n+            v.grow_set(idx, initval, val);\n             move v\n         }\n     }\n@@ -325,11 +319,11 @@ impl<A: Copy> DVec<A> {\n         self.check_not_borrowed();\n \n         let length = self.len();\n-        if length == 0u {\n+        if length == 0 {\n             fail ~\"attempt to retrieve the last element of an empty vector\";\n         }\n \n-        return self.data[length - 1u];\n+        return self.data[length - 1];\n     }\n \n     /// Iterates over the elements in reverse order\n@@ -360,7 +354,7 @@ impl<A: Copy> DVec<A> {\n }\n \n impl<A:Copy> DVec<A>: Index<uint,A> {\n-    pure fn index(&&idx: uint) -> A {\n+    pure fn index(idx: uint) -> A {\n         self.get_elt(idx)\n     }\n }"}, {"sha": "c64cd25e4813a279ea786e8b3d85b4144b1de3cb", "filename": "src/libcore/either.rs", "status": "modified", "additions": 40, "deletions": 35, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -1,5 +1,5 @@\n // NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n+// tjc: re-forbid deprecated modes after snapshot\n #[forbid(deprecated_pattern)];\n \n //! A type that represents one of two alternatives\n@@ -8,13 +8,13 @@ use cmp::Eq;\n use result::Result;\n \n /// The either type\n-enum Either<T, U> {\n+pub enum Either<T, U> {\n     Left(T),\n     Right(U)\n }\n \n-fn either<T, U, V>(f_left: fn((&T)) -> V,\n-                   f_right: fn((&U)) -> V, value: &Either<T, U>) -> V {\n+pub fn either<T, U, V>(f_left: fn((&T)) -> V,\n+                       f_right: fn((&U)) -> V, value: &Either<T, U>) -> V {\n     /*!\n      * Applies a function based on the given either value\n      *\n@@ -29,33 +29,34 @@ fn either<T, U, V>(f_left: fn((&T)) -> V,\n     }\n }\n \n-fn lefts<T: Copy, U>(eithers: &[Either<T, U>]) -> ~[T] {\n+pub fn lefts<T: Copy, U>(eithers: &[Either<T, U>]) -> ~[T] {\n     //! Extracts from a vector of either all the left values\n \n-    let mut result: ~[T] = ~[];\n-    for vec::each(eithers) |elt| {\n-        match *elt {\n-          Left(l) => vec::push(result, l),\n-          _ => { /* fallthrough */ }\n+    do vec::build_sized(eithers.len()) |push| {\n+        for vec::each(eithers) |elt| {\n+            match *elt {\n+                Left(ref l) => { push(*l); }\n+                _ => { /* fallthrough */ }\n+            }\n         }\n     }\n-    move result\n }\n \n-fn rights<T, U: Copy>(eithers: &[Either<T, U>]) -> ~[U] {\n+pub fn rights<T, U: Copy>(eithers: &[Either<T, U>]) -> ~[U] {\n     //! Extracts from a vector of either all the right values\n \n-    let mut result: ~[U] = ~[];\n-    for vec::each(eithers) |elt| {\n-        match *elt {\n-          Right(r) => vec::push(result, r),\n-          _ => { /* fallthrough */ }\n+    do vec::build_sized(eithers.len()) |push| {\n+        for vec::each(eithers) |elt| {\n+            match *elt {\n+                Right(ref r) => { push(*r); }\n+                _ => { /* fallthrough */ }\n+            }\n         }\n     }\n-    move result\n }\n \n-fn partition<T: Copy, U: Copy>(eithers: &[Either<T, U>])\n+// XXX bad copies. take arg by val\n+pub fn partition<T: Copy, U: Copy>(eithers: &[Either<T, U>])\n     -> {lefts: ~[T], rights: ~[U]} {\n     /*!\n      * Extracts from a vector of either all the left values and right values\n@@ -68,23 +69,26 @@ fn partition<T: Copy, U: Copy>(eithers: &[Either<T, U>])\n     let mut rights: ~[U] = ~[];\n     for vec::each(eithers) |elt| {\n         match *elt {\n-          Left(l) => vec::push(lefts, l),\n-          Right(r) => vec::push(rights, r)\n+          Left(copy l) => lefts.push(l),\n+          Right(copy r) => rights.push(r)\n         }\n     }\n     return {lefts: move lefts, rights: move rights};\n }\n \n-pure fn flip<T: Copy, U: Copy>(eith: &Either<T, U>) -> Either<U, T> {\n+// XXX bad copies\n+pub pure fn flip<T: Copy, U: Copy>(eith: &Either<T, U>) -> Either<U, T> {\n     //! Flips between left and right of a given either\n \n     match *eith {\n-      Right(r) => Left(r),\n-      Left(l) => Right(l)\n+      Right(copy r) => Left(r),\n+      Left(copy l) => Right(l)\n     }\n }\n \n-pure fn to_result<T: Copy, U: Copy>(eith: &Either<T, U>) -> Result<U, T> {\n+// XXX bad copies\n+pub pure fn to_result<T: Copy, U: Copy>(eith: &Either<T, U>)\n+    -> Result<U, T> {\n     /*!\n      * Converts either::t to a result::t\n      *\n@@ -93,32 +97,33 @@ pure fn to_result<T: Copy, U: Copy>(eith: &Either<T, U>) -> Result<U, T> {\n      */\n \n     match *eith {\n-      Right(r) => result::Ok(r),\n-      Left(l) => result::Err(l)\n+      Right(copy r) => result::Ok(r),\n+      Left(copy l) => result::Err(l)\n     }\n }\n \n-pure fn is_left<T, U>(eith: &Either<T, U>) -> bool {\n+pub pure fn is_left<T, U>(eith: &Either<T, U>) -> bool {\n     //! Checks whether the given value is a left\n \n     match *eith { Left(_) => true, _ => false }\n }\n \n-pure fn is_right<T, U>(eith: &Either<T, U>) -> bool {\n+pub pure fn is_right<T, U>(eith: &Either<T, U>) -> bool {\n     //! Checks whether the given value is a right\n \n     match *eith { Right(_) => true, _ => false }\n }\n \n-pure fn unwrap_left<T,U>(+eith: Either<T,U>) -> T {\n+// tjc: fix the next two after a snapshot\n+pub pure fn unwrap_left<T,U>(eith: Either<T,U>) -> T {\n     //! Retrieves the value in the left branch. Fails if the either is Right.\n \n     match move eith {\n         Left(move x) => move x, Right(_) => fail ~\"either::unwrap_left Right\"\n     }\n }\n \n-pure fn unwrap_right<T,U>(+eith: Either<T,U>) -> U {\n+pub pure fn unwrap_right<T,U>(eith: Either<T,U>) -> U {\n     //! Retrieves the value in the right branch. Fails if the either is Left.\n \n     match move eith {\n@@ -129,16 +134,16 @@ pure fn unwrap_right<T,U>(+eith: Either<T,U>) -> U {\n impl<T:Eq,U:Eq> Either<T,U> : Eq {\n     pure fn eq(other: &Either<T,U>) -> bool {\n         match self {\n-            Left(a) => {\n+            Left(ref a) => {\n                 match (*other) {\n-                    Left(ref b) => a.eq(b),\n+                    Left(ref b) => (*a).eq(b),\n                     Right(_) => false\n                 }\n             }\n-            Right(a) => {\n+            Right(ref a) => {\n                 match (*other) {\n                     Left(_) => false,\n-                    Right(ref b) => a.eq(b)\n+                    Right(ref b) => (*a).eq(b)\n                 }\n             }\n         }"}, {"sha": "e10ff4bac714798b381ede662f028c41700d942d", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 45, "deletions": 37, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -81,16 +81,16 @@ mod ct {\n \n     // A fragment of the output sequence\n     enum Piece { PieceString(~str), PieceConv(Conv), }\n-    type ErrorFn = fn@(~str) -> ! ;\n+    type ErrorFn = fn@(&str) -> ! ;\n \n-    fn parse_fmt_string(s: ~str, error: ErrorFn) -> ~[Piece] {\n+    fn parse_fmt_string(s: &str, error: ErrorFn) -> ~[Piece] {\n         let mut pieces: ~[Piece] = ~[];\n         let lim = str::len(s);\n         let mut buf = ~\"\";\n-        fn flush_buf(+buf: ~str, &pieces: ~[Piece]) -> ~str {\n-            if str::len(buf) > 0 {\n+        fn flush_buf(buf: ~str, pieces: &mut ~[Piece]) -> ~str {\n+            if buf.len() > 0 {\n                 let piece = PieceString(move buf);\n-                vec::push(pieces, move piece);\n+                pieces.push(move piece);\n             }\n             return ~\"\";\n         }\n@@ -108,17 +108,17 @@ mod ct {\n                     buf += curr2;\n                     i += 1;\n                 } else {\n-                    buf = flush_buf(move buf, pieces);\n+                    buf = flush_buf(move buf, &mut pieces);\n                     let rs = parse_conversion(s, i, lim, error);\n-                    vec::push(pieces, copy rs.piece);\n+                    pieces.push(copy rs.piece);\n                     i = rs.next;\n                 }\n             } else { buf += curr; i += size; }\n         }\n-        flush_buf(move buf, pieces);\n+        flush_buf(move buf, &mut pieces);\n         move pieces\n     }\n-    fn peek_num(s: ~str, i: uint, lim: uint) ->\n+    fn peek_num(s: &str, i: uint, lim: uint) ->\n        Option<{num: uint, next: uint}> {\n         let mut j = i;\n         let mut accum = 0u;\n@@ -140,7 +140,7 @@ mod ct {\n             None\n         }\n     }\n-    fn parse_conversion(s: ~str, i: uint, lim: uint, error: ErrorFn) ->\n+    fn parse_conversion(s: &str, i: uint, lim: uint, error: ErrorFn) ->\n        {piece: Piece, next: uint} {\n         let parm = parse_parameter(s, i, lim);\n         let flags = parse_flags(s, parm.next, lim);\n@@ -155,7 +155,7 @@ mod ct {\n                              ty: ty.ty}),\n              next: ty.next};\n     }\n-    fn parse_parameter(s: ~str, i: uint, lim: uint) ->\n+    fn parse_parameter(s: &str, i: uint, lim: uint) ->\n        {param: Option<int>, next: uint} {\n         if i >= lim { return {param: None, next: i}; }\n         let num = peek_num(s, i, lim);\n@@ -170,34 +170,35 @@ mod ct {\n               }\n             };\n     }\n-    fn parse_flags(s: ~str, i: uint, lim: uint) ->\n+    fn parse_flags(s: &str, i: uint, lim: uint) ->\n        {flags: ~[Flag], next: uint} {\n         let noflags: ~[Flag] = ~[];\n         if i >= lim { return {flags: move noflags, next: i}; }\n \n-        fn more_(f: Flag, s: ~str, i: uint, lim: uint) ->\n+        fn more(f: Flag, s: &str, i: uint, lim: uint) ->\n            {flags: ~[Flag], next: uint} {\n             let next = parse_flags(s, i + 1u, lim);\n             let rest = copy next.flags;\n             let j = next.next;\n             let curr: ~[Flag] = ~[f];\n             return {flags: vec::append(move curr, rest), next: j};\n         }\n-        let more = |x, copy s| more_(x, copy s, i, lim);\n+        // Unfortunate, but because s is borrowed, can't use a closure\n+     //   fn more(f: Flag, s: &str) { more_(f, s, i, lim); }\n         let f = s[i];\n         return if f == '-' as u8 {\n-                more(FlagLeftJustify)\n+                more(FlagLeftJustify, s, i, lim)\n             } else if f == '0' as u8 {\n-                more(FlagLeftZeroPad)\n+                more(FlagLeftZeroPad, s, i, lim)\n             } else if f == ' ' as u8 {\n-                more(FlagSpaceForSign)\n+                more(FlagSpaceForSign, s, i, lim)\n             } else if f == '+' as u8 {\n-                more(FlagSignAlways)\n+                more(FlagSignAlways, s, i, lim)\n             } else if f == '#' as u8 {\n-                more(FlagAlternate)\n+                more(FlagAlternate, s, i, lim)\n             } else { {flags: move noflags, next: i} };\n     }\n-    fn parse_count(s: ~str, i: uint, lim: uint)\n+    fn parse_count(s: &str, i: uint, lim: uint)\n         -> {count: Count, next: uint} {\n         return if i >= lim {\n                 {count: CountImplied, next: i}\n@@ -219,7 +220,7 @@ mod ct {\n                 }\n             };\n     }\n-    fn parse_precision(s: ~str, i: uint, lim: uint) ->\n+    fn parse_precision(s: &str, i: uint, lim: uint) ->\n        {count: Count, next: uint} {\n         return if i >= lim {\n                 {count: CountImplied, next: i}\n@@ -235,7 +236,7 @@ mod ct {\n                 }\n             } else { {count: CountImplied, next: i} };\n     }\n-    fn parse_type(s: ~str, i: uint, lim: uint, error: ErrorFn) ->\n+    fn parse_type(s: &str, i: uint, lim: uint, error: ErrorFn) ->\n        {ty: Ty, next: uint} {\n         if i >= lim { error(~\"missing type in conversion\"); }\n         let tstr = str::slice(s, i, i+1u);\n@@ -288,7 +289,7 @@ mod rt {\n     type Conv = {flags: u32, width: Count, precision: Count, ty: Ty};\n \n     pure fn conv_int(cv: Conv, i: int) -> ~str {\n-        let radix = 10u;\n+        let radix = 10;\n         let prec = get_int_precision(cv);\n         let mut s : ~str = int_to_str_prec(i, radix, prec);\n         if 0 <= i {\n@@ -350,8 +351,8 @@ mod rt {\n         }\n         return unsafe { pad(cv, s, PadFloat) };\n     }\n-    pure fn conv_poly<T>(cv: Conv, v: T) -> ~str {\n-        let s = sys::log_str(&v);\n+    pure fn conv_poly<T>(cv: Conv, v: &T) -> ~str {\n+        let s = sys::log_str(v);\n         return conv_str(cv, s);\n     }\n \n@@ -404,16 +405,17 @@ mod rt {\n         pure fn ne(other: &PadMode) -> bool { !self.eq(other) }\n     }\n \n-    fn pad(cv: Conv, &s: ~str, mode: PadMode) -> ~str {\n+    fn pad(cv: Conv, s: ~str, mode: PadMode) -> ~str {\n+        let mut s = move s; // sadtimes\n         let uwidth : uint = match cv.width {\n-          CountImplied => return copy s,\n+          CountImplied => return s,\n           CountIs(width) => {\n               // FIXME: width should probably be uint (see Issue #1996)\n               width as uint\n           }\n         };\n         let strlen = str::char_len(s);\n-        if uwidth <= strlen { return copy s; }\n+        if uwidth <= strlen { return s; }\n         let mut padchar = ' ';\n         let diff = uwidth - strlen;\n         if have_flag(cv.flags, flag_left_justify) {\n@@ -444,7 +446,7 @@ mod rt {\n         // zeros. It may make sense to convert zero padding to a precision\n         // instead.\n \n-        if signed && zero_padding && str::len(s) > 0u {\n+        if signed && zero_padding && s.len() > 0 {\n             let head = str::shift_char(&mut s);\n             if head == '+' || head == '-' || head == ' ' {\n                 let headstr = str::from_chars(vec::from_elem(1u, head));\n@@ -461,7 +463,12 @@ mod rt {\n     }\n }\n \n-// XXX remove after snapshots\n+// Remove after snapshot\n+\n+// Functions used by the fmt extension at runtime. For now there are a lot of\n+// decisions made a runtime. If it proves worthwhile then some of these\n+// conditions can be evaluated at compile-time. For now though it's cleaner to\n+// implement it 0this way, I think.\n mod rt2 {\n     #[legacy_exports];\n     const flag_none : u32 = 0u32;\n@@ -477,7 +484,7 @@ mod rt2 {\n     type Conv = {flags: u32, width: Count, precision: Count, ty: Ty};\n \n     pure fn conv_int(cv: Conv, i: int) -> ~str {\n-        let radix = 10u;\n+        let radix = 10;\n         let prec = get_int_precision(cv);\n         let mut s : ~str = int_to_str_prec(i, radix, prec);\n         if 0 <= i {\n@@ -539,8 +546,8 @@ mod rt2 {\n         }\n         return unsafe { pad(cv, s, PadFloat) };\n     }\n-    pure fn conv_poly<T>(cv: Conv, v: T) -> ~str {\n-        let s = sys::log_str(&v);\n+    pure fn conv_poly<T>(cv: Conv, v: &T) -> ~str {\n+        let s = sys::log_str(v);\n         return conv_str(cv, s);\n     }\n \n@@ -593,16 +600,17 @@ mod rt2 {\n         pure fn ne(other: &PadMode) -> bool { !self.eq(other) }\n     }\n \n-    fn pad(cv: Conv, &s: ~str, mode: PadMode) -> ~str {\n+    fn pad(cv: Conv, s: ~str, mode: PadMode) -> ~str {\n+        let mut s = move s; // sadtimes\n         let uwidth : uint = match cv.width {\n-          CountImplied => return copy s,\n+          CountImplied => return s,\n           CountIs(width) => {\n               // FIXME: width should probably be uint (see Issue #1996)\n               width as uint\n           }\n         };\n         let strlen = str::char_len(s);\n-        if uwidth <= strlen { return copy s; }\n+        if uwidth <= strlen { return s; }\n         let mut padchar = ' ';\n         let diff = uwidth - strlen;\n         if have_flag(cv.flags, flag_left_justify) {\n@@ -633,7 +641,7 @@ mod rt2 {\n         // zeros. It may make sense to convert zero padding to a precision\n         // instead.\n \n-        if signed && zero_padding && str::len(s) > 0u {\n+        if signed && zero_padding && s.len() > 0 {\n             let head = str::shift_char(&mut s);\n             if head == '+' || head == '-' || head == ' ' {\n                 let headstr = str::from_chars(vec::from_elem(1u, head));"}, {"sha": "ec0e66734fa394a493dee4f2087eed24dd79f399", "filename": "src/libcore/f32.rs", "status": "modified", "additions": 45, "deletions": 64, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ff32.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -4,76 +4,59 @@\n \n //! Operations and constants for `f32`\n \n-// PORT\n-\n-use cmath::c_float::*;\n-use cmath::c_float_targ_consts::*;\n-\n-export add, sub, mul, div, rem, lt, le, eq, ne, ge, gt;\n-export is_positive, is_negative, is_nonpositive, is_nonnegative;\n-export is_zero, is_infinite, is_finite;\n-export NaN, is_NaN, infinity, neg_infinity;\n-export consts;\n-export logarithm;\n-export acos, asin, atan, atan2, cbrt, ceil, copysign, cos, cosh, floor;\n-export erf, erfc, exp, expm1, exp2, abs, abs_sub;\n-export mul_add, fmax, fmin, nextafter, frexp, hypot, ldexp;\n-export lgamma, ln, log_radix, ln1p, log10, log2, ilog_radix;\n-export modf, pow, round, sin, sinh, sqrt, tan, tanh, tgamma, trunc;\n-export signbit;\n-\n-export num;\n+pub use cmath::c_float::*;\n+pub use cmath::c_float_targ_consts::*;\n \n // These are not defined inside consts:: for consistency with\n // the integer types\n \n-const NaN: f32 = 0.0_f32/0.0_f32;\n+pub const NaN: f32 = 0.0_f32/0.0_f32;\n \n-const infinity: f32 = 1.0_f32/0.0_f32;\n+pub const infinity: f32 = 1.0_f32/0.0_f32;\n \n-const neg_infinity: f32 = -1.0_f32/0.0_f32;\n+pub const neg_infinity: f32 = -1.0_f32/0.0_f32;\n \n-pure fn is_NaN(f: f32) -> bool { f != f }\n+pub pure fn is_NaN(f: f32) -> bool { f != f }\n \n-pure fn add(x: f32, y: f32) -> f32 { return x + y; }\n+pub pure fn add(x: f32, y: f32) -> f32 { return x + y; }\n \n-pure fn sub(x: f32, y: f32) -> f32 { return x - y; }\n+pub pure fn sub(x: f32, y: f32) -> f32 { return x - y; }\n \n-pure fn mul(x: f32, y: f32) -> f32 { return x * y; }\n+pub pure fn mul(x: f32, y: f32) -> f32 { return x * y; }\n \n-pure fn div(x: f32, y: f32) -> f32 { return x / y; }\n+pub pure fn div(x: f32, y: f32) -> f32 { return x / y; }\n \n-pure fn rem(x: f32, y: f32) -> f32 { return x % y; }\n+pub pure fn rem(x: f32, y: f32) -> f32 { return x % y; }\n \n-pure fn lt(x: f32, y: f32) -> bool { return x < y; }\n+pub pure fn lt(x: f32, y: f32) -> bool { return x < y; }\n \n-pure fn le(x: f32, y: f32) -> bool { return x <= y; }\n+pub pure fn le(x: f32, y: f32) -> bool { return x <= y; }\n \n-pure fn eq(x: f32, y: f32) -> bool { return x == y; }\n+pub pure fn eq(x: f32, y: f32) -> bool { return x == y; }\n \n-pure fn ne(x: f32, y: f32) -> bool { return x != y; }\n+pub pure fn ne(x: f32, y: f32) -> bool { return x != y; }\n \n-pure fn ge(x: f32, y: f32) -> bool { return x >= y; }\n+pub pure fn ge(x: f32, y: f32) -> bool { return x >= y; }\n \n-pure fn gt(x: f32, y: f32) -> bool { return x > y; }\n+pub pure fn gt(x: f32, y: f32) -> bool { return x > y; }\n \n // FIXME (#1999): replace the predicates below with llvm intrinsics or\n // calls to the libmath macros in the rust runtime for performance.\n \n /// Returns true if `x` is a positive number, including +0.0f320 and +Infinity\n-pure fn is_positive(x: f32) -> bool\n+pub pure fn is_positive(x: f32) -> bool\n     { return x > 0.0f32 || (1.0f32/x) == infinity; }\n \n /// Returns true if `x` is a negative number, including -0.0f320 and -Infinity\n-pure fn is_negative(x: f32) -> bool\n+pub pure fn is_negative(x: f32) -> bool\n     { return x < 0.0f32 || (1.0f32/x) == neg_infinity; }\n \n /**\n  * Returns true if `x` is a negative number, including -0.0f320 and -Infinity\n  *\n  * This is the same as `f32::is_negative`.\n  */\n-pure fn is_nonpositive(x: f32) -> bool {\n+pub pure fn is_nonpositive(x: f32) -> bool {\n   return x < 0.0f32 || (1.0f32/x) == neg_infinity;\n }\n \n@@ -82,87 +65,85 @@ pure fn is_nonpositive(x: f32) -> bool {\n  *\n  * This is the same as `f32::is_positive`.)\n  */\n-pure fn is_nonnegative(x: f32) -> bool {\n+pub pure fn is_nonnegative(x: f32) -> bool {\n   return x > 0.0f32 || (1.0f32/x) == infinity;\n }\n \n /// Returns true if `x` is a zero number (positive or negative zero)\n-pure fn is_zero(x: f32) -> bool {\n+pub pure fn is_zero(x: f32) -> bool {\n     return x == 0.0f32 || x == -0.0f32;\n }\n \n /// Returns true if `x`is an infinite number\n-pure fn is_infinite(x: f32) -> bool {\n+pub pure fn is_infinite(x: f32) -> bool {\n     return x == infinity || x == neg_infinity;\n }\n \n /// Returns true if `x`is a finite number\n-pure fn is_finite(x: f32) -> bool {\n+pub pure fn is_finite(x: f32) -> bool {\n     return !(is_NaN(x) || is_infinite(x));\n }\n \n // FIXME (#1999): add is_normal, is_subnormal, and fpclassify.\n \n /* Module: consts */\n-mod consts {\n-    #[legacy_exports];\n-\n+pub mod consts {\n     // FIXME (requires Issue #1433 to fix): replace with mathematical\n     // constants from cmath.\n     /// Archimedes' constant\n-    const pi: f32 = 3.14159265358979323846264338327950288_f32;\n+    pub const pi: f32 = 3.14159265358979323846264338327950288_f32;\n \n     /// pi/2.0\n-    const frac_pi_2: f32 = 1.57079632679489661923132169163975144_f32;\n+    pub const frac_pi_2: f32 = 1.57079632679489661923132169163975144_f32;\n \n     /// pi/4.0\n-    const frac_pi_4: f32 = 0.785398163397448309615660845819875721_f32;\n+    pub const frac_pi_4: f32 = 0.785398163397448309615660845819875721_f32;\n \n     /// 1.0/pi\n-    const frac_1_pi: f32 = 0.318309886183790671537767526745028724_f32;\n+    pub const frac_1_pi: f32 = 0.318309886183790671537767526745028724_f32;\n \n     /// 2.0/pi\n-    const frac_2_pi: f32 = 0.636619772367581343075535053490057448_f32;\n+    pub const frac_2_pi: f32 = 0.636619772367581343075535053490057448_f32;\n \n     /// 2.0/sqrt(pi)\n-    const frac_2_sqrtpi: f32 = 1.12837916709551257389615890312154517_f32;\n+    pub const frac_2_sqrtpi: f32 = 1.12837916709551257389615890312154517_f32;\n \n     /// sqrt(2.0)\n-    const sqrt2: f32 = 1.41421356237309504880168872420969808_f32;\n+    pub const sqrt2: f32 = 1.41421356237309504880168872420969808_f32;\n \n     /// 1.0/sqrt(2.0)\n-    const frac_1_sqrt2: f32 = 0.707106781186547524400844362104849039_f32;\n+    pub const frac_1_sqrt2: f32 = 0.707106781186547524400844362104849039_f32;\n \n     /// Euler's number\n-    const e: f32 = 2.71828182845904523536028747135266250_f32;\n+    pub const e: f32 = 2.71828182845904523536028747135266250_f32;\n \n     /// log2(e)\n-    const log2_e: f32 = 1.44269504088896340735992468100189214_f32;\n+    pub const log2_e: f32 = 1.44269504088896340735992468100189214_f32;\n \n     /// log10(e)\n-    const log10_e: f32 = 0.434294481903251827651128918916605082_f32;\n+    pub const log10_e: f32 = 0.434294481903251827651128918916605082_f32;\n \n     /// ln(2.0)\n-    const ln_2: f32 = 0.693147180559945309417232121458176568_f32;\n+    pub const ln_2: f32 = 0.693147180559945309417232121458176568_f32;\n \n     /// ln(10.0)\n-    const ln_10: f32 = 2.30258509299404568401799145468436421_f32;\n+    pub const ln_10: f32 = 2.30258509299404568401799145468436421_f32;\n }\n \n-pure fn signbit(x: f32) -> int {\n+pub pure fn signbit(x: f32) -> int {\n     if is_negative(x) { return 1; } else { return 0; }\n }\n \n-pure fn logarithm(n: f32, b: f32) -> f32 {\n+pub pure fn logarithm(n: f32, b: f32) -> f32 {\n     return log2(n) / log2(b);\n }\n \n impl f32: num::Num {\n-    pure fn add(&&other: f32)    -> f32 { return self + other; }\n-    pure fn sub(&&other: f32)    -> f32 { return self - other; }\n-    pure fn mul(&&other: f32)    -> f32 { return self * other; }\n-    pure fn div(&&other: f32)    -> f32 { return self / other; }\n-    pure fn modulo(&&other: f32) -> f32 { return self % other; }\n+    pure fn add(other: &f32)    -> f32 { return self + *other; }\n+    pure fn sub(other: &f32)    -> f32 { return self - *other; }\n+    pure fn mul(other: &f32)    -> f32 { return self * *other; }\n+    pure fn div(other: &f32)    -> f32 { return self / *other; }\n+    pure fn modulo(other: &f32) -> f32 { return self % *other; }\n     pure fn neg()                -> f32 { return -self;        }\n \n     pure fn to_int()         -> int { return self as int; }"}, {"sha": "731d369649b16293d84747f84b7fbe3b59ec13ec", "filename": "src/libcore/f64.rs", "status": "modified", "additions": 58, "deletions": 85, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ff64.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -4,103 +4,78 @@\n \n //! Operations and constants for `f64`\n \n-// PORT\n-\n-use cmath::c_double::*;\n-use cmath::c_double_targ_consts::*;\n-\n-// Even though this module exports everything defined in it,\n-// because it contains re-exports, we also have to explicitly\n-// export locally defined things. That's a bit annoying.\n-export add, sub, mul, div, rem, lt, le, eq, ne, ge, gt;\n-export is_positive, is_negative, is_nonpositive, is_nonnegative;\n-export is_zero, is_infinite, is_finite;\n-export NaN, is_NaN, infinity, neg_infinity;\n-export consts;\n-export logarithm;\n-export acos, asin, atan, atan2, cbrt, ceil, copysign, cos, cosh, floor;\n-export erf, erfc, exp, expm1, exp2, abs, abs_sub;\n-export mul_add, fmax, fmin, nextafter, frexp, hypot, ldexp;\n-export lgamma, ln, log_radix, ln1p, log10, log2, ilog_radix;\n-export modf, pow, round, sin, sinh, sqrt, tan, tanh, tgamma, trunc;\n-export signbit;\n-export epsilon;\n-\n-export j0, j1, jn, y0, y1, yn;\n-\n-export num;\n+pub use cmath::c_double::*;\n+pub use cmath::c_double_targ_consts::*;\n+\n+// FIXME (#1433): obtain these in a different way\n \n // These are not defined inside consts:: for consistency with\n // the integer types\n \n-// PORT check per architecture\n-\n-// FIXME (#1433): obtain these in a different way\n-\n-const radix: uint = 2u;\n+pub const radix: uint = 2u;\n \n-const mantissa_digits: uint = 53u;\n-const digits: uint = 15u;\n+pub const mantissa_digits: uint = 53u;\n+pub const digits: uint = 15u;\n \n-const epsilon: f64 = 2.2204460492503131e-16_f64;\n+pub const epsilon: f64 = 2.2204460492503131e-16_f64;\n \n-const min_value: f64 = 2.2250738585072014e-308_f64;\n-const max_value: f64 = 1.7976931348623157e+308_f64;\n+pub const min_value: f64 = 2.2250738585072014e-308_f64;\n+pub const max_value: f64 = 1.7976931348623157e+308_f64;\n \n-const min_exp: int = -1021;\n-const max_exp: int = 1024;\n+pub const min_exp: int = -1021;\n+pub const max_exp: int = 1024;\n \n-const min_10_exp: int = -307;\n-const max_10_exp: int = 308;\n+pub const min_10_exp: int = -307;\n+pub const max_10_exp: int = 308;\n \n-const NaN: f64 = 0.0_f64/0.0_f64;\n+pub const NaN: f64 = 0.0_f64/0.0_f64;\n \n-const infinity: f64 = 1.0_f64/0.0_f64;\n+pub const infinity: f64 = 1.0_f64/0.0_f64;\n \n-const neg_infinity: f64 = -1.0_f64/0.0_f64;\n+pub const neg_infinity: f64 = -1.0_f64/0.0_f64;\n \n-pure fn is_NaN(f: f64) -> bool { f != f }\n+pub pure fn is_NaN(f: f64) -> bool { f != f }\n \n-pure fn add(x: f64, y: f64) -> f64 { return x + y; }\n+pub pure fn add(x: f64, y: f64) -> f64 { return x + y; }\n \n-pure fn sub(x: f64, y: f64) -> f64 { return x - y; }\n+pub pure fn sub(x: f64, y: f64) -> f64 { return x - y; }\n \n-pure fn mul(x: f64, y: f64) -> f64 { return x * y; }\n+pub pure fn mul(x: f64, y: f64) -> f64 { return x * y; }\n \n-pure fn div(x: f64, y: f64) -> f64 { return x / y; }\n+pub pure fn div(x: f64, y: f64) -> f64 { return x / y; }\n \n-pure fn rem(x: f64, y: f64) -> f64 { return x % y; }\n+pub pure fn rem(x: f64, y: f64) -> f64 { return x % y; }\n \n-pure fn lt(x: f64, y: f64) -> bool { return x < y; }\n+pub pure fn lt(x: f64, y: f64) -> bool { return x < y; }\n \n-pure fn le(x: f64, y: f64) -> bool { return x <= y; }\n+pub pure fn le(x: f64, y: f64) -> bool { return x <= y; }\n \n-pure fn eq(x: f64, y: f64) -> bool { return x == y; }\n+pub pure fn eq(x: f64, y: f64) -> bool { return x == y; }\n \n-pure fn ne(x: f64, y: f64) -> bool { return x != y; }\n+pub pure fn ne(x: f64, y: f64) -> bool { return x != y; }\n \n-pure fn ge(x: f64, y: f64) -> bool { return x >= y; }\n+pub pure fn ge(x: f64, y: f64) -> bool { return x >= y; }\n \n-pure fn gt(x: f64, y: f64) -> bool { return x > y; }\n+pub pure fn gt(x: f64, y: f64) -> bool { return x > y; }\n \n-pure fn sqrt(x: f64) -> f64 {\n+pub pure fn sqrt(x: f64) -> f64 {\n     cmath::c_double::sqrt(x as libc::c_double) as f64\n }\n \n /// Returns true if `x` is a positive number, including +0.0f640 and +Infinity\n-pure fn is_positive(x: f64) -> bool\n+pub pure fn is_positive(x: f64) -> bool\n     { return x > 0.0f64 || (1.0f64/x) == infinity; }\n \n /// Returns true if `x` is a negative number, including -0.0f640 and -Infinity\n-pure fn is_negative(x: f64) -> bool\n+pub pure fn is_negative(x: f64) -> bool\n     { return x < 0.0f64 || (1.0f64/x) == neg_infinity; }\n \n /**\n  * Returns true if `x` is a negative number, including -0.0f640 and -Infinity\n  *\n  * This is the same as `f64::is_negative`.\n  */\n-pure fn is_nonpositive(x: f64) -> bool {\n+pub pure fn is_nonpositive(x: f64) -> bool {\n   return x < 0.0f64 || (1.0f64/x) == neg_infinity;\n }\n \n@@ -109,87 +84,85 @@ pure fn is_nonpositive(x: f64) -> bool {\n  *\n  * This is the same as `f64::positive`.\n  */\n-pure fn is_nonnegative(x: f64) -> bool {\n+pub pure fn is_nonnegative(x: f64) -> bool {\n   return x > 0.0f64 || (1.0f64/x) == infinity;\n }\n \n /// Returns true if `x` is a zero number (positive or negative zero)\n-pure fn is_zero(x: f64) -> bool {\n+pub pure fn is_zero(x: f64) -> bool {\n     return x == 0.0f64 || x == -0.0f64;\n }\n \n /// Returns true if `x`is an infinite number\n-pure fn is_infinite(x: f64) -> bool {\n+pub pure fn is_infinite(x: f64) -> bool {\n     return x == infinity || x == neg_infinity;\n }\n \n /// Returns true if `x`is a finite number\n-pure fn is_finite(x: f64) -> bool {\n+pub pure fn is_finite(x: f64) -> bool {\n     return !(is_NaN(x) || is_infinite(x));\n }\n \n // FIXME (#1999): add is_normal, is_subnormal, and fpclassify\n \n /* Module: consts */\n-mod consts {\n-    #[legacy_exports];\n-\n+pub mod consts {\n     // FIXME (requires Issue #1433 to fix): replace with mathematical\n     // constants from cmath.\n     /// Archimedes' constant\n-    const pi: f64 = 3.14159265358979323846264338327950288_f64;\n+    pub const pi: f64 = 3.14159265358979323846264338327950288_f64;\n \n     /// pi/2.0\n-    const frac_pi_2: f64 = 1.57079632679489661923132169163975144_f64;\n+    pub const frac_pi_2: f64 = 1.57079632679489661923132169163975144_f64;\n \n     /// pi/4.0\n-    const frac_pi_4: f64 = 0.785398163397448309615660845819875721_f64;\n+    pub const frac_pi_4: f64 = 0.785398163397448309615660845819875721_f64;\n \n     /// 1.0/pi\n-    const frac_1_pi: f64 = 0.318309886183790671537767526745028724_f64;\n+    pub const frac_1_pi: f64 = 0.318309886183790671537767526745028724_f64;\n \n     /// 2.0/pi\n-    const frac_2_pi: f64 = 0.636619772367581343075535053490057448_f64;\n+    pub const frac_2_pi: f64 = 0.636619772367581343075535053490057448_f64;\n \n     /// 2.0/sqrt(pi)\n-    const frac_2_sqrtpi: f64 = 1.12837916709551257389615890312154517_f64;\n+    pub const frac_2_sqrtpi: f64 = 1.12837916709551257389615890312154517_f64;\n \n     /// sqrt(2.0)\n-    const sqrt2: f64 = 1.41421356237309504880168872420969808_f64;\n+    pub const sqrt2: f64 = 1.41421356237309504880168872420969808_f64;\n \n     /// 1.0/sqrt(2.0)\n-    const frac_1_sqrt2: f64 = 0.707106781186547524400844362104849039_f64;\n+    pub const frac_1_sqrt2: f64 = 0.707106781186547524400844362104849039_f64;\n \n     /// Euler's number\n-    const e: f64 = 2.71828182845904523536028747135266250_f64;\n+    pub const e: f64 = 2.71828182845904523536028747135266250_f64;\n \n     /// log2(e)\n-    const log2_e: f64 = 1.44269504088896340735992468100189214_f64;\n+    pub const log2_e: f64 = 1.44269504088896340735992468100189214_f64;\n \n     /// log10(e)\n-    const log10_e: f64 = 0.434294481903251827651128918916605082_f64;\n+    pub const log10_e: f64 = 0.434294481903251827651128918916605082_f64;\n \n     /// ln(2.0)\n-    const ln_2: f64 = 0.693147180559945309417232121458176568_f64;\n+    pub const ln_2: f64 = 0.693147180559945309417232121458176568_f64;\n \n     /// ln(10.0)\n-    const ln_10: f64 = 2.30258509299404568401799145468436421_f64;\n+    pub const ln_10: f64 = 2.30258509299404568401799145468436421_f64;\n }\n \n-pure fn signbit(x: f64) -> int {\n+pub pure fn signbit(x: f64) -> int {\n     if is_negative(x) { return 1; } else { return 0; }\n }\n \n-pure fn logarithm(n: f64, b: f64) -> f64 {\n+pub pure fn logarithm(n: f64, b: f64) -> f64 {\n     return log2(n) / log2(b);\n }\n \n impl f64: num::Num {\n-    pure fn add(&&other: f64)    -> f64 { return self + other; }\n-    pure fn sub(&&other: f64)    -> f64 { return self - other; }\n-    pure fn mul(&&other: f64)    -> f64 { return self * other; }\n-    pure fn div(&&other: f64)    -> f64 { return self / other; }\n-    pure fn modulo(&&other: f64) -> f64 { return self % other; }\n+    pure fn add(other: &f64)    -> f64 { return self + *other; }\n+    pure fn sub(other: &f64)    -> f64 { return self - *other; }\n+    pure fn mul(other: &f64)    -> f64 { return self * *other; }\n+    pure fn div(other: &f64)    -> f64 { return self / *other; }\n+    pure fn modulo(other: &f64) -> f64 { return self % *other; }\n     pure fn neg()                -> f64 { return -self;        }\n \n     pure fn to_int()         -> int { return self as int; }"}, {"sha": "7c5176494a2243d6631da5ad463dd8b9523cea02", "filename": "src/libcore/flate.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fflate.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -11,8 +11,6 @@ Simple compression\n use libc::{c_void, size_t, c_int};\n \n extern mod rustrt {\n-    #[legacy_exports];\n-\n     fn tdefl_compress_mem_to_heap(psrc_buf: *const c_void,\n                                   src_buf_len: size_t,\n                                   pout_len: *size_t,\n@@ -29,14 +27,14 @@ const lz_fast : c_int = 0x1;   // LZ with only one probe\n const lz_norm : c_int = 0x80;  // LZ with 128 probes, \"normal\"\n const lz_best : c_int = 0xfff; // LZ with 4095 probes, \"best\"\n \n-fn deflate_bytes(bytes: &[const u8]) -> ~[u8] {\n+pub fn deflate_bytes(bytes: &[const u8]) -> ~[u8] {\n     do vec::as_const_buf(bytes) |b, len| {\n         unsafe {\n             let mut outsz : size_t = 0;\n             let res =\n                 rustrt::tdefl_compress_mem_to_heap(b as *c_void,\n                                                    len as size_t,\n-                                                   ptr::addr_of(outsz),\n+                                                   ptr::addr_of(&outsz),\n                                                    lz_norm);\n             assert res as int != 0;\n             let out = vec::raw::from_buf(res as *u8,\n@@ -47,14 +45,14 @@ fn deflate_bytes(bytes: &[const u8]) -> ~[u8] {\n     }\n }\n \n-fn inflate_bytes(bytes: &[const u8]) -> ~[u8] {\n+pub fn inflate_bytes(bytes: &[const u8]) -> ~[u8] {\n     do vec::as_const_buf(bytes) |b, len| {\n         unsafe {\n             let mut outsz : size_t = 0;\n             let res =\n                 rustrt::tinfl_decompress_mem_to_heap(b as *c_void,\n                                                      len as size_t,\n-                                                     ptr::addr_of(outsz),\n+                                                     ptr::addr_of(&outsz),\n                                                      0);\n             assert res as int != 0;\n             let out = vec::raw::from_buf(res as *u8,\n@@ -71,12 +69,12 @@ fn test_flate_round_trip() {\n     let r = rand::Rng();\n     let mut words = ~[];\n     for 20.times {\n-        vec::push(words, r.gen_bytes(r.gen_uint_range(1, 10)));\n+        words.push(r.gen_bytes(r.gen_uint_range(1, 10)));\n     }\n     for 20.times {\n         let mut in = ~[];\n         for 2000.times {\n-            vec::push_all(in, r.choose(words));\n+            in.push_all(r.choose(words));\n         }\n         debug!(\"de/inflate of %u bytes of random word-sequences\",\n                in.len());"}, {"sha": "098e82f5fad7ad58498545b4b015d3cd08578103", "filename": "src/libcore/float.rs", "status": "modified", "additions": 72, "deletions": 90, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffloat.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -7,26 +7,10 @@\n // Even though this module exports everything defined in it,\n // because it contains re-exports, we also have to explicitly\n // export locally defined things. That's a bit annoying.\n-export to_str_common, to_str_exact, to_str, from_str;\n-export add, sub, mul, div, rem, lt, le, eq, ne, ge, gt;\n-export is_positive, is_negative, is_nonpositive, is_nonnegative;\n-export is_zero, is_infinite, is_finite;\n-export NaN, is_NaN, infinity, neg_infinity;\n-export consts;\n-export logarithm;\n-export acos, asin, atan, atan2, cbrt, ceil, copysign, cos, cosh, floor;\n-export erf, erfc, exp, expm1, exp2, abs, abs_sub;\n-export mul_add, fmax, fmin, nextafter, frexp, hypot, ldexp;\n-export lgamma, ln, log_radix, ln1p, log10, log2, ilog_radix;\n-export modf, pow, round, sin, sinh, sqrt, tan, tanh, tgamma, trunc;\n-export signbit;\n-export pow_with_uint;\n-\n-export num;\n+\n \n // export when m_float == c_double\n \n-export j0, j1, jn, y0, y1, yn;\n \n // PORT this must match in width according to architecture\n \n@@ -44,56 +28,54 @@ use f64::{j0, j1, jn, y0, y1, yn};\n use cmp::{Eq, Ord};\n use num::from_int;\n \n-const NaN: float = 0.0/0.0;\n+pub const NaN: float = 0.0/0.0;\n \n-const infinity: float = 1.0/0.0;\n+pub const infinity: float = 1.0/0.0;\n \n-const neg_infinity: float = -1.0/0.0;\n+pub const neg_infinity: float = -1.0/0.0;\n \n /* Module: consts */\n-mod consts {\n-    #[legacy_exports];\n-\n+pub mod consts {\n     // FIXME (requires Issue #1433 to fix): replace with mathematical\n     // constants from cmath.\n     /// Archimedes' constant\n-    const pi: float = 3.14159265358979323846264338327950288;\n+    pub const pi: float = 3.14159265358979323846264338327950288;\n \n     /// pi/2.0\n-    const frac_pi_2: float = 1.57079632679489661923132169163975144;\n+    pub const frac_pi_2: float = 1.57079632679489661923132169163975144;\n \n     /// pi/4.0\n-    const frac_pi_4: float = 0.785398163397448309615660845819875721;\n+    pub const frac_pi_4: float = 0.785398163397448309615660845819875721;\n \n     /// 1.0/pi\n-    const frac_1_pi: float = 0.318309886183790671537767526745028724;\n+    pub const frac_1_pi: float = 0.318309886183790671537767526745028724;\n \n     /// 2.0/pi\n-    const frac_2_pi: float = 0.636619772367581343075535053490057448;\n+    pub const frac_2_pi: float = 0.636619772367581343075535053490057448;\n \n     /// 2.0/sqrt(pi)\n-    const frac_2_sqrtpi: float = 1.12837916709551257389615890312154517;\n+    pub const frac_2_sqrtpi: float = 1.12837916709551257389615890312154517;\n \n     /// sqrt(2.0)\n-    const sqrt2: float = 1.41421356237309504880168872420969808;\n+    pub const sqrt2: float = 1.41421356237309504880168872420969808;\n \n     /// 1.0/sqrt(2.0)\n-    const frac_1_sqrt2: float = 0.707106781186547524400844362104849039;\n+    pub const frac_1_sqrt2: float = 0.707106781186547524400844362104849039;\n \n     /// Euler's number\n-    const e: float = 2.71828182845904523536028747135266250;\n+    pub const e: float = 2.71828182845904523536028747135266250;\n \n     /// log2(e)\n-    const log2_e: float = 1.44269504088896340735992468100189214;\n+    pub const log2_e: float = 1.44269504088896340735992468100189214;\n \n     /// log10(e)\n-    const log10_e: float = 0.434294481903251827651128918916605082;\n+    pub const log10_e: float = 0.434294481903251827651128918916605082;\n \n     /// ln(2.0)\n-    const ln_2: float = 0.693147180559945309417232121458176568;\n+    pub const ln_2: float = 0.693147180559945309417232121458176568;\n \n     /// ln(10.0)\n-    const ln_10: float = 2.30258509299404568401799145468436421;\n+    pub const ln_10: float = 2.30258509299404568401799145468436421;\n }\n \n /**\n@@ -109,7 +91,7 @@ mod consts {\n  * * digits - The number of significant digits\n  * * exact - Whether to enforce the exact number of significant digits\n  */\n-fn to_str_common(num: float, digits: uint, exact: bool) -> ~str {\n+pub fn to_str_common(num: float, digits: uint, exact: bool) -> ~str {\n     if is_NaN(num) { return ~\"NaN\"; }\n     if num == infinity { return ~\"inf\"; }\n     if num == neg_infinity { return ~\"-inf\"; }\n@@ -139,11 +121,11 @@ fn to_str_common(num: float, digits: uint, exact: bool) -> ~str {\n \n     // while we still need digits\n     // build stack of digits\n-    while ii > 0u && (frac >= epsilon_prime || exact) {\n+    while ii > 0 && (frac >= epsilon_prime || exact) {\n         // store the next digit\n         frac *= 10.0;\n         let digit = frac as uint;\n-        vec::push(fractionalParts, digit);\n+        fractionalParts.push(digit);\n \n         // calculate the next frac\n         frac -= digit as float;\n@@ -153,25 +135,25 @@ fn to_str_common(num: float, digits: uint, exact: bool) -> ~str {\n \n     let mut acc;\n     let mut racc = ~\"\";\n-    let mut carry = if frac * 10.0 as uint >= 5u { 1u } else { 0u };\n+    let mut carry = if frac * 10.0 as uint >= 5 { 1 } else { 0 };\n \n     // turn digits into string\n     // using stack of digits\n-    while vec::len(fractionalParts) > 0u {\n-        let mut adjusted_digit = carry + vec::pop(fractionalParts);\n+    while fractionalParts.is_not_empty() {\n+        let mut adjusted_digit = carry + fractionalParts.pop();\n \n-        if adjusted_digit == 10u {\n-            carry = 1u;\n-            adjusted_digit %= 10u\n+        if adjusted_digit == 10 {\n+            carry = 1;\n+            adjusted_digit %= 10\n         } else {\n-            carry = 0u\n+            carry = 0;\n         };\n \n         racc = uint::str(adjusted_digit) + racc;\n     }\n \n     // pad decimals with trailing zeroes\n-    while str::len(racc) < digits && exact {\n+    while racc.len() < digits && exact {\n         racc += ~\"0\"\n     }\n \n@@ -194,12 +176,12 @@ fn to_str_common(num: float, digits: uint, exact: bool) -> ~str {\n  * * num - The float value\n  * * digits - The number of significant digits\n  */\n-fn to_str_exact(num: float, digits: uint) -> ~str {\n+pub fn to_str_exact(num: float, digits: uint) -> ~str {\n     to_str_common(num, digits, true)\n }\n \n #[test]\n-fn test_to_str_exact_do_decimal() {\n+pub fn test_to_str_exact_do_decimal() {\n     let s = to_str_exact(5.0, 4u);\n     assert s == ~\"5.0000\";\n }\n@@ -214,7 +196,7 @@ fn test_to_str_exact_do_decimal() {\n  * * num - The float value\n  * * digits - The number of significant digits\n  */\n-fn to_str(num: float, digits: uint) -> ~str {\n+pub fn to_str(num: float, digits: uint) -> ~str {\n     to_str_common(num, digits, false)\n }\n \n@@ -244,7 +226,7 @@ fn to_str(num: float, digits: uint) -> ~str {\n  * `none` if the string did not represent a valid number.  Otherwise,\n  * `Some(n)` where `n` is the floating-point number represented by `[num]`.\n  */\n-fn from_str(num: &str) -> Option<float> {\n+pub fn from_str(num: &str) -> Option<float> {\n    if num == \"inf\" {\n        return Some(infinity as float);\n    } else if num == \"-inf\" {\n@@ -379,7 +361,7 @@ fn from_str(num: &str) -> Option<float> {\n  *\n  * `NaN` if both `x` and `pow` are `0u`, otherwise `x^pow`\n  */\n-fn pow_with_uint(base: uint, pow: uint) -> float {\n+pub fn pow_with_uint(base: uint, pow: uint) -> float {\n     if base == 0u {\n         if pow == 0u {\n             return NaN as float;\n@@ -399,48 +381,48 @@ fn pow_with_uint(base: uint, pow: uint) -> float {\n     return total;\n }\n \n-pure fn is_positive(x: float) -> bool { f64::is_positive(x as f64) }\n-pure fn is_negative(x: float) -> bool { f64::is_negative(x as f64) }\n-pure fn is_nonpositive(x: float) -> bool { f64::is_nonpositive(x as f64) }\n-pure fn is_nonnegative(x: float) -> bool { f64::is_nonnegative(x as f64) }\n-pure fn is_zero(x: float) -> bool { f64::is_zero(x as f64) }\n-pure fn is_infinite(x: float) -> bool { f64::is_infinite(x as f64) }\n-pure fn is_finite(x: float) -> bool { f64::is_finite(x as f64) }\n-pure fn is_NaN(x: float) -> bool { f64::is_NaN(x as f64) }\n-\n-pure fn abs(x: float) -> float { f64::abs(x as f64) as float }\n-pure fn sqrt(x: float) -> float { f64::sqrt(x as f64) as float }\n-pure fn atan(x: float) -> float { f64::atan(x as f64) as float }\n-pure fn sin(x: float) -> float { f64::sin(x as f64) as float }\n-pure fn cos(x: float) -> float { f64::cos(x as f64) as float }\n-pure fn tan(x: float) -> float { f64::tan(x as f64) as float }\n+pub pure fn is_positive(x: float) -> bool { f64::is_positive(x as f64) }\n+pub pure fn is_negative(x: float) -> bool { f64::is_negative(x as f64) }\n+pub pure fn is_nonpositive(x: float) -> bool { f64::is_nonpositive(x as f64) }\n+pub pure fn is_nonnegative(x: float) -> bool { f64::is_nonnegative(x as f64) }\n+pub pure fn is_zero(x: float) -> bool { f64::is_zero(x as f64) }\n+pub pure fn is_infinite(x: float) -> bool { f64::is_infinite(x as f64) }\n+pub pure fn is_finite(x: float) -> bool { f64::is_finite(x as f64) }\n+pub pure fn is_NaN(x: float) -> bool { f64::is_NaN(x as f64) }\n+\n+pub pure fn abs(x: float) -> float { f64::abs(x as f64) as float }\n+pub pure fn sqrt(x: float) -> float { f64::sqrt(x as f64) as float }\n+pub pure fn atan(x: float) -> float { f64::atan(x as f64) as float }\n+pub pure fn sin(x: float) -> float { f64::sin(x as f64) as float }\n+pub pure fn cos(x: float) -> float { f64::cos(x as f64) as float }\n+pub pure fn tan(x: float) -> float { f64::tan(x as f64) as float }\n \n impl float : Eq {\n-    pure fn eq(other: &float) -> bool { self == (*other) }\n-    pure fn ne(other: &float) -> bool { self != (*other) }\n+    pub pure fn eq(other: &float) -> bool { self == (*other) }\n+    pub pure fn ne(other: &float) -> bool { self != (*other) }\n }\n \n impl float : Ord {\n-    pure fn lt(other: &float) -> bool { self < (*other) }\n-    pure fn le(other: &float) -> bool { self <= (*other) }\n-    pure fn ge(other: &float) -> bool { self >= (*other) }\n-    pure fn gt(other: &float) -> bool { self > (*other) }\n+    pub pure fn lt(other: &float) -> bool { self < (*other) }\n+    pub pure fn le(other: &float) -> bool { self <= (*other) }\n+    pub pure fn ge(other: &float) -> bool { self >= (*other) }\n+    pub pure fn gt(other: &float) -> bool { self > (*other) }\n }\n \n impl float: num::Num {\n-    pure fn add(&&other: float)    -> float { return self + other; }\n-    pure fn sub(&&other: float)    -> float { return self - other; }\n-    pure fn mul(&&other: float)    -> float { return self * other; }\n-    pure fn div(&&other: float)    -> float { return self / other; }\n-    pure fn modulo(&&other: float) -> float { return self % other; }\n+    pub pure fn add(other: &float)    -> float { return self + *other; }\n+    pub pure fn sub(other: &float)    -> float { return self - *other; }\n+    pub pure fn mul(other: &float)    -> float { return self * *other; }\n+    pub pure fn div(other: &float)    -> float { return self / *other; }\n+    pure fn modulo(other: &float) -> float { return self % *other; }\n     pure fn neg()                  -> float { return -self;        }\n \n     pure fn to_int()         -> int   { return self as int; }\n     static pure fn from_int(n: int) -> float { return n as float;  }\n }\n \n #[test]\n-fn test_from_str() {\n+pub fn test_from_str() {\n    assert from_str(~\"3\") == Some(3.);\n    assert from_str(~\"3\") == Some(3.);\n    assert from_str(~\"3.14\") == Some(3.14);\n@@ -483,7 +465,7 @@ fn test_from_str() {\n }\n \n #[test]\n-fn test_positive() {\n+pub fn test_positive() {\n   assert(is_positive(infinity));\n   assert(is_positive(1.));\n   assert(is_positive(0.));\n@@ -494,7 +476,7 @@ fn test_positive() {\n }\n \n #[test]\n-fn test_negative() {\n+pub fn test_negative() {\n   assert(!is_negative(infinity));\n   assert(!is_negative(1.));\n   assert(!is_negative(0.));\n@@ -505,7 +487,7 @@ fn test_negative() {\n }\n \n #[test]\n-fn test_nonpositive() {\n+pub fn test_nonpositive() {\n   assert(!is_nonpositive(infinity));\n   assert(!is_nonpositive(1.));\n   assert(!is_nonpositive(0.));\n@@ -516,7 +498,7 @@ fn test_nonpositive() {\n }\n \n #[test]\n-fn test_nonnegative() {\n+pub fn test_nonnegative() {\n   assert(is_nonnegative(infinity));\n   assert(is_nonnegative(1.));\n   assert(is_nonnegative(0.));\n@@ -527,24 +509,24 @@ fn test_nonnegative() {\n }\n \n #[test]\n-fn test_to_str_inf() {\n+pub fn test_to_str_inf() {\n     assert to_str(infinity, 10u) == ~\"inf\";\n     assert to_str(-infinity, 10u) == ~\"-inf\";\n }\n \n #[test]\n-fn test_traits() {\n+pub fn test_traits() {\n     fn test<U:num::Num cmp::Eq>(ten: &U) {\n         assert (ten.to_int() == 10);\n \n         let two: U = from_int(2);\n         assert (two.to_int() == 2);\n \n-        assert (ten.add(two) == from_int(12));\n-        assert (ten.sub(two) == from_int(8));\n-        assert (ten.mul(two) == from_int(20));\n-        assert (ten.div(two) == from_int(5));\n-        assert (ten.modulo(two) == from_int(0));\n+        assert (ten.add(&two) == from_int(12));\n+        assert (ten.sub(&two) == from_int(8));\n+        assert (ten.mul(&two) == from_int(20));\n+        assert (ten.div(&two) == from_int(5));\n+        assert (ten.modulo(&two) == from_int(0));\n     }\n \n     test(&10.0);"}, {"sha": "c4dd2536e2cfc23e20e7a2d3d6271802c26bc7d0", "filename": "src/libcore/from_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Ffrom_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Ffrom_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffrom_str.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -6,7 +6,7 @@\n \n use option::Option;\n \n-trait FromStr {\n+pub trait FromStr {\n     static fn from_str(s: &str) -> Option<self>;\n }\n "}, {"sha": "11b6a2c01354adc562e11fff55c169a60c7671ef", "filename": "src/libcore/future.rs", "status": "modified", "additions": 22, "deletions": 34, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -1,5 +1,5 @@\n // NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n+// tjc: re-forbid deprecated modes after snapshot\n #[forbid(deprecated_pattern)];\n \n /*!\n@@ -19,20 +19,8 @@ use either::Either;\n use pipes::recv;\n use cast::copy_lifetime;\n \n-export Future;\n-export extensions;\n-export from_value;\n-export from_port;\n-export from_fn;\n-export get;\n-export with;\n-export spawn;\n-\n-// for task.rs\n-export future_pipe;\n-\n #[doc = \"The future type\"]\n-struct Future<A> {\n+pub struct Future<A> {\n     /*priv*/ mut state: FutureState<A>,\n \n     // FIXME(#2829) -- futures should not be copyable, because they close\n@@ -67,7 +55,7 @@ impl<A> Future<A> {\n     }\n }\n \n-fn from_value<A>(+val: A) -> Future<A> {\n+pub fn from_value<A>(val: A) -> Future<A> {\n     /*!\n      * Create a future from a value\n      *\n@@ -78,7 +66,8 @@ fn from_value<A>(+val: A) -> Future<A> {\n     Future {state: Forced(~(move val))}\n }\n \n-fn from_port<A:Send>(+port: future_pipe::client::waiting<A>) -> Future<A> {\n+pub fn from_port<A:Send>(port: future_pipe::client::waiting<A>) ->\n+        Future<A> {\n     /*!\n      * Create a future from a port\n      *\n@@ -97,7 +86,7 @@ fn from_port<A:Send>(+port: future_pipe::client::waiting<A>) -> Future<A> {\n     }\n }\n \n-fn from_fn<A>(+f: ~fn() -> A) -> Future<A> {\n+pub fn from_fn<A>(+f: ~fn() -> A) -> Future<A> {\n     /*!\n      * Create a future from a function.\n      *\n@@ -109,7 +98,7 @@ fn from_fn<A>(+f: ~fn() -> A) -> Future<A> {\n     Future {state: Pending(move f)}\n }\n \n-fn spawn<A:Send>(+blk: fn~() -> A) -> Future<A> {\n+pub fn spawn<A:Send>(+blk: fn~() -> A) -> Future<A> {\n     /*!\n      * Create a future from a unique closure.\n      *\n@@ -122,7 +111,7 @@ fn spawn<A:Send>(+blk: fn~() -> A) -> Future<A> {\n     }))\n }\n \n-fn get_ref<A>(future: &r/Future<A>) -> &r/A {\n+pub fn get_ref<A>(future: &r/Future<A>) -> &r/A {\n     /*!\n      * Executes the future's closure and then returns a borrowed\n      * pointer to the result.  The borrowed pointer lasts as long as\n@@ -160,13 +149,13 @@ fn get_ref<A>(future: &r/Future<A>) -> &r/A {\n     }\n }\n \n-fn get<A:Copy>(future: &Future<A>) -> A {\n+pub fn get<A:Copy>(future: &Future<A>) -> A {\n     //! Get the value of the future\n \n     *get_ref(future)\n }\n \n-fn with<A,B>(future: &Future<A>, blk: fn((&A)) -> B) -> B {\n+pub fn with<A,B>(future: &Future<A>, blk: fn((&A)) -> B) -> B {\n     //! Work with the value without copying it\n \n     blk(get_ref(future))\n@@ -179,74 +168,73 @@ proto! future_pipe (\n )\n \n #[allow(non_implicitly_copyable_typarams)]\n-mod test {\n-    #[legacy_exports];\n+pub mod test {\n     #[test]\n-    fn test_from_value() {\n+    pub fn test_from_value() {\n         let f = from_value(~\"snail\");\n         assert get(&f) == ~\"snail\";\n     }\n \n     #[test]\n-    fn test_from_port() {\n+    pub fn test_from_port() {\n         let (po, ch) = future_pipe::init();\n         future_pipe::server::completed(ch, ~\"whale\");\n         let f = from_port(po);\n         assert get(&f) == ~\"whale\";\n     }\n \n     #[test]\n-    fn test_from_fn() {\n+    pub fn test_from_fn() {\n         let f = from_fn(|| ~\"brail\");\n         assert get(&f) == ~\"brail\";\n     }\n \n     #[test]\n-    fn test_interface_get() {\n+    pub fn test_interface_get() {\n         let f = from_value(~\"fail\");\n         assert f.get() == ~\"fail\";\n     }\n \n     #[test]\n-    fn test_with() {\n+    pub fn test_with() {\n         let f = from_value(~\"nail\");\n         assert with(&f, |v| copy *v) == ~\"nail\";\n     }\n \n     #[test]\n-    fn test_get_ref_method() {\n+    pub fn test_get_ref_method() {\n         let f = from_value(22);\n         assert *f.get_ref() == 22;\n     }\n \n     #[test]\n-    fn test_get_ref_fn() {\n+    pub fn test_get_ref_fn() {\n         let f = from_value(22);\n         assert *get_ref(&f) == 22;\n     }\n \n     #[test]\n-    fn test_interface_with() {\n+    pub fn test_interface_with() {\n         let f = from_value(~\"kale\");\n         assert f.with(|v| copy *v) == ~\"kale\";\n     }\n \n     #[test]\n-    fn test_spawn() {\n+    pub fn test_spawn() {\n         let f = spawn(|| ~\"bale\");\n         assert get(&f) == ~\"bale\";\n     }\n \n     #[test]\n     #[should_fail]\n     #[ignore(cfg(target_os = \"win32\"))]\n-    fn test_futurefail() {\n+    pub fn test_futurefail() {\n         let f = spawn(|| fail);\n         let _x: ~str = get(&f);\n     }\n \n     #[test]\n-    fn test_sendable_future() {\n+    pub fn test_sendable_future() {\n         let expected = ~\"schlorf\";\n         let f = do spawn |copy expected| { copy expected };\n         do task::spawn {"}, {"sha": "464600b946931620d865746f2f027ab01a9db5dd", "filename": "src/libcore/gc.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fgc.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -29,15 +29,11 @@ with destructors.\n #[forbid(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n \n-use stackwalk::Word;\n+pub use stackwalk::Word;\n use libc::size_t;\n use libc::uintptr_t;\n use send_map::linear::LinearMap;\n \n-export Word;\n-export gc;\n-export cleanup_stack_for_failure;\n-\n // Mirrors rust_stack.h stk_seg\n struct StackSegment {\n     prev: *StackSegment,\n@@ -268,7 +264,7 @@ unsafe fn walk_gc_roots(mem: Memory, sentinel: **Word, visitor: Visitor) {\n     }\n }\n \n-fn gc() {\n+pub fn gc() {\n     unsafe {\n         // Abort when GC is disabled.\n         if get_safe_point_count() == 0 {\n@@ -301,7 +297,7 @@ fn expect_sentinel() -> bool { false }\n // This should only be called from fail, as it will drop the roots\n // which are *live* on the stack, rather than dropping those that are\n // dead.\n-fn cleanup_stack_for_failure() {\n+pub fn cleanup_stack_for_failure() {\n     unsafe {\n         // Abort when GC is disabled.\n         if get_safe_point_count() == 0 {\n@@ -320,7 +316,7 @@ fn cleanup_stack_for_failure() {\n         // own stack roots on the stack anyway.\n         let sentinel_box = ~0;\n         let sentinel: **Word = if expect_sentinel() {\n-            cast::reinterpret_cast(&ptr::addr_of(sentinel_box))\n+            cast::reinterpret_cast(&ptr::addr_of(&sentinel_box))\n         } else {\n             ptr::null()\n         };"}, {"sha": "6703006650b030e109e74f62b7784900668409a0", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -17,9 +17,6 @@ use io::Writer;\n use io::WriterUtil;\n use to_bytes::IterBytes;\n \n-export Streaming, State, Hash, HashUtil;\n-export default_state;\n-\n /**\n  * Types that can meaningfully be hashed should implement this.\n  *\n@@ -32,7 +29,7 @@ export default_state;\n  * the rest. This is the recommended approach, since constructing\n  * good keyed hash functions is quite difficult.\n  */\n-trait Hash {\n+pub trait Hash {\n     /**\n      * Compute a \"keyed\" hash of the value implementing the trait,\n      * taking `k0` and `k1` as \"keying\" parameters that randomize or\n@@ -49,7 +46,7 @@ trait Hash {\n }\n \n // When we have default methods, won't need this.\n-trait HashUtil {\n+pub trait HashUtil {\n     pure fn hash() -> u64;\n }\n \n@@ -59,7 +56,7 @@ impl <A: Hash> A: HashUtil {\n }\n \n /// Streaming hash-functions should implement this.\n-trait Streaming {\n+pub trait Streaming {\n     fn input((&[const u8]));\n     // These can be refactored some when we have default methods.\n     fn result_bytes() -> ~[u8];\n@@ -139,15 +136,15 @@ pure fn hash_keyed_5<A: IterBytes,\n \n // Implement State as SipState\n \n-type State = SipState;\n+pub type State = SipState;\n \n #[inline(always)]\n-fn State(k0: u64, k1: u64) -> State {\n+pub fn State(k0: u64, k1: u64) -> State {\n     SipState(k0, k1)\n }\n \n #[inline(always)]\n-fn default_state() -> State {\n+pub fn default_state() -> State {\n     State(0,0)\n }\n \n@@ -361,7 +358,7 @@ impl &SipState : Streaming {\n }\n \n #[test]\n-fn test_siphash() {\n+pub fn test_siphash() {\n     let vecs : [[u8]/8]/64 = [\n         [ 0x31, 0x0e, 0x0e, 0xdd, 0x47, 0xdb, 0x6f, 0x72, ]/_,\n         [ 0xfd, 0x67, 0xdc, 0x93, 0xc5, 0x39, 0xf8, 0x74, ]/_,\n@@ -468,34 +465,34 @@ fn test_siphash() {\n }\n \n #[test] #[cfg(target_arch = \"arm\")]\n-fn test_hash_uint() {\n+pub fn test_hash_uint() {\n     let val = 0xdeadbeef_deadbeef_u64;\n     assert (val as u64).hash() != (val as uint).hash();\n     assert (val as u32).hash() == (val as uint).hash();\n }\n #[test] #[cfg(target_arch = \"x86_64\")]\n-fn test_hash_uint() {\n+pub fn test_hash_uint() {\n     let val = 0xdeadbeef_deadbeef_u64;\n     assert (val as u64).hash() == (val as uint).hash();\n     assert (val as u32).hash() != (val as uint).hash();\n }\n #[test] #[cfg(target_arch = \"x86\")]\n-fn test_hash_uint() {\n+pub fn test_hash_uint() {\n     let val = 0xdeadbeef_deadbeef_u64;\n     assert (val as u64).hash() != (val as uint).hash();\n     assert (val as u32).hash() == (val as uint).hash();\n }\n \n #[test]\n-fn test_hash_idempotent() {\n+pub fn test_hash_idempotent() {\n     let val64 = 0xdeadbeef_deadbeef_u64;\n     val64.hash() == val64.hash();\n     let val32 = 0xdeadbeef_u32;\n     val32.hash() == val32.hash();\n }\n \n #[test]\n-fn test_hash_no_bytes_dropped_64() {\n+pub fn test_hash_no_bytes_dropped_64() {\n     let val = 0xdeadbeef_deadbeef_u64;\n \n     assert val.hash() != zero_byte(val, 0).hash();\n@@ -514,7 +511,7 @@ fn test_hash_no_bytes_dropped_64() {\n }\n \n #[test]\n-fn test_hash_no_bytes_dropped_32() {\n+pub fn test_hash_no_bytes_dropped_32() {\n     let val = 0xdeadbeef_u32;\n \n     assert val.hash() != zero_byte(val, 0).hash();"}, {"sha": "6942d38d5d3420e3f824902e2bb6b943c0ec4fbb", "filename": "src/libcore/int-template.rs", "status": "modified", "additions": 46, "deletions": 59, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -1,55 +1,42 @@\n // NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n+// tjc: re-forbid deprecated modes after snapshot\n #[forbid(deprecated_pattern)];\n \n use T = inst::T;\n use cmp::{Eq, Ord};\n use from_str::FromStr;\n use num::from_int;\n \n-export min_value, max_value;\n-export min, max;\n-export add, sub, mul, div, rem;\n-export lt, le, eq, ne, ge, gt;\n-export is_positive, is_negative;\n-export is_nonpositive, is_nonnegative;\n-export range;\n-export compl;\n-export abs;\n-export parse_bytes, from_str, to_str, to_str_bytes, str;\n-export num, ord, eq, times, timesi;\n-export bits, bytes;\n-\n-const bits : uint = inst::bits;\n-const bytes : uint = (inst::bits / 8);\n-\n-const min_value: T = (-1 as T) << (bits - 1);\n-const max_value: T = min_value - 1 as T;\n-\n-pure fn min(x: T, y: T) -> T { if x < y { x } else { y } }\n-pure fn max(x: T, y: T) -> T { if x > y { x } else { y } }\n-\n-pure fn add(x: T, y: T) -> T { x + y }\n-pure fn sub(x: T, y: T) -> T { x - y }\n-pure fn mul(x: T, y: T) -> T { x * y }\n-pure fn div(x: T, y: T) -> T { x / y }\n-pure fn rem(x: T, y: T) -> T { x % y }\n-\n-pure fn lt(x: T, y: T) -> bool { x < y }\n-pure fn le(x: T, y: T) -> bool { x <= y }\n-pure fn eq(x: T, y: T) -> bool { x == y }\n-pure fn ne(x: T, y: T) -> bool { x != y }\n-pure fn ge(x: T, y: T) -> bool { x >= y }\n-pure fn gt(x: T, y: T) -> bool { x > y }\n-\n-pure fn is_positive(x: T) -> bool { x > 0 as T }\n-pure fn is_negative(x: T) -> bool { x < 0 as T }\n-pure fn is_nonpositive(x: T) -> bool { x <= 0 as T }\n-pure fn is_nonnegative(x: T) -> bool { x >= 0 as T }\n+pub const bits : uint = inst::bits;\n+pub const bytes : uint = (inst::bits / 8);\n+\n+pub const min_value: T = (-1 as T) << (bits - 1);\n+pub const max_value: T = min_value - 1 as T;\n+\n+pub pure fn min(x: T, y: T) -> T { if x < y { x } else { y } }\n+pub pure fn max(x: T, y: T) -> T { if x > y { x } else { y } }\n+\n+pub pure fn add(x: T, y: T) -> T { x + y }\n+pub pure fn sub(x: T, y: T) -> T { x - y }\n+pub pure fn mul(x: T, y: T) -> T { x * y }\n+pub pure fn div(x: T, y: T) -> T { x / y }\n+pub pure fn rem(x: T, y: T) -> T { x % y }\n+\n+pub pure fn lt(x: T, y: T) -> bool { x < y }\n+pub pure fn le(x: T, y: T) -> bool { x <= y }\n+pub pure fn eq(x: T, y: T) -> bool { x == y }\n+pub pure fn ne(x: T, y: T) -> bool { x != y }\n+pub pure fn ge(x: T, y: T) -> bool { x >= y }\n+pub pure fn gt(x: T, y: T) -> bool { x > y }\n+\n+pub pure fn is_positive(x: T) -> bool { x > 0 as T }\n+pub pure fn is_negative(x: T) -> bool { x < 0 as T }\n+pub pure fn is_nonpositive(x: T) -> bool { x <= 0 as T }\n+pub pure fn is_nonnegative(x: T) -> bool { x >= 0 as T }\n \n #[inline(always)]\n /// Iterate over the range [`lo`..`hi`)\n-fn range(lo: T, hi: T, it: fn(T) -> bool) {\n+pub fn range(lo: T, hi: T, it: fn(T) -> bool) {\n     let mut i = lo;\n     while i < hi {\n         if !it(i) { break }\n@@ -58,13 +45,13 @@ fn range(lo: T, hi: T, it: fn(T) -> bool) {\n }\n \n /// Computes the bitwise complement\n-pure fn compl(i: T) -> T {\n+pub pure fn compl(i: T) -> T {\n     -1 as T ^ i\n }\n \n /// Computes the absolute value\n // FIXME: abs should return an unsigned int (#2353)\n-pure fn abs(i: T) -> T {\n+pub pure fn abs(i: T) -> T {\n     if is_negative(i) { -i } else { i }\n }\n \n@@ -81,11 +68,11 @@ impl T : Eq {\n }\n \n impl T: num::Num {\n-    pure fn add(&&other: T)    -> T { return self + other; }\n-    pure fn sub(&&other: T)    -> T { return self - other; }\n-    pure fn mul(&&other: T)    -> T { return self * other; }\n-    pure fn div(&&other: T)    -> T { return self / other; }\n-    pure fn modulo(&&other: T) -> T { return self % other; }\n+    pure fn add(other: &T)    -> T { return self + *other; }\n+    pure fn sub(other: &T)    -> T { return self - *other; }\n+    pure fn mul(other: &T)    -> T { return self * *other; }\n+    pure fn div(other: &T)    -> T { return self / *other; }\n+    pure fn modulo(other: &T) -> T { return self % *other; }\n     pure fn neg()              -> T { return -self;        }\n \n     pure fn to_int()         -> int { return self as int; }\n@@ -137,7 +124,7 @@ impl T: iter::TimesIx {\n  * * buf - A byte buffer\n  * * radix - The base of the number\n  */\n-fn parse_bytes(buf: &[u8], radix: uint) -> Option<T> {\n+pub fn parse_bytes(buf: &[u8], radix: uint) -> Option<T> {\n     if vec::len(buf) == 0u { return None; }\n     let mut i = vec::len(buf) - 1u;\n     let mut start = 0u;\n@@ -160,22 +147,22 @@ fn parse_bytes(buf: &[u8], radix: uint) -> Option<T> {\n }\n \n /// Parse a string to an int\n-fn from_str(s: &str) -> Option<T> { parse_bytes(str::to_bytes(s), 10u) }\n+pub fn from_str(s: &str) -> Option<T> { parse_bytes(str::to_bytes(s), 10u) }\n \n impl T : FromStr {\n     static fn from_str(s: &str) -> Option<T> { from_str(s) }\n }\n \n /// Convert to a string in a given base\n-fn to_str(n: T, radix: uint) -> ~str {\n+pub fn to_str(n: T, radix: uint) -> ~str {\n     do to_str_bytes(n, radix) |slice| {\n         do vec::as_imm_buf(slice) |p, len| {\n             unsafe { str::raw::from_buf_len(p, len) }\n         }\n     }\n }\n \n-fn to_str_bytes<U>(n: T, radix: uint, f: fn(v: &[u8]) -> U) -> U {\n+pub fn to_str_bytes<U>(n: T, radix: uint, f: fn(v: &[u8]) -> U) -> U {\n     if n < 0 as T {\n         uint::to_str_bytes(true, -n as uint, radix, f)\n     } else {\n@@ -184,7 +171,7 @@ fn to_str_bytes<U>(n: T, radix: uint, f: fn(v: &[u8]) -> U) -> U {\n }\n \n /// Convert to a string\n-fn str(i: T) -> ~str { return to_str(i, 10u); }\n+pub fn str(i: T) -> ~str { return to_str(i, 10u); }\n \n // FIXME: Has alignment issues on windows and 32-bit linux (#2609)\n #[test]\n@@ -244,17 +231,17 @@ fn test_to_str() {\n \n #[test]\n fn test_interfaces() {\n-    fn test<U:num::Num cmp::Eq>(+ten: U) {\n+    fn test<U:num::Num cmp::Eq>(ten: U) {\n         assert (ten.to_int() == 10);\n \n         let two: U = from_int(2);\n         assert (two.to_int() == 2);\n \n-        assert (ten.add(two) == from_int(12));\n-        assert (ten.sub(two) == from_int(8));\n-        assert (ten.mul(two) == from_int(20));\n-        assert (ten.div(two) == from_int(5));\n-        assert (ten.modulo(two) == from_int(0));\n+        assert (ten.add(&two) == from_int(12));\n+        assert (ten.sub(&two) == from_int(8));\n+        assert (ten.mul(&two) == from_int(20));\n+        assert (ten.div(&two) == from_int(5));\n+        assert (ten.modulo(&two) == from_int(0));\n         assert (ten.neg() == from_int(-10));\n     }\n "}, {"sha": "9e7055c3e7a64a6065a70a048342dd60575ecc51", "filename": "src/libcore/int-template/i16.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fint-template%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fint-template%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template%2Fi16.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -1,2 +1,2 @@\n-type T = i16;\n-const bits: uint = u16::bits;\n\\ No newline at end of file\n+pub type T = i16;\n+pub const bits: uint = u16::bits;\n\\ No newline at end of file"}, {"sha": "6545eaffdac921984278079333ec8fedb6a610da", "filename": "src/libcore/int-template/i32.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fint-template%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fint-template%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template%2Fi32.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -1,2 +1,2 @@\n-type T = i32;\n-const bits: uint = u32::bits;\n+pub type T = i32;\n+pub const bits: uint = u32::bits;"}, {"sha": "c6ed97e8162c68f0953a88952e1f39b735efea51", "filename": "src/libcore/int-template/i64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fint-template%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fint-template%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template%2Fi64.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -1,2 +1,2 @@\n-type T = i64;\n-const bits: uint = u64::bits;\n\\ No newline at end of file\n+pub type T = i64;\n+pub const bits: uint = u64::bits;\n\\ No newline at end of file"}, {"sha": "0a2823e63c6edf39bf6184cb232900f46428ce25", "filename": "src/libcore/int-template/i8.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fint-template%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fint-template%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template%2Fi8.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -1,2 +1,2 @@\n-type T = i8;\n-const bits: uint = u8::bits;\n\\ No newline at end of file\n+pub type T = i8;\n+pub const bits: uint = u8::bits;\n\\ No newline at end of file"}, {"sha": "8b898b173ac31a411867233bcaf08ef5ad33fbb1", "filename": "src/libcore/int-template/int.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fint-template%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fint-template%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template%2Fint.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -1,8 +1,8 @@\n-type T = int;\n-const bits: uint = uint::bits;\n+pub type T = int;\n+pub const bits: uint = uint::bits;\n \n /// Returns `base` raised to the power of `exponent`\n-fn pow(base: int, exponent: uint) -> int {\n+pub fn pow(base: int, exponent: uint) -> int {\n     if exponent == 0u { return 1; } //Not mathemtically true if ~[base == 0]\n     if base     == 0  { return 0; }\n     let mut my_pow  = exponent;"}, {"sha": "2efc96933da85c374ab354344df8d61135afd930", "filename": "src/libcore/io.rs", "status": "modified", "additions": 120, "deletions": 107, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -17,7 +17,6 @@ type fd_t = c_int;\n \n #[abi = \"cdecl\"]\n extern mod rustrt {\n-    #[legacy_exports];\n     fn rust_get_stdin() -> *libc::FILE;\n     fn rust_get_stdout() -> *libc::FILE;\n     fn rust_get_stderr() -> *libc::FILE;\n@@ -27,11 +26,11 @@ extern mod rustrt {\n \n // FIXME (#2004): This is all buffered. We might need an unbuffered variant\n // as well\n-enum SeekStyle { SeekSet, SeekEnd, SeekCur, }\n+pub enum SeekStyle { SeekSet, SeekEnd, SeekCur, }\n \n \n // The raw underlying reader trait. All readers must implement this.\n-trait Reader {\n+pub trait Reader {\n     // FIXME (#2004): Seekable really should be orthogonal.\n \n     // FIXME (#2982): This should probably return an error.\n@@ -45,106 +44,117 @@ trait Reader {\n \n // Generic utility functions defined on readers\n \n-trait ReaderUtil {\n+pub trait ReaderUtil {\n     fn read_bytes(len: uint) -> ~[u8];\n     fn read_line() -> ~str;\n+\n+    fn read_chars(n: uint) -> ~[char];\n+    fn read_char() -> char;\n+    fn read_c_str() -> ~str;\n+    fn read_le_uint(size: uint) -> uint;\n+    fn read_le_int(size: uint) -> int;\n+    fn read_be_uint(size: uint) -> uint;\n+    fn read_whole_stream() -> ~[u8];\n+    fn each_byte(it: fn(int) -> bool);\n+    fn each_char(it: fn(char) -> bool);\n+    fn each_line(it: fn((&str)) -> bool);\n }\n \n impl<T: Reader> T : ReaderUtil {\n     fn read_bytes(len: uint) -> ~[u8] {\n         let mut buf = vec::with_capacity(len);\n-        unsafe { vec::raw::set_len(buf, len); }\n+        unsafe { vec::raw::set_len(&mut buf, len); }\n \n         let count = self.read(buf, len);\n \n-        unsafe { vec::raw::set_len(buf, count); }\n+        unsafe { vec::raw::set_len(&mut buf, count); }\n         move buf\n     }\n     fn read_line() -> ~str {\n         let mut buf = ~[];\n         loop {\n             let ch = self.read_byte();\n             if ch == -1 || ch == 10 { break; }\n-            vec::push(buf, ch as u8);\n+            buf.push(ch as u8);\n         }\n         str::from_bytes(buf)\n     }\n-}\n \n-impl Reader {\n     fn read_chars(n: uint) -> ~[char] {\n         // returns the (consumed offset, n_req), appends characters to &chars\n-        fn chars_from_bytes(buf: ~[u8], &chars: ~[char]) -> (uint, uint) {\n-            let mut i = 0u;\n-            while i < vec::len(buf) {\n+        fn chars_from_bytes<T: Reader>(buf: &~[u8], chars: &mut ~[char])\n+            -> (uint, uint) {\n+            let mut i = 0;\n+            let buf_len = buf.len();\n+            while i < buf_len {\n                 let b0 = buf[i];\n                 let w = str::utf8_char_width(b0);\n                 let end = i + w;\n-                i += 1u;\n-                assert (w > 0u);\n-                if w == 1u {\n-                    vec::push(chars,  b0 as char );\n+                i += 1;\n+                assert (w > 0);\n+                if w == 1 {\n+                    chars.push(b0 as char);\n                     loop;\n                 }\n                 // can't satisfy this char with the existing data\n-                if end > vec::len(buf) {\n-                    return (i - 1u, end - vec::len(buf));\n+                if end > buf_len {\n+                    return (i - 1, end - buf_len);\n                 }\n-                let mut val = 0u;\n+                let mut val = 0;\n                 while i < end {\n                     let next = buf[i] as int;\n-                    i += 1u;\n+                    i += 1;\n                     assert (next > -1);\n                     assert (next & 192 == 128);\n-                    val <<= 6u;\n+                    val <<= 6;\n                     val += (next & 63) as uint;\n                 }\n                 // See str::char_at\n-                val += ((b0 << ((w + 1u) as u8)) as uint)\n-                    << (w - 1u) * 6u - w - 1u;\n-                vec::push(chars,  val as char );\n+                val += ((b0 << ((w + 1) as u8)) as uint)\n+                    << (w - 1) * 6 - w - 1u;\n+                chars.push(val as char);\n             }\n-            return (i, 0u);\n+            return (i, 0);\n         }\n         let mut buf: ~[u8] = ~[];\n         let mut chars: ~[char] = ~[];\n         // might need more bytes, but reading n will never over-read\n         let mut nbread = n;\n-        while nbread > 0u {\n+        while nbread > 0 {\n             let data = self.read_bytes(nbread);\n-            if vec::len(data) == 0u {\n+            if data.is_empty() {\n                 // eof - FIXME (#2004): should we do something if\n                 // we're split in a unicode char?\n                 break;\n             }\n-            vec::push_all(buf, data);\n-            let (offset, nbreq) = chars_from_bytes(buf, chars);\n-            let ncreq = n - vec::len(chars);\n+            buf.push_all(data);\n+            let (offset, nbreq) = chars_from_bytes::<T>(&buf, &mut chars);\n+            let ncreq = n - chars.len();\n             // again we either know we need a certain number of bytes\n             // to complete a character, or we make sure we don't\n             // over-read by reading 1-byte per char needed\n             nbread = if ncreq > nbreq { ncreq } else { nbreq };\n-            if nbread > 0u {\n-                buf = vec::slice(buf, offset, vec::len(buf));\n+            if nbread > 0 {\n+                buf = vec::slice(buf, offset, buf.len());\n             }\n         }\n         move chars\n     }\n \n     fn read_char() -> char {\n-        let c = self.read_chars(1u);\n-        if vec::len(c) == 0u {\n+        let c = self.read_chars(1);\n+        if vec::len(c) == 0 {\n             return -1 as char; // FIXME will this stay valid? // #2004\n         }\n-        assert(vec::len(c) == 1u);\n+        assert(vec::len(c) == 1);\n         return c[0];\n     }\n \n     fn read_c_str() -> ~str {\n         let mut buf: ~[u8] = ~[];\n         loop {\n             let ch = self.read_byte();\n-            if ch < 1 { break; } else { vec::push(buf, ch as u8); }\n+            if ch < 1 { break; } else { buf.push(ch as u8); }\n         }\n         str::from_bytes(buf)\n     }\n@@ -179,7 +189,7 @@ impl Reader {\n \n     fn read_whole_stream() -> ~[u8] {\n         let mut buf: ~[u8] = ~[];\n-        while !self.eof() { vec::push_all(buf, self.read_bytes(2048u)); }\n+        while !self.eof() { buf.push_all(self.read_bytes(2048u)); }\n         move buf\n     }\n \n@@ -195,7 +205,7 @@ impl Reader {\n         }\n     }\n \n-    fn each_line(it: fn(~str) -> bool) {\n+    fn each_line(it: fn(s: &str) -> bool) {\n         while !self.eof() {\n             if !it(self.read_line()) { break; }\n         }\n@@ -256,7 +266,7 @@ fn FILERes(f: *libc::FILE) -> FILERes {\n     }\n }\n \n-fn FILE_reader(f: *libc::FILE, cleanup: bool) -> Reader {\n+pub fn FILE_reader(f: *libc::FILE, cleanup: bool) -> Reader {\n     if cleanup {\n         {base: f, cleanup: FILERes(f)} as Reader\n     } else {\n@@ -268,9 +278,9 @@ fn FILE_reader(f: *libc::FILE, cleanup: bool) -> Reader {\n // top-level functions that take a reader, or a set of default methods on\n // reader (which can then be called reader)\n \n-fn stdin() -> Reader { rustrt::rust_get_stdin() as Reader }\n+pub fn stdin() -> Reader { rustrt::rust_get_stdin() as Reader }\n \n-fn file_reader(path: &Path) -> Result<Reader, ~str> {\n+pub fn file_reader(path: &Path) -> Result<Reader, ~str> {\n     let f = os::as_c_charp(path.to_str(), |pathbuf| {\n         os::as_c_charp(\"r\", |modebuf|\n             libc::fopen(pathbuf, modebuf)\n@@ -286,7 +296,7 @@ fn file_reader(path: &Path) -> Result<Reader, ~str> {\n \n // Byte buffer readers\n \n-type ByteBuf = {buf: &[const u8], mut pos: uint};\n+pub type ByteBuf = {buf: &[const u8], mut pos: uint};\n \n impl ByteBuf: Reader {\n     fn read(buf: &[mut u8], len: uint) -> uint {\n@@ -315,21 +325,21 @@ impl ByteBuf: Reader {\n     fn tell() -> uint { self.pos }\n }\n \n-fn with_bytes_reader<t>(bytes: &[u8], f: fn(Reader) -> t) -> t {\n+pub fn with_bytes_reader<t>(bytes: &[u8], f: fn(Reader) -> t) -> t {\n     f({buf: bytes, mut pos: 0u} as Reader)\n }\n \n-fn with_str_reader<T>(s: &str, f: fn(Reader) -> T) -> T {\n+pub fn with_str_reader<T>(s: &str, f: fn(Reader) -> T) -> T {\n     str::byte_slice(s, |bytes| with_bytes_reader(bytes, f))\n }\n \n // Writing\n-enum FileFlag { Append, Create, Truncate, NoFlag, }\n+pub enum FileFlag { Append, Create, Truncate, NoFlag, }\n \n // What type of writer are we?\n-enum WriterType { Screen, File }\n+pub enum WriterType { Screen, File }\n \n-impl WriterType : Eq {\n+pub impl WriterType : Eq {\n     pure fn eq(other: &WriterType) -> bool {\n         match (self, (*other)) {\n             (Screen, Screen) | (File, File) => true,\n@@ -341,7 +351,7 @@ impl WriterType : Eq {\n \n // FIXME (#2004): Seekable really should be orthogonal.\n // FIXME (#2004): eventually u64\n-trait Writer {\n+pub trait Writer {\n     fn write(v: &[const u8]);\n     fn seek(int, SeekStyle);\n     fn tell() -> uint;\n@@ -382,7 +392,7 @@ impl *libc::FILE: Writer {\n     }\n }\n \n-fn FILE_writer(f: *libc::FILE, cleanup: bool) -> Writer {\n+pub fn FILE_writer(f: *libc::FILE, cleanup: bool) -> Writer {\n     if cleanup {\n         {base: f, cleanup: FILERes(f)} as Writer\n     } else {\n@@ -431,7 +441,7 @@ fn FdRes(fd: fd_t) -> FdRes {\n     }\n }\n \n-fn fd_writer(fd: fd_t, cleanup: bool) -> Writer {\n+pub fn fd_writer(fd: fd_t, cleanup: bool) -> Writer {\n     if cleanup {\n         {base: fd, cleanup: FdRes(fd)} as Writer\n     } else {\n@@ -440,7 +450,7 @@ fn fd_writer(fd: fd_t, cleanup: bool) -> Writer {\n }\n \n \n-fn mk_file_writer(path: &Path, flags: ~[FileFlag])\n+pub fn mk_file_writer(path: &Path, flags: &[FileFlag])\n     -> Result<Writer, ~str> {\n \n     #[cfg(windows)]\n@@ -470,7 +480,8 @@ fn mk_file_writer(path: &Path, flags: ~[FileFlag])\n     }\n }\n \n-fn u64_to_le_bytes<T>(n: u64, size: uint, f: fn(v: &[u8]) -> T) -> T {\n+pub fn u64_to_le_bytes<T>(n: u64, size: uint,\n+                          f: fn(v: &[u8]) -> T) -> T {\n     assert size <= 8u;\n     match size {\n       1u => f(&[n as u8]),\n@@ -492,7 +503,7 @@ fn u64_to_le_bytes<T>(n: u64, size: uint, f: fn(v: &[u8]) -> T) -> T {\n \n         let mut bytes: ~[u8] = ~[], i = size, n = n;\n         while i > 0u {\n-            vec::push(bytes, (n & 255_u64) as u8);\n+            bytes.push((n & 255_u64) as u8);\n             n >>= 8_u64;\n             i -= 1u;\n         }\n@@ -501,7 +512,8 @@ fn u64_to_le_bytes<T>(n: u64, size: uint, f: fn(v: &[u8]) -> T) -> T {\n     }\n }\n \n-fn u64_to_be_bytes<T>(n: u64, size: uint, f: fn(v: &[u8]) -> T) -> T {\n+pub fn u64_to_be_bytes<T>(n: u64, size: uint,\n+                           f: fn(v: &[u8]) -> T) -> T {\n     assert size <= 8u;\n     match size {\n       1u => f(&[n as u8]),\n@@ -524,15 +536,16 @@ fn u64_to_be_bytes<T>(n: u64, size: uint, f: fn(v: &[u8]) -> T) -> T {\n         let mut i = size;\n         while i > 0u {\n             let shift = ((i - 1u) * 8u) as u64;\n-            vec::push(bytes, (n >> shift) as u8);\n+            bytes.push((n >> shift) as u8);\n             i -= 1u;\n         }\n         f(bytes)\n       }\n     }\n }\n \n-fn u64_from_be_bytes(data: &[const u8], start: uint, size: uint) -> u64 {\n+pub fn u64_from_be_bytes(data: &[const u8],\n+                         start: uint, size: uint) -> u64 {\n     let mut sz = size;\n     assert (sz <= 8u);\n     let mut val = 0_u64;\n@@ -547,7 +560,7 @@ fn u64_from_be_bytes(data: &[const u8], start: uint, size: uint) -> u64 {\n \n // FIXME: #3048 combine trait+impl (or just move these to\n // default methods on writer)\n-trait WriterUtil {\n+pub trait WriterUtil {\n     fn write_char(ch: char);\n     fn write_str(s: &str);\n     fn write_line(s: &str);\n@@ -644,13 +657,13 @@ impl<T: Writer> T : WriterUtil {\n }\n \n #[allow(non_implicitly_copyable_typarams)]\n-fn file_writer(path: &Path, flags: ~[FileFlag]) -> Result<Writer, ~str> {\n-    result::chain(mk_file_writer(path, flags), |w| result::Ok(w))\n+pub fn file_writer(path: &Path, flags: &[FileFlag]) -> Result<Writer, ~str> {\n+    mk_file_writer(path, flags).chain(|w| result::Ok(w))\n }\n \n \n // FIXME: fileflags // #2004\n-fn buffered_file_writer(path: &Path) -> Result<Writer, ~str> {\n+pub fn buffered_file_writer(path: &Path) -> Result<Writer, ~str> {\n     let f = do os::as_c_charp(path.to_str()) |pathbuf| {\n         do os::as_c_charp(\"w\") |modebuf| {\n             libc::fopen(pathbuf, modebuf)\n@@ -664,13 +677,13 @@ fn buffered_file_writer(path: &Path) -> Result<Writer, ~str> {\n // FIXME (#2004) it would be great if this could be a const\n // FIXME (#2004) why are these different from the way stdin() is\n // implemented?\n-fn stdout() -> Writer { fd_writer(libc::STDOUT_FILENO as c_int, false) }\n-fn stderr() -> Writer { fd_writer(libc::STDERR_FILENO as c_int, false) }\n+pub fn stdout() -> Writer { fd_writer(libc::STDOUT_FILENO as c_int, false) }\n+pub fn stderr() -> Writer { fd_writer(libc::STDERR_FILENO as c_int, false) }\n \n-fn print(s: &str) { stdout().write_str(s); }\n-fn println(s: &str) { stdout().write_line(s); }\n+pub fn print(s: &str) { stdout().write_str(s); }\n+pub fn println(s: &str) { stdout().write_line(s); }\n \n-struct BytesWriter {\n+pub struct BytesWriter {\n     buf: DVec<u8>,\n     mut pos: uint,\n }\n@@ -684,10 +697,12 @@ impl BytesWriter: Writer {\n \n             let count = uint::max(buf_len, self.pos + v_len);\n             vec::reserve(&mut buf, count);\n-            unsafe { vec::raw::set_len(buf, count); }\n+            unsafe { vec::raw::set_len(&mut buf, count); }\n \n-            let view = vec::mut_view(buf, self.pos, count);\n-            vec::bytes::memcpy(view, v, v_len);\n+            {\n+                let view = vec::mut_view(buf, self.pos, count);\n+                vec::bytes::memcpy(view, v, v_len);\n+            }\n \n             self.pos += v_len;\n \n@@ -712,28 +727,28 @@ impl @BytesWriter : Writer {\n     fn get_type() -> WriterType { (*self).get_type() }\n }\n \n-fn BytesWriter() -> BytesWriter {\n+pub fn BytesWriter() -> BytesWriter {\n     BytesWriter { buf: DVec(), mut pos: 0u }\n }\n \n-fn with_bytes_writer(f: fn(Writer)) -> ~[u8] {\n+pub fn with_bytes_writer(f: fn(Writer)) -> ~[u8] {\n     let wr = @BytesWriter();\n     f(wr as Writer);\n     wr.buf.check_out(|buf| buf)\n }\n \n-fn with_str_writer(f: fn(Writer)) -> ~str {\n+pub fn with_str_writer(f: fn(Writer)) -> ~str {\n     let mut v = with_bytes_writer(f);\n \n     // Make sure the vector has a trailing null and is proper utf8.\n-    vec::push(v, 0);\n+    v.push(0);\n     assert str::is_utf8(v);\n \n     unsafe { move ::cast::transmute(v) }\n }\n \n // Utility functions\n-fn seek_in_buf(offset: int, pos: uint, len: uint, whence: SeekStyle) ->\n+pub fn seek_in_buf(offset: int, pos: uint, len: uint, whence: SeekStyle) ->\n    uint {\n     let mut bpos = pos as int;\n     let blen = len as int;\n@@ -747,7 +762,7 @@ fn seek_in_buf(offset: int, pos: uint, len: uint, whence: SeekStyle) ->\n }\n \n #[allow(non_implicitly_copyable_typarams)]\n-fn read_whole_file_str(file: &Path) -> Result<~str, ~str> {\n+pub fn read_whole_file_str(file: &Path) -> Result<~str, ~str> {\n     result::chain(read_whole_file(file), |bytes| {\n         if str::is_utf8(bytes) {\n             result::Ok(str::from_bytes(bytes))\n@@ -760,18 +775,17 @@ fn read_whole_file_str(file: &Path) -> Result<~str, ~str> {\n // FIXME (#2004): implement this in a low-level way. Going through the\n // abstractions is pointless.\n #[allow(non_implicitly_copyable_typarams)]\n-fn read_whole_file(file: &Path) -> Result<~[u8], ~str> {\n+pub fn read_whole_file(file: &Path) -> Result<~[u8], ~str> {\n     result::chain(file_reader(file), |rdr| {\n         result::Ok(rdr.read_whole_stream())\n     })\n }\n \n // fsync related\n \n-mod fsync {\n-    #[legacy_exports];\n+pub mod fsync {\n \n-    enum Level {\n+    pub enum Level {\n         // whatever fsync does on that platform\n         FSync,\n \n@@ -786,7 +800,7 @@ mod fsync {\n \n \n     // Artifacts that need to fsync on destruction\n-    struct Res<t> {\n+    pub struct Res<t: Copy> {\n         arg: Arg<t>,\n         drop {\n           match self.arg.opt_level {\n@@ -799,51 +813,51 @@ mod fsync {\n         }\n     }\n \n-    fn Res<t>(-arg: Arg<t>) -> Res<t>{\n+    pub fn Res<t: Copy>(arg: Arg<t>) -> Res<t>{\n         Res {\n             arg: move arg\n         }\n     }\n \n-    type Arg<t> = {\n+    pub type Arg<t> = {\n         val: t,\n         opt_level: Option<Level>,\n-        fsync_fn: fn@(t, Level) -> int\n+        fsync_fn: fn@(f: t, Level) -> int\n     };\n \n     // fsync file after executing blk\n     // FIXME (#2004) find better way to create resources within lifetime of\n     // outer res\n-    fn FILE_res_sync(&&file: FILERes, opt_level: Option<Level>,\n-                  blk: fn(&&v: Res<*libc::FILE>)) {\n-        blk(Res({\n+    pub fn FILE_res_sync(file: &FILERes, opt_level: Option<Level>,\n+                         blk: fn(v: Res<*libc::FILE>)) {\n+        blk(move Res({\n             val: file.f, opt_level: opt_level,\n-            fsync_fn: fn@(&&file: *libc::FILE, l: Level) -> int {\n+            fsync_fn: fn@(file: *libc::FILE, l: Level) -> int {\n                 return os::fsync_fd(libc::fileno(file), l) as int;\n             }\n         }));\n     }\n \n     // fsync fd after executing blk\n-    fn fd_res_sync(&&fd: FdRes, opt_level: Option<Level>,\n-                   blk: fn(&&v: Res<fd_t>)) {\n-        blk(Res({\n+    pub fn fd_res_sync(fd: &FdRes, opt_level: Option<Level>,\n+                       blk: fn(v: Res<fd_t>)) {\n+        blk(move Res({\n             val: fd.fd, opt_level: opt_level,\n-            fsync_fn: fn@(&&fd: fd_t, l: Level) -> int {\n+            fsync_fn: fn@(fd: fd_t, l: Level) -> int {\n                 return os::fsync_fd(fd, l) as int;\n             }\n         }));\n     }\n \n     // Type of objects that may want to fsync\n-    trait FSyncable { fn fsync(l: Level) -> int; }\n+    pub trait FSyncable { fn fsync(l: Level) -> int; }\n \n     // Call o.fsync after executing blk\n-    fn obj_sync(&&o: FSyncable, opt_level: Option<Level>,\n-                blk: fn(&&v: Res<FSyncable>)) {\n+    pub fn obj_sync(o: FSyncable, opt_level: Option<Level>,\n+                    blk: fn(v: Res<FSyncable>)) {\n         blk(Res({\n             val: o, opt_level: opt_level,\n-            fsync_fn: fn@(&&o: FSyncable, l: Level) -> int {\n+            fsync_fn: fn@(o: FSyncable, l: Level) -> int {\n                 return o.fsync(l);\n             }\n         }));\n@@ -852,7 +866,6 @@ mod fsync {\n \n #[cfg(test)]\n mod tests {\n-    #[legacy_exports];\n \n     #[test]\n     fn test_simple() {\n@@ -864,10 +877,10 @@ mod tests {\n         {\n             let out: io::Writer =\n                 result::get(\n-                    io::file_writer(tmpfile, ~[io::Create, io::Truncate]));\n+                    &io::file_writer(tmpfile, ~[io::Create, io::Truncate]));\n             out.write_str(frood);\n         }\n-        let inp: io::Reader = result::get(io::file_reader(tmpfile));\n+        let inp: io::Reader = result::get(&io::file_reader(tmpfile));\n         let frood2: ~str = inp.read_c_str();\n         log(debug, frood2);\n         assert frood == frood2;\n@@ -876,8 +889,8 @@ mod tests {\n     #[test]\n     fn test_readchars_empty() {\n         do io::with_str_reader(~\"\") |inp| {\n-            let res : ~[char] = inp.read_chars(128u);\n-            assert(vec::len(res) == 0u);\n+            let res : ~[char] = inp.read_chars(128);\n+            assert(vec::len(res) == 0);\n         }\n     }\n \n@@ -890,7 +903,7 @@ mod tests {\n             104, 101, 108, 108, 111,\n             29983, 38152, 30340, 27748,\n             21273, 20999, 32905, 27748];\n-        fn check_read_ln(len : uint, s: ~str, ivals: ~[int]) {\n+        fn check_read_ln(len : uint, s: &str, ivals: &[int]) {\n             do io::with_str_reader(s) |inp| {\n                 let res : ~[char] = inp.read_chars(len);\n                 if (len <= vec::len(ivals)) {\n@@ -900,13 +913,13 @@ mod tests {\n                        vec::map(res, |x| *x as int));\n             }\n         }\n-        let mut i = 0u;\n-        while i < 8u {\n+        let mut i = 0;\n+        while i < 8 {\n             check_read_ln(i, wide_test, ivals);\n-            i += 1u;\n+            i += 1;\n         }\n         // check a long read for good measure\n-        check_read_ln(128u, wide_test, ivals);\n+        check_read_ln(128, wide_test, ivals);\n     }\n \n     #[test]\n@@ -928,7 +941,7 @@ mod tests {\n     #[test]\n     fn file_reader_not_exist() {\n         match io::file_reader(&Path(\"not a file\")) {\n-          result::Err(e) => {\n+          result::Err(copy e) => {\n             assert e == ~\"error opening not a file\";\n           }\n           result::Ok(_) => fail\n@@ -938,7 +951,7 @@ mod tests {\n     #[test]\n     fn file_writer_bad_name() {\n         match io::file_writer(&Path(\"?/?\"), ~[]) {\n-          result::Err(e) => {\n+          result::Err(copy e) => {\n             assert str::starts_with(e, \"error opening\");\n           }\n           result::Ok(_) => fail\n@@ -948,7 +961,7 @@ mod tests {\n     #[test]\n     fn buffered_file_writer_bad_name() {\n         match io::buffered_file_writer(&Path(\"?/?\")) {\n-          result::Err(e) => {\n+          result::Err(copy e) => {\n             assert str::starts_with(e, \"error opening\");\n           }\n           result::Ok(_) => fail"}, {"sha": "09bfe2eff36a5470ccd25519815e588cbd7443d6", "filename": "src/libcore/iter-trait.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fiter-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fiter-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -2,51 +2,52 @@\n // workaround our lack of traits and lack of macros.  See core.{rc,rs} for\n // how this file is used.\n \n+#[warn(deprecated_mode)];\n+\n use cmp::{Eq, Ord};\n use inst::{IMPL_T, EACH, SIZE_HINT};\n-export extensions;\n \n impl<A> IMPL_T<A>: iter::BaseIter<A> {\n-    pure fn each(blk: fn(v: &A) -> bool) { EACH(self, blk) }\n-    pure fn size_hint() -> Option<uint> { SIZE_HINT(self) }\n+    pure fn each(blk: fn(v: &A) -> bool) { EACH(&self, blk) }\n+    pure fn size_hint() -> Option<uint> { SIZE_HINT(&self) }\n }\n \n impl<A> IMPL_T<A>: iter::ExtendedIter<A> {\n-    pure fn eachi(blk: fn(uint, v: &A) -> bool) { iter::eachi(self, blk) }\n-    pure fn all(blk: fn(A) -> bool) -> bool { iter::all(self, blk) }\n-    pure fn any(blk: fn(A) -> bool) -> bool { iter::any(self, blk) }\n-    pure fn foldl<B>(+b0: B, blk: fn(B, A) -> B) -> B {\n-        iter::foldl(self, move b0, blk)\n+    pure fn eachi(blk: fn(uint, v: &A) -> bool) { iter::eachi(&self, blk) }\n+    pure fn all(blk: fn(&A) -> bool) -> bool { iter::all(&self, blk) }\n+    pure fn any(blk: fn(&A) -> bool) -> bool { iter::any(&self, blk) }\n+    pure fn foldl<B>(b0: B, blk: fn(&B, &A) -> B) -> B {\n+        iter::foldl(&self, move b0, blk)\n     }\n-    pure fn position(f: fn(A) -> bool) -> Option<uint> {\n-        iter::position(self, f)\n+    pure fn position(f: fn(&A) -> bool) -> Option<uint> {\n+        iter::position(&self, f)\n     }\n }\n \n impl<A: Eq> IMPL_T<A>: iter::EqIter<A> {\n-    pure fn contains(x: A) -> bool { iter::contains(self, x) }\n-    pure fn count(x: A) -> uint { iter::count(self, x) }\n+    pure fn contains(x: &A) -> bool { iter::contains(&self, x) }\n+    pure fn count(x: &A) -> uint { iter::count(&self, x) }\n }\n \n impl<A: Copy> IMPL_T<A>: iter::CopyableIter<A> {\n-    pure fn filter_to_vec(pred: fn(A) -> bool) -> ~[A] {\n-        iter::filter_to_vec(self, pred)\n+    pure fn filter_to_vec(pred: fn(a: A) -> bool) -> ~[A] {\n+        iter::filter_to_vec(&self, pred)\n     }\n-    pure fn map_to_vec<B>(op: fn(v: &A) -> B) -> ~[B] {\n-        iter::map_to_vec(self, op)\n+    pure fn map_to_vec<B>(op: fn(v: A) -> B) -> ~[B] {\n+        iter::map_to_vec(&self, op)\n     }\n-    pure fn to_vec() -> ~[A] { iter::to_vec(self) }\n+    pure fn to_vec() -> ~[A] { iter::to_vec(&self) }\n \n-    // FIXME--bug in resolve prevents this from working (#2611)\n-    // fn flat_map_to_vec<B:copy,IB:base_iter<B>>(op: fn(A) -> IB) -> ~[B] {\n-    //     iter::flat_map_to_vec(self, op)\n-    // }\n+    pure fn flat_map_to_vec<B:Copy,IB:BaseIter<B>>(op: fn(a: A) -> IB)\n+        -> ~[B] {\n+        iter::flat_map_to_vec(&self, op)\n+    }\n \n-    pure fn find(p: fn(A) -> bool) -> Option<A> { iter::find(self, p) }\n+    pure fn find(p: fn(a: A) -> bool) -> Option<A> { iter::find(&self, p) }\n }\n \n impl<A: Copy Ord> IMPL_T<A>: iter::CopyableOrderedIter<A> {\n-    pure fn min() -> A { iter::min(self) }\n-    pure fn max() -> A { iter::max(self) }\n+    pure fn min() -> A { iter::min(&self) }\n+    pure fn max() -> A { iter::max(&self) }\n }\n "}, {"sha": "2a5bb59b0c1fc5165d36598e1ce732358f50150f", "filename": "src/libcore/iter-trait/dlist.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fiter-trait%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fiter-trait%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Fdlist.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -1,5 +1,5 @@\n #[allow(non_camel_case_types)]\n-type IMPL_T<A> = dlist::DList<A>;\n+pub type IMPL_T<A> = dlist::DList<A>;\n \n /**\n  * Iterates through the current contents.\n@@ -8,7 +8,7 @@ type IMPL_T<A> = dlist::DList<A>;\n  * e.g. breadth-first search with in-place enqueues), but removing the current\n  * node is forbidden.\n  */\n-pure fn EACH<A>(self: IMPL_T<A>, f: fn(v: &A) -> bool) {\n+pub pure fn EACH<A>(self: &IMPL_T<A>, f: fn(v: &A) -> bool) {\n     let mut link = self.peek_n();\n     while option::is_some(&link) {\n         let nobe = option::get(&link);\n@@ -29,6 +29,6 @@ pure fn EACH<A>(self: IMPL_T<A>, f: fn(v: &A) -> bool) {\n     }\n }\n \n-pure fn SIZE_HINT<A>(self: IMPL_T<A>) -> Option<uint> {\n+pub pure fn SIZE_HINT<A>(self: &IMPL_T<A>) -> Option<uint> {\n     Some(self.len())\n }"}, {"sha": "f03f1a154e4dd84205cb53ba2a92857d8dde42b8", "filename": "src/libcore/iter-trait/dvec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fiter-trait%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fiter-trait%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Fdvec.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -1,12 +1,12 @@\n #[allow(non_camel_case_types)]\n-type IMPL_T<A> = dvec::DVec<A>;\n+pub type IMPL_T<A> = dvec::DVec<A>;\n \n /**\n  * Iterates through the current contents.\n  *\n  * Attempts to access this dvec during iteration will fail.\n  */\n-pure fn EACH<A>(self: IMPL_T<A>, f: fn(v: &A) -> bool) {\n+pub pure fn EACH<A>(self: &IMPL_T<A>, f: fn(v: &A) -> bool) {\n     unsafe {\n         do self.swap |v| {\n             v.each(f);\n@@ -15,6 +15,6 @@ pure fn EACH<A>(self: IMPL_T<A>, f: fn(v: &A) -> bool) {\n     }\n }\n \n-pure fn SIZE_HINT<A>(self: IMPL_T<A>) -> Option<uint> {\n+pub pure fn SIZE_HINT<A>(self: &IMPL_T<A>) -> Option<uint> {\n     Some(self.len())\n }"}, {"sha": "44afe9f54f00c6eca225176f675ead7e268129b7", "filename": "src/libcore/iter-trait/option.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fiter-trait%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fiter-trait%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Foption.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -1,16 +1,16 @@\n #[allow(non_camel_case_types)]\n-type IMPL_T<A> = Option<A>;\n+pub type IMPL_T<A> = Option<A>;\n \n-pure fn EACH<A>(self: IMPL_T<A>, f: fn(v: &A) -> bool) {\n-    match self {\n+pub pure fn EACH<A>(self: &IMPL_T<A>, f: fn(v: &A) -> bool) {\n+    match *self {\n       None => (),\n       Some(ref a) => { f(a); }\n     }\n }\n \n-pure fn SIZE_HINT<A>(self: IMPL_T<A>) -> Option<uint> {\n-    match self {\n-      None => Some(0u),\n-      Some(_) => Some(1u)\n+pub pure fn SIZE_HINT<A>(self: &IMPL_T<A>) -> Option<uint> {\n+    match *self {\n+      None => Some(0),\n+      Some(_) => Some(1)\n     }\n }"}, {"sha": "bf3e91f7071925b5d87533811323f1fb881880e4", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 86, "deletions": 80, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -7,48 +7,49 @@ The iteration traits and common implementation\n use cmp::{Eq, Ord};\n \n /// A function used to initialize the elements of a sequence\n-type InitOp<T> = fn(uint) -> T;\n+pub type InitOp<T> = &fn(uint) -> T;\n \n-trait BaseIter<A> {\n+pub trait BaseIter<A> {\n     pure fn each(blk: fn(v: &A) -> bool);\n     pure fn size_hint() -> Option<uint>;\n }\n \n-trait ExtendedIter<A> {\n+pub trait ExtendedIter<A> {\n     pure fn eachi(blk: fn(uint, v: &A) -> bool);\n-    pure fn all(blk: fn(A) -> bool) -> bool;\n-    pure fn any(blk: fn(A) -> bool) -> bool;\n-    pure fn foldl<B>(+b0: B, blk: fn(B, A) -> B) -> B;\n-    pure fn position(f: fn(A) -> bool) -> Option<uint>;\n+    pure fn all(blk: fn(&A) -> bool) -> bool;\n+    pure fn any(blk: fn(&A) -> bool) -> bool;\n+    pure fn foldl<B>(b0: B, blk: fn(&B, &A) -> B) -> B;\n+    pure fn position(f: fn(&A) -> bool) -> Option<uint>;\n }\n \n-trait EqIter<A:Eq> {\n-    pure fn contains(x: A) -> bool;\n-    pure fn count(x: A) -> uint;\n+pub trait EqIter<A:Eq> {\n+    pure fn contains(x: &A) -> bool;\n+    pure fn count(x: &A) -> uint;\n }\n \n-trait Times {\n+pub trait Times {\n     pure fn times(it: fn() -> bool);\n }\n-trait TimesIx{\n+\n+pub trait TimesIx{\n     pure fn timesi(it: fn(uint) -> bool);\n }\n \n-trait CopyableIter<A:Copy> {\n-    pure fn filter_to_vec(pred: fn(A) -> bool) -> ~[A];\n-    pure fn map_to_vec<B>(op: fn(v: &A) -> B) -> ~[B];\n+pub trait CopyableIter<A:Copy> {\n+    pure fn filter_to_vec(pred: fn(a: A) -> bool) -> ~[A];\n+    pure fn map_to_vec<B>(op: fn(v: A) -> B) -> ~[B];\n     pure fn to_vec() -> ~[A];\n-    pure fn find(p: fn(A) -> bool) -> Option<A>;\n+    pure fn find(p: fn(a: A) -> bool) -> Option<A>;\n }\n \n-trait CopyableOrderedIter<A:Copy Ord> {\n+pub trait CopyableOrderedIter<A:Copy Ord> {\n     pure fn min() -> A;\n     pure fn max() -> A;\n }\n \n // A trait for sequences that can be by imperatively pushing elements\n // onto them.\n-trait Buildable<A> {\n+pub trait Buildable<A> {\n     /**\n      * Builds a buildable sequence by calling a provided function with\n      * an argument function that pushes an element onto the back of\n@@ -63,52 +64,55 @@ trait Buildable<A> {\n      *             onto the sequence being constructed.\n      */\n      static pure fn build_sized(size: uint,\n-                                builder: fn(push: pure fn(+v: A))) -> self;\n+                                builder: fn(push: pure fn(v: A))) -> self;\n }\n \n-pure fn eachi<A,IA:BaseIter<A>>(self: IA, blk: fn(uint, v: &A) -> bool) {\n-    let mut i = 0u;\n+pub pure fn eachi<A,IA:BaseIter<A>>(self: &IA,\n+                                    blk: fn(uint, v: &A) -> bool) {\n+    let mut i = 0;\n     for self.each |a| {\n         if !blk(i, a) { break; }\n-        i += 1u;\n+        i += 1;\n     }\n }\n \n-pure fn all<A,IA:BaseIter<A>>(self: IA, blk: fn(A) -> bool) -> bool {\n+pub pure fn all<A,IA:BaseIter<A>>(self: &IA,\n+                                  blk: fn(&A) -> bool) -> bool {\n     for self.each |a| {\n-        if !blk(*a) { return false; }\n+        if !blk(a) { return false; }\n     }\n     return true;\n }\n \n-pure fn any<A,IA:BaseIter<A>>(self: IA, blk: fn(A) -> bool) -> bool {\n+pub pure fn any<A,IA:BaseIter<A>>(self: &IA,\n+                                  blk: fn(&A) -> bool) -> bool {\n     for self.each |a| {\n-        if blk(*a) { return true; }\n+        if blk(a) { return true; }\n     }\n     return false;\n }\n \n-pure fn filter_to_vec<A:Copy,IA:BaseIter<A>>(self: IA,\n-                                         prd: fn(A) -> bool) -> ~[A] {\n+pub pure fn filter_to_vec<A:Copy,IA:BaseIter<A>>(\n+    self: &IA, prd: fn(a: A) -> bool) -> ~[A] {\n     do vec::build_sized_opt(self.size_hint()) |push| {\n         for self.each |a| {\n             if prd(*a) { push(*a); }\n         }\n     }\n }\n \n-pure fn map_to_vec<A:Copy,B,IA:BaseIter<A>>(self: IA, op: fn(v: &A) -> B)\n+pub pure fn map_to_vec<A:Copy,B,IA:BaseIter<A>>(self: &IA,\n+                                                op: fn(v: A) -> B)\n     -> ~[B] {\n     do vec::build_sized_opt(self.size_hint()) |push| {\n         for self.each |a| {\n-            push(op(a));\n+            push(op(*a));\n         }\n     }\n }\n \n-pure fn flat_map_to_vec<A:Copy,B:Copy,IA:BaseIter<A>,IB:BaseIter<B>>(\n-    self: IA, op: fn(A) -> IB) -> ~[B] {\n-\n+pub pure fn flat_map_to_vec<A:Copy,B:Copy,IA:BaseIter<A>,IB:BaseIter<B>>(\n+    self: &IA, op: fn(a: A) -> IB) -> ~[B] {\n     do vec::build |push| {\n         for self.each |a| {\n             for op(*a).each |b| {\n@@ -118,41 +122,43 @@ pure fn flat_map_to_vec<A:Copy,B:Copy,IA:BaseIter<A>,IB:BaseIter<B>>(\n     }\n }\n \n-pure fn foldl<A,B,IA:BaseIter<A>>(self: IA, +b0: B, blk: fn(B, A) -> B) -> B {\n+pub pure fn foldl<A,B,IA:BaseIter<A>>(self: &IA, b0: B,\n+                                      blk: fn(&B, &A) -> B)\n+    -> B {\n     let mut b <- b0;\n     for self.each |a| {\n-        b = blk(b, *a);\n+        b = blk(&b, a);\n     }\n     move b\n }\n \n-pure fn to_vec<A:Copy,IA:BaseIter<A>>(self: IA) -> ~[A] {\n-    foldl::<A,~[A],IA>(self, ~[], |r, a| vec::append(copy r, ~[a]))\n+pub pure fn to_vec<A:Copy,IA:BaseIter<A>>(self: &IA) -> ~[A] {\n+    foldl::<A,~[A],IA>(self, ~[], |r, a| vec::append(copy (*r), ~[*a]))\n }\n \n-pure fn contains<A:Eq,IA:BaseIter<A>>(self: IA, x: A) -> bool {\n+pub pure fn contains<A:Eq,IA:BaseIter<A>>(self: &IA, x: &A) -> bool {\n     for self.each |a| {\n-        if *a == x { return true; }\n+        if *a == *x { return true; }\n     }\n     return false;\n }\n \n-pure fn count<A:Eq,IA:BaseIter<A>>(self: IA, x: A) -> uint {\n-    do foldl(self, 0u) |count, value| {\n-        if value == x {\n-            count + 1u\n+pub pure fn count<A:Eq,IA:BaseIter<A>>(self: &IA, x: &A) -> uint {\n+    do foldl(self, 0) |count, value| {\n+        if *value == *x {\n+            *count + 1\n         } else {\n-            count\n+            *count\n         }\n     }\n }\n \n-pure fn position<A,IA:BaseIter<A>>(self: IA, f: fn(A) -> bool)\n+pub pure fn position<A,IA:BaseIter<A>>(self: &IA, f: fn(&A) -> bool)\n     -> Option<uint>\n {\n     let mut i = 0;\n     for self.each |a| {\n-        if f(*a) { return Some(i); }\n+        if f(a) { return Some(i); }\n         i += 1;\n     }\n     return None;\n@@ -162,48 +168,44 @@ pure fn position<A,IA:BaseIter<A>>(self: IA, f: fn(A) -> bool)\n // iter interface, such as would provide \"reach\" in addition to \"each\". as is,\n // it would have to be implemented with foldr, which is too inefficient.\n \n-pure fn repeat(times: uint, blk: fn() -> bool) {\n-    let mut i = 0u;\n+pub pure fn repeat(times: uint, blk: fn() -> bool) {\n+    let mut i = 0;\n     while i < times {\n         if !blk() { break }\n-        i += 1u;\n+        i += 1;\n     }\n }\n \n-pure fn min<A:Copy Ord,IA:BaseIter<A>>(self: IA) -> A {\n+pub pure fn min<A:Copy Ord,IA:BaseIter<A>>(self: &IA) -> A {\n     match do foldl::<A,Option<A>,IA>(self, None) |a, b| {\n         match a {\n-          Some(a_) if a_ < b => {\n-            // FIXME (#2005): Not sure if this is successfully optimized to\n-            // a move\n-            a\n+          &Some(ref a_) if *a_ < *b => {\n+             *(move a)\n           }\n-          _ => Some(b)\n+          _ => Some(*b)\n         }\n     } {\n-        Some(val) => val,\n+        Some(move val) => val,\n         None => fail ~\"min called on empty iterator\"\n     }\n }\n \n-pure fn max<A:Copy Ord,IA:BaseIter<A>>(self: IA) -> A {\n+pub pure fn max<A:Copy Ord,IA:BaseIter<A>>(self: &IA) -> A {\n     match do foldl::<A,Option<A>,IA>(self, None) |a, b| {\n         match a {\n-          Some(a_) if a_ > b => {\n-            // FIXME (#2005): Not sure if this is successfully optimized to\n-            // a move.\n-            a\n+          &Some(ref a_) if *a_ > *b => {\n+              *(move a)\n           }\n-          _ => Some(b)\n+          _ => Some(*b)\n         }\n     } {\n-        Some(val) => val,\n+        Some(move val) => val,\n         None => fail ~\"max called on empty iterator\"\n     }\n }\n \n-pure fn find<A: Copy,IA:BaseIter<A>>(self: IA,\n-                                     p: fn(A) -> bool) -> Option<A> {\n+pub pure fn find<A: Copy,IA:BaseIter<A>>(self: &IA,\n+                                     p: fn(a: A) -> bool) -> Option<A> {\n     for self.each |i| {\n         if p(*i) { return Some(*i) }\n     }\n@@ -223,7 +225,8 @@ pure fn find<A: Copy,IA:BaseIter<A>>(self: IA,\n  *             onto the sequence being constructed.\n  */\n #[inline(always)]\n-pure fn build<A,B: Buildable<A>>(builder: fn(push: pure fn(+v: A))) -> B {\n+pub pure fn build<A,B: Buildable<A>>(builder: fn(push: pure fn(v: A)))\n+    -> B {\n     build_sized(4, builder)\n }\n \n@@ -241,20 +244,21 @@ pure fn build<A,B: Buildable<A>>(builder: fn(push: pure fn(+v: A))) -> B {\n  *             onto the sequence being constructed.\n  */\n #[inline(always)]\n-pure fn build_sized_opt<A,B: Buildable<A>>(\n+pub pure fn build_sized_opt<A,B: Buildable<A>>(\n     size: Option<uint>,\n-    builder: fn(push: pure fn(+v: A))) -> B {\n+    builder: fn(push: pure fn(v: A))) -> B {\n \n     build_sized(size.get_default(4), builder)\n }\n \n // Functions that combine iteration and building\n \n /// Apply a function to each element of an iterable and return the results\n-fn map<T,IT: BaseIter<T>,U,BU: Buildable<U>>(v: IT, f: fn(T) -> U) -> BU {\n+pub fn map<T,IT: BaseIter<T>,U,BU: Buildable<U>>(v: &IT, f: fn(&T) -> U)\n+    -> BU {\n     do build_sized_opt(v.size_hint()) |push| {\n         for v.each() |elem| {\n-            push(f(*elem));\n+            push(f(elem));\n         }\n     }\n }\n@@ -265,7 +269,8 @@ fn map<T,IT: BaseIter<T>,U,BU: Buildable<U>>(v: IT, f: fn(T) -> U) -> BU {\n  * Creates a generic sequence of size `n_elts` and initializes the elements\n  * to the value returned by the function `op`.\n  */\n-pure fn from_fn<T,BT: Buildable<T>>(n_elts: uint, op: InitOp<T>) -> BT {\n+pub pure fn from_fn<T,BT: Buildable<T>>(n_elts: uint,\n+                                        op: InitOp<T>) -> BT {\n     do build_sized(n_elts) |push| {\n         let mut i: uint = 0u;\n         while i < n_elts { push(op(i)); i += 1u; }\n@@ -278,19 +283,20 @@ pure fn from_fn<T,BT: Buildable<T>>(n_elts: uint, op: InitOp<T>) -> BT {\n  * Creates an immutable vector of size `n_elts` and initializes the elements\n  * to the value `t`.\n  */\n-pure fn from_elem<T: Copy,BT: Buildable<T>>(n_elts: uint, t: T) -> BT {\n+pub pure fn from_elem<T: Copy,BT: Buildable<T>>(n_elts: uint,\n+                                                t: T) -> BT {\n     do build_sized(n_elts) |push| {\n-        let mut i: uint = 0u;\n-        while i < n_elts { push(t); i += 1u; }\n+        let mut i: uint = 0;\n+        while i < n_elts { push(t); i += 1; }\n     }\n }\n \n /// Appending two generic sequences\n #[inline(always)]\n-pure fn append<T: Copy,IT: BaseIter<T>,BT: Buildable<T>>(\n-    lhs: IT, rhs: IT) -> BT {\n-    let size_opt = lhs.size_hint().chain(\n-        |sz1| rhs.size_hint().map(|sz2| sz1+sz2));\n+pub pure fn append<T: Copy,IT: BaseIter<T>,BT: Buildable<T>>(\n+    lhs: &IT, rhs: &IT) -> BT {\n+    let size_opt = lhs.size_hint().chain_ref(\n+        |sz1| rhs.size_hint().map(|sz2| *sz1+*sz2));\n     do build_sized_opt(size_opt) |push| {\n         for lhs.each |x| { push(*x); }\n         for rhs.each |x| { push(*x); }\n@@ -300,8 +306,8 @@ pure fn append<T: Copy,IT: BaseIter<T>,BT: Buildable<T>>(\n /// Copies a generic sequence, possibly converting it to a different\n /// type of sequence.\n #[inline(always)]\n-pure fn copy_seq<T: Copy,IT: BaseIter<T>,BT: Buildable<T>>(\n-    v: IT) -> BT {\n+pub pure fn copy_seq<T: Copy,IT: BaseIter<T>,BT: Buildable<T>>(\n+    v: &IT) -> BT {\n     do build_sized_opt(v.size_hint()) |push| {\n         for v.each |x| { push(*x); }\n     }"}, {"sha": "3665128bf3ca53588e32b5f1257576ed2c4586ab", "filename": "src/libcore/libc.rs", "status": "modified", "additions": 676, "deletions": 775, "changes": 1451, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flibc.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -2,40 +2,40 @@\n #[forbid(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n /*!\n- * Bindings for libc.\n- *\n- * We consider the following specs reasonably normative with respect\n- * to interoperating with the C standard library (libc/msvcrt):\n- *\n- * * ISO 9899:1990 ('C95', 'ANSI C', 'Standard C'), NA1, 1995.\n- * * ISO 9899:1999 ('C99' or 'C9x').\n- * * ISO 9945:1988 / IEEE 1003.1-1988 ('POSIX.1').\n- * * ISO 9945:2001 / IEEE 1003.1-2001 ('POSIX:2001', 'SUSv3').\n- * * ISO 9945:2008 / IEEE 1003.1-2008 ('POSIX:2008', 'SUSv4').\n- *\n- * Despite having several names each, these are *reasonably* coherent\n- * point-in-time, list-of-definition sorts of specs. You can get each under a\n- * variety of names but will wind up with the same definition in each case.\n- *\n- * Our interface to these libraries is complicated by the non-universality of\n- * conformance to any of them. About the only thing universally supported is\n- * the first (C95), beyond that definitions quickly become absent on various\n- * platforms.\n- *\n- * We therefore wind up dividing our module-space up (mostly for the sake of\n- * sanity while editing, filling-in-details and eliminating duplication) into\n- * definitions common-to-all (held in modules named c95, c99, posix88, posix01\n- * and posix08) and definitions that appear only on *some* platforms (named\n- * 'extra'). This would be things like significant OSX foundation kit, or\n- * win32 library kernel32.dll, or various fancy glibc, linux or BSD\n- * extensions.\n- *\n- * In addition to the per-platform 'extra' modules, we define a module of\n- * 'common BSD' libc routines that never quite made it into POSIX but show up\n- * in multiple derived systems. This is the 4.4BSD r2 / 1995 release, the\n- * final one from Berkeley after the lawsuits died down and the CSRG\n- * dissolved.\n- */\n+* Bindings for libc.\n+*\n+* We consider the following specs reasonably normative with respect\n+* to interoperating with the C standard library (libc/msvcrt):\n+*\n+* * ISO 9899:1990 ('C95', 'ANSI C', 'Standard C'), NA1, 1995.\n+* * ISO 9899:1999 ('C99' or 'C9x').\n+* * ISO 9945:1988 / IEEE 1003.1-1988 ('POSIX.1').\n+* * ISO 9945:2001 / IEEE 1003.1-2001 ('POSIX:2001', 'SUSv3').\n+* * ISO 9945:2008 / IEEE 1003.1-2008 ('POSIX:2008', 'SUSv4').\n+*\n+* Despite having several names each, these are *reasonably* coherent\n+* point-in-time, list-of-definition sorts of specs. You can get each under a\n+* variety of names but will wind up with the same definition in each case.\n+*\n+* Our interface to these libraries is complicated by the non-universality of\n+* conformance to any of them. About the only thing universally supported is\n+* the first (C95), beyond that definitions quickly become absent on various\n+* platforms.\n+*\n+* We therefore wind up dividing our module-space up (mostly for the sake of\n+* sanity while editing, filling-in-details and eliminating duplication) into\n+* definitions common-to-all (held in modules named c95, c99, posix88, posix01\n+* and posix08) and definitions that appear only on *some* platforms (named\n+* 'extra'). This would be things like significant OSX foundation kit, or\n+* win32 library kernel32.dll, or various fancy glibc, linux or BSD\n+* extensions.\n+*\n+* In addition to the per-platform 'extra' modules, we define a module of\n+* 'common BSD' libc routines that never quite made it into POSIX but show up\n+* in multiple derived systems. This is the 4.4BSD r2 / 1995 release, the\n+* final one from Berkeley after the lawsuits died down and the CSRG\n+* dissolved.\n+*/\n \n #[allow(non_camel_case_types)];\n \n@@ -44,795 +44,721 @@\n \n // FIXME (#2006): change these to glob-exports when sufficiently supported.\n \n-use types::common::c95::*;\n-use types::common::c99::*;\n-use types::common::posix88::*;\n-use types::common::posix01::*;\n-use types::common::posix08::*;\n-use types::common::bsd44::*;\n-use types::os::arch::c95::*;\n-use types::os::arch::c99::*;\n-use types::os::arch::posix88::*;\n-use types::os::arch::posix01::*;\n-use types::os::arch::posix08::*;\n-use types::os::arch::bsd44::*;\n-use types::os::arch::extra::*;\n-\n-use consts::os::c95::*;\n-use consts::os::c99::*;\n-use consts::os::posix88::*;\n-use consts::os::posix01::*;\n-use consts::os::posix08::*;\n-use consts::os::bsd44::*;\n-use consts::os::extra::*;\n-\n-use funcs::c95::ctype::*;\n-use funcs::c95::stdio::*;\n-use funcs::c95::stdlib::*;\n-use funcs::c95::string::*;\n-\n-use funcs::posix88::stat::*;\n-use funcs::posix88::stdio::*;\n-use funcs::posix88::fcntl::*;\n-use funcs::posix88::dirent::*;\n-use funcs::posix88::unistd::*;\n-\n-use funcs::posix01::unistd::*;\n-use funcs::posix08::unistd::*;\n-\n-use funcs::bsd44::*;\n-use funcs::extra::*;\n-\n-// FIXME (#2006): remove these 3 exports (and their uses next door in os::)\n-// when export globs work. They provide access (for now) for os:: to dig\n-// around in the rest of the platform-specific definitions.\n-\n-export types, funcs, consts;\n+pub use types::common::c95::*;\n+pub use types::common::c99::*;\n+pub use types::common::posix88::*;\n+pub use types::common::posix01::*;\n+pub use types::common::posix08::*;\n+pub use types::common::bsd44::*;\n+pub use types::os::arch::c95::*;\n+pub use types::os::arch::c99::*;\n+pub use types::os::arch::posix88::*;\n+pub use types::os::arch::posix01::*;\n+pub use types::os::arch::posix08::*;\n+pub use types::os::arch::bsd44::*;\n+pub use types::os::arch::extra::*;\n+\n+pub use consts::os::c95::*;\n+pub use consts::os::c99::*;\n+pub use consts::os::posix88::*;\n+pub use consts::os::posix01::*;\n+pub use consts::os::posix08::*;\n+pub use consts::os::bsd44::*;\n+pub use consts::os::extra::*;\n+\n+pub use funcs::c95::ctype::*;\n+pub use funcs::c95::stdio::*;\n+pub use funcs::c95::stdlib::*;\n+pub use funcs::c95::string::*;\n+\n+pub use funcs::posix88::stat::*;\n+pub use funcs::posix88::stdio::*;\n+pub use funcs::posix88::fcntl::*;\n+pub use funcs::posix88::dirent::*;\n+pub use funcs::posix88::unistd::*;\n+\n+pub use funcs::posix01::unistd::*;\n+pub use funcs::posix08::unistd::*;\n+\n+pub use funcs::bsd44::*;\n+pub use funcs::extra::*;\n \n // Explicit export lists for the intersection (provided here) mean that\n // you can write more-platform-agnostic code if you stick to just these\n // symbols.\n \n-export c_float, c_double, c_void, FILE, fpos_t;\n-export DIR, dirent;\n-export c_char, c_schar, c_uchar;\n-export c_short, c_ushort, c_int, c_uint, c_long, c_ulong;\n-export size_t, ptrdiff_t, clock_t, time_t;\n-export c_longlong, c_ulonglong, intptr_t, uintptr_t;\n-export off_t, dev_t, ino_t, pid_t, mode_t, ssize_t;\n+pub use size_t;\n+pub use c_float, c_double, c_void, FILE, fpos_t;\n+pub use DIR, dirent;\n+pub use c_char, c_schar, c_uchar;\n+pub use c_short, c_ushort, c_int, c_uint, c_long, c_ulong;\n+pub use size_t, ptrdiff_t, clock_t, time_t;\n+pub use c_longlong, c_ulonglong, intptr_t, uintptr_t;\n+pub use off_t, dev_t, ino_t, pid_t, mode_t, ssize_t;\n \n-export EXIT_FAILURE, EXIT_SUCCESS, RAND_MAX,\n-       EOF, SEEK_SET, SEEK_CUR, SEEK_END, _IOFBF, _IONBF, _IOLBF,\n-       BUFSIZ, FOPEN_MAX, FILENAME_MAX, L_tmpnam, TMP_MAX,\n-       O_RDONLY, O_WRONLY, O_RDWR, O_APPEND, O_CREAT, O_EXCL, O_TRUNC,\n-       S_IFIFO, S_IFCHR, S_IFBLK, S_IFDIR, S_IFREG, S_IFMT, S_IEXEC,\n-       S_IWRITE, S_IREAD, S_IRWXU, S_IXUSR, S_IWUSR, S_IRUSR, F_OK, R_OK,\n-       W_OK, X_OK, STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO;\n+pub use EXIT_FAILURE, EXIT_SUCCESS, RAND_MAX,\n+EOF, SEEK_SET, SEEK_CUR, SEEK_END, _IOFBF, _IONBF, _IOLBF,\n+BUFSIZ, FOPEN_MAX, FILENAME_MAX, L_tmpnam, TMP_MAX,\n+O_RDONLY, O_WRONLY, O_RDWR, O_APPEND, O_CREAT, O_EXCL, O_TRUNC,\n+S_IFIFO, S_IFCHR, S_IFBLK, S_IFDIR, S_IFREG, S_IFMT, S_IEXEC,\n+S_IWRITE, S_IREAD, S_IRWXU, S_IXUSR, S_IWUSR, S_IRUSR, F_OK, R_OK,\n+W_OK, X_OK, STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO;\n \n-export isalnum, isalpha, iscntrl, isdigit, islower, isprint, ispunct,\n-       isspace, isupper, isxdigit, tolower, toupper;\n+pub use isalnum, isalpha, iscntrl, isdigit, islower, isprint, ispunct,\n+isspace, isupper, isxdigit, tolower, toupper;\n \n-export fopen, freopen, fflush, fclose, remove, tmpfile, setvbuf, setbuf,\n-       fgetc, fgets, fputc, fputs, puts, ungetc, fread, fwrite, fseek, ftell,\n-       rewind, fgetpos, fsetpos, feof, ferror, perror;\n+pub use fopen, freopen, fflush, fclose, remove, tmpfile, setvbuf, setbuf,\n+fgetc, fgets, fputc, fputs, puts, ungetc, fread, fwrite, fseek, ftell,\n+rewind, fgetpos, fsetpos, feof, ferror, perror;\n \n-export abs, labs, atof, atoi, strtod, strtol, strtoul, calloc, malloc,\n-       realloc, free, abort, exit, system, getenv, rand, srand;\n+pub use abs, labs, atof, atoi, strtod, strtol, strtoul, calloc, malloc,\n+realloc, free, abort, exit, system, getenv, rand, srand;\n \n-export strcpy, strncpy, strcat, strncat, strcmp, strncmp, strcoll, strchr,\n-       strrchr, strspn, strcspn, strpbrk, strstr, strlen, strerror, strtok,\n-       strxfrm, memcpy, memmove, memcmp, memchr, memset;\n+pub use strcpy, strncpy, strcat, strncat, strcmp, strncmp, strcoll, strchr,\n+strrchr, strspn, strcspn, strpbrk, strstr, strlen, strerror, strtok,\n+strxfrm, memcpy, memmove, memcmp, memchr, memset;\n \n-export chmod, mkdir;\n-export popen, pclose, fdopen, fileno;\n-export open, creat;\n-export access, chdir, close, dup, dup2, execv, execve, execvp, getcwd,\n-       getpid, isatty, lseek, pipe, read, rmdir, unlink, write;\n+pub use chmod, mkdir;\n+pub use popen, pclose, fdopen, fileno;\n+pub use open, creat;\n+pub use access, chdir, close, dup, dup2, execv, execve, execvp, getcwd,\n+getpid, isatty, lseek, pipe, read, rmdir, unlink, write;\n \n \n mod types {\n-    #[legacy_exports];\n \n     // Types tend to vary *per architecture* so we pull their definitions out\n     // into this module.\n \n     // Standard types that are opaque or common, so are not per-target.\n-    mod common {\n-        #[legacy_exports];\n-        mod c95 {\n-            #[legacy_exports];\n-            enum c_void {}\n-            enum FILE {}\n-            enum fpos_t {}\n+    pub mod common {\n+        pub mod c95 {\n+            pub enum c_void {}\n+            pub enum FILE {}\n+            pub enum fpos_t {}\n         }\n-        mod c99 {\n-            #[legacy_exports];\n-            type int8_t = i8;\n-            type int16_t = i16;\n-            type int32_t = i32;\n-            type int64_t = i64;\n-            type uint8_t = u8;\n-            type uint16_t = u16;\n-            type uint32_t = u32;\n-            type uint64_t = u64;\n+        pub mod c99 {\n+            pub type int8_t = i8;\n+            pub type int16_t = i16;\n+            pub type int32_t = i32;\n+            pub type int64_t = i64;\n+            pub type uint8_t = u8;\n+            pub type uint16_t = u16;\n+            pub type uint32_t = u32;\n+            pub type uint64_t = u64;\n         }\n-        mod posix88 {\n-            #[legacy_exports];\n-            enum DIR {}\n-            enum dirent {}\n+        pub mod posix88 {\n+            pub enum DIR {}\n+            pub enum dirent {}\n         }\n-        mod posix01 {\n-            #[legacy_exports]; }\n-        mod posix08 {\n-            #[legacy_exports]; }\n-        mod bsd44 {\n-            #[legacy_exports]; }\n+        pub mod posix01 {}\n+        pub mod posix08 {}\n+        pub mod bsd44 {}\n     }\n \n     // Standard types that are scalar but vary by OS and arch.\n \n     #[cfg(target_os = \"linux\")]\n-    mod os {\n-        #[legacy_exports];\n+    pub mod os {\n         #[cfg(target_arch = \"x86\")]\n-        mod arch {\n-            #[legacy_exports];\n-            mod c95 {\n-                #[legacy_exports];\n-                type c_char = i8;\n-                type c_schar = i8;\n-                type c_uchar = u8;\n-                type c_short = i16;\n-                type c_ushort = u16;\n-                type c_int = i32;\n-                type c_uint = u32;\n-                type c_long = i32;\n-                type c_ulong = u32;\n-                type c_float = f32;\n-                type c_double = f64;\n-                type size_t = u32;\n-                type ptrdiff_t = i32;\n-                type clock_t = i32;\n-                type time_t = i32;\n-                type wchar_t = i32;\n+        pub mod arch {\n+            pub mod c95 {\n+                pub type c_char = i8;\n+                pub type c_schar = i8;\n+                pub type c_uchar = u8;\n+                pub type c_short = i16;\n+                pub type c_ushort = u16;\n+                pub type c_int = i32;\n+                pub type c_uint = u32;\n+                pub type c_long = i32;\n+                pub type c_ulong = u32;\n+                pub type c_float = f32;\n+                pub type c_double = f64;\n+                pub type size_t = u32;\n+                pub type ptrdiff_t = i32;\n+                pub type clock_t = i32;\n+                pub type time_t = i32;\n+                pub type wchar_t = i32;\n             }\n-            mod c99 {\n-                #[legacy_exports];\n-                type c_longlong = i64;\n-                type c_ulonglong = u64;\n-                type intptr_t = int;\n-                type uintptr_t = uint;\n+            pub mod c99 {\n+                pub type c_longlong = i64;\n+                pub type c_ulonglong = u64;\n+                pub type intptr_t = int;\n+                pub type uintptr_t = uint;\n             }\n-            mod posix88 {\n-                #[legacy_exports];\n-                type off_t = i32;\n-                type dev_t = u64;\n-                type ino_t = u32;\n-                type pid_t = i32;\n-                type uid_t = u32;\n-                type gid_t = u32;\n-                type useconds_t = u32;\n-                type mode_t = u32;\n-                type ssize_t = i32;\n-            }\n-            mod posix01 {\n-                #[legacy_exports]; }\n-            mod posix08 {\n-                #[legacy_exports]; }\n-            mod bsd44 {\n-                #[legacy_exports]; }\n-            mod extra {\n-                #[legacy_exports];\n+            pub mod posix88 {\n+                pub type off_t = i32;\n+                pub type dev_t = u64;\n+                pub type ino_t = u32;\n+                pub type pid_t = i32;\n+                pub type uid_t = u32;\n+                pub type gid_t = u32;\n+                pub type useconds_t = u32;\n+                pub type mode_t = u32;\n+                pub type ssize_t = i32;\n             }\n+            pub mod posix01 {}\n+            pub mod posix08 {}\n+            pub mod bsd44 {}\n+            pub mod extra {}\n         }\n \n         #[cfg(target_arch = \"x86_64\")]\n-        mod arch {\n-            #[legacy_exports];\n-            mod c95 {\n-                #[legacy_exports];\n-                type c_char = i8;\n-                type c_schar = i8;\n-                type c_uchar = u8;\n-                type c_short = i16;\n-                type c_ushort = u16;\n-                type c_int = i32;\n-                type c_uint = u32;\n-                type c_long = i64;\n-                type c_ulong = u64;\n-                type c_float = f32;\n-                type c_double = f64;\n-                type size_t = u64;\n-                type ptrdiff_t = i64;\n-                type clock_t = i64;\n-                type time_t = i64;\n-                type wchar_t = i32;\n+        pub mod arch {\n+            pub mod c95 {\n+                pub type c_char = i8;\n+                pub type c_schar = i8;\n+                pub type c_uchar = u8;\n+                pub type c_short = i16;\n+                pub type c_ushort = u16;\n+                pub type c_int = i32;\n+                pub type c_uint = u32;\n+                pub type c_long = i64;\n+                pub type c_ulong = u64;\n+                pub type c_float = f32;\n+                pub type c_double = f64;\n+                pub type size_t = u64;\n+                pub type ptrdiff_t = i64;\n+                pub type clock_t = i64;\n+                pub type time_t = i64;\n+                pub type wchar_t = i32;\n+            }\n+            pub mod c99 {\n+                pub type c_longlong = i64;\n+                pub type c_ulonglong = u64;\n+                pub type intptr_t = int;\n+                pub type uintptr_t = uint;\n+            }\n+            pub mod posix88 {\n+                pub type off_t = i64;\n+                pub type dev_t = u64;\n+                pub type ino_t = u64;\n+                pub type pid_t = i32;\n+                pub type uid_t = u32;\n+                pub type gid_t = u32;\n+                pub type useconds_t = u32;\n+                pub type mode_t = u32;\n+                pub type ssize_t = i64;\n             }\n-            mod c99 {\n-                #[legacy_exports];\n-                type c_longlong = i64;\n-                type c_ulonglong = u64;\n-                type intptr_t = int;\n-                type uintptr_t = uint;\n+            pub mod posix01 {\n             }\n-            mod posix88 {\n-                #[legacy_exports];\n-                type off_t = i64;\n-                type dev_t = u64;\n-                type ino_t = u64;\n-                type pid_t = i32;\n-                type uid_t = u32;\n-                type gid_t = u32;\n-                type useconds_t = u32;\n-                type mode_t = u32;\n-                type ssize_t = i64;\n+            pub mod posix08 {\n             }\n-            mod posix01 {\n-                #[legacy_exports]; }\n-            mod posix08 {\n-                #[legacy_exports]; }\n-            mod bsd44 {\n-                #[legacy_exports]; }\n-            mod extra {\n-                #[legacy_exports];\n+            pub mod bsd44 {\n+            }\n+            pub mod extra {\n             }\n         }\n     }\n \n     #[cfg(target_os = \"freebsd\")]\n-    mod os {\n-        #[legacy_exports];\n+    pub mod os {\n         #[cfg(target_arch = \"x86_64\")]\n-        mod arch {\n-            #[legacy_exports];\n-            mod c95 {\n-                #[legacy_exports];\n-                type c_char = i8;\n-                type c_schar = i8;\n-                type c_uchar = u8;\n-                type c_short = i16;\n-                type c_ushort = u16;\n-                type c_int = i32;\n-                type c_uint = u32;\n-                type c_long = i64;\n-                type c_ulong = u64;\n-                type c_float = f32;\n-                type c_double = f64;\n-                type size_t = u64;\n-                type ptrdiff_t = i64;\n-                type clock_t = i32;\n-                type time_t = i64;\n-                type wchar_t = i32;\n+        pub mod arch {\n+            pub mod c95 {\n+                pub type c_char = i8;\n+                pub type c_schar = i8;\n+                pub type c_uchar = u8;\n+                pub type c_short = i16;\n+                pub type c_ushort = u16;\n+                pub type c_int = i32;\n+                pub type c_uint = u32;\n+                pub type c_long = i64;\n+                pub type c_ulong = u64;\n+                pub type c_float = f32;\n+                pub type c_double = f64;\n+                pub type size_t = u64;\n+                pub type ptrdiff_t = i64;\n+                pub type clock_t = i32;\n+                pub type time_t = i64;\n+                pub type wchar_t = i32;\n+            }\n+            pub mod c99 {\n+                pub type c_longlong = i64;\n+                pub type c_ulonglong = u64;\n+                pub type intptr_t = int;\n+                pub type uintptr_t = uint;\n+            }\n+            pub mod posix88 {\n+                pub type off_t = i64;\n+                pub type dev_t = u32;\n+                pub type ino_t = u32;\n+                pub type pid_t = i32;\n+                pub type uid_t = u32;\n+                pub type gid_t = u32;\n+                pub type useconds_t = u32;\n+                pub type mode_t = u16;\n+                pub type ssize_t = i64;\n             }\n-            mod c99 {\n-                #[legacy_exports];\n-                type c_longlong = i64;\n-                type c_ulonglong = u64;\n-                type intptr_t = int;\n-                type uintptr_t = uint;\n+            pub mod posix01 {\n             }\n-            mod posix88 {\n-                #[legacy_exports];\n-                type off_t = i64;\n-                type dev_t = u32;\n-                type ino_t = u32;\n-                type pid_t = i32;\n-                type uid_t = u32;\n-                type gid_t = u32;\n-                type useconds_t = u32;\n-                type mode_t = u16;\n-                type ssize_t = i64;\n+            pub mod posix08 {\n             }\n-            mod posix01 {\n-                #[legacy_exports]; }\n-            mod posix08 {\n-                #[legacy_exports]; }\n-            mod bsd44 {\n-                #[legacy_exports]; }\n-            mod extra {\n-                #[legacy_exports];\n+            pub mod bsd44 {\n+            }\n+            pub mod extra {\n             }\n         }\n     }\n \n     #[cfg(target_os = \"win32\")]\n-    mod os {\n-        #[legacy_exports];\n+    pub mod os {\n         #[cfg(target_arch = \"x86\")]\n-        mod arch {\n-            #[legacy_exports];\n-            mod c95 {\n-                #[legacy_exports];\n-                type c_char = i8;\n-                type c_schar = i8;\n-                type c_uchar = u8;\n-                type c_short = i16;\n-                type c_ushort = u16;\n-                type c_int = i32;\n-                type c_uint = u32;\n-                type c_long = i32;\n-                type c_ulong = u32;\n-                type c_float = f32;\n-                type c_double = f64;\n-                type size_t = u32;\n-                type ptrdiff_t = i32;\n-                type clock_t = i32;\n-                type time_t = i32;\n-                type wchar_t = u16;\n+        pub mod arch {\n+            pub mod c95 {\n+                pub type c_char = i8;\n+                pub type c_schar = i8;\n+                pub type c_uchar = u8;\n+                pub type c_short = i16;\n+                pub type c_ushort = u16;\n+                pub type c_int = i32;\n+                pub type c_uint = u32;\n+                pub type c_long = i32;\n+                pub type c_ulong = u32;\n+                pub type c_float = f32;\n+                pub type c_double = f64;\n+                pub type size_t = u32;\n+                pub type ptrdiff_t = i32;\n+                pub type clock_t = i32;\n+                pub type time_t = i32;\n+                pub type wchar_t = u16;\n+            }\n+            pub mod c99 {\n+                pub type c_longlong = i64;\n+                pub type c_ulonglong = u64;\n+                pub type intptr_t = int;\n+                pub type uintptr_t = uint;\n+            }\n+            pub mod posix88 {\n+                pub type off_t = i32;\n+                pub type dev_t = u32;\n+                pub type ino_t = i16;\n+                pub type pid_t = i32;\n+                pub type useconds_t = u32;\n+                pub type mode_t = u16;\n+                pub type ssize_t = i32;\n             }\n-            mod c99 {\n-                #[legacy_exports];\n-                type c_longlong = i64;\n-                type c_ulonglong = u64;\n-                type intptr_t = int;\n-                type uintptr_t = uint;\n+            pub mod posix01 {\n             }\n-            mod posix88 {\n-                #[legacy_exports];\n-                type off_t = i32;\n-                type dev_t = u32;\n-                type ino_t = i16;\n-                type pid_t = i32;\n-                type useconds_t = u32;\n-                type mode_t = u16;\n-                type ssize_t = i32;\n+            pub mod posix08 {\n             }\n-            mod posix01 {\n-                #[legacy_exports]; }\n-            mod posix08 {\n-                #[legacy_exports]; }\n-            mod bsd44 {\n-                #[legacy_exports]; }\n-            mod extra {\n-                #[legacy_exports];\n-                type BOOL = c_int;\n-                type BYTE = u8;\n-                type CCHAR = c_char;\n-                type CHAR = c_char;\n+            pub mod bsd44 {\n+            }\n+            pub mod extra {\n+                pub type BOOL = c_int;\n+                pub type BYTE = u8;\n+                pub type CCHAR = c_char;\n+                pub type CHAR = c_char;\n \n-                type DWORD = c_ulong;\n-                type DWORDLONG = c_ulonglong;\n+                pub type DWORD = c_ulong;\n+                pub type DWORDLONG = c_ulonglong;\n \n-                type HANDLE = LPVOID;\n-                type HMODULE = c_uint;\n+                pub type HANDLE = LPVOID;\n+                pub type HMODULE = c_uint;\n \n-                type LONG_PTR = c_long;\n+                pub type LONG_PTR = c_long;\n \n-                type LPCWSTR = *WCHAR;\n-                type LPCSTR = *CHAR;\n+                pub type LPCWSTR = *WCHAR;\n+                pub type LPCSTR = *CHAR;\n \n-                type LPWSTR = *mut WCHAR;\n-                type LPSTR = *mut CHAR;\n+                pub type LPWSTR = *mut WCHAR;\n+                pub type LPSTR = *mut CHAR;\n \n                 // Not really, but opaque to us.\n-                type LPSECURITY_ATTRIBUTES = LPVOID;\n+                pub type LPSECURITY_ATTRIBUTES = LPVOID;\n \n-                type LPVOID = *mut c_void;\n-                type LPWORD = *mut WORD;\n+                pub type LPVOID = *mut c_void;\n+                pub type LPWORD = *mut WORD;\n \n-                type LRESULT = LONG_PTR;\n-                type PBOOL = *mut BOOL;\n-                type WCHAR = wchar_t;\n-                type WORD = u16;\n+                pub type LRESULT = LONG_PTR;\n+                pub type PBOOL = *mut BOOL;\n+                pub type WCHAR = wchar_t;\n+                pub type WORD = u16;\n             }\n         }\n     }\n \n     #[cfg(target_os = \"macos\")]\n-    mod os {\n-        #[legacy_exports];\n+    pub mod os {\n         #[cfg(target_arch = \"x86\")]\n-        mod arch {\n-            #[legacy_exports];\n-            mod c95 {\n-                #[legacy_exports];\n-                type c_char = i8;\n-                type c_schar = i8;\n-                type c_uchar = u8;\n-                type c_short = i16;\n-                type c_ushort = u16;\n-                type c_int = i32;\n-                type c_uint = u32;\n-                type c_long = i32;\n-                type c_ulong = u32;\n-                type c_float = f32;\n-                type c_double = f64;\n-                type size_t = u32;\n-                type ptrdiff_t = i32;\n-                type clock_t = u32;\n-                type time_t = i32;\n-                type wchar_t = i32;\n+        pub mod arch {\n+            pub mod c95 {\n+                pub type c_char = i8;\n+                pub type c_schar = i8;\n+                pub type c_uchar = u8;\n+                pub type c_short = i16;\n+                pub type c_ushort = u16;\n+                pub type c_int = i32;\n+                pub type c_uint = u32;\n+                pub type c_long = i32;\n+                pub type c_ulong = u32;\n+                pub type c_float = f32;\n+                pub type c_double = f64;\n+                pub type size_t = u32;\n+                pub type ptrdiff_t = i32;\n+                pub type clock_t = u32;\n+                pub type time_t = i32;\n+                pub type wchar_t = i32;\n+            }\n+            pub mod c99 {\n+                pub type c_longlong = i64;\n+                pub type c_ulonglong = u64;\n+                pub type intptr_t = int;\n+                pub type uintptr_t = uint;\n+            }\n+            pub mod posix88 {\n+                pub type off_t = i64;\n+                pub type dev_t = i32;\n+                pub type ino_t = u64;\n+                pub type pid_t = i32;\n+                pub type uid_t = u32;\n+                pub type gid_t = u32;\n+                pub type useconds_t = u32;\n+                pub type mode_t = u16;\n+                pub type ssize_t = i32;\n             }\n-            mod c99 {\n-                #[legacy_exports];\n-                type c_longlong = i64;\n-                type c_ulonglong = u64;\n-                type intptr_t = int;\n-                type uintptr_t = uint;\n+            pub mod posix01 {\n             }\n-            mod posix88 {\n-                #[legacy_exports];\n-                type off_t = i64;\n-                type dev_t = i32;\n-                type ino_t = u64;\n-                type pid_t = i32;\n-                type uid_t = u32;\n-                type gid_t = u32;\n-                type useconds_t = u32;\n-                type mode_t = u16;\n-                type ssize_t = i32;\n+            pub mod posix08 {\n             }\n-            mod posix01 {\n-                #[legacy_exports]; }\n-            mod posix08 {\n-                #[legacy_exports]; }\n-            mod bsd44 {\n-                #[legacy_exports]; }\n-            mod extra {\n-                #[legacy_exports];\n+            pub mod bsd44 {\n+            }\n+            pub mod extra {\n             }\n         }\n \n         #[cfg(target_arch = \"x86_64\")]\n-        mod arch {\n-            #[legacy_exports];\n-            mod c95 {\n-                #[legacy_exports];\n-                type c_char = i8;\n-                type c_schar = i8;\n-                type c_uchar = u8;\n-                type c_short = i16;\n-                type c_ushort = u16;\n-                type c_int = i32;\n-                type c_uint = u32;\n-                type c_long = i64;\n-                type c_ulong = u64;\n-                type c_float = f32;\n-                type c_double = f64;\n-                type size_t = u64;\n-                type ptrdiff_t = i64;\n-                type clock_t = u64;\n-                type time_t = i64;\n-                type wchar_t = i32;\n+        pub mod arch {\n+            pub mod c95 {\n+                pub type c_char = i8;\n+                pub type c_schar = i8;\n+                pub type c_uchar = u8;\n+                pub type c_short = i16;\n+                pub type c_ushort = u16;\n+                pub type c_int = i32;\n+                pub type c_uint = u32;\n+                pub type c_long = i64;\n+                pub type c_ulong = u64;\n+                pub type c_float = f32;\n+                pub type c_double = f64;\n+                pub type size_t = u64;\n+                pub type ptrdiff_t = i64;\n+                pub type clock_t = u64;\n+                pub type time_t = i64;\n+                pub type wchar_t = i32;\n+            }\n+            pub mod c99 {\n+                pub type c_longlong = i64;\n+                pub type c_ulonglong = u64;\n+                pub type intptr_t = int;\n+                pub type uintptr_t = uint;\n+            }\n+            pub mod posix88 {\n+                pub type off_t = i64;\n+                pub type dev_t = i32;\n+                pub type ino_t = u64;\n+                pub type pid_t = i32;\n+                pub type uid_t = u32;\n+                pub type gid_t = u32;\n+                pub type useconds_t = u32;\n+                pub type mode_t = u16;\n+                pub type ssize_t = i64;\n             }\n-            mod c99 {\n-                #[legacy_exports];\n-                type c_longlong = i64;\n-                type c_ulonglong = u64;\n-                type intptr_t = int;\n-                type uintptr_t = uint;\n+            pub mod posix01 {\n             }\n-            mod posix88 {\n-                #[legacy_exports];\n-                type off_t = i64;\n-                type dev_t = i32;\n-                type ino_t = u64;\n-                type pid_t = i32;\n-                type uid_t = u32;\n-                type gid_t = u32;\n-                type useconds_t = u32;\n-                type mode_t = u16;\n-                type ssize_t = i64;\n+            pub mod posix08 {\n             }\n-            mod posix01 {\n-                #[legacy_exports]; }\n-            mod posix08 {\n-                #[legacy_exports]; }\n-            mod bsd44 {\n-                #[legacy_exports]; }\n-            mod extra {\n-                #[legacy_exports];\n+            pub mod bsd44 {\n+            }\n+            pub mod extra {\n             }\n         }\n     }\n }\n \n-mod consts {\n-    #[legacy_exports];\n-\n+pub mod consts {\n     // Consts tend to vary per OS so we pull their definitions out\n     // into this module.\n \n     #[cfg(target_os = \"win32\")]\n-    mod os {\n-        #[legacy_exports];\n-        mod c95 {\n-            #[legacy_exports];\n-            const EXIT_FAILURE : int = 1;\n-            const EXIT_SUCCESS : int = 0;\n-            const RAND_MAX : int = 32767;\n-            const EOF : int = -1;\n-            const SEEK_SET : int = 0;\n-            const SEEK_CUR : int = 1;\n-            const SEEK_END : int = 2;\n-            const _IOFBF : int = 0;\n-            const _IONBF : int = 4;\n-            const _IOLBF : int = 64;\n-            const BUFSIZ : uint = 512_u;\n-            const FOPEN_MAX : uint = 20_u;\n-            const FILENAME_MAX : uint = 260_u;\n-            const L_tmpnam : uint = 16_u;\n-            const TMP_MAX : uint = 32767_u;\n+    pub mod os {\n+        pub mod c95 {\n+            pub const EXIT_FAILURE : int = 1;\n+            pub const EXIT_SUCCESS : int = 0;\n+            pub const RAND_MAX : int = 32767;\n+            pub const EOF : int = -1;\n+            pub const SEEK_SET : int = 0;\n+            pub const SEEK_CUR : int = 1;\n+            pub const SEEK_END : int = 2;\n+            pub const _IOFBF : int = 0;\n+            pub const _IONBF : int = 4;\n+            pub const _IOLBF : int = 64;\n+            pub const BUFSIZ : uint = 512_u;\n+            pub const FOPEN_MAX : uint = 20_u;\n+            pub const FILENAME_MAX : uint = 260_u;\n+            pub const L_tmpnam : uint = 16_u;\n+            pub const TMP_MAX : uint = 32767_u;\n+        }\n+        pub mod c99 {\n         }\n-        mod c99 {\n-            #[legacy_exports]; }\n-        mod posix88 {\n-            #[legacy_exports];\n-            const O_RDONLY : int = 0;\n-            const O_WRONLY : int = 1;\n-            const O_RDWR : int = 2;\n-            const O_APPEND : int = 8;\n-            const O_CREAT : int = 256;\n-            const O_EXCL : int = 1024;\n-            const O_TRUNC : int = 512;\n-            const S_IFIFO : int = 4096;\n-            const S_IFCHR : int = 8192;\n-            const S_IFBLK : int = 12288;\n-            const S_IFDIR : int = 16384;\n-            const S_IFREG : int = 32768;\n-            const S_IFMT : int = 61440;\n-            const S_IEXEC : int = 64;\n-            const S_IWRITE : int = 128;\n-            const S_IREAD : int = 256;\n-            const S_IRWXU : int = 448;\n-            const S_IXUSR : int = 64;\n-            const S_IWUSR : int = 128;\n-            const S_IRUSR : int = 256;\n-            const F_OK : int = 0;\n-            const R_OK : int = 4;\n-            const W_OK : int = 2;\n-            const X_OK : int = 1;\n-            const STDIN_FILENO : int = 0;\n-            const STDOUT_FILENO : int = 1;\n-            const STDERR_FILENO : int = 2;\n+        pub mod posix88 {\n+            pub const O_RDONLY : int = 0;\n+            pub const O_WRONLY : int = 1;\n+            pub const O_RDWR : int = 2;\n+            pub const O_APPEND : int = 8;\n+            pub const O_CREAT : int = 256;\n+            pub const O_EXCL : int = 1024;\n+            pub const O_TRUNC : int = 512;\n+            pub const S_IFIFO : int = 4096;\n+            pub const S_IFCHR : int = 8192;\n+            pub const S_IFBLK : int = 12288;\n+            pub const S_IFDIR : int = 16384;\n+            pub const S_IFREG : int = 32768;\n+            pub const S_IFMT : int = 61440;\n+            pub const S_IEXEC : int = 64;\n+            pub const S_IWRITE : int = 128;\n+            pub const S_IREAD : int = 256;\n+            pub const S_IRWXU : int = 448;\n+            pub const S_IXUSR : int = 64;\n+            pub const S_IWUSR : int = 128;\n+            pub const S_IRUSR : int = 256;\n+            pub const F_OK : int = 0;\n+            pub const R_OK : int = 4;\n+            pub const W_OK : int = 2;\n+            pub const X_OK : int = 1;\n+            pub const STDIN_FILENO : int = 0;\n+            pub const STDOUT_FILENO : int = 1;\n+            pub const STDERR_FILENO : int = 2;\n         }\n-        mod posix01 {\n-            #[legacy_exports]; }\n-        mod posix08 {\n-            #[legacy_exports]; }\n-        mod bsd44 {\n-            #[legacy_exports]; }\n-        mod extra {\n-            #[legacy_exports];\n-            const O_TEXT : int = 16384;\n-            const O_BINARY : int = 32768;\n-            const O_NOINHERIT: int = 128;\n-\n-            const ERROR_SUCCESS : int = 0;\n-            const ERROR_INSUFFICIENT_BUFFER : int = 122;\n+        pub mod posix01 {\n+        }\n+        pub mod posix08 {\n+        }\n+        pub mod bsd44 {\n+        }\n+        pub mod extra {\n+            pub const O_TEXT : int = 16384;\n+            pub const O_BINARY : int = 32768;\n+            pub const O_NOINHERIT: int = 128;\n+\n+            pub const ERROR_SUCCESS : int = 0;\n+            pub const ERROR_INSUFFICIENT_BUFFER : int = 122;\n         }\n     }\n \n \n     #[cfg(target_os = \"linux\")]\n-    mod os {\n-        #[legacy_exports];\n-        mod c95 {\n-            #[legacy_exports];\n-            const EXIT_FAILURE : int = 1;\n-            const EXIT_SUCCESS : int = 0;\n-            const RAND_MAX : int = 2147483647;\n-            const EOF : int = -1;\n-            const SEEK_SET : int = 0;\n-            const SEEK_CUR : int = 1;\n-            const SEEK_END : int = 2;\n-            const _IOFBF : int = 0;\n-            const _IONBF : int = 2;\n-            const _IOLBF : int = 1;\n-            const BUFSIZ : uint = 8192_u;\n-            const FOPEN_MAX : uint = 16_u;\n-            const FILENAME_MAX : uint = 4096_u;\n-            const L_tmpnam : uint = 20_u;\n-            const TMP_MAX : uint = 238328_u;\n+    pub mod os {\n+        pub mod c95 {\n+            pub const EXIT_FAILURE : int = 1;\n+            pub const EXIT_SUCCESS : int = 0;\n+            pub const RAND_MAX : int = 2147483647;\n+            pub const EOF : int = -1;\n+            pub const SEEK_SET : int = 0;\n+            pub const SEEK_CUR : int = 1;\n+            pub const SEEK_END : int = 2;\n+            pub const _IOFBF : int = 0;\n+            pub const _IONBF : int = 2;\n+            pub const _IOLBF : int = 1;\n+            pub const BUFSIZ : uint = 8192_u;\n+            pub const FOPEN_MAX : uint = 16_u;\n+            pub const FILENAME_MAX : uint = 4096_u;\n+            pub const L_tmpnam : uint = 20_u;\n+            pub const TMP_MAX : uint = 238328_u;\n+        }\n+        pub mod c99 {\n+        }\n+        pub mod posix88 {\n+            pub const O_RDONLY : int = 0;\n+            pub const O_WRONLY : int = 1;\n+            pub const O_RDWR : int = 2;\n+            pub const O_APPEND : int = 1024;\n+            pub const O_CREAT : int = 64;\n+            pub const O_EXCL : int = 128;\n+            pub const O_TRUNC : int = 512;\n+            pub const S_IFIFO : int = 4096;\n+            pub const S_IFCHR : int = 8192;\n+            pub const S_IFBLK : int = 24576;\n+            pub const S_IFDIR : int = 16384;\n+            pub const S_IFREG : int = 32768;\n+            pub const S_IFMT : int = 61440;\n+            pub const S_IEXEC : int = 64;\n+            pub const S_IWRITE : int = 128;\n+            pub const S_IREAD : int = 256;\n+            pub const S_IRWXU : int = 448;\n+            pub const S_IXUSR : int = 64;\n+            pub const S_IWUSR : int = 128;\n+            pub const S_IRUSR : int = 256;\n+            pub const F_OK : int = 0;\n+            pub const R_OK : int = 4;\n+            pub const W_OK : int = 2;\n+            pub const X_OK : int = 1;\n+            pub const STDIN_FILENO : int = 0;\n+            pub const STDOUT_FILENO : int = 1;\n+            pub const STDERR_FILENO : int = 2;\n+            pub const F_LOCK : int = 1;\n+            pub const F_TEST : int = 3;\n+            pub const F_TLOCK : int = 2;\n+            pub const F_ULOCK : int = 0;\n         }\n-        mod c99 {\n-            #[legacy_exports]; }\n-        mod posix88 {\n-            #[legacy_exports];\n-            const O_RDONLY : int = 0;\n-            const O_WRONLY : int = 1;\n-            const O_RDWR : int = 2;\n-            const O_APPEND : int = 1024;\n-            const O_CREAT : int = 64;\n-            const O_EXCL : int = 128;\n-            const O_TRUNC : int = 512;\n-            const S_IFIFO : int = 4096;\n-            const S_IFCHR : int = 8192;\n-            const S_IFBLK : int = 24576;\n-            const S_IFDIR : int = 16384;\n-            const S_IFREG : int = 32768;\n-            const S_IFMT : int = 61440;\n-            const S_IEXEC : int = 64;\n-            const S_IWRITE : int = 128;\n-            const S_IREAD : int = 256;\n-            const S_IRWXU : int = 448;\n-            const S_IXUSR : int = 64;\n-            const S_IWUSR : int = 128;\n-            const S_IRUSR : int = 256;\n-            const F_OK : int = 0;\n-            const R_OK : int = 4;\n-            const W_OK : int = 2;\n-            const X_OK : int = 1;\n-            const STDIN_FILENO : int = 0;\n-            const STDOUT_FILENO : int = 1;\n-            const STDERR_FILENO : int = 2;\n-            const F_LOCK : int = 1;\n-            const F_TEST : int = 3;\n-            const F_TLOCK : int = 2;\n-            const F_ULOCK : int = 0;\n+        pub mod posix01 {\n         }\n-        mod posix01 {\n-            #[legacy_exports]; }\n-        mod posix08 {\n-            #[legacy_exports]; }\n-        mod bsd44 {\n-            #[legacy_exports]; }\n-        mod extra {\n-            #[legacy_exports];\n-            const O_RSYNC : int = 1052672;\n-            const O_DSYNC : int = 4096;\n-            const O_SYNC : int = 1052672;\n+        pub mod posix08 {\n+        }\n+        pub mod bsd44 {\n+        }\n+        pub mod extra {\n+            pub const O_RSYNC : int = 1052672;\n+            pub const O_DSYNC : int = 4096;\n+            pub const O_SYNC : int = 1052672;\n         }\n     }\n \n     #[cfg(target_os = \"freebsd\")]\n-    mod os {\n-        #[legacy_exports];\n-        mod c95 {\n-            #[legacy_exports];\n-            const EXIT_FAILURE : int = 1;\n-            const EXIT_SUCCESS : int = 0;\n-            const RAND_MAX : int = 2147483647;\n-            const EOF : int = -1;\n-            const SEEK_SET : int = 0;\n-            const SEEK_CUR : int = 1;\n-            const SEEK_END : int = 2;\n-            const _IOFBF : int = 0;\n-            const _IONBF : int = 2;\n-            const _IOLBF : int = 1;\n-            const BUFSIZ : uint = 1024_u;\n-            const FOPEN_MAX : uint = 20_u;\n-            const FILENAME_MAX : uint = 1024_u;\n-            const L_tmpnam : uint = 1024_u;\n-            const TMP_MAX : uint = 308915776_u;\n+    pub mod os {\n+        pub mod c95 {\n+            pub const EXIT_FAILURE : int = 1;\n+            pub const EXIT_SUCCESS : int = 0;\n+            pub const RAND_MAX : int = 2147483647;\n+            pub const EOF : int = -1;\n+            pub const SEEK_SET : int = 0;\n+            pub const SEEK_CUR : int = 1;\n+            pub const SEEK_END : int = 2;\n+            pub const _IOFBF : int = 0;\n+            pub const _IONBF : int = 2;\n+            pub const _IOLBF : int = 1;\n+            pub const BUFSIZ : uint = 1024_u;\n+            pub const FOPEN_MAX : uint = 20_u;\n+            pub const FILENAME_MAX : uint = 1024_u;\n+            pub const L_tmpnam : uint = 1024_u;\n+            pub const TMP_MAX : uint = 308915776_u;\n+        }\n+        pub mod c99 {\n+        }\n+        pub mod posix88 {\n+            pub const O_RDONLY : int = 0;\n+            pub const O_WRONLY : int = 1;\n+            pub const O_RDWR : int = 2;\n+            pub const O_APPEND : int = 8;\n+            pub const O_CREAT : int = 512;\n+            pub const O_EXCL : int = 2048;\n+            pub const O_TRUNC : int = 1024;\n+            pub const S_IFIFO : int = 4096;\n+            pub const S_IFCHR : int = 8192;\n+            pub const S_IFBLK : int = 24576;\n+            pub const S_IFDIR : int = 16384;\n+            pub const S_IFREG : int = 32768;\n+            pub const S_IFMT : int = 61440;\n+            pub const S_IEXEC : int = 64;\n+            pub const S_IWRITE : int = 128;\n+            pub const S_IREAD : int = 256;\n+            pub const S_IRWXU : int = 448;\n+            pub const S_IXUSR : int = 64;\n+            pub const S_IWUSR : int = 128;\n+            pub const S_IRUSR : int = 256;\n+            pub const F_OK : int = 0;\n+            pub const R_OK : int = 4;\n+            pub const W_OK : int = 2;\n+            pub const X_OK : int = 1;\n+            pub const STDIN_FILENO : int = 0;\n+            pub const STDOUT_FILENO : int = 1;\n+            pub const STDERR_FILENO : int = 2;\n+            pub const F_LOCK : int = 1;\n+            pub const F_TEST : int = 3;\n+            pub const F_TLOCK : int = 2;\n+            pub const F_ULOCK : int = 0;\n+        }\n+        pub mod posix01 {\n+        }\n+        pub mod posix08 {\n         }\n-        mod c99 {\n-            #[legacy_exports]; }\n-        mod posix88 {\n-            #[legacy_exports];\n-            const O_RDONLY : int = 0;\n-            const O_WRONLY : int = 1;\n-            const O_RDWR : int = 2;\n-            const O_APPEND : int = 8;\n-            const O_CREAT : int = 512;\n-            const O_EXCL : int = 2048;\n-            const O_TRUNC : int = 1024;\n-            const S_IFIFO : int = 4096;\n-            const S_IFCHR : int = 8192;\n-            const S_IFBLK : int = 24576;\n-            const S_IFDIR : int = 16384;\n-            const S_IFREG : int = 32768;\n-            const S_IFMT : int = 61440;\n-            const S_IEXEC : int = 64;\n-            const S_IWRITE : int = 128;\n-            const S_IREAD : int = 256;\n-            const S_IRWXU : int = 448;\n-            const S_IXUSR : int = 64;\n-            const S_IWUSR : int = 128;\n-            const S_IRUSR : int = 256;\n-            const F_OK : int = 0;\n-            const R_OK : int = 4;\n-            const W_OK : int = 2;\n-            const X_OK : int = 1;\n-            const STDIN_FILENO : int = 0;\n-            const STDOUT_FILENO : int = 1;\n-            const STDERR_FILENO : int = 2;\n-            const F_LOCK : int = 1;\n-            const F_TEST : int = 3;\n-            const F_TLOCK : int = 2;\n-            const F_ULOCK : int = 0;\n+        pub mod bsd44 {\n         }\n-        mod posix01 {\n-            #[legacy_exports]; }\n-        mod posix08 {\n-            #[legacy_exports]; }\n-        mod bsd44 {\n-            #[legacy_exports]; }\n-        mod extra {\n-            #[legacy_exports];\n-            const O_SYNC : int = 128;\n-            const CTL_KERN: int = 1;\n-            const KERN_PROC: int = 14;\n-            const KERN_PROC_PATHNAME: int = 12;\n+        pub mod extra {\n+            pub const O_SYNC : int = 128;\n+            pub const CTL_KERN: int = 1;\n+            pub const KERN_PROC: int = 14;\n+            pub const KERN_PROC_PATHNAME: int = 12;\n         }\n     }\n \n     #[cfg(target_os = \"macos\")]\n-    mod os {\n-        #[legacy_exports];\n-        mod c95 {\n-            #[legacy_exports];\n-            const EXIT_FAILURE : int = 1;\n-            const EXIT_SUCCESS : int = 0;\n-            const RAND_MAX : int = 2147483647;\n-            const EOF : int = -1;\n-            const SEEK_SET : int = 0;\n-            const SEEK_CUR : int = 1;\n-            const SEEK_END : int = 2;\n-            const _IOFBF : int = 0;\n-            const _IONBF : int = 2;\n-            const _IOLBF : int = 1;\n-            const BUFSIZ : uint = 1024_u;\n-            const FOPEN_MAX : uint = 20_u;\n-            const FILENAME_MAX : uint = 1024_u;\n-            const L_tmpnam : uint = 1024_u;\n-            const TMP_MAX : uint = 308915776_u;\n+    pub mod os {\n+        pub mod c95 {\n+            pub const EXIT_FAILURE : int = 1;\n+            pub const EXIT_SUCCESS : int = 0;\n+            pub const RAND_MAX : int = 2147483647;\n+            pub const EOF : int = -1;\n+            pub const SEEK_SET : int = 0;\n+            pub const SEEK_CUR : int = 1;\n+            pub const SEEK_END : int = 2;\n+            pub const _IOFBF : int = 0;\n+            pub const _IONBF : int = 2;\n+            pub const _IOLBF : int = 1;\n+            pub const BUFSIZ : uint = 1024_u;\n+            pub const FOPEN_MAX : uint = 20_u;\n+            pub const FILENAME_MAX : uint = 1024_u;\n+            pub const L_tmpnam : uint = 1024_u;\n+            pub const TMP_MAX : uint = 308915776_u;\n         }\n-        mod c99 {\n-            #[legacy_exports]; }\n-        mod posix88 {\n-            #[legacy_exports];\n-            const O_RDONLY : int = 0;\n-            const O_WRONLY : int = 1;\n-            const O_RDWR : int = 2;\n-            const O_APPEND : int = 8;\n-            const O_CREAT : int = 512;\n-            const O_EXCL : int = 2048;\n-            const O_TRUNC : int = 1024;\n-            const S_IFIFO : int = 4096;\n-            const S_IFCHR : int = 8192;\n-            const S_IFBLK : int = 24576;\n-            const S_IFDIR : int = 16384;\n-            const S_IFREG : int = 32768;\n-            const S_IFMT : int = 61440;\n-            const S_IEXEC : int = 64;\n-            const S_IWRITE : int = 128;\n-            const S_IREAD : int = 256;\n-            const S_IRWXU : int = 448;\n-            const S_IXUSR : int = 64;\n-            const S_IWUSR : int = 128;\n-            const S_IRUSR : int = 256;\n-            const F_OK : int = 0;\n-            const R_OK : int = 4;\n-            const W_OK : int = 2;\n-            const X_OK : int = 1;\n-            const STDIN_FILENO : int = 0;\n-            const STDOUT_FILENO : int = 1;\n-            const STDERR_FILENO : int = 2;\n-            const F_LOCK : int = 1;\n-            const F_TEST : int = 3;\n-            const F_TLOCK : int = 2;\n-            const F_ULOCK : int = 0;\n+        pub mod c99 {\n         }\n-        mod posix01 {\n-            #[legacy_exports]; }\n-        mod posix08 {\n-            #[legacy_exports]; }\n-        mod bsd44 {\n-            #[legacy_exports]; }\n-        mod extra {\n-            #[legacy_exports];\n-            const O_DSYNC : int = 4194304;\n-            const O_SYNC : int = 128;\n-            const F_FULLFSYNC : int = 51;\n+        pub mod posix88 {\n+            pub const O_RDONLY : int = 0;\n+            pub const O_WRONLY : int = 1;\n+            pub const O_RDWR : int = 2;\n+            pub const O_APPEND : int = 8;\n+            pub const O_CREAT : int = 512;\n+            pub const O_EXCL : int = 2048;\n+            pub const O_TRUNC : int = 1024;\n+            pub const S_IFIFO : int = 4096;\n+            pub const S_IFCHR : int = 8192;\n+            pub const S_IFBLK : int = 24576;\n+            pub const S_IFDIR : int = 16384;\n+            pub const S_IFREG : int = 32768;\n+            pub const S_IFMT : int = 61440;\n+            pub const S_IEXEC : int = 64;\n+            pub const S_IWRITE : int = 128;\n+            pub const S_IREAD : int = 256;\n+            pub const S_IRWXU : int = 448;\n+            pub const S_IXUSR : int = 64;\n+            pub const S_IWUSR : int = 128;\n+            pub const S_IRUSR : int = 256;\n+            pub const F_OK : int = 0;\n+            pub const R_OK : int = 4;\n+            pub const W_OK : int = 2;\n+            pub const X_OK : int = 1;\n+            pub const STDIN_FILENO : int = 0;\n+            pub const STDOUT_FILENO : int = 1;\n+            pub const STDERR_FILENO : int = 2;\n+            pub const F_LOCK : int = 1;\n+            pub const F_TEST : int = 3;\n+            pub const F_TLOCK : int = 2;\n+            pub const F_ULOCK : int = 0;\n+        }\n+        pub mod posix01 {\n+        }\n+        pub mod posix08 {\n+        }\n+        pub mod bsd44 {\n+        }\n+        pub mod extra {\n+            pub const O_DSYNC : int = 4194304;\n+            pub const O_SYNC : int = 128;\n+            pub const F_FULLFSYNC : int = 51;\n         }\n     }\n }\n \n \n-mod funcs {\n-    #[legacy_exports];\n-\n+pub mod funcs {\n     // Thankfull most of c95 is universally available and does not vary by OS\n     // or anything. The same is not true of POSIX.\n \n-    mod c95 {\n-        #[legacy_exports];\n-\n+    pub mod c95 {\n         #[nolink]\n         #[abi = \"cdecl\"]\n-        extern mod ctype {\n-            #[legacy_exports];\n+        pub extern mod ctype {\n             fn isalnum(c: c_int) -> c_int;\n             fn isalpha(c: c_int) -> c_int;\n             fn iscntrl(c: c_int) -> c_int;\n@@ -850,9 +776,7 @@ mod funcs {\n \n         #[nolink]\n         #[abi = \"cdecl\"]\n-        extern mod stdio {\n-            #[legacy_exports];\n-\n+        pub extern mod stdio {\n             fn fopen(filename: *c_char, mode: *c_char) -> *FILE;\n             fn freopen(filename: *c_char, mode: *c_char,\n                        file: *FILE) -> *FILE;\n@@ -882,7 +806,8 @@ mod funcs {\n                      nobj: size_t, stream: *FILE) -> size_t;\n             fn fwrite(ptr: *c_void, size: size_t,\n                       nobj: size_t, stream: *FILE) -> size_t;\n-            fn fseek(stream: *FILE, offset: c_long, whence: c_int) -> c_int;\n+            fn fseek(stream: *FILE, offset: c_long,\n+                     whence: c_int) -> c_int;\n             fn ftell(stream: *FILE) -> c_long;\n             fn rewind(stream: *FILE);\n             fn fgetpos(stream: *FILE, ptr: *fpos_t) -> c_int;\n@@ -895,16 +820,16 @@ mod funcs {\n \n         #[nolink]\n         #[abi = \"cdecl\"]\n-        extern mod stdlib {\n-            #[legacy_exports];\n+        pub extern mod stdlib {\n             fn abs(i: c_int) -> c_int;\n             fn labs(i: c_long) -> c_long;\n-            // Omitted: div, ldiv (return type incomplete).\n+            // Omitted: div, ldiv (return pub type incomplete).\n             fn atof(s: *c_char) -> c_double;\n             fn atoi(s: *c_char) -> c_int;\n             fn strtod(s: *c_char, endp: **c_char) -> c_double;\n             fn strtol(s: *c_char, endp: **c_char, base: c_int) -> c_long;\n-            fn strtoul(s: *c_char, endp: **c_char, base: c_int) -> c_ulong;\n+            fn strtoul(s: *c_char, endp: **c_char,\n+                       base: c_int) -> c_ulong;\n             fn calloc(nobj: size_t, size: size_t) -> *c_void;\n             fn malloc(size: size_t) -> *c_void;\n             fn realloc(p: *c_void, size: size_t) -> *c_void;\n@@ -921,9 +846,7 @@ mod funcs {\n \n         #[nolink]\n         #[abi = \"cdecl\"]\n-        extern mod string {\n-            #[legacy_exports];\n-\n+        pub extern mod string {\n             fn strcpy(dst: *c_char, src: *c_char) -> *c_char;\n             fn strncpy(dst: *c_char, src: *c_char, n: size_t) -> *c_char;\n             fn strcat(s: *c_char, ct: *c_char) -> *c_char;\n@@ -956,13 +879,10 @@ mod funcs {\n     // with the same POSIX functions and types as other platforms.\n \n     #[cfg(target_os = \"win32\")]\n-    mod posix88 {\n-        #[legacy_exports];\n-\n+    pub mod posix88 {\n         #[nolink]\n         #[abi = \"cdecl\"]\n-        extern mod stat {\n-            #[legacy_exports];\n+        pub extern mod stat {\n             #[link_name = \"_chmod\"]\n             fn chmod(path: *c_char, mode: c_int) -> c_int;\n \n@@ -972,8 +892,7 @@ mod funcs {\n \n         #[nolink]\n         #[abi = \"cdecl\"]\n-        extern mod stdio {\n-            #[legacy_exports];\n+        pub extern mod stdio {\n             #[link_name = \"_popen\"]\n             fn popen(command: *c_char, mode: *c_char) -> *FILE;\n \n@@ -989,8 +908,7 @@ mod funcs {\n \n         #[nolink]\n         #[abi = \"cdecl\"]\n-        extern mod fcntl {\n-            #[legacy_exports];\n+        pub extern mod fcntl {\n             #[link_name = \"_open\"]\n             fn open(path: *c_char, oflag: c_int, mode: c_int) -> c_int;\n \n@@ -1000,15 +918,13 @@ mod funcs {\n \n         #[nolink]\n         #[abi = \"cdecl\"]\n-        extern mod dirent {\n-            #[legacy_exports];\n+        pub extern mod dirent {\n             // Not supplied at all.\n         }\n \n         #[nolink]\n         #[abi = \"cdecl\"]\n-        extern mod unistd {\n-            #[legacy_exports];\n+        pub extern mod unistd {\n             #[link_name = \"_access\"]\n             fn access(path: *c_char, amode: c_int) -> c_int;\n \n@@ -1035,7 +951,8 @@ mod funcs {\n             fn execvp(c: *c_char, argv: **c_char) -> c_int;\n \n             #[link_name = \"_execvpe\"]\n-            fn execvpe(c: *c_char, argv: **c_char, envp: **c_char) -> c_int;\n+            fn execvpe(c: *c_char, argv: **c_char,\n+                       envp: **c_char) -> c_int;\n \n             #[link_name = \"_getcwd\"]\n             fn getcwd(buf: *c_char, size: size_t) -> *c_char;\n@@ -1072,13 +989,10 @@ mod funcs {\n     #[cfg(target_os = \"linux\")]\n     #[cfg(target_os = \"macos\")]\n     #[cfg(target_os = \"freebsd\")]\n-    mod posix88 {\n-        #[legacy_exports];\n-\n+    pub mod posix88 {\n         #[nolink]\n         #[abi = \"cdecl\"]\n-        extern mod stat {\n-            #[legacy_exports];\n+        pub extern mod stat {\n             fn chmod(path: *c_char, mode: mode_t) -> c_int;\n             fn fchmod(fd: c_int, mode: mode_t) -> c_int;\n             fn mkdir(path: *c_char, mode: mode_t) -> c_int;\n@@ -1087,8 +1001,7 @@ mod funcs {\n \n         #[nolink]\n         #[abi = \"cdecl\"]\n-        extern mod stdio {\n-            #[legacy_exports];\n+        pub extern mod stdio {\n             fn popen(command: *c_char, mode: *c_char) -> *FILE;\n             fn pclose(stream: *FILE) -> c_int;\n             fn fdopen(fd: c_int, mode: *c_char) -> *FILE;\n@@ -1097,17 +1010,15 @@ mod funcs {\n \n         #[nolink]\n         #[abi = \"cdecl\"]\n-        extern mod fcntl {\n-            #[legacy_exports];\n+        pub extern mod fcntl {\n             fn open(path: *c_char, oflag: c_int, mode: c_int) -> c_int;\n             fn creat(path: *c_char, mode: mode_t) -> c_int;\n             fn fcntl(fd: c_int, cmd: c_int) -> c_int;\n         }\n \n         #[nolink]\n         #[abi = \"cdecl\"]\n-        extern mod dirent {\n-            #[legacy_exports];\n+        pub extern mod dirent {\n             fn opendir(dirname: *c_char) -> *DIR;\n             fn closedir(dirp: *DIR) -> c_int;\n             fn readdir(dirp: *DIR) -> *dirent;\n@@ -1118,8 +1029,7 @@ mod funcs {\n \n         #[nolink]\n         #[abi = \"cdecl\"]\n-        extern mod unistd {\n-            #[legacy_exports];\n+        pub extern mod unistd {\n             fn access(path: *c_char, amode: c_int) -> c_int;\n             fn alarm(seconds: c_uint) -> c_uint;\n             fn chdir(dir: *c_char) -> c_int;\n@@ -1128,7 +1038,8 @@ mod funcs {\n             fn dup(fd: c_int) -> c_int;\n             fn dup2(src: c_int, dst: c_int) -> c_int;\n             fn execv(prog: *c_char, argv: **c_char) -> c_int;\n-            fn execve(prog: *c_char, argv: **c_char, envp: **c_char) -> c_int;\n+            fn execve(prog: *c_char, argv: **c_char,\n+                      envp: **c_char) -> c_int;\n             fn execvp(c: *c_char, argv: **c_char) -> c_int;\n             fn fork() -> pid_t;\n             fn fpathconf(filedes: c_int, name: c_int) -> c_long;\n@@ -1138,7 +1049,8 @@ mod funcs {\n             fn getgid() -> gid_t ;\n             fn getgroups(ngroups_max: c_int, groups: *mut gid_t) -> c_int;\n             fn getlogin() -> *c_char;\n-            fn getopt(argc: c_int, argv: **c_char, optstr: *c_char) -> c_int;\n+            fn getopt(argc: c_int, argv: **c_char,\n+                      optstr: *c_char) -> c_int;\n             fn getpgrp() -> pid_t;\n             fn getpid() -> pid_t;\n             fn getppid() -> pid_t;\n@@ -1168,13 +1080,10 @@ mod funcs {\n     #[cfg(target_os = \"linux\")]\n     #[cfg(target_os = \"macos\")]\n     #[cfg(target_os = \"freebsd\")]\n-    mod posix01 {\n-        #[legacy_exports];\n-\n+    pub mod posix01 {\n         #[nolink]\n         #[abi = \"cdecl\"]\n-        extern mod unistd {\n-            #[legacy_exports];\n+        pub extern mod unistd {\n             fn readlink(path: *c_char, buf: *mut c_char,\n                         bufsz: size_t) -> ssize_t;\n \n@@ -1191,41 +1100,36 @@ mod funcs {\n \n         #[nolink]\n         #[abi = \"cdecl\"]\n-        extern mod wait {\n-            #[legacy_exports];\n+        pub extern mod wait {\n             fn waitpid(pid: pid_t, status: *mut c_int,\n                        options: c_int) -> pid_t;\n         }\n     }\n \n     #[cfg(target_os = \"win32\")]\n-    mod posix01 {\n-        #[legacy_exports];\n+    pub mod posix01 {\n         #[nolink]\n-        extern mod unistd {\n-            #[legacy_exports]; }\n+        pub extern mod unistd {\n+        }\n     }\n \n \n     #[cfg(target_os = \"win32\")]\n     #[cfg(target_os = \"linux\")]\n     #[cfg(target_os = \"macos\")]\n     #[cfg(target_os = \"freebsd\")]\n-    mod posix08 {\n-        #[legacy_exports];\n+    pub mod posix08 {\n         #[nolink]\n-        extern mod unistd {\n-            #[legacy_exports]; }\n+        pub extern mod unistd {\n+        }\n     }\n \n \n     #[cfg(target_os = \"macos\")]\n     #[cfg(target_os = \"freebsd\")]\n     #[nolink]\n     #[abi = \"cdecl\"]\n-    extern mod bsd44 {\n-        #[legacy_exports];\n-\n+    pub extern mod bsd44 {\n         fn sysctl(name: *c_int, namelen: c_uint,\n                   oldp: *mut c_void, oldlenp: *mut size_t,\n                   newp: *c_void, newlen: size_t) -> c_int;\n@@ -1241,37 +1145,35 @@ mod funcs {\n \n     #[cfg(target_os = \"linux\")]\n     #[cfg(target_os = \"win32\")]\n-    mod bsd44 {\n-        #[legacy_exports];\n+    pub mod bsd44 {\n     }\n \n \n     #[cfg(target_os = \"macos\")]\n     #[nolink]\n     #[abi = \"cdecl\"]\n-    extern mod extra {\n-        #[legacy_exports];\n+    pub extern mod extra {\n         fn _NSGetExecutablePath(buf: *mut c_char,\n                                 bufsize: *mut u32) -> c_int;\n     }\n \n     #[cfg(target_os = \"freebsd\")]\n-    mod extra {\n-        #[legacy_exports]; }\n+    pub mod extra {\n+    }\n \n     #[cfg(target_os = \"linux\")]\n-    mod extra {\n-        #[legacy_exports]; }\n+    pub mod extra {\n+    }\n \n \n     #[cfg(target_os = \"win32\")]\n-    mod extra {\n-        #[legacy_exports];\n+    pub mod extra {\n         use types::os::arch::extra::*;\n+        pub use kernel32::*;\n+        pub use msvcrt::*;\n \n         #[abi = \"stdcall\"]\n-        extern mod kernel32 {\n-            #[legacy_exports];\n+        pub extern mod kernel32 {\n             fn GetEnvironmentVariableW(n: LPCWSTR,\n                                        v: LPWSTR,\n                                        nsize: DWORD) -> DWORD;\n@@ -1295,8 +1197,7 @@ mod funcs {\n \n         #[abi = \"cdecl\"]\n         #[nolink]\n-        extern mod msvcrt {\n-            #[legacy_exports];\n+        pub extern mod msvcrt {\n             #[link_name = \"_commit\"]\n             fn commit(fd: c_int) -> c_int;\n         }"}, {"sha": "d4f3c0ea272ed5b2b52d6e2b9f0e05e420cd825c", "filename": "src/libcore/logging.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flogging.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -6,18 +6,15 @@\n \n use cast::transmute;\n \n-export console_on, console_off, log_type;\n-\n #[nolink]\n extern mod rustrt {\n-    #[legacy_exports];\n     fn rust_log_console_on();\n     fn rust_log_console_off();\n     fn rust_log_str(level: u32, string: *libc::c_char, size: libc::size_t);\n }\n \n /// Turns on logging to stdout globally\n-fn console_on() {\n+pub fn console_on() {\n     rustrt::rust_log_console_on();\n }\n \n@@ -28,7 +25,7 @@ fn console_on() {\n  * runtime environment's logging spec, e.g. by setting\n  * the RUST_LOG environment variable\n  */\n-fn console_off() {\n+pub fn console_off() {\n     rustrt::rust_log_console_off();\n }\n "}, {"sha": "5948c630cd85d6bda9e5e885abc35786b6970bf9", "filename": "src/libcore/mutable.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fmutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fmutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmutable.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -8,34 +8,31 @@ dynamic checks: your program will fail if you attempt to perform\n mutation when the data structure should be immutable.\n \n */\n-\n-#[forbid(deprecated_mode)];\n+// tjc: re-forbid deprecated modes after snapshot\n #[forbid(deprecated_pattern)];\n \n use util::with;\n use cast::transmute_immut;\n \n-export Mut;\n-\n enum Mode { ReadOnly, Mutable, Immutable }\n \n struct Data<T> {\n     priv mut value: T,\n     priv mut mode: Mode\n }\n \n-type Mut<T> = Data<T>;\n+pub type Mut<T> = Data<T>;\n \n-fn Mut<T>(+t: T) -> Mut<T> {\n+pub fn Mut<T>(t: T) -> Mut<T> {\n     Data {value: t, mode: ReadOnly}\n }\n \n-fn unwrap<T>(+m: Mut<T>) -> T {\n+pub fn unwrap<T>(m: Mut<T>) -> T {\n     // Borrowck should prevent us from calling unwrap while the value\n     // is in use, as that would be a move from a borrowed value.\n     assert (m.mode as uint) == (ReadOnly as uint);\n-    let Data {value, mode: _} <- m;\n-    return move value;\n+    let Data {value: move value, mode: _} = move m;\n+    return value;\n }\n \n impl<T> Data<T> {\n@@ -71,7 +68,7 @@ impl<T> Data<T> {\n #[test]\n #[ignore(cfg(windows))]\n #[should_fail]\n-fn test_mut_in_imm() {\n+pub fn test_mut_in_imm() {\n     let m = @Mut(1);\n     do m.borrow_imm |_p| {\n         do m.borrow_mut |_q| {\n@@ -83,7 +80,7 @@ fn test_mut_in_imm() {\n #[test]\n #[ignore(cfg(windows))]\n #[should_fail]\n-fn test_imm_in_mut() {\n+pub fn test_imm_in_mut() {\n     let m = @Mut(1);\n     do m.borrow_mut |_p| {\n         do m.borrow_imm |_q| {\n@@ -93,7 +90,7 @@ fn test_imm_in_mut() {\n }\n \n #[test]\n-fn test_const_in_mut() {\n+pub fn test_const_in_mut() {\n     let m = @Mut(1);\n     do m.borrow_mut |p| {\n         do m.borrow_const |q| {\n@@ -105,7 +102,7 @@ fn test_const_in_mut() {\n }\n \n #[test]\n-fn test_mut_in_const() {\n+pub fn test_mut_in_const() {\n     let m = @Mut(1);\n     do m.borrow_const |p| {\n         do m.borrow_mut |q| {\n@@ -117,7 +114,7 @@ fn test_mut_in_const() {\n }\n \n #[test]\n-fn test_imm_in_const() {\n+pub fn test_imm_in_const() {\n     let m = @Mut(1);\n     do m.borrow_const |p| {\n         do m.borrow_imm |q| {\n@@ -127,7 +124,7 @@ fn test_imm_in_const() {\n }\n \n #[test]\n-fn test_const_in_imm() {\n+pub fn test_const_in_imm() {\n     let m = @Mut(1);\n     do m.borrow_imm |p| {\n         do m.borrow_const |q| {\n@@ -140,7 +137,7 @@ fn test_const_in_imm() {\n #[test]\n #[ignore(cfg(windows))]\n #[should_fail]\n-fn test_mut_in_imm_in_const() {\n+pub fn test_mut_in_imm_in_const() {\n     let m = @Mut(1);\n     do m.borrow_const |_p| {\n         do m.borrow_imm |_q| {\n@@ -149,3 +146,4 @@ fn test_mut_in_imm_in_const() {\n         }\n     }\n }\n+"}, {"sha": "d84f97c963933cca41fd1ae6c3dc2cbdcedeab98", "filename": "src/libcore/num.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -1,12 +1,12 @@\n //! An interface for numeric types\n \n-trait Num {\n+pub trait Num {\n     // FIXME: Trait composition. (#2616)\n-    pure fn add(&&other: self) -> self;\n-    pure fn sub(&&other: self) -> self;\n-    pure fn mul(&&other: self) -> self;\n-    pure fn div(&&other: self) -> self;\n-    pure fn modulo(&&other: self) -> self;\n+    pure fn add(other: &self) -> self;\n+    pure fn sub(other: &self) -> self;\n+    pure fn mul(other: &self) -> self;\n+    pure fn div(other: &self) -> self;\n+    pure fn modulo(other: &self) -> self;\n     pure fn neg() -> self;\n \n     pure fn to_int() -> int;"}, {"sha": "038c117b8bed7b0a0033c10ac887e23c8be3faa7", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -1,82 +1,82 @@\n // Core operators and kinds.\n \n #[lang=\"const\"]\n-trait Const {\n+pub trait Const {\n     // Empty.\n }\n \n #[lang=\"copy\"]\n-trait Copy {\n+pub trait Copy {\n     // Empty.\n }\n \n #[lang=\"send\"]\n-trait Send {\n+pub trait Send {\n     // Empty.\n }\n \n #[lang=\"owned\"]\n-trait Owned {\n+pub trait Owned {\n     // Empty.\n }\n \n #[lang=\"add\"]\n-trait Add<RHS,Result> {\n+pub trait Add<RHS,Result> {\n     pure fn add(rhs: &RHS) -> Result;\n }\n \n #[lang=\"sub\"]\n-trait Sub<RHS,Result> {\n+pub trait Sub<RHS,Result> {\n     pure fn sub(rhs: &RHS) -> Result;\n }\n \n #[lang=\"mul\"]\n-trait Mul<RHS,Result> {\n+pub trait Mul<RHS,Result> {\n     pure fn mul(rhs: &RHS) -> Result;\n }\n \n #[lang=\"div\"]\n-trait Div<RHS,Result> {\n+pub trait Div<RHS,Result> {\n     pure fn div(rhs: &RHS) -> Result;\n }\n \n #[lang=\"modulo\"]\n-trait Modulo<RHS,Result> {\n+pub trait Modulo<RHS,Result> {\n     pure fn modulo(rhs: &RHS) -> Result;\n }\n \n #[lang=\"neg\"]\n-trait Neg<Result> {\n+pub trait Neg<Result> {\n     pure fn neg() -> Result;\n }\n \n #[lang=\"bitand\"]\n-trait BitAnd<RHS,Result> {\n+pub trait BitAnd<RHS,Result> {\n     pure fn bitand(rhs: &RHS) -> Result;\n }\n \n #[lang=\"bitor\"]\n-trait BitOr<RHS,Result> {\n+pub trait BitOr<RHS,Result> {\n     pure fn bitor(rhs: &RHS) -> Result;\n }\n \n #[lang=\"bitxor\"]\n-trait BitXor<RHS,Result> {\n+pub trait BitXor<RHS,Result> {\n     pure fn bitxor(rhs: &RHS) -> Result;\n }\n \n #[lang=\"shl\"]\n-trait Shl<RHS,Result> {\n+pub trait Shl<RHS,Result> {\n     pure fn shl(rhs: &RHS) -> Result;\n }\n \n #[lang=\"shr\"]\n-trait Shr<RHS,Result> {\n+pub trait Shr<RHS,Result> {\n     pure fn shr(rhs: &RHS) -> Result;\n }\n \n #[lang=\"index\"]\n-trait Index<Index,Result> {\n+pub trait Index<Index,Result> {\n     pure fn index(index: Index) -> Result;\n }\n "}, {"sha": "6bd326186cb4c94cfcad278570f0318dfc30a8e7", "filename": "src/libcore/option.rs", "status": "modified", "additions": 46, "deletions": 73, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -9,18 +9,18 @@\n  */\n \n // NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n+#[warn(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n \n use cmp::Eq;\n \n /// The option type\n-enum Option<T> {\n+pub enum Option<T> {\n     None,\n     Some(T),\n }\n \n-pure fn get<T: Copy>(opt: &Option<T>) -> T {\n+pub pure fn get<T: Copy>(opt: &Option<T>) -> T {\n     /*!\n      * Gets the value out of an option\n      *\n@@ -30,12 +30,12 @@ pure fn get<T: Copy>(opt: &Option<T>) -> T {\n      */\n \n     match *opt {\n-      Some(x) => return x,\n+      Some(copy x) => return x,\n       None => fail ~\"option::get none\"\n     }\n }\n \n-pure fn get_ref<T>(opt: &r/Option<T>) -> &r/T {\n+pub pure fn get_ref<T>(opt: &r/Option<T>) -> &r/T {\n     /*!\n      * Gets an immutable reference to the value inside an option.\n      *\n@@ -49,7 +49,7 @@ pure fn get_ref<T>(opt: &r/Option<T>) -> &r/T {\n     }\n }\n \n-pure fn expect<T: Copy>(opt: &Option<T>, +reason: ~str) -> T {\n+pub pure fn expect<T: Copy>(opt: &Option<T>, reason: ~str) -> T {\n     /*!\n      * Gets the value out of an option, printing a specified message on\n      * failure\n@@ -58,40 +58,41 @@ pure fn expect<T: Copy>(opt: &Option<T>, +reason: ~str) -> T {\n      *\n      * Fails if the value equals `none`\n      */\n-    match *opt { Some(x) => x, None => fail reason }\n+    match *opt { Some(copy x) => x, None => fail reason }\n }\n \n-pure fn map<T, U>(opt: &Option<T>, f: fn(T) -> U) -> Option<U> {\n-    //! Maps a `some` value from one type to another\n-\n-    match *opt { Some(x) => Some(f(x)), None => None }\n-}\n-\n-pure fn map_ref<T, U>(opt: &Option<T>, f: fn(x: &T) -> U) -> Option<U> {\n+pub pure fn map<T, U>(opt: &Option<T>, f: fn(x: &T) -> U) -> Option<U> {\n     //! Maps a `some` value by reference from one type to another\n \n     match *opt { Some(ref x) => Some(f(x)), None => None }\n }\n \n-pure fn map_consume<T, U>(+opt: Option<T>, f: fn(+v: T) -> U) -> Option<U> {\n+pub pure fn map_consume<T, U>(opt: Option<T>,\n+                              f: fn(v: T) -> U) -> Option<U> {\n     /*!\n      * As `map`, but consumes the option and gives `f` ownership to avoid\n      * copying.\n      */\n     if opt.is_some() { Some(f(option::unwrap(move opt))) } else { None }\n }\n \n-pure fn chain<T, U>(opt: &Option<T>, f: fn(T) -> Option<U>) -> Option<U> {\n+pub pure fn chain<T, U>(opt: Option<T>,\n+                        f: fn(t: T) -> Option<U>) -> Option<U> {\n     /*!\n      * Update an optional value by optionally running its content through a\n      * function that returns an option.\n      */\n \n-    match *opt { Some(x) => f(x), None => None }\n+    // XXX write with move match\n+    if opt.is_some() {\n+        f(unwrap(opt))\n+    } else {\n+        None\n+    }\n }\n \n-pure fn chain_ref<T, U>(opt: &Option<T>,\n-                        f: fn(x: &T) -> Option<U>) -> Option<U> {\n+pub pure fn chain_ref<T, U>(opt: &Option<T>,\n+                            f: fn(x: &T) -> Option<U>) -> Option<U> {\n     /*!\n      * Update an optional value by optionally running its content by reference\n      * through a function that returns an option.\n@@ -100,7 +101,7 @@ pure fn chain_ref<T, U>(opt: &Option<T>,\n     match *opt { Some(ref x) => f(x), None => None }\n }\n \n-pure fn or<T>(+opta: Option<T>, +optb: Option<T>) -> Option<T> {\n+pub pure fn or<T>(opta: Option<T>, optb: Option<T>) -> Option<T> {\n     /*!\n      * Returns the leftmost some() value, or none if both are none.\n      */\n@@ -111,7 +112,7 @@ pure fn or<T>(+opta: Option<T>, +optb: Option<T>) -> Option<T> {\n }\n \n #[inline(always)]\n-pure fn while_some<T>(+x: Option<T>, blk: fn(+v: T) -> Option<T>) {\n+pub pure fn while_some<T>(x: Option<T>, blk: fn(v: T) -> Option<T>) {\n     //! Applies a function zero or more times until the result is none.\n \n     let mut opt <- x;\n@@ -120,54 +121,38 @@ pure fn while_some<T>(+x: Option<T>, blk: fn(+v: T) -> Option<T>) {\n     }\n }\n \n-pure fn is_none<T>(opt: &Option<T>) -> bool {\n+pub pure fn is_none<T>(opt: &Option<T>) -> bool {\n     //! Returns true if the option equals `none`\n \n     match *opt { None => true, Some(_) => false }\n }\n \n-pure fn is_some<T>(opt: &Option<T>) -> bool {\n+pub pure fn is_some<T>(opt: &Option<T>) -> bool {\n     //! Returns true if the option contains some value\n \n     !is_none(opt)\n }\n \n-pure fn get_default<T: Copy>(opt: &Option<T>, +def: T) -> T {\n+pub pure fn get_default<T: Copy>(opt: &Option<T>, def: T) -> T {\n     //! Returns the contained value or a default\n \n-    match *opt { Some(x) => x, None => def }\n+    match *opt { Some(copy x) => x, None => def }\n }\n \n-pure fn map_default<T, U>(opt: &Option<T>, +def: U, f: fn(T) -> U) -> U {\n-    //! Applies a function to the contained value or returns a default\n-\n-    match *opt { None => move def, Some(t) => f(t) }\n-}\n-\n-// This should replace map_default.\n-pure fn map_default_ref<T, U>(opt: &Option<T>, +def: U,\n+pub pure fn map_default<T, U>(opt: &Option<T>, def: U,\n                               f: fn(x: &T) -> U) -> U {\n     //! Applies a function to the contained value or returns a default\n \n     match *opt { None => move def, Some(ref t) => f(t) }\n }\n \n-// This should change to by-copy mode; use iter_ref below for by reference\n-pure fn iter<T>(opt: &Option<T>, f: fn(T)) {\n-    //! Performs an operation on the contained value or does nothing\n-\n-    match *opt { None => (), Some(t) => f(t) }\n-}\n-\n-pure fn iter_ref<T>(opt: &Option<T>, f: fn(x: &T)) {\n+pub pure fn iter<T>(opt: &Option<T>, f: fn(x: &T)) {\n     //! Performs an operation on the contained value by reference\n     match *opt { None => (), Some(ref t) => f(t) }\n }\n \n-// tjc: shouldn't this be - instead of +?\n-// then could get rid of some superfluous moves\n #[inline(always)]\n-pure fn unwrap<T>(+opt: Option<T>) -> T {\n+pub pure fn unwrap<T>(opt: Option<T>) -> T {\n     /*!\n      * Moves a value out of an option type and returns it.\n      *\n@@ -182,35 +167,23 @@ pure fn unwrap<T>(+opt: Option<T>) -> T {\n \n /// The ubiquitous option dance.\n #[inline(always)]\n-fn swap_unwrap<T>(opt: &mut Option<T>) -> T {\n+pub fn swap_unwrap<T>(opt: &mut Option<T>) -> T {\n     if opt.is_none() { fail ~\"option::swap_unwrap none\" }\n     unwrap(util::replace(opt, None))\n }\n \n-pure fn unwrap_expect<T>(+opt: Option<T>, reason: &str) -> T {\n+pub pure fn unwrap_expect<T>(opt: Option<T>, reason: &str) -> T {\n     //! As unwrap, but with a specified failure message.\n     if opt.is_none() { fail reason.to_unique(); }\n     unwrap(move opt)\n }\n \n // Some of these should change to be &Option<T>, some should not. See below.\n impl<T> Option<T> {\n-    /**\n-     * Update an optional value by optionally running its content through a\n-     * function that returns an option.\n-     */\n-    pure fn chain<U>(f: fn(T) -> Option<U>) -> Option<U> { chain(&self, f) }\n-    /// Applies a function to the contained value or returns a default\n-    pure fn map_default<U>(+def: U, f: fn(T) -> U) -> U\n-        { map_default(&self, move def, f) }\n-    /// Performs an operation on the contained value or does nothing\n-    pure fn iter(f: fn(T)) { iter(&self, f) }\n     /// Returns true if the option equals `none`\n     pure fn is_none() -> bool { is_none(&self) }\n     /// Returns true if the option contains some value\n     pure fn is_some() -> bool { is_some(&self) }\n-    /// Maps a `some` value from one type to another\n-    pure fn map<U>(f: fn(T) -> U) -> Option<U> { map(&self, f) }\n }\n \n impl<T> &Option<T> {\n@@ -222,12 +195,12 @@ impl<T> &Option<T> {\n         chain_ref(self, f)\n     }\n     /// Applies a function to the contained value or returns a default\n-    pure fn map_default_ref<U>(+def: U, f: fn(x: &T) -> U) -> U\n-        { map_default_ref(self, move def, f) }\n+    pure fn map_default<U>(def: U, f: fn(x: &T) -> U) -> U\n+        { map_default(self, move def, f) }\n     /// Performs an operation on the contained value by reference\n-    pure fn iter_ref(f: fn(x: &T)) { iter_ref(self, f) }\n+    pure fn iter(f: fn(x: &T)) { iter(self, f) }\n     /// Maps a `some` value from one type to another by reference\n-    pure fn map_ref<U>(f: fn(x: &T) -> U) -> Option<U> { map_ref(self, f) }\n+    pure fn map<U>(f: fn(x: &T) -> U) -> Option<U> { map(self, f) }\n     /// Gets an immutable reference to the value inside a `some`.\n     pure fn get_ref() -> &self/T { get_ref(self) }\n }\n@@ -241,7 +214,7 @@ impl<T: Copy> Option<T> {\n      * Fails if the value equals `none`\n      */\n     pure fn get() -> T { get(&self) }\n-    pure fn get_default(+def: T) -> T { get_default(&self, def) }\n+    pure fn get_default(def: T) -> T { get_default(&self, def) }\n     /**\n      * Gets the value out of an option, printing a specified message on\n      * failure\n@@ -250,9 +223,9 @@ impl<T: Copy> Option<T> {\n      *\n      * Fails if the value equals `none`\n      */\n-    pure fn expect(+reason: ~str) -> T { expect(&self, reason) }\n+    pure fn expect(reason: ~str) -> T { expect(&self, reason) }\n     /// Applies a function zero or more times until the result is none.\n-    pure fn while_some(blk: fn(+v: T) -> Option<T>) { while_some(self, blk) }\n+    pure fn while_some(blk: fn(v: T) -> Option<T>) { while_some(self, blk) }\n }\n \n impl<T: Eq> Option<T> : Eq {\n@@ -264,11 +237,11 @@ impl<T: Eq> Option<T> : Eq {\n                     Some(_) => false\n                 }\n             }\n-            Some(self_contents) => {\n+            Some(ref self_contents) => {\n                 match (*other) {\n                     None => false,\n                     Some(ref other_contents) =>\n-                        self_contents.eq(other_contents)\n+                        (*self_contents).eq(other_contents)\n                 }\n             }\n         }\n@@ -279,20 +252,20 @@ impl<T: Eq> Option<T> : Eq {\n #[test]\n fn test_unwrap_ptr() {\n     let x = ~0;\n-    let addr_x = ptr::addr_of(*x);\n+    let addr_x = ptr::p2::addr_of(&(*x));\n     let opt = Some(x);\n     let y = unwrap(opt);\n-    let addr_y = ptr::addr_of(*y);\n+    let addr_y = ptr::p2::addr_of(&(*y));\n     assert addr_x == addr_y;\n }\n \n #[test]\n fn test_unwrap_str() {\n     let x = ~\"test\";\n-    let addr_x = str::as_buf(x, |buf, _len| ptr::addr_of(buf));\n-    let opt = Some(x);\n-    let y = unwrap(opt);\n-    let addr_y = str::as_buf(y, |buf, _len| ptr::addr_of(buf));\n+    let addr_x = str::as_buf(x, |buf, _len| buf);\n+    let opt = Some(move x);\n+    let y = unwrap(move opt);\n+    let addr_y = str::as_buf(y, |buf, _len| buf);\n     assert addr_x == addr_y;\n }\n "}, {"sha": "68571da3a1e9dee022e9f835d8c06fa5c763f3ed", "filename": "src/libcore/os.rs", "status": "modified", "additions": 225, "deletions": 171, "changes": 396, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -1,5 +1,5 @@\n // NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n+// tjc: re-forbid\n #[forbid(deprecated_pattern)];\n \n /*!\n@@ -21,34 +21,23 @@\n  */\n \n use libc::{c_char, c_void, c_int, c_uint, size_t, ssize_t,\n-              mode_t, pid_t, FILE};\n-use libc::{close, fclose};\n+           mode_t, pid_t, FILE};\n+pub use libc::{close, fclose};\n \n use option::{Some, None};\n \n-use consts::*;\n+pub use consts::*;\n use task::TaskBuilder;\n \n-export close, fclose, fsync_fd, waitpid;\n-export env, getenv, setenv, fdopen, pipe;\n-export getcwd, dll_filename, self_exe_path;\n-export exe_suffix, dll_suffix, sysname, arch, family;\n-export homedir, tmpdir, list_dir, list_dir_path, path_is_dir, path_exists,\n-       make_absolute, make_dir, remove_dir, change_dir, remove_file,\n-       copy_file;\n-export last_os_error;\n-export set_exit_status;\n-export walk_dir;\n-\n // FIXME: move these to str perhaps? #2620\n-export as_c_charp, fill_charp_buf;\n \n extern mod rustrt {\n-    #[legacy_exports];\n+    fn rust_get_argc() -> c_int;\n+    fn rust_get_argv() -> **c_char;\n     fn rust_getcwd() -> ~str;\n     fn rust_path_is_dir(path: *libc::c_char) -> c_int;\n     fn rust_path_exists(path: *libc::c_char) -> c_int;\n-    fn rust_list_files(path: ~str) -> ~[~str];\n+    fn rust_list_files2(&&path: ~str) -> ~[~str];\n     fn rust_process_wait(handle: c_int) -> c_int;\n     fn last_os_error() -> ~str;\n     fn rust_set_exit_status(code: libc::intptr_t);\n@@ -57,15 +46,15 @@ extern mod rustrt {\n \n const tmpbuf_sz : uint = 1000u;\n \n-fn getcwd() -> Path {\n+pub fn getcwd() -> Path {\n     Path(rustrt::rust_getcwd())\n }\n \n-fn as_c_charp<T>(s: &str, f: fn(*c_char) -> T) -> T {\n+pub fn as_c_charp<T>(s: &str, f: fn(*c_char) -> T) -> T {\n     str::as_c_str(s, |b| f(b as *c_char))\n }\n \n-fn fill_charp_buf(f: fn(*mut c_char, size_t) -> bool)\n+pub fn fill_charp_buf(f: fn(*mut c_char, size_t) -> bool)\n     -> Option<~str> {\n     let buf = vec::to_mut(vec::from_elem(tmpbuf_sz, 0u8 as c_char));\n     do vec::as_mut_buf(buf) |b, sz| {\n@@ -79,29 +68,23 @@ fn fill_charp_buf(f: fn(*mut c_char, size_t) -> bool)\n \n #[cfg(windows)]\n mod win32 {\n-    #[legacy_exports];\n-    use dword = libc::types::os::arch::extra::DWORD;\n+    use libc::DWORD;\n \n-    fn fill_utf16_buf_and_decode(f: fn(*mut u16, dword) -> dword)\n+    pub fn fill_utf16_buf_and_decode(f: fn(*mut u16, DWORD) -> DWORD)\n         -> Option<~str> {\n-\n-        // FIXME: remove these when export globs work properly. #1238\n-        use libc::funcs::extra::kernel32::*;\n-        use libc::consts::os::extra::*;\n-\n-        let mut n = tmpbuf_sz as dword;\n+        let mut n = tmpbuf_sz as DWORD;\n         let mut res = None;\n         let mut done = false;\n         while !done {\n             let buf = vec::to_mut(vec::from_elem(n as uint, 0u16));\n             do vec::as_mut_buf(buf) |b, _sz| {\n-                let k : dword = f(b, tmpbuf_sz as dword);\n-                if k == (0 as dword) {\n+                let k : DWORD = f(b, tmpbuf_sz as DWORD);\n+                if k == (0 as DWORD) {\n                     done = true;\n                 } else if (k == n &&\n-                           GetLastError() ==\n-                           ERROR_INSUFFICIENT_BUFFER as dword) {\n-                    n *= (2 as dword);\n+                           libc::GetLastError() ==\n+                           libc::ERROR_INSUFFICIENT_BUFFER as DWORD) {\n+                    n *= (2 as DWORD);\n                 } else {\n                     let sub = vec::slice(buf, 0u, k as uint);\n                     res = option::Some(str::from_utf16(sub));\n@@ -112,36 +95,30 @@ mod win32 {\n         return res;\n     }\n \n-    fn as_utf16_p<T>(s: &str, f: fn(*u16) -> T) -> T {\n+    pub fn as_utf16_p<T>(s: &str, f: fn(*u16) -> T) -> T {\n         let mut t = str::to_utf16(s);\n         // Null terminate before passing on.\n         t += ~[0u16];\n         vec::as_imm_buf(t, |buf, _len| f(buf))\n     }\n }\n \n-fn getenv(n: &str) -> Option<~str> {\n+pub fn getenv(n: &str) -> Option<~str> {\n     global_env::getenv(n)\n }\n \n-fn setenv(n: &str, v: &str) {\n+pub fn setenv(n: &str, v: &str) {\n     global_env::setenv(n, v)\n }\n \n-fn env() -> ~[(~str,~str)] {\n+pub fn env() -> ~[(~str,~str)] {\n     global_env::env()\n }\n \n mod global_env {\n-    #[legacy_exports];\n     //! Internal module for serializing access to getenv/setenv\n \n-    export getenv;\n-    export setenv;\n-    export env;\n-\n     extern mod rustrt {\n-        #[legacy_exports];\n         fn rust_global_env_chan_ptr() -> *libc::uintptr_t;\n     }\n \n@@ -151,15 +128,15 @@ mod global_env {\n         MsgEnv(comm::Chan<~[(~str,~str)]>)\n     }\n \n-    fn getenv(n: &str) -> Option<~str> {\n+    pub fn getenv(n: &str) -> Option<~str> {\n         let env_ch = get_global_env_chan();\n         let po = comm::Port();\n         comm::send(env_ch, MsgGetEnv(str::from_slice(n),\n                                      comm::Chan(po)));\n         comm::recv(po)\n     }\n \n-    fn setenv(n: &str, v: &str) {\n+    pub fn setenv(n: &str, v: &str) {\n         let env_ch = get_global_env_chan();\n         let po = comm::Port();\n         comm::send(env_ch, MsgSetEnv(str::from_slice(n),\n@@ -168,7 +145,7 @@ mod global_env {\n         comm::recv(po)\n     }\n \n-    fn env() -> ~[(~str,~str)] {\n+    pub fn env() -> ~[(~str,~str)] {\n         let env_ch = get_global_env_chan();\n         let po = comm::Port();\n         comm::send(env_ch, MsgEnv(comm::Chan(po)));\n@@ -191,11 +168,11 @@ mod global_env {\n             do private::weaken_task |weak_po| {\n                 loop {\n                     match comm::select2(msg_po, weak_po) {\n-                      either::Left(MsgGetEnv(n, resp_ch)) => {\n-                        comm::send(resp_ch, impl_::getenv(n))\n+                      either::Left(MsgGetEnv(ref n, resp_ch)) => {\n+                        comm::send(resp_ch, impl_::getenv(*n))\n                       }\n-                      either::Left(MsgSetEnv(n, v, resp_ch)) => {\n-                        comm::send(resp_ch, impl_::setenv(n, v))\n+                      either::Left(MsgSetEnv(ref n, ref v, resp_ch)) => {\n+                        comm::send(resp_ch, impl_::setenv(*n, *v))\n                       }\n                       either::Left(MsgEnv(resp_ch)) => {\n                         comm::send(resp_ch, impl_::env())\n@@ -208,24 +185,22 @@ mod global_env {\n     }\n \n     mod impl_ {\n-        #[legacy_exports];\n         extern mod rustrt {\n-            #[legacy_exports];\n             fn rust_env_pairs() -> ~[~str];\n         }\n \n-        fn env() -> ~[(~str,~str)] {\n+        pub fn env() -> ~[(~str,~str)] {\n             let mut pairs = ~[];\n             for vec::each(rustrt::rust_env_pairs()) |p| {\n                 let vs = str::splitn_char(*p, '=', 1u);\n                 assert vec::len(vs) == 2u;\n-                vec::push(pairs, (copy vs[0], copy vs[1]));\n+                pairs.push((copy vs[0], copy vs[1]));\n             }\n             move pairs\n         }\n \n         #[cfg(unix)]\n-        fn getenv(n: &str) -> Option<~str> {\n+        pub fn getenv(n: &str) -> Option<~str> {\n             unsafe {\n                 let s = str::as_c_str(n, libc::getenv);\n                 return if ptr::null::<u8>() == cast::reinterpret_cast(&s) {\n@@ -238,47 +213,40 @@ mod global_env {\n         }\n \n         #[cfg(windows)]\n-        fn getenv(n: &str) -> Option<~str> {\n-            use libc::types::os::arch::extra::*;\n-            use libc::funcs::extra::kernel32::*;\n+        pub fn getenv(n: &str) -> Option<~str> {\n             use win32::*;\n             do as_utf16_p(n) |u| {\n                 do fill_utf16_buf_and_decode() |buf, sz| {\n-                    GetEnvironmentVariableW(u, buf, sz)\n+                    libc::GetEnvironmentVariableW(u, buf, sz)\n                 }\n             }\n         }\n \n \n         #[cfg(unix)]\n-        fn setenv(n: &str, v: &str) {\n-\n-            // FIXME: remove this when export globs work properly. #1238\n-            use libc::funcs::posix01::unistd::setenv;\n+        pub fn setenv(n: &str, v: &str) {\n             do str::as_c_str(n) |nbuf| {\n                 do str::as_c_str(v) |vbuf| {\n-                    setenv(nbuf, vbuf, 1i32);\n+                    libc::funcs::posix01::unistd::setenv(nbuf, vbuf, 1i32);\n                 }\n             }\n         }\n \n \n         #[cfg(windows)]\n-        fn setenv(n: &str, v: &str) {\n-            // FIXME: remove imports when export globs work properly. #1238\n-            use libc::funcs::extra::kernel32::*;\n+        pub fn setenv(n: &str, v: &str) {\n             use win32::*;\n             do as_utf16_p(n) |nbuf| {\n                 do as_utf16_p(v) |vbuf| {\n-                    SetEnvironmentVariableW(nbuf, vbuf);\n+                    libc::SetEnvironmentVariableW(nbuf, vbuf);\n                 }\n             }\n         }\n \n     }\n }\n \n-fn fdopen(fd: c_int) -> *FILE {\n+pub fn fdopen(fd: c_int) -> *FILE {\n     return do as_c_charp(\"r\") |modebuf| {\n         libc::fdopen(fd, modebuf)\n     };\n@@ -288,13 +256,13 @@ fn fdopen(fd: c_int) -> *FILE {\n // fsync related\n \n #[cfg(windows)]\n-fn fsync_fd(fd: c_int, _level: io::fsync::Level) -> c_int {\n+pub fn fsync_fd(fd: c_int, _level: io::fsync::Level) -> c_int {\n     use libc::funcs::extra::msvcrt::*;\n     return commit(fd);\n }\n \n #[cfg(target_os = \"linux\")]\n-fn fsync_fd(fd: c_int, level: io::fsync::Level) -> c_int {\n+pub fn fsync_fd(fd: c_int, level: io::fsync::Level) -> c_int {\n     use libc::funcs::posix01::unistd::*;\n     match level {\n       io::fsync::FSync\n@@ -304,7 +272,7 @@ fn fsync_fd(fd: c_int, level: io::fsync::Level) -> c_int {\n }\n \n #[cfg(target_os = \"macos\")]\n-fn fsync_fd(fd: c_int, level: io::fsync::Level) -> c_int {\n+pub fn fsync_fd(fd: c_int, level: io::fsync::Level) -> c_int {\n     use libc::consts::os::extra::*;\n     use libc::funcs::posix88::fcntl::*;\n     use libc::funcs::posix01::unistd::*;\n@@ -321,52 +289,50 @@ fn fsync_fd(fd: c_int, level: io::fsync::Level) -> c_int {\n }\n \n #[cfg(target_os = \"freebsd\")]\n-fn fsync_fd(fd: c_int, _l: io::fsync::Level) -> c_int {\n+pub fn fsync_fd(fd: c_int, _l: io::fsync::Level) -> c_int {\n     use libc::funcs::posix01::unistd::*;\n     return fsync(fd);\n }\n \n \n #[cfg(windows)]\n-fn waitpid(pid: pid_t) -> c_int {\n+pub fn waitpid(pid: pid_t) -> c_int {\n     return rustrt::rust_process_wait(pid);\n }\n \n #[cfg(unix)]\n-fn waitpid(pid: pid_t) -> c_int {\n+pub fn waitpid(pid: pid_t) -> c_int {\n     use libc::funcs::posix01::wait::*;\n     let status = 0 as c_int;\n \n-    assert (waitpid(pid, ptr::mut_addr_of(status),\n+    assert (waitpid(pid, ptr::mut_addr_of(&status),\n                     0 as c_int) != (-1 as c_int));\n     return status;\n }\n \n \n #[cfg(unix)]\n-fn pipe() -> {in: c_int, out: c_int} {\n+pub fn pipe() -> {in: c_int, out: c_int} {\n     let fds = {mut in: 0 as c_int,\n                mut out: 0 as c_int };\n-    assert (libc::pipe(ptr::mut_addr_of(fds.in)) == (0 as c_int));\n+    assert (libc::pipe(ptr::mut_addr_of(&(fds.in))) == (0 as c_int));\n     return {in: fds.in, out: fds.out};\n }\n \n \n \n #[cfg(windows)]\n-fn pipe() -> {in: c_int, out: c_int} {\n-    // FIXME: remove this when export globs work properly. #1238\n-    use libc::consts::os::extra::*;\n+pub fn pipe() -> {in: c_int, out: c_int} {\n     // Windows pipes work subtly differently than unix pipes, and their\n     // inheritance has to be handled in a different way that I do not fully\n     // understand. Here we explicitly make the pipe non-inheritable, which\n     // means to pass it to a subprocess they need to be duplicated first, as\n     // in rust_run_program.\n     let fds = { mut in: 0 as c_int,\n-               mut out: 0 as c_int };\n-    let res = libc::pipe(ptr::mut_addr_of(fds.in),\n+                mut out: 0 as c_int };\n+    let res = libc::pipe(ptr::mut_addr_of(&(fds.in)),\n                          1024 as c_uint,\n-                         (O_BINARY | O_NOINHERIT) as c_int);\n+                         (libc::O_BINARY | libc::O_NOINHERIT) as c_int);\n     assert (res == 0 as c_int);\n     assert (fds.in != -1 as c_int && fds.in != 0 as c_int);\n     assert (fds.out != -1 as c_int && fds.in != 0 as c_int);\n@@ -378,7 +344,7 @@ fn dup2(src: c_int, dst: c_int) -> c_int {\n }\n \n \n-fn dll_filename(base: &str) -> ~str {\n+pub fn dll_filename(base: &str) -> ~str {\n     return pre() + str::from_slice(base) + dll_suffix();\n \n     #[cfg(unix)]\n@@ -389,7 +355,7 @@ fn dll_filename(base: &str) -> ~str {\n }\n \n \n-fn self_exe_path() -> Option<Path> {\n+pub fn self_exe_path() -> Option<Path> {\n \n     #[cfg(target_os = \"freebsd\")]\n     fn load_self() -> Option<~str> {\n@@ -401,7 +367,7 @@ fn self_exe_path() -> Option<Path> {\n                            KERN_PROC as c_int,\n                            KERN_PROC_PATHNAME as c_int, -1 as c_int];\n                 sysctl(vec::raw::to_ptr(mib), vec::len(mib) as c_uint,\n-                       buf as *mut c_void, ptr::mut_addr_of(sz),\n+                       buf as *mut c_void, ptr::mut_addr_of(&sz),\n                        ptr::null(), 0u as size_t) == (0 as c_int)\n             }\n         }\n@@ -419,27 +385,22 @@ fn self_exe_path() -> Option<Path> {\n \n     #[cfg(target_os = \"macos\")]\n     fn load_self() -> Option<~str> {\n-        // FIXME: remove imports when export globs work properly. #1238\n-        use libc::funcs::extra::*;\n         do fill_charp_buf() |buf, sz| {\n-            _NSGetExecutablePath(buf, ptr::mut_addr_of(sz as u32))\n-                == (0 as c_int)\n+            libc::funcs::extra::_NSGetExecutablePath(\n+                buf, ptr::mut_addr_of(&(sz as u32))) == (0 as c_int)\n         }\n     }\n \n     #[cfg(windows)]\n     fn load_self() -> Option<~str> {\n-        // FIXME: remove imports when export globs work properly. #1238\n-        use libc::types::os::arch::extra::*;\n-        use libc::funcs::extra::kernel32::*;\n         use win32::*;\n         do fill_utf16_buf_and_decode() |buf, sz| {\n-            GetModuleFileNameW(0u as dword, buf, sz)\n+            libc::GetModuleFileNameW(0u as libc::DWORD, buf, sz)\n         }\n     }\n \n     do load_self().map |pth| {\n-        Path(pth).dir_path()\n+        Path(*pth).dir_path()\n     }\n }\n \n@@ -457,10 +418,10 @@ fn self_exe_path() -> Option<Path> {\n  *\n  * Otherwise, homedir returns option::none.\n  */\n-fn homedir() -> Option<Path> {\n+pub fn homedir() -> Option<Path> {\n     return match getenv(~\"HOME\") {\n-        Some(p) => if !str::is_empty(p) {\n-          Some(Path(p))\n+        Some(ref p) => if !str::is_empty(*p) {\n+          Some(Path(*p))\n         } else {\n           secondary()\n         },\n@@ -474,7 +435,7 @@ fn homedir() -> Option<Path> {\n \n     #[cfg(windows)]\n     fn secondary() -> Option<Path> {\n-        do option::chain(&getenv(~\"USERPROFILE\")) |p| {\n+        do option::chain(getenv(~\"USERPROFILE\")) |p| {\n             if !str::is_empty(p) {\n                 Some(Path(p))\n             } else {\n@@ -494,12 +455,12 @@ fn homedir() -> Option<Path> {\n  * 'USERPROFILE' environment variable  if any are set and not the empty\n  * string. Otherwise, tmpdir returns the path to the Windows directory.\n  */\n-fn tmpdir() -> Path {\n+pub fn tmpdir() -> Path {\n     return lookup();\n \n     fn getenv_nonempty(v: &str) -> Option<Path> {\n         match getenv(v) {\n-            Some(x) =>\n+            Some(move x) =>\n                 if str::is_empty(x) {\n                     None\n                 } else {\n@@ -528,7 +489,7 @@ fn tmpdir() -> Path {\n     }\n }\n /// Recursively walk a directory structure\n-fn walk_dir(p: &Path, f: fn((&Path)) -> bool) {\n+pub fn walk_dir(p: &Path, f: fn((&Path)) -> bool) {\n \n     walk_dir_(p, f);\n \n@@ -557,21 +518,19 @@ fn walk_dir(p: &Path, f: fn((&Path)) -> bool) {\n }\n \n /// Indicates whether a path represents a directory\n-fn path_is_dir(p: &Path) -> bool {\n+pub fn path_is_dir(p: &Path) -> bool {\n     do str::as_c_str(p.to_str()) |buf| {\n         rustrt::rust_path_is_dir(buf) != 0 as c_int\n     }\n }\n \n /// Indicates whether a path exists\n-fn path_exists(p: &Path) -> bool {\n+pub fn path_exists(p: &Path) -> bool {\n     do str::as_c_str(p.to_str()) |buf| {\n         rustrt::rust_path_exists(buf) != 0 as c_int\n     }\n }\n \n-// FIXME (#2622): under Windows, we should prepend the current drive letter\n-// to paths that start with a slash.\n /**\n  * Convert a relative path to an absolute path\n  *\n@@ -582,7 +541,7 @@ fn path_exists(p: &Path) -> bool {\n // NB: this is here rather than in path because it is a form of environment\n // querying; what it does depends on the process working directory, not just\n // the input paths.\n-fn make_absolute(p: &Path) -> Path {\n+pub fn make_absolute(p: &Path) -> Path {\n     if p.is_absolute {\n         copy *p\n     } else {\n@@ -592,19 +551,18 @@ fn make_absolute(p: &Path) -> Path {\n \n \n /// Creates a directory at the specified path\n-fn make_dir(p: &Path, mode: c_int) -> bool {\n+pub fn make_dir(p: &Path, mode: c_int) -> bool {\n     return mkdir(p, mode);\n \n     #[cfg(windows)]\n     fn mkdir(p: &Path, _mode: c_int) -> bool {\n-        // FIXME: remove imports when export globs work properly. #1238\n-        use libc::types::os::arch::extra::*;\n-        use libc::funcs::extra::kernel32::*;\n         use win32::*;\n         // FIXME: turn mode into something useful? #2623\n         do as_utf16_p(p.to_str()) |buf| {\n-            CreateDirectoryW(buf, unsafe { cast::reinterpret_cast(&0) })\n-                != (0 as BOOL)\n+            libc::CreateDirectoryW(buf, unsafe {\n+                cast::reinterpret_cast(&0)\n+            })\n+                != (0 as libc::BOOL)\n         }\n     }\n \n@@ -618,16 +576,16 @@ fn make_dir(p: &Path, mode: c_int) -> bool {\n \n /// Lists the contents of a directory\n #[allow(non_implicitly_copyable_typarams)]\n-fn list_dir(p: &Path) -> ~[~str] {\n+pub fn list_dir(p: &Path) -> ~[~str] {\n \n     #[cfg(unix)]\n     fn star(p: &Path) -> Path { copy *p }\n \n     #[cfg(windows)]\n     fn star(p: &Path) -> Path { p.push(\"*\") }\n \n-    do rustrt::rust_list_files(star(p).to_str()).filter |filename| {\n-        filename != ~\".\" && filename != ~\"..\"\n+    do rustrt::rust_list_files2(star(p).to_str()).filter |filename| {\n+        *filename != ~\".\" && *filename != ~\"..\"\n     }\n }\n \n@@ -636,22 +594,19 @@ fn list_dir(p: &Path) -> ~[~str] {\n  *\n  * This version prepends each entry with the directory.\n  */\n-fn list_dir_path(p: &Path) -> ~[~Path] {\n+pub fn list_dir_path(p: &Path) -> ~[~Path] {\n     os::list_dir(p).map(|f| ~p.push(*f))\n }\n \n /// Removes a directory at the specified path\n-fn remove_dir(p: &Path) -> bool {\n+pub fn remove_dir(p: &Path) -> bool {\n    return rmdir(p);\n \n     #[cfg(windows)]\n     fn rmdir(p: &Path) -> bool {\n-        // FIXME: remove imports when export globs work properly. #1238\n-        use libc::funcs::extra::kernel32::*;\n-        use libc::types::os::arch::extra::*;\n         use win32::*;\n         return do as_utf16_p(p.to_str()) |buf| {\n-            RemoveDirectoryW(buf) != (0 as BOOL)\n+            libc::RemoveDirectoryW(buf) != (0 as libc::BOOL)\n         };\n     }\n \n@@ -663,17 +618,14 @@ fn remove_dir(p: &Path) -> bool {\n     }\n }\n \n-fn change_dir(p: &Path) -> bool {\n+pub fn change_dir(p: &Path) -> bool {\n     return chdir(p);\n \n     #[cfg(windows)]\n     fn chdir(p: &Path) -> bool {\n-        // FIXME: remove imports when export globs work properly. #1238\n-        use libc::funcs::extra::kernel32::*;\n-        use libc::types::os::arch::extra::*;\n         use win32::*;\n         return do as_utf16_p(p.to_str()) |buf| {\n-            SetCurrentDirectoryW(buf) != (0 as BOOL)\n+            libc::SetCurrentDirectoryW(buf) != (0 as libc::BOOL)\n         };\n     }\n \n@@ -686,18 +638,16 @@ fn change_dir(p: &Path) -> bool {\n }\n \n /// Copies a file from one location to another\n-fn copy_file(from: &Path, to: &Path) -> bool {\n+pub fn copy_file(from: &Path, to: &Path) -> bool {\n     return do_copy_file(from, to);\n \n     #[cfg(windows)]\n     fn do_copy_file(from: &Path, to: &Path) -> bool {\n-        // FIXME: remove imports when export globs work properly. #1238\n-        use libc::funcs::extra::kernel32::*;\n-        use libc::types::os::arch::extra::*;\n         use win32::*;\n         return do as_utf16_p(from.to_str()) |fromp| {\n             do as_utf16_p(to.to_str()) |top| {\n-                CopyFileW(fromp, top, (0 as BOOL)) != (0 as BOOL)\n+                libc::CopyFileW(fromp, top, (0 as libc::BOOL)) !=\n+                    (0 as libc::BOOL)\n             }\n         }\n     }\n@@ -748,18 +698,14 @@ fn copy_file(from: &Path, to: &Path) -> bool {\n }\n \n /// Deletes an existing file\n-fn remove_file(p: &Path) -> bool {\n+pub fn remove_file(p: &Path) -> bool {\n     return unlink(p);\n \n     #[cfg(windows)]\n     fn unlink(p: &Path) -> bool {\n-        // FIXME (similar to Issue #2006): remove imports when export globs\n-        // work properly.\n-        use libc::funcs::extra::kernel32::*;\n-        use libc::types::os::arch::extra::*;\n         use win32::*;\n         return do as_utf16_p(p.to_str()) |buf| {\n-            DeleteFileW(buf) != (0 as BOOL)\n+            libc::DeleteFileW(buf) != (0 as libc::BOOL)\n         };\n     }\n \n@@ -772,7 +718,7 @@ fn remove_file(p: &Path) -> bool {\n }\n \n /// Get a string representing the platform-dependent last error\n-fn last_os_error() -> ~str {\n+pub fn last_os_error() -> ~str {\n     rustrt::last_os_error()\n }\n \n@@ -784,67 +730,175 @@ fn last_os_error() -> ~str {\n  * and is supervised by the scheduler then any user-specified exit status is\n  * ignored and the process exits with the default failure status\n  */\n-fn set_exit_status(code: int) {\n+pub fn set_exit_status(code: int) {\n     rustrt::rust_set_exit_status(code as libc::intptr_t);\n }\n \n+unsafe fn load_argc_and_argv(argc: c_int, argv: **c_char) -> ~[~str] {\n+    let mut args = ~[];\n+    for uint::range(0, argc as uint) |i| {\n+        vec::push(&mut args, str::raw::from_c_str(*argv.offset(i)));\n+    }\n+    return args;\n+}\n+\n+/**\n+ * Returns the command line arguments\n+ *\n+ * Returns a list of the command line arguments.\n+ */\n+#[cfg(target_os = \"macos\")]\n+fn real_args() -> ~[~str] {\n+    unsafe {\n+        let (argc, argv) = (*_NSGetArgc() as c_int,\n+                            *_NSGetArgv() as **c_char);\n+        load_argc_and_argv(argc, argv)\n+    }\n+}\n+\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"freebsd\")]\n+fn real_args() -> ~[~str] {\n+    unsafe {\n+        let argc = rustrt::rust_get_argc();\n+        let argv = rustrt::rust_get_argv();\n+        load_argc_and_argv(argc, argv)\n+    }\n+}\n+\n+#[cfg(windows)]\n+fn real_args() -> ~[~str] {\n+    let mut nArgs: c_int = 0;\n+    let lpArgCount = ptr::to_mut_unsafe_ptr(&mut nArgs);\n+    let lpCmdLine = GetCommandLineW();\n+    let szArgList = CommandLineToArgvW(lpCmdLine, lpArgCount);\n+\n+    let mut args = ~[];\n+    for uint::range(0, nArgs as uint) |i| {\n+        unsafe {\n+            // Determine the length of this argument.\n+            let ptr = *szArgList.offset(i);\n+            let mut len = 0;\n+            while *ptr.offset(len) != 0 { len += 1; }\n+\n+            // Push it onto the list.\n+            vec::push(&mut args,\n+                      vec::raw::buf_as_slice(ptr, len,\n+                                             str::from_utf16));\n+        }\n+    }\n+\n+    unsafe {\n+        LocalFree(cast::transmute(szArgList));\n+    }\n+\n+    return args;\n+}\n+\n+type LPCWSTR = *u16;\n+\n+#[cfg(windows)]\n+#[link_name=\"kernel32\"]\n+#[abi=\"stdcall\"]\n+extern {\n+    fn GetCommandLineW() -> LPCWSTR;\n+    fn LocalFree(ptr: *c_void);\n+}\n+\n+#[cfg(windows)]\n+#[link_name=\"shell32\"]\n+#[abi=\"stdcall\"]\n+extern {\n+    fn CommandLineToArgvW(lpCmdLine: LPCWSTR, pNumArgs: *mut c_int) -> **u16;\n+}\n+\n+struct OverriddenArgs {\n+    val: ~[~str]\n+}\n+\n+fn overridden_arg_key(_v: @OverriddenArgs) {}\n+\n+pub fn args() -> ~[~str] {\n+    unsafe {\n+        match task::local_data::local_data_get(overridden_arg_key) {\n+            None => real_args(),\n+            Some(args) => copy args.val\n+        }\n+    }\n+}\n+\n+pub fn set_args(new_args: ~[~str]) {\n+    unsafe {\n+        let overridden_args = @OverriddenArgs { val: copy new_args };\n+        task::local_data::local_data_set(overridden_arg_key, overridden_args);\n+    }\n+}\n+\n+#[cfg(target_os = \"macos\")]\n+extern {\n+    // These functions are in crt_externs.h.\n+    pub fn _NSGetArgc() -> *c_int;\n+    pub fn _NSGetArgv() -> ***c_char;\n+}\n+\n #[cfg(unix)]\n-fn family() -> ~str { ~\"unix\" }\n+pub fn family() -> ~str { ~\"unix\" }\n \n #[cfg(windows)]\n-fn family() -> ~str { ~\"windows\" }\n+pub fn family() -> ~str { ~\"windows\" }\n \n #[cfg(target_os = \"macos\")]\n mod consts {\n-    #[legacy_exports];\n-    fn sysname() -> ~str { ~\"macos\" }\n-    fn exe_suffix() -> ~str { ~\"\" }\n-    fn dll_suffix() -> ~str { ~\".dylib\" }\n+    pub fn sysname() -> ~str { ~\"macos\" }\n+    pub fn exe_suffix() -> ~str { ~\"\" }\n+    pub fn dll_suffix() -> ~str { ~\".dylib\" }\n }\n \n #[cfg(target_os = \"freebsd\")]\n mod consts {\n-    #[legacy_exports];\n-    fn sysname() -> ~str { ~\"freebsd\" }\n-    fn exe_suffix() -> ~str { ~\"\" }\n-    fn dll_suffix() -> ~str { ~\".so\" }\n+    pub fn sysname() -> ~str { ~\"freebsd\" }\n+    pub fn exe_suffix() -> ~str { ~\"\" }\n+    pub fn dll_suffix() -> ~str { ~\".so\" }\n }\n \n #[cfg(target_os = \"linux\")]\n mod consts {\n-    #[legacy_exports];\n-    fn sysname() -> ~str { ~\"linux\" }\n-    fn exe_suffix() -> ~str { ~\"\" }\n-    fn dll_suffix() -> ~str { ~\".so\" }\n+    pub fn sysname() -> ~str { ~\"linux\" }\n+    pub fn exe_suffix() -> ~str { ~\"\" }\n+    pub fn dll_suffix() -> ~str { ~\".so\" }\n }\n \n #[cfg(target_os = \"win32\")]\n mod consts {\n-    #[legacy_exports];\n-    fn sysname() -> ~str { ~\"win32\" }\n-    fn exe_suffix() -> ~str { ~\".exe\" }\n-    fn dll_suffix() -> ~str { ~\".dll\" }\n+    pub fn sysname() -> ~str { ~\"win32\" }\n+    pub fn exe_suffix() -> ~str { ~\".exe\" }\n+    pub fn dll_suffix() -> ~str { ~\".dll\" }\n }\n \n #[cfg(target_arch = \"x86\")]\n-fn arch() -> ~str { ~\"x86\" }\n+pub fn arch() -> ~str { ~\"x86\" }\n \n #[cfg(target_arch = \"x86_64\")]\n-fn arch() -> ~str { ~\"x86_64\" }\n+pub fn arch() -> ~str { ~\"x86_64\" }\n \n #[cfg(target_arch = \"arm\")]\n-fn arch() -> str { ~\"arm\" }\n+pub fn arch() -> str { ~\"arm\" }\n \n #[cfg(test)]\n #[allow(non_implicitly_copyable_typarams)]\n mod tests {\n-    #[legacy_exports];\n \n     #[test]\n-    fn last_os_error() {\n+    pub fn last_os_error() {\n         log(debug, last_os_error());\n     }\n \n+    #[test]\n+    pub fn test_args() {\n+        let a = real_args();\n+        assert a.len() >= 1;\n+    }\n+\n     fn make_rand_name() -> ~str {\n         let rng: rand::Rng = rand::Rng();\n         let n = ~\"TEST\" + rng.gen_str(10u);\n@@ -919,10 +973,10 @@ mod tests {\n \n         let mut e = env();\n         setenv(n, ~\"VALUE\");\n-        assert !vec::contains(e, (copy n, ~\"VALUE\"));\n+        assert !vec::contains(e, &(copy n, ~\"VALUE\"));\n \n         e = env();\n-        assert vec::contains(e, (n, ~\"VALUE\"));\n+        assert vec::contains(e, &(n, ~\"VALUE\"));\n     }\n \n     #[test]\n@@ -946,7 +1000,7 @@ mod tests {\n         setenv(~\"HOME\", ~\"\");\n         assert os::homedir().is_none();\n \n-        oldhome.iter(|s| setenv(~\"HOME\", s));\n+        oldhome.iter(|s| setenv(~\"HOME\", *s));\n     }\n \n     #[test]\n@@ -973,9 +1027,9 @@ mod tests {\n         setenv(~\"USERPROFILE\", ~\"/home/PaloAlto\");\n         assert os::homedir() == Some(Path(\"/home/MountainView\"));\n \n-        option::iter(&oldhome, |s| setenv(~\"HOME\", s));\n+        option::iter(&oldhome, |s| setenv(~\"HOME\", *s));\n         option::iter(&olduserprofile,\n-                               |s| setenv(~\"USERPROFILE\", s));\n+                               |s| setenv(~\"USERPROFILE\", *s));\n     }\n \n     #[test]"}, {"sha": "6d023ed1bfb77f17898f30d55e3011615ff5c668", "filename": "src/libcore/path.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -10,19 +10,19 @@ Cross-platform file path handling\n \n use cmp::Eq;\n \n-struct WindowsPath {\n+pub struct WindowsPath {\n     host: Option<~str>,\n     device: Option<~str>,\n     is_absolute: bool,\n     components: ~[~str],\n }\n \n-struct PosixPath {\n+pub struct PosixPath {\n     is_absolute: bool,\n     components: ~[~str],\n }\n \n-trait GenericPath {\n+pub trait GenericPath {\n \n     static pure fn from_str((&str)) -> self;\n \n@@ -45,18 +45,18 @@ trait GenericPath {\n }\n \n #[cfg(windows)]\n-type Path = WindowsPath;\n+pub type Path = WindowsPath;\n \n #[cfg(windows)]\n-pure fn Path(s: &str) -> Path {\n+pub pure fn Path(s: &str) -> Path {\n     from_str::<WindowsPath>(s)\n }\n \n #[cfg(unix)]\n-type Path = PosixPath;\n+pub type Path = PosixPath;\n \n #[cfg(unix)]\n-pure fn Path(s: &str) -> Path {\n+pub pure fn Path(s: &str) -> Path {\n     from_str::<PosixPath>(s)\n }\n \n@@ -167,7 +167,7 @@ impl PosixPath : GenericPath {\n         if t.len() == 0 {\n             match self.filestem() {\n               None => copy self,\n-              Some(s) => self.with_filename(s)\n+              Some(ref s) => self.with_filename(*s)\n             }\n         } else {\n             let t = ~\".\" + str::from_slice(t);\n@@ -206,22 +206,22 @@ impl PosixPath : GenericPath {\n             let mut ss = str::split_nonempty(\n                 *e,\n                 |c| windows::is_sep(c as u8));\n-            unsafe { vec::push_all_move(v, move ss); }\n+            unsafe { v.push_all_move(move ss); }\n         }\n         PosixPath { components: move v, ..self }\n     }\n \n     pure fn push(s: &str) -> PosixPath {\n         let mut v = copy self.components;\n         let mut ss = str::split_nonempty(s, |c| windows::is_sep(c as u8));\n-        unsafe { vec::push_all_move(v, move ss); }\n+        unsafe { v.push_all_move(move ss); }\n         PosixPath { components: move v, ..self }\n     }\n \n     pure fn pop() -> PosixPath {\n         let mut cs = copy self.components;\n         if cs.len() != 0 {\n-            unsafe { vec::pop(cs); }\n+            unsafe { cs.pop(); }\n         }\n         return PosixPath { components: move cs, ..self }\n     }\n@@ -239,11 +239,11 @@ impl WindowsPath : ToStr {\n     fn to_str() -> ~str {\n         let mut s = ~\"\";\n         match self.host {\n-          Some(h) => { s += \"\\\\\\\\\"; s += h; }\n+          Some(ref h) => { s += \"\\\\\\\\\"; s += *h; }\n           None => { }\n         }\n         match self.device {\n-          Some(d) => { s += d; s += \":\"; }\n+          Some(ref d) => { s += *d; s += \":\"; }\n           None => { }\n         }\n         if self.is_absolute {\n@@ -358,7 +358,7 @@ impl WindowsPath : GenericPath {\n         if t.len() == 0 {\n             match self.filestem() {\n               None => copy self,\n-              Some(s) => self.with_filename(s)\n+              Some(ref s) => self.with_filename(*s)\n             }\n         } else {\n             let t = ~\".\" + str::from_slice(t);\n@@ -400,22 +400,22 @@ impl WindowsPath : GenericPath {\n             let mut ss = str::split_nonempty(\n                 *e,\n                 |c| windows::is_sep(c as u8));\n-            unsafe { vec::push_all_move(v, move ss); }\n+            unsafe { v.push_all_move(move ss); }\n         }\n         return WindowsPath { components: move v, ..self }\n     }\n \n     pure fn push(s: &str) -> WindowsPath {\n         let mut v = copy self.components;\n         let mut ss = str::split_nonempty(s, |c| windows::is_sep(c as u8));\n-        unsafe { vec::push_all_move(v, move ss); }\n+        unsafe { v.push_all_move(move ss); }\n         return WindowsPath { components: move v, ..self }\n     }\n \n     pure fn pop() -> WindowsPath {\n         let mut cs = copy self.components;\n         if cs.len() != 0 {\n-            unsafe { vec::pop(cs); }\n+            unsafe { cs.pop(); }\n         }\n         return WindowsPath { components: move cs, ..self }\n     }\n@@ -429,18 +429,18 @@ impl WindowsPath : GenericPath {\n }\n \n \n-pure fn normalize(components: &[~str]) -> ~[~str] {\n+pub pure fn normalize(components: &[~str]) -> ~[~str] {\n     let mut cs = ~[];\n     unsafe {\n         for components.each |c| {\n             unsafe {\n                 if *c == ~\".\" && components.len() > 1 { loop; }\n                 if *c == ~\"\" { loop; }\n                 if *c == ~\"..\" && cs.len() != 0 {\n-                    vec::pop(cs);\n+                    cs.pop();\n                     loop;\n                 }\n-                vec::push(cs, copy *c);\n+                cs.push(copy *c);\n             }\n         }\n     }\n@@ -462,7 +462,6 @@ fn test_double_slash_collapsing()\n }\n \n mod posix {\n-    #[legacy_exports];\n \n     #[cfg(test)]\n     fn mk(s: &str) -> PosixPath { from_str::<PosixPath>(s) }\n@@ -553,14 +552,13 @@ mod posix {\n \n // Various windows helpers, and tests for the impl.\n mod windows {\n-    #[legacy_exports];\n \n     #[inline(always)]\n-    pure fn is_sep(u: u8) -> bool {\n+    pub pure fn is_sep(u: u8) -> bool {\n         u == '/' as u8 || u == '\\\\' as u8\n     }\n \n-    pure fn extract_unc_prefix(s: &str) -> Option<(~str,~str)> {\n+    pub pure fn extract_unc_prefix(s: &str) -> Option<(~str,~str)> {\n         if (s.len() > 1 &&\n             s[0] == '\\\\' as u8 &&\n             s[1] == '\\\\' as u8) {\n@@ -577,7 +575,7 @@ mod windows {\n         None\n     }\n \n-    pure fn extract_drive_prefix(s: &str) -> Option<(~str,~str)> {\n+    pub pure fn extract_drive_prefix(s: &str) -> Option<(~str,~str)> {\n         unsafe {\n             if (s.len() > 1 &&\n                 libc::isalpha(s[0] as libc::c_int) != 0 &&"}, {"sha": "e34c0db35e9d59133ea6fc94d286160ab45da7a2", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 93, "deletions": 131, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -73,39 +73,19 @@ bounded and unbounded protocols allows for less code duplication.\n */\n \n // NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n+// tjc: re-forbid deprecated modes after snapshot\n #[forbid(deprecated_pattern)];\n \n use cmp::Eq;\n use cast::{forget, reinterpret_cast, transmute};\n use either::{Either, Left, Right};\n use option::unwrap;\n \n-// Things used by code generated by the pipe compiler.\n-export entangle, get_buffer, drop_buffer;\n-export SendPacketBuffered, RecvPacketBuffered;\n-export Packet, packet, mk_packet, entangle_buffer, HasBuffer, BufferHeader;\n-\n-// export these so we can find them in the buffer_resource\n-// destructor. This is probably a symptom of #3005.\n-export atomic_add_acq, atomic_sub_rel;\n-\n-// User-level things\n-export SendPacket, RecvPacket, send, recv, try_recv, peek;\n-export select, select2, selecti, select2i, selectable;\n-export spawn_service, spawn_service_recv;\n-export stream, Port, Chan, SharedChan, PortSet, Channel;\n-export oneshot, ChanOne, PortOne;\n-export recv_one, try_recv_one, send_one, try_send_one;\n-\n-// Functions used by the protocol compiler\n-export rt;\n-\n #[doc(hidden)]\n const SPIN_COUNT: uint = 0;\n \n macro_rules! move_it (\n-    { $x:expr } => { unsafe { let y <- *ptr::addr_of($x); move y } }\n+    { $x:expr } => { unsafe { let y <- *ptr::addr_of(&($x)); move y } }\n )\n \n #[doc(hidden)]\n@@ -123,7 +103,7 @@ impl State : Eq {\n     pure fn ne(other: &State) -> bool { !self.eq(other) }\n }\n \n-struct BufferHeader {\n+pub struct BufferHeader {\n     // Tracks whether this buffer needs to be freed. We can probably\n     // get away with restricting it to 0 or 1, if we're careful.\n     mut ref_count: int,\n@@ -132,7 +112,7 @@ struct BufferHeader {\n     // thing along.\n }\n \n-fn BufferHeader() -> BufferHeader{\n+pub fn BufferHeader() -> BufferHeader{\n     BufferHeader {\n         ref_count: 0\n     }\n@@ -195,13 +175,13 @@ impl PacketHeader {\n }\n \n #[doc(hidden)]\n-type Packet<T: Send> = {\n+pub type Packet<T: Send> = {\n     header: PacketHeader,\n     mut payload: Option<T>,\n };\n \n #[doc(hidden)]\n-trait HasBuffer {\n+pub trait HasBuffer {\n     // XXX This should not have a trailing underscore\n     fn set_buffer_(b: *libc::c_void);\n }\n@@ -213,7 +193,7 @@ impl<T: Send> Packet<T>: HasBuffer {\n }\n \n #[doc(hidden)]\n-fn mk_packet<T: Send>() -> Packet<T> {\n+pub fn mk_packet<T: Send>() -> Packet<T> {\n     {\n         header: PacketHeader(),\n         mut payload: None\n@@ -237,17 +217,17 @@ fn unibuffer<T: Send>() -> ~Buffer<Packet<T>> {\n }\n \n #[doc(hidden)]\n-fn packet<T: Send>() -> *Packet<T> {\n+pub fn packet<T: Send>() -> *Packet<T> {\n     let b = unibuffer();\n-    let p = ptr::addr_of(b.data);\n+    let p = ptr::addr_of(&(b.data));\n     // We'll take over memory management from here.\n     unsafe { forget(move b) }\n     p\n }\n \n #[doc(hidden)]\n-fn entangle_buffer<T: Send, Tstart: Send>(\n-    +buffer: ~Buffer<T>,\n+pub fn entangle_buffer<T: Send, Tstart: Send>(\n+    buffer: ~Buffer<T>,\n     init: fn(*libc::c_void, x: &T) -> *Packet<Tstart>)\n     -> (SendPacketBuffered<Tstart, T>, RecvPacketBuffered<Tstart, T>)\n {\n@@ -256,52 +236,36 @@ fn entangle_buffer<T: Send, Tstart: Send>(\n     (SendPacketBuffered(p), RecvPacketBuffered(p))\n }\n \n-#[cfg(stage0)]\n-#[abi = \"rust-intrinsic\"]\n-#[doc(hidden)]\n-extern mod rusti {\n-    #[legacy_exports];\n-    fn atomic_xchg(dst: &mut int, ++src: int) -> int;\n-    fn atomic_xchg_acq(dst: &mut int, ++src: int) -> int;\n-    fn atomic_xchg_rel(dst: &mut int, ++src: int) -> int;\n-\n-    fn atomic_xadd_acq(dst: &mut int, ++src: int) -> int;\n-    fn atomic_xsub_rel(dst: &mut int, ++src: int) -> int;\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n #[abi = \"rust-intrinsic\"]\n #[doc(hidden)]\n extern mod rusti {\n-    #[legacy_exports];\n-    fn atomic_xchg(dst: &mut int, +src: int) -> int;\n-    fn atomic_xchg_acq(dst: &mut int, +src: int) -> int;\n-    fn atomic_xchg_rel(dst: &mut int, +src: int) -> int;\n+    fn atomic_xchg(dst: &mut int, src: int) -> int;\n+    fn atomic_xchg_acq(dst: &mut int, src: int) -> int;\n+    fn atomic_xchg_rel(dst: &mut int, src: int) -> int;\n \n-    fn atomic_xadd_acq(dst: &mut int, +src: int) -> int;\n-    fn atomic_xsub_rel(dst: &mut int, +src: int) -> int;\n+    fn atomic_xadd_acq(dst: &mut int, src: int) -> int;\n+    fn atomic_xsub_rel(dst: &mut int, src: int) -> int;\n }\n \n // If I call the rusti versions directly from a polymorphic function,\n // I get link errors. This is a bug that needs investigated more.\n #[doc(hidden)]\n-fn atomic_xchng_rel(dst: &mut int, src: int) -> int {\n+pub fn atomic_xchng_rel(dst: &mut int, src: int) -> int {\n     rusti::atomic_xchg_rel(dst, src)\n }\n \n #[doc(hidden)]\n-fn atomic_add_acq(dst: &mut int, src: int) -> int {\n+pub fn atomic_add_acq(dst: &mut int, src: int) -> int {\n     rusti::atomic_xadd_acq(dst, src)\n }\n \n #[doc(hidden)]\n-fn atomic_sub_rel(dst: &mut int, src: int) -> int {\n+pub fn atomic_sub_rel(dst: &mut int, src: int) -> int {\n     rusti::atomic_xsub_rel(dst, src)\n }\n \n #[doc(hidden)]\n-fn swap_task(+dst: &mut *rust_task, src: *rust_task) -> *rust_task {\n+pub fn swap_task(dst: &mut *rust_task, src: *rust_task) -> *rust_task {\n     // It might be worth making both acquire and release versions of\n     // this.\n     unsafe {\n@@ -315,7 +279,6 @@ type rust_task = libc::c_void;\n \n #[doc(hidden)]\n extern mod rustrt {\n-    #[legacy_exports];\n     #[rust_stack]\n     fn rust_get_task() -> *rust_task;\n     #[rust_stack]\n@@ -341,21 +304,21 @@ fn wait_event(this: *rust_task) -> *libc::c_void {\n }\n \n #[doc(hidden)]\n-fn swap_state_acq(+dst: &mut State, src: State) -> State {\n+fn swap_state_acq(dst: &mut State, src: State) -> State {\n     unsafe {\n         transmute(rusti::atomic_xchg_acq(transmute(move dst), src as int))\n     }\n }\n \n #[doc(hidden)]\n-fn swap_state_rel(+dst: &mut State, src: State) -> State {\n+fn swap_state_rel(dst: &mut State, src: State) -> State {\n     unsafe {\n         transmute(rusti::atomic_xchg_rel(transmute(move dst), src as int))\n     }\n }\n \n #[doc(hidden)]\n-unsafe fn get_buffer<T: Send>(p: *PacketHeader) -> ~Buffer<T> {\n+pub unsafe fn get_buffer<T: Send>(p: *PacketHeader) -> ~Buffer<T> {\n     transmute((*p).buf_header())\n }\n \n@@ -380,7 +343,7 @@ struct BufferResource<T: Send> {\n     }\n }\n \n-fn BufferResource<T: Send>(+b: ~Buffer<T>) -> BufferResource<T> {\n+fn BufferResource<T: Send>(b: ~Buffer<T>) -> BufferResource<T> {\n     //let p = ptr::addr_of(*b);\n     //error!(\"take %?\", p);\n     atomic_add_acq(&mut b.header.ref_count, 1);\n@@ -391,12 +354,12 @@ fn BufferResource<T: Send>(+b: ~Buffer<T>) -> BufferResource<T> {\n }\n \n #[doc(hidden)]\n-fn send<T: Send, Tbuffer: Send>(+p: SendPacketBuffered<T, Tbuffer>,\n-                                +payload: T) -> bool {\n+pub fn send<T: Send, Tbuffer: Send>(p: SendPacketBuffered<T, Tbuffer>,\n+                                    payload: T) -> bool {\n     let header = p.header();\n     let p_ = p.unwrap();\n     let p = unsafe { &*p_ };\n-    assert ptr::addr_of(p.header) == header;\n+    assert ptr::addr_of(&(p.header)) == header;\n     assert p.payload.is_none();\n     p.payload <- Some(move payload);\n     let old_state = swap_state_rel(&mut p.header.state, Full);\n@@ -414,7 +377,7 @@ fn send<T: Send, Tbuffer: Send>(+p: SendPacketBuffered<T, Tbuffer>,\n             let old_task = swap_task(&mut p.header.blocked_task, ptr::null());\n             if !old_task.is_null() {\n                 rustrt::task_signal_event(\n-                    old_task, ptr::addr_of(p.header) as *libc::c_void);\n+                    old_task, ptr::addr_of(&(p.header)) as *libc::c_void);\n                 rustrt::rust_task_deref(old_task);\n             }\n \n@@ -435,7 +398,7 @@ fn send<T: Send, Tbuffer: Send>(+p: SendPacketBuffered<T, Tbuffer>,\n Fails if the sender closes the connection.\n \n */\n-fn recv<T: Send, Tbuffer: Send>(+p: RecvPacketBuffered<T, Tbuffer>) -> T {\n+pub fn recv<T: Send, Tbuffer: Send>(p: RecvPacketBuffered<T, Tbuffer>) -> T {\n     option::unwrap_expect(try_recv(move p), \"connection closed\")\n }\n \n@@ -445,7 +408,7 @@ Returns `none` if the sender has closed the connection without sending\n a message, or `Some(T)` if a message was received.\n \n */\n-fn try_recv<T: Send, Tbuffer: Send>(+p: RecvPacketBuffered<T, Tbuffer>)\n+pub fn try_recv<T: Send, Tbuffer: Send>(p: RecvPacketBuffered<T, Tbuffer>)\n     -> Option<T>\n {\n     let p_ = p.unwrap();\n@@ -539,7 +502,7 @@ fn try_recv<T: Send, Tbuffer: Send>(+p: RecvPacketBuffered<T, Tbuffer>)\n }\n \n /// Returns true if messages are available.\n-pure fn peek<T: Send, Tb: Send>(p: &RecvPacketBuffered<T, Tb>) -> bool {\n+pub pure fn peek<T: Send, Tb: Send>(p: &RecvPacketBuffered<T, Tb>) -> bool {\n     match unsafe {(*p.header()).state} {\n       Empty => false,\n       Blocked => fail ~\"peeking on blocked packet\",\n@@ -566,7 +529,7 @@ fn sender_terminate<T: Send>(p: *Packet<T>) {\n         if !old_task.is_null() {\n             rustrt::task_signal_event(\n                 old_task,\n-                ptr::addr_of(p.header) as *libc::c_void);\n+                ptr::addr_of(&(p.header)) as *libc::c_void);\n             rustrt::rust_task_deref(old_task);\n         }\n         // The receiver will eventually clean up.\n@@ -691,9 +654,9 @@ Sometimes messages will be available on both endpoints at once. In\n this case, `select2` may return either `left` or `right`.\n \n */\n-fn select2<A: Send, Ab: Send, B: Send, Bb: Send>(\n-    +a: RecvPacketBuffered<A, Ab>,\n-    +b: RecvPacketBuffered<B, Bb>)\n+pub fn select2<A: Send, Ab: Send, B: Send, Bb: Send>(\n+    a: RecvPacketBuffered<A, Ab>,\n+    b: RecvPacketBuffered<B, Bb>)\n     -> Either<(Option<A>, RecvPacketBuffered<B, Bb>),\n               (RecvPacketBuffered<A, Ab>, Option<B>)>\n {\n@@ -716,12 +679,13 @@ impl *PacketHeader: Selectable {\n }\n \n /// Returns the index of an endpoint that is ready to receive.\n-fn selecti<T: Selectable>(endpoints: &[T]) -> uint {\n+pub fn selecti<T: Selectable>(endpoints: &[T]) -> uint {\n     wait_many(endpoints)\n }\n \n /// Returns 0 or 1 depending on which endpoint is ready to receive\n-fn select2i<A: Selectable, B: Selectable>(a: &A, b: &B) -> Either<(), ()> {\n+pub fn select2i<A: Selectable, B: Selectable>(a: &A, b: &B) ->\n+        Either<(), ()> {\n     match wait_many([a.header(), b.header()]/_) {\n       0 => Left(()),\n       1 => Right(()),\n@@ -733,12 +697,12 @@ fn select2i<A: Selectable, B: Selectable>(a: &A, b: &B) -> Either<(), ()> {\n  list of the remaining endpoints.\n \n */\n-fn select<T: Send, Tb: Send>(+endpoints: ~[RecvPacketBuffered<T, Tb>])\n+pub fn select<T: Send, Tb: Send>(endpoints: ~[RecvPacketBuffered<T, Tb>])\n     -> (uint, Option<T>, ~[RecvPacketBuffered<T, Tb>])\n {\n     let ready = wait_many(endpoints.map(|p| p.header()));\n     let mut remaining <- endpoints;\n-    let port = vec::swap_remove(remaining, ready);\n+    let port = remaining.swap_remove(ready);\n     let result = try_recv(move port);\n     (ready, move result, move remaining)\n }\n@@ -747,14 +711,14 @@ fn select<T: Send, Tb: Send>(+endpoints: ~[RecvPacketBuffered<T, Tb>])\n message.\n \n */\n-type SendPacket<T: Send> = SendPacketBuffered<T, Packet<T>>;\n+pub type SendPacket<T: Send> = SendPacketBuffered<T, Packet<T>>;\n \n #[doc(hidden)]\n-fn SendPacket<T: Send>(p: *Packet<T>) -> SendPacket<T> {\n+pub fn SendPacket<T: Send>(p: *Packet<T>) -> SendPacket<T> {\n     SendPacketBuffered(p)\n }\n \n-struct SendPacketBuffered<T: Send, Tbuffer: Send> {\n+pub struct SendPacketBuffered<T: Send, Tbuffer: Send> {\n     mut p: Option<*Packet<T>>,\n     mut buffer: Option<BufferResource<Tbuffer>>,\n     drop {\n@@ -773,14 +737,14 @@ struct SendPacketBuffered<T: Send, Tbuffer: Send> {\n     }\n }\n \n-fn SendPacketBuffered<T: Send, Tbuffer: Send>(p: *Packet<T>)\n+pub fn SendPacketBuffered<T: Send, Tbuffer: Send>(p: *Packet<T>)\n     -> SendPacketBuffered<T, Tbuffer> {\n         //debug!(\"take send %?\", p);\n     SendPacketBuffered {\n         p: Some(p),\n         buffer: unsafe {\n             Some(BufferResource(\n-                get_buffer(ptr::addr_of((*p).header))))\n+                get_buffer(ptr::addr_of(&((*p).header)))))\n         }\n     }\n }\n@@ -796,7 +760,7 @@ impl<T: Send, Tbuffer: Send> SendPacketBuffered<T, Tbuffer> {\n         match self.p {\n           Some(packet) => unsafe {\n             let packet = &*packet;\n-            let header = ptr::addr_of(packet.header);\n+            let header = ptr::addr_of(&(packet.header));\n             //forget(packet);\n             header\n           },\n@@ -814,14 +778,14 @@ impl<T: Send, Tbuffer: Send> SendPacketBuffered<T, Tbuffer> {\n \n /// Represents the receive end of a pipe. It can receive exactly one\n /// message.\n-type RecvPacket<T: Send> = RecvPacketBuffered<T, Packet<T>>;\n+pub type RecvPacket<T: Send> = RecvPacketBuffered<T, Packet<T>>;\n \n #[doc(hidden)]\n-fn RecvPacket<T: Send>(p: *Packet<T>) -> RecvPacket<T> {\n+pub fn RecvPacket<T: Send>(p: *Packet<T>) -> RecvPacket<T> {\n     RecvPacketBuffered(p)\n }\n \n-struct RecvPacketBuffered<T: Send, Tbuffer: Send> {\n+pub struct RecvPacketBuffered<T: Send, Tbuffer: Send> {\n     mut p: Option<*Packet<T>>,\n     mut buffer: Option<BufferResource<Tbuffer>>,\n     drop {\n@@ -851,7 +815,7 @@ impl<T: Send, Tbuffer: Send> RecvPacketBuffered<T, Tbuffer> : Selectable {\n         match self.p {\n           Some(packet) => unsafe {\n             let packet = &*packet;\n-            let header = ptr::addr_of(packet.header);\n+            let header = ptr::addr_of(&(packet.header));\n             //forget(packet);\n             header\n           },\n@@ -867,20 +831,20 @@ impl<T: Send, Tbuffer: Send> RecvPacketBuffered<T, Tbuffer> : Selectable {\n     }\n }\n \n-fn RecvPacketBuffered<T: Send, Tbuffer: Send>(p: *Packet<T>)\n+pub fn RecvPacketBuffered<T: Send, Tbuffer: Send>(p: *Packet<T>)\n     -> RecvPacketBuffered<T, Tbuffer> {\n     //debug!(\"take recv %?\", p);\n     RecvPacketBuffered {\n         p: Some(p),\n         buffer: unsafe {\n             Some(BufferResource(\n-                get_buffer(ptr::addr_of((*p).header))))\n+                get_buffer(ptr::addr_of(&((*p).header)))))\n         }\n     }\n }\n \n #[doc(hidden)]\n-fn entangle<T: Send>() -> (SendPacket<T>, RecvPacket<T>) {\n+pub fn entangle<T: Send>() -> (SendPacket<T>, RecvPacket<T>) {\n     let p = packet();\n     (SendPacket(p), RecvPacket(p))\n }\n@@ -892,10 +856,10 @@ endpoint. The send endpoint is returned to the caller and the receive\n endpoint is passed to the new task.\n \n */\n-fn spawn_service<T: Send, Tb: Send>(\n+pub fn spawn_service<T: Send, Tb: Send>(\n     init: extern fn() -> (SendPacketBuffered<T, Tb>,\n                           RecvPacketBuffered<T, Tb>),\n-    +service: fn~(+v: RecvPacketBuffered<T, Tb>))\n+    +service: fn~(v: RecvPacketBuffered<T, Tb>))\n     -> SendPacketBuffered<T, Tb>\n {\n     let (client, server) = init();\n@@ -916,10 +880,10 @@ fn spawn_service<T: Send, Tb: Send>(\n receive state.\n \n */\n-fn spawn_service_recv<T: Send, Tb: Send>(\n+pub fn spawn_service_recv<T: Send, Tb: Send>(\n     init: extern fn() -> (RecvPacketBuffered<T, Tb>,\n                           SendPacketBuffered<T, Tb>),\n-    +service: fn~(+v: SendPacketBuffered<T, Tb>))\n+    +service: fn~(v: SendPacketBuffered<T, Tb>))\n     -> RecvPacketBuffered<T, Tb>\n {\n     let (client, server) = init();\n@@ -945,19 +909,19 @@ proto! streamp (\n )\n \n /// A trait for things that can send multiple messages.\n-trait Channel<T: Send> {\n+pub trait Channel<T: Send> {\n     // It'd be nice to call this send, but it'd conflict with the\n     // built in send kind.\n \n     /// Sends a message.\n-    fn send(+x: T);\n+    fn send(x: T);\n \n     /// Sends a message, or report if the receiver has closed the connection.\n-    fn try_send(+x: T) -> bool;\n+    fn try_send(x: T) -> bool;\n }\n \n /// A trait for things that can receive multiple messages.\n-trait Recv<T: Send> {\n+pub trait Recv<T: Send> {\n     /// Receives a message, or fails if the connection closes.\n     fn recv() -> T;\n \n@@ -978,15 +942,15 @@ trait Recv<T: Send> {\n type Chan_<T:Send> = { mut endp: Option<streamp::client::Open<T>> };\n \n /// An endpoint that can send many messages.\n-enum Chan<T:Send> {\n+pub enum Chan<T:Send> {\n     Chan_(Chan_<T>)\n }\n \n #[doc(hidden)]\n type Port_<T:Send> = { mut endp: Option<streamp::server::Open<T>> };\n \n /// An endpoint that can receive many messages.\n-enum Port<T:Send> {\n+pub enum Port<T:Send> {\n     Port_(Port_<T>)\n }\n \n@@ -995,21 +959,21 @@ enum Port<T:Send> {\n These allow sending or receiving an unlimited number of messages.\n \n */\n-fn stream<T:Send>() -> (Chan<T>, Port<T>) {\n+pub fn stream<T:Send>() -> (Chan<T>, Port<T>) {\n     let (c, s) = streamp::init();\n \n     (Chan_({ mut endp: Some(move c) }), Port_({ mut endp: Some(move s) }))\n }\n \n impl<T: Send> Chan<T>: Channel<T> {\n-    fn send(+x: T) {\n+    fn send(x: T) {\n         let mut endp = None;\n         endp <-> self.endp;\n         self.endp = Some(\n             streamp::client::data(unwrap(move endp), move x))\n     }\n \n-    fn try_send(+x: T) -> bool {\n+    fn try_send(x: T) -> bool {\n         let mut endp = None;\n         endp <-> self.endp;\n         match move streamp::client::try_data(unwrap(move endp), move x) {\n@@ -1047,7 +1011,7 @@ impl<T: Send> Port<T>: Recv<T> {\n         let mut endp = None;\n         endp <-> self.endp;\n         let peek = match endp {\n-          Some(endp) => pipes::peek(&endp),\n+          Some(ref endp) => pipes::peek(endp),\n           None => fail ~\"peeking empty stream\"\n         };\n         self.endp <-> endp;\n@@ -1058,27 +1022,27 @@ impl<T: Send> Port<T>: Recv<T> {\n impl<T: Send> Port<T>: Selectable {\n     pure fn header() -> *PacketHeader unsafe {\n         match self.endp {\n-          Some(endp) => endp.header(),\n+          Some(ref endp) => endp.header(),\n           None => fail ~\"peeking empty stream\"\n         }\n     }\n }\n \n /// Treat many ports as one.\n-struct PortSet<T: Send> {\n+pub struct PortSet<T: Send> {\n     mut ports: ~[pipes::Port<T>],\n }\n \n-fn PortSet<T: Send>() -> PortSet<T>{\n+pub fn PortSet<T: Send>() -> PortSet<T>{\n     PortSet {\n         ports: ~[]\n     }\n }\n \n impl<T: Send> PortSet<T> : Recv<T> {\n \n-    fn add(+port: pipes::Port<T>) {\n-        vec::push(self.ports, move port)\n+    fn add(port: pipes::Port<T>) {\n+        self.ports.push(move port)\n     }\n \n     fn chan() -> Chan<T> {\n@@ -1101,7 +1065,7 @@ impl<T: Send> PortSet<T> : Recv<T> {\n                 }\n                 None => {\n                     // Remove this port.\n-                    let _ = vec::swap_remove(ports, i);\n+                    let _ = ports.swap_remove(i);\n                 }\n             }\n         }\n@@ -1124,10 +1088,10 @@ impl<T: Send> PortSet<T> : Recv<T> {\n }\n \n /// A channel that can be shared between many senders.\n-type SharedChan<T: Send> = private::Exclusive<Chan<T>>;\n+pub type SharedChan<T: Send> = private::Exclusive<Chan<T>>;\n \n impl<T: Send> SharedChan<T>: Channel<T> {\n-    fn send(+x: T) {\n+    fn send(x: T) {\n         let mut xx = Some(move x);\n         do self.with_imm |chan| {\n             let mut x = None;\n@@ -1136,7 +1100,7 @@ impl<T: Send> SharedChan<T>: Channel<T> {\n         }\n     }\n \n-    fn try_send(+x: T) -> bool {\n+    fn try_send(x: T) -> bool {\n         let mut xx = Some(move x);\n         do self.with_imm |chan| {\n             let mut x = None;\n@@ -1147,12 +1111,12 @@ impl<T: Send> SharedChan<T>: Channel<T> {\n }\n \n /// Converts a `chan` into a `shared_chan`.\n-fn SharedChan<T:Send>(+c: Chan<T>) -> SharedChan<T> {\n+pub fn SharedChan<T:Send>(c: Chan<T>) -> SharedChan<T> {\n     private::exclusive(move c)\n }\n \n /// Receive a message from one of two endpoints.\n-trait Select2<T: Send, U: Send> {\n+pub trait Select2<T: Send, U: Send> {\n     /// Receive a message or return `none` if a connection closes.\n     fn try_select() -> Either<Option<T>, Option<U>>;\n     /// Receive a message or fail if a connection closes.\n@@ -1164,7 +1128,7 @@ impl<T: Send, U: Send, Left: Selectable Recv<T>, Right: Selectable Recv<U>>\n \n     fn select() -> Either<T, U> {\n         match self {\n-          (lp, rp) => match select2i(&lp, &rp) {\n+          (ref lp, ref rp) => match select2i(lp, rp) {\n             Left(()) => Left (lp.recv()),\n             Right(()) => Right(rp.recv())\n           }\n@@ -1173,7 +1137,7 @@ impl<T: Send, U: Send, Left: Selectable Recv<T>, Right: Selectable Recv<U>>\n \n     fn try_select() -> Either<Option<T>, Option<U>> {\n         match self {\n-          (lp, rp) => match select2i(&lp, &rp) {\n+          (ref lp, ref rp) => match select2i(lp, rp) {\n             Left(()) => Left (lp.try_recv()),\n             Right(()) => Right(rp.try_recv())\n           }\n@@ -1188,26 +1152,26 @@ proto! oneshot (\n )\n \n /// The send end of a oneshot pipe.\n-type ChanOne<T: Send> = oneshot::client::Oneshot<T>;\n+pub type ChanOne<T: Send> = oneshot::client::Oneshot<T>;\n /// The receive end of a oneshot pipe.\n-type PortOne<T: Send> = oneshot::server::Oneshot<T>;\n+pub type PortOne<T: Send> = oneshot::server::Oneshot<T>;\n \n /// Initialiase a (send-endpoint, recv-endpoint) oneshot pipe pair.\n-fn oneshot<T: Send>() -> (ChanOne<T>, PortOne<T>) {\n+pub fn oneshot<T: Send>() -> (ChanOne<T>, PortOne<T>) {\n     oneshot::init()\n }\n \n /**\n  * Receive a message from a oneshot pipe, failing if the connection was\n  * closed.\n  */\n-fn recv_one<T: Send>(+port: PortOne<T>) -> T {\n+pub fn recv_one<T: Send>(port: PortOne<T>) -> T {\n     let oneshot::send(message) = recv(move port);\n     move message\n }\n \n /// Receive a message from a oneshot pipe unless the connection was closed.\n-fn try_recv_one<T: Send> (+port: PortOne<T>) -> Option<T> {\n+pub fn try_recv_one<T: Send> (port: PortOne<T>) -> Option<T> {\n     let message = try_recv(move port);\n \n     if message.is_none() { None }\n@@ -1218,32 +1182,30 @@ fn try_recv_one<T: Send> (+port: PortOne<T>) -> Option<T> {\n }\n \n /// Send a message on a oneshot pipe, failing if the connection was closed.\n-fn send_one<T: Send>(+chan: ChanOne<T>, +data: T) {\n+pub fn send_one<T: Send>(chan: ChanOne<T>, data: T) {\n     oneshot::client::send(move chan, move data);\n }\n \n /**\n  * Send a message on a oneshot pipe, or return false if the connection was\n  * closed.\n  */\n-fn try_send_one<T: Send>(+chan: ChanOne<T>, +data: T)\n+pub fn try_send_one<T: Send>(chan: ChanOne<T>, data: T)\n         -> bool {\n     oneshot::client::try_send(move chan, move data).is_some()\n }\n \n-mod rt {\n-    #[legacy_exports];\n+pub mod rt {\n     // These are used to hide the option constructors from the\n     // compiler because their names are changing\n-    fn make_some<T>(+val: T) -> Option<T> { Some(move val) }\n-    fn make_none<T>() -> Option<T> { None }\n+    pub fn make_some<T>(val: T) -> Option<T> { Some(move val) }\n+    pub fn make_none<T>() -> Option<T> { None }\n }\n \n #[cfg(test)]\n-mod test {\n-    #[legacy_exports];\n+pub mod test {\n     #[test]\n-    fn test_select2() {\n+    pub fn test_select2() {\n         let (c1, p1) = pipes::stream();\n         let (c2, p2) = pipes::stream();\n \n@@ -1258,7 +1220,7 @@ mod test {\n     }\n \n     #[test]\n-    fn test_oneshot() {\n+    pub fn test_oneshot() {\n         let (c, p) = oneshot::init();\n \n         oneshot::client::send(c, ());"}, {"sha": "c1b2b32edafc6530db483e929ededcd749d65f66", "filename": "src/libcore/private.rs", "status": "modified", "additions": 36, "deletions": 44, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -1,16 +1,9 @@\n // NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n+// tjc: re-forbid deprecated modes after snapshot\n #[forbid(deprecated_pattern)];\n \n #[doc(hidden)];\n \n-export chan_from_global_ptr, weaken_task;\n-\n-export SharedMutableState, shared_mutable_state, clone_shared_mutable_state;\n-export get_shared_mutable_state, get_shared_immutable_state;\n-export unwrap_shared_mutable_state;\n-export Exclusive, exclusive, unwrap_exclusive;\n-\n use compare_and_swap = rustrt::rust_compare_and_swap_ptr;\n use task::TaskBuilder;\n use task::atomically;\n@@ -49,7 +42,7 @@ type GlobalPtr = *libc::uintptr_t;\n  * or, if no channel exists creates and installs a new channel and sets up a\n  * new task to receive from it.\n  */\n-unsafe fn chan_from_global_ptr<T: Send>(\n+pub unsafe fn chan_from_global_ptr<T: Send>(\n     global: GlobalPtr,\n     task_fn: fn() -> task::TaskBuilder,\n     +f: fn~(comm::Port<T>)\n@@ -110,13 +103,13 @@ unsafe fn chan_from_global_ptr<T: Send>(\n }\n \n #[test]\n-fn test_from_global_chan1() {\n+pub fn test_from_global_chan1() {\n \n     // This is unreadable, right?\n \n     // The global channel\n-    let globchan = 0u;\n-    let globchanp = ptr::addr_of(globchan);\n+    let globchan = 0;\n+    let globchanp = ptr::p2::addr_of(&globchan);\n \n     // Create the global channel, attached to a new task\n     let ch = unsafe {\n@@ -147,25 +140,25 @@ fn test_from_global_chan1() {\n }\n \n #[test]\n-fn test_from_global_chan2() {\n+pub fn test_from_global_chan2() {\n \n-    for iter::repeat(100u) {\n+    for iter::repeat(100) {\n         // The global channel\n-        let globchan = 0u;\n-        let globchanp = ptr::addr_of(globchan);\n+        let globchan = 0;\n+        let globchanp = ptr::p2::addr_of(&globchan);\n \n         let resultpo = comm::Port();\n         let resultch = comm::Chan(resultpo);\n \n         // Spawn a bunch of tasks that all want to compete to\n         // create the global channel\n-        for uint::range(0u, 10u) |i| {\n+        for uint::range(0, 10) |i| {\n             do task::spawn {\n                 let ch = unsafe {\n                     do chan_from_global_ptr(\n                         globchanp, task::task) |po| {\n \n-                        for uint::range(0u, 10u) |_j| {\n+                        for uint::range(0, 10) |_j| {\n                             let ch = comm::recv(po);\n                             comm::send(ch, {i});\n                         }\n@@ -208,7 +201,7 @@ fn test_from_global_chan2() {\n  * * Weak tasks must not be supervised. A supervised task keeps\n  *   a reference to its parent, so the parent will not die.\n  */\n-unsafe fn weaken_task(f: fn(comm::Port<()>)) {\n+pub unsafe fn weaken_task(f: fn(comm::Port<()>)) {\n     let po = comm::Port();\n     let ch = comm::Chan(po);\n     unsafe {\n@@ -232,7 +225,7 @@ unsafe fn weaken_task(f: fn(comm::Port<()>)) {\n }\n \n #[test]\n-fn test_weaken_task_then_unweaken() {\n+pub fn test_weaken_task_then_unweaken() {\n     do task::try {\n         unsafe {\n             do weaken_task |_po| {\n@@ -242,7 +235,7 @@ fn test_weaken_task_then_unweaken() {\n }\n \n #[test]\n-fn test_weaken_task_wait() {\n+pub fn test_weaken_task_wait() {\n     do task::spawn_unlinked {\n         unsafe {\n             do weaken_task |po| {\n@@ -253,7 +246,7 @@ fn test_weaken_task_wait() {\n }\n \n #[test]\n-fn test_weaken_task_stress() {\n+pub fn test_weaken_task_stress() {\n     // Create a bunch of weak tasks\n     for iter::repeat(100u) {\n         do task::spawn {\n@@ -275,15 +268,15 @@ fn test_weaken_task_stress() {\n \n #[test]\n #[ignore(cfg(windows))]\n-fn test_weaken_task_fail() {\n+pub fn test_weaken_task_fail() {\n     let res = do task::try {\n         unsafe {\n             do weaken_task |_po| {\n                 fail;\n             }\n         }\n     };\n-    assert result::is_err(res);\n+    assert result::is_err(&res);\n }\n \n /****************************************************************************\n@@ -347,7 +340,7 @@ fn ArcDestruct<T>(data: *libc::c_void) -> ArcDestruct<T> {\n     }\n }\n \n-unsafe fn unwrap_shared_mutable_state<T: Send>(+rc: SharedMutableState<T>)\n+pub unsafe fn unwrap_shared_mutable_state<T: Send>(rc: SharedMutableState<T>)\n         -> T {\n     struct DeathThroes<T> {\n         mut ptr:      Option<~ArcData<T>>,\n@@ -418,9 +411,10 @@ unsafe fn unwrap_shared_mutable_state<T: Send>(+rc: SharedMutableState<T>)\n  * Data races between tasks can result in crashes and, with sufficient\n  * cleverness, arbitrary type coercion.\n  */\n-type SharedMutableState<T: Send> = ArcDestruct<T>;\n+pub type SharedMutableState<T: Send> = ArcDestruct<T>;\n \n-unsafe fn shared_mutable_state<T: Send>(+data: T) -> SharedMutableState<T> {\n+pub unsafe fn shared_mutable_state<T: Send>(data: T) ->\n+        SharedMutableState<T> {\n     let data = ~ArcData { count: 1, unwrapper: 0, data: Some(move data) };\n     unsafe {\n         let ptr = cast::transmute(move data);\n@@ -429,7 +423,7 @@ unsafe fn shared_mutable_state<T: Send>(+data: T) -> SharedMutableState<T> {\n }\n \n #[inline(always)]\n-unsafe fn get_shared_mutable_state<T: Send>(rc: &a/SharedMutableState<T>)\n+pub unsafe fn get_shared_mutable_state<T: Send>(rc: &a/SharedMutableState<T>)\n         -> &a/mut T {\n     unsafe {\n         let ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n@@ -441,8 +435,8 @@ unsafe fn get_shared_mutable_state<T: Send>(rc: &a/SharedMutableState<T>)\n     }\n }\n #[inline(always)]\n-unsafe fn get_shared_immutable_state<T: Send>(rc: &a/SharedMutableState<T>)\n-        -> &a/T {\n+pub unsafe fn get_shared_immutable_state<T: Send>(\n+        rc: &a/SharedMutableState<T>) -> &a/T {\n     unsafe {\n         let ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n         assert ptr.count > 0;\n@@ -453,7 +447,7 @@ unsafe fn get_shared_immutable_state<T: Send>(rc: &a/SharedMutableState<T>)\n     }\n }\n \n-unsafe fn clone_shared_mutable_state<T: Send>(rc: &SharedMutableState<T>)\n+pub unsafe fn clone_shared_mutable_state<T: Send>(rc: &SharedMutableState<T>)\n         -> SharedMutableState<T> {\n     unsafe {\n         let ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n@@ -506,9 +500,9 @@ struct ExData<T: Send> { lock: LittleLock, mut failed: bool, mut data: T, }\n /**\n  * An arc over mutable data that is protected by a lock. For library use only.\n  */\n-struct Exclusive<T: Send> { x: SharedMutableState<ExData<T>> }\n+pub struct Exclusive<T: Send> { x: SharedMutableState<ExData<T>> }\n \n-fn exclusive<T:Send >(+user_data: T) -> Exclusive<T> {\n+pub fn exclusive<T:Send >(user_data: T) -> Exclusive<T> {\n     let data = ExData {\n         lock: LittleLock(), mut failed: false, mut data: user_data\n     };\n@@ -550,19 +544,17 @@ impl<T: Send> Exclusive<T> {\n }\n \n // FIXME(#2585) make this a by-move method on the exclusive\n-fn unwrap_exclusive<T: Send>(+arc: Exclusive<T>) -> T {\n+pub fn unwrap_exclusive<T: Send>(arc: Exclusive<T>) -> T {\n     let Exclusive { x: x } <- arc;\n     let inner = unsafe { unwrap_shared_mutable_state(move x) };\n     let ExData { data: data, _ } <- inner;\n     move data\n }\n \n #[cfg(test)]\n-mod tests {\n-    #[legacy_exports];\n-\n+pub mod tests {\n     #[test]\n-    fn exclusive_arc() {\n+    pub fn exclusive_arc() {\n         let mut futures = ~[];\n \n         let num_tasks = 10u;\n@@ -572,7 +564,7 @@ mod tests {\n \n         for uint::range(0u, num_tasks) |_i| {\n             let total = total.clone();\n-            vec::push(futures, future::spawn(|| {\n+            futures.push(future::spawn(|| {\n                 for uint::range(0u, count) |_i| {\n                     do total.with |count| {\n                         **count += 1u;\n@@ -589,7 +581,7 @@ mod tests {\n     }\n \n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn exclusive_poison() {\n+    pub fn exclusive_poison() {\n         // Tests that if one task fails inside of an exclusive, subsequent\n         // accesses will also fail.\n         let x = exclusive(1);\n@@ -605,13 +597,13 @@ mod tests {\n     }\n \n     #[test]\n-    fn exclusive_unwrap_basic() {\n+    pub fn exclusive_unwrap_basic() {\n         let x = exclusive(~~\"hello\");\n         assert unwrap_exclusive(x) == ~~\"hello\";\n     }\n \n     #[test]\n-    fn exclusive_unwrap_contended() {\n+    pub fn exclusive_unwrap_contended() {\n         let x = exclusive(~~\"hello\");\n         let x2 = ~mut Some(x.clone());\n         do task::spawn {\n@@ -636,7 +628,7 @@ mod tests {\n     }\n \n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn exclusive_unwrap_conflict() {\n+    pub fn exclusive_unwrap_conflict() {\n         let x = exclusive(~~\"hello\");\n         let x2 = ~mut Some(x.clone());\n         let mut res = None;\n@@ -650,7 +642,7 @@ mod tests {\n     }\n \n     #[test] #[ignore(cfg(windows))]\n-    fn exclusive_unwrap_deadlock() {\n+    pub fn exclusive_unwrap_deadlock() {\n         // This is not guaranteed to get to the deadlock before being killed,\n         // but it will show up sometimes, and if the deadlock were not there,\n         // the test would nondeterministically fail."}, {"sha": "fad7eddd2d8dcf43450998e7a89365e655acaec3", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 48, "deletions": 58, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -1,33 +1,11 @@\n //! Unsafe pointer utility functions\n \n-export addr_of;\n-export to_unsafe_ptr;\n-export to_const_unsafe_ptr;\n-export to_mut_unsafe_ptr;\n-export mut_addr_of;\n-export offset;\n-export const_offset;\n-export mut_offset;\n-export null;\n-export mut_null;\n-export is_null;\n-export is_not_null;\n-export memcpy;\n-export memmove;\n-export memset;\n-export to_uint;\n-export ref_eq;\n-export buf_len;\n-export position;\n-export Ptr;\n-\n use cmp::{Eq, Ord};\n use libc::{c_void, size_t};\n \n #[nolink]\n #[abi = \"cdecl\"]\n extern mod libc_ {\n-    #[legacy_exports];\n     #[rust_stack]\n     fn memcpy(dest: *mut c_void, src: *const c_void,\n               n: libc::size_t) -> *c_void;\n@@ -43,73 +21,78 @@ extern mod libc_ {\n \n #[abi = \"rust-intrinsic\"]\n extern mod rusti {\n-    #[legacy_exports];\n-    fn addr_of<T>(val: T) -> *T;\n+    fn addr_of<T>(&&val: T) -> *T;\n }\n \n /// Get an unsafe pointer to a value\n #[inline(always)]\n-pure fn addr_of<T>(val: T) -> *T { unsafe { rusti::addr_of(val) } }\n+pub pure fn addr_of<T>(val: &T) -> *T { unsafe { rusti::addr_of(*val) } }\n+\n+pub mod p2 {\n+    /// Get an unsafe pointer to a value\n+    #[inline(always)]\n+    pub pure fn addr_of<T>(val: &T) -> *T { unsafe { rusti::addr_of(*val) } }\n+}\n \n /// Get an unsafe mut pointer to a value\n #[inline(always)]\n-pure fn mut_addr_of<T>(val: T) -> *mut T {\n+pub pure fn mut_addr_of<T>(val: &T) -> *mut T {\n     unsafe {\n-        cast::reinterpret_cast(&rusti::addr_of(val))\n+        cast::reinterpret_cast(&rusti::addr_of(*val))\n     }\n }\n \n /// Calculate the offset from a pointer\n #[inline(always)]\n-fn offset<T>(ptr: *T, count: uint) -> *T {\n+pub pure fn offset<T>(ptr: *T, count: uint) -> *T {\n     unsafe {\n         (ptr as uint + count * sys::size_of::<T>()) as *T\n     }\n }\n \n /// Calculate the offset from a const pointer\n #[inline(always)]\n-fn const_offset<T>(ptr: *const T, count: uint) -> *const T {\n+pub pure fn const_offset<T>(ptr: *const T, count: uint) -> *const T {\n     unsafe {\n         (ptr as uint + count * sys::size_of::<T>()) as *T\n     }\n }\n \n /// Calculate the offset from a mut pointer\n #[inline(always)]\n-fn mut_offset<T>(ptr: *mut T, count: uint) -> *mut T {\n+pub pure fn mut_offset<T>(ptr: *mut T, count: uint) -> *mut T {\n     (ptr as uint + count * sys::size_of::<T>()) as *mut T\n }\n \n /// Return the offset of the first null pointer in `buf`.\n #[inline(always)]\n-unsafe fn buf_len<T>(buf: **T) -> uint {\n-    position(buf, |i| i == null())\n+pub unsafe fn buf_len<T>(buf: **T) -> uint {\n+    position(buf, |i| *i == null())\n }\n \n /// Return the first offset `i` such that `f(buf[i]) == true`.\n #[inline(always)]\n-unsafe fn position<T>(buf: *T, f: fn(T) -> bool) -> uint {\n-    let mut i = 0u;\n+pub unsafe fn position<T>(buf: *T, f: fn(&T) -> bool) -> uint {\n+    let mut i = 0;\n     loop {\n-        if f(*offset(buf, i)) { return i; }\n-        else { i += 1u; }\n+        if f(&(*offset(buf, i))) { return i; }\n+        else { i += 1; }\n     }\n }\n \n /// Create an unsafe null pointer\n #[inline(always)]\n-pure fn null<T>() -> *T { unsafe { cast::reinterpret_cast(&0u) } }\n+pub pure fn null<T>() -> *T { unsafe { cast::reinterpret_cast(&0u) } }\n \n /// Create an unsafe mutable null pointer\n #[inline(always)]\n-pure fn mut_null<T>() -> *mut T { unsafe { cast::reinterpret_cast(&0u) } }\n+pub pure fn mut_null<T>() -> *mut T { unsafe { cast::reinterpret_cast(&0u) } }\n \n /// Returns true if the pointer is equal to the null pointer.\n-pure fn is_null<T>(ptr: *const T) -> bool { ptr == null() }\n+pub pure fn is_null<T>(ptr: *const T) -> bool { ptr == null() }\n \n /// Returns true if the pointer is not equal to the null pointer.\n-pure fn is_not_null<T>(ptr: *const T) -> bool { !is_null(ptr) }\n+pub pure fn is_not_null<T>(ptr: *const T) -> bool { !is_null(ptr) }\n \n /**\n  * Copies data from one location to another\n@@ -118,7 +101,7 @@ pure fn is_not_null<T>(ptr: *const T) -> bool { !is_null(ptr) }\n  * and destination may not overlap.\n  */\n #[inline(always)]\n-unsafe fn memcpy<T>(dst: *mut T, src: *const T, count: uint) {\n+pub unsafe fn memcpy<T>(dst: *mut T, src: *const T, count: uint) {\n     let n = count * sys::size_of::<T>();\n     libc_::memcpy(dst as *mut c_void, src as *c_void, n as size_t);\n }\n@@ -130,13 +113,13 @@ unsafe fn memcpy<T>(dst: *mut T, src: *const T, count: uint) {\n  * and destination may overlap.\n  */\n #[inline(always)]\n-unsafe fn memmove<T>(dst: *mut T, src: *const T, count: uint)  {\n+pub unsafe fn memmove<T>(dst: *mut T, src: *const T, count: uint) {\n     let n = count * sys::size_of::<T>();\n     libc_::memmove(dst as *mut c_void, src as *c_void, n as size_t);\n }\n \n #[inline(always)]\n-unsafe fn memset<T>(dst: *mut T, c: int, count: uint)  {\n+pub unsafe fn memset<T>(dst: *mut T, c: int, count: uint) {\n     let n = count * sys::size_of::<T>();\n     libc_::memset(dst as *mut c_void, c as libc::c_int, n as size_t);\n }\n@@ -148,7 +131,7 @@ unsafe fn memset<T>(dst: *mut T, c: int, count: uint)  {\n   reinterpret_cast.\n */\n #[inline(always)]\n-fn to_unsafe_ptr<T>(thing: &T) -> *T {\n+pub pure fn to_unsafe_ptr<T>(thing: &T) -> *T {\n     unsafe { cast::reinterpret_cast(&thing) }\n }\n \n@@ -158,7 +141,7 @@ fn to_unsafe_ptr<T>(thing: &T) -> *T {\n   reinterpret_cast.\n */\n #[inline(always)]\n-fn to_const_unsafe_ptr<T>(thing: &const T) -> *const T {\n+pub pure fn to_const_unsafe_ptr<T>(thing: &const T) -> *const T {\n     unsafe { cast::reinterpret_cast(&thing) }\n }\n \n@@ -168,7 +151,7 @@ fn to_const_unsafe_ptr<T>(thing: &const T) -> *const T {\n   reinterpret_cast.\n */\n #[inline(always)]\n-fn to_mut_unsafe_ptr<T>(thing: &mut T) -> *mut T {\n+pub pure fn to_mut_unsafe_ptr<T>(thing: &mut T) -> *mut T {\n     unsafe { cast::reinterpret_cast(&thing) }\n }\n \n@@ -180,28 +163,35 @@ fn to_mut_unsafe_ptr<T>(thing: &mut T) -> *mut T {\n   (I couldn't think of a cutesy name for this one.)\n */\n #[inline(always)]\n-fn to_uint<T>(thing: &T) -> uint unsafe {\n+pub fn to_uint<T>(thing: &T) -> uint unsafe {\n     cast::reinterpret_cast(&thing)\n }\n \n /// Determine if two borrowed pointers point to the same thing.\n #[inline(always)]\n-fn ref_eq<T>(thing: &a/T, other: &b/T) -> bool {\n+pub fn ref_eq<T>(thing: &a/T, other: &b/T) -> bool {\n     to_uint(thing) == to_uint(other)\n }\n \n-trait Ptr {\n+pub trait Ptr<T> {\n     pure fn is_null() -> bool;\n     pure fn is_not_null() -> bool;\n+    pure fn offset(count: uint) -> self;\n }\n \n /// Extension methods for pointers\n-impl<T> *T: Ptr {\n+impl<T> *T: Ptr<T> {\n     /// Returns true if the pointer is equal to the null pointer.\n+    #[inline(always)]\n     pure fn is_null() -> bool { is_null(self) }\n \n     /// Returns true if the pointer is not equal to the null pointer.\n+    #[inline(always)]\n     pure fn is_not_null() -> bool { is_not_null(self) }\n+\n+    /// Calculates the offset from a pointer.\n+    #[inline(always)]\n+    pure fn offset(count: uint) -> *T { offset(self, count) }\n }\n \n // Equality for pointers\n@@ -253,11 +243,11 @@ impl<T:Ord> &const T : Ord {\n }\n \n #[test]\n-fn test() {\n+pub fn test() {\n     unsafe {\n         type Pair = {mut fst: int, mut snd: int};\n         let p = {mut fst: 10, mut snd: 20};\n-        let pptr: *mut Pair = mut_addr_of(p);\n+        let pptr: *mut Pair = mut_addr_of(&p);\n         let iptr: *mut int = cast::reinterpret_cast(&pptr);\n         assert (*iptr == 10);;\n         *iptr = 30;\n@@ -285,20 +275,20 @@ fn test() {\n }\n \n #[test]\n-fn test_position() {\n+pub fn test_position() {\n     use str::as_c_str;\n     use libc::c_char;\n \n     let s = ~\"hello\";\n     unsafe {\n-        assert 2u == as_c_str(s, |p| position(p, |c| c == 'l' as c_char));\n-        assert 4u == as_c_str(s, |p| position(p, |c| c == 'o' as c_char));\n-        assert 5u == as_c_str(s, |p| position(p, |c| c == 0 as c_char));\n+        assert 2u == as_c_str(s, |p| position(p, |c| *c == 'l' as c_char));\n+        assert 4u == as_c_str(s, |p| position(p, |c| *c == 'o' as c_char));\n+        assert 5u == as_c_str(s, |p| position(p, |c| *c == 0 as c_char));\n     }\n }\n \n #[test]\n-fn test_buf_len() {\n+pub fn test_buf_len() {\n     let s0 = ~\"hello\";\n     let s1 = ~\"there\";\n     let s2 = ~\"thing\";\n@@ -316,7 +306,7 @@ fn test_buf_len() {\n }\n \n #[test]\n-fn test_is_null() {\n+pub fn test_is_null() {\n    let p: *int = ptr::null();\n    assert p.is_null();\n    assert !p.is_not_null();"}, {"sha": "32f77a533a67e0876c23f4ce687adc52fd94a0c5", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 85, "deletions": 39, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -1,29 +1,29 @@\n //! Random number generation\n \n-export Rng, seed, seeded_rng, Weighted, extensions;\n-export xorshift, seeded_xorshift;\n+// NB: transitional, de-mode-ing.\n+#[warn(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n \n #[allow(non_camel_case_types)] // runtime type\n enum rctx {}\n \n #[abi = \"cdecl\"]\n extern mod rustrt {\n-    #[legacy_exports];\n     fn rand_seed() -> ~[u8];\n     fn rand_new() -> *rctx;\n-    fn rand_new_seeded(seed: ~[u8]) -> *rctx;\n+    fn rand_new_seeded2(&&seed: ~[u8]) -> *rctx;\n     fn rand_next(c: *rctx) -> u32;\n     fn rand_free(c: *rctx);\n }\n \n /// A random number generator\n-trait Rng {\n+pub trait Rng {\n     /// Return the next random integer\n     fn next() -> u32;\n }\n \n /// A value with a particular weight compared to other values\n-type Weighted<T> = { weight: uint, item: T };\n+pub type Weighted<T> = { weight: uint, item: T };\n \n /// Extension methods for random number generators\n impl Rng {\n@@ -123,7 +123,7 @@ impl Rng {\n     /**\n      * Return a char randomly chosen from chars, failing if chars is empty\n      */\n-    fn gen_char_from(chars: ~str) -> char {\n+    fn gen_char_from(chars: &str) -> char {\n         assert !chars.is_empty();\n         self.choose(str::chars(chars))\n     }\n@@ -218,7 +218,7 @@ impl Rng {\n         let mut r = ~[];\n         for v.each |item| {\n             for uint::range(0u, item.weight) |_i| {\n-                vec::push(r, item.item);\n+                r.push(item.item);\n             }\n         }\n         move r\n@@ -260,12 +260,12 @@ impl @RandRes: Rng {\n }\n \n /// Create a new random seed for seeded_rng\n-fn seed() -> ~[u8] {\n+pub fn seed() -> ~[u8] {\n     rustrt::rand_seed()\n }\n \n /// Create a random number generator with a system specified seed\n-fn Rng() -> Rng {\n+pub fn Rng() -> Rng {\n     @RandRes(rustrt::rand_new()) as Rng\n }\n \n@@ -275,8 +275,8 @@ fn Rng() -> Rng {\n  * all other generators constructed with the same seed. The seed may be any\n  * length.\n  */\n-fn seeded_rng(seed: ~[u8]) -> Rng {\n-    @RandRes(rustrt::rand_new_seeded(seed)) as Rng\n+pub fn seeded_rng(seed: &~[u8]) -> Rng {\n+    @RandRes(rustrt::rand_new_seeded2(*seed)) as Rng\n }\n \n type XorShiftState = {\n@@ -299,40 +299,72 @@ impl XorShiftState: Rng {\n     }\n }\n \n-fn xorshift() -> Rng {\n+pub fn xorshift() -> Rng {\n     // constants taken from http://en.wikipedia.org/wiki/Xorshift\n     seeded_xorshift(123456789u32, 362436069u32, 521288629u32, 88675123u32)\n }\n \n-fn seeded_xorshift(x: u32, y: u32, z: u32, w: u32) -> Rng {\n+pub fn seeded_xorshift(x: u32, y: u32, z: u32, w: u32) -> Rng {\n     {mut x: x, mut y: y, mut z: z, mut w: w} as Rng\n }\n \n-#[cfg(test)]\n-mod tests {\n-    #[legacy_exports];\n \n+// used to make space in TLS for a random number generator\n+fn tls_rng_state(+_v: @RandRes) {}\n+\n+/**\n+ * Gives back a lazily initialized task-local random number generator,\n+ * seeded by the system. Intended to be used in method chaining style, ie\n+ * task_rng().gen_int().\n+ */\n+pub fn task_rng() -> Rng {\n+    let r : Option<@RandRes>;\n+    unsafe {\n+        r = task::local_data::local_data_get(tls_rng_state);\n+    }\n+    match r {\n+        None => {\n+            let rng = @RandRes(rustrt::rand_new());\n+            unsafe {\n+                task::local_data::local_data_set(tls_rng_state, rng);\n+            }\n+            rng as Rng\n+        }\n+        Some(rng) => rng as Rng\n+    }\n+}\n+\n+/**\n+ * Returns a random uint, using the task's based random number generator.\n+ */\n+pub fn random() -> uint {\n+    task_rng().gen_uint()\n+}\n+\n+\n+#[cfg(test)]\n+pub mod tests {\n     #[test]\n-    fn rng_seeded() {\n+    pub fn rng_seeded() {\n         let seed = rand::seed();\n-        let ra = rand::seeded_rng(seed);\n-        let rb = rand::seeded_rng(seed);\n+        let ra = rand::seeded_rng(&seed);\n+        let rb = rand::seeded_rng(&seed);\n         assert ra.gen_str(100u) == rb.gen_str(100u);\n     }\n \n     #[test]\n-    fn rng_seeded_custom_seed() {\n+    pub fn rng_seeded_custom_seed() {\n         // much shorter than generated seeds which are 1024 bytes\n         let seed = ~[2u8, 32u8, 4u8, 32u8, 51u8];\n-        let ra = rand::seeded_rng(seed);\n-        let rb = rand::seeded_rng(seed);\n+        let ra = rand::seeded_rng(&seed);\n+        let rb = rand::seeded_rng(&seed);\n         assert ra.gen_str(100u) == rb.gen_str(100u);\n     }\n \n     #[test]\n-    fn rng_seeded_custom_seed2() {\n+    pub fn rng_seeded_custom_seed2() {\n         let seed = ~[2u8, 32u8, 4u8, 32u8, 51u8];\n-        let ra = rand::seeded_rng(seed);\n+        let ra = rand::seeded_rng(&seed);\n         // Regression test that isaac is actually using the above vector\n         let r = ra.next();\n         error!(\"%?\", r);\n@@ -341,7 +373,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn gen_int_range() {\n+    pub fn gen_int_range() {\n         let r = rand::Rng();\n         let a = r.gen_int_range(-3, 42);\n         assert a >= -3 && a < 42;\n@@ -352,12 +384,12 @@ mod tests {\n     #[test]\n     #[should_fail]\n     #[ignore(cfg(windows))]\n-    fn gen_int_from_fail() {\n+    pub fn gen_int_from_fail() {\n         rand::Rng().gen_int_range(5, -2);\n     }\n \n     #[test]\n-    fn gen_uint_range() {\n+    pub fn gen_uint_range() {\n         let r = rand::Rng();\n         let a = r.gen_uint_range(3u, 42u);\n         assert a >= 3u && a < 42u;\n@@ -368,27 +400,27 @@ mod tests {\n     #[test]\n     #[should_fail]\n     #[ignore(cfg(windows))]\n-    fn gen_uint_range_fail() {\n+    pub fn gen_uint_range_fail() {\n         rand::Rng().gen_uint_range(5u, 2u);\n     }\n \n     #[test]\n-    fn gen_float() {\n+    pub fn gen_float() {\n         let r = rand::Rng();\n         let a = r.gen_float();\n         let b = r.gen_float();\n         log(debug, (a, b));\n     }\n \n     #[test]\n-    fn gen_weighted_bool() {\n+    pub fn gen_weighted_bool() {\n         let r = rand::Rng();\n         assert r.gen_weighted_bool(0u) == true;\n         assert r.gen_weighted_bool(1u) == true;\n     }\n \n     #[test]\n-    fn gen_str() {\n+    pub fn gen_str() {\n         let r = rand::Rng();\n         log(debug, r.gen_str(10u));\n         log(debug, r.gen_str(10u));\n@@ -399,29 +431,29 @@ mod tests {\n     }\n \n     #[test]\n-    fn gen_bytes() {\n+    pub fn gen_bytes() {\n         let r = rand::Rng();\n         assert r.gen_bytes(0u).len() == 0u;\n         assert r.gen_bytes(10u).len() == 10u;\n         assert r.gen_bytes(16u).len() == 16u;\n     }\n \n     #[test]\n-    fn choose() {\n+    pub fn choose() {\n         let r = rand::Rng();\n         assert r.choose([1, 1, 1]) == 1;\n     }\n \n     #[test]\n-    fn choose_option() {\n+    pub fn choose_option() {\n         let r = rand::Rng();\n         let x: Option<int> = r.choose_option([]);\n         assert x.is_none();\n         assert r.choose_option([1, 1, 1]) == Some(1);\n     }\n \n     #[test]\n-    fn choose_weighted() {\n+    pub fn choose_weighted() {\n         let r = rand::Rng();\n         assert r.choose_weighted(~[{weight: 1u, item: 42}]) == 42;\n         assert r.choose_weighted(~[\n@@ -431,7 +463,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn choose_weighted_option() {\n+    pub fn choose_weighted_option() {\n         let r = rand::Rng();\n         assert r.choose_weighted_option(~[{weight: 1u, item: 42}]) ==\n                Some(42);\n@@ -444,7 +476,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn weighted_vec() {\n+    pub fn weighted_vec() {\n         let r = rand::Rng();\n         let empty: ~[int] = ~[];\n         assert r.weighted_vec(~[]) == empty;\n@@ -456,12 +488,26 @@ mod tests {\n     }\n \n     #[test]\n-    fn shuffle() {\n+    pub fn shuffle() {\n         let r = rand::Rng();\n         let empty: ~[int] = ~[];\n         assert r.shuffle(~[]) == empty;\n         assert r.shuffle(~[1, 1, 1]) == ~[1, 1, 1];\n     }\n+\n+    #[test]\n+    pub fn task_rng() {\n+        let r = rand::task_rng();\n+        r.gen_int();\n+        assert r.shuffle(~[1, 1, 1]) == ~[1, 1, 1];\n+        assert r.gen_uint_range(0u, 1u) == 0u;\n+    }\n+\n+    #[test]\n+    pub fn random() {\n+        // not sure how to test this aside from just getting a number\n+        let _n : uint = rand::random();\n+    }\n }\n \n "}, {"sha": "41006e1dfb5e6c3437815528006435e2db66f933", "filename": "src/libcore/reflect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Freflect.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -13,7 +13,7 @@ use libc::c_void;\n  * data structure, and implement both `MovePtr` for it as well as `TyVisitor`;\n  * then build a MovePtrAdaptor wrapped around your struct.\n  */\n-trait MovePtr {\n+pub trait MovePtr {\n     fn move_ptr(adjustment: fn(*c_void) -> *c_void);\n }\n \n@@ -27,7 +27,7 @@ fn align(size: uint, align: uint) -> uint {\n struct MovePtrAdaptor<V: TyVisitor MovePtr> {\n     inner: V\n }\n-pub fn MovePtrAdaptor<V: TyVisitor MovePtr>(+v: V) -> MovePtrAdaptor<V> {\n+pub fn MovePtrAdaptor<V: TyVisitor MovePtr>(v: V) -> MovePtrAdaptor<V> {\n     MovePtrAdaptor { inner: move v }\n }\n "}, {"sha": "ff82ed3fb419ccea4c0bc926119d56fb59a2c462", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -13,7 +13,8 @@ use cast::transmute;\n use intrinsic::{TyDesc, TyVisitor, visit_tydesc};\n use reflect::{MovePtr, MovePtrAdaptor};\n use vec::raw::{VecRepr, UnboxedVecRepr, SliceRepr};\n-use box::raw::{BoxRepr, BoxHeaderRepr};\n+pub use box::raw::BoxRepr;\n+use box::raw::BoxHeaderRepr;\n \n /// Helpers\n "}, {"sha": "e61690d5b2c0e0acc7258170277fac8f5e21cd26", "filename": "src/libcore/result.rs", "status": "modified", "additions": 96, "deletions": 87, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -1,10 +1,14 @@\n //! A type representing either success or failure\n \n+// NB: transitionary, de-mode-ing.\n+// tjc: re-forbid deprecated modes after snapshot\n+#[forbid(deprecated_pattern)];\n+\n use cmp::Eq;\n use either::Either;\n \n /// The result type\n-enum Result<T, U> {\n+pub enum Result<T, U> {\n     /// Contains the successful result value\n     Ok(T),\n     /// Contains the error value\n@@ -18,11 +22,11 @@ enum Result<T, U> {\n  *\n  * If the result is an error\n  */\n-pure fn get<T: Copy, U>(res: Result<T, U>) -> T {\n-    match res {\n-      Ok(t) => t,\n-      Err(the_err) => unsafe {\n-        fail fmt!(\"get called on error result: %?\", the_err)\n+pub pure fn get<T: Copy, U>(res: &Result<T, U>) -> T {\n+    match *res {\n+      Ok(copy t) => t,\n+      Err(ref the_err) => unsafe {\n+        fail fmt!(\"get called on error result: %?\", *the_err)\n       }\n     }\n }\n@@ -34,11 +38,11 @@ pure fn get<T: Copy, U>(res: Result<T, U>) -> T {\n  *\n  * If the result is an error\n  */\n-pure fn get_ref<T, U>(res: &a/Result<T, U>) -> &a/T {\n+pub pure fn get_ref<T, U>(res: &a/Result<T, U>) -> &a/T {\n     match *res {\n         Ok(ref t) => t,\n         Err(ref the_err) => unsafe {\n-            fail fmt!(\"get_ref called on error result: %?\", the_err)\n+            fail fmt!(\"get_ref called on error result: %?\", *the_err)\n         }\n     }\n }\n@@ -50,23 +54,23 @@ pure fn get_ref<T, U>(res: &a/Result<T, U>) -> &a/T {\n  *\n  * If the result is not an error\n  */\n-pure fn get_err<T, U: Copy>(res: Result<T, U>) -> U {\n-    match res {\n-      Err(u) => u,\n+pub pure fn get_err<T, U: Copy>(res: &Result<T, U>) -> U {\n+    match *res {\n+      Err(copy u) => u,\n       Ok(_) => fail ~\"get_err called on ok result\"\n     }\n }\n \n /// Returns true if the result is `ok`\n-pure fn is_ok<T, U>(res: Result<T, U>) -> bool {\n-    match res {\n+pub pure fn is_ok<T, U>(res: &Result<T, U>) -> bool {\n+    match *res {\n       Ok(_) => true,\n       Err(_) => false\n     }\n }\n \n /// Returns true if the result is `err`\n-pure fn is_err<T, U>(res: Result<T, U>) -> bool {\n+pub pure fn is_err<T, U>(res: &Result<T, U>) -> bool {\n     !is_ok(res)\n }\n \n@@ -76,10 +80,11 @@ pure fn is_err<T, U>(res: Result<T, U>) -> bool {\n  * `ok` result variants are converted to `either::right` variants, `err`\n  * result variants are converted to `either::left`.\n  */\n-pure fn to_either<T: Copy, U: Copy>(res: Result<U, T>) -> Either<T, U> {\n-    match res {\n-      Ok(res) => either::Right(res),\n-      Err(fail_) => either::Left(fail_)\n+pub pure fn to_either<T: Copy, U: Copy>(res: &Result<U, T>)\n+    -> Either<T, U> {\n+    match *res {\n+      Ok(copy res) => either::Right(res),\n+      Err(copy fail_) => either::Left(fail_)\n     }\n }\n \n@@ -97,11 +102,13 @@ pure fn to_either<T: Copy, U: Copy>(res: Result<U, T>) -> Either<T, U> {\n  *         ok(parse_bytes(buf))\n  *     }\n  */\n-fn chain<T, U: Copy, V: Copy>(res: Result<T, V>, op: fn(T) -> Result<U, V>)\n-    -> Result<U, V> {\n-    match res {\n-      Ok(t) => op(t),\n-      Err(e) => Err(e)\n+pub fn chain<T, U: Copy, V: Copy>(res: Result<T, V>, op: fn(t: T)\n+    -> Result<U, V>) -> Result<U, V> {\n+    // XXX: Should be writable with move + match\n+    if res.is_ok() {\n+        op(unwrap(res))\n+    } else {\n+        Err(unwrap_err(res))\n     }\n }\n \n@@ -113,13 +120,13 @@ fn chain<T, U: Copy, V: Copy>(res: Result<T, V>, op: fn(T) -> Result<U, V>)\n  * immediately returned.  This function can be used to pass through a\n  * successful result while handling an error.\n  */\n-fn chain_err<T: Copy, U: Copy, V: Copy>(\n+pub fn chain_err<T: Copy, U: Copy, V: Copy>(\n     res: Result<T, V>,\n-    op: fn(V) -> Result<T, U>)\n+    op: fn(t: V) -> Result<T, U>)\n     -> Result<T, U> {\n-    match res {\n-      Ok(t) => Ok(t),\n-      Err(v) => op(v)\n+    match move res {\n+      Ok(move t) => Ok(t),\n+      Err(move v) => op(v)\n     }\n }\n \n@@ -137,9 +144,9 @@ fn chain_err<T: Copy, U: Copy, V: Copy>(\n  *         print_buf(buf)\n  *     }\n  */\n-fn iter<T, E>(res: Result<T, E>, f: fn(T)) {\n-    match res {\n-      Ok(t) => f(t),\n+pub fn iter<T, E>(res: &Result<T, E>, f: fn((&T))) {\n+    match *res {\n+      Ok(ref t) => f(t),\n       Err(_) => ()\n     }\n }\n@@ -152,10 +159,10 @@ fn iter<T, E>(res: Result<T, E>, f: fn(T)) {\n  * This function can be used to pass through a successful result while\n  * handling an error.\n  */\n-fn iter_err<T, E>(res: Result<T, E>, f: fn(E)) {\n-    match res {\n+pub fn iter_err<T, E>(res: &Result<T, E>, f: fn((&E))) {\n+    match *res {\n       Ok(_) => (),\n-      Err(e) => f(e)\n+      Err(ref e) => f(e)\n     }\n }\n \n@@ -173,11 +180,11 @@ fn iter_err<T, E>(res: Result<T, E>, f: fn(E)) {\n  *         parse_bytes(buf)\n  *     }\n  */\n-fn map<T, E: Copy, U: Copy>(res: Result<T, E>, op: fn(T) -> U)\n+pub fn map<T, E: Copy, U: Copy>(res: &Result<T, E>, op: fn((&T)) -> U)\n   -> Result<U, E> {\n-    match res {\n-      Ok(t) => Ok(op(t)),\n-      Err(e) => Err(e)\n+    match *res {\n+      Ok(ref t) => Ok(op(t)),\n+      Err(copy e) => Err(e)\n     }\n }\n \n@@ -189,63 +196,65 @@ fn map<T, E: Copy, U: Copy>(res: Result<T, E>, op: fn(T) -> U)\n  * is immediately returned.  This function can be used to pass through a\n  * successful result while handling an error.\n  */\n-fn map_err<T: Copy, E, F: Copy>(res: Result<T, E>, op: fn(E) -> F)\n+pub fn map_err<T: Copy, E, F: Copy>(res: &Result<T, E>, op: fn((&E)) -> F)\n   -> Result<T, F> {\n-    match res {\n-      Ok(t) => Ok(t),\n-      Err(e) => Err(op(e))\n+    match *res {\n+      Ok(copy t) => Ok(t),\n+      Err(ref e) => Err(op(e))\n     }\n }\n \n impl<T, E> Result<T, E> {\n-    fn is_ok() -> bool { is_ok(self) }\n+    fn is_ok() -> bool { is_ok(&self) }\n \n-    fn is_err() -> bool { is_err(self) }\n+    fn is_err() -> bool { is_err(&self) }\n \n-    fn iter(f: fn(T)) {\n+    fn iter(f: fn((&T))) {\n         match self {\n-          Ok(t) => f(t),\n+          Ok(ref t) => f(t),\n           Err(_) => ()\n         }\n     }\n \n-    fn iter_err(f: fn(E)) {\n+    fn iter_err(f: fn((&E))) {\n         match self {\n           Ok(_) => (),\n-          Err(e) => f(e)\n+          Err(ref e) => f(e)\n         }\n     }\n }\n \n impl<T: Copy, E> Result<T, E> {\n-    fn get() -> T { get(self) }\n+    fn get() -> T { get(&self) }\n \n-    fn map_err<F:Copy>(op: fn(E) -> F) -> Result<T,F> {\n+    fn map_err<F:Copy>(op: fn((&E)) -> F) -> Result<T,F> {\n         match self {\n-          Ok(t) => Ok(t),\n-          Err(e) => Err(op(e))\n+          Ok(copy t) => Ok(t),\n+          Err(ref e) => Err(op(e))\n         }\n     }\n }\n \n impl<T, E: Copy> Result<T, E> {\n-    fn get_err() -> E { get_err(self) }\n+    fn get_err() -> E { get_err(&self) }\n \n-    fn map<U:Copy>(op: fn(T) -> U) -> Result<U,E> {\n+    fn map<U:Copy>(op: fn((&T)) -> U) -> Result<U,E> {\n         match self {\n-          Ok(t) => Ok(op(t)),\n-          Err(e) => Err(e)\n+          Ok(ref t) => Ok(op(t)),\n+          Err(copy e) => Err(e)\n         }\n     }\n }\n \n impl<T: Copy, E: Copy> Result<T, E> {\n-    fn chain<U:Copy>(op: fn(T) -> Result<U,E>) -> Result<U,E> {\n-        chain(self, op)\n+    fn chain<U:Copy>(op: fn(t: T) -> Result<U,E>) -> Result<U,E> {\n+        // XXX: Bad copy\n+        chain(copy self, op)\n     }\n \n-    fn chain_err<F:Copy>(op: fn(E) -> Result<T,F>) -> Result<T,F> {\n-        chain_err(self, op)\n+    fn chain_err<F:Copy>(op: fn(t: E) -> Result<T,F>) -> Result<T,F> {\n+        // XXX: Bad copy\n+        chain_err(copy self, op)\n     }\n }\n \n@@ -266,27 +275,27 @@ impl<T: Copy, E: Copy> Result<T, E> {\n  *         assert incd == ~[2u, 3u, 4u];\n  *     }\n  */\n-fn map_vec<T,U:Copy,V:Copy>(\n+pub fn map_vec<T,U:Copy,V:Copy>(\n     ts: &[T], op: fn((&T)) -> Result<V,U>) -> Result<~[V],U> {\n \n     let mut vs: ~[V] = vec::with_capacity(vec::len(ts));\n     for vec::each(ts) |t| {\n         match op(t) {\n-          Ok(v) => vec::push(vs, v),\n-          Err(u) => return Err(u)\n+          Ok(copy v) => vs.push(v),\n+          Err(copy u) => return Err(u)\n         }\n     }\n     return Ok(move vs);\n }\n \n-fn map_opt<T,U:Copy,V:Copy>(\n-    o_t: Option<T>, op: fn(T) -> Result<V,U>) -> Result<Option<V>,U> {\n+pub fn map_opt<T,U:Copy,V:Copy>(\n+    o_t: &Option<T>, op: fn((&T)) -> Result<V,U>) -> Result<Option<V>,U> {\n \n-    match o_t {\n+    match *o_t {\n       None => Ok(None),\n-      Some(t) => match op(t) {\n-        Ok(v) => Ok(Some(v)),\n-        Err(e) => Err(e)\n+      Some(ref t) => match op(t) {\n+        Ok(copy v) => Ok(Some(v)),\n+        Err(copy e) => Err(e)\n       }\n     }\n }\n@@ -300,17 +309,17 @@ fn map_opt<T,U:Copy,V:Copy>(\n  * used in 'careful' code contexts where it is both appropriate and easy\n  * to accommodate an error like the vectors being of different lengths.\n  */\n-fn map_vec2<S,T,U:Copy,V:Copy>(ss: &[S], ts: &[T],\n-                               op: fn(S,T) -> Result<V,U>) -> Result<~[V],U> {\n+pub fn map_vec2<S,T,U:Copy,V:Copy>(ss: &[S], ts: &[T],\n+                op: fn((&S),(&T)) -> Result<V,U>) -> Result<~[V],U> {\n \n     assert vec::same_length(ss, ts);\n     let n = vec::len(ts);\n     let mut vs = vec::with_capacity(n);\n     let mut i = 0u;\n     while i < n {\n-        match op(ss[i],ts[i]) {\n-          Ok(v) => vec::push(vs, v),\n-          Err(u) => return Err(u)\n+        match op(&ss[i],&ts[i]) {\n+          Ok(copy v) => vs.push(v),\n+          Err(copy u) => return Err(u)\n         }\n         i += 1u;\n     }\n@@ -322,32 +331,32 @@ fn map_vec2<S,T,U:Copy,V:Copy>(ss: &[S], ts: &[T],\n  * error.  This could be implemented using `map2()` but it is more efficient\n  * on its own as no result vector is built.\n  */\n-fn iter_vec2<S,T,U:Copy>(ss: &[S], ts: &[T],\n-                         op: fn(S,T) -> Result<(),U>) -> Result<(),U> {\n+pub fn iter_vec2<S,T,U:Copy>(ss: &[S], ts: &[T],\n+                         op: fn((&S),(&T)) -> Result<(),U>) -> Result<(),U> {\n \n     assert vec::same_length(ss, ts);\n     let n = vec::len(ts);\n     let mut i = 0u;\n     while i < n {\n-        match op(ss[i],ts[i]) {\n+        match op(&ss[i],&ts[i]) {\n           Ok(()) => (),\n-          Err(u) => return Err(u)\n+          Err(copy u) => return Err(u)\n         }\n         i += 1u;\n     }\n     return Ok(());\n }\n \n /// Unwraps a result, assuming it is an `ok(T)`\n-fn unwrap<T, U>(+res: Result<T, U>) -> T {\n+pub fn unwrap<T, U>(res: Result<T, U>) -> T {\n     match move res {\n       Ok(move t) => move t,\n       Err(_) => fail ~\"unwrap called on an err result\"\n     }\n }\n \n /// Unwraps a result, assuming it is an `err(U)`\n-fn unwrap_err<T, U>(+res: Result<T, U>) -> U {\n+pub fn unwrap_err<T, U>(res: Result<T, U>) -> U {\n     match move res {\n       Err(move u) => move u,\n       Ok(_) => fail ~\"unwrap called on an ok result\"\n@@ -357,15 +366,15 @@ fn unwrap_err<T, U>(+res: Result<T, U>) -> U {\n impl<T:Eq,U:Eq> Result<T,U> : Eq {\n     pure fn eq(other: &Result<T,U>) -> bool {\n         match self {\n-            Ok(e0a) => {\n+            Ok(ref e0a) => {\n                 match (*other) {\n-                    Ok(e0b) => e0a == e0b,\n+                    Ok(ref e0b) => *e0a == *e0b,\n                     _ => false\n                 }\n             }\n-            Err(e0a) => {\n+            Err(ref e0a) => {\n                 match (*other) {\n-                    Err(e0b) => e0a == e0b,\n+                    Err(ref e0b) => *e0a == *e0b,\n                     _ => false\n                 }\n             }\n@@ -380,20 +389,20 @@ mod tests {\n     #[legacy_exports];\n     fn op1() -> result::Result<int, ~str> { result::Ok(666) }\n \n-    fn op2(&&i: int) -> result::Result<uint, ~str> {\n+    fn op2(i: int) -> result::Result<uint, ~str> {\n         result::Ok(i as uint + 1u)\n     }\n \n     fn op3() -> result::Result<int, ~str> { result::Err(~\"sadface\") }\n \n     #[test]\n     fn chain_success() {\n-        assert get(chain(op1(), op2)) == 667u;\n+        assert get(&chain(op1(), op2)) == 667u;\n     }\n \n     #[test]\n     fn chain_failure() {\n-        assert get_err(chain(op3(), op2)) == ~\"sadface\";\n+        assert get_err(&chain(op3(), op2)) == ~\"sadface\";\n     }\n \n     #[test]"}, {"sha": "9bc83a5f9043d3ba18fd54e5b3c1cc64f4241055", "filename": "src/libcore/rt.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -11,10 +11,9 @@ use libc::uintptr_t;\n use gc::{cleanup_stack_for_failure, gc, Word};\n \n #[allow(non_camel_case_types)]\n-type rust_task = c_void;\n+pub type rust_task = c_void;\n \n extern mod rustrt {\n-    #[legacy_exports];\n     #[rust_stack]\n     fn rust_upcall_fail(expr: *c_char, file: *c_char, line: size_t);\n \n@@ -35,34 +34,44 @@ extern mod rustrt {\n // 'rt_', otherwise the compiler won't find it. To fix this, see\n // gather_rust_rtcalls.\n #[rt(fail_)]\n-fn rt_fail_(expr: *c_char, file: *c_char, line: size_t) {\n+pub fn rt_fail_(expr: *c_char, file: *c_char, line: size_t) {\n     cleanup_stack_for_failure();\n     rustrt::rust_upcall_fail(expr, file, line);\n }\n \n+#[rt(fail_bounds_check)]\n+pub fn rt_fail_bounds_check(file: *c_char, line: size_t,\n+                        index: size_t, len: size_t) {\n+    let msg = fmt!(\"index out of bounds: the len is %d but the index is %d\",\n+                    len as int, index as int);\n+    do str::as_buf(msg) |p, _len| {\n+        rt_fail_(p as *c_char, file, line);\n+    }\n+}\n+\n #[rt(exchange_malloc)]\n-fn rt_exchange_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n+pub fn rt_exchange_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n     return rustrt::rust_upcall_exchange_malloc(td, size);\n }\n \n // NB: Calls to free CANNOT be allowed to fail, as throwing an exception from\n // inside a landing pad may corrupt the state of the exception handler. If a\n // problem occurs, call exit instead.\n #[rt(exchange_free)]\n-fn rt_exchange_free(ptr: *c_char) {\n+pub fn rt_exchange_free(ptr: *c_char) {\n     rustrt::rust_upcall_exchange_free(ptr);\n }\n \n #[rt(malloc)]\n-fn rt_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n+pub fn rt_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n     return rustrt::rust_upcall_malloc(td, size);\n }\n \n // NB: Calls to free CANNOT be allowed to fail, as throwing an exception from\n // inside a landing pad may corrupt the state of the exception handler. If a\n // problem occurs, call exit instead.\n #[rt(free)]\n-fn rt_free(ptr: *c_char) {\n+pub fn rt_free(ptr: *c_char) {\n     rustrt::rust_upcall_free(ptr);\n }\n "}, {"sha": "f3e98f6ba8272b6b6f8f83dc41eefd760fca374f", "filename": "src/libcore/run.rs", "status": "modified", "additions": 27, "deletions": 36, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -1,30 +1,22 @@\n // NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n+// tjc: re-forbid deprecated modes after snapshot\n #[forbid(deprecated_pattern)];\n \n //! Process spawning\n use option::{Some, None};\n use libc::{pid_t, c_void, c_int};\n use io::ReaderUtil;\n \n-export Program;\n-export run_program;\n-export start_program;\n-export program_output;\n-export spawn_process;\n-export waitpid;\n-\n #[abi = \"cdecl\"]\n extern mod rustrt {\n-    #[legacy_exports];\n     fn rust_run_program(argv: **libc::c_char, envp: *c_void,\n                         dir: *libc::c_char,\n                         in_fd: c_int, out_fd: c_int, err_fd: c_int)\n         -> pid_t;\n }\n \n /// A value representing a child process\n-trait Program {\n+pub trait Program {\n     /// Returns the process id of the program\n     fn get_id() -> pid_t;\n \n@@ -68,7 +60,7 @@ trait Program {\n  *\n  * The process id of the spawned process\n  */\n-fn spawn_process(prog: &str, args: &[~str],\n+pub fn spawn_process(prog: &str, args: &[~str],\n                  env: &Option<~[(~str,~str)]>,\n                  dir: &Option<~str>,\n                  in_fd: c_int, out_fd: c_int, err_fd: c_int)\n@@ -89,10 +81,10 @@ fn with_argv<T>(prog: &str, args: &[~str],\n     let mut tmps = ~[];\n     for vec::each(args) |arg| {\n         let t = @copy *arg;\n-        vec::push(tmps, t);\n-        vec::push_all(argptrs, str::as_c_str(*t, |b| ~[b]));\n+        tmps.push(t);\n+        argptrs.push_all(str::as_c_str(*t, |b| ~[b]));\n     }\n-    vec::push(argptrs, ptr::null());\n+    argptrs.push(ptr::null());\n     vec::as_imm_buf(argptrs, |buf, _len| cb(buf))\n }\n \n@@ -102,17 +94,17 @@ fn with_envp<T>(env: &Option<~[(~str,~str)]>,\n     // On posixy systems we can pass a char** for envp, which is\n     // a null-terminated array of \"k=v\\n\" strings.\n     match *env {\n-      Some(es) if !vec::is_empty(es) => {\n+      Some(ref es) if !vec::is_empty(*es) => {\n         let mut tmps = ~[];\n         let mut ptrs = ~[];\n \n-        for vec::each(es) |e| {\n+        for vec::each(*es) |e| {\n             let (k,v) = copy *e;\n             let t = @(fmt!(\"%s=%s\", k, v));\n-            vec::push(tmps, t);\n-            vec::push_all(ptrs, str::as_c_str(*t, |b| ~[b]));\n+            tmps.push(t);\n+            ptrs.push_all(str::as_c_str(*t, |b| ~[b]));\n         }\n-        vec::push(ptrs, ptr::null());\n+        ptrs.push(ptr::null());\n         vec::as_imm_buf(ptrs, |p, _len|\n             unsafe { cb(::cast::reinterpret_cast(&p)) }\n         )\n@@ -149,7 +141,7 @@ fn with_envp<T>(env: &Option<~[(~str,~str)]>,\n fn with_dirp<T>(d: &Option<~str>,\n                 cb: fn(*libc::c_char) -> T) -> T {\n     match *d {\n-      Some(dir) => str::as_c_str(dir, cb),\n+      Some(ref dir) => str::as_c_str(*dir, cb),\n       None => cb(ptr::null())\n     }\n }\n@@ -166,7 +158,7 @@ fn with_dirp<T>(d: &Option<~str>,\n  *\n  * The process id\n  */\n-fn run_program(prog: &str, args: &[~str]) -> int {\n+pub fn run_program(prog: &str, args: &[~str]) -> int {\n     let pid = spawn_process(prog, args, &None, &None,\n                             0i32, 0i32, 0i32);\n     if pid == -1 as pid_t { fail; }\n@@ -189,7 +181,7 @@ fn run_program(prog: &str, args: &[~str]) -> int {\n  *\n  * A class with a <program> field\n  */\n-fn start_program(prog: &str, args: &[~str]) -> Program {\n+pub fn start_program(prog: &str, args: &[~str]) -> Program {\n     let pipe_input = os::pipe();\n     let pipe_output = os::pipe();\n     let pipe_err = os::pipe();\n@@ -232,7 +224,7 @@ fn start_program(prog: &str, args: &[~str]) -> Program {\n         drop { destroy_repr(&self.r); }\n     }\n \n-    fn ProgRes(+r: ProgRepr) -> ProgRes {\n+    fn ProgRes(r: ProgRepr) -> ProgRes {\n         ProgRes {\n             r: r\n         }\n@@ -278,7 +270,7 @@ fn read_all(rd: io::Reader) -> ~str {\n  * A record, {status: int, out: str, err: str} containing the exit code,\n  * the contents of stdout and the contents of stderr.\n  */\n-fn program_output(prog: &str, args: &[~str]) ->\n+pub fn program_output(prog: &str, args: &[~str]) ->\n    {status: int, out: ~str, err: ~str} {\n \n     let pipe_in = os::pipe();\n@@ -320,11 +312,11 @@ fn program_output(prog: &str, args: &[~str]) ->\n     while count > 0 {\n         let stream = comm::recv(p);\n         match stream {\n-            (1, s) => {\n-                outs = copy s;\n+            (1, copy s) => {\n+                outs = s;\n             }\n-            (2, s) => {\n-                errs = copy s;\n+            (2, copy s) => {\n+                errs = s;\n             }\n             (n, _) => {\n                 fail(fmt!(\"program_output received an unexpected file \\\n@@ -336,7 +328,7 @@ fn program_output(prog: &str, args: &[~str]) ->\n     return {status: status, out: move outs, err: move errs};\n }\n \n-fn writeclose(fd: c_int, s: &str) {\n+fn writeclose(fd: c_int, s: ~str) {\n     use io::WriterUtil;\n \n     error!(\"writeclose %d, %s\", fd as int, s);\n@@ -359,7 +351,7 @@ fn readclose(fd: c_int) -> ~str {\n }\n \n /// Waits for a process to exit and returns the exit code\n-fn waitpid(pid: pid_t) -> int {\n+pub fn waitpid(pid: pid_t) -> int {\n     return waitpid_os(pid);\n \n     #[cfg(windows)]\n@@ -402,20 +394,19 @@ fn waitpid(pid: pid_t) -> int {\n \n #[cfg(test)]\n mod tests {\n-    #[legacy_exports];\n-\n     use io::WriterUtil;\n \n     // Regression test for memory leaks\n     #[ignore(cfg(windows))] // FIXME (#2626)\n-    fn test_leaks() {\n+    pub fn test_leaks() {\n         run::run_program(\"echo\", []);\n         run::start_program(\"echo\", []);\n         run::program_output(\"echo\", []);\n     }\n \n     #[test]\n-    fn test_pipes() {\n+    #[allow(non_implicitly_copyable_typarams)]\n+    pub fn test_pipes() {\n         let pipe_in = os::pipe();\n         let pipe_out = os::pipe();\n         let pipe_err = os::pipe();\n@@ -430,7 +421,7 @@ mod tests {\n \n         if pid == -1i32 { fail; }\n         let expected = ~\"test\";\n-        writeclose(pipe_in.out, expected);\n+        writeclose(pipe_in.out, copy expected);\n         let actual = readclose(pipe_out.in);\n         readclose(pipe_err.in);\n         os::waitpid(pid);\n@@ -441,7 +432,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn waitpid() {\n+    pub fn waitpid() {\n         let pid = run::spawn_process(\"false\", [],\n                                      &None, &None,\n                                      0i32, 0i32, 0i32);"}, {"sha": "4a56ee5b896800809e5c3ddbb80278141e05b156", "filename": "src/libcore/send_map.rs", "status": "modified", "additions": 23, "deletions": 36, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fsend_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fsend_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsend_map.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -12,10 +12,10 @@ use cmp::Eq;\n use hash::Hash;\n use to_bytes::IterBytes;\n \n-trait SendMap<K:Eq Hash, V: Copy> {\n+pub trait SendMap<K:Eq Hash, V: Copy> {\n     // FIXME(#3148)  ^^^^ once find_ref() works, we can drop V:copy\n \n-    fn insert(&mut self, +k: K, +v: V) -> bool;\n+    fn insert(&mut self, k: K, +v: V) -> bool;\n     fn remove(&mut self, k: &K) -> bool;\n     fn clear(&mut self);\n     pure fn len(&const self) -> uint;\n@@ -31,17 +31,15 @@ trait SendMap<K:Eq Hash, V: Copy> {\n }\n \n /// Open addressing with linear probing.\n-mod linear {\n-    #[legacy_exports];\n-    export LinearMap, linear_map, linear_map_with_capacity, public_methods;\n-\n+pub mod linear {\n     const initial_capacity: uint = 32u; // 2^5\n+\n     struct Bucket<K:Eq Hash,V> {\n         hash: uint,\n         key: K,\n         value: V,\n     }\n-    struct LinearMap<K:Eq Hash,V> {\n+    pub struct LinearMap<K:Eq Hash,V> {\n         k0: u64,\n         k1: u64,\n         resize_at: uint,\n@@ -60,11 +58,11 @@ mod linear {\n         ((capacity as float) * 3. / 4.) as uint\n     }\n \n-    fn LinearMap<K:Eq Hash,V>() -> LinearMap<K,V> {\n+    pub fn LinearMap<K:Eq Hash,V>() -> LinearMap<K,V> {\n         linear_map_with_capacity(32)\n     }\n \n-    fn linear_map_with_capacity<K:Eq Hash,V>(\n+    pub fn linear_map_with_capacity<K:Eq Hash,V>(\n         initial_capacity: uint) -> LinearMap<K,V> {\n         let r = rand::Rng();\n         linear_map_with_capacity_and_keys(r.gen_u64(), r.gen_u64(),\n@@ -137,7 +135,7 @@ mod linear {\n                                          k: &K) -> SearchResult {\n             let _ = for self.bucket_sequence(hash) |i| {\n                 match buckets[i] {\n-                    Some(bkt) => if bkt.hash == hash && *k == bkt.key {\n+                    Some(ref bkt) => if bkt.hash == hash && *k == bkt.key {\n                         return FoundEntry(i);\n                     },\n                     None => return FoundHole(i)\n@@ -163,7 +161,7 @@ mod linear {\n             }\n         }\n \n-        fn insert_opt_bucket(&mut self, +bucket: Option<Bucket<K,V>>) {\n+        fn insert_opt_bucket(&mut self, bucket: Option<Bucket<K,V>>) {\n             match move bucket {\n                 Some(Bucket {hash: move hash,\n                              key: move key,\n@@ -177,7 +175,7 @@ mod linear {\n         /// Inserts the key value pair into the buckets.\n         /// Assumes that there will be a bucket.\n         /// True if there was no previous entry with that key\n-        fn insert_internal(&mut self, hash: uint, +k: K, +v: V) -> bool {\n+        fn insert_internal(&mut self, hash: uint, k: K, v: V) -> bool {\n             match self.bucket_for_key_with_hash(self.buckets, hash, &k) {\n                 TableFull => { fail ~\"Internal logic error\"; }\n                 FoundHole(idx) => {\n@@ -208,7 +206,7 @@ mod linear {\n     }\n \n     impl<K:Hash IterBytes Eq,V> LinearMap<K,V> {\n-        fn insert(&mut self, +k: K, +v: V) -> bool {\n+        fn insert(&mut self, k: K, v: V) -> bool {\n             if self.size >= self.resize_at {\n                 // n.b.: We could also do this after searching, so\n                 // that we do not resize if this call to insert is\n@@ -285,18 +283,9 @@ mod linear {\n                 FoundEntry(idx) => {\n                     match self.buckets[idx] {\n                         Some(ref bkt) => {\n-                            let ptr = unsafe {\n-                                // FIXME(#3148)--region inference\n-                                // fails to capture needed deps.\n-                                // Here, the bucket value is known to\n-                                // live as long as self, because self\n-                                // is immutable.  But the region\n-                                // inference stupidly infers a\n-                                // lifetime for `ref bkt` that is\n-                                // shorter than it needs to be.\n-                                cast::copy_lifetime(self, &bkt.value)\n-                            };\n-                            Some(ptr)\n+                            // FIXME(#3148)---should be inferred\n+                            let bkt: &self/Bucket<K,V> = bkt;\n+                            Some(&bkt.value)\n                         }\n                         None => {\n                             fail ~\"LinearMap::find: internal logic error\"\n@@ -344,7 +333,7 @@ mod linear {\n                     // FIXME (#3148): Once we rewrite found_entry, this\n                     // failure case won't be necessary\n                     match self.buckets[idx] {\n-                        Some(bkt) => {Some(copy bkt.value)}\n+                        Some(Bucket {value: copy value, _}) => {Some(value)}\n                         None => fail ~\"LinearMap::find: internal logic error\"\n                     }\n                 }\n@@ -366,13 +355,11 @@ mod linear {\n }\n \n #[test]\n-mod test {\n-    #[legacy_exports];\n-\n+pub mod test {\n     use linear::LinearMap;\n \n     #[test]\n-    fn inserts() {\n+    pub fn inserts() {\n         let mut m = ~LinearMap();\n         assert m.insert(1, 2);\n         assert m.insert(2, 4);\n@@ -381,7 +368,7 @@ mod test {\n     }\n \n     #[test]\n-    fn overwrite() {\n+    pub fn overwrite() {\n         let mut m = ~LinearMap();\n         assert m.insert(1, 2);\n         assert m.get(&1) == 2;\n@@ -390,7 +377,7 @@ mod test {\n     }\n \n     #[test]\n-    fn conflicts() {\n+    pub fn conflicts() {\n         let mut m = linear::linear_map_with_capacity(4);\n         assert m.insert(1, 2);\n         assert m.insert(5, 3);\n@@ -401,7 +388,7 @@ mod test {\n     }\n \n     #[test]\n-    fn conflict_remove() {\n+    pub fn conflict_remove() {\n         let mut m = linear::linear_map_with_capacity(4);\n         assert m.insert(1, 2);\n         assert m.insert(5, 3);\n@@ -412,7 +399,7 @@ mod test {\n     }\n \n     #[test]\n-    fn empty() {\n+    pub fn empty() {\n         let mut m = linear::linear_map_with_capacity(4);\n         assert m.insert(1, 2);\n         assert !m.is_empty();\n@@ -421,7 +408,7 @@ mod test {\n     }\n \n     #[test]\n-    fn iterate() {\n+    pub fn iterate() {\n         let mut m = linear::linear_map_with_capacity(4);\n         for uint::range(0, 32) |i| {\n             assert m.insert(i, i*2);\n@@ -435,7 +422,7 @@ mod test {\n     }\n \n     #[test]\n-    fn find_ref() {\n+    pub fn find_ref() {\n         let mut m = ~LinearMap();\n         assert m.find_ref(&1).is_none();\n         m.insert(1, 2);"}, {"sha": "09973148c8c8106ab08cac4ce312a4863a6e7494", "filename": "src/libcore/stackwalk.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fstackwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fstackwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstackwalk.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -1,7 +1,10 @@\n #[doc(hidden)]; // FIXME #3538\n \n+#[legacy_modes]; // tjc: remove after snapshot\n+\n // NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n+// XXX: Can't do this because frame_address needs a deprecated mode.\n+//#[forbid(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n \n use cast::reinterpret_cast;\n@@ -74,7 +77,7 @@ fn breakpoint() {\n     rustrt::rust_dbg_breakpoint()\n }\n \n-fn frame_address(f: fn(*u8)) {\n+fn frame_address(f: fn(++x: *u8)) {\n     rusti::frame_address(f)\n }\n \n@@ -86,5 +89,5 @@ extern mod rustrt {\n #[abi = \"rust-intrinsic\"]\n extern mod rusti {\n     #[legacy_exports];\n-    fn frame_address(f: fn(*u8));\n+    fn frame_address(f: fn(++x: *u8));\n }"}, {"sha": "cf996a8b254ca1efbb174d562365e7c8e63d0e75", "filename": "src/libcore/str.rs", "status": "modified", "additions": 149, "deletions": 273, "changes": 422, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -15,115 +15,6 @@ use libc::size_t;\n use io::WriterUtil;\n use to_str::ToStr;\n \n-export\n-   // Creating a string\n-   from_bytes,\n-   from_byte,\n-   from_slice,\n-   from_char,\n-   from_chars,\n-   append,\n-   concat,\n-   connect,\n-\n-   // Reinterpretation\n-   as_bytes,\n-   as_bytes_slice,\n-   as_buf,\n-   as_c_str,\n-\n-   // Adding things to and removing things from a string\n-   push_str_no_overallocate,\n-   push_str,\n-   push_char,\n-   pop_char,\n-   shift_char,\n-   view_shift_char,\n-   unshift_char,\n-   trim_left,\n-   trim_right,\n-   trim,\n-   trim_left_chars,\n-   trim_right_chars,\n-   trim_chars,\n-\n-   // Transforming strings\n-   to_bytes,\n-   byte_slice,\n-   chars,\n-   substr,\n-   slice,\n-   view,\n-   split, splitn, split_nonempty,\n-   split_char, splitn_char, split_char_nonempty,\n-   split_str, split_str_nonempty,\n-   lines,\n-   lines_any,\n-   words,\n-   to_lower,\n-   to_upper,\n-   replace,\n-\n-   // Comparing strings\n-   eq,\n-   eq_slice,\n-   le,\n-   hash,\n-\n-   // Iterating through strings\n-   all, any,\n-   all_between, any_between,\n-   map,\n-   each, eachi,\n-   each_char, each_chari,\n-   bytes_each,\n-   chars_each,\n-   split_char_each,\n-   splitn_char_each,\n-   words_each,\n-   lines_each,\n-\n-   // Searching\n-   find, find_from, find_between,\n-   rfind, rfind_from, rfind_between,\n-   find_char, find_char_from, find_char_between,\n-   rfind_char, rfind_char_from, rfind_char_between,\n-   find_str, find_str_from, find_str_between,\n-   contains, contains_char,\n-   starts_with,\n-   ends_with,\n-\n-   // String properties\n-   is_ascii,\n-   is_empty,\n-   is_not_empty,\n-   is_whitespace,\n-   len,\n-   char_len,\n-\n-   // Misc\n-   is_utf8,\n-   is_utf16,\n-   to_utf16,\n-   from_utf16,\n-   utf16_chars,\n-   count_chars, count_bytes,\n-   utf8_char_width,\n-   char_range_at,\n-   is_char_boundary,\n-   char_at,\n-   reserve,\n-   reserve_at_least,\n-   capacity,\n-   escape_default,\n-   escape_unicode,\n-\n-   raw,\n-   extensions,\n-   StrSlice,\n-   UniqueStr,\n-   traits;\n-\n /*\n Section: Creating a string\n */\n@@ -135,13 +26,13 @@ Section: Creating a string\n  *\n  * Fails if invalid UTF-8\n  */\n-pure fn from_bytes(vv: &[const u8]) -> ~str {\n+pub pure fn from_bytes(vv: &[const u8]) -> ~str {\n     assert is_utf8(vv);\n     return unsafe { raw::from_bytes(vv) };\n }\n \n /// Copy a slice into a new unique str\n-pure fn from_slice(s: &str) -> ~str {\n+pub pure fn from_slice(s: &str) -> ~str {\n     unsafe { raw::slice_bytes(s, 0, len(s)) }\n }\n \n@@ -152,13 +43,13 @@ pure fn from_slice(s: &str) -> ~str {\n  *\n  * Fails if invalid UTF-8\n  */\n-pure fn from_byte(b: u8) -> ~str {\n+pub pure fn from_byte(b: u8) -> ~str {\n     assert b < 128u8;\n     unsafe { ::cast::transmute(~[b, 0u8]) }\n }\n \n /// Appends a character at the end of a string\n-fn push_char(s: &const ~str, ch: char) {\n+pub fn push_char(s: &const ~str, ch: char) {\n     unsafe {\n         let code = ch as uint;\n         let nb = if code < max_one_b { 1u }\n@@ -229,14 +120,14 @@ fn push_char(s: &const ~str, ch: char) {\n }\n \n /// Convert a char to a string\n-pure fn from_char(ch: char) -> ~str {\n+pub pure fn from_char(ch: char) -> ~str {\n     let mut buf = ~\"\";\n     unsafe { push_char(&mut buf, ch); }\n     move buf\n }\n \n /// Convert a vector of chars to a string\n-pure fn from_chars(chs: &[char]) -> ~str {\n+pub pure fn from_chars(chs: &[char]) -> ~str {\n     let mut buf = ~\"\";\n     unsafe {\n         reserve(&mut buf, chs.len());\n@@ -249,7 +140,7 @@ pure fn from_chars(chs: &[char]) -> ~str {\n \n /// Appends a string slice to the back of a string, without overallocating\n #[inline(always)]\n-fn push_str_no_overallocate(lhs: &const ~str, rhs: &str) {\n+pub fn push_str_no_overallocate(lhs: &const ~str, rhs: &str) {\n     unsafe {\n         let llen = lhs.len();\n         let rlen = rhs.len();\n@@ -266,7 +157,7 @@ fn push_str_no_overallocate(lhs: &const ~str, rhs: &str) {\n }\n /// Appends a string slice to the back of a string\n #[inline(always)]\n-fn push_str(lhs: &const ~str, rhs: &str) {\n+pub fn push_str(lhs: &const ~str, rhs: &str) {\n     unsafe {\n         let llen = lhs.len();\n         let rlen = rhs.len();\n@@ -284,7 +175,7 @@ fn push_str(lhs: &const ~str, rhs: &str) {\n \n /// Concatenate two strings together\n #[inline(always)]\n-pure fn append(+lhs: ~str, rhs: &str) -> ~str {\n+pub pure fn append(lhs: ~str, rhs: &str) -> ~str {\n     let mut v <- lhs;\n     unsafe {\n         push_str_no_overallocate(&mut v, rhs);\n@@ -294,7 +185,7 @@ pure fn append(+lhs: ~str, rhs: &str) -> ~str {\n \n \n /// Concatenate a vector of strings\n-pure fn concat(v: &[~str]) -> ~str {\n+pub pure fn concat(v: &[~str]) -> ~str {\n     let mut s: ~str = ~\"\";\n     for vec::each(v) |ss| {\n         unsafe { push_str(&mut s, *ss) };\n@@ -303,7 +194,7 @@ pure fn concat(v: &[~str]) -> ~str {\n }\n \n /// Concatenate a vector of strings, placing a given separator between each\n-pure fn connect(v: &[~str], sep: &str) -> ~str {\n+pub pure fn connect(v: &[~str], sep: &str) -> ~str {\n     let mut s = ~\"\", first = true;\n     for vec::each(v) |ss| {\n         if first { first = false; } else { unsafe { push_str(&mut s, sep); } }\n@@ -323,7 +214,7 @@ Section: Adding to and removing from a string\n  *\n  * If the string does not contain any characters\n  */\n-fn pop_char(s: &const ~str) -> char {\n+pub fn pop_char(s: &const ~str) -> char {\n     let end = len(*s);\n     assert end > 0u;\n     let {ch, prev} = char_range_at_reverse(*s, end);\n@@ -338,7 +229,7 @@ fn pop_char(s: &const ~str) -> char {\n  *\n  * If the string does not contain any characters\n  */\n-fn shift_char(s: &mut ~str) -> char {\n+pub fn shift_char(s: &mut ~str) -> char {\n     let {ch, next} = char_range_at(*s, 0u);\n     *s = unsafe { raw::slice_bytes(*s, next, len(*s)) };\n     return ch;\n@@ -354,14 +245,14 @@ fn shift_char(s: &mut ~str) -> char {\n  * If the string does not contain any characters\n  */\n #[inline]\n-fn view_shift_char(s: &a/str) -> (char, &a/str) {\n+pub fn view_shift_char(s: &a/str) -> (char, &a/str) {\n     let {ch, next} = char_range_at(s, 0u);\n     let next_s = unsafe { raw::view_bytes(s, next, len(s)) };\n     return (ch, next_s);\n }\n \n /// Prepend a char to a string\n-fn unshift_char(s: &mut ~str, ch: char) {\n+pub fn unshift_char(s: &mut ~str, ch: char) {\n     *s = from_char(ch) + *s;\n }\n \n@@ -374,10 +265,10 @@ fn unshift_char(s: &mut ~str, ch: char) {\n  * * chars_to_trim - A vector of chars\n  *\n  */\n-pure fn trim_left_chars(s: &str, chars_to_trim: &[char]) -> ~str {\n+pub pure fn trim_left_chars(s: &str, chars_to_trim: &[char]) -> ~str {\n     if chars_to_trim.is_empty() { return from_slice(s); }\n \n-    match find(s, |c| !chars_to_trim.contains(c)) {\n+    match find(s, |c| !chars_to_trim.contains(&c)) {\n       None => ~\"\",\n       Some(first) => unsafe { raw::slice_bytes(s, first, s.len()) }\n     }\n@@ -392,10 +283,10 @@ pure fn trim_left_chars(s: &str, chars_to_trim: &[char]) -> ~str {\n  * * chars_to_trim - A vector of chars\n  *\n  */\n-pure fn trim_right_chars(s: &str, chars_to_trim: &[char]) -> ~str {\n+pub pure fn trim_right_chars(s: &str, chars_to_trim: &[char]) -> ~str {\n     if chars_to_trim.is_empty() { return str::from_slice(s); }\n \n-    match rfind(s, |c| !chars_to_trim.contains(c)) {\n+    match rfind(s, |c| !chars_to_trim.contains(&c)) {\n       None => ~\"\",\n       Some(last) => {\n         let {next, _} = char_range_at(s, last);\n@@ -413,20 +304,20 @@ pure fn trim_right_chars(s: &str, chars_to_trim: &[char]) -> ~str {\n  * * chars_to_trim - A vector of chars\n  *\n  */\n-pure fn trim_chars(s: &str, chars_to_trim: &[char]) -> ~str {\n+pub pure fn trim_chars(s: &str, chars_to_trim: &[char]) -> ~str {\n     trim_left_chars(trim_right_chars(s, chars_to_trim), chars_to_trim)\n }\n \n /// Returns a string with leading whitespace removed\n-pure fn trim_left(s: &str) -> ~str {\n+pub pure fn trim_left(s: &str) -> ~str {\n     match find(s, |c| !char::is_whitespace(c)) {\n       None => ~\"\",\n       Some(first) => unsafe { raw::slice_bytes(s, first, len(s)) }\n     }\n }\n \n /// Returns a string with trailing whitespace removed\n-pure fn trim_right(s: &str) -> ~str {\n+pub pure fn trim_right(s: &str) -> ~str {\n     match rfind(s, |c| !char::is_whitespace(c)) {\n       None => ~\"\",\n       Some(last) => {\n@@ -437,7 +328,7 @@ pure fn trim_right(s: &str) -> ~str {\n }\n \n /// Returns a string with leading and trailing whitespace removed\n-pure fn trim(s: &str) -> ~str { trim_left(trim_right(s)) }\n+pub pure fn trim(s: &str) -> ~str { trim_left(trim_right(s)) }\n \n /*\n Section: Transforming strings\n@@ -448,27 +339,27 @@ Section: Transforming strings\n  *\n  * The result vector is not null-terminated.\n  */\n-pure fn to_bytes(s: &str) -> ~[u8] unsafe {\n+pub pure fn to_bytes(s: &str) -> ~[u8] unsafe {\n     let mut v: ~[u8] = ::cast::transmute(from_slice(s));\n-    vec::raw::set_len(v, len(s));\n+    vec::raw::set_len(&mut v, len(s));\n     move v\n }\n \n /// Work with the string as a byte slice, not including trailing null.\n #[inline(always)]\n-pure fn byte_slice<T>(s: &str, f: fn(v: &[u8]) -> T) -> T {\n+pub pure fn byte_slice<T>(s: &str, f: fn(v: &[u8]) -> T) -> T {\n     do as_buf(s) |p,n| {\n-        unsafe { vec::raw::form_slice(p, n-1u, f) }\n+        unsafe { vec::raw::buf_as_slice(p, n-1u, f) }\n     }\n }\n \n /// Convert a string to a vector of characters\n-pure fn chars(s: &str) -> ~[char] {\n-    let mut buf = ~[], i = 0u;\n+pub pure fn chars(s: &str) -> ~[char] {\n+    let mut buf = ~[], i = 0;\n     let len = len(s);\n     while i < len {\n         let {ch, next} = char_range_at(s, i);\n-        unsafe { vec::push(buf, ch); }\n+        unsafe { buf.push(ch); }\n         i = next;\n     }\n     move buf\n@@ -480,7 +371,7 @@ pure fn chars(s: &str) -> ~[char] {\n  * Returns a string containing `n` characters starting at byte offset\n  * `begin`.\n  */\n-pure fn substr(s: &str, begin: uint, n: uint) -> ~str {\n+pub pure fn substr(s: &str, begin: uint, n: uint) -> ~str {\n     slice(s, begin, begin + count_bytes(s, begin, n))\n }\n \n@@ -490,7 +381,7 @@ pure fn substr(s: &str, begin: uint, n: uint) -> ~str {\n  * Fails when `begin` and `end` do not point to valid characters or\n  * beyond the last character of the string\n  */\n-pure fn slice(s: &str, begin: uint, end: uint) -> ~str {\n+pub pure fn slice(s: &str, begin: uint, end: uint) -> ~str {\n     assert is_char_boundary(s, begin);\n     assert is_char_boundary(s, end);\n     unsafe { raw::slice_bytes(s, begin, end) }\n@@ -502,14 +393,14 @@ pure fn slice(s: &str, begin: uint, end: uint) -> ~str {\n  * Fails when `begin` and `end` do not point to valid characters or beyond\n  * the last character of the string\n  */\n-pure fn view(s: &a/str, begin: uint, end: uint) -> &a/str {\n+pub pure fn view(s: &a/str, begin: uint, end: uint) -> &a/str {\n     assert is_char_boundary(s, begin);\n     assert is_char_boundary(s, end);\n     unsafe { raw::view_bytes(s, begin, end) }\n }\n \n /// Splits a string into substrings at each occurrence of a given character\n-pure fn split_char(s: &str, sep: char) -> ~[~str] {\n+pub pure fn split_char(s: &str, sep: char) -> ~[~str] {\n     split_char_inner(s, sep, len(s), true)\n }\n \n@@ -519,12 +410,12 @@ pure fn split_char(s: &str, sep: char) -> ~[~str] {\n  *\n  * The byte must be a valid UTF-8/ASCII byte\n  */\n-pure fn splitn_char(s: &str, sep: char, count: uint) -> ~[~str] {\n+pub pure fn splitn_char(s: &str, sep: char, count: uint) -> ~[~str] {\n     split_char_inner(s, sep, count, true)\n }\n \n /// Like `split_char`, but omits empty strings from the returned vector\n-pure fn split_char_nonempty(s: &str, sep: char) -> ~[~str] {\n+pub pure fn split_char_nonempty(s: &str, sep: char) -> ~[~str] {\n     split_char_inner(s, sep, len(s), false)\n }\n \n@@ -537,16 +428,15 @@ pure fn split_char_inner(s: &str, sep: char, count: uint, allow_empty: bool)\n         while i < l && done < count {\n             if s[i] == b {\n                 if allow_empty || start < i unsafe {\n-                    vec::push(result,\n-                              unsafe { raw::slice_bytes(s, start, i) });\n+                    result.push(unsafe { raw::slice_bytes(s, start, i) });\n                 }\n                 start = i + 1u;\n                 done += 1u;\n             }\n             i += 1u;\n         }\n         if allow_empty || start < l {\n-            unsafe { vec::push(result, raw::slice_bytes(s, start, l) ) };\n+            unsafe { result.push(raw::slice_bytes(s, start, l) ) };\n         }\n         move result\n     } else {\n@@ -556,20 +446,20 @@ pure fn split_char_inner(s: &str, sep: char, count: uint, allow_empty: bool)\n \n \n /// Splits a string into substrings using a character function\n-pure fn split(s: &str, sepfn: fn(char) -> bool) -> ~[~str] {\n+pub pure fn split(s: &str, sepfn: fn(char) -> bool) -> ~[~str] {\n     split_inner(s, sepfn, len(s), true)\n }\n \n /**\n  * Splits a string into substrings using a character function, cutting at\n  * most `count` times.\n  */\n-pure fn splitn(s: &str, sepfn: fn(char) -> bool, count: uint) -> ~[~str] {\n+pub pure fn splitn(s: &str, sepfn: fn(char) -> bool, count: uint) -> ~[~str] {\n     split_inner(s, sepfn, count, true)\n }\n \n /// Like `split`, but omits empty strings from the returned vector\n-pure fn split_nonempty(s: &str, sepfn: fn(char) -> bool) -> ~[~str] {\n+pub pure fn split_nonempty(s: &str, sepfn: fn(char) -> bool) -> ~[~str] {\n     split_inner(s, sepfn, len(s), false)\n }\n \n@@ -581,15 +471,15 @@ pure fn split_inner(s: &str, sepfn: fn(cc: char) -> bool, count: uint,\n         let {ch, next} = char_range_at(s, i);\n         if sepfn(ch) {\n             if allow_empty || start < i unsafe {\n-                vec::push(result, unsafe { raw::slice_bytes(s, start, i)});\n+                result.push(unsafe { raw::slice_bytes(s, start, i)});\n             }\n             start = next;\n             done += 1u;\n         }\n         i = next;\n     }\n     if allow_empty || start < l unsafe {\n-        vec::push(result, unsafe { raw::slice_bytes(s, start, l) });\n+        result.push(unsafe { raw::slice_bytes(s, start, l) });\n     }\n     move result\n }\n@@ -640,19 +530,19 @@ pure fn iter_between_matches(s: &a/str, sep: &b/str, f: fn(uint, uint)) {\n  * assert [\"\", \"XXX\", \"YYY\", \"\"] == split_str(\".XXX.YYY.\", \".\")\n  * ~~~\n  */\n-pure fn split_str(s: &a/str, sep: &b/str) -> ~[~str] {\n+pub pure fn split_str(s: &a/str, sep: &b/str) -> ~[~str] {\n     let mut result = ~[];\n     do iter_between_matches(s, sep) |from, to| {\n-        unsafe { vec::push(result, raw::slice_bytes(s, from, to)); }\n+        unsafe { result.push(raw::slice_bytes(s, from, to)); }\n     }\n     move result\n }\n \n-pure fn split_str_nonempty(s: &a/str, sep: &b/str) -> ~[~str] {\n+pub pure fn split_str_nonempty(s: &a/str, sep: &b/str) -> ~[~str] {\n     let mut result = ~[];\n     do iter_between_matches(s, sep) |from, to| {\n         if to > from {\n-            unsafe { vec::push(result, raw::slice_bytes(s, from, to)); }\n+            unsafe { result.push(raw::slice_bytes(s, from, to)); }\n         }\n     }\n     move result\n@@ -661,13 +551,13 @@ pure fn split_str_nonempty(s: &a/str, sep: &b/str) -> ~[~str] {\n /**\n  * Splits a string into a vector of the substrings separated by LF ('\\n')\n  */\n-pure fn lines(s: &str) -> ~[~str] { split_char(s, '\\n') }\n+pub pure fn lines(s: &str) -> ~[~str] { split_char(s, '\\n') }\n \n /**\n  * Splits a string into a vector of the substrings separated by LF ('\\n')\n  * and/or CR LF (\"\\r\\n\")\n  */\n-pure fn lines_any(s: &str) -> ~[~str] {\n+pub pure fn lines_any(s: &str) -> ~[~str] {\n     vec::map(lines(s), |s| {\n         let l = len(*s);\n         let mut cp = copy *s;\n@@ -679,19 +569,19 @@ pure fn lines_any(s: &str) -> ~[~str] {\n }\n \n /// Splits a string into a vector of the substrings separated by whitespace\n-pure fn words(s: &str) -> ~[~str] {\n+pub pure fn words(s: &str) -> ~[~str] {\n     split_nonempty(s, |c| char::is_whitespace(c))\n }\n \n /// Convert a string to lowercase. ASCII only\n-pure fn to_lower(s: &str) -> ~str {\n+pub pure fn to_lower(s: &str) -> ~str {\n     map(s,\n         |c| unsafe{(libc::tolower(c as libc::c_char)) as char}\n     )\n }\n \n /// Convert a string to uppercase. ASCII only\n-pure fn to_upper(s: &str) -> ~str {\n+pub pure fn to_upper(s: &str) -> ~str {\n     map(s,\n         |c| unsafe{(libc::toupper(c as libc::c_char)) as char}\n     )\n@@ -710,7 +600,7 @@ pure fn to_upper(s: &str) -> ~str {\n  *\n  * The original string with all occurances of `from` replaced with `to`\n  */\n-pure fn replace(s: &str, from: &str, to: &str) -> ~str {\n+pub pure fn replace(s: &str, from: &str, to: &str) -> ~str {\n     let mut result = ~\"\", first = true;\n     do iter_between_matches(s, from) |start, end| {\n         if first {\n@@ -730,7 +620,7 @@ Section: Comparing strings\n /// Bytewise slice equality\n #[cfg(notest)]\n #[lang=\"str_eq\"]\n-pure fn eq_slice(a: &str, b: &str) -> bool {\n+pub pure fn eq_slice(a: &str, b: &str) -> bool {\n     do as_buf(a) |ap, alen| {\n         do as_buf(b) |bp, blen| {\n             if (alen != blen) { false }\n@@ -746,7 +636,7 @@ pure fn eq_slice(a: &str, b: &str) -> bool {\n }\n \n #[cfg(test)]\n-pure fn eq_slice(a: &str, b: &str) -> bool {\n+pub pure fn eq_slice(a: &str, b: &str) -> bool {\n     do as_buf(a) |ap, alen| {\n         do as_buf(b) |bp, blen| {\n             if (alen != blen) { false }\n@@ -764,12 +654,12 @@ pure fn eq_slice(a: &str, b: &str) -> bool {\n /// Bytewise string equality\n #[cfg(notest)]\n #[lang=\"uniq_str_eq\"]\n-pure fn eq(a: &~str, b: &~str) -> bool {\n+pub pure fn eq(a: &~str, b: &~str) -> bool {\n     eq_slice(*a, *b)\n }\n \n #[cfg(test)]\n-pure fn eq(a: &~str, b: &~str) -> bool {\n+pub pure fn eq(a: &~str, b: &~str) -> bool {\n     eq_slice(*a, *b)\n }\n \n@@ -790,7 +680,7 @@ pure fn lt(a: &str, b: &str) -> bool {\n }\n \n /// Bytewise less than or equal\n-pure fn le(a: &str, b: &str) -> bool {\n+pub pure fn le(a: &str, b: &str) -> bool {\n     !lt(b, a)\n }\n \n@@ -872,20 +762,20 @@ Section: Iterating through strings\n  * Return true if a predicate matches all characters or if the string\n  * contains no characters\n  */\n-pure fn all(s: &str, it: fn(char) -> bool) -> bool {\n+pub pure fn all(s: &str, it: fn(char) -> bool) -> bool {\n     all_between(s, 0u, len(s), it)\n }\n \n /**\n  * Return true if a predicate matches any character (and false if it\n  * matches none or there are no characters)\n  */\n-pure fn any(ss: &str, pred: fn(char) -> bool) -> bool {\n+pub pure fn any(ss: &str, pred: fn(char) -> bool) -> bool {\n     !all(ss, |cc| !pred(cc))\n }\n \n /// Apply a function to each character\n-pure fn map(ss: &str, ff: fn(char) -> char) -> ~str {\n+pub pure fn map(ss: &str, ff: fn(char) -> char) -> ~str {\n     let mut result = ~\"\";\n     unsafe {\n         reserve(&mut result, len(ss));\n@@ -897,7 +787,7 @@ pure fn map(ss: &str, ff: fn(char) -> char) -> ~str {\n }\n \n /// Iterate over the bytes in a string\n-pure fn bytes_each(ss: &str, it: fn(u8) -> bool) {\n+pub pure fn bytes_each(ss: &str, it: fn(u8) -> bool) {\n     let mut pos = 0u;\n     let len = len(ss);\n \n@@ -909,13 +799,13 @@ pure fn bytes_each(ss: &str, it: fn(u8) -> bool) {\n \n /// Iterate over the bytes in a string\n #[inline(always)]\n-pure fn each(s: &str, it: fn(u8) -> bool) {\n+pub pure fn each(s: &str, it: fn(u8) -> bool) {\n     eachi(s, |_i, b| it(b) )\n }\n \n /// Iterate over the bytes in a string, with indices\n #[inline(always)]\n-pure fn eachi(s: &str, it: fn(uint, u8) -> bool) {\n+pub pure fn eachi(s: &str, it: fn(uint, u8) -> bool) {\n     let mut i = 0u, l = len(s);\n     while (i < l) {\n         if !it(i, s[i]) { break; }\n@@ -925,13 +815,13 @@ pure fn eachi(s: &str, it: fn(uint, u8) -> bool) {\n \n /// Iterates over the chars in a string\n #[inline(always)]\n-pure fn each_char(s: &str, it: fn(char) -> bool) {\n+pub pure fn each_char(s: &str, it: fn(char) -> bool) {\n     each_chari(s, |_i, c| it(c))\n }\n \n /// Iterates over the chars in a string, with indices\n #[inline(always)]\n-pure fn each_chari(s: &str, it: fn(uint, char) -> bool) {\n+pub pure fn each_chari(s: &str, it: fn(uint, char) -> bool) {\n     let mut pos = 0u, ch_pos = 0u;\n     let len = len(s);\n     while pos < len {\n@@ -943,7 +833,7 @@ pure fn each_chari(s: &str, it: fn(uint, char) -> bool) {\n }\n \n /// Iterate over the characters in a string\n-pure fn chars_each(s: &str, it: fn(char) -> bool) {\n+pub pure fn chars_each(s: &str, it: fn(char) -> bool) {\n     let mut pos = 0u;\n     let len = len(s);\n     while (pos < len) {\n@@ -954,28 +844,28 @@ pure fn chars_each(s: &str, it: fn(char) -> bool) {\n }\n \n /// Apply a function to each substring after splitting by character\n-pure fn split_char_each(ss: &str, cc: char, ff: fn(v: &str) -> bool) {\n+pub pure fn split_char_each(ss: &str, cc: char, ff: fn(v: &str) -> bool) {\n     vec::each(split_char(ss, cc), |s| ff(*s))\n }\n \n /**\n  * Apply a function to each substring after splitting by character, up to\n  * `count` times\n  */\n-pure fn splitn_char_each(ss: &str, sep: char, count: uint,\n+pub pure fn splitn_char_each(ss: &str, sep: char, count: uint,\n                          ff: fn(v: &str) -> bool) {\n     vec::each(splitn_char(ss, sep, count), |s| ff(*s))\n }\n \n /// Apply a function to each word\n-pure fn words_each(ss: &str, ff: fn(v: &str) -> bool) {\n+pub pure fn words_each(ss: &str, ff: fn(v: &str) -> bool) {\n     vec::each(words(ss), |s| ff(*s))\n }\n \n /**\n  * Apply a function to each line (by '\\n')\n  */\n-pure fn lines_each(ss: &str, ff: fn(v: &str) -> bool) {\n+pub pure fn lines_each(ss: &str, ff: fn(v: &str) -> bool) {\n     vec::each(lines(ss), |s| ff(*s))\n }\n \n@@ -996,7 +886,7 @@ Section: Searching\n  * An `option` containing the byte index of the first matching character\n  * or `none` if there is no match\n  */\n-pure fn find_char(s: &str, c: char) -> Option<uint> {\n+pub pure fn find_char(s: &str, c: char) -> Option<uint> {\n     find_char_between(s, c, 0u, len(s))\n }\n \n@@ -1020,7 +910,7 @@ pure fn find_char(s: &str, c: char) -> Option<uint> {\n  * `start` must be less than or equal to `len(s)`. `start` must be the\n  * index of a character boundary, as defined by `is_char_boundary`.\n  */\n-pure fn find_char_from(s: &str, c: char, start: uint) -> Option<uint> {\n+pub pure fn find_char_from(s: &str, c: char, start: uint) -> Option<uint> {\n     find_char_between(s, c, start, len(s))\n }\n \n@@ -1045,7 +935,7 @@ pure fn find_char_from(s: &str, c: char, start: uint) -> Option<uint> {\n  * or equal to `len(s)`. `start` must be the index of a character boundary,\n  * as defined by `is_char_boundary`.\n  */\n-pure fn find_char_between(s: &str, c: char, start: uint, end: uint)\n+pub pure fn find_char_between(s: &str, c: char, start: uint, end: uint)\n     -> Option<uint> {\n     if c < 128u as char {\n         assert start <= end;\n@@ -1075,7 +965,7 @@ pure fn find_char_between(s: &str, c: char, start: uint, end: uint)\n  * An `option` containing the byte index of the last matching character\n  * or `none` if there is no match\n  */\n-pure fn rfind_char(s: &str, c: char) -> Option<uint> {\n+pub pure fn rfind_char(s: &str, c: char) -> Option<uint> {\n     rfind_char_between(s, c, len(s), 0u)\n }\n \n@@ -1099,7 +989,7 @@ pure fn rfind_char(s: &str, c: char) -> Option<uint> {\n  * `start` must be less than or equal to `len(s)`. `start` must be\n  * the index of a character boundary, as defined by `is_char_boundary`.\n  */\n-pure fn rfind_char_from(s: &str, c: char, start: uint) -> Option<uint> {\n+pub pure fn rfind_char_from(s: &str, c: char, start: uint) -> Option<uint> {\n     rfind_char_between(s, c, start, 0u)\n }\n \n@@ -1124,7 +1014,7 @@ pure fn rfind_char_from(s: &str, c: char, start: uint) -> Option<uint> {\n  * or equal to `len(s)`. `start` must be the index of a character boundary,\n  * as defined by `is_char_boundary`.\n  */\n-pure fn rfind_char_between(s: &str, c: char, start: uint, end: uint)\n+pub pure fn rfind_char_between(s: &str, c: char, start: uint, end: uint)\n     -> Option<uint> {\n     if c < 128u as char {\n         assert start >= end;\n@@ -1155,7 +1045,7 @@ pure fn rfind_char_between(s: &str, c: char, start: uint, end: uint)\n  * An `option` containing the byte index of the first matching character\n  * or `none` if there is no match\n  */\n-pure fn find(s: &str, f: fn(char) -> bool) -> Option<uint> {\n+pub pure fn find(s: &str, f: fn(char) -> bool) -> Option<uint> {\n     find_between(s, 0u, len(s), f)\n }\n \n@@ -1179,7 +1069,7 @@ pure fn find(s: &str, f: fn(char) -> bool) -> Option<uint> {\n  * `start` must be less than or equal to `len(s)`. `start` must be the\n  * index of a character boundary, as defined by `is_char_boundary`.\n  */\n-pure fn find_from(s: &str, start: uint, f: fn(char)\n+pub pure fn find_from(s: &str, start: uint, f: fn(char)\n     -> bool) -> Option<uint> {\n     find_between(s, start, len(s), f)\n }\n@@ -1206,7 +1096,7 @@ pure fn find_from(s: &str, start: uint, f: fn(char)\n  * or equal to `len(s)`. `start` must be the index of a character\n  * boundary, as defined by `is_char_boundary`.\n  */\n-pure fn find_between(s: &str, start: uint, end: uint, f: fn(char) -> bool)\n+pub pure fn find_between(s: &str, start: uint, end: uint, f: fn(char) -> bool)\n     -> Option<uint> {\n     assert start <= end;\n     assert end <= len(s);\n@@ -1234,7 +1124,7 @@ pure fn find_between(s: &str, start: uint, end: uint, f: fn(char) -> bool)\n  * An option containing the byte index of the last matching character\n  * or `none` if there is no match\n  */\n-pure fn rfind(s: &str, f: fn(char) -> bool) -> Option<uint> {\n+pub pure fn rfind(s: &str, f: fn(char) -> bool) -> Option<uint> {\n     rfind_between(s, len(s), 0u, f)\n }\n \n@@ -1258,7 +1148,7 @@ pure fn rfind(s: &str, f: fn(char) -> bool) -> Option<uint> {\n  * `start` must be less than or equal to `len(s)', `start` must be the\n  * index of a character boundary, as defined by `is_char_boundary`\n  */\n-pure fn rfind_from(s: &str, start: uint, f: fn(char) -> bool)\n+pub pure fn rfind_from(s: &str, start: uint, f: fn(char) -> bool)\n     -> Option<uint> {\n     rfind_between(s, start, 0u, f)\n }\n@@ -1285,7 +1175,8 @@ pure fn rfind_from(s: &str, start: uint, f: fn(char) -> bool)\n  * than or equal to `len(s)`. `start` must be the index of a character\n  * boundary, as defined by `is_char_boundary`\n  */\n-pure fn rfind_between(s: &str, start: uint, end: uint, f: fn(char) -> bool)\n+pub pure fn rfind_between(s: &str, start: uint, end: uint,\n+                          f: fn(char) -> bool)\n     -> Option<uint> {\n     assert start >= end;\n     assert start <= len(s);\n@@ -1319,7 +1210,7 @@ pure fn match_at(haystack: &a/str, needle: &b/str, at: uint) -> bool {\n  * An `option` containing the byte index of the first matching substring\n  * or `none` if there is no match\n  */\n-pure fn find_str(haystack: &a/str, needle: &b/str) -> Option<uint> {\n+pub pure fn find_str(haystack: &a/str, needle: &b/str) -> Option<uint> {\n     find_str_between(haystack, needle, 0u, len(haystack))\n }\n \n@@ -1342,7 +1233,7 @@ pure fn find_str(haystack: &a/str, needle: &b/str) -> Option<uint> {\n  *\n  * `start` must be less than or equal to `len(s)`\n  */\n-pure fn find_str_from(haystack: &a/str, needle: &b/str, start: uint)\n+pub pure fn find_str_from(haystack: &a/str, needle: &b/str, start: uint)\n   -> Option<uint> {\n     find_str_between(haystack, needle, start, len(haystack))\n }\n@@ -1367,7 +1258,7 @@ pure fn find_str_from(haystack: &a/str, needle: &b/str, start: uint)\n  * `start` must be less than or equal to `end` and `end` must be less than\n  * or equal to `len(s)`.\n  */\n-pure fn find_str_between(haystack: &a/str, needle: &b/str, start: uint,\n+pub pure fn find_str_between(haystack: &a/str, needle: &b/str, start: uint,\n                          end:uint)\n   -> Option<uint> {\n     // See Issue #1932 for why this is a naive search\n@@ -1393,7 +1284,7 @@ pure fn find_str_between(haystack: &a/str, needle: &b/str, start: uint,\n  * * haystack - The string to look in\n  * * needle - The string to look for\n  */\n-pure fn contains(haystack: &a/str, needle: &b/str) -> bool {\n+pub pure fn contains(haystack: &a/str, needle: &b/str) -> bool {\n     find_str(haystack, needle).is_some()\n }\n \n@@ -1405,7 +1296,7 @@ pure fn contains(haystack: &a/str, needle: &b/str) -> bool {\n  * * haystack - The string to look in\n  * * needle - The char to look for\n  */\n-pure fn contains_char(haystack: &str, needle: char) -> bool {\n+pub pure fn contains_char(haystack: &str, needle: char) -> bool {\n     find_char(haystack, needle).is_some()\n }\n \n@@ -1417,7 +1308,7 @@ pure fn contains_char(haystack: &str, needle: char) -> bool {\n  * * haystack - The string to look in\n  * * needle - The string to look for\n  */\n-pure fn starts_with(haystack: &a/str, needle: &b/str) -> bool {\n+pub pure fn starts_with(haystack: &a/str, needle: &b/str) -> bool {\n     let haystack_len = len(haystack), needle_len = len(needle);\n     if needle_len == 0u { true }\n     else if needle_len > haystack_len { false }\n@@ -1432,7 +1323,7 @@ pure fn starts_with(haystack: &a/str, needle: &b/str) -> bool {\n  * * haystack - The string to look in\n  * * needle - The string to look for\n  */\n-pure fn ends_with(haystack: &a/str, needle: &b/str) -> bool {\n+pub pure fn ends_with(haystack: &a/str, needle: &b/str) -> bool {\n     let haystack_len = len(haystack), needle_len = len(needle);\n     if needle_len == 0u { true }\n     else if needle_len > haystack_len { false }\n@@ -1444,24 +1335,24 @@ Section: String properties\n */\n \n /// Determines if a string contains only ASCII characters\n-pure fn is_ascii(s: &str) -> bool {\n+pub pure fn is_ascii(s: &str) -> bool {\n     let mut i: uint = len(s);\n     while i > 0u { i -= 1u; if !u8::is_ascii(s[i]) { return false; } }\n     return true;\n }\n \n /// Returns true if the string has length 0\n-pure fn is_empty(s: &str) -> bool { len(s) == 0u }\n+pub pure fn is_empty(s: &str) -> bool { len(s) == 0u }\n \n /// Returns true if the string has length greater than 0\n-pure fn is_not_empty(s: &str) -> bool { !is_empty(s) }\n+pub pure fn is_not_empty(s: &str) -> bool { !is_empty(s) }\n \n /**\n  * Returns true if the string contains only whitespace\n  *\n  * Whitespace characters are determined by `char::is_whitespace`\n  */\n-pure fn is_whitespace(s: &str) -> bool {\n+pub pure fn is_whitespace(s: &str) -> bool {\n     return all(s, char::is_whitespace);\n }\n \n@@ -1475,19 +1366,19 @@ fn is_alphanumeric(s: &str) -> bool {\n }\n \n /// Returns the string length/size in bytes not counting the null terminator\n-pure fn len(s: &str) -> uint {\n+pub pure fn len(s: &str) -> uint {\n     do as_buf(s) |_p, n| { n - 1u }\n }\n \n /// Returns the number of characters that a string holds\n-pure fn char_len(s: &str) -> uint { count_chars(s, 0u, len(s)) }\n+pub pure fn char_len(s: &str) -> uint { count_chars(s, 0u, len(s)) }\n \n /*\n Section: Misc\n */\n \n /// Determines if a vector of bytes contains valid UTF-8\n-pure fn is_utf8(v: &[const u8]) -> bool {\n+pub pure fn is_utf8(v: &[const u8]) -> bool {\n     let mut i = 0u;\n     let total = vec::len::<u8>(v);\n     while i < total {\n@@ -1505,7 +1396,7 @@ pure fn is_utf8(v: &[const u8]) -> bool {\n }\n \n /// Determines if a vector of `u16` contains valid UTF-16\n-pure fn is_utf16(v: &[u16]) -> bool {\n+pub pure fn is_utf16(v: &[u16]) -> bool {\n     let len = vec::len(v);\n     let mut i = 0u;\n     while (i < len) {\n@@ -1526,7 +1417,7 @@ pure fn is_utf16(v: &[u16]) -> bool {\n }\n \n /// Converts to a vector of `u16` encoded as UTF-16\n-pure fn to_utf16(s: &str) -> ~[u16] {\n+pub pure fn to_utf16(s: &str) -> ~[u16] {\n     let mut u = ~[];\n     for chars_each(s) |cch| {\n         // Arithmetic with u32 literals is easier on the eyes than chars.\n@@ -1535,20 +1426,20 @@ pure fn to_utf16(s: &str) -> ~[u16] {\n         if (ch & 0xFFFF_u32) == ch unsafe {\n             // The BMP falls through (assuming non-surrogate, as it should)\n             assert ch <= 0xD7FF_u32 || ch >= 0xE000_u32;\n-            vec::push(u, ch as u16)\n+            u.push(ch as u16)\n         } else unsafe {\n             // Supplementary planes break into surrogates.\n             assert ch >= 0x1_0000_u32 && ch <= 0x10_FFFF_u32;\n             ch -= 0x1_0000_u32;\n             let w1 = 0xD800_u16 | ((ch >> 10) as u16);\n             let w2 = 0xDC00_u16 | ((ch as u16) & 0x3FF_u16);\n-            vec::push_all(u, ~[w1, w2])\n+            u.push_all(~[w1, w2])\n         }\n     }\n     move u\n }\n \n-pure fn utf16_chars(v: &[u16], f: fn(char)) {\n+pub pure fn utf16_chars(v: &[u16], f: fn(char)) {\n     let len = vec::len(v);\n     let mut i = 0u;\n     while (i < len && v[i] != 0u16) {\n@@ -1573,7 +1464,7 @@ pure fn utf16_chars(v: &[u16], f: fn(char)) {\n }\n \n \n-pure fn from_utf16(v: &[u16]) -> ~str {\n+pub pure fn from_utf16(v: &[u16]) -> ~str {\n     let mut buf = ~\"\";\n     unsafe {\n         reserve(&mut buf, vec::len(v));\n@@ -1596,7 +1487,7 @@ pure fn from_utf16(v: &[u16]) -> ~str {\n  *\n  * The number of Unicode characters in `s` between the given indices.\n  */\n-pure fn count_chars(s: &str, start: uint, end: uint) -> uint {\n+pub pure fn count_chars(s: &str, start: uint, end: uint) -> uint {\n     assert is_char_boundary(s, start);\n     assert is_char_boundary(s, end);\n     let mut i = start, len = 0u;\n@@ -1609,7 +1500,7 @@ pure fn count_chars(s: &str, start: uint, end: uint) -> uint {\n }\n \n /// Counts the number of bytes taken by the `n` in `s` starting from `start`.\n-pure fn count_bytes(s: &b/str, start: uint, n: uint) -> uint {\n+pub pure fn count_bytes(s: &b/str, start: uint, n: uint) -> uint {\n     assert is_char_boundary(s, start);\n     let mut end = start, cnt = n;\n     let l = len(s);\n@@ -1623,7 +1514,7 @@ pure fn count_bytes(s: &b/str, start: uint, n: uint) -> uint {\n }\n \n /// Given a first byte, determine how many bytes are in this UTF-8 character\n-pure fn utf8_char_width(b: u8) -> uint {\n+pub pure fn utf8_char_width(b: u8) -> uint {\n     let byte: uint = b as uint;\n     if byte < 128u { return 1u; }\n     // Not a valid start byte\n@@ -1639,7 +1530,7 @@ pure fn utf8_char_width(b: u8) -> uint {\n  * Returns false if the index points into the middle of a multi-byte\n  * character sequence.\n  */\n-pure fn is_char_boundary(s: &str, index: uint) -> bool {\n+pub pure fn is_char_boundary(s: &str, index: uint) -> bool {\n     if index == len(s) { return true; }\n     let b = s[index];\n     return b < 128u8 || b >= 192u8;\n@@ -1694,7 +1585,7 @@ pure fn is_char_boundary(s: &str, index: uint) -> bool {\n  * If `i` is greater than or equal to the length of the string.\n  * If `i` is not the index of the beginning of a valid UTF-8 character.\n  */\n-pure fn char_range_at(s: &str, i: uint) -> {ch: char, next: uint} {\n+pub pure fn char_range_at(s: &str, i: uint) -> {ch: char, next: uint} {\n     let b0 = s[i];\n     let w = utf8_char_width(b0);\n     assert (w != 0u);\n@@ -1717,7 +1608,9 @@ pure fn char_range_at(s: &str, i: uint) -> {ch: char, next: uint} {\n }\n \n /// Pluck a character out of a string\n-pure fn char_at(s: &str, i: uint) -> char { return char_range_at(s, i).ch; }\n+pub pure fn char_at(s: &str, i: uint) -> char {\n+    return char_range_at(s, i).ch;\n+}\n \n /**\n  * Given a byte position and a str, return the previous char and its position\n@@ -1763,7 +1656,7 @@ pure fn char_range_at_reverse(ss: &str, start: uint)\n  * `true` If execution proceeded correctly, `false` if it was interrupted,\n  * that is if `it` returned `false` at any point.\n  */\n-pure fn all_between(s: &str, start: uint, end: uint,\n+pub pure fn all_between(s: &str, start: uint, end: uint,\n                     it: fn(char) -> bool) -> bool {\n     assert is_char_boundary(s, start);\n     let mut i = start;\n@@ -1796,7 +1689,7 @@ pure fn all_between(s: &str, start: uint, end: uint,\n  *\n  * `true` if `it` returns `true` for any character\n  */\n-pure fn any_between(s: &str, start: uint, end: uint,\n+pub pure fn any_between(s: &str, start: uint, end: uint,\n                     it: fn(char) -> bool) -> bool {\n     !all_between(s, start, end, |c| !it(c))\n }\n@@ -1828,10 +1721,10 @@ const tag_six_b: uint = 252u;\n  * let i = str::as_bytes(\"Hello World\") { |bytes| vec::len(bytes) };\n  * ~~~\n  */\n-pure fn as_bytes<T>(s: &const ~str, f: fn(~[u8]) -> T) -> T {\n+pub pure fn as_bytes<T>(s: &const ~str, f: fn((&~[u8])) -> T) -> T {\n     unsafe {\n         let v: *~[u8] = cast::transmute(copy s);\n-        f(*v)\n+        f(&*v)\n     }\n }\n \n@@ -1840,7 +1733,7 @@ pure fn as_bytes<T>(s: &const ~str, f: fn(~[u8]) -> T) -> T {\n  *\n  * The byte slice does not include the null terminator.\n  */\n-pure fn as_bytes_slice(s: &a/str) -> &a/[u8] {\n+pub pure fn as_bytes_slice(s: &a/str) -> &a/[u8] {\n     unsafe {\n         let (ptr, len): (*u8, uint) = ::cast::reinterpret_cast(&s);\n         let outgoing_tuple: (*u8, uint) = (ptr, len - 1);\n@@ -1863,7 +1756,7 @@ pure fn as_bytes_slice(s: &a/str) -> &a/[u8] {\n  * let s = str::as_c_str(\"PATH\", { |path| libc::getenv(path) });\n  * ~~~\n  */\n-pure fn as_c_str<T>(s: &str, f: fn(*libc::c_char) -> T) -> T {\n+pub pure fn as_c_str<T>(s: &str, f: fn(*libc::c_char) -> T) -> T {\n     do as_buf(s) |buf, len| {\n         // NB: len includes the trailing null.\n         assert len > 0;\n@@ -1885,9 +1778,9 @@ pure fn as_c_str<T>(s: &str, f: fn(*libc::c_char) -> T) -> T {\n  * to full strings, or suffixes of them.\n  */\n #[inline(always)]\n-pure fn as_buf<T>(s: &str, f: fn(*u8, uint) -> T) -> T {\n+pub pure fn as_buf<T>(s: &str, f: fn(*u8, uint) -> T) -> T {\n     unsafe {\n-        let v : *(*u8,uint) = ::cast::reinterpret_cast(&ptr::addr_of(s));\n+        let v : *(*u8,uint) = ::cast::reinterpret_cast(&ptr::addr_of(&s));\n         let (buf,len) = *v;\n         f(buf, len)\n     }\n@@ -1909,7 +1802,7 @@ pure fn as_buf<T>(s: &str, f: fn(*u8, uint) -> T) -> T {\n  * * s - A string\n  * * n - The number of bytes to reserve space for\n  */\n-fn reserve(s: &const ~str, n: uint) {\n+pub fn reserve(s: &const ~str, n: uint) {\n     unsafe {\n         let v: *mut ~[u8] = cast::transmute(copy s);\n         vec::reserve(&mut *v, n + 1);\n@@ -1936,15 +1829,15 @@ fn reserve(s: &const ~str, n: uint) {\n  * * s - A string\n  * * n - The number of bytes to reserve space for\n  */\n-fn reserve_at_least(s: &const ~str, n: uint) {\n+pub fn reserve_at_least(s: &const ~str, n: uint) {\n     reserve(s, uint::next_power_of_two(n + 1u) - 1u)\n }\n \n /**\n  * Returns the number of single-byte characters the string can hold without\n  * reallocating\n  */\n-pure fn capacity(s: &const ~str) -> uint {\n+pub pure fn capacity(s: &const ~str) -> uint {\n     do as_bytes(s) |buf| {\n         let vcap = vec::capacity(buf);\n         assert vcap > 0u;\n@@ -1953,7 +1846,7 @@ pure fn capacity(s: &const ~str) -> uint {\n }\n \n /// Escape each char in `s` with char::escape_default.\n-pure fn escape_default(s: &str) -> ~str {\n+pub pure fn escape_default(s: &str) -> ~str {\n     let mut out: ~str = ~\"\";\n     unsafe {\n         reserve_at_least(&mut out, str::len(s));\n@@ -1965,7 +1858,7 @@ pure fn escape_default(s: &str) -> ~str {\n }\n \n /// Escape each char in `s` with char::escape_unicode.\n-pure fn escape_unicode(s: &str) -> ~str {\n+pub pure fn escape_unicode(s: &str) -> ~str {\n     let mut out: ~str = ~\"\";\n     unsafe {\n         reserve_at_least(&mut out, str::len(s));\n@@ -1977,24 +1870,10 @@ pure fn escape_unicode(s: &str) -> ~str {\n }\n \n /// Unsafe operations\n-mod raw {\n-    #[legacy_exports];\n-   export\n-      from_buf,\n-      from_buf_len,\n-      from_c_str,\n-      from_c_str_len,\n-      from_bytes,\n-      buf_as_slice,\n-      slice_bytes,\n-      view_bytes,\n-      push_byte,\n-      pop_byte,\n-      shift_byte,\n-      set_len;\n+pub mod raw {\n \n     /// Create a Rust string from a null-terminated *u8 buffer\n-    unsafe fn from_buf(buf: *u8) -> ~str {\n+    pub unsafe fn from_buf(buf: *u8) -> ~str {\n         let mut curr = buf, i = 0u;\n         while *curr != 0u8 {\n             i += 1u;\n@@ -2004,41 +1883,41 @@ mod raw {\n     }\n \n     /// Create a Rust string from a *u8 buffer of the given length\n-    unsafe fn from_buf_len(buf: *const u8, len: uint) -> ~str {\n+    pub unsafe fn from_buf_len(buf: *const u8, len: uint) -> ~str {\n         let mut v: ~[u8] = vec::with_capacity(len + 1);\n         vec::as_mut_buf(v, |vbuf, _len| {\n             ptr::memcpy(vbuf, buf as *u8, len)\n         });\n-        vec::raw::set_len(v, len);\n-        vec::push(v, 0u8);\n+        vec::raw::set_len(&mut v, len);\n+        v.push(0u8);\n \n         assert is_utf8(v);\n         return ::cast::transmute(move v);\n     }\n \n     /// Create a Rust string from a null-terminated C string\n-    unsafe fn from_c_str(c_str: *libc::c_char) -> ~str {\n+    pub unsafe fn from_c_str(c_str: *libc::c_char) -> ~str {\n         from_buf(::cast::reinterpret_cast(&c_str))\n     }\n \n     /// Create a Rust string from a `*c_char` buffer of the given length\n-    unsafe fn from_c_str_len(c_str: *libc::c_char, len: uint) -> ~str {\n+    pub unsafe fn from_c_str_len(c_str: *libc::c_char, len: uint) -> ~str {\n         from_buf_len(::cast::reinterpret_cast(&c_str), len)\n     }\n \n     /// Converts a vector of bytes to a string.\n-    unsafe fn from_bytes(v: &[const u8]) -> ~str {\n+    pub pub unsafe fn from_bytes(v: &[const u8]) -> ~str {\n         do vec::as_const_buf(v) |buf, len| {\n             from_buf_len(buf, len)\n         }\n     }\n \n     /// Converts a byte to a string.\n-    unsafe fn from_byte(u: u8) -> ~str { raw::from_bytes([u]) }\n+    pub unsafe fn from_byte(u: u8) -> ~str { raw::from_bytes([u]) }\n \n     /// Form a slice from a *u8 buffer of the given length without copying.\n-    unsafe fn buf_as_slice<T>(buf: *u8, len: uint,\n-                              f: fn(&&v: &str) -> T) -> T {\n+    pub unsafe fn buf_as_slice<T>(buf: *u8, len: uint,\n+                              f: fn(v: &str) -> T) -> T {\n         let v = (buf, len + 1);\n         assert is_utf8(::cast::reinterpret_cast(&v));\n         f(::cast::transmute(move v))\n@@ -2054,7 +1933,7 @@ mod raw {\n      * If begin is greater than end.\n      * If end is greater than the length of the string.\n      */\n-    unsafe fn slice_bytes(s: &str, begin: uint, end: uint) -> ~str {\n+    pub unsafe fn slice_bytes(s: &str, begin: uint, end: uint) -> ~str {\n         do as_buf(s) |sbuf, n| {\n             assert (begin <= end);\n             assert (end <= n);\n@@ -2066,8 +1945,8 @@ mod raw {\n                     let src = ptr::offset(sbuf, begin);\n                     ptr::memcpy(vbuf, src, end - begin);\n                 }\n-                vec::raw::set_len(v, end - begin);\n-                vec::push(v, 0u8);\n+                vec::raw::set_len(&mut v, end - begin);\n+                v.push(0u8);\n                 ::cast::transmute(move v)\n             }\n         }\n@@ -2084,7 +1963,7 @@ mod raw {\n      * If end is greater than the length of the string.\n      */\n     #[inline]\n-    unsafe fn view_bytes(s: &str, begin: uint, end: uint) -> &str {\n+    pub unsafe fn view_bytes(s: &str, begin: uint, end: uint) -> &str {\n         do as_buf(s) |sbuf, n| {\n              assert (begin <= end);\n              assert (end <= n);\n@@ -2095,7 +1974,7 @@ mod raw {\n     }\n \n     /// Appends a byte to a string. (Not UTF-8 safe).\n-    unsafe fn push_byte(s: &const ~str, b: u8) {\n+    pub unsafe fn push_byte(s: &const ~str, b: u8) {\n         reserve_at_least(s, s.len() + 1);\n         do as_buf(*s) |buf, len| {\n             let buf: *mut u8 = ::cast::reinterpret_cast(&buf);\n@@ -2111,7 +1990,7 @@ mod raw {\n     }\n \n     /// Removes the last byte from a string and returns it. (Not UTF-8 safe).\n-    unsafe fn pop_byte(s: &const ~str) -> u8 {\n+    pub unsafe fn pop_byte(s: &const ~str) -> u8 {\n         let len = len(*s);\n         assert (len > 0u);\n         let b = s[len - 1u];\n@@ -2120,7 +1999,7 @@ mod raw {\n     }\n \n     /// Removes the first byte from a string and returns it. (Not UTF-8 safe).\n-    unsafe fn shift_byte(s: &mut ~str) -> u8 {\n+    pub unsafe fn shift_byte(s: &mut ~str) -> u8 {\n         let len = len(*s);\n         assert (len > 0u);\n         let b = s[0];\n@@ -2129,11 +2008,11 @@ mod raw {\n     }\n \n     /// Sets the length of the string and adds the null terminator\n-    unsafe fn set_len(v: &const ~str, new_len: uint) {\n+    pub unsafe fn set_len(v: &const ~str, new_len: uint) {\n         let v: **vec::raw::VecRepr = cast::transmute(copy v);\n         let repr: *vec::raw::VecRepr = *v;\n         (*repr).unboxed.fill = new_len + 1u;\n-        let null = ptr::mut_offset(ptr::mut_addr_of((*repr).unboxed.data),\n+        let null = ptr::mut_offset(ptr::mut_addr_of(&((*repr).unboxed.data)),\n                                    new_len);\n         *null = 0u8;\n     }\n@@ -2150,7 +2029,7 @@ mod raw {\n \n }\n \n-trait UniqueStr {\n+pub trait UniqueStr {\n     fn trim() -> self;\n     fn trim_left() -> self;\n     fn trim_right() -> self;\n@@ -2170,8 +2049,7 @@ impl ~str: UniqueStr {\n }\n \n #[cfg(notest)]\n-mod traits {\n-    #[legacy_exports];\n+pub mod traits {\n     impl ~str : Add<&str,~str> {\n         #[inline(always)]\n         pure fn add(rhs: & &str) -> ~str {\n@@ -2181,10 +2059,9 @@ mod traits {\n }\n \n #[cfg(test)]\n-mod traits {\n-    #[legacy_exports];}\n+pub mod traits {}\n \n-trait StrSlice {\n+pub trait StrSlice {\n     fn all(it: fn(char) -> bool) -> bool;\n     fn any(it: fn(char) -> bool) -> bool;\n     fn contains(needle: &a/str) -> bool;\n@@ -2327,7 +2204,6 @@ impl &str: StrSlice {\n \n #[cfg(test)]\n mod tests {\n-    #[legacy_exports];\n \n     use libc::c_char;\n "}, {"sha": "12329616fbf9fd13f1c0dad0b817acd96467e068", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 20, "deletions": 33, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -7,21 +7,10 @@\n use cmp::{Eq, Ord};\n use libc::c_void;\n \n-export FreeGlue;\n-export TypeDesc;\n-export Closure;\n-export get_type_desc;\n-export size_of;\n-export min_align_of;\n-export pref_align_of;\n-export refcount;\n-export log_str;\n-export shape_eq, shape_lt, shape_le;\n-\n-type FreeGlue = fn(*TypeDesc, *c_void);\n+pub type FreeGlue = fn(*TypeDesc, *c_void);\n \n // Corresponds to runtime type_desc type\n-enum TypeDesc = {\n+pub enum TypeDesc = {\n     size: uint,\n     align: uint,\n     take_glue: uint,\n@@ -31,14 +20,13 @@ enum TypeDesc = {\n };\n \n /// The representation of a Rust closure\n-struct Closure {\n+pub struct Closure {\n     code: *(),\n     env: *(),\n }\n \n #[abi = \"rust-intrinsic\"]\n extern mod rusti {\n-    #[legacy_exports];\n     fn get_tydesc<T>() -> *();\n     fn size_of<T>() -> uint;\n     fn pref_align_of<T>() -> uint;\n@@ -47,15 +35,15 @@ extern mod rusti {\n \n /// Compares contents of two pointers using the default method.\n /// Equivalent to `*x1 == *x2`.  Useful for hashtables.\n-pure fn shape_eq<T:Eq>(x1: &T, x2: &T) -> bool {\n+pub pure fn shape_eq<T:Eq>(x1: &T, x2: &T) -> bool {\n     *x1 == *x2\n }\n \n-pure fn shape_lt<T:Ord>(x1: &T, x2: &T) -> bool {\n+pub pure fn shape_lt<T:Ord>(x1: &T, x2: &T) -> bool {\n     *x1 < *x2\n }\n \n-pure fn shape_le<T:Ord>(x1: &T, x2: &T) -> bool {\n+pub pure fn shape_le<T:Ord>(x1: &T, x2: &T) -> bool {\n     *x1 <= *x2\n }\n \n@@ -66,13 +54,13 @@ pure fn shape_le<T:Ord>(x1: &T, x2: &T) -> bool {\n  * performing dark magick.\n  */\n #[inline(always)]\n-pure fn get_type_desc<T>() -> *TypeDesc {\n+pub pure fn get_type_desc<T>() -> *TypeDesc {\n     unsafe { rusti::get_tydesc::<T>() as *TypeDesc }\n }\n \n /// Returns the size of a type\n #[inline(always)]\n-pure fn size_of<T>() -> uint {\n+pub pure fn size_of<T>() -> uint {\n     unsafe { rusti::size_of::<T>() }\n }\n \n@@ -83,26 +71,26 @@ pure fn size_of<T>() -> uint {\n  * than the preferred alignment.\n  */\n #[inline(always)]\n-pure fn min_align_of<T>() -> uint {\n+pub pure fn min_align_of<T>() -> uint {\n     unsafe { rusti::min_align_of::<T>() }\n }\n \n /// Returns the preferred alignment of a type\n #[inline(always)]\n-pure fn pref_align_of<T>() -> uint {\n+pub pure fn pref_align_of<T>() -> uint {\n     unsafe { rusti::pref_align_of::<T>() }\n }\n \n /// Returns the refcount of a shared box (as just before calling this)\n #[inline(always)]\n-pure fn refcount<T>(+t: @T) -> uint {\n+pub pure fn refcount<T>(t: @T) -> uint {\n     unsafe {\n         let ref_ptr: *uint = cast::reinterpret_cast(&t);\n         *ref_ptr - 1\n     }\n }\n \n-pure fn log_str<T>(t: &T) -> ~str {\n+pub pure fn log_str<T>(t: &T) -> ~str {\n     unsafe {\n         do io::with_str_writer |wr| {\n             repr::write_repr(wr, t)\n@@ -111,11 +99,10 @@ pure fn log_str<T>(t: &T) -> ~str {\n }\n \n #[cfg(test)]\n-mod tests {\n-    #[legacy_exports];\n+pub mod tests {\n \n     #[test]\n-    fn size_of_basic() {\n+    pub fn size_of_basic() {\n         assert size_of::<u8>() == 1u;\n         assert size_of::<u16>() == 2u;\n         assert size_of::<u32>() == 4u;\n@@ -125,20 +112,20 @@ mod tests {\n     #[test]\n     #[cfg(target_arch = \"x86\")]\n     #[cfg(target_arch = \"arm\")]\n-    fn size_of_32() {\n+    pub fn size_of_32() {\n         assert size_of::<uint>() == 4u;\n         assert size_of::<*uint>() == 4u;\n     }\n \n     #[test]\n     #[cfg(target_arch = \"x86_64\")]\n-    fn size_of_64() {\n+    pub fn size_of_64() {\n         assert size_of::<uint>() == 8u;\n         assert size_of::<*uint>() == 8u;\n     }\n \n     #[test]\n-    fn align_of_basic() {\n+    pub fn align_of_basic() {\n         assert pref_align_of::<u8>() == 1u;\n         assert pref_align_of::<u16>() == 2u;\n         assert pref_align_of::<u32>() == 4u;\n@@ -147,20 +134,20 @@ mod tests {\n     #[test]\n     #[cfg(target_arch = \"x86\")]\n     #[cfg(target_arch = \"arm\")]\n-    fn align_of_32() {\n+    pub fn align_of_32() {\n         assert pref_align_of::<uint>() == 4u;\n         assert pref_align_of::<*uint>() == 4u;\n     }\n \n     #[test]\n     #[cfg(target_arch = \"x86_64\")]\n-    fn align_of_64() {\n+    pub fn align_of_64() {\n         assert pref_align_of::<uint>() == 8u;\n         assert pref_align_of::<*uint>() == 8u;\n     }\n \n     #[test]\n-    fn synthesize_closure() unsafe {\n+    pub fn synthesize_closure() unsafe {\n         let x = 10;\n         let f: fn(int) -> int = |y| x + y;\n "}, {"sha": "5ca35a7f56230e334cf1e52710a323ef82457bd3", "filename": "src/libcore/task.rs", "status": "modified", "additions": 34, "deletions": 78, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -1,5 +1,5 @@\n // NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n+// tjc: re-forbid deprecated modes after snapshot\n #[forbid(deprecated_pattern)];\n \n /*!\n@@ -32,54 +32,11 @@ use result::Result;\n use pipes::{stream, Chan, Port};\n use local_data_priv::{local_get, local_set};\n \n-export Task;\n-export TaskResult;\n-export Notification;\n-export SchedMode;\n-export SchedOpts;\n-export TaskOpts;\n-export TaskBuilder;\n-\n-export task;\n-export default_task_opts;\n-export get_opts;\n-export set_opts;\n-export set_sched_mode;\n-export add_wrapper;\n-export run;\n-\n-export future_result;\n-export run_listener;\n-export run_with;\n-\n-export spawn;\n-export spawn_unlinked;\n-export spawn_supervised;\n-export spawn_with;\n-export spawn_listener;\n-export spawn_conversation;\n-export spawn_sched;\n-export try;\n-\n-export yield;\n-export failing;\n-export get_task;\n-export unkillable, rekillable;\n-export atomically;\n-\n-export local_data;\n-\n-export SingleThreaded;\n-export ThreadPerCore;\n-export ThreadPerTask;\n-export ManualThreads;\n-export PlatformThread;\n-\n use rt::task_id;\n use rt::rust_task;\n \n /// A handle to a task\n-enum Task {\n+pub enum Task {\n     TaskHandle(task_id)\n }\n \n@@ -99,7 +56,7 @@ impl Task : cmp::Eq {\n  * If you wish for this result's delivery to block until all linked and/or\n  * children tasks complete, recommend using a result future.\n  */\n-enum TaskResult {\n+pub enum TaskResult {\n     Success,\n     Failure,\n }\n@@ -115,7 +72,7 @@ impl TaskResult : Eq {\n }\n \n /// A message type for notifying of task lifecycle events\n-enum Notification {\n+pub enum Notification {\n     /// Sent when a task exits with the task handle and result\n     Exit(Task, TaskResult)\n }\n@@ -134,7 +91,7 @@ impl Notification : cmp::Eq {\n }\n \n /// Scheduler modes\n-enum SchedMode {\n+pub enum SchedMode {\n     /// All tasks run in the same OS thread\n     SingleThreaded,\n     /// Tasks are distributed among available CPUs\n@@ -207,7 +164,7 @@ impl SchedMode : cmp::Eq {\n  *     default these foreign stacks have unspecified size, but with this\n  *     option their size can be precisely specified.\n  */\n-type SchedOpts = {\n+pub type SchedOpts = {\n     mode: SchedMode,\n     foreign_stack_size: Option<uint>\n };\n@@ -239,7 +196,7 @@ type SchedOpts = {\n  *     into foreign code that blocks. Without doing so in a different\n  *     scheduler other tasks will be impeded or even blocked indefinitely.\n  */\n-type TaskOpts = {\n+pub type TaskOpts = {\n     linked: bool,\n     supervised: bool,\n     mut notify_chan: Option<Chan<Notification>>,\n@@ -260,7 +217,7 @@ type TaskOpts = {\n // the run function move them in.\n \n // FIXME (#2585): Replace the 'consumed' bit with move mode on self\n-enum TaskBuilder = {\n+pub enum TaskBuilder = {\n     opts: TaskOpts,\n     gen_body: fn@(+v: fn~()) -> fn~(),\n     can_not_copy: Option<util::NonCopyable>,\n@@ -272,10 +229,10 @@ enum TaskBuilder = {\n  * configuration methods can be chained.\n  * For example, task().unlinked().spawn is equivalent to spawn_unlinked.\n  */\n-fn task() -> TaskBuilder {\n+pub fn task() -> TaskBuilder {\n     TaskBuilder({\n         opts: default_task_opts(),\n-        gen_body: |body| move body, // Identity function\n+        gen_body: |+body| move body, // Identity function\n         can_not_copy: None,\n         mut consumed: false,\n     })\n@@ -390,7 +347,7 @@ impl TaskBuilder {\n      * # Failure\n      * Fails if a future_result was already set for this task.\n      */\n-    fn future_result(blk: fn(+v: future::Future<TaskResult>)) -> TaskBuilder {\n+    fn future_result(blk: fn(v: future::Future<TaskResult>)) -> TaskBuilder {\n         // FIXME (#1087, #1857): Once linked failure and notification are\n         // handled in the library, I can imagine implementing this by just\n         // registering an arbitrary number of task::on_exit handlers and\n@@ -473,7 +430,7 @@ impl TaskBuilder {\n     }\n \n     /**\n-     * Creates and exucutes a new child task\n+     * Creates and executes a new child task\n      *\n      * Sets up a new task with its own call stack and schedules it to run\n      * the provided unique closure. The task has the properties and behavior\n@@ -502,9 +459,9 @@ impl TaskBuilder {\n         spawn::spawn_raw(move opts, x.gen_body(move f));\n     }\n     /// Runs a task, while transfering ownership of one argument to the child.\n-    fn spawn_with<A: Send>(+arg: A, +f: fn~(+v: A)) {\n+    fn spawn_with<A: Send>(arg: A, +f: fn~(+v: A)) {\n         let arg = ~mut Some(move arg);\n-        do self.spawn |move arg, move f|{\n+        do self.spawn |move arg, move f| {\n             f(option::swap_unwrap(arg))\n         }\n     }\n@@ -516,7 +473,7 @@ impl TaskBuilder {\n      * child task, passes the port to child's body, and returns a channel\n      * linked to the port to the parent.\n      *\n-     * This encapsulates Some boilerplate handshaking logic that would\n+     * This encapsulates some boilerplate handshaking logic that would\n      * otherwise be required to establish communication from the parent\n      * to the child.\n      */\n@@ -580,7 +537,7 @@ impl TaskBuilder {\n \n /* Task construction */\n \n-fn default_task_opts() -> TaskOpts {\n+pub fn default_task_opts() -> TaskOpts {\n     /*!\n      * The default task options\n      *\n@@ -598,7 +555,7 @@ fn default_task_opts() -> TaskOpts {\n \n /* Spawn convenience functions */\n \n-fn spawn(+f: fn~()) {\n+pub fn spawn(+f: fn~()) {\n     /*!\n      * Creates and executes a new child task\n      *\n@@ -611,7 +568,7 @@ fn spawn(+f: fn~()) {\n     task().spawn(move f)\n }\n \n-fn spawn_unlinked(+f: fn~()) {\n+pub fn spawn_unlinked(+f: fn~()) {\n     /*!\n      * Creates a child task unlinked from the current one. If either this\n      * task or the child task fails, the other will not be killed.\n@@ -620,7 +577,7 @@ fn spawn_unlinked(+f: fn~()) {\n     task().unlinked().spawn(move f)\n }\n \n-fn spawn_supervised(+f: fn~()) {\n+pub fn spawn_supervised(+f: fn~()) {\n     /*!\n      * Creates a child task unlinked from the current one. If either this\n      * task or the child task fails, the other will not be killed.\n@@ -629,7 +586,7 @@ fn spawn_supervised(+f: fn~()) {\n     task().supervised().spawn(move f)\n }\n \n-fn spawn_with<A:Send>(+arg: A, +f: fn~(+v: A)) {\n+pub fn spawn_with<A:Send>(+arg: A, +f: fn~(+v: A)) {\n     /*!\n      * Runs a task, while transfering ownership of one argument to the\n      * child.\n@@ -643,7 +600,7 @@ fn spawn_with<A:Send>(+arg: A, +f: fn~(+v: A)) {\n     task().spawn_with(move arg, move f)\n }\n \n-fn spawn_listener<A:Send>(+f: fn~(comm::Port<A>)) -> comm::Chan<A> {\n+pub fn spawn_listener<A:Send>(+f: fn~(comm::Port<A>)) -> comm::Chan<A> {\n     /*!\n      * Runs a new task while providing a channel from the parent to the child\n      *\n@@ -653,7 +610,7 @@ fn spawn_listener<A:Send>(+f: fn~(comm::Port<A>)) -> comm::Chan<A> {\n     task().spawn_listener(move f)\n }\n \n-fn spawn_conversation<A: Send, B: Send>\n+pub fn spawn_conversation<A: Send, B: Send>\n     (+f: fn~(comm::Port<A>, comm::Chan<B>))\n     -> (comm::Port<B>, comm::Chan<A>) {\n     /*!\n@@ -665,7 +622,7 @@ fn spawn_conversation<A: Send, B: Send>\n     task().spawn_conversation(move f)\n }\n \n-fn spawn_sched(mode: SchedMode, +f: fn~()) {\n+pub fn spawn_sched(mode: SchedMode, +f: fn~()) {\n     /*!\n      * Creates a new scheduler and executes a task on it\n      *\n@@ -682,7 +639,7 @@ fn spawn_sched(mode: SchedMode, +f: fn~()) {\n     task().sched_mode(mode).spawn(move f)\n }\n \n-fn try<T:Send>(+f: fn~() -> T) -> Result<T,()> {\n+pub fn try<T:Send>(+f: fn~() -> T) -> Result<T,()> {\n     /*!\n      * Execute a function in another task and return either the return value\n      * of the function or result::err.\n@@ -696,7 +653,7 @@ fn try<T:Send>(+f: fn~() -> T) -> Result<T,()> {\n \n /* Lifecycle functions */\n \n-fn yield() {\n+pub fn yield() {\n     //! Yield control to the task scheduler\n \n     let task_ = rt::rust_get_task();\n@@ -706,13 +663,13 @@ fn yield() {\n     }\n }\n \n-fn failing() -> bool {\n+pub fn failing() -> bool {\n     //! True if the running task has failed\n \n     rt::rust_task_is_unwinding(rt::rust_get_task())\n }\n \n-fn get_task() -> Task {\n+pub fn get_task() -> Task {\n     //! Get a handle to the running task\n \n     TaskHandle(rt::get_task_id())\n@@ -733,7 +690,7 @@ fn get_task() -> Task {\n  * }\n  * ~~~\n  */\n-unsafe fn unkillable<U>(f: fn() -> U) -> U {\n+pub unsafe fn unkillable<U>(f: fn() -> U) -> U {\n     struct AllowFailure {\n         t: *rust_task,\n         drop { rt::rust_task_allow_kill(self.t); }\n@@ -752,7 +709,7 @@ unsafe fn unkillable<U>(f: fn() -> U) -> U {\n }\n \n /// The inverse of unkillable. Only ever to be used nested in unkillable().\n-unsafe fn rekillable<U>(f: fn() -> U) -> U {\n+pub unsafe fn rekillable<U>(f: fn() -> U) -> U {\n     struct DisallowFailure {\n         t: *rust_task,\n         drop { rt::rust_task_inhibit_kill(self.t); }\n@@ -774,7 +731,7 @@ unsafe fn rekillable<U>(f: fn() -> U) -> U {\n  * A stronger version of unkillable that also inhibits scheduling operations.\n  * For use with exclusive ARCs, which use pthread mutexes directly.\n  */\n-unsafe fn atomically<U>(f: fn() -> U) -> U {\n+pub unsafe fn atomically<U>(f: fn() -> U) -> U {\n     struct DeferInterrupts {\n         t: *rust_task,\n         drop {\n@@ -1102,7 +1059,6 @@ fn test_spawn_sched_childs_on_same_sched() {\n #[nolink]\n #[cfg(test)]\n extern mod testrt {\n-    #[legacy_exports];\n     fn rust_dbg_lock_create() -> *libc::c_void;\n     fn rust_dbg_lock_destroy(lock: *libc::c_void);\n     fn rust_dbg_lock_lock(lock: *libc::c_void);\n@@ -1175,10 +1131,10 @@ fn avoid_copying_the_body(spawnfn: fn(+v: fn~())) {\n     let ch = comm::Chan(p);\n \n     let x = ~1;\n-    let x_in_parent = ptr::addr_of(*x) as uint;\n+    let x_in_parent = ptr::p2::addr_of(&(*x)) as uint;\n \n     do spawnfn {\n-        let x_in_child = ptr::addr_of(*x) as uint;\n+        let x_in_child = ptr::p2::addr_of(&(*x)) as uint;\n         comm::send(ch, x_in_child);\n     }\n \n@@ -1193,7 +1149,7 @@ fn test_avoid_copying_the_body_spawn() {\n \n #[test]\n fn test_avoid_copying_the_body_spawn_listener() {\n-    do avoid_copying_the_body |f| {\n+    do avoid_copying_the_body |+f| {\n         spawn_listener(fn~(move f, _po: comm::Port<int>) {\n             f();\n         });\n@@ -1211,7 +1167,7 @@ fn test_avoid_copying_the_body_task_spawn() {\n \n #[test]\n fn test_avoid_copying_the_body_spawn_listener_1() {\n-    do avoid_copying_the_body |f| {\n+    do avoid_copying_the_body |+f| {\n         task().spawn_listener(fn~(move f, _po: comm::Port<int>) {\n             f();\n         });"}, {"sha": "2130354229a24250d9fe6c33d20d3568241813ea", "filename": "src/libcore/task/local_data.rs", "status": "modified", "additions": 30, "deletions": 36, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Ftask%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Ftask%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -16,12 +16,6 @@ magic.\n \n */\n \n-export LocalDataKey;\n-export local_data_pop;\n-export local_data_get;\n-export local_data_set;\n-export local_data_modify;\n-\n use local_data_priv::{\n     local_pop,\n     local_get,\n@@ -43,13 +37,13 @@ use local_data_priv::{\n  *\n  * These two cases aside, the interface is safe.\n  */\n-type LocalDataKey<T: Owned> = &fn(+v: @T);\n+pub type LocalDataKey<T: Owned> = &fn(v: @T);\n \n /**\n  * Remove a task-local data value from the table, returning the\n  * reference that was originally created to insert it.\n  */\n-unsafe fn local_data_pop<T: Owned>(\n+pub unsafe fn local_data_pop<T: Owned>(\n     key: LocalDataKey<T>) -> Option<@T> {\n \n     local_pop(rt::rust_get_task(), key)\n@@ -58,7 +52,7 @@ unsafe fn local_data_pop<T: Owned>(\n  * Retrieve a task-local data value. It will also be kept alive in the\n  * table until explicitly removed.\n  */\n-unsafe fn local_data_get<T: Owned>(\n+pub unsafe fn local_data_get<T: Owned>(\n     key: LocalDataKey<T>) -> Option<@T> {\n \n     local_get(rt::rust_get_task(), key)\n@@ -67,25 +61,25 @@ unsafe fn local_data_get<T: Owned>(\n  * Store a value in task-local data. If this key already has a value,\n  * that value is overwritten (and its destructor is run).\n  */\n-unsafe fn local_data_set<T: Owned>(\n-    key: LocalDataKey<T>, +data: @T) {\n+pub unsafe fn local_data_set<T: Owned>(\n+    key: LocalDataKey<T>, data: @T) {\n \n     local_set(rt::rust_get_task(), key, data)\n }\n /**\n  * Modify a task-local data value. If the function returns 'None', the\n  * data is removed (and its reference dropped).\n  */\n-unsafe fn local_data_modify<T: Owned>(\n+pub unsafe fn local_data_modify<T: Owned>(\n     key: LocalDataKey<T>,\n     modify_fn: fn(Option<@T>) -> Option<@T>) {\n \n     local_modify(rt::rust_get_task(), key, modify_fn)\n }\n \n #[test]\n-fn test_tls_multitask() unsafe {\n-    fn my_key(+_x: @~str) { }\n+pub fn test_tls_multitask() unsafe {\n+    fn my_key(_x: @~str) { }\n     local_data_set(my_key, @~\"parent data\");\n     do task::spawn unsafe {\n         assert local_data_get(my_key).is_none(); // TLS shouldn't carry over.\n@@ -100,59 +94,59 @@ fn test_tls_multitask() unsafe {\n }\n \n #[test]\n-fn test_tls_overwrite() unsafe {\n-    fn my_key(+_x: @~str) { }\n+pub fn test_tls_overwrite() unsafe {\n+    fn my_key(_x: @~str) { }\n     local_data_set(my_key, @~\"first data\");\n     local_data_set(my_key, @~\"next data\"); // Shouldn't leak.\n     assert *(local_data_get(my_key).get()) == ~\"next data\";\n }\n \n #[test]\n-fn test_tls_pop() unsafe {\n-    fn my_key(+_x: @~str) { }\n+pub fn test_tls_pop() unsafe {\n+    fn my_key(_x: @~str) { }\n     local_data_set(my_key, @~\"weasel\");\n     assert *(local_data_pop(my_key).get()) == ~\"weasel\";\n     // Pop must remove the data from the map.\n     assert local_data_pop(my_key).is_none();\n }\n \n #[test]\n-fn test_tls_modify() unsafe {\n-    fn my_key(+_x: @~str) { }\n+pub fn test_tls_modify() unsafe {\n+    fn my_key(_x: @~str) { }\n     local_data_modify(my_key, |data| {\n         match data {\n-            Some(@val) => fail ~\"unwelcome value: \" + val,\n+            Some(@ref val) => fail ~\"unwelcome value: \" + *val,\n             None       => Some(@~\"first data\")\n         }\n     });\n     local_data_modify(my_key, |data| {\n         match data {\n             Some(@~\"first data\") => Some(@~\"next data\"),\n-            Some(@val)           => fail ~\"wrong value: \" + val,\n+            Some(@ref val)           => fail ~\"wrong value: \" + *val,\n             None                 => fail ~\"missing value\"\n         }\n     });\n     assert *(local_data_pop(my_key).get()) == ~\"next data\";\n }\n \n #[test]\n-fn test_tls_crust_automorestack_memorial_bug() unsafe {\n+pub fn test_tls_crust_automorestack_memorial_bug() unsafe {\n     // This might result in a stack-canary clobber if the runtime fails to set\n     // sp_limit to 0 when calling the cleanup extern - it might automatically\n     // jump over to the rust stack, which causes next_c_sp to get recorded as\n     // Something within a rust stack segment. Then a subsequent upcall (esp.\n     // for logging, think vsnprintf) would run on a stack smaller than 1 MB.\n-    fn my_key(+_x: @~str) { }\n+    fn my_key(_x: @~str) { }\n     do task::spawn {\n         unsafe { local_data_set(my_key, @~\"hax\"); }\n     }\n }\n \n #[test]\n-fn test_tls_multiple_types() unsafe {\n-    fn str_key(+_x: @~str) { }\n-    fn box_key(+_x: @@()) { }\n-    fn int_key(+_x: @int) { }\n+pub fn test_tls_multiple_types() unsafe {\n+    fn str_key(_x: @~str) { }\n+    fn box_key(_x: @@()) { }\n+    fn int_key(_x: @int) { }\n     do task::spawn unsafe {\n         local_data_set(str_key, @~\"string data\");\n         local_data_set(box_key, @@());\n@@ -161,10 +155,10 @@ fn test_tls_multiple_types() unsafe {\n }\n \n #[test]\n-fn test_tls_overwrite_multiple_types() {\n-    fn str_key(+_x: @~str) { }\n-    fn box_key(+_x: @@()) { }\n-    fn int_key(+_x: @int) { }\n+pub fn test_tls_overwrite_multiple_types() {\n+    fn str_key(_x: @~str) { }\n+    fn box_key(_x: @@()) { }\n+    fn int_key(_x: @int) { }\n     do task::spawn unsafe {\n         local_data_set(str_key, @~\"string data\");\n         local_data_set(int_key, @42);\n@@ -177,10 +171,10 @@ fn test_tls_overwrite_multiple_types() {\n #[test]\n #[should_fail]\n #[ignore(cfg(windows))]\n-fn test_tls_cleanup_on_failure() unsafe {\n-    fn str_key(+_x: @~str) { }\n-    fn box_key(+_x: @@()) { }\n-    fn int_key(+_x: @int) { }\n+pub fn test_tls_cleanup_on_failure() unsafe {\n+    fn str_key(_x: @~str) { }\n+    fn box_key(_x: @@()) { }\n+    fn int_key(_x: @int) { }\n     local_data_set(str_key, @~\"parent data\");\n     local_data_set(box_key, @@());\n     do task::spawn unsafe { // spawn_linked"}, {"sha": "9849ce7b68cdb15a7f40bcdad5b519466927063c", "filename": "src/libcore/task/local_data_priv.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data_priv.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -3,7 +3,7 @@\n use local_data::LocalDataKey;\n use rt::rust_task;\n \n-trait LocalData { }\n+pub trait LocalData { }\n impl<T: Owned> @T: LocalData { }\n \n impl LocalData: Eq {\n@@ -17,19 +17,19 @@ impl LocalData: Eq {\n \n // We use dvec because it's the best data structure in core. If TLS is used\n // heavily in future, this could be made more efficient with a proper map.\n-type TaskLocalElement = (*libc::c_void, *libc::c_void, LocalData);\n+pub type TaskLocalElement = (*libc::c_void, *libc::c_void, LocalData);\n // Has to be a pointer at outermost layer; the foreign call returns void *.\n-type TaskLocalMap = @dvec::DVec<Option<TaskLocalElement>>;\n+pub type TaskLocalMap = @dvec::DVec<Option<TaskLocalElement>>;\n \n-extern fn cleanup_task_local_map(map_ptr: *libc::c_void) unsafe {\n+pub extern fn cleanup_task_local_map(map_ptr: *libc::c_void) unsafe {\n     assert !map_ptr.is_null();\n     // Get and keep the single reference that was created at the beginning.\n     let _map: TaskLocalMap = cast::reinterpret_cast(&map_ptr);\n     // All local_data will be destroyed along with the map.\n }\n \n // Gets the map from the runtime. Lazily initialises if not done so already.\n-unsafe fn get_task_local_map(task: *rust_task) -> TaskLocalMap {\n+pub unsafe fn get_task_local_map(task: *rust_task) -> TaskLocalMap {\n \n     // Relies on the runtime initialising the pointer to null.\n     // NOTE: The map's box lives in TLS invisibly referenced once. Each time\n@@ -52,7 +52,7 @@ unsafe fn get_task_local_map(task: *rust_task) -> TaskLocalMap {\n     }\n }\n \n-unsafe fn key_to_key_value<T: Owned>(\n+pub unsafe fn key_to_key_value<T: Owned>(\n     key: LocalDataKey<T>) -> *libc::c_void {\n \n     // Keys are closures, which are (fnptr,envptr) pairs. Use fnptr.\n@@ -62,25 +62,25 @@ unsafe fn key_to_key_value<T: Owned>(\n }\n \n // If returning Some(..), returns with @T with the map's reference. Careful!\n-unsafe fn local_data_lookup<T: Owned>(\n+pub unsafe fn local_data_lookup<T: Owned>(\n     map: TaskLocalMap, key: LocalDataKey<T>)\n     -> Option<(uint, *libc::c_void)> {\n \n     let key_value = key_to_key_value(key);\n     let map_pos = (*map).position(|entry|\n-        match entry {\n+        match *entry {\n             Some((k,_,_)) => k == key_value,\n             None => false\n         }\n     );\n     do map_pos.map |index| {\n         // .get() is guaranteed because of \"None { false }\" above.\n-        let (_, data_ptr, _) = (*map)[index].get();\n-        (index, data_ptr)\n+        let (_, data_ptr, _) = (*map)[*index].get();\n+        (*index, data_ptr)\n     }\n }\n \n-unsafe fn local_get_helper<T: Owned>(\n+pub unsafe fn local_get_helper<T: Owned>(\n     task: *rust_task, key: LocalDataKey<T>,\n     do_pop: bool) -> Option<@T> {\n \n@@ -91,7 +91,7 @@ unsafe fn local_get_helper<T: Owned>(\n         // was referenced in the local_data box, though, not here, so before\n         // overwriting the local_data_box we need to give an extra reference.\n         // We must also give an extra reference when not removing.\n-        let (index, data_ptr) = result;\n+        let (index, data_ptr) = *result;\n         let data: @T = cast::transmute(move data_ptr);\n         cast::bump_box_refcount(data);\n         if do_pop {\n@@ -102,22 +102,22 @@ unsafe fn local_get_helper<T: Owned>(\n }\n \n \n-unsafe fn local_pop<T: Owned>(\n+pub unsafe fn local_pop<T: Owned>(\n     task: *rust_task,\n     key: LocalDataKey<T>) -> Option<@T> {\n \n     local_get_helper(task, key, true)\n }\n \n-unsafe fn local_get<T: Owned>(\n+pub unsafe fn local_get<T: Owned>(\n     task: *rust_task,\n     key: LocalDataKey<T>) -> Option<@T> {\n \n     local_get_helper(task, key, false)\n }\n \n-unsafe fn local_set<T: Owned>(\n-    task: *rust_task, key: LocalDataKey<T>, +data: @T) {\n+pub unsafe fn local_set<T: Owned>(\n+    task: *rust_task, key: LocalDataKey<T>, data: @T) {\n \n     let map = get_task_local_map(task);\n     // Store key+data as *voids. Data is invisibly referenced once; key isn't.\n@@ -148,7 +148,7 @@ unsafe fn local_set<T: Owned>(\n     }\n }\n \n-unsafe fn local_modify<T: Owned>(\n+pub unsafe fn local_modify<T: Owned>(\n     task: *rust_task, key: LocalDataKey<T>,\n     modify_fn: fn(Option<@T>) -> Option<@T>) {\n "}, {"sha": "db3d1ec9f70940ef4275ee3527e0941ebbbffda2", "filename": "src/libcore/task/rt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Ftask%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Ftask%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Frt.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -7,16 +7,16 @@ The task interface to the runtime\n #[doc(hidden)]; // FIXME #3538\n \n #[allow(non_camel_case_types)] // runtime type\n-type sched_id = int;\n+pub type sched_id = int;\n #[allow(non_camel_case_types)] // runtime type\n-type task_id = int;\n+pub type task_id = int;\n \n // These are both opaque runtime/compiler types that we don't know the\n // structure of and should only deal with via unsafe pointer\n #[allow(non_camel_case_types)] // runtime type\n-type rust_task = libc::c_void;\n+pub type rust_task = libc::c_void;\n #[allow(non_camel_case_types)] // runtime type\n-type rust_closure = libc::c_void;\n+pub type rust_closure = libc::c_void;\n \n extern {\n     #[rust_stack]"}, {"sha": "0e1284da3bcbbd2bd0c9e7fb388397d403563b14", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 44, "deletions": 41, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -66,41 +66,41 @@ use rt::rust_task;\n use rt::rust_closure;\n \n macro_rules! move_it (\n-    { $x:expr } => { unsafe { let y <- *ptr::addr_of($x); move y } }\n+    { $x:expr } => { unsafe { let y <- *ptr::addr_of(&($x)); move y } }\n )\n \n-type TaskSet = send_map::linear::LinearMap<*rust_task,()>;\n+pub type TaskSet = send_map::linear::LinearMap<*rust_task,()>;\n \n-fn new_taskset() -> TaskSet {\n+pub fn new_taskset() -> TaskSet {\n     send_map::linear::LinearMap()\n }\n-fn taskset_insert(tasks: &mut TaskSet, task: *rust_task) {\n+pub fn taskset_insert(tasks: &mut TaskSet, task: *rust_task) {\n     let didnt_overwrite = tasks.insert(task, ());\n     assert didnt_overwrite;\n }\n-fn taskset_remove(tasks: &mut TaskSet, task: *rust_task) {\n+pub fn taskset_remove(tasks: &mut TaskSet, task: *rust_task) {\n     let was_present = tasks.remove(&task);\n     assert was_present;\n }\n-fn taskset_each(tasks: &TaskSet, blk: fn(+v: *rust_task) -> bool) {\n+pub fn taskset_each(tasks: &TaskSet, blk: fn(v: *rust_task) -> bool) {\n     tasks.each_key(|k| blk(*k))\n }\n \n // One of these per group of linked-failure tasks.\n-type TaskGroupData = {\n+pub type TaskGroupData = {\n     // All tasks which might kill this group. When this is empty, the group\n     // can be \"GC\"ed (i.e., its link in the ancestor list can be removed).\n     mut members:     TaskSet,\n     // All tasks unidirectionally supervised by (directly or transitively)\n     // tasks in this group.\n     mut descendants: TaskSet,\n };\n-type TaskGroupArc = private::Exclusive<Option<TaskGroupData>>;\n+pub type TaskGroupArc = private::Exclusive<Option<TaskGroupData>>;\n \n-type TaskGroupInner = &mut Option<TaskGroupData>;\n+pub type TaskGroupInner = &mut Option<TaskGroupData>;\n \n // A taskgroup is 'dead' when nothing can cause it to fail; only members can.\n-pure fn taskgroup_is_dead(tg: &TaskGroupData) -> bool {\n+pub pure fn taskgroup_is_dead(tg: &TaskGroupData) -> bool {\n     (&tg.members).is_empty()\n }\n \n@@ -111,7 +111,7 @@ pure fn taskgroup_is_dead(tg: &TaskGroupData) -> bool {\n // taskgroup which was spawned-unlinked. Tasks from intermediate generations\n // have references to the middle of the list; when intermediate generations\n // die, their node in the list will be collected at a descendant's spawn-time.\n-type AncestorNode = {\n+pub type AncestorNode = {\n     // Since the ancestor list is recursive, we end up with references to\n     // exclusives within other exclusives. This is dangerous business (if\n     // circular references arise, deadlock and memory leaks are imminent).\n@@ -124,16 +124,16 @@ type AncestorNode = {\n     // Recursive rest of the list.\n     mut ancestors:    AncestorList,\n };\n-enum AncestorList = Option<private::Exclusive<AncestorNode>>;\n+pub enum AncestorList = Option<private::Exclusive<AncestorNode>>;\n \n // Accessors for taskgroup arcs and ancestor arcs that wrap the unsafety.\n #[inline(always)]\n-fn access_group<U>(x: &TaskGroupArc, blk: fn(TaskGroupInner) -> U) -> U {\n+pub fn access_group<U>(x: &TaskGroupArc, blk: fn(TaskGroupInner) -> U) -> U {\n     unsafe { x.with(blk) }\n }\n \n #[inline(always)]\n-fn access_ancestors<U>(x: &private::Exclusive<AncestorNode>,\n+pub fn access_ancestors<U>(x: &private::Exclusive<AncestorNode>,\n                        blk: fn(x: &mut AncestorNode) -> U) -> U {\n     unsafe { x.with(blk) }\n }\n@@ -146,9 +146,9 @@ fn access_ancestors<U>(x: &private::Exclusive<AncestorNode>,\n // (3) As a bonus, coalesces away all 'dead' taskgroup nodes in the list.\n // FIXME(#2190): Change Option<fn@(...)> to Option<fn&(...)>, to save on\n // allocations. Once that bug is fixed, changing the sigil should suffice.\n-fn each_ancestor(list:        &mut AncestorList,\n-                 bail_opt:    Option<fn@(TaskGroupInner)>,\n-                 forward_blk: fn(TaskGroupInner) -> bool)\n+pub fn each_ancestor(list:        &mut AncestorList,\n+                     bail_opt:    Option<fn@(TaskGroupInner)>,\n+                     forward_blk: fn(TaskGroupInner) -> bool)\n         -> bool {\n     // \"Kickoff\" call - there was no last generation.\n     return !coalesce(list, bail_opt, forward_blk, uint::max_value);\n@@ -200,7 +200,7 @@ fn each_ancestor(list:        &mut AncestorList,\n         // the end of the list, which doesn't make sense to coalesce.\n         return do (**ancestors).map_default((None,false)) |ancestor_arc| {\n             // NB: Takes a lock! (this ancestor node)\n-            do access_ancestors(&ancestor_arc) |nobe| {\n+            do access_ancestors(ancestor_arc) |nobe| {\n                 // Check monotonicity\n                 assert last_generation > nobe.generation;\n                 /*##########################################################*\n@@ -240,7 +240,7 @@ fn each_ancestor(list:        &mut AncestorList,\n                 if need_unwind && !nobe_is_dead {\n                     do bail_opt.iter |bail_blk| {\n                         do with_parent_tg(&mut nobe.parent_group) |tg_opt| {\n-                            bail_blk(tg_opt)\n+                            (*bail_blk)(tg_opt)\n                         }\n                     }\n                 }\n@@ -271,7 +271,7 @@ fn each_ancestor(list:        &mut AncestorList,\n }\n \n // One of these per task.\n-struct TCB {\n+pub struct TCB {\n     me:            *rust_task,\n     // List of tasks with whose fates this one's is intertwined.\n     tasks:         TaskGroupArc, // 'none' means the group has failed.\n@@ -303,8 +303,8 @@ struct TCB {\n     }\n }\n \n-fn TCB(me: *rust_task, +tasks: TaskGroupArc, +ancestors: AncestorList,\n-       is_main: bool, +notifier: Option<AutoNotify>) -> TCB {\n+pub fn TCB(me: *rust_task, tasks: TaskGroupArc, ancestors: AncestorList,\n+       is_main: bool, notifier: Option<AutoNotify>) -> TCB {\n \n     let notifier = move notifier;\n     notifier.iter(|x| { x.failed = false; });\n@@ -318,7 +318,7 @@ fn TCB(me: *rust_task, +tasks: TaskGroupArc, +ancestors: AncestorList,\n     }\n }\n \n-struct AutoNotify {\n+pub struct AutoNotify {\n     notify_chan: Chan<Notification>,\n     mut failed:  bool,\n     drop {\n@@ -327,15 +327,15 @@ struct AutoNotify {\n     }\n }\n \n-fn AutoNotify(+chan: Chan<Notification>) -> AutoNotify {\n+pub fn AutoNotify(chan: Chan<Notification>) -> AutoNotify {\n     AutoNotify {\n         notify_chan: chan,\n         failed: true // Un-set above when taskgroup successfully made.\n     }\n }\n \n-fn enlist_in_taskgroup(state: TaskGroupInner, me: *rust_task,\n-                       is_member: bool) -> bool {\n+pub fn enlist_in_taskgroup(state: TaskGroupInner, me: *rust_task,\n+                           is_member: bool) -> bool {\n     let newstate = util::replace(state, None);\n     // If 'None', the group was failing. Can't enlist.\n     if newstate.is_some() {\n@@ -350,7 +350,8 @@ fn enlist_in_taskgroup(state: TaskGroupInner, me: *rust_task,\n }\n \n // NB: Runs in destructor/post-exit context. Can't 'fail'.\n-fn leave_taskgroup(state: TaskGroupInner, me: *rust_task, is_member: bool) {\n+pub fn leave_taskgroup(state: TaskGroupInner, me: *rust_task,\n+                       is_member: bool) {\n     let newstate = util::replace(state, None);\n     // If 'None', already failing and we've already gotten a kill signal.\n     if newstate.is_some() {\n@@ -362,7 +363,7 @@ fn leave_taskgroup(state: TaskGroupInner, me: *rust_task, is_member: bool) {\n }\n \n // NB: Runs in destructor/post-exit context. Can't 'fail'.\n-fn kill_taskgroup(state: TaskGroupInner, me: *rust_task, is_main: bool) {\n+pub fn kill_taskgroup(state: TaskGroupInner, me: *rust_task, is_main: bool) {\n     // NB: We could do the killing iteration outside of the group arc, by\n     // having \"let mut newstate\" here, swapping inside, and iterating after.\n     // But that would let other exiting tasks fall-through and exit while we\n@@ -377,13 +378,13 @@ fn kill_taskgroup(state: TaskGroupInner, me: *rust_task, is_main: bool) {\n     // see 'None' if Somebody already failed and we got a kill signal.)\n     if newstate.is_some() {\n         let group = option::unwrap(move newstate);\n-        for taskset_each(&group.members) |+sibling| {\n+        for taskset_each(&group.members) |sibling| {\n             // Skip self - killing ourself won't do much good.\n             if sibling != me {\n                 rt::rust_task_kill_other(sibling);\n             }\n         }\n-        for taskset_each(&group.descendants) |+child| {\n+        for taskset_each(&group.descendants) |child| {\n             assert child != me;\n             rt::rust_task_kill_other(child);\n         }\n@@ -404,8 +405,8 @@ macro_rules! taskgroup_key (\n     () => (cast::transmute((-2 as uint, 0u)))\n )\n \n-fn gen_child_taskgroup(linked: bool, supervised: bool)\n-        -> (TaskGroupArc, AncestorList, bool) {\n+pub fn gen_child_taskgroup(linked: bool, supervised: bool)\n+    -> (TaskGroupArc, AncestorList, bool) {\n     let spawner = rt::rust_get_task();\n     /*######################################################################*\n      * Step 1. Get spawner's taskgroup info.\n@@ -451,7 +452,9 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n             // it should be enabled only in debug builds.\n             let new_generation =\n                 match *old_ancestors {\n-                    Some(arc) => access_ancestors(&arc, |a| a.generation+1),\n+                    Some(ref arc) => {\n+                        access_ancestors(arc, |a| a.generation+1)\n+                    }\n                     None      => 0 // the actual value doesn't really matter.\n                 };\n             assert new_generation < uint::max_value;\n@@ -484,7 +487,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n     }\n }\n \n-fn spawn_raw(+opts: TaskOpts, +f: fn~()) {\n+pub fn spawn_raw(opts: TaskOpts, +f: fn~()) {\n     let (child_tg, ancestors, is_main) =\n         gen_child_taskgroup(opts.linked, opts.supervised);\n \n@@ -509,8 +512,8 @@ fn spawn_raw(+opts: TaskOpts, +f: fn~()) {\n \n             let child_wrapper = make_child_wrapper(new_task, move child_tg,\n                   move ancestors, is_main, move notify_chan, move f);\n-            let fptr = ptr::addr_of(child_wrapper);\n-            let closure: *rust_closure = cast::reinterpret_cast(&fptr);\n+\n+            let closure = cast::transmute(&child_wrapper);\n \n             // Getting killed between these two calls would free the child's\n             // closure. (Reordering them wouldn't help - then getting killed\n@@ -526,9 +529,9 @@ fn spawn_raw(+opts: TaskOpts, +f: fn~()) {\n     // (3a) If any of those fails, it leaves all groups, and does nothing.\n     // (3b) Otherwise it builds a task control structure and puts it in TLS,\n     // (4) ...and runs the provided body function.\n-    fn make_child_wrapper(child: *rust_task, +child_arc: TaskGroupArc,\n-                          +ancestors: AncestorList, is_main: bool,\n-                          +notify_chan: Option<Chan<Notification>>,\n+    fn make_child_wrapper(child: *rust_task, child_arc: TaskGroupArc,\n+                          ancestors: AncestorList, is_main: bool,\n+                          notify_chan: Option<Chan<Notification>>,\n                           +f: fn~()) -> fn~() {\n         let child_data = ~mut Some((move child_arc, move ancestors));\n         return fn~(move notify_chan, move child_data, move f) {\n@@ -541,8 +544,8 @@ fn spawn_raw(+opts: TaskOpts, +f: fn~()) {\n \n             //let mut notifier = None;//notify_chan.map(|c| AutoNotify(c));\n             let notifier = match notify_chan {\n-                Some(notify_chan_value) => {\n-                    let moved_ncv = move_it!(notify_chan_value);\n+                Some(ref notify_chan_value) => {\n+                    let moved_ncv = move_it!(*notify_chan_value);\n                     Some(AutoNotify(move moved_ncv))\n                 }\n                 _ => None"}, {"sha": "ef15aa00f113817f98b0de25965507da1665b2b4", "filename": "src/libcore/to_bytes.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_bytes.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -10,7 +10,7 @@ The `ToBytes` and `IterBytes` traits\n \n use io::Writer;\n \n-type Cb = fn(buf: &[const u8]) -> bool;\n+pub type Cb = fn(buf: &[const u8]) -> bool;\n \n /**\n  * A trait to implement in order to make a type hashable;\n@@ -19,7 +19,7 @@ type Cb = fn(buf: &[const u8]) -> bool;\n  * modified when default methods and trait inheritence are\n  * completed.\n  */\n-trait IterBytes {\n+pub trait IterBytes {\n     /**\n      * Call the provided callback `f` one or more times with\n      * byte-slices that should be used when computing a hash\n@@ -211,15 +211,15 @@ impl<A: IterBytes> @[A]: IterBytes {\n     }\n }\n \n-pure fn iter_bytes_2<A: IterBytes, B: IterBytes>(a: &A, b: &B,\n+pub pure fn iter_bytes_2<A: IterBytes, B: IterBytes>(a: &A, b: &B,\n                                             lsb0: bool, z: Cb) {\n     let mut flag = true;\n     a.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n     if !flag { return; }\n     b.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n }\n \n-pure fn iter_bytes_3<A: IterBytes,\n+pub pure fn iter_bytes_3<A: IterBytes,\n                 B: IterBytes,\n                 C: IterBytes>(a: &A, b: &B, c: &C,\n                               lsb0: bool, z: Cb) {\n@@ -231,7 +231,7 @@ pure fn iter_bytes_3<A: IterBytes,\n     c.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n }\n \n-pure fn iter_bytes_4<A: IterBytes,\n+pub pure fn iter_bytes_4<A: IterBytes,\n                 B: IterBytes,\n                 C: IterBytes,\n                 D: IterBytes>(a: &A, b: &B, c: &C,\n@@ -247,7 +247,7 @@ pure fn iter_bytes_4<A: IterBytes,\n     d.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n }\n \n-pure fn iter_bytes_5<A: IterBytes,\n+pub pure fn iter_bytes_5<A: IterBytes,\n                 B: IterBytes,\n                 C: IterBytes,\n                 D: IterBytes,\n@@ -266,7 +266,7 @@ pure fn iter_bytes_5<A: IterBytes,\n     e.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n }\n \n-pure fn iter_bytes_6<A: IterBytes,\n+pub pure fn iter_bytes_6<A: IterBytes,\n                 B: IterBytes,\n                 C: IterBytes,\n                 D: IterBytes,\n@@ -288,7 +288,7 @@ pure fn iter_bytes_6<A: IterBytes,\n     f.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n }\n \n-pure fn iter_bytes_7<A: IterBytes,\n+pub pure fn iter_bytes_7<A: IterBytes,\n                 B: IterBytes,\n                 C: IterBytes,\n                 D: IterBytes,\n@@ -345,7 +345,7 @@ impl<A: IterBytes> Option<A>: IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(lsb0: bool, f: Cb) {\n         match self {\n-          Some(a) => iter_bytes_2(&0u8, &a, lsb0, f),\n+          Some(ref a) => iter_bytes_2(&0u8, a, lsb0, f),\n           None => 1u8.iter_bytes(lsb0, f)\n         }\n     }"}, {"sha": "a3659937ad4590228274980dc60f76329267f9b6", "filename": "src/libcore/to_str.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_str.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -8,7 +8,7 @@ The `ToStr` trait for converting to strings\n #[forbid(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n \n-trait ToStr { fn to_str() -> ~str; }\n+pub trait ToStr { fn to_str() -> ~str; }\n \n impl int: ToStr {\n     fn to_str() -> ~str { int::str(self) }\n@@ -101,7 +101,6 @@ impl<A: ToStr> ~A: ToStr {\n #[cfg(test)]\n #[allow(non_implicitly_copyable_typarams)]\n mod tests {\n-    #[legacy_exports];\n     #[test]\n     fn test_simple_types() {\n         assert 1.to_str() == ~\"1\";"}, {"sha": "246ce16c813111951c5683e89f86212fce71f79d", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -6,7 +6,7 @@\n \n use cmp::{Eq, Ord};\n \n-trait TupleOps<T,U> {\n+pub trait TupleOps<T,U> {\n     pure fn first() -> T;\n     pure fn second() -> U;\n     pure fn swap() -> (U, T);\n@@ -34,49 +34,54 @@ impl<T: Copy, U: Copy> (T, U): TupleOps<T,U> {\n \n }\n \n-trait ExtendedTupleOps<A,B> {\n-    fn zip() -> ~[(A, B)];\n-    fn map<C>(f: fn(A, B) -> C) -> ~[C];\n+pub trait ExtendedTupleOps<A,B> {\n+    fn zip(&self) -> ~[(A, B)];\n+    fn map<C>(&self, f: &fn(a: &A, b: &B) -> C) -> ~[C];\n }\n \n impl<A: Copy, B: Copy> (&[A], &[B]): ExtendedTupleOps<A,B> {\n-\n-    fn zip() -> ~[(A, B)] {\n-        let (a, b) = self;\n-        vec::zip_slice(a, b)\n+    fn zip(&self) -> ~[(A, B)] {\n+        match *self {\n+            (ref a, ref b) => {\n+                vec::zip_slice(*a, *b)\n+            }\n+        }\n     }\n \n-    fn map<C>(f: fn(A, B) -> C) -> ~[C] {\n-        let (a, b) = self;\n-        vec::map2(a, b, f)\n+    fn map<C>(&self, f: &fn(a: &A, b: &B) -> C) -> ~[C] {\n+        match *self {\n+            (ref a, ref b) => {\n+                vec::map2(*a, *b, f)\n+            }\n+        }\n     }\n }\n \n impl<A: Copy, B: Copy> (~[A], ~[B]): ExtendedTupleOps<A,B> {\n \n-    fn zip() -> ~[(A, B)] {\n-        // FIXME #2543: Bad copy\n-        let (a, b) = copy self;\n-        vec::zip(move a, move b)\n+    fn zip(&self) -> ~[(A, B)] {\n+        match *self {\n+            (ref a, ref b) => {\n+                vec::zip_slice(*a, *b)\n+            }\n+        }\n     }\n \n-    fn map<C>(f: fn(A, B) -> C) -> ~[C] {\n-        // FIXME #2543: Bad copy\n-        let (a, b) = copy self;\n-        vec::map2(a, b, f)\n+    fn map<C>(&self, f: &fn(a: &A, b: &B) -> C) -> ~[C] {\n+        match *self {\n+            (ref a, ref b) => {\n+                vec::map2(*a, *b, f)\n+            }\n+        }\n     }\n }\n \n impl<A: Eq, B: Eq> (A, B) : Eq {\n     pure fn eq(other: &(A, B)) -> bool {\n-        // XXX: This would be a lot less wordy with ref bindings, but I don't\n-        // trust that they work yet.\n         match self {\n-            (self_a, self_b) => {\n-                match (*other) {\n-                    (ref other_a, ref other_b) => {\n-                        self_a.eq(other_a) && self_b.eq(other_b)\n-                    }\n+            (ref self_a, ref self_b) => match other {\n+                &(ref other_a, ref other_b) => {\n+                    (*self_a).eq(other_a) && (*self_b).eq(other_b)\n                 }\n             }\n         }\n@@ -106,16 +111,11 @@ impl<A: Ord, B: Ord> (A, B) : Ord {\n \n impl<A: Eq, B: Eq, C: Eq> (A, B, C) : Eq {\n     pure fn eq(other: &(A, B, C)) -> bool {\n-        // XXX: This would be a lot less wordy with ref bindings, but I don't\n-        // trust that they work yet.\n         match self {\n-            (self_a, self_b, self_c) => {\n-                match (*other) {\n-                    (ref other_a, ref other_b, ref other_c) => {\n-                        self_a.eq(other_a) &&\n-                        self_b.eq(other_b) &&\n-                        self_c.eq(other_c)\n-                    }\n+            (ref self_a, ref self_b, ref self_c) => match other {\n+                &(ref other_a, ref other_b, ref other_c) => {\n+                    (*self_a).eq(other_a) && (*self_b).eq(other_b)\n+                        && (*self_c).eq(other_c)\n                 }\n             }\n         }"}, {"sha": "7d0421c0730153c5ca13c0dd75772d3a47f1ef2d", "filename": "src/libcore/uint-template.rs", "status": "modified", "additions": 46, "deletions": 60, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -6,49 +6,36 @@ use T = inst::T;\n use cmp::{Eq, Ord};\n use from_str::FromStr;\n \n-export min_value, max_value;\n-export min, max;\n-export add, sub, mul, div, rem;\n-export lt, le, eq, ne, ge, gt;\n-export is_positive, is_negative;\n-export is_nonpositive, is_nonnegative;\n-export range;\n-export compl;\n-export to_str, to_str_bytes;\n-export from_str, from_str_radix, str, parse_bytes;\n-export num, ord, eq, times, timesi;\n-export bits, bytes;\n-\n-const bits : uint = inst::bits;\n-const bytes : uint = (inst::bits / 8);\n-\n-const min_value: T = 0 as T;\n-const max_value: T = 0 as T - 1 as T;\n-\n-pure fn min(x: T, y: T) -> T { if x < y { x } else { y } }\n-pure fn max(x: T, y: T) -> T { if x > y { x } else { y } }\n-\n-pure fn add(x: T, y: T) -> T { x + y }\n-pure fn sub(x: T, y: T) -> T { x - y }\n-pure fn mul(x: T, y: T) -> T { x * y }\n-pure fn div(x: T, y: T) -> T { x / y }\n-pure fn rem(x: T, y: T) -> T { x % y }\n-\n-pure fn lt(x: T, y: T) -> bool { x < y }\n-pure fn le(x: T, y: T) -> bool { x <= y }\n-pure fn eq(x: T, y: T) -> bool { x == y }\n-pure fn ne(x: T, y: T) -> bool { x != y }\n-pure fn ge(x: T, y: T) -> bool { x >= y }\n-pure fn gt(x: T, y: T) -> bool { x > y }\n-\n-pure fn is_positive(x: T) -> bool { x > 0 as T }\n-pure fn is_negative(x: T) -> bool { x < 0 as T }\n-pure fn is_nonpositive(x: T) -> bool { x <= 0 as T }\n-pure fn is_nonnegative(x: T) -> bool { x >= 0 as T }\n+pub const bits : uint = inst::bits;\n+pub const bytes : uint = (inst::bits / 8);\n+\n+pub const min_value: T = 0 as T;\n+pub const max_value: T = 0 as T - 1 as T;\n+\n+pub pure fn min(x: T, y: T) -> T { if x < y { x } else { y } }\n+pub pure fn max(x: T, y: T) -> T { if x > y { x } else { y } }\n+\n+pub pure fn add(x: T, y: T) -> T { x + y }\n+pub pure fn sub(x: T, y: T) -> T { x - y }\n+pub pure fn mul(x: T, y: T) -> T { x * y }\n+pub pure fn div(x: T, y: T) -> T { x / y }\n+pub pure fn rem(x: T, y: T) -> T { x % y }\n+\n+pub pure fn lt(x: T, y: T) -> bool { x < y }\n+pub pure fn le(x: T, y: T) -> bool { x <= y }\n+pub pure fn eq(x: T, y: T) -> bool { x == y }\n+pub pure fn ne(x: T, y: T) -> bool { x != y }\n+pub pure fn ge(x: T, y: T) -> bool { x >= y }\n+pub pure fn gt(x: T, y: T) -> bool { x > y }\n+\n+pub pure fn is_positive(x: T) -> bool { x > 0 as T }\n+pub pure fn is_negative(x: T) -> bool { x < 0 as T }\n+pub pure fn is_nonpositive(x: T) -> bool { x <= 0 as T }\n+pub pure fn is_nonnegative(x: T) -> bool { x >= 0 as T }\n \n #[inline(always)]\n /// Iterate over the range [`lo`..`hi`)\n-pure fn range(lo: T, hi: T, it: fn(T) -> bool) {\n+pub pure fn range(lo: T, hi: T, it: fn(T) -> bool) {\n     let mut i = lo;\n     while i < hi {\n         if !it(i) { break }\n@@ -57,7 +44,7 @@ pure fn range(lo: T, hi: T, it: fn(T) -> bool) {\n }\n \n /// Computes the bitwise complement\n-pure fn compl(i: T) -> T {\n+pub pure fn compl(i: T) -> T {\n     max_value ^ i\n }\n \n@@ -74,11 +61,11 @@ impl T : Eq {\n }\n \n impl T: num::Num {\n-    pure fn add(&&other: T)    -> T { return self + other; }\n-    pure fn sub(&&other: T)    -> T { return self - other; }\n-    pure fn mul(&&other: T)    -> T { return self * other; }\n-    pure fn div(&&other: T)    -> T { return self / other; }\n-    pure fn modulo(&&other: T) -> T { return self % other; }\n+    pure fn add(other: &T)    -> T { return self + *other; }\n+    pure fn sub(other: &T)    -> T { return self - *other; }\n+    pure fn mul(other: &T)    -> T { return self * *other; }\n+    pure fn div(other: &T)    -> T { return self / *other; }\n+    pure fn modulo(other: &T) -> T { return self % *other; }\n     pure fn neg()              -> T { return -self;        }\n \n     pure fn to_int()         -> int { return self as int; }\n@@ -126,7 +113,7 @@ impl T: iter::TimesIx {\n  *\n  * `buf` must not be empty\n  */\n-fn parse_bytes(buf: &[const u8], radix: uint) -> Option<T> {\n+pub fn parse_bytes(buf: &[const u8], radix: uint) -> Option<T> {\n     if vec::len(buf) == 0u { return None; }\n     let mut i = vec::len(buf) - 1u;\n     let mut power = 1u as T;\n@@ -143,14 +130,14 @@ fn parse_bytes(buf: &[const u8], radix: uint) -> Option<T> {\n }\n \n /// Parse a string to an int\n-fn from_str(s: &str) -> Option<T> { parse_bytes(str::to_bytes(s), 10u) }\n+pub fn from_str(s: &str) -> Option<T> { parse_bytes(str::to_bytes(s), 10u) }\n \n impl T : FromStr {\n     static fn from_str(s: &str) -> Option<T> { from_str(s) }\n }\n \n /// Parse a string as an unsigned integer.\n-fn from_str_radix(buf: &str, radix: u64) -> Option<u64> {\n+pub fn from_str_radix(buf: &str, radix: u64) -> Option<u64> {\n     if str::len(buf) == 0u { return None; }\n     let mut i = str::len(buf) - 1u;\n     let mut power = 1u64, n = 0u64;\n@@ -172,7 +159,7 @@ fn from_str_radix(buf: &str, radix: u64) -> Option<u64> {\n  *\n  * Fails if `radix` < 2 or `radix` > 16\n  */\n-pure fn to_str(num: T, radix: uint) -> ~str {\n+pub pure fn to_str(num: T, radix: uint) -> ~str {\n     do to_str_bytes(false, num, radix) |slice| {\n         do vec::as_imm_buf(slice) |p, len| {\n             unsafe { str::raw::from_buf_len(p, len) }\n@@ -181,7 +168,7 @@ pure fn to_str(num: T, radix: uint) -> ~str {\n }\n \n /// Low-level helper routine for string conversion.\n-pure fn to_str_bytes<U>(neg: bool, num: T, radix: uint,\n+pub pure fn to_str_bytes<U>(neg: bool, num: T, radix: uint,\n                    f: fn(v: &[u8]) -> U) -> U {\n \n     #[inline(always)]\n@@ -239,17 +226,16 @@ pure fn to_str_bytes<U>(neg: bool, num: T, radix: uint,\n                 *ptr::mut_offset(mp, i) = '-' as u8;\n             }\n \n-            vec::raw::form_slice(ptr::offset(p, i),\n-                                 len - i, f)\n+            vec::raw::buf_as_slice(ptr::offset(p, i), len - i, f)\n         }\n     }\n }\n \n /// Convert to a string\n-fn str(i: T) -> ~str { return to_str(i, 10u); }\n+pub fn str(i: T) -> ~str { return to_str(i, 10u); }\n \n #[test]\n-fn test_to_str() {\n+pub fn test_to_str() {\n     assert to_str(0 as T, 10u) == ~\"0\";\n     assert to_str(1 as T, 10u) == ~\"1\";\n     assert to_str(2 as T, 10u) == ~\"2\";\n@@ -261,7 +247,7 @@ fn test_to_str() {\n \n #[test]\n #[ignore]\n-fn test_from_str() {\n+pub fn test_from_str() {\n     assert from_str(~\"0\") == Some(0u as T);\n     assert from_str(~\"3\") == Some(3u as T);\n     assert from_str(~\"10\") == Some(10u as T);\n@@ -275,7 +261,7 @@ fn test_from_str() {\n \n #[test]\n #[ignore]\n-fn test_parse_bytes() {\n+pub fn test_parse_bytes() {\n     use str::to_bytes;\n     assert parse_bytes(to_bytes(~\"123\"), 10u) == Some(123u as T);\n     assert parse_bytes(to_bytes(~\"1001\"), 2u) == Some(9u as T);\n@@ -291,19 +277,19 @@ fn test_parse_bytes() {\n #[test]\n #[should_fail]\n #[ignore(cfg(windows))]\n-fn to_str_radix1() {\n+pub fn to_str_radix1() {\n     uint::to_str(100u, 1u);\n }\n \n #[test]\n #[should_fail]\n #[ignore(cfg(windows))]\n-fn to_str_radix17() {\n+pub fn to_str_radix17() {\n     uint::to_str(100u, 17u);\n }\n \n #[test]\n-fn test_times() {\n+pub fn test_times() {\n     use iter::Times;\n     let ten = 10 as T;\n     let mut accum = 0;"}, {"sha": "d8e078eb65c20ce6dd9ea6230fd643f9ee15e82b", "filename": "src/libcore/uint-template/u16.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fuint-template%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fuint-template%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template%2Fu16.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -1,2 +1,2 @@\n-type T = u16;\n-const bits: uint = 16;\n+pub type T = u16;\n+pub const bits: uint = 16;"}, {"sha": "0e2eb2f09e1d30b67c164ec99545ff53cac70bb8", "filename": "src/libcore/uint-template/u32.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fuint-template%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fuint-template%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template%2Fu32.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -1,2 +1,2 @@\n-type T = u32;\n-const bits: uint = 32;\n\\ No newline at end of file\n+pub type T = u32;\n+pub const bits: uint = 32;\n\\ No newline at end of file"}, {"sha": "030c6379628c59563bc23d8399208fc1b642eb99", "filename": "src/libcore/uint-template/u64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fuint-template%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fuint-template%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template%2Fu64.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -1,2 +1,2 @@\n-type T = u64;\n-const bits: uint = 64;\n\\ No newline at end of file\n+pub type T = u64;\n+pub const bits: uint = 64;\n\\ No newline at end of file"}, {"sha": "539567a2cfd45fc0fa45dfc2737b906f3259b389", "filename": "src/libcore/uint-template/u8.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fuint-template%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fuint-template%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template%2Fu8.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -1,7 +1,7 @@\n-type T = u8;\n-const bits: uint = 8;\n+pub type T = u8;\n+pub const bits: uint = 8;\n \n // Type-specific functions here. These must be reexported by the\n // parent module so that they appear in core::u8 and not core::u8::u8;\n \n-pure fn is_ascii(x: T) -> bool { return 0 as T == x & 128 as T; }\n+pub pure fn is_ascii(x: T) -> bool { return 0 as T == x & 128 as T; }"}, {"sha": "24beaad4d5e88bd9324513e97a43dad575396060", "filename": "src/libcore/uint-template/uint.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fuint-template%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fuint-template%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template%2Fuint.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -1,11 +1,11 @@\n-type T = uint;\n+pub type T = uint;\n \n #[cfg(target_arch = \"x86\")]\n #[cfg(target_arch = \"arm\")]\n-const bits: uint = 32;\n+pub const bits: uint = 32;\n \n #[cfg(target_arch = \"x86_64\")]\n-const bits: uint = 64;\n+pub const bits: uint = 64;\n \n /**\n  * Divide two numbers, return the result, rounded up.\n@@ -19,7 +19,7 @@ const bits: uint = 64;\n  *\n  * The smallest integer `q` such that `x/y <= q`.\n  */\n-pure fn div_ceil(x: uint, y: uint) -> uint {\n+pub pure fn div_ceil(x: uint, y: uint) -> uint {\n     let div = x / y;\n     if x % y == 0u { div }\n     else { div + 1u }\n@@ -37,7 +37,7 @@ pure fn div_ceil(x: uint, y: uint) -> uint {\n  *\n  * The integer `q` closest to `x/y`.\n  */\n-pure fn div_round(x: uint, y: uint) -> uint {\n+pub pure fn div_round(x: uint, y: uint) -> uint {\n     let div = x / y;\n     if x % y * 2u  < y { div }\n     else { div + 1u }\n@@ -58,7 +58,7 @@ pure fn div_round(x: uint, y: uint) -> uint {\n  * The smallest integer `q` such that `x/y <= q`. This\n  * is either `x/y` or `x/y + 1`.\n  */\n-pure fn div_floor(x: uint, y: uint) -> uint { return x / y; }\n+pub pure fn div_floor(x: uint, y: uint) -> uint { return x / y; }\n \n /**\n  * Iterate over the range [`lo`..`hi`), or stop when requested\n@@ -75,7 +75,7 @@ pure fn div_floor(x: uint, y: uint) -> uint { return x / y; }\n  * `true` If execution proceeded correctly, `false` if it was interrupted,\n  * that is if `it` returned `false` at any point.\n  */\n-pure fn iterate(lo: uint, hi: uint, it: fn(uint) -> bool) -> bool {\n+pub pure fn iterate(lo: uint, hi: uint, it: fn(uint) -> bool) -> bool {\n     let mut i = lo;\n     while i < hi {\n         if (!it(i)) { return false; }\n@@ -86,7 +86,7 @@ pure fn iterate(lo: uint, hi: uint, it: fn(uint) -> bool) -> bool {\n \n /// Returns the smallest power of 2 greater than or equal to `n`\n #[inline(always)]\n-fn next_power_of_two(n: uint) -> uint {\n+pub fn next_power_of_two(n: uint) -> uint {\n     let halfbits: uint = sys::size_of::<uint>() * 4u;\n     let mut tmp: uint = n - 1u;\n     let mut shift: uint = 1u;"}, {"sha": "9341ef7cef432116343d4ff14388be14ce54cf81", "filename": "src/libcore/unicode.rs", "status": "modified", "additions": 33, "deletions": 34, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -3,17 +3,16 @@\n #[forbid(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n \n-mod general_category {\n-    #[legacy_exports];\n-    pure fn Cc(c: char) -> bool {\n+pub mod general_category {\n+    pub pure fn Cc(c: char) -> bool {\n         return match c {\n               '\\x00' .. '\\x1f'\n             | '\\x7f' .. '\\x9f' => true,\n             _ => false\n         };\n     }\n \n-    pure fn Cf(c: char) -> bool {\n+    pub pure fn Cf(c: char) -> bool {\n         return match c {\n               '\\xad'\n             | '\\u0600' .. '\\u0603'\n@@ -32,21 +31,21 @@ mod general_category {\n         };\n     }\n \n-    pure fn Co(c: char) -> bool {\n+    pub pure fn Co(c: char) -> bool {\n         return match c {\n           '\\ue000' .. '\\uf8ff' => true,\n           _ => false\n         };\n     }\n \n-    pure fn Cs(c: char) -> bool {\n+    pub pure fn Cs(c: char) -> bool {\n         return match c {\n               '\\ud800' .. '\\udfff' => true,\n             _ => false\n         };\n     }\n \n-    pure fn Ll(c: char) -> bool {\n+    pub pure fn Ll(c: char) -> bool {\n         return match c {\n               '\\x61' .. '\\x7a'\n             | '\\xaa'\n@@ -651,7 +650,7 @@ mod general_category {\n         };\n     }\n \n-    pure fn Lm(c: char) -> bool {\n+    pub pure fn Lm(c: char) -> bool {\n         return match c {\n               '\\u02b0' .. '\\u02c1'\n             | '\\u02c6' .. '\\u02d1'\n@@ -707,7 +706,7 @@ mod general_category {\n         };\n     }\n \n-    pure fn Lo(c: char) -> bool {\n+    pub pure fn Lo(c: char) -> bool {\n         return match c {\n               '\\u01bb'\n             | '\\u01c0' .. '\\u01c3'\n@@ -893,7 +892,7 @@ mod general_category {\n         };\n     }\n \n-    pure fn Lt(c: char) -> bool {\n+    pub pure fn Lt(c: char) -> bool {\n         return match c {\n               '\\u01c5'\n             | '\\u01c8'\n@@ -910,7 +909,7 @@ mod general_category {\n         };\n     }\n \n-    pure fn Lu(c: char) -> bool {\n+    pub pure fn Lu(c: char) -> bool {\n         return match c {\n               '\\x41' .. '\\x5a'\n             | '\\xc0' .. '\\xd6'\n@@ -1502,7 +1501,7 @@ mod general_category {\n         };\n     }\n \n-    pure fn Mc(c: char) -> bool {\n+    pub pure fn Mc(c: char) -> bool {\n         return match c {\n               '\\u0903'\n             | '\\u093b'\n@@ -1613,7 +1612,7 @@ mod general_category {\n         };\n     }\n \n-    pure fn Me(c: char) -> bool {\n+    pub pure fn Me(c: char) -> bool {\n         return match c {\n               '\\u0488' .. '\\u0489'\n             | '\\u20dd' .. '\\u20e0'\n@@ -1624,7 +1623,7 @@ mod general_category {\n         };\n     }\n \n-    pure fn Mn(c: char) -> bool {\n+    pub pure fn Mn(c: char) -> bool {\n         return match c {\n               '\\u0300' .. '\\u036f'\n             | '\\u0483' .. '\\u0487'\n@@ -1817,7 +1816,7 @@ mod general_category {\n         };\n     }\n \n-    pure fn Nd(c: char) -> bool {\n+    pub pure fn Nd(c: char) -> bool {\n         return match c {\n               '\\x30' .. '\\x39'\n             | '\\u0660' .. '\\u0669'\n@@ -1861,7 +1860,7 @@ mod general_category {\n         };\n     }\n \n-    pure fn Nl(c: char) -> bool {\n+    pub pure fn Nl(c: char) -> bool {\n         return match c {\n               '\\u16ee' .. '\\u16f0'\n             | '\\u2160' .. '\\u2182'\n@@ -1880,7 +1879,7 @@ mod general_category {\n         };\n     }\n \n-    pure fn No(c: char) -> bool {\n+    pub pure fn No(c: char) -> bool {\n         return match c {\n               '\\xb2' .. '\\xb3'\n             | '\\xb9'\n@@ -1928,7 +1927,7 @@ mod general_category {\n         };\n     }\n \n-    pure fn Pc(c: char) -> bool {\n+    pub pure fn Pc(c: char) -> bool {\n         return match c {\n               '\\x5f'\n             | '\\u203f' .. '\\u2040'\n@@ -1941,7 +1940,7 @@ mod general_category {\n         };\n     }\n \n-    pure fn Pd(c: char) -> bool {\n+    pub pure fn Pd(c: char) -> bool {\n         return match c {\n               '\\x2d'\n             | '\\u058a'\n@@ -1963,7 +1962,7 @@ mod general_category {\n         };\n     }\n \n-    pure fn Pe(c: char) -> bool {\n+    pub pure fn Pe(c: char) -> bool {\n         return match c {\n               '\\x29'\n             | '\\x5d'\n@@ -2040,7 +2039,7 @@ mod general_category {\n         };\n     }\n \n-    pure fn Pf(c: char) -> bool {\n+    pub pure fn Pf(c: char) -> bool {\n         return match c {\n               '\\xbb'\n             | '\\u2019'\n@@ -2057,7 +2056,7 @@ mod general_category {\n         };\n     }\n \n-    pure fn Pi(c: char) -> bool {\n+    pub pure fn Pi(c: char) -> bool {\n         return match c {\n               '\\xab'\n             | '\\u2018'\n@@ -2075,7 +2074,7 @@ mod general_category {\n         };\n     }\n \n-    pure fn Po(c: char) -> bool {\n+    pub pure fn Po(c: char) -> bool {\n         return match c {\n               '\\x21' .. '\\x23'\n             | '\\x25' .. '\\x27'\n@@ -2208,7 +2207,7 @@ mod general_category {\n         };\n     }\n \n-    pure fn Ps(c: char) -> bool {\n+    pub pure fn Ps(c: char) -> bool {\n         return match c {\n               '\\x28'\n             | '\\x5b'\n@@ -2287,7 +2286,7 @@ mod general_category {\n         };\n     }\n \n-    pure fn Sc(c: char) -> bool {\n+    pub pure fn Sc(c: char) -> bool {\n         return match c {\n               '\\x24'\n             | '\\xa2' .. '\\xa5'\n@@ -2310,7 +2309,7 @@ mod general_category {\n         };\n     }\n \n-    pure fn Sk(c: char) -> bool {\n+    pub pure fn Sk(c: char) -> bool {\n         return match c {\n               '\\x5e'\n             | '\\x60'\n@@ -2344,7 +2343,7 @@ mod general_category {\n         };\n     }\n \n-    pure fn Sm(c: char) -> bool {\n+    pub pure fn Sm(c: char) -> bool {\n         return match c {\n               '\\x2b'\n             | '\\x3c' .. '\\x3e'\n@@ -2415,7 +2414,7 @@ mod general_category {\n         };\n     }\n \n-    pure fn So(c: char) -> bool {\n+    pub pure fn So(c: char) -> bool {\n         return match c {\n               '\\xa6' .. '\\xa7'\n             | '\\xa9'\n@@ -2534,21 +2533,21 @@ mod general_category {\n         };\n     }\n \n-    pure fn Zl(c: char) -> bool {\n+    pub pure fn Zl(c: char) -> bool {\n         return match c {\n           '\\u2028' => true,\n           _ => false\n         };\n     }\n \n-    pure fn Zp(c: char) -> bool {\n+    pub pure fn Zp(c: char) -> bool {\n         return match c {\n           '\\u2029' => true,\n           _ => false\n         };\n     }\n \n-    pure fn Zs(c: char) -> bool {\n+    pub pure fn Zs(c: char) -> bool {\n         return match c {\n               '\\x20'\n             | '\\xa0'\n@@ -2567,7 +2566,7 @@ mod general_category {\n mod derived_property {\n     #[legacy_exports];\n     /// Check if a character has the alphabetic unicode property\n-    pure fn Alphabetic(c: char) -> bool {\n+    pub pure fn Alphabetic(c: char) -> bool {\n         return match c {\n               '\\x41' .. '\\x5a'\n             | '\\x61' .. '\\x7a'\n@@ -3305,7 +3304,7 @@ mod derived_property {\n         };\n     }\n \n-    pure fn XID_Continue(c: char) -> bool {\n+    pub pure fn XID_Continue(c: char) -> bool {\n         return match c {\n               '\\x30' .. '\\x39'\n             | '\\x41' .. '\\x5a'\n@@ -4176,7 +4175,7 @@ mod derived_property {\n         };\n     }\n \n-    pure fn XID_Start(c: char) -> bool {\n+    pub pure fn XID_Start(c: char) -> bool {\n         return match c {\n               '\\x41' .. '\\x5a'\n             | '\\x61' .. '\\x7a'"}, {"sha": "aa1fe14ba88279b13cab470008207c970625081b", "filename": "src/libcore/util.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Futil.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -5,25 +5,25 @@ Miscellaneous helpers for common patterns.\n */\n \n // NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n+// tjc: re-forbid deprecated modes after snapshot\n #[forbid(deprecated_pattern)];\n \n use cmp::Eq;\n \n /// The identity function.\n #[inline(always)]\n-pure fn id<T>(+x: T) -> T { move x }\n+pub pure fn id<T>(x: T) -> T { move x }\n \n /// Ignores a value.\n #[inline(always)]\n-pure fn ignore<T>(+_x: T) { }\n+pub pure fn ignore<T>(_x: T) { }\n \n /// Sets `*ptr` to `new_value`, invokes `op()`, and then restores the\n /// original value of `*ptr`.\n #[inline(always)]\n-fn with<T: Copy, R>(\n+pub fn with<T: Copy, R>(\n     ptr: &mut T,\n-    +new_value: T,\n+    new_value: T,\n     op: &fn() -> R) -> R\n {\n     // NDM: if swap operator were defined somewhat differently,\n@@ -41,7 +41,7 @@ fn with<T: Copy, R>(\n  * deinitialising or copying either one.\n  */\n #[inline(always)]\n-fn swap<T>(x: &mut T, y: &mut T) {\n+pub fn swap<T>(x: &mut T, y: &mut T) {\n     *x <-> *y;\n }\n \n@@ -50,19 +50,19 @@ fn swap<T>(x: &mut T, y: &mut T) {\n  * value, without deinitialising or copying either one.\n  */\n #[inline(always)]\n-fn replace<T>(dest: &mut T, +src: T) -> T {\n+pub fn replace<T>(dest: &mut T, src: T) -> T {\n     let mut tmp <- src;\n     swap(dest, &mut tmp);\n     move tmp\n }\n \n /// A non-copyable dummy type.\n-struct NonCopyable {\n+pub struct NonCopyable {\n     i: (),\n     drop { }\n }\n \n-fn NonCopyable() -> NonCopyable { NonCopyable { i: () } }\n+pub fn NonCopyable() -> NonCopyable { NonCopyable { i: () } }\n \n /**\n A utility function for indicating unreachable code. It will fail if\n@@ -88,7 +88,7 @@ fn choose_weighted_item(v: &[Item]) -> Item {\n ~~~\n \n */\n-fn unreachable() -> ! {\n+pub fn unreachable() -> ! {\n     fail ~\"internal error: entered unreachable code\";\n }\n "}, {"sha": "0c822bd0a031d991bea961b0ff4ff9f832c87a3b", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 1059, "deletions": 503, "changes": 1562, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130", "patch": "@@ -1,127 +1,38 @@\n //! Vectors\n \n+#[warn(deprecated_mode)];\n+#[warn(deprecated_pattern)];\n+#[warn(non_camel_case_types)];\n+\n use cmp::{Eq, Ord};\n use option::{Some, None};\n use ptr::addr_of;\n use libc::size_t;\n \n-export append;\n-export append_one;\n-export consume, consume_mut;\n-export init_op;\n-export is_empty;\n-export is_not_empty;\n-export same_length;\n-export reserve;\n-export reserve_at_least;\n-export capacity;\n-export len;\n-export from_fn;\n-export from_elem;\n-export from_slice;\n-export with_capacity;\n-export build, build_sized, build_sized_opt;\n-export to_mut;\n-export from_mut;\n-export head;\n-export tail;\n-export tailn;\n-export init;\n-export last;\n-export last_opt;\n-export slice;\n-export view, mut_view, const_view;\n-export split;\n-export splitn;\n-export rsplit;\n-export rsplitn;\n-export shift;\n-export unshift;\n-export pop;\n-export swap_remove;\n-export push, push_all, push_all_move;\n-export grow;\n-export grow_fn;\n-export grow_set;\n-export truncate;\n-export dedup;\n-export map;\n-export mapi;\n-export map2;\n-export map_consume;\n-export flat_map;\n-export filter_map;\n-export filter;\n-export concat;\n-export connect;\n-export foldl;\n-export foldr;\n-export any;\n-export any2;\n-export all;\n-export alli;\n-export all2;\n-export contains;\n-export count;\n-export find;\n-export find_between;\n-export rfind;\n-export rfind_between;\n-export position_elem;\n-export position;\n-export position_between;\n-export rposition;\n-export rposition_between;\n-export unzip;\n-export zip, zip_slice;\n-export swap;\n-export reverse;\n-export reversed;\n-export each, each_mut, each_const, eachi, rev_each, rev_eachi;\n-export iter2;\n-export permute;\n-export windowed;\n-export as_imm_buf;\n-export as_mut_buf;\n-export as_const_buf;\n-export raw;\n-export bytes;\n-export extensions;\n-export ConstVector;\n-export CopyableVector;\n-export ImmutableVector;\n-export ImmutableEqVector;\n-export ImmutableCopyableVector;\n-export IterTraitExtensions;\n-export vec_concat;\n-export traits;\n-\n #[abi = \"cdecl\"]\n extern mod rustrt {\n-    #[legacy_exports];\n     fn vec_reserve_shared(++t: *sys::TypeDesc,\n                           ++v: **raw::VecRepr,\n                           ++n: libc::size_t);\n }\n \n #[abi = \"rust-intrinsic\"]\n extern mod rusti {\n-    #[legacy_exports];\n     fn move_val_init<T>(&dst: T, -src: T);\n }\n \n /// Returns true if a vector contains no elements\n-pure fn is_empty<T>(v: &[const T]) -> bool {\n+pub pure fn is_empty<T>(v: &[const T]) -> bool {\n     as_const_buf(v, |_p, len| len == 0u)\n }\n \n /// Returns true if a vector contains some elements\n-pure fn is_not_empty<T>(v: &[const T]) -> bool {\n+pub pure fn is_not_empty<T>(v: &[const T]) -> bool {\n     as_const_buf(v, |_p, len| len > 0u)\n }\n \n /// Returns true if two vectors have the same length\n-pure fn same_length<T, U>(xs: &[const T], ys: &[const U]) -> bool {\n+pub pure fn same_length<T, U>(xs: &[const T], ys: &[const U]) -> bool {\n     len(xs) == len(ys)\n }\n \n@@ -136,9 +47,9 @@ pure fn same_length<T, U>(xs: &[const T], ys: &[const U]) -> bool {\n  * * v - A vector\n  * * n - The number of elements to reserve space for\n  */\n-fn reserve<T>(+v: &mut ~[T], +n: uint) {\n+pub fn reserve<T>(v: &mut ~[T], n: uint) {\n     // Only make the (slow) call into the runtime if we have to\n-    if capacity(*v) < n {\n+    if capacity(v) < n {\n         unsafe {\n             let ptr: **raw::VecRepr = cast::transmute(v);\n             rustrt::vec_reserve_shared(sys::get_type_desc::<T>(),\n@@ -162,22 +73,22 @@ fn reserve<T>(+v: &mut ~[T], +n: uint) {\n  * * v - A vector\n  * * n - The number of elements to reserve space for\n  */\n-fn reserve_at_least<T>(v: &mut ~[T], n: uint) {\n+pub fn reserve_at_least<T>(v: &mut ~[T], n: uint) {\n     reserve(v, uint::next_power_of_two(n));\n }\n \n /// Returns the number of elements the vector can hold without reallocating\n #[inline(always)]\n-pure fn capacity<T>(&&v: ~[const T]) -> uint {\n+pub pure fn capacity<T>(v: &const ~[T]) -> uint {\n     unsafe {\n-        let repr: **raw::VecRepr = ::cast::reinterpret_cast(&addr_of(v));\n+        let repr: **raw::VecRepr = ::cast::transmute(v);\n         (**repr).unboxed.alloc / sys::size_of::<T>()\n     }\n }\n \n /// Returns the length of a vector\n #[inline(always)]\n-pure fn len<T>(&&v: &[const T]) -> uint {\n+pub pure fn len<T>(v: &[const T]) -> uint {\n     as_const_buf(v, |_p, len| len)\n }\n \n@@ -187,12 +98,19 @@ pure fn len<T>(&&v: &[const T]) -> uint {\n  * Creates an immutable vector of size `n_elts` and initializes the elements\n  * to the value returned by the function `op`.\n  */\n-pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> ~[T] {\n-    let mut v = with_capacity(n_elts);\n-    let mut i: uint = 0u;\n-    while i < n_elts unsafe { raw::set(v, i, op(i)); i += 1u; }\n-    unsafe { raw::set_len(v, n_elts); }\n-    move v\n+pub pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> ~[T] {\n+    unsafe {\n+        let mut v = with_capacity(n_elts);\n+        do as_mut_buf(v) |p, _len| {\n+            let mut i: uint = 0u;\n+            while i < n_elts {\n+                rusti::move_val_init(*ptr::mut_offset(p, i), op(i));\n+                i += 1u;\n+            }\n+        }\n+        raw::set_len(&mut v, n_elts);\n+        return move v;\n+    }\n }\n \n /**\n@@ -201,22 +119,16 @@ pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> ~[T] {\n  * Creates an immutable vector of size `n_elts` and initializes the elements\n  * to the value `t`.\n  */\n-pure fn from_elem<T: Copy>(n_elts: uint, t: T) -> ~[T] {\n-    let mut v = with_capacity(n_elts);\n-    let mut i: uint = 0u;\n-    unsafe { // because unsafe::set is unsafe\n-        while i < n_elts { raw::set(v, i, t); i += 1u; }\n-        unsafe { raw::set_len(v, n_elts); }\n-    }\n-    move v\n+pub pure fn from_elem<T: Copy>(n_elts: uint, t: T) -> ~[T] {\n+    from_fn(n_elts, |_i| copy t)\n }\n \n /// Creates a new unique vector with the same contents as the slice\n-pure fn from_slice<T: Copy>(t: &[T]) -> ~[T] {\n+pub pure fn from_slice<T: Copy>(t: &[T]) -> ~[T] {\n     from_fn(t.len(), |i| t[i])\n }\n \n-pure fn with_capacity<T>(capacity: uint) -> ~[T] {\n+pub pure fn with_capacity<T>(capacity: uint) -> ~[T] {\n     let mut vec = ~[];\n     unsafe { reserve(&mut vec, capacity); }\n     return move vec;\n@@ -235,10 +147,10 @@ pure fn with_capacity<T>(capacity: uint) -> ~[T] {\n  *             onto the vector being constructed.\n  */\n #[inline(always)]\n-pure fn build_sized<A>(size: uint,\n-                       builder: fn(push: pure fn(+v: A))) -> ~[A] {\n+pub pure fn build_sized<A>(size: uint,\n+                       builder: fn(push: pure fn(v: A))) -> ~[A] {\n     let mut vec = with_capacity(size);\n-    builder(|+x| unsafe { push(vec, move x) });\n+    builder(|x| unsafe { vec.push(move x) });\n     move vec\n }\n \n@@ -253,7 +165,7 @@ pure fn build_sized<A>(size: uint,\n  *             onto the vector being constructed.\n  */\n #[inline(always)]\n-pure fn build<A>(builder: fn(push: pure fn(+v: A))) -> ~[A] {\n+pub pure fn build<A>(builder: fn(push: pure fn(v: A))) -> ~[A] {\n     build_sized(4, builder)\n }\n \n@@ -270,47 +182,47 @@ pure fn build<A>(builder: fn(push: pure fn(+v: A))) -> ~[A] {\n  *             onto the vector being constructed.\n  */\n #[inline(always)]\n-pure fn build_sized_opt<A>(size: Option<uint>,\n-                           builder: fn(push: pure fn(+v: A))) -> ~[A] {\n+pub pure fn build_sized_opt<A>(size: Option<uint>,\n+                           builder: fn(push: pure fn(v: A))) -> ~[A] {\n     build_sized(size.get_default(4), builder)\n }\n \n /// Produces a mut vector from an immutable vector.\n-pure fn to_mut<T>(+v: ~[T]) -> ~[mut T] {\n+pub pure fn to_mut<T>(v: ~[T]) -> ~[mut T] {\n     unsafe { ::cast::transmute(move v) }\n }\n \n /// Produces an immutable vector from a mut vector.\n-pure fn from_mut<T>(+v: ~[mut T]) -> ~[T] {\n+pub pure fn from_mut<T>(v: ~[mut T]) -> ~[T] {\n     unsafe { ::cast::transmute(move v) }\n }\n \n // Accessors\n \n /// Returns the first element of a vector\n-pure fn head<T: Copy>(v: &[const T]) -> T { v[0] }\n+pub pure fn head<T: Copy>(v: &[const T]) -> T { v[0] }\n \n /// Returns a vector containing all but the first element of a slice\n-pure fn tail<T: Copy>(v: &[const T]) -> ~[T] {\n+pub pure fn tail<T: Copy>(v: &[const T]) -> ~[T] {\n     return slice(v, 1u, len(v));\n }\n \n /**\n  * Returns a vector containing all but the first `n` \\\n  * elements of a slice\n  */\n-pure fn tailn<T: Copy>(v: &[const T], n: uint) -> ~[T] {\n+pub pure fn tailn<T: Copy>(v: &[const T], n: uint) -> ~[T] {\n     slice(v, n, len(v))\n }\n \n /// Returns a vector containing all but the last element of a slice\n-pure fn init<T: Copy>(v: &[const T]) -> ~[T] {\n+pub pure fn init<T: Copy>(v: &[const T]) -> ~[T] {\n     assert len(v) != 0u;\n     slice(v, 0u, len(v) - 1u)\n }\n \n /// Returns the last element of the slice `v`, failing if the slice is empty.\n-pure fn last<T: Copy>(v: &[const T]) -> T {\n+pub pure fn last<T: Copy>(v: &[const T]) -> T {\n     if len(v) == 0u { fail ~\"last_unsafe: empty vector\" }\n     v[len(v) - 1u]\n }\n@@ -319,24 +231,24 @@ pure fn last<T: Copy>(v: &[const T]) -> T {\n  * Returns `Some(x)` where `x` is the last element of the slice `v`,\n  * or `none` if the vector is empty.\n  */\n-pure fn last_opt<T: Copy>(v: &[const T]) -> Option<T> {\n+pub pure fn last_opt<T: Copy>(v: &[const T]) -> Option<T> {\n     if len(v) == 0u { return None; }\n     Some(v[len(v) - 1u])\n }\n \n /// Returns a copy of the elements from [`start`..`end`) from `v`.\n-pure fn slice<T: Copy>(v: &[const T], start: uint, end: uint) -> ~[T] {\n+pub pure fn slice<T: Copy>(v: &[const T], start: uint, end: uint) -> ~[T] {\n     assert (start <= end);\n     assert (end <= len(v));\n     let mut result = ~[];\n     unsafe {\n-        for uint::range(start, end) |i| { vec::push(result, v[i]) }\n+        for uint::range(start, end) |i| { result.push(v[i]) }\n     }\n     move result\n }\n \n /// Return a slice that points into another slice.\n-pure fn view<T>(v: &[T], start: uint, end: uint) -> &[T] {\n+pub pure fn view<T>(v: &r/[T], start: uint, end: uint) -> &r/[T] {\n     assert (start <= end);\n     assert (end <= len(v));\n     do as_imm_buf(v) |p, _len| {\n@@ -349,7 +261,7 @@ pure fn view<T>(v: &[T], start: uint, end: uint) -> &[T] {\n }\n \n /// Return a slice that points into another slice.\n-pure fn mut_view<T>(v: &[mut T], start: uint, end: uint) -> &[mut T] {\n+pub pure fn mut_view<T>(v: &r/[mut T], start: uint, end: uint) -> &r/[mut T] {\n     assert (start <= end);\n     assert (end <= len(v));\n     do as_mut_buf(v) |p, _len| {\n@@ -362,7 +274,8 @@ pure fn mut_view<T>(v: &[mut T], start: uint, end: uint) -> &[mut T] {\n }\n \n /// Return a slice that points into another slice.\n-pure fn const_view<T>(v: &[const T], start: uint, end: uint) -> &[const T] {\n+pub pure fn const_view<T>(v: &r/[const T], start: uint,\n+                      end: uint) -> &r/[const T] {\n     assert (start <= end);\n     assert (end <= len(v));\n     do as_const_buf(v) |p, _len| {\n@@ -375,30 +288,30 @@ pure fn const_view<T>(v: &[const T], start: uint, end: uint) -> &[const T] {\n }\n \n /// Split the vector `v` by applying each element against the predicate `f`.\n-fn split<T: Copy>(v: &[T], f: fn(T) -> bool) -> ~[~[T]] {\n+pub fn split<T: Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[~[T]] {\n     let ln = len(v);\n     if (ln == 0u) { return ~[] }\n \n     let mut start = 0u;\n     let mut result = ~[];\n     while start < ln {\n         match position_between(v, start, ln, f) {\n-          None => break,\n-          Some(i) => {\n-            push(result, slice(v, start, i));\n-            start = i + 1u;\n-          }\n+            None => break,\n+            Some(i) => {\n+                result.push(slice(v, start, i));\n+                start = i + 1u;\n+            }\n         }\n     }\n-    push(result, slice(v, start, ln));\n+    result.push(slice(v, start, ln));\n     move result\n }\n \n /**\n  * Split the vector `v` by applying each element against the predicate `f` up\n  * to `n` times.\n  */\n-fn splitn<T: Copy>(v: &[T], n: uint, f: fn(T) -> bool) -> ~[~[T]] {\n+pub fn splitn<T: Copy>(v: &[T], n: uint, f: fn(t: &T) -> bool) -> ~[~[T]] {\n     let ln = len(v);\n     if (ln == 0u) { return ~[] }\n \n@@ -407,39 +320,39 @@ fn splitn<T: Copy>(v: &[T], n: uint, f: fn(T) -> bool) -> ~[~[T]] {\n     let mut result = ~[];\n     while start < ln && count > 0u {\n         match position_between(v, start, ln, f) {\n-          None => break,\n-          Some(i) => {\n-            push(result, slice(v, start, i));\n-            // Make sure to skip the separator.\n-            start = i + 1u;\n-            count -= 1u;\n-          }\n+            None => break,\n+            Some(i) => {\n+                result.push(slice(v, start, i));\n+                // Make sure to skip the separator.\n+                start = i + 1u;\n+                count -= 1u;\n+            }\n         }\n     }\n-    push(result, slice(v, start, ln));\n+    result.push(slice(v, start, ln));\n     move result\n }\n \n /**\n  * Reverse split the vector `v` by applying each element against the predicate\n  * `f`.\n  */\n-fn rsplit<T: Copy>(v: &[T], f: fn(T) -> bool) -> ~[~[T]] {\n+pub fn rsplit<T: Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[~[T]] {\n     let ln = len(v);\n     if (ln == 0u) { return ~[] }\n \n     let mut end = ln;\n     let mut result = ~[];\n     while end > 0u {\n         match rposition_between(v, 0u, end, f) {\n-          None => break,\n-          Some(i) => {\n-            push(result, slice(v, i + 1u, end));\n-            end = i;\n-          }\n+            None => break,\n+            Some(i) => {\n+                result.push(slice(v, i + 1u, end));\n+                end = i;\n+            }\n         }\n     }\n-    push(result, slice(v, 0u, end));\n+    result.push(slice(v, 0u, end));\n     reverse(result);\n     return move result;\n }\n@@ -448,7 +361,7 @@ fn rsplit<T: Copy>(v: &[T], f: fn(T) -> bool) -> ~[~[T]] {\n  * Reverse split the vector `v` by applying each element against the predicate\n  * `f` up to `n times.\n  */\n-fn rsplitn<T: Copy>(v: &[T], n: uint, f: fn(T) -> bool) -> ~[~[T]] {\n+pub fn rsplitn<T: Copy>(v: &[T], n: uint, f: fn(t: &T) -> bool) -> ~[~[T]] {\n     let ln = len(v);\n     if (ln == 0u) { return ~[] }\n \n@@ -457,29 +370,29 @@ fn rsplitn<T: Copy>(v: &[T], n: uint, f: fn(T) -> bool) -> ~[~[T]] {\n     let mut result = ~[];\n     while end > 0u && count > 0u {\n         match rposition_between(v, 0u, end, f) {\n-          None => break,\n-          Some(i) => {\n-            push(result, slice(v, i + 1u, end));\n-            // Make sure to skip the separator.\n-            end = i;\n-            count -= 1u;\n-          }\n+            None => break,\n+            Some(i) => {\n+                result.push(slice(v, i + 1u, end));\n+                // Make sure to skip the separator.\n+                end = i;\n+                count -= 1u;\n+            }\n         }\n     }\n-    push(result, slice(v, 0u, end));\n+    result.push(slice(v, 0u, end));\n     reverse(result);\n     move result\n }\n \n // Mutators\n \n /// Removes the first element from a vector and return it\n-fn shift<T>(&v: ~[T]) -> T {\n-    let ln = len::<T>(v);\n+pub fn shift<T>(v: &mut ~[T]) -> T {\n+    let ln = v.len();\n     assert (ln > 0);\n \n     let mut vv = ~[];\n-    v <-> vv;\n+    *v <-> vv;\n \n     unsafe {\n         let mut rr;\n@@ -489,55 +402,48 @@ fn shift<T>(&v: ~[T]) -> T {\n \n             for uint::range(1, ln) |i| {\n                 let r <- *ptr::offset(vv, i);\n-                push(v, move r);\n+                v.push(move r);\n             }\n         }\n-        raw::set_len(vv, 0);\n+        raw::set_len(&mut vv, 0);\n \n         move rr\n     }\n }\n \n /// Prepend an element to the vector\n-fn unshift<T>(&v: ~[T], +x: T) {\n+pub fn unshift<T>(v: &mut ~[T], x: T) {\n     let mut vv = ~[move x];\n-    v <-> vv;\n-    while len(vv) > 0 {\n-        push(v, shift(vv));\n-    }\n+    *v <-> vv;\n+    v.push_all_move(vv);\n }\n \n-fn consume<T>(+v: ~[T], f: fn(uint, +v: T)) unsafe {\n+pub fn consume<T>(v: ~[T], f: fn(uint, v: T)) unsafe {\n+    let mut v = move v; // FIXME(#3488)\n+\n     do as_imm_buf(v) |p, ln| {\n         for uint::range(0, ln) |i| {\n             let x <- *ptr::offset(p, i);\n             f(i, move x);\n         }\n     }\n \n-    raw::set_len(v, 0);\n+    raw::set_len(&mut v, 0);\n }\n \n-fn consume_mut<T>(+v: ~[mut T], f: fn(uint, +v: T)) unsafe {\n-    do as_imm_buf(v) |p, ln| {\n-        for uint::range(0, ln) |i| {\n-            let x <- *ptr::offset(p, i);\n-            f(i, move x);\n-        }\n-    }\n-\n-    raw::set_len(v, 0);\n+pub fn consume_mut<T>(v: ~[mut T], f: fn(uint, v: T)) {\n+    consume(vec::from_mut(v), f)\n }\n \n /// Remove the last element from a vector and return it\n-fn pop<T>(&v: ~[const T]) -> T {\n-    let ln = len(v);\n+pub fn pop<T>(v: &mut ~[T]) -> T {\n+    let ln = v.len();\n     if ln == 0 {\n         fail ~\"sorry, cannot vec::pop an empty vector\"\n     }\n-    let valptr = ptr::mut_addr_of(v[ln - 1u]);\n+    let valptr = ptr::to_mut_unsafe_ptr(&mut v[ln - 1u]);\n     unsafe {\n-        let val <- *valptr;\n+        let val = move *valptr;\n         raw::set_len(v, ln - 1u);\n         move val\n     }\n@@ -549,28 +455,22 @@ fn pop<T>(&v: ~[const T]) -> T {\n  *\n  * Fails if index >= length.\n  */\n-fn swap_remove<T>(&v: ~[const T], index: uint) -> T {\n-    let ln = len(v);\n+pub fn swap_remove<T>(v: &mut ~[T], index: uint) -> T {\n+    let ln = v.len();\n     if index >= ln {\n         fail fmt!(\"vec::swap_remove - index %u >= length %u\", index, ln);\n     }\n-    let lastptr = ptr::mut_addr_of(v[ln - 1]);\n-    unsafe {\n-        let mut val <- *lastptr;\n-        if index < ln - 1 {\n-            let valptr = ptr::mut_addr_of(v[index]);\n-            *valptr <-> val;\n-        }\n-        raw::set_len(v, ln - 1);\n-        move val\n+    if index < ln - 1 {\n+        v[index] <-> v[ln - 1];\n     }\n+    vec::pop(v)\n }\n \n /// Append an element to a vector\n #[inline(always)]\n-fn push<T>(&v: ~[T], +initval: T) {\n+pub fn push<T>(v: &mut ~[T], initval: T) {\n     unsafe {\n-        let repr: **raw::VecRepr = ::cast::reinterpret_cast(&addr_of(v));\n+        let repr: **raw::VecRepr = ::cast::transmute(copy v);\n         let fill = (**repr).unboxed.fill;\n         if (**repr).unboxed.alloc > fill {\n             push_fast(v, move initval);\n@@ -583,47 +483,48 @@ fn push<T>(&v: ~[T], +initval: T) {\n \n // This doesn't bother to make sure we have space.\n #[inline(always)] // really pretty please\n-unsafe fn push_fast<T>(&v: ~[T], +initval: T) {\n-    let repr: **raw::VecRepr = ::cast::reinterpret_cast(&addr_of(v));\n+unsafe fn push_fast<T>(v: &mut ~[T], initval: T) {\n+    let repr: **raw::VecRepr = ::cast::transmute(v);\n     let fill = (**repr).unboxed.fill;\n     (**repr).unboxed.fill += sys::size_of::<T>();\n-    let p = ptr::addr_of((**repr).unboxed.data);\n+    let p = addr_of(&((**repr).unboxed.data));\n     let p = ptr::offset(p, fill) as *mut T;\n     rusti::move_val_init(*p, move initval);\n }\n \n #[inline(never)]\n-fn push_slow<T>(&v: ~[T], +initval: T) {\n-    reserve_at_least(&mut v, v.len() + 1u);\n+fn push_slow<T>(v: &mut ~[T], initval: T) {\n+    reserve_at_least(v, v.len() + 1u);\n     unsafe { push_fast(v, move initval) }\n }\n \n #[inline(always)]\n-fn push_all<T: Copy>(&v: ~[T], rhs: &[const T]) {\n-    reserve(&mut v, v.len() + rhs.len());\n+pub fn push_all<T: Copy>(v: &mut ~[T], rhs: &[const T]) {\n+    reserve(v, v.len() + rhs.len());\n \n     for uint::range(0u, rhs.len()) |i| {\n         push(v, unsafe { raw::get(rhs, i) })\n     }\n }\n \n #[inline(always)]\n-fn push_all_move<T>(&v: ~[T], -rhs: ~[const T]) {\n-    reserve(&mut v, v.len() + rhs.len());\n+pub fn push_all_move<T>(v: &mut ~[T], rhs: ~[T]) {\n+    let mut rhs = move rhs; // FIXME(#3488)\n+    reserve(v, v.len() + rhs.len());\n     unsafe {\n         do as_imm_buf(rhs) |p, len| {\n             for uint::range(0, len) |i| {\n                 let x <- *ptr::offset(p, i);\n                 push(v, move x);\n             }\n         }\n-        raw::set_len(rhs, 0);\n+        raw::set_len(&mut rhs, 0);\n     }\n }\n \n /// Shorten a vector, dropping excess elements.\n-fn truncate<T>(&v: ~[const T], newlen: uint) {\n-    do as_imm_buf(v) |p, oldlen| {\n+pub fn truncate<T>(v: &mut ~[T], newlen: uint) {\n+    do as_imm_buf(*v) |p, oldlen| {\n         assert(newlen <= oldlen);\n         unsafe {\n             // This loop is optimized out for non-drop types.\n@@ -639,10 +540,10 @@ fn truncate<T>(&v: ~[const T], newlen: uint) {\n  * Remove consecutive repeated elements from a vector; if the vector is\n  * sorted, this removes all duplicates.\n  */\n-fn dedup<T: Eq>(&v: ~[const T]) unsafe {\n+pub fn dedup<T: Eq>(v: &mut ~[T]) unsafe {\n     if v.len() < 1 { return; }\n     let mut last_written = 0, next_to_read = 1;\n-    do as_const_buf(v) |p, ln| {\n+    do as_const_buf(*v) |p, ln| {\n         // We have a mutable reference to v, so we can make arbitrary changes.\n         // (cf. push and pop)\n         let p = p as *mut T;\n@@ -672,23 +573,23 @@ fn dedup<T: Eq>(&v: ~[const T]) unsafe {\n \n // Appending\n #[inline(always)]\n-pure fn append<T: Copy>(+lhs: ~[T], rhs: &[const T]) -> ~[T] {\n+pub pure fn append<T: Copy>(lhs: ~[T], rhs: &[const T]) -> ~[T] {\n     let mut v <- lhs;\n     unsafe {\n-        push_all(v, rhs);\n+        v.push_all(rhs);\n     }\n     move v\n }\n \n #[inline(always)]\n-pure fn append_one<T>(+lhs: ~[T], +x: T) -> ~[T] {\n+pub pure fn append_one<T>(lhs: ~[T], x: T) -> ~[T] {\n     let mut v <- lhs;\n-    unsafe { push(v, move x); }\n+    unsafe { v.push(move x); }\n     move v\n }\n \n #[inline(always)]\n-pure fn append_mut<T: Copy>(+lhs: ~[mut T], rhs: &[const T]) -> ~[mut T] {\n+pure fn append_mut<T: Copy>(lhs: ~[mut T], rhs: &[const T]) -> ~[mut T] {\n     to_mut(append(from_mut(lhs), rhs))\n }\n \n@@ -701,11 +602,14 @@ pure fn append_mut<T: Copy>(+lhs: ~[mut T], rhs: &[const T]) -> ~[mut T] {\n  * * n - The number of elements to add\n  * * initval - The value for the new elements\n  */\n-fn grow<T: Copy>(&v: ~[T], n: uint, initval: T) {\n-    reserve_at_least(&mut v, len(v) + n);\n+pub fn grow<T: Copy>(v: &mut ~[T], n: uint, initval: &T) {\n+    reserve_at_least(v, v.len() + n);\n     let mut i: uint = 0u;\n \n-    while i < n { push(v, initval); i += 1u; }\n+    while i < n {\n+        v.push(*initval);\n+        i += 1u;\n+    }\n }\n \n /**\n@@ -721,10 +625,13 @@ fn grow<T: Copy>(&v: ~[T], n: uint, initval: T) {\n  * * init_op - A function to call to retreive each appended element's\n  *             value\n  */\n-fn grow_fn<T>(&v: ~[T], n: uint, op: iter::InitOp<T>) {\n-    reserve_at_least(&mut v, len(v) + n);\n+pub fn grow_fn<T>(v: &mut ~[T], n: uint, op: iter::InitOp<T>) {\n+    reserve_at_least(v, v.len() + n);\n     let mut i: uint = 0u;\n-    while i < n { push(v, op(i)); i += 1u; }\n+    while i < n {\n+        v.push(op(i));\n+        i += 1u;\n+    }\n }\n \n /**\n@@ -735,30 +642,35 @@ fn grow_fn<T>(&v: ~[T], n: uint, op: iter::InitOp<T>) {\n  * of the vector, expands the vector by replicating `initval` to fill the\n  * intervening space.\n  */\n-fn grow_set<T: Copy>(&v: ~[T], index: uint, initval: T, val: T) {\n-    if index >= len(v) { grow(v, index - len(v) + 1u, initval); }\n-    v[index] = val;\n+pub fn grow_set<T: Copy>(v: &mut ~[T], index: uint, initval: &T, val: T) {\n+    let l = v.len();\n+    if index >= l { grow(v, index - l + 1u, initval); }\n+    v[index] = move val;\n }\n \n // Functional utilities\n \n /// Apply a function to each element of a vector and return the results\n-pure fn map<T, U>(v: &[T], f: fn(v: &T) -> U) -> ~[U] {\n+pub pure fn map<T, U>(v: &[T], f: fn(t: &T) -> U) -> ~[U] {\n     let mut result = with_capacity(len(v));\n-    for each(v) |elem| { unsafe { push(result, f(elem)); } }\n+    for each(v) |elem| {\n+        unsafe {\n+            result.push(f(elem));\n+        }\n+    }\n     move result\n }\n \n-fn map_consume<T, U>(+v: ~[T], f: fn(+v: T) -> U) -> ~[U] {\n+pub fn map_consume<T, U>(v: ~[T], f: fn(v: T) -> U) -> ~[U] {\n     let mut result = ~[];\n     do consume(move v) |_i, x| {\n-        vec::push(result, f(move x));\n+        result.push(f(move x));\n     }\n     move result\n }\n \n /// Apply a function to each element of a vector and return the results\n-pure fn mapi<T, U>(v: &[T], f: fn(uint, v: &T) -> U) -> ~[U] {\n+pub pure fn mapi<T, U>(v: &[T], f: fn(uint, t: &T) -> U) -> ~[U] {\n     let mut i = 0;\n     do map(v) |e| {\n         i += 1;\n@@ -770,21 +682,21 @@ pure fn mapi<T, U>(v: &[T], f: fn(uint, v: &T) -> U) -> ~[U] {\n  * Apply a function to each element of a vector and return a concatenation\n  * of each result vector\n  */\n-pure fn flat_map<T, U>(v: &[T], f: fn(T) -> ~[U]) -> ~[U] {\n+pub pure fn flat_map<T, U>(v: &[T], f: fn(t: &T) -> ~[U]) -> ~[U] {\n     let mut result = ~[];\n-    for each(v) |elem| { unsafe{ push_all_move(result, f(*elem)); } }\n+    for each(v) |elem| { unsafe{ result.push_all_move(f(elem)); } }\n     move result\n }\n \n /// Apply a function to each pair of elements and return the results\n-pure fn map2<T: Copy, U: Copy, V>(v0: &[T], v1: &[U],\n-                                  f: fn(T, U) -> V) -> ~[V] {\n+pub pure fn map2<T: Copy, U: Copy, V>(v0: &[T], v1: &[U],\n+                                  f: fn(t: &T, v: &U) -> V) -> ~[V] {\n     let v0_len = len(v0);\n     if v0_len != len(v1) { fail; }\n     let mut u: ~[V] = ~[];\n     let mut i = 0u;\n     while i < v0_len {\n-        unsafe { push(u, f(copy v0[i], copy v1[i])) };\n+        unsafe { u.push(f(&v0[i], &v1[i])) };\n         i += 1u;\n     }\n     move u\n@@ -796,13 +708,13 @@ pure fn map2<T: Copy, U: Copy, V>(v0: &[T], v1: &[U],\n  * If function `f` returns `none` then that element is excluded from\n  * the resulting vector.\n  */\n-pure fn filter_map<T, U: Copy>(v: &[T], f: fn(T) -> Option<U>)\n+pub pure fn filter_map<T, U: Copy>(v: &[T], f: fn(t: &T) -> Option<U>)\n     -> ~[U] {\n     let mut result = ~[];\n     for each(v) |elem| {\n-        match f(*elem) {\n+        match f(elem) {\n           None => {/* no-op */ }\n-          Some(result_elem) => unsafe { push(result, result_elem); }\n+          Some(move result_elem) => unsafe { result.push(result_elem); }\n         }\n     }\n     move result\n@@ -815,10 +727,10 @@ pure fn filter_map<T, U: Copy>(v: &[T], f: fn(T) -> Option<U>)\n  * Apply function `f` to each element of `v` and return a vector containing\n  * only those elements for which `f` returned true.\n  */\n-pure fn filter<T: Copy>(v: &[T], f: fn(T) -> bool) -> ~[T] {\n+pub pure fn filter<T: Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[T] {\n     let mut result = ~[];\n     for each(v) |elem| {\n-        if f(*elem) { unsafe { push(result, *elem); } }\n+        if f(elem) { unsafe { result.push(*elem); } }\n     }\n     move result\n }\n@@ -828,37 +740,39 @@ pure fn filter<T: Copy>(v: &[T], f: fn(T) -> bool) -> ~[T] {\n  *\n  * Flattens a vector of vectors of T into a single vector of T.\n  */\n-pure fn concat<T: Copy>(v: &[~[T]]) -> ~[T] {\n+pub pure fn concat<T: Copy>(v: &[~[T]]) -> ~[T] {\n     let mut r = ~[];\n-    for each(v) |inner| { unsafe { push_all(r, *inner); } }\n+    for each(v) |inner| { unsafe { r.push_all(*inner); } }\n     move r\n }\n \n /// Concatenate a vector of vectors, placing a given separator between each\n-pure fn connect<T: Copy>(v: &[~[T]], sep: T) -> ~[T] {\n+pub pure fn connect<T: Copy>(v: &[~[T]], sep: &T) -> ~[T] {\n     let mut r: ~[T] = ~[];\n     let mut first = true;\n     for each(v) |inner| {\n-        if first { first = false; } else { unsafe { push(r, sep); } }\n-        unsafe { push_all(r, *inner) };\n+        if first { first = false; } else { unsafe { r.push(*sep); } }\n+        unsafe { r.push_all(*inner) };\n     }\n     move r\n }\n \n /// Reduce a vector from left to right\n-pure fn foldl<T: Copy, U>(z: T, v: &[U], p: fn(T, U) -> T) -> T {\n+pub pure fn foldl<T: Copy, U>(z: T, v: &[U], p: fn(t: T, u: &U) -> T) -> T {\n     let mut accum = z;\n     for each(v) |elt| {\n-        accum = p(accum, *elt);\n+        // it should be possible to move accum in, but the liveness analysis\n+        // is not smart enough.\n+        accum = p(accum, elt);\n     }\n     return accum;\n }\n \n /// Reduce a vector from right to left\n-pure fn foldr<T, U: Copy>(v: &[T], z: U, p: fn(T, U) -> U) -> U {\n+pub pure fn foldr<T, U: Copy>(v: &[T], z: U, p: fn(t: &T, u: U) -> U) -> U {\n     let mut accum = z;\n     for rev_each(v) |elt| {\n-        accum = p(*elt, accum);\n+        accum = p(elt, accum);\n     }\n     return accum;\n }\n@@ -868,8 +782,8 @@ pure fn foldr<T, U: Copy>(v: &[T], z: U, p: fn(T, U) -> U) -> U {\n  *\n  * If the vector contains no elements then false is returned.\n  */\n-pure fn any<T>(v: &[T], f: fn(T) -> bool) -> bool {\n-    for each(v) |elem| { if f(*elem) { return true; } }\n+pub pure fn any<T>(v: &[T], f: fn(t: &T) -> bool) -> bool {\n+    for each(v) |elem| { if f(elem) { return true; } }\n     return false;\n }\n \n@@ -878,13 +792,13 @@ pure fn any<T>(v: &[T], f: fn(T) -> bool) -> bool {\n  *\n  * If the vectors contains no elements then false is returned.\n  */\n-pure fn any2<T, U>(v0: &[T], v1: &[U],\n-                   f: fn(T, U) -> bool) -> bool {\n+pub pure fn any2<T, U>(v0: &[T], v1: &[U],\n+                   f: fn(a: &T, b: &U) -> bool) -> bool {\n     let v0_len = len(v0);\n     let v1_len = len(v1);\n     let mut i = 0u;\n     while i < v0_len && i < v1_len {\n-        if f(v0[i], v1[i]) { return true; };\n+        if f(&v0[i], &v1[i]) { return true; };\n         i += 1u;\n     }\n     return false;\n@@ -895,8 +809,8 @@ pure fn any2<T, U>(v0: &[T], v1: &[U],\n  *\n  * If the vector contains no elements then true is returned.\n  */\n-pure fn all<T>(v: &[T], f: fn(T) -> bool) -> bool {\n-    for each(v) |elem| { if !f(*elem) { return false; } }\n+pub pure fn all<T>(v: &[T], f: fn(t: &T) -> bool) -> bool {\n+    for each(v) |elem| { if !f(elem) { return false; } }\n     return true;\n }\n \n@@ -905,8 +819,8 @@ pure fn all<T>(v: &[T], f: fn(T) -> bool) -> bool {\n  *\n  * If the vector contains no elements then true is returned.\n  */\n-pure fn alli<T>(v: &[T], f: fn(uint, T) -> bool) -> bool {\n-    for eachi(v) |i, elem| { if !f(i, *elem) { return false; } }\n+pub pure fn alli<T>(v: &[T], f: fn(uint, t: &T) -> bool) -> bool {\n+    for eachi(v) |i, elem| { if !f(i, elem) { return false; } }\n     return true;\n }\n \n@@ -915,25 +829,25 @@ pure fn alli<T>(v: &[T], f: fn(uint, T) -> bool) -> bool {\n  *\n  * If the vectors are not the same size then false is returned.\n  */\n-pure fn all2<T, U>(v0: &[T], v1: &[U],\n-                   f: fn(T, U) -> bool) -> bool {\n+pub pure fn all2<T, U>(v0: &[T], v1: &[U],\n+                   f: fn(t: &T, u: &U) -> bool) -> bool {\n     let v0_len = len(v0);\n     if v0_len != len(v1) { return false; }\n     let mut i = 0u;\n-    while i < v0_len { if !f(v0[i], v1[i]) { return false; }; i += 1u; }\n+    while i < v0_len { if !f(&v0[i], &v1[i]) { return false; }; i += 1u; }\n     return true;\n }\n \n /// Return true if a vector contains an element with the given value\n-pure fn contains<T: Eq>(v: &[T], x: T) -> bool {\n-    for each(v) |elt| { if x == *elt { return true; } }\n+pub pure fn contains<T: Eq>(v: &[T], x: &T) -> bool {\n+    for each(v) |elt| { if *x == *elt { return true; } }\n     return false;\n }\n \n /// Returns the number of elements that are equal to a given value\n-pure fn count<T: Eq>(v: &[T], x: T) -> uint {\n+pub pure fn count<T: Eq>(v: &[T], x: &T) -> uint {\n     let mut cnt = 0u;\n-    for each(v) |elt| { if x == *elt { cnt += 1u; } }\n+    for each(v) |elt| { if *x == *elt { cnt += 1u; } }\n     return cnt;\n }\n \n@@ -944,7 +858,7 @@ pure fn count<T: Eq>(v: &[T], x: T) -> uint {\n  * When function `f` returns true then an option containing the element\n  * is returned. If `f` matches no elements then none is returned.\n  */\n-pure fn find<T: Copy>(v: &[T], f: fn(T) -> bool) -> Option<T> {\n+pub pure fn find<T: Copy>(v: &[T], f: fn(t: &T) -> bool) -> Option<T> {\n     find_between(v, 0u, len(v), f)\n }\n \n@@ -955,9 +869,9 @@ pure fn find<T: Copy>(v: &[T], f: fn(T) -> bool) -> Option<T> {\n  * [`start`, `end`). When function `f` returns true then an option containing\n  * the element is returned. If `f` matches no elements then none is returned.\n  */\n-pure fn find_between<T: Copy>(v: &[T], start: uint, end: uint,\n-                      f: fn(T) -> bool) -> Option<T> {\n-    position_between(v, start, end, f).map(|i| v[i])\n+pub pure fn find_between<T: Copy>(v: &[T], start: uint, end: uint,\n+                      f: fn(t: &T) -> bool) -> Option<T> {\n+    position_between(v, start, end, f).map(|i| v[*i])\n }\n \n /**\n@@ -967,7 +881,7 @@ pure fn find_between<T: Copy>(v: &[T], start: uint, end: uint,\n  * `f` returns true then an option containing the element is returned. If `f`\n  * matches no elements then none is returned.\n  */\n-pure fn rfind<T: Copy>(v: &[T], f: fn(T) -> bool) -> Option<T> {\n+pub pure fn rfind<T: Copy>(v: &[T], f: fn(t: &T) -> bool) -> Option<T> {\n     rfind_between(v, 0u, len(v), f)\n }\n \n@@ -976,16 +890,16 @@ pure fn rfind<T: Copy>(v: &[T], f: fn(T) -> bool) -> Option<T> {\n  *\n  * Apply function `f` to each element of `v` in reverse order within the range\n  * [`start`, `end`). When function `f` returns true then an option containing\n- * the element is returned. If `f` matches no elements then none is returned.\n+ * the element is returned. If `f` matches no elements then none is return.\n  */\n-pure fn rfind_between<T: Copy>(v: &[T], start: uint, end: uint,\n-                               f: fn(T) -> bool) -> Option<T> {\n-    rposition_between(v, start, end, f).map(|i| v[i])\n+pub pure fn rfind_between<T: Copy>(v: &[T], start: uint, end: uint,\n+                               f: fn(t: &T) -> bool) -> Option<T> {\n+    rposition_between(v, start, end, f).map(|i| v[*i])\n }\n \n /// Find the first index containing a matching value\n-pure fn position_elem<T: Eq>(v: &[T], x: T) -> Option<uint> {\n-    position(v, |y| x == y)\n+pub pure fn position_elem<T: Eq>(v: &[T], x: &T) -> Option<uint> {\n+    position(v, |y| *x == *y)\n }\n \n /**\n@@ -995,7 +909,7 @@ pure fn position_elem<T: Eq>(v: &[T], x: T) -> Option<uint> {\n  * then an option containing the index is returned. If `f` matches no elements\n  * then none is returned.\n  */\n-pure fn position<T>(v: &[T], f: fn(T) -> bool) -> Option<uint> {\n+pub pure fn position<T>(v: &[T], f: fn(t: &T) -> bool) -> Option<uint> {\n     position_between(v, 0u, len(v), f)\n }\n \n@@ -1006,18 +920,18 @@ pure fn position<T>(v: &[T], f: fn(T) -> bool) -> Option<uint> {\n  * [`start`, `end`). When function `f` returns true then an option containing\n  * the index is returned. If `f` matches no elements then none is returned.\n  */\n-pure fn position_between<T>(v: &[T], start: uint, end: uint,\n-                            f: fn(T) -> bool) -> Option<uint> {\n+pub pure fn position_between<T>(v: &[T], start: uint, end: uint,\n+                            f: fn(t: &T) -> bool) -> Option<uint> {\n     assert start <= end;\n     assert end <= len(v);\n     let mut i = start;\n-    while i < end { if f(v[i]) { return Some::<uint>(i); } i += 1u; }\n+    while i < end { if f(&v[i]) { return Some::<uint>(i); } i += 1u; }\n     return None;\n }\n \n /// Find the last index containing a matching value\n-pure fn rposition_elem<T: Eq>(v: &[T], x: T) -> Option<uint> {\n-    rposition(v, |y| x == y)\n+pure fn rposition_elem<T: Eq>(v: &[T], x: &T) -> Option<uint> {\n+    rposition(v, |y| *x == *y)\n }\n \n /**\n@@ -1027,7 +941,7 @@ pure fn rposition_elem<T: Eq>(v: &[T], x: T) -> Option<uint> {\n  * `f` returns true then an option containing the index is returned. If `f`\n  * matches no elements then none is returned.\n  */\n-pure fn rposition<T>(v: &[T], f: fn(T) -> bool) -> Option<uint> {\n+pub pure fn rposition<T>(v: &[T], f: fn(t: &T) -> bool) -> Option<uint> {\n     rposition_between(v, 0u, len(v), f)\n }\n \n@@ -1039,13 +953,13 @@ pure fn rposition<T>(v: &[T], f: fn(T) -> bool) -> Option<uint> {\n  * containing the index is returned. If `f` matches no elements then none is\n  * returned.\n  */\n-pure fn rposition_between<T>(v: &[T], start: uint, end: uint,\n-                             f: fn(T) -> bool) -> Option<uint> {\n+pub pure fn rposition_between<T>(v: &[T], start: uint, end: uint,\n+                             f: fn(t: &T) -> bool) -> Option<uint> {\n     assert start <= end;\n     assert end <= len(v);\n     let mut i = end;\n     while i > start {\n-        if f(v[i - 1u]) { return Some::<uint>(i - 1u); }\n+        if f(&v[i - 1u]) { return Some::<uint>(i - 1u); }\n         i -= 1u;\n     }\n     return None;\n@@ -1059,15 +973,15 @@ pure fn rposition_between<T>(v: &[T], start: uint, end: uint,\n  * Convert a vector of pairs into a pair of vectors, by reference. As unzip().\n  */\n pure fn unzip_slice<T: Copy, U: Copy>(v: &[(T, U)]) -> (~[T], ~[U]) {\n-    let mut as_ = ~[], bs = ~[];\n+    let mut ts = ~[], us = ~[];\n     for each(v) |p| {\n-        let (a, b) = *p;\n+        let (t, u) = *p;\n         unsafe {\n-            vec::push(as_, a);\n-            vec::push(bs, b);\n+            ts.push(t);\n+            us.push(u);\n         }\n     }\n-    return (move as_, move bs);\n+    return (move ts, move us);\n }\n \n /**\n@@ -1078,13 +992,13 @@ pure fn unzip_slice<T: Copy, U: Copy>(v: &[(T, U)]) -> (~[T], ~[U]) {\n  * and the i-th element of the second vector contains the second element\n  * of the i-th tuple of the input vector.\n  */\n-pure fn unzip<T,U>(+v: ~[(T, U)]) -> (~[T], ~[U]) {\n+pub pure fn unzip<T,U>(v: ~[(T, U)]) -> (~[T], ~[U]) {\n     let mut ts = ~[], us = ~[];\n     unsafe {\n         do consume(move v) |_i, p| {\n-            let (a,b) = move p;\n-            push(ts, move a);\n-            push(us, move b);\n+            let (t, u) = move p;\n+            ts.push(move t);\n+            us.push(move u);\n         }\n     }\n     (move ts, move us)\n@@ -1093,13 +1007,13 @@ pure fn unzip<T,U>(+v: ~[(T, U)]) -> (~[T], ~[U]) {\n /**\n  * Convert two vectors to a vector of pairs, by reference. As zip().\n  */\n-pure fn zip_slice<T: Copy, U: Copy>(v: &[const T], u: &[const U])\n+pub pure fn zip_slice<T: Copy, U: Copy>(v: &[const T], u: &[const U])\n         -> ~[(T, U)] {\n     let mut zipped = ~[];\n     let sz = len(v);\n     let mut i = 0u;\n     assert sz == len(u);\n-    while i < sz unsafe { vec::push(zipped, (v[i], u[i])); i += 1u; }\n+    while i < sz unsafe { zipped.push((v[i], u[i])); i += 1u; }\n     move zipped\n }\n \n@@ -1109,12 +1023,13 @@ pure fn zip_slice<T: Copy, U: Copy>(v: &[const T], u: &[const U])\n  * Returns a vector of tuples, where the i-th tuple contains contains the\n  * i-th elements from each of the input vectors.\n  */\n-pure fn zip<T, U>(+v: ~[const T], +u: ~[const U]) -> ~[(T, U)] {\n-    let mut v = move v, u = move u, i = len(v);\n+pub pure fn zip<T, U>(v: ~[T], u: ~[U]) -> ~[(T, U)] {\n+    let mut v = move v, u = move u; // FIXME(#3488)\n+    let mut i = len(v);\n     assert i == len(u);\n     let mut w = with_capacity(i);\n     while i > 0 {\n-        unsafe { push(w, (pop(v),pop(u))); }\n+        unsafe { w.push((v.pop(),u.pop())); }\n         i -= 1;\n     }\n     unsafe { reverse(w); }\n@@ -1130,25 +1045,25 @@ pure fn zip<T, U>(+v: ~[const T], +u: ~[const U]) -> ~[(T, U)] {\n  * * a - The index of the first element\n  * * b - The index of the second element\n  */\n-fn swap<T>(v: &[mut T], a: uint, b: uint) {\n+pub fn swap<T>(v: &[mut T], a: uint, b: uint) {\n     v[a] <-> v[b];\n }\n \n /// Reverse the order of elements in a vector, in place\n-fn reverse<T>(v: &[mut T]) {\n+pub fn reverse<T>(v: &[mut T]) {\n     let mut i: uint = 0u;\n     let ln = len::<T>(v);\n     while i < ln / 2u { v[i] <-> v[ln - i - 1u]; i += 1u; }\n }\n \n /// Returns a vector with the order of elements reversed\n-pure fn reversed<T: Copy>(v: &[const T]) -> ~[T] {\n+pub pure fn reversed<T: Copy>(v: &[const T]) -> ~[T] {\n     let mut rs: ~[T] = ~[];\n     let mut i = len::<T>(v);\n     if i == 0 { return (move rs); } else { i -= 1; }\n     unsafe {\n-        while i != 0 { vec::push(rs, v[i]); i -= 1; }\n-        vec::push(rs, v[0]);\n+        while i != 0 { rs.push(v[i]); i -= 1; }\n+        rs.push(v[0]);\n     }\n     move rs\n }\n@@ -1159,7 +1074,7 @@ pure fn reversed<T: Copy>(v: &[const T]) -> ~[T] {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pure fn each<T>(v: &r/[T], f: fn((&r/T)) -> bool) {\n+pub pure fn each<T>(v: &r/[T], f: fn((&r/T)) -> bool) {\n     //             ^^^^\n     // NB---this CANNOT be &[const T]!  The reason\n     // is that you are passing it to `f()` using\n@@ -1183,7 +1098,7 @@ pure fn each<T>(v: &r/[T], f: fn((&r/T)) -> bool) {\n /// a vector with mutable contents and you would like\n /// to mutate the contents as you iterate.\n #[inline(always)]\n-fn each_mut<T>(v: &[mut T], f: fn(elem: &mut T) -> bool) {\n+pub fn each_mut<T>(v: &[mut T], f: fn(elem: &mut T) -> bool) {\n     let mut i = 0;\n     let n = v.len();\n     while i < n {\n@@ -1197,7 +1112,7 @@ fn each_mut<T>(v: &[mut T], f: fn(elem: &mut T) -> bool) {\n /// Like `each()`, but for the case where you have a vector that *may or may\n /// not* have mutable contents.\n #[inline(always)]\n-pure fn each_const<T>(v: &[const T], f: fn(elem: &const T) -> bool) {\n+pub pure fn each_const<T>(v: &[const T], f: fn(elem: &const T) -> bool) {\n     let mut i = 0;\n     let n = v.len();\n     while i < n {\n@@ -1214,7 +1129,7 @@ pure fn each_const<T>(v: &[const T], f: fn(elem: &const T) -> bool) {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pure fn eachi<T>(v: &r/[T], f: fn(uint, v: &r/T) -> bool) {\n+pub pure fn eachi<T>(v: &r/[T], f: fn(uint, v: &r/T) -> bool) {\n     let mut i = 0;\n     for each(v) |p| {\n         if !f(i, p) { return; }\n@@ -1228,7 +1143,7 @@ pure fn eachi<T>(v: &r/[T], f: fn(uint, v: &r/T) -> bool) {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pure fn rev_each<T>(v: &r/[T], blk: fn(v: &r/T) -> bool) {\n+pub pure fn rev_each<T>(v: &r/[T], blk: fn(v: &r/T) -> bool) {\n     rev_eachi(v, |_i, v| blk(v))\n }\n \n@@ -1238,7 +1153,7 @@ pure fn rev_each<T>(v: &r/[T], blk: fn(v: &r/T) -> bool) {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pure fn rev_eachi<T>(v: &r/[T], blk: fn(i: uint, v: &r/T) -> bool) {\n+pub pure fn rev_eachi<T>(v: &r/[T], blk: fn(i: uint, v: &r/T) -> bool) {\n     let mut i = v.len();\n     while i > 0 {\n         i -= 1;\n@@ -1256,10 +1171,12 @@ pure fn rev_eachi<T>(v: &r/[T], blk: fn(i: uint, v: &r/T) -> bool) {\n  * Both vectors must have the same length\n  */\n #[inline]\n-fn iter2<U, T>(v1: &[U], v2: &[T], f: fn(U, T)) {\n+pub fn each2<U, T>(v1: &[U], v2: &[T], f: fn(u: &U, t: &T) -> bool) {\n     assert len(v1) == len(v2);\n     for uint::range(0u, len(v1)) |i| {\n-        f(v1[i], v2[i])\n+        if !f(&v1[i], &v2[i]) {\n+            return;\n+        }\n     }\n }\n \n@@ -1273,33 +1190,37 @@ fn iter2<U, T>(v1: &[U], v2: &[T], f: fn(U, T)) {\n  * The total number of permutations produced is `len(v)!`.  If `v` contains\n  * repeated elements, then some permutations are repeated.\n  */\n-pure fn permute<T: Copy>(v: &[const T], put: fn(~[T])) {\n+pure fn each_permutation<T: Copy>(v: &[T], put: fn(ts: &[T]) -> bool) {\n     let ln = len(v);\n-    if ln == 0u {\n-        put(~[]);\n+    if ln <= 1 {\n+        put(v);\n     } else {\n+        // This does not seem like the most efficient implementation.  You\n+        // could make far fewer copies if you put your mind to it.\n         let mut i = 0u;\n         while i < ln {\n             let elt = v[i];\n             let mut rest = slice(v, 0u, i);\n             unsafe {\n-                push_all(rest, const_view(v, i+1u, ln));\n-                permute(rest, |permutation| {\n-                    put(append(~[elt], permutation))\n-                })\n+                rest.push_all(const_view(v, i+1u, ln));\n+                for each_permutation(rest) |permutation| {\n+                    if !put(append(~[elt], permutation)) {\n+                        return;\n+                    }\n+                }\n             }\n             i += 1u;\n         }\n     }\n }\n \n-pure fn windowed<TT: Copy>(nn: uint, xx: &[TT]) -> ~[~[TT]] {\n+pub pure fn windowed<TT: Copy>(nn: uint, xx: &[TT]) -> ~[~[TT]] {\n     let mut ww = ~[];\n     assert 1u <= nn;\n     for vec::eachi (xx) |ii, _x| {\n         let len = vec::len(xx);\n         if ii+nn <= len unsafe {\n-            vec::push(ww, vec::slice(xx, ii, ii+nn));\n+            ww.push(vec::slice(xx, ii, ii+nn));\n         }\n     }\n     move ww\n@@ -1312,8 +1233,9 @@ pure fn windowed<TT: Copy>(nn: uint, xx: &[TT]) -> ~[~[TT]] {\n  * foreign interop.\n  */\n #[inline(always)]\n-pure fn as_imm_buf<T,U>(s: &[T], /* NB---this CANNOT be const, see below */\n-                        f: fn(*T, uint) -> U) -> U {\n+pub pure fn as_imm_buf<T,U>(s: &[T],\n+                            /* NB---this CANNOT be const, see below */\n+                            f: fn(*T, uint) -> U) -> U {\n \n     // NB---Do not change the type of s to `&[const T]`.  This is\n     // unsound.  The reason is that we are going to create immutable pointers\n@@ -1323,33 +1245,33 @@ pure fn as_imm_buf<T,U>(s: &[T], /* NB---this CANNOT be const, see below */\n \n     unsafe {\n         let v : *(*T,uint) =\n-            ::cast::reinterpret_cast(&ptr::addr_of(s));\n+            ::cast::reinterpret_cast(&addr_of(&s));\n         let (buf,len) = *v;\n         f(buf, len / sys::size_of::<T>())\n     }\n }\n \n /// Similar to `as_imm_buf` but passing a `*const T`\n #[inline(always)]\n-pure fn as_const_buf<T,U>(s: &[const T],\n+pub pure fn as_const_buf<T,U>(s: &[const T],\n                           f: fn(*const T, uint) -> U) -> U {\n \n     unsafe {\n         let v : *(*const T,uint) =\n-            ::cast::reinterpret_cast(&ptr::addr_of(s));\n+            ::cast::reinterpret_cast(&addr_of(&s));\n         let (buf,len) = *v;\n         f(buf, len / sys::size_of::<T>())\n     }\n }\n \n /// Similar to `as_imm_buf` but passing a `*mut T`\n #[inline(always)]\n-pure fn as_mut_buf<T,U>(s: &[mut T],\n+pub pure fn as_mut_buf<T,U>(s: &[mut T],\n                         f: fn(*mut T, uint) -> U) -> U {\n \n     unsafe {\n         let v : *(*mut T,uint) =\n-            ::cast::reinterpret_cast(&ptr::addr_of(s));\n+            ::cast::reinterpret_cast(&addr_of(&s));\n         let (buf,len) = *v;\n         f(buf, len / sys::size_of::<T>())\n     }\n@@ -1446,8 +1368,7 @@ impl<T: Ord> @[T] : Ord {\n }\n \n #[cfg(notest)]\n-mod traits {\n-    #[legacy_exports];\n+pub mod traits {\n     impl<T: Copy> ~[T] : Add<&[const T],~[T]> {\n         #[inline(always)]\n         pure fn add(rhs: & &[const T]) -> ~[T] {\n@@ -1464,10 +1385,9 @@ mod traits {\n }\n \n #[cfg(test)]\n-mod traits {\n-    #[legacy_exports];}\n+pub mod traits {}\n \n-trait ConstVector {\n+pub trait ConstVector {\n     pure fn is_empty() -> bool;\n     pure fn is_not_empty() -> bool;\n     pure fn len() -> uint;\n@@ -1486,7 +1406,7 @@ impl<T> &[const T]: ConstVector {\n     pure fn len() -> uint { len(self) }\n }\n \n-trait CopyableVector<T> {\n+pub trait CopyableVector<T> {\n     pure fn head() -> T;\n     pure fn init() -> ~[T];\n     pure fn last() -> T;\n@@ -1513,36 +1433,43 @@ impl<T: Copy> &[const T]: CopyableVector<T> {\n     pure fn tail() -> ~[T] { tail(self) }\n }\n \n-trait ImmutableVector<T> {\n-    pure fn foldr<U: Copy>(z: U, p: fn(T, U) -> U) -> U;\n-    pure fn map<U>(f: fn(v: &T) -> U) -> ~[U];\n-    pure fn mapi<U>(f: fn(uint, v: &T) -> U) -> ~[U];\n+pub trait ImmutableVector<T> {\n+    pure fn view(start: uint, end: uint) -> &self/[T];\n+    pure fn foldr<U: Copy>(z: U, p: fn(t: &T, u: U) -> U) -> U;\n+    pure fn map<U>(f: fn(t: &T) -> U) -> ~[U];\n+    pure fn mapi<U>(f: fn(uint, t: &T) -> U) -> ~[U];\n     fn map_r<U>(f: fn(x: &T) -> U) -> ~[U];\n-    pure fn alli(f: fn(uint, T) -> bool) -> bool;\n-    pure fn flat_map<U>(f: fn(T) -> ~[U]) -> ~[U];\n-    pure fn filter_map<U: Copy>(f: fn(T) -> Option<U>) -> ~[U];\n+    pure fn alli(f: fn(uint, t: &T) -> bool) -> bool;\n+    pure fn flat_map<U>(f: fn(t: &T) -> ~[U]) -> ~[U];\n+    pure fn filter_map<U: Copy>(f: fn(t: &T) -> Option<U>) -> ~[U];\n }\n \n-trait ImmutableEqVector<T: Eq> {\n-    pure fn position(f: fn(T) -> bool) -> Option<uint>;\n-    pure fn position_elem(x: T) -> Option<uint>;\n-    pure fn rposition(f: fn(T) -> bool) -> Option<uint>;\n-    pure fn rposition_elem(x: T) -> Option<uint>;\n+pub trait ImmutableEqVector<T: Eq> {\n+    pure fn position(f: fn(t: &T) -> bool) -> Option<uint>;\n+    pure fn position_elem(t: &T) -> Option<uint>;\n+    pure fn rposition(f: fn(t: &T) -> bool) -> Option<uint>;\n+    pure fn rposition_elem(t: &T) -> Option<uint>;\n }\n \n /// Extension methods for vectors\n impl<T> &[T]: ImmutableVector<T> {\n+    /// Return a slice that points into another slice.\n+    pure fn view(start: uint, end: uint) -> &self/[T] {\n+        view(self, start, end)\n+    }\n     /// Reduce a vector from right to left\n     #[inline]\n-    pure fn foldr<U: Copy>(z: U, p: fn(T, U) -> U) -> U { foldr(self, z, p) }\n+    pure fn foldr<U: Copy>(z: U, p: fn(t: &T, u: U) -> U) -> U {\n+        foldr(self, z, p)\n+    }\n     /// Apply a function to each element of a vector and return the results\n     #[inline]\n-    pure fn map<U>(f: fn(v: &T) -> U) -> ~[U] { map(self, f) }\n+    pure fn map<U>(f: fn(t: &T) -> U) -> ~[U] { map(self, f) }\n     /**\n      * Apply a function to the index and value of each element in the vector\n      * and return the results\n      */\n-    pure fn mapi<U>(f: fn(uint, v: &T) -> U) -> ~[U] {\n+    pure fn mapi<U>(f: fn(uint, t: &T) -> U) -> ~[U] {\n         mapi(self, f)\n     }\n \n@@ -1551,7 +1478,7 @@ impl<T> &[T]: ImmutableVector<T> {\n         let mut r = ~[];\n         let mut i = 0;\n         while i < self.len() {\n-            push(r, f(&self[i]));\n+            r.push(f(&self[i]));\n             i += 1;\n         }\n         move r\n@@ -1562,23 +1489,25 @@ impl<T> &[T]: ImmutableVector<T> {\n      *\n      *     If the vector is empty, true is returned.\n      */\n-    pure fn alli(f: fn(uint, T) -> bool) -> bool {\n+    pure fn alli(f: fn(uint, t: &T) -> bool) -> bool {\n         alli(self, f)\n     }\n     /**\n      * Apply a function to each element of a vector and return a concatenation\n      * of each result vector\n      */\n     #[inline]\n-    pure fn flat_map<U>(f: fn(T) -> ~[U]) -> ~[U] { flat_map(self, f) }\n+    pure fn flat_map<U>(f: fn(t: &T) -> ~[U]) -> ~[U] {\n+        flat_map(self, f)\n+    }\n     /**\n      * Apply a function to each element of a vector and return the results\n      *\n      * If function `f` returns `none` then that element is excluded from\n      * the resulting vector.\n      */\n     #[inline]\n-    pure fn filter_map<U: Copy>(f: fn(T) -> Option<U>) -> ~[U] {\n+    pure fn filter_map<U: Copy>(f: fn(t: &T) -> Option<U>) -> ~[U] {\n         filter_map(self, f)\n     }\n }\n@@ -1592,10 +1521,16 @@ impl<T: Eq> &[T]: ImmutableEqVector<T> {\n      * elements then none is returned.\n      */\n     #[inline]\n-    pure fn position(f: fn(T) -> bool) -> Option<uint> { position(self, f) }\n+    pure fn position(f: fn(t: &T) -> bool) -> Option<uint> {\n+        position(self, f)\n+    }\n+\n     /// Find the first index containing a matching value\n     #[inline]\n-    pure fn position_elem(x: T) -> Option<uint> { position_elem(self, x) }\n+    pure fn position_elem(x: &T) -> Option<uint> {\n+        position_elem(self, x)\n+    }\n+\n     /**\n      * Find the last index matching some predicate\n      *\n@@ -1604,15 +1539,21 @@ impl<T: Eq> &[T]: ImmutableEqVector<T> {\n      * returned. If `f` matches no elements then none is returned.\n      */\n     #[inline]\n-    pure fn rposition(f: fn(T) -> bool) -> Option<uint> { rposition(self, f) }\n+    pure fn rposition(f: fn(t: &T) -> bool) -> Option<uint> {\n+        rposition(self, f)\n+    }\n+\n     /// Find the last index containing a matching value\n     #[inline]\n-    pure fn rposition_elem(x: T) -> Option<uint> { rposition_elem(self, x) }\n+    pure fn rposition_elem(t: &T) -> Option<uint> {\n+        rposition_elem(self, t)\n+    }\n }\n \n-trait ImmutableCopyableVector<T> {\n-    pure fn filter(f: fn(T) -> bool) -> ~[T];\n-    pure fn rfind(f: fn(T) -> bool) -> Option<T>;\n+pub trait ImmutableCopyableVector<T> {\n+    pure fn filter(f: fn(t: &T) -> bool) -> ~[T];\n+\n+    pure fn rfind(f: fn(t: &T) -> bool) -> Option<T>;\n }\n \n /// Extension methods for vectors\n@@ -1625,7 +1566,10 @@ impl<T: Copy> &[T]: ImmutableCopyableVector<T> {\n      * containing only those elements for which `f` returned true.\n      */\n     #[inline]\n-    pure fn filter(f: fn(T) -> bool) -> ~[T] { filter(self, f) }\n+    pure fn filter(f: fn(t: &T) -> bool) -> ~[T] {\n+        filter(self, f)\n+    }\n+\n     /**\n      * Search for the last element that matches a given predicate\n      *\n@@ -1634,28 +1578,102 @@ impl<T: Copy> &[T]: ImmutableCopyableVector<T> {\n      * returned. If `f` matches no elements then none is returned.\n      */\n     #[inline]\n-    pure fn rfind(f: fn(T) -> bool) -> Option<T> { rfind(self, f) }\n+    pure fn rfind(f: fn(t: &T) -> bool) -> Option<T> { rfind(self, f) }\n+}\n+\n+pub trait MutableVector<T> {\n+    fn push(&mut self, t: T);\n+    fn push_all_move(&mut self, rhs: ~[T]);\n+    fn pop(&mut self) -> T;\n+    fn shift(&mut self) -> T;\n+    fn unshift(&mut self, x: T);\n+    fn swap_remove(&mut self, index: uint) -> T;\n+    fn truncate(&mut self, newlen: uint);\n+}\n+\n+pub trait MutableCopyableVector<T: Copy> {\n+    fn push_all(&mut self, rhs: &[const T]);\n+    fn grow(&mut self, n: uint, initval: &T);\n+    fn grow_fn(&mut self, n: uint, op: iter::InitOp<T>);\n+    fn grow_set(&mut self, index: uint, initval: &T, val: T);\n+}\n+\n+trait MutableEqVector<T: Eq> {\n+    fn dedup(&mut self);\n+}\n+\n+impl<T> ~[T]: MutableVector<T> {\n+    fn push(&mut self, t: T) {\n+        push(self, move t);\n+    }\n+\n+    fn push_all_move(&mut self, rhs: ~[T]) {\n+        push_all_move(self, move rhs);\n+    }\n+\n+    fn pop(&mut self) -> T {\n+        pop(self)\n+    }\n+\n+    fn shift(&mut self) -> T {\n+        shift(self)\n+    }\n+\n+    fn unshift(&mut self, x: T) {\n+        unshift(self, x)\n+    }\n+\n+    fn swap_remove(&mut self, index: uint) -> T {\n+        swap_remove(self, index)\n+    }\n+\n+    fn truncate(&mut self, newlen: uint) {\n+        truncate(self, newlen);\n+    }\n+}\n+\n+impl<T: Copy> ~[T]: MutableCopyableVector<T> {\n+    fn push_all(&mut self, rhs: &[const T]) {\n+        push_all(self, rhs);\n+    }\n+\n+    fn grow(&mut self, n: uint, initval: &T) {\n+        grow(self, n, initval);\n+    }\n+\n+    fn grow_fn(&mut self, n: uint, op: iter::InitOp<T>) {\n+        grow_fn(self, n, op);\n+    }\n+\n+    fn grow_set(&mut self, index: uint, initval: &T, val: T) {\n+        grow_set(self, index, initval, val);\n+    }\n+}\n+\n+impl<T: Eq> ~[T]: MutableEqVector<T> {\n+    fn dedup(&mut self) {\n+        dedup(self)\n+    }\n }\n \n /// Unsafe operations\n-mod raw {\n-    #[legacy_exports];\n+pub mod raw {\n     // FIXME: This should have crate visibility (#1893 blocks that)\n \n     /// The internal representation of a (boxed) vector\n-    struct VecRepr {\n+    pub struct VecRepr {\n         box_header: box::raw::BoxHeaderRepr,\n         unboxed: UnboxedVecRepr\n     }\n \n     /// The internal 'unboxed' representation of a vector\n-    struct UnboxedVecRepr {\n+    pub struct UnboxedVecRepr {\n         mut fill: uint,\n         mut alloc: uint,\n         data: u8\n     }\n \n-    type SliceRepr = {\n+    pub type SliceRepr = {\n         mut data: *u8,\n         mut len: uint\n     };\n@@ -1669,9 +1687,9 @@ mod raw {\n      * * elts - The number of elements in the buffer\n      */\n     #[inline(always)]\n-    unsafe fn from_buf<T>(ptr: *T, elts: uint) -> ~[T] {\n+    pub unsafe fn from_buf<T>(ptr: *T, elts: uint) -> ~[T] {\n         let mut dst = with_capacity(elts);\n-        set_len(dst, elts);\n+        set_len(&mut dst, elts);\n         as_mut_buf(dst, |p_dst, _len_dst| ptr::memcpy(p_dst, ptr, elts));\n         move dst\n     }\n@@ -1684,8 +1702,8 @@ mod raw {\n      * the vector is actually the specified size.\n      */\n     #[inline(always)]\n-    unsafe fn set_len<T>(&&v: ~[const T], new_len: uint) {\n-        let repr: **VecRepr = ::cast::reinterpret_cast(&addr_of(v));\n+    pub unsafe fn set_len<T>(v: &mut ~[T], new_len: uint) {\n+        let repr: **VecRepr = ::cast::transmute(v);\n         (**repr).unboxed.fill = new_len * sys::size_of::<T>();\n     }\n \n@@ -1699,50 +1717,54 @@ mod raw {\n      * would also make any pointers to it invalid.\n      */\n     #[inline(always)]\n-    unsafe fn to_ptr<T>(v: &[T]) -> *T {\n-        let repr: **SliceRepr = ::cast::reinterpret_cast(&addr_of(v));\n-        return ::cast::reinterpret_cast(&addr_of((**repr).data));\n+    pub unsafe fn to_ptr<T>(v: &[T]) -> *T {\n+        let repr: **SliceRepr = ::cast::transmute(&v);\n+        return ::cast::reinterpret_cast(&addr_of(&((**repr).data)));\n     }\n \n     /** see `to_ptr()` */\n     #[inline(always)]\n-    unsafe fn to_const_ptr<T>(v: &[const T]) -> *const T {\n-        let repr: **SliceRepr = ::cast::reinterpret_cast(&addr_of(v));\n-        return ::cast::reinterpret_cast(&addr_of((**repr).data));\n+    pub unsafe fn to_const_ptr<T>(v: &[const T]) -> *const T {\n+        let repr: **SliceRepr = ::cast::transmute(&v);\n+        return ::cast::reinterpret_cast(&addr_of(&((**repr).data)));\n     }\n \n     /** see `to_ptr()` */\n     #[inline(always)]\n-    unsafe fn to_mut_ptr<T>(v: &[mut T]) -> *mut T {\n-        let repr: **SliceRepr = ::cast::reinterpret_cast(&addr_of(v));\n-        return ::cast::reinterpret_cast(&addr_of((**repr).data));\n+    pub unsafe fn to_mut_ptr<T>(v: &[mut T]) -> *mut T {\n+        let repr: **SliceRepr = ::cast::transmute(&v);\n+        return ::cast::reinterpret_cast(&addr_of(&((**repr).data)));\n     }\n \n     /**\n      * Form a slice from a pointer and length (as a number of units,\n      * not bytes).\n      */\n     #[inline(always)]\n-    unsafe fn form_slice<T,U>(p: *T, len: uint, f: fn(v: &[T]) -> U) -> U {\n+    pub unsafe fn buf_as_slice<T,U>(p: *T,\n+                                    len: uint,\n+                                    f: fn(v: &[T]) -> U) -> U {\n         let pair = (p, len * sys::size_of::<T>());\n         let v : *(&blk/[T]) =\n-            ::cast::reinterpret_cast(&ptr::addr_of(pair));\n+            ::cast::reinterpret_cast(&addr_of(&pair));\n         f(*v)\n     }\n \n     /**\n      * Unchecked vector indexing.\n      */\n     #[inline(always)]\n-    unsafe fn get<T: Copy>(v: &[const T], i: uint) -> T {\n+    pub unsafe fn get<T: Copy>(v: &[const T], i: uint) -> T {\n         as_const_buf(v, |p, _len| *ptr::const_offset(p, i))\n     }\n \n     /**\n-     * Unchecked vector index assignment.\n+     * Unchecked vector index assignment.  Does not drop the\n+     * old value and hence is only suitable when the vector\n+     * is newly allocated.\n      */\n     #[inline(always)]\n-    unsafe fn set<T>(v: &[mut T], i: uint, +val: T) {\n+    pub unsafe fn init_elem<T>(v: &[mut T], i: uint, val: T) {\n         let mut box = Some(move val);\n         do as_mut_buf(v) |p, _len| {\n             let mut box2 = None;\n@@ -1758,7 +1780,7 @@ mod raw {\n       * Copies `count` bytes from `src` to `dst`. The source and destination\n       * may overlap.\n       */\n-    unsafe fn memcpy<T>(dst: &[mut T], src: &[const T], count: uint) {\n+    pub unsafe fn memcpy<T>(dst: &[mut T], src: &[const T], count: uint) {\n         do as_mut_buf(dst) |p_dst, _len_dst| {\n             do as_const_buf(src) |p_src, _len_src| {\n                 ptr::memcpy(p_dst, p_src, count)\n@@ -1772,7 +1794,7 @@ mod raw {\n       * Copies `count` bytes from `src` to `dst`. The source and destination\n       * may overlap.\n       */\n-    unsafe fn memmove<T>(dst: &[mut T], src: &[const T], count: uint) {\n+    pub unsafe fn memmove<T>(dst: &[mut T], src: &[const T], count: uint) {\n         do as_mut_buf(dst) |p_dst, _len_dst| {\n             do as_const_buf(src) |p_src, _len_src| {\n                 ptr::memmove(p_dst, p_src, count)\n@@ -1782,14 +1804,10 @@ mod raw {\n }\n \n /// Operations on `[u8]`\n-mod bytes {\n-    #[legacy_exports];\n-    export cmp;\n-    export lt, le, eq, ne, ge, gt;\n-    export memcpy, memmove;\n+pub mod bytes {\n \n     /// Bytewise string comparison\n-    pure fn cmp(a: &~[u8], b: &~[u8]) -> int {\n+    pub pure fn cmp(a: &~[u8], b: &~[u8]) -> int {\n         let a_len = len(*a);\n         let b_len = len(*b);\n         let n = uint::min(a_len, b_len) as libc::size_t;\n@@ -1810,30 +1828,30 @@ mod bytes {\n     }\n \n     /// Bytewise less than or equal\n-    pure fn lt(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) < 0 }\n+    pub pure fn lt(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) < 0 }\n \n     /// Bytewise less than or equal\n-    pure fn le(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) <= 0 }\n+    pub pure fn le(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) <= 0 }\n \n     /// Bytewise equality\n-    pure fn eq(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) == 0 }\n+    pub pure fn eq(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) == 0 }\n \n     /// Bytewise inequality\n-    pure fn ne(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) != 0 }\n+    pub pure fn ne(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) != 0 }\n \n     /// Bytewise greater than or equal\n-    pure fn ge(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) >= 0 }\n+    pub pure fn ge(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) >= 0 }\n \n     /// Bytewise greater than\n-    pure fn gt(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) > 0 }\n+    pub pure fn gt(a: &~[u8], b: &~[u8]) -> bool { cmp(a, b) > 0 }\n \n     /**\n       * Copies data from one vector to another.\n       *\n       * Copies `count` bytes from `src` to `dst`. The source and destination\n       * may not overlap.\n       */\n-    fn memcpy(dst: &[mut u8], src: &[const u8], count: uint) {\n+    pub fn memcpy(dst: &[mut u8], src: &[const u8], count: uint) {\n         assert dst.len() >= count;\n         assert src.len() >= count;\n \n@@ -1846,7 +1864,7 @@ mod bytes {\n       * Copies `count` bytes from `src` to `dst`. The source and destination\n       * may overlap.\n       */\n-    fn memmove(dst: &[mut u8], src: &[const u8], count: uint) {\n+    pub fn memmove(dst: &[mut u8], src: &[const u8], count: uint) {\n         assert dst.len() >= count;\n         assert src.len() >= count;\n \n@@ -1861,7 +1879,7 @@ mod bytes {\n // required in the slice.\n \n impl<A> &[A]: iter::BaseIter<A> {\n-    pure fn each(blk: fn(v: &A) -> bool) {\n+    pub pure fn each(blk: fn(v: &A) -> bool) {\n         // FIXME(#2263)---should be able to call each(self, blk)\n         for each(self) |e| {\n             if (!blk(e)) {\n@@ -1873,64 +1891,67 @@ impl<A> &[A]: iter::BaseIter<A> {\n }\n \n impl<A> &[A]: iter::ExtendedIter<A> {\n-    pure fn eachi(blk: fn(uint, v: &A) -> bool) { iter::eachi(self, blk) }\n-    pure fn all(blk: fn(A) -> bool) -> bool { iter::all(self, blk) }\n-    pure fn any(blk: fn(A) -> bool) -> bool { iter::any(self, blk) }\n-    pure fn foldl<B>(+b0: B, blk: fn(B, A) -> B) -> B {\n-        iter::foldl(self, move b0, blk)\n+    pub pure fn eachi(blk: fn(uint, v: &A) -> bool) {\n+        iter::eachi(&self, blk)\n     }\n-    pure fn position(f: fn(A) -> bool) -> Option<uint> {\n-        iter::position(self, f)\n+    pub pure fn all(blk: fn(&A) -> bool) -> bool { iter::all(&self, blk) }\n+    pub pure fn any(blk: fn(&A) -> bool) -> bool { iter::any(&self, blk) }\n+    pub pure fn foldl<B>(b0: B, blk: fn(&B, &A) -> B) -> B {\n+        iter::foldl(&self, move b0, blk)\n+    }\n+    pub pure fn position(f: fn(&A) -> bool) -> Option<uint> {\n+        iter::position(&self, f)\n     }\n }\n \n impl<A: Eq> &[A]: iter::EqIter<A> {\n-    pure fn contains(x: A) -> bool { iter::contains(self, x) }\n-    pure fn count(x: A) -> uint { iter::count(self, x) }\n+    pub pure fn contains(x: &A) -> bool { iter::contains(&self, x) }\n+    pub pure fn count(x: &A) -> uint { iter::count(&self, x) }\n }\n \n impl<A: Copy> &[A]: iter::CopyableIter<A> {\n-    pure fn filter_to_vec(pred: fn(A) -> bool) -> ~[A] {\n-        iter::filter_to_vec(self, pred)\n+    pure fn filter_to_vec(pred: fn(a: A) -> bool) -> ~[A] {\n+        iter::filter_to_vec(&self, pred)\n     }\n-    pure fn map_to_vec<B>(op: fn(v: &A) -> B) -> ~[B] {\n-        iter::map_to_vec(self, op)\n+    pure fn map_to_vec<B>(op: fn(v: A) -> B) -> ~[B] {\n+        iter::map_to_vec(&self, op)\n     }\n-    pure fn to_vec() -> ~[A] { iter::to_vec(self) }\n+    pure fn to_vec() -> ~[A] { iter::to_vec(&self) }\n \n     // FIXME--bug in resolve prevents this from working (#2611)\n     // fn flat_map_to_vec<B:copy,IB:base_iter<B>>(op: fn(A) -> IB) -> ~[B] {\n     //     iter::flat_map_to_vec(self, op)\n     // }\n \n-    pure fn find(p: fn(A) -> bool) -> Option<A> { iter::find(self, p) }\n+    pub pure fn find(p: fn(a: A) -> bool) -> Option<A> {\n+        iter::find(&self, p)\n+    }\n }\n \n impl<A: Copy Ord> &[A]: iter::CopyableOrderedIter<A> {\n-    pure fn min() -> A { iter::min(self) }\n-    pure fn max() -> A { iter::max(self) }\n+    pure fn min() -> A { iter::min(&self) }\n+    pure fn max() -> A { iter::max(&self) }\n }\n // ___________________________________________________________________________\n \n #[cfg(test)]\n mod tests {\n-    #[legacy_exports];\n \n     fn square(n: uint) -> uint { return n * n; }\n \n     fn square_ref(n: &uint) -> uint { return square(*n); }\n \n-    pure fn is_three(&&n: uint) -> bool { return n == 3u; }\n+    pure fn is_three(n: &uint) -> bool { return *n == 3u; }\n \n-    pure fn is_odd(&&n: uint) -> bool { return n % 2u == 1u; }\n+    pure fn is_odd(n: &uint) -> bool { return *n % 2u == 1u; }\n \n-    pure fn is_equal(&&x: uint, &&y:uint) -> bool { return x == y; }\n+    pure fn is_equal(x: &uint, y:&uint) -> bool { return *x == *y; }\n \n-    fn square_if_odd(&&n: uint) -> Option<uint> {\n-        return if n % 2u == 1u { Some(n * n) } else { None };\n+    fn square_if_odd(n: &uint) -> Option<uint> {\n+        return if *n % 2u == 1u { Some(*n * *n) } else { None };\n     }\n \n-    fn add(&&x: uint, &&y: uint) -> uint { return x + y; }\n+    fn add(x: uint, y: &uint) -> uint { return x + *y; }\n \n     #[test]\n     fn test_unsafe_ptrs() {\n@@ -2060,15 +2081,15 @@ mod tests {\n     fn test_pop() {\n         // Test on-stack pop.\n         let mut v = ~[1, 2, 3];\n-        let mut e = pop(v);\n+        let mut e = v.pop();\n         assert (len(v) == 2u);\n         assert (v[0] == 1);\n         assert (v[1] == 2);\n         assert (e == 3);\n \n         // Test on-heap pop.\n         v = ~[1, 2, 3, 4, 5];\n-        e = pop(v);\n+        e = v.pop();\n         assert (len(v) == 4u);\n         assert (v[0] == 1);\n         assert (v[1] == 2);\n@@ -2080,11 +2101,11 @@ mod tests {\n     #[test]\n     fn test_swap_remove() {\n         let mut v = ~[1, 2, 3, 4, 5];\n-        let mut e = swap_remove(v, 0);\n+        let mut e = v.swap_remove(0);\n         assert (len(v) == 4);\n         assert e == 1;\n         assert (v[0] == 5);\n-        e = swap_remove(v, 3);\n+        e = v.swap_remove(3);\n         assert (len(v) == 3);\n         assert e == 4;\n         assert (v[0] == 5);\n@@ -2097,24 +2118,24 @@ mod tests {\n         // Tests that we don't accidentally run destructors twice.\n         let mut v = ~[::private::exclusive(()), ::private::exclusive(()),\n                       ::private::exclusive(())];\n-        let mut _e = swap_remove(v, 0);\n+        let mut _e = v.swap_remove(0);\n         assert (len(v) == 2);\n-        _e = swap_remove(v, 1);\n+        _e = v.swap_remove(1);\n         assert (len(v) == 1);\n-        _e = swap_remove(v, 0);\n+        _e = v.swap_remove(0);\n         assert (len(v) == 0);\n     }\n \n     #[test]\n     fn test_push() {\n         // Test on-stack push().\n         let mut v = ~[];\n-        push(v, 1);\n+        v.push(1);\n         assert (len(v) == 1u);\n         assert (v[0] == 1);\n \n         // Test on-heap push().\n-        push(v, 2);\n+        v.push(2);\n         assert (len(v) == 2u);\n         assert (v[0] == 1);\n         assert (v[1] == 2);\n@@ -2124,13 +2145,13 @@ mod tests {\n     fn test_grow() {\n         // Test on-stack grow().\n         let mut v = ~[];\n-        grow(v, 2u, 1);\n+        v.grow(2u, &1);\n         assert (len(v) == 2u);\n         assert (v[0] == 1);\n         assert (v[1] == 1);\n \n         // Test on-heap grow().\n-        grow(v, 3u, 2);\n+        v.grow(3u, &2);\n         assert (len(v) == 5u);\n         assert (v[0] == 1);\n         assert (v[1] == 1);\n@@ -2142,7 +2163,7 @@ mod tests {\n     #[test]\n     fn test_grow_fn() {\n         let mut v = ~[];\n-        grow_fn(v, 3u, square);\n+        v.grow_fn(3u, square);\n         assert (len(v) == 3u);\n         assert (v[0] == 0u);\n         assert (v[1] == 1u);\n@@ -2152,7 +2173,7 @@ mod tests {\n     #[test]\n     fn test_grow_set() {\n         let mut v = ~[1, 2, 3];\n-        grow_set(v, 4u, 4, 5);\n+        v.grow_set(4u, &4, 5);\n         assert (len(v) == 5u);\n         assert (v[0] == 1);\n         assert (v[1] == 2);\n@@ -2164,17 +2185,17 @@ mod tests {\n     #[test]\n     fn test_truncate() {\n         let mut v = ~[@6,@5,@4];\n-        truncate(v, 1);\n+        v.truncate(1);\n         assert(v.len() == 1);\n         assert(*(v[0]) == 6);\n         // If the unsafe block didn't drop things properly, we blow up here.\n     }\n \n     #[test]\n     fn test_dedup() {\n-        fn case(-a: ~[uint], -b: ~[uint]) {\n+        fn case(a: ~[uint], b: ~[uint]) {\n             let mut v = a;\n-            dedup(v);\n+            v.dedup();\n             assert(v == b);\n         }\n         case(~[], ~[]);\n@@ -2190,11 +2211,11 @@ mod tests {\n     #[test]\n     fn test_dedup_unique() {\n         let mut v0 = ~[~1, ~1, ~2, ~3];\n-        dedup(v0);\n+        v0.dedup();\n         let mut v1 = ~[~1, ~2, ~2, ~3];\n-        dedup(v1);\n+        v1.dedup();\n         let mut v2 = ~[~1, ~2, ~3, ~3];\n-        dedup(v2);\n+        v2.dedup();\n         /*\n          * If the ~pointers were leaked or otherwise misused, valgrind and/or\n          * rustrt should raise errors.\n@@ -2204,11 +2225,11 @@ mod tests {\n     #[test]\n     fn test_dedup_shared() {\n         let mut v0 = ~[@1, @1, @2, @3];\n-        dedup(v0);\n+        v0.dedup();\n         let mut v1 = ~[@1, @2, @2, @3];\n-        dedup(v1);\n+        v1.dedup();\n         let mut v2 = ~[@1, @2, @3, @3];\n-        dedup(v2);\n+        v2.dedup();\n         /*\n          * If the @pointers were leaked or otherwise misused, valgrind and/or\n          * rustrt should raise errors.\n@@ -2238,7 +2259,7 @@ mod tests {\n \n     #[test]\n     fn test_map2() {\n-        fn times(&&x: int, &&y: int) -> int { return x * y; }\n+        fn times(x: &int, y: &int) -> int { return *x * *y; }\n         let f = times;\n         let v0 = ~[1, 2, 3, 4, 5];\n         let v1 = ~[5, 4, 3, 2, 1];\n@@ -2264,9 +2285,9 @@ mod tests {\n         assert (w[1] == 9u);\n         assert (w[2] == 25u);\n \n-        fn halve(&&i: int) -> Option<int> {\n-            if i % 2 == 0 {\n-                return option::Some::<int>(i / 2);\n+        fn halve(i: &int) -> Option<int> {\n+            if *i % 2 == 0 {\n+                return option::Some::<int>(*i / 2);\n             } else { return option::None::<int>; }\n         }\n         fn halve_for_sure(i: &int) -> int { return *i / 2; }\n@@ -2302,8 +2323,8 @@ mod tests {\n \n     #[test]\n     fn test_foldl2() {\n-        fn sub(&&a: int, &&b: int) -> int {\n-            a - b\n+        fn sub(a: int, b: &int) -> int {\n+            a - *b\n         }\n         let mut v = ~[1, 2, 3, 4];\n         let sum = foldl(0, v, sub);\n@@ -2312,8 +2333,8 @@ mod tests {\n \n     #[test]\n     fn test_foldr() {\n-        fn sub(&&a: int, &&b: int) -> int {\n-            a - b\n+        fn sub(a: &int, b: int) -> int {\n+            *a - b\n         }\n         let mut v = ~[1, 2, 3, 4];\n         let sum = foldr(v, 0, sub);\n@@ -2376,23 +2397,23 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_permute() {\n+    fn test_each_permutation() {\n         let mut results: ~[~[int]];\n \n         results = ~[];\n-        permute(~[], |v| vec::push(results, copy v));\n+        for each_permutation(~[]) |v| { results.push(from_slice(v)); }\n         assert results == ~[~[]];\n \n         results = ~[];\n-        permute(~[7], |v| push(results, copy v));\n+        for each_permutation(~[7]) |v| { results.push(from_slice(v)); }\n         assert results == ~[~[7]];\n \n         results = ~[];\n-        permute(~[1,1], |v| push(results, copy v));\n+        for each_permutation(~[1,1]) |v| { results.push(from_slice(v)); }\n         assert results == ~[~[1,1],~[1,1]];\n \n         results = ~[];\n-        permute(~[5,2,0], |v| push(results, copy v));\n+        for each_permutation(~[5,2,0]) |v| { results.push(from_slice(v)); }\n         assert results ==\n             ~[~[5,2,0],~[5,0,2],~[2,5,0],~[2,0,5],~[0,5,2],~[0,2,5]];\n     }\n@@ -2444,19 +2465,19 @@ mod tests {\n \n     #[test]\n     fn test_position_elem() {\n-        assert position_elem(~[], 1).is_none();\n+        assert position_elem(~[], &1).is_none();\n \n         let v1 = ~[1, 2, 3, 3, 2, 5];\n-        assert position_elem(v1, 1) == Some(0u);\n-        assert position_elem(v1, 2) == Some(1u);\n-        assert position_elem(v1, 5) == Some(5u);\n-        assert position_elem(v1, 4).is_none();\n+        assert position_elem(v1, &1) == Some(0u);\n+        assert position_elem(v1, &2) == Some(1u);\n+        assert position_elem(v1, &5) == Some(5u);\n+        assert position_elem(v1, &4).is_none();\n     }\n \n     #[test]\n     fn test_position() {\n-        fn less_than_three(&&i: int) -> bool { return i < 3; }\n-        fn is_eighteen(&&i: int) -> bool { return i == 18; }\n+        fn less_than_three(i: &int) -> bool { return *i < 3; }\n+        fn is_eighteen(i: &int) -> bool { return *i == 18; }\n \n         assert position(~[], less_than_three).is_none();\n \n@@ -2469,7 +2490,7 @@ mod tests {\n     fn test_position_between() {\n         assert position_between(~[], 0u, 0u, f).is_none();\n \n-        fn f(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'b' }\n+        fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n         let mut v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n         assert position_between(v, 0u, 0u, f).is_none();\n@@ -2497,8 +2518,8 @@ mod tests {\n     fn test_find() {\n         assert find(~[], f).is_none();\n \n-        fn f(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'b' }\n-        fn g(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'd' }\n+        fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n+        fn g(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'd' }\n         let mut v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n         assert find(v, f) == Some((1, 'b'));\n@@ -2509,7 +2530,7 @@ mod tests {\n     fn test_find_between() {\n         assert find_between(~[], 0u, 0u, f).is_none();\n \n-        fn f(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'b' }\n+        fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n         let mut v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n         assert find_between(v, 0u, 0u, f).is_none();\n@@ -2537,8 +2558,8 @@ mod tests {\n     fn test_rposition() {\n         assert find(~[], f).is_none();\n \n-        fn f(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'b' }\n-        fn g(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'd' }\n+        fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n+        fn g(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'd' }\n         let mut v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n         assert position(v, f) == Some(1u);\n@@ -2549,7 +2570,7 @@ mod tests {\n     fn test_rposition_between() {\n         assert rposition_between(~[], 0u, 0u, f).is_none();\n \n-        fn f(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'b' }\n+        fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n         let mut v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n         assert rposition_between(v, 0u, 0u, f).is_none();\n@@ -2577,8 +2598,8 @@ mod tests {\n     fn test_rfind() {\n         assert rfind(~[], f).is_none();\n \n-        fn f(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'b' }\n-        fn g(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'd' }\n+        fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n+        fn g(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'd' }\n         let mut v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n         assert rfind(v, f) == Some((3, 'b'));\n@@ -2589,7 +2610,7 @@ mod tests {\n     fn test_rfind_between() {\n         assert rfind_between(~[], 0u, 0u, f).is_none();\n \n-        fn f(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'b' }\n+        fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n         let mut v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n         assert rfind_between(v, 0u, 0u, f).is_none();\n@@ -2649,7 +2670,7 @@ mod tests {\n \n     #[test]\n     fn test_split() {\n-        fn f(&&x: int) -> bool { x == 3 }\n+        fn f(x: &int) -> bool { *x == 3 }\n \n         assert split(~[], f) == ~[];\n         assert split(~[1, 2], f) == ~[~[1, 2]];\n@@ -2660,7 +2681,7 @@ mod tests {\n \n     #[test]\n     fn test_splitn() {\n-        fn f(&&x: int) -> bool { x == 3 }\n+        fn f(x: &int) -> bool { *x == 3 }\n \n         assert splitn(~[], 1u, f) == ~[];\n         assert splitn(~[1, 2], 1u, f) == ~[~[1, 2]];\n@@ -2672,7 +2693,7 @@ mod tests {\n \n     #[test]\n     fn test_rsplit() {\n-        fn f(&&x: int) -> bool { x == 3 }\n+        fn f(x: &int) -> bool { *x == 3 }\n \n         assert rsplit(~[], f) == ~[];\n         assert rsplit(~[1, 2], f) == ~[~[1, 2]];\n@@ -2682,7 +2703,7 @@ mod tests {\n \n     #[test]\n     fn test_rsplitn() {\n-        fn f(&&x: int) -> bool { x == 3 }\n+        fn f(x: &int) -> bool { *x == 3 }\n \n         assert rsplitn(~[], 1u, f) == ~[];\n         assert rsplitn(~[1, 2], 1u, f) == ~[~[1, 2]];\n@@ -2705,9 +2726,9 @@ mod tests {\n \n     #[test]\n     fn test_connect() {\n-        assert connect(~[], 0) == ~[];\n-        assert connect(~[~[1], ~[2, 3]], 0) == ~[1, 0, 2, 3];\n-        assert connect(~[~[1], ~[2], ~[3]], 0) == ~[1, 0, 2, 0, 3];\n+        assert connect(~[], &0) == ~[];\n+        assert connect(~[~[1], ~[2, 3]], &0) == ~[1, 0, 2, 3];\n+        assert connect(~[~[1], ~[2], ~[3]], &0) == ~[1, 0, 2, 0, 3];\n     }\n \n     #[test]\n@@ -2753,31 +2774,566 @@ mod tests {\n     #[test]\n     fn test_unshift() {\n         let mut x = ~[1, 2, 3];\n-        unshift(x, 0);\n+        x.unshift(0);\n         assert x == ~[0, 1, 2, 3];\n     }\n \n     #[test]\n     fn test_capacity() {\n         let mut v = ~[0u64];\n         reserve(&mut v, 10u);\n-        assert capacity(v) == 10u;\n+        assert capacity(&v) == 10u;\n         let mut v = ~[0u32];\n         reserve(&mut v, 10u);\n-        assert capacity(v) == 10u;\n+        assert capacity(&v) == 10u;\n     }\n \n-/*\n     #[test]\n-    #[ignore] // region inference doesn't work well enough for this yet.\n     fn test_view() {\n         let v = ~[1, 2, 3, 4, 5];\n-        let v = view(v, 1u, 3u);\n+        let v = v.view(1u, 3u);\n         assert(len(v) == 2u);\n         assert(v[0] == 2);\n         assert(v[1] == 3);\n     }\n-*/\n+\n+\n+    #[test]\n+    #[ignore(windows)]\n+    #[should_fail]\n+    fn test_from_fn_fail() {\n+        do from_fn(100) |v| {\n+            if v == 50 { fail }\n+            (~0, @0)\n+        };\n+    }\n+\n+    #[test]\n+    #[ignore(windows)]\n+    #[should_fail]\n+    fn test_build_fail() {\n+        do build |push| {\n+            push((~0, @0));\n+            push((~0, @0));\n+            push((~0, @0));\n+            push((~0, @0));\n+            fail;\n+        };\n+    }\n+\n+    #[test]\n+    #[ignore(windows)]\n+    #[should_fail]\n+    #[allow(non_implicitly_copyable_typarams)]\n+    fn test_split_fail_ret_true() {\n+        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n+        let mut i = 0;\n+        do split(v) |_elt| {\n+            if i == 2 {\n+                fail\n+            }\n+            i += 1;\n+\n+            true\n+        };\n+    }\n+\n+    #[test]\n+    #[ignore(windows)]\n+    #[should_fail]\n+    #[allow(non_implicitly_copyable_typarams)]\n+    fn test_split_fail_ret_false() {\n+        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n+        let mut i = 0;\n+        do split(v) |_elt| {\n+            if i == 2 {\n+                fail\n+            }\n+            i += 1;\n+\n+            false\n+        };\n+    }\n+\n+    #[test]\n+    #[ignore(windows)]\n+    #[should_fail]\n+    #[allow(non_implicitly_copyable_typarams)]\n+    fn test_splitn_fail_ret_true() {\n+        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n+        let mut i = 0;\n+        do splitn(v, 100) |_elt| {\n+            if i == 2 {\n+                fail\n+            }\n+            i += 1;\n+\n+            true\n+        };\n+    }\n+\n+    #[test]\n+    #[ignore(windows)]\n+    #[should_fail]\n+    #[allow(non_implicitly_copyable_typarams)]\n+    fn test_splitn_fail_ret_false() {\n+        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n+        let mut i = 0;\n+        do split(v) |_elt| {\n+            if i == 2 {\n+                fail\n+            }\n+            i += 1;\n+\n+            false\n+        };\n+    }\n+\n+    #[test]\n+    #[ignore(windows)]\n+    #[should_fail]\n+    #[allow(non_implicitly_copyable_typarams)]\n+    fn test_rsplit_fail_ret_true() {\n+        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n+        let mut i = 0;\n+        do rsplit(v) |_elt| {\n+            if i == 2 {\n+                fail\n+            }\n+            i += 1;\n+\n+            true\n+        };\n+    }\n+\n+    #[test]\n+    #[ignore(windows)]\n+    #[should_fail]\n+    #[allow(non_implicitly_copyable_typarams)]\n+    fn test_rsplit_fail_ret_false() {\n+        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n+        let mut i = 0;\n+        do rsplit(v) |_elt| {\n+            if i == 2 {\n+                fail\n+            }\n+            i += 1;\n+\n+            false\n+        };\n+    }\n+\n+    #[test]\n+    #[ignore(windows)]\n+    #[should_fail]\n+    #[allow(non_implicitly_copyable_typarams)]\n+    fn test_rsplitn_fail_ret_true() {\n+        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n+        let mut i = 0;\n+        do rsplitn(v, 100) |_elt| {\n+            if i == 2 {\n+                fail\n+            }\n+            i += 1;\n+\n+            true\n+        };\n+    }\n+\n+    #[test]\n+    #[ignore(windows)]\n+    #[should_fail]\n+    #[allow(non_implicitly_copyable_typarams)]\n+    fn test_rsplitn_fail_ret_false() {\n+        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n+        let mut i = 0;\n+        do rsplitn(v, 100) |_elt| {\n+            if i == 2 {\n+                fail\n+            }\n+            i += 1;\n+\n+            false\n+        };\n+    }\n+\n+    #[test]\n+    #[ignore(windows)]\n+    #[should_fail]\n+    fn test_consume_fail() {\n+        let v = ~[(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n+        let mut i = 0;\n+        do consume(v) |_i, _elt| {\n+            if i == 2 {\n+                fail\n+            }\n+            i += 1;\n+        };\n+    }\n+\n+    #[test]\n+    #[ignore(windows)]\n+    #[should_fail]\n+    fn test_consume_mut_fail() {\n+        let v = ~[mut (~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n+        let mut i = 0;\n+        do consume_mut(v) |_i, _elt| {\n+            if i == 2 {\n+                fail\n+            }\n+            i += 1;\n+        };\n+    }\n+\n+    #[test]\n+    #[ignore(windows)]\n+    #[should_fail]\n+    #[allow(non_implicitly_copyable_typarams)]\n+    fn test_grow_fn_fail() {\n+        let mut v = ~[];\n+        do v.grow_fn(100) |i| {\n+            if i == 50 {\n+                fail\n+            }\n+            (~0, @0)\n+        }\n+    }\n+\n+    #[test]\n+    #[ignore(windows)]\n+    #[should_fail]\n+    fn test_map_fail() {\n+        let v = [mut (~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n+        let mut i = 0;\n+        do map(v) |_elt| {\n+            if i == 2 {\n+                fail\n+            }\n+            i += 0;\n+            ~[(~0, @0)]\n+        };\n+    }\n+\n+    #[test]\n+    #[ignore(windows)]\n+    #[should_fail]\n+    fn test_map_consume_fail() {\n+        let v = ~[(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n+        let mut i = 0;\n+        do map_consume(v) |_elt| {\n+            if i == 2 {\n+                fail\n+            }\n+            i += 0;\n+            ~[(~0, @0)]\n+        };\n+    }\n+\n+    #[test]\n+    #[ignore(windows)]\n+    #[should_fail]\n+    fn test_mapi_fail() {\n+        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n+        let mut i = 0;\n+        do mapi(v) |_i, _elt| {\n+            if i == 2 {\n+                fail\n+            }\n+            i += 0;\n+            ~[(~0, @0)]\n+        };\n+    }\n+\n+    #[test]\n+    #[ignore(windows)]\n+    #[should_fail]\n+    fn test_flat_map_fail() {\n+        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n+        let mut i = 0;\n+        do map(v) |_elt| {\n+            if i == 2 {\n+                fail\n+            }\n+            i += 0;\n+            ~[(~0, @0)]\n+        };\n+    }\n+\n+    #[test]\n+    #[ignore(windows)]\n+    #[should_fail]\n+    #[allow(non_implicitly_copyable_typarams)]\n+    fn test_map2_fail() {\n+        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n+        let mut i = 0;\n+        do map2(v, v) |_elt1, _elt2| {\n+            if i == 2 {\n+                fail\n+            }\n+            i += 0;\n+            ~[(~0, @0)]\n+        };\n+    }\n+\n+    #[test]\n+    #[ignore(windows)]\n+    #[should_fail]\n+    #[allow(non_implicitly_copyable_typarams)]\n+    fn test_filter_map_fail() {\n+        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n+        let mut i = 0;\n+        do filter_map(v) |_elt| {\n+            if i == 2 {\n+                fail\n+            }\n+            i += 0;\n+            Some((~0, @0))\n+        };\n+    }\n+\n+    #[test]\n+    #[ignore(windows)]\n+    #[should_fail]\n+    #[allow(non_implicitly_copyable_typarams)]\n+    fn test_filter_fail() {\n+        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n+        let mut i = 0;\n+        do filter(v) |_elt| {\n+            if i == 2 {\n+                fail\n+            }\n+            i += 0;\n+            true\n+        };\n+    }\n+\n+    #[test]\n+    #[ignore(windows)]\n+    #[should_fail]\n+    #[allow(non_implicitly_copyable_typarams)]\n+    fn test_foldl_fail() {\n+        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n+        let mut i = 0;\n+        do foldl((~0, @0), v) |_a, _b| {\n+            if i == 2 {\n+                fail\n+            }\n+            i += 0;\n+            (~0, @0)\n+        };\n+    }\n+\n+    #[test]\n+    #[ignore(windows)]\n+    #[should_fail]\n+    #[allow(non_implicitly_copyable_typarams)]\n+    fn test_foldr_fail() {\n+        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n+        let mut i = 0;\n+        do foldr(v, (~0, @0)) |_a, _b| {\n+            if i == 2 {\n+                fail\n+            }\n+            i += 0;\n+            (~0, @0)\n+        };\n+    }\n+\n+    #[test]\n+    #[ignore(windows)]\n+    #[should_fail]\n+    fn test_any_fail() {\n+        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n+        let mut i = 0;\n+        do any(v) |_elt| {\n+            if i == 2 {\n+                fail\n+            }\n+            i += 0;\n+            false\n+        };\n+    }\n+\n+    #[test]\n+    #[ignore(windows)]\n+    #[should_fail]\n+    fn test_any2_fail() {\n+        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n+        let mut i = 0;\n+        do any(v) |_elt| {\n+            if i == 2 {\n+                fail\n+            }\n+            i += 0;\n+            false\n+        };\n+    }\n+\n+    #[test]\n+    #[ignore(windows)]\n+    #[should_fail]\n+    fn test_all_fail() {\n+        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n+        let mut i = 0;\n+        do all(v) |_elt| {\n+            if i == 2 {\n+                fail\n+            }\n+            i += 0;\n+            true\n+        };\n+    }\n+\n+    #[test]\n+    #[ignore(windows)]\n+    #[should_fail]\n+    fn test_alli_fail() {\n+        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n+        let mut i = 0;\n+        do alli(v) |_i, _elt| {\n+            if i == 2 {\n+                fail\n+            }\n+            i += 0;\n+            true\n+        };\n+    }\n+\n+    #[test]\n+    #[ignore(windows)]\n+    #[should_fail]\n+    fn test_all2_fail() {\n+        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n+        let mut i = 0;\n+        do all2(v, v) |_elt1, _elt2| {\n+            if i == 2 {\n+                fail\n+            }\n+            i += 0;\n+            true\n+        };\n+    }\n+\n+    #[test]\n+    #[ignore(windows)]\n+    #[should_fail]\n+    #[allow(non_implicitly_copyable_typarams)]\n+    fn test_find_fail() {\n+        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n+        let mut i = 0;\n+        do find(v) |_elt| {\n+            if i == 2 {\n+                fail\n+            }\n+            i += 0;\n+            false\n+        };\n+    }\n+\n+    #[test]\n+    #[ignore(windows)]\n+    #[should_fail]\n+    fn test_position_fail() {\n+        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n+        let mut i = 0;\n+        do position(v) |_elt| {\n+            if i == 2 {\n+                fail\n+            }\n+            i += 0;\n+            false\n+        };\n+    }\n+\n+    #[test]\n+    #[ignore(windows)]\n+    #[should_fail]\n+    fn test_rposition_fail() {\n+        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n+        let mut i = 0;\n+        do rposition(v) |_elt| {\n+            if i == 2 {\n+                fail\n+            }\n+            i += 0;\n+            false\n+        };\n+    }\n+\n+    #[test]\n+    #[ignore(windows)]\n+    #[should_fail]\n+    fn test_each_fail() {\n+        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n+        let mut i = 0;\n+        do each(v) |_elt| {\n+            if i == 2 {\n+                fail\n+            }\n+            i += 0;\n+            false\n+        }\n+    }\n+\n+    #[test]\n+    #[ignore(windows)]\n+    #[should_fail]\n+    fn test_eachi_fail() {\n+        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n+        let mut i = 0;\n+        do eachi(v) |_i, _elt| {\n+            if i == 2 {\n+                fail\n+            }\n+            i += 0;\n+            false\n+        }\n+    }\n+\n+    #[test]\n+    #[ignore(windows)]\n+    #[should_fail]\n+    #[allow(non_implicitly_copyable_typarams)]\n+    fn test_permute_fail() {\n+        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n+        let mut i = 0;\n+        for each_permutation(v) |_elt| {\n+            if i == 2 {\n+                fail\n+            }\n+            i += 0;\n+        }\n+    }\n+\n+    #[test]\n+    #[ignore(windows)]\n+    #[should_fail]\n+    fn test_as_imm_buf_fail() {\n+        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n+        do as_imm_buf(v) |_buf, _i| {\n+            fail\n+        }\n+    }\n+\n+    #[test]\n+    #[ignore(windows)]\n+    #[should_fail]\n+    fn test_as_const_buf_fail() {\n+        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n+        do as_const_buf(v) |_buf, _i| {\n+            fail\n+        }\n+    }\n+\n+    #[test]\n+    #[ignore(windows)]\n+    #[should_fail]\n+    fn test_as_mut_buf_fail() {\n+        let v = [mut (~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n+        do as_mut_buf(v) |_buf, _i| {\n+            fail\n+        }\n+    }\n }\n \n // Local Variables:"}, {"sha": "60db62ce01ae2a59df60d019469a379bbdaa871f", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "4d2b910fa8510502d1853eb731b5184f17c67567", "filename": "src/libstd/arena.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farena.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "9bad4d397500350f2dff0bf8a13f2c5e7a81b4aa", "filename": "src/libstd/base64.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbase64.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "77f0d39c338e92ce969cde563cf1a51b21938a15", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 47, "deletions": 50, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "1ff5b63ee12f3dd6a1f27fe2bb642c63b3950bf4", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "866dbce1c08591268b2178d3f6a747f26226e6d8", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "2ec0bf41675cfab2ff9b6e1743c5d458d68fe4b9", "filename": "src/libstd/cmp.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcmp.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "4d87ebeac99d338704e8df058404c57e946c0bf8", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "f85d4655ad14bdb3f802e0f90156c5941318710c", "filename": "src/libstd/dbg.rs", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fdbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fdbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdbg.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "f4fbc11c4f715dc75f4d56b288f4b4ba678b12ab", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "238e9d77a771ed83a9937783f2acd63438113803", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 33, "deletions": 58, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "30d68da06f56ff07458fc5b74d98fd46235a9866", "filename": "src/libstd/ebml2.rs", "status": "added", "additions": 643, "deletions": 0, "changes": 643, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Febml2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Febml2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml2.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "2973c8cc9f784c3f461b392b2aa2e9654cc54c41", "filename": "src/libstd/fun_treemap.rs", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Ffun_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Ffun_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffun_treemap.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "771eaaeca7fa331904e1a99d74796aac13811f14", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 97, "deletions": 106, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "2d78ef066cc86f2b1e03b0f3ee5a8dda684c5128", "filename": "src/libstd/json.rs", "status": "modified", "additions": 817, "deletions": 341, "changes": 1158, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "4ff493f5ab9101763bc8ef1b903d7404684086c9", "filename": "src/libstd/list.rs", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "cc42c5623762911355c7c50674a3b231a8c21698", "filename": "src/libstd/map.rs", "status": "modified", "additions": 39, "deletions": 48, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "581beb78bdc555f2ff63479b03b3fed746ff1b02", "filename": "src/libstd/md4.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fmd4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fmd4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmd4.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "76a5955c3e196273ffae53ebbfd54a01596fed15", "filename": "src/libstd/net.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "2d9dd5bdf4e83a5f8d069dc7b60dd223d098fad3", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 41, "deletions": 51, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "546231da6333e1ff3f366c653fb347a034c7a1d0", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 82, "deletions": 99, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "40c9f96f5e84c0c83ab3f2c23477ddd2ebf68d03", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 36, "deletions": 46, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "65e41dba5d83c06f5ff1ede0a5a6dc41a15c116e", "filename": "src/libstd/par.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpar.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "bc528800666d294c636cbe098f8627e898109518", "filename": "src/libstd/prettyprint.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fprettyprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fprettyprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprettyprint.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "87af519eb123d98ed16b8216944806aa574d6c8d", "filename": "src/libstd/prettyprint2.rs", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fprettyprint2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fprettyprint2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprettyprint2.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "5df4fc10a036c1d3bc2f5f8d4afa165bfd6fc7d0", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 81, "deletions": 87, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "e9067bc64042d8ee0ff94e415f2d30b45c512201", "filename": "src/libstd/serialization.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fserialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fserialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialization.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "5173ef163a22aef06ea3fd6787bea0dbcaa8efa9", "filename": "src/libstd/serialization2.rs", "status": "added", "additions": 563, "deletions": 0, "changes": 563, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fserialization2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fserialization2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialization2.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "05890035273def4404b29e86dfb017372c9b4da1", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "58ecbb0d6c3a5b31b1d2679b514ddaa85b99213e", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "6a292402dac34406d2c8359367892f93a73fdb7c", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "6a5658d24eb0dc34a3cd72a1ff4b1452839e56d7", "filename": "src/libstd/std.rc", "status": "modified", "additions": 8, "deletions": 43, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "f66134d38923408394a6a030f02cda6e48087364", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "37fcbf6f4caa0aa2461eefcce9e7480aea1189db", "filename": "src/libstd/tempfile.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftempfile.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "2c12fd11e6eec0de3af8093ae2665d401e22b4fc", "filename": "src/libstd/term.rs", "status": "modified", "additions": 26, "deletions": 27, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fterm.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "5fb7df1f68c64ae12cd16090b1464db736c5e6be", "filename": "src/libstd/test.rs", "status": "modified", "additions": 30, "deletions": 41, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "aef3bb2ac0ad10e056ae6b3bdeb950f81ed966b0", "filename": "src/libstd/time.rs", "status": "modified", "additions": 21, "deletions": 36, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "2aca87b942ecbb3fbd274b3b52e37d0c2c829792", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "184dfd362796c83f863908c436cceb06fb2659f6", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "bafe385ed19da76de552cb0d90726aa870b5cb42", "filename": "src/libstd/unicode.rs", "status": "modified", "additions": 144, "deletions": 148, "changes": 292, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funicode.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "e0fd013907c8efe04de9111c868bf7c04398c641", "filename": "src/libstd/uv.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fuv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fuv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "869c3efa38f9a0b7e14028f84194b65e505786b6", "filename": "src/libstd/uv_global_loop.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "4a4a34704be21437b10d3731d41cb4b42732ab93", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "f0594475d04eb7a39060cbb5361e8dec33897628", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 153, "deletions": 162, "changes": 315, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "e17b52fb27d176d30f317680a9976851ae9809dd", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 29, "deletions": 15, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "d05c6eadaf6a31fc23c26615b99ab43e9fcfdf15", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "e8099de246cca59c2a4679051ef1b70bc73e33e3", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "374300f07c73abc162a2b49cff1a47a3d2108d60", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "e07985119ec49630c7b2f2c47f702da202fd5fb6", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "7f208a3a710c8f886070dea8c9a5f3798c382a15", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 37, "deletions": 35, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "64915c607425fe39642a3cbba86045e2c8dadc34", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "99f837a4c8446d61151e631acf5ffe5134ccf9c4", "filename": "src/libsyntax/ext/auto_serialize2.rs", "status": "added", "additions": 1025, "deletions": 0, "changes": 1025, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fext%2Fauto_serialize2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fext%2Fauto_serialize2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize2.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "9a31cc1d8f672d45252072d0917e792a959fdc47", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "a43b0cb69f4b68626ffbba2c7dd48b22239ddc96", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "22e2cfcde6b5113dba31df4fc23fe86c76e2cde6", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "ea493eab56174421f7f4dc724799bd2fea7f64e2", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "a9bfd87ab0eb3506e747cd6c3655b7aeb40b470a", "filename": "src/libsyntax/ext/pipes/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "9c10d228a23f3a04ca9264ed859e895b3138fb6e", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 47, "deletions": 49, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "6d58d209fcfc7a52dda9ab8f5c97fa3d0489e595", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "e16e1c55349970cf007feca47fae7e72d887a96d", "filename": "src/libsyntax/ext/simplext.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsimplext.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "16e3454ca2c45fbf46cc83ae8fc667cc3bafbd4f", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "a8a41cca6cbd7dcbdf7e34e1ae46cbb05d14b52b", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "088df01985ee981217dc7c740fdd62e1fa4d135c", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "2c04b2a14190c6a5d6b84e45abb7bb36382ae8ad", "filename": "src/libsyntax/parse.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "cb8416501b37f170084e7243a2149a0383ef3024", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "c8c30ee7fa9cbaf179b7f895da0233ab533f26b6", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "14dc490346eb94df5805ed59acc7b2b1ef6469e7", "filename": "src/libsyntax/parse/eval.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Feval.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "06fcc1cf9589fa2e0a1ae8bf8384c58849ffc5be", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "782535f5c2b2c50c097e42236067845e18545aa1", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "8860d1b5cea83d30dbc5452a63586c756a625a50", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 122, "deletions": 108, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "a328ff1bdf6459436fddbb9d152f18f349d4e5c8", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 67, "deletions": 51, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "d08b20eed843e40056bccb9ceb6b348a9077fbfa", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "38abf5f445c237898499c060b625c6c6f509b38b", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "021c25e3dd710bb255949485972d87749d083e58", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "e6fd65eb458a2c98d38d17aa96a3da5bc06b7ca6", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "c51053bf71de475df6a91204acd9ad78f4747c38", "filename": "src/llvm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "11e65347f11bc618883a2dc9d13fb3ee26953613", "filename": "src/rt/rust.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frt%2Frust.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frt%2Frust.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust.cpp?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "5baa95c7323f401cc01f2479acec389a0401cfec", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "4e653c8f9e63c6cd4e8f6dd97e7d766efa86fb6d", "filename": "src/rt/rust_env.cpp", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frt%2Frust_env.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frt%2Frust_env.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_env.cpp?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "0e3af9eae60cfaf5c47efb20c41324913479a212", "filename": "src/rt/rust_env.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frt%2Frust_env.h", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frt%2Frust_env.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_env.h?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "7412f06d8cd87c913115cb90d65b9203fa73828e", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "02fecd440f8e0ffaa05e047ba3de2940a083845f", "filename": "src/rt/sync/rust_thread.cpp", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frt%2Fsync%2Frust_thread.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frt%2Fsync%2Frust_thread.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Frust_thread.cpp?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "2e310785306c066d16f9413fe745a6f56851a3aa", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 57, "deletions": 46, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "8aa7caefc7a5e624fbe3bdc4d2686045b001ed8c", "filename": "src/rustc/back/rpath.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Frpath.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "a2c864f6f465fc6d4f79575a9036531852b6d284", "filename": "src/rustc/back/upcall.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Fupcall.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "e389f3a4bdf7dfc3e92a390155cb0d80b6bc3dba", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "c6b93fc0603ab1adb633447d34efb7673d94761c", "filename": "src/rustc/driver/rustc.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Frustc.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "c6c0ff2826a528a2293d25ddc24545eb4ae78db5", "filename": "src/rustc/driver/session.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fsession.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "4577b54fb5c7610fc3563f34187fddf9ab53c73f", "filename": "src/rustc/front/config.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fconfig.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "952d7b9ab7937cba3657501c917f6f22a1dba2ee", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "0d92c19b9521b9163c3773bda44a4c6a31e28c18", "filename": "src/rustc/lib/llvm.rs", "status": "modified", "additions": 27, "deletions": 21, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Flib%2Fllvm.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "1857abf2cf2f9504a8515f8032518d3895de557c", "filename": "src/rustc/metadata/common.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcommon.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "3ed56a1953e68f2686fd7abc5acdf6b0d9d41fdf", "filename": "src/rustc/metadata/creader.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcreader.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "d59464d58c7342107e683f544bb58cfa4324e505", "filename": "src/rustc/metadata/cstore.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcstore.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "0e6bc2aee15a8b3e6d6309f2dd2595917874a107", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "17d686b41d1aceade275592c12a83c42f78defe5", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 30, "deletions": 31, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "63370b09321040bdecd6ce86209cf04da0a715d7", "filename": "src/rustc/metadata/filesearch.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ffilesearch.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "0a8354be71f76e9e1e2d4fbb6deb8aa354ca3bf6", "filename": "src/rustc/metadata/loader.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Floader.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "f3fa0e3f3507ff02818edfbba9fa7e60d2b2181d", "filename": "src/rustc/metadata/tydecode.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftydecode.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "29368ae95b80064eda545568d63a51ab421a2a96", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "414890cbd7c643e49b66997b0751e3c9d2c370e1", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "0c79c0fcd7f36b69a074c24a5f2e5d332b13d01f", "filename": "src/rustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "327db51518be580f216e6273db47ccf615c0be07", "filename": "src/rustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "618d43e121a307f6241dd8d6d3c2cae759a8baa5", "filename": "src/rustc/middle/capture.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Fcapture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Fcapture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcapture.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "f71b82a2be7ea868fbcba4e65fae9de4d96d100c", "filename": "src/rustc/middle/check_alt.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_alt.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "bd3abe201349508e0ee944d5f2ac5f071ab0ae84", "filename": "src/rustc/middle/check_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_const.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "5def18cacc31d60d08434613250bafb725691253", "filename": "src/rustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fconst_eval.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "7e925d7d8d84213e6a124cdd2b2f495272f05c6a", "filename": "src/rustc/middle/freevars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ffreevars.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "9aff382775c85ca40b2bcc9bdf12447452f903f6", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "7cb2c9eb9cf192dae754fb31620067e336e461f2", "filename": "src/rustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flang_items.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "0f31f2056a14abdf2244975837fb08d69d627b2a", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 106, "deletions": 34, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "69b325b03a4a7ffd3d7a539f5b5f097dad5acafa", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "fe465db1312c6fff609435b732d3fe0385ac51f5", "filename": "src/rustc/middle/mem_categorization.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fmem_categorization.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "006065988b92ceecd2bcefb2ab694459fdf17980", "filename": "src/rustc/middle/pat_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fpat_util.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "4d291ceb590dc7c5d92d6b569b8564ca8b482d58", "filename": "src/rustc/middle/privacy.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fprivacy.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "ff708b7f4efa12b0e433317ed870088c32555b0a", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "eca0687f2fda36ca36a50caeef794a54f3e1631f", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 236, "deletions": 207, "changes": 443, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "73f1e9bd1191c725f235af3dfa9a5520d751c835", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "0631d7b1ea4d06771bfa35d7df795956f66d7923", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 36, "deletions": 37, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "69de8a2cca3e247056c44d3bf05bc8f10cd741dd", "filename": "src/rustc/middle/trans/build.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "e7b4dd171e316b4650fa5b4ad117ef7ffca79116", "filename": "src/rustc/middle/trans/callee.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "1ab25a1832932bd3d753148ba41df46a360afe36", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "6768f3e71a0d319fc0070cc1747e66d813b65cd8", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "ce32cd0a2dd1e0802855677bec9e22cabb1f7535", "filename": "src/rustc/middle/trans/controlflow.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "241fa5e53afb29bd828bc8d5ffd47f33c9909507", "filename": "src/rustc/middle/trans/datum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "6cd4b49fa3b36fa006b148e4a7686ec1c37eed7c", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "57439daca2f2c527241e22775662d3b5d6dda654", "filename": "src/rustc/middle/trans/expr.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "74dadd2cab49820d704c97de11c8c4a7a6cd9c30", "filename": "src/rustc/middle/trans/foreign.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "a8a750cd4be4091b50de83acae25188d8deb8408", "filename": "src/rustc/middle/trans/glue.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "76888471bf978c6cd03e67004082b0412c2dc96f", "filename": "src/rustc/middle/trans/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Finline.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "5515d80f4bdea18ac81c8e90872197abb21e19a7", "filename": "src/rustc/middle/trans/machine.rs", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fmachine.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "a94519306a48007b28f0f8a656eb68d9f12a5fad", "filename": "src/rustc/middle/trans/meth.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "cd8cffa297a6409f122ef9c25bb26f1a5514c1e4", "filename": "src/rustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "cf58b5b51c4c3631fcc02440f3e8aecd35441d88", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 7, "deletions": 731, "changes": 738, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "e1eae11569453b5577ca3409dc98711c8db972dd", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "b45da3b27004b95649dfddaeae8eae5c90e85dfd", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "6bd3c22f626a2fe395018bf8073b8f85c04fed98", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "109db9ace099088de7a55c2ca7ac59dbce7ef1bf", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 70, "deletions": 65, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "45a7c22e2f90836670f13fb766185ae29d5556de", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "368b69cafaba1787a7edd34510da3c12e3646dd1", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "0b2e9c8ab3dda0287d15693f3209ed9c64d23b93", "filename": "src/rustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "d08d3e9b8478abbd7cb87f85beafd216763c3349", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 12, "deletions": 54, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "4afb3ad78a635639ac7987d478256a552f7eb4e3", "filename": "src/rustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "e8595b2f50a1d141b223a4ad8ff51d35b6b8185c", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 78, "deletions": 28, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "33a26c8daf4972c26c4c99efde6b54fbac7074c4", "filename": "src/rustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "e9238e30c663443272000db7e484da1b4056386f", "filename": "src/rustc/middle/typeck/coherence.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "18e29981af30d054cec4afd9da6b32a5b65ea88c", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "e5aa0debfe17d2869df9d52c369e6ab29353f094", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "db65bff9bfec22586ea5f2e9529e4a1fa79c4aef", "filename": "src/rustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "8bbdab74d230ef81b44bede225fb189daa3f6a61", "filename": "src/rustc/middle/typeck/infer/region_var_bindings.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "2a851a5f7bb26994927e895b10d995e11340a09b", "filename": "src/rustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "7ccbaa40ada199960d3cb876a7bc7adfe9fffa3a", "filename": "src/rustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "dad27b706e60f42f1e6f410198c32ef17b496c7a", "filename": "src/rustc/rustc.rc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Frustc.rc?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "37cc016e8ea08dea0b9afade952c2d1cfe900b77", "filename": "src/rustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fcommon.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "0df5827ed3d8f794230e285bf80afcb24e2083b8", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "ab6b348c04a2d39fd16c5791c7763a34e3d87467", "filename": "src/rustdoc/astsrv.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fastsrv.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "d5f0ca9f507b44f845b48fc91963b23e7e42d2dc", "filename": "src/rustdoc/attr_pass.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_pass.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "d601d6d92d1e3b16f024e441fce2f1d40271cb95", "filename": "src/rustdoc/config.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fconfig.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "b8946ce17b0dc798caffa3fade8c462de0381a67", "filename": "src/rustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdesc_to_brief_pass.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "0764d9e2432687cb7cd3d5de53d905d961d4fce6", "filename": "src/rustdoc/doc.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdoc.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "7b34a327bee248f29d74ba9bfcb27d8f062d989c", "filename": "src/rustdoc/extract.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fextract.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "28dbdaeea801fcf1eaf3d077b091b181451ff260", "filename": "src/rustdoc/fold.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ffold.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "3bd74d6ffe2ee5f37460224e3cd2b758c5543555", "filename": "src/rustdoc/markdown_index_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_index_pass.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "ad3f679a97cb5886ec39fd5eda89f27ccf5ca94c", "filename": "src/rustdoc/page_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fpage_pass.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "f6a241fdac8488924b9042f90199b6fe16be1957", "filename": "src/rustdoc/path_pass.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustdoc%2Fpath_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustdoc%2Fpath_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fpath_pass.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "f8714b0e9bacef9ead6012624baeb0b794cc8e6b", "filename": "src/rustdoc/rustdoc.rc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustdoc%2Frustdoc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustdoc%2Frustdoc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Frustdoc.rc?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "50ebef05afbec49ffbaba75d903021f3a4a133cd", "filename": "src/rustdoc/rustdoc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Frustdoc.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "088ca4d51bd06b51f0f7db1ef69a96a5a3ac0505", "filename": "src/rustdoc/sectionalize_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsectionalize_pass.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "b929cd0aa91a54104eea575f24eb6f62f0a6d1f5", "filename": "src/rustdoc/text_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftext_pass.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "08ad3ea3ecf4c16a883c269134ce3a1de4014f2d", "filename": "src/rustdoc/tystr_pass.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftystr_pass.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "2f38c20e900fdb222d37386163791c1ea682bb14", "filename": "src/rustdoc/unindent_pass.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustdoc%2Funindent_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustdoc%2Funindent_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Funindent_pass.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "fc2049507eed970eb1ff3a146335faeca7a14fa0", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 55, "deletions": 19, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "36833e5175e6d193014287c8131ee58dbe7c7f2f", "filename": "src/rustllvm/rustllvm.def.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustllvm%2Frustllvm.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Frustllvm%2Frustllvm.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.def.in?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "7464d18247d99745ec168b1ac73f7d861198e3a9", "filename": "src/snapshots.txt", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "bb286f956bcdc6de76070953e216ac6210616f66", "filename": "src/test/auxiliary/cci_class.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fauxiliary%2Fcci_class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fauxiliary%2Fcci_class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "186f021a81f983d8fd6c6df6470499c0d6e1dc63", "filename": "src/test/auxiliary/cci_class_2.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fauxiliary%2Fcci_class_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fauxiliary%2Fcci_class_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_2.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "dbae452a8f906ddb52b60ef7014743f1dcde84c3", "filename": "src/test/auxiliary/cci_class_3.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fauxiliary%2Fcci_class_3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fauxiliary%2Fcci_class_3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_3.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "436f92e5e78131e832e4a0a8f03d57d889660ee6", "filename": "src/test/auxiliary/cci_class_4.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fauxiliary%2Fcci_class_4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fauxiliary%2Fcci_class_4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_4.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "6cf86aff055e983a0e6fce79ad29b269651b9cd7", "filename": "src/test/auxiliary/cci_class_6.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fauxiliary%2Fcci_class_6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fauxiliary%2Fcci_class_6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_6.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "288fe66dd2053458e2ae7fb599aa6a896129ee67", "filename": "src/test/auxiliary/cci_class_cast.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "e7bf211d3f0e1e9439ac42200bc94f057561a652", "filename": "src/test/auxiliary/crateresolve7x.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fauxiliary%2Fcrateresolve7x.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fauxiliary%2Fcrateresolve7x.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve7x.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "bb6d425de34488a46478484c133dc5d357f1d9ca", "filename": "src/test/auxiliary/foreign_lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fauxiliary%2Fforeign_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fauxiliary%2Fforeign_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fforeign_lib.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "d774669cd13268311dc69c2166abe36192e34505", "filename": "src/test/auxiliary/issue-3012-1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fauxiliary%2Fissue-3012-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fauxiliary%2Fissue-3012-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-3012-1.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "77f107fda090d0b0384d66a04d15084ea4ed234e", "filename": "src/test/auxiliary/test_comm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fauxiliary%2Ftest_comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fauxiliary%2Ftest_comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftest_comm.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "afd9b2ccc9ca0ea95c651e00f23adc35ee04e867", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "cf44d478356282b54d966224dfc451dbd7c9117e", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "2b9216876b42fd8ec946f28ec0e8d8531a28f967", "filename": "src/test/bench/core-vec-append.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fbench%2Fcore-vec-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fbench%2Fcore-vec-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-vec-append.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "a34fcc89c048ce497a3605db7d50c2f29b8f09e8", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "0a55e7572db9341fc131fdf58f5124bb065e3dbf", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "ab67a8c7cb128688ac4004b9dec844794900b1ce", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "ec144b78a10ae8e117862ab4305c24a683b7be98", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "119c2065d6bc0235090004638ee607d79c8c9c67", "filename": "src/test/bench/msgsend-ring-pipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "1b857b6caeb80abaf50b1212a96668711182df54", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "5533aeeeb41b788b07b3620b29d1881906d61dd6", "filename": "src/test/bench/msgsend-ring.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fbench%2Fmsgsend-ring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fbench%2Fmsgsend-ring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "fb1e3ae92262817f4a25ea743ed6ea38955d70c3", "filename": "src/test/bench/msgsend.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fbench%2Fmsgsend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fbench%2Fmsgsend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "70f98934e1bc3ed3894228ad0ca4694bebf07a30", "filename": "src/test/bench/pingpong.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fbench%2Fpingpong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fbench%2Fpingpong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fpingpong.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "5c7827f5106d114c4ec8f09e777141e10b19d350", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "0c742e16bfa574df8ace7e3c8209b87d4d1b995a", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "85dcdd32e13d11fec5f6df09f8cd9951efbfbc85", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "6ba6eb7feadd37b3735aad4b44a27cb2240ee911", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}, {"sha": "ee38b957b0cb00d19f416a9515ecc5d10a7ae391", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efcd2385ea2389f270ff8ac8bc256636f647b130/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=efcd2385ea2389f270ff8ac8bc256636f647b130"}]}