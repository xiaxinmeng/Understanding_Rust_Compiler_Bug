{"sha": "c28c28779c082b6e1d0e7007a222392dc5d6c052", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyOGMyODc3OWMwODJiNmUxZDBlNzAwN2EyMjIzOTJkYzVkNmMwNTI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-12-11T10:02:23Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-12-11T10:02:23Z"}, "message": "use an enum instead of bool", "tree": {"sha": "e5ca04b1e823d32d3516e2764cf6c41ed5f17237", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5ca04b1e823d32d3516e2764cf6c41ed5f17237"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c28c28779c082b6e1d0e7007a222392dc5d6c052", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c28c28779c082b6e1d0e7007a222392dc5d6c052", "html_url": "https://github.com/rust-lang/rust/commit/c28c28779c082b6e1d0e7007a222392dc5d6c052", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c28c28779c082b6e1d0e7007a222392dc5d6c052/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "741ba1f2c29cf8f0f404699a284c4f3647d3d48a", "url": "https://api.github.com/repos/rust-lang/rust/commits/741ba1f2c29cf8f0f404699a284c4f3647d3d48a", "html_url": "https://github.com/rust-lang/rust/commit/741ba1f2c29cf8f0f404699a284c4f3647d3d48a"}], "stats": {"total": 29, "additions": 17, "deletions": 12}, "files": [{"sha": "49cb3e55b098b57c8c8943497ad6bd9dfc742888", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c28c28779c082b6e1d0e7007a222392dc5d6c052/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c28c28779c082b6e1d0e7007a222392dc5d6c052/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=c28c28779c082b6e1d0e7007a222392dc5d6c052", "patch": "@@ -99,6 +99,10 @@ mod formatters;\n \n use formatters::{JsonFormatter, OutputFormatter, PrettyFormatter, TerseFormatter};\n \n+/// Whether to execute tests concurrently or not\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum Concurrent { Yes, No }\n+\n // The name of a test. By convention this follows the rules for rust\n // paths; i.e. it should be a series of identifiers separated by double\n // colons. This way if some test runner wants to arrange the tests\n@@ -1150,7 +1154,7 @@ where\n         while !remaining.is_empty() {\n             let test = remaining.pop().unwrap();\n             callback(TeWait(test.desc.clone()))?;\n-            run_test(opts, !opts.run_tests, test, tx.clone(), /*concurrency*/false);\n+            run_test(opts, !opts.run_tests, test, tx.clone(), Concurrent::No);\n             let (test, result, stdout) = rx.recv().unwrap();\n             callback(TeResult(test, result, stdout))?;\n         }\n@@ -1161,7 +1165,7 @@ where\n                 let timeout = Instant::now() + Duration::from_secs(TEST_WARN_TIMEOUT_S);\n                 running_tests.insert(test.desc.clone(), timeout);\n                 callback(TeWait(test.desc.clone()))?; //here no pad\n-                run_test(opts, !opts.run_tests, test, tx.clone(), /*concurrency*/true);\n+                run_test(opts, !opts.run_tests, test, tx.clone(), Concurrent::Yes);\n                 pending += 1;\n             }\n \n@@ -1193,7 +1197,7 @@ where\n         // All benchmarks run at the end, in serial.\n         for b in filtered_benchs {\n             callback(TeWait(b.desc.clone()))?;\n-            run_test(opts, false, b, tx.clone(), /*concurrency*/true);\n+            run_test(opts, false, b, tx.clone(), Concurrent::No);\n             let (test, result, stdout) = rx.recv().unwrap();\n             callback(TeResult(test, result, stdout))?;\n         }\n@@ -1395,7 +1399,7 @@ pub fn run_test(\n     force_ignore: bool,\n     test: TestDescAndFn,\n     monitor_ch: Sender<MonitorMsg>,\n-    concurrency: bool,\n+    concurrency: Concurrent,\n ) {\n     let TestDescAndFn { desc, testfn } = test;\n \n@@ -1412,7 +1416,7 @@ pub fn run_test(\n         monitor_ch: Sender<MonitorMsg>,\n         nocapture: bool,\n         testfn: Box<dyn FnBox() + Send>,\n-        concurrency: bool,\n+        concurrency: Concurrent,\n     ) {\n         // Buffer for capturing standard I/O\n         let data = Arc::new(Mutex::new(Vec::new()));\n@@ -1447,7 +1451,7 @@ pub fn run_test(\n         // the test synchronously, regardless of the concurrency\n         // level.\n         let supports_threads = !cfg!(target_os = \"emscripten\") && !cfg!(target_arch = \"wasm32\");\n-        if concurrency && supports_threads {\n+        if concurrency == Concurrent::Yes && supports_threads {\n             let cfg = thread::Builder::new().name(name.as_slice().to_owned());\n             cfg.spawn(runtest).unwrap();\n         } else {\n@@ -1758,6 +1762,7 @@ mod tests {\n     use std::sync::mpsc::channel;\n     use bench;\n     use Bencher;\n+    use Concurrent;\n \n \n     fn one_ignored_one_unignored_test() -> Vec<TestDescAndFn> {\n@@ -1798,7 +1803,7 @@ mod tests {\n             testfn: DynTestFn(Box::new(f)),\n         };\n         let (tx, rx) = channel();\n-        run_test(&TestOpts::new(), false, desc, tx, /*concurrency*/false);\n+        run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n         let (_, res, _) = rx.recv().unwrap();\n         assert!(res != TrOk);\n     }\n@@ -1816,7 +1821,7 @@ mod tests {\n             testfn: DynTestFn(Box::new(f)),\n         };\n         let (tx, rx) = channel();\n-        run_test(&TestOpts::new(), false, desc, tx, /*concurrency*/false);\n+        run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n         let (_, res, _) = rx.recv().unwrap();\n         assert!(res == TrIgnored);\n     }\n@@ -1836,7 +1841,7 @@ mod tests {\n             testfn: DynTestFn(Box::new(f)),\n         };\n         let (tx, rx) = channel();\n-        run_test(&TestOpts::new(), false, desc, tx, /*concurrency*/false);\n+        run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n         let (_, res, _) = rx.recv().unwrap();\n         assert!(res == TrOk);\n     }\n@@ -1856,7 +1861,7 @@ mod tests {\n             testfn: DynTestFn(Box::new(f)),\n         };\n         let (tx, rx) = channel();\n-        run_test(&TestOpts::new(), false, desc, tx, /*concurrency*/false);\n+        run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n         let (_, res, _) = rx.recv().unwrap();\n         assert!(res == TrOk);\n     }\n@@ -1878,7 +1883,7 @@ mod tests {\n             testfn: DynTestFn(Box::new(f)),\n         };\n         let (tx, rx) = channel();\n-        run_test(&TestOpts::new(), false, desc, tx, /*concurrency*/false);\n+        run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n         let (_, res, _) = rx.recv().unwrap();\n         assert!(res == TrFailedMsg(format!(\"{} '{}'\", failed_msg, expected)));\n     }\n@@ -1896,7 +1901,7 @@ mod tests {\n             testfn: DynTestFn(Box::new(f)),\n         };\n         let (tx, rx) = channel();\n-        run_test(&TestOpts::new(), false, desc, tx, /*concurrency*/false);\n+        run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n         let (_, res, _) = rx.recv().unwrap();\n         assert!(res == TrFailed);\n     }"}]}