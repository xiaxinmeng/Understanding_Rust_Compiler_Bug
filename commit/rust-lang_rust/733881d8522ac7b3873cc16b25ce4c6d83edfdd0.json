{"sha": "733881d8522ac7b3873cc16b25ce4c6d83edfdd0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczMzg4MWQ4NTIyYWM3YjM4NzNjYzE2YjI1Y2U0YzZkODNlZGZkZDA=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-05-09T22:07:54Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-05-23T05:29:16Z"}, "message": "std: tightening up net::tcp, server/client test done, still has races..\n\n.. going to rework the listen() API to be non-blocking.", "tree": {"sha": "d9ac6db7b7018cf77e63658d98fc5a908c575505", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9ac6db7b7018cf77e63658d98fc5a908c575505"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/733881d8522ac7b3873cc16b25ce4c6d83edfdd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/733881d8522ac7b3873cc16b25ce4c6d83edfdd0", "html_url": "https://github.com/rust-lang/rust/commit/733881d8522ac7b3873cc16b25ce4c6d83edfdd0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/733881d8522ac7b3873cc16b25ce4c6d83edfdd0/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4127d3fc696588e00fd2201a95c766b2bf8755f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4127d3fc696588e00fd2201a95c766b2bf8755f", "html_url": "https://github.com/rust-lang/rust/commit/a4127d3fc696588e00fd2201a95c766b2bf8755f"}], "stats": {"total": 547, "additions": 325, "deletions": 222}, "files": [{"sha": "42c2fba6911caab7a4629999b4a1463a122c1a57", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 324, "deletions": 221, "changes": 545, "blob_url": "https://github.com/rust-lang/rust/blob/733881d8522ac7b3873cc16b25ce4c6d83edfdd0/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/733881d8522ac7b3873cc16b25ce4c6d83edfdd0/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=733881d8522ac7b3873cc16b25ce4c6d83edfdd0", "patch": "@@ -3,12 +3,25 @@ High-level interface to libuv's TCP functionality\n \"];\n \n import ip = net_ip;\n+import comm::*;\n+import result::*;\n+import str::*;\n \n+// data\n export tcp_socket, tcp_err_data;\n-export connect, write, read_start, read_stop, listen, accept;\n+// operations on a tcp_socket\n+export write, read_start, read_stop;\n+// tcp server stuff\n+export listen, accept;\n+// tcp client stuff\n+export connect;\n+// misc util\n+export is_responding;\n \n #[doc=\"\n Encapsulates an open TCP/IP connection through libuv\n+\n+`tcp_socket` non-sendable and handles automatically closing the underlying libuv data structures when it goes out of scope.\n \"]\n resource tcp_socket(socket_data: @tcp_socket_data) unsafe {\n     let closed_po = comm::port::<()>();\n@@ -221,6 +234,7 @@ fn read_start(sock: tcp_socket)\n     let stream_handle_ptr = ptr::addr_of((**sock).stream_handle);\n     let start_po = comm::port::<option<uv::ll::uv_err_data>>();\n     let start_ch = comm::chan(start_po);\n+    log(debug, \"in tcp::read_start before interact loop\");\n     uv::hl::interact((**sock).hl_loop) {|loop_ptr|\n         log(debug, #fmt(\"in tcp::read_start interact cb %?\", loop_ptr));\n         alt uv::ll::read_start(stream_handle_ptr as *uv::ll::uv_stream_t,\n@@ -290,7 +304,19 @@ Bind to a given IP/port and listen for new connections\n * `backlog` - a uint representing the number of incoming connections\n to cache in memory\n * `new_connect_cb` - a callback to be evaluated, on the libuv thread,\n-whenever a client attempts to conect on the provided ip/port\n+whenever a client attempts to conect on the provided ip/port. The\n+callback's arguments are:\n+    * `new_conn` - an opaque type that can be passed to\n+    `net::tcp::accept` in order to be converted to a `tcp_socket`.\n+    * `kill_ch` - channel of type `comm::chan<option<tcp_err_data>>`. This\n+    channel can be used to send a message to cause `listen` to begin\n+    closing the underlying libuv data structures.\n+\n+# Returns\n+\n+A `result` instance containing empty data of type `()` on a successful\n+or normal shutdown, and a `tcp_err_data` record in the event of listen\n+exiting because of an error\n \"]\n fn listen(host_ip: ip::ip_addr, port: uint, backlog: uint,\n           new_connect_cb: fn~(tcp_new_connection,\n@@ -385,18 +411,49 @@ Bind an incoming client connection to a `net::tcp::tcp_socket`\n \n # Notes\n \n-It is safe to call `net::tcp::accept` _only_ within the callback\n-provided as the final argument of the `net::tcp::listen` function.\n+It is safe to call `net::tcp::accept` _only_ within the context of the\n+`new_connect_cb` callback provided as the final argument to the\n+`net::tcp::listen` function.\n \n-The `new_conn` opaque value provided _only_ as the first argument to the\n-`new_connect_cb`. It can be safely sent to another task but it _must_ be\n+The `new_conn` opaque value is provided _only_ as the first argument to the\n+`new_connect_cb` provided as a part of `net::tcp::listen`.\n+It can be safely sent to another task but it _must_ be\n used (via `net::tcp::accept`) before the `new_connect_cb` call it was\n-provided within returns.\n+provided to returns.\n \n-This means that a port/chan pair must be used to make sure that the\n+This implies that a port/chan pair must be used to make sure that the\n `new_connect_cb` call blocks until an attempt to create a\n `net::tcp::tcp_socket` is completed.\n \n+# Example\n+\n+Here, the `new_conn` is used in conjunction with `accept` from within\n+a task spawned by the `new_connect_cb` passed into `listen`\n+\n+~~~~~~~~~~~\n+net::tcp::listen(remote_ip, remote_port, backlog) {|new_conn, kill_ch|\n+    let cont_po = comm::port::<option<tcp_err_data>>();\n+    let cont_ch = comm::chan(cont_po);\n+    task::spawn {||\n+        let accept_result = net::tcp::accept(new_conn);\n+        alt accept_result.is_failure() {\n+          false { comm::send(cont_ch, result::get_err(accept_result)); }\n+          true {\n+            let sock = result::get(accept_result);\n+            comm::send(cont_ch, true);\n+            // do work here\n+          }\n+        }\n+    };\n+    alt comm::recv(cont_po) {\n+      // shut down listen()\n+      some(err_data) { comm::send(kill_chan, some(err_data)) }\n+      // wait for next connection\n+      none {}\n+    }\n+};\n+~~~~~~~~~~~\n+\n # Arguments\n \n * `new_conn` - an opaque value used to create a new `tcp_socket`\n@@ -418,8 +475,8 @@ fn accept(new_conn: tcp_new_connection)\n       new_tcp_conn(server_handle_ptr) {\n         let server_data_ptr = uv::ll::get_data_for_uv_handle(\n             server_handle_ptr) as *tcp_server_data;\n-        let hl_loop = (*server_data_ptr).hl_loop;// FIXME\n         let reader_po = comm::port::<result::result<[u8], tcp_err_data>>();\n+        let hl_loop = (*server_data_ptr).hl_loop;\n         let client_socket_data = @{\n             reader_po: reader_po,\n             reader_ch: comm::chan(reader_po),\n@@ -434,31 +491,42 @@ fn accept(new_conn: tcp_new_connection)\n \n         let result_po = comm::port::<option<tcp_err_data>>();\n         let result_ch = comm::chan(result_po);\n-        uv::hl::interact(hl_loop) {|loop_ptr|\n-            log(debug, \"in interact cb for tcp::accept\");\n-            alt uv::ll::tcp_init(loop_ptr, client_stream_handle_ptr) {\n+\n+        // UNSAFE LIBUV INTERACTION BEGIN\n+        // .. normally this happens within the context of\n+        // a call to uv::hl::interact.. but we're breaking\n+        // the rules here because this always has to be\n+        // called within the context of a listen() new_connect_cb\n+        // callback (or it will likely fail and drown your cat)\n+        log(debug, \"in interact cb for tcp::accept\");\n+        let loop_ptr = uv::ll::get_loop_for_uv_handle(\n+            server_handle_ptr);\n+        alt uv::ll::tcp_init(loop_ptr, client_stream_handle_ptr) {\n+          0i32 {\n+            log(debug, \"uv_tcp_init successful for client stream\");\n+            alt uv::ll::accept(\n+                server_handle_ptr as *libc::c_void,\n+                client_stream_handle_ptr as *libc::c_void) {\n               0i32 {\n-                log(debug, \"uv_tcp_init successful for client stream\");\n-                alt uv::ll::accept(server_handle_ptr,\n-                                   client_stream_handle_ptr) {\n-                  0i32 {\n-                    log(debug, \"successfully accepted client connection\");\n-                    comm::send(result_ch, none);\n-                  }\n-                  _ {\n-                    log(debug, \"failed to accept client conn\");\n-                    comm::send(result_ch, some(\n-                        uv::ll::get_last_err_data(loop_ptr).to_tcp_err()));\n-                  }\n-                }\n+                log(debug, \"successfully accepted client connection\");\n+                uv::ll::set_data_for_uv_handle(client_stream_handle_ptr,\n+                                               client_socket_data_ptr);\n+                comm::send(result_ch, none);\n               }\n               _ {\n-                log(debug, \"failed to init client stream\");\n+                log(debug, \"failed to accept client conn\");\n                 comm::send(result_ch, some(\n                     uv::ll::get_last_err_data(loop_ptr).to_tcp_err()));\n               }\n             }\n-        };\n+          }\n+          _ {\n+            log(debug, \"failed to init client stream\");\n+            comm::send(result_ch, some(\n+                uv::ll::get_last_err_data(loop_ptr).to_tcp_err()));\n+          }\n+        }\n+        // UNSAFE LIBUV INTERACTION END\n         alt comm::recv(result_po) {\n           some(err_data) {\n             result::err(err_data)\n@@ -471,6 +539,52 @@ fn accept(new_conn: tcp_new_connection)\n     }\n }\n \n+#[doc=\"\n+Attempt to open a TCP/IP connection on a remote host\n+\n+The connection will (attempt to) be successfully established and then\n+disconnect immediately. It is useful to determine, simply, if a remote\n+host is responding, and that is all.\n+\n+# Arguments\n+\n+* `remote_ip` - an IP address (versions 4 or 6) for the remote host\n+* `remote_port` - a uint representing the port on the remote host to\n+connect to\n+* `timeout_msecs` - a timeout period, in miliseconds, to wait before\n+aborting the connection attempt\n+\n+# Returns\n+\n+A `bool` indicating success or failure. If a connection was established\n+to the remote host in the alloted timeout, `true` is returned. If the\n+host refused the connection, timed out or had some other error condition,\n+`false` is returned.\n+\"]\n+fn is_responding(remote_ip: ip::ip_addr, remote_port: uint,\n+                timeout_msecs: uint) -> bool {\n+    log(debug, \"entering is_responding\");\n+    let connected_po = comm::port::<bool>();\n+    let connected_ch = comm::chan(connected_po);\n+    task::spawn {||\n+        log(debug, \"in is_responding nested task\");\n+        let connect_result = connect(remote_ip, remote_port);\n+        let connect_succeeded = result::is_success(connect_result);\n+        log(debug, #fmt(\"leaving is_responding nested task .. result %?\",\n+           connect_succeeded));\n+        comm::send(connected_ch, connect_succeeded);\n+    };\n+    log(debug, \"exiting is_responding\");\n+    alt timer::recv_timeout(timeout_msecs, connected_po) {\n+      some(connect_succeeded) {\n+        log(debug, #fmt(\"connect succedded? %?\", connect_succeeded));\n+        connect_succeeded }\n+      none {\n+        log(debug, \"is_responding timed out on waiting to connect\");\n+        false }\n+    }\n+}\n+\n // INTERNAL API\n \n enum tcp_new_connection {\n@@ -553,23 +667,27 @@ impl of to_tcp_err_iface for uv::ll::uv_err_data {\n crust fn on_tcp_read_cb(stream: *uv::ll::uv_stream_t,\n                     nread: libc::ssize_t,\n                     ++buf: uv::ll::uv_buf_t) unsafe {\n-    log(debug, \"entering on_tcp_read_cb\");\n+    log(debug, #fmt(\"entering on_tcp_read_cb stream: %? nread: %?\",\n+                    stream, nread));\n     let loop_ptr = uv::ll::get_loop_for_uv_handle(stream);\n     let socket_data_ptr = uv::ll::get_data_for_uv_handle(stream)\n         as *tcp_socket_data;\n-    let reader_ch = (*socket_data_ptr).reader_ch;\n     alt nread {\n       // incoming err.. probably eof\n       -1 {\n-        let err_data = uv::ll::get_last_err_data(loop_ptr);\n-        comm::send(reader_ch, result::err(err_data.to_tcp_err()));\n+        let err_data = uv::ll::get_last_err_data(loop_ptr).to_tcp_err();\n+        log(debug, #fmt(\"on_tcp_read_cb: incoming err.. name %? msg %?\",\n+                        err_data.err_name, err_data.err_msg));\n+        let reader_ch = (*socket_data_ptr).reader_ch;\n+        comm::send(reader_ch, result::err(err_data));\n       }\n       // do nothing .. unneeded buf\n       0 {}\n       // have data\n       _ {\n         // we have data\n         log(debug, #fmt(\"tcp on_read_cb nread: %d\", nread));\n+        let reader_ch = (*socket_data_ptr).reader_ch;\n         let buf_base = uv::ll::get_base_from_buf(buf);\n         let buf_len = uv::ll::get_len_from_buf(buf);\n         let new_bytes = vec::unsafe::from_buf(buf_base, buf_len);\n@@ -702,221 +820,206 @@ fn ipv4_ip_addr_to_sockaddr_in(input_ip: ip::ip_addr,\n \n //#[cfg(test)]\n mod test {\n-    #[test]\n-    fn test_gl_tcp_ipv4_client() {\n-        let ip_str = \"173.194.79.99\";\n-        let port = 80u;\n-        let write_input = \"GET / HTTP/1.1\\r\\n\\r\\n\";\n-        let read_output =\n-            impl_gl_tcp_ipv4_client(ip_str, port, write_input);\n-        log(debug, \"DATA RECEIVED: \"+read_output);\n+    // FIXME don't run on fbsd or linux 32 bit(#2064)\n+    #[cfg(target_os=\"win32\")]\n+    #[cfg(target_os=\"darwin\")]\n+    #[cfg(target_os=\"linux\")]\n+    mod tcp_ipv4_server_and_client_test {\n+        #[cfg(target_arch=\"x86_64\")]\n+        mod impl64 {\n+            #[test]\n+            fn test_gl_tcp_server_and_client_ipv4() unsafe {\n+                impl_gl_tcp_ipv4_server_and_client();\n+            }\n+        }\n+        #[cfg(target_arch=\"x86\")]\n+        mod impl32 {\n+            #[test]\n+            #[ignore(cfg(target_os = \"linux\"))]\n+            fn test_gl_tcp_server_and_client_ipv4() unsafe {\n+                impl_gl_tcp_ipv4_server_and_client();\n+            }\n+        }\n     }\n-\n-    #[test]\n-    fn test_gl_tcp_ipv4_server() {\n+    fn impl_gl_tcp_ipv4_server_and_client() {\n         let server_ip = \"127.0.0.1\";\n         let server_port = 8888u;\n-        let kill_str = \"asdf\";\n-        let resp_str = \"hw\";\n-\n-        let result_po = comm::port::<str>();\n-        let result_ch = comm::chan(result_po);\n-        task::spawn_sched(task::manual_threads(4u)) {||\n-            let inner_result_po = comm::port::<str>();\n-            let inner_result_ch = comm::chan(inner_result_po);\n-\n-            impl_gl_tcp_ipv4_server(server_ip, server_port,\n-                                    kill_str, resp_str,\n-                                    inner_result_ch);\n-            let result_str = comm::recv(inner_result_po);\n-            comm::send(result_ch, result_str);\n+        let expected_req = \"ping\";\n+        let expected_resp = \"pong\";\n+\n+        let server_result_po = comm::port::<str>();\n+        let server_result_ch = comm::chan(server_result_po);\n+        // server\n+        task::spawn_sched(task::manual_threads(1u)) {||\n+            let actual_req = comm::listen {|server_ch|\n+                run_tcp_test_server(\n+                    server_ip,\n+                    server_port,\n+                    expected_resp,\n+                    server_ch)\n+            };\n+            server_result_ch.send(actual_req);\n+        };\n+        // client\n+        log(debug, \"server started, firing up client..\");\n+        let actual_resp = comm::listen {|client_ch|\n+            log(debug, \"before client sleep\");\n+            timer::sleep(2u);\n+            log(debug, \"after client sleep\");\n+            run_tcp_test_client(\n+                server_ip,\n+                server_port,\n+                expected_req,\n+                client_ch)\n         };\n-        let output = comm::recv(result_po);\n-        log(debug, #fmt(\"RECEIVED REQ %? FROM USER\", output));\n+        let actual_req = comm::recv(server_result_po);\n+        log(debug, #fmt(\"REQ: expected: '%s' actual: '%s'\",\n+                       expected_req, actual_req));\n+        log(debug, #fmt(\"RESP: expected: '%s' actual: '%s'\",\n+                       expected_resp, actual_resp));\n+        assert str::contains(actual_req, expected_req);\n+        assert str::contains(actual_resp, expected_resp);\n     }\n \n-    fn impl_gl_tcp_ipv4_server(host_str: str, port: uint,\n-                               kill_str: str, resp_str: str,\n-                              output_ch: comm::chan<str>) {\n-        let host_ip = ip::v4::parse_addr(host_str);\n-        log(debug, \"about to enter listen() call for test server\");\n-        listen(host_ip, port, 128u) {|new_conn, kill_ch|\n-            // this is a callback that is going to be invoked on the\n-            // loop's thread (can't be avoided).\n-            let cont_po = comm::port::<()>();\n-            let cont_ch = comm::chan(cont_po);\n-            task::spawn {||\n-                log(debug, \"starting worker for incoming req\");\n-\n-                // work loop\n-                let accept_result = accept(new_conn);\n-                if result::is_failure(accept_result) {\n-                    // accept failed..\n-                    log(debug,\"accept in worker task failed\");\n-                    comm::send(kill_ch,\n-                               some(result::get_err(accept_result)\n-                                    .to_tcp_err()));\n-                }\n-                // accept() succeeded, let the task that is\n-                // listen()'ing know so it can continue and\n-                // unblock libuv..\n-                comm::send(cont_ch, ());\n-\n-                // our precious sock.. from here on out, things\n-                // match the tcp request/client api, as they're\n-                // both on tcp_sockets at this point..\n-                let sock = result::unwrap(accept_result);\n-                let req_bytes = single_read_bytes_from(sock);\n-                let req_str = str::from_bytes(req_bytes);\n-                if str::contains(req_str, kill_str) {\n-                    // our signal to shut down the tcp\n-                    // server was received. shut it down.\n-                    comm::send(kill_ch, none);\n-                }\n-                write_single_str(sock, resp_str);\n-\n-                comm::send(output_ch, req_str);\n-                // work's complete, let socket close..\n-                log(debug, \"exiting worker\");\n+    fn run_tcp_test_server(server_ip: str, server_port: uint, resp: str,\n+                          server_ch: comm::chan<str>) -> str {\n+\n+        task::spawn_sched(task::manual_threads(1u)) {||\n+            let server_ip_addr = ip::v4::parse_addr(server_ip);\n+            let listen_result = listen(server_ip_addr, server_port, 128u)\n+                // this callback is ran on the loop.\n+                // .. should it go?\n+                {|new_conn, kill_ch|\n+                log(debug, \"SERVER: new connection!\");\n+                comm::listen {|cont_ch|\n+                    task::spawn_sched(task::manual_threads(1u)) {||\n+                        log(debug, \"SERVER: starting worker for new req\");\n+\n+                        let accept_result = accept(new_conn);\n+                        log(debug, \"SERVER: after accept()\");\n+                        if result::is_failure(accept_result) {\n+                            log(debug, \"SERVER: error accept connection\");\n+                            let err_data = result::get_err(accept_result);\n+                            comm::send(kill_ch, some(err_data));\n+                            log(debug,\n+                                \"SERVER/WORKER: send on err cont ch\");\n+                            cont_ch.send(());\n+                        }\n+                        else {\n+                            log(debug,\n+                                \"SERVER/WORKER: send on cont ch\");\n+                            cont_ch.send(());\n+                            let sock = result::unwrap(accept_result);\n+                            log(debug, \"SERVER: successfully accepted\"+\n+                                \"connection!\");\n+                            let received_req_bytes =\n+                                tcp_read_single(sock);\n+                            alt received_req_bytes {\n+                              result::ok(data) {\n+                                server_ch.send(\n+                                    str::from_bytes(data));\n+                                log(debug, \"SERVER: before write\");\n+                                tcp_write_single(sock, str::bytes(resp));\n+                                log(debug, \"SERVER: after write.. die\");\n+                                comm::send(kill_ch, none);\n+                              }\n+                              result::err(err_data) {\n+                                comm::send(kill_ch, some(err_data));\n+                                server_ch.send(\"\");\n+                              }\n+                            }\n+                            log(debug, \"SERVER: worker spinning down\");\n+                        }\n+                    }\n+                    log(debug, \"SERVER: waiting to recv on cont_ch\");\n+                    cont_ch.recv()\n+                };\n+                log(debug, \"SERVER: recv'd on cont_ch..leaving listen cb\");\n             };\n-\n-            comm::recv(cont_po);\n+            // err check on listen_result\n+            if result::is_failure(listen_result) {\n+                let err_data = result::get_err(listen_result);\n+                log(debug, #fmt(\"SERVER: exited abnormally name %s msg %s\",\n+                                err_data.err_name, err_data.err_msg));\n+            }\n         };\n-        log(debug, \"exiting listen() block for test server\");\n+        let ret_val = server_ch.recv();\n+        log(debug, #fmt(\"SERVER: exited and got ret val: '%s'\", ret_val));\n+        ret_val\n     }\n+    \n+    fn run_tcp_test_client(server_ip: str, server_port: uint, resp: str,\n+                          client_ch: comm::chan<str>) -> str {\n \n-    fn impl_gl_tcp_ipv4_client(ip_str: str, port: uint,\n-                               write_input: str) -> str {\n-        // pre-connection/input data\n-        let host_ip = ip::v4::parse_addr(ip_str);\n+        let server_ip_addr = ip::v4::parse_addr(server_ip);\n \n-        // connect to remote host\n-        let connect_result = connect(host_ip, port);\n+        log(debug, \"CLIENT: starting..\");\n+        let connect_result = connect(server_ip_addr, server_port);\n         if result::is_failure(connect_result) {\n+            log(debug, \"CLIENT: failed to connect\");\n             let err_data = result::get_err(connect_result);\n-            log(debug, \"tcp_connect_error received..\");\n-            log(debug, #fmt(\"tcp connect error: %? %?\", err_data.err_name,\n-                           err_data.err_msg));\n-            assert false;\n-        }\n-\n-        // this is our tcp_socket resource instance. It's dtor will\n-        // clean-up/close the underlying TCP stream when the fn scope\n-        // ends\n-        let sock = result::unwrap(connect_result);\n-        log(debug, \"successful tcp connect\");\n-\n-        // set up write data\n-        let write_data = [str::as_bytes(write_input) {|str_bytes|\n-            str_bytes\n-        }];\n-\n-        // write data to tcp socket\n-        let write_result = write(sock, write_data);\n-        if result::is_failure(write_result) {\n-            let err_data = result::get_err(write_result);\n-            log(debug, \"tcp_write_error received..\");\n-            log(debug, #fmt(\"tcp write error: %? %?\", err_data.err_name,\n-                           err_data.err_msg));\n-            assert false;\n-        }\n-        log(debug, \"tcp::write successful\");\n-\n-        // set up read data\n-        let mut total_read_data: [u8] = [];\n-        let read_start_result = read_start(sock);\n-        if result::is_failure(read_start_result) {\n-            let err_data = result::get_err(read_start_result);\n-            log(debug, \"tcp read_start err received..\");\n-            log(debug, #fmt(\"read_start error: %? %?\", err_data.err_name,\n-                           err_data.err_msg));\n-            assert false;\n+            log(debug, #fmt(\"CLIENT: connect err name: %s msg: %s\",\n+                            err_data.err_name, err_data.err_msg));\n+            \"\"\n         }\n-        let reader_po = result::get(read_start_result);\n-        loop {\n-            let read_data_result = comm::recv(reader_po);\n-            if result::is_failure(read_data_result) {\n-                let err_data = result::get_err(read_data_result);\n-                log(debug, \"read error data recv'd\");\n-                log(debug, #fmt(\"read error: %? %?\",\n-                                err_data.err_name,\n-                                err_data.err_msg));\n-                assert false;\n+        else {\n+            let sock = result::unwrap(connect_result);\n+            let resp_bytes = str::bytes(resp);\n+            tcp_write_single(sock, resp_bytes);\n+            let read_result = tcp_read_single(sock);\n+            if read_result.is_failure() {\n+                log(debug, \"CLIENT: failure to read\");\n+                \"\"\n             }\n-            let new_data = result::unwrap(read_data_result);\n-            total_read_data += new_data;\n-            // theoretically, we could keep iterating, if\n-            // we expect the server on the other end to keep\n-            // streaming/chunking data to us, but..\n-            let read_stop_result = read_stop(sock);\n-            if result::is_failure(read_stop_result) {\n-                let err_data = result::get_err(read_stop_result);\n-                log(debug, \"error while calling read_stop\");\n-                log(debug, #fmt(\"read_stop error: %? %?\",\n-                                err_data.err_name,\n-                                err_data.err_msg));\n-                assert false;\n+            else {\n+                client_ch.send(str::from_bytes(read_result.get()));\n+                let ret_val = client_ch.recv();\n+                log(debug, #fmt(\"CLIENT: after client_ch recv ret: '%s'\",\n+                   ret_val));\n+                ret_val\n             }\n-            break;\n         }\n-        str::from_bytes(total_read_data)\n     }\n \n-    fn single_read_bytes_from(sock: tcp_socket) -> [u8] {\n-        let mut total_read_data: [u8] = [];\n-        let read_start_result = read_start(sock);\n-        if result::is_failure(read_start_result) {\n-            let err_data = result::get_err(read_start_result);\n-            log(debug, \"srbf tcp read_start err received..\");\n-            log(debug, #fmt(\"srbf read_start error: %? %?\",\n-                            err_data.err_name,\n-                           err_data.err_msg));\n-            assert false;\n-        }\n-        let reader_po = result::get(read_start_result);\n-\n-        let read_data_result = comm::recv(reader_po);\n-        if result::is_failure(read_data_result) {\n-            let err_data = result::get_err(read_data_result);\n-            log(debug, \"srbf read error data recv'd\");\n-            log(debug, #fmt(\"srbf read error: %? %?\",\n-                            err_data.err_name,\n-                            err_data.err_msg));\n-            assert false;\n+    fn tcp_read_single(sock: tcp_socket)\n+        -> result::result<[u8],tcp_err_data> {\n+        log(debug, \"starting tcp_read_single\");\n+        let rs_result = read_start(sock);\n+        if result::is_failure(rs_result) {\n+            let err_data = result::get_err(rs_result);\n+            result::err(err_data)\n         }\n-        let new_data = result::unwrap(read_data_result);\n-        total_read_data += new_data;\n-        // theoretically, we could keep iterating, if\n-        // we expect the server on the other end to keep\n-        // streaming/chunking data to us, but..\n-        let read_stop_result = read_stop(sock);\n-        if result::is_failure(read_stop_result) {\n-            let err_data = result::get_err(read_stop_result);\n-            log(debug, \"srbf error while calling read_stop\");\n-            log(debug, #fmt(\"srbf read_stop error: %? %?\",\n-                            err_data.err_name,\n-                            err_data.err_msg));\n-            assert false;\n+        else {\n+            log(debug, \"before recv_timeout\");\n+            let read_result = timer::recv_timeout(\n+                2000u, result::get(rs_result));\n+            log(debug, \"after recv_timeout\");\n+            alt read_result {\n+              none {\n+                log(debug, \"tcp_read_single: timed out..\");\n+                let err_data = {\n+                    err_name: \"TIMEOUT\",\n+                    err_msg: \"req timed out\"\n+                };\n+                result::err(err_data)\n+              }\n+              some(data_result) {\n+                log(debug, \"tcp_read_single: got data\");\n+                data_result\n+              }\n+            }\n         }\n-        total_read_data\n     }\n \n-    fn write_single_str(sock: tcp_socket, write_input: str) {\n-        // set up write data\n-        let write_data = [str::as_bytes(write_input) {|str_bytes|\n-            str_bytes\n-        }];\n-\n-        // write data to tcp socket\n-        let write_result = write(sock, write_data);\n+    fn tcp_write_single(sock: tcp_socket, val: [u8]) {\n+        let write_result = write(sock, [val]);\n         if result::is_failure(write_result) {\n+            log(debug, \"tcp_write_single: write failed!\");\n             let err_data = result::get_err(write_result);\n-            log(debug, \"wss tcp_write_error received..\");\n-            log(debug, #fmt(\"wss tcp write error: %? %?\",\n-                            err_data.err_name,\n-                            err_data.err_msg));\n-            assert false;\n+            log(debug, #fmt(\"tcp_write_single err name: %s msg: %s\",\n+                err_data.err_name, err_data.err_msg));\n+            // meh. torn on what to do here.\n+            fail \"tcp_write_single failed\";\n         }\n-        log(debug, \"wss tcp::write successful\");\n     }\n }"}, {"sha": "b48f2e73e4c68aab2ea92180f800d656d35ba119", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/733881d8522ac7b3873cc16b25ce4c6d83edfdd0/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/733881d8522ac7b3873cc16b25ce4c6d83edfdd0/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=733881d8522ac7b3873cc16b25ce4c6d83edfdd0", "patch": "@@ -1318,7 +1318,7 @@ mod test {\n         assert str::contains(msg_from_server, server_resp_msg);\n     }\n \n-    // don't run this test on fbsd or 32bit linux\n+    // FIXME don't run on fbsd or linux 32 bit(#2064)\n     #[cfg(target_os=\"win32\")]\n     #[cfg(target_os=\"darwin\")]\n     #[cfg(target_os=\"linux\")]"}]}