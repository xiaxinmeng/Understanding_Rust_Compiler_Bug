{"sha": "fd8e175c4e39537b16beb40c704a17fcf9796852", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkOGUxNzVjNGUzOTUzN2IxNmJlYjQwYzcwNGExN2ZjZjk3OTY4NTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-08T03:11:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-08T03:11:36Z"}, "message": "Auto merge of #26859 - arielb1:const-deref-again, r=eddyb\n\nFixes #25901 \r\n\r\nr? @eddyb", "tree": {"sha": "fbb7d8c23d8163999efe0eff80fe5ef6298d027f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fbb7d8c23d8163999efe0eff80fe5ef6298d027f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd8e175c4e39537b16beb40c704a17fcf9796852", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd8e175c4e39537b16beb40c704a17fcf9796852", "html_url": "https://github.com/rust-lang/rust/commit/fd8e175c4e39537b16beb40c704a17fcf9796852", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd8e175c4e39537b16beb40c704a17fcf9796852/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e6a9be10bc1b178dc0b23c505fc8f17e925cabb2", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6a9be10bc1b178dc0b23c505fc8f17e925cabb2", "html_url": "https://github.com/rust-lang/rust/commit/e6a9be10bc1b178dc0b23c505fc8f17e925cabb2"}, {"sha": "45fd29621dc0827c12f4534976026f1f8d1676b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/45fd29621dc0827c12f4534976026f1f8d1676b5", "html_url": "https://github.com/rust-lang/rust/commit/45fd29621dc0827c12f4534976026f1f8d1676b5"}], "stats": {"total": 76, "additions": 58, "deletions": 18}, "files": [{"sha": "c329f2fb012db00519bc9b9e8452ce697c512cbe", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fd8e175c4e39537b16beb40c704a17fcf9796852/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd8e175c4e39537b16beb40c704a17fcf9796852/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=fd8e175c4e39537b16beb40c704a17fcf9796852", "patch": "@@ -1237,5 +1237,6 @@ register_diagnostics! {\n     E0314, // closure outlives stack frame\n     E0315, // cannot invoke closure outside of its lifetime\n     E0316, // nested quantification of lifetimes\n-    E0370  // discriminant overflow\n+    E0370, // discriminant overflow\n+    E0400  // overloaded derefs are not allowed in constants\n }"}, {"sha": "d4737f9d604d154467a10a6a5332248032ce0c1a", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fd8e175c4e39537b16beb40c704a17fcf9796852/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd8e175c4e39537b16beb40c704a17fcf9796852/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=fd8e175c4e39537b16beb40c704a17fcf9796852", "patch": "@@ -332,7 +332,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             ast::ExprIndex(ref l, ref r) |\n-            ast::ExprBinary(_, ref l, ref r) if self.is_method_call(expr) => {\n+            ast::ExprBinary(_, ref l, ref r) if self.tcx.is_method_call(expr.id) => {\n                 self.call(expr, pred, &**l, Some(&**r).into_iter())\n             }\n \n@@ -342,7 +342,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.straightline(expr, pred, fields)\n             }\n \n-            ast::ExprUnary(_, ref e) if self.is_method_call(expr) => {\n+            ast::ExprUnary(_, ref e) if self.tcx.is_method_call(expr.id) => {\n                 self.call(expr, pred, &**e, None::<ast::Expr>.iter())\n             }\n \n@@ -631,9 +631,4 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n         }\n     }\n-\n-    fn is_method_call(&self, expr: &ast::Expr) -> bool {\n-        let method_call = ty::MethodCall::expr(expr.id);\n-        self.tcx.tables.borrow().method_map.contains_key(&method_call)\n-    }\n }"}, {"sha": "59f91a50f74212e92c9422a070f2550429ca3610", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fd8e175c4e39537b16beb40c704a17fcf9796852/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd8e175c4e39537b16beb40c704a17fcf9796852/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=fd8e175c4e39537b16beb40c704a17fcf9796852", "patch": "@@ -405,6 +405,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n \n         let node_ty = self.tcx.node_id_to_type(ex.id);\n         check_expr(self, ex, node_ty);\n+        check_adjustments(self, ex);\n \n         // Special-case some expressions to avoid certain flags bubbling up.\n         match ex.node {\n@@ -777,6 +778,25 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n     }\n }\n \n+/// Check the adjustments of an expression\n+fn check_adjustments<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &ast::Expr) {\n+    match v.tcx.tables.borrow().adjustments.get(&e.id) {\n+        None | Some(&ty::AdjustReifyFnPointer) | Some(&ty::AdjustUnsafeFnPointer) => {}\n+        Some(&ty::AdjustDerefRef(ty::AutoDerefRef { autoderefs, .. })) => {\n+            if (0..autoderefs as u32).any(|autoderef| {\n+                    v.tcx.is_overloaded_autoderef(e.id, autoderef)\n+            }) {\n+                v.add_qualif(ConstQualif::NOT_CONST);\n+                if v.mode != Mode::Var {\n+                    span_err!(v.tcx.sess, e.span, E0400,\n+                              \"user-defined dereference operators are not allowed in {}s\",\n+                              v.msg());\n+                }\n+            }\n+        }\n+    }\n+}\n+\n pub fn check_crate(tcx: &ty::ctxt) {\n     visit::walk_crate(&mut CheckCrateVisitor {\n         tcx: tcx,"}, {"sha": "b4b8fbf2064adb5bfce97dcd5488785e66860475", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fd8e175c4e39537b16beb40c704a17fcf9796852/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd8e175c4e39537b16beb40c704a17fcf9796852/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=fd8e175c4e39537b16beb40c704a17fcf9796852", "patch": "@@ -6631,6 +6631,11 @@ impl<'tcx> ctxt<'tcx> {\n         self.tables.borrow().method_map.contains_key(&MethodCall::expr(expr_id))\n     }\n \n+    pub fn is_overloaded_autoderef(&self, expr_id: ast::NodeId, autoderefs: u32) -> bool {\n+        self.tables.borrow().method_map.contains_key(&MethodCall::autoderef(expr_id,\n+                                                                            autoderefs))\n+    }\n+\n     pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture> {\n         Some(self.tables.borrow().upvar_capture_map.get(&upvar_id).unwrap().clone())\n     }"}, {"sha": "c88c194106e8ccb5e511f98bcd6792b3686cd5ce", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fd8e175c4e39537b16beb40c704a17fcf9796852/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd8e175c4e39537b16beb40c704a17fcf9796852/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=fd8e175c4e39537b16beb40c704a17fcf9796852", "patch": "@@ -367,8 +367,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 match datum.ty.sty {\n                     // Don't skip a conversion from Box<T> to &T, etc.\n                     ty::TyRef(..) => {\n-                        let method_call = MethodCall::autoderef(expr.id, 0);\n-                        if bcx.tcx().tables.borrow().method_map.contains_key(&method_call) {\n+                        if bcx.tcx().is_overloaded_autoderef(expr.id, 0) {\n                             // Don't skip an overloaded deref.\n                             0\n                         } else {\n@@ -1612,9 +1611,7 @@ fn trans_unary<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // The only overloaded operator that is translated to a datum\n     // is an overloaded deref, since it is always yields a `&T`.\n     // Otherwise, we should be in the RvalueDpsExpr path.\n-    assert!(\n-        op == ast::UnDeref ||\n-        !ccx.tcx().tables.borrow().method_map.contains_key(&method_call));\n+    assert!(op == ast::UnDeref || !ccx.tcx().is_method_call(expr.id));\n \n     let un_ty = expr_ty(bcx, expr);\n \n@@ -1907,7 +1904,7 @@ fn trans_binary<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let ccx = bcx.ccx();\n \n     // if overloaded, would be RvalueDpsExpr\n-    assert!(!ccx.tcx().tables.borrow().method_map.contains_key(&MethodCall::expr(expr.id)));\n+    assert!(!ccx.tcx().is_method_call(expr.id));\n \n     match op.node {\n         ast::BiAnd => {\n@@ -2141,7 +2138,7 @@ fn trans_assign_op<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     debug!(\"trans_assign_op(expr={:?})\", expr);\n \n     // User-defined operator methods cannot be used with `+=` etc right now\n-    assert!(!bcx.tcx().tables.borrow().method_map.contains_key(&MethodCall::expr(expr.id)));\n+    assert!(!bcx.tcx().is_method_call(expr.id));\n \n     // Evaluate LHS (destination), which should be an lvalue\n     let dst_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, dst, \"assign_op\"));\n@@ -2606,7 +2603,7 @@ enum ExprKind {\n }\n \n fn expr_kind(tcx: &ty::ctxt, expr: &ast::Expr) -> ExprKind {\n-    if tcx.tables.borrow().method_map.contains_key(&MethodCall::expr(expr.id)) {\n+    if tcx.is_method_call(expr.id) {\n         // Overloaded operations are generally calls, and hence they are\n         // generated via DPS, but there are a few exceptions:\n         return match expr.node {"}, {"sha": "1c21813fc63bda63920dfb881851332d8324abef", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fd8e175c4e39537b16beb40c704a17fcf9796852/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd8e175c4e39537b16beb40c704a17fcf9796852/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=fd8e175c4e39537b16beb40c704a17fcf9796852", "patch": "@@ -516,8 +516,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n     type_must_outlive(rcx, infer::ExprTypeIsNotInScope(expr_ty, expr.span),\n                       expr_ty, ty::ReScope(CodeExtent::from_node_id(expr.id)));\n \n-    let method_call = MethodCall::expr(expr.id);\n-    let has_method_map = rcx.fcx.inh.tables.borrow().method_map.contains_key(&method_call);\n+    let has_method_map = rcx.fcx.infcx().is_method_call(expr.id);\n \n     // Check any autoderefs or autorefs that appear.\n     let adjustment = rcx.fcx.inh.tables.borrow().adjustments.get(&expr.id).map(|a| a.clone());"}, {"sha": "3254f0b2aa9bdd1bd7544cb39da6bdbd18fb3b00", "filename": "src/test/compile-fail/issue-25901.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fd8e175c4e39537b16beb40c704a17fcf9796852/src%2Ftest%2Fcompile-fail%2Fissue-25901.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd8e175c4e39537b16beb40c704a17fcf9796852/src%2Ftest%2Fcompile-fail%2Fissue-25901.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-25901.rs?ref=fd8e175c4e39537b16beb40c704a17fcf9796852", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct A;\n+struct B;\n+\n+static S: &'static B = &A; //~ ERROR user-defined dereference operators\n+\n+use std::ops::Deref;\n+\n+impl Deref for A {\n+    type Target = B;\n+    fn deref(&self)->&B { static B_: B = B; &B_ }\n+}\n+\n+fn main(){}"}]}