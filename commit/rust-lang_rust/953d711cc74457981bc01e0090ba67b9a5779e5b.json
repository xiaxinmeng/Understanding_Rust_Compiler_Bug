{"sha": "953d711cc74457981bc01e0090ba67b9a5779e5b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1M2Q3MTFjYzc0NDU3OTgxYmMwMWUwMDkwYmE2N2I5YTU3NzllNWI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-07-27T19:00:38Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-08-10T00:28:46Z"}, "message": "promote svh calculation into its own directory", "tree": {"sha": "15600f18d62c9b63c15ee0c302f085c34154a9fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15600f18d62c9b63c15ee0c302f085c34154a9fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/953d711cc74457981bc01e0090ba67b9a5779e5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/953d711cc74457981bc01e0090ba67b9a5779e5b", "html_url": "https://github.com/rust-lang/rust/commit/953d711cc74457981bc01e0090ba67b9a5779e5b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/953d711cc74457981bc01e0090ba67b9a5779e5b/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae9c049cfc69ac8e14adb8bf6c26ef73c2bbe4ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae9c049cfc69ac8e14adb8bf6c26ef73c2bbe4ba", "html_url": "https://github.com/rust-lang/rust/commit/ae9c049cfc69ac8e14adb8bf6c26ef73c2bbe4ba"}], "stats": {"total": 909, "additions": 459, "deletions": 450}, "files": [{"sha": "de53da2fd36ad3ccd823864612b086363270f5ed", "filename": "src/librustc_incremental/calculate_svh.rs", "status": "removed", "additions": 0, "deletions": 450, "changes": 450, "blob_url": "https://github.com/rust-lang/rust/blob/ae9c049cfc69ac8e14adb8bf6c26ef73c2bbe4ba/src%2Flibrustc_incremental%2Fcalculate_svh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae9c049cfc69ac8e14adb8bf6c26ef73c2bbe4ba/src%2Flibrustc_incremental%2Fcalculate_svh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh.rs?ref=ae9c049cfc69ac8e14adb8bf6c26ef73c2bbe4ba", "patch": "@@ -1,450 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Calculation of a Strict Version Hash for crates.  For a length\n-//! comment explaining the general idea, see `librustc/middle/svh.rs`.\n-\n-use syntax::attr::AttributeMethods;\n-use std::hash::{Hash, SipHasher, Hasher};\n-use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n-use rustc::hir::map::{NodeItem, NodeForeignItem};\n-use rustc::hir::svh::Svh;\n-use rustc::ty::TyCtxt;\n-use rustc::hir::intravisit::{self, Visitor};\n-\n-use self::svh_visitor::StrictVersionHashVisitor;\n-\n-pub trait SvhCalculate {\n-    /// Calculate the SVH for an entire krate.\n-    fn calculate_krate_hash(self) -> Svh;\n-\n-    /// Calculate the SVH for a particular item.\n-    fn calculate_item_hash(self, def_id: DefId) -> u64;\n-}\n-\n-impl<'a, 'tcx> SvhCalculate for TyCtxt<'a, 'tcx, 'tcx> {\n-    fn calculate_krate_hash(self) -> Svh {\n-        // FIXME (#14132): This is better than it used to be, but it still not\n-        // ideal. We now attempt to hash only the relevant portions of the\n-        // Crate AST as well as the top-level crate attributes. (However,\n-        // the hashing of the crate attributes should be double-checked\n-        // to ensure it is not incorporating implementation artifacts into\n-        // the hash that are not otherwise visible.)\n-\n-        let crate_disambiguator = self.sess.local_crate_disambiguator();\n-        let krate = self.map.krate();\n-\n-        // FIXME: this should use SHA1, not SipHash. SipHash is not built to\n-        //        avoid collisions.\n-        let mut state = SipHasher::new();\n-        debug!(\"state: {:?}\", state);\n-\n-        // FIXME(#32753) -- at (*) we `to_le` for endianness, but is\n-        // this enough, and does it matter anyway?\n-        \"crate_disambiguator\".hash(&mut state);\n-        crate_disambiguator.len().to_le().hash(&mut state); // (*)\n-        crate_disambiguator.hash(&mut state);\n-\n-        debug!(\"crate_disambiguator: {:?}\", crate_disambiguator);\n-        debug!(\"state: {:?}\", state);\n-\n-        {\n-            let mut visit = StrictVersionHashVisitor::new(&mut state, self);\n-            krate.visit_all_items(&mut visit);\n-        }\n-\n-        // FIXME (#14132): This hash is still sensitive to e.g. the\n-        // spans of the crate Attributes and their underlying\n-        // MetaItems; we should make ContentHashable impl for those\n-        // types and then use hash_content.  But, since all crate\n-        // attributes should appear near beginning of the file, it is\n-        // not such a big deal to be sensitive to their spans for now.\n-        //\n-        // We hash only the MetaItems instead of the entire Attribute\n-        // to avoid hashing the AttrId\n-        for attr in &krate.attrs {\n-            debug!(\"krate attr {:?}\", attr);\n-            attr.meta().hash(&mut state);\n-        }\n-\n-        Svh::new(state.finish())\n-    }\n-\n-    fn calculate_item_hash(self, def_id: DefId) -> u64 {\n-        assert!(def_id.is_local());\n-\n-        debug!(\"calculate_item_hash(def_id={:?})\", def_id);\n-\n-        let mut state = SipHasher::new();\n-\n-        {\n-            let mut visit = StrictVersionHashVisitor::new(&mut state, self);\n-            if def_id.index == CRATE_DEF_INDEX {\n-                // the crate root itself is not registered in the map\n-                // as an item, so we have to fetch it this way\n-                let krate = self.map.krate();\n-                intravisit::walk_crate(&mut visit, krate);\n-            } else {\n-                let node_id = self.map.as_local_node_id(def_id).unwrap();\n-                match self.map.find(node_id) {\n-                    Some(NodeItem(item)) => visit.visit_item(item),\n-                    Some(NodeForeignItem(item)) => visit.visit_foreign_item(item),\n-                    r => bug!(\"calculate_item_hash: expected an item for node {} not {:?}\",\n-                              node_id, r),\n-                }\n-            }\n-        }\n-\n-        let hash = state.finish();\n-\n-        debug!(\"calculate_item_hash: def_id={:?} hash={:?}\", def_id, hash);\n-\n-        hash\n-    }\n-}\n-\n-// FIXME (#14132): Even this SVH computation still has implementation\n-// artifacts: namely, the order of item declaration will affect the\n-// hash computation, but for many kinds of items the order of\n-// declaration should be irrelevant to the ABI.\n-\n-mod svh_visitor {\n-    pub use self::SawExprComponent::*;\n-    pub use self::SawStmtComponent::*;\n-    use self::SawAbiComponent::*;\n-    use syntax::ast::{self, Name, NodeId};\n-    use syntax::parse::token;\n-    use syntax_pos::Span;\n-    use rustc::ty::TyCtxt;\n-    use rustc::hir;\n-    use rustc::hir::*;\n-    use rustc::hir::map::DefPath;\n-    use rustc::hir::intravisit as visit;\n-    use rustc::hir::intravisit::{Visitor, FnKind};\n-\n-    use std::hash::{Hash, SipHasher};\n-\n-    pub struct StrictVersionHashVisitor<'a, 'tcx: 'a> {\n-        pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        pub st: &'a mut SipHasher,\n-    }\n-\n-    impl<'a, 'tcx> StrictVersionHashVisitor<'a, 'tcx> {\n-        pub fn new(st: &'a mut SipHasher,\n-                   tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                   -> Self {\n-            StrictVersionHashVisitor { st: st, tcx: tcx }\n-        }\n-\n-        fn hash_def_path(&mut self, path: &DefPath) {\n-            path.deterministic_hash_to(self.tcx, self.st);\n-        }\n-    }\n-\n-    // To off-load the bulk of the hash-computation on #[derive(Hash)],\n-    // we define a set of enums corresponding to the content that our\n-    // crate visitor will encounter as it traverses the ast.\n-    //\n-    // The important invariant is that all of the Saw*Component enums\n-    // do not carry any Spans, Names, or Idents.\n-    //\n-    // Not carrying any Names/Idents is the important fix for problem\n-    // noted on PR #13948: using the ident.name as the basis for a\n-    // hash leads to unstable SVH, because ident.name is just an index\n-    // into intern table (i.e. essentially a random address), not\n-    // computed from the name content.\n-    //\n-    // With the below enums, the SVH computation is not sensitive to\n-    // artifacts of how rustc was invoked nor of how the source code\n-    // was laid out.  (Or at least it is *less* sensitive.)\n-\n-    // This enum represents the different potential bits of code the\n-    // visitor could encounter that could affect the ABI for the crate,\n-    // and assigns each a distinct tag to feed into the hash computation.\n-    #[derive(Hash)]\n-    enum SawAbiComponent<'a> {\n-\n-        // FIXME (#14132): should we include (some function of)\n-        // ident.ctxt as well?\n-        SawIdent(token::InternedString),\n-        SawStructDef(token::InternedString),\n-\n-        SawLifetime(token::InternedString),\n-        SawLifetimeDef(token::InternedString),\n-\n-        SawMod,\n-        SawForeignItem,\n-        SawItem,\n-        SawTy,\n-        SawGenerics,\n-        SawFn,\n-        SawTraitItem,\n-        SawImplItem,\n-        SawStructField,\n-        SawVariant,\n-        SawPath,\n-        SawBlock,\n-        SawPat,\n-        SawLocal,\n-        SawArm,\n-        SawExpr(SawExprComponent<'a>),\n-        SawStmt(SawStmtComponent),\n-    }\n-\n-    /// SawExprComponent carries all of the information that we want\n-    /// to include in the hash that *won't* be covered by the\n-    /// subsequent recursive traversal of the expression's\n-    /// substructure by the visitor.\n-    ///\n-    /// We know every Expr_ variant is covered by a variant because\n-    /// `fn saw_expr` maps each to some case below.  Ensuring that\n-    /// each variant carries an appropriate payload has to be verified\n-    /// by hand.\n-    ///\n-    /// (However, getting that *exactly* right is not so important\n-    /// because the SVH is just a developer convenience; there is no\n-    /// guarantee of collision-freedom, hash collisions are just\n-    /// (hopefully) unlikely.)\n-    #[derive(Hash)]\n-    pub enum SawExprComponent<'a> {\n-\n-        SawExprLoop(Option<token::InternedString>),\n-        SawExprField(token::InternedString),\n-        SawExprTupField(usize),\n-        SawExprBreak(Option<token::InternedString>),\n-        SawExprAgain(Option<token::InternedString>),\n-\n-        SawExprBox,\n-        SawExprVec,\n-        SawExprCall,\n-        SawExprMethodCall,\n-        SawExprTup,\n-        SawExprBinary(hir::BinOp_),\n-        SawExprUnary(hir::UnOp),\n-        SawExprLit(ast::LitKind),\n-        SawExprCast,\n-        SawExprType,\n-        SawExprIf,\n-        SawExprWhile,\n-        SawExprMatch,\n-        SawExprClosure,\n-        SawExprBlock,\n-        SawExprAssign,\n-        SawExprAssignOp(hir::BinOp_),\n-        SawExprIndex,\n-        SawExprPath(Option<usize>),\n-        SawExprAddrOf(hir::Mutability),\n-        SawExprRet,\n-        SawExprInlineAsm(&'a hir::InlineAsm),\n-        SawExprStruct,\n-        SawExprRepeat,\n-    }\n-\n-    fn saw_expr<'a>(node: &'a Expr_) -> SawExprComponent<'a> {\n-        match *node {\n-            ExprBox(..)              => SawExprBox,\n-            ExprVec(..)              => SawExprVec,\n-            ExprCall(..)             => SawExprCall,\n-            ExprMethodCall(..)       => SawExprMethodCall,\n-            ExprTup(..)              => SawExprTup,\n-            ExprBinary(op, _, _)     => SawExprBinary(op.node),\n-            ExprUnary(op, _)         => SawExprUnary(op),\n-            ExprLit(ref lit)         => SawExprLit(lit.node.clone()),\n-            ExprCast(..)             => SawExprCast,\n-            ExprType(..)             => SawExprType,\n-            ExprIf(..)               => SawExprIf,\n-            ExprWhile(..)            => SawExprWhile,\n-            ExprLoop(_, id)          => SawExprLoop(id.map(|id| id.node.as_str())),\n-            ExprMatch(..)            => SawExprMatch,\n-            ExprClosure(..)          => SawExprClosure,\n-            ExprBlock(..)            => SawExprBlock,\n-            ExprAssign(..)           => SawExprAssign,\n-            ExprAssignOp(op, _, _)   => SawExprAssignOp(op.node),\n-            ExprField(_, name)       => SawExprField(name.node.as_str()),\n-            ExprTupField(_, id)      => SawExprTupField(id.node),\n-            ExprIndex(..)            => SawExprIndex,\n-            ExprPath(ref qself, _)   => SawExprPath(qself.as_ref().map(|q| q.position)),\n-            ExprAddrOf(m, _)         => SawExprAddrOf(m),\n-            ExprBreak(id)            => SawExprBreak(id.map(|id| id.node.as_str())),\n-            ExprAgain(id)            => SawExprAgain(id.map(|id| id.node.as_str())),\n-            ExprRet(..)              => SawExprRet,\n-            ExprInlineAsm(ref a,_,_) => SawExprInlineAsm(a),\n-            ExprStruct(..)           => SawExprStruct,\n-            ExprRepeat(..)           => SawExprRepeat,\n-        }\n-    }\n-\n-    /// SawStmtComponent is analogous to SawExprComponent, but for statements.\n-    #[derive(Hash)]\n-    pub enum SawStmtComponent {\n-        SawStmtExpr,\n-        SawStmtSemi,\n-    }\n-\n-    impl<'a, 'tcx> Visitor<'a> for StrictVersionHashVisitor<'a, 'tcx> {\n-        fn visit_nested_item(&mut self, _: ItemId) {\n-            // Each item is hashed independently; ignore nested items.\n-        }\n-\n-        fn visit_variant_data(&mut self, s: &'a VariantData, name: Name,\n-                              g: &'a Generics, _: NodeId, _: Span) {\n-            debug!(\"visit_variant_data: st={:?}\", self.st);\n-            SawStructDef(name.as_str()).hash(self.st);\n-            visit::walk_generics(self, g);\n-            visit::walk_struct_def(self, s)\n-        }\n-\n-        fn visit_variant(&mut self, v: &'a Variant, g: &'a Generics, item_id: NodeId) {\n-            debug!(\"visit_variant: st={:?}\", self.st);\n-            SawVariant.hash(self.st);\n-            // walk_variant does not call walk_generics, so do it here.\n-            visit::walk_generics(self, g);\n-            visit::walk_variant(self, v, g, item_id)\n-        }\n-\n-        // All of the remaining methods just record (in the hash\n-        // SipHasher) that the visitor saw that particular variant\n-        // (with its payload), and continue walking as the default\n-        // visitor would.\n-        //\n-        // Some of the implementations have some notes as to how one\n-        // might try to make their SVH computation less discerning\n-        // (e.g. by incorporating reachability analysis).  But\n-        // currently all of their implementations are uniform and\n-        // uninteresting.\n-        //\n-        // (If you edit a method such that it deviates from the\n-        // pattern, please move that method up above this comment.)\n-\n-        fn visit_name(&mut self, _: Span, name: Name) {\n-            debug!(\"visit_name: st={:?}\", self.st);\n-            SawIdent(name.as_str()).hash(self.st);\n-        }\n-\n-        fn visit_lifetime(&mut self, l: &'a Lifetime) {\n-            debug!(\"visit_lifetime: st={:?}\", self.st);\n-            SawLifetime(l.name.as_str()).hash(self.st);\n-        }\n-\n-        fn visit_lifetime_def(&mut self, l: &'a LifetimeDef) {\n-            debug!(\"visit_lifetime_def: st={:?}\", self.st);\n-            SawLifetimeDef(l.lifetime.name.as_str()).hash(self.st);\n-        }\n-\n-        // We do recursively walk the bodies of functions/methods\n-        // (rather than omitting their bodies from the hash) since\n-        // monomorphization and cross-crate inlining generally implies\n-        // that a change to a crate body will require downstream\n-        // crates to be recompiled.\n-        fn visit_expr(&mut self, ex: &'a Expr) {\n-            debug!(\"visit_expr: st={:?}\", self.st);\n-            SawExpr(saw_expr(&ex.node)).hash(self.st); visit::walk_expr(self, ex)\n-        }\n-\n-        fn visit_stmt(&mut self, s: &'a Stmt) {\n-            debug!(\"visit_stmt: st={:?}\", self.st);\n-\n-            // We don't want to modify the hash for decls, because\n-            // they might be item decls (if they are local decls,\n-            // we'll hash that fact in visit_local); but we do want to\n-            // remember if this was a StmtExpr or StmtSemi (the later\n-            // had an explicit semi-colon; this affects the typing\n-            // rules).\n-            match s.node {\n-                StmtDecl(..) => (),\n-                StmtExpr(..) => SawStmt(SawStmtExpr).hash(self.st),\n-                StmtSemi(..) => SawStmt(SawStmtSemi).hash(self.st),\n-            }\n-\n-            visit::walk_stmt(self, s)\n-        }\n-\n-        fn visit_foreign_item(&mut self, i: &'a ForeignItem) {\n-            debug!(\"visit_foreign_item: st={:?}\", self.st);\n-\n-            // FIXME (#14132) ideally we would incorporate privacy (or\n-            // perhaps reachability) somewhere here, so foreign items\n-            // that do not leak into downstream crates would not be\n-            // part of the ABI.\n-            SawForeignItem.hash(self.st); visit::walk_foreign_item(self, i)\n-        }\n-\n-        fn visit_item(&mut self, i: &'a Item) {\n-            debug!(\"visit_item: {:?} st={:?}\", i, self.st);\n-\n-            // FIXME (#14132) ideally would incorporate reachability\n-            // analysis somewhere here, so items that never leak into\n-            // downstream crates (e.g. via monomorphisation or\n-            // inlining) would not be part of the ABI.\n-            SawItem.hash(self.st); visit::walk_item(self, i)\n-        }\n-\n-        fn visit_mod(&mut self, m: &'a Mod, _s: Span, n: NodeId) {\n-            debug!(\"visit_mod: st={:?}\", self.st);\n-            SawMod.hash(self.st); visit::walk_mod(self, m, n)\n-        }\n-\n-        fn visit_ty(&mut self, t: &'a Ty) {\n-            debug!(\"visit_ty: st={:?}\", self.st);\n-            SawTy.hash(self.st); visit::walk_ty(self, t)\n-        }\n-\n-        fn visit_generics(&mut self, g: &'a Generics) {\n-            debug!(\"visit_generics: st={:?}\", self.st);\n-            SawGenerics.hash(self.st); visit::walk_generics(self, g)\n-        }\n-\n-        fn visit_fn(&mut self, fk: FnKind<'a>, fd: &'a FnDecl,\n-                    b: &'a Block, s: Span, n: NodeId) {\n-            debug!(\"visit_fn: st={:?}\", self.st);\n-            SawFn.hash(self.st); visit::walk_fn(self, fk, fd, b, s, n)\n-        }\n-\n-        fn visit_trait_item(&mut self, ti: &'a TraitItem) {\n-            debug!(\"visit_trait_item: st={:?}\", self.st);\n-            SawTraitItem.hash(self.st); visit::walk_trait_item(self, ti)\n-        }\n-\n-        fn visit_impl_item(&mut self, ii: &'a ImplItem) {\n-            debug!(\"visit_impl_item: st={:?}\", self.st);\n-            SawImplItem.hash(self.st); visit::walk_impl_item(self, ii)\n-        }\n-\n-        fn visit_struct_field(&mut self, s: &'a StructField) {\n-            debug!(\"visit_struct_field: st={:?}\", self.st);\n-            SawStructField.hash(self.st); visit::walk_struct_field(self, s)\n-        }\n-\n-        fn visit_path(&mut self, path: &'a Path, _: ast::NodeId) {\n-            debug!(\"visit_path: st={:?}\", self.st);\n-            SawPath.hash(self.st); visit::walk_path(self, path)\n-        }\n-\n-        fn visit_block(&mut self, b: &'a Block) {\n-            debug!(\"visit_block: st={:?}\", self.st);\n-            SawBlock.hash(self.st); visit::walk_block(self, b)\n-        }\n-\n-        fn visit_pat(&mut self, p: &'a Pat) {\n-            debug!(\"visit_pat: st={:?}\", self.st);\n-            SawPat.hash(self.st); visit::walk_pat(self, p)\n-        }\n-\n-        fn visit_local(&mut self, l: &'a Local) {\n-            debug!(\"visit_local: st={:?}\", self.st);\n-            SawLocal.hash(self.st); visit::walk_local(self, l)\n-        }\n-\n-        fn visit_arm(&mut self, a: &'a Arm) {\n-            debug!(\"visit_arm: st={:?}\", self.st);\n-            SawArm.hash(self.st); visit::walk_arm(self, a)\n-        }\n-    }\n-}"}, {"sha": "d7caf8c882f0b36d52f575f98125ab368e81b3ad", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/953d711cc74457981bc01e0090ba67b9a5779e5b/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/953d711cc74457981bc01e0090ba67b9a5779e5b/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=953d711cc74457981bc01e0090ba67b9a5779e5b", "patch": "@@ -0,0 +1,113 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Calculation of a Strict Version Hash for crates.  For a length\n+//! comment explaining the general idea, see `librustc/middle/svh.rs`.\n+\n+use syntax::attr::AttributeMethods;\n+use std::hash::{Hash, SipHasher, Hasher};\n+use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n+use rustc::hir::map::{NodeItem, NodeForeignItem};\n+use rustc::hir::svh::Svh;\n+use rustc::ty::TyCtxt;\n+use rustc::hir::intravisit::{self, Visitor};\n+\n+use self::svh_visitor::StrictVersionHashVisitor;\n+\n+mod svh_visitor;\n+\n+pub trait SvhCalculate {\n+    /// Calculate the SVH for an entire krate.\n+    fn calculate_krate_hash(self) -> Svh;\n+\n+    /// Calculate the SVH for a particular item.\n+    fn calculate_item_hash(self, def_id: DefId) -> u64;\n+}\n+\n+impl<'a, 'tcx> SvhCalculate for TyCtxt<'a, 'tcx, 'tcx> {\n+    fn calculate_krate_hash(self) -> Svh {\n+        // FIXME (#14132): This is better than it used to be, but it still not\n+        // ideal. We now attempt to hash only the relevant portions of the\n+        // Crate AST as well as the top-level crate attributes. (However,\n+        // the hashing of the crate attributes should be double-checked\n+        // to ensure it is not incorporating implementation artifacts into\n+        // the hash that are not otherwise visible.)\n+\n+        let crate_disambiguator = self.sess.local_crate_disambiguator();\n+        let krate = self.map.krate();\n+\n+        // FIXME: this should use SHA1, not SipHash. SipHash is not built to\n+        //        avoid collisions.\n+        let mut state = SipHasher::new();\n+        debug!(\"state: {:?}\", state);\n+\n+        // FIXME(#32753) -- at (*) we `to_le` for endianness, but is\n+        // this enough, and does it matter anyway?\n+        \"crate_disambiguator\".hash(&mut state);\n+        crate_disambiguator.len().to_le().hash(&mut state); // (*)\n+        crate_disambiguator.hash(&mut state);\n+\n+        debug!(\"crate_disambiguator: {:?}\", crate_disambiguator);\n+        debug!(\"state: {:?}\", state);\n+\n+        {\n+            let mut visit = StrictVersionHashVisitor::new(&mut state, self);\n+            krate.visit_all_items(&mut visit);\n+        }\n+\n+        // FIXME (#14132): This hash is still sensitive to e.g. the\n+        // spans of the crate Attributes and their underlying\n+        // MetaItems; we should make ContentHashable impl for those\n+        // types and then use hash_content.  But, since all crate\n+        // attributes should appear near beginning of the file, it is\n+        // not such a big deal to be sensitive to their spans for now.\n+        //\n+        // We hash only the MetaItems instead of the entire Attribute\n+        // to avoid hashing the AttrId\n+        for attr in &krate.attrs {\n+            debug!(\"krate attr {:?}\", attr);\n+            attr.meta().hash(&mut state);\n+        }\n+\n+        Svh::new(state.finish())\n+    }\n+\n+    fn calculate_item_hash(self, def_id: DefId) -> u64 {\n+        assert!(def_id.is_local());\n+\n+        debug!(\"calculate_item_hash(def_id={:?})\", def_id);\n+\n+        let mut state = SipHasher::new();\n+\n+        {\n+            let mut visit = StrictVersionHashVisitor::new(&mut state, self);\n+            if def_id.index == CRATE_DEF_INDEX {\n+                // the crate root itself is not registered in the map\n+                // as an item, so we have to fetch it this way\n+                let krate = self.map.krate();\n+                intravisit::walk_crate(&mut visit, krate);\n+            } else {\n+                let node_id = self.map.as_local_node_id(def_id).unwrap();\n+                match self.map.find(node_id) {\n+                    Some(NodeItem(item)) => visit.visit_item(item),\n+                    Some(NodeForeignItem(item)) => visit.visit_foreign_item(item),\n+                    r => bug!(\"calculate_item_hash: expected an item for node {} not {:?}\",\n+                              node_id, r),\n+                }\n+            }\n+        }\n+\n+        let hash = state.finish();\n+\n+        debug!(\"calculate_item_hash: def_id={:?} hash={:?}\", def_id, hash);\n+\n+        hash\n+    }\n+}"}, {"sha": "d15734dce700531e45b5115f22105296062e588f", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "added", "additions": 346, "deletions": 0, "changes": 346, "blob_url": "https://github.com/rust-lang/rust/blob/953d711cc74457981bc01e0090ba67b9a5779e5b/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/953d711cc74457981bc01e0090ba67b9a5779e5b/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=953d711cc74457981bc01e0090ba67b9a5779e5b", "patch": "@@ -0,0 +1,346 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// FIXME (#14132): Even this SVH computation still has implementation\n+// artifacts: namely, the order of item declaration will affect the\n+// hash computation, but for many kinds of items the order of\n+// declaration should be irrelevant to the ABI.\n+\n+pub use self::SawExprComponent::*;\n+pub use self::SawStmtComponent::*;\n+use self::SawAbiComponent::*;\n+use syntax::ast::{self, Name, NodeId};\n+use syntax::parse::token;\n+use syntax_pos::Span;\n+use rustc::ty::TyCtxt;\n+use rustc::hir;\n+use rustc::hir::*;\n+use rustc::hir::map::DefPath;\n+use rustc::hir::intravisit as visit;\n+use rustc::hir::intravisit::{Visitor, FnKind};\n+\n+use std::hash::{Hash, SipHasher};\n+\n+pub struct StrictVersionHashVisitor<'a, 'tcx: 'a> {\n+    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub st: &'a mut SipHasher,\n+}\n+\n+impl<'a, 'tcx> StrictVersionHashVisitor<'a, 'tcx> {\n+    pub fn new(st: &'a mut SipHasher,\n+               tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+               -> Self {\n+        StrictVersionHashVisitor { st: st, tcx: tcx }\n+    }\n+\n+    fn hash_def_path(&mut self, path: &DefPath) {\n+        path.deterministic_hash_to(self.tcx, self.st);\n+    }\n+}\n+\n+// To off-load the bulk of the hash-computation on #[derive(Hash)],\n+// we define a set of enums corresponding to the content that our\n+// crate visitor will encounter as it traverses the ast.\n+//\n+// The important invariant is that all of the Saw*Component enums\n+// do not carry any Spans, Names, or Idents.\n+//\n+// Not carrying any Names/Idents is the important fix for problem\n+// noted on PR #13948: using the ident.name as the basis for a\n+// hash leads to unstable SVH, because ident.name is just an index\n+// into intern table (i.e. essentially a random address), not\n+// computed from the name content.\n+//\n+// With the below enums, the SVH computation is not sensitive to\n+// artifacts of how rustc was invoked nor of how the source code\n+// was laid out.  (Or at least it is *less* sensitive.)\n+\n+// This enum represents the different potential bits of code the\n+// visitor could encounter that could affect the ABI for the crate,\n+// and assigns each a distinct tag to feed into the hash computation.\n+#[derive(Hash)]\n+enum SawAbiComponent<'a> {\n+\n+    // FIXME (#14132): should we include (some function of)\n+    // ident.ctxt as well?\n+    SawIdent(token::InternedString),\n+    SawStructDef(token::InternedString),\n+\n+    SawLifetime(token::InternedString),\n+    SawLifetimeDef(token::InternedString),\n+\n+    SawMod,\n+    SawForeignItem,\n+    SawItem,\n+    SawTy,\n+    SawGenerics,\n+    SawFn,\n+    SawTraitItem,\n+    SawImplItem,\n+    SawStructField,\n+    SawVariant,\n+    SawPath,\n+    SawBlock,\n+    SawPat,\n+    SawLocal,\n+    SawArm,\n+    SawExpr(SawExprComponent<'a>),\n+    SawStmt(SawStmtComponent),\n+}\n+\n+/// SawExprComponent carries all of the information that we want\n+/// to include in the hash that *won't* be covered by the\n+/// subsequent recursive traversal of the expression's\n+/// substructure by the visitor.\n+///\n+/// We know every Expr_ variant is covered by a variant because\n+/// `fn saw_expr` maps each to some case below.  Ensuring that\n+/// each variant carries an appropriate payload has to be verified\n+/// by hand.\n+///\n+/// (However, getting that *exactly* right is not so important\n+/// because the SVH is just a developer convenience; there is no\n+/// guarantee of collision-freedom, hash collisions are just\n+/// (hopefully) unlikely.)\n+#[derive(Hash)]\n+pub enum SawExprComponent<'a> {\n+\n+    SawExprLoop(Option<token::InternedString>),\n+    SawExprField(token::InternedString),\n+    SawExprTupField(usize),\n+    SawExprBreak(Option<token::InternedString>),\n+    SawExprAgain(Option<token::InternedString>),\n+\n+    SawExprBox,\n+    SawExprVec,\n+    SawExprCall,\n+    SawExprMethodCall,\n+    SawExprTup,\n+    SawExprBinary(hir::BinOp_),\n+    SawExprUnary(hir::UnOp),\n+    SawExprLit(ast::LitKind),\n+    SawExprCast,\n+    SawExprType,\n+    SawExprIf,\n+    SawExprWhile,\n+    SawExprMatch,\n+    SawExprClosure,\n+    SawExprBlock,\n+    SawExprAssign,\n+    SawExprAssignOp(hir::BinOp_),\n+    SawExprIndex,\n+    SawExprPath(Option<usize>),\n+    SawExprAddrOf(hir::Mutability),\n+    SawExprRet,\n+    SawExprInlineAsm(&'a hir::InlineAsm),\n+    SawExprStruct,\n+    SawExprRepeat,\n+}\n+\n+fn saw_expr<'a>(node: &'a Expr_) -> SawExprComponent<'a> {\n+    match *node {\n+        ExprBox(..)              => SawExprBox,\n+        ExprVec(..)              => SawExprVec,\n+        ExprCall(..)             => SawExprCall,\n+        ExprMethodCall(..)       => SawExprMethodCall,\n+        ExprTup(..)              => SawExprTup,\n+        ExprBinary(op, _, _)     => SawExprBinary(op.node),\n+        ExprUnary(op, _)         => SawExprUnary(op),\n+        ExprLit(ref lit)         => SawExprLit(lit.node.clone()),\n+        ExprCast(..)             => SawExprCast,\n+        ExprType(..)             => SawExprType,\n+        ExprIf(..)               => SawExprIf,\n+        ExprWhile(..)            => SawExprWhile,\n+        ExprLoop(_, id)          => SawExprLoop(id.map(|id| id.node.as_str())),\n+        ExprMatch(..)            => SawExprMatch,\n+        ExprClosure(..)          => SawExprClosure,\n+        ExprBlock(..)            => SawExprBlock,\n+        ExprAssign(..)           => SawExprAssign,\n+        ExprAssignOp(op, _, _)   => SawExprAssignOp(op.node),\n+        ExprField(_, name)       => SawExprField(name.node.as_str()),\n+        ExprTupField(_, id)      => SawExprTupField(id.node),\n+        ExprIndex(..)            => SawExprIndex,\n+        ExprPath(ref qself, _)   => SawExprPath(qself.as_ref().map(|q| q.position)),\n+        ExprAddrOf(m, _)         => SawExprAddrOf(m),\n+        ExprBreak(id)            => SawExprBreak(id.map(|id| id.node.as_str())),\n+        ExprAgain(id)            => SawExprAgain(id.map(|id| id.node.as_str())),\n+        ExprRet(..)              => SawExprRet,\n+        ExprInlineAsm(ref a,_,_) => SawExprInlineAsm(a),\n+        ExprStruct(..)           => SawExprStruct,\n+        ExprRepeat(..)           => SawExprRepeat,\n+    }\n+}\n+\n+/// SawStmtComponent is analogous to SawExprComponent, but for statements.\n+#[derive(Hash)]\n+pub enum SawStmtComponent {\n+    SawStmtExpr,\n+    SawStmtSemi,\n+}\n+\n+impl<'a, 'tcx> Visitor<'a> for StrictVersionHashVisitor<'a, 'tcx> {\n+    fn visit_nested_item(&mut self, _: ItemId) {\n+        // Each item is hashed independently; ignore nested items.\n+    }\n+\n+    fn visit_variant_data(&mut self, s: &'a VariantData, name: Name,\n+                          g: &'a Generics, _: NodeId, _: Span) {\n+        debug!(\"visit_variant_data: st={:?}\", self.st);\n+        SawStructDef(name.as_str()).hash(self.st);\n+        visit::walk_generics(self, g);\n+        visit::walk_struct_def(self, s)\n+    }\n+\n+    fn visit_variant(&mut self, v: &'a Variant, g: &'a Generics, item_id: NodeId) {\n+        debug!(\"visit_variant: st={:?}\", self.st);\n+        SawVariant.hash(self.st);\n+        // walk_variant does not call walk_generics, so do it here.\n+        visit::walk_generics(self, g);\n+        visit::walk_variant(self, v, g, item_id)\n+    }\n+\n+    // All of the remaining methods just record (in the hash\n+    // SipHasher) that the visitor saw that particular variant\n+    // (with its payload), and continue walking as the default\n+    // visitor would.\n+    //\n+    // Some of the implementations have some notes as to how one\n+    // might try to make their SVH computation less discerning\n+    // (e.g. by incorporating reachability analysis).  But\n+    // currently all of their implementations are uniform and\n+    // uninteresting.\n+    //\n+    // (If you edit a method such that it deviates from the\n+    // pattern, please move that method up above this comment.)\n+\n+    fn visit_name(&mut self, _: Span, name: Name) {\n+        debug!(\"visit_name: st={:?}\", self.st);\n+        SawIdent(name.as_str()).hash(self.st);\n+    }\n+\n+    fn visit_lifetime(&mut self, l: &'a Lifetime) {\n+        debug!(\"visit_lifetime: st={:?}\", self.st);\n+        SawLifetime(l.name.as_str()).hash(self.st);\n+    }\n+\n+    fn visit_lifetime_def(&mut self, l: &'a LifetimeDef) {\n+        debug!(\"visit_lifetime_def: st={:?}\", self.st);\n+        SawLifetimeDef(l.lifetime.name.as_str()).hash(self.st);\n+    }\n+\n+    // We do recursively walk the bodies of functions/methods\n+    // (rather than omitting their bodies from the hash) since\n+    // monomorphization and cross-crate inlining generally implies\n+    // that a change to a crate body will require downstream\n+    // crates to be recompiled.\n+    fn visit_expr(&mut self, ex: &'a Expr) {\n+        debug!(\"visit_expr: st={:?}\", self.st);\n+        SawExpr(saw_expr(&ex.node)).hash(self.st); visit::walk_expr(self, ex)\n+    }\n+\n+    fn visit_stmt(&mut self, s: &'a Stmt) {\n+        debug!(\"visit_stmt: st={:?}\", self.st);\n+\n+        // We don't want to modify the hash for decls, because\n+        // they might be item decls (if they are local decls,\n+        // we'll hash that fact in visit_local); but we do want to\n+        // remember if this was a StmtExpr or StmtSemi (the later\n+        // had an explicit semi-colon; this affects the typing\n+        // rules).\n+        match s.node {\n+            StmtDecl(..) => (),\n+            StmtExpr(..) => SawStmt(SawStmtExpr).hash(self.st),\n+            StmtSemi(..) => SawStmt(SawStmtSemi).hash(self.st),\n+        }\n+\n+        visit::walk_stmt(self, s)\n+    }\n+\n+    fn visit_foreign_item(&mut self, i: &'a ForeignItem) {\n+        debug!(\"visit_foreign_item: st={:?}\", self.st);\n+\n+        // FIXME (#14132) ideally we would incorporate privacy (or\n+        // perhaps reachability) somewhere here, so foreign items\n+        // that do not leak into downstream crates would not be\n+        // part of the ABI.\n+        SawForeignItem.hash(self.st); visit::walk_foreign_item(self, i)\n+    }\n+\n+    fn visit_item(&mut self, i: &'a Item) {\n+        debug!(\"visit_item: {:?} st={:?}\", i, self.st);\n+\n+        // FIXME (#14132) ideally would incorporate reachability\n+        // analysis somewhere here, so items that never leak into\n+        // downstream crates (e.g. via monomorphisation or\n+        // inlining) would not be part of the ABI.\n+        SawItem.hash(self.st); visit::walk_item(self, i)\n+    }\n+\n+    fn visit_mod(&mut self, m: &'a Mod, _s: Span, n: NodeId) {\n+        debug!(\"visit_mod: st={:?}\", self.st);\n+        SawMod.hash(self.st); visit::walk_mod(self, m, n)\n+    }\n+\n+    fn visit_ty(&mut self, t: &'a Ty) {\n+        debug!(\"visit_ty: st={:?}\", self.st);\n+        SawTy.hash(self.st); visit::walk_ty(self, t)\n+    }\n+\n+    fn visit_generics(&mut self, g: &'a Generics) {\n+        debug!(\"visit_generics: st={:?}\", self.st);\n+        SawGenerics.hash(self.st); visit::walk_generics(self, g)\n+    }\n+\n+    fn visit_fn(&mut self, fk: FnKind<'a>, fd: &'a FnDecl,\n+                b: &'a Block, s: Span, n: NodeId) {\n+        debug!(\"visit_fn: st={:?}\", self.st);\n+        SawFn.hash(self.st); visit::walk_fn(self, fk, fd, b, s, n)\n+    }\n+\n+    fn visit_trait_item(&mut self, ti: &'a TraitItem) {\n+        debug!(\"visit_trait_item: st={:?}\", self.st);\n+        SawTraitItem.hash(self.st); visit::walk_trait_item(self, ti)\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &'a ImplItem) {\n+        debug!(\"visit_impl_item: st={:?}\", self.st);\n+        SawImplItem.hash(self.st); visit::walk_impl_item(self, ii)\n+    }\n+\n+    fn visit_struct_field(&mut self, s: &'a StructField) {\n+        debug!(\"visit_struct_field: st={:?}\", self.st);\n+        SawStructField.hash(self.st); visit::walk_struct_field(self, s)\n+    }\n+\n+    fn visit_path(&mut self, path: &'a Path, _: ast::NodeId) {\n+        debug!(\"visit_path: st={:?}\", self.st);\n+        SawPath.hash(self.st); visit::walk_path(self, path)\n+    }\n+\n+    fn visit_block(&mut self, b: &'a Block) {\n+        debug!(\"visit_block: st={:?}\", self.st);\n+        SawBlock.hash(self.st); visit::walk_block(self, b)\n+    }\n+\n+    fn visit_pat(&mut self, p: &'a Pat) {\n+        debug!(\"visit_pat: st={:?}\", self.st);\n+        SawPat.hash(self.st); visit::walk_pat(self, p)\n+    }\n+\n+    fn visit_local(&mut self, l: &'a Local) {\n+        debug!(\"visit_local: st={:?}\", self.st);\n+        SawLocal.hash(self.st); visit::walk_local(self, l)\n+    }\n+\n+    fn visit_arm(&mut self, a: &'a Arm) {\n+        debug!(\"visit_arm: st={:?}\", self.st);\n+        SawArm.hash(self.st); visit::walk_arm(self, a)\n+    }\n+}"}]}