{"sha": "d6d280b7df3bc3b333950bc5d0a766d17d433bf9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2ZDI4MGI3ZGYzYmMzYjMzMzk1MGJjNWQwYTc2NmQxN2Q0MzNiZjk=", "commit": {"author": {"name": "Tobias Bucher", "email": "tobiasbucher5991@gmail.com", "date": "2018-08-29T20:30:29Z"}, "committer": {"name": "Tobias Bucher", "email": "tobiasbucher5991@gmail.com", "date": "2018-08-29T20:30:29Z"}, "message": "Don't leak the file descriptor in `rand`", "tree": {"sha": "ebd18208313187515ed961956e62f1efd5a47e1c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ebd18208313187515ed961956e62f1efd5a47e1c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6d280b7df3bc3b333950bc5d0a766d17d433bf9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6d280b7df3bc3b333950bc5d0a766d17d433bf9", "html_url": "https://github.com/rust-lang/rust/commit/d6d280b7df3bc3b333950bc5d0a766d17d433bf9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6d280b7df3bc3b333950bc5d0a766d17d433bf9/comments", "author": {"login": "tbu-", "id": 6666593, "node_id": "MDQ6VXNlcjY2NjY1OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/6666593?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tbu-", "html_url": "https://github.com/tbu-", "followers_url": "https://api.github.com/users/tbu-/followers", "following_url": "https://api.github.com/users/tbu-/following{/other_user}", "gists_url": "https://api.github.com/users/tbu-/gists{/gist_id}", "starred_url": "https://api.github.com/users/tbu-/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tbu-/subscriptions", "organizations_url": "https://api.github.com/users/tbu-/orgs", "repos_url": "https://api.github.com/users/tbu-/repos", "events_url": "https://api.github.com/users/tbu-/events{/privacy}", "received_events_url": "https://api.github.com/users/tbu-/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tbu-", "id": 6666593, "node_id": "MDQ6VXNlcjY2NjY1OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/6666593?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tbu-", "html_url": "https://github.com/tbu-", "followers_url": "https://api.github.com/users/tbu-/followers", "following_url": "https://api.github.com/users/tbu-/following{/other_user}", "gists_url": "https://api.github.com/users/tbu-/gists{/gist_id}", "starred_url": "https://api.github.com/users/tbu-/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tbu-/subscriptions", "organizations_url": "https://api.github.com/users/tbu-/orgs", "repos_url": "https://api.github.com/users/tbu-/repos", "events_url": "https://api.github.com/users/tbu-/events{/privacy}", "received_events_url": "https://api.github.com/users/tbu-/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09a615c09761d5066b19d4b58a6a1d0e515ede45", "url": "https://api.github.com/repos/rust-lang/rust/commits/09a615c09761d5066b19d4b58a6a1d0e515ede45", "html_url": "https://github.com/rust-lang/rust/commit/09a615c09761d5066b19d4b58a6a1d0e515ede45"}], "stats": {"total": 55, "additions": 11, "deletions": 44}, "files": [{"sha": "210ace9bbb2268bca701729c3af783a43bb558f5", "filename": "src/libstd/sys/unix/rand.rs", "status": "modified", "additions": 11, "deletions": 44, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/d6d280b7df3bc3b333950bc5d0a766d17d433bf9/src%2Flibstd%2Fsys%2Funix%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d280b7df3bc3b333950bc5d0a766d17d433bf9/src%2Flibstd%2Fsys%2Funix%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Frand.rs?ref=d6d280b7df3bc3b333950bc5d0a766d17d433bf9", "patch": "@@ -29,23 +29,8 @@ pub fn hashmap_random_keys() -> (u64, u64) {\n mod imp {\n     use fs::File;\n     use io::Read;\n-    use libc;\n-    use sync::atomic::{AtomicBool, AtomicI32, Ordering};\n-    use sys::os::errno;\n-\n-    static GETRANDOM_URANDOM_FD: AtomicI32 = AtomicI32::new(-1);\n-    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-    static GETRANDOM_UNAVAILABLE: AtomicBool = AtomicBool::new(false);\n-\n     #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-    fn is_getrandom_permanently_unavailable() -> bool {\n-        GETRANDOM_UNAVAILABLE.load(Ordering::Relaxed)\n-    }\n-\n-    #[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n-    fn is_getrandom_permanently_unavailable() -> bool {\n-        true\n-    }\n+    use libc;\n \n     #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n     fn getrandom(buf: &mut [u8]) -> libc::c_long {\n@@ -59,7 +44,11 @@ mod imp {\n \n     #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n     fn getrandom_fill_bytes(v: &mut [u8]) -> bool {\n-        if is_getrandom_permanently_unavailable() {\n+        use sync::atomic::{AtomicBool, Ordering};\n+        use sys::os::errno;\n+\n+        static GETRANDOM_UNAVAILABLE: AtomicBool = AtomicBool::new(false);\n+        if GETRANDOM_UNAVAILABLE.load(Ordering::Relaxed) {\n             return false;\n         }\n \n@@ -96,33 +85,11 @@ mod imp {\n             return;\n         }\n \n-        // getrandom failed for some reason. If the getrandom call is\n-        // permanently unavailable (OS without getrandom, or OS version without\n-        // getrandom), we'll keep around the fd for /dev/urandom for future\n-        // requests, to avoid re-opening the file on every call.\n-        //\n-        // Otherwise, open /dev/urandom, read from it, and close it again.\n-        use super::super::ext::io::{FromRawFd, IntoRawFd};\n-        let mut fd = GETRANDOM_URANDOM_FD.load(Ordering::Relaxed);\n-        let mut close_fd = false;\n-        if fd == -1 {\n-            if !is_getrandom_permanently_unavailable() {\n-                close_fd = true;\n-            }\n-            let file = File::open(\"/dev/urandom\").expect(\"failed to open /dev/urandom\");\n-            fd = file.into_raw_fd();\n-            // If some other thread also opened /dev/urandom and set the global\n-            // fd already, we close our fd at the end of the function.\n-            if !close_fd && GETRANDOM_URANDOM_FD.compare_and_swap(-1, fd, Ordering::Relaxed) != -1 {\n-                close_fd = true;\n-            }\n-        }\n-        let mut file = unsafe { File::from_raw_fd(fd) };\n-        let res = file.read_exact(v);\n-        if !close_fd {\n-            let _ = file.into_raw_fd();\n-        }\n-        res.expect(\"failed to read /dev/urandom\");\n+        // getrandom failed because it is permanently or temporarily (because\n+        // of missing entropy) unavailable. Open /dev/urandom, read from it,\n+        // and close it again.\n+        let mut file = File::open(\"/dev/urandom\").expect(\"failed to open /dev/urandom\");\n+        file.read_exact(v).expect(\"failed to read /dev/urandom\")\n     }\n }\n "}]}