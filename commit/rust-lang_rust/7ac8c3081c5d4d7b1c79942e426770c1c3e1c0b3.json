{"sha": "7ac8c3081c5d4d7b1c79942e426770c1c3e1c0b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhYzhjMzA4MWM1ZDRkN2IxYzc5OTQyZTQyNjc3MGMxYzNlMWMwYjM=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-04-20T12:00:14Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-20T22:23:23Z"}, "message": "std: add std::timer and timer::delayed_send and timer::sleep\n\n.. leveraging std::uv, we have:\ntimer::delayed_send - send a value over a provided channel after the\ntimeout has passed\ntimer::sleep - block the current task for the specified period\n\nboth of these fns (and everything that goes in timer.rs) leverage the\nuv_timer_* API", "tree": {"sha": "a9be790d707033f9dfcfdf403e64b076361fdf9e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9be790d707033f9dfcfdf403e64b076361fdf9e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ac8c3081c5d4d7b1c79942e426770c1c3e1c0b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ac8c3081c5d4d7b1c79942e426770c1c3e1c0b3", "html_url": "https://github.com/rust-lang/rust/commit/7ac8c3081c5d4d7b1c79942e426770c1c3e1c0b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ac8c3081c5d4d7b1c79942e426770c1c3e1c0b3/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1c43cc7c92f98acd9b45e36b7dfc3407ca5f3fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1c43cc7c92f98acd9b45e36b7dfc3407ca5f3fe", "html_url": "https://github.com/rust-lang/rust/commit/a1c43cc7c92f98acd9b45e36b7dfc3407ca5f3fe"}], "stats": {"total": 116, "additions": 115, "deletions": 1}, "files": [{"sha": "d1b578f3d87036619ac6cc6115bf799e7b7ba8ec", "filename": "src/libstd/std.rc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7ac8c3081c5d4d7b1c79942e426770c1c3e1c0b3/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/7ac8c3081c5d4d7b1c79942e426770c1c3e1c0b3/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=7ac8c3081c5d4d7b1c79942e426770c1c3e1c0b3", "patch": "@@ -14,7 +14,7 @@ use core(vers = \"0.2\");\n import core::*;\n \n export net, uv;\n-export c_vec, util;\n+export c_vec, util, timer;\n export bitv, deque, fun_treemap, list, map, smallintmap, sort, treemap, ufind;\n export rope, arena;\n export ebml, dbg, getopts, json, rand, sha1, term, time, prettyprint;\n@@ -35,6 +35,7 @@ mod uv_global_loop;\n \n mod c_vec;\n mod util;\n+mod timer;\n \n \n // Collections"}, {"sha": "c8243ae8cf1b68ebd3e68fdf34e169956c9d8362", "filename": "src/libstd/timer.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/7ac8c3081c5d4d7b1c79942e426770c1c3e1c0b3/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac8c3081c5d4d7b1c79942e426770c1c3e1c0b3/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=7ac8c3081c5d4d7b1c79942e426770c1c3e1c0b3", "patch": "@@ -0,0 +1,113 @@\n+#[doc =\"\n+Utilities that leverage libuv's `uv_timer_*` API\n+\"];\n+\n+import uv = uv;\n+export delayed_send, sleep;\n+\n+#[doc = \"\n+Wait for timeout period then send provided value over a channel\n+\n+This call returns immediately. Useful as the building block for a number\n+of higher-level timer functions.\n+\n+Is not guaranteed to wait for exactly the specified time, but will wait\n+for *at least* that period of time.\n+\n+# Arguments\n+\n+msecs - a timeout period, in milliseconds, to wait\n+ch - a channel of type T to send a `val` on\n+val - a value of type T to send over the provided `ch`\n+\"]\n+fn delayed_send<T: send>(msecs: uint, ch: comm::chan<T>, val: T) {\n+    task::spawn() {||\n+        unsafe {\n+            let timer_done_po = comm::port::<()>();\n+            let timer_done_ch = comm::chan(timer_done_po);\n+            let timer_done_ch_ptr = ptr::addr_of(timer_done_ch);\n+            let timer = uv::ll::timer_t();\n+            let timer_ptr = ptr::addr_of(timer);\n+            let hl_loop = uv::global_loop::get();\n+            uv::hl::interact(hl_loop) {|loop_ptr|\n+                uv::hl::ref(hl_loop, timer_ptr);\n+                let init_result = uv::ll::timer_init(loop_ptr, timer_ptr);\n+                if (init_result == 0i32) {\n+                    let start_result = uv::ll::timer_start(\n+                        timer_ptr, delayed_send_cb, msecs, 0u);\n+                    if (start_result == 0i32) {\n+                        uv::ll::set_data_for_uv_handle(\n+                            timer_ptr,\n+                            timer_done_ch_ptr as *libc::c_void);\n+                    }\n+                    else {\n+                        let error_msg = uv::ll::get_last_err_info(loop_ptr);\n+                        fail \"timer::delayed_send() start failed: \"+error_msg;\n+                    }\n+                }\n+                else {\n+                    let error_msg = uv::ll::get_last_err_info(loop_ptr);\n+                    fail \"timer::delayed_send() init failed: \"+error_msg;\n+                }\n+            };\n+            // delayed_send_cb has been processed by libuv\n+            comm::recv(timer_done_po);\n+            // notify the caller immediately\n+            comm::send(ch, copy(val));\n+            // then clean up our handle\n+            uv::hl::unref_and_close(hl_loop, timer_ptr,\n+                                    delayed_send_close_cb);\n+            // uv_close for this timer has been processed\n+            comm::recv(timer_done_po);\n+        }\n+    };\n+}\n+\n+#[doc = \"\n+Blocks the current task for (at least) the specified time period.\n+\n+Is not guaranteed to sleep for exactly the specified time, but will sleep\n+for *at least* that period of time.\n+\n+# Arguments\n+\n+* msecs - an amount of time, in milliseconds, for the current task to block\n+\"]\n+fn sleep(msecs: uint) {\n+    let exit_po = comm::port::<()>();\n+    let exit_ch = comm::chan(exit_po);\n+    delayed_send(msecs, exit_ch, ());\n+    comm::recv(exit_po);\n+}\n+\n+// INTERNAL API\n+crust fn delayed_send_cb(handle: *uv::ll::uv_timer_t,\n+                                status: libc::c_int) unsafe {\n+    log(debug, #fmt(\"delayed_send_cb handle %? status %?\", handle, status));\n+    let timer_done_ch =\n+        *(uv::ll::get_data_for_uv_handle(handle) as *comm::chan<()>);\n+    let stop_result = uv::ll::timer_stop(handle);\n+    if (stop_result == 0i32) {\n+        comm::send(timer_done_ch, ());\n+    }\n+    else {\n+        let loop_ptr = uv::ll::get_loop_for_uv_handle(handle);\n+        let error_msg = uv::ll::get_last_err_info(loop_ptr);\n+        fail \"timer::sleep() init failed: \"+error_msg;\n+    }\n+}\n+\n+crust fn delayed_send_close_cb(handle: *uv::ll::uv_timer_t) unsafe {\n+    log(debug, #fmt(\"delayed_send_close_cb handle %?\", handle));\n+    let timer_done_ch =\n+        *(uv::ll::get_data_for_uv_handle(handle) as *comm::chan<()>);\n+    comm::send(timer_done_ch, ());\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    #[test]\n+    fn test_timer_simple_sleep_test() {\n+        sleep(2000u);\n+    }\n+}"}]}