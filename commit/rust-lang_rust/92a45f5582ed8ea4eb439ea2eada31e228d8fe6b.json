{"sha": "92a45f5582ed8ea4eb439ea2eada31e228d8fe6b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyYTQ1ZjU1ODJlZDhlYTRlYjQzOWVhMmVhZGEzMWUyMjhkOGZlNmI=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-21T14:22:55Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-21T16:08:14Z"}, "message": "Move trans::type_of code into its own file\n\nSlowly shrinking base.rs", "tree": {"sha": "e5f36ba47d8e3ba7272f2eaf505154a71b529343", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5f36ba47d8e3ba7272f2eaf505154a71b529343"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92a45f5582ed8ea4eb439ea2eada31e228d8fe6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92a45f5582ed8ea4eb439ea2eada31e228d8fe6b", "html_url": "https://github.com/rust-lang/rust/commit/92a45f5582ed8ea4eb439ea2eada31e228d8fe6b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92a45f5582ed8ea4eb439ea2eada31e228d8fe6b/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d85d4f55f7f7cf35dfbf39979a72062f4181f9ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/d85d4f55f7f7cf35dfbf39979a72062f4181f9ed", "html_url": "https://github.com/rust-lang/rust/commit/d85d4f55f7f7cf35dfbf39979a72062f4181f9ed"}], "stats": {"total": 443, "additions": 223, "deletions": 220}, "files": [{"sha": "2057296d197f46afe86859a0f8af0f45e9e48f8c", "filename": "src/comp/middle/trans/alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92a45f5582ed8ea4eb439ea2eada31e228d8fe6b/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92a45f5582ed8ea4eb439ea2eada31e228d8fe6b/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs?ref=92a45f5582ed8ea4eb439ea2eada31e228d8fe6b", "patch": "@@ -686,7 +686,7 @@ fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n       ast::pat_ident(_,inner) {\n         if make_copy || ccx.copy_map.contains_key(pat.id) {\n             let ty = node_id_type(bcx, pat.id);\n-            let llty = type_of(ccx, ty);\n+            let llty = type_of::type_of(ccx, ty);\n             let alloc = alloca(bcx, llty);\n             bcx = copy_val(bcx, INIT, alloc,\n                                   load_if_immediate(bcx, val, ty), ty);"}, {"sha": "eb25415357ae5f50f556122e09760f7fabacd814", "filename": "src/comp/middle/trans/base.rs", "status": "modified", "additions": 54, "deletions": 198, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/92a45f5582ed8ea4eb439ea2eada31e228d8fe6b/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92a45f5582ed8ea4eb439ea2eada31e228d8fe6b/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs?ref=92a45f5582ed8ea4eb439ea2eada31e228d8fe6b", "patch": "@@ -44,157 +44,80 @@ import util::ppaux::{ty_to_str, ty_to_short_str};\n import common::*;\n import build::*;\n import shape::*;\n+import type_of::*;\n+import type_of::type_of; // Issue #1873\n import ast_map::{path, path_mod, path_name};\n \n-fn type_of_explicit_args(cx: crate_ctxt, inputs: [ty::arg]) -> [TypeRef] {\n-    vec::map(inputs) {|arg|\n-        let arg_ty = arg.ty;\n-        let llty = type_of(cx, arg_ty);\n-        alt ty::resolved_mode(cx.tcx, arg.mode) {\n-          ast::by_val { llty }\n-          _ { T_ptr(llty) }\n-        }\n-    }\n-}\n+// Destinations\n \n+// These are passed around by the code generating functions to track the\n+// destination of a computation's value.\n \n-// NB: must keep 4 fns in sync:\n-//\n-//  - type_of_fn\n-//  - create_llargs_for_fn_args.\n-//  - new_fn_ctxt\n-//  - trans_args\n-fn type_of_fn(cx: crate_ctxt, inputs: [ty::arg],\n-              output: ty::t, params: [ty::param_bounds]) -> TypeRef {\n-    let atys: [TypeRef] = [];\n+enum dest {\n+    by_val(@mutable ValueRef),\n+    save_in(ValueRef),\n+    ignore,\n+}\n \n-    // Arg 0: Output pointer.\n-    atys += [T_ptr(type_of(cx, output))];\n+fn empty_dest_cell() -> @mutable ValueRef {\n+    ret @mutable llvm::LLVMGetUndef(T_nil());\n+}\n \n-    // Arg 1: Environment\n-    atys += [T_opaque_box_ptr(cx)];\n+fn dup_for_join(dest: dest) -> dest {\n+    alt dest {\n+      by_val(_) { by_val(empty_dest_cell()) }\n+      _ { dest }\n+    }\n+}\n \n-    // Args >2: ty params, if not acquired via capture...\n-    for bounds in params {\n-        atys += [T_ptr(cx.tydesc_type)];\n-        for bound in *bounds {\n-            alt bound {\n-              ty::bound_iface(_) { atys += [T_ptr(T_dict())]; }\n+fn join_returns(parent_cx: block, in_cxs: [block],\n+                in_ds: [dest], out_dest: dest) -> block {\n+    let out = sub_block(parent_cx, \"join\");\n+    let reachable = false, i = 0u, phi = none;\n+    for cx in in_cxs {\n+        if !cx.unreachable {\n+            Br(cx, out.llbb);\n+            reachable = true;\n+            alt in_ds[i] {\n+              by_val(cell) {\n+                if option::is_none(phi) {\n+                    phi = some(EmptyPhi(out, val_ty(*cell)));\n+                }\n+                AddIncomingToPhi(option::get(phi), *cell, cx.llbb);\n+              }\n               _ {}\n             }\n         }\n+        i += 1u;\n     }\n-    // ... then explicit args.\n-    atys += type_of_explicit_args(cx, inputs);\n-    ret T_fn(atys, llvm::LLVMVoidType());\n-}\n-\n-// Given a function type and a count of ty params, construct an llvm type\n-fn type_of_fn_from_ty(cx: crate_ctxt, fty: ty::t,\n-                      param_bounds: [ty::param_bounds]) -> TypeRef {\n-    type_of_fn(cx, ty::ty_fn_args(fty), ty::ty_fn_ret(fty), param_bounds)\n-}\n-\n-fn type_of(cx: crate_ctxt, t: ty::t) -> TypeRef {\n-    assert !ty::type_has_vars(t);\n-    // Check the cache.\n-\n-    if cx.lltypes.contains_key(t) { ret cx.lltypes.get(t); }\n-    let llty = alt ty::get(t).struct {\n-      ty::ty_nil | ty::ty_bot { T_nil() }\n-      ty::ty_bool { T_bool() }\n-      ty::ty_int(t) { T_int_ty(cx, t) }\n-      ty::ty_uint(t) { T_uint_ty(cx, t) }\n-      ty::ty_float(t) { T_float_ty(cx, t) }\n-      ty::ty_str { T_ptr(T_vec(cx, T_i8())) }\n-      ty::ty_enum(did, _) { type_of_enum(cx, did, t) }\n-      ty::ty_box(mt) {\n-        let mt_ty = mt.ty;\n-        T_ptr(T_box(cx, type_of(cx, mt_ty))) }\n-      ty::ty_opaque_box { T_ptr(T_box(cx, T_i8())) }\n-      ty::ty_uniq(mt) {\n-        let mt_ty = mt.ty;\n-        T_ptr(type_of(cx, mt_ty)) }\n-      ty::ty_vec(mt) {\n-        let mt_ty = mt.ty;\n-        if ty::type_has_dynamic_size(cx.tcx, mt_ty) {\n-            T_ptr(cx.opaque_vec_type)\n-        } else {\n-            T_ptr(T_vec(cx, type_of(cx, mt_ty))) }\n-      }\n-      ty::ty_ptr(mt) {\n-        let mt_ty = mt.ty;\n-        T_ptr(type_of(cx, mt_ty)) }\n-      ty::ty_rec(fields) {\n-        let tys: [TypeRef] = [];\n-        for f: ty::field in fields {\n-            let mt_ty = f.mt.ty;\n-            tys += [type_of(cx, mt_ty)];\n-        }\n-        T_struct(tys)\n-      }\n-      ty::ty_fn(_) {\n-        T_fn_pair(cx, type_of_fn_from_ty(cx, t, []))\n-      }\n-      ty::ty_iface(_, _) { T_opaque_iface(cx) }\n-      ty::ty_res(_, sub, tps) {\n-        let sub1 = ty::substitute_type_params(cx.tcx, tps, sub);\n-        ret T_struct([T_i8(), type_of(cx, sub1)]);\n-      }\n-      ty::ty_param(_, _) { T_typaram(cx.tn) }\n-      ty::ty_send_type | ty::ty_type { T_ptr(cx.tydesc_type) }\n-      ty::ty_tup(elts) {\n-        let tys = [];\n-        for elt in elts {\n-            tys += [type_of(cx, elt)];\n+    if !reachable {\n+        Unreachable(out);\n+    } else {\n+        alt out_dest {\n+          by_val(cell) { *cell = option::get(phi); }\n+          _ {}\n         }\n-        T_struct(tys)\n-      }\n-      ty::ty_opaque_closure_ptr(_) { T_opaque_box_ptr(cx) }\n-      ty::ty_constr(subt,_) { type_of(cx, subt) }\n-\n-      _ { fail \"type_of not implemented for this kind of type\"; }\n-    };\n-    cx.lltypes.insert(t, llty);\n-    ret llty;\n-}\n-\n-fn type_of_enum(cx: crate_ctxt, did: ast::def_id, t: ty::t)\n-    -> TypeRef {\n-    let degen = (*ty::enum_variants(cx.tcx, did)).len() == 1u;\n-    if check type_has_static_size(cx, t) {\n-        let size = static_size_of_enum(cx, t);\n-        if !degen { T_enum(cx, size) }\n-        else if size == 0u { T_struct([T_enum_variant(cx)]) }\n-        else { T_array(T_i8(), size) }\n-    }\n-    else {\n-        if degen { T_struct([T_enum_variant(cx)]) }\n-        else { T_opaque_enum(cx) }\n     }\n+    ret out;\n }\n \n-fn type_of_ty_param_bounds_and_ty\n-    (ccx: crate_ctxt, tpt: ty::ty_param_bounds_and_ty) -> TypeRef {\n-    let t = tpt.ty;\n-    alt ty::get(t).struct {\n-      ty::ty_fn(_) {\n-        ret type_of_fn_from_ty(ccx, t, *tpt.bounds);\n-      }\n-      _ {\n-        // fall through\n-      }\n+// Used to put an immediate value in a dest.\n+fn store_in_dest(bcx: block, val: ValueRef, dest: dest) -> block {\n+    alt dest {\n+      ignore {}\n+      by_val(cell) { *cell = val; }\n+      save_in(addr) { Store(bcx, val, addr); }\n     }\n-    type_of(ccx, t)\n+    ret bcx;\n }\n \n-fn type_of_or_i8(ccx: crate_ctxt, typ: ty::t) -> TypeRef {\n-    if check type_has_static_size(ccx, typ) {\n-        type_of(ccx, typ)\n-    } else { T_i8() }\n+fn get_dest_addr(dest: dest) -> ValueRef {\n+    alt dest {\n+       save_in(a) { a }\n+       _ { fail \"get_dest_addr: not a save_in\"; }\n+    }\n }\n \n-\n // Name sanitation. LLVM will happily accept identifiers with weird names, but\n // gas doesn't!\n fn sanitize(s: str) -> str {\n@@ -1886,8 +1809,6 @@ fn trans_lazy_binop(bcx: block, op: lazy_binop_ty, a: @ast::expr,\n     ret store_in_dest(join, phi, dest);\n }\n \n-\n-\n fn trans_binary(bcx: block, op: ast::binop, lhs: @ast::expr,\n                 rhs: @ast::expr, dest: dest, ex: @ast::expr) -> block {\n     // User-defined operators\n@@ -1921,71 +1842,6 @@ fn trans_binary(bcx: block, op: ast::binop, lhs: @ast::expr,\n     }\n }\n \n-enum dest {\n-    by_val(@mutable ValueRef),\n-    save_in(ValueRef),\n-    ignore,\n-}\n-\n-fn empty_dest_cell() -> @mutable ValueRef {\n-    ret @mutable llvm::LLVMGetUndef(T_nil());\n-}\n-\n-fn dup_for_join(dest: dest) -> dest {\n-    alt dest {\n-      by_val(_) { by_val(empty_dest_cell()) }\n-      _ { dest }\n-    }\n-}\n-\n-fn join_returns(parent_cx: block, in_cxs: [block],\n-                in_ds: [dest], out_dest: dest) -> block {\n-    let out = sub_block(parent_cx, \"join\");\n-    let reachable = false, i = 0u, phi = none;\n-    for cx in in_cxs {\n-        if !cx.unreachable {\n-            Br(cx, out.llbb);\n-            reachable = true;\n-            alt in_ds[i] {\n-              by_val(cell) {\n-                if option::is_none(phi) {\n-                    phi = some(EmptyPhi(out, val_ty(*cell)));\n-                }\n-                AddIncomingToPhi(option::get(phi), *cell, cx.llbb);\n-              }\n-              _ {}\n-            }\n-        }\n-        i += 1u;\n-    }\n-    if !reachable {\n-        Unreachable(out);\n-    } else {\n-        alt out_dest {\n-          by_val(cell) { *cell = option::get(phi); }\n-          _ {}\n-        }\n-    }\n-    ret out;\n-}\n-\n-// Used to put an immediate value in a dest.\n-fn store_in_dest(bcx: block, val: ValueRef, dest: dest) -> block {\n-    alt dest {\n-      ignore {}\n-      by_val(cell) { *cell = val; }\n-      save_in(addr) { Store(bcx, val, addr); }\n-    }\n-    ret bcx;\n-}\n-\n-fn get_dest_addr(dest: dest) -> ValueRef {\n-    alt dest {\n-       save_in(a) { a }\n-       _ { fail \"get_dest_addr: not a save_in\"; }\n-    }\n-}\n-\n fn trans_if(cx: block, cond: @ast::expr, thn: ast::blk,\n             els: option<@ast::expr>, dest: dest)\n     -> block {"}, {"sha": "cde07aeedc468a9fcb48a45e78b0ddb5ecb99cfc", "filename": "src/comp/middle/trans/closure.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92a45f5582ed8ea4eb439ea2eada31e228d8fe6b/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92a45f5582ed8ea4eb439ea2eada31e228d8fe6b/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs?ref=92a45f5582ed8ea4eb439ea2eada31e228d8fe6b", "patch": "@@ -6,6 +6,8 @@ import lib::llvm::{ValueRef, TypeRef};\n import common::*;\n import build::*;\n import base::*;\n+import type_of::*;\n+import type_of::type_of; // Issue #1873\n import middle::freevars::{get_freevars, freevar_info};\n import back::abi;\n import syntax::codemap::span;"}, {"sha": "a5d8390674921a64768c82dff417299a10be18ba", "filename": "src/comp/middle/trans/common.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/92a45f5582ed8ea4eb439ea2eada31e228d8fe6b/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92a45f5582ed8ea4eb439ea2eada31e228d8fe6b/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs?ref=92a45f5582ed8ea4eb439ea2eada31e228d8fe6b", "patch": "@@ -20,9 +20,6 @@ import lib::llvm::{True, False, Bool};\n import metadata::csearch;\n import ast_map::path;\n \n-// FIXME: These should probably be pulled in here too.\n-import base::{type_of_fn, drop_ty};\n-\n type namegen = fn@(str) -> str;\n fn new_namegen() -> namegen {\n     let i = @mutable 0;\n@@ -231,7 +228,7 @@ fn scope_clean_changed(info: scope_info) {\n fn add_clean(cx: block, val: ValueRef, ty: ty::t) {\n     if !ty::type_needs_drop(cx.tcx(), ty) { ret; }\n     in_scope_cx(cx) {|info|\n-        info.cleanups += [clean(bind drop_ty(_, val, ty))];\n+        info.cleanups += [clean(bind base::drop_ty(_, val, ty))];\n         scope_clean_changed(info);\n     }\n }\n@@ -242,7 +239,7 @@ fn add_clean_temp(cx: block, val: ValueRef, ty: ty::t) {\n         if ty::type_is_immediate(ty) {\n             ret base::drop_ty_immediate(bcx, val, ty);\n         } else {\n-            ret drop_ty(bcx, val, ty);\n+            ret base::drop_ty(bcx, val, ty);\n         }\n     }\n     in_scope_cx(cx) {|info|\n@@ -253,7 +250,7 @@ fn add_clean_temp(cx: block, val: ValueRef, ty: ty::t) {\n fn add_clean_temp_mem(cx: block, val: ValueRef, ty: ty::t) {\n     if !ty::type_needs_drop(cx.tcx(), ty) { ret; }\n     in_scope_cx(cx) {|info|\n-        info.cleanups += [clean_temp(val, bind drop_ty(_, val, ty))];\n+        info.cleanups += [clean_temp(val, bind base::drop_ty(_, val, ty))];\n         scope_clean_changed(info);\n     }\n }\n@@ -301,8 +298,8 @@ fn get_res_dtor(ccx: crate_ctxt, did: ast::def_id, inner_t: ty::t)\n     let param_bounds = ty::lookup_item_type(ccx.tcx, did).bounds;\n     let nil_res = ty::mk_nil(ccx.tcx);\n     let fn_mode = ast::expl(ast::by_ref);\n-    let f_t = type_of_fn(ccx, [{mode: fn_mode, ty: inner_t}],\n-                         nil_res, *param_bounds);\n+    let f_t = type_of::type_of_fn(ccx, [{mode: fn_mode, ty: inner_t}],\n+                                  nil_res, *param_bounds);\n     ret base::get_extern_const(ccx.externs, ccx.llmod,\n                                 csearch::get_symbol(ccx.sess.cstore,\n                                                     did), f_t);"}, {"sha": "45c9499f197aa589b581f5f50f58d70258215b06", "filename": "src/comp/middle/trans/impl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/92a45f5582ed8ea4eb439ea2eada31e228d8fe6b/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92a45f5582ed8ea4eb439ea2eada31e228d8fe6b/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs?ref=92a45f5582ed8ea4eb439ea2eada31e228d8fe6b", "patch": "@@ -1,6 +1,7 @@\n import ctypes::c_uint;\n import base::*;\n import common::*;\n+import type_of::*;\n import build::*;\n import driver::session::session;\n import syntax::{ast, ast_util};"}, {"sha": "22791047ef91c32297ff871d0f50985f23768925", "filename": "src/comp/middle/trans/native.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/92a45f5582ed8ea4eb439ea2eada31e228d8fe6b/src%2Fcomp%2Fmiddle%2Ftrans%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92a45f5582ed8ea4eb439ea2eada31e228d8fe6b/src%2Fcomp%2Fmiddle%2Ftrans%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fnative.rs?ref=92a45f5582ed8ea4eb439ea2eada31e228d8fe6b", "patch": "@@ -8,6 +8,7 @@ import back::link;\n import common::*;\n import build::*;\n import base::*;\n+import type_of::*;\n \n export link_name, trans_native_mod, register_crust_fn, trans_crust_fn;\n \n@@ -31,7 +32,7 @@ fn c_arg_and_ret_lltys(ccx: crate_ctxt,\n     alt ty::get(ty::node_id_to_type(ccx.tcx, id)).struct {\n       ty::ty_fn({inputs: arg_tys, output: ret_ty, _}) {\n         let llargtys = type_of_explicit_args(ccx, arg_tys);\n-        let llretty = type_of(ccx, ret_ty);\n+        let llretty = type_of::type_of(ccx, ret_ty);\n         (llargtys, llretty, ret_ty)\n       }\n       _ { ccx.sess.bug(\"c_arg_and_ret_lltys called on non-function type\"); }"}, {"sha": "2805778e927c18decde9df3fa22c54cffaa80aaa", "filename": "src/comp/middle/trans/shape.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/92a45f5582ed8ea4eb439ea2eada31e228d8fe6b/src%2Fcomp%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92a45f5582ed8ea4eb439ea2eada31e228d8fe6b/src%2Fcomp%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fshape.rs?ref=92a45f5582ed8ea4eb439ea2eada31e228d8fe6b", "patch": "@@ -118,7 +118,7 @@ fn largest_variants(ccx: crate_ctxt, tag_id: ast::def_id) -> [uint] {\n                 // when in fact it has minimum size sizeof(int).\n                 bounded = false;\n             } else {\n-                let llty = base::type_of(ccx, elem_t);\n+                let llty = type_of::type_of(ccx, elem_t);\n                 min_size += llsize_of_real(ccx, llty);\n                 min_align += llalign_of_real(ccx, llty);\n             }\n@@ -188,7 +188,7 @@ fn compute_static_enum_size(ccx: crate_ctxt, largest_variants: [uint],\n         // We increment a \"virtual data pointer\" to compute the size.\n         let lltys = [];\n         for typ: ty::t in variants[vid].args {\n-            lltys += [base::type_of(ccx, typ)];\n+            lltys += [type_of::type_of(ccx, typ)];\n         }\n \n         let llty = trans::common::T_struct(lltys);\n@@ -590,7 +590,7 @@ type tag_metrics = {\n fn size_of(bcx: block, t: ty::t) -> result {\n     let ccx = bcx.ccx();\n     if check type_has_static_size(ccx, t) {\n-        rslt(bcx, llsize_of(ccx, base::type_of(ccx, t)))\n+        rslt(bcx, llsize_of(ccx, type_of::type_of(ccx, t)))\n     } else {\n         let { bcx, sz, align: _ } = dynamic_metrics(bcx, t);\n         rslt(bcx, sz)\n@@ -600,7 +600,7 @@ fn size_of(bcx: block, t: ty::t) -> result {\n fn align_of(bcx: block, t: ty::t) -> result {\n     let ccx = bcx.ccx();\n     if check type_has_static_size(ccx, t) {\n-        rslt(bcx, llalign_of(ccx, base::type_of(ccx, t)))\n+        rslt(bcx, llalign_of(ccx, type_of::type_of(ccx, t)))\n     } else {\n         let { bcx, sz: _, align } = dynamic_metrics(bcx, t);\n         rslt(bcx, align)\n@@ -610,7 +610,7 @@ fn align_of(bcx: block, t: ty::t) -> result {\n fn metrics(bcx: block, t: ty::t) -> metrics {\n     let ccx = bcx.ccx();\n     if check type_has_static_size(ccx, t) {\n-        let llty = base::type_of(ccx, t);\n+        let llty = type_of::type_of(ccx, t);\n         { bcx: bcx, sz: llsize_of(ccx, llty), align: llalign_of(ccx, llty) }\n     } else {\n         dynamic_metrics(bcx, t)\n@@ -657,7 +657,7 @@ fn static_size_of_enum(cx: crate_ctxt, t: ty::t) -> uint {\n             tup_ty = ty::substitute_type_params(cx.tcx, subtys, tup_ty);\n             // Here we possibly do a recursive call.\n             let this_size =\n-                llsize_of_real(cx, base::type_of(cx, tup_ty));\n+                llsize_of_real(cx, type_of::type_of(cx, tup_ty));\n             if max_size < this_size { max_size = this_size; }\n         }\n         cx.enum_sizes.insert(t, max_size);"}, {"sha": "ab9412263d2cf460f7cad4b829ee2168ffd05f53", "filename": "src/comp/middle/trans/tvec.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/92a45f5582ed8ea4eb439ea2eada31e228d8fe6b/src%2Fcomp%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92a45f5582ed8ea4eb439ea2eada31e228d8fe6b/src%2Fcomp%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Ftvec.rs?ref=92a45f5582ed8ea4eb439ea2eada31e228d8fe6b", "patch": "@@ -2,7 +2,7 @@ import syntax::ast;\n import driver::session::session;\n import lib::llvm::{ValueRef, TypeRef};\n import back::abi;\n-import base::{call_memmove, trans_shared_malloc, type_of_or_i8,\n+import base::{call_memmove, trans_shared_malloc,\n                INIT, copy_val, load_if_immediate, get_tydesc,\n                sub_block, do_spill_noroot,\n                dest};\n@@ -46,7 +46,7 @@ type alloc_result =\n fn alloc(bcx: block, vec_ty: ty::t, elts: uint) -> alloc_result {\n     let ccx = bcx.ccx();\n     let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n-    let llunitty = type_of_or_i8(ccx, unit_ty);\n+    let llunitty = type_of::type_of_or_i8(ccx, unit_ty);\n     let llvecty = T_vec(ccx, llunitty);\n     let {bcx: bcx, val: unit_sz} = size_of(bcx, unit_ty);\n \n@@ -156,7 +156,7 @@ fn trans_append(cx: block, vec_ty: ty::t, lhsptr: ValueRef,\n     };\n \n     let {bcx: bcx, val: unit_sz} = size_of(cx, unit_ty);\n-    let llunitty = type_of_or_i8(ccx, unit_ty);\n+    let llunitty = type_of::type_of_or_i8(ccx, unit_ty);\n \n     let lhs = Load(bcx, lhsptr);\n     let self_append = ICmp(bcx, lib::llvm::IntEQ, lhs, rhs);\n@@ -226,7 +226,7 @@ fn trans_add(bcx: block, vec_ty: ty::t, lhs: ValueRef,\n       _ { false }\n     };\n     let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n-    let llunitty = type_of_or_i8(ccx, unit_ty);\n+    let llunitty = type_of::type_of_or_i8(ccx, unit_ty);\n     let {bcx: bcx, val: llunitsz} = size_of(bcx, unit_ty);\n \n     let lhs_fill = get_fill(bcx, lhs);\n@@ -268,7 +268,7 @@ fn iter_vec_raw(bcx: block, vptr: ValueRef, vec_ty: ty::t,\n                 fill: ValueRef, f: iter_vec_block) -> block {\n     let ccx = bcx.ccx();\n     let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n-    let llunitty = type_of_or_i8(ccx, unit_ty);\n+    let llunitty = type_of::type_of_or_i8(ccx, unit_ty);\n     let {bcx: bcx, val: unit_sz} = size_of(bcx, unit_ty);\n     let vptr = PointerCast(bcx, vptr, T_ptr(T_vec(ccx, llunitty)));\n     let data_ptr = get_dataptr(bcx, vptr, llunitty);"}, {"sha": "f7095be55ffecbb45ab20d1595238b1994e121cb", "filename": "src/comp/middle/trans/type_of.rs", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/92a45f5582ed8ea4eb439ea2eada31e228d8fe6b/src%2Fcomp%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92a45f5582ed8ea4eb439ea2eada31e228d8fe6b/src%2Fcomp%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=92a45f5582ed8ea4eb439ea2eada31e228d8fe6b", "patch": "@@ -0,0 +1,145 @@\n+import common::*;\n+import lib::llvm::{TypeRef};\n+import syntax::ast;\n+import lib::llvm::llvm;\n+\n+fn type_of_explicit_args(cx: crate_ctxt, inputs: [ty::arg]) -> [TypeRef] {\n+    vec::map(inputs) {|arg|\n+        let arg_ty = arg.ty;\n+        let llty = type_of(cx, arg_ty);\n+        alt ty::resolved_mode(cx.tcx, arg.mode) {\n+          ast::by_val { llty }\n+          _ { T_ptr(llty) }\n+        }\n+    }\n+}\n+\n+fn type_of_fn(cx: crate_ctxt, inputs: [ty::arg],\n+              output: ty::t, params: [ty::param_bounds]) -> TypeRef {\n+    let atys: [TypeRef] = [];\n+\n+    // Arg 0: Output pointer.\n+    atys += [T_ptr(type_of(cx, output))];\n+\n+    // Arg 1: Environment\n+    atys += [T_opaque_box_ptr(cx)];\n+\n+    // Args >2: ty params, if not acquired via capture...\n+    for bounds in params {\n+        atys += [T_ptr(cx.tydesc_type)];\n+        for bound in *bounds {\n+            alt bound {\n+              ty::bound_iface(_) { atys += [T_ptr(T_dict())]; }\n+              _ {}\n+            }\n+        }\n+    }\n+    // ... then explicit args.\n+    atys += type_of_explicit_args(cx, inputs);\n+    ret T_fn(atys, llvm::LLVMVoidType());\n+}\n+\n+// Given a function type and a count of ty params, construct an llvm type\n+fn type_of_fn_from_ty(cx: crate_ctxt, fty: ty::t,\n+                      param_bounds: [ty::param_bounds]) -> TypeRef {\n+    type_of_fn(cx, ty::ty_fn_args(fty), ty::ty_fn_ret(fty), param_bounds)\n+}\n+\n+fn type_of(cx: crate_ctxt, t: ty::t) -> TypeRef {\n+    assert !ty::type_has_vars(t);\n+    // Check the cache.\n+\n+    if cx.lltypes.contains_key(t) { ret cx.lltypes.get(t); }\n+    let llty = alt ty::get(t).struct {\n+      ty::ty_nil | ty::ty_bot { T_nil() }\n+      ty::ty_bool { T_bool() }\n+      ty::ty_int(t) { T_int_ty(cx, t) }\n+      ty::ty_uint(t) { T_uint_ty(cx, t) }\n+      ty::ty_float(t) { T_float_ty(cx, t) }\n+      ty::ty_str { T_ptr(T_vec(cx, T_i8())) }\n+      ty::ty_enum(did, _) { type_of_enum(cx, did, t) }\n+      ty::ty_box(mt) {\n+        let mt_ty = mt.ty;\n+        T_ptr(T_box(cx, type_of(cx, mt_ty))) }\n+      ty::ty_opaque_box { T_ptr(T_box(cx, T_i8())) }\n+      ty::ty_uniq(mt) {\n+        let mt_ty = mt.ty;\n+        T_ptr(type_of(cx, mt_ty)) }\n+      ty::ty_vec(mt) {\n+        let mt_ty = mt.ty;\n+        if ty::type_has_dynamic_size(cx.tcx, mt_ty) {\n+            T_ptr(cx.opaque_vec_type)\n+        } else {\n+            T_ptr(T_vec(cx, type_of(cx, mt_ty))) }\n+      }\n+      ty::ty_ptr(mt) {\n+        let mt_ty = mt.ty;\n+        T_ptr(type_of(cx, mt_ty)) }\n+      ty::ty_rec(fields) {\n+        let tys: [TypeRef] = [];\n+        for f: ty::field in fields {\n+            let mt_ty = f.mt.ty;\n+            tys += [type_of(cx, mt_ty)];\n+        }\n+        T_struct(tys)\n+      }\n+      ty::ty_fn(_) {\n+        T_fn_pair(cx, type_of_fn_from_ty(cx, t, []))\n+      }\n+      ty::ty_iface(_, _) { T_opaque_iface(cx) }\n+      ty::ty_res(_, sub, tps) {\n+        let sub1 = ty::substitute_type_params(cx.tcx, tps, sub);\n+        ret T_struct([T_i8(), type_of(cx, sub1)]);\n+      }\n+      ty::ty_param(_, _) { T_typaram(cx.tn) }\n+      ty::ty_send_type | ty::ty_type { T_ptr(cx.tydesc_type) }\n+      ty::ty_tup(elts) {\n+        let tys = [];\n+        for elt in elts {\n+            tys += [type_of(cx, elt)];\n+        }\n+        T_struct(tys)\n+      }\n+      ty::ty_opaque_closure_ptr(_) { T_opaque_box_ptr(cx) }\n+      ty::ty_constr(subt,_) { type_of(cx, subt) }\n+\n+      _ { fail \"type_of not implemented for this kind of type\"; }\n+    };\n+    cx.lltypes.insert(t, llty);\n+    ret llty;\n+}\n+\n+fn type_of_enum(cx: crate_ctxt, did: ast::def_id, t: ty::t)\n+    -> TypeRef {\n+    let degen = (*ty::enum_variants(cx.tcx, did)).len() == 1u;\n+    if check type_has_static_size(cx, t) {\n+        let size = shape::static_size_of_enum(cx, t);\n+        if !degen { T_enum(cx, size) }\n+        else if size == 0u { T_struct([T_enum_variant(cx)]) }\n+        else { T_array(T_i8(), size) }\n+    }\n+    else {\n+        if degen { T_struct([T_enum_variant(cx)]) }\n+        else { T_opaque_enum(cx) }\n+    }\n+}\n+\n+fn type_of_ty_param_bounds_and_ty\n+    (ccx: crate_ctxt, tpt: ty::ty_param_bounds_and_ty) -> TypeRef {\n+    let t = tpt.ty;\n+    alt ty::get(t).struct {\n+      ty::ty_fn(_) {\n+        ret type_of_fn_from_ty(ccx, t, *tpt.bounds);\n+      }\n+      _ {\n+        // fall through\n+      }\n+    }\n+    type_of(ccx, t)\n+}\n+\n+fn type_of_or_i8(ccx: crate_ctxt, typ: ty::t) -> TypeRef {\n+    if check type_has_static_size(ccx, typ) {\n+        type_of(ccx, typ)\n+    } else { T_i8() }\n+}"}, {"sha": "d6d325108581a6f32850fb5f621b08983bfcc09d", "filename": "src/comp/middle/trans/uniq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92a45f5582ed8ea4eb439ea2eada31e228d8fe6b/src%2Fcomp%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92a45f5582ed8ea4eb439ea2eada31e228d8fe6b/src%2Fcomp%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Funiq.rs?ref=92a45f5582ed8ea4eb439ea2eada31e228d8fe6b", "patch": "@@ -24,7 +24,7 @@ fn alloc_uniq(cx: block, uniq_ty: ty::t) -> result {\n     bcx = r.bcx;\n     let llsz = r.val;\n \n-    let llptrty = T_ptr(type_of(bcx.ccx(), contents_ty));\n+    let llptrty = T_ptr(type_of::type_of(bcx.ccx(), contents_ty));\n \n     r = trans_shared_malloc(bcx, llptrty, llsz);\n     bcx = r.bcx;"}, {"sha": "0b8ce111f1fe850401b8c33b94f78f71a781f924", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/92a45f5582ed8ea4eb439ea2eada31e228d8fe6b/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/92a45f5582ed8ea4eb439ea2eada31e228d8fe6b/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=92a45f5582ed8ea4eb439ea2eada31e228d8fe6b", "patch": "@@ -16,6 +16,7 @@ use std (name = \"std\",\n mod middle {\n     mod trans {\n         mod common;\n+        mod type_of;\n         mod build;\n         mod base;\n         mod alt;"}]}