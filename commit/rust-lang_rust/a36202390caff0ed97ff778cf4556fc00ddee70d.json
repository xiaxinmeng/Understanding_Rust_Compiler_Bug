{"sha": "a36202390caff0ed97ff778cf4556fc00ddee70d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzNjIwMjM5MGNhZmYwZWQ5N2ZmNzc4Y2Y0NTU2ZmMwMGRkZWU3MGQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-05-19T23:30:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-19T23:30:48Z"}, "message": "Merge #4521 #4522\n\n4521: Use snippets in add_function r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\n4522: Explain the purpose of `ast::make` module more clearly r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "0f02f3c0f2c8adaba5e4593a5ec576186611b31a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f02f3c0f2c8adaba5e4593a5ec576186611b31a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a36202390caff0ed97ff778cf4556fc00ddee70d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJexGwoCRBK7hj4Ov3rIwAAdHIIAIlEQDxEjCEEiR8JeOJ4LiHB\nxxyt8I9hYxYkV3FwXpl4MAF/8iFDArEUNyIP0ydjqzN6LNrB7mtFVPnustpC4/0F\nYd2ocoqt8k417mmClH0qHZQFwOd9INjQgGtPCTXd/AoxU1iJFfOgCsSUz6Mydpih\nld8kVKW6rshrFfedqDo4CR2yNyI5Dyq6M129/ZWfotTztQIb2pWhfk2azoPWf9WV\nILUgEcvD6D5gGrjUx8mVbw86sHVY7547lwFpjAXj0OdSavH3qRYWwrcOqk65hovH\neCnClPqFqfNwpqvgwLMQ+Z8MBrx4/bel4+ysc6xZx/0X3XzpCBenqdxKNnWIQHQ=\n=dnDy\n-----END PGP SIGNATURE-----\n", "payload": "tree 0f02f3c0f2c8adaba5e4593a5ec576186611b31a\nparent 28f6b5b8493024b87f53ea9be4d517442588b7e5\nparent e6fc0bdffb213f6e94c5bb4081e6d175ccbd518f\nparent 4de2749db8281c00aba37270fa9ae8d4bd2572d8\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1589931048 +0000\ncommitter GitHub <noreply@github.com> 1589931048 +0000\n\nMerge #4521 #4522\n\n4521: Use snippets in add_function r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\n4522: Explain the purpose of `ast::make` module more clearly r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a36202390caff0ed97ff778cf4556fc00ddee70d", "html_url": "https://github.com/rust-lang/rust/commit/a36202390caff0ed97ff778cf4556fc00ddee70d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a36202390caff0ed97ff778cf4556fc00ddee70d/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28f6b5b8493024b87f53ea9be4d517442588b7e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/28f6b5b8493024b87f53ea9be4d517442588b7e5", "html_url": "https://github.com/rust-lang/rust/commit/28f6b5b8493024b87f53ea9be4d517442588b7e5"}, {"sha": "e6fc0bdffb213f6e94c5bb4081e6d175ccbd518f", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6fc0bdffb213f6e94c5bb4081e6d175ccbd518f", "html_url": "https://github.com/rust-lang/rust/commit/e6fc0bdffb213f6e94c5bb4081e6d175ccbd518f"}, {"sha": "4de2749db8281c00aba37270fa9ae8d4bd2572d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/4de2749db8281c00aba37270fa9ae8d4bd2572d8", "html_url": "https://github.com/rust-lang/rust/commit/4de2749db8281c00aba37270fa9ae8d4bd2572d8"}], "stats": {"total": 312, "additions": 205, "deletions": 107}, "files": [{"sha": "770049212d29d19d50e7e4339306a9996bf08391", "filename": "crates/ra_assists/src/handlers/add_explicit_type.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a36202390caff0ed97ff778cf4556fc00ddee70d/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a36202390caff0ed97ff778cf4556fc00ddee70d/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs?ref=a36202390caff0ed97ff778cf4556fc00ddee70d", "patch": "@@ -25,9 +25,8 @@ pub(crate) fn add_explicit_type(acc: &mut Assists, ctx: &AssistContext) -> Optio\n     let stmt = ctx.find_node_at_offset::<LetStmt>()?;\n     let module = ctx.sema.scope(stmt.syntax()).module()?;\n     let expr = stmt.initializer()?;\n-    let pat = stmt.pat()?;\n     // Must be a binding\n-    let pat = match pat {\n+    let pat = match stmt.pat()? {\n         ast::Pat::BindPat(bind_pat) => bind_pat,\n         _ => return None,\n     };\n@@ -46,7 +45,7 @@ pub(crate) fn add_explicit_type(acc: &mut Assists, ctx: &AssistContext) -> Optio\n     // Assist not applicable if the type has already been specified\n     // and it has no placeholders\n     let ascribed_ty = stmt.ascribed_type();\n-    if let Some(ref ty) = ascribed_ty {\n+    if let Some(ty) = &ascribed_ty {\n         if ty.syntax().descendants().find_map(ast::PlaceholderType::cast).is_none() {\n             return None;\n         }"}, {"sha": "eb57b7231fa74ea5aa69f066300572dcaeadbce8", "filename": "crates/ra_assists/src/handlers/add_from_impl_for_enum.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a36202390caff0ed97ff778cf4556fc00ddee70d/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_from_impl_for_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a36202390caff0ed97ff778cf4556fc00ddee70d/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_from_impl_for_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_from_impl_for_enum.rs?ref=a36202390caff0ed97ff778cf4556fc00ddee70d", "patch": "@@ -1,6 +1,5 @@\n use ra_ide_db::RootDatabase;\n use ra_syntax::ast::{self, AstNode, NameOwner};\n-use stdx::format_to;\n use test_utils::tested_by;\n \n use crate::{utils::FamousDefs, AssistContext, AssistId, Assists};\n@@ -35,7 +34,7 @@ pub(crate) fn add_from_impl_for_enum(acc: &mut Assists, ctx: &AssistContext) ->\n     }\n     let field_type = field_list.fields().next()?.type_ref()?;\n     let path = match field_type {\n-        ast::TypeRef::PathType(p) => p,\n+        ast::TypeRef::PathType(it) => it,\n         _ => return None,\n     };\n \n@@ -51,9 +50,7 @@ pub(crate) fn add_from_impl_for_enum(acc: &mut Assists, ctx: &AssistContext) ->\n         target,\n         |edit| {\n             let start_offset = variant.parent_enum().syntax().text_range().end();\n-            let mut buf = String::new();\n-            format_to!(\n-                buf,\n+            let buf = format!(\n                 r#\"\n \n impl From<{0}> for {1} {{"}, {"sha": "a0709630d27ef3662d8d1dbb705a6a83ce0b58d6", "filename": "crates/ra_assists/src/handlers/add_function.rs", "status": "modified", "additions": 79, "deletions": 58, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/a36202390caff0ed97ff778cf4556fc00ddee70d/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a36202390caff0ed97ff778cf4556fc00ddee70d/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs?ref=a36202390caff0ed97ff778cf4556fc00ddee70d", "patch": "@@ -4,13 +4,13 @@ use ra_syntax::{\n     ast::{\n         self,\n         edit::{AstNodeEdit, IndentLevel},\n-        ArgListOwner, AstNode, ModuleItemOwner,\n+        make, ArgListOwner, AstNode, ModuleItemOwner,\n     },\n     SyntaxKind, SyntaxNode, TextSize,\n };\n use rustc_hash::{FxHashMap, FxHashSet};\n \n-use crate::{AssistContext, AssistId, Assists};\n+use crate::{assist_config::SnippetCap, utils::render_snippet, AssistContext, AssistId, Assists};\n \n // Assist: add_function\n //\n@@ -33,7 +33,7 @@ use crate::{AssistContext, AssistId, Assists};\n // }\n //\n // fn bar(arg: &str, baz: Baz) {\n-//     todo!()\n+//     ${0:todo!()}\n // }\n //\n // ```\n@@ -58,21 +58,36 @@ pub(crate) fn add_function(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n     let function_builder = FunctionBuilder::from_call(&ctx, &call, &path, target_module)?;\n \n     let target = call.syntax().text_range();\n-    acc.add(AssistId(\"add_function\"), \"Add function\", target, |edit| {\n+    acc.add(AssistId(\"add_function\"), \"Add function\", target, |builder| {\n         let function_template = function_builder.render();\n-        edit.set_file(function_template.file);\n-        edit.set_cursor(function_template.cursor_offset);\n-        edit.insert(function_template.insert_offset, function_template.fn_def.to_string());\n+        builder.set_file(function_template.file);\n+        let new_fn = function_template.to_string(ctx.config.snippet_cap);\n+        match ctx.config.snippet_cap {\n+            Some(cap) => builder.insert_snippet(cap, function_template.insert_offset, new_fn),\n+            None => builder.insert(function_template.insert_offset, new_fn),\n+        }\n     })\n }\n \n struct FunctionTemplate {\n     insert_offset: TextSize,\n-    cursor_offset: TextSize,\n-    fn_def: ast::SourceFile,\n+    placeholder_expr: ast::MacroCall,\n+    leading_ws: String,\n+    fn_def: ast::FnDef,\n+    trailing_ws: String,\n     file: FileId,\n }\n \n+impl FunctionTemplate {\n+    fn to_string(&self, cap: Option<SnippetCap>) -> String {\n+        let f = match cap {\n+            Some(cap) => render_snippet(cap, self.fn_def.syntax(), self.placeholder_expr.syntax()),\n+            None => self.fn_def.to_string(),\n+        };\n+        format!(\"{}{}{}\", self.leading_ws, f, self.trailing_ws)\n+    }\n+}\n+\n struct FunctionBuilder {\n     target: GeneratedFunctionTarget,\n     fn_name: ast::Name,\n@@ -110,35 +125,41 @@ impl FunctionBuilder {\n     }\n \n     fn render(self) -> FunctionTemplate {\n-        let placeholder_expr = ast::make::expr_todo();\n-        let fn_body = ast::make::block_expr(vec![], Some(placeholder_expr));\n-        let mut fn_def = ast::make::fn_def(self.fn_name, self.type_params, self.params, fn_body);\n-        if self.needs_pub {\n-            fn_def = ast::make::add_pub_crate_modifier(fn_def);\n-        }\n-\n-        let (fn_def, insert_offset) = match self.target {\n+        let placeholder_expr = make::expr_todo();\n+        let fn_body = make::block_expr(vec![], Some(placeholder_expr));\n+        let visibility = if self.needs_pub { Some(make::visibility_pub_crate()) } else { None };\n+        let mut fn_def =\n+            make::fn_def(visibility, self.fn_name, self.type_params, self.params, fn_body);\n+        let leading_ws;\n+        let trailing_ws;\n+\n+        let insert_offset = match self.target {\n             GeneratedFunctionTarget::BehindItem(it) => {\n-                let with_leading_blank_line = ast::make::add_leading_newlines(2, fn_def);\n-                let indented = with_leading_blank_line.indent(IndentLevel::from_node(&it));\n-                (indented, it.text_range().end())\n+                let indent = IndentLevel::from_node(&it);\n+                leading_ws = format!(\"\\n\\n{}\", indent);\n+                fn_def = fn_def.indent(indent);\n+                trailing_ws = String::new();\n+                it.text_range().end()\n             }\n             GeneratedFunctionTarget::InEmptyItemList(it) => {\n-                let indent_once = IndentLevel(1);\n                 let indent = IndentLevel::from_node(it.syntax());\n-                let fn_def = ast::make::add_leading_newlines(1, fn_def);\n-                let fn_def = fn_def.indent(indent_once);\n-                let fn_def = ast::make::add_trailing_newlines(1, fn_def);\n-                let fn_def = fn_def.indent(indent);\n-                (fn_def, it.syntax().text_range().start() + TextSize::of('{'))\n+                leading_ws = format!(\"\\n{}\", indent + 1);\n+                fn_def = fn_def.indent(indent + 1);\n+                trailing_ws = format!(\"\\n{}\", indent);\n+                it.syntax().text_range().start() + TextSize::of('{')\n             }\n         };\n \n         let placeholder_expr =\n             fn_def.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n-        let cursor_offset_from_fn_start = placeholder_expr.syntax().text_range().start();\n-        let cursor_offset = insert_offset + cursor_offset_from_fn_start;\n-        FunctionTemplate { insert_offset, cursor_offset, fn_def, file: self.file }\n+        FunctionTemplate {\n+            insert_offset,\n+            placeholder_expr,\n+            leading_ws,\n+            fn_def,\n+            trailing_ws,\n+            file: self.file,\n+        }\n     }\n }\n \n@@ -158,7 +179,7 @@ impl GeneratedFunctionTarget {\n \n fn fn_name(call: &ast::Path) -> Option<ast::Name> {\n     let name = call.segment()?.syntax().to_string();\n-    Some(ast::make::name(&name))\n+    Some(make::name(&name))\n }\n \n /// Computes the type variables and arguments required for the generated function\n@@ -180,8 +201,8 @@ fn fn_args(\n         });\n     }\n     deduplicate_arg_names(&mut arg_names);\n-    let params = arg_names.into_iter().zip(arg_types).map(|(name, ty)| ast::make::param(name, ty));\n-    Some((None, ast::make::param_list(params)))\n+    let params = arg_names.into_iter().zip(arg_types).map(|(name, ty)| make::param(name, ty));\n+    Some((None, make::param_list(params)))\n }\n \n /// Makes duplicate argument names unique by appending incrementing numbers.\n@@ -316,7 +337,7 @@ fn foo() {\n }\n \n fn bar() {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -343,7 +364,7 @@ impl Foo {\n }\n \n fn bar() {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -367,7 +388,7 @@ fn foo1() {\n }\n \n fn bar() {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \n fn foo2() {}\n@@ -393,7 +414,7 @@ mod baz {\n     }\n \n     fn bar() {\n-        <|>todo!()\n+        ${0:todo!()}\n     }\n }\n \",\n@@ -419,7 +440,7 @@ fn foo() {\n }\n \n fn bar(baz: Baz) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         );\n@@ -452,7 +473,7 @@ impl Baz {\n }\n \n fn bar(baz: Baz) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -473,7 +494,7 @@ fn foo() {\n }\n \n fn bar(arg: &str) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \"#,\n         )\n@@ -494,7 +515,7 @@ fn foo() {\n }\n \n fn bar(arg: char) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \"#,\n         )\n@@ -515,7 +536,7 @@ fn foo() {\n }\n \n fn bar(arg: i32) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -536,7 +557,7 @@ fn foo() {\n }\n \n fn bar(arg: u8) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -561,7 +582,7 @@ fn foo() {\n }\n \n fn bar(x: u8) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -584,7 +605,7 @@ fn foo() {\n }\n \n fn bar(worble: ()) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -613,7 +634,7 @@ fn baz() {\n }\n \n fn bar(foo: impl Foo) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -640,7 +661,7 @@ fn foo() {\n }\n \n fn bar(baz: &Baz) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -669,7 +690,7 @@ fn foo() {\n }\n \n fn bar(baz: Baz::Bof) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -692,7 +713,7 @@ fn foo<T>(t: T) {\n }\n \n fn bar<T>(t: T) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -723,7 +744,7 @@ fn foo() {\n }\n \n fn bar(arg: fn() -> Baz) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -748,7 +769,7 @@ fn foo() {\n }\n \n fn bar(closure: impl Fn(i64) -> i64) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -769,7 +790,7 @@ fn foo() {\n }\n \n fn bar(baz: ()) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -794,7 +815,7 @@ fn foo() {\n }\n \n fn bar(baz_1: Baz, baz_2: Baz) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -819,7 +840,7 @@ fn foo() {\n }\n \n fn bar(baz_1: Baz, baz_2: Baz, arg_1: &str, arg_2: &str) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \"#,\n         )\n@@ -839,7 +860,7 @@ fn foo() {\n             r\"\n mod bar {\n     pub(crate) fn my_fn() {\n-        <|>todo!()\n+        ${0:todo!()}\n     }\n }\n \n@@ -878,7 +899,7 @@ fn bar() {\n }\n \n fn baz(foo: foo::Foo) {\n-    <|>todo!()\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -902,7 +923,7 @@ mod bar {\n     fn something_else() {}\n \n     pub(crate) fn my_fn() {\n-        <|>todo!()\n+        ${0:todo!()}\n     }\n }\n \n@@ -930,7 +951,7 @@ fn foo() {\n mod bar {\n     mod baz {\n         pub(crate) fn my_fn() {\n-            <|>todo!()\n+            ${0:todo!()}\n         }\n     }\n }\n@@ -959,7 +980,7 @@ fn main() {\n \n \n pub(crate) fn bar() {\n-    <|>todo!()\n+    ${0:todo!()}\n }\",\n         )\n     }"}, {"sha": "b379b55a83fe7095c1a37605bbf63bad0bc4eac6", "filename": "crates/ra_assists/src/handlers/replace_unwrap_with_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a36202390caff0ed97ff778cf4556fc00ddee70d/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_unwrap_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a36202390caff0ed97ff778cf4556fc00ddee70d/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_unwrap_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_unwrap_with_match.rs?ref=a36202390caff0ed97ff778cf4556fc00ddee70d", "patch": "@@ -51,7 +51,7 @@ pub(crate) fn replace_unwrap_with_match(acc: &mut Assists, ctx: &AssistContext)\n         let bind_path = make::path_unqualified(make::path_segment(make::name_ref(\"a\")));\n         let ok_arm = make::match_arm(iter::once(ok_tuple), make::expr_path(bind_path));\n \n-        let unreachable_call = make::unreachable_macro_call().into();\n+        let unreachable_call = make::expr_unreachable();\n         let err_arm = make::match_arm(iter::once(make::placeholder_pat().into()), unreachable_call);\n \n         let match_arm_list = make::match_arm_list(vec![ok_arm, err_arm]);"}, {"sha": "1d82c245d0429b34a482a5e08dc7e30ec0b5e10a", "filename": "crates/ra_assists/src/tests/generated.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a36202390caff0ed97ff778cf4556fc00ddee70d/crates%2Fra_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a36202390caff0ed97ff778cf4556fc00ddee70d/crates%2Fra_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=a36202390caff0ed97ff778cf4556fc00ddee70d", "patch": "@@ -78,7 +78,7 @@ fn foo() {\n }\n \n fn bar(arg: &str, baz: Baz) {\n-    todo!()\n+    ${0:todo!()}\n }\n \n \"#####,"}, {"sha": "8a26a680828696e17eaf1960dce2ab4cc18aaeb2", "filename": "crates/ra_assists/src/utils.rs", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a36202390caff0ed97ff778cf4556fc00ddee70d/crates%2Fra_assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a36202390caff0ed97ff778cf4556fc00ddee70d/crates%2Fra_assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Futils.rs?ref=a36202390caff0ed97ff778cf4556fc00ddee70d", "patch": "@@ -1,18 +1,44 @@\n //! Assorted functions shared by several assists.\n pub(crate) mod insert_use;\n \n-use std::iter;\n+use std::{iter, ops};\n \n use hir::{Adt, Crate, Semantics, Trait, Type};\n use ra_ide_db::RootDatabase;\n use ra_syntax::{\n     ast::{self, make, NameOwner},\n-    AstNode, T,\n+    AstNode, SyntaxNode, T,\n };\n use rustc_hash::FxHashSet;\n \n+use crate::assist_config::SnippetCap;\n+\n pub(crate) use insert_use::insert_use_statement;\n \n+pub(crate) fn render_snippet(\n+    _cap: SnippetCap,\n+    node: &SyntaxNode,\n+    placeholder: &SyntaxNode,\n+) -> String {\n+    assert!(placeholder.ancestors().any(|it| it == *node));\n+    let range = placeholder.text_range() - node.text_range().start();\n+    let range: ops::Range<usize> = range.into();\n+\n+    let mut placeholder = placeholder.to_string();\n+    escape(&mut placeholder);\n+    let tab_stop = format!(\"${{0:{}}}\", placeholder);\n+\n+    let mut buf = node.to_string();\n+    buf.replace_range(range, &tab_stop);\n+    return buf;\n+\n+    fn escape(buf: &mut String) {\n+        stdx::replace(buf, '{', r\"\\{\");\n+        stdx::replace(buf, '}', r\"\\}\");\n+        stdx::replace(buf, '$', r\"\\$\");\n+    }\n+}\n+\n pub fn get_missing_assoc_items(\n     sema: &Semantics<RootDatabase>,\n     impl_def: &ast::ImplDef,"}, {"sha": "664894d1f839cfba0e1259bc625016fae30ad9d4", "filename": "crates/ra_syntax/src/algo.rs", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a36202390caff0ed97ff778cf4556fc00ddee70d/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a36202390caff0ed97ff778cf4556fc00ddee70d/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Falgo.rs?ref=a36202390caff0ed97ff778cf4556fc00ddee70d", "patch": "@@ -266,6 +266,15 @@ impl<'a> SyntaxRewriter<'a> {\n         let replacement = Replacement::Single(with.clone().into());\n         self.replacements.insert(what, replacement);\n     }\n+    pub fn replace_with_many<T: Clone + Into<SyntaxElement>>(\n+        &mut self,\n+        what: &T,\n+        with: Vec<SyntaxElement>,\n+    ) {\n+        let what = what.clone().into();\n+        let replacement = Replacement::Many(with);\n+        self.replacements.insert(what, replacement);\n+    }\n     pub fn replace_ast<T: AstNode>(&mut self, what: &T, with: &T) {\n         self.replace(what.syntax(), with.syntax())\n     }\n@@ -302,31 +311,41 @@ impl<'a> SyntaxRewriter<'a> {\n \n     fn rewrite_children(&self, node: &SyntaxNode) -> SyntaxNode {\n         //  FIXME: this could be made much faster.\n-        let new_children =\n-            node.children_with_tokens().flat_map(|it| self.rewrite_self(&it)).collect::<Vec<_>>();\n+        let mut new_children = Vec::new();\n+        for child in node.children_with_tokens() {\n+            self.rewrite_self(&mut new_children, &child);\n+        }\n         with_children(node, new_children)\n     }\n \n     fn rewrite_self(\n         &self,\n+        acc: &mut Vec<NodeOrToken<rowan::GreenNode, rowan::GreenToken>>,\n         element: &SyntaxElement,\n-    ) -> Option<NodeOrToken<rowan::GreenNode, rowan::GreenToken>> {\n+    ) {\n         if let Some(replacement) = self.replacement(&element) {\n-            return match replacement {\n+            match replacement {\n                 Replacement::Single(NodeOrToken::Node(it)) => {\n-                    Some(NodeOrToken::Node(it.green().clone()))\n+                    acc.push(NodeOrToken::Node(it.green().clone()))\n                 }\n                 Replacement::Single(NodeOrToken::Token(it)) => {\n-                    Some(NodeOrToken::Token(it.green().clone()))\n+                    acc.push(NodeOrToken::Token(it.green().clone()))\n                 }\n-                Replacement::Delete => None,\n+                Replacement::Many(replacements) => {\n+                    acc.extend(replacements.iter().map(|it| match it {\n+                        NodeOrToken::Node(it) => NodeOrToken::Node(it.green().clone()),\n+                        NodeOrToken::Token(it) => NodeOrToken::Token(it.green().clone()),\n+                    }))\n+                }\n+                Replacement::Delete => (),\n             };\n+            return;\n         }\n         let res = match element {\n             NodeOrToken::Token(it) => NodeOrToken::Token(it.green().clone()),\n             NodeOrToken::Node(it) => NodeOrToken::Node(self.rewrite_children(it).green().clone()),\n         };\n-        Some(res)\n+        acc.push(res)\n     }\n }\n \n@@ -341,6 +360,7 @@ impl ops::AddAssign for SyntaxRewriter<'_> {\n enum Replacement {\n     Delete,\n     Single(SyntaxElement),\n+    Many(Vec<SyntaxElement>),\n }\n \n fn with_children("}, {"sha": "29eb3fcb9ccca443055ef4c2bde26bf8f5735aac", "filename": "crates/ra_syntax/src/ast/edit.rs", "status": "modified", "additions": 36, "deletions": 8, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a36202390caff0ed97ff778cf4556fc00ddee70d/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a36202390caff0ed97ff778cf4556fc00ddee70d/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs?ref=a36202390caff0ed97ff778cf4556fc00ddee70d", "patch": "@@ -1,7 +1,10 @@\n //! This module contains functions for editing syntax trees. As the trees are\n //! immutable, all function here return a fresh copy of the tree, instead of\n //! doing an in-place modification.\n-use std::{iter, ops::RangeInclusive};\n+use std::{\n+    fmt, iter,\n+    ops::{self, RangeInclusive},\n+};\n \n use arrayvec::ArrayVec;\n \n@@ -437,6 +440,28 @@ impl From<u8> for IndentLevel {\n     }\n }\n \n+impl fmt::Display for IndentLevel {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let spaces = \"                                        \";\n+        let buf;\n+        let len = self.0 as usize * 4;\n+        let indent = if len <= spaces.len() {\n+            &spaces[..len]\n+        } else {\n+            buf = iter::repeat(' ').take(len).collect::<String>();\n+            &buf\n+        };\n+        fmt::Display::fmt(indent, f)\n+    }\n+}\n+\n+impl ops::Add<u8> for IndentLevel {\n+    type Output = IndentLevel;\n+    fn add(self, rhs: u8) -> IndentLevel {\n+        IndentLevel(self.0 + rhs)\n+    }\n+}\n+\n impl IndentLevel {\n     pub fn from_node(node: &SyntaxNode) -> IndentLevel {\n         let first_token = match node.first_token() {\n@@ -453,6 +478,14 @@ impl IndentLevel {\n         IndentLevel(0)\n     }\n \n+    /// XXX: this intentionally doesn't change the indent of the very first token.\n+    /// Ie, in something like\n+    /// ```\n+    /// fn foo() {\n+    ///    92\n+    /// }\n+    /// ```\n+    /// if you indent the block, the `{` token would stay put.\n     fn increase_indent(self, node: SyntaxNode) -> SyntaxNode {\n         let mut rewriter = SyntaxRewriter::default();\n         node.descendants_with_tokens()\n@@ -463,12 +496,7 @@ impl IndentLevel {\n                 text.contains('\\n')\n             })\n             .for_each(|ws| {\n-                let new_ws = make::tokens::whitespace(&format!(\n-                    \"{}{:width$}\",\n-                    ws.syntax().text(),\n-                    \"\",\n-                    width = self.0 as usize * 4\n-                ));\n+                let new_ws = make::tokens::whitespace(&format!(\"{}{}\", ws.syntax(), self,));\n                 rewriter.replace(ws.syntax(), &new_ws)\n             });\n         rewriter.rewrite(&node)\n@@ -485,7 +513,7 @@ impl IndentLevel {\n             })\n             .for_each(|ws| {\n                 let new_ws = make::tokens::whitespace(\n-                    &ws.syntax().text().replace(&format!(\"\\n{:1$}\", \"\", self.0 as usize * 4), \"\\n\"),\n+                    &ws.syntax().text().replace(&format!(\"\\n{}\", self), \"\\n\"),\n                 );\n                 rewriter.replace(ws.syntax(), &new_ws)\n             });"}, {"sha": "da0eb09267ffe9eef47c0acaf689023618dabe1f", "filename": "crates/ra_syntax/src/ast/make.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a36202390caff0ed97ff778cf4556fc00ddee70d/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a36202390caff0ed97ff778cf4556fc00ddee70d/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs?ref=a36202390caff0ed97ff778cf4556fc00ddee70d", "patch": "@@ -1,5 +1,9 @@\n //! This module contains free-standing functions for creating AST fragments out\n //! of smaller pieces.\n+//!\n+//! Note that all functions here intended to be stupid constructors, which just\n+//! assemble a finish node from immediate children. If you want to do something\n+//! smarter than that, it probably doesn't belong in this module.\n use itertools::Itertools;\n use stdx::format_to;\n \n@@ -95,6 +99,9 @@ pub fn expr_empty_block() -> ast::Expr {\n pub fn expr_unimplemented() -> ast::Expr {\n     expr_from_text(\"unimplemented!()\")\n }\n+pub fn expr_unreachable() -> ast::Expr {\n+    expr_from_text(\"unreachable!()\")\n+}\n pub fn expr_todo() -> ast::Expr {\n     expr_from_text(\"todo!()\")\n }\n@@ -264,10 +271,6 @@ pub fn token(kind: SyntaxKind) -> SyntaxToken {\n         .unwrap_or_else(|| panic!(\"unhandled token: {:?}\", kind))\n }\n \n-pub fn unreachable_macro_call() -> ast::MacroCall {\n-    ast_from_text(&format!(\"unreachable!()\"))\n-}\n-\n pub fn param(name: String, ty: String) -> ast::Param {\n     ast_from_text(&format!(\"fn f({}: {}) {{ }}\", name, ty))\n }\n@@ -277,29 +280,24 @@ pub fn param_list(pats: impl IntoIterator<Item = ast::Param>) -> ast::ParamList\n     ast_from_text(&format!(\"fn f({}) {{ }}\", args))\n }\n \n+pub fn visibility_pub_crate() -> ast::Visibility {\n+    ast_from_text(\"pub(crate) struct S\")\n+}\n+\n pub fn fn_def(\n+    visibility: Option<ast::Visibility>,\n     fn_name: ast::Name,\n     type_params: Option<ast::TypeParamList>,\n     params: ast::ParamList,\n     body: ast::BlockExpr,\n ) -> ast::FnDef {\n     let type_params =\n         if let Some(type_params) = type_params { format!(\"<{}>\", type_params) } else { \"\".into() };\n-    ast_from_text(&format!(\"fn {}{}{} {}\", fn_name, type_params, params, body))\n-}\n-\n-pub fn add_leading_newlines(amount_of_newlines: usize, t: impl AstNode) -> ast::SourceFile {\n-    let newlines = \"\\n\".repeat(amount_of_newlines);\n-    ast_from_text(&format!(\"{}{}\", newlines, t.syntax()))\n-}\n-\n-pub fn add_trailing_newlines(amount_of_newlines: usize, t: impl AstNode) -> ast::SourceFile {\n-    let newlines = \"\\n\".repeat(amount_of_newlines);\n-    ast_from_text(&format!(\"{}{}\", t.syntax(), newlines))\n-}\n-\n-pub fn add_pub_crate_modifier(fn_def: ast::FnDef) -> ast::FnDef {\n-    ast_from_text(&format!(\"pub(crate) {}\", fn_def))\n+    let visibility = match visibility {\n+        None => String::new(),\n+        Some(it) => format!(\"{} \", it),\n+    };\n+    ast_from_text(&format!(\"{}fn {}{}{} {}\", visibility, fn_name, type_params, params, body))\n }\n \n fn ast_from_text<N: AstNode>(text: &str) -> N {"}, {"sha": "af54f81b7da558e7ce99dac952ed6d6c5056be81", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a36202390caff0ed97ff778cf4556fc00ddee70d/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a36202390caff0ed97ff778cf4556fc00ddee70d/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=a36202390caff0ed97ff778cf4556fc00ddee70d", "patch": "@@ -639,14 +639,15 @@ fn main() <fold>{\n }\n \n pub(crate) fn code_action(world: &WorldSnapshot, assist: Assist) -> Result<lsp_ext::CodeAction> {\n-    let res = if assist.source_change.is_snippet {\n+    let res = if assist.source_change.cursor_position.is_none() {\n         lsp_ext::CodeAction {\n             title: assist.label,\n             kind: Some(String::new()),\n             edit: Some(snippet_workspace_edit(world, assist.source_change)?),\n             command: None,\n         }\n     } else {\n+        assert!(!assist.source_change.is_snippet);\n         let source_change = source_change(&world, assist.source_change)?;\n         let arg = serde_json::to_value(source_change)?;\n         let title = assist.label;"}, {"sha": "71a57fba230f1ac05aa1c3b7fefc526986ab7577", "filename": "crates/stdx/src/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a36202390caff0ed97ff778cf4556fc00ddee70d/crates%2Fstdx%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a36202390caff0ed97ff778cf4556fc00ddee70d/crates%2Fstdx%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fstdx%2Fsrc%2Flib.rs?ref=a36202390caff0ed97ff778cf4556fc00ddee70d", "patch": "@@ -116,3 +116,11 @@ pub fn to_lower_snake_case(s: &str) -> String {\n     }\n     buf\n }\n+\n+pub fn replace(buf: &mut String, from: char, to: &str) {\n+    if !buf.contains(from) {\n+        return;\n+    }\n+    // FIXME: do this in place.\n+    *buf = buf.replace(from, to)\n+}"}, {"sha": "10ab67b2e72281aa1a5618c95e0792222f03662e", "filename": "docs/user/assists.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a36202390caff0ed97ff778cf4556fc00ddee70d/docs%2Fuser%2Fassists.md", "raw_url": "https://github.com/rust-lang/rust/raw/a36202390caff0ed97ff778cf4556fc00ddee70d/docs%2Fuser%2Fassists.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fassists.md?ref=a36202390caff0ed97ff778cf4556fc00ddee70d", "patch": "@@ -77,7 +77,7 @@ fn foo() {\n }\n \n fn bar(arg: &str, baz: Baz) {\n-    todo!()\n+    ${0:todo!()}\n }\n \n ```"}]}