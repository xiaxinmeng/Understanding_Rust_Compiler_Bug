{"sha": "f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxYjg4MmI1NTgwNWMzNDJlNDZlZTRjYTNiZWVlZjFkMWZhMjA0NGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-20T19:15:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-20T19:15:41Z"}, "message": "Auto merge of #66578 - Centril:rollup-pgz1v7t, r=Centril\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #66060 (Making ICEs and test them in incremental)\n - #66298 (rustdoc: fixes #64305: disable search field instead of hidding it)\n - #66457 (Just derive Hashstable in librustc)\n - #66496 (rustc_metadata: Privatize more things)\n - #66514 (Fix selected crate search filter)\n - #66535 (Avoid ICE when `break`ing to an unreachable label)\n - #66573 (Ignore run-make reproducible-build-2 on Mac)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "a76cffee5474f8b62ff9218cf85852304acd6cb4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a76cffee5474f8b62ff9218cf85852304acd6cb4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "html_url": "https://github.com/rust-lang/rust/commit/f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b9cf5417892ef242c783ef963deff5436205b0f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9cf5417892ef242c783ef963deff5436205b0f6", "html_url": "https://github.com/rust-lang/rust/commit/b9cf5417892ef242c783ef963deff5436205b0f6"}, {"sha": "8754409159112776e9da43c62e2e66bbfabf59ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/8754409159112776e9da43c62e2e66bbfabf59ab", "html_url": "https://github.com/rust-lang/rust/commit/8754409159112776e9da43c62e2e66bbfabf59ab"}], "stats": {"total": 1264, "additions": 590, "deletions": 674}, "files": [{"sha": "d5d66f899871049012046dbeda5dae8454a3f232", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -3719,6 +3719,7 @@ dependencies = [\n  \"rustc_errors\",\n  \"rustc_index\",\n  \"rustc_lexer\",\n+ \"rustc_macros\",\n  \"rustc_target\",\n  \"serialize\",\n  \"smallvec 1.0.0\","}, {"sha": "17ab0c187a2fc1c4a14c88c60dd6a4f63f55fa61", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -578,7 +578,7 @@ impl<'tcx> DepNodeParams<'tcx> for HirId {\n /// the need to be mapped or unmapped. (This ensures we can serialize\n /// them even in the absence of a tcx.)\n #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash,\n-         RustcEncodable, RustcDecodable)]\n+         RustcEncodable, RustcDecodable, HashStable)]\n pub struct WorkProductId {\n     hash: Fingerprint\n }\n@@ -599,7 +599,3 @@ impl WorkProductId {\n         }\n     }\n }\n-\n-impl_stable_hash_for!(struct crate::dep_graph::WorkProductId {\n-    hash\n-});"}, {"sha": "2b3bc37c87ccbe8a2e4c9f2d9d4c9a73d3f5e601", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -313,11 +313,9 @@ pub enum DefPathData {\n }\n \n #[derive(Copy, Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug,\n-         RustcEncodable, RustcDecodable)]\n+         RustcEncodable, RustcDecodable, HashStable)]\n pub struct DefPathHash(pub Fingerprint);\n \n-impl_stable_hash_for!(tuple_struct DefPathHash { fingerprint });\n-\n impl Borrow<Fingerprint> for DefPathHash {\n     #[inline]\n     fn borrow(&self) -> &Fingerprint {"}, {"sha": "465673082e50af32e59f6e9f31a962b62d26e54a", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -1215,7 +1215,7 @@ impl UnOp {\n }\n \n /// A statement.\n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(RustcEncodable, RustcDecodable, HashStable)]\n pub struct Stmt {\n     pub hir_id: HirId,\n     pub kind: StmtKind,"}, {"sha": "816e93698bce961ad6a2a483afc001633ea59995", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -140,13 +140,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Ty {\n \n impl_stable_hash_for_spanned!(hir::BinOpKind);\n \n-impl_stable_hash_for!(struct hir::Stmt {\n-    hir_id,\n-    kind,\n-    span,\n-});\n-\n-\n impl_stable_hash_for_spanned!(ast::Name);\n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::Expr {"}, {"sha": "fd8ccce6833522d3368e16704133f4ce220effc0", "filename": "src/librustc/infer/outlives/free_region_map.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -1,7 +1,7 @@\n use crate::ty::{self, Lift, TyCtxt, Region};\n use rustc_data_structures::transitive_relation::TransitiveRelation;\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Default)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Default, HashStable)]\n pub struct FreeRegionMap<'tcx> {\n     // Stores the relation `a < b`, where `a` and `b` are regions.\n     //\n@@ -89,10 +89,6 @@ fn is_free_or_static(r: Region<'_>) -> bool {\n     }\n }\n \n-impl_stable_hash_for!(struct FreeRegionMap<'tcx> {\n-    relation\n-});\n-\n impl<'a, 'tcx> Lift<'tcx> for FreeRegionMap<'a> {\n     type Lifted = FreeRegionMap<'tcx>;\n     fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<FreeRegionMap<'tcx>> {"}, {"sha": "d84102ff3c5d8caf07a6b37895cf9b397b210ce7", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -543,18 +543,11 @@ impl LintId {\n }\n \n /// Setting for how to handle a lint.\n-#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]\n+#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash, HashStable)]\n pub enum Level {\n     Allow, Warn, Deny, Forbid,\n }\n \n-impl_stable_hash_for!(enum self::Level {\n-    Allow,\n-    Warn,\n-    Deny,\n-    Forbid\n-});\n-\n impl Level {\n     /// Converts a level to a lower-case string.\n     pub fn as_str(self) -> &'static str {\n@@ -590,7 +583,7 @@ impl Level {\n }\n \n /// How a lint level was set.\n-#[derive(Clone, Copy, PartialEq, Eq)]\n+#[derive(Clone, Copy, PartialEq, Eq, HashStable)]\n pub enum LintSource {\n     /// Lint is at the default level as declared\n     /// in rustc or a plugin.\n@@ -603,12 +596,6 @@ pub enum LintSource {\n     CommandLine(Symbol),\n }\n \n-impl_stable_hash_for!(enum self::LintSource {\n-    Default,\n-    Node(name, span, reason),\n-    CommandLine(text)\n-});\n-\n pub type LevelSource = (Level, LintSource);\n \n pub mod builtin;"}, {"sha": "7182f031824025ae74579522461e017390f262c1", "filename": "src/librustc/middle/exported_symbols.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -11,17 +11,12 @@ use crate::ty::subst::SubstsRef;\n /// kind of crate, including cdylibs which export very few things.\n /// `Rust` will only be exported if the crate produced is a Rust\n /// dylib.\n-#[derive(Eq, PartialEq, Debug, Copy, Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Eq, PartialEq, Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub enum SymbolExportLevel {\n     C,\n     Rust,\n }\n \n-impl_stable_hash_for!(enum self::SymbolExportLevel {\n-    C,\n-    Rust\n-});\n-\n impl SymbolExportLevel {\n     pub fn is_below_threshold(self, threshold: SymbolExportLevel) -> bool {\n         threshold == SymbolExportLevel::Rust // export everything from Rust dylibs"}, {"sha": "c13c44c413d776fe45942b409b6ac7e21e2c4958", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -207,20 +207,14 @@ struct NamedRegionMap {\n }\n \n /// See [`NamedRegionMap`].\n-#[derive(Default)]\n+#[derive(Default, HashStable)]\n pub struct ResolveLifetimes {\n     defs: FxHashMap<LocalDefId, FxHashMap<ItemLocalId, Region>>,\n     late_bound: FxHashMap<LocalDefId, FxHashSet<ItemLocalId>>,\n     object_lifetime_defaults:\n         FxHashMap<LocalDefId, FxHashMap<ItemLocalId, Vec<ObjectLifetimeDefault>>>,\n }\n \n-impl_stable_hash_for!(struct crate::middle::resolve_lifetime::ResolveLifetimes {\n-    defs,\n-    late_bound,\n-    object_lifetime_defaults\n-});\n-\n struct LifetimeContext<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     map: &'a mut NamedRegionMap,"}, {"sha": "411a47423c5aa7c93f0917e49e0790756f83c63f", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -52,7 +52,7 @@ enum AnnotationKind {\n }\n \n /// An entry in the `depr_map`.\n-#[derive(Clone)]\n+#[derive(Clone, HashStable)]\n pub struct DeprecationEntry {\n     /// The metadata of the attribute associated with this entry.\n     pub attr: Deprecation,\n@@ -61,11 +61,6 @@ pub struct DeprecationEntry {\n     origin: Option<HirId>,\n }\n \n-impl_stable_hash_for!(struct self::DeprecationEntry {\n-    attr,\n-    origin\n-});\n-\n impl DeprecationEntry {\n     fn local(attr: Deprecation, id: HirId) -> DeprecationEntry {\n         DeprecationEntry {\n@@ -90,6 +85,7 @@ impl DeprecationEntry {\n }\n \n /// A stability index, giving the stability level for items and methods.\n+#[derive(HashStable)]\n pub struct Index<'tcx> {\n     /// This is mostly a cache, except the stabilities of local items\n     /// are filled by the annotator.\n@@ -103,13 +99,6 @@ pub struct Index<'tcx> {\n     active_features: FxHashSet<Symbol>,\n }\n \n-impl_stable_hash_for!(struct self::Index<'tcx> {\n-    stab_map,\n-    depr_map,\n-    staged_api,\n-    active_features\n-});\n-\n // A private tree-walker for producing an Index.\n struct Annotator<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,"}, {"sha": "f849361e08be9e0b0dbfd36267a8972af043e586", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -4,7 +4,6 @@ use super::{\n     Pointer, InterpResult, AllocId, ScalarMaybeUndef, write_target_uint, read_target_uint, Scalar,\n };\n \n-use crate::mir;\n use crate::ty::layout::{Size, Align};\n \n use rustc_data_structures::sorted_map::SortedMap;\n@@ -787,14 +786,13 @@ type Block = u64;\n \n /// A bitmask where each bit refers to the byte with the same index. If the bit is `true`, the byte\n /// is defined. If it is `false` the byte is undefined.\n-#[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash,\n+         RustcEncodable, RustcDecodable, HashStable)]\n pub struct UndefMask {\n     blocks: Vec<Block>,\n     len: Size,\n }\n \n-impl_stable_hash_for!(struct mir::interpret::UndefMask{blocks, len});\n-\n impl UndefMask {\n     pub const BLOCK_SIZE: u64 = 64;\n "}, {"sha": "52c72de7579e1e22f76ecb7c50355e2eba972986", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -458,7 +458,7 @@ impl<Tag> From<Pointer<Tag>> for Scalar<Tag> {\n     }\n }\n \n-#[derive(Clone, Copy, Eq, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, Eq, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n pub enum ScalarMaybeUndef<Tag = (), Id = AllocId> {\n     Scalar(Scalar<Tag, Id>),\n     Undef,\n@@ -583,11 +583,6 @@ impl<'tcx, Tag> ScalarMaybeUndef<Tag> {\n     }\n }\n \n-impl_stable_hash_for!(enum crate::mir::interpret::ScalarMaybeUndef {\n-    Scalar(v),\n-    Undef\n-});\n-\n /// Gets the bytes of a constant slice value.\n pub fn get_slice_bytes<'tcx>(cx: &impl HasDataLayout, val: ConstValue<'tcx>) -> &'tcx [u8] {\n     if let ConstValue::Slice { data, start, end } = val {"}, {"sha": "79468b68055d4e508a6698e6f32499f25887d576", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 8, "deletions": 54, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -70,7 +70,8 @@ impl<'tcx> HasLocalDecls<'tcx> for Body<'tcx> {\n /// The various \"big phases\" that MIR goes through.\n ///\n /// Warning: ordering of variants is significant.\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, HashStable,\n+         Debug, PartialEq, Eq, PartialOrd, Ord)]\n pub enum MirPhase {\n     Build = 0,\n     Const = 1,\n@@ -86,7 +87,7 @@ impl MirPhase {\n }\n \n /// The lowered representation of a single function.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, TypeFoldable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable, TypeFoldable)]\n pub struct Body<'tcx> {\n     /// A list of basic blocks. References to basic block use a newtyped index type `BasicBlock`\n     /// that indexes into this vector.\n@@ -412,24 +413,6 @@ pub enum Safety {\n     ExplicitUnsafe(hir::HirId),\n }\n \n-impl_stable_hash_for!(struct Body<'tcx> {\n-    phase,\n-    basic_blocks,\n-    source_scopes,\n-    source_scope_local_data,\n-    yield_ty,\n-    generator_drop,\n-    generator_layout,\n-    local_decls,\n-    user_type_annotations,\n-    arg_count,\n-    __upvar_debuginfo_codegen_only_do_not_use,\n-    spread_arg,\n-    control_flow_destroyed,\n-    span,\n-    cache\n-});\n-\n impl<'tcx> Index<BasicBlock> for Body<'tcx> {\n     type Output = BasicBlockData<'tcx>;\n \n@@ -609,7 +592,7 @@ pub enum LocalKind {\n     ReturnPointer,\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct VarBindingForm<'tcx> {\n     /// Is variable bound via `x`, `mut x`, `ref x`, or `ref mut x`?\n     pub binding_mode: ty::BindingMode,\n@@ -642,7 +625,7 @@ pub enum BindingForm<'tcx> {\n }\n \n /// Represents what type of implicit self a function has, if any.\n-#[derive(Clone, Copy, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub enum ImplicitSelfKind {\n     /// Represents a `fn x(self);`.\n     Imm,\n@@ -659,28 +642,6 @@ pub enum ImplicitSelfKind {\n \n CloneTypeFoldableAndLiftImpls! { BindingForm<'tcx>, }\n \n-impl_stable_hash_for!(struct self::VarBindingForm<'tcx> {\n-    binding_mode,\n-    opt_ty_info,\n-    opt_match_place,\n-    pat_span\n-});\n-\n-impl_stable_hash_for!(enum self::ImplicitSelfKind {\n-    Imm,\n-    Mut,\n-    ImmRef,\n-    MutRef,\n-    None\n-});\n-\n-impl_stable_hash_for!(enum self::MirPhase {\n-    Build,\n-    Const,\n-    Validated,\n-    Optimized,\n-});\n-\n mod binding_form_impl {\n     use crate::ich::StableHashingContext;\n     use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n@@ -707,7 +668,7 @@ mod binding_form_impl {\n /// involved in borrow_check errors, e.g., explanations of where the\n /// temporaries come from, when their destructors are run, and/or how\n /// one might revise the code to satisfy the borrow checker's rules.\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct BlockTailInfo {\n     /// If `true`, then the value resulting from evaluating this tail\n     /// expression is ignored by the block's expression context.\n@@ -717,8 +678,6 @@ pub struct BlockTailInfo {\n     pub tail_result_is_ignored: bool,\n }\n \n-impl_stable_hash_for!(struct BlockTailInfo { tail_result_is_ignored });\n-\n /// A MIR local.\n ///\n /// This can be a binding declared by the user, a temporary inserted by the compiler, a function\n@@ -1746,7 +1705,8 @@ pub enum PlaceBase<'tcx> {\n }\n \n /// We store the normalized type to avoid requiring normalization when reading MIR\n-#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash,\n+         RustcEncodable, RustcDecodable, HashStable)]\n pub struct Static<'tcx> {\n     pub ty: Ty<'tcx>,\n     pub kind: StaticKind<'tcx>,\n@@ -1768,12 +1728,6 @@ pub enum StaticKind<'tcx> {\n     Static,\n }\n \n-impl_stable_hash_for!(struct Static<'tcx> {\n-    ty,\n-    kind,\n-    def_id\n-});\n-\n #[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n #[derive(RustcEncodable, RustcDecodable, HashStable)]\n pub enum ProjectionElem<V, T> {"}, {"sha": "34daf185b29527e182d47ee790835f1ead8ec6e3", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -251,7 +251,7 @@ pub struct CodegenUnit<'tcx> {\n     size_estimate: Option<usize>,\n }\n \n-#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub enum Linkage {\n     External,\n     AvailableExternally,\n@@ -266,33 +266,13 @@ pub enum Linkage {\n     Common,\n }\n \n-impl_stable_hash_for!(enum self::Linkage {\n-    External,\n-    AvailableExternally,\n-    LinkOnceAny,\n-    LinkOnceODR,\n-    WeakAny,\n-    WeakODR,\n-    Appending,\n-    Internal,\n-    Private,\n-    ExternalWeak,\n-    Common\n-});\n-\n-#[derive(Copy, Clone, PartialEq, Debug)]\n+#[derive(Copy, Clone, PartialEq, Debug, HashStable)]\n pub enum Visibility {\n     Default,\n     Hidden,\n     Protected,\n }\n \n-impl_stable_hash_for!(enum self::Visibility {\n-    Default,\n-    Hidden,\n-    Protected\n-});\n-\n impl<'tcx> CodegenUnit<'tcx> {\n     pub fn new(name: Symbol) -> CodegenUnit<'tcx> {\n         CodegenUnit {"}, {"sha": "cd93fed8e1e0e7da1bd85e1538f5a2cd70c0db5a", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -29,6 +29,12 @@ use syntax_pos::symbol::Symbol;\n // Queries marked with `fatal_cycle` do not need the latter implementation,\n // as they will raise an fatal error on query cycles instead.\n rustc_queries! {\n+    Other {\n+        query trigger_delay_span_bug(key: DefId) -> () {\n+            desc { \"trigger a delay span bug\" }\n+        }\n+    }\n+\n     Other {\n         /// Records the type of every item.\n         query type_of(key: DefId) -> Ty<'tcx> {"}, {"sha": "785b4122d087359eee25fab69bd84cdc02c73ccf", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -79,7 +79,7 @@ impl<'cx, 'tcx> At<'cx, 'tcx> {\n     }\n }\n \n-#[derive(Clone, Debug, Default, TypeFoldable, Lift)]\n+#[derive(Clone, Debug, Default, HashStable, TypeFoldable, Lift)]\n pub struct DropckOutlivesResult<'tcx> {\n     pub kinds: Vec<GenericArg<'tcx>>,\n     pub overflows: Vec<Ty<'tcx>>,\n@@ -114,7 +114,7 @@ impl<'tcx> DropckOutlivesResult<'tcx> {\n \n /// A set of constraints that need to be satisfied in order for\n /// a type to be valid for destruction.\n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, HashStable)]\n pub struct DtorckConstraint<'tcx> {\n     /// Types that are required to be alive in order for this\n     /// type to be valid for destruction.\n@@ -152,15 +152,6 @@ impl<'tcx> FromIterator<DtorckConstraint<'tcx>> for DtorckConstraint<'tcx> {\n         result\n     }\n }\n-impl_stable_hash_for!(struct DropckOutlivesResult<'tcx> {\n-    kinds, overflows\n-});\n-\n-impl_stable_hash_for!(struct DtorckConstraint<'tcx> {\n-    outlives,\n-    dtorck_types,\n-    overflows\n-});\n \n /// This returns true if the type `ty` is \"trivial\" for\n /// dropck-outlives -- that is, if it doesn't require any types to"}, {"sha": "be846287e290c1a5a4b993efb3beacda8ba7fe40", "filename": "src/librustc/traits/query/method_autoderef.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -2,7 +2,7 @@ use rustc_data_structures::sync::Lrc;\n use crate::infer::canonical::{Canonical, QueryResponse};\n use crate::ty::Ty;\n \n-#[derive(Debug)]\n+#[derive(Debug, HashStable)]\n pub struct CandidateStep<'tcx> {\n     pub self_ty: Canonical<'tcx, QueryResponse<'tcx, Ty<'tcx>>>,\n     pub autoderefs: usize,\n@@ -15,7 +15,7 @@ pub struct CandidateStep<'tcx> {\n     pub unsize: bool,\n }\n \n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, HashStable)]\n pub struct MethodAutoderefStepsResult<'tcx> {\n     /// The valid autoderef steps that could be find.\n     pub steps: Lrc<Vec<CandidateStep<'tcx>>>,\n@@ -26,20 +26,8 @@ pub struct MethodAutoderefStepsResult<'tcx> {\n     pub reached_recursion_limit: bool,\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, HashStable)]\n pub struct MethodAutoderefBadTy<'tcx> {\n     pub reached_raw_pointer: bool,\n     pub ty: Canonical<'tcx, QueryResponse<'tcx, Ty<'tcx>>>,\n }\n-\n-impl_stable_hash_for!(struct MethodAutoderefBadTy<'tcx> {\n-    reached_raw_pointer, ty\n-});\n-\n-impl_stable_hash_for!(struct MethodAutoderefStepsResult<'tcx> {\n-    reached_recursion_limit, steps, opt_bad_ty\n-});\n-\n-impl_stable_hash_for!(struct CandidateStep<'tcx> {\n-    self_ty, autoderefs, from_unsafe_deref, unsize\n-});"}, {"sha": "66683cab95960409216a1a795d78c018b6d31c9a", "filename": "src/librustc/traits/query/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -40,7 +40,7 @@ pub type CanonicalTypeOpProvePredicateGoal<'tcx> =\n pub type CanonicalTypeOpNormalizeGoal<'tcx, T> =\n     Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::normalize::Normalize<T>>>;\n \n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, HashStable)]\n pub struct NoSolution;\n \n pub type Fallible<T> = Result<T, NoSolution>;\n@@ -50,5 +50,3 @@ impl<'tcx> From<TypeError<'tcx>> for NoSolution {\n         NoSolution\n     }\n }\n-\n-impl_stable_hash_for!(struct NoSolution { });"}, {"sha": "09c7f45c22b0a32f364de4dcda1b3b658950f4e3", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -66,7 +66,7 @@ impl<'cx, 'tcx> At<'cx, 'tcx> {\n }\n \n /// Result from the `normalize_projection_ty` query.\n-#[derive(Clone, Debug, TypeFoldable, Lift)]\n+#[derive(Clone, Debug, HashStable, TypeFoldable, Lift)]\n pub struct NormalizationResult<'tcx> {\n     /// Result of normalization.\n     pub normalized_ty: Ty<'tcx>,\n@@ -193,7 +193,3 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n         constant.eval(self.infcx.tcx, self.param_env)\n     }\n }\n-\n-impl_stable_hash_for!(struct NormalizationResult<'tcx> {\n-    normalized_ty\n-});"}, {"sha": "ee8b73f86a61a033520a68361326684dc1123675", "filename": "src/librustc/traits/query/type_op/ascribe_user_type.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -4,7 +4,7 @@ use crate::hir::def_id::DefId;\n use crate::ty::{ParamEnvAnd, Ty, TyCtxt};\n use crate::ty::subst::UserSubsts;\n \n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, TypeFoldable, Lift)]\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable, TypeFoldable, Lift)]\n pub struct AscribeUserType<'tcx> {\n     pub mir_ty: Ty<'tcx>,\n     pub def_id: DefId,\n@@ -38,9 +38,3 @@ impl<'tcx> super::QueryTypeOp<'tcx> for AscribeUserType<'tcx> {\n         tcx.type_op_ascribe_user_type(canonicalized)\n     }\n }\n-\n-impl_stable_hash_for! {\n-    struct AscribeUserType<'tcx> {\n-        mir_ty, def_id, user_substs\n-    }\n-}"}, {"sha": "8ea800cced2134a351b7b541032305748b4830ae", "filename": "src/librustc/traits/query/type_op/eq.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -2,7 +2,7 @@ use crate::infer::canonical::{Canonicalized, CanonicalizedQueryResponse};\n use crate::traits::query::Fallible;\n use crate::ty::{ParamEnvAnd, Ty, TyCtxt};\n \n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, TypeFoldable, Lift)]\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable, TypeFoldable, Lift)]\n pub struct Eq<'tcx> {\n     pub a: Ty<'tcx>,\n     pub b: Ty<'tcx>,\n@@ -35,7 +35,3 @@ impl<'tcx> super::QueryTypeOp<'tcx> for Eq<'tcx> {\n         tcx.type_op_eq(canonicalized)\n     }\n }\n-\n-impl_stable_hash_for! {\n-    struct Eq<'tcx> { a, b }\n-}"}, {"sha": "6f45d76a8e9d7d9b4ffd23a06848aa7195de5613", "filename": "src/librustc/traits/query/type_op/implied_outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -3,7 +3,7 @@ use crate::traits::query::outlives_bounds::OutlivesBound;\n use crate::traits::query::Fallible;\n use crate::ty::{ParamEnvAnd, Ty, TyCtxt};\n \n-#[derive(Clone, Debug, TypeFoldable, Lift)]\n+#[derive(Clone, Debug, HashStable, TypeFoldable, Lift)]\n pub struct ImpliedOutlivesBounds<'tcx> {\n     pub ty: Ty<'tcx>,\n }\n@@ -39,7 +39,3 @@ impl<'tcx> super::QueryTypeOp<'tcx> for ImpliedOutlivesBounds<'tcx> {\n         tcx.implied_outlives_bounds(canonicalized)\n     }\n }\n-\n-impl_stable_hash_for! {\n-    struct ImpliedOutlivesBounds<'tcx> { ty }\n-}"}, {"sha": "f905d5a019ec8c3d30a2a608a91ecc5669fe7a4a", "filename": "src/librustc/traits/query/type_op/normalize.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -4,7 +4,7 @@ use crate::traits::query::Fallible;\n use crate::ty::fold::TypeFoldable;\n use crate::ty::{self, Lift, ParamEnvAnd, Ty, TyCtxt};\n \n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, TypeFoldable, Lift)]\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable, TypeFoldable, Lift)]\n pub struct Normalize<T> {\n     pub value: T,\n }\n@@ -82,9 +82,3 @@ impl Normalizable<'tcx> for ty::FnSig<'tcx> {\n         tcx.type_op_normalize_fn_sig(canonicalized)\n     }\n }\n-\n-impl_stable_hash_for! {\n-    impl<T> for struct Normalize<T> {\n-        value\n-    }\n-}"}, {"sha": "83d51b6d3ebf78500cd227dd13080ebe078d2455", "filename": "src/librustc/traits/query/type_op/outlives.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -3,7 +3,7 @@ use crate::traits::query::dropck_outlives::{DropckOutlivesResult, trivial_dropck\n use crate::traits::query::Fallible;\n use crate::ty::{ParamEnvAnd, Ty, TyCtxt};\n \n-#[derive(Copy, Clone, Debug, TypeFoldable, Lift)]\n+#[derive(Copy, Clone, Debug, HashStable, TypeFoldable, Lift)]\n pub struct DropckOutlives<'tcx> {\n     dropped_ty: Ty<'tcx>,\n }\n@@ -53,7 +53,3 @@ impl super::QueryTypeOp<'tcx> for DropckOutlives<'tcx> {\n         tcx.dropck_outlives(canonicalized)\n     }\n }\n-\n-impl_stable_hash_for! {\n-    struct DropckOutlives<'tcx> { dropped_ty }\n-}"}, {"sha": "c0a0cbe9a3876029ae201bd03874ed69639de6d8", "filename": "src/librustc/traits/query/type_op/prove_predicate.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -2,7 +2,7 @@ use crate::infer::canonical::{Canonicalized, CanonicalizedQueryResponse};\n use crate::traits::query::Fallible;\n use crate::ty::{ParamEnvAnd, Predicate, TyCtxt};\n \n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, TypeFoldable, Lift)]\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable, TypeFoldable, Lift)]\n pub struct ProvePredicate<'tcx> {\n     pub predicate: Predicate<'tcx>,\n }\n@@ -44,7 +44,3 @@ impl<'tcx> super::QueryTypeOp<'tcx> for ProvePredicate<'tcx> {\n         tcx.type_op_prove_predicate(canonicalized)\n     }\n }\n-\n-impl_stable_hash_for! {\n-    struct ProvePredicate<'tcx> { predicate }\n-}"}, {"sha": "76292f9dea085cc29425c9e2a7da6c07c52e2b09", "filename": "src/librustc/traits/query/type_op/subtype.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -2,7 +2,7 @@ use crate::infer::canonical::{Canonicalized, CanonicalizedQueryResponse};\n use crate::traits::query::Fallible;\n use crate::ty::{ParamEnvAnd, Ty, TyCtxt};\n \n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, TypeFoldable, Lift)]\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable, TypeFoldable, Lift)]\n pub struct Subtype<'tcx> {\n     pub sub: Ty<'tcx>,\n     pub sup: Ty<'tcx>,\n@@ -35,7 +35,3 @@ impl<'tcx> super::QueryTypeOp<'tcx> for Subtype<'tcx> {\n         tcx.type_op_subtype(canonicalized)\n     }\n }\n-\n-impl_stable_hash_for! {\n-    struct Subtype<'tcx> { sub, sup }\n-}"}, {"sha": "ffc94cf2b125eb870905c98e4f9bdb64b79dfa3c", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -367,7 +367,6 @@ enum BuiltinImplConditions<'tcx> {\n     Ambiguous,\n }\n \n-#[derive(Copy, Clone, Debug, PartialOrd, Ord, PartialEq, Eq)]\n /// The result of trait evaluation. The order is important\n /// here as the evaluation of a list is the maximum of the\n /// evaluations.\n@@ -380,6 +379,7 @@ enum BuiltinImplConditions<'tcx> {\n ///     all the \"potential success\" candidates can potentially succeed,\n ///     so they are noops when unioned with a definite error, and within\n ///     the categories it's easy to see that the unions are correct.\n+#[derive(Copy, Clone, Debug, PartialOrd, Ord, PartialEq, Eq, HashStable)]\n pub enum EvaluationResult {\n     /// Evaluation successful\n     EvaluatedToOk,\n@@ -478,21 +478,10 @@ impl EvaluationResult {\n     }\n }\n \n-impl_stable_hash_for!(enum self::EvaluationResult {\n-    EvaluatedToOk,\n-    EvaluatedToOkModuloRegions,\n-    EvaluatedToAmbig,\n-    EvaluatedToUnknown,\n-    EvaluatedToRecur,\n-    EvaluatedToErr\n-});\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n /// Indicates that trait evaluation caused overflow.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, HashStable)]\n pub struct OverflowError;\n \n-impl_stable_hash_for!(struct OverflowError {});\n-\n impl<'tcx> From<OverflowError> for SelectionError<'tcx> {\n     fn from(OverflowError: OverflowError) -> SelectionError<'tcx> {\n         SelectionError::Overflow"}, {"sha": "d945c756f6662d1045b8f333528c597273513a5c", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -24,7 +24,7 @@ use crate::util::nodemap::{DefIdMap, FxHashMap};\n ///   parents of a given specializing impl, which is needed for extracting\n ///   default items amongst other things. In the simple \"chain\" rule, every impl\n ///   has at most one parent.\n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(RustcEncodable, RustcDecodable, HashStable)]\n pub struct Graph {\n     // All impls have a parent; the \"root\" impls have as their parent the `def_id`\n     // of the trait.\n@@ -535,8 +535,3 @@ impl<'a> HashStable<StableHashingContext<'a>> for Children {\n         ich::hash_stable_trait_impls(hcx, hasher, blanket_impls, nonblanket_impls);\n     }\n }\n-\n-impl_stable_hash_for!(struct self::Graph {\n-    parent,\n-    children\n-});"}, {"sha": "491e09dff09506561cbbf5d09e447aa3565bf018", "filename": "src/librustc/ty/binding.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Fty%2Fbinding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Fty%2Fbinding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fbinding.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -2,7 +2,7 @@ use crate::hir::BindingAnnotation::*;\n use crate::hir::BindingAnnotation;\n use crate::hir::Mutability;\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, HashStable)]\n pub enum BindingMode {\n     BindByReference(Mutability),\n     BindByValue(Mutability),\n@@ -20,8 +20,3 @@ impl BindingMode {\n         }\n     }\n }\n-\n-impl_stable_hash_for!(enum self::BindingMode {\n-    BindByReference(mutability),\n-    BindByValue(mutability)\n-});"}, {"sha": "a54bf5079cac4f189f7ec0510625752b037d84dc", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 7, "deletions": 32, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -1590,12 +1590,11 @@ rustc_index::newtype_index! {\n     /// type -- an idealized representative of \"types in general\" that we\n     /// use for checking generic functions.\n     pub struct UniverseIndex {\n+        derive [HashStable]\n         DEBUG_FORMAT = \"U{}\",\n     }\n }\n \n-impl_stable_hash_for!(struct UniverseIndex { private });\n-\n impl UniverseIndex {\n     pub const ROOT: UniverseIndex = UniverseIndex::from_u32_const(0);\n \n@@ -1839,7 +1838,7 @@ bitflags! {\n }\n \n /// Definition of a variant -- a struct's fields or a enum variant.\n-#[derive(Debug)]\n+#[derive(Debug, HashStable)]\n pub struct VariantDef {\n     /// `DefId` that identifies the variant itself.\n     /// If this variant belongs to a struct or union, then this is a copy of its `DefId`.\n@@ -1848,6 +1847,7 @@ pub struct VariantDef {\n     /// If this variant is a struct variant, then this is `None`.\n     pub ctor_def_id: Option<DefId>,\n     /// Variant or struct name.\n+    #[stable_hasher(project(name))]\n     pub ident: Ident,\n     /// Discriminant of this variant.\n     pub discr: VariantDiscr,\n@@ -1927,17 +1927,6 @@ impl<'tcx> VariantDef {\n     }\n }\n \n-impl_stable_hash_for!(struct VariantDef {\n-    def_id,\n-    ctor_def_id,\n-    ident -> (ident.name),\n-    discr,\n-    fields,\n-    ctor_kind,\n-    flags,\n-    recovered\n-});\n-\n #[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n pub enum VariantDiscr {\n     /// Explicit value for this variant, i.e., `X = 123`.\n@@ -2061,7 +2050,7 @@ impl Into<DataTypeKind> for AdtKind {\n }\n \n bitflags! {\n-    #[derive(RustcEncodable, RustcDecodable, Default)]\n+    #[derive(RustcEncodable, RustcDecodable, Default, HashStable)]\n     pub struct ReprFlags: u8 {\n         const IS_C               = 1 << 0;\n         const IS_SIMD            = 1 << 1;\n@@ -2076,26 +2065,16 @@ bitflags! {\n     }\n }\n \n-impl_stable_hash_for!(struct ReprFlags {\n-    bits\n-});\n-\n /// Represents the repr options provided by the user,\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, RustcEncodable, RustcDecodable, Default)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, RustcEncodable, RustcDecodable,\n+         Default, HashStable)]\n pub struct ReprOptions {\n     pub int: Option<attr::IntType>,\n     pub align: Option<Align>,\n     pub pack: Option<Align>,\n     pub flags: ReprFlags,\n }\n \n-impl_stable_hash_for!(struct ReprOptions {\n-    align,\n-    pack,\n-    int,\n-    flags\n-});\n-\n impl ReprOptions {\n     pub fn new(tcx: TyCtxt<'_>, did: DefId) -> ReprOptions {\n         let mut flags = ReprFlags::empty();\n@@ -3439,17 +3418,13 @@ pub struct CrateInherentImpls {\n     pub inherent_impls: DefIdMap<Vec<DefId>>,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n pub struct SymbolName {\n     // FIXME: we don't rely on interning or equality here - better have\n     // this be a `&'tcx str`.\n     pub name: Symbol\n }\n \n-impl_stable_hash_for!(struct self::SymbolName {\n-    name\n-});\n-\n impl SymbolName {\n     pub fn new(name: &str) -> SymbolName {\n         SymbolName {"}, {"sha": "07258717cd9d4a668dc9769545f7fe33da3146e2", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -1204,6 +1204,7 @@ rustc_index::newtype_index! {\n     /// is the outer fn.\n     ///\n     /// [dbi]: http://en.wikipedia.org/wiki/De_Bruijn_index\n+    #[derive(HashStable)]\n     pub struct DebruijnIndex {\n         DEBUG_FORMAT = \"DebruijnIndex({})\",\n         const INNERMOST = 0,\n@@ -1379,21 +1380,20 @@ rustc_index::newtype_index! {\n     pub struct BoundVar { .. }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug,\n+         RustcEncodable, RustcDecodable, HashStable)]\n pub struct BoundTy {\n     pub var: BoundVar,\n     pub kind: BoundTyKind,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug,\n+         RustcEncodable, RustcDecodable, HashStable)]\n pub enum BoundTyKind {\n     Anon,\n     Param(Symbol),\n }\n \n-impl_stable_hash_for!(struct BoundTy { var, kind });\n-impl_stable_hash_for!(enum self::BoundTyKind { Anon, Param(a) });\n-\n impl From<BoundVar> for BoundTy {\n     fn from(var: BoundVar) -> Self {\n         BoundTy {\n@@ -1518,8 +1518,6 @@ impl DebruijnIndex {\n     }\n }\n \n-impl_stable_hash_for!(struct DebruijnIndex { private });\n-\n /// Region utilities\n impl RegionKind {\n     /// Is this region named by the user?"}, {"sha": "fb2099e71a31a136597f853f93f18dba1d50bdd0", "filename": "src/librustc_codegen_utils/lib.rs", "status": "modified", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc_codegen_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc_codegen_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Flib.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -19,26 +19,58 @@ extern crate rustc;\n \n use rustc::ty::TyCtxt;\n use rustc::ty::query::Providers;\n-use rustc::hir::def_id::LOCAL_CRATE;\n+use rustc::hir::def_id::{LOCAL_CRATE, DefId};\n use syntax::symbol::sym;\n \n pub mod link;\n pub mod codegen_backend;\n pub mod symbol_names;\n pub mod symbol_names_test;\n \n+\n+pub fn trigger_delay_span_bug(tcx: TyCtxt<'_>, key: DefId) {\n+    tcx.sess.delay_span_bug(\n+        tcx.def_span(key),\n+        \"delayed span bug triggered by #[rustc_error(delay_span_bug_from_inside_query)]\"\n+    );\n+}\n+\n /// check for the #[rustc_error] annotation, which forces an\n /// error in codegen. This is used to write compile-fail tests\n /// that actually test that compilation succeeds without\n /// reporting an error.\n pub fn check_for_rustc_errors_attr(tcx: TyCtxt<'_>) {\n     if let Some((def_id, _)) = tcx.entry_fn(LOCAL_CRATE) {\n-        if tcx.has_attr(def_id, sym::rustc_error) {\n-            tcx.sess.span_fatal(tcx.def_span(def_id), \"compilation successful\");\n+        let attrs = &*tcx.get_attrs(def_id);\n+        for attr in attrs {\n+            if attr.check_name(sym::rustc_error) {\n+                match attr.meta_item_list() {\n+                    // check if there is a #[rustc_error(delayed)]\n+                    Some(list) => {\n+                        if list.iter().any(|list_item| {\n+                            list_item.ident().map(|i| i.name) ==\n+                                Some(sym::delay_span_bug_from_inside_query)\n+                        }) {\n+                            tcx.ensure().trigger_delay_span_bug(def_id);\n+                        }\n+                    }\n+                    // bare #[rustc_error]\n+                    None => {\n+                        tcx.sess.span_fatal(\n+                            tcx.def_span(def_id),\n+                            \"fatal error triggered by #[rustc_error]\"\n+                        );\n+                    }\n+                }\n+            }\n         }\n     }\n }\n \n pub fn provide(providers: &mut Providers<'_>) {\n     crate::symbol_names::provide(providers);\n+    *providers = Providers {\n+        trigger_delay_span_bug,\n+        ..*providers\n+    };\n }"}, {"sha": "a721e381b4e9971ef560a7e374d4daea9d29d73c", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 51, "deletions": 81, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -1,21 +1,17 @@\n //! Validates all used crates and extern libraries and loads their metadata\n \n-use crate::cstore::{self, CStore, MetadataBlob};\n-use crate::locator::{self, CratePaths};\n-use crate::rmeta::{CrateRoot, CrateDep};\n-use rustc_data_structures::sync::{Lock, Once, AtomicCell};\n+use crate::cstore::CStore;\n+use crate::locator::{CrateLocator, CratePaths};\n+use crate::rmeta::{CrateMetadata, CrateNumMap, CrateRoot, CrateDep, MetadataBlob};\n \n use rustc::hir::def_id::CrateNum;\n use rustc_data_structures::svh::Svh;\n-use rustc::dep_graph::DepNodeIndex;\n use rustc::middle::cstore::DepKind;\n-use rustc::mir::interpret::AllocDecodingState;\n use rustc::session::{Session, CrateDisambiguator};\n use rustc::session::config::{Sanitizer, self};\n use rustc_target::spec::{PanicStrategy, TargetTriple};\n use rustc::session::search_paths::PathKind;\n use rustc::middle::cstore::{CrateSource, ExternCrate, ExternCrateSource, MetadataLoaderDyn};\n-use rustc::util::common::record_time;\n use rustc::util::nodemap::FxHashSet;\n use rustc::hir::map::Definitions;\n use rustc::hir::def_id::LOCAL_CRATE;\n@@ -50,9 +46,9 @@ pub struct CrateLoader<'a> {\n \n fn dump_crates(cstore: &CStore) {\n     info!(\"resolved crates:\");\n-    cstore.iter_crate_data(|_, data| {\n+    cstore.iter_crate_data(|cnum, data| {\n         info!(\"  name: {}\", data.root.name);\n-        info!(\"  cnum: {}\", data.cnum);\n+        info!(\"  cnum: {}\", cnum);\n         info!(\"  hash: {}\", data.root.hash);\n         info!(\"  reqd: {:?}\", *data.dep_kind.lock());\n         let CrateSource { dylib, rlib, rmeta } = data.source.clone();\n@@ -68,13 +64,13 @@ enum LoadResult {\n }\n \n enum LoadError<'a> {\n-    LocatorError(locator::Context<'a>),\n+    LocatorError(CrateLocator<'a>),\n }\n \n impl<'a> LoadError<'a> {\n     fn report(self) -> ! {\n         match self {\n-            LoadError::LocatorError(locate_ctxt) => locate_ctxt.report_errs(),\n+            LoadError::LocatorError(locator) => locator.report_errs(),\n         }\n     }\n }\n@@ -145,7 +141,7 @@ impl<'a> CrateLoader<'a> {\n             let prev_kind = source.dylib.as_ref().or(source.rlib.as_ref())\n                                   .or(source.rmeta.as_ref())\n                                   .expect(\"No sources for crate\").1;\n-            if ret.is_none() && (prev_kind == kind || prev_kind == PathKind::All) {\n+            if kind.matches(prev_kind) {\n                 ret = Some(cnum);\n             }\n         });\n@@ -211,71 +207,52 @@ impl<'a> CrateLoader<'a> {\n         let root = if let Some(root) = root {\n             root\n         } else {\n-            crate_paths = CratePaths { name: crate_root.name, source: source.clone() };\n+            crate_paths = CratePaths::new(crate_root.name, source.clone());\n             &crate_paths\n         };\n \n         let cnum_map = self.resolve_crate_deps(root, &crate_root, &metadata, cnum, span, dep_kind);\n \n-        let dependencies: Vec<CrateNum> = cnum_map.iter().cloned().collect();\n-\n-        let raw_proc_macros =  crate_root.proc_macro_data.map(|_| {\n+        let raw_proc_macros = if crate_root.is_proc_macro_crate() {\n             let temp_root;\n             let (dlsym_source, dlsym_root) = match &host_lib {\n                 Some(host_lib) =>\n                     (&host_lib.source, { temp_root = host_lib.metadata.get_root(); &temp_root }),\n                 None => (&source, &crate_root),\n             };\n             let dlsym_dylib = dlsym_source.dylib.as_ref().expect(\"no dylib for a proc-macro crate\");\n-            self.dlsym_proc_macros(&dlsym_dylib.0, dlsym_root.disambiguator, span)\n-        });\n-\n-        let interpret_alloc_index: Vec<u32> = crate_root.interpret_alloc_index\n-                                                        .decode(&metadata)\n-                                                        .collect();\n-        let trait_impls = crate_root\n-            .impls\n-            .decode((&metadata, self.sess))\n-            .map(|trait_impls| (trait_impls.trait_id, trait_impls.impls))\n-            .collect();\n-\n-        let def_path_table = record_time(&self.sess.perf_stats.decode_def_path_tables_time, || {\n-            crate_root.def_path_table.decode((&metadata, self.sess))\n-        });\n+            Some(self.dlsym_proc_macros(&dlsym_dylib.0, dlsym_root.disambiguator, span))\n+        } else {\n+            None\n+        };\n \n-        self.cstore.set_crate_data(cnum, cstore::CrateMetadata {\n-            extern_crate: Lock::new(None),\n-            def_path_table,\n-            trait_impls,\n-            root: crate_root,\n-            host_hash,\n-            blob: metadata,\n-            cnum_map,\n+        self.cstore.set_crate_data(cnum, CrateMetadata::new(\n+            self.sess,\n+            metadata,\n+            crate_root,\n+            raw_proc_macros,\n             cnum,\n-            dependencies: Lock::new(dependencies),\n-            source_map_import_info: Once::new(),\n-            alloc_decoding_state: AllocDecodingState::new(interpret_alloc_index),\n-            dep_kind: Lock::new(dep_kind),\n+            cnum_map,\n+            dep_kind,\n             source,\n             private_dep,\n-            raw_proc_macros,\n-            dep_node_index: AtomicCell::new(DepNodeIndex::INVALID),\n-        });\n+            host_hash,\n+        ));\n \n         cnum\n     }\n \n     fn load_proc_macro<'b>(\n         &self,\n-        locate_ctxt: &mut locator::Context<'b>,\n+        locator: &mut CrateLocator<'b>,\n         path_kind: PathKind,\n     ) -> Option<(LoadResult, Option<Library>)>\n     where\n         'a: 'b,\n     {\n-        // Use a new locator Context so trying to load a proc macro doesn't affect the error\n+        // Use a new crate locator so trying to load a proc macro doesn't affect the error\n         // message we emit\n-        let mut proc_macro_locator = locate_ctxt.clone();\n+        let mut proc_macro_locator = locator.clone();\n \n         // Try to load a proc macro\n         proc_macro_locator.is_proc_macro = Some(true);\n@@ -287,10 +264,10 @@ impl<'a> CrateLoader<'a> {\n                 LoadResult::Previous(cnum) => return Some((LoadResult::Previous(cnum), None)),\n                 LoadResult::Loaded(library) => Some(LoadResult::Loaded(library))\n             };\n-            locate_ctxt.hash = locate_ctxt.host_hash;\n-            // Use the locate_ctxt when looking for the host proc macro crate, as that is required\n+            locator.hash = locator.host_hash;\n+            // Use the locator when looking for the host proc macro crate, as that is required\n             // so we want it to affect the error message\n-            (locate_ctxt, result)\n+            (locator, result)\n         } else {\n             (&mut proc_macro_locator, None)\n         };\n@@ -350,37 +327,30 @@ impl<'a> CrateLoader<'a> {\n             (LoadResult::Previous(cnum), None)\n         } else {\n             info!(\"falling back to a load\");\n-            let mut locate_ctxt = locator::Context {\n-                sess: self.sess,\n-                span,\n-                crate_name: name,\n+            let mut locator = CrateLocator::new(\n+                self.sess,\n+                self.metadata_loader,\n+                name,\n                 hash,\n                 host_hash,\n                 extra_filename,\n-                filesearch: self.sess.target_filesearch(path_kind),\n-                target: &self.sess.target.target,\n-                triple: self.sess.opts.target_triple.clone(),\n+                false, // is_host\n+                path_kind,\n+                span,\n                 root,\n-                rejected_via_hash: vec![],\n-                rejected_via_triple: vec![],\n-                rejected_via_kind: vec![],\n-                rejected_via_version: vec![],\n-                rejected_via_filename: vec![],\n-                should_match_name: true,\n-                is_proc_macro: Some(false),\n-                metadata_loader: self.metadata_loader,\n-            };\n+                Some(false), // is_proc_macro\n+            );\n \n-            self.load(&mut locate_ctxt).map(|r| (r, None)).or_else(|| {\n+            self.load(&mut locator).map(|r| (r, None)).or_else(|| {\n                 dep_kind = DepKind::UnexportedMacrosOnly;\n-                self.load_proc_macro(&mut locate_ctxt, path_kind)\n-            }).ok_or_else(move || LoadError::LocatorError(locate_ctxt))?\n+                self.load_proc_macro(&mut locator, path_kind)\n+            }).ok_or_else(move || LoadError::LocatorError(locator))?\n         };\n \n         match result {\n             (LoadResult::Previous(cnum), None) => {\n                 let data = self.cstore.get_crate_data(cnum);\n-                if data.root.proc_macro_data.is_some() {\n+                if data.root.is_proc_macro_crate() {\n                     dep_kind = DepKind::UnexportedMacrosOnly;\n                 }\n                 data.dep_kind.with_lock(|data_dep_kind| {\n@@ -395,8 +365,8 @@ impl<'a> CrateLoader<'a> {\n         }\n     }\n \n-    fn load(&self, locate_ctxt: &mut locator::Context<'_>) -> Option<LoadResult> {\n-        let library = locate_ctxt.maybe_load_library_crate()?;\n+    fn load(&self, locator: &mut CrateLocator<'_>) -> Option<LoadResult> {\n+        let library = locator.maybe_load_library_crate()?;\n \n         // In the case that we're loading a crate, but not matching\n         // against a hash, we could load a crate which has the same hash\n@@ -407,11 +377,11 @@ impl<'a> CrateLoader<'a> {\n         // don't want to match a host crate against an equivalent target one\n         // already loaded.\n         let root = library.metadata.get_root();\n-        if locate_ctxt.triple == self.sess.opts.target_triple {\n+        if locator.triple == self.sess.opts.target_triple {\n             let mut result = LoadResult::Loaded(library);\n             self.cstore.iter_crate_data(|cnum, data| {\n                 if data.root.name == root.name && root.hash == data.root.hash {\n-                    assert!(locate_ctxt.hash.is_none());\n+                    assert!(locator.hash.is_none());\n                     info!(\"load success, going to previous cnum: {}\", cnum);\n                     result = LoadResult::Previous(cnum);\n                 }\n@@ -471,16 +441,16 @@ impl<'a> CrateLoader<'a> {\n                           krate: CrateNum,\n                           span: Span,\n                           dep_kind: DepKind)\n-                          -> cstore::CrateNumMap {\n+                          -> CrateNumMap {\n         debug!(\"resolving deps of external crate\");\n-        if crate_root.proc_macro_data.is_some() {\n-            return cstore::CrateNumMap::new();\n+        if crate_root.is_proc_macro_crate() {\n+            return CrateNumMap::new();\n         }\n \n         // The map from crate numbers in the crate we're resolving to local crate numbers.\n         // We map 0 and all other holes in the map to our parent crate. The \"additional\"\n         // self-dependencies should be harmless.\n-        std::iter::once(krate).chain(crate_root.crate_deps.decode(metadata).map(|dep| {\n+        std::iter::once(krate).chain(crate_root.decode_crate_deps(metadata).map(|dep| {\n             info!(\"resolving dep crate {} hash: `{}` extra filename: `{}`\", dep.name, dep.hash,\n                   dep.extra_filename);\n             if dep.kind == DepKind::UnexportedMacrosOnly {\n@@ -824,7 +794,7 @@ impl<'a> CrateLoader<'a> {\n     fn inject_dependency_if(&self,\n                             krate: CrateNum,\n                             what: &str,\n-                            needs_dep: &dyn Fn(&cstore::CrateMetadata) -> bool) {\n+                            needs_dep: &dyn Fn(&CrateMetadata) -> bool) {\n         // don't perform this validation if the session has errors, as one of\n         // those errors may indicate a circular dependency which could cause\n         // this to stack overflow."}, {"sha": "48cf0b982f2902192775ab755f8aff95d852c59c", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 7, "deletions": 93, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -1,109 +1,23 @@\n // The crate store - a central repo for information collected about external\n // crates and libraries\n \n-use crate::rmeta;\n-use rustc::dep_graph::DepNodeIndex;\n-use rustc::hir::def_id::{CrateNum, DefIndex};\n-use rustc::hir::map::definitions::DefPathTable;\n-use rustc::middle::cstore::{CrateSource, DepKind, ExternCrate};\n-use rustc::mir::interpret::AllocDecodingState;\n+use crate::rmeta::CrateMetadata;\n+\n+use rustc_data_structures::sync::Lrc;\n use rustc_index::vec::IndexVec;\n-use rustc::util::nodemap::FxHashMap;\n-use rustc_data_structures::sync::{Lrc, Lock, MetadataRef, Once, AtomicCell};\n-use rustc_data_structures::svh::Svh;\n+use rustc::hir::def_id::CrateNum;\n use syntax::ast;\n use syntax::edition::Edition;\n-use syntax_expand::base::SyntaxExtension;\n use syntax::expand::allocator::AllocatorKind;\n-use syntax_pos;\n-use proc_macro::bridge::client::ProcMacro;\n+use syntax_expand::base::SyntaxExtension;\n \n pub use crate::rmeta::{provide, provide_extern};\n \n-// A map from external crate numbers (as decoded from some crate file) to\n-// local crate numbers (as generated during this session). Each external\n-// crate may refer to types in other external crates, and each has their\n-// own crate numbers.\n-crate type CrateNumMap = IndexVec<CrateNum, CrateNum>;\n-\n-crate struct MetadataBlob(pub MetadataRef);\n-\n-/// Holds information about a syntax_pos::SourceFile imported from another crate.\n-/// See `imported_source_files()` for more information.\n-crate struct ImportedSourceFile {\n-    /// This SourceFile's byte-offset within the source_map of its original crate\n-    pub original_start_pos: syntax_pos::BytePos,\n-    /// The end of this SourceFile within the source_map of its original crate\n-    pub original_end_pos: syntax_pos::BytePos,\n-    /// The imported SourceFile's representation within the local source_map\n-    pub translated_source_file: Lrc<syntax_pos::SourceFile>,\n-}\n-\n-crate struct CrateMetadata {\n-    /// The primary crate data - binary metadata blob.\n-    crate blob: MetadataBlob,\n-\n-    // --- Some data pre-decoded from the metadata blob, usually for performance ---\n-\n-    /// Properties of the whole crate.\n-    /// NOTE(eddyb) we pass `'static` to a `'tcx` parameter because this\n-    /// lifetime is only used behind `Lazy`, and therefore acts like an\n-    /// universal (`for<'tcx>`), that is paired up with whichever `TyCtxt`\n-    /// is being used to decode those values.\n-    crate root: rmeta::CrateRoot<'static>,\n-    /// For each definition in this crate, we encode a key. When the\n-    /// crate is loaded, we read all the keys and put them in this\n-    /// hashmap, which gives the reverse mapping. This allows us to\n-    /// quickly retrace a `DefPath`, which is needed for incremental\n-    /// compilation support.\n-    crate def_path_table: DefPathTable,\n-    /// Trait impl data.\n-    /// FIXME: Used only from queries and can use query cache,\n-    /// so pre-decoding can probably be avoided.\n-    crate trait_impls: FxHashMap<(u32, DefIndex), rmeta::Lazy<[DefIndex]>>,\n-    /// Proc macro descriptions for this crate, if it's a proc macro crate.\n-    crate raw_proc_macros: Option<&'static [ProcMacro]>,\n-    /// Source maps for code from the crate.\n-    crate source_map_import_info: Once<Vec<ImportedSourceFile>>,\n-    /// Used for decoding interpret::AllocIds in a cached & thread-safe manner.\n-    crate alloc_decoding_state: AllocDecodingState,\n-    /// The `DepNodeIndex` of the `DepNode` representing this upstream crate.\n-    /// It is initialized on the first access in `get_crate_dep_node_index()`.\n-    /// Do not access the value directly, as it might not have been initialized yet.\n-    /// The field must always be initialized to `DepNodeIndex::INVALID`.\n-    crate dep_node_index: AtomicCell<DepNodeIndex>,\n-\n-    // --- Other significant crate properties ---\n-\n-    /// ID of this crate, from the current compilation session's point of view.\n-    crate cnum: CrateNum,\n-    /// Maps crate IDs as they are were seen from this crate's compilation sessions into\n-    /// IDs as they are seen from the current compilation session.\n-    crate cnum_map: CrateNumMap,\n-    /// Same ID set as `cnum_map` plus maybe some injected crates like panic runtime.\n-    crate dependencies: Lock<Vec<CrateNum>>,\n-    /// How to link (or not link) this crate to the currently compiled crate.\n-    crate dep_kind: Lock<DepKind>,\n-    /// Filesystem location of this crate.\n-    crate source: CrateSource,\n-    /// Whether or not this crate should be consider a private dependency\n-    /// for purposes of the 'exported_private_dependencies' lint\n-    crate private_dep: bool,\n-    /// The hash for the host proc macro. Used to support `-Z dual-proc-macro`.\n-    crate host_hash: Option<Svh>,\n-\n-    // --- Data used only for improving diagnostics ---\n-\n-    /// Information about the `extern crate` item or path that caused this crate to be loaded.\n-    /// If this is `None`, then the crate was injected (e.g., by the allocator).\n-    crate extern_crate: Lock<Option<ExternCrate>>,\n-}\n-\n #[derive(Clone)]\n pub struct CStore {\n     metas: IndexVec<CrateNum, Option<Lrc<CrateMetadata>>>,\n-    pub(crate) injected_panic_runtime: Option<CrateNum>,\n-    pub(crate) allocator_kind: Option<AllocatorKind>,\n+    crate injected_panic_runtime: Option<CrateNum>,\n+    crate allocator_kind: Option<AllocatorKind>,\n }\n \n pub enum LoadedMacro {"}, {"sha": "64230fd9e608d5194d6519a51c32eee332d7b277", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 114, "deletions": 72, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -212,9 +212,8 @@\n //! no means all of the necessary details. Take a look at the rest of\n //! metadata::locator or metadata::creader for all the juicy details!\n \n-use crate::cstore::MetadataBlob;\n use crate::creader::Library;\n-use crate::rmeta::{METADATA_HEADER, rustc_version};\n+use crate::rmeta::{METADATA_HEADER, rustc_version, MetadataBlob};\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::svh::Svh;\n@@ -249,37 +248,47 @@ use log::{debug, info, warn};\n use rustc_error_codes::*;\n \n #[derive(Clone)]\n-crate struct CrateMismatch {\n+struct CrateMismatch {\n     path: PathBuf,\n     got: String,\n }\n \n #[derive(Clone)]\n-crate struct Context<'a> {\n-    pub sess: &'a Session,\n-    pub span: Span,\n-    pub crate_name: Symbol,\n+crate struct CrateLocator<'a> {\n+    // Immutable per-session configuration.\n+    sess: &'a Session,\n+    metadata_loader: &'a dyn MetadataLoader,\n+\n+    // Immutable per-search configuration.\n+    crate_name: Symbol,\n+    exact_paths: Vec<PathBuf>,\n     pub hash: Option<&'a Svh>,\n     pub host_hash: Option<&'a Svh>,\n-    pub extra_filename: Option<&'a str>,\n-    // points to either self.sess.target.target or self.sess.host, must match triple\n+    extra_filename: Option<&'a str>,\n     pub target: &'a Target,\n     pub triple: TargetTriple,\n     pub filesearch: FileSearch<'a>,\n-    pub root: Option<&'a CratePaths>,\n-    pub rejected_via_hash: Vec<CrateMismatch>,\n-    pub rejected_via_triple: Vec<CrateMismatch>,\n-    pub rejected_via_kind: Vec<CrateMismatch>,\n-    pub rejected_via_version: Vec<CrateMismatch>,\n-    pub rejected_via_filename: Vec<CrateMismatch>,\n-    pub should_match_name: bool,\n+    span: Span,\n+    root: Option<&'a CratePaths>,\n     pub is_proc_macro: Option<bool>,\n-    pub metadata_loader: &'a dyn MetadataLoader,\n+\n+    // Mutable in-progress state or output.\n+    rejected_via_hash: Vec<CrateMismatch>,\n+    rejected_via_triple: Vec<CrateMismatch>,\n+    rejected_via_kind: Vec<CrateMismatch>,\n+    rejected_via_version: Vec<CrateMismatch>,\n+    rejected_via_filename: Vec<CrateMismatch>,\n }\n \n crate struct CratePaths {\n-    pub name: Symbol,\n-    pub source: CrateSource,\n+    name: Symbol,\n+    source: CrateSource,\n+}\n+\n+impl CratePaths {\n+    crate fn new(name: Symbol, source: CrateSource) -> CratePaths {\n+        CratePaths { name, source }\n+    }\n }\n \n #[derive(Copy, Clone, PartialEq)]\n@@ -299,7 +308,58 @@ impl fmt::Display for CrateFlavor {\n     }\n }\n \n-impl<'a> Context<'a> {\n+impl<'a> CrateLocator<'a> {\n+    crate fn new(\n+        sess: &'a Session,\n+        metadata_loader: &'a dyn MetadataLoader,\n+        crate_name: Symbol,\n+        hash: Option<&'a Svh>,\n+        host_hash: Option<&'a Svh>,\n+        extra_filename: Option<&'a str>,\n+        is_host: bool,\n+        path_kind: PathKind,\n+        span: Span,\n+        root: Option<&'a CratePaths>,\n+        is_proc_macro: Option<bool>,\n+    ) -> CrateLocator<'a> {\n+        CrateLocator {\n+            sess,\n+            metadata_loader,\n+            crate_name,\n+            exact_paths: if hash.is_none() {\n+                sess.opts.externs.get(&crate_name.as_str()).into_iter()\n+                    .flat_map(|entry| entry.locations.iter())\n+                    .filter_map(|location| location.clone().map(PathBuf::from)).collect()\n+            } else {\n+                // SVH being specified means this is a transitive dependency,\n+                // so `--extern` options do not apply.\n+                Vec::new()\n+            },\n+            hash,\n+            host_hash,\n+            extra_filename,\n+            target: if is_host { &sess.host } else { &sess.target.target },\n+            triple: if is_host {\n+                TargetTriple::from_triple(config::host_triple())\n+            } else {\n+                sess.opts.target_triple.clone()\n+            },\n+            filesearch: if is_host {\n+                sess.host_filesearch(path_kind)\n+            } else {\n+                sess.target_filesearch(path_kind)\n+            },\n+            span,\n+            root,\n+            is_proc_macro,\n+            rejected_via_hash: Vec::new(),\n+            rejected_via_triple: Vec::new(),\n+            rejected_via_kind: Vec::new(),\n+            rejected_via_version: Vec::new(),\n+            rejected_via_filename: Vec::new(),\n+        }\n+    }\n+\n     crate fn reset(&mut self) {\n         self.rejected_via_hash.clear();\n         self.rejected_via_triple.clear();\n@@ -309,6 +369,9 @@ impl<'a> Context<'a> {\n     }\n \n     crate fn maybe_load_library_crate(&mut self) -> Option<Library> {\n+        if !self.exact_paths.is_empty() {\n+            return self.find_commandline_library();\n+        }\n         let mut seen_paths = FxHashSet::default();\n         match self.extra_filename {\n             Some(s) => self.find_library_crate(s, &mut seen_paths)\n@@ -434,21 +497,6 @@ impl<'a> Context<'a> {\n                           extra_prefix: &str,\n                           seen_paths: &mut FxHashSet<PathBuf>)\n                           -> Option<Library> {\n-        // If an SVH is specified, then this is a transitive dependency that\n-        // must be loaded via -L plus some filtering.\n-        if self.hash.is_none() {\n-            self.should_match_name = false;\n-            if let Some(entry) = self.sess.opts.externs.get(&self.crate_name.as_str()) {\n-                // Only use `--extern crate_name=path` here, not `--extern crate_name`.\n-                if entry.locations.iter().any(|l| l.is_some()) {\n-                    return self.find_commandline_library(\n-                        entry.locations.iter().filter_map(|l| l.as_ref()),\n-                    );\n-                }\n-            }\n-            self.should_match_name = true;\n-        }\n-\n         let dypair = self.dylibname();\n         let staticpair = self.staticlibname();\n \n@@ -716,15 +764,16 @@ impl<'a> Context<'a> {\n         }\n \n         let root = metadata.get_root();\n-        if let Some(is_proc_macro) = self.is_proc_macro {\n-            if root.proc_macro_data.is_some() != is_proc_macro {\n+        if let Some(expected_is_proc_macro) = self.is_proc_macro {\n+            let is_proc_macro = root.is_proc_macro_crate();\n+            if is_proc_macro != expected_is_proc_macro {\n                 info!(\"Rejecting via proc macro: expected {} got {}\",\n-                      is_proc_macro, root.proc_macro_data.is_some());\n+                      expected_is_proc_macro, is_proc_macro);\n                 return None;\n             }\n         }\n \n-        if self.should_match_name {\n+        if self.exact_paths.is_empty() {\n             if self.crate_name != root.name {\n                 info!(\"Rejecting via crate name\");\n                 return None;\n@@ -771,9 +820,7 @@ impl<'a> Context<'a> {\n         (t.options.staticlib_prefix.clone(), t.options.staticlib_suffix.clone())\n     }\n \n-    fn find_commandline_library<'b, LOCS>(&mut self, locs: LOCS) -> Option<Library>\n-        where LOCS: Iterator<Item = &'b String>\n-    {\n+    fn find_commandline_library(&mut self) -> Option<Library> {\n         // First, filter out all libraries that look suspicious. We only accept\n         // files which actually exist that have the correct naming scheme for\n         // rlibs/dylibs.\n@@ -783,18 +830,20 @@ impl<'a> Context<'a> {\n         let mut rmetas = FxHashMap::default();\n         let mut dylibs = FxHashMap::default();\n         {\n-            let locs = locs.map(|l| PathBuf::from(l)).filter(|loc| {\n+                let crate_name = self.crate_name;\n+                let rejected_via_filename = &mut self.rejected_via_filename;\n+                let locs = self.exact_paths.iter().filter(|loc| {\n                 if !loc.exists() {\n                     sess.err(&format!(\"extern location for {} does not exist: {}\",\n-                                      self.crate_name,\n+                                      crate_name,\n                                       loc.display()));\n                     return false;\n                 }\n                 let file = match loc.file_name().and_then(|s| s.to_str()) {\n                     Some(file) => file,\n                     None => {\n                         sess.err(&format!(\"extern location for {} is not a file: {}\",\n-                                          self.crate_name,\n+                                          crate_name,\n                                           loc.display()));\n                         return false;\n                     }\n@@ -809,8 +858,8 @@ impl<'a> Context<'a> {\n                     }\n                 }\n \n-                self.rejected_via_filename.push(CrateMismatch {\n-                    path: loc.clone(),\n+                rejected_via_filename.push(CrateMismatch {\n+                    path: (*loc).clone(),\n                     got: String::new(),\n                 });\n \n@@ -907,7 +956,7 @@ fn get_metadata_section_imp(target: &Target,\n             rustc_erase_owner!(OwningRef::new(StableDerefMmap(mmap)).map_owner_box())\n         }\n     };\n-    let blob = MetadataBlob(raw_bytes);\n+    let blob = MetadataBlob::new(raw_bytes);\n     if blob.is_compatible() {\n         Ok(blob)\n     } else {\n@@ -927,44 +976,37 @@ pub fn find_plugin_registrar(\n     let host_triple = TargetTriple::from_triple(config::host_triple());\n     let is_cross = target_triple != host_triple;\n     let mut target_only = false;\n-    let mut locate_ctxt = Context {\n+    let mut locator = CrateLocator::new(\n         sess,\n-        span,\n-        crate_name: name,\n-        hash: None,\n-        host_hash: None,\n-        extra_filename: None,\n-        filesearch: sess.host_filesearch(PathKind::Crate),\n-        target: &sess.host,\n-        triple: host_triple,\n-        root: None,\n-        rejected_via_hash: vec![],\n-        rejected_via_triple: vec![],\n-        rejected_via_kind: vec![],\n-        rejected_via_version: vec![],\n-        rejected_via_filename: vec![],\n-        should_match_name: true,\n-        is_proc_macro: None,\n         metadata_loader,\n-    };\n+        name,\n+        None, // hash\n+        None, // host_hash\n+        None, // extra_filename\n+        true, // is_host\n+        PathKind::Crate,\n+        span,\n+        None, // root\n+        None, // is_proc_macro\n+    );\n \n-    let library = locate_ctxt.maybe_load_library_crate().or_else(|| {\n+    let library = locator.maybe_load_library_crate().or_else(|| {\n         if !is_cross {\n             return None\n         }\n         // Try loading from target crates. This will abort later if we\n         // try to load a plugin registrar function,\n         target_only = true;\n \n-        locate_ctxt.target = &sess.target.target;\n-        locate_ctxt.triple = target_triple;\n-        locate_ctxt.filesearch = sess.target_filesearch(PathKind::Crate);\n+        locator.target = &sess.target.target;\n+        locator.triple = target_triple;\n+        locator.filesearch = sess.target_filesearch(PathKind::Crate);\n \n-        locate_ctxt.maybe_load_library_crate()\n+        locator.maybe_load_library_crate()\n     });\n     let library = match library {\n         Some(l) => l,\n-        None => locate_ctxt.report_errs(),\n+        None => locator.report_errs(),\n     };\n \n     if target_only {"}, {"sha": "7b0cf451ff918227d3ed5afcff12badd86907028", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 157, "deletions": 23, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -1,27 +1,30 @@\n // Decoding metadata from a single crate's metadata\n \n-use crate::cstore::{self, CrateMetadata, MetadataBlob};\n use crate::rmeta::*;\n use crate::rmeta::table::{FixedSizeEncoding, PerDefTable};\n \n use rustc_index::vec::IndexVec;\n-use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::sync::{Lrc, Lock, Once, AtomicCell};\n use rustc::hir::map::{DefKey, DefPath, DefPathData, DefPathHash};\n+use rustc::hir::map::definitions::DefPathTable;\n use rustc::hir;\n+use rustc::middle::cstore::{CrateSource, ExternCrate};\n use rustc::middle::cstore::{LinkagePreference, NativeLibrary, ForeignModule};\n use rustc::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n use rustc::hir::def::{self, Res, DefKind, CtorOf, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc::dep_graph::{DepNodeIndex, DepKind};\n+use rustc_data_structures::svh::Svh;\n+use rustc::dep_graph::{self, DepNodeIndex};\n use rustc::middle::lang_items;\n use rustc::mir::{self, interpret};\n-use rustc::mir::interpret::AllocDecodingSession;\n+use rustc::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::codec::TyDecoder;\n use rustc::mir::{Body, Promoted};\n+use rustc::util::common::record_time;\n use rustc::util::captures::Captures;\n \n use std::io;\n@@ -44,7 +47,86 @@ pub use cstore_impl::{provide, provide_extern};\n \n mod cstore_impl;\n \n-crate struct DecodeContext<'a, 'tcx> {\n+crate struct MetadataBlob(MetadataRef);\n+\n+// A map from external crate numbers (as decoded from some crate file) to\n+// local crate numbers (as generated during this session). Each external\n+// crate may refer to types in other external crates, and each has their\n+// own crate numbers.\n+crate type CrateNumMap = IndexVec<CrateNum, CrateNum>;\n+\n+crate struct CrateMetadata {\n+    /// The primary crate data - binary metadata blob.\n+    blob: MetadataBlob,\n+\n+    // --- Some data pre-decoded from the metadata blob, usually for performance ---\n+\n+    /// Properties of the whole crate.\n+    /// NOTE(eddyb) we pass `'static` to a `'tcx` parameter because this\n+    /// lifetime is only used behind `Lazy`, and therefore acts like an\n+    /// universal (`for<'tcx>`), that is paired up with whichever `TyCtxt`\n+    /// is being used to decode those values.\n+    crate root: CrateRoot<'static>,\n+    /// For each definition in this crate, we encode a key. When the\n+    /// crate is loaded, we read all the keys and put them in this\n+    /// hashmap, which gives the reverse mapping. This allows us to\n+    /// quickly retrace a `DefPath`, which is needed for incremental\n+    /// compilation support.\n+    def_path_table: DefPathTable,\n+    /// Trait impl data.\n+    /// FIXME: Used only from queries and can use query cache,\n+    /// so pre-decoding can probably be avoided.\n+    trait_impls: FxHashMap<(u32, DefIndex), Lazy<[DefIndex]>>,\n+    /// Proc macro descriptions for this crate, if it's a proc macro crate.\n+    raw_proc_macros: Option<&'static [ProcMacro]>,\n+    /// Source maps for code from the crate.\n+    source_map_import_info: Once<Vec<ImportedSourceFile>>,\n+    /// Used for decoding interpret::AllocIds in a cached & thread-safe manner.\n+    alloc_decoding_state: AllocDecodingState,\n+    /// The `DepNodeIndex` of the `DepNode` representing this upstream crate.\n+    /// It is initialized on the first access in `get_crate_dep_node_index()`.\n+    /// Do not access the value directly, as it might not have been initialized yet.\n+    /// The field must always be initialized to `DepNodeIndex::INVALID`.\n+    dep_node_index: AtomicCell<DepNodeIndex>,\n+\n+    // --- Other significant crate properties ---\n+\n+    /// ID of this crate, from the current compilation session's point of view.\n+    cnum: CrateNum,\n+    /// Maps crate IDs as they are were seen from this crate's compilation sessions into\n+    /// IDs as they are seen from the current compilation session.\n+    cnum_map: CrateNumMap,\n+    /// Same ID set as `cnum_map` plus maybe some injected crates like panic runtime.\n+    crate dependencies: Lock<Vec<CrateNum>>,\n+    /// How to link (or not link) this crate to the currently compiled crate.\n+    crate dep_kind: Lock<DepKind>,\n+    /// Filesystem location of this crate.\n+    crate source: CrateSource,\n+    /// Whether or not this crate should be consider a private dependency\n+    /// for purposes of the 'exported_private_dependencies' lint\n+    private_dep: bool,\n+    /// The hash for the host proc macro. Used to support `-Z dual-proc-macro`.\n+    host_hash: Option<Svh>,\n+\n+    // --- Data used only for improving diagnostics ---\n+\n+    /// Information about the `extern crate` item or path that caused this crate to be loaded.\n+    /// If this is `None`, then the crate was injected (e.g., by the allocator).\n+    crate extern_crate: Lock<Option<ExternCrate>>,\n+}\n+\n+/// Holds information about a syntax_pos::SourceFile imported from another crate.\n+/// See `imported_source_files()` for more information.\n+struct ImportedSourceFile {\n+    /// This SourceFile's byte-offset within the source_map of its original crate\n+    original_start_pos: syntax_pos::BytePos,\n+    /// The end of this SourceFile within the source_map of its original crate\n+    original_end_pos: syntax_pos::BytePos,\n+    /// The imported SourceFile's representation within the local source_map\n+    translated_source_file: Lrc<syntax_pos::SourceFile>,\n+}\n+\n+pub(super) struct DecodeContext<'a, 'tcx> {\n     opaque: opaque::Decoder<'a>,\n     cdata: Option<&'a CrateMetadata>,\n     sess: Option<&'tcx Session>,\n@@ -60,7 +142,7 @@ crate struct DecodeContext<'a, 'tcx> {\n }\n \n /// Abstract over the various ways one can create metadata decoders.\n-crate trait Metadata<'a, 'tcx>: Copy {\n+pub(super) trait Metadata<'a, 'tcx>: Copy {\n     fn raw_bytes(self) -> &'a [u8];\n     fn cdata(self) -> Option<&'a CrateMetadata> { None }\n     fn sess(self) -> Option<&'tcx Session> { None }\n@@ -136,15 +218,15 @@ impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadata, TyCtxt<'tcx>) {\n }\n \n impl<'a, 'tcx, T: Encodable + Decodable> Lazy<T> {\n-    crate fn decode<M: Metadata<'a, 'tcx>>(self, metadata: M) -> T {\n+    fn decode<M: Metadata<'a, 'tcx>>(self, metadata: M) -> T {\n         let mut dcx = metadata.decoder(self.position.get());\n         dcx.lazy_state = LazyState::NodeStart(self.position);\n         T::decode(&mut dcx).unwrap()\n     }\n }\n \n impl<'a: 'x, 'tcx: 'x, 'x, T: Encodable + Decodable> Lazy<[T]> {\n-    crate fn decode<M: Metadata<'a, 'tcx>>(\n+    fn decode<M: Metadata<'a, 'tcx>>(\n         self,\n         metadata: M,\n     ) -> impl ExactSizeIterator<Item = T> + Captures<'a> + Captures<'tcx> + 'x {\n@@ -393,7 +475,11 @@ for DecodeContext<'a, 'tcx> {\n \n implement_ty_decoder!( DecodeContext<'a, 'tcx> );\n \n-impl<'tcx> MetadataBlob {\n+impl MetadataBlob {\n+    crate fn new(metadata_ref: MetadataRef) -> MetadataBlob {\n+        MetadataBlob(metadata_ref)\n+    }\n+\n     crate fn is_compatible(&self) -> bool {\n         self.raw_bytes().starts_with(METADATA_HEADER)\n     }\n@@ -467,14 +553,62 @@ impl<'tcx> EntryKind<'tcx> {\n     }\n }\n \n+impl CrateRoot<'_> {\n+    crate fn is_proc_macro_crate(&self) -> bool {\n+        self.proc_macro_data.is_some()\n+    }\n+\n+    crate fn decode_crate_deps(\n+        &self,\n+        metadata: &'a MetadataBlob,\n+    ) -> impl ExactSizeIterator<Item = CrateDep> + Captures<'a> {\n+        self.crate_deps.decode(metadata)\n+    }\n+}\n+\n impl<'a, 'tcx> CrateMetadata {\n-    fn is_proc_macro_crate(&self) -> bool {\n-        self.root.proc_macro_decls_static.is_some()\n+    crate fn new(\n+        sess: &Session,\n+        blob: MetadataBlob,\n+        root: CrateRoot<'static>,\n+        raw_proc_macros: Option<&'static [ProcMacro]>,\n+        cnum: CrateNum,\n+        cnum_map: CrateNumMap,\n+        dep_kind: DepKind,\n+        source: CrateSource,\n+        private_dep: bool,\n+        host_hash: Option<Svh>,\n+    ) -> CrateMetadata {\n+        let def_path_table = record_time(&sess.perf_stats.decode_def_path_tables_time, || {\n+            root.def_path_table.decode((&blob, sess))\n+        });\n+        let trait_impls = root.impls.decode((&blob, sess))\n+            .map(|trait_impls| (trait_impls.trait_id, trait_impls.impls)).collect();\n+        let alloc_decoding_state =\n+            AllocDecodingState::new(root.interpret_alloc_index.decode(&blob).collect());\n+        let dependencies = Lock::new(cnum_map.iter().cloned().collect());\n+        CrateMetadata {\n+            blob,\n+            root,\n+            def_path_table,\n+            trait_impls,\n+            raw_proc_macros,\n+            source_map_import_info: Once::new(),\n+            alloc_decoding_state,\n+            dep_node_index: AtomicCell::new(DepNodeIndex::INVALID),\n+            cnum,\n+            cnum_map,\n+            dependencies,\n+            dep_kind: Lock::new(dep_kind),\n+            source,\n+            private_dep,\n+            host_hash,\n+            extern_crate: Lock::new(None),\n+        }\n     }\n \n     fn is_proc_macro(&self, id: DefIndex) -> bool {\n-        self.is_proc_macro_crate() &&\n-            self.root.proc_macro_data.unwrap().decode(self).find(|x| *x == id).is_some()\n+        self.root.proc_macro_data.and_then(|data| data.decode(self).find(|x| *x == id)).is_some()\n     }\n \n     fn maybe_kind(&self, item_id: DefIndex) -> Option<EntryKind<'tcx>> {\n@@ -757,7 +891,7 @@ impl<'a, 'tcx> CrateMetadata {\n \n     /// Iterates over the language items in the given crate.\n     fn get_lang_items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [(DefId, usize)] {\n-        if self.is_proc_macro_crate() {\n+        if self.root.is_proc_macro_crate() {\n             // Proc macro crates do not export any lang-items to the target.\n             &[]\n         } else {\n@@ -773,7 +907,7 @@ impl<'a, 'tcx> CrateMetadata {\n         &self,\n         tcx: TyCtxt<'tcx>,\n     ) -> &'tcx FxHashMap<Symbol, DefId> {\n-        tcx.arena.alloc(if self.is_proc_macro_crate() {\n+        tcx.arena.alloc(if self.root.is_proc_macro_crate() {\n             // Proc macro crates do not export any diagnostic-items to the target.\n             Default::default()\n         } else {\n@@ -1081,7 +1215,7 @@ impl<'a, 'tcx> CrateMetadata {\n         tcx: TyCtxt<'tcx>,\n         filter: Option<DefId>,\n     ) -> &'tcx [DefId] {\n-        if self.is_proc_macro_crate() {\n+        if self.root.is_proc_macro_crate() {\n             // proc-macro crates export no trait impls.\n             return &[]\n         }\n@@ -1125,7 +1259,7 @@ impl<'a, 'tcx> CrateMetadata {\n \n \n     fn get_native_libraries(&self, sess: &Session) -> Vec<NativeLibrary> {\n-        if self.is_proc_macro_crate() {\n+        if self.root.is_proc_macro_crate() {\n             // Proc macro crates do not have any *target* native libraries.\n             vec![]\n         } else {\n@@ -1134,7 +1268,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     fn get_foreign_modules(&self, tcx: TyCtxt<'tcx>) -> &'tcx [ForeignModule] {\n-        if self.is_proc_macro_crate() {\n+        if self.root.is_proc_macro_crate() {\n             // Proc macro crates do not have any *target* foreign modules.\n             &[]\n         } else {\n@@ -1157,7 +1291,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     fn get_missing_lang_items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [lang_items::LangItem] {\n-        if self.is_proc_macro_crate() {\n+        if self.root.is_proc_macro_crate() {\n             // Proc macro crates do not depend on any target weak lang-items.\n             &[]\n         } else {\n@@ -1181,7 +1315,7 @@ impl<'a, 'tcx> CrateMetadata {\n         &self,\n         tcx: TyCtxt<'tcx>,\n     ) -> Vec<(ExportedSymbol<'tcx>, SymbolExportLevel)> {\n-        if self.is_proc_macro_crate() {\n+        if self.root.is_proc_macro_crate() {\n             // If this crate is a custom derive crate, then we're not even going to\n             // link those in so we skip those crates.\n             vec![]\n@@ -1296,7 +1430,7 @@ impl<'a, 'tcx> CrateMetadata {\n     fn imported_source_files(\n         &'a self,\n         local_source_map: &source_map::SourceMap,\n-    ) -> &[cstore::ImportedSourceFile] {\n+    ) -> &[ImportedSourceFile] {\n         self.source_map_import_info.init_locking(|| {\n             let external_source_map = self.root.source_map.decode(self);\n \n@@ -1351,7 +1485,7 @@ impl<'a, 'tcx> CrateMetadata {\n                        local_version.name, start_pos, end_pos,\n                        local_version.start_pos, local_version.end_pos);\n \n-                cstore::ImportedSourceFile {\n+                ImportedSourceFile {\n                     original_start_pos: start_pos,\n                     original_end_pos: end_pos,\n                     translated_source_file: local_version,\n@@ -1374,7 +1508,7 @@ impl<'a, 'tcx> CrateMetadata {\n             // would always write the same value.\n \n             let def_path_hash = self.def_path_hash(CRATE_DEF_INDEX);\n-            let dep_node = def_path_hash.to_dep_node(DepKind::CrateMetadata);\n+            let dep_node = def_path_hash.to_dep_node(dep_graph::DepKind::CrateMetadata);\n \n             dep_node_index = tcx.dep_graph.dep_node_index_of(&dep_node);\n             assert!(dep_node_index != DepNodeIndex::INVALID);"}, {"sha": "abb0ceb4ff4277f8083bafc1bd31fa5ad2da750c", "filename": "src/librustc_metadata/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -52,7 +52,7 @@ macro_rules! provide {\n                 assert!(!$def_id.is_local());\n \n                 let $cdata = $tcx.crate_data_as_any($def_id.krate);\n-                let $cdata = $cdata.downcast_ref::<cstore::CrateMetadata>()\n+                let $cdata = $cdata.downcast_ref::<rmeta::CrateMetadata>()\n                     .expect(\"CrateStore created data is not a CrateMetadata\");\n \n                 if $tcx.dep_graph.is_fully_enabled() {\n@@ -410,7 +410,7 @@ impl cstore::CStore {\n         let _prof_timer = sess.prof.generic_activity(\"metadata_load_macro\");\n \n         let data = self.get_crate_data(id.krate);\n-        if data.is_proc_macro_crate() {\n+        if data.root.is_proc_macro_crate() {\n             return LoadedMacro::ProcMacro(data.load_proc_macro(id.index, sess));\n         }\n "}, {"sha": "23c0204ee256bd138d5bc58f4e63907f674afae0", "filename": "src/librustc_metadata/rmeta/mod.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -14,6 +14,7 @@ use rustc::ty::{self, Ty, ReprOptions};\n use rustc_target::spec::{PanicStrategy, TargetTriple};\n use rustc_index::vec::IndexVec;\n use rustc_data_structures::svh::Svh;\n+use rustc_data_structures::sync::MetadataRef;\n use rustc_serialize::Encodable;\n use syntax::{ast, attr};\n use syntax::edition::Edition;\n@@ -24,6 +25,7 @@ use std::marker::PhantomData;\n use std::num::NonZeroUsize;\n \n pub use decoder::{provide, provide_extern};\n+crate use decoder::{CrateMetadata, CrateNumMap, MetadataBlob};\n \n mod decoder;\n mod encoder;\n@@ -49,7 +51,7 @@ crate const METADATA_HEADER: &[u8; 8] =\n \n /// Additional metadata for a `Lazy<T>` where `T` may not be `Sized`,\n /// e.g. for `Lazy<[T]>`, this is the length (count of `T` values).\n-crate trait LazyMeta {\n+trait LazyMeta {\n     type Meta: Copy + 'static;\n \n     /// Returns the minimum encoded size.\n@@ -103,7 +105,7 @@ impl<T: Encodable> LazyMeta for [T] {\n #[must_use]\n // FIXME(#59875) the `Meta` parameter only exists to dodge\n // invariance wrt `T` (coming from the `meta: T::Meta` field).\n-crate struct Lazy<T, Meta = <T as LazyMeta>::Meta>\n+struct Lazy<T, Meta = <T as LazyMeta>::Meta>\n     where T: ?Sized + LazyMeta<Meta = Meta>,\n           Meta: 'static + Copy,\n {\n@@ -186,7 +188,7 @@ crate struct CrateRoot<'tcx> {\n     proc_macro_decls_static: Option<DefIndex>,\n     proc_macro_stability: Option<attr::Stability>,\n \n-    pub crate_deps: Lazy<[CrateDep]>,\n+    crate_deps: Lazy<[CrateDep]>,\n     dylib_dependency_formats: Lazy<[Option<LinkagePreference>]>,\n     lib_features: Lazy<[(Symbol, Option<Symbol>)]>,\n     lang_items: Lazy<[(DefIndex, usize)]>,\n@@ -195,16 +197,15 @@ crate struct CrateRoot<'tcx> {\n     native_libraries: Lazy<[NativeLibrary]>,\n     foreign_modules: Lazy<[ForeignModule]>,\n     source_map: Lazy<[syntax_pos::SourceFile]>,\n-    pub def_path_table: Lazy<hir::map::definitions::DefPathTable>,\n-    pub impls: Lazy<[TraitImpls]>,\n+    def_path_table: Lazy<hir::map::definitions::DefPathTable>,\n+    impls: Lazy<[TraitImpls]>,\n     exported_symbols: Lazy!([(ExportedSymbol<'tcx>, SymbolExportLevel)]),\n-    pub interpret_alloc_index: Lazy<[u32]>,\n+    interpret_alloc_index: Lazy<[u32]>,\n \n     per_def: LazyPerDefTables<'tcx>,\n \n-    /// The DefIndex's of any proc macros delcared by\n-    /// this crate\n-    pub proc_macro_data: Option<Lazy<[DefIndex]>>,\n+    /// The DefIndex's of any proc macros delcared by this crate.\n+    proc_macro_data: Option<Lazy<[DefIndex]>>,\n \n     compiler_builtins: bool,\n     pub needs_allocator: bool,\n@@ -227,8 +228,8 @@ crate struct CrateDep {\n \n #[derive(RustcEncodable, RustcDecodable)]\n crate struct TraitImpls {\n-    pub trait_id: (u32, DefIndex),\n-    pub impls: Lazy<[DefIndex]>,\n+    trait_id: (u32, DefIndex),\n+    impls: Lazy<[DefIndex]>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]"}, {"sha": "9bc6d32b7cb385a990e483a6a2431cfa9bbf1183", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -22,6 +22,7 @@ rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_index = { path = \"../librustc_index\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_lexer = { path = \"../librustc_lexer\" }\n+rustc_macros = { path = \"../librustc_macros\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "08640476f7ab720e21b7feb0d9d45aab1238a4ef", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -18,6 +18,7 @@ use rustc::mir::interpret::{\n     InterpResult, truncate, sign_extend,\n };\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_macros::HashStable;\n \n use super::{\n     Immediate, Operand, MemPlace, MPlaceTy, Place, PlaceTy, ScalarMaybeUndef,\n@@ -93,7 +94,7 @@ pub struct Frame<'mir, 'tcx, Tag=(), Extra=()> {\n     pub stmt: usize,\n }\n \n-#[derive(Clone, Eq, PartialEq, Debug)] // Miri debug-prints these\n+#[derive(Clone, Eq, PartialEq, Debug, HashStable)] // Miri debug-prints these\n pub enum StackPopCleanup {\n     /// Jump to the next block in the caller, or cause UB if None (that's a function\n     /// that may never return). Also store layout of return place so\n@@ -109,15 +110,16 @@ pub enum StackPopCleanup {\n }\n \n /// State of a local variable including a memoized layout\n-#[derive(Clone, PartialEq, Eq)]\n+#[derive(Clone, PartialEq, Eq, HashStable)]\n pub struct LocalState<'tcx, Tag=(), Id=AllocId> {\n     pub value: LocalValue<Tag, Id>,\n     /// Don't modify if `Some`, this is only used to prevent computing the layout twice\n+    #[stable_hasher(ignore)]\n     pub layout: Cell<Option<TyLayout<'tcx>>>,\n }\n \n /// Current value of a local variable\n-#[derive(Clone, PartialEq, Eq, Debug)] // Miri debug-prints these\n+#[derive(Clone, PartialEq, Eq, Debug, HashStable)] // Miri debug-prints these\n pub enum LocalValue<Tag=(), Id=AllocId> {\n     /// This local is not currently alive, and cannot be used at all.\n     Dead,"}, {"sha": "cfa70164cdce430aca3e9f16fdee91132a76f8f2", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -18,6 +18,7 @@ use super::{\n     MemPlace, MPlaceTy, PlaceTy, Place,\n };\n pub use rustc::mir::interpret::ScalarMaybeUndef;\n+use rustc_macros::HashStable;\n \n /// An `Immediate` represents a single immediate self-contained Rust value.\n ///\n@@ -26,7 +27,7 @@ pub use rustc::mir::interpret::ScalarMaybeUndef;\n /// operations and fat pointers. This idea was taken from rustc's codegen.\n /// In particular, thanks to `ScalarPair`, arithmetic operations and casts can be entirely\n /// defined on `Immediate`, and do not have to work with a `Place`.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, HashStable)]\n pub enum Immediate<Tag=(), Id=AllocId> {\n     Scalar(ScalarMaybeUndef<Tag, Id>),\n     ScalarPair(ScalarMaybeUndef<Tag, Id>, ScalarMaybeUndef<Tag, Id>),\n@@ -103,7 +104,7 @@ impl<'tcx, Tag> ::std::ops::Deref for ImmTy<'tcx, Tag> {\n /// An `Operand` is the result of computing a `mir::Operand`. It can be immediate,\n /// or still in memory. The latter is an optimization, to delay reading that chunk of\n /// memory and to avoid having to store arbitrary-sized data here.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, HashStable)]\n pub enum Operand<Tag=(), Id=AllocId> {\n     Immediate(Immediate<Tag, Id>),\n     Indirect(MemPlace<Tag, Id>),"}, {"sha": "088fbe1695efd3cedc0619341264bb4949518516", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -12,14 +12,15 @@ use rustc::ty::layout::{\n     self, Size, Align, LayoutOf, TyLayout, HasDataLayout, VariantIdx, PrimitiveExt\n };\n use rustc::ty::TypeFoldable;\n+use rustc_macros::HashStable;\n \n use super::{\n     GlobalId, AllocId, Allocation, Scalar, InterpResult, Pointer, PointerArithmetic,\n     InterpCx, Machine, AllocMap, AllocationExtra,\n     RawConst, Immediate, ImmTy, ScalarMaybeUndef, Operand, OpTy, MemoryKind, LocalValue,\n };\n \n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable)]\n pub struct MemPlace<Tag=(), Id=AllocId> {\n     /// A place may have an integral pointer for ZSTs, and since it might\n     /// be turned back into a reference before ever being dereferenced.\n@@ -32,7 +33,7 @@ pub struct MemPlace<Tag=(), Id=AllocId> {\n     pub meta: Option<Scalar<Tag, Id>>,\n }\n \n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable)]\n pub enum Place<Tag=(), Id=AllocId> {\n     /// A place referring to a value allocated in the `Memory` system.\n     Ptr(MemPlace<Tag, Id>),"}, {"sha": "b460badd1fdac3353ec54e9737ba7c0968025e5e", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 4, "deletions": 38, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -19,6 +19,7 @@ use rustc::ty::layout::{Align, Size};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_index::vec::IndexVec;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_macros::HashStable;\n use syntax::ast::Mutability;\n use syntax::source_map::Span;\n \n@@ -197,21 +198,12 @@ impl_snapshot_for!(enum ScalarMaybeUndef {\n     Undef,\n });\n \n-impl_stable_hash_for!(struct crate::interpret::MemPlace {\n-    ptr,\n-    align,\n-    meta,\n-});\n impl_snapshot_for!(struct MemPlace {\n     ptr,\n     meta,\n     align -> *align, // just copy alignment verbatim\n });\n \n-impl_stable_hash_for!(enum crate::interpret::Place {\n-    Ptr(mem_place),\n-    Local { frame, local },\n-});\n impl<'a, Ctx> Snapshot<'a, Ctx> for Place\n     where Ctx: SnapshotContext<'a>,\n {\n@@ -229,29 +221,16 @@ impl<'a, Ctx> Snapshot<'a, Ctx> for Place\n     }\n }\n \n-impl_stable_hash_for!(enum crate::interpret::Immediate {\n-    Scalar(x),\n-    ScalarPair(x, y),\n-});\n impl_snapshot_for!(enum Immediate {\n     Scalar(s),\n     ScalarPair(s, t),\n });\n \n-impl_stable_hash_for!(enum crate::interpret::Operand {\n-    Immediate(x),\n-    Indirect(x),\n-});\n impl_snapshot_for!(enum Operand {\n     Immediate(v),\n     Indirect(m),\n });\n \n-impl_stable_hash_for!(enum crate::interpret::LocalValue {\n-    Dead,\n-    Uninitialized,\n-    Live(x),\n-});\n impl_snapshot_for!(enum LocalValue {\n     Dead,\n     Uninitialized,\n@@ -314,11 +293,6 @@ impl<'a, Ctx> Snapshot<'a, Ctx> for &'a Allocation\n     }\n }\n \n-impl_stable_hash_for!(enum crate::interpret::eval_context::StackPopCleanup {\n-    Goto { ret, unwind },\n-    None { cleanup },\n-});\n-\n #[derive(Eq, PartialEq)]\n struct FrameSnapshot<'a, 'tcx> {\n     instance: ty::Instance<'tcx>,\n@@ -383,11 +357,6 @@ impl<'a, 'tcx, Ctx> Snapshot<'a, Ctx> for &'a LocalState<'tcx>\n     }\n }\n \n-impl_stable_hash_for!(struct LocalState<'tcx> {\n-    value,\n-    layout -> _,\n-});\n-\n impl<'b, 'mir, 'tcx> SnapshotContext<'b>\n     for Memory<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>\n {\n@@ -399,7 +368,10 @@ impl<'b, 'mir, 'tcx> SnapshotContext<'b>\n /// The virtual machine state during const-evaluation at a given point in time.\n /// We assume the `CompileTimeInterpreter` has no interesting extra state that\n /// is worth considering here.\n+#[derive(HashStable)]\n struct InterpSnapshot<'mir, 'tcx> {\n+    // Not hashing memory: Avoid hashing memory all the time during execution\n+    #[stable_hasher(ignore)]\n     memory: Memory<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>,\n     stack: Vec<Frame<'mir, 'tcx>>,\n }\n@@ -434,12 +406,6 @@ impl<'mir, 'tcx> Hash for InterpSnapshot<'mir, 'tcx> {\n     }\n }\n \n-impl_stable_hash_for!(impl<> for struct InterpSnapshot<'mir, 'tcx> {\n-    // Not hashing memory: Avoid hashing memory all the time during execution\n-    memory -> _,\n-    stack,\n-});\n-\n impl<'mir, 'tcx> Eq for InterpSnapshot<'mir, 'tcx> {}\n \n impl<'mir, 'tcx> PartialEq for InterpSnapshot<'mir, 'tcx> {"}, {"sha": "6847e45458a0bd49129083ad5a9bf65f646a9500", "filename": "src/librustc_passes/liveness.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc_passes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustc_passes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fliveness.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -987,8 +987,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         opt_expr.map_or(succ, |expr| self.propagate_through_expr(expr, succ))\n     }\n \n-    fn propagate_through_expr(&mut self, expr: &Expr, succ: LiveNode)\n-                              -> LiveNode {\n+    fn propagate_through_expr(&mut self, expr: &Expr, succ: LiveNode) -> LiveNode {\n         debug!(\"propagate_through_expr: {}\", self.ir.tcx.hir().hir_to_pretty_string(expr.hir_id));\n \n         match expr.kind {\n@@ -1074,7 +1073,15 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n                 match target {\n                     Some(b) => self.propagate_through_opt_expr(opt_expr.as_ref().map(|e| &**e), b),\n-                    None => span_bug!(expr.span, \"break to unknown label\")\n+                    None => {\n+                        // FIXME: This should have been checked earlier. Once this is fixed,\n+                        // replace with `delay_span_bug`. (#62480)\n+                        self.ir.tcx.sess.struct_span_err(\n+                            expr.span,\n+                            \"`break` to unknown label\",\n+                        ).emit();\n+                        errors::FatalError.raise()\n+                    }\n                 }\n             }\n "}, {"sha": "a6f37053687c995d6cff07eaeddb86a4803c54db", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -87,10 +87,11 @@ pub fn render<T: Print, S: Print>(\n     </div>\\\n     <script src=\\\"{static_root_path}theme{suffix}.js\\\"></script>\\\n     <nav class=\\\"sub\\\">\\\n-        <form class=\\\"search-form js-only\\\">\\\n+        <form class=\\\"search-form\\\">\\\n             <div class=\\\"search-container\\\">\\\n                 <div>{filter_crates}\\\n                     <input class=\\\"search-input\\\" name=\\\"search\\\" \\\n+                           disabled \\\n                            autocomplete=\\\"off\\\" \\\n                            spellcheck=\\\"false\\\" \\\n                            placeholder=\\\"Click or press \u2018S\u2019 to search, \u2018?\u2019 for more options\u2026\\\" \\"}, {"sha": "bd2a6602e16bee657c9778ed87ae49f492e08c22", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -882,7 +882,9 @@ themePicker.onblur = handleThemeButtonsBlur;\n         v.push_str(&minify_replacer(\n             &format!(\"{}\\n{}\", variables.join(\"\"), all_indexes.join(\"\\n\")),\n             options.enable_minification));\n-        v.push_str(\"initSearch(searchIndex);addSearchOptions(searchIndex);\");\n+        // \"addSearchOptions\" has to be called first so the crate filtering can be set before the\n+        // search might start (if it's set into the URL for example).\n+        v.push_str(\"addSearchOptions(searchIndex);initSearch(searchIndex);\");\n         cx.shared.fs.write(&dst, &v)?;\n     }\n     if options.enable_index_page {"}, {"sha": "cc0f470b3492030af9fd65fddd68aed520ded815", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -142,10 +142,6 @@ function getSearchElement() {\n     var TY_PRIMITIVE = itemTypes.indexOf(\"primitive\");\n     var TY_KEYWORD = itemTypes.indexOf(\"keyword\");\n \n-    onEachLazy(document.getElementsByClassName(\"js-only\"), function(e) {\n-        removeClass(e, \"js-only\");\n-    });\n-\n     function getQueryStringParams() {\n         var params = {};\n         window.location.search.substring(1).split(\"&\").\n@@ -525,21 +521,6 @@ function getSearchElement() {\n         var OUTPUT_DATA = 1;\n         var params = getQueryStringParams();\n \n-        // Set the crate filter from saved storage, if the current page has the saved crate filter.\n-        //\n-        // If not, ignore the crate filter -- we want to support filtering for crates on sites like\n-        // doc.rust-lang.org where the crates may differ from page to page while on the same domain.\n-        var savedCrate = getCurrentValue(\"rustdoc-saved-filter-crate\");\n-        if (savedCrate !== null) {\n-            onEachLazy(document.getElementById(\"crate-search\").getElementsByTagName(\"option\"),\n-                       function(e) {\n-                if (e.value === savedCrate) {\n-                    document.getElementById(\"crate-search\").value = e.value;\n-                    return true;\n-                }\n-            });\n-        }\n-\n         // Populate search bar with query string search term when provided,\n         // but only if the input bar is empty. This avoid the obnoxious issue\n         // where you start trying to do a search, and the index loads, and\n@@ -2633,12 +2614,26 @@ function getSearchElement() {\n             }\n             return 0;\n         });\n+        var savedCrate = getCurrentValue(\"rustdoc-saved-filter-crate\");\n         for (var i = 0; i < crates_text.length; ++i) {\n             var option = document.createElement(\"option\");\n             option.value = crates_text[i];\n             option.innerText = crates_text[i];\n             elem.appendChild(option);\n+            // Set the crate filter from saved storage, if the current page has the saved crate\n+            // filter.\n+            //\n+            // If not, ignore the crate filter -- we want to support filtering for crates on sites\n+            // like doc.rust-lang.org where the crates may differ from page to page while on the\n+            // same domain.\n+            if (crates_text[i] === savedCrate) {\n+                elem.value = savedCrate;\n+            }\n         }\n+\n+        if (search_input) {\n+            search_input.removeAttribute('disabled');\n+        };\n     }\n \n     window.addSearchOptions = addSearchOptions;"}, {"sha": "b2c48bf089b1b242416451b7c95a16c91c83cec6", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -203,7 +203,7 @@ nav.sub {\n \n /* Everything else */\n \n-.js-only, .hidden {\n+.hidden {\n \tdisplay: none !important;\n }\n "}, {"sha": "f46bd6d6a10052530880791548e987c46ffe38c3", "filename": "src/librustdoc/html/static/themes/dark.css", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -177,6 +177,10 @@ a.test-arrow {\n \tborder-color: #008dfd;\n }\n \n+.search-focus:disabled {\n+\tbackground-color: #c5c4c4;\n+}\n+\n #crate-search + .search-input:focus {\n \tbox-shadow: 0 0 8px 4px #078dd8;\n }"}, {"sha": "ca67b1c1f8241993e474b0f0824447ba4d889ebf", "filename": "src/librustdoc/html/static/themes/light.css", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -177,6 +177,10 @@ a.test-arrow {\n \tborder-color: #66afe9;\n }\n \n+.search-focus:disabled {\n+\tbackground-color: #e6e6e6;\n+}\n+\n #crate-search + .search-input:focus {\n \tbox-shadow: 0 0 8px #078dd8;\n }"}, {"sha": "a13a4475ef01cd270bdac96798ffd3496d082834", "filename": "src/libsyntax/feature_gate/builtin_attrs.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibsyntax%2Ffeature_gate%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibsyntax%2Ffeature_gate%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fbuiltin_attrs.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -543,7 +543,10 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     rustc_attr!(TEST, rustc_variance, Normal, template!(Word)),\n     rustc_attr!(TEST, rustc_layout, Normal, template!(List: \"field1, field2, ...\")),\n     rustc_attr!(TEST, rustc_regions, Normal, template!(Word)),\n-    rustc_attr!(TEST, rustc_error, Whitelisted, template!(Word)),\n+    rustc_attr!(\n+        TEST, rustc_error, Whitelisted,\n+        template!(Word, List: \"delay_span_bug_from_inside_query\")\n+    ),\n     rustc_attr!(TEST, rustc_dump_user_substs, Whitelisted, template!(Word)),\n     rustc_attr!(TEST, rustc_if_this_changed, Whitelisted, template!(Word, List: \"DepNode\")),\n     rustc_attr!(TEST, rustc_then_this_would_need, Whitelisted, template!(List: \"DepNode\")),"}, {"sha": "1139bf67a36d09ded74f31816c75695af5bf5ba7", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -236,6 +236,7 @@ symbols! {\n         default_lib_allocator,\n         default_type_parameter_fallback,\n         default_type_params,\n+        delay_span_bug_from_inside_query,\n         deny,\n         deprecated,\n         deref,"}, {"sha": "2529e531e30ad18d1d255f17d9c3bc33a0d89aab", "filename": "src/test/incremental/delayed_span_bug.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fincremental%2Fdelayed_span_bug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fincremental%2Fdelayed_span_bug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fdelayed_span_bug.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -0,0 +1,8 @@\n+// revisions: cfail1 cfail2\n+// should-ice\n+// error-pattern: delayed span bug triggered by #[rustc_error(delay_span_bug_from_inside_query)]\n+\n+#![feature(rustc_attrs)]\n+\n+#[rustc_error(delay_span_bug_from_inside_query)]\n+fn main() {}"}, {"sha": "fc912efed5e3caca873de9c1fa46e98cf0cd31f0", "filename": "src/test/run-make-fulldeps/reproducible-build-2/Makefile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Frun-make-fulldeps%2Freproducible-build-2%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Frun-make-fulldeps%2Freproducible-build-2%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Freproducible-build-2%2FMakefile?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -2,6 +2,7 @@\n \n # ignore-musl\n # ignore-windows\n+# ignore-macos (rust-lang/rust#66568)\n # Objects are reproducible but their path is not.\n \n all:  \\"}, {"sha": "4e6754c865dcef8173dc85e6e3d5737dc573540d", "filename": "src/test/ui/associated-types/bound-lifetime-constrained.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-constrained.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-constrained.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-constrained.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -45,4 +45,4 @@ fn clause2<T>() where T: for<'a> Fn() -> <() as Foo<'a>>::Item {\n }\n \n #[rustc_error]\n-fn main() { } //[ok]~ ERROR compilation successful\n+fn main() { } //[ok]~ ERROR fatal error triggered by #[rustc_error]"}, {"sha": "5ece425196c777cba7e326998a661cea4798bcdd", "filename": "src/test/ui/associated-types/bound-lifetime-in-binding-only.ok.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-binding-only.ok.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-binding-only.ok.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-binding-only.ok.stderr?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -1,4 +1,4 @@\n-error: compilation successful\n+error: fatal error triggered by #[rustc_error]\n   --> $DIR/bound-lifetime-in-binding-only.rs:71:1\n    |\n LL | fn main() { }"}, {"sha": "e714457ef7b382ecd7d7abe819927cd6851c94ac", "filename": "src/test/ui/associated-types/bound-lifetime-in-binding-only.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-binding-only.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-binding-only.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-binding-only.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -68,4 +68,4 @@ fn ok3<T>() where for<'a> Parameterized<'a>: Foo<Item=&'a i32> {\n }\n \n #[rustc_error]\n-fn main() { } //[ok]~ ERROR compilation successful\n+fn main() { } //[ok]~ ERROR fatal error triggered by #[rustc_error]"}, {"sha": "8c0980983119b9e2eba30177d3da56d5d9f190e8", "filename": "src/test/ui/associated-types/bound-lifetime-in-return-only.ok.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-return-only.ok.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-return-only.ok.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-return-only.ok.stderr?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -1,4 +1,4 @@\n-error: compilation successful\n+error: fatal error triggered by #[rustc_error]\n   --> $DIR/bound-lifetime-in-return-only.rs:49:1\n    |\n LL | fn main() { }"}, {"sha": "a60ccb6c4b28d8e8d443af37544620f33796fa33", "filename": "src/test/ui/associated-types/bound-lifetime-in-return-only.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-return-only.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-return-only.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fbound-lifetime-in-return-only.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -46,4 +46,4 @@ fn ok2(_: &dyn for<'a,'b> Fn<(&'b Parameterized<'a>,), Output=&'a i32>) {\n }\n \n #[rustc_error]\n-fn main() { } //[ok]~ ERROR compilation successful\n+fn main() { } //[ok]~ ERROR fatal error triggered by #[rustc_error]"}, {"sha": "baa8e6f82f646fa0fa55d7355d370c4285656b18", "filename": "src/test/ui/associated-types/cache/project-fn-ret-contravariant.ok.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-contravariant.ok.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-contravariant.ok.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-contravariant.ok.stderr?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -1,4 +1,4 @@\n-error: compilation successful\n+error: fatal error triggered by #[rustc_error]\n   --> $DIR/project-fn-ret-contravariant.rs:50:1\n    |\n LL | fn main() { }"}, {"sha": "baa8e6f82f646fa0fa55d7355d370c4285656b18", "filename": "src/test/ui/associated-types/cache/project-fn-ret-contravariant.oneuse.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-contravariant.oneuse.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-contravariant.oneuse.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-contravariant.oneuse.stderr?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -1,4 +1,4 @@\n-error: compilation successful\n+error: fatal error triggered by #[rustc_error]\n   --> $DIR/project-fn-ret-contravariant.rs:50:1\n    |\n LL | fn main() { }"}, {"sha": "ebf52918153c1678c15cd0d080faddb127dce564", "filename": "src/test/ui/associated-types/cache/project-fn-ret-contravariant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-contravariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-contravariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-contravariant.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -48,5 +48,5 @@ fn transmute<'a,'b>(x: &'a u32, y: &'b u32) -> (&'a u32, &'b u32) {\n \n #[rustc_error]\n fn main() { }\n-//[ok]~^ ERROR compilation successful\n-//[oneuse]~^^ ERROR compilation successful\n+//[ok]~^ ERROR fatal error triggered by #[rustc_error]\n+//[oneuse]~^^ ERROR fatal error triggered by #[rustc_error]"}, {"sha": "8f445acf2b98cf4fae8b7327221c731c98ecda97", "filename": "src/test/ui/associated-types/cache/project-fn-ret-invariant.ok.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.ok.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.ok.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.ok.stderr?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -1,4 +1,4 @@\n-error: compilation successful\n+error: fatal error triggered by #[rustc_error]\n   --> $DIR/project-fn-ret-invariant.rs:59:1\n    |\n LL | fn main() { }"}, {"sha": "23d873212ed1edbe7741fd67a35e0b1662d13e50", "filename": "src/test/ui/associated-types/cache/project-fn-ret-invariant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -57,4 +57,4 @@ fn transmute<'a,'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n \n #[rustc_error]\n fn main() { }\n-//[ok]~^ ERROR compilation successful\n+//[ok]~^ ERROR fatal error triggered by #[rustc_error]"}, {"sha": "63d88543607f3635f7db9156f21ed684138742cd", "filename": "src/test/ui/associated-types/higher-ranked-projection.good.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fassociated-types%2Fhigher-ranked-projection.good.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fassociated-types%2Fhigher-ranked-projection.good.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhigher-ranked-projection.good.stderr?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -1,4 +1,4 @@\n-error: compilation successful\n+error: fatal error triggered by #[rustc_error]\n   --> $DIR/higher-ranked-projection.rs:24:1\n    |\n LL | / fn main() {"}, {"sha": "5315e21b0f5a9ea2545d15d5e3550374b75c59f4", "filename": "src/test/ui/associated-types/higher-ranked-projection.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fassociated-types%2Fhigher-ranked-projection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fassociated-types%2Fhigher-ranked-projection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhigher-ranked-projection.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -21,7 +21,7 @@ fn foo<U, T>(_t: T)\n {}\n \n #[rustc_error]\n-fn main() { //[good]~ ERROR compilation successful\n+fn main() { //[good]~ ERROR fatal error triggered by #[rustc_error]\n     foo(());\n     //[bad]~^ ERROR type mismatch\n }"}, {"sha": "6aba6466fada53b920ef1bcd13d0eaf27a98ebec", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_a_vs_bound_a.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_vs_bound_a.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_vs_bound_a.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_vs_bound_a.stderr?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -1,4 +1,4 @@\n-error: compilation successful\n+error: fatal error triggered by #[rustc_error]\n   --> $DIR/hr-subtype.rs:100:1\n    |\n LL | / fn main() {"}, {"sha": "6aba6466fada53b920ef1bcd13d0eaf27a98ebec", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_a_vs_bound_b.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_vs_bound_b.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_vs_bound_b.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_vs_bound_b.stderr?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -1,4 +1,4 @@\n-error: compilation successful\n+error: fatal error triggered by #[rustc_error]\n   --> $DIR/hr-subtype.rs:100:1\n    |\n LL | / fn main() {"}, {"sha": "6aba6466fada53b920ef1bcd13d0eaf27a98ebec", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_co_a_vs_bound_co_b.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_co_a_vs_bound_co_b.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_co_a_vs_bound_co_b.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_co_a_vs_bound_co_b.stderr?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -1,4 +1,4 @@\n-error: compilation successful\n+error: fatal error triggered by #[rustc_error]\n   --> $DIR/hr-subtype.rs:100:1\n    |\n LL | / fn main() {"}, {"sha": "6aba6466fada53b920ef1bcd13d0eaf27a98ebec", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_inv_a_vs_bound_inv_b.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_inv_a_vs_bound_inv_b.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_inv_a_vs_bound_inv_b.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_inv_a_vs_bound_inv_b.stderr?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -1,4 +1,4 @@\n-error: compilation successful\n+error: fatal error triggered by #[rustc_error]\n   --> $DIR/hr-subtype.rs:100:1\n    |\n LL | / fn main() {"}, {"sha": "6aba6466fada53b920ef1bcd13d0eaf27a98ebec", "filename": "src/test/ui/hr-subtype/hr-subtype.free_x_vs_free_x.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_x_vs_free_x.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_x_vs_free_x.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_x_vs_free_x.stderr?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -1,4 +1,4 @@\n-error: compilation successful\n+error: fatal error triggered by #[rustc_error]\n   --> $DIR/hr-subtype.rs:100:1\n    |\n LL | / fn main() {"}, {"sha": "b31f198bd97bf8cee87182f5f2efae6780ce8870", "filename": "src/test/ui/hr-subtype/hr-subtype.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -98,9 +98,9 @@ check! { bound_a_b_ret_a_vs_bound_a_ret_a: (for<'a,'b> fn(&'a u32, &'b u32) -> &\n \n #[rustc_error]\n fn main() {\n-//[bound_a_vs_bound_a]~^ ERROR compilation successful\n-//[bound_a_vs_bound_b]~^^ ERROR compilation successful\n-//[bound_inv_a_vs_bound_inv_b]~^^^ ERROR compilation successful\n-//[bound_co_a_vs_bound_co_b]~^^^^ ERROR compilation successful\n-//[free_x_vs_free_x]~^^^^^ ERROR compilation successful\n+//[bound_a_vs_bound_a]~^ ERROR fatal error triggered by #[rustc_error]\n+//[bound_a_vs_bound_b]~^^ ERROR fatal error triggered by #[rustc_error]\n+//[bound_inv_a_vs_bound_inv_b]~^^^ ERROR fatal error triggered by #[rustc_error]\n+//[bound_co_a_vs_bound_co_b]~^^^^ ERROR fatal error triggered by #[rustc_error]\n+//[free_x_vs_free_x]~^^^^^ ERROR fatal error triggered by #[rustc_error]\n }"}, {"sha": "bc3e6c69a60243bcfd3db7218be15920435559f6", "filename": "src/test/ui/issues/issue-62480.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fissues%2Fissue-62480.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fissues%2Fissue-62480.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-62480.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -0,0 +1,10 @@\n+#![feature(label_break_value)]\n+\n+fn main() {\n+    // This used to ICE during liveness check because `target_id` passed to\n+    // `propagate_through_expr` would be the closure and not the `loop`, which wouldn't be found in\n+    // `self.break_ln`. (#62480)\n+    'a: {\n+        || break 'a //~ ERROR `break` to unknown label\n+    }\n+}"}, {"sha": "de8451ad7df0a7554907d21c599eb27bad5c8abb", "filename": "src/test/ui/issues/issue-62480.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fissues%2Fissue-62480.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fissues%2Fissue-62480.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-62480.stderr?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -0,0 +1,8 @@\n+error: `break` to unknown label\n+  --> $DIR/issue-62480.rs:8:12\n+   |\n+LL |         || break 'a\n+   |            ^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "a8a8fa4e19a4a91756f9a6f6d7a7e2886d28adbd", "filename": "src/test/ui/proc-macro/no-macro-use-attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fproc-macro%2Fno-macro-use-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fproc-macro%2Fno-macro-use-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fno-macro-use-attr.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -7,4 +7,4 @@ extern crate test_macros;\n //~^ WARN unused extern crate\n \n #[rustc_error]\n-fn main() {} //~ ERROR compilation successful\n+fn main() {} //~ ERROR fatal error triggered by #[rustc_error]"}, {"sha": "50552ea7dbb68a61ccf91243015e8750c254c605", "filename": "src/test/ui/proc-macro/no-macro-use-attr.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fproc-macro%2Fno-macro-use-attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Fproc-macro%2Fno-macro-use-attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fno-macro-use-attr.stderr?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -10,7 +10,7 @@ note: lint level defined here\n LL | #![warn(unused_extern_crates)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n-error: compilation successful\n+error: fatal error triggered by #[rustc_error]\n   --> $DIR/no-macro-use-attr.rs:10:1\n    |\n LL | fn main() {}"}, {"sha": "21addfab8f50da51dab0c8c65eab2648cf317a93", "filename": "src/test/ui/rfc1445/feature-gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Frfc1445%2Ffeature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Frfc1445%2Ffeature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Ffeature-gate.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -18,7 +18,7 @@ struct Foo {\n const FOO: Foo = Foo { x: 0 };\n \n #[rustc_error]\n-fn main() { //[with_gate]~ ERROR compilation successful\n+fn main() { //[with_gate]~ ERROR fatal error triggered by #[rustc_error]\n     let y = Foo { x: 1 };\n     match y {\n         FOO => { }"}, {"sha": "fabbfd5c70bb901b9ed0c4cc81e68e698d244c0d", "filename": "src/test/ui/rfc1445/feature-gate.with_gate.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Frfc1445%2Ffeature-gate.with_gate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Frfc1445%2Ffeature-gate.with_gate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Ffeature-gate.with_gate.stderr?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -1,4 +1,4 @@\n-error: compilation successful\n+error: fatal error triggered by #[rustc_error]\n   --> $DIR/feature-gate.rs:21:1\n    |\n LL | / fn main() {"}, {"sha": "69d57948fb5e74a27b7eeb36d2305e7bffe8f805", "filename": "src/test/ui/rustc-error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Frustc-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Frustc-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frustc-error.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -2,5 +2,5 @@\n \n #[rustc_error]\n fn main() {\n-    //~^ ERROR compilation successful\n+    //~^ ERROR fatal error triggered by #[rustc_error]\n }"}, {"sha": "7dfc44492959473f8d5f9c9c61afdad183a828ce", "filename": "src/test/ui/rustc-error.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Frustc-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftest%2Fui%2Frustc-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frustc-error.stderr?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -1,4 +1,4 @@\n-error: compilation successful\n+error: fatal error triggered by #[rustc_error]\n   --> $DIR/rustc-error.rs:4:1\n    |\n LL | / fn main() {"}, {"sha": "dc4811e5d24ce96d422eabbd573fbd8a9cffb441", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -375,6 +375,8 @@ pub struct TestProps {\n     // If true, `rustfix` will only apply `MachineApplicable` suggestions.\n     pub rustfix_only_machine_applicable: bool,\n     pub assembly_output: Option<String>,\n+    // If true, the test is expected to ICE\n+    pub should_ice: bool,\n }\n \n impl TestProps {\n@@ -413,6 +415,7 @@ impl TestProps {\n             run_rustfix: false,\n             rustfix_only_machine_applicable: false,\n             assembly_output: None,\n+            should_ice: false,\n         }\n     }\n \n@@ -463,6 +466,10 @@ impl TestProps {\n                 self.pp_exact = config.parse_pp_exact(ln, testfile);\n             }\n \n+            if !self.should_ice {\n+                self.should_ice = config.parse_should_ice(ln);\n+            }\n+\n             if !self.build_aux_docs {\n                 self.build_aux_docs = config.parse_build_aux_docs(ln);\n             }\n@@ -577,6 +584,9 @@ impl TestProps {\n                 _ => 1,\n             };\n         }\n+        if self.should_ice {\n+            self.failure_status = 101;\n+        }\n \n         for key in &[\"RUST_TEST_NOCAPTURE\", \"RUST_TEST_THREADS\"] {\n             if let Ok(val) = env::var(key) {\n@@ -687,6 +697,9 @@ fn iter_header(testfile: &Path, cfg: Option<&str>, it: &mut dyn FnMut(&str)) {\n }\n \n impl Config {\n+    fn parse_should_ice(&self, line: &str) -> bool {\n+        self.parse_name_directive(line, \"should-ice\")\n+    }\n     fn parse_error_pattern(&self, line: &str) -> Option<String> {\n         self.parse_name_value_directive(line, \"error-pattern\")\n     }"}, {"sha": "15ae67fb12c516a0484e84ab59c7d9424d83944d", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "patch": "@@ -298,6 +298,12 @@ impl<'test> TestCx<'test> {\n     /// Code executed for each revision in turn (or, if there are no\n     /// revisions, exactly once, with revision == None).\n     fn run_revision(&self) {\n+        if self.props.should_ice {\n+            if self.config.mode != CompileFail &&\n+                self.config.mode != Incremental {\n+                self.fatal(\"cannot use should-ice in a test that is not cfail\");\n+            }\n+        }\n         match self.config.mode {\n             CompileFail => self.run_cfail_test(),\n             RunFail => self.run_rfail_test(),\n@@ -383,7 +389,7 @@ impl<'test> TestCx<'test> {\n     fn run_cfail_test(&self) {\n         let proc_res = self.compile_test();\n         self.check_if_test_should_compile(&proc_res);\n-        self.check_no_compiler_crash(&proc_res);\n+        self.check_no_compiler_crash(&proc_res, self.props.should_ice);\n \n         let output_to_check = self.get_output(&proc_res);\n         let expected_errors = errors::load_errors(&self.testpaths.file, self.revision);\n@@ -395,6 +401,12 @@ impl<'test> TestCx<'test> {\n         } else {\n             self.check_error_patterns(&output_to_check, &proc_res);\n         }\n+        if self.props.should_ice {\n+            match proc_res.status.code() {\n+                Some(101) => (),\n+                _ => self.fatal(\"expected ICE\"),\n+            }\n+        }\n \n         self.check_forbid_output(&output_to_check, &proc_res);\n     }\n@@ -1402,9 +1414,11 @@ impl<'test> TestCx<'test> {\n         }\n     }\n \n-    fn check_no_compiler_crash(&self, proc_res: &ProcRes) {\n+    fn check_no_compiler_crash(&self, proc_res: &ProcRes, should_ice: bool) {\n         match proc_res.status.code() {\n-            Some(101) => self.fatal_proc_rec(\"compiler encountered internal error\", proc_res),\n+            Some(101) if !should_ice => {\n+                self.fatal_proc_rec(\"compiler encountered internal error\", proc_res)\n+            }\n             None => self.fatal_proc_rec(\"compiler terminated by signal\", proc_res),\n             _ => (),\n         }\n@@ -2518,7 +2532,7 @@ impl<'test> TestCx<'test> {\n             self.fatal_proc_rec(\"compilation failed!\", &proc_res);\n         }\n \n-        self.check_no_compiler_crash(&proc_res);\n+        self.check_no_compiler_crash(&proc_res, self.props.should_ice);\n \n         const PREFIX: &'static str = \"MONO_ITEM \";\n         const CGU_MARKER: &'static str = \"@@\";\n@@ -2774,8 +2788,14 @@ impl<'test> TestCx<'test> {\n         }\n \n         if revision.starts_with(\"rpass\") {\n+            if revision_cx.props.should_ice {\n+                revision_cx.fatal(\"can only use should-ice in cfail tests\");\n+            }\n             revision_cx.run_rpass_test();\n         } else if revision.starts_with(\"rfail\") {\n+            if revision_cx.props.should_ice {\n+                revision_cx.fatal(\"can only use should-ice in cfail tests\");\n+            }\n             revision_cx.run_rfail_test();\n         } else if revision.starts_with(\"cfail\") {\n             revision_cx.run_cfail_test();"}]}