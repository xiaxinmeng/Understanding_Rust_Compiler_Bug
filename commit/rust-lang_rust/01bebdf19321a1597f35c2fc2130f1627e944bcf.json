{"sha": "01bebdf19321a1597f35c2fc2130f1627e944bcf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxYmViZGYxOTMyMWExNTk3ZjM1YzJmYzIxMzBmMTYyN2U5NDRiY2Y=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2019-02-17T23:31:41Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2019-02-17T23:31:41Z"}, "message": "Merge remote-tracking branch 'upstream/master'", "tree": {"sha": "2c71bc6a77545eacabdc67b1fcaa5f52dd22878c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c71bc6a77545eacabdc67b1fcaa5f52dd22878c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01bebdf19321a1597f35c2fc2130f1627e944bcf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01bebdf19321a1597f35c2fc2130f1627e944bcf", "html_url": "https://github.com/rust-lang/rust/commit/01bebdf19321a1597f35c2fc2130f1627e944bcf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01bebdf19321a1597f35c2fc2130f1627e944bcf/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b9ad6e6fd017837647eed8e5ae824d1f6e278b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b9ad6e6fd017837647eed8e5ae824d1f6e278b2", "html_url": "https://github.com/rust-lang/rust/commit/0b9ad6e6fd017837647eed8e5ae824d1f6e278b2"}, {"sha": "9a3392e174a432a5f06c1157befc1ce0fae74bec", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a3392e174a432a5f06c1157befc1ce0fae74bec", "html_url": "https://github.com/rust-lang/rust/commit/9a3392e174a432a5f06c1157befc1ce0fae74bec"}], "stats": {"total": 40262, "additions": 22847, "deletions": 17415}, "files": [{"sha": "d603e4575159df2edea87b55d70debd64bceeb7c", "filename": ".gitmodules", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -44,3 +44,6 @@\n \tpath = src/llvm-project\n \turl = https://github.com/rust-lang/llvm-project.git\n \tbranch = rustc/8.0-2019-01-16\n+[submodule \"src/doc/embedded-book\"]\n+\tpath = src/doc/embedded-book\n+\turl = https://github.com/rust-embedded/book.git\n\\ No newline at end of file"}, {"sha": "963bbcf0f0429b59a0164a95b6f5e7b981aa02b2", "filename": "Cargo.lock", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,3 +1,5 @@\n+# This file is automatically @generated by Cargo.\n+# It is not intended for manual editing.\n [[package]]\n name = \"adler32\"\n version = \"1.0.3\"\n@@ -75,8 +77,8 @@ dependencies = [\n  \"colored 1.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"difference 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"environment 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"failure 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"failure_derive 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"failure_derive 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -237,7 +239,7 @@ dependencies = [\n  \"curl 0.4.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"curl-sys 0.4.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"failure 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"filetime 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"flate2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"fs2 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -530,7 +532,7 @@ name = \"crates-io\"\n version = \"0.23.0\"\n dependencies = [\n  \"curl 0.4.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"failure 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.81 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -841,16 +843,16 @@ dependencies = [\n \n [[package]]\n name = \"failure\"\n-version = \"0.1.3\"\n+version = \"0.1.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"backtrace 0.3.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"failure_derive 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"failure_derive 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"failure_derive\"\n-version = \"0.1.3\"\n+version = \"0.1.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1503,7 +1505,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"minifier\"\n-version = \"0.0.26\"\n+version = \"0.0.28\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"macro-utils 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1677,8 +1679,8 @@ name = \"opener\"\n version = \"0.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"failure 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"failure_derive 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"failure_derive 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -2254,7 +2256,7 @@ dependencies = [\n  \"crossbeam-channel 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"difference 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"failure 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"futures 0.1.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"home 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"itertools 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2820,7 +2822,6 @@ name = \"rustc_mir\"\n version = \"0.0.0\"\n dependencies = [\n  \"arena 0.0.0\",\n- \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"byteorder 1.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"either 1.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"graphviz 0.0.0\",\n@@ -2992,7 +2993,7 @@ dependencies = [\n name = \"rustdoc\"\n version = \"0.0.0\"\n dependencies = [\n- \"minifier 0.0.26 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"minifier 0.0.28 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.6.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pulldown-cmark 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tempfile 3.0.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -3014,7 +3015,7 @@ name = \"rustfix\"\n version = \"0.4.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"failure 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.81 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -3032,7 +3033,7 @@ dependencies = [\n  \"derive-new 0.5.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"diff 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.5.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"failure 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"itertools 0.7.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -3818,7 +3819,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"chrono 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"failure 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -3997,8 +3998,8 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum environment 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1f4b14e20978669064c33b4c1e0fb4083412e40fe56cbea2eae80fd7591503ee\"\n \"checksum error-chain 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ff511d5dc435d703f4971bc399647c9bc38e20cb41452e3b9feb4765419ed3f3\"\n \"checksum error-chain 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"07e791d3be96241c77c43846b665ef1384606da2cd2a48730abe606a12906e02\"\n-\"checksum failure 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6dd377bcc1b1b7ce911967e3ec24fa19c3224394ec05b54aa7b083d498341ac7\"\n-\"checksum failure_derive 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"64c2d913fe8ed3b6c6518eedf4538255b989945c14c2a7d5cbff62a5e2120596\"\n+\"checksum failure 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"795bd83d3abeb9220f257e597aa0080a508b27533824adf336529648f6abf7e2\"\n+\"checksum failure_derive 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ea1063915fd7ef4309e222a5a07cf9c319fb9c7836b1f89b85458672dbb127e1\"\n \"checksum fake-simd 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e88a8acf291dafb59c2d96e8f59828f3838bb1a70398823ade51a84de6a6deed\"\n \"checksum filetime 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a2df5c1a8c4be27e7707789dc42ae65976e60b394afd293d1419ab915833e646\"\n \"checksum fixedbitset 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"86d4de0081402f5e88cdac65c8dcdcc73118c1a7a465e2a05f0da05843a8ea33\"\n@@ -4066,7 +4067,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum memchr 2.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0a3eb002f0535929f1199681417029ebea04aadc0c7a4224b46be99c7f5d6a16\"\n \"checksum memmap 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e2ffa2c986de11a9df78620c01eeaaf27d94d3ff02bf81bfcca953102dd0c6ff\"\n \"checksum memoffset 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0f9dc261e2b62d7a622bf416ea3c5245cdd5d9a7fcc428c0d06804dfce1775b3\"\n-\"checksum minifier 0.0.26 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f299df45afd73332044ea9f717c816a84fc90c8b631409abf339ba93642a7985\"\n+\"checksum minifier 0.0.28 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3a2898502751dcc9d66b6fff57f3cf63cc91605e83e1a33515396f5027f8e4ca\"\n \"checksum miniz-sys 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0300eafb20369952951699b68243ab4334f4b10a88f411c221d444b36c40e649\"\n \"checksum miniz_oxide 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5ad30a47319c16cde58d0314f5d98202a80c9083b5f61178457403dfb14e509c\"\n \"checksum miniz_oxide_c_api 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"28edaef377517fd9fe3e085c37d892ce7acd1fbeab9239c5a36eec352d8a8b7e\""}, {"sha": "aeb15821b0bb742c32e35d8cccb2e70fd048f675", "filename": "src/bootstrap/bin/rustdoc.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustdoc.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -16,6 +16,7 @@ fn main() {\n     let libdir = env::var_os(\"RUSTDOC_LIBDIR\").expect(\"RUSTDOC_LIBDIR was not set\");\n     let stage = env::var(\"RUSTC_STAGE\").expect(\"RUSTC_STAGE was not set\");\n     let sysroot = env::var_os(\"RUSTC_SYSROOT\").expect(\"RUSTC_SYSROOT was not set\");\n+    let mut has_unstable = false;\n \n     use std::str::FromStr;\n \n@@ -54,9 +55,22 @@ fn main() {\n     // it up so we can make rustdoc print this into the docs\n     if let Some(version) = env::var_os(\"RUSTDOC_CRATE_VERSION\") {\n         // This \"unstable-options\" can be removed when `--crate-version` is stabilized\n-        cmd.arg(\"-Z\")\n-           .arg(\"unstable-options\")\n-           .arg(\"--crate-version\").arg(version);\n+        if !has_unstable {\n+            cmd.arg(\"-Z\")\n+               .arg(\"unstable-options\");\n+        }\n+        cmd.arg(\"--crate-version\").arg(version);\n+        has_unstable = true;\n+    }\n+\n+    // Needed to be able to run all rustdoc tests.\n+    if let Some(_) = env::var_os(\"RUSTDOC_GENERATE_REDIRECT_PAGES\") {\n+        // This \"unstable-options\" can be removed when `--generate-redirect-pages` is stabilized\n+        if !has_unstable {\n+            cmd.arg(\"-Z\")\n+               .arg(\"unstable-options\");\n+        }\n+        cmd.arg(\"--generate-redirect-pages\");\n     }\n \n     if verbose > 1 {"}, {"sha": "9d037dad9ccbd15a9d88d379b59439fc39ae2da4", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -60,17 +60,17 @@ pub trait Step: 'static + Clone + Debug + PartialEq + Eq + Hash {\n     /// Run this rule for all hosts without cross compiling.\n     const ONLY_HOSTS: bool = false;\n \n-    /// Primary function to execute this rule. Can call `builder.ensure(...)`\n+    /// Primary function to execute this rule. Can call `builder.ensure()`\n     /// with other steps to run those.\n     fn run(self, builder: &Builder) -> Self::Output;\n \n     /// When bootstrap is passed a set of paths, this controls whether this rule\n     /// will execute. However, it does not get called in a \"default\" context\n-    /// when we are not passed any paths; in that case, make_run is called\n+    /// when we are not passed any paths; in that case, `make_run` is called\n     /// directly.\n     fn should_run(run: ShouldRun) -> ShouldRun;\n \n-    /// Build up a \"root\" rule, either as a default rule or from a path passed\n+    /// Builds up a \"root\" rule, either as a default rule or from a path passed\n     /// to us.\n     ///\n     /// When path is `None`, we are executing in a context where no paths were\n@@ -400,6 +400,7 @@ impl<'a> Builder<'a> {\n                 test::TheBook,\n                 test::UnstableBook,\n                 test::RustcBook,\n+                test::EmbeddedBook,\n                 test::Rustfmt,\n                 test::Miri,\n                 test::Clippy,\n@@ -430,6 +431,7 @@ impl<'a> Builder<'a> {\n                 doc::RustByExample,\n                 doc::RustcBook,\n                 doc::CargoBook,\n+                doc::EmbeddedBook,\n                 doc::EditionGuide,\n             ),\n             Kind::Dist => describe!(\n@@ -646,7 +648,7 @@ impl<'a> Builder<'a> {\n         add_lib_path(vec![self.rustc_libdir(compiler)], cmd);\n     }\n \n-    /// Get a path to the compiler specified.\n+    /// Gets a path to the compiler specified.\n     pub fn rustc(&self, compiler: Compiler) -> PathBuf {\n         if compiler.is_snapshot(self) {\n             self.initial_rustc.clone()\n@@ -657,7 +659,7 @@ impl<'a> Builder<'a> {\n         }\n     }\n \n-    /// Get the paths to all of the compiler's codegen backends.\n+    /// Gets the paths to all of the compiler's codegen backends.\n     fn codegen_backends(&self, compiler: Compiler) -> impl Iterator<Item = PathBuf> {\n         fs::read_dir(self.sysroot_codegen_backends(compiler))\n             .into_iter()\n@@ -675,10 +677,9 @@ impl<'a> Builder<'a> {\n         let compiler = self.compiler(self.top_stage, host);\n         cmd.env(\"RUSTC_STAGE\", compiler.stage.to_string())\n             .env(\"RUSTC_SYSROOT\", self.sysroot(compiler))\n-            .env(\n-                \"RUSTDOC_LIBDIR\",\n-                self.sysroot_libdir(compiler, self.config.build),\n-            )\n+            // Note that this is *not* the sysroot_libdir because rustdoc must be linked\n+            // equivalently to rustc.\n+            .env(\"RUSTDOC_LIBDIR\", self.rustc_libdir(compiler))\n             .env(\"CFG_RELEASE_CHANNEL\", &self.config.channel)\n             .env(\"RUSTDOC_REAL\", self.rustdoc(host))\n             .env(\"RUSTDOC_CRATE_VERSION\", self.rust_version())\n@@ -872,7 +873,7 @@ impl<'a> Builder<'a> {\n         } else {\n             &maybe_sysroot\n         };\n-        let libdir = sysroot.join(libdir(&compiler.host));\n+        let libdir = self.rustc_libdir(compiler);\n \n         // Customize the compiler we're running. Specify the compiler to cargo\n         // as our shim and then pass it some various options used to configure\n@@ -914,7 +915,7 @@ impl<'a> Builder<'a> {\n             cargo.env(\"RUSTC_ERROR_FORMAT\", error_format);\n         }\n         if cmd != \"build\" && cmd != \"check\" && cmd != \"rustc\" && want_rustdoc {\n-            cargo.env(\"RUSTDOC_LIBDIR\", self.sysroot_libdir(compiler, self.config.build));\n+            cargo.env(\"RUSTDOC_LIBDIR\", self.rustc_libdir(compiler));\n         }\n \n         if mode.is_tool() {\n@@ -1017,8 +1018,7 @@ impl<'a> Builder<'a> {\n \n         cargo.env(\"RUSTC_VERBOSE\", self.verbosity.to_string());\n \n-        // in std, we want to avoid denying warnings for stage 0 as that makes cfg's painful.\n-        if self.config.deny_warnings && !(mode == Mode::Std && stage == 0) {\n+        if self.config.deny_warnings {\n             cargo.env(\"RUSTC_DENY_WARNINGS\", \"1\");\n         }\n "}, {"sha": "5f84816789a689cb09690954c3f240facc974c4f", "filename": "src/bootstrap/cache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fbootstrap%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fbootstrap%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcache.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -227,10 +227,10 @@ lazy_static! {\n     pub static ref INTERNER: Interner = Interner::default();\n }\n \n-/// This is essentially a HashMap which allows storing any type in its input and\n+/// This is essentially a `HashMap` which allows storing any type in its input and\n /// any type in its output. It is a write-once cache; values are never evicted,\n /// which means that references to the value can safely be returned from the\n-/// get() method.\n+/// `get()` method.\n #[derive(Debug)]\n pub struct Cache(\n     RefCell<HashMap<"}, {"sha": "2a2533a3c1407d773667f281968bdbcecdea5950", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -66,7 +66,7 @@ impl Step for Rustc {\n         });\n     }\n \n-    /// Build the compiler.\n+    /// Builds the compiler.\n     ///\n     /// This will build the compiler for a particular stage of the build using\n     /// the `compiler` targeting the `target` architecture. The artifacts"}, {"sha": "b52e1a7b0e6816032c9ca07f4d500888f7637592", "filename": "src/bootstrap/clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fbootstrap%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fbootstrap%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fclean.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -3,7 +3,7 @@\n //! Responsible for cleaning out a build directory of all old and stale\n //! artifacts to prepare for a fresh build. Currently doesn't remove the\n //! `build/cache` directory (download cache) or the `build/$target/llvm`\n-//! directory unless the --all flag is present.\n+//! directory unless the `--all` flag is present.\n \n use std::fs;\n use std::io::{self, ErrorKind};"}, {"sha": "8fabb8c3fd08f504f4c2bb56a8d80f98aee8adfb", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -48,7 +48,7 @@ impl Step for Std {\n         });\n     }\n \n-    /// Build the standard library.\n+    /// Builds the standard library.\n     ///\n     /// This will build the standard library for a particular stage of the build\n     /// using the `compiler` targeting the `target` architecture. The artifacts\n@@ -269,7 +269,7 @@ impl Step for StartupObjects {\n         });\n     }\n \n-    /// Build and prepare startup objects like rsbegin.o and rsend.o\n+    /// Builds and prepare startup objects like rsbegin.o and rsend.o\n     ///\n     /// These are primarily used on Windows right now for linking executables/dlls.\n     /// They don't require any library support as they're just plain old object\n@@ -334,7 +334,7 @@ impl Step for Test {\n         });\n     }\n \n-    /// Build libtest.\n+    /// Builds libtest.\n     ///\n     /// This will build libtest and supporting libraries for a particular stage of\n     /// the build using the `compiler` targeting the `target` architecture. The\n@@ -455,7 +455,7 @@ impl Step for Rustc {\n         });\n     }\n \n-    /// Build the compiler.\n+    /// Builds the compiler.\n     ///\n     /// This will build the compiler for a particular stage of the build using\n     /// the `compiler` targeting the `target` architecture. The artifacts"}, {"sha": "bc1fdad356be3eee5e959b3063dbb3a62acde22d", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -342,7 +342,7 @@ impl Step for Mingw {\n         run.builder.ensure(Mingw { host: run.target });\n     }\n \n-    /// Build the `rust-mingw` installer component.\n+    /// Builds the `rust-mingw` installer component.\n     ///\n     /// This contains all the bits and pieces to run the MinGW Windows targets\n     /// without any extra installed software (e.g., we bundle gcc, libraries, etc)."}, {"sha": "660f9b9ef578adeecd41f28f0798aa03c1c771a2", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -61,6 +61,7 @@ macro_rules! book {\n // adding a build step in `src/bootstrap/builder.rs`!\n book!(\n     EditionGuide, \"src/doc/edition-guide\", \"edition-guide\", RustbookVersion::MdBook1;\n+    EmbeddedBook, \"src/doc/embedded-book\", \"embedded-book\", RustbookVersion::MdBook2;\n     Nomicon, \"src/doc/nomicon\", \"nomicon\", RustbookVersion::MdBook1;\n     Reference, \"src/doc/reference\", \"reference\", RustbookVersion::MdBook1;\n     RustByExample, \"src/doc/rust-by-example\", \"rust-by-example\", RustbookVersion::MdBook1;\n@@ -71,10 +72,6 @@ book!(\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n enum RustbookVersion {\n     MdBook1,\n-\n-    /// Note: Currently no books use mdBook v2, but we want the option\n-    /// to be available\n-    #[allow(dead_code)]\n     MdBook2,\n }\n \n@@ -262,7 +259,7 @@ impl Step for TheBook {\n         });\n     }\n \n-    /// Build the book and associated stuff.\n+    /// Builds the book and associated stuff.\n     ///\n     /// We need to build:\n     ///\n@@ -520,6 +517,7 @@ impl Step for Std {\n             cargo.arg(\"--\")\n                  .arg(\"--markdown-css\").arg(\"rust.css\")\n                  .arg(\"--markdown-no-toc\")\n+                 .arg(\"--generate-redirect-pages\")\n                  .arg(\"--index-page\").arg(&builder.src.join(\"src/doc/index.md\"));\n \n             builder.run(&mut cargo);\n@@ -584,7 +582,9 @@ impl Step for Test {\n         let mut cargo = builder.cargo(compiler, Mode::Test, target, \"doc\");\n         compile::test_cargo(builder, &compiler, target, &mut cargo);\n \n-        cargo.arg(\"--no-deps\").arg(\"-p\").arg(\"test\");\n+        cargo.arg(\"--no-deps\")\n+             .arg(\"-p\").arg(\"test\")\n+             .env(\"RUSTDOC_GENERATE_REDIRECT_PAGES\", \"1\");\n \n         builder.run(&mut cargo);\n         builder.cp_r(&my_out, &out);\n@@ -614,7 +614,7 @@ impl Step for WhitelistedRustc {\n         });\n     }\n \n-    /// Generate whitelisted compiler crate documentation.\n+    /// Generates whitelisted compiler crate documentation.\n     ///\n     /// This will generate all documentation for crates that are whitelisted\n     /// to be included in the standard documentation. This documentation is\n@@ -653,9 +653,9 @@ impl Step for WhitelistedRustc {\n         // We don't want to build docs for internal compiler dependencies in this\n         // step (there is another step for that). Therefore, we whitelist the crates\n         // for which docs must be built.\n-        cargo.arg(\"--no-deps\");\n         for krate in &[\"proc_macro\"] {\n-            cargo.arg(\"-p\").arg(krate);\n+            cargo.arg(\"-p\").arg(krate)\n+                 .env(\"RUSTDOC_GENERATE_REDIRECT_PAGES\", \"1\");\n         }\n \n         builder.run(&mut cargo);\n@@ -686,7 +686,7 @@ impl Step for Rustc {\n         });\n     }\n \n-    /// Generate compiler documentation.\n+    /// Generates compiler documentation.\n     ///\n     /// This will generate all documentation for compiler and dependencies.\n     /// Compiler documentation is distributed separately, so we make sure\n@@ -787,7 +787,7 @@ impl Step for Rustdoc {\n         });\n     }\n \n-    /// Generate compiler documentation.\n+    /// Generates compiler documentation.\n     ///\n     /// This will generate all documentation for compiler and dependencies.\n     /// Compiler documentation is distributed separately, so we make sure"}, {"sha": "6a93c95c3d97fb4d6012a876c1fcb7e076ebf9c0", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -69,7 +69,7 @@\n //! ## Copying stage0 {std,test,rustc}\n //!\n //! This copies the build output from Cargo into\n-//! `build/$HOST/stage0-sysroot/lib/rustlib/$ARCH/lib`. FIXME: This step's\n+//! `build/$HOST/stage0-sysroot/lib/rustlib/$ARCH/lib`. FIXME: this step's\n //! documentation should be expanded -- the information already here may be\n //! incorrect.\n //!\n@@ -504,7 +504,7 @@ impl Build {\n         cleared\n     }\n \n-    /// Get the space-separated set of activated features for the standard\n+    /// Gets the space-separated set of activated features for the standard\n     /// library.\n     fn std_features(&self) -> String {\n         let mut features = \"panic-unwind\".to_string();\n@@ -521,7 +521,7 @@ impl Build {\n         features\n     }\n \n-    /// Get the space-separated set of activated features for the compiler.\n+    /// Gets the space-separated set of activated features for the compiler.\n     fn rustc_features(&self) -> String {\n         let mut features = String::new();\n         if self.config.jemalloc {\n@@ -609,7 +609,7 @@ impl Build {\n         self.out.join(&*target).join(\"crate-docs\")\n     }\n \n-    /// Returns true if no custom `llvm-config` is set for the specified target.\n+    /// Returns `true` if no custom `llvm-config` is set for the specified target.\n     ///\n     /// If no custom `llvm-config` was specified then Rust's llvm will be used.\n     fn is_rust_llvm(&self, target: Interned<String>) -> bool {\n@@ -857,13 +857,13 @@ impl Build {\n             .map(|p| &**p)\n     }\n \n-    /// Returns true if this is a no-std `target`, if defined\n+    /// Returns `true` if this is a no-std `target`, if defined\n     fn no_std(&self, target: Interned<String>) -> Option<bool> {\n         self.config.target_config.get(&target)\n             .map(|t| t.no_std)\n     }\n \n-    /// Returns whether the target will be tested using the `remote-test-client`\n+    /// Returns `true` if the target will be tested using the `remote-test-client`\n     /// and `remote-test-server` binaries.\n     fn remote_tested(&self, target: Interned<String>) -> bool {\n         self.qemu_rootfs(target).is_some() || target.contains(\"android\") ||\n@@ -1059,7 +1059,7 @@ impl Build {\n         self.rust_info.version(self, channel::CFG_RELEASE_NUM)\n     }\n \n-    /// Return the full commit hash\n+    /// Returns the full commit hash.\n     fn rust_sha(&self) -> Option<&str> {\n         self.rust_info.sha()\n     }\n@@ -1079,7 +1079,7 @@ impl Build {\n         panic!(\"failed to find version in {}'s Cargo.toml\", package)\n     }\n \n-    /// Returns whether unstable features should be enabled for the compiler\n+    /// Returns `true` if unstable features should be enabled for the compiler\n     /// we're building.\n     fn unstable_features(&self) -> bool {\n         match &self.config.channel[..] {\n@@ -1327,7 +1327,7 @@ impl<'a> Compiler {\n         self\n     }\n \n-    /// Returns whether this is a snapshot compiler for `build`'s configuration\n+    /// Returns `true` if this is a snapshot compiler for `build`'s configuration\n     pub fn is_snapshot(&self, build: &Build) -> bool {\n         self.stage == 0 && self.host == build.build\n     }"}, {"sha": "a882550f734f40ead12195582c15e84dc2dedc9a", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -30,9 +30,9 @@ const ADB_TEST_DIR: &str = \"/data/tmp/work\";\n /// The two modes of the test runner; tests or benchmarks.\n #[derive(Debug, PartialEq, Eq, Hash, Copy, Clone, PartialOrd, Ord)]\n pub enum TestKind {\n-    /// Run `cargo test`\n+    /// Run `cargo test`.\n     Test,\n-    /// Run `cargo bench`\n+    /// Run `cargo bench`.\n     Bench,\n }\n \n@@ -1288,7 +1288,7 @@ impl Step for DocTest {\n         run.never()\n     }\n \n-    /// Run `rustdoc --test` for all documentation in `src/doc`.\n+    /// Runs `rustdoc --test` for all documentation in `src/doc`.\n     ///\n     /// This will run all tests in our markdown documentation (e.g., the book)\n     /// located in `src/doc`. The `rustdoc` that's run is the one that sits next to\n@@ -1383,6 +1383,7 @@ test_book!(\n     RustdocBook, \"src/doc/rustdoc\", \"rustdoc\", default=true;\n     RustcBook, \"src/doc/rustc\", \"rustc\", default=true;\n     RustByExample, \"src/doc/rust-by-example\", \"rust-by-example\", default=false;\n+    EmbeddedBook, \"src/doc/embedded-book\", \"embedded-book\", default=false;\n     TheBook, \"src/doc/book\", \"book\", default=false;\n     UnstableBook, \"src/doc/unstable-book\", \"unstable-book\", default=true;\n );\n@@ -1407,7 +1408,7 @@ impl Step for ErrorIndex {\n         });\n     }\n \n-    /// Run the error index generator tool to execute the tests located in the error\n+    /// Runs the error index generator tool to execute the tests located in the error\n     /// index.\n     ///\n     /// The `error_index_generator` tool lives in `src/tools` and is used to\n@@ -1613,7 +1614,7 @@ impl Step for Crate {\n         }\n     }\n \n-    /// Run all unit tests plus documentation tests for a given crate defined\n+    /// Runs all unit tests plus documentation tests for a given crate defined\n     /// by a `Cargo.toml` (single manifest)\n     ///\n     /// This is what runs tests for crates like the standard library, compiler, etc.\n@@ -1832,7 +1833,7 @@ fn envify(s: &str) -> String {\n /// the standard library and such to the emulator ahead of time. This step\n /// represents this and is a dependency of all test suites.\n ///\n-/// Most of the time this is a noop. For some steps such as shipping data to\n+/// Most of the time this is a no-op. For some steps such as shipping data to\n /// QEMU we have to build our own tools so we've got conditional dependencies\n /// on those programs as well. Note that the remote test client is built for\n /// the build target (us) and the server is built for the target.\n@@ -1903,7 +1904,7 @@ impl Step for Distcheck {\n         run.builder.ensure(Distcheck);\n     }\n \n-    /// Run \"distcheck\", a 'make check' from a tarball\n+    /// Runs \"distcheck\", a 'make check' from a tarball\n     fn run(self, builder: &Builder) {\n         builder.info(\"Distcheck\");\n         let dir = builder.out.join(\"tmp\").join(\"distcheck\");\n@@ -1964,7 +1965,7 @@ impl Step for Bootstrap {\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n-    /// Test the build system itself\n+    /// Tests the build system itself.\n     fn run(self, builder: &Builder) {\n         let mut cmd = Command::new(&builder.initial_cargo);\n         cmd.arg(\"test\")"}, {"sha": "6383a2ecc75832a2498fe45d66ef8c55923648f1", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -40,7 +40,7 @@ impl Step for ToolBuild {\n         run.never()\n     }\n \n-    /// Build a tool in `src/tools`\n+    /// Builds a tool in `src/tools`\n     ///\n     /// This will build the specified tool with the specified `host` compiler in\n     /// `stage` into the normal cargo output directory.\n@@ -418,25 +418,25 @@ impl Step for Rustdoc {\n \n     fn run(self, builder: &Builder) -> PathBuf {\n         let target_compiler = builder.compiler(builder.top_stage, self.host);\n+        if target_compiler.stage == 0 {\n+            if !target_compiler.is_snapshot(builder) {\n+                panic!(\"rustdoc in stage 0 must be snapshot rustdoc\");\n+            }\n+            return builder.initial_rustc.with_file_name(exe(\"rustdoc\", &target_compiler.host));\n+        }\n         let target = target_compiler.host;\n-        let build_compiler = if target_compiler.stage == 0 {\n-            builder.compiler(0, builder.config.build)\n-        } else if target_compiler.stage >= 2 {\n-            // Past stage 2, we consider the compiler to be ABI-compatible and hence capable of\n-            // building rustdoc itself.\n-            builder.compiler(target_compiler.stage, builder.config.build)\n-        } else {\n-            // Similar to `compile::Assemble`, build with the previous stage's compiler. Otherwise\n-            // we'd have stageN/bin/rustc and stageN/bin/rustdoc be effectively different stage\n-            // compilers, which isn't what we want.\n-            builder.compiler(target_compiler.stage - 1, builder.config.build)\n-        };\n-\n-        builder.ensure(compile::Rustc { compiler: build_compiler, target });\n-        builder.ensure(compile::Rustc {\n-            compiler: build_compiler,\n-            target: builder.config.build,\n-        });\n+        // Similar to `compile::Assemble`, build with the previous stage's compiler. Otherwise\n+        // we'd have stageN/bin/rustc and stageN/bin/rustdoc be effectively different stage\n+        // compilers, which isn't what we want. Rustdoc should be linked in the same way as the\n+        // rustc compiler it's paired with, so it must be built with the previous stage compiler.\n+        let build_compiler = builder.compiler(target_compiler.stage - 1, builder.config.build);\n+\n+        // The presence of `target_compiler` ensures that the necessary libraries (codegen backends,\n+        // compiler libraries, ...) are built. Rustdoc does not require the presence of any\n+        // libraries within sysroot_libdir (i.e., rustlib), though doctests may want it (since\n+        // they'll be linked to those libraries). As such, don't explicitly `ensure` any additional\n+        // libraries here. The intuition here is that If we've built a compiler, we should be able\n+        // to build rustdoc.\n \n         let mut cargo = prepare_tool_cargo(\n             builder,\n@@ -621,7 +621,7 @@ tool_extended!((self, builder),\n );\n \n impl<'a> Builder<'a> {\n-    /// Get a `Command` which is ready to run `tool` in `stage` built for\n+    /// Gets a `Command` which is ready to run `tool` in `stage` built for\n     /// `host`.\n     pub fn tool_cmd(&self, tool: Tool) -> Command {\n         let mut cmd = Command::new(self.tool_exe(tool));"}, {"sha": "29aa98971fb567a846b7cd18d5cf5197f355a571", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -33,7 +33,7 @@ pub fn exe(name: &str, target: &str) -> String {\n     }\n }\n \n-/// Returns whether the file name given looks like a dynamic library.\n+/// Returns `true` if the file name given looks like a dynamic library.\n pub fn is_dylib(name: &str) -> bool {\n     name.ends_with(\".dylib\") || name.ends_with(\".so\") || name.ends_with(\".dll\")\n }"}, {"sha": "04c7820b45665feb9fe465f3936d086dc5b907f7", "filename": "src/build_helper/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fbuild_helper%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fbuild_helper%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2FCargo.toml?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -2,6 +2,7 @@\n name = \"build_helper\"\n version = \"0.1.0\"\n authors = [\"The Rust Project Developers\"]\n+edition = \"2018\"\n \n [lib]\n name = \"build_helper\""}, {"sha": "bd99dc118e66a36ab2f819aac565669f2fc947c3", "filename": "src/build_helper/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fbuild_helper%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fbuild_helper%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2Flib.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rust_2018_idioms)]\n+\n use std::fs::File;\n use std::path::{Path, PathBuf};\n use std::process::{Command, Stdio};\n@@ -161,7 +163,7 @@ pub fn mtime(path: &Path) -> SystemTime {\n         .unwrap_or(UNIX_EPOCH)\n }\n \n-/// Returns whether `dst` is up to date given that the file or files in `src`\n+/// Returns `true` if `dst` is up to date given that the file or files in `src`\n /// are used to generate it.\n ///\n /// Uses last-modified time checks to verify this.\n@@ -188,12 +190,12 @@ pub struct NativeLibBoilerplate {\n }\n \n impl NativeLibBoilerplate {\n-    /// On OSX we don't want to ship the exact filename that compiler-rt builds.\n+    /// On macOS we don't want to ship the exact filename that compiler-rt builds.\n     /// This conflicts with the system and ours is likely a wildly different\n     /// version, so they can't be substituted.\n     ///\n     /// As a result, we rename it here but we need to also use\n-    /// `install_name_tool` on OSX to rename the commands listed inside of it to\n+    /// `install_name_tool` on macOS to rename the commands listed inside of it to\n     /// ensure it's linked against correctly.\n     pub fn fixup_sanitizer_lib_name(&self, sanitizer_name: &str) {\n         if env::var(\"TARGET\").unwrap() != \"x86_64-apple-darwin\" {"}, {"sha": "34320ab4411e2d70640efd7e55f2e62011f230a7", "filename": "src/ci/docker/README.md", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2FREADME.md?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -131,36 +131,42 @@ $category > $option = $value -- $comment\n For targets: `arm-unknown-linux-gnueabi`\n \n - Path and misc options > Prefix directory = /x-tools/${CT\\_TARGET}\n+- Path and misc options > Patches origin = Bundled, then local\n+- Path and misc options > Local patch directory = /tmp/patches\n - Target options > Target Architecture = arm\n - Target options > Architecture level = armv6 -- (+)\n - Target options > Floating point = software (no FPU) -- (\\*)\n - Operating System > Target OS = linux\n - Operating System > Linux kernel version = 3.2.72 -- Precise kernel\n-- C-library > glibc version = 2.14.1\n-- C compiler > gcc version = 4.9.3\n+- C-library > glibc version = 2.16.0\n+- C compiler > gcc version = 5.2.0\n - C compiler > C++ = ENABLE -- to cross compile LLVM\n \n ### `arm-linux-gnueabihf.config`\n \n For targets: `arm-unknown-linux-gnueabihf`\n \n - Path and misc options > Prefix directory = /x-tools/${CT\\_TARGET}\n+- Path and misc options > Patches origin = Bundled, then local\n+- Path and misc options > Local patch directory = /tmp/patches\n - Target options > Target Architecture = arm\n - Target options > Architecture level = armv6 -- (+)\n - Target options > Use specific FPU = vfp -- (+)\n - Target options > Floating point = hardware (FPU) -- (\\*)\n - Target options > Default instruction set mode = arm -- (+)\n - Operating System > Target OS = linux\n - Operating System > Linux kernel version = 3.2.72 -- Precise kernel\n-- C-library > glibc version = 2.14.1\n-- C compiler > gcc version = 4.9.3\n+- C-library > glibc version = 2.16.0\n+- C compiler > gcc version = 5.2.0\n - C compiler > C++ = ENABLE -- to cross compile LLVM\n \n ### `armv7-linux-gnueabihf.config`\n \n For targets: `armv7-unknown-linux-gnueabihf`\n \n - Path and misc options > Prefix directory = /x-tools/${CT\\_TARGET}\n+- Path and misc options > Patches origin = Bundled, then local\n+- Path and misc options > Local patch directory = /tmp/patches\n - Target options > Target Architecture = arm\n - Target options > Suffix to the arch-part = v7\n - Target options > Architecture level = armv7-a -- (+)\n@@ -169,8 +175,8 @@ For targets: `armv7-unknown-linux-gnueabihf`\n - Target options > Default instruction set mode = thumb -- (\\*)\n - Operating System > Target OS = linux\n - Operating System > Linux kernel version = 3.2.72 -- Precise kernel\n-- C-library > glibc version = 2.14.1\n-- C compiler > gcc version = 4.9.3\n+- C-library > glibc version = 2.16.0\n+- C compiler > gcc version = 5.2.0\n - C compiler > C++ = ENABLE -- to cross compile LLVM\n \n (\\*) These options have been selected to match the configuration of the arm\n@@ -204,7 +210,7 @@ For targets: `powerpc-unknown-linux-gnu`\n - Operating System > Target OS = linux\n - Operating System > Linux kernel version = 2.6.32.68 -- ~RHEL6 kernel\n - C-library > glibc version = 2.12.2 -- ~RHEL6 glibc\n-- C compiler > gcc version = 4.9.3\n+- C compiler > gcc version = 5.2.0\n - C compiler > C++ = ENABLE -- to cross compile LLVM\n \n ### `powerpc64-linux-gnu.config`\n@@ -221,7 +227,7 @@ For targets: `powerpc64-unknown-linux-gnu`\n - Operating System > Target OS = linux\n - Operating System > Linux kernel version = 2.6.32.68 -- ~RHEL6 kernel\n - C-library > glibc version = 2.12.2 -- ~RHEL6 glibc\n-- C compiler > gcc version = 4.9.3\n+- C compiler > gcc version = 5.2.0\n - C compiler > C++ = ENABLE -- to cross compile LLVM\n \n (+) These CPU options match the configuration of the toolchains in RHEL6.\n@@ -232,12 +238,12 @@ For targets: `s390x-unknown-linux-gnu`\n \n - Path and misc options > Prefix directory = /x-tools/${CT\\_TARGET}\n - Path and misc options > Patches origin = Bundled, then local\n-- Path and misc options > Local patch directory = /build/patches\n+- Path and misc options > Local patch directory = /tmp/patches\n - Target options > Target Architecture = s390\n - Target options > Bitness = 64-bit\n - Operating System > Target OS = linux\n - Operating System > Linux kernel version = 2.6.32.68 -- ~RHEL6 kernel\n - C-library > glibc version = 2.12.2 -- ~RHEL6 glibc\n-- C compiler > gcc version = 4.9.3\n+- C compiler > gcc version = 5.2.0\n - C compiler > gcc extra config = --with-arch=z10 -- LLVM's minimum support\n - C compiler > C++ = ENABLE -- to cross compile LLVM"}, {"sha": "48851ae232c99c481ba7482e5758b17e98bab6c9", "filename": "src/ci/docker/dist-arm-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2Fdist-arm-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2Fdist-arm-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-arm-linux%2FDockerfile?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -16,6 +16,7 @@ RUN sh /scripts/rustbuild-setup.sh\n USER rustbuild\n WORKDIR /tmp\n \n+COPY dist-arm-linux/patches/ /tmp/patches/\n COPY dist-arm-linux/arm-linux-gnueabi.config dist-arm-linux/build-toolchains.sh /tmp/\n RUN ./build-toolchains.sh\n "}, {"sha": "4185112d8be90f28c34da0d0242fe36f1452f989", "filename": "src/ci/docker/dist-arm-linux/arm-linux-gnueabi.config", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2Fdist-arm-linux%2Farm-linux-gnueabi.config", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2Fdist-arm-linux%2Farm-linux-gnueabi.config", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-arm-linux%2Farm-linux-gnueabi.config?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -3,6 +3,7 @@\n # Crosstool-NG Configuration\n #\n CT_CONFIGURE_has_make381=y\n+CT_CONFIGURE_has_xz=y\n CT_MODULES=y\n \n #\n@@ -44,14 +45,16 @@ CT_CONNECT_TIMEOUT=10\n # CT_FORCE_EXTRACT is not set\n CT_OVERIDE_CONFIG_GUESS_SUB=y\n # CT_ONLY_EXTRACT is not set\n-CT_PATCH_BUNDLED=y\n+# CT_PATCH_BUNDLED is not set\n # CT_PATCH_LOCAL is not set\n-# CT_PATCH_BUNDLED_LOCAL is not set\n+CT_PATCH_BUNDLED_LOCAL=y\n # CT_PATCH_LOCAL_BUNDLED is not set\n # CT_PATCH_BUNDLED_FALLBACK_LOCAL is not set\n # CT_PATCH_LOCAL_FALLBACK_BUNDLED is not set\n # CT_PATCH_NONE is not set\n-CT_PATCH_ORDER=\"bundled\"\n+CT_PATCH_ORDER=\"bundled,local\"\n+CT_PATCH_USE_LOCAL=y\n+CT_LOCAL_PATCH_DIR=\"/tmp/patches\"\n \n #\n # Build behavior\n@@ -391,8 +394,8 @@ CT_CC_CORE_PASS_1_NEEDED=y\n CT_CC_CORE_PASS_2_NEEDED=y\n CT_CC_gcc=y\n # CT_CC_GCC_SHOW_LINARO is not set\n-# CT_CC_GCC_V_5_2_0 is not set\n-CT_CC_GCC_V_4_9_3=y\n+CT_CC_GCC_V_5_2_0=y\n+# CT_CC_GCC_V_4_9_3 is not set\n # CT_CC_GCC_V_4_8_5 is not set\n # CT_CC_GCC_V_4_7_4 is not set\n # CT_CC_GCC_V_4_6_4 is not set\n@@ -407,8 +410,9 @@ CT_CC_GCC_4_5_or_later=y\n CT_CC_GCC_4_6_or_later=y\n CT_CC_GCC_4_7_or_later=y\n CT_CC_GCC_4_8_or_later=y\n-CT_CC_GCC_4_9=y\n CT_CC_GCC_4_9_or_later=y\n+CT_CC_GCC_5=y\n+CT_CC_GCC_5_or_later=y\n CT_CC_GCC_HAS_GRAPHITE=y\n CT_CC_GCC_USE_GRAPHITE=y\n CT_CC_GCC_HAS_LTO=y\n@@ -420,7 +424,7 @@ CT_CC_GCC_USE_GMP_MPFR=y\n CT_CC_GCC_USE_MPC=y\n CT_CC_GCC_HAS_LIBQUADMATH=y\n CT_CC_GCC_HAS_LIBSANITIZER=y\n-CT_CC_GCC_VERSION=\"4.9.3\"\n+CT_CC_GCC_VERSION=\"5.2.0\"\n # CT_CC_LANG_FORTRAN is not set\n CT_CC_GCC_ENABLE_CXX_FLAGS=\"\"\n CT_CC_GCC_CORE_EXTRA_CONFIG_ARRAY=\"\"\n@@ -492,15 +496,13 @@ CT_GETTEXT_NEEDED=y\n CT_GMP_NEEDED=y\n CT_MPFR_NEEDED=y\n CT_ISL_NEEDED=y\n-CT_CLOOG_NEEDED=y\n CT_MPC_NEEDED=y\n CT_COMPLIBS=y\n CT_LIBICONV=y\n CT_GETTEXT=y\n CT_GMP=y\n CT_MPFR=y\n CT_ISL=y\n-CT_CLOOG=y\n CT_MPC=y\n CT_LIBICONV_V_1_14=y\n CT_LIBICONV_VERSION=\"1.14\"\n@@ -526,15 +528,13 @@ CT_MPFR_V_3_1_3=y\n # CT_MPFR_V_2_4_0 is not set\n CT_MPFR_VERSION=\"3.1.3\"\n CT_ISL_V_0_14=y\n+# CT_ISL_V_0_12_2 is not set\n CT_ISL_V_0_14_or_later=y\n CT_ISL_V_0_12_or_later=y\n CT_ISL_VERSION=\"0.14\"\n-CT_CLOOG_V_0_18_4=y\n+# CT_CLOOG_V_0_18_4 is not set\n # CT_CLOOG_V_0_18_1 is not set\n # CT_CLOOG_V_0_18_0 is not set\n-CT_CLOOG_VERSION=\"0.18.4\"\n-CT_CLOOG_0_18_4_or_later=y\n-CT_CLOOG_0_18_or_later=y\n CT_MPC_V_1_0_3=y\n # CT_MPC_V_1_0_2 is not set\n # CT_MPC_V_1_0_1 is not set"}, {"sha": "871d5225c0f714e035a0d97c7c2d841acfa09431", "filename": "src/ci/docker/dist-arm-linux/patches/glibc/ports-2.16.0/001-arm-libgcc_s_resume-used.patch", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2Fdist-arm-linux%2Fpatches%2Fglibc%2Fports-2.16.0%2F001-arm-libgcc_s_resume-used.patch", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2Fdist-arm-linux%2Fpatches%2Fglibc%2Fports-2.16.0%2F001-arm-libgcc_s_resume-used.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-arm-linux%2Fpatches%2Fglibc%2Fports-2.16.0%2F001-arm-libgcc_s_resume-used.patch?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -0,0 +1,48 @@\n+commit bdb24c2851fd5f0ad9b82d7ea1db911d334b02d2\n+Author: Joseph Myers <joseph@codesourcery.com>\n+Date:   Tue May 20 21:27:13 2014 +0000\n+\n+    Fix ARM build with GCC trunk.\n+    \n+    sysdeps/unix/sysv/linux/arm/unwind-resume.c and\n+    sysdeps/unix/sysv/linux/arm/unwind-forcedunwind.c have static\n+    variables that are written in C code but only read from toplevel asms.\n+    Current GCC trunk now optimizes away such apparently write-only static\n+    variables, so causing a build failure.  This patch marks those\n+    variables with __attribute_used__ to avoid that optimization.\n+    \n+    Tested that this fixes the build for ARM.\n+    \n+            * sysdeps/unix/sysv/linux/arm/unwind-forcedunwind.c\n+            (libgcc_s_resume): Use __attribute_used__.\n+            * sysdeps/unix/sysv/linux/arm/unwind-resume.c (libgcc_s_resume):\n+            Likewise.\n+\n+diff --git a/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c b/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c\n+index 29e2c2b00b04..e848bfeffdcb 100644\n+--- a/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c\n++++ b/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c\n+@@ -22,7 +22,8 @@\n+ #include <pthreadP.h>\n+ \n+ static void *libgcc_s_handle;\n+-static void (*libgcc_s_resume) (struct _Unwind_Exception *exc);\n++static void (*libgcc_s_resume) (struct _Unwind_Exception *exc)\n++  __attribute_used__;\n+ static _Unwind_Reason_Code (*libgcc_s_personality)\n+   (_Unwind_State, struct _Unwind_Exception *, struct _Unwind_Context *);\n+ static _Unwind_Reason_Code (*libgcc_s_forcedunwind)\n+diff --git a/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c b/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c\n+index 285b99b5ed0d..48d00fc83641 100644\n+--- a/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c\n++++ b/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c\n+@@ -20,7 +20,8 @@\n+ #include <stdio.h>\n+ #include <unwind.h>\n+ \n+-static void (*libgcc_s_resume) (struct _Unwind_Exception *exc);\n++static void (*libgcc_s_resume) (struct _Unwind_Exception *exc)\n++  __attribute_used__;\n+ static _Unwind_Reason_Code (*libgcc_s_personality)\n+   (_Unwind_State, struct _Unwind_Exception *, struct _Unwind_Context *);\n+ "}, {"sha": "d1dd9faaa103526b51cc3d2f99756d8eb745524f", "filename": "src/ci/docker/dist-armhf-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2Fdist-armhf-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2Fdist-armhf-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armhf-linux%2FDockerfile?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -16,6 +16,7 @@ RUN sh /scripts/rustbuild-setup.sh\n USER rustbuild\n WORKDIR /tmp\n \n+COPY dist-armhf-linux/patches/ /tmp/patches/\n COPY dist-armhf-linux/arm-linux-gnueabihf.config dist-armhf-linux/build-toolchains.sh /tmp/\n RUN ./build-toolchains.sh\n "}, {"sha": "bebbcd1670a5e154bb5674a67af6054ac3ee7d2f", "filename": "src/ci/docker/dist-armhf-linux/arm-linux-gnueabihf.config", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2Fdist-armhf-linux%2Farm-linux-gnueabihf.config", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2Fdist-armhf-linux%2Farm-linux-gnueabihf.config", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armhf-linux%2Farm-linux-gnueabihf.config?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -3,6 +3,7 @@\n # Crosstool-NG Configuration\n #\n CT_CONFIGURE_has_make381=y\n+CT_CONFIGURE_has_xz=y\n CT_MODULES=y\n \n #\n@@ -44,14 +45,16 @@ CT_CONNECT_TIMEOUT=10\n # CT_FORCE_EXTRACT is not set\n CT_OVERIDE_CONFIG_GUESS_SUB=y\n # CT_ONLY_EXTRACT is not set\n-CT_PATCH_BUNDLED=y\n+# CT_PATCH_BUNDLED is not set\n # CT_PATCH_LOCAL is not set\n-# CT_PATCH_BUNDLED_LOCAL is not set\n+CT_PATCH_BUNDLED_LOCAL=y\n # CT_PATCH_LOCAL_BUNDLED is not set\n # CT_PATCH_BUNDLED_FALLBACK_LOCAL is not set\n # CT_PATCH_LOCAL_FALLBACK_BUNDLED is not set\n # CT_PATCH_NONE is not set\n-CT_PATCH_ORDER=\"bundled\"\n+CT_PATCH_ORDER=\"bundled,local\"\n+CT_PATCH_USE_LOCAL=y\n+CT_LOCAL_PATCH_DIR=\"/tmp/patches\"\n \n #\n # Build behavior\n@@ -392,8 +395,8 @@ CT_CC_CORE_PASS_1_NEEDED=y\n CT_CC_CORE_PASS_2_NEEDED=y\n CT_CC_gcc=y\n # CT_CC_GCC_SHOW_LINARO is not set\n-# CT_CC_GCC_V_5_2_0 is not set\n-CT_CC_GCC_V_4_9_3=y\n+CT_CC_GCC_V_5_2_0=y\n+# CT_CC_GCC_V_4_9_3 is not set\n # CT_CC_GCC_V_4_8_5 is not set\n # CT_CC_GCC_V_4_7_4 is not set\n # CT_CC_GCC_V_4_6_4 is not set\n@@ -408,8 +411,9 @@ CT_CC_GCC_4_5_or_later=y\n CT_CC_GCC_4_6_or_later=y\n CT_CC_GCC_4_7_or_later=y\n CT_CC_GCC_4_8_or_later=y\n-CT_CC_GCC_4_9=y\n CT_CC_GCC_4_9_or_later=y\n+CT_CC_GCC_5=y\n+CT_CC_GCC_5_or_later=y\n CT_CC_GCC_HAS_GRAPHITE=y\n CT_CC_GCC_USE_GRAPHITE=y\n CT_CC_GCC_HAS_LTO=y\n@@ -421,7 +425,7 @@ CT_CC_GCC_USE_GMP_MPFR=y\n CT_CC_GCC_USE_MPC=y\n CT_CC_GCC_HAS_LIBQUADMATH=y\n CT_CC_GCC_HAS_LIBSANITIZER=y\n-CT_CC_GCC_VERSION=\"4.9.3\"\n+CT_CC_GCC_VERSION=\"5.2.0\"\n # CT_CC_LANG_FORTRAN is not set\n CT_CC_GCC_ENABLE_CXX_FLAGS=\"\"\n CT_CC_GCC_CORE_EXTRA_CONFIG_ARRAY=\"\"\n@@ -493,15 +497,13 @@ CT_GETTEXT_NEEDED=y\n CT_GMP_NEEDED=y\n CT_MPFR_NEEDED=y\n CT_ISL_NEEDED=y\n-CT_CLOOG_NEEDED=y\n CT_MPC_NEEDED=y\n CT_COMPLIBS=y\n CT_LIBICONV=y\n CT_GETTEXT=y\n CT_GMP=y\n CT_MPFR=y\n CT_ISL=y\n-CT_CLOOG=y\n CT_MPC=y\n CT_LIBICONV_V_1_14=y\n CT_LIBICONV_VERSION=\"1.14\"\n@@ -527,15 +529,13 @@ CT_MPFR_V_3_1_3=y\n # CT_MPFR_V_2_4_0 is not set\n CT_MPFR_VERSION=\"3.1.3\"\n CT_ISL_V_0_14=y\n+# CT_ISL_V_0_12_2 is not set\n CT_ISL_V_0_14_or_later=y\n CT_ISL_V_0_12_or_later=y\n CT_ISL_VERSION=\"0.14\"\n-CT_CLOOG_V_0_18_4=y\n+# CT_CLOOG_V_0_18_4 is not set\n # CT_CLOOG_V_0_18_1 is not set\n # CT_CLOOG_V_0_18_0 is not set\n-CT_CLOOG_VERSION=\"0.18.4\"\n-CT_CLOOG_0_18_4_or_later=y\n-CT_CLOOG_0_18_or_later=y\n CT_MPC_V_1_0_3=y\n # CT_MPC_V_1_0_2 is not set\n # CT_MPC_V_1_0_1 is not set"}, {"sha": "871d5225c0f714e035a0d97c7c2d841acfa09431", "filename": "src/ci/docker/dist-armhf-linux/patches/glibc/ports-2.16.0/001-arm-libgcc_s_resume-used.patch", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2Fdist-armhf-linux%2Fpatches%2Fglibc%2Fports-2.16.0%2F001-arm-libgcc_s_resume-used.patch", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2Fdist-armhf-linux%2Fpatches%2Fglibc%2Fports-2.16.0%2F001-arm-libgcc_s_resume-used.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armhf-linux%2Fpatches%2Fglibc%2Fports-2.16.0%2F001-arm-libgcc_s_resume-used.patch?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -0,0 +1,48 @@\n+commit bdb24c2851fd5f0ad9b82d7ea1db911d334b02d2\n+Author: Joseph Myers <joseph@codesourcery.com>\n+Date:   Tue May 20 21:27:13 2014 +0000\n+\n+    Fix ARM build with GCC trunk.\n+    \n+    sysdeps/unix/sysv/linux/arm/unwind-resume.c and\n+    sysdeps/unix/sysv/linux/arm/unwind-forcedunwind.c have static\n+    variables that are written in C code but only read from toplevel asms.\n+    Current GCC trunk now optimizes away such apparently write-only static\n+    variables, so causing a build failure.  This patch marks those\n+    variables with __attribute_used__ to avoid that optimization.\n+    \n+    Tested that this fixes the build for ARM.\n+    \n+            * sysdeps/unix/sysv/linux/arm/unwind-forcedunwind.c\n+            (libgcc_s_resume): Use __attribute_used__.\n+            * sysdeps/unix/sysv/linux/arm/unwind-resume.c (libgcc_s_resume):\n+            Likewise.\n+\n+diff --git a/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c b/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c\n+index 29e2c2b00b04..e848bfeffdcb 100644\n+--- a/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c\n++++ b/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c\n+@@ -22,7 +22,8 @@\n+ #include <pthreadP.h>\n+ \n+ static void *libgcc_s_handle;\n+-static void (*libgcc_s_resume) (struct _Unwind_Exception *exc);\n++static void (*libgcc_s_resume) (struct _Unwind_Exception *exc)\n++  __attribute_used__;\n+ static _Unwind_Reason_Code (*libgcc_s_personality)\n+   (_Unwind_State, struct _Unwind_Exception *, struct _Unwind_Context *);\n+ static _Unwind_Reason_Code (*libgcc_s_forcedunwind)\n+diff --git a/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c b/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c\n+index 285b99b5ed0d..48d00fc83641 100644\n+--- a/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c\n++++ b/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c\n+@@ -20,7 +20,8 @@\n+ #include <stdio.h>\n+ #include <unwind.h>\n+ \n+-static void (*libgcc_s_resume) (struct _Unwind_Exception *exc);\n++static void (*libgcc_s_resume) (struct _Unwind_Exception *exc)\n++  __attribute_used__;\n+ static _Unwind_Reason_Code (*libgcc_s_personality)\n+   (_Unwind_State, struct _Unwind_Exception *, struct _Unwind_Context *);\n+ "}, {"sha": "170b8134d3edcd8ac32931c06416e472f5f0253e", "filename": "src/ci/docker/dist-armv7-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2Fdist-armv7-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2Fdist-armv7-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armv7-linux%2FDockerfile?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -16,6 +16,7 @@ RUN sh /scripts/rustbuild-setup.sh\n USER rustbuild\n WORKDIR /tmp\n \n+COPY dist-armv7-linux/patches/ /tmp/patches/\n COPY dist-armv7-linux/build-toolchains.sh dist-armv7-linux/armv7-linux-gnueabihf.config /tmp/\n RUN ./build-toolchains.sh\n "}, {"sha": "5cccfd8444d3536a8c501e48f8782a958e795fd9", "filename": "src/ci/docker/dist-armv7-linux/armv7-linux-gnueabihf.config", "status": "modified", "additions": 13, "deletions": 21, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2Fdist-armv7-linux%2Farmv7-linux-gnueabihf.config", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2Fdist-armv7-linux%2Farmv7-linux-gnueabihf.config", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armv7-linux%2Farmv7-linux-gnueabihf.config?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -3,6 +3,7 @@\n # Crosstool-NG Configuration\n #\n CT_CONFIGURE_has_make381=y\n+CT_CONFIGURE_has_xz=y\n CT_MODULES=y\n \n #\n@@ -44,14 +45,16 @@ CT_CONNECT_TIMEOUT=10\n # CT_FORCE_EXTRACT is not set\n CT_OVERIDE_CONFIG_GUESS_SUB=y\n # CT_ONLY_EXTRACT is not set\n-CT_PATCH_BUNDLED=y\n+# CT_PATCH_BUNDLED is not set\n # CT_PATCH_LOCAL is not set\n-# CT_PATCH_BUNDLED_LOCAL is not set\n+CT_PATCH_BUNDLED_LOCAL=y\n # CT_PATCH_LOCAL_BUNDLED is not set\n # CT_PATCH_BUNDLED_FALLBACK_LOCAL is not set\n # CT_PATCH_LOCAL_FALLBACK_BUNDLED is not set\n # CT_PATCH_NONE is not set\n-CT_PATCH_ORDER=\"bundled\"\n+CT_PATCH_ORDER=\"bundled,local\"\n+CT_PATCH_USE_LOCAL=y\n+CT_LOCAL_PATCH_DIR=\"/tmp/patches\"\n \n #\n # Build behavior\n@@ -155,12 +158,6 @@ CT_ARCH_EXCLUSIVE_WITH_CPU=y\n # CT_ARCH_FLOAT_AUTO is not set\n # CT_ARCH_FLOAT_SOFTFP is not set\n CT_ARCH_FLOAT=\"hard\"\n-# CT_ARCH_ALPHA_EV4 is not set\n-# CT_ARCH_ALPHA_EV45 is not set\n-# CT_ARCH_ALPHA_EV5 is not set\n-# CT_ARCH_ALPHA_EV56 is not set\n-# CT_ARCH_ALPHA_EV6 is not set\n-# CT_ARCH_ALPHA_EV67 is not set\n \n #\n # arm other options\n@@ -311,8 +308,6 @@ CT_LIBC=\"glibc\"\n CT_LIBC_VERSION=\"2.16.0\"\n CT_LIBC_glibc=y\n # CT_LIBC_musl is not set\n-# CT_LIBC_newlib is not set\n-# CT_LIBC_none is not set\n # CT_LIBC_uClibc is not set\n CT_LIBC_avr_libc_AVAILABLE=y\n CT_LIBC_glibc_AVAILABLE=y\n@@ -400,8 +395,8 @@ CT_CC_CORE_PASS_1_NEEDED=y\n CT_CC_CORE_PASS_2_NEEDED=y\n CT_CC_gcc=y\n # CT_CC_GCC_SHOW_LINARO is not set\n-# CT_CC_GCC_V_5_2_0 is not set\n-CT_CC_GCC_V_4_9_3=y\n+CT_CC_GCC_V_5_2_0=y\n+# CT_CC_GCC_V_4_9_3 is not set\n # CT_CC_GCC_V_4_8_5 is not set\n # CT_CC_GCC_V_4_7_4 is not set\n # CT_CC_GCC_V_4_6_4 is not set\n@@ -416,8 +411,9 @@ CT_CC_GCC_4_5_or_later=y\n CT_CC_GCC_4_6_or_later=y\n CT_CC_GCC_4_7_or_later=y\n CT_CC_GCC_4_8_or_later=y\n-CT_CC_GCC_4_9=y\n CT_CC_GCC_4_9_or_later=y\n+CT_CC_GCC_5=y\n+CT_CC_GCC_5_or_later=y\n CT_CC_GCC_HAS_GRAPHITE=y\n CT_CC_GCC_USE_GRAPHITE=y\n CT_CC_GCC_HAS_LTO=y\n@@ -429,7 +425,7 @@ CT_CC_GCC_USE_GMP_MPFR=y\n CT_CC_GCC_USE_MPC=y\n CT_CC_GCC_HAS_LIBQUADMATH=y\n CT_CC_GCC_HAS_LIBSANITIZER=y\n-CT_CC_GCC_VERSION=\"4.9.3\"\n+CT_CC_GCC_VERSION=\"5.2.0\"\n # CT_CC_LANG_FORTRAN is not set\n CT_CC_GCC_ENABLE_CXX_FLAGS=\"\"\n CT_CC_GCC_CORE_EXTRA_CONFIG_ARRAY=\"\"\n@@ -501,15 +497,13 @@ CT_GETTEXT_NEEDED=y\n CT_GMP_NEEDED=y\n CT_MPFR_NEEDED=y\n CT_ISL_NEEDED=y\n-CT_CLOOG_NEEDED=y\n CT_MPC_NEEDED=y\n CT_COMPLIBS=y\n CT_LIBICONV=y\n CT_GETTEXT=y\n CT_GMP=y\n CT_MPFR=y\n CT_ISL=y\n-CT_CLOOG=y\n CT_MPC=y\n CT_LIBICONV_V_1_14=y\n CT_LIBICONV_VERSION=\"1.14\"\n@@ -535,15 +529,13 @@ CT_MPFR_V_3_1_3=y\n # CT_MPFR_V_2_4_0 is not set\n CT_MPFR_VERSION=\"3.1.3\"\n CT_ISL_V_0_14=y\n+# CT_ISL_V_0_12_2 is not set\n CT_ISL_V_0_14_or_later=y\n CT_ISL_V_0_12_or_later=y\n CT_ISL_VERSION=\"0.14\"\n-CT_CLOOG_V_0_18_4=y\n+# CT_CLOOG_V_0_18_4 is not set\n # CT_CLOOG_V_0_18_1 is not set\n # CT_CLOOG_V_0_18_0 is not set\n-CT_CLOOG_VERSION=\"0.18.4\"\n-CT_CLOOG_0_18_4_or_later=y\n-CT_CLOOG_0_18_or_later=y\n CT_MPC_V_1_0_3=y\n # CT_MPC_V_1_0_2 is not set\n # CT_MPC_V_1_0_1 is not set"}, {"sha": "871d5225c0f714e035a0d97c7c2d841acfa09431", "filename": "src/ci/docker/dist-armv7-linux/patches/glibc/ports-2.16.0/001-arm-libgcc_s_resume-used.patch", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2Fdist-armv7-linux%2Fpatches%2Fglibc%2Fports-2.16.0%2F001-arm-libgcc_s_resume-used.patch", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2Fdist-armv7-linux%2Fpatches%2Fglibc%2Fports-2.16.0%2F001-arm-libgcc_s_resume-used.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armv7-linux%2Fpatches%2Fglibc%2Fports-2.16.0%2F001-arm-libgcc_s_resume-used.patch?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -0,0 +1,48 @@\n+commit bdb24c2851fd5f0ad9b82d7ea1db911d334b02d2\n+Author: Joseph Myers <joseph@codesourcery.com>\n+Date:   Tue May 20 21:27:13 2014 +0000\n+\n+    Fix ARM build with GCC trunk.\n+    \n+    sysdeps/unix/sysv/linux/arm/unwind-resume.c and\n+    sysdeps/unix/sysv/linux/arm/unwind-forcedunwind.c have static\n+    variables that are written in C code but only read from toplevel asms.\n+    Current GCC trunk now optimizes away such apparently write-only static\n+    variables, so causing a build failure.  This patch marks those\n+    variables with __attribute_used__ to avoid that optimization.\n+    \n+    Tested that this fixes the build for ARM.\n+    \n+            * sysdeps/unix/sysv/linux/arm/unwind-forcedunwind.c\n+            (libgcc_s_resume): Use __attribute_used__.\n+            * sysdeps/unix/sysv/linux/arm/unwind-resume.c (libgcc_s_resume):\n+            Likewise.\n+\n+diff --git a/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c b/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c\n+index 29e2c2b00b04..e848bfeffdcb 100644\n+--- a/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c\n++++ b/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c\n+@@ -22,7 +22,8 @@\n+ #include <pthreadP.h>\n+ \n+ static void *libgcc_s_handle;\n+-static void (*libgcc_s_resume) (struct _Unwind_Exception *exc);\n++static void (*libgcc_s_resume) (struct _Unwind_Exception *exc)\n++  __attribute_used__;\n+ static _Unwind_Reason_Code (*libgcc_s_personality)\n+   (_Unwind_State, struct _Unwind_Exception *, struct _Unwind_Context *);\n+ static _Unwind_Reason_Code (*libgcc_s_forcedunwind)\n+diff --git a/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c b/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c\n+index 285b99b5ed0d..48d00fc83641 100644\n+--- a/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c\n++++ b/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c\n+@@ -20,7 +20,8 @@\n+ #include <stdio.h>\n+ #include <unwind.h>\n+ \n+-static void (*libgcc_s_resume) (struct _Unwind_Exception *exc);\n++static void (*libgcc_s_resume) (struct _Unwind_Exception *exc)\n++  __attribute_used__;\n+ static _Unwind_Reason_Code (*libgcc_s_personality)\n+   (_Unwind_State, struct _Unwind_Exception *, struct _Unwind_Context *);\n+ "}, {"sha": "a96b4882c2d5765e3a600e77ebbef747f6e4d9ff", "filename": "src/ci/docker/dist-powerpc-linux/patches/glibc/2.12.2/002-newer-gcc.patch", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2Fpatches%2Fglibc%2F2.12.2%2F002-newer-gcc.patch", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2Fpatches%2Fglibc%2F2.12.2%2F002-newer-gcc.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2Fpatches%2Fglibc%2F2.12.2%2F002-newer-gcc.patch?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -0,0 +1,26 @@\n+diff --git a/configure b/configure\n+index b6752d147c6b..6089a3403410 100755\n+--- a/configure\n++++ b/configure\n+@@ -5079,7 +5079,7 @@ $as_echo_n \"checking version of $CC... \" >&6; }\n+   ac_prog_version=`$CC -v 2>&1 | sed -n 's/^.*version \\([egcygnustpi-]*[0-9.]*\\).*$/\\1/p'`\n+   case $ac_prog_version in\n+     '') ac_prog_version=\"v. ?.??, bad\"; ac_verc_fail=yes;;\n+-    3.4* | 4.[0-9]* )\n++    3.4* | [4-9].* )\n+        ac_prog_version=\"$ac_prog_version, ok\"; ac_verc_fail=no;;\n+     *) ac_prog_version=\"$ac_prog_version, bad\"; ac_verc_fail=yes;;\n+ \n+diff --git a/configure.in b/configure.in\n+index 56849dfc489a..09677eb3d0c1 100644\n+--- a/configure.in\n++++ b/configure.in\n+@@ -960,7 +960,7 @@ fi\n+ # These programs are version sensitive.\n+ AC_CHECK_TOOL_PREFIX\n+ AC_CHECK_PROG_VER(CC, ${ac_tool_prefix}gcc ${ac_tool_prefix}cc, -v,\n+-  [version \\([egcygnustpi-]*[0-9.]*\\)], [3.4* | 4.[0-9]* ],\n++  [version \\([egcygnustpi-]*[0-9.]*\\)], [3.4* | [4-9].* ],\n+   critic_missing=\"$critic_missing gcc\")\n+ AC_CHECK_PROG_VER(MAKE, gnumake gmake make, --version,\n+   [GNU Make[^0-9]*\\([0-9][0-9.]*\\)],"}, {"sha": "7df41da2bf76e87cc5f3fe670b252b6850318578", "filename": "src/ci/docker/dist-powerpc-linux/powerpc-linux-gnu.config", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2Fpowerpc-linux-gnu.config", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2Fpowerpc-linux-gnu.config", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2Fpowerpc-linux-gnu.config?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -359,8 +359,8 @@ CT_CC_CORE_PASS_1_NEEDED=y\n CT_CC_CORE_PASS_2_NEEDED=y\n CT_CC_gcc=y\n # CT_CC_GCC_SHOW_LINARO is not set\n-# CT_CC_GCC_V_5_2_0 is not set\n-CT_CC_GCC_V_4_9_3=y\n+CT_CC_GCC_V_5_2_0=y\n+# CT_CC_GCC_V_4_9_3 is not set\n # CT_CC_GCC_V_4_8_5 is not set\n # CT_CC_GCC_V_4_7_4 is not set\n # CT_CC_GCC_V_4_6_4 is not set\n@@ -375,8 +375,9 @@ CT_CC_GCC_4_5_or_later=y\n CT_CC_GCC_4_6_or_later=y\n CT_CC_GCC_4_7_or_later=y\n CT_CC_GCC_4_8_or_later=y\n-CT_CC_GCC_4_9=y\n CT_CC_GCC_4_9_or_later=y\n+CT_CC_GCC_5=y\n+CT_CC_GCC_5_or_later=y\n CT_CC_GCC_HAS_GRAPHITE=y\n CT_CC_GCC_USE_GRAPHITE=y\n CT_CC_GCC_HAS_LTO=y\n@@ -388,7 +389,7 @@ CT_CC_GCC_USE_GMP_MPFR=y\n CT_CC_GCC_USE_MPC=y\n CT_CC_GCC_HAS_LIBQUADMATH=y\n CT_CC_GCC_HAS_LIBSANITIZER=y\n-CT_CC_GCC_VERSION=\"4.9.3\"\n+CT_CC_GCC_VERSION=\"5.2.0\"\n # CT_CC_LANG_FORTRAN is not set\n CT_CC_GCC_ENABLE_CXX_FLAGS=\"\"\n CT_CC_GCC_CORE_EXTRA_CONFIG_ARRAY=\"\"\n@@ -460,15 +461,13 @@ CT_GETTEXT_NEEDED=y\n CT_GMP_NEEDED=y\n CT_MPFR_NEEDED=y\n CT_ISL_NEEDED=y\n-CT_CLOOG_NEEDED=y\n CT_MPC_NEEDED=y\n CT_COMPLIBS=y\n CT_LIBICONV=y\n CT_GETTEXT=y\n CT_GMP=y\n CT_MPFR=y\n CT_ISL=y\n-CT_CLOOG=y\n CT_MPC=y\n CT_LIBICONV_V_1_14=y\n CT_LIBICONV_VERSION=\"1.14\"\n@@ -494,15 +493,13 @@ CT_MPFR_V_3_1_3=y\n # CT_MPFR_V_2_4_0 is not set\n CT_MPFR_VERSION=\"3.1.3\"\n CT_ISL_V_0_14=y\n+# CT_ISL_V_0_12_2 is not set\n CT_ISL_V_0_14_or_later=y\n CT_ISL_V_0_12_or_later=y\n CT_ISL_VERSION=\"0.14\"\n-CT_CLOOG_V_0_18_4=y\n+# CT_CLOOG_V_0_18_4 is not set\n # CT_CLOOG_V_0_18_1 is not set\n # CT_CLOOG_V_0_18_0 is not set\n-CT_CLOOG_VERSION=\"0.18.4\"\n-CT_CLOOG_0_18_4_or_later=y\n-CT_CLOOG_0_18_or_later=y\n CT_MPC_V_1_0_3=y\n # CT_MPC_V_1_0_2 is not set\n # CT_MPC_V_1_0_1 is not set"}, {"sha": "a96b4882c2d5765e3a600e77ebbef747f6e4d9ff", "filename": "src/ci/docker/dist-powerpc64-linux/patches/glibc/2.12.2/003-newer-gcc.patch", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2Fpatches%2Fglibc%2F2.12.2%2F003-newer-gcc.patch", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2Fpatches%2Fglibc%2F2.12.2%2F003-newer-gcc.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2Fpatches%2Fglibc%2F2.12.2%2F003-newer-gcc.patch?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -0,0 +1,26 @@\n+diff --git a/configure b/configure\n+index b6752d147c6b..6089a3403410 100755\n+--- a/configure\n++++ b/configure\n+@@ -5079,7 +5079,7 @@ $as_echo_n \"checking version of $CC... \" >&6; }\n+   ac_prog_version=`$CC -v 2>&1 | sed -n 's/^.*version \\([egcygnustpi-]*[0-9.]*\\).*$/\\1/p'`\n+   case $ac_prog_version in\n+     '') ac_prog_version=\"v. ?.??, bad\"; ac_verc_fail=yes;;\n+-    3.4* | 4.[0-9]* )\n++    3.4* | [4-9].* )\n+        ac_prog_version=\"$ac_prog_version, ok\"; ac_verc_fail=no;;\n+     *) ac_prog_version=\"$ac_prog_version, bad\"; ac_verc_fail=yes;;\n+ \n+diff --git a/configure.in b/configure.in\n+index 56849dfc489a..09677eb3d0c1 100644\n+--- a/configure.in\n++++ b/configure.in\n+@@ -960,7 +960,7 @@ fi\n+ # These programs are version sensitive.\n+ AC_CHECK_TOOL_PREFIX\n+ AC_CHECK_PROG_VER(CC, ${ac_tool_prefix}gcc ${ac_tool_prefix}cc, -v,\n+-  [version \\([egcygnustpi-]*[0-9.]*\\)], [3.4* | 4.[0-9]* ],\n++  [version \\([egcygnustpi-]*[0-9.]*\\)], [3.4* | [4-9].* ],\n+   critic_missing=\"$critic_missing gcc\")\n+ AC_CHECK_PROG_VER(MAKE, gnumake gmake make, --version,\n+   [GNU Make[^0-9]*\\([0-9][0-9.]*\\)],"}, {"sha": "4aab4f4fd44457eccf86ed90e8290bdd59f1e6e1", "filename": "src/ci/docker/dist-powerpc64-linux/powerpc64-linux-gnu.config", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2Fpowerpc64-linux-gnu.config", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2Fpowerpc64-linux-gnu.config", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2Fpowerpc64-linux-gnu.config?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -359,8 +359,8 @@ CT_CC_CORE_PASS_1_NEEDED=y\n CT_CC_CORE_PASS_2_NEEDED=y\n CT_CC_gcc=y\n # CT_CC_GCC_SHOW_LINARO is not set\n-# CT_CC_GCC_V_5_2_0 is not set\n-CT_CC_GCC_V_4_9_3=y\n+CT_CC_GCC_V_5_2_0=y\n+# CT_CC_GCC_V_4_9_3 is not set\n # CT_CC_GCC_V_4_8_5 is not set\n # CT_CC_GCC_V_4_7_4 is not set\n # CT_CC_GCC_V_4_6_4 is not set\n@@ -375,8 +375,9 @@ CT_CC_GCC_4_5_or_later=y\n CT_CC_GCC_4_6_or_later=y\n CT_CC_GCC_4_7_or_later=y\n CT_CC_GCC_4_8_or_later=y\n-CT_CC_GCC_4_9=y\n CT_CC_GCC_4_9_or_later=y\n+CT_CC_GCC_5=y\n+CT_CC_GCC_5_or_later=y\n CT_CC_GCC_HAS_GRAPHITE=y\n CT_CC_GCC_USE_GRAPHITE=y\n CT_CC_GCC_HAS_LTO=y\n@@ -388,7 +389,7 @@ CT_CC_GCC_USE_GMP_MPFR=y\n CT_CC_GCC_USE_MPC=y\n CT_CC_GCC_HAS_LIBQUADMATH=y\n CT_CC_GCC_HAS_LIBSANITIZER=y\n-CT_CC_GCC_VERSION=\"4.9.3\"\n+CT_CC_GCC_VERSION=\"5.2.0\"\n # CT_CC_LANG_FORTRAN is not set\n CT_CC_GCC_ENABLE_CXX_FLAGS=\"\"\n CT_CC_GCC_CORE_EXTRA_CONFIG_ARRAY=\"\"\n@@ -460,15 +461,13 @@ CT_GETTEXT_NEEDED=y\n CT_GMP_NEEDED=y\n CT_MPFR_NEEDED=y\n CT_ISL_NEEDED=y\n-CT_CLOOG_NEEDED=y\n CT_MPC_NEEDED=y\n CT_COMPLIBS=y\n CT_LIBICONV=y\n CT_GETTEXT=y\n CT_GMP=y\n CT_MPFR=y\n CT_ISL=y\n-CT_CLOOG=y\n CT_MPC=y\n CT_LIBICONV_V_1_14=y\n CT_LIBICONV_VERSION=\"1.14\"\n@@ -494,15 +493,10 @@ CT_MPFR_V_3_1_3=y\n # CT_MPFR_V_2_4_0 is not set\n CT_MPFR_VERSION=\"3.1.3\"\n CT_ISL_V_0_14=y\n+# CT_ISL_V_0_12_2 is not set\n CT_ISL_V_0_14_or_later=y\n CT_ISL_V_0_12_or_later=y\n CT_ISL_VERSION=\"0.14\"\n-CT_CLOOG_V_0_18_4=y\n-# CT_CLOOG_V_0_18_1 is not set\n-# CT_CLOOG_V_0_18_0 is not set\n-CT_CLOOG_VERSION=\"0.18.4\"\n-CT_CLOOG_0_18_4_or_later=y\n-CT_CLOOG_0_18_or_later=y\n CT_MPC_V_1_0_3=y\n # CT_MPC_V_1_0_2 is not set\n # CT_MPC_V_1_0_1 is not set"}, {"sha": "a96b4882c2d5765e3a600e77ebbef747f6e4d9ff", "filename": "src/ci/docker/dist-s390x-linux/patches/glibc/2.12.2/002-newer-gcc.patch", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2Fdist-s390x-linux%2Fpatches%2Fglibc%2F2.12.2%2F002-newer-gcc.patch", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2Fdist-s390x-linux%2Fpatches%2Fglibc%2F2.12.2%2F002-newer-gcc.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-s390x-linux%2Fpatches%2Fglibc%2F2.12.2%2F002-newer-gcc.patch?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -0,0 +1,26 @@\n+diff --git a/configure b/configure\n+index b6752d147c6b..6089a3403410 100755\n+--- a/configure\n++++ b/configure\n+@@ -5079,7 +5079,7 @@ $as_echo_n \"checking version of $CC... \" >&6; }\n+   ac_prog_version=`$CC -v 2>&1 | sed -n 's/^.*version \\([egcygnustpi-]*[0-9.]*\\).*$/\\1/p'`\n+   case $ac_prog_version in\n+     '') ac_prog_version=\"v. ?.??, bad\"; ac_verc_fail=yes;;\n+-    3.4* | 4.[0-9]* )\n++    3.4* | [4-9].* )\n+        ac_prog_version=\"$ac_prog_version, ok\"; ac_verc_fail=no;;\n+     *) ac_prog_version=\"$ac_prog_version, bad\"; ac_verc_fail=yes;;\n+ \n+diff --git a/configure.in b/configure.in\n+index 56849dfc489a..09677eb3d0c1 100644\n+--- a/configure.in\n++++ b/configure.in\n+@@ -960,7 +960,7 @@ fi\n+ # These programs are version sensitive.\n+ AC_CHECK_TOOL_PREFIX\n+ AC_CHECK_PROG_VER(CC, ${ac_tool_prefix}gcc ${ac_tool_prefix}cc, -v,\n+-  [version \\([egcygnustpi-]*[0-9.]*\\)], [3.4* | 4.[0-9]* ],\n++  [version \\([egcygnustpi-]*[0-9.]*\\)], [3.4* | [4-9].* ],\n+   critic_missing=\"$critic_missing gcc\")\n+ AC_CHECK_PROG_VER(MAKE, gnumake gmake make, --version,\n+   [GNU Make[^0-9]*\\([0-9][0-9.]*\\)],"}, {"sha": "cd1c41b02e3122e53059ac6a9a5565cd8952cb62", "filename": "src/ci/docker/dist-s390x-linux/s390x-linux-gnu.config", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2Fdist-s390x-linux%2Fs390x-linux-gnu.config", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2Fdist-s390x-linux%2Fs390x-linux-gnu.config", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-s390x-linux%2Fs390x-linux-gnu.config?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -339,8 +339,8 @@ CT_CC_CORE_PASS_1_NEEDED=y\n CT_CC_CORE_PASS_2_NEEDED=y\n CT_CC_gcc=y\n # CT_CC_GCC_SHOW_LINARO is not set\n-# CT_CC_GCC_V_5_2_0 is not set\n-CT_CC_GCC_V_4_9_3=y\n+CT_CC_GCC_V_5_2_0=y\n+# CT_CC_GCC_V_4_9_3 is not set\n # CT_CC_GCC_V_4_8_5 is not set\n # CT_CC_GCC_V_4_7_4 is not set\n # CT_CC_GCC_V_4_6_4 is not set\n@@ -355,8 +355,9 @@ CT_CC_GCC_4_5_or_later=y\n CT_CC_GCC_4_6_or_later=y\n CT_CC_GCC_4_7_or_later=y\n CT_CC_GCC_4_8_or_later=y\n-CT_CC_GCC_4_9=y\n CT_CC_GCC_4_9_or_later=y\n+CT_CC_GCC_5=y\n+CT_CC_GCC_5_or_later=y\n CT_CC_GCC_HAS_GRAPHITE=y\n CT_CC_GCC_USE_GRAPHITE=y\n CT_CC_GCC_HAS_LTO=y\n@@ -368,7 +369,7 @@ CT_CC_GCC_USE_GMP_MPFR=y\n CT_CC_GCC_USE_MPC=y\n CT_CC_GCC_HAS_LIBQUADMATH=y\n CT_CC_GCC_HAS_LIBSANITIZER=y\n-CT_CC_GCC_VERSION=\"4.9.3\"\n+CT_CC_GCC_VERSION=\"5.2.0\"\n # CT_CC_LANG_FORTRAN is not set\n CT_CC_GCC_ENABLE_CXX_FLAGS=\"\"\n CT_CC_GCC_CORE_EXTRA_CONFIG_ARRAY=\"\"\n@@ -440,15 +441,13 @@ CT_GETTEXT_NEEDED=y\n CT_GMP_NEEDED=y\n CT_MPFR_NEEDED=y\n CT_ISL_NEEDED=y\n-CT_CLOOG_NEEDED=y\n CT_MPC_NEEDED=y\n CT_COMPLIBS=y\n CT_LIBICONV=y\n CT_GETTEXT=y\n CT_GMP=y\n CT_MPFR=y\n CT_ISL=y\n-CT_CLOOG=y\n CT_MPC=y\n CT_LIBICONV_V_1_14=y\n CT_LIBICONV_VERSION=\"1.14\"\n@@ -474,15 +473,13 @@ CT_MPFR_V_3_1_3=y\n # CT_MPFR_V_2_4_0 is not set\n CT_MPFR_VERSION=\"3.1.3\"\n CT_ISL_V_0_14=y\n+# CT_ISL_V_0_12_2 is not set\n CT_ISL_V_0_14_or_later=y\n CT_ISL_V_0_12_or_later=y\n CT_ISL_VERSION=\"0.14\"\n-CT_CLOOG_V_0_18_4=y\n+# CT_CLOOG_V_0_18_4 is not set\n # CT_CLOOG_V_0_18_1 is not set\n # CT_CLOOG_V_0_18_0 is not set\n-CT_CLOOG_VERSION=\"0.18.4\"\n-CT_CLOOG_0_18_4_or_later=y\n-CT_CLOOG_0_18_or_later=y\n CT_MPC_V_1_0_3=y\n # CT_MPC_V_1_0_2 is not set\n # CT_MPC_V_1_0_1 is not set"}, {"sha": "f80293b182e97d93ba03ceb23d068301a9340288", "filename": "src/ci/docker/dist-various-1/Dockerfile", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -112,6 +112,8 @@ ENV TARGETS=$TARGETS,thumbv7em-none-eabihf\n ENV TARGETS=$TARGETS,thumbv8m.main-none-eabi\n ENV TARGETS=$TARGETS,riscv32imc-unknown-none-elf\n ENV TARGETS=$TARGETS,riscv32imac-unknown-none-elf\n+ENV TARGETS=$TARGETS,riscv64imac-unknown-none-elf\n+ENV TARGETS=$TARGETS,riscv64gc-unknown-none-elf\n ENV TARGETS=$TARGETS,armebv7r-none-eabi\n ENV TARGETS=$TARGETS,armebv7r-none-eabihf\n ENV TARGETS=$TARGETS,armv7r-none-eabi"}, {"sha": "3354a796c357e51672845828d83e4a0e94160722", "filename": "src/ci/docker/dist-various-2/build-cloudabi-toolchain.sh", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-cloudabi-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-cloudabi-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-cloudabi-toolchain.sh?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -32,9 +32,8 @@ ln -s ../lib/llvm-5.0/bin/lld /usr/bin/${target}-ld\n ln -s ../../${target} /usr/lib/llvm-5.0/${target}\n \n # Install the C++ runtime libraries from CloudABI Ports.\n-echo deb https://nuxi.nl/distfiles/cloudabi-ports/debian/ cloudabi cloudabi > \\\n-    /etc/apt/sources.list.d/cloudabi.list\n-curl 'https://pgp.mit.edu/pks/lookup?op=get&search=0x0DA51B8531344B15' | \\\n-    apt-key add -\n+apt-key adv --batch --yes --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 0DA51B8531344B15\n+add-apt-repository -y 'deb https://nuxi.nl/distfiles/cloudabi-ports/debian/ cloudabi cloudabi'\n+\n apt-get update\n-apt-get install -y $(echo ${target} | sed -e s/_/-/g)-cxx-runtime\n+apt-get install -y \"${target//_/-}-cxx-runtime\""}, {"sha": "ac681b71686229cedb957e8f95b1337e2297c06a", "filename": "src/ci/docker/dist-x86_64-linux/build-clang.sh", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-clang.sh", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-clang.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-clang.sh?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -4,26 +4,14 @@ set -ex\n \n source shared.sh\n \n-# Currently these commits are all tip-of-tree as of 2018-12-16, used to pick up\n-# a fix for rust-lang/rust#56849\n-LLVM=032b00a5404865765cda7db3039f39d54964d8b0\n-LLD=3e4aa4e8671523321af51449e0569f455ef3ad43\n-CLANG=a6b9739069763243020f4ea6fe586bc135fde1f9\n+LLVM=llvmorg-8.0.0-rc2\n \n-mkdir clang\n-cd clang\n+mkdir llvm-project\n+cd llvm-project\n \n-curl -L https://github.com/llvm-mirror/llvm/archive/$LLVM.tar.gz | \\\n+curl -L https://github.com/llvm/llvm-project/archive/$LLVM.tar.gz | \\\n   tar xzf - --strip-components=1\n \n-mkdir -p tools/clang\n-curl -L https://github.com/llvm-mirror/clang/archive/$CLANG.tar.gz | \\\n-  tar xzf - --strip-components=1 -C tools/clang\n-\n-mkdir -p tools/lld\n-curl -L https://github.com/llvm-mirror/lld/archive/$LLD.tar.gz | \\\n-  tar zxf - --strip-components=1 -C tools/lld\n-\n mkdir clang-build\n cd clang-build\n \n@@ -39,20 +27,21 @@ cd clang-build\n #\n # [1]: https://sourceware.org/ml/crossgcc/2008-11/msg00028.html\n INC=\"/rustroot/include\"\n-INC=\"$INC:/rustroot/lib/gcc/x86_64-unknown-linux-gnu/4.8.5/include-fixed\"\n+INC=\"$INC:/rustroot/lib/gcc/x86_64-unknown-linux-gnu/5.5.0/include-fixed\"\n INC=\"$INC:/usr/include\"\n \n hide_output \\\n-    cmake .. \\\n+    cmake ../llvm \\\n       -DCMAKE_C_COMPILER=/rustroot/bin/gcc \\\n       -DCMAKE_CXX_COMPILER=/rustroot/bin/g++ \\\n       -DCMAKE_BUILD_TYPE=Release \\\n       -DCMAKE_INSTALL_PREFIX=/rustroot \\\n       -DLLVM_TARGETS_TO_BUILD=X86 \\\n+      -DLLVM_ENABLE_PROJECTS=\"clang;lld\" \\\n       -DC_INCLUDE_DIRS=\"$INC\"\n \n hide_output make -j10\n hide_output make install\n \n cd ../..\n-rm -rf clang\n+rm -rf llvm-project"}, {"sha": "7f6e94d326ddf3012e8bf1257b5b99f727c4f1cb", "filename": "src/ci/docker/dist-x86_64-linux/build-gcc.sh", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-gcc.sh", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-gcc.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-gcc.sh?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -3,9 +3,9 @@ set -ex\n \n source shared.sh\n \n-GCC=4.8.5\n+GCC=5.5.0\n \n-curl https://ftp.gnu.org/gnu/gcc/gcc-$GCC/gcc-$GCC.tar.bz2 | tar xjf -\n+curl https://ftp.gnu.org/gnu/gcc/gcc-$GCC/gcc-$GCC.tar.xz | xzcat | tar xf -\n cd gcc-$GCC\n \n # FIXME(#49246): Remove the `sed` below."}, {"sha": "a678d353d52f5881f69ffde98d10dfac6ceeb465", "filename": "src/ci/docker/dist-x86_64-linux/build-perl.sh", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-perl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-perl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-perl.sh?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -11,7 +11,8 @@ cd perl-5.28.0\n # Gotta do some hackery to tell python about our custom OpenSSL build, but other\n # than that fairly normal.\n CC=gcc \\\n-CFLAGS='-I /rustroot/include' LDFLAGS='-L /rustroot/lib -L /rustroot/lib64' \\\n+CFLAGS='-I /rustroot/include -fgnu89-inline' \\\n+LDFLAGS='-L /rustroot/lib -L /rustroot/lib64' \\\n     hide_output ./configure.gnu\n hide_output make -j10\n hide_output make install"}, {"sha": "3343716419ff459a473a69a4488f99251fcc7ab0", "filename": "src/ci/docker/x86_64-gnu-tools/checktools.sh", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -23,6 +23,7 @@ python2.7 \"$X_PY\" test --no-fail-fast \\\n     src/doc/nomicon \\\n     src/doc/reference \\\n     src/doc/rust-by-example \\\n+    src/doc/embedded-book \\\n     src/tools/clippy \\\n     src/tools/rls \\\n     src/tools/rustfmt \\"}, {"sha": "42d0d7db5964ca59a2e444e1aed0dc80ab43f795", "filename": "src/ci/run.sh", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -121,14 +121,7 @@ fi\n travis_fold end log-system-info\n \n if [ ! -z \"$SCRIPT\" ]; then\n-  # This `set +e` followed by capturing the return value is a temporary measure\n-  # to help debug \"error with exit 259\" on AppVeyor temporarily, otherwise all\n-  # that's needed here is the `sh`\n-  set +e\n   sh -x -c \"$SCRIPT\"\n-  ret=$?\n-  echo \"script exited with $ret\"\n-  exit $ret\n else\n   do_make() {\n     travis_fold start \"make-$1\""}, {"sha": "bd2778f304989ee52be8201504d6ec621dd60ca9", "filename": "src/doc/embedded-book", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fembedded-book?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -0,0 +1 @@\n+Subproject commit bd2778f304989ee52be8201504d6ec621dd60ca9"}, {"sha": "fd71d3e3c8e79e1030039dc17f587cda6018df3a", "filename": "src/doc/guide-error-handling.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fdoc%2Fguide-error-handling.md", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fdoc%2Fguide-error-handling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-error-handling.md?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,4 +1,4 @@\n % Error Handling in Rust\n \n This content has moved into\n-[the Rust Programming Language book](book/error-handling.html).\n+[the Rust Programming Language book](book/ch09-00-error-handling.html)."}, {"sha": "767dafc5baf9208e3927680947fe3da83c493201", "filename": "src/doc/guide-ownership.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fdoc%2Fguide-ownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fdoc%2Fguide-ownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-ownership.md?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,4 +1,4 @@\n % The (old) Rust Ownership Guide\n \n This content has moved into\n-[the Rust Programming Language book](book/ownership.html).\n+[the Rust Programming Language book](book/ch04-00-understanding-ownership.html)."}, {"sha": "bafdb2fe0bbc3790867d1e8a117226f033c298ae", "filename": "src/doc/guide-pointers.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fdoc%2Fguide-pointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fdoc%2Fguide-pointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-pointers.md?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -2,6 +2,6 @@\n \n This content has been removed, with no direct replacement. Rust only\n has two built-in pointer types now,\n-[references](book/references-and-borrowing.html) and [raw\n+[references](book/ch04-02-references-and-borrowing.html) and [raw\n pointers](book/raw-pointers.html). Older Rusts had many more pointer\n types, they\u2019re gone now."}, {"sha": "28d9fb48b73e74485f6a8b930428a7fbb6db81ef", "filename": "src/doc/guide-testing.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fdoc%2Fguide-testing.md", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fdoc%2Fguide-testing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-testing.md?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,4 +1,4 @@\n % The (old) Rust Testing Guide\n \n This content has moved into\n-[the Rust Programming Language book](book/testing.html).\n+[the Rust Programming Language book](book/ch11-00-testing.html)."}, {"sha": "0a2a80e8fd6e2b4d62dcf9a93f2dc5983b0da249", "filename": "src/doc/index.md", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -52,6 +52,12 @@ If reading multiple hundreds of pages about a language isn't your style, then\n a lot of words, RBE shows off a bunch of code, and keeps the talking to a\n minimum. It also includes exercises!\n \n+## Rustlings\n+\n+[Rustlings](https://github.com/rust-lang/rustlings) guides you through downloading and setting up the Rust toolchain,\n+and teaches you the basics of reading and writing Rust syntax. It's an\n+alternative to Rust by Example that works with your own environment.\n+\n # Use Rust\n \n Once you've gotten familiar with the language, these resources can help you\n@@ -117,3 +123,19 @@ Rust. It's also sometimes called \"the 'nomicon.\"\n [The `rustc` Guide](https://rust-lang.github.io/rustc-guide/) documents how\n the compiler works and how to contribute to it. This is useful if you want to build\n or modify the Rust compiler from source (e.g. to target something non-standard).\n+\n+# Specialize Rust\n+\n+When using Rust in specific domain areas, consider using the following resources tailored to each domain.\n+\n+## Embedded Systems\n+\n+When developing for Bare Metal or Embedded Linux systems, you may find these resources maintained by the [Embedded Working Group] useful.\n+\n+[Embedded Working Group]: https://github.com/rust-embedded\n+\n+### The Embedded Rust Book\n+\n+[The Embedded Rust Book] is targeted at developers familiar with embedded development and familiar with Rust, but have not used Rust for embedded development.\n+\n+[The Embedded Rust Book]: embedded-book/index.html"}, {"sha": "34708d1847f6b802e908cc147133a1b0b475642f", "filename": "src/doc/rustc/src/SUMMARY.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -13,4 +13,5 @@\n - [Targets](targets/index.md)\n     - [Built-in Targets](targets/built-in.md)\n     - [Custom Targets](targets/custom.md)\n-- [Contributing to `rustc`](contributing.md)\n\\ No newline at end of file\n+- [Linker-plugin based LTO](linker-plugin-lto.md)\n+- [Contributing to `rustc`](contributing.md)"}, {"sha": "73a2efcb33a75a1b2ac2473f5e15c59de932e3b5", "filename": "src/doc/rustc/src/linker-plugin-lto.md", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -0,0 +1,108 @@\n+# Linker-plugin-LTO\n+\n+The `-C linker-plugin-lto` flag allows for deferring the LTO optimization\n+to the actual linking step, which in turn allows for performing\n+interprocedural optimizations across programming language boundaries if\n+all the object files being linked were created by LLVM based toolchains.\n+The prime example here would be linking Rust code together with\n+Clang-compiled C/C++ code.\n+\n+## Usage\n+\n+There are two main cases how linker plugin based LTO can be used:\n+\n+ - compiling a Rust `staticlib` that is used as a C ABI dependency\n+ - compiling a Rust binary where `rustc` invokes the linker\n+\n+In both cases the Rust code has to be compiled with `-C linker-plugin-lto` and\n+the C/C++ code with `-flto` or `-flto=thin` so that object files are emitted\n+as LLVM bitcode.\n+\n+### Rust `staticlib` as dependency in C/C++ program\n+\n+In this case the Rust compiler just has to make sure that the object files in\n+the `staticlib` are in the right format. For linking, a linker with the\n+LLVM plugin must be used (e.g. LLD).\n+\n+Using `rustc` directly:\n+\n+```bash\n+# Compile the Rust staticlib\n+rustc --crate-type=staticlib -Clinker-plugin-lto -Copt-level=2 ./lib.rs\n+# Compile the C code with `-flto=thin`\n+clang -c -O2 -flto=thin -o main.o ./main.c\n+# Link everything, making sure that we use an appropriate linker\n+clang -flto=thin -fuse-ld=lld -L . -l\"name-of-your-rust-lib\" -o main -O2 ./cmain.o\n+```\n+\n+Using `cargo`:\n+\n+```bash\n+# Compile the Rust staticlib\n+RUSTFLAGS=\"-Clinker-plugin-lto\" cargo build --release\n+# Compile the C code with `-flto=thin`\n+clang -c -O2 -flto=thin -o main.o ./main.c\n+# Link everything, making sure that we use an appropriate linker\n+clang -flto=thin -fuse-ld=lld -L . -l\"name-of-your-rust-lib\" -o main -O2 ./cmain.o\n+```\n+\n+### C/C++ code as a dependency in Rust\n+\n+In this case the linker will be invoked by `rustc`. We again have to make sure\n+that an appropriate linker is used.\n+\n+Using `rustc` directly:\n+\n+```bash\n+# Compile C code with `-flto`\n+clang ./clib.c -flto=thin -c -o ./clib.o -O2\n+# Create a static library from the C code\n+ar crus ./libxyz.a ./clib.o\n+\n+# Invoke `rustc` with the additional arguments\n+rustc -Clinker-plugin-lto -L. -Copt-level=2 -Clinker=clang -Clink-arg=-fuse-ld=lld ./main.rs\n+```\n+\n+Using `cargo` directly:\n+\n+```bash\n+# Compile C code with `-flto`\n+clang ./clib.c -flto=thin -c -o ./clib.o -O2\n+# Create a static library from the C code\n+ar crus ./libxyz.a ./clib.o\n+\n+# Set the linking arguments via RUSTFLAGS\n+RUSTFLAGS=\"-Clinker-plugin-lto -Clinker=clang -Clink-arg=-fuse-ld=lld\" cargo build --release\n+```\n+\n+### Explicitly specifying the linker plugin to be used by `rustc`\n+\n+If one wants to use a linker other than LLD, the LLVM linker plugin has to be\n+specified explicitly. Otherwise the linker cannot read the object files. The\n+path to the plugin is passed as an argument to the `-Clinker-plugin-lto`\n+option:\n+\n+```bash\n+rustc -Clinker-plugin-lto=\"/path/to/LLVMgold.so\" -L. -Copt-level=2 ./main.rs\n+```\n+\n+\n+## Toolchain Compatibility\n+\n+In order for this kind of LTO to work, the LLVM linker plugin must be able to\n+handle the LLVM bitcode produced by both `rustc` and `clang`.\n+\n+Best results are achieved by using a `rustc` and `clang` that are based on the\n+exact same version of LLVM. One can use `rustc -vV` in order to view the LLVM\n+used by a given `rustc` version. Note that the version number given\n+here is only an approximation as Rust sometimes uses unstable revisions of\n+LLVM. However, the approximation is usually reliable.\n+\n+The following table shows known good combinations of toolchain versions.\n+\n+|           | Clang 7   | Clang 8   |\n+|-----------|-----------|-----------|\n+| Rust 1.34 |     \u2717     |     \u2713     |\n+| Rust 1.35 |     \u2717     |    \u2713(?)   |\n+\n+Note that the compatibility policy for this feature might change in the future."}, {"sha": "3463cdb126cc6b558e977dd2391782ca3da31e68", "filename": "src/doc/rustdoc/src/unstable-features.md", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,9 +1,8 @@\n # Unstable features\n \n Rustdoc is under active development, and like the Rust compiler, some features are only available\n-on the nightly releases. Some of these are new and need some more testing before they're able to get\n-released to the world at large, and some of them are tied to features in the Rust compiler that are\n-themselves unstable. Several features here require a matching `#![feature(...)]` attribute to\n+on nightly releases. Some of these features are new and need some more testing before they're able to be\n+released to the world at large, and some of them are tied to features in the Rust compiler that are unstable. Several features here require a matching `#![feature(...)]` attribute to\n enable, and thus are more fully documented in the [Unstable Book]. Those sections will link over\n there as necessary.\n \n@@ -428,4 +427,4 @@ $ rustdoc src/lib.rs --test -Z unstable-options --persist-doctests target/rustdo\n \n This flag allows you to keep doctest executables around after they're compiled or run.\n Usually, rustdoc will immediately discard a compiled doctest after it's been tested, but\n-with this option, you can keep those binaries around for farther testing.\n\\ No newline at end of file\n+with this option, you can keep those binaries around for farther testing."}, {"sha": "415c6ebe8b4bcfe7e45026f4e0dda575da807bcb", "filename": "src/doc/unstable-book/src/language-features/repr-align-enum.md", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr-align-enum.md", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr-align-enum.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr-align-enum.md?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -0,0 +1,42 @@\n+# `repr_align_enum`\n+\n+The tracking issue for this feature is: [#57996]\n+\n+[#57996]: https://github.com/rust-lang/rust/issues/57996\n+\n+------------------------\n+\n+The `repr_align_enum` feature allows using the `#[repr(align(x))]` attribute\n+on enums, similarly to structs.\n+\n+# Examples\n+\n+```rust\n+#![feature(repr_align_enum)]\n+\n+#[repr(align(8))]\n+enum Aligned {\n+    Foo,\n+    Bar { value: u32 },\n+}\n+\n+fn main() {\n+    assert_eq!(std::mem::align_of::<Aligned>(), 8);\n+}\n+```\n+\n+This is equivalent to using an aligned wrapper struct everywhere:\n+\n+```rust\n+#[repr(align(8))]\n+struct Aligned(Unaligned);\n+\n+enum Unaligned {\n+    Foo,\n+    Bar { value: u32 },\n+}\n+\n+fn main() {\n+    assert_eq!(std::mem::align_of::<Aligned>(), 8);\n+}\n+```"}, {"sha": "1c525101c76f66ac40d4e709eca2428c589449d3", "filename": "src/etc/generate-deriving-span-tests.py", "status": "modified", "additions": 7, "deletions": 23, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fetc%2Fgenerate-deriving-span-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fetc%2Fgenerate-deriving-span-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgenerate-deriving-span-tests.py?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -8,14 +8,12 @@\n sample usage: src/etc/generate-deriving-span-tests.py\n \"\"\"\n \n-import os, datetime, stat, re\n+import os, stat\n \n TEST_DIR = os.path.abspath(\n     os.path.join(os.path.dirname(__file__), '../test/ui/derives/'))\n \n-YEAR = datetime.datetime.now().year\n-\n-TEMPLATE = \"\"\"\n+TEMPLATE = \"\"\"\\\n // This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n {error_deriving}\n@@ -63,19 +61,11 @@ def create_test_case(type, trait, super_traits, error_count):\n \n     errors = '\\n'.join('//~%s ERROR' % ('^' * n) for n in range(error_count))\n     code = string.format(traits = all_traits, errors = errors)\n-    return TEMPLATE.format(year = YEAR, error_deriving=error_deriving, code = code)\n+    return TEMPLATE.format(error_deriving=error_deriving, code = code)\n \n def write_file(name, string):\n     test_file = os.path.join(TEST_DIR, 'derives-span-%s.rs' % name)\n \n-    with open(test_file) as f:\n-        old_str = f.read()\n-        old_str_ignoring_date = re.sub(r'^// Copyright \\d+',\n-                                        '// Copyright {year}'.format(year = YEAR), old_str)\n-        if old_str_ignoring_date == string:\n-            # if all we're doing is updating the copyright year, ignore it\n-            return 0\n-\n     # set write permission if file exists, so it can be changed\n     if os.path.exists(test_file):\n         os.chmod(test_file, stat.S_IWUSR)\n@@ -86,8 +76,6 @@ def write_file(name, string):\n     # mark file read-only\n     os.chmod(test_file, stat.S_IRUSR|stat.S_IRGRP|stat.S_IROTH)\n \n-    return 1\n-\n \n ENUM = 1\n STRUCT = 2\n@@ -110,15 +98,11 @@ def write_file(name, string):\n                               ('Hash', [], 1)]:\n     traits[trait] = (ALL, supers, errs)\n \n-files = 0\n-\n for (trait, (types, super_traits, error_count)) in traits.items():\n     mk = lambda ty: create_test_case(ty, trait, super_traits, error_count)\n     if types & ENUM:\n-        files += write_file(trait + '-enum', mk(ENUM_TUPLE))\n-        files += write_file(trait + '-enum-struct-variant', mk(ENUM_STRUCT))\n+        write_file(trait + '-enum', mk(ENUM_TUPLE))\n+        write_file(trait + '-enum-struct-variant', mk(ENUM_STRUCT))\n     if types & STRUCT:\n-        files += write_file(trait + '-struct', mk(STRUCT_FIELDS))\n-        files += write_file(trait + '-tuple-struct', mk(STRUCT_TUPLE))\n-\n-print('Generated {files} deriving span test{}.'.format('s' if files != 1 else '', files = files))\n+        write_file(trait + '-struct', mk(STRUCT_FIELDS))\n+        write_file(trait + '-tuple-struct', mk(STRUCT_TUPLE))"}, {"sha": "bc046a8f42d0b6676ac64b8a29d3e71dc539132d", "filename": "src/etc/generate-keyword-tests.py", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fetc%2Fgenerate-keyword-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fetc%2Fgenerate-keyword-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgenerate-keyword-tests.py?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -15,7 +15,7 @@\n import stat\n \n \n-template = \"\"\"\n+template = \"\"\"\\\n // This file was auto-generated using 'src/etc/generate-keyword-tests.py %s'\n \n fn main() {\n@@ -35,7 +35,7 @@\n         os.chmod(test_file, stat.S_IWUSR)\n \n     with open(test_file, 'wt') as f:\n-        f.write(template % (datetime.datetime.now().year, kw, kw, kw))\n+        f.write(template % (kw, kw, kw))\n \n     # mark file read-only\n     os.chmod(test_file, stat.S_IRUSR | stat.S_IRGRP | stat.S_IROTH)"}, {"sha": "a1884b7d548523a59423c7bbfffe285ffcf37529", "filename": "src/liballoc/benches/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Flib.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,5 +1,4 @@\n #![feature(repr_simd)]\n-#![feature(slice_sort_by_cached_key)]\n #![feature(test)]\n \n extern crate rand;"}, {"sha": "40c71f12cd8a6320e9751024c25fcc81716440cd", "filename": "src/liballoc/borrow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fborrow.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -137,11 +137,11 @@ impl<T> ToOwned for T\n /// ```\n /// use std::borrow::{Cow, ToOwned};\n ///\n-/// struct Items<'a, X: 'a> where [X]: ToOwned<Owned=Vec<X>> {\n+/// struct Items<'a, X: 'a> where [X]: ToOwned<Owned = Vec<X>> {\n ///     values: Cow<'a, [X]>,\n /// }\n ///\n-/// impl<'a, X: Clone + 'a> Items<'a, X> where [X]: ToOwned<Owned=Vec<X>> {\n+/// impl<'a, X: Clone + 'a> Items<'a, X> where [X]: ToOwned<Owned = Vec<X>> {\n ///     fn new(v: Cow<'a, [X]>) -> Self {\n ///         Items { values: v }\n ///     }"}, {"sha": "0cd2373c7f0215c19d9924522610eac7294f3d02", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -71,7 +71,7 @@ use core::ops::{\n     CoerceUnsized, DispatchFromDyn, Deref, DerefMut, Receiver, Generator, GeneratorState\n };\n use core::ptr::{self, NonNull, Unique};\n-use core::task::{LocalWaker, Poll};\n+use core::task::{Waker, Poll};\n \n use crate::vec::Vec;\n use crate::raw_vec::RawVec;\n@@ -202,10 +202,15 @@ impl<T: ?Sized> Box<T> {\n     #[unstable(feature = \"ptr_internals\", issue = \"0\", reason = \"use into_raw_non_null instead\")]\n     #[inline]\n     #[doc(hidden)]\n-    pub fn into_unique(b: Box<T>) -> Unique<T> {\n-        let unique = b.0;\n+    pub fn into_unique(mut b: Box<T>) -> Unique<T> {\n+        // Box is kind-of a library type, but recognized as a \"unique pointer\" by\n+        // Stacked Borrows.  This function here corresponds to \"reborrowing to\n+        // a raw pointer\", but there is no actual reborrow here -- so\n+        // without some care, the pointer we are returning here still carries\n+        // the `Uniq` tag.  We round-trip through a mutable reference to avoid that.\n+        let unique = unsafe { b.0.as_mut() as *mut T };\n         mem::forget(b);\n-        unique\n+        unsafe { Unique::new_unchecked(unique) }\n     }\n \n     /// Consumes and leaks the `Box`, returning a mutable reference,\n@@ -896,7 +901,7 @@ impl<G: ?Sized + Generator> Generator for Pin<Box<G>> {\n impl<F: ?Sized + Future + Unpin> Future for Box<F> {\n     type Output = F::Output;\n \n-    fn poll(mut self: Pin<&mut Self>, lw: &LocalWaker) -> Poll<Self::Output> {\n-        F::poll(Pin::new(&mut *self), lw)\n+    fn poll(mut self: Pin<&mut Self>, waker: &Waker) -> Poll<Self::Output> {\n+        F::poll(Pin::new(&mut *self), waker)\n     }\n }"}, {"sha": "3b94379b58f8f03c2e09e09bba1254263b53b423", "filename": "src/liballoc/collections/binary_heap.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -248,14 +248,18 @@ impl<T: Ord> Drop for PeekMut<'_, T> {\n impl<T: Ord> Deref for PeekMut<'_, T> {\n     type Target = T;\n     fn deref(&self) -> &T {\n-        &self.heap.data[0]\n+        debug_assert!(!self.heap.is_empty());\n+        // SAFE: PeekMut is only instantiated for non-empty heaps\n+        unsafe { self.heap.data.get_unchecked(0) }\n     }\n }\n \n #[stable(feature = \"binary_heap_peek_mut\", since = \"1.12.0\")]\n impl<T: Ord> DerefMut for PeekMut<'_, T> {\n     fn deref_mut(&mut self) -> &mut T {\n-        &mut self.heap.data[0]\n+        debug_assert!(!self.heap.is_empty());\n+        // SAFE: PeekMut is only instantiated for non-empty heaps\n+        unsafe { self.heap.data.get_unchecked_mut(0) }\n     }\n }\n \n@@ -859,13 +863,14 @@ struct Hole<'a, T: 'a> {\n }\n \n impl<'a, T> Hole<'a, T> {\n-    /// Create a new Hole at index `pos`.\n+    /// Create a new `Hole` at index `pos`.\n     ///\n     /// Unsafe because pos must be within the data slice.\n     #[inline]\n     unsafe fn new(data: &'a mut [T], pos: usize) -> Self {\n         debug_assert!(pos < data.len());\n-        let elt = ptr::read(&data[pos]);\n+        // SAFE: pos should be inside the slice\n+        let elt = ptr::read(data.get_unchecked(pos));\n         Hole {\n             data,\n             elt: ManuallyDrop::new(elt),"}, {"sha": "5ec5064b735150b45465fc1c0fc996daf52ac285", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -2368,7 +2368,7 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n \n     /// Gets a mutable reference to the value in the entry.\n     ///\n-    /// If you need a reference to the `OccupiedEntry` which may outlive the\n+    /// If you need a reference to the `OccupiedEntry` that may outlive the\n     /// destruction of the `Entry` value, see [`into_mut`].\n     ///\n     /// [`into_mut`]: #method.into_mut"}, {"sha": "fc1c18789247104ad53c992d9fa3e216d6fe2ca1", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -50,11 +50,11 @@ pub const CAPACITY: usize = 2 * B - 1;\n ///\n /// We have a separate type for the header and rely on it matching the prefix of `LeafNode`, in\n /// order to statically allocate a single dummy node to avoid allocations. This struct is\n-/// `repr(C)` to prevent them from being reordered.  `LeafNode` does not just contain a\n+/// `repr(C)` to prevent them from being reordered. `LeafNode` does not just contain a\n /// `NodeHeader` because we do not want unnecessary padding between `len` and the keys.\n-/// Crucially, `NodeHeader` can be safely transmuted to different K and V.  (This is exploited\n+/// Crucially, `NodeHeader` can be safely transmuted to different K and V. (This is exploited\n /// by `as_header`.)\n-/// See `into_key_slice` for an explanation of K2.  K2 cannot be safely transmuted around\n+/// See `into_key_slice` for an explanation of K2. K2 cannot be safely transmuted around\n /// because the size of `NodeHeader` depends on its alignment!\n #[repr(C)]\n struct NodeHeader<K, V, K2 = ()> {\n@@ -453,7 +453,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n                     root: self.root,\n                     _marker: PhantomData\n                 },\n-                idx: unsafe { usize::from(*self.as_header().parent_idx.get_ref()) },\n+                idx: unsafe { usize::from(*self.as_header().parent_idx.as_ptr()) },\n                 _marker: PhantomData\n             })\n         } else {\n@@ -1143,7 +1143,7 @@ impl<BorrowType, K, V>\n         NodeRef {\n             height: self.node.height - 1,\n             node: unsafe {\n-                self.node.as_internal().edges.get_unchecked(self.idx).get_ref().as_ptr()\n+                (&*self.node.as_internal().edges.get_unchecked(self.idx).as_ptr()).as_ptr()\n             },\n             root: self.node.root,\n             _marker: PhantomData\n@@ -1295,7 +1295,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         }\n     }\n \n-    /// Returns whether it is valid to call `.merge()`, i.e., whether there is enough room in\n+    /// Returns `true` if it is valid to call `.merge()`, i.e., whether there is enough room in\n     /// a node to hold the combination of the nodes to the left and right of this handle along\n     /// with the key/value pair at this handle.\n     pub fn can_merge(&self) -> bool {\n@@ -1573,7 +1573,7 @@ unsafe fn move_edges<K, V>(\n impl<BorrowType, K, V, HandleType>\n         Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, HandleType> {\n \n-    /// Check whether the underlying node is an `Internal` node or a `Leaf` node.\n+    /// Checks whether the underlying node is an `Internal` node or a `Leaf` node.\n     pub fn force(self) -> ForceResult<\n         Handle<NodeRef<BorrowType, K, V, marker::Leaf>, HandleType>,\n         Handle<NodeRef<BorrowType, K, V, marker::Internal>, HandleType>"}, {"sha": "870e3e47692b02ba605dea74239aa740e088c452", "filename": "src/liballoc/collections/btree/set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -556,7 +556,7 @@ impl<T: Ord> BTreeSet<T> {\n         Recover::replace(&mut self.map, value)\n     }\n \n-    /// Removes a value from the set. Returns `true` if the value was\n+    /// Removes a value from the set. Returns whether the value was\n     /// present in the set.\n     ///\n     /// The value may be any borrowed form of the set's value type,\n@@ -988,7 +988,7 @@ impl<'a, T> DoubleEndedIterator for Range<'a, T> {\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T> FusedIterator for Range<'_, T> {}\n \n-/// Compare `x` and `y`, but return `short` if x is None and `long` if y is None\n+/// Compares `x` and `y`, but return `short` if x is None and `long` if y is None\n fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>, short: Ordering, long: Ordering) -> Ordering {\n     match (x, y) {\n         (None, _) => short,"}, {"sha": "b6fdaa89992122f98c94938e9e091cfedf41a0e4", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -124,7 +124,7 @@ impl<T> VecDeque<T> {\n         ptr::write(self.ptr().add(off), value);\n     }\n \n-    /// Returns `true` if and only if the buffer is at full capacity.\n+    /// Returns `true` if the buffer is at full capacity.\n     #[inline]\n     fn is_full(&self) -> bool {\n         self.cap() - self.len() == 1\n@@ -560,7 +560,7 @@ impl<T> VecDeque<T> {\n     /// Does nothing if the capacity is already sufficient.\n     ///\n     /// Note that the allocator may give the collection more space than it\n-    /// requests. Therefore capacity can not be relied upon to be precisely\n+    /// requests. Therefore, capacity can not be relied upon to be precisely\n     /// minimal. Prefer `reserve` if future insertions are expected.\n     ///\n     /// # Errors\n@@ -924,15 +924,15 @@ impl<T> VecDeque<T> {\n         self.tail == self.head\n     }\n \n-    /// Create a draining iterator that removes the specified range in the\n+    /// Creates a draining iterator that removes the specified range in the\n     /// `VecDeque` and yields the removed items.\n     ///\n     /// Note 1: The element range is removed even if the iterator is not\n     /// consumed until the end.\n     ///\n     /// Note 2: It is unspecified how many elements are removed from the deque,\n     /// if the `Drain` value is not dropped, but the borrow it holds expires\n-    /// (eg. due to mem::forget).\n+    /// (e.g., due to `mem::forget`).\n     ///\n     /// # Panics\n     ///\n@@ -1922,7 +1922,7 @@ impl<T> VecDeque<T> {\n     ///\n     /// # Panics\n     ///\n-    /// If `mid` is greater than `len()`.  Note that `mid == len()`\n+    /// If `mid` is greater than `len()`. Note that `mid == len()`\n     /// does _not_ panic and is a no-op rotation.\n     ///\n     /// # Complexity\n@@ -1967,7 +1967,7 @@ impl<T> VecDeque<T> {\n     ///\n     /// # Panics\n     ///\n-    /// If `k` is greater than `len()`.  Note that `k == len()`\n+    /// If `k` is greater than `len()`. Note that `k == len()`\n     /// does _not_ panic and is a no-op rotation.\n     ///\n     /// # Complexity"}, {"sha": "d2ba9b001916c572e142fedfbc6d312842928cb0", "filename": "src/liballoc/fmt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ffmt.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -27,7 +27,7 @@\n //! will then parse the format string and determine if the list of arguments\n //! provided is suitable to pass to this format string.\n //!\n-//! To convert a single value to a string, use the [`to_string`] method.  This\n+//! To convert a single value to a string, use the [`to_string`] method. This\n //! will use the [`Display`] formatting trait.\n //!\n //! ## Positional parameters\n@@ -102,7 +102,7 @@\n //! When requesting that an argument be formatted with a particular type, you\n //! are actually requesting that an argument ascribes to a particular trait.\n //! This allows multiple actual types to be formatted via `{:x}` (like [`i8`] as\n-//! well as [`isize`]).  The current mapping of types to traits is:\n+//! well as [`isize`]). The current mapping of types to traits is:\n //!\n //! * *nothing* \u21d2 [`Display`]\n //! * `?` \u21d2 [`Debug`]\n@@ -427,7 +427,7 @@\n //! 3. An asterisk `.*`:\n //!\n //!    `.*` means that this `{...}` is associated with *two* format inputs rather than one: the\n-//!    first input holds the `usize` precision, and the second holds the value to print.  Note that\n+//!    first input holds the `usize` precision, and the second holds the value to print. Note that\n //!    in this case, if one uses the format string `{<arg>:<spec>.*}`, then the `<arg>` part refers\n //!    to the *value* to print, and the `precision` must come in the input preceding `<arg>`.\n //!"}, {"sha": "440ce8ac5e842d47ad5ee631f4ecdfa56bbb6c40", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -55,9 +55,7 @@\n             reason = \"this library is unlikely to be stabilized in its current \\\n                       form or name\",\n             issue = \"27783\")]\n-#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-       html_root_url = \"https://doc.rust-lang.org/nightly/\",\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\",\n        test(no_crate_inject, attr(allow(unused_variables), deny(warnings))))]\n #![no_std]\n@@ -70,7 +68,6 @@\n #![warn(intra_doc_link_resolution_failure)]\n #![warn(missing_debug_implementations)]\n \n-#![cfg_attr(not(test), feature(fn_traits))]\n #![cfg_attr(not(test), feature(generator_trait))]\n #![cfg_attr(test, feature(test))]\n \n@@ -88,6 +85,7 @@\n #![feature(dropck_eyepatch)]\n #![feature(exact_size_is_empty)]\n #![feature(fmt_internals)]\n+#![feature(fn_traits)]\n #![feature(fundamental)]\n #![feature(futures_api)]\n #![feature(lang_items)]\n@@ -102,6 +100,7 @@\n #![feature(receiver_trait)]\n #![feature(specialization)]\n #![feature(staged_api)]\n+#![feature(std_internals)]\n #![feature(str_internals)]\n #![feature(trusted_len)]\n #![feature(try_reserve)]\n@@ -113,7 +112,7 @@\n #![feature(rustc_const_unstable)]\n #![feature(const_vec_new)]\n #![feature(slice_partition_dedup)]\n-#![feature(maybe_uninit)]\n+#![feature(maybe_uninit, maybe_uninit_slice, maybe_uninit_array)]\n #![feature(alloc_layout_extra)]\n #![feature(try_trait)]\n \n@@ -133,10 +132,6 @@ mod macros;\n \n pub mod alloc;\n \n-#[unstable(feature = \"futures_api\",\n-           reason = \"futures in libcore are unstable\",\n-           issue = \"50547\")]\n-pub mod task;\n // Primitive types using the heaps above\n \n // Need to conditionally define the mod from `boxed.rs` to avoid"}, {"sha": "eb3410078513de3e25a945caaf58645462afab1f", "filename": "src/liballoc/macros.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fmacros.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -34,7 +34,8 @@\n #[cfg(not(test))]\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow_internal_unstable]\n+#[cfg_attr(not(stage0), allow_internal_unstable(box_syntax))]\n+#[cfg_attr(stage0, allow_internal_unstable)]\n macro_rules! vec {\n     ($elem:expr; $n:expr) => (\n         $crate::vec::from_elem($elem, $n)\n@@ -62,18 +63,18 @@ macro_rules! vec {\n \n /// Creates a `String` using interpolation of runtime expressions.\n ///\n-/// The first argument `format!` receives is a format string.  This must be a string\n-/// literal.  The power of the formatting string is in the `{}`s contained.\n+/// The first argument `format!` receives is a format string. This must be a string\n+/// literal. The power of the formatting string is in the `{}`s contained.\n ///\n /// Additional parameters passed to `format!` replace the `{}`s within the\n /// formatting string in the order given unless named or positional parameters\n-/// are used, see [`std::fmt`][fmt] for more information.\n+/// are used; see [`std::fmt`][fmt] for more information.\n ///\n /// A common use for `format!` is concatenation and interpolation of strings.\n /// The same convention is used with [`print!`] and [`write!`] macros,\n /// depending on the intended destination of the string.\n ///\n-/// To convert a single value to a string, use the [`to_string`] method.  This\n+/// To convert a single value to a string, use the [`to_string`] method. This\n /// will use the [`Display`] formatting trait.\n ///\n /// [fmt]: ../std/fmt/index.html"}, {"sha": "fe28fe5095ccef29333311057ac65cb415f31da0", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -335,7 +335,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// enough to want to do that it's easiest to just have a dedicated method. Slightly\n     /// more efficient logic can be provided for this than the general case.\n     ///\n-    /// Returns true if the reallocation attempt has succeeded, or false otherwise.\n+    /// Returns `true` if the reallocation attempt has succeeded.\n     ///\n     /// # Panics\n     ///\n@@ -504,7 +504,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// the requested space. This is not really unsafe, but the unsafe\n     /// code *you* write that relies on the behavior of this function may break.\n     ///\n-    /// Returns true if the reallocation attempt has succeeded, or false otherwise.\n+    /// Returns `true` if the reallocation attempt has succeeded.\n     ///\n     /// # Panics\n     ///"}, {"sha": "12f75d84211e6f03e555b4c7e32e2aabc7c5255c", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -512,7 +512,7 @@ impl<T: ?Sized> Rc<T> {\n         this.strong()\n     }\n \n-    /// Returns true if there are no other `Rc` or [`Weak`][weak] pointers to\n+    /// Returns `true` if there are no other `Rc` or [`Weak`][weak] pointers to\n     /// this inner value.\n     ///\n     /// [weak]: struct.Weak.html\n@@ -561,7 +561,7 @@ impl<T: ?Sized> Rc<T> {\n \n     #[inline]\n     #[stable(feature = \"ptr_eq\", since = \"1.17.0\")]\n-    /// Returns true if the two `Rc`s point to the same value (not\n+    /// Returns `true` if the two `Rc`s point to the same value (not\n     /// just values that compare as equal).\n     ///\n     /// # Examples\n@@ -1334,8 +1334,8 @@ impl<T: ?Sized> Weak<T> {\n         })\n     }\n \n-    /// Return `None` when the pointer is dangling and there is no allocated `RcBox`,\n-    /// i.e., this `Weak` was created by `Weak::new`\n+    /// Returns `None` when the pointer is dangling and there is no allocated `RcBox`\n+    /// (i.e., when this `Weak` was created by `Weak::new`).\n     #[inline]\n     fn inner(&self) -> Option<&RcBox<T>> {\n         if is_dangling(self.ptr) {\n@@ -1345,7 +1345,7 @@ impl<T: ?Sized> Weak<T> {\n         }\n     }\n \n-    /// Returns true if the two `Weak`s point to the same value (not just values\n+    /// Returns `true` if the two `Weak`s point to the same value (not just values\n     /// that compare as equal).\n     ///\n     /// # Notes"}, {"sha": "f4b2d463778a99dede8d43748159c11d12df656a", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -205,10 +205,10 @@ impl<T> [T] {\n     ///\n     /// The comparator function must define a total ordering for the elements in the slice. If\n     /// the ordering is not total, the order of the elements is unspecified. An order is a\n-    /// total order if it is (for all a, b and c):\n+    /// total order if it is (for all `a`, `b` and `c`):\n     ///\n-    /// * total and antisymmetric: exactly one of a < b, a == b or a > b is true; and\n-    /// * transitive, a < b and b < c implies a < c. The same must hold for both == and >.\n+    /// * total and antisymmetric: exactly one of `a < b`, `a == b` or `a > b` is true, and\n+    /// * transitive, `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`.\n     ///\n     /// For example, while [`f64`] doesn't implement [`Ord`] because `NaN != NaN`, we can use\n     /// `partial_cmp` as our sort function when we know the slice doesn't contain a `NaN`.\n@@ -257,6 +257,10 @@ impl<T> [T] {\n     /// This sort is stable (i.e., does not reorder equal elements) and `O(m n log(m n))`\n     /// worst-case, where the key function is `O(m)`.\n     ///\n+    /// For expensive key functions (e.g. functions that are not simple property accesses or\n+    /// basic operations), [`sort_by_cached_key`](#method.sort_by_cached_key) is likely to be\n+    /// significantly faster, as it does not recompute element keys.\n+    ///\n     /// When applicable, unstable sorting is preferred because it is generally faster than stable\n     /// sorting and it doesn't allocate auxiliary memory.\n     /// See [`sort_unstable_by_key`](#method.sort_unstable_by_key).\n@@ -312,15 +316,14 @@ impl<T> [T] {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(slice_sort_by_cached_key)]\n     /// let mut v = [-5i32, 4, 32, -3, 2];\n     ///\n     /// v.sort_by_cached_key(|k| k.to_string());\n     /// assert!(v == [-3, -5, 2, 32, 4]);\n     /// ```\n     ///\n     /// [pdqsort]: https://github.com/orlp/pdqsort\n-    #[unstable(feature = \"slice_sort_by_cached_key\", issue = \"34447\")]\n+    #[stable(feature = \"slice_sort_by_cached_key\", since = \"1.34.0\")]\n     #[inline]\n     pub fn sort_by_cached_key<K, F>(&mut self, f: F)\n         where F: FnMut(&T) -> K, K: Ord"}, {"sha": "a36804bddff32ec16b048e5ae2e2f1d3534071a6", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 1, "deletions": 41, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -29,8 +29,6 @@\n #![allow(unused_imports)]\n \n use core::borrow::Borrow;\n-use core::fmt;\n-use core::str as core_str;\n use core::str::pattern::{Pattern, Searcher, ReverseSearcher, DoubleEndedSearcher};\n use core::mem;\n use core::ptr;\n@@ -443,45 +441,6 @@ impl str {\n         return s;\n     }\n \n-    /// Escapes each char in `s` with [`char::escape_debug`].\n-    ///\n-    /// Note: only extended grapheme codepoints that begin the string will be\n-    /// escaped.\n-    ///\n-    /// [`char::escape_debug`]: primitive.char.html#method.escape_debug\n-    #[unstable(feature = \"str_escape\",\n-               reason = \"return type may change to be an iterator\",\n-               issue = \"27791\")]\n-    pub fn escape_debug(&self) -> String {\n-        let mut string = String::with_capacity(self.len());\n-        let mut chars = self.chars();\n-        if let Some(first) = chars.next() {\n-            string.extend(first.escape_debug_ext(true))\n-        }\n-        string.extend(chars.flat_map(|c| c.escape_debug_ext(false)));\n-        string\n-    }\n-\n-    /// Escapes each char in `s` with [`char::escape_default`].\n-    ///\n-    /// [`char::escape_default`]: primitive.char.html#method.escape_default\n-    #[unstable(feature = \"str_escape\",\n-               reason = \"return type may change to be an iterator\",\n-               issue = \"27791\")]\n-    pub fn escape_default(&self) -> String {\n-        self.chars().flat_map(|c| c.escape_default()).collect()\n-    }\n-\n-    /// Escapes each char in `s` with [`char::escape_unicode`].\n-    ///\n-    /// [`char::escape_unicode`]: primitive.char.html#method.escape_unicode\n-    #[unstable(feature = \"str_escape\",\n-               reason = \"return type may change to be an iterator\",\n-               issue = \"27791\")]\n-    pub fn escape_unicode(&self) -> String {\n-        self.chars().flat_map(|c| c.escape_unicode()).collect()\n-    }\n-\n     /// Converts a [`Box<str>`] into a [`String`] without copying or allocating.\n     ///\n     /// [`String`]: string/struct.String.html\n@@ -612,3 +571,4 @@ impl str {\n pub unsafe fn from_boxed_utf8_unchecked(v: Box<[u8]>) -> Box<str> {\n     Box::from_raw(Box::into_raw(v) as *mut str)\n }\n+"}, {"sha": "84c35c6f1bd2b0b943faa86cbf24d65fe87114e1", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -963,7 +963,7 @@ impl String {\n     /// Does nothing if the capacity is already sufficient.\n     ///\n     /// Note that the allocator may give the collection more space than it\n-    /// requests. Therefore capacity can not be relied upon to be precisely\n+    /// requests. Therefore, capacity can not be relied upon to be precisely\n     /// minimal. Prefer `reserve` if future insertions are expected.\n     ///\n     /// # Errors\n@@ -1377,9 +1377,7 @@ impl String {\n         self.vec.len()\n     }\n \n-    /// Returns `true` if this `String` has a length of zero.\n-    ///\n-    /// Returns `false` otherwise.\n+    /// Returns `true` if this `String` has a length of zero, and `false` otherwise.\n     ///\n     /// # Examples\n     ///"}, {"sha": "b7d7995b540bac75fd23000e8351cd76c66bfd1b", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -560,7 +560,7 @@ impl<T: ?Sized> Arc<T> {\n \n     #[inline]\n     #[stable(feature = \"ptr_eq\", since = \"1.17.0\")]\n-    /// Returns true if the two `Arc`s point to the same value (not\n+    /// Returns `true` if the two `Arc`s point to the same value (not\n     /// just values that compare as equal).\n     ///\n     /// # Examples\n@@ -1191,8 +1191,8 @@ impl<T: ?Sized> Weak<T> {\n         })\n     }\n \n-    /// Return `None` when the pointer is dangling and there is no allocated `ArcInner`,\n-    /// i.e., this `Weak` was created by `Weak::new`\n+    /// Returns `None` when the pointer is dangling and there is no allocated `ArcInner`,\n+    /// (i.e., when this `Weak` was created by `Weak::new`).\n     #[inline]\n     fn inner(&self) -> Option<&ArcInner<T>> {\n         if is_dangling(self.ptr) {\n@@ -1202,7 +1202,7 @@ impl<T: ?Sized> Weak<T> {\n         }\n     }\n \n-    /// Returns true if the two `Weak`s point to the same value (not just values\n+    /// Returns `true` if the two `Weak`s point to the same value (not just values\n     /// that compare as equal).\n     ///\n     /// # Notes"}, {"sha": "2261dabe2779af4b35d35107db0db391023b879d", "filename": "src/liballoc/task.rs", "status": "removed", "additions": 0, "deletions": 130, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/0b9ad6e6fd017837647eed8e5ae824d1f6e278b2/src%2Fliballoc%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9ad6e6fd017837647eed8e5ae824d1f6e278b2/src%2Fliballoc%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftask.rs?ref=0b9ad6e6fd017837647eed8e5ae824d1f6e278b2", "patch": "@@ -1,130 +0,0 @@\n-//! Types and Traits for working with asynchronous tasks.\n-\n-pub use core::task::*;\n-\n-#[cfg(all(target_has_atomic = \"ptr\", target_has_atomic = \"cas\"))]\n-pub use if_arc::*;\n-\n-#[cfg(all(target_has_atomic = \"ptr\", target_has_atomic = \"cas\"))]\n-mod if_arc {\n-    use super::*;\n-    use core::marker::PhantomData;\n-    use core::mem;\n-    use core::ptr::{self, NonNull};\n-    use crate::sync::Arc;\n-\n-    /// A way of waking up a specific task.\n-    ///\n-    /// Any task executor must provide a way of signaling that a task it owns\n-    /// is ready to be `poll`ed again. Executors do so by implementing this trait.\n-    pub trait Wake: Send + Sync {\n-        /// Indicates that the associated task is ready to make progress and should\n-        /// be `poll`ed.\n-        ///\n-        /// Executors generally maintain a queue of \"ready\" tasks; `wake` should place\n-        /// the associated task onto this queue.\n-        fn wake(arc_self: &Arc<Self>);\n-\n-        /// Indicates that the associated task is ready to make progress and should\n-        /// be `poll`ed. This function is like `wake`, but can only be called from the\n-        /// thread on which this `Wake` was created.\n-        ///\n-        /// Executors generally maintain a queue of \"ready\" tasks; `wake_local` should place\n-        /// the associated task onto this queue.\n-        #[inline]\n-        unsafe fn wake_local(arc_self: &Arc<Self>) {\n-            Self::wake(arc_self);\n-        }\n-    }\n-\n-    #[cfg(all(target_has_atomic = \"ptr\", target_has_atomic = \"cas\"))]\n-    struct ArcWrapped<T>(PhantomData<T>);\n-\n-    unsafe impl<T: Wake + 'static> UnsafeWake for ArcWrapped<T> {\n-        #[inline]\n-        unsafe fn clone_raw(&self) -> Waker {\n-            let me: *const ArcWrapped<T> = self;\n-            let arc = (*(&me as *const *const ArcWrapped<T> as *const Arc<T>)).clone();\n-            Waker::from(arc)\n-        }\n-\n-        #[inline]\n-        unsafe fn drop_raw(&self) {\n-            let mut me: *const ArcWrapped<T> = self;\n-            let me = &mut me as *mut *const ArcWrapped<T> as *mut Arc<T>;\n-            ptr::drop_in_place(me);\n-        }\n-\n-        #[inline]\n-        unsafe fn wake(&self) {\n-            let me: *const ArcWrapped<T> = self;\n-            T::wake(&*(&me as *const *const ArcWrapped<T> as *const Arc<T>))\n-        }\n-\n-        #[inline]\n-        unsafe fn wake_local(&self) {\n-            let me: *const ArcWrapped<T> = self;\n-            T::wake_local(&*(&me as *const *const ArcWrapped<T> as *const Arc<T>))\n-        }\n-    }\n-\n-    impl<T> From<Arc<T>> for Waker\n-        where T: Wake + 'static,\n-    {\n-        fn from(rc: Arc<T>) -> Self {\n-            unsafe {\n-                let ptr = mem::transmute::<Arc<T>, NonNull<ArcWrapped<T>>>(rc);\n-                Waker::new(ptr)\n-            }\n-        }\n-    }\n-\n-    /// Creates a `LocalWaker` from a local `wake`.\n-    ///\n-    /// This function requires that `wake` is \"local\" (created on the current thread).\n-    /// The resulting `LocalWaker` will call `wake.wake_local()` when awoken, and\n-    /// will call `wake.wake()` if awoken after being converted to a `Waker`.\n-    #[inline]\n-    pub unsafe fn local_waker<W: Wake + 'static>(wake: Arc<W>) -> LocalWaker {\n-        let ptr = mem::transmute::<Arc<W>, NonNull<ArcWrapped<W>>>(wake);\n-        LocalWaker::new(ptr)\n-    }\n-\n-    struct NonLocalAsLocal<T>(ArcWrapped<T>);\n-\n-    unsafe impl<T: Wake + 'static> UnsafeWake for NonLocalAsLocal<T> {\n-        #[inline]\n-        unsafe fn clone_raw(&self) -> Waker {\n-            self.0.clone_raw()\n-        }\n-\n-        #[inline]\n-        unsafe fn drop_raw(&self) {\n-            self.0.drop_raw()\n-        }\n-\n-        #[inline]\n-        unsafe fn wake(&self) {\n-            self.0.wake()\n-        }\n-\n-        #[inline]\n-        unsafe fn wake_local(&self) {\n-            // Since we're nonlocal, we can't call wake_local\n-            self.0.wake()\n-        }\n-    }\n-\n-    /// Creates a `LocalWaker` from a non-local `wake`.\n-    ///\n-    /// This function is similar to `local_waker`, but does not require that `wake`\n-    /// is local to the current thread. The resulting `LocalWaker` will call\n-    /// `wake.wake()` when awoken.\n-    #[inline]\n-    pub fn local_waker_from_nonlocal<W: Wake + 'static>(wake: Arc<W>) -> LocalWaker {\n-        unsafe {\n-            let ptr = mem::transmute::<Arc<W>, NonNull<NonLocalAsLocal<W>>>(wake);\n-            LocalWaker::new(ptr)\n-        }\n-    }\n-}"}, {"sha": "1d4a3edc1ac42c2d4e05f71df6bc43766ecd666f", "filename": "src/liballoc/tests/binary_heap.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbinary_heap.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -282,6 +282,7 @@ fn assert_covariance() {\n //\n // Destructors must be called exactly once per element.\n #[test]\n+#[cfg(not(miri))] // Miri does not support panics\n fn panic_safe() {\n     static DROP_COUNTER: AtomicUsize = AtomicUsize::new(0);\n "}, {"sha": "f14750089c9560fdf2d6446f30ac355e67d12ef5", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -9,7 +9,10 @@ use super::DeterministicRng;\n #[test]\n fn test_basic_large() {\n     let mut map = BTreeMap::new();\n+    #[cfg(not(miri))] // Miri is too slow\n     let size = 10000;\n+    #[cfg(miri)]\n+    let size = 200;\n     assert_eq!(map.len(), 0);\n \n     for i in 0..size {\n@@ -69,7 +72,10 @@ fn test_basic_small() {\n \n #[test]\n fn test_iter() {\n+    #[cfg(not(miri))] // Miri is too slow\n     let size = 10000;\n+    #[cfg(miri)]\n+    let size = 200;\n \n     // Forwards\n     let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n@@ -91,7 +97,10 @@ fn test_iter() {\n \n #[test]\n fn test_iter_rev() {\n+    #[cfg(not(miri))] // Miri is too slow\n     let size = 10000;\n+    #[cfg(miri)]\n+    let size = 200;\n \n     // Forwards\n     let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n@@ -127,7 +136,10 @@ fn test_values_mut() {\n \n #[test]\n fn test_iter_mixed() {\n+    #[cfg(not(miri))] // Miri is too slow\n     let size = 10000;\n+    #[cfg(miri)]\n+    let size = 200;\n \n     // Forwards\n     let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n@@ -214,42 +226,50 @@ fn test_range_equal_empty_cases() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_range_equal_excluded() {\n     let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n     map.range((Excluded(2), Excluded(2)));\n }\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_range_backwards_1() {\n     let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n     map.range((Included(3), Included(2)));\n }\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_range_backwards_2() {\n     let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n     map.range((Included(3), Excluded(2)));\n }\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_range_backwards_3() {\n     let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n     map.range((Excluded(3), Included(2)));\n }\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_range_backwards_4() {\n     let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n     map.range((Excluded(3), Excluded(2)));\n }\n \n #[test]\n fn test_range_1000() {\n+    #[cfg(not(miri))] // Miri is too slow\n     let size = 1000;\n+    #[cfg(miri)]\n+    let size = 200;\n     let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n     fn test(map: &BTreeMap<u32, u32>, size: u32, min: Bound<&u32>, max: Bound<&u32>) {\n@@ -286,7 +306,10 @@ fn test_range_borrowed_key() {\n \n #[test]\n fn test_range() {\n+    #[cfg(not(miri))] // Miri is too slow\n     let size = 200;\n+    #[cfg(miri)]\n+    let size = 30;\n     let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n     for i in 0..size {\n@@ -305,7 +328,10 @@ fn test_range() {\n \n #[test]\n fn test_range_mut() {\n+    #[cfg(not(miri))] // Miri is too slow\n     let size = 200;\n+    #[cfg(miri)]\n+    let size = 30;\n     let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n     for i in 0..size {\n@@ -479,7 +505,10 @@ fn test_bad_zst() {\n #[test]\n fn test_clone() {\n     let mut map = BTreeMap::new();\n+    #[cfg(not(miri))] // Miri is too slow\n     let size = 100;\n+    #[cfg(miri)]\n+    let size = 30;\n     assert_eq!(map.len(), 0);\n \n     for i in 0..size {\n@@ -631,6 +660,7 @@ create_append_test!(test_append_145, 145);\n create_append_test!(test_append_170, 170);\n create_append_test!(test_append_181, 181);\n create_append_test!(test_append_239, 239);\n+#[cfg(not(miri))] // Miri is too slow\n create_append_test!(test_append_1700, 1700);\n \n fn rand_data(len: usize) -> Vec<(u32, u32)> {"}, {"sha": "c225ebfa96b91d36f127a71656e61970d19d3088", "filename": "src/liballoc/tests/heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Ftests%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Ftests%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fheap.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,6 +1,6 @@\n use std::alloc::{Global, Alloc, Layout, System};\n \n-/// https://github.com/rust-lang/rust/issues/45955\n+/// Issue #45955.\n #[test]\n fn alloc_system_overaligned_request() {\n     check_overalign_requests(System)"}, {"sha": "2361a7db1f7a79e10066a096edf841b961f41278", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -4,8 +4,6 @@\n #![feature(exact_size_is_empty)]\n #![feature(pattern)]\n #![feature(repeat_generic_slice)]\n-#![feature(slice_sort_by_cached_key)]\n-#![feature(str_escape)]\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]\n #![feature(vecdeque_rotate)]"}, {"sha": "feba46b0fad78466af3496fb3ab98bfa9807d68f", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -258,6 +258,7 @@ fn test_swap_remove() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_swap_remove_fail() {\n     let mut v = vec![1];\n     let _ = v.swap_remove(0);\n@@ -389,6 +390,7 @@ fn test_reverse() {\n }\n \n #[test]\n+#[cfg(not(miri))] // Miri does not support entropy\n fn test_sort() {\n     let mut rng = thread_rng();\n \n@@ -465,6 +467,7 @@ fn test_sort() {\n }\n \n #[test]\n+#[cfg(not(miri))] // Miri does not support entropy\n fn test_sort_stability() {\n     for len in (2..25).chain(500..510) {\n         for _ in 0..10 {\n@@ -629,6 +632,7 @@ fn test_insert() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_insert_oob() {\n     let mut a = vec![1, 2, 3];\n     a.insert(4, 5);\n@@ -653,6 +657,7 @@ fn test_remove() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_remove_fail() {\n     let mut a = vec![1];\n     let _ = a.remove(0);\n@@ -934,6 +939,7 @@ fn test_windowsator() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_windowsator_0() {\n     let v = &[1, 2, 3, 4];\n     let _it = v.windows(0);\n@@ -958,6 +964,7 @@ fn test_chunksator() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_chunksator_0() {\n     let v = &[1, 2, 3, 4];\n     let _it = v.chunks(0);\n@@ -982,6 +989,7 @@ fn test_chunks_exactator() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_chunks_exactator_0() {\n     let v = &[1, 2, 3, 4];\n     let _it = v.chunks_exact(0);\n@@ -1006,6 +1014,7 @@ fn test_rchunksator() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_rchunksator_0() {\n     let v = &[1, 2, 3, 4];\n     let _it = v.rchunks(0);\n@@ -1030,6 +1039,7 @@ fn test_rchunks_exactator() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_rchunks_exactator_0() {\n     let v = &[1, 2, 3, 4];\n     let _it = v.rchunks_exact(0);\n@@ -1082,6 +1092,7 @@ fn test_vec_default() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_overflow_does_not_cause_segfault() {\n     let mut v = vec![];\n     v.reserve_exact(!0);\n@@ -1091,6 +1102,7 @@ fn test_overflow_does_not_cause_segfault() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_overflow_does_not_cause_segfault_managed() {\n     let mut v = vec![Rc::new(1)];\n     v.reserve_exact(!0);\n@@ -1266,6 +1278,7 @@ fn test_mut_chunks_rev() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_mut_chunks_0() {\n     let mut v = [1, 2, 3, 4];\n     let _it = v.chunks_mut(0);\n@@ -1298,6 +1311,7 @@ fn test_mut_chunks_exact_rev() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_mut_chunks_exact_0() {\n     let mut v = [1, 2, 3, 4];\n     let _it = v.chunks_exact_mut(0);\n@@ -1330,6 +1344,7 @@ fn test_mut_rchunks_rev() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_mut_rchunks_0() {\n     let mut v = [1, 2, 3, 4];\n     let _it = v.rchunks_mut(0);\n@@ -1362,6 +1377,7 @@ fn test_mut_rchunks_exact_rev() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_mut_rchunks_exact_0() {\n     let mut v = [1, 2, 3, 4];\n     let _it = v.rchunks_exact_mut(0);\n@@ -1395,6 +1411,7 @@ fn test_box_slice_clone() {\n #[test]\n #[allow(unused_must_use)] // here, we care about the side effects of `.clone()`\n #[cfg_attr(target_os = \"emscripten\", ignore)]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_box_slice_clone_panics() {\n     use std::sync::Arc;\n     use std::sync::atomic::{AtomicUsize, Ordering};\n@@ -1459,6 +1476,7 @@ fn test_copy_from_slice() {\n \n #[test]\n #[should_panic(expected = \"destination and source slices have different lengths\")]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_copy_from_slice_dst_longer() {\n     let src = [0, 1, 2, 3];\n     let mut dst = [0; 5];\n@@ -1467,6 +1485,7 @@ fn test_copy_from_slice_dst_longer() {\n \n #[test]\n #[should_panic(expected = \"destination and source slices have different lengths\")]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_copy_from_slice_dst_shorter() {\n     let src = [0, 1, 2, 3];\n     let mut dst = [0; 3];\n@@ -1586,6 +1605,7 @@ thread_local!(static SILENCE_PANIC: Cell<bool> = Cell::new(false));\n \n #[test]\n #[cfg_attr(target_os = \"emscripten\", ignore)] // no threads\n+#[cfg(not(miri))] // Miri does not support panics\n fn panic_safe() {\n     let prev = panic::take_hook();\n     panic::set_hook(Box::new(move |info| {"}, {"sha": "b33a56421888831bf0607d4832f77f92f84d5891", "filename": "src/liballoc/tests/str.rs", "status": "modified", "additions": 49, "deletions": 30, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstr.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -166,6 +166,7 @@ fn test_join_for_different_lengths_with_long_separator() {\n }\n \n #[test]\n+#[cfg(not(miri))] // Miri is too slow\n fn test_unsafe_slice() {\n     assert_eq!(\"ab\", unsafe {\"abc\".get_unchecked(0..2)});\n     assert_eq!(\"bc\", unsafe {\"abc\".get_unchecked(1..3)});\n@@ -350,6 +351,7 @@ mod slice_index {\n     //  to be used in `should_panic`)\n     #[test]\n     #[should_panic(expected = \"out of bounds\")]\n+    #[cfg(not(miri))] // Miri does not support panics\n     fn assert_range_eq_can_fail_by_panic() {\n         assert_range_eq!(\"abc\", 0..5, \"abc\");\n     }\n@@ -359,6 +361,7 @@ mod slice_index {\n     //  to be used in `should_panic`)\n     #[test]\n     #[should_panic(expected = \"==\")]\n+    #[cfg(not(miri))] // Miri does not support panics\n     fn assert_range_eq_can_fail_by_inequality() {\n         assert_range_eq!(\"abc\", 0..2, \"abc\");\n     }\n@@ -406,6 +409,7 @@ mod slice_index {\n \n                 #[test]\n                 #[should_panic(expected = $expect_msg)]\n+                #[cfg(not(miri))] // Miri does not support panics\n                 fn index_fail() {\n                     let v: String = $data.into();\n                     let v: &str = &v;\n@@ -414,6 +418,7 @@ mod slice_index {\n \n                 #[test]\n                 #[should_panic(expected = $expect_msg)]\n+                #[cfg(not(miri))] // Miri does not support panics\n                 fn index_mut_fail() {\n                     let mut v: String = $data.into();\n                     let v: &mut str = &mut v;\n@@ -483,6 +488,7 @@ mod slice_index {\n \n     #[test]\n     #[cfg(not(target_arch = \"asmjs\"))] // hits an OOM\n+    #[cfg(not(miri))] // Miri is too slow\n     fn simple_big() {\n         fn a_million_letter_x() -> String {\n             let mut i = 0;\n@@ -508,6 +514,7 @@ mod slice_index {\n \n     #[test]\n     #[should_panic]\n+    #[cfg(not(miri))] // Miri does not support panics\n     fn test_slice_fail() {\n         &\"\u4e2d\u534eVi\u1ec7t Nam\"[0..2];\n     }\n@@ -659,12 +666,14 @@ mod slice_index {\n     // check the panic includes the prefix of the sliced string\n     #[test]\n     #[should_panic(expected=\"byte index 1024 is out of bounds of `Lorem ipsum dolor sit amet\")]\n+    #[cfg(not(miri))] // Miri does not support panics\n     fn test_slice_fail_truncated_1() {\n         &LOREM_PARAGRAPH[..1024];\n     }\n     // check the truncation in the panic message\n     #[test]\n     #[should_panic(expected=\"luctus, im`[...]\")]\n+    #[cfg(not(miri))] // Miri does not support panics\n     fn test_slice_fail_truncated_2() {\n         &LOREM_PARAGRAPH[..1024];\n     }\n@@ -679,6 +688,7 @@ fn test_str_slice_rangetoinclusive_ok() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_str_slice_rangetoinclusive_notok() {\n     let s = \"abc\u03b1\u03b2\u03b3\";\n     &s[..=3];\n@@ -694,6 +704,7 @@ fn test_str_slicemut_rangetoinclusive_ok() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_str_slicemut_rangetoinclusive_notok() {\n     let mut s = \"abc\u03b1\u03b2\u03b3\".to_owned();\n     let s: &mut str = &mut s;\n@@ -883,6 +894,7 @@ fn test_as_bytes() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_as_bytes_fail() {\n     // Don't double free. (I'm not sure if this exercises the\n     // original problem code path anymore.)\n@@ -972,22 +984,23 @@ fn test_split_at_mut() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_split_at_boundscheck() {\n     let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n     s.split_at(1);\n }\n \n #[test]\n fn test_escape_unicode() {\n-    assert_eq!(\"abc\".escape_unicode(), \"\\\\u{61}\\\\u{62}\\\\u{63}\");\n-    assert_eq!(\"a c\".escape_unicode(), \"\\\\u{61}\\\\u{20}\\\\u{63}\");\n-    assert_eq!(\"\\r\\n\\t\".escape_unicode(), \"\\\\u{d}\\\\u{a}\\\\u{9}\");\n-    assert_eq!(\"'\\\"\\\\\".escape_unicode(), \"\\\\u{27}\\\\u{22}\\\\u{5c}\");\n-    assert_eq!(\"\\x00\\x01\\u{fe}\\u{ff}\".escape_unicode(), \"\\\\u{0}\\\\u{1}\\\\u{fe}\\\\u{ff}\");\n-    assert_eq!(\"\\u{100}\\u{ffff}\".escape_unicode(), \"\\\\u{100}\\\\u{ffff}\");\n-    assert_eq!(\"\\u{10000}\\u{10ffff}\".escape_unicode(), \"\\\\u{10000}\\\\u{10ffff}\");\n-    assert_eq!(\"ab\\u{fb00}\".escape_unicode(), \"\\\\u{61}\\\\u{62}\\\\u{fb00}\");\n-    assert_eq!(\"\\u{1d4ea}\\r\".escape_unicode(), \"\\\\u{1d4ea}\\\\u{d}\");\n+    assert_eq!(\"abc\".escape_unicode().to_string(), \"\\\\u{61}\\\\u{62}\\\\u{63}\");\n+    assert_eq!(\"a c\".escape_unicode().to_string(), \"\\\\u{61}\\\\u{20}\\\\u{63}\");\n+    assert_eq!(\"\\r\\n\\t\".escape_unicode().to_string(), \"\\\\u{d}\\\\u{a}\\\\u{9}\");\n+    assert_eq!(\"'\\\"\\\\\".escape_unicode().to_string(), \"\\\\u{27}\\\\u{22}\\\\u{5c}\");\n+    assert_eq!(\"\\x00\\x01\\u{fe}\\u{ff}\".escape_unicode().to_string(), \"\\\\u{0}\\\\u{1}\\\\u{fe}\\\\u{ff}\");\n+    assert_eq!(\"\\u{100}\\u{ffff}\".escape_unicode().to_string(), \"\\\\u{100}\\\\u{ffff}\");\n+    assert_eq!(\"\\u{10000}\\u{10ffff}\".escape_unicode().to_string(), \"\\\\u{10000}\\\\u{10ffff}\");\n+    assert_eq!(\"ab\\u{fb00}\".escape_unicode().to_string(), \"\\\\u{61}\\\\u{62}\\\\u{fb00}\");\n+    assert_eq!(\"\\u{1d4ea}\\r\".escape_unicode().to_string(), \"\\\\u{1d4ea}\\\\u{d}\");\n }\n \n #[test]\n@@ -998,31 +1011,32 @@ fn test_escape_debug() {\n     // they are escaped. However, when the character is unescaped (e.g., for\n     // printable characters), only a single backslash appears (as the character\n     // itself appears in the debug string).\n-    assert_eq!(\"abc\".escape_debug(), \"abc\");\n-    assert_eq!(\"a c\".escape_debug(), \"a c\");\n-    assert_eq!(\"\u00e9\u00e8\u00ea\".escape_debug(), \"\u00e9\u00e8\u00ea\");\n-    assert_eq!(\"\\r\\n\\t\".escape_debug(), \"\\\\r\\\\n\\\\t\");\n-    assert_eq!(\"'\\\"\\\\\".escape_debug(), \"\\\\'\\\\\\\"\\\\\\\\\");\n-    assert_eq!(\"\\u{7f}\\u{ff}\".escape_debug(), \"\\\\u{7f}\\u{ff}\");\n-    assert_eq!(\"\\u{100}\\u{ffff}\".escape_debug(), \"\\u{100}\\\\u{ffff}\");\n-    assert_eq!(\"\\u{10000}\\u{10ffff}\".escape_debug(), \"\\u{10000}\\\\u{10ffff}\");\n-    assert_eq!(\"ab\\u{200b}\".escape_debug(), \"ab\\\\u{200b}\");\n-    assert_eq!(\"\\u{10d4ea}\\r\".escape_debug(), \"\\\\u{10d4ea}\\\\r\");\n-    assert_eq!(\"\\u{301}a\\u{301}b\u00e9\\u{e000}\".escape_debug(), \"\\\\u{301}a\\u{301}b\u00e9\\\\u{e000}\");\n+    assert_eq!(\"abc\".escape_debug().to_string(), \"abc\");\n+    assert_eq!(\"a c\".escape_debug().to_string(), \"a c\");\n+    assert_eq!(\"\u00e9\u00e8\u00ea\".escape_debug().to_string(), \"\u00e9\u00e8\u00ea\");\n+    assert_eq!(\"\\r\\n\\t\".escape_debug().to_string(), \"\\\\r\\\\n\\\\t\");\n+    assert_eq!(\"'\\\"\\\\\".escape_debug().to_string(), \"\\\\'\\\\\\\"\\\\\\\\\");\n+    assert_eq!(\"\\u{7f}\\u{ff}\".escape_debug().to_string(), \"\\\\u{7f}\\u{ff}\");\n+    assert_eq!(\"\\u{100}\\u{ffff}\".escape_debug().to_string(), \"\\u{100}\\\\u{ffff}\");\n+    assert_eq!(\"\\u{10000}\\u{10ffff}\".escape_debug().to_string(), \"\\u{10000}\\\\u{10ffff}\");\n+    assert_eq!(\"ab\\u{200b}\".escape_debug().to_string(), \"ab\\\\u{200b}\");\n+    assert_eq!(\"\\u{10d4ea}\\r\".escape_debug().to_string(), \"\\\\u{10d4ea}\\\\r\");\n+    assert_eq!(\"\\u{301}a\\u{301}b\u00e9\\u{e000}\".escape_debug().to_string(),\n+               \"\\\\u{301}a\\u{301}b\u00e9\\\\u{e000}\");\n }\n \n #[test]\n fn test_escape_default() {\n-    assert_eq!(\"abc\".escape_default(), \"abc\");\n-    assert_eq!(\"a c\".escape_default(), \"a c\");\n-    assert_eq!(\"\u00e9\u00e8\u00ea\".escape_default(), \"\\\\u{e9}\\\\u{e8}\\\\u{ea}\");\n-    assert_eq!(\"\\r\\n\\t\".escape_default(), \"\\\\r\\\\n\\\\t\");\n-    assert_eq!(\"'\\\"\\\\\".escape_default(), \"\\\\'\\\\\\\"\\\\\\\\\");\n-    assert_eq!(\"\\u{7f}\\u{ff}\".escape_default(), \"\\\\u{7f}\\\\u{ff}\");\n-    assert_eq!(\"\\u{100}\\u{ffff}\".escape_default(), \"\\\\u{100}\\\\u{ffff}\");\n-    assert_eq!(\"\\u{10000}\\u{10ffff}\".escape_default(), \"\\\\u{10000}\\\\u{10ffff}\");\n-    assert_eq!(\"ab\\u{200b}\".escape_default(), \"ab\\\\u{200b}\");\n-    assert_eq!(\"\\u{10d4ea}\\r\".escape_default(), \"\\\\u{10d4ea}\\\\r\");\n+    assert_eq!(\"abc\".escape_default().to_string(), \"abc\");\n+    assert_eq!(\"a c\".escape_default().to_string(), \"a c\");\n+    assert_eq!(\"\u00e9\u00e8\u00ea\".escape_default().to_string(), \"\\\\u{e9}\\\\u{e8}\\\\u{ea}\");\n+    assert_eq!(\"\\r\\n\\t\".escape_default().to_string(), \"\\\\r\\\\n\\\\t\");\n+    assert_eq!(\"'\\\"\\\\\".escape_default().to_string(), \"\\\\'\\\\\\\"\\\\\\\\\");\n+    assert_eq!(\"\\u{7f}\\u{ff}\".escape_default().to_string(), \"\\\\u{7f}\\\\u{ff}\");\n+    assert_eq!(\"\\u{100}\\u{ffff}\".escape_default().to_string(), \"\\\\u{100}\\\\u{ffff}\");\n+    assert_eq!(\"\\u{10000}\\u{10ffff}\".escape_default().to_string(), \"\\\\u{10000}\\\\u{10ffff}\");\n+    assert_eq!(\"ab\\u{200b}\".escape_default().to_string(), \"ab\\\\u{200b}\");\n+    assert_eq!(\"\\u{10d4ea}\\r\".escape_default().to_string(), \"\\\\u{10d4ea}\\\\r\");\n }\n \n #[test]\n@@ -1066,6 +1080,7 @@ fn test_rev_iterator() {\n }\n \n #[test]\n+#[cfg(not(miri))] // Miri is too slow\n fn test_chars_decoding() {\n     let mut bytes = [0; 4];\n     for c in (0..0x110000).filter_map(std::char::from_u32) {\n@@ -1077,6 +1092,7 @@ fn test_chars_decoding() {\n }\n \n #[test]\n+#[cfg(not(miri))] // Miri is too slow\n fn test_chars_rev_decoding() {\n     let mut bytes = [0; 4];\n     for c in (0..0x110000).filter_map(std::char::from_u32) {\n@@ -1365,6 +1381,7 @@ fn test_bool_from_str() {\n     assert_eq!(\"not even a boolean\".parse::<bool>().ok(), None);\n }\n \n+#[cfg(not(miri))] // Miri is too slow\n fn check_contains_all_substrings(s: &str) {\n     assert!(s.contains(\"\"));\n     for i in 0..s.len() {\n@@ -1375,6 +1392,7 @@ fn check_contains_all_substrings(s: &str) {\n }\n \n #[test]\n+#[cfg(not(miri))] // Miri is too slow\n fn strslice_issue_16589() {\n     assert!(\"bananas\".contains(\"nana\"));\n \n@@ -1391,6 +1409,7 @@ fn strslice_issue_16878() {\n \n \n #[test]\n+#[cfg(not(miri))] // Miri is too slow\n fn test_strslice_contains() {\n     let x = \"There are moments, Jeeves, when one asks oneself, 'Do trousers matter?'\";\n     check_contains_all_substrings(x);"}, {"sha": "7e93d84fe3b97b1578dad9e6ebd9eb2324ab83c4", "filename": "src/liballoc/tests/string.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstring.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -231,6 +231,7 @@ fn test_split_off_empty() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_split_off_past_end() {\n     let orig = \"Hello, world!\";\n     let mut split = String::from(orig);\n@@ -239,6 +240,7 @@ fn test_split_off_past_end() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_split_off_mid_char() {\n     let mut orig = String::from(\"\u5c71\");\n     orig.split_off(1);\n@@ -287,6 +289,7 @@ fn test_str_truncate_invalid_len() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_str_truncate_split_codepoint() {\n     let mut s = String::from(\"\\u{FC}\"); // \u00fc\n     s.truncate(1);\n@@ -321,6 +324,7 @@ fn remove() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn remove_bad() {\n     \"\u0e28\".to_string().remove(1);\n }\n@@ -356,11 +360,13 @@ fn insert() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn insert_bad1() {\n     \"\".to_string().insert(1, 't');\n }\n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn insert_bad2() {\n     \"\u1ec7\".to_string().insert(1, 't');\n }\n@@ -441,6 +447,7 @@ fn test_replace_range() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_replace_range_char_boundary() {\n     let mut s = \"Hello, \u4e16\u754c!\".to_owned();\n     s.replace_range(..8, \"\");\n@@ -457,13 +464,15 @@ fn test_replace_range_inclusive_range() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_replace_range_out_of_bounds() {\n     let mut s = String::from(\"12345\");\n     s.replace_range(5..6, \"789\");\n }\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_replace_range_inclusive_out_of_bounds() {\n     let mut s = String::from(\"12345\");\n     s.replace_range(5..=5, \"789\");\n@@ -523,6 +532,7 @@ fn test_reserve_exact() {\n }\n \n #[test]\n+#[cfg(not(miri))] // Miri does not support signalling OOM\n fn test_try_reserve() {\n \n     // These are the interesting cases:\n@@ -600,6 +610,7 @@ fn test_try_reserve() {\n }\n \n #[test]\n+#[cfg(not(miri))] // Miri does not support signalling OOM\n fn test_try_reserve_exact() {\n \n     // This is exactly the same as test_try_reserve with the method changed."}, {"sha": "6e4ca1d90e642dd31bf20bfd5e3efc00c56e0256", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,3 +1,5 @@\n+#![cfg(not(miri))]\n+\n use std::borrow::Cow;\n use std::mem::size_of;\n use std::{usize, isize};\n@@ -366,6 +368,7 @@ fn test_vec_truncate_drop() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_vec_truncate_fail() {\n     struct BadElem(i32);\n     impl Drop for BadElem {\n@@ -389,48 +392,55 @@ fn test_index() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_index_out_of_bounds() {\n     let vec = vec![1, 2, 3];\n     let _ = vec[3];\n }\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_slice_out_of_bounds_1() {\n     let x = vec![1, 2, 3, 4, 5];\n     &x[!0..];\n }\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_slice_out_of_bounds_2() {\n     let x = vec![1, 2, 3, 4, 5];\n     &x[..6];\n }\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_slice_out_of_bounds_3() {\n     let x = vec![1, 2, 3, 4, 5];\n     &x[!0..4];\n }\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_slice_out_of_bounds_4() {\n     let x = vec![1, 2, 3, 4, 5];\n     &x[1..6];\n }\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_slice_out_of_bounds_5() {\n     let x = vec![1, 2, 3, 4, 5];\n     &x[3..2];\n }\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_swap_remove_empty() {\n     let mut vec = Vec::<i32>::new();\n     vec.swap_remove(0);\n@@ -501,6 +511,7 @@ fn test_drain_items_zero_sized() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_drain_out_of_bounds() {\n     let mut v = vec![1, 2, 3, 4, 5];\n     v.drain(5..6);\n@@ -574,6 +585,7 @@ fn test_drain_max_vec_size() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_drain_inclusive_out_of_bounds() {\n     let mut v = vec![1, 2, 3, 4, 5];\n     v.drain(5..=5);\n@@ -603,6 +615,7 @@ fn test_splice_inclusive_range() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_splice_out_of_bounds() {\n     let mut v = vec![1, 2, 3, 4, 5];\n     let a = [10, 11, 12];\n@@ -611,6 +624,7 @@ fn test_splice_out_of_bounds() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_splice_inclusive_out_of_bounds() {\n     let mut v = vec![1, 2, 3, 4, 5];\n     let a = [10, 11, 12];"}, {"sha": "e0cb0e7a9e70c532ccd3f915b5afffa2d1d45514", "filename": "src/liballoc/tests/vec_deque.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec_deque.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -108,6 +108,7 @@ fn test_index() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_index_out_of_bounds() {\n     let mut deq = VecDeque::new();\n     for i in 1..4 {\n@@ -943,7 +944,10 @@ fn test_append_permutations() {\n         out\n     }\n \n+    #[cfg(not(miri))] // Miri is too slow\n     const MAX: usize = 5;\n+    #[cfg(miri)]\n+    const MAX: usize = 3;\n \n     // Many different permutations of both the `VecDeque` getting appended to\n     // and the one getting appended are generated to check `append`.\n@@ -1120,6 +1124,7 @@ fn test_reserve_exact_2() {\n }\n \n #[test]\n+#[cfg(not(miri))] // Miri does not support signalling OOM\n fn test_try_reserve() {\n \n     // These are the interesting cases:\n@@ -1221,6 +1226,7 @@ fn test_try_reserve() {\n }\n \n #[test]\n+#[cfg(not(miri))] // Miri does not support signalling OOM\n fn test_try_reserve_exact() {\n \n     // This is exactly the same as test_try_reserve with the method changed."}, {"sha": "57723e4d2128182001b917c90a7ba81b39bd2710", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -463,7 +463,7 @@ impl<T> Vec<T> {\n     /// Does nothing if the capacity is already sufficient.\n     ///\n     /// Note that the allocator may give the collection more space than it\n-    /// requests. Therefore capacity can not be relied upon to be precisely\n+    /// requests. Therefore, capacity can not be relied upon to be precisely\n     /// minimal. Prefer `reserve` if future insertions are expected.\n     ///\n     /// # Panics\n@@ -525,7 +525,7 @@ impl<T> Vec<T> {\n     /// Does nothing if the capacity is already sufficient.\n     ///\n     /// Note that the allocator may give the collection more space than it\n-    /// requests. Therefore capacity can not be relied upon to be precisely\n+    /// requests. Therefore, capacity can not be relied upon to be precisely\n     /// minimal. Prefer `reserve` if future insertions are expected.\n     ///\n     /// # Errors\n@@ -738,7 +738,7 @@ impl<T> Vec<T> {\n     /// Forces the length of the vector to `new_len`.\n     ///\n     /// This is a low-level operation that maintains none of the normal\n-    /// invariants of the type.  Normally changing the length of a vector\n+    /// invariants of the type. Normally changing the length of a vector\n     /// is done using one of the safe operations instead, such as\n     /// [`truncate`], [`resize`], [`extend`], or [`clear`].\n     ///\n@@ -2608,7 +2608,7 @@ impl<T> Drain<'_, T> {\n     /// The range from `self.vec.len` to `self.tail_start` contains elements\n     /// that have been moved out.\n     /// Fill that range as much as possible with new elements from the `replace_with` iterator.\n-    /// Return whether we filled the entire range. (`replace_with.next()` didn\u2019t return `None`.)\n+    /// Returns `true` if we filled the entire range. (`replace_with.next()` didn\u2019t return `None`.)\n     unsafe fn fill<I: Iterator<Item=T>>(&mut self, replace_with: &mut I) -> bool {\n         let vec = self.vec.as_mut();\n         let range_start = vec.len;\n@@ -2628,7 +2628,7 @@ impl<T> Drain<'_, T> {\n         true\n     }\n \n-    /// Make room for inserting more elements before the tail.\n+    /// Makes room for inserting more elements before the tail.\n     unsafe fn move_tail(&mut self, extra_capacity: usize) {\n         let vec = self.vec.as_mut();\n         let used_capacity = self.tail_start + self.tail_len;"}, {"sha": "82fc64ba64e331645d075fbd879a6696e04cf523", "filename": "src/libarena/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibarena%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibarena%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2FCargo.toml?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -2,11 +2,12 @@\n authors = [\"The Rust Project Developers\"]\n name = \"arena\"\n version = \"0.0.0\"\n+edition = \"2018\"\n \n [lib]\n name = \"arena\"\n path = \"lib.rs\"\n crate-type = [\"dylib\"]\n \n [dependencies]\n-rustc_data_structures = { path = \"../librustc_data_structures\" }\n\\ No newline at end of file\n+rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "8ae046c0796bc53e8f57eaa413af43a7e1bad17e", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -8,22 +8,20 @@\n //! This crate implements `TypedArena`, a simple arena that can only hold\n //! objects of a single type.\n \n-#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-       html_root_url = \"https://doc.rust-lang.org/nightly/\",\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        test(no_crate_inject, attr(deny(warnings))))]\n \n+#![deny(rust_2018_idioms)]\n+\n #![feature(alloc)]\n #![feature(core_intrinsics)]\n #![feature(dropck_eyepatch)]\n-#![feature(nll)]\n #![feature(raw_vec_internals)]\n #![cfg_attr(test, feature(test))]\n \n #![allow(deprecated)]\n \n extern crate alloc;\n-extern crate rustc_data_structures;\n \n use rustc_data_structures::sync::MTLock;\n \n@@ -478,7 +476,7 @@ impl SyncDroplessArena {\n #[cfg(test)]\n mod tests {\n     extern crate test;\n-    use self::test::Bencher;\n+    use test::Bencher;\n     use super::TypedArena;\n     use std::cell::Cell;\n \n@@ -513,15 +511,15 @@ mod tests {\n \n         impl<'a> Wrap<'a> {\n             fn alloc_inner<F: Fn() -> Inner>(&self, f: F) -> &Inner {\n-                let r: &EI = self.0.alloc(EI::I(f()));\n+                let r: &EI<'_> = self.0.alloc(EI::I(f()));\n                 if let &EI::I(ref i) = r {\n                     i\n                 } else {\n                     panic!(\"mismatch\");\n                 }\n             }\n-            fn alloc_outer<F: Fn() -> Outer<'a>>(&self, f: F) -> &Outer {\n-                let r: &EI = self.0.alloc(EI::O(f()));\n+            fn alloc_outer<F: Fn() -> Outer<'a>>(&self, f: F) -> &Outer<'_> {\n+                let r: &EI<'_> = self.0.alloc(EI::O(f()));\n                 if let &EI::O(ref o) = r {\n                     o\n                 } else {\n@@ -611,7 +609,7 @@ mod tests {\n         count: &'a Cell<u32>,\n     }\n \n-    impl<'a> Drop for DropCounter<'a> {\n+    impl Drop for DropCounter<'_> {\n         fn drop(&mut self) {\n             self.count.set(self.count.get() + 1);\n         }\n@@ -621,7 +619,7 @@ mod tests {\n     fn test_typed_arena_drop_count() {\n         let counter = Cell::new(0);\n         {\n-            let arena: TypedArena<DropCounter> = TypedArena::default();\n+            let arena: TypedArena<DropCounter<'_>> = TypedArena::default();\n             for _ in 0..100 {\n                 // Allocate something with drop glue to make sure it doesn't leak.\n                 arena.alloc(DropCounter { count: &counter });\n@@ -633,7 +631,7 @@ mod tests {\n     #[test]\n     fn test_typed_arena_drop_on_clear() {\n         let counter = Cell::new(0);\n-        let mut arena: TypedArena<DropCounter> = TypedArena::default();\n+        let mut arena: TypedArena<DropCounter<'_>> = TypedArena::default();\n         for i in 0..10 {\n             for _ in 0..100 {\n                 // Allocate something with drop glue to make sure it doesn't leak."}, {"sha": "f49e226a5cb68ed04b5064008cb102f41982ca5c", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -425,7 +425,7 @@ impl fmt::Display for CannotReallocInPlace {\n /// The `GlobalAlloc` trait is an `unsafe` trait for a number of reasons, and\n /// implementors must ensure that they adhere to these contracts:\n ///\n-/// * It's undefined behavior if global allocators unwind.  This restriction may\n+/// * It's undefined behavior if global allocators unwind. This restriction may\n ///   be lifted in the future, but currently a panic from any of these\n ///   functions may lead to memory unsafety.\n ///"}, {"sha": "01ab523a4c3f6ce8bd3c825d2b7c2e735034419b", "filename": "src/libcore/any.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -18,7 +18,7 @@\n //!\n //! Consider a situation where we want to log out a value passed to a function.\n //! We know the value we're working on implements Debug, but we don't know its\n-//! concrete type.  We want to give special treatment to certain types: in this\n+//! concrete type. We want to give special treatment to certain types: in this\n //! case printing out the length of String values prior to their value.\n //! We don't know the concrete type of our value at compile time, so we need to\n //! use runtime reflection instead.\n@@ -31,8 +31,8 @@\n //! fn log<T: Any + Debug>(value: &T) {\n //!     let value_any = value as &dyn Any;\n //!\n-//!     // try to convert our value to a String.  If successful, we want to\n-//!     // output the String's length as well as its value.  If not, it's a\n+//!     // Try to convert our value to a `String`. If successful, we want to\n+//!     // output the String`'s length as well as its value. If not, it's a\n //!     // different type: just print it out unadorned.\n //!     match value_any.downcast_ref::<String>() {\n //!         Some(as_string) => {"}, {"sha": "8383d305518ab39e7ea822ab67ef3715358c7213", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -130,7 +130,7 @@\n //!\n //! This is simply a special - but common - case of the previous: hiding mutability for operations\n //! that appear to be immutable. The `clone` method is expected to not change the source value, and\n-//! is declared to take `&self`, not `&mut self`. Therefore any mutation that happens in the\n+//! is declared to take `&self`, not `&mut self`. Therefore, any mutation that happens in the\n //! `clone` method must use cell types. For example, `Rc<T>` maintains its reference counts within a\n //! `Cell<T>`.\n //!\n@@ -1133,7 +1133,7 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n     /// The `RefCell` is already immutably borrowed, so this cannot fail.\n     ///\n     /// This is an associated function that needs to be used as\n-    /// `Ref::clone(...)`.  A `Clone` implementation or a method would interfere\n+    /// `Ref::clone(...)`. A `Clone` implementation or a method would interfere\n     /// with the widespread use of `r.borrow().clone()` to clone the contents of\n     /// a `RefCell`.\n     #[stable(feature = \"cell_extras\", since = \"1.15.0\")]\n@@ -1145,7 +1145,7 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n         }\n     }\n \n-    /// Make a new `Ref` for a component of the borrowed data.\n+    /// Makes a new `Ref` for a component of the borrowed data.\n     ///\n     /// The `RefCell` is already immutably borrowed, so this cannot fail.\n     ///\n@@ -1174,7 +1174,7 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n         }\n     }\n \n-    /// Split a `Ref` into multiple `Ref`s for different components of the\n+    /// Splits a `Ref` into multiple `Ref`s for different components of the\n     /// borrowed data.\n     ///\n     /// The `RefCell` is already immutably borrowed, so this cannot fail.\n@@ -1217,13 +1217,13 @@ impl<T: ?Sized + fmt::Display> fmt::Display for Ref<'_, T> {\n }\n \n impl<'b, T: ?Sized> RefMut<'b, T> {\n-    /// Make a new `RefMut` for a component of the borrowed data, e.g., an enum\n+    /// Makes a new `RefMut` for a component of the borrowed data, e.g., an enum\n     /// variant.\n     ///\n     /// The `RefCell` is already mutably borrowed, so this cannot fail.\n     ///\n     /// This is an associated function that needs to be used as\n-    /// `RefMut::map(...)`.  A method would interfere with methods of the same\n+    /// `RefMut::map(...)`. A method would interfere with methods of the same\n     /// name on the contents of a `RefCell` used through `Deref`.\n     ///\n     /// # Examples\n@@ -1253,7 +1253,7 @@ impl<'b, T: ?Sized> RefMut<'b, T> {\n         }\n     }\n \n-    /// Split a `RefMut` into multiple `RefMut`s for different components of the\n+    /// Splits a `RefMut` into multiple `RefMut`s for different components of the\n     /// borrowed data.\n     ///\n     /// The underlying `RefCell` will remain mutably borrowed until both\n@@ -1416,7 +1416,7 @@ impl<T: ?Sized + fmt::Display> fmt::Display for RefMut<'_, T> {\n /// co-exist with it. A `&mut T` must always be unique.\n ///\n /// Note that while mutating or mutably aliasing the contents of an `&UnsafeCell<T>` is\n-/// okay (provided you enforce the invariants some other way), it is still undefined behavior\n+/// ok (provided you enforce the invariants some other way), it is still undefined behavior\n /// to have multiple `&mut UnsafeCell<T>` aliases.\n ///\n /// # Examples"}, {"sha": "133c9169df858c050e3bf536cb8b988c82dfd030", "filename": "src/libcore/char/decode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fchar%2Fdecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fchar%2Fdecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fdecode.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -20,7 +20,7 @@ pub struct DecodeUtf16Error {\n     code: u16,\n }\n \n-/// Create an iterator over the UTF-16 encoded code points in `iter`,\n+/// Creates an iterator over the UTF-16 encoded code points in `iter`,\n /// returning unpaired surrogates as `Err`s.\n ///\n /// # Examples"}, {"sha": "122e5f3affdc2455cdd61db2dae60c9912ae339a", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -189,10 +189,8 @@ impl char {\n     /// An extended version of `escape_debug` that optionally permits escaping\n     /// Extended Grapheme codepoints. This allows us to format characters like\n     /// nonspacing marks better when they're at the start of a string.\n-    #[doc(hidden)]\n-    #[unstable(feature = \"str_internals\", issue = \"0\")]\n     #[inline]\n-    pub fn escape_debug_ext(self, escape_grapheme_extended: bool) -> EscapeDebug {\n+    pub(crate) fn escape_debug_ext(self, escape_grapheme_extended: bool) -> EscapeDebug {\n         let init_state = match self {\n             '\\t' => EscapeDefaultState::Backslash('t'),\n             '\\r' => EscapeDefaultState::Backslash('r'),\n@@ -524,7 +522,7 @@ impl char {\n         }\n     }\n \n-    /// Returns true if this `char` is an alphabetic code point, and false if not.\n+    /// Returns `true` if this `char` is an alphabetic code point, and false if not.\n     ///\n     /// # Examples\n     ///\n@@ -548,7 +546,7 @@ impl char {\n         }\n     }\n \n-    /// Returns true if this `char` satisfies the 'XID_Start' Unicode property, and false\n+    /// Returns `true` if this `char` satisfies the 'XID_Start' Unicode property, and false\n     /// otherwise.\n     ///\n     /// 'XID_Start' is a Unicode Derived Property specified in\n@@ -562,7 +560,7 @@ impl char {\n         derived_property::XID_Start(self)\n     }\n \n-    /// Returns true if this `char` satisfies the 'XID_Continue' Unicode property, and false\n+    /// Returns `true` if this `char` satisfies the 'XID_Continue' Unicode property, and false\n     /// otherwise.\n     ///\n     /// 'XID_Continue' is a Unicode Derived Property specified in\n@@ -576,7 +574,7 @@ impl char {\n         derived_property::XID_Continue(self)\n     }\n \n-    /// Returns true if this `char` is lowercase, and false otherwise.\n+    /// Returns `true` if this `char` is lowercase.\n     ///\n     /// 'Lowercase' is defined according to the terms of the Unicode Derived Core\n     /// Property `Lowercase`.\n@@ -604,7 +602,7 @@ impl char {\n         }\n     }\n \n-    /// Returns true if this `char` is uppercase, and false otherwise.\n+    /// Returns `true` if this `char` is uppercase.\n     ///\n     /// 'Uppercase' is defined according to the terms of the Unicode Derived Core\n     /// Property `Uppercase`.\n@@ -632,7 +630,7 @@ impl char {\n         }\n     }\n \n-    /// Returns true if this `char` is whitespace, and false otherwise.\n+    /// Returns `true` if this `char` is whitespace.\n     ///\n     /// 'Whitespace' is defined according to the terms of the Unicode Derived Core\n     /// Property `White_Space`.\n@@ -659,7 +657,7 @@ impl char {\n         }\n     }\n \n-    /// Returns true if this `char` is alphanumeric, and false otherwise.\n+    /// Returns `true` if this `char` is alphanumeric.\n     ///\n     /// 'Alphanumeric'-ness is defined in terms of the Unicode General Categories\n     /// 'Nd', 'Nl', 'No' and the Derived Core Property 'Alphabetic'.\n@@ -684,7 +682,7 @@ impl char {\n         self.is_alphabetic() || self.is_numeric()\n     }\n \n-    /// Returns true if this `char` is a control code point, and false otherwise.\n+    /// Returns `true` if this `char` is a control code point.\n     ///\n     /// 'Control code point' is defined in terms of the Unicode General\n     /// Category `Cc`.\n@@ -704,7 +702,7 @@ impl char {\n         general_category::Cc(self)\n     }\n \n-    /// Returns true if this `char` is an extended grapheme character, and false otherwise.\n+    /// Returns `true` if this `char` is an extended grapheme character.\n     ///\n     /// 'Extended grapheme character' is defined in terms of the Unicode Shaping and Rendering\n     /// Category `Grapheme_Extend`.\n@@ -713,7 +711,7 @@ impl char {\n         derived_property::Grapheme_Extend(self)\n     }\n \n-    /// Returns true if this `char` is numeric, and false otherwise.\n+    /// Returns `true` if this `char` is numeric.\n     ///\n     /// 'Numeric'-ness is defined in terms of the Unicode General Categories\n     /// 'Nd', 'Nl', 'No'."}, {"sha": "81fcdeee12d29e96614069f3b52e9ae79c2b8790", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -26,7 +26,7 @@ use self::Ordering::*;\n /// relations](http://en.wikipedia.org/wiki/Partial_equivalence_relation).\n ///\n /// This trait allows for partial equality, for types that do not have a full\n-/// equivalence relation.  For example, in floating point numbers `NaN != NaN`,\n+/// equivalence relation. For example, in floating point numbers `NaN != NaN`,\n /// so floating point types implement `PartialEq` but not `Eq`.\n ///\n /// Formally, the equality must be (for all `a`, `b` and `c`):"}, {"sha": "b8d751cfbb6df24f06b8d5e8dd0ed9fb33210436", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -17,7 +17,10 @@\n //! [`TryFrom<T>`][`TryFrom`] rather than [`Into<U>`][`Into`] or [`TryInto<U>`][`TryInto`],\n //! as [`From`] and [`TryFrom`] provide greater flexibility and offer\n //! equivalent [`Into`] or [`TryInto`] implementations for free, thanks to a\n-//! blanket implementation in the standard library.\n+//! blanket implementation in the standard library.  However, there are some cases\n+//! where this is not possible, such as creating conversions into a type defined\n+//! outside your library, so implementing [`Into`] instead of [`From`] is\n+//! sometimes necessary.\n //!\n //! # Generic Implementations\n //!\n@@ -113,9 +116,6 @@ pub const fn identity<T>(x: T) -> T { x }\n /// - Use `Borrow` when the goal is related to writing code that is agnostic to\n ///   the type of borrow and whether it is a reference or value\n ///\n-/// See [the book][book] for a more detailed comparison.\n-///\n-/// [book]: ../../book/first-edition/borrow-and-asref.html\n /// [`Borrow`]: ../../std/borrow/trait.Borrow.html\n ///\n /// **Note: this trait must not fail**. If the conversion can fail, use a\n@@ -217,7 +217,7 @@ pub trait AsMut<T: ?Sized> {\n ///\n /// There is one exception to implementing `Into`, and it's kind of esoteric.\n /// If the destination type is not part of the current crate, and it uses a\n-/// generic variable, then you can't implement `From` directly.  For example,\n+/// generic variable, then you can't implement `From` directly. For example,\n /// take this crate:\n ///\n /// ```compile_fail\n@@ -348,7 +348,7 @@ pub trait Into<T>: Sized {\n /// [`String`]: ../../std/string/struct.String.html\n /// [`Into<U>`]: trait.Into.html\n /// [`from`]: trait.From.html#tymethod.from\n-/// [book]: ../../book/first-edition/error-handling.html\n+/// [book]: ../../book/ch09-00-error-handling.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait From<T>: Sized {\n     /// Performs the conversion."}, {"sha": "5ad05b3824764f5ba3038c638357c988ce44a89b", "filename": "src/libcore/default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdefault.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -54,7 +54,7 @@\n ///\n /// ## How can I implement `Default`?\n ///\n-/// Provide an implementation for the `default()` method that returns the value of\n+/// Provides an implementation for the `default()` method that returns the value of\n /// your type that should be the default:\n ///\n /// ```"}, {"sha": "d88793f2801e72abdf5449d8f8cf19b5ae66fa2c", "filename": "src/libcore/ffi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fffi.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -184,7 +184,7 @@ impl<'a> VaList<'a> {\n         va_arg(self)\n     }\n \n-    /// Copy the `va_list` at the current location.\n+    /// Copies the `va_list` at the current location.\n     #[unstable(feature = \"c_variadic\",\n                reason = \"the `c_variadic` feature has not been properly tested on \\\n                          all supported platforms\",\n@@ -213,7 +213,7 @@ extern \"rust-intrinsic\" {\n     /// `va_copy`.\n     fn va_end(ap: &mut VaList);\n \n-    /// Copy the current location of arglist `src` to the arglist `dst`.\n+    /// Copies the current location of arglist `src` to the arglist `dst`.\n     #[cfg(any(all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"),\n                   not(target_arch = \"x86_64\")),\n               windows))]"}, {"sha": "7efb7f31298bf194fea3657d7555519e26a04a46", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 64, "deletions": 41, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -483,12 +483,12 @@ impl Display for Arguments<'_> {\n /// implementations, such as [`debug_struct`][debug_struct].\n ///\n /// `Debug` implementations using either `derive` or the debug builder API\n-/// on [`Formatter`] support pretty printing using the alternate flag: `{:#?}`.\n+/// on [`Formatter`] support pretty-printing using the alternate flag: `{:#?}`.\n ///\n /// [debug_struct]: ../../std/fmt/struct.Formatter.html#method.debug_struct\n /// [`Formatter`]: ../../std/fmt/struct.Formatter.html\n ///\n-/// Pretty printing with `#?`:\n+/// Pretty-printing with `#?`:\n ///\n /// ```\n /// #[derive(Debug)]\n@@ -1036,6 +1036,27 @@ pub fn write(output: &mut dyn Write, args: Arguments) -> Result {\n     Ok(())\n }\n \n+/// Padding after the end of something. Returned by `Formatter::padding`.\n+#[must_use = \"don't forget to write the post padding\"]\n+struct PostPadding {\n+    fill: char,\n+    padding: usize,\n+}\n+\n+impl PostPadding {\n+    fn new(fill: char, padding: usize) -> PostPadding {\n+        PostPadding { fill, padding }\n+    }\n+\n+    /// Write this post padding.\n+    fn write(self, buf: &mut dyn Write) -> Result {\n+        for _ in 0..self.padding {\n+            buf.write_char(self.fill)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n impl<'a> Formatter<'a> {\n     fn wrap_buf<'b, 'c, F>(&'b mut self, wrap: F) -> Formatter<'c>\n         where 'b: 'c, F: FnOnce(&'b mut (dyn Write+'b)) -> &'c mut (dyn Write+'c)\n@@ -1153,47 +1174,56 @@ impl<'a> Formatter<'a> {\n             sign = Some('+'); width += 1;\n         }\n \n-        let prefixed = self.alternate();\n-        if prefixed {\n+        let prefix = if self.alternate() {\n             width += prefix.chars().count();\n-        }\n+            Some(prefix)\n+        } else {\n+            None\n+        };\n \n         // Writes the sign if it exists, and then the prefix if it was requested\n-        let write_prefix = |f: &mut Formatter| {\n+        #[inline(never)]\n+        fn write_prefix(f: &mut Formatter, sign: Option<char>, prefix: Option<&str>) -> Result {\n             if let Some(c) = sign {\n                 f.buf.write_char(c)?;\n             }\n-            if prefixed { f.buf.write_str(prefix) }\n-            else { Ok(()) }\n-        };\n+            if let Some(prefix) = prefix {\n+                f.buf.write_str(prefix)\n+            } else {\n+                Ok(())\n+            }\n+        }\n \n         // The `width` field is more of a `min-width` parameter at this point.\n         match self.width {\n             // If there's no minimum length requirements then we can just\n             // write the bytes.\n             None => {\n-                write_prefix(self)?; self.buf.write_str(buf)\n+                write_prefix(self, sign, prefix)?;\n+                self.buf.write_str(buf)\n             }\n             // Check if we're over the minimum width, if so then we can also\n             // just write the bytes.\n             Some(min) if width >= min => {\n-                write_prefix(self)?; self.buf.write_str(buf)\n+                write_prefix(self, sign, prefix)?;\n+                self.buf.write_str(buf)\n             }\n             // The sign and prefix goes before the padding if the fill character\n             // is zero\n             Some(min) if self.sign_aware_zero_pad() => {\n                 self.fill = '0';\n                 self.align = rt::v1::Alignment::Right;\n-                write_prefix(self)?;\n-                self.with_padding(min - width, rt::v1::Alignment::Right, |f| {\n-                    f.buf.write_str(buf)\n-                })\n+                write_prefix(self, sign, prefix)?;\n+                let post_padding = self.padding(min - width, rt::v1::Alignment::Right)?;\n+                self.buf.write_str(buf)?;\n+                post_padding.write(self.buf)\n             }\n             // Otherwise, the sign and prefix goes after the padding\n             Some(min) => {\n-                self.with_padding(min - width, rt::v1::Alignment::Right, |f| {\n-                    write_prefix(f)?; f.buf.write_str(buf)\n-                })\n+                let post_padding = self.padding(min - width, rt::v1::Alignment::Right)?;\n+                write_prefix(self, sign, prefix)?;\n+                self.buf.write_str(buf)?;\n+                post_padding.write(self.buf)\n             }\n         }\n     }\n@@ -1264,19 +1294,21 @@ impl<'a> Formatter<'a> {\n             // up the minimum width with the specified string + some alignment.\n             Some(width) => {\n                 let align = rt::v1::Alignment::Left;\n-                self.with_padding(width - s.chars().count(), align, |me| {\n-                    me.buf.write_str(s)\n-                })\n+                let post_padding = self.padding(width - s.chars().count(), align)?;\n+                self.buf.write_str(s)?;\n+                post_padding.write(self.buf)\n             }\n         }\n     }\n \n-    /// Runs a callback, emitting the correct padding either before or\n-    /// afterwards depending on whether right or left alignment is requested.\n-    fn with_padding<F>(&mut self, padding: usize, default: rt::v1::Alignment,\n-                       f: F) -> Result\n-        where F: FnOnce(&mut Formatter) -> Result,\n-    {\n+    /// Write the pre-padding and return the unwritten post-padding. Callers are\n+    /// responsible for ensuring post-padding is written after the thing that is\n+    /// being padded.\n+    fn padding(\n+        &mut self,\n+        padding: usize,\n+        default: rt::v1::Alignment\n+    ) -> result::Result<PostPadding, Error> {\n         let align = match self.align {\n             rt::v1::Alignment::Unknown => default,\n             _ => self.align\n@@ -1289,20 +1321,11 @@ impl<'a> Formatter<'a> {\n             rt::v1::Alignment::Center => (padding / 2, (padding + 1) / 2),\n         };\n \n-        let mut fill = [0; 4];\n-        let fill = self.fill.encode_utf8(&mut fill);\n-\n         for _ in 0..pre_pad {\n-            self.buf.write_str(fill)?;\n-        }\n-\n-        f(self)?;\n-\n-        for _ in 0..post_pad {\n-            self.buf.write_str(fill)?;\n+            self.buf.write_char(self.fill)?;\n         }\n \n-        Ok(())\n+        Ok(PostPadding::new(self.fill, post_pad))\n     }\n \n     /// Takes the formatted parts and applies the padding.\n@@ -1334,9 +1357,9 @@ impl<'a> Formatter<'a> {\n             let ret = if width <= len { // no padding\n                 self.write_formatted_parts(&formatted)\n             } else {\n-                self.with_padding(width - len, align, |f| {\n-                    f.write_formatted_parts(&formatted)\n-                })\n+                let post_padding = self.padding(width - len, align)?;\n+                self.write_formatted_parts(&formatted)?;\n+                post_padding.write(self.buf)\n             };\n             self.fill = old_fill;\n             self.align = old_align;"}, {"sha": "b9fa3640371082148624f625ad1e0eabbea9faa7", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 52, "deletions": 35, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -178,45 +178,36 @@ integer! { i32, u32 }\n integer! { i64, u64 }\n integer! { i128, u128 }\n \n-const DEC_DIGITS_LUT: &'static[u8] =\n+\n+static DEC_DIGITS_LUT: &[u8; 200] =\n     b\"0001020304050607080910111213141516171819\\\n       2021222324252627282930313233343536373839\\\n       4041424344454647484950515253545556575859\\\n       6061626364656667686970717273747576777879\\\n       8081828384858687888990919293949596979899\";\n \n macro_rules! impl_Display {\n-    ($($t:ident),*: $conv_fn:ident) => ($(\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl fmt::Display for $t {\n-        #[allow(unused_comparisons)]\n-        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-            let is_nonnegative = *self >= 0;\n-            let mut n = if is_nonnegative {\n-                self.$conv_fn()\n-            } else {\n-                // convert the negative num to positive by summing 1 to it's 2 complement\n-                (!self.$conv_fn()).wrapping_add(1)\n-            };\n+    ($($t:ident),* as $u:ident via $conv_fn:ident named $name:ident) => {\n+        fn $name(mut n: $u, is_nonnegative: bool, f: &mut fmt::Formatter) -> fmt::Result {\n             let mut buf = uninitialized_array![u8; 39];\n             let mut curr = buf.len() as isize;\n             let buf_ptr = MaybeUninit::first_ptr_mut(&mut buf);\n             let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n \n             unsafe {\n                 // need at least 16 bits for the 4-characters-at-a-time to work.\n-                if ::mem::size_of::<$t>() >= 2 {\n-                    // eagerly decode 4 characters at a time\n-                    while n >= 10000 {\n-                        let rem = (n % 10000) as isize;\n-                        n /= 10000;\n-\n-                        let d1 = (rem / 100) << 1;\n-                        let d2 = (rem % 100) << 1;\n-                        curr -= 4;\n-                        ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n-                        ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);\n-                    }\n+                assert!(::mem::size_of::<$u>() >= 2);\n+\n+                // eagerly decode 4 characters at a time\n+                while n >= 10000 {\n+                    let rem = (n % 10000) as isize;\n+                    n /= 10000;\n+\n+                    let d1 = (rem / 100) << 1;\n+                    let d2 = (rem % 100) << 1;\n+                    curr -= 4;\n+                    ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n+                    ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);\n                 }\n \n                 // if we reach here numbers are <= 9999, so at most 4 chars long\n@@ -247,15 +238,41 @@ macro_rules! impl_Display {\n             };\n             f.pad_integral(is_nonnegative, \"\", buf_slice)\n         }\n-    })*);\n+\n+        $(\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            impl fmt::Display for $t {\n+                #[allow(unused_comparisons)]\n+                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                    let is_nonnegative = *self >= 0;\n+                    let n = if is_nonnegative {\n+                        self.$conv_fn()\n+                    } else {\n+                        // convert the negative num to positive by summing 1 to it's 2 complement\n+                        (!self.$conv_fn()).wrapping_add(1)\n+                    };\n+                    $name(n, is_nonnegative, f)\n+                }\n+            })*\n+    };\n+}\n+\n+// Include wasm32 in here since it doesn't reflect the native pointer size, and\n+// often cares strongly about getting a smaller code size.\n+#[cfg(any(target_pointer_width = \"64\", target_arch = \"wasm32\"))]\n+mod imp {\n+    use super::*;\n+    impl_Display!(\n+        i8, u8, i16, u16, i32, u32, i64, u64, usize, isize\n+            as u64 via to_u64 named fmt_u64\n+    );\n+}\n+\n+#[cfg(not(any(target_pointer_width = \"64\", target_arch = \"wasm32\")))]\n+mod imp {\n+    use super::*;\n+    impl_Display!(i8, u8, i16, u16, i32, u32, isize, usize as u32 via to_u32 named fmt_u32);\n+    impl_Display!(i64, u64 as u64 via to_u64 named fmt_u64);\n }\n \n-impl_Display!(i8, u8, i16, u16, i32, u32: to_u32);\n-impl_Display!(i64, u64: to_u64);\n-impl_Display!(i128, u128: to_u128);\n-#[cfg(target_pointer_width = \"16\")]\n-impl_Display!(isize, usize: to_u16);\n-#[cfg(target_pointer_width = \"32\")]\n-impl_Display!(isize, usize: to_u32);\n-#[cfg(target_pointer_width = \"64\")]\n-impl_Display!(isize, usize: to_u64);\n+impl_Display!(i128, u128 as u128 via to_u128 named fmt_u128);"}, {"sha": "02457e00054c8eb0f19f8d95a1d9a2300f53f942", "filename": "src/libcore/future/future.rs", "status": "modified", "additions": 21, "deletions": 29, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Ffuture%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Ffuture%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Ffuture.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -5,7 +5,7 @@\n use marker::Unpin;\n use ops;\n use pin::Pin;\n-use task::{Poll, LocalWaker};\n+use task::{Poll, Waker};\n \n /// A future represents an asynchronous computation.\n ///\n@@ -19,13 +19,14 @@ use task::{Poll, LocalWaker};\n /// final value. This method does not block if the value is not ready. Instead,\n /// the current task is scheduled to be woken up when it's possible to make\n /// further progress by `poll`ing again. The wake up is performed using\n-/// `cx.waker()`, a handle for waking up the current task.\n+/// the `waker` argument of the `poll()` method, which is a handle for waking\n+/// up the current task.\n ///\n /// When using a future, you generally won't call `poll` directly, but instead\n /// `await!` the value.\n #[must_use = \"futures do nothing unless polled\"]\n pub trait Future {\n-    /// The result of the `Future`.\n+    /// The type of value produced on completion.\n     type Output;\n \n     /// Attempt to resolve the future to a final value, registering\n@@ -42,16 +43,16 @@ pub trait Future {\n     /// Once a future has finished, clients should not `poll` it again.\n     ///\n     /// When a future is not ready yet, `poll` returns `Poll::Pending` and\n-    /// stores a clone of the [`LocalWaker`] to be woken once the future can\n+    /// stores a clone of the [`Waker`] to be woken once the future can\n     /// make progress. For example, a future waiting for a socket to become\n-    /// readable would call `.clone()` on the [`LocalWaker`] and store it.\n+    /// readable would call `.clone()` on the [`Waker`] and store it.\n     /// When a signal arrives elsewhere indicating that the socket is readable,\n-    /// `[LocalWaker::wake]` is called and the socket future's task is awoken.\n+    /// `[Waker::wake]` is called and the socket future's task is awoken.\n     /// Once a task has been woken up, it should attempt to `poll` the future\n     /// again, which may or may not produce a final value.\n     ///\n     /// Note that on multiple calls to `poll`, only the most recent\n-    /// [`LocalWaker`] passed to `poll` should be scheduled to receive a\n+    /// [`Waker`] passed to `poll` should be scheduled to receive a\n     /// wakeup.\n     ///\n     /// # Runtime characteristics\n@@ -60,51 +61,42 @@ pub trait Future {\n     /// progress, meaning that each time the current task is woken up, it should\n     /// actively re-`poll` pending futures that it still has an interest in.\n     ///\n-    /// The `poll` function is not called repeatedly in a tight loop-- instead,\n+    /// The `poll` function is not called repeatedly in a tight loop -- instead,\n     /// it should only be called when the future indicates that it is ready to\n     /// make progress (by calling `wake()`). If you're familiar with the\n     /// `poll(2)` or `select(2)` syscalls on Unix it's worth noting that futures\n     /// typically do *not* suffer the same problems of \"all wakeups must poll\n     /// all events\"; they are more like `epoll(4)`.\n     ///\n-    /// An implementation of `poll` should strive to return quickly, and must\n-    /// *never* block. Returning quickly prevents unnecessarily clogging up\n+    /// An implementation of `poll` should strive to return quickly, and should\n+    /// not block. Returning quickly prevents unnecessarily clogging up\n     /// threads or event loops. If it is known ahead of time that a call to\n     /// `poll` may end up taking awhile, the work should be offloaded to a\n     /// thread pool (or something similar) to ensure that `poll` can return\n     /// quickly.\n     ///\n-    /// # [`LocalWaker`], [`Waker`] and thread-safety\n-    ///\n-    /// The `poll` function takes a [`LocalWaker`], an object which knows how to\n-    /// awaken the current task. [`LocalWaker`] is not `Send` nor `Sync`, so in\n-    /// order to make thread-safe futures the [`LocalWaker::into_waker`] method\n-    /// should be used to convert the [`LocalWaker`] into a thread-safe version.\n-    /// [`LocalWaker::wake`] implementations have the ability to be more\n-    /// efficient, however, so when thread safety is not necessary,\n-    /// [`LocalWaker`] should be preferred.\n+    /// An implementation of `poll` may also never cause memory unsafety.\n     ///\n     /// # Panics\n     ///\n     /// Once a future has completed (returned `Ready` from `poll`),\n     /// then any future calls to `poll` may panic, block forever, or otherwise\n-    /// cause bad behavior. The `Future` trait itself provides no guarantees\n-    /// about the behavior of `poll` after a future has completed.\n+    /// cause any kind of bad behavior expect causing memory unsafety.\n+    /// The `Future` trait itself provides no guarantees about the behavior\n+    /// of `poll` after a future has completed.\n     ///\n     /// [`Poll::Pending`]: ../task/enum.Poll.html#variant.Pending\n     /// [`Poll::Ready(val)`]: ../task/enum.Poll.html#variant.Ready\n-    /// [`LocalWaker`]: ../task/struct.LocalWaker.html\n-    /// [`LocalWaker::into_waker`]: ../task/struct.LocalWaker.html#method.into_waker\n-    /// [`LocalWaker::wake`]: ../task/struct.LocalWaker.html#method.wake\n     /// [`Waker`]: ../task/struct.Waker.html\n-    fn poll(self: Pin<&mut Self>, lw: &LocalWaker) -> Poll<Self::Output>;\n+    /// [`Waker::wake`]: ../task/struct.Waker.html#method.wake\n+    fn poll(self: Pin<&mut Self>, waker: &Waker) -> Poll<Self::Output>;\n }\n \n impl<'a, F: ?Sized + Future + Unpin> Future for &'a mut F {\n     type Output = F::Output;\n \n-    fn poll(mut self: Pin<&mut Self>, lw: &LocalWaker) -> Poll<Self::Output> {\n-        F::poll(Pin::new(&mut **self), lw)\n+    fn poll(mut self: Pin<&mut Self>, waker: &Waker) -> Poll<Self::Output> {\n+        F::poll(Pin::new(&mut **self), waker)\n     }\n }\n \n@@ -115,7 +107,7 @@ where\n {\n     type Output = <<P as ops::Deref>::Target as Future>::Output;\n \n-    fn poll(self: Pin<&mut Self>, lw: &LocalWaker) -> Poll<Self::Output> {\n-        Pin::get_mut(self).as_mut().poll(lw)\n+    fn poll(self: Pin<&mut Self>, waker: &Waker) -> Poll<Self::Output> {\n+        Pin::get_mut(self).as_mut().poll(waker)\n     }\n }"}, {"sha": "235c79307ab8dfa3b48844c165a55afdb288e063", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -10,7 +10,7 @@ use mem;\n /// An implementation of SipHash 1-3.\n ///\n /// This is currently the default hashing function used by standard library\n-/// (eg. `collections::HashMap` uses it by default).\n+/// (e.g., `collections::HashMap` uses it by default).\n ///\n /// See: <https://131002.net/siphash>\n #[unstable(feature = \"hashmap_internals\", issue = \"0\")]\n@@ -90,7 +90,7 @@ macro_rules! compress {\n     });\n }\n \n-/// Load an integer of the desired type from a byte stream, in LE order. Uses\n+/// Loads an integer of the desired type from a byte stream, in LE order. Uses\n /// `copy_nonoverlapping` to let the compiler generate the most efficient way\n /// to load it from a possibly unaligned address.\n ///\n@@ -107,7 +107,7 @@ macro_rules! load_int_le {\n     });\n }\n \n-/// Load an u64 using up to 7 bytes of a byte slice.\n+/// Loads an u64 using up to 7 bytes of a byte slice.\n ///\n /// Unsafe because: unchecked indexing at start..start+len\n #[inline]"}, {"sha": "89de5c1bc8af80d5c2652849fe760ca5247e19d0", "filename": "src/libcore/hint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhint.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -34,7 +34,7 @@ use intrinsics;\n ///     use std::hint::unreachable_unchecked;\n ///\n ///     // `b.saturating_add(1)` is always positive (not zero),\n-///     // hence `checked_div` will never return None.\n+///     // hence `checked_div` will never return `None`.\n ///     // Therefore, the else branch is unreachable.\n ///     a.checked_div(b.saturating_add(1))\n ///         .unwrap_or_else(|| unsafe { unreachable_unchecked() })"}, {"sha": "9f0f6fd49fba1e930c41bfc08c4abc2b6d92d31f", "filename": "src/libcore/internal_macros.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Finternal_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Finternal_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Finternal_macros.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -75,3 +75,47 @@ macro_rules! forward_ref_op_assign {\n         }\n     }\n }\n+\n+/// Create a zero-size type similar to a closure type, but named.\n+#[unstable(feature = \"std_internals\", issue = \"0\")]\n+macro_rules! impl_fn_for_zst {\n+    ($(\n+        $( #[$attr: meta] )*\n+        // FIXME: when libcore is in the 2018 edition, use `?` repetition in\n+        // $( <$( $li : lifetime ),+> )?\n+        struct $Name: ident impl$( <$( $lifetime : lifetime ),+> )* Fn =\n+            |$( $arg: ident: $ArgTy: ty ),*| -> $ReturnTy: ty\n+            $body: block;\n+    )+) => {\n+        $(\n+            $( #[$attr] )*\n+            struct $Name;\n+\n+            impl $( <$( $lifetime ),+> )* Fn<($( $ArgTy, )*)> for $Name {\n+                #[inline]\n+                extern \"rust-call\" fn call(&self, ($( $arg, )*): ($( $ArgTy, )*)) -> $ReturnTy {\n+                    $body\n+                }\n+            }\n+\n+            impl $( <$( $lifetime ),+> )* FnMut<($( $ArgTy, )*)> for $Name {\n+                #[inline]\n+                extern \"rust-call\" fn call_mut(\n+                    &mut self,\n+                    ($( $arg, )*): ($( $ArgTy, )*)\n+                ) -> $ReturnTy {\n+                    Fn::call(&*self, ($( $arg, )*))\n+                }\n+            }\n+\n+            impl $( <$( $lifetime ),+> )* FnOnce<($( $ArgTy, )*)> for $Name {\n+                type Output = $ReturnTy;\n+\n+                #[inline]\n+                extern \"rust-call\" fn call_once(self, ($( $arg, )*): ($( $ArgTy, )*)) -> $ReturnTy {\n+                    Fn::call(&self, ($( $arg, )*))\n+                }\n+            }\n+        )+\n+    }\n+}"}, {"sha": "f6de7566be914281686e5109f20760886c7abfd0", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,6 +1,6 @@\n-//! rustc compiler intrinsics.\n+//! Compiler intrinsics.\n //!\n-//! The corresponding definitions are in librustc_codegen_llvm/intrinsic.rs.\n+//! The corresponding definitions are in `librustc_codegen_llvm/intrinsic.rs`.\n //!\n //! # Volatiles\n //!\n@@ -315,35 +315,35 @@ extern \"rust-intrinsic\" {\n     /// [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n     pub fn atomic_xchg_relaxed<T>(dst: *mut T, src: T) -> T;\n \n-    /// Add to the current value, returning the previous value.\n+    /// Adds to the current value, returning the previous value.\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_add` method by passing\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n     pub fn atomic_xadd<T>(dst: *mut T, src: T) -> T;\n-    /// Add to the current value, returning the previous value.\n+    /// Adds to the current value, returning the previous value.\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_add` method by passing\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n     pub fn atomic_xadd_acq<T>(dst: *mut T, src: T) -> T;\n-    /// Add to the current value, returning the previous value.\n+    /// Adds to the current value, returning the previous value.\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_add` method by passing\n     /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n     pub fn atomic_xadd_rel<T>(dst: *mut T, src: T) -> T;\n-    /// Add to the current value, returning the previous value.\n+    /// Adds to the current value, returning the previous value.\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_add` method by passing\n     /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n     pub fn atomic_xadd_acqrel<T>(dst: *mut T, src: T) -> T;\n-    /// Add to the current value, returning the previous value.\n+    /// Adds to the current value, returning the previous value.\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_add` method by passing\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n@@ -556,31 +556,31 @@ extern \"rust-intrinsic\" {\n     pub fn atomic_umax_relaxed<T>(dst: *mut T, src: T) -> T;\n \n     /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n-    /// if supported; otherwise, it is a noop.\n+    /// if supported; otherwise, it is a no-op.\n     /// Prefetches have no effect on the behavior of the program but can change its performance\n     /// characteristics.\n     ///\n     /// The `locality` argument must be a constant integer and is a temporal locality specifier\n     /// ranging from (0) - no locality, to (3) - extremely local keep in cache\n     pub fn prefetch_read_data<T>(data: *const T, locality: i32);\n     /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n-    /// if supported; otherwise, it is a noop.\n+    /// if supported; otherwise, it is a no-op.\n     /// Prefetches have no effect on the behavior of the program but can change its performance\n     /// characteristics.\n     ///\n     /// The `locality` argument must be a constant integer and is a temporal locality specifier\n     /// ranging from (0) - no locality, to (3) - extremely local keep in cache\n     pub fn prefetch_write_data<T>(data: *const T, locality: i32);\n     /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n-    /// if supported; otherwise, it is a noop.\n+    /// if supported; otherwise, it is a no-op.\n     /// Prefetches have no effect on the behavior of the program but can change its performance\n     /// characteristics.\n     ///\n     /// The `locality` argument must be a constant integer and is a temporal locality specifier\n     /// ranging from (0) - no locality, to (3) - extremely local keep in cache\n     pub fn prefetch_read_instruction<T>(data: *const T, locality: i32);\n     /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n-    /// if supported; otherwise, it is a noop.\n+    /// if supported; otherwise, it is a no-op.\n     /// Prefetches have no effect on the behavior of the program but can change its performance\n     /// characteristics.\n     ///\n@@ -697,7 +697,7 @@ extern \"rust-intrinsic\" {\n     /// Creates a value initialized to zero.\n     ///\n     /// `init` is unsafe because it returns a zeroed-out datum,\n-    /// which is unsafe unless T is `Copy`.  Also, even if T is\n+    /// which is unsafe unless `T` is `Copy`. Also, even if T is\n     /// `Copy`, an all-zero value may not correspond to any legitimate\n     /// state for the type in question.\n     pub fn init<T>() -> T;\n@@ -857,7 +857,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// // The no-copy, unsafe way, still using transmute, but not UB.\n     /// // This is equivalent to the original, but safer, and reuses the\n-    /// // same Vec internals. Therefore the new inner type must have the\n+    /// // same `Vec` internals. Therefore, the new inner type must have the\n     /// // exact same size, and the same alignment, as the old type.\n     /// // The same caveats exist for this method as transmute, for\n     /// // the original inner type (`&i32`) to the converted inner type\n@@ -875,8 +875,8 @@ extern \"rust-intrinsic\" {\n     /// ```\n     /// use std::{slice, mem};\n     ///\n-    /// // There are multiple ways to do this; and there are multiple problems\n-    /// // with the following, transmute, way.\n+    /// // There are multiple ways to do this, and there are multiple problems\n+    /// // with the following (transmute) way.\n     /// fn split_at_mut_transmute<T>(slice: &mut [T], mid: usize)\n     ///                              -> (&mut [T], &mut [T]) {\n     ///     let len = slice.len();\n@@ -988,7 +988,7 @@ extern \"rust-intrinsic\" {\n     ///   beginning at `dst` with the same size.\n     ///\n     /// Like [`read`], `copy_nonoverlapping` creates a bitwise copy of `T`, regardless of\n-    /// whether `T` is [`Copy`].  If `T` is not [`Copy`], using *both* the values\n+    /// whether `T` is [`Copy`]. If `T` is not [`Copy`], using *both* the values\n     /// in the region beginning at `*src` and the region beginning at `*dst` can\n     /// [violate memory safety][read-ownership].\n     ///\n@@ -1055,7 +1055,7 @@ extern \"rust-intrinsic\" {\n     /// [`copy_nonoverlapping`] can be used instead.\n     ///\n     /// `copy` is semantically equivalent to C's [`memmove`], but with the argument\n-    /// order swapped.  Copying takes place as if the bytes were copied from `src`\n+    /// order swapped. Copying takes place as if the bytes were copied from `src`\n     /// to a temporary array and then copied from the array to `dst`.\n     ///\n     /// [`copy_nonoverlapping`]: ./fn.copy_nonoverlapping.html\n@@ -1072,7 +1072,7 @@ extern \"rust-intrinsic\" {\n     /// * Both `src` and `dst` must be properly aligned.\n     ///\n     /// Like [`read`], `copy` creates a bitwise copy of `T`, regardless of\n-    /// whether `T` is [`Copy`].  If `T` is not [`Copy`], using both the values\n+    /// whether `T` is [`Copy`]. If `T` is not [`Copy`], using both the values\n     /// in the region beginning at `*src` and the region beginning at `*dst` can\n     /// [violate memory safety][read-ownership].\n     ///\n@@ -1200,19 +1200,19 @@ extern \"rust-intrinsic\" {\n     /// unless size is equal to zero.\n     pub fn volatile_set_memory<T>(dst: *mut T, val: u8, count: usize);\n \n-    /// Perform a volatile load from the `src` pointer.\n+    /// Performs a volatile load from the `src` pointer.\n     /// The stabilized version of this intrinsic is\n     /// [`std::ptr::read_volatile`](../../std/ptr/fn.read_volatile.html).\n     pub fn volatile_load<T>(src: *const T) -> T;\n-    /// Perform a volatile store to the `dst` pointer.\n+    /// Performs a volatile store to the `dst` pointer.\n     /// The stabilized version of this intrinsic is\n     /// [`std::ptr::write_volatile`](../../std/ptr/fn.write_volatile.html).\n     pub fn volatile_store<T>(dst: *mut T, val: T);\n \n-    /// Perform a volatile load from the `src` pointer\n+    /// Performs a volatile load from the `src` pointer\n     /// The pointer is not required to be aligned.\n     pub fn unaligned_volatile_load<T>(src: *const T) -> T;\n-    /// Perform a volatile store to the `dst` pointer.\n+    /// Performs a volatile store to the `dst` pointer.\n     /// The pointer is not required to be aligned.\n     pub fn unaligned_volatile_store<T>(dst: *mut T, val: T);\n "}, {"sha": "a3e9cfa94931297cfbfc32aab5fb55e81ddf2990", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -20,19 +20,19 @@ pub trait Step: Clone + PartialOrd + Sized {\n     /// without overflow.\n     fn steps_between(start: &Self, end: &Self) -> Option<usize>;\n \n-    /// Replaces this step with `1`, returning itself\n+    /// Replaces this step with `1`, returning itself.\n     fn replace_one(&mut self) -> Self;\n \n-    /// Replaces this step with `0`, returning itself\n+    /// Replaces this step with `0`, returning itself.\n     fn replace_zero(&mut self) -> Self;\n \n-    /// Adds one to this step, returning the result\n+    /// Adds one to this step, returning the result.\n     fn add_one(&self) -> Self;\n \n-    /// Subtracts one to this step, returning the result\n+    /// Subtracts one to this step, returning the result.\n     fn sub_one(&self) -> Self;\n \n-    /// Add an usize, returning None on overflow\n+    /// Adds a `usize`, returning `None` on overflow.\n     fn add_usize(&self, n: usize) -> Option<Self>;\n }\n "}, {"sha": "6f45f082d6a3714be887c7e1e001b92d6053742e", "filename": "src/libcore/iter/sources.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fiter%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fiter%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fsources.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -504,10 +504,8 @@ pub fn once_with<A, F: FnOnce() -> A>(gen: F) -> OnceWith<F> {\n /// [`FusedIterator`]: trait.FusedIterator.html\n /// [`Iterator::size_hint`]: trait.Iterator.html#method.size_hint\n ///\n-/// The closure can use its its captures and environment\n-/// to track state across iterations.\n-/// Depending on how the iterator is used,\n-/// this may require specifying the `move` keyword on the closure.\n+/// The closure can use captures and its environment to track state across iterations. Depending on\n+/// how the iterator is used, this may require specifying the `move` keyword on the closure.\n ///\n /// # Examples\n ///"}, {"sha": "d6eab40213edb0fe9902fb95838ca294a99c82e9", "filename": "src/libcore/iter/traits/exact_size.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fiter%2Ftraits%2Fexact_size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fiter%2Ftraits%2Fexact_size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fexact_size.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -104,7 +104,7 @@ pub trait ExactSizeIterator: Iterator {\n         lower\n     }\n \n-    /// Returns whether the iterator is empty.\n+    /// Returns `true` if the iterator is empty.\n     ///\n     /// This method has a default implementation using `self.len()`, so you\n     /// don't need to implement it yourself."}, {"sha": "861e9c3157a790d51da98e72c698566f2b5b1391", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -120,7 +120,7 @@ pub trait Iterator {\n     /// // ... and then None once it's over.\n     /// assert_eq!(None, iter.next());\n     ///\n-    /// // More calls may or may not return None. Here, they always will.\n+    /// // More calls may or may not return `None`. Here, they always will.\n     /// assert_eq!(None, iter.next());\n     /// assert_eq!(None, iter.next());\n     /// ```\n@@ -564,9 +564,9 @@ pub trait Iterator {\n     /// Calls a closure on each element of an iterator.\n     ///\n     /// This is equivalent to using a [`for`] loop on the iterator, although\n-    /// `break` and `continue` are not possible from a closure.  It's generally\n+    /// `break` and `continue` are not possible from a closure. It's generally\n     /// more idiomatic to use a `for` loop, but `for_each` may be more legible\n-    /// when processing items at the end of longer iterator chains.  In some\n+    /// when processing items at the end of longer iterator chains. In some\n     /// cases `for_each` may also be faster than a loop, because it will use\n     /// internal iteration on adaptors like `Chain`.\n     ///\n@@ -952,8 +952,7 @@ pub trait Iterator {\n     /// ```\n     ///\n     /// The `3` is no longer there, because it was consumed in order to see if\n-    /// the iteration should stop, but wasn't placed back into the iterator or\n-    /// some similar thing.\n+    /// the iteration should stop, but wasn't placed back into the iterator.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn take_while<P>(self, predicate: P) -> TakeWhile<Self, P> where\n@@ -1216,7 +1215,7 @@ pub trait Iterator {\n     /// assert_eq!(iter.next(), Some(4));\n     /// assert_eq!(iter.next(), None);\n     ///\n-    /// // it will always return None after the first time.\n+    /// // it will always return `None` after the first time.\n     /// assert_eq!(iter.next(), None);\n     /// assert_eq!(iter.next(), None);\n     /// assert_eq!(iter.next(), None);\n@@ -1516,7 +1515,7 @@ pub trait Iterator {\n     /// is propagated back to the caller immediately (short-circuiting).\n     ///\n     /// The initial value is the value the accumulator will have on the first\n-    /// call.  If applying the closure succeeded against every element of the\n+    /// call. If applying the closure succeeded against every element of the\n     /// iterator, `try_fold()` returns the final accumulator as success.\n     ///\n     /// Folding is useful whenever you have a collection of something, and want\n@@ -1529,10 +1528,10 @@ pub trait Iterator {\n     /// do something better than the default `for` loop implementation.\n     ///\n     /// In particular, try to have this call `try_fold()` on the internal parts\n-    /// from which this iterator is composed.  If multiple calls are needed,\n+    /// from which this iterator is composed. If multiple calls are needed,\n     /// the `?` operator may be convenient for chaining the accumulator value\n     /// along, but beware any invariants that need to be upheld before those\n-    /// early returns.  This is a `&mut self` method, so iteration needs to be\n+    /// early returns. This is a `&mut self` method, so iteration needs to be\n     /// resumable after hitting an error here.\n     ///\n     /// # Examples"}, {"sha": "d046236b5353a0ea5357c81f0ff261bd65bde4bf", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -24,7 +24,7 @@\n //!   often generated by LLVM. Additionally, this library can make explicit\n //!   calls to these functions. Their signatures are the same as found in C.\n //!   These functions are often provided by the system libc, but can also be\n-//!   provided by the [rlibc crate](https://crates.io/crates/rlibc).\n+//!   provided by the [compiler-builtins crate](https://crates.io/crates/compiler_builtins).\n //!\n //! * `rust_begin_panic` - This function takes four arguments, a\n //!   `fmt::Arguments`, a `&'static str`, and two `u32`'s. These four arguments\n@@ -51,9 +51,7 @@\n #![cfg(not(test))]\n \n #![stable(feature = \"core\", since = \"1.6.0\")]\n-#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-       html_root_url = \"https://doc.rust-lang.org/nightly/\",\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"https://play.rust-lang.org/\",\n        issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\",\n        test(no_crate_inject, attr(deny(warnings))),\n@@ -97,6 +95,7 @@\n #![feature(simd_ffi)]\n #![feature(specialization)]\n #![feature(staged_api)]\n+#![feature(std_internals)]\n #![feature(stmt_expr_attributes)]\n #![feature(unboxed_closures)]\n #![feature(unsized_locals)]\n@@ -123,7 +122,7 @@\n #![feature(structural_match)]\n #![feature(abi_unadjusted)]\n #![feature(adx_target_feature)]\n-#![feature(maybe_uninit)]\n+#![feature(maybe_uninit, maybe_uninit_slice, maybe_uninit_array)]\n #![feature(unrestricted_attribute_tokens)]\n \n #[prelude_import]\n@@ -228,20 +227,6 @@ mod unit;\n // `core_arch` depends on libcore, but the contents of this module are\n // set up in such a way that directly pulling it here works such that the\n // crate uses the this crate as its libcore.\n-#[allow(unused_macros)]\n-macro_rules! test_v16 { ($item:item) => {}; }\n-#[allow(unused_macros)]\n-macro_rules! test_v32 { ($item:item) => {}; }\n-#[allow(unused_macros)]\n-macro_rules! test_v64 { ($item:item) => {}; }\n-#[allow(unused_macros)]\n-macro_rules! test_v128 { ($item:item) => {}; }\n-#[allow(unused_macros)]\n-macro_rules! test_v256 { ($item:item) => {}; }\n-#[allow(unused_macros)]\n-macro_rules! test_v512 { ($item:item) => {}; }\n-#[allow(unused_macros)]\n-macro_rules! vector_impl { ($([$f:ident, $($args:tt)*]),*) => { $($f!($($args)*);)* } }\n #[path = \"../stdsimd/crates/core_arch/src/mod.rs\"]\n #[allow(missing_docs, missing_debug_implementations, dead_code, unused_imports)]\n #[unstable(feature = \"stdsimd\", issue = \"48556\")]"}, {"sha": "fdbfa56000b8ebbc32c5fafea80c1e78cee8f152", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,6 +1,7 @@\n-/// Entry point of thread panic, for details, see std::macros\n+/// Entry point of thread panic. For details, see `std::macros`.\n #[macro_export]\n-#[allow_internal_unstable]\n+#[cfg_attr(not(stage0), allow_internal_unstable(core_panic, __rust_unstable_column))]\n+#[cfg_attr(stage0, allow_internal_unstable)]\n #[stable(feature = \"core\", since = \"1.6.0\")]\n macro_rules! panic {\n     () => (\n@@ -45,9 +46,12 @@ macro_rules! assert_eq {\n         match (&$left, &$right) {\n             (left_val, right_val) => {\n                 if !(*left_val == *right_val) {\n+                    // The reborrows below are intentional. Without them, the stack slot for the\n+                    // borrow is initialized even before the values are compared, leading to a\n+                    // noticeable slow down.\n                     panic!(r#\"assertion failed: `(left == right)`\n   left: `{:?}`,\n- right: `{:?}`\"#, left_val, right_val)\n+ right: `{:?}`\"#, &*left_val, &*right_val)\n                 }\n             }\n         }\n@@ -59,9 +63,12 @@ macro_rules! assert_eq {\n         match (&($left), &($right)) {\n             (left_val, right_val) => {\n                 if !(*left_val == *right_val) {\n+                    // The reborrows below are intentional. Without them, the stack slot for the\n+                    // borrow is initialized even before the values are compared, leading to a\n+                    // noticeable slow down.\n                     panic!(r#\"assertion failed: `(left == right)`\n   left: `{:?}`,\n- right: `{:?}`: {}\"#, left_val, right_val,\n+ right: `{:?}`: {}\"#, &*left_val, &*right_val,\n                            format_args!($($arg)+))\n                 }\n             }\n@@ -96,9 +103,12 @@ macro_rules! assert_ne {\n         match (&$left, &$right) {\n             (left_val, right_val) => {\n                 if *left_val == *right_val {\n+                    // The reborrows below are intentional. Without them, the stack slot for the\n+                    // borrow is initialized even before the values are compared, leading to a\n+                    // noticeable slow down.\n                     panic!(r#\"assertion failed: `(left != right)`\n   left: `{:?}`,\n- right: `{:?}`\"#, left_val, right_val)\n+ right: `{:?}`\"#, &*left_val, &*right_val)\n                 }\n             }\n         }\n@@ -110,9 +120,12 @@ macro_rules! assert_ne {\n         match (&($left), &($right)) {\n             (left_val, right_val) => {\n                 if *left_val == *right_val {\n+                    // The reborrows below are intentional. Without them, the stack slot for the\n+                    // borrow is initialized even before the values are compared, leading to a\n+                    // noticeable slow down.\n                     panic!(r#\"assertion failed: `(left != right)`\n   left: `{:?}`,\n- right: `{:?}`: {}\"#, left_val, right_val,\n+ right: `{:?}`: {}\"#, &*left_val, &*right_val,\n                            format_args!($($arg)+))\n                 }\n             }\n@@ -409,7 +422,8 @@ macro_rules! write {\n /// ```\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow_internal_unstable]\n+#[cfg_attr(stage0, allow_internal_unstable)]\n+#[cfg_attr(not(stage0), allow_internal_unstable(format_args_nl))]\n macro_rules! writeln {\n     ($dst:expr) => (\n         write!($dst, \"\\n\")\n@@ -432,7 +446,7 @@ macro_rules! writeln {\n /// * Iterators that dynamically terminate.\n ///\n /// If the determination that the code is unreachable proves incorrect, the\n-/// program immediately terminates with a [`panic!`].  The function [`unreachable_unchecked`],\n+/// program immediately terminates with a [`panic!`]. The function [`unreachable_unchecked`],\n /// which belongs to the [`std::hint`] module, informs the compiler to\n /// optimize the code out of the release version entirely.\n ///\n@@ -493,7 +507,7 @@ macro_rules! unreachable {\n /// A standardized placeholder for marking unfinished code.\n ///\n /// This can be useful if you are prototyping and are just looking to have your\n-/// code typecheck, or if you're implementing a trait that requires multiple\n+/// code type-check, or if you're implementing a trait that requires multiple\n /// methods, and you're only planning on using one of them.\n ///\n /// # Panics\n@@ -549,18 +563,18 @@ macro_rules! unimplemented {\n \n /// A macro to create an array of [`MaybeUninit`]\n ///\n-/// This macro constructs and uninitialized array of the type `[MaybeUninit<K>; N]`.\n+/// This macro constructs an uninitialized array of the type `[MaybeUninit<K>; N]`.\n ///\n /// [`MaybeUninit`]: mem/union.MaybeUninit.html\n #[macro_export]\n-#[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+#[unstable(feature = \"maybe_uninit_array\", issue = \"53491\")]\n macro_rules! uninitialized_array {\n-    // This `into_inner` is safe because an array of `MaybeUninit` does not\n+    // This `into_initialized` is safe because an array of `MaybeUninit` does not\n     // require initialization.\n     // FIXME(#49147): Could be replaced by an array initializer, once those can\n     // be any const expression.\n     ($t:ty; $size:expr) => (unsafe {\n-        MaybeUninit::<[MaybeUninit<$t>; $size]>::uninitialized().into_inner()\n+        MaybeUninit::<[MaybeUninit<$t>; $size]>::uninitialized().into_initialized()\n     });\n }\n "}, {"sha": "c4b41f1a3090c3685e52a228a6b9efbf1ebb9836", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -78,7 +78,7 @@ impl<T: ?Sized> !Send for *mut T { }\n ///                         // be made into an object\n /// ```\n ///\n-/// [trait object]: ../../book/first-edition/trait-objects.html\n+/// [trait object]: ../../book/ch17-02-trait-objects.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"sized\"]\n #[rustc_on_unimplemented(\n@@ -518,7 +518,7 @@ macro_rules! impls{\n /// types. We track the Rust type using a phantom type parameter on\n /// the struct `ExternalResource` which wraps a handle.\n ///\n-/// [FFI]: ../../book/first-edition/ffi.html\n+/// [FFI]: ../../book/ch19-01-unsafe-rust.html#using-extern-functions-to-call-external-code\n ///\n /// ```\n /// # #![allow(dead_code)]"}, {"sha": "e0b0e72ff9b5f0e1aeea46d4aa48946617521baa", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 112, "deletions": 39, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -15,6 +15,7 @@ use ptr;\n use ops::{Deref, DerefMut};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[doc(inline)]\n pub use intrinsics::transmute;\n \n /// Takes ownership and \"forgets\" about the value **without running its destructor**.\n@@ -294,11 +295,11 @@ pub const fn size_of<T>() -> usize {\n /// Returns the size of the pointed-to value in bytes.\n ///\n /// This is usually the same as `size_of::<T>()`. However, when `T` *has* no\n-/// statically known size, e.g., a slice [`[T]`][slice] or a [trait object],\n+/// statically-known size, e.g., a slice [`[T]`][slice] or a [trait object],\n /// then `size_of_val` can be used to get the dynamically-known size.\n ///\n /// [slice]: ../../std/primitive.slice.html\n-/// [trait object]: ../../book/first-edition/trait-objects.html\n+/// [trait object]: ../../book/ch17-02-trait-objects.html\n ///\n /// # Examples\n ///\n@@ -402,7 +403,7 @@ pub fn align_of_val<T: ?Sized>(val: &T) -> usize {\n     unsafe { intrinsics::min_align_of_val(val) }\n }\n \n-/// Returns whether dropping values of type `T` matters.\n+/// Returns `true` if dropping values of type `T` matters.\n ///\n /// This is purely an optimization hint, and may be implemented conservatively:\n /// it may return `true` for types that don't actually need to be dropped.\n@@ -957,7 +958,7 @@ impl<T> ManuallyDrop<T> {\n         ManuallyDrop { value }\n     }\n \n-    /// Extract the value from the `ManuallyDrop` container.\n+    /// Extracts the value from the `ManuallyDrop` container.\n     ///\n     /// This allows the value to be dropped again.\n     ///\n@@ -1034,7 +1035,65 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n     }\n }\n \n-/// A newtype to construct uninitialized instances of `T`\n+/// A newtype to construct uninitialized instances of `T`.\n+///\n+/// The compiler, in general, assumes that variables are properly initialized\n+/// at their respective type. For example, a variable of reference type must\n+/// be aligned and non-NULL. This is an invariant that must *always* be upheld,\n+/// even in unsafe code. As a consequence, zero-initializing a variable of reference\n+/// type causes instantaneous undefined behavior, no matter whether that reference\n+/// ever gets used to access memory:\n+///\n+/// ```rust,no_run\n+/// #![feature(maybe_uninit)]\n+/// use std::mem::{self, MaybeUninit};\n+///\n+/// let x: &i32 = unsafe { mem::zeroed() }; // undefined behavior!\n+/// // equivalent code with `MaybeUninit`\n+/// let x: &i32 = unsafe { MaybeUninit::zeroed().into_initialized() }; // undefined behavior!\n+/// ```\n+///\n+/// This is exploited by the compiler for various optimizations, such as eliding\n+/// run-time checks and optimizing `enum` layout.\n+///\n+/// Not initializing memory at all (instead of zero-initializing it) causes the same\n+/// issue: after all, the initial value of the variable might just happen to be\n+/// one that violates the invariant. Moreover, uninitialized memory is special\n+/// in that the compiler knows that it does not have a fixed value. This makes\n+/// it undefined behavior to have uninitialized data in a variable even if that\n+/// variable has otherwise no restrictions about which values are valid:\n+///\n+/// ```rust,no_run\n+/// #![feature(maybe_uninit)]\n+/// use std::mem::{self, MaybeUninit};\n+///\n+/// let x: i32 = unsafe { mem::uninitialized() }; // undefined behavior!\n+/// // equivalent code with `MaybeUninit`\n+/// let x: i32 = unsafe { MaybeUninit::uninitialized().into_initialized() }; // undefined behavior!\n+/// ```\n+/// (Notice that the rules around uninitialized integers are not finalized yet, but\n+/// until they are, it is advisable to avoid them.)\n+///\n+/// `MaybeUninit` serves to enable unsafe code to deal with uninitialized data:\n+/// it is a signal to the compiler indicating that the data here might *not*\n+/// be initialized:\n+///\n+/// ```rust\n+/// #![feature(maybe_uninit)]\n+/// use std::mem::MaybeUninit;\n+///\n+/// // Create an explicitly uninitialized reference. The compiler knows that data inside\n+/// // a `MaybeUninit` may be invalid, and hence this is not UB:\n+/// let mut x = MaybeUninit::<&i32>::uninitialized();\n+/// // Set it to a valid value.\n+/// x.set(&0);\n+/// // Extract the initialized data -- this is only allowed *after* properly\n+/// // initializing `x`!\n+/// let x = unsafe { x.into_initialized() };\n+/// ```\n+///\n+/// The compiler then knows to not optimize this code.\n+// FIXME before stabilizing, explain how to initialize a struct field-by-field.\n #[allow(missing_debug_implementations)]\n #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n // NOTE after stabilizing `MaybeUninit` proceed to deprecate `mem::{uninitialized,zeroed}`\n@@ -1054,7 +1113,7 @@ impl<T> MaybeUninit<T> {\n         MaybeUninit { value: ManuallyDrop::new(val) }\n     }\n \n-    /// Create a new `MaybeUninit` in an uninitialized state.\n+    /// Creates a new `MaybeUninit` in an uninitialized state.\n     ///\n     /// Note that dropping a `MaybeUninit` will never call `T`'s drop code.\n     /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n@@ -1064,8 +1123,8 @@ impl<T> MaybeUninit<T> {\n         MaybeUninit { uninit: () }\n     }\n \n-    /// Create a new `MaybeUninit` in an uninitialized state, with the memory being\n-    /// filled with `0` bytes.  It depends on `T` whether that already makes for\n+    /// Creates a new `MaybeUninit` in an uninitialized state, with the memory being\n+    /// filled with `0` bytes. It depends on `T` whether that already makes for\n     /// proper initialization. For example, `MaybeUninit<usize>::zeroed()` is initialized,\n     /// but `MaybeUninit<&'static i32>::zeroed()` is not because references must not\n     /// be null.\n@@ -1082,82 +1141,96 @@ impl<T> MaybeUninit<T> {\n         u\n     }\n \n-    /// Set the value of the `MaybeUninit`. This overwrites any previous value without dropping it.\n+    /// Sets the value of the `MaybeUninit`. This overwrites any previous value without dropping it.\n+    /// For your convenience, this also returns a mutable reference to the (now safely initialized)\n+    /// contents of `self`.\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n-    pub fn set(&mut self, val: T) {\n+    pub fn set(&mut self, val: T) -> &mut T {\n         unsafe {\n             self.value = ManuallyDrop::new(val);\n+            self.get_mut()\n         }\n     }\n \n-    /// Extract the value from the `MaybeUninit` container.  This is a great way\n+    /// Gets a pointer to the contained value. Reading from this pointer or turning it\n+    /// into a reference will be undefined behavior unless the `MaybeUninit` is initialized.\n+    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[inline(always)]\n+    pub fn as_ptr(&self) -> *const T {\n+        unsafe { &*self.value as *const T }\n+    }\n+\n+    /// Gets a mutable pointer to the contained value. Reading from this pointer or turning it\n+    /// into a reference will be undefined behavior unless the `MaybeUninit` is initialized.\n+    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[inline(always)]\n+    pub fn as_mut_ptr(&mut self) -> *mut T {\n+        unsafe { &mut *self.value as *mut T }\n+    }\n+\n+    /// Extracts the value from the `MaybeUninit` container. This is a great way\n     /// to ensure that the data will get dropped, because the resulting `T` is\n     /// subject to the usual drop handling.\n     ///\n     /// # Unsafety\n     ///\n     /// It is up to the caller to guarantee that the `MaybeUninit` really is in an initialized\n-    /// state, otherwise this will immediately cause undefined behavior.\n+    /// state. Calling this when the content is not yet fully initialized causes undefined\n+    /// behavior.\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n-    pub unsafe fn into_inner(self) -> T {\n+    pub unsafe fn into_initialized(self) -> T {\n         intrinsics::panic_if_uninhabited::<T>();\n         ManuallyDrop::into_inner(self.value)\n     }\n \n-    /// Get a reference to the contained value.\n+    /// Deprecated alternative to `into_initialized`. Will never get stabilized.\n+    /// Exists only to transition stdsimd to `into_initialized`.\n+    #[inline(always)]\n+    #[allow(unused)]\n+    pub(crate) unsafe fn into_inner(self) -> T {\n+        self.into_initialized()\n+    }\n+\n+    /// Gets a reference to the contained value.\n     ///\n     /// # Unsafety\n     ///\n     /// It is up to the caller to guarantee that the `MaybeUninit` really is in an initialized\n-    /// state, otherwise this will immediately cause undefined behavior.\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    /// state. Calling this when the content is not yet fully initialized causes undefined\n+    /// behavior.\n+    #[unstable(feature = \"maybe_uninit_ref\", issue = \"53491\")]\n     #[inline(always)]\n     pub unsafe fn get_ref(&self) -> &T {\n         &*self.value\n     }\n \n-    /// Get a mutable reference to the contained value.\n+    /// Gets a mutable reference to the contained value.\n     ///\n     /// # Unsafety\n     ///\n     /// It is up to the caller to guarantee that the `MaybeUninit` really is in an initialized\n-    /// state, otherwise this will immediately cause undefined behavior.\n+    /// state. Calling this when the content is not yet fully initialized causes undefined\n+    /// behavior.\n     // FIXME(#53491): We currently rely on the above being incorrect, i.e., we have references\n     // to uninitialized data (e.g., in `libcore/fmt/float.rs`).  We should make\n     // a final decision about the rules before stabilization.\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[unstable(feature = \"maybe_uninit_ref\", issue = \"53491\")]\n     #[inline(always)]\n     pub unsafe fn get_mut(&mut self) -> &mut T {\n         &mut *self.value\n     }\n \n-    /// Get a pointer to the contained value. Reading from this pointer will be undefined\n-    /// behavior unless the `MaybeUninit` is initialized.\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n-    #[inline(always)]\n-    pub fn as_ptr(&self) -> *const T {\n-        unsafe { &*self.value as *const T }\n-    }\n-\n-    /// Get a mutable pointer to the contained value. Reading from this pointer will be undefined\n-    /// behavior unless the `MaybeUninit` is initialized.\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n-    #[inline(always)]\n-    pub fn as_mut_ptr(&mut self) -> *mut T {\n-        unsafe { &mut *self.value as *mut T }\n-    }\n-\n-    /// Get a pointer to the first element of the array.\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    /// Gets a pointer to the first element of the array.\n+    #[unstable(feature = \"maybe_uninit_slice\", issue = \"53491\")]\n     #[inline(always)]\n     pub fn first_ptr(this: &[MaybeUninit<T>]) -> *const T {\n         this as *const [MaybeUninit<T>] as *const T\n     }\n \n-    /// Get a mutable pointer to the first element of the array.\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    /// Gets a mutable pointer to the first element of the array.\n+    #[unstable(feature = \"maybe_uninit_slice\", issue = \"53491\")]\n     #[inline(always)]\n     pub fn first_ptr_mut(this: &mut [MaybeUninit<T>]) -> *mut T {\n         this as *mut [MaybeUninit<T>] as *mut T"}, {"sha": "3b57bb7544b35bb3b8b18d4422f01527ab7da3c3", "filename": "src/libcore/num/dec2flt/algorithm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -61,7 +61,7 @@ mod fpu_precision {\n         unsafe { asm!(\"fldcw $0\" :: \"m\" (cw) :: \"volatile\") }\n     }\n \n-    /// Set the precision field of the FPU to `T` and return a `FPUControlWord`\n+    /// Sets the precision field of the FPU to `T` and returns a `FPUControlWord`.\n     pub fn set_precision<T>() -> FPUControlWord {\n         let cw = 0u16;\n "}, {"sha": "47ea5aa5ff000b8c8b1b08f8656375112e4b0802", "filename": "src/libcore/num/dec2flt/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -37,7 +37,7 @@\n //!\n //! In addition, there are numerous helper functions that are used in the paper but not available\n //! in Rust (or at least in core). Our version is additionally complicated by the need to handle\n-//! overflow and underflow and the desire to handle subnormal numbers.  Bellerophon and\n+//! overflow and underflow and the desire to handle subnormal numbers. Bellerophon and\n //! Algorithm R have trouble with overflow, subnormals, and underflow. We conservatively switch to\n //! Algorithm M (with the modifications described in section 8 of the paper) well before the\n //! inputs get into the critical region.\n@@ -54,7 +54,7 @@\n //! operations as well, if you want 0.5 ULP accuracy you need to do *everything* in full precision\n //! and round *exactly once, at the end*, by considering all truncated bits at once.\n //!\n-//! FIXME Although some code duplication is necessary, perhaps parts of the code could be shuffled\n+//! FIXME: Although some code duplication is necessary, perhaps parts of the code could be shuffled\n //! around such that less code is duplicated. Large parts of the algorithms are independent of the\n //! float type to output, or only needs access to a few constants, which could be passed in as\n //! parameters.\n@@ -148,7 +148,7 @@ macro_rules! from_str_float_impl {\n             /// # Return value\n             ///\n             /// `Err(ParseFloatError)` if the string did not represent a valid\n-            /// number.  Otherwise, `Ok(n)` where `n` is the floating-point\n+            /// number. Otherwise, `Ok(n)` where `n` is the floating-point\n             /// number represented by `src`.\n             #[inline]\n             fn from_str(src: &str) -> Result<Self, ParseFloatError> {\n@@ -209,7 +209,7 @@ fn pfe_invalid() -> ParseFloatError {\n     ParseFloatError { kind: FloatErrorKind::Invalid }\n }\n \n-/// Split decimal string into sign and the rest, without inspecting or validating the rest.\n+/// Splits a decimal string into sign and the rest, without inspecting or validating the rest.\n fn extract_sign(s: &str) -> (Sign, &str) {\n     match s.as_bytes()[0] {\n         b'+' => (Sign::Positive, &s[1..]),\n@@ -219,7 +219,7 @@ fn extract_sign(s: &str) -> (Sign, &str) {\n     }\n }\n \n-/// Convert a decimal string into a floating point number.\n+/// Converts a decimal string into a floating point number.\n fn dec2flt<T: RawFloat>(s: &str) -> Result<T, ParseFloatError> {\n     if s.is_empty() {\n         return Err(pfe_empty())"}, {"sha": "126713185711b3fecd0a4046e8e8bf4c0bee8ccc", "filename": "src/libcore/num/dec2flt/num.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fnum%2Fdec2flt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fnum%2Fdec2flt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fnum.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -27,7 +27,7 @@ pub fn compare_with_half_ulp(f: &Big, ones_place: usize) -> Ordering {\n     Equal\n }\n \n-/// Convert an ASCII string containing only decimal digits to a `u64`.\n+/// Converts an ASCII string containing only decimal digits to a `u64`.\n ///\n /// Does not perform checks for overflow or invalid characters, so if the caller is not careful,\n /// the result is bogus and can panic (though it won't be `unsafe`). Additionally, empty strings\n@@ -44,7 +44,7 @@ pub fn from_str_unchecked<'a, T>(bytes: T) -> u64 where T : IntoIterator<Item=&'\n     result\n }\n \n-/// Convert a string of ASCII digits into a bignum.\n+/// Converts a string of ASCII digits into a bignum.\n ///\n /// Like `from_str_unchecked`, this function relies on the parser to weed out non-digits.\n pub fn digits_to_big(integral: &[u8], fractional: &[u8]) -> Big {\n@@ -69,7 +69,7 @@ pub fn to_u64(x: &Big) -> u64 {\n }\n \n \n-/// Extract a range of bits.\n+/// Extracts a range of bits.\n \n /// Index 0 is the least significant bit and the range is half-open as usual.\n /// Panics if asked to extract more bits than fit into the return type."}, {"sha": "933f8c1d3f781e959c7dbe309a92fbc9ca784bb6", "filename": "src/libcore/num/dec2flt/parse.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -42,7 +42,7 @@ pub enum ParseResult<'a> {\n     Invalid,\n }\n \n-/// Check if the input string is a valid floating point number and if so, locate the integral\n+/// Checks if the input string is a valid floating point number and if so, locate the integral\n /// part, the fractional part, and the exponent in it. Does not handle signs.\n pub fn parse_decimal(s: &str) -> ParseResult {\n     if s.is_empty() {"}, {"sha": "b65f539b29c97c105df01ada310443a104a0eb9f", "filename": "src/libcore/num/dec2flt/rawfp.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -59,10 +59,10 @@ pub trait RawFloat\n     /// Type used by `to_bits` and `from_bits`.\n     type Bits: Add<Output = Self::Bits> + From<u8> + TryFrom<u64>;\n \n-    /// Raw transmutation to integer.\n+    /// Performs a raw transmutation to an integer.\n     fn to_bits(self) -> Self::Bits;\n \n-    /// Raw transmutation from integer.\n+    /// Performs a raw transmutation from an integer.\n     fn from_bits(v: Self::Bits) -> Self;\n \n     /// Returns the category that this number falls into.\n@@ -71,14 +71,14 @@ pub trait RawFloat\n     /// Returns the mantissa, exponent and sign as integers.\n     fn integer_decode(self) -> (u64, i16, i8);\n \n-    /// Decode the float.\n+    /// Decodes the float.\n     fn unpack(self) -> Unpacked;\n \n-    /// Cast from a small integer that can be represented exactly.  Panic if the integer can't be\n+    /// Casts from a small integer that can be represented exactly. Panic if the integer can't be\n     /// represented, the other code in this module makes sure to never let that happen.\n     fn from_int(x: u64) -> Self;\n \n-    /// Get the value 10<sup>e</sup> from a pre-computed table.\n+    /// Gets the value 10<sup>e</sup> from a pre-computed table.\n     /// Panics for `e >= CEIL_LOG5_OF_MAX_SIG`.\n     fn short_fast_pow10(e: usize) -> Self;\n \n@@ -240,7 +240,7 @@ impl RawFloat for f64 {\n     fn from_bits(v: Self::Bits) -> Self { Self::from_bits(v) }\n }\n \n-/// Convert an Fp to the closest machine float type.\n+/// Converts an `Fp` to the closest machine float type.\n /// Does not handle subnormal results.\n pub fn fp_to_float<T: RawFloat>(x: Fp) -> T {\n     let x = x.normalize();\n@@ -319,7 +319,7 @@ pub fn big_to_fp(f: &Big) -> Fp {\n     }\n }\n \n-/// Find the largest floating point number strictly smaller than the argument.\n+/// Finds the largest floating point number strictly smaller than the argument.\n /// Does not handle subnormals, zero, or exponent underflow.\n pub fn prev_float<T: RawFloat>(x: T) -> T {\n     match x.classify() {"}, {"sha": "dc0580764acb74838221593997cb5a194337c153", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -144,7 +144,7 @@ pub mod consts {\n #[lang = \"f32\"]\n #[cfg(not(test))]\n impl f32 {\n-    /// Returns `true` if this value is `NaN` and false otherwise.\n+    /// Returns `true` if this value is `NaN`.\n     ///\n     /// ```\n     /// use std::f32;\n@@ -169,8 +169,8 @@ impl f32 {\n         f32::from_bits(self.to_bits() & 0x7fff_ffff)\n     }\n \n-    /// Returns `true` if this value is positive infinity or negative infinity and\n-    /// false otherwise.\n+    /// Returns `true` if this value is positive infinity or negative infinity, and\n+    /// `false` otherwise.\n     ///\n     /// ```\n     /// use std::f32;\n@@ -272,7 +272,7 @@ impl f32 {\n         }\n     }\n \n-    /// Returns `true` if and only if `self` has a positive sign, including `+0.0`, `NaN`s with\n+    /// Returns `true` if `self` has a positive sign, including `+0.0`, `NaN`s with\n     /// positive sign bit and positive infinity.\n     ///\n     /// ```\n@@ -288,7 +288,7 @@ impl f32 {\n         !self.is_sign_negative()\n     }\n \n-    /// Returns `true` if and only if `self` has a negative sign, including `-0.0`, `NaN`s with\n+    /// Returns `true` if `self` has a negative sign, including `-0.0`, `NaN`s with\n     /// negative sign bit and negative infinity.\n     ///\n     /// ```"}, {"sha": "c3677f8c8faea466532e864c1d68110fff0ffc3c", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -144,7 +144,7 @@ pub mod consts {\n #[lang = \"f64\"]\n #[cfg(not(test))]\n impl f64 {\n-    /// Returns `true` if this value is `NaN` and false otherwise.\n+    /// Returns `true` if this value is `NaN`.\n     ///\n     /// ```\n     /// use std::f64;\n@@ -169,8 +169,8 @@ impl f64 {\n         f64::from_bits(self.to_bits() & 0x7fff_ffff_ffff_ffff)\n     }\n \n-    /// Returns `true` if this value is positive infinity or negative infinity and\n-    /// false otherwise.\n+    /// Returns `true` if this value is positive infinity or negative infinity, and\n+    /// `false` otherwise.\n     ///\n     /// ```\n     /// use std::f64;\n@@ -272,7 +272,7 @@ impl f64 {\n         }\n     }\n \n-    /// Returns `true` if and only if `self` has a positive sign, including `+0.0`, `NaN`s with\n+    /// Returns `true` if `self` has a positive sign, including `+0.0`, `NaN`s with\n     /// positive sign bit and positive infinity.\n     ///\n     /// ```\n@@ -296,7 +296,7 @@ impl f64 {\n         self.is_sign_positive()\n     }\n \n-    /// Returns `true` if and only if `self` has a negative sign, including `-0.0`, `NaN`s with\n+    /// Returns `true` if `self` has a negative sign, including `-0.0`, `NaN`s with\n     /// negative sign bit and negative infinity.\n     ///\n     /// ```"}, {"sha": "6fb67ea9c9acbf7536caccc37ca7282618b8ddd5", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 97, "deletions": 22, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -52,7 +52,7 @@ assert_eq!(size_of::<Option<core::num::\", stringify!($Ty), \">>(), size_of::<\", s\n             }\n \n             impl $Ty {\n-                /// Create a non-zero without checking the value.\n+                /// Creates a non-zero without checking the value.\n                 ///\n                 /// # Safety\n                 ///\n@@ -63,7 +63,7 @@ assert_eq!(size_of::<Option<core::num::\", stringify!($Ty), \">>(), size_of::<\", s\n                     $Ty(n)\n                 }\n \n-                /// Create a non-zero if the given value is not zero.\n+                /// Creates a non-zero if the given value is not zero.\n                 #[$stability]\n                 #[inline]\n                 pub fn new(n: $Int) -> Option<Self> {\n@@ -882,17 +882,38 @@ $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n+            #[cfg(stage0)]\n             pub fn saturating_add(self, rhs: Self) -> Self {\n-                #[cfg(stage0)]\n                 match self.checked_add(rhs) {\n                     Some(x) => x,\n                     None if rhs >= 0 => Self::max_value(),\n                     None => Self::min_value(),\n                 }\n-                #[cfg(not(stage0))]\n-                {\n-                    intrinsics::saturating_add(self, rhs)\n-                }\n+            }\n+\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Saturating integer addition. Computes `self + rhs`, saturating at the numeric\n+bounds instead of overflowing.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\n+assert_eq!(\", stringify!($SelfT), \"::max_value().saturating_add(100), \", stringify!($SelfT),\n+\"::max_value());\",\n+$EndFeature, \"\n+```\"),\n+\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_saturating_int_methods\")]\n+            #[inline]\n+            #[cfg(not(stage0))]\n+            pub const fn saturating_add(self, rhs: Self) -> Self {\n+                intrinsics::saturating_add(self, rhs)\n             }\n         }\n \n@@ -912,17 +933,36 @@ $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n+            #[cfg(stage0)]\n             pub fn saturating_sub(self, rhs: Self) -> Self {\n-                #[cfg(stage0)]\n                 match self.checked_sub(rhs) {\n                     Some(x) => x,\n                     None if rhs >= 0 => Self::min_value(),\n                     None => Self::max_value(),\n                 }\n-                #[cfg(not(stage0))]\n-                {\n-                    intrinsics::saturating_sub(self, rhs)\n-                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Saturating integer subtraction. Computes `self - rhs`, saturating at the\n+numeric bounds instead of overflowing.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".saturating_sub(127), -27);\n+assert_eq!(\", stringify!($SelfT), \"::min_value().saturating_sub(100), \", stringify!($SelfT),\n+\"::min_value());\",\n+$EndFeature, \"\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_saturating_int_methods\")]\n+            #[inline]\n+            #[cfg(not(stage0))]\n+            pub const fn saturating_sub(self, rhs: Self) -> Self {\n+                intrinsics::saturating_sub(self, rhs)\n             }\n         }\n \n@@ -2753,16 +2793,34 @@ assert_eq!(200u8.saturating_add(127), 255);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n+            #[cfg(stage0)]\n             pub fn saturating_add(self, rhs: Self) -> Self {\n-                #[cfg(stage0)]\n                 match self.checked_add(rhs) {\n                     Some(x) => x,\n                     None => Self::max_value(),\n                 }\n-                #[cfg(not(stage0))]\n-                {\n-                    intrinsics::saturating_add(self, rhs)\n-                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Saturating integer addition. Computes `self + rhs`, saturating at\n+the numeric bounds instead of overflowing.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\n+assert_eq!(200u8.saturating_add(127), 255);\", $EndFeature, \"\n+```\"),\n+\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_saturating_int_methods\")]\n+            #[inline]\n+            #[cfg(not(stage0))]\n+            pub const fn saturating_add(self, rhs: Self) -> Self {\n+                intrinsics::saturating_add(self, rhs)\n             }\n         }\n \n@@ -2780,16 +2838,33 @@ assert_eq!(13\", stringify!($SelfT), \".saturating_sub(127), 0);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n+            #[cfg(stage0)]\n             pub fn saturating_sub(self, rhs: Self) -> Self {\n-                #[cfg(stage0)]\n                 match self.checked_sub(rhs) {\n                     Some(x) => x,\n                     None => Self::min_value(),\n                 }\n-                #[cfg(not(stage0))]\n-                {\n-                    intrinsics::saturating_sub(self, rhs)\n-                }\n+            }\n+        }\n+\n+        doc_comment! {\n+            concat!(\"Saturating integer subtraction. Computes `self - rhs`, saturating\n+at the numeric bounds instead of overflowing.\n+\n+# Examples\n+\n+Basic usage:\n+\n+```\n+\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".saturating_sub(27), 73);\n+assert_eq!(13\", stringify!($SelfT), \".saturating_sub(127), 0);\", $EndFeature, \"\n+```\"),\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_saturating_int_methods\")]\n+            #[inline]\n+            #[cfg(not(stage0))]\n+            pub const fn saturating_sub(self, rhs: Self) -> Self {\n+                intrinsics::saturating_sub(self, rhs)\n             }\n         }\n "}, {"sha": "0252edee231254a0afe3e0786e3701cd5cfb5669", "filename": "src/libcore/ops/arith.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fops%2Farith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fops%2Farith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Farith.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -49,7 +49,7 @@\n /// }\n ///\n /// // Notice that the implementation uses the associated type `Output`.\n-/// impl<T: Add<Output=T>> Add for Point<T> {\n+/// impl<T: Add<Output = T>> Add for Point<T> {\n ///     type Output = Point<T>;\n ///\n ///     fn add(self, other: Point<T>) -> Point<T> {\n@@ -157,7 +157,7 @@ add_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n /// }\n ///\n /// // Notice that the implementation uses the associated type `Output`.\n-/// impl<T: Sub<Output=T>> Sub for Point<T> {\n+/// impl<T: Sub<Output = T>> Sub for Point<T> {\n ///     type Output = Point<T>;\n ///\n ///     fn sub(self, other: Point<T>) -> Point<T> {\n@@ -518,7 +518,7 @@ pub trait Rem<RHS=Self> {\n \n macro_rules! rem_impl_integer {\n     ($($t:ty)*) => ($(\n-        /// This operation satisfies `n % d == n - (n / d) * d`.  The\n+        /// This operation satisfies `n % d == n - (n / d) * d`. The\n         /// result has the same sign as the left operand.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Rem for $t {"}, {"sha": "c69f5fd989696d5d1d3f50b15ec9a1aed8b36163", "filename": "src/libcore/ops/function.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fops%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fops%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ffunction.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -62,7 +62,7 @@\n     label=\"expected an `Fn<{Args}>` closure, found `{Self}`\",\n )]\n #[fundamental] // so that regex can rely that `&str: !FnMut`\n-#[must_use]\n+#[must_use = \"closures are lazy and do nothing unless called\"]\n pub trait Fn<Args> : FnMut<Args> {\n     /// Performs the call operation.\n     #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n@@ -141,7 +141,7 @@ pub trait Fn<Args> : FnMut<Args> {\n     label=\"expected an `FnMut<{Args}>` closure, found `{Self}`\",\n )]\n #[fundamental] // so that regex can rely that `&str: !FnMut`\n-#[must_use]\n+#[must_use = \"closures are lazy and do nothing unless called\"]\n pub trait FnMut<Args> : FnOnce<Args> {\n     /// Performs the call operation.\n     #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n@@ -220,7 +220,7 @@ pub trait FnMut<Args> : FnOnce<Args> {\n     label=\"expected an `FnOnce<{Args}>` closure, found `{Self}`\",\n )]\n #[fundamental] // so that regex can rely that `&str: !FnMut`\n-#[must_use]\n+#[must_use = \"closures are lazy and do nothing unless called\"]\n pub trait FnOnce<Args> {\n     /// The returned type after the call operator is used.\n     #[stable(feature = \"fn_once_output\", since = \"1.12.0\")]"}, {"sha": "b3dd5d20299c1706ec50582ca7f1cf8180b64d86", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -52,7 +52,7 @@ impl fmt::Debug for RangeFull {\n /// (`start..end`).\n ///\n /// The `Range` `start..end` contains all values with `x >= start` and\n-/// `x < end`.  It is empty unless `start < end`.\n+/// `x < end`. It is empty unless `start < end`.\n ///\n /// # Examples\n ///\n@@ -297,7 +297,7 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n /// A range bounded inclusively below and above (`start..=end`).\n ///\n /// The `RangeInclusive` `start..=end` contains all values with `x >= start`\n-/// and `x <= end`.  It is empty unless `start <= end`.\n+/// and `x <= end`. It is empty unless `start <= end`.\n ///\n /// This iterator is [fused], but the specific values of `start` and `end` after\n /// iteration has finished are **unspecified** other than that [`.is_empty()`]"}, {"sha": "9fa2c81954ee16a8ffc4a31bf6cd4f94f525f15f", "filename": "src/libcore/ops/try.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fops%2Ftry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fops%2Ftry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ftry.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,7 +1,7 @@\n /// A trait for customizing the behavior of the `?` operator.\n ///\n /// A type implementing `Try` is one that has a canonical way to view it\n-/// in terms of a success/failure dichotomy.  This trait allows both\n+/// in terms of a success/failure dichotomy. This trait allows both\n /// extracting those success or failure values from an existing instance and\n /// creating a new instance from a success or failure value.\n #[unstable(feature = \"try_trait\", issue = \"42327\")]"}, {"sha": "76ef36ac30962d19dfef4a5792f742b03ee0bbb5", "filename": "src/libcore/option.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -214,7 +214,7 @@ impl<T> Option<T> {\n     ///\n     /// # Examples\n     ///\n-    /// Convert an `Option<`[`String`]`>` into an `Option<`[`usize`]`>`, preserving the original.\n+    /// Converts an `Option<`[`String`]`>` into an `Option<`[`usize`]`>`, preserving the original.\n     /// The [`map`] method takes the `self` argument by value, consuming the original,\n     /// so this technique uses `as_ref` to first take an `Option` to a reference\n     /// to the value inside the original.\n@@ -395,7 +395,7 @@ impl<T> Option<T> {\n     ///\n     /// # Examples\n     ///\n-    /// Convert an `Option<`[`String`]`>` into an `Option<`[`usize`]`>`, consuming the original:\n+    /// Converts an `Option<`[`String`]`>` into an `Option<`[`usize`]`>`, consuming the original:\n     ///\n     /// [`String`]: ../../std/string/struct.String.html\n     /// [`usize`]: ../../std/primitive.usize.html\n@@ -963,7 +963,7 @@ impl<T: Default> Option<T> {\n     ///\n     /// # Examples\n     ///\n-    /// Convert a string to an integer, turning poorly-formed strings\n+    /// Converts a string to an integer, turning poorly-formed strings\n     /// into 0 (the default value for integers). [`parse`] converts\n     /// a string to any other type that implements [`FromStr`], returning\n     /// [`None`] on error."}, {"sha": "ee9098d73ee92ff8ad2933dbfd7ea0a5c91e9602", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -199,7 +199,7 @@ impl<P: Deref> Pin<P> {\n         Pin { pointer }\n     }\n \n-    /// Get a pinned shared reference from this pinned pointer.\n+    /// Gets a pinned shared reference from this pinned pointer.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n     pub fn as_ref(self: &Pin<P>) -> Pin<&P::Target> {\n@@ -208,7 +208,7 @@ impl<P: Deref> Pin<P> {\n }\n \n impl<P: DerefMut> Pin<P> {\n-    /// Get a pinned mutable reference from this pinned pointer.\n+    /// Gets a pinned mutable reference from this pinned pointer.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n     pub fn as_mut(self: &mut Pin<P>) -> Pin<&mut P::Target> {\n@@ -247,7 +247,7 @@ impl<'a, T: ?Sized> Pin<&'a T> {\n         Pin::new_unchecked(new_pointer)\n     }\n \n-    /// Get a shared reference out of a pin.\n+    /// Gets a shared reference out of a pin.\n     ///\n     /// Note: `Pin` also implements `Deref` to the target, which can be used\n     /// to access the inner value. However, `Deref` only provides a reference\n@@ -262,14 +262,14 @@ impl<'a, T: ?Sized> Pin<&'a T> {\n }\n \n impl<'a, T: ?Sized> Pin<&'a mut T> {\n-    /// Convert this `Pin<&mut T>` into a `Pin<&T>` with the same lifetime.\n+    /// Converts this `Pin<&mut T>` into a `Pin<&T>` with the same lifetime.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n     pub fn into_ref(self: Pin<&'a mut T>) -> Pin<&'a T> {\n         Pin { pointer: self.pointer }\n     }\n \n-    /// Get a mutable reference to the data inside of this `Pin`.\n+    /// Gets a mutable reference to the data inside of this `Pin`.\n     ///\n     /// This requires that the data inside this `Pin` is `Unpin`.\n     ///\n@@ -286,7 +286,7 @@ impl<'a, T: ?Sized> Pin<&'a mut T> {\n         self.pointer\n     }\n \n-    /// Get a mutable reference to the data inside of this `Pin`.\n+    /// Gets a mutable reference to the data inside of this `Pin`.\n     ///\n     /// # Safety\n     ///"}, {"sha": "866c8d0896b3c637a714d13dd8f4106b115ae98b", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -12,7 +12,7 @@\n //! to access only a single value, in which case the documentation omits the size\n //! and implicitly assumes it to be `size_of::<T>()` bytes.\n //!\n-//! The precise rules for validity are not determined yet.  The guarantees that are\n+//! The precise rules for validity are not determined yet. The guarantees that are\n //! provided at this point are very minimal:\n //!\n //! * A [null] pointer is *never* valid, not even for accesses of [size zero][zst].\n@@ -104,7 +104,7 @@ pub use intrinsics::write_bytes;\n ///\n /// * `to_drop` must be [valid] for reads.\n ///\n-/// * `to_drop` must be properly aligned.  See the example below for how to drop\n+/// * `to_drop` must be properly aligned. See the example below for how to drop\n ///   an unaligned pointer.\n ///\n /// Additionally, if `T` is not [`Copy`], using the pointed-to value after\n@@ -135,7 +135,7 @@ pub use intrinsics::write_bytes;\n /// unsafe {\n ///     // Get a raw pointer to the last element in `v`.\n ///     let ptr = &mut v[1] as *mut _;\n-///     // Shorten `v` to prevent the last item from being dropped.  We do that first,\n+///     // Shorten `v` to prevent the last item from being dropped. We do that first,\n ///     // to prevent issues if the `drop_in_place` below panics.\n ///     v.set_len(1);\n ///     // Without a call `drop_in_place`, the last item would never be dropped,\n@@ -531,7 +531,7 @@ pub unsafe fn replace<T>(dst: *mut T, mut src: T) -> T {\n ///\n /// `read` creates a bitwise copy of `T`, regardless of whether `T` is [`Copy`].\n /// If `T` is not [`Copy`], using both the returned value and the value at\n-/// `*src` can violate memory safety.  Note that assigning to `*src` counts as a\n+/// `*src` can violate memory safety. Note that assigning to `*src` counts as a\n /// use because it will attempt to drop the value at `*src`.\n ///\n /// [`write`] can be used to overwrite data without causing it to be dropped.\n@@ -573,7 +573,7 @@ pub unsafe fn replace<T>(dst: *mut T, mut src: T) -> T {\n pub unsafe fn read<T>(src: *const T) -> T {\n     let mut tmp = MaybeUninit::<T>::uninitialized();\n     copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n-    tmp.into_inner()\n+    tmp.into_initialized()\n }\n \n /// Reads the value from `src` without moving it. This leaves the\n@@ -588,7 +588,7 @@ pub unsafe fn read<T>(src: *const T) -> T {\n /// * `src` must be [valid] for reads.\n ///\n /// Like [`read`], `read_unaligned` creates a bitwise copy of `T`, regardless of\n-/// whether `T` is [`Copy`].  If `T` is not [`Copy`], using both the returned\n+/// whether `T` is [`Copy`]. If `T` is not [`Copy`], using both the returned\n /// value and the value at `*src` can [violate memory safety][read-ownership].\n ///\n /// Note that even if `T` has size `0`, the pointer must be non-NULL.\n@@ -642,7 +642,7 @@ pub unsafe fn read_unaligned<T>(src: *const T) -> T {\n     copy_nonoverlapping(src as *const u8,\n                         tmp.as_mut_ptr() as *mut u8,\n                         mem::size_of::<T>());\n-    tmp.into_inner()\n+    tmp.into_initialized()\n }\n \n /// Overwrites a memory location with the given value without reading or\n@@ -825,7 +825,7 @@ pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n ///\n /// The compiler shouldn't change the relative order or number of volatile\n /// memory operations. However, volatile memory operations on zero-sized types\n-/// (e.g., if a zero-sized type is passed to `read_volatile`) are no-ops\n+/// (e.g., if a zero-sized type is passed to `read_volatile`) are noops\n /// and may be ignored.\n ///\n /// [c11]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\n@@ -839,7 +839,7 @@ pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n /// * `src` must be properly aligned.\n ///\n /// Like [`read`], `read_unaligned` creates a bitwise copy of `T`, regardless of\n-/// whether `T` is [`Copy`].  If `T` is not [`Copy`], using both the returned\n+/// whether `T` is [`Copy`]. If `T` is not [`Copy`], using both the returned\n /// value and the value at `*src` can [violate memory safety][read-ownership].\n /// However, storing non-[`Copy`] types in volatile memory is almost certainly\n /// incorrect.\n@@ -903,7 +903,7 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n ///\n /// The compiler shouldn't change the relative order or number of volatile\n /// memory operations. However, volatile memory operations on zero-sized types\n-/// (e.g., if a zero-sized type is passed to `write_volatile`) are no-ops\n+/// (e.g., if a zero-sized type is passed to `write_volatile`) are noops\n /// and may be ignored.\n ///\n /// [c11]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\n@@ -1093,7 +1093,7 @@ impl<T: ?Sized> *const T {\n     /// unless `x` and `y` point into the same allocated object.\n     ///\n     /// Always use `.offset(count)` instead when possible, because `offset`\n-    /// allows the compiler to optimize better.  If you need to cross object\n+    /// allows the compiler to optimize better. If you need to cross object\n     /// boundaries, cast the pointer to an integer and do the arithmetic there.\n     ///\n     /// # Examples\n@@ -1712,7 +1712,7 @@ impl<T: ?Sized> *mut T {\n     /// unless `x` and `y` point into the same allocated object.\n     ///\n     /// Always use `.offset(count)` instead when possible, because `offset`\n-    /// allows the compiler to optimize better.  If you need to cross object\n+    /// allows the compiler to optimize better. If you need to cross object\n     /// boundaries, cast the pointer to an integer and do the arithmetic there.\n     ///\n     /// # Examples\n@@ -2473,7 +2473,7 @@ impl<T: ?Sized> PartialEq for *mut T {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Eq for *mut T {}\n \n-/// Compare raw pointers for equality.\n+/// Compares raw pointers for equality.\n ///\n /// This is the same as using the `==` operator, but less generic:\n /// the arguments have to be `*const T` raw pointers,"}, {"sha": "92d29f6ee8a30c83ba9ec50c9cbf7983c61fc22b", "filename": "src/libcore/result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -896,7 +896,7 @@ impl<T: Default, E> Result<T, E> {\n     ///\n     /// # Examples\n     ///\n-    /// Convert a string to an integer, turning poorly-formed strings\n+    /// Converts a string to an integer, turning poorly-formed strings\n     /// into 0 (the default value for integers). [`parse`] converts\n     /// a string to any other type that implements [`FromStr`], returning an\n     /// [`Err`] on error."}, {"sha": "cbba546b8dabad1137a3cc235c199cad5a424faa", "filename": "src/libcore/slice/memchr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fslice%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fslice%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmemchr.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -11,7 +11,7 @@ const HI_U64: u64 = 0x8080808080808080;\n const LO_USIZE: usize = LO_U64 as usize;\n const HI_USIZE: usize = HI_U64 as usize;\n \n-/// Returns whether `x` contains any zero byte.\n+/// Returns `true` if `x` contains any zero byte.\n ///\n /// From *Matters Computational*, J. Arndt:\n ///"}, {"sha": "a628fd0cfa4b2a1831e261776cc073b36a8692c5", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1197,7 +1197,7 @@ impl<T> [T] {\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred` limited to returning at most `n` items. This starts at the end of\n-    /// the slice and works backwards.  The matched element is not contained in\n+    /// the slice and works backwards. The matched element is not contained in\n     /// the subslices.\n     ///\n     /// The last element returned, if any, will contain the remainder of the\n@@ -1563,6 +1563,10 @@ impl<T> [T] {\n     /// randomization to avoid degenerate cases, but with a fixed seed to always provide\n     /// deterministic behavior.\n     ///\n+    /// Due to its key calling strategy, [`sort_unstable_by_key`](#method.sort_unstable_by_key)\n+    /// is likely to be slower than [`sort_by_cached_key`](#method.sort_by_cached_key) in\n+    /// cases where the key function is expensive.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -3145,7 +3149,7 @@ unsafe impl<T: Sync> Sync for Iter<'_, T> {}\n unsafe impl<T: Sync> Send for Iter<'_, T> {}\n \n impl<'a, T> Iter<'a, T> {\n-    /// View the underlying data as a subslice of the original data.\n+    /// Views the underlying data as a subslice of the original data.\n     ///\n     /// This has the same lifetime as the original slice, and so the\n     /// iterator can continue to be used while this exists.\n@@ -3247,7 +3251,7 @@ unsafe impl<T: Sync> Sync for IterMut<'_, T> {}\n unsafe impl<T: Send> Send for IterMut<'_, T> {}\n \n impl<'a, T> IterMut<'a, T> {\n-    /// View the underlying data as a subslice of the original data.\n+    /// Views the underlying data as a subslice of the original data.\n     ///\n     /// To avoid creating `&mut` references that alias, this is forced\n     /// to consume the iterator.\n@@ -4123,7 +4127,7 @@ pub struct ChunksExact<'a, T:'a> {\n }\n \n impl<'a, T> ChunksExact<'a, T> {\n-    /// Return the remainder of the original slice that is not going to be\n+    /// Returns the remainder of the original slice that is not going to be\n     /// returned by the iterator. The returned slice has at most `chunk_size-1`\n     /// elements.\n     #[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n@@ -4247,7 +4251,7 @@ pub struct ChunksExactMut<'a, T:'a> {\n }\n \n impl<'a, T> ChunksExactMut<'a, T> {\n-    /// Return the remainder of the original slice that is not going to be\n+    /// Returns the remainder of the original slice that is not going to be\n     /// returned by the iterator. The returned slice has at most `chunk_size-1`\n     /// elements.\n     #[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n@@ -4619,7 +4623,7 @@ pub struct RChunksExact<'a, T:'a> {\n }\n \n impl<'a, T> RChunksExact<'a, T> {\n-    /// Return the remainder of the original slice that is not going to be\n+    /// Returns the remainder of the original slice that is not going to be\n     /// returned by the iterator. The returned slice has at most `chunk_size-1`\n     /// elements.\n     #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n@@ -4744,7 +4748,7 @@ pub struct RChunksExactMut<'a, T:'a> {\n }\n \n impl<'a, T> RChunksExactMut<'a, T> {\n-    /// Return the remainder of the original slice that is not going to be\n+    /// Returns the remainder of the original slice that is not going to be\n     /// returned by the iterator. The returned slice has at most `chunk_size-1`\n     /// elements.\n     #[stable(feature = \"rchunks\", since = \"1.31.0\")]"}, {"sha": "9b35b51349a02612de93e6f276f6316a1ab7cfcf", "filename": "src/libcore/slice/rotate.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fslice%2Frotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fslice%2Frotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Frotate.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -26,7 +26,7 @@ impl<T> RawArray<T> {\n }\n \n /// Rotates the range `[mid-left, mid+right)` such that the element at `mid`\n-/// becomes the first element.  Equivalently, rotates the range `left`\n+/// becomes the first element. Equivalently, rotates the range `left`\n /// elements to the left or `right` elements to the right.\n ///\n /// # Safety\n@@ -36,10 +36,10 @@ impl<T> RawArray<T> {\n /// # Algorithm\n ///\n /// For longer rotations, swap the left-most `delta = min(left, right)`\n-/// elements with the right-most `delta` elements.  LLVM vectorizes this,\n+/// elements with the right-most `delta` elements. LLVM vectorizes this,\n /// which is profitable as we only reach this step for a \"large enough\"\n-/// rotation.  Doing this puts `delta` elements on the larger side into the\n-/// correct position, leaving a smaller rotate problem.  Demonstration:\n+/// rotation. Doing this puts `delta` elements on the larger side into the\n+/// correct position, leaving a smaller rotate problem. Demonstration:\n ///\n /// ```text\n /// [ 6 7 8 9 10 11 12 13 . 1 2 3 4 5 ]"}, {"sha": "76a45e53684bd93b723f263ba1224623fcc74ceb", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 297, "deletions": 152, "changes": 449, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,17 +1,20 @@\n-//! String manipulation\n+//! String manipulation.\n //!\n-//! For more details, see std::str\n+//! For more details, see the `std::str` module.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use self::pattern::Pattern;\n use self::pattern::{Searcher, ReverseSearcher, DoubleEndedSearcher};\n \n use char;\n-use fmt;\n+use fmt::{self, Write};\n use iter::{Map, Cloned, FusedIterator, TrustedLen, TrustedRandomAccess, Filter};\n+use iter::{Flatten, FlatMap, Chain};\n use slice::{self, SliceIndex, Split as SliceSplit};\n use mem;\n+use ops::Try;\n+use option;\n \n pub mod pattern;\n \n@@ -226,7 +229,7 @@ impl Utf8Error {\n     #[stable(feature = \"utf8_error\", since = \"1.5.0\")]\n     pub fn valid_up_to(&self) -> usize { self.valid_up_to }\n \n-    /// Provide more information about the failure:\n+    /// Provides more information about the failure:\n     ///\n     /// * `None`: the end of the input was reached unexpectedly.\n     ///   `self.valid_up_to()` is 1 to 3 bytes from the end of the input.\n@@ -612,7 +615,7 @@ impl<'a> DoubleEndedIterator for Chars<'a> {\n impl FusedIterator for Chars<'_> {}\n \n impl<'a> Chars<'a> {\n-    /// View the underlying data as a subslice of the original data.\n+    /// Views the underlying data as a subslice of the original data.\n     ///\n     /// This has the same lifetime as the original slice, and so the\n     /// iterator can continue to be used while this exists.\n@@ -702,7 +705,7 @@ impl<'a> DoubleEndedIterator for CharIndices<'a> {\n impl FusedIterator for CharIndices<'_> {}\n \n impl<'a> CharIndices<'a> {\n-    /// View the underlying data as a subslice of the original data.\n+    /// Views the underlying data as a subslice of the original data.\n     ///\n     /// This has the same lifetime as the original slice, and so the\n     /// iterator can continue to be used while this exists.\n@@ -1345,33 +1348,14 @@ impl FusedIterator for Lines<'_> {}\n #[allow(deprecated)]\n pub struct LinesAny<'a>(Lines<'a>);\n \n-/// A nameable, cloneable fn type\n-#[derive(Clone)]\n-struct LinesAnyMap;\n-\n-impl<'a> Fn<(&'a str,)> for LinesAnyMap {\n-    #[inline]\n-    extern \"rust-call\" fn call(&self, (line,): (&'a str,)) -> &'a str {\n+impl_fn_for_zst! {\n+    /// A nameable, cloneable fn type\n+    #[derive(Clone)]\n+    struct LinesAnyMap impl<'a> Fn = |line: &'a str| -> &'a str {\n         let l = line.len();\n         if l > 0 && line.as_bytes()[l - 1] == b'\\r' { &line[0 .. l - 1] }\n         else { line }\n-    }\n-}\n-\n-impl<'a> FnMut<(&'a str,)> for LinesAnyMap {\n-    #[inline]\n-    extern \"rust-call\" fn call_mut(&mut self, (line,): (&'a str,)) -> &'a str {\n-        Fn::call(&*self, (line,))\n-    }\n-}\n-\n-impl<'a> FnOnce<(&'a str,)> for LinesAnyMap {\n-    type Output = &'a str;\n-\n-    #[inline]\n-    extern \"rust-call\" fn call_once(self, (line,): (&'a str,)) -> &'a str {\n-        Fn::call(&self, (line,))\n-    }\n+    };\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1579,9 +1563,9 @@ mod traits {\n \n     /// Implements ordering of strings.\n     ///\n-    /// Strings are ordered  lexicographically by their byte values.  This orders Unicode code\n-    /// points based on their positions in the code charts.  This is not necessarily the same as\n-    /// \"alphabetical\" order, which varies by language and locale.  Sorting strings according to\n+    /// Strings are ordered  lexicographically by their byte values. This orders Unicode code\n+    /// points based on their positions in the code charts. This is not necessarily the same as\n+    /// \"alphabetical\" order, which varies by language and locale. Sorting strings according to\n     /// culturally-accepted standards requires locale-specific data that is outside the scope of\n     /// the `str` type.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1607,9 +1591,9 @@ mod traits {\n \n     /// Implements comparison operations on strings.\n     ///\n-    /// Strings are compared lexicographically by their byte values.  This compares Unicode code\n-    /// points based on their positions in the code charts.  This is not necessarily the same as\n-    /// \"alphabetical\" order, which varies by language and locale.  Comparing strings according to\n+    /// Strings are compared lexicographically by their byte values. This compares Unicode code\n+    /// points based on their positions in the code charts. This is not necessarily the same as\n+    /// \"alphabetical\" order, which varies by language and locale. Comparing strings according to\n     /// culturally-accepted standards requires locale-specific data that is outside the scope of\n     /// the `str` type.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1757,9 +1741,9 @@ mod traits {\n         }\n         #[inline]\n         unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n-            let ptr = slice.as_ptr().add(self.start);\n+            let ptr = slice.as_mut_ptr().add(self.start);\n             let len = self.end - self.start;\n-            super::from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr as *mut u8, len))\n+            super::from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr, len))\n         }\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n@@ -1821,8 +1805,8 @@ mod traits {\n         }\n         #[inline]\n         unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n-            let ptr = slice.as_ptr();\n-            super::from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr as *mut u8, self.end))\n+            let ptr = slice.as_mut_ptr();\n+            super::from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr, self.end))\n         }\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n@@ -1883,9 +1867,9 @@ mod traits {\n         }\n         #[inline]\n         unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n-            let ptr = slice.as_ptr().add(self.start);\n+            let ptr = slice.as_mut_ptr().add(self.start);\n             let len = slice.len() - self.start;\n-            super::from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr as *mut u8, len))\n+            super::from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr, len))\n         }\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n@@ -2213,6 +2197,22 @@ impl str {\n         self as *const str as *const u8\n     }\n \n+    /// Converts a mutable string slice to a raw pointer.\n+    ///\n+    /// As string slices are a slice of bytes, the raw pointer points to a\n+    /// [`u8`]. This pointer will be pointing to the first byte of the string\n+    /// slice.\n+    ///\n+    /// It is your responsibility to make sure that the string slice only gets\n+    /// modified in a way that it remains valid UTF-8.\n+    ///\n+    /// [`u8`]: primitive.u8.html\n+    #[unstable(feature = \"str_as_mut_ptr\", issue = \"58215\")]\n+    #[inline]\n+    pub fn as_mut_ptr(&mut self) -> *mut u8 {\n+        self as *mut str as *mut u8\n+    }\n+\n     /// Returns a subslice of `str`.\n     ///\n     /// This is the non-panicking alternative to indexing the `str`. Returns\n@@ -2500,7 +2500,7 @@ impl str {\n         // is_char_boundary checks that the index is in [0, .len()]\n         if self.is_char_boundary(mid) {\n             let len = self.len();\n-            let ptr = self.as_ptr() as *mut u8;\n+            let ptr = self.as_mut_ptr();\n             unsafe {\n                 (from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr, mid)),\n                  from_utf8_unchecked_mut(slice::from_raw_parts_mut(\n@@ -2643,7 +2643,7 @@ impl str {\n         Bytes(self.as_bytes().iter().cloned())\n     }\n \n-    /// Split a string slice by whitespace.\n+    /// Splits a string slice by whitespace.\n     ///\n     /// The iterator returned will return string slices that are sub-slices of\n     /// the original string slice, separated by any amount of whitespace.\n@@ -2686,7 +2686,7 @@ impl str {\n         SplitWhitespace { inner: self.split(IsWhitespace).filter(IsNotEmpty) }\n     }\n \n-    /// Split a string slice by ASCII whitespace.\n+    /// Splits a string slice by ASCII whitespace.\n     ///\n     /// The iterator returned will return string slices that are sub-slices of\n     /// the original string slice, separated by any amount of ASCII whitespace.\n@@ -2727,7 +2727,7 @@ impl str {\n         let inner = self\n             .as_bytes()\n             .split(IsAsciiWhitespace)\n-            .filter(IsNotEmpty)\n+            .filter(BytesIsNotEmpty)\n             .map(UnsafeBytesToStr);\n         SplitAsciiWhitespace { inner }\n     }\n@@ -2961,8 +2961,8 @@ impl str {\n     /// An iterator over substrings of this string slice, separated by\n     /// characters matched by a pattern.\n     ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n-    /// split.\n+    /// The pattern can be any type that implements the Pattern trait. Notable\n+    /// examples are `&str`, [`char`], and closures that determines the split.\n     ///\n     /// # Iterator behavior\n     ///\n@@ -3078,8 +3078,8 @@ impl str {\n     /// An iterator over substrings of the given string slice, separated by\n     /// characters matched by a pattern and yielded in reverse order.\n     ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n-    /// split.\n+    /// The pattern can be any type that implements the Pattern trait. Notable\n+    /// examples are `&str`, [`char`], and closures that determines the split.\n     ///\n     /// # Iterator behavior\n     ///\n@@ -3128,8 +3128,8 @@ impl str {\n     /// An iterator over substrings of the given string slice, separated by\n     /// characters matched by a pattern.\n     ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n-    /// split.\n+    /// The pattern can be any type that implements the Pattern trait. Notable\n+    /// examples are `&str`, [`char`], and closures that determines the split.\n     ///\n     /// Equivalent to [`split`], except that the trailing substring\n     /// is skipped if empty.\n@@ -3175,8 +3175,8 @@ impl str {\n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by a pattern and yielded in reverse order.\n     ///\n-    /// The pattern can be a simple `&str`, [`char`], or a closure that\n-    /// determines the split.\n+    /// The pattern can be any type that implements the Pattern trait. Notable\n+    /// examples are `&str`, [`char`], and closures that determines the split.\n     /// Additional libraries might provide more complex patterns like\n     /// regular expressions.\n     ///\n@@ -3222,8 +3222,8 @@ impl str {\n     /// If `n` substrings are returned, the last substring (the `n`th substring)\n     /// will contain the remainder of the string.\n     ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n-    /// split.\n+    /// The pattern can be any type that implements the Pattern trait. Notable\n+    /// examples are `&str`, [`char`], and closures that determines the split.\n     ///\n     /// # Iterator behavior\n     ///\n@@ -3275,8 +3275,8 @@ impl str {\n     /// If `n` substrings are returned, the last substring (the `n`th substring)\n     /// will contain the remainder of the string.\n     ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that\n-    /// determines the split.\n+    /// The pattern can be any type that implements the Pattern trait. Notable\n+    /// examples are `&str`, [`char`], and closures that determines the split.\n     ///\n     /// # Iterator behavior\n     ///\n@@ -3319,8 +3319,8 @@ impl str {\n     /// An iterator over the disjoint matches of a pattern within the given string\n     /// slice.\n     ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that\n-    /// determines if a character matches.\n+    /// The pattern can be any type that implements the Pattern trait. Notable\n+    /// examples are `&str`, [`char`], and closures that determines the split.\n     ///\n     /// # Iterator behavior\n     ///\n@@ -3504,7 +3504,7 @@ impl str {\n     ///\n     /// A string is a sequence of bytes. `start` in this context means the first\n     /// position of that byte string; for a left-to-right language like English or\n-    /// Russian, this will be left side; and for right-to-left languages like\n+    /// Russian, this will be left side, and for right-to-left languages like\n     /// like Arabic or Hebrew, this will be the right side.\n     ///\n     /// # Examples\n@@ -3541,7 +3541,7 @@ impl str {\n     ///\n     /// A string is a sequence of bytes. `end` in this context means the last\n     /// position of that byte string; for a left-to-right language like English or\n-    /// Russian, this will be right side; and for right-to-left languages like\n+    /// Russian, this will be right side, and for right-to-left languages like\n     /// like Arabic or Hebrew, this will be the left side.\n     ///\n     /// # Examples\n@@ -3787,7 +3787,7 @@ impl str {\n     ///\n     /// A string is a sequence of bytes. `start` in this context means the first\n     /// position of that byte string; for a left-to-right language like English or\n-    /// Russian, this will be left side; and for right-to-left languages like\n+    /// Russian, this will be left side, and for right-to-left languages like\n     /// like Arabic or Hebrew, this will be the right side.\n     ///\n     /// # Examples\n@@ -3819,7 +3819,7 @@ impl str {\n     ///\n     /// A string is a sequence of bytes. `end` in this context means the last\n     /// position of that byte string; for a left-to-right language like English or\n-    /// Russian, this will be right side; and for right-to-left languages like\n+    /// Russian, this will be right side, and for right-to-left languages like\n     /// like Arabic or Hebrew, this will be the left side.\n     ///\n     /// # Examples\n@@ -3964,6 +3964,146 @@ impl str {\n         let me = unsafe { self.as_bytes_mut() };\n         me.make_ascii_lowercase()\n     }\n+\n+    /// Return an iterator that escapes each char in `s` with [`char::escape_debug`].\n+    ///\n+    /// Note: only extended grapheme codepoints that begin the string will be\n+    /// escaped.\n+    ///\n+    /// [`char::escape_debug`]: ../std/primitive.char.html#method.escape_debug\n+    ///\n+    /// # Examples\n+    ///\n+    /// As an iterator:\n+    ///\n+    /// ```\n+    /// for c in \"\u2764\\n!\".escape_debug() {\n+    ///     print!(\"{}\", c);\n+    /// }\n+    /// println!();\n+    /// ```\n+    ///\n+    /// Using `println!` directly:\n+    ///\n+    /// ```\n+    /// println!(\"{}\", \"\u2764\\n!\".escape_debug());\n+    /// ```\n+    ///\n+    ///\n+    /// Both are equivalent to:\n+    ///\n+    /// ```\n+    /// println!(\"\u2764\\\\n!\");\n+    /// ```\n+    ///\n+    /// Using `to_string`:\n+    ///\n+    /// ```\n+    /// assert_eq!(\"\u2764\\n!\".escape_debug().to_string(), \"\u2764\\\\n!\");\n+    /// ```\n+    #[stable(feature = \"str_escape\", since = \"1.34.0\")]\n+    pub fn escape_debug(&self) -> EscapeDebug {\n+        let mut chars = self.chars();\n+        EscapeDebug {\n+            inner: chars.next()\n+                .map(|first| first.escape_debug_ext(true))\n+                .into_iter()\n+                .flatten()\n+                .chain(chars.flat_map(CharEscapeDebugContinue))\n+        }\n+    }\n+\n+    /// Return an iterator that escapes each char in `s` with [`char::escape_default`].\n+    ///\n+    /// [`char::escape_default`]: ../std/primitive.char.html#method.escape_default\n+    ///\n+    /// # Examples\n+    ///\n+    /// As an iterator:\n+    ///\n+    /// ```\n+    /// for c in \"\u2764\\n!\".escape_default() {\n+    ///     print!(\"{}\", c);\n+    /// }\n+    /// println!();\n+    /// ```\n+    ///\n+    /// Using `println!` directly:\n+    ///\n+    /// ```\n+    /// println!(\"{}\", \"\u2764\\n!\".escape_default());\n+    /// ```\n+    ///\n+    ///\n+    /// Both are equivalent to:\n+    ///\n+    /// ```\n+    /// println!(\"\\\\u{{2764}}\\n!\");\n+    /// ```\n+    ///\n+    /// Using `to_string`:\n+    ///\n+    /// ```\n+    /// assert_eq!(\"\u2764\\n!\".escape_default().to_string(), \"\\\\u{2764}\\\\n!\");\n+    /// ```\n+    #[stable(feature = \"str_escape\", since = \"1.34.0\")]\n+    pub fn escape_default(&self) -> EscapeDefault {\n+        EscapeDefault { inner: self.chars().flat_map(CharEscapeDefault) }\n+    }\n+\n+    /// Return an iterator that escapes each char in `s` with [`char::escape_unicode`].\n+    ///\n+    /// [`char::escape_unicode`]: ../std/primitive.char.html#method.escape_unicode\n+    ///\n+    /// # Examples\n+    ///\n+    /// As an iterator:\n+    ///\n+    /// ```\n+    /// for c in \"\u2764\\n!\".escape_unicode() {\n+    ///     print!(\"{}\", c);\n+    /// }\n+    /// println!();\n+    /// ```\n+    ///\n+    /// Using `println!` directly:\n+    ///\n+    /// ```\n+    /// println!(\"{}\", \"\u2764\\n!\".escape_unicode());\n+    /// ```\n+    ///\n+    ///\n+    /// Both are equivalent to:\n+    ///\n+    /// ```\n+    /// println!(\"\\\\u{{2764}}\\\\u{{a}}\\\\u{{21}}\");\n+    /// ```\n+    ///\n+    /// Using `to_string`:\n+    ///\n+    /// ```\n+    /// assert_eq!(\"\u2764\\n!\".escape_unicode().to_string(), \"\\\\u{2764}\\\\u{a}\\\\u{21}\");\n+    /// ```\n+    #[stable(feature = \"str_escape\", since = \"1.34.0\")]\n+    pub fn escape_unicode(&self) -> EscapeUnicode {\n+        EscapeUnicode { inner: self.chars().flat_map(CharEscapeUnicode) }\n+    }\n+}\n+\n+impl_fn_for_zst! {\n+    #[derive(Clone)]\n+    struct CharEscapeDebugContinue impl Fn = |c: char| -> char::EscapeDebug {\n+        c.escape_debug_ext(false)\n+    };\n+\n+    #[derive(Clone)]\n+    struct CharEscapeUnicode impl Fn = |c: char| -> char::EscapeUnicode {\n+        c.escape_unicode()\n+    };\n+    #[derive(Clone)]\n+    struct CharEscapeDefault impl Fn = |c: char| -> char::EscapeDefault {\n+        c.escape_default()\n+    };\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -4011,102 +4151,36 @@ pub struct SplitWhitespace<'a> {\n #[stable(feature = \"split_ascii_whitespace\", since = \"1.34.0\")]\n #[derive(Clone, Debug)]\n pub struct SplitAsciiWhitespace<'a> {\n-    inner: Map<Filter<SliceSplit<'a, u8, IsAsciiWhitespace>, IsNotEmpty>, UnsafeBytesToStr>,\n-}\n-\n-#[derive(Clone)]\n-struct IsWhitespace;\n-\n-impl FnOnce<(char, )> for IsWhitespace {\n-    type Output = bool;\n-\n-    #[inline]\n-    extern \"rust-call\" fn call_once(mut self, arg: (char, )) -> bool {\n-        self.call_mut(arg)\n-    }\n-}\n-\n-impl FnMut<(char, )> for IsWhitespace {\n-    #[inline]\n-    extern \"rust-call\" fn call_mut(&mut self, arg: (char, )) -> bool {\n-        arg.0.is_whitespace()\n-    }\n-}\n-\n-#[derive(Clone)]\n-struct IsAsciiWhitespace;\n-\n-impl<'a> FnOnce<(&'a u8, )> for IsAsciiWhitespace {\n-    type Output = bool;\n-\n-    #[inline]\n-    extern \"rust-call\" fn call_once(mut self, arg: (&u8, )) -> bool {\n-        self.call_mut(arg)\n-    }\n-}\n-\n-impl<'a> FnMut<(&'a u8, )> for IsAsciiWhitespace {\n-    #[inline]\n-    extern \"rust-call\" fn call_mut(&mut self, arg: (&u8, )) -> bool {\n-        arg.0.is_ascii_whitespace()\n-    }\n-}\n-\n-#[derive(Clone)]\n-struct IsNotEmpty;\n-\n-impl<'a, 'b> FnOnce<(&'a &'b str, )> for IsNotEmpty {\n-    type Output = bool;\n-\n-    #[inline]\n-    extern \"rust-call\" fn call_once(mut self, arg: (&'a &'b str, )) -> bool {\n-        self.call_mut(arg)\n-    }\n-}\n-\n-impl<'a, 'b> FnMut<(&'a &'b str, )> for IsNotEmpty {\n-    #[inline]\n-    extern \"rust-call\" fn call_mut(&mut self, arg: (&'a &'b str, )) -> bool {\n-        !arg.0.is_empty()\n-    }\n+    inner: Map<Filter<SliceSplit<'a, u8, IsAsciiWhitespace>, BytesIsNotEmpty>, UnsafeBytesToStr>,\n }\n \n-impl<'a, 'b> FnOnce<(&'a &'b [u8], )> for IsNotEmpty {\n-    type Output = bool;\n-\n-    #[inline]\n-    extern \"rust-call\" fn call_once(mut self, arg: (&'a &'b [u8], )) -> bool {\n-        self.call_mut(arg)\n-    }\n-}\n-\n-impl<'a, 'b> FnMut<(&'a &'b [u8], )> for IsNotEmpty {\n-    #[inline]\n-    extern \"rust-call\" fn call_mut(&mut self, arg: (&'a &'b [u8], )) -> bool {\n-        !arg.0.is_empty()\n-    }\n-}\n+impl_fn_for_zst! {\n+    #[derive(Clone)]\n+    struct IsWhitespace impl Fn = |c: char| -> bool {\n+        c.is_whitespace()\n+    };\n \n-#[derive(Clone)]\n-struct UnsafeBytesToStr;\n+    #[derive(Clone)]\n+    struct IsAsciiWhitespace impl Fn = |byte: &u8| -> bool {\n+        byte.is_ascii_whitespace()\n+    };\n \n-impl<'a> FnOnce<(&'a [u8], )> for UnsafeBytesToStr {\n-    type Output = &'a str;\n+    #[derive(Clone)]\n+    struct IsNotEmpty impl<'a, 'b> Fn = |s: &'a &'b str| -> bool {\n+        !s.is_empty()\n+    };\n \n-    #[inline]\n-    extern \"rust-call\" fn call_once(mut self, arg: (&'a [u8], )) -> &'a str {\n-        self.call_mut(arg)\n-    }\n-}\n+    #[derive(Clone)]\n+    struct BytesIsNotEmpty impl<'a, 'b> Fn = |s: &'a &'b [u8]| -> bool {\n+        !s.is_empty()\n+    };\n \n-impl<'a> FnMut<(&'a [u8], )> for UnsafeBytesToStr {\n-    #[inline]\n-    extern \"rust-call\" fn call_mut(&mut self, arg: (&'a [u8], )) -> &'a str {\n-        unsafe { from_utf8_unchecked(arg.0) }\n-    }\n+    #[derive(Clone)]\n+    struct UnsafeBytesToStr impl<'a> Fn = |bytes: &'a [u8]| -> &'a str {\n+        unsafe { from_utf8_unchecked(bytes) }\n+    };\n }\n \n-\n #[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n impl<'a> Iterator for SplitWhitespace<'a> {\n     type Item = &'a str;\n@@ -4216,3 +4290,74 @@ impl<'a> Iterator for EncodeUtf16<'a> {\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl FusedIterator for EncodeUtf16<'_> {}\n+\n+/// The return type of [`str::escape_debug`].\n+///\n+/// [`str::escape_debug`]: ../../std/primitive.str.html#method.escape_debug\n+#[stable(feature = \"str_escape\", since = \"1.34.0\")]\n+#[derive(Clone, Debug)]\n+pub struct EscapeDebug<'a> {\n+    inner: Chain<\n+        Flatten<option::IntoIter<char::EscapeDebug>>,\n+        FlatMap<Chars<'a>, char::EscapeDebug, CharEscapeDebugContinue>\n+    >,\n+}\n+\n+/// The return type of [`str::escape_default`].\n+///\n+/// [`str::escape_default`]: ../../std/primitive.str.html#method.escape_default\n+#[stable(feature = \"str_escape\", since = \"1.34.0\")]\n+#[derive(Clone, Debug)]\n+pub struct EscapeDefault<'a> {\n+    inner: FlatMap<Chars<'a>, char::EscapeDefault, CharEscapeDefault>,\n+}\n+\n+/// The return type of [`str::escape_unicode`].\n+///\n+/// [`str::escape_unicode`]: ../../std/primitive.str.html#method.escape_unicode\n+#[stable(feature = \"str_escape\", since = \"1.34.0\")]\n+#[derive(Clone, Debug)]\n+pub struct EscapeUnicode<'a> {\n+    inner: FlatMap<Chars<'a>, char::EscapeUnicode, CharEscapeUnicode>,\n+}\n+\n+macro_rules! escape_types_impls {\n+    ($( $Name: ident ),+) => {$(\n+        #[stable(feature = \"str_escape\", since = \"1.34.0\")]\n+        impl<'a> fmt::Display for $Name<'a> {\n+            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                self.clone().try_for_each(|c| f.write_char(c))\n+            }\n+        }\n+\n+        #[stable(feature = \"str_escape\", since = \"1.34.0\")]\n+        impl<'a> Iterator for $Name<'a> {\n+            type Item = char;\n+\n+            #[inline]\n+            fn next(&mut self) -> Option<char> { self.inner.next() }\n+\n+            #[inline]\n+            fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+\n+            #[inline]\n+            fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+                Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+            {\n+                self.inner.try_fold(init, fold)\n+            }\n+\n+            #[inline]\n+            fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+                where Fold: FnMut(Acc, Self::Item) -> Acc,\n+            {\n+                self.inner.fold(init, fold)\n+            }\n+        }\n+\n+        #[stable(feature = \"str_escape\", since = \"1.34.0\")]\n+        impl<'a> FusedIterator for $Name<'a> {}\n+    )+}\n+}\n+\n+escape_types_impls!(EscapeDebug, EscapeDefault, EscapeUnicode);"}, {"sha": "2571780ad0bab11987bd02cff0fb79cdb30ac55a", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,7 +1,7 @@\n //! The string Pattern API.\n //!\n-//! For more details, see the traits `Pattern`, `Searcher`,\n-//! `ReverseSearcher` and `DoubleEndedSearcher`.\n+//! For more details, see the traits [`Pattern`], [`Searcher`],\n+//! [`ReverseSearcher`], and [`DoubleEndedSearcher`].\n \n #![unstable(feature = \"pattern\",\n             reason = \"API not fully fleshed out and ready to be stabilized\",\n@@ -117,7 +117,7 @@ pub unsafe trait Searcher<'a> {\n     /// `[Reject(0, 1), Reject(1, 2), Match(2, 5), Reject(5, 8)]`\n     fn next(&mut self) -> SearchStep;\n \n-    /// Find the next `Match` result. See `next()`\n+    /// Finds the next `Match` result. See `next()`\n     ///\n     /// Unlike next(), there is no guarantee that the returned ranges\n     /// of this and next_reject will overlap. This will return (start_match, end_match),\n@@ -134,7 +134,7 @@ pub unsafe trait Searcher<'a> {\n         }\n     }\n \n-    /// Find the next `Reject` result. See `next()` and `next_match()`\n+    /// Finds the next `Reject` result. See `next()` and `next_match()`\n     ///\n     /// Unlike next(), there is no guarantee that the returned ranges\n     /// of this and next_match will overlap.\n@@ -185,7 +185,7 @@ pub unsafe trait ReverseSearcher<'a>: Searcher<'a> {\n     /// `[Reject(7, 8), Match(4, 7), Reject(1, 4), Reject(0, 1)]`\n     fn next_back(&mut self) -> SearchStep;\n \n-    /// Find the next `Match` result. See `next_back()`\n+    /// Finds the next `Match` result. See `next_back()`\n     #[inline]\n     fn next_match_back(&mut self) -> Option<(usize, usize)>{\n         loop {\n@@ -197,7 +197,7 @@ pub unsafe trait ReverseSearcher<'a>: Searcher<'a> {\n         }\n     }\n \n-    /// Find the next `Reject` result. See `next_back()`\n+    /// Finds the next `Reject` result. See `next_back()`\n     #[inline]\n     fn next_reject_back(&mut self) -> Option<(usize, usize)>{\n         loop {"}, {"sha": "9b8f59811620083edf04be7e8cb1b8795d2d1253", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -8,4 +8,4 @@ mod poll;\n pub use self::poll::Poll;\n \n mod wake;\n-pub use self::wake::{Waker, LocalWaker, UnsafeWake};\n+pub use self::wake::{Waker, RawWaker, RawWakerVTable};"}, {"sha": "c811f96ace3baba30f317458db80230eaca8837e", "filename": "src/libcore/task/poll.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Ftask%2Fpoll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Ftask%2Fpoll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fpoll.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -7,6 +7,7 @@ use result::Result;\n \n /// Indicates whether a value is available or if the current task has been\n /// scheduled to receive a wakeup instead.\n+#[must_use = \"this `Poll` may be a `Pending` variant, which should be handled\"]\n #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]\n pub enum Poll<T> {\n     /// Represents that a value is immediately ready.\n@@ -21,7 +22,7 @@ pub enum Poll<T> {\n }\n \n impl<T> Poll<T> {\n-    /// Change the ready value of this `Poll` with the closure provided\n+    /// Changes the ready value of this `Poll` with the closure provided.\n     pub fn map<U, F>(self, f: F) -> Poll<U>\n         where F: FnOnce(T) -> U\n     {\n@@ -31,7 +32,7 @@ impl<T> Poll<T> {\n         }\n     }\n \n-    /// Returns whether this is `Poll::Ready`\n+    /// Returns `true` if this is `Poll::Ready`\n     #[inline]\n     pub fn is_ready(&self) -> bool {\n         match *self {\n@@ -40,15 +41,15 @@ impl<T> Poll<T> {\n         }\n     }\n \n-    /// Returns whether this is `Poll::Pending`\n+    /// Returns `true` if this is `Poll::Pending`\n     #[inline]\n     pub fn is_pending(&self) -> bool {\n         !self.is_ready()\n     }\n }\n \n impl<T, E> Poll<Result<T, E>> {\n-    /// Change the success value of this `Poll` with the closure provided\n+    /// Changes the success value of this `Poll` with the closure provided.\n     pub fn map_ok<U, F>(self, f: F) -> Poll<Result<U, E>>\n         where F: FnOnce(T) -> U\n     {\n@@ -59,7 +60,7 @@ impl<T, E> Poll<Result<T, E>> {\n         }\n     }\n \n-    /// Change the error value of this `Poll` with the closure provided\n+    /// Changes the error value of this `Poll` with the closure provided.\n     pub fn map_err<U, F>(self, f: F) -> Poll<Result<T, U>>\n         where F: FnOnce(E) -> U\n     {"}, {"sha": "21f0a8cea4168a87667a3aa571545aa92091a4d5", "filename": "src/libcore/task/wake.rs", "status": "modified", "additions": 112, "deletions": 234, "changes": 346, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Ftask%2Fwake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Ftask%2Fwake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fwake.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -4,281 +4,159 @@\n \n use fmt;\n use marker::Unpin;\n-use ptr::NonNull;\n+\n+/// A `RawWaker` allows the implementor of a task executor to create a [`Waker`]\n+/// which provides customized wakeup behavior.\n+///\n+/// [vtable]: https://en.wikipedia.org/wiki/Virtual_method_table\n+///\n+/// It consists of a data pointer and a [virtual function pointer table (vtable)][vtable] that\n+/// customizes the behavior of the `RawWaker`.\n+#[derive(PartialEq, Debug)]\n+pub struct RawWaker {\n+    /// A data pointer, which can be used to store arbitrary data as required\n+    /// by the executor. This could be e.g. a type-erased pointer to an `Arc`\n+    /// that is associated with the task.\n+    /// The value of this field gets passed to all functions that are part of\n+    /// the vtable as the first parameter.\n+    data: *const (),\n+    /// Virtual function pointer table that customizes the behavior of this waker.\n+    vtable: &'static RawWakerVTable,\n+}\n+\n+impl RawWaker {\n+    /// Creates a new `RawWaker` from the provided `data` pointer and `vtable`.\n+    ///\n+    /// The `data` pointer can be used to store arbitrary data as required\n+    /// by the executor. This could be e.g. a type-erased pointer to an `Arc`\n+    /// that is associated with the task.\n+    /// The value of this poiner will get passed to all functions that are part\n+    /// of the `vtable` as the first parameter.\n+    ///\n+    /// The `vtable` customizes the behavior of a `Waker` which gets created\n+    /// from a `RawWaker`. For each operation on the `Waker`, the associated\n+    /// function in the `vtable` of the underlying `RawWaker` will be called.\n+    pub const fn new(data: *const (), vtable: &'static RawWakerVTable) -> RawWaker {\n+        RawWaker {\n+            data,\n+            vtable,\n+        }\n+    }\n+}\n+\n+/// A virtual function pointer table (vtable) that specifies the behavior\n+/// of a [`RawWaker`].\n+///\n+/// The pointer passed to all functions inside the vtable is the `data` pointer\n+/// from the enclosing [`RawWaker`] object.\n+///\n+/// The functions inside this struct are only intended be called on the `data`\n+/// pointer of a properly constructed [`RawWaker`] object from inside the\n+/// [`RawWaker`] implementation. Calling one of the contained functions using\n+/// any other `data` pointer will cause undefined behavior.\n+#[derive(PartialEq, Copy, Clone, Debug)]\n+pub struct RawWakerVTable {\n+    /// This function will be called when the [`RawWaker`] gets cloned, e.g. when\n+    /// the [`Waker`] in which the [`RawWaker`] is stored gets cloned.\n+    ///\n+    /// The implementation of this function must retain all resources that are\n+    /// required for this additional instance of a [`RawWaker`] and associated\n+    /// task. Calling `wake` on the resulting [`RawWaker`] should result in a wakeup\n+    /// of the same task that would have been awoken by the original [`RawWaker`].\n+    pub clone: unsafe fn(*const ()) -> RawWaker,\n+\n+    /// This function will be called when `wake` is called on the [`Waker`].\n+    /// It must wake up the task associated with this [`RawWaker`].\n+    ///\n+    /// The implemention of this function must not consume the provided data\n+    /// pointer.\n+    pub wake: unsafe fn(*const ()),\n+\n+    /// This function gets called when a [`RawWaker`] gets dropped.\n+    ///\n+    /// The implementation of this function must make sure to release any\n+    /// resources that are associated with this instance of a [`RawWaker`] and\n+    /// associated task.\n+    pub drop: unsafe fn(*const ()),\n+}\n \n /// A `Waker` is a handle for waking up a task by notifying its executor that it\n /// is ready to be run.\n ///\n-/// This handle contains a trait object pointing to an instance of the `UnsafeWake`\n-/// trait, allowing notifications to get routed through it.\n+/// This handle encapsulates a [`RawWaker`] instance, which defines the\n+/// executor-specific wakeup behavior.\n+///\n+/// Implements [`Clone`], [`Send`], and [`Sync`].\n #[repr(transparent)]\n pub struct Waker {\n-    inner: NonNull<dyn UnsafeWake>,\n+    waker: RawWaker,\n }\n \n impl Unpin for Waker {}\n unsafe impl Send for Waker {}\n unsafe impl Sync for Waker {}\n \n impl Waker {\n-    /// Constructs a new `Waker` directly.\n-    ///\n-    /// Note that most code will not need to call this. Implementers of the\n-    /// `UnsafeWake` trait will typically provide a wrapper that calls this\n-    /// but you otherwise shouldn't call it directly.\n-    ///\n-    /// If you're working with the standard library then it's recommended to\n-    /// use the `Waker::from` function instead which works with the safe\n-    /// `Arc` type and the safe `Wake` trait.\n-    #[inline]\n-    pub unsafe fn new(inner: NonNull<dyn UnsafeWake>) -> Self {\n-        Waker { inner }\n-    }\n-\n     /// Wake up the task associated with this `Waker`.\n-    #[inline]\n     pub fn wake(&self) {\n-        unsafe { self.inner.as_ref().wake() }\n+        // The actual wakeup call is delegated through a virtual function call\n+        // to the implementation which is defined by the executor.\n+\n+        // SAFETY: This is safe because `Waker::new_unchecked` is the only way\n+        // to initialize `wake` and `data` requiring the user to acknowledge\n+        // that the contract of `RawWaker` is upheld.\n+        unsafe { (self.waker.vtable.wake)(self.waker.data) }\n     }\n \n-    /// Returns whether or not this `Waker` and `other` awaken the same task.\n+    /// Returns whether or not this `Waker` and other `Waker` have awaken the same task.\n     ///\n     /// This function works on a best-effort basis, and may return false even\n     /// when the `Waker`s would awaken the same task. However, if this function\n-    /// returns true, it is guaranteed that the `Waker`s will awaken the same\n-    /// task.\n+    /// returns `true`, it is guaranteed that the `Waker`s will awaken the same task.\n     ///\n     /// This function is primarily used for optimization purposes.\n-    #[inline]\n     pub fn will_wake(&self, other: &Waker) -> bool {\n-        self.inner == other.inner\n+        self.waker == other.waker\n     }\n \n-    /// Returns whether or not this `Waker` and `other` `LocalWaker` awaken\n-    /// the same task.\n+    /// Creates a new `Waker` from [`RawWaker`].\n     ///\n-    /// This function works on a best-effort basis, and may return false even\n-    /// when the `Waker`s would awaken the same task. However, if this function\n-    /// returns true, it is guaranteed that the `Waker`s will awaken the same\n-    /// task.\n-    ///\n-    /// This function is primarily used for optimization purposes.\n-    #[inline]\n-    pub fn will_wake_local(&self, other: &LocalWaker) -> bool {\n-        self.will_wake(&other.0)\n+    /// The behavior of the returned `Waker` is undefined if the contract defined\n+    /// in [`RawWaker`]'s and [`RawWakerVTable`]'s documentation is not upheld.\n+    /// Therefore this method is unsafe.\n+    pub unsafe fn new_unchecked(waker: RawWaker) -> Waker {\n+        Waker {\n+            waker,\n+        }\n     }\n }\n \n impl Clone for Waker {\n-    #[inline]\n     fn clone(&self) -> Self {\n-        unsafe {\n-            self.inner.as_ref().clone_raw()\n+        Waker {\n+            // SAFETY: This is safe because `Waker::new_unchecked` is the only way\n+            // to initialize `clone` and `data` requiring the user to acknowledge\n+            // that the contract of [`RawWaker`] is upheld.\n+            waker: unsafe { (self.waker.vtable.clone)(self.waker.data) },\n         }\n     }\n }\n \n-impl fmt::Debug for Waker {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"Waker\")\n-            .finish()\n-    }\n-}\n-\n impl Drop for Waker {\n-    #[inline]\n     fn drop(&mut self) {\n-        unsafe {\n-            self.inner.as_ref().drop_raw()\n-        }\n-    }\n-}\n-\n-/// A `LocalWaker` is a handle for waking up a task by notifying its executor that it\n-/// is ready to be run.\n-///\n-/// This is similar to the `Waker` type, but cannot be sent across threads.\n-/// Task executors can use this type to implement more optimized single-threaded wakeup\n-/// behavior.\n-#[repr(transparent)]\n-#[derive(Clone)]\n-pub struct LocalWaker(Waker);\n-\n-impl Unpin for LocalWaker {}\n-impl !Send for LocalWaker {}\n-impl !Sync for LocalWaker {}\n-\n-impl LocalWaker {\n-    /// Constructs a new `LocalWaker` directly.\n-    ///\n-    /// Note that most code will not need to call this. Implementers of the\n-    /// `UnsafeWake` trait will typically provide a wrapper that calls this\n-    /// but you otherwise shouldn't call it directly.\n-    ///\n-    /// If you're working with the standard library then it's recommended to\n-    /// use the `local_waker_from_nonlocal` or `local_waker` to convert a `Waker`\n-    /// into a `LocalWaker`.\n-    ///\n-    /// For this function to be used safely, it must be sound to call `inner.wake_local()`\n-    /// on the current thread.\n-    #[inline]\n-    pub unsafe fn new(inner: NonNull<dyn UnsafeWake>) -> Self {\n-        LocalWaker(Waker::new(inner))\n-    }\n-\n-    /// Borrows this `LocalWaker` as a `Waker`.\n-    ///\n-    /// `Waker` is nearly identical to `LocalWaker`, but is threadsafe\n-    /// (implements `Send` and `Sync`).\n-    #[inline]\n-    pub fn as_waker(&self) -> &Waker {\n-        &self.0\n-    }\n-\n-    /// Converts this `LocalWaker` into a `Waker`.\n-    ///\n-    /// `Waker` is nearly identical to `LocalWaker`, but is threadsafe\n-    /// (implements `Send` and `Sync`).\n-    #[inline]\n-    pub fn into_waker(self) -> Waker {\n-        self.0\n-    }\n-\n-    /// Wake up the task associated with this `LocalWaker`.\n-    #[inline]\n-    pub fn wake(&self) {\n-        unsafe { self.0.inner.as_ref().wake_local() }\n-    }\n-\n-    /// Returns whether or not this `LocalWaker` and `other` `LocalWaker` awaken the same task.\n-    ///\n-    /// This function works on a best-effort basis, and may return false even\n-    /// when the `LocalWaker`s would awaken the same task. However, if this function\n-    /// returns true, it is guaranteed that the `LocalWaker`s will awaken the same\n-    /// task.\n-    ///\n-    /// This function is primarily used for optimization purposes.\n-    #[inline]\n-    pub fn will_wake(&self, other: &LocalWaker) -> bool {\n-        self.0.will_wake(&other.0)\n-    }\n-\n-    /// Returns whether or not this `LocalWaker` and `other` `Waker` awaken the same task.\n-    ///\n-    /// This function works on a best-effort basis, and may return false even\n-    /// when the `Waker`s would awaken the same task. However, if this function\n-    /// returns true, it is guaranteed that the `LocalWaker`s will awaken the same\n-    /// task.\n-    ///\n-    /// This function is primarily used for optimization purposes.\n-    #[inline]\n-    pub fn will_wake_nonlocal(&self, other: &Waker) -> bool {\n-        self.0.will_wake(other)\n-    }\n-}\n-\n-impl From<LocalWaker> for Waker {\n-    /// Converts a `LocalWaker` into a `Waker`.\n-    ///\n-    /// This conversion turns a `!Sync` `LocalWaker` into a `Sync` `Waker`, allowing a wakeup\n-    /// object to be sent to another thread, but giving up its ability to do specialized\n-    /// thread-local wakeup behavior.\n-    #[inline]\n-    fn from(local_waker: LocalWaker) -> Self {\n-        local_waker.0\n+        // SAFETY: This is safe because `Waker::new_unchecked` is the only way\n+        // to initialize `drop` and `data` requiring the user to acknowledge\n+        // that the contract of `RawWaker` is upheld.\n+        unsafe { (self.waker.vtable.drop)(self.waker.data) }\n     }\n }\n \n-impl fmt::Debug for LocalWaker {\n+impl fmt::Debug for Waker {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"LocalWaker\")\n+        let vtable_ptr = self.waker.vtable as *const RawWakerVTable;\n+        f.debug_struct(\"Waker\")\n+            .field(\"data\", &self.waker.data)\n+            .field(\"vtable\", &vtable_ptr)\n             .finish()\n     }\n }\n-\n-/// An unsafe trait for implementing custom memory management for a `Waker` or `LocalWaker`.\n-///\n-/// A `Waker` conceptually is a cloneable trait object for `Wake`, and is\n-/// most often essentially just `Arc<dyn Wake>`. However, in some contexts\n-/// (particularly `no_std`), it's desirable to avoid `Arc` in favor of some\n-/// custom memory management strategy. This trait is designed to allow for such\n-/// customization.\n-///\n-/// When using `std`, a default implementation of the `UnsafeWake` trait is provided for\n-/// `Arc<T>` where `T: Wake`.\n-pub unsafe trait UnsafeWake: Send + Sync {\n-    /// Creates a clone of this `UnsafeWake` and stores it behind a `Waker`.\n-    ///\n-    /// This function will create a new uniquely owned handle that under the\n-    /// hood references the same notification instance. In other words calls\n-    /// to `wake` on the returned handle should be equivalent to calls to\n-    /// `wake` on this handle.\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This function is unsafe to call because it's asserting the `UnsafeWake`\n-    /// value is in a consistent state, i.e., hasn't been dropped.\n-    unsafe fn clone_raw(&self) -> Waker;\n-\n-    /// Drops this instance of `UnsafeWake`, deallocating resources\n-    /// associated with it.\n-    ///\n-    /// FIXME(cramertj)\n-    /// This method is intended to have a signature such as:\n-    ///\n-    /// ```ignore (not-a-doctest)\n-    /// fn drop_raw(self: *mut Self);\n-    /// ```\n-    ///\n-    /// Unfortunately in Rust today that signature is not object safe.\n-    /// Nevertheless it's recommended to implement this function *as if* that\n-    /// were its signature. As such it is not safe to call on an invalid\n-    /// pointer, nor is the validity of the pointer guaranteed after this\n-    /// function returns.\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This function is unsafe to call because it's asserting the `UnsafeWake`\n-    /// value is in a consistent state, i.e., hasn't been dropped.\n-    unsafe fn drop_raw(&self);\n-\n-    /// Indicates that the associated task is ready to make progress and should\n-    /// be `poll`ed.\n-    ///\n-    /// Executors generally maintain a queue of \"ready\" tasks; `wake` should place\n-    /// the associated task onto this queue.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Implementations should avoid panicking, but clients should also be prepared\n-    /// for panics.\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This function is unsafe to call because it's asserting the `UnsafeWake`\n-    /// value is in a consistent state, i.e., hasn't been dropped.\n-    unsafe fn wake(&self);\n-\n-    /// Indicates that the associated task is ready to make progress and should\n-    /// be `poll`ed. This function is the same as `wake`, but can only be called\n-    /// from the thread that this `UnsafeWake` is \"local\" to. This allows for\n-    /// implementors to provide specialized wakeup behavior specific to the current\n-    /// thread. This function is called by `LocalWaker::wake`.\n-    ///\n-    /// Executors generally maintain a queue of \"ready\" tasks; `wake_local` should place\n-    /// the associated task onto this queue.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Implementations should avoid panicking, but clients should also be prepared\n-    /// for panics.\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This function is unsafe to call because it's asserting the `UnsafeWake`\n-    /// value is in a consistent state, i.e., hasn't been dropped, and that the\n-    /// `UnsafeWake` hasn't moved from the thread on which it was created.\n-    unsafe fn wake_local(&self) {\n-        self.wake()\n-    }\n-}"}, {"sha": "b16416022c04e700197081fcdaa016d4fb565655", "filename": "src/libcore/tests/cell.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Ftests%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Ftests%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fcell.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -109,6 +109,7 @@ fn double_borrow_single_release_no_borrow_mut() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn discard_doesnt_unborrow() {\n     let x = RefCell::new(0);\n     let _b = x.borrow();\n@@ -349,6 +350,7 @@ fn refcell_ref_coercion() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn refcell_swap_borrows() {\n     let x = RefCell::new(0);\n     let _b = x.borrow();\n@@ -358,6 +360,7 @@ fn refcell_swap_borrows() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn refcell_replace_borrows() {\n     let x = RefCell::new(0);\n     let _b = x.borrow();"}, {"sha": "df1deeaeb97b789c84387f2f69a9d26e06183d31", "filename": "src/libcore/tests/fmt/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Ftests%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Ftests%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ffmt%2Fmod.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -3,6 +3,7 @@ mod float;\n mod num;\n \n #[test]\n+#[cfg(not(miri))] // Miri cannot print pointers\n fn test_format_flags() {\n     // No residual flags left by pointer formatting\n     let p = \"\".as_ptr();\n@@ -12,6 +13,7 @@ fn test_format_flags() {\n }\n \n #[test]\n+#[cfg(not(miri))] // Miri cannot print pointers\n fn test_pointer_formats_data_pointer() {\n     let b: &[u8] = b\"\";\n     let s: &str = \"\";"}, {"sha": "1000088e6b0633c5489e9eeee91c4e2af1c1a289", "filename": "src/libcore/tests/hash/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Ftests%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Ftests%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fhash%2Fmod.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -73,9 +73,11 @@ fn test_writer_hasher() {\n     let cs: &mut [u8] = &mut [1, 2, 3];\n     let ptr = cs.as_ptr();\n     let slice_ptr = cs as *const [u8];\n+    #[cfg(not(miri))] // Miri cannot hash pointers\n     assert_eq!(hash(&slice_ptr), hash(&ptr) + cs.len() as u64);\n \n     let slice_ptr = cs as *mut [u8];\n+    #[cfg(not(miri))] // Miri cannot hash pointers\n     assert_eq!(hash(&slice_ptr), hash(&ptr) + cs.len() as u64);\n }\n "}, {"sha": "9b76a4af98824a46052bd62c1cf9f552b4e98b90", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -253,6 +253,7 @@ fn test_iterator_step_by_nth_overflow() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_iterator_step_by_zero() {\n     let mut it = (0..).step_by(0);\n     it.next();\n@@ -877,7 +878,7 @@ fn test_iterator_flat_map() {\n     assert_eq!(i, ys.len());\n }\n \n-/// Test `FlatMap::fold` with items already picked off the front and back,\n+/// Tests `FlatMap::fold` with items already picked off the front and back,\n /// to make sure all parts of the `FlatMap` are folded correctly.\n #[test]\n fn test_iterator_flat_map_fold() {\n@@ -915,7 +916,7 @@ fn test_iterator_flatten() {\n     assert_eq!(i, ys.len());\n }\n \n-/// Test `Flatten::fold` with items already picked off the front and back,\n+/// Tests `Flatten::fold` with items already picked off the front and back,\n /// to make sure all parts of the `Flatten` are folded correctly.\n #[test]\n fn test_iterator_flatten_fold() {\n@@ -1413,6 +1414,7 @@ fn test_rposition() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_rposition_panic() {\n     let v: [(Box<_>, Box<_>); 4] =\n         [(box 0, box 0), (box 0, box 0),"}, {"sha": "956c22c998219ead7c9b65b0eb793c6f2d1b5137", "filename": "src/libcore/tests/num/bignum.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Ftests%2Fnum%2Fbignum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Ftests%2Fnum%2Fbignum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fbignum.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -3,6 +3,7 @@ use core::num::bignum::tests::Big8x3 as Big;\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_from_u64_overflow() {\n     Big::from_u64(0x1000000);\n }\n@@ -19,12 +20,14 @@ fn test_add() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_add_overflow_1() {\n     Big::from_small(1).add(&Big::from_u64(0xffffff));\n }\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_add_overflow_2() {\n     Big::from_u64(0xffffff).add(&Big::from_small(1));\n }\n@@ -42,6 +45,7 @@ fn test_add_small() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_add_small_overflow() {\n     Big::from_u64(0xffffff).add_small(1);\n }\n@@ -57,12 +61,14 @@ fn test_sub() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_sub_underflow_1() {\n     Big::from_u64(0x10665).sub(&Big::from_u64(0x10666));\n }\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_sub_underflow_2() {\n     Big::from_small(0).sub(&Big::from_u64(0x123456));\n }\n@@ -76,6 +82,7 @@ fn test_mul_small() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_mul_small_overflow() {\n     Big::from_u64(0x800000).mul_small(2);\n }\n@@ -94,12 +101,14 @@ fn test_mul_pow2() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_mul_pow2_overflow_1() {\n     Big::from_u64(0x1).mul_pow2(24);\n }\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_mul_pow2_overflow_2() {\n     Big::from_u64(0x123).mul_pow2(16);\n }\n@@ -118,12 +127,14 @@ fn test_mul_pow5() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_mul_pow5_overflow_1() {\n     Big::from_small(1).mul_pow5(12);\n }\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_mul_pow5_overflow_2() {\n     Big::from_small(230).mul_pow5(8);\n }\n@@ -141,12 +152,14 @@ fn test_mul_digits() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_mul_digits_overflow_1() {\n     Big::from_u64(0x800000).mul_digits(&[2]);\n }\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_mul_digits_overflow_2() {\n     Big::from_u64(0x1000).mul_digits(&[0, 0x10]);\n }\n@@ -206,6 +219,7 @@ fn test_get_bit() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_get_bit_out_of_range() {\n     Big::from_small(42).get_bit(24);\n }"}, {"sha": "faeaabbf95adacb75d7edd518f11ffdba021a087", "filename": "src/libcore/tests/num/dec2flt/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -52,6 +52,7 @@ fn large() {\n }\n \n #[test]\n+#[cfg(not(miri))] // Miri is too slow\n fn subnormals() {\n     test_literal!(5e-324);\n     test_literal!(91e-324);\n@@ -63,6 +64,7 @@ fn subnormals() {\n }\n \n #[test]\n+#[cfg(not(miri))] // Miri is too slow\n fn infinity() {\n     test_literal!(1e400);\n     test_literal!(1e309);"}, {"sha": "d362c7994d8066e0dd707a027c866ac1bed1f9ee", "filename": "src/libcore/tests/num/flt2dec/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,3 +1,5 @@\n+#![cfg(not(miri))] // Miri does not implement ldexp, which most tests here need\n+\n use std::prelude::v1::*;\n use std::{str, i16, f32, f64, fmt};\n "}, {"sha": "87ce2720c5918209a4a6f85b375f63d9fc6e5967", "filename": "src/libcore/tests/option.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Ftests%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Ftests%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Foption.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -69,6 +69,7 @@ fn test_option_dance() {\n }\n \n #[test] #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_option_too_much_dance() {\n     struct A;\n     let mut y = Some(A);\n@@ -129,13 +130,15 @@ fn test_unwrap() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_unwrap_panic1() {\n     let x: Option<isize> = None;\n     x.unwrap();\n }\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_unwrap_panic2() {\n     let x: Option<String> = None;\n     x.unwrap();"}, {"sha": "2c53e4832a8cc20086f33b023f3264e40d99c172", "filename": "src/libcore/tests/ptr.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Ftests%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Ftests%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fptr.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -40,6 +40,7 @@ fn test() {\n }\n \n #[test]\n+#[cfg(not(miri))] // This test performs invalid OOB pointer arithmetic\n fn test_is_null() {\n     let p: *const isize = null();\n     assert!(p.is_null());\n@@ -145,6 +146,7 @@ fn test_as_ref() {\n }\n \n #[test]\n+#[cfg(not(miri))] // This test is UB according to Stacked Borrows\n fn test_as_mut() {\n     unsafe {\n         let p: *mut isize = null_mut();\n@@ -206,6 +208,7 @@ fn test_ptr_addition() {\n }\n \n #[test]\n+#[cfg(not(miri))] // This test performs invalid OOB pointer arithmetic\n fn test_ptr_subtraction() {\n     unsafe {\n         let xs = vec![0,1,2,3,4,5,6,7,8,9];\n@@ -249,6 +252,7 @@ fn test_unsized_nonnull() {\n \n #[test]\n #[allow(warnings)]\n+#[cfg(not(miri))] // Miri cannot hash pointers\n // Have a symbol for the test below. It doesn\u2019t need to be an actual variadic function, match the\n // ABI, or even point to an actual executable code, because the function itself is never invoked.\n #[no_mangle]\n@@ -288,6 +292,7 @@ fn write_unaligned_drop() {\n }\n \n #[test]\n+#[cfg(not(miri))] // Miri cannot compute actual alignment of an allocation\n fn align_offset_zst() {\n     // For pointers of stride = 0, the pointer is already aligned or it cannot be aligned at\n     // all, because no amount of elements will align the pointer.\n@@ -302,6 +307,7 @@ fn align_offset_zst() {\n }\n \n #[test]\n+#[cfg(not(miri))] // Miri cannot compute actual alignment of an allocation\n fn align_offset_stride1() {\n     // For pointers of stride = 1, the pointer can always be aligned. The offset is equal to\n     // number of bytes.\n@@ -318,6 +324,7 @@ fn align_offset_stride1() {\n }\n \n #[test]\n+#[cfg(not(miri))] // Miri is too slow\n fn align_offset_weird_strides() {\n     #[repr(packed)]\n     struct A3(u16, u8);"}, {"sha": "bbc85685176671ad20051ddc28fa2a50014b4718", "filename": "src/libcore/tests/result.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Ftests%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Ftests%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fresult.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -117,6 +117,7 @@ fn test_unwrap_or_else() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n pub fn test_unwrap_or_else_panic() {\n     fn handler(msg: &'static str) -> isize {\n         if msg == \"I got this.\" {\n@@ -138,6 +139,7 @@ pub fn test_expect_ok() {\n }\n #[test]\n #[should_panic(expected=\"Got expected error: \\\"All good\\\"\")]\n+#[cfg(not(miri))] // Miri does not support panics\n pub fn test_expect_err() {\n     let err: Result<isize, &'static str> = Err(\"All good\");\n     err.expect(\"Got expected error\");\n@@ -151,6 +153,7 @@ pub fn test_expect_err_err() {\n }\n #[test]\n #[should_panic(expected=\"Got expected ok: \\\"All good\\\"\")]\n+#[cfg(not(miri))] // Miri does not support panics\n pub fn test_expect_err_ok() {\n     let err: Result<&'static str, isize> = Ok(\"All good\");\n     err.expect_err(\"Got expected ok\");"}, {"sha": "31d16e0e320571c28897f4b30feb266e3bc86ba0", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -782,6 +782,7 @@ mod slice_index {\n     //  to be used in `should_panic`)\n     #[test]\n     #[should_panic(expected = \"out of range\")]\n+    #[cfg(not(miri))] // Miri does not support panics\n     fn assert_range_eq_can_fail_by_panic() {\n         assert_range_eq!([0, 1, 2], 0..5, [0, 1, 2]);\n     }\n@@ -791,6 +792,7 @@ mod slice_index {\n     //  to be used in `should_panic`)\n     #[test]\n     #[should_panic(expected = \"==\")]\n+    #[cfg(not(miri))] // Miri does not support panics\n     fn assert_range_eq_can_fail_by_inequality() {\n         assert_range_eq!([0, 1, 2], 0..2, [0, 1, 2]);\n     }\n@@ -840,6 +842,7 @@ mod slice_index {\n \n                 #[test]\n                 #[should_panic(expected = $expect_msg)]\n+                #[cfg(not(miri))] // Miri does not support panics\n                 fn index_fail() {\n                     let v = $data;\n                     let v: &[_] = &v;\n@@ -848,6 +851,7 @@ mod slice_index {\n \n                 #[test]\n                 #[should_panic(expected = $expect_msg)]\n+                #[cfg(not(miri))] // Miri does not support panics\n                 fn index_mut_fail() {\n                     let mut v = $data;\n                     let v: &mut [_] = &mut v;\n@@ -1011,6 +1015,7 @@ fn test_rotate_right() {\n \n #[test]\n #[cfg(not(target_arch = \"wasm32\"))]\n+#[cfg(not(miri))] // Miri does not support entropy\n fn sort_unstable() {\n     use core::cmp::Ordering::{Equal, Greater, Less};\n     use core::slice::heapsort;\n@@ -1166,6 +1171,7 @@ pub mod memchr {\n }\n \n #[test]\n+#[cfg(not(miri))] // Miri cannot compute actual alignment of an allocation\n fn test_align_to_simple() {\n     let bytes = [1u8, 2, 3, 4, 5, 6, 7];\n     let (prefix, aligned, suffix) = unsafe { bytes.align_to::<u16>() };\n@@ -1189,6 +1195,7 @@ fn test_align_to_zst() {\n }\n \n #[test]\n+#[cfg(not(miri))] // Miri cannot compute actual alignment of an allocation\n fn test_align_to_non_trivial() {\n     #[repr(align(8))] struct U64(u64, u64);\n     #[repr(align(8))] struct U64U64U32(u64, u64, u32);\n@@ -1297,6 +1304,7 @@ fn test_copy_within() {\n \n #[test]\n #[should_panic(expected = \"src is out of bounds\")]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_copy_within_panics_src_too_long() {\n     let mut bytes = *b\"Hello, World!\";\n     // The length is only 13, so 14 is out of bounds.\n@@ -1305,13 +1313,15 @@ fn test_copy_within_panics_src_too_long() {\n \n #[test]\n #[should_panic(expected = \"dest is out of bounds\")]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_copy_within_panics_dest_too_long() {\n     let mut bytes = *b\"Hello, World!\";\n     // The length is only 13, so a slice of length 4 starting at index 10 is out of bounds.\n     bytes.copy_within(0..4, 10);\n }\n #[test]\n #[should_panic(expected = \"src end is before src start\")]\n+#[cfg(not(miri))] // Miri does not support panics\n fn test_copy_within_panics_src_inverted() {\n     let mut bytes = *b\"Hello, World!\";\n     // 2 is greater than 1, so this range is invalid."}, {"sha": "09aae4583482f83e41bd6574e453fedaf0500c60", "filename": "src/libcore/tests/time.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Ftests%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Ftests%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ftime.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -107,12 +107,14 @@ fn checked_sub() {\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn sub_bad1() {\n     let _ = Duration::new(0, 0) - Duration::new(0, 1);\n }\n \n #[test]\n #[should_panic]\n+#[cfg(not(miri))] // Miri does not support panics\n fn sub_bad2() {\n     let _ = Duration::new(0, 0) - Duration::new(1, 0);\n }"}, {"sha": "ac7e11754aa3a21955d9036134dd0ce055140403", "filename": "src/libcore/time.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibcore%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftime.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -43,7 +43,7 @@ pub const NANOSECOND: Duration = Duration::from_nanos(1);\n /// timeouts.\n ///\n /// Each `Duration` is composed of a whole number of seconds and a fractional part\n-/// represented in nanoseconds.  If the underlying system does not support\n+/// represented in nanoseconds. If the underlying system does not support\n /// nanosecond-level precision, APIs binding a system timeout will typically round up\n /// the number of nanoseconds.\n ///\n@@ -515,7 +515,7 @@ impl Duration {\n         }\n     }\n \n-    /// Multiply `Duration` by `f64`.\n+    /// Multiplies `Duration` by `f64`.\n     ///\n     /// # Panics\n     /// This method will panic if result is not finite, negative or overflows `Duration`."}, {"sha": "50779a2d9ad08d526e5c9a02def260618c422fe7", "filename": "src/libfmt_macros/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibfmt_macros%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibfmt_macros%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2FCargo.toml?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -2,6 +2,7 @@\n authors = [\"The Rust Project Developers\"]\n name = \"fmt_macros\"\n version = \"0.0.0\"\n+edition = \"2018\"\n \n [lib]\n name = \"fmt_macros\""}, {"sha": "aacd6cec565a5a971576f7ae79cf00e273387f67", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -4,20 +4,20 @@\n //! Parsing does not happen at runtime: structures of `std::fmt::rt` are\n //! generated instead.\n \n-#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-       html_root_url = \"https://doc.rust-lang.org/nightly/\",\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"https://play.rust-lang.org/\",\n        test(attr(deny(warnings))))]\n \n+#![deny(rust_2018_idioms)]\n+\n #![feature(nll)]\n #![feature(rustc_private)]\n \n-pub use self::Piece::*;\n-pub use self::Position::*;\n-pub use self::Alignment::*;\n-pub use self::Flag::*;\n-pub use self::Count::*;\n+pub use Piece::*;\n+pub use Position::*;\n+pub use Alignment::*;\n+pub use Flag::*;\n+pub use Count::*;\n \n use std::str;\n use std::string;"}, {"sha": "a6a3c1a249d64285e1fbb154f766f196fa926909", "filename": "src/libgraphviz/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibgraphviz%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibgraphviz%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2FCargo.toml?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -2,6 +2,7 @@\n authors = [\"The Rust Project Developers\"]\n name = \"graphviz\"\n version = \"0.0.0\"\n+edition = \"2018\"\n \n [lib]\n name = \"graphviz\""}, {"sha": "489020d4ee778483ed03fbbc801b799ddf390284", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -271,15 +271,14 @@\n //!\n //! * [DOT language](http://www.graphviz.org/doc/info/lang.html)\n \n-#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-       html_root_url = \"https://doc.rust-lang.org/nightly/\",\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        test(attr(allow(unused_variables), deny(warnings))))]\n \n+#![deny(rust_2018_idioms)]\n+\n #![feature(nll)]\n-#![feature(str_escape)]\n \n-use self::LabelText::*;\n+use LabelText::*;\n \n use std::borrow::Cow;\n use std::io::prelude::*;\n@@ -393,7 +392,7 @@ impl<'a> Id<'a> {\n     /// digit (i.e., the regular expression `[a-zA-Z_][a-zA-Z_0-9]*`).\n     ///\n     /// (Note: this format is a strict subset of the `ID` format\n-    /// defined by the DOT language.  This function may change in the\n+    /// defined by the DOT language. This function may change in the\n     /// future to accept a broader subset, or the entirety, of DOT's\n     /// `ID` format.)\n     ///\n@@ -530,15 +529,15 @@ impl<'a> LabelText<'a> {\n     }\n \n     /// Decomposes content into string suitable for making EscStr that\n-    /// yields same content as self.  The result obeys the law\n+    /// yields same content as self. The result obeys the law\n     /// render(`lt`) == render(`EscStr(lt.pre_escaped_content())`) for\n     /// all `lt: LabelText`.\n     fn pre_escaped_content(self) -> Cow<'a, str> {\n         match self {\n             EscStr(s) => s,\n             LabelStr(s) => {\n                 if s.contains('\\\\') {\n-                    (&*s).escape_default().into()\n+                    (&*s).escape_default().to_string().into()\n                 } else {\n                     s\n                 }\n@@ -548,12 +547,12 @@ impl<'a> LabelText<'a> {\n     }\n \n     /// Puts `prefix` on a line above this label, with a blank line separator.\n-    pub fn prefix_line(self, prefix: LabelText) -> LabelText<'static> {\n+    pub fn prefix_line(self, prefix: LabelText<'_>) -> LabelText<'static> {\n         prefix.suffix_line(self)\n     }\n \n     /// Puts `suffix` on a line below this label, with a blank line separator.\n-    pub fn suffix_line(self, suffix: LabelText) -> LabelText<'static> {\n+    pub fn suffix_line(self, suffix: LabelText<'_>) -> LabelText<'static> {\n         let mut prefix = self.pre_escaped_content().into_owned();\n         let suffix = suffix.pre_escaped_content();\n         prefix.push_str(r\"\\n\\n\");\n@@ -686,7 +685,7 @@ pub fn render_opts<'a, N, E, G, W>(g: &'a G,\n \n #[cfg(test)]\n mod tests {\n-    use self::NodeLabels::*;\n+    use NodeLabels::*;\n     use super::{Id, Labeller, Nodes, Edges, GraphWalk, render, Style};\n     use super::LabelText::{self, LabelStr, EscStr, HtmlStr};\n     use std::io;"}, {"sha": "2bee0b716c750f4836068ea38b85e74cceb09b7d", "filename": "src/libpanic_abort/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibpanic_abort%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibpanic_abort%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_abort%2FCargo.toml?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -2,6 +2,7 @@\n authors = [\"The Rust Project Developers\"]\n name = \"panic_abort\"\n version = \"0.0.0\"\n+edition = \"2018\"\n \n [lib]\n path = \"lib.rs\""}, {"sha": "edc97cd28a52af89d4d65147286cdf864904c821", "filename": "src/libpanic_abort/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibpanic_abort%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibpanic_abort%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_abort%2Flib.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -5,12 +5,12 @@\n \n #![no_std]\n #![unstable(feature = \"panic_abort\", issue = \"32837\")]\n-#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-       html_root_url = \"https://doc.rust-lang.org/nightly/\",\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\")]\n #![panic_runtime]\n+\n #![allow(unused_features)]\n+#![deny(rust_2018_idioms)]\n \n #![feature(core_intrinsics)]\n #![feature(libc)]\n@@ -46,7 +46,6 @@ pub unsafe extern fn __rust_start_panic(_payload: usize) -> u32 {\n \n     #[cfg(any(unix, target_os = \"cloudabi\"))]\n     unsafe fn abort() -> ! {\n-        extern crate libc;\n         libc::abort();\n     }\n "}, {"sha": "1b3901ac11a96c580c605497a3a074c2fe58c50d", "filename": "src/libpanic_unwind/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibpanic_unwind%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibpanic_unwind%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2FCargo.toml?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -2,6 +2,7 @@\n authors = [\"The Rust Project Developers\"]\n name = \"panic_unwind\"\n version = \"0.0.0\"\n+edition = \"2018\"\n \n [lib]\n path = \"lib.rs\""}, {"sha": "3a00d6376658c1a64751ddd349181ff7325ab23c", "filename": "src/libpanic_unwind/dummy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibpanic_unwind%2Fdummy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibpanic_unwind%2Fdummy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fdummy.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,6 +1,6 @@\n-//! Unwinding for wasm32\n+//! Unwinding for *wasm32* target.\n //!\n-//! Right now we don't support this, so this is just stubs\n+//! Right now we don't support this, so this is just stubs.\n \n use alloc::boxed::Box;\n use core::any::Any;"}, {"sha": "07fa2971847f65d5d49df89a547e3b6c8ca86d75", "filename": "src/libpanic_unwind/dwarf/eh.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -6,12 +6,12 @@\n //!   http://www.airs.com/blog/archives/464\n //!\n //! A reference implementation may be found in the GCC source tree\n-//! (<root>/libgcc/unwind-c.c as of this writing)\n+//! (`<root>/libgcc/unwind-c.c` as of this writing).\n \n #![allow(non_upper_case_globals)]\n #![allow(unused)]\n \n-use dwarf::DwarfReader;\n+use crate::dwarf::DwarfReader;\n use core::mem;\n \n pub const DW_EH_PE_omit: u8 = 0xFF;\n@@ -51,7 +51,7 @@ pub enum EHAction {\n \n pub const USING_SJLJ_EXCEPTIONS: bool = cfg!(all(target_os = \"ios\", target_arch = \"arm\"));\n \n-pub unsafe fn find_eh_action(lsda: *const u8, context: &EHContext)\n+pub unsafe fn find_eh_action(lsda: *const u8, context: &EHContext<'_>)\n     -> Result<EHAction, ()>\n {\n     if lsda.is_null() {\n@@ -145,7 +145,7 @@ fn round_up(unrounded: usize, align: usize) -> Result<usize, ()> {\n }\n \n unsafe fn read_encoded_pointer(reader: &mut DwarfReader,\n-                               context: &EHContext,\n+                               context: &EHContext<'_>,\n                                encoding: u8)\n                                -> Result<usize, ()> {\n     if encoding == DW_EH_PE_omit {"}, {"sha": "0360696426dc94ba8441e7c1cbdc9bfb6a1bb671", "filename": "src/libpanic_unwind/dwarf/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibpanic_unwind%2Fdwarf%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibpanic_unwind%2Fdwarf%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fdwarf%2Fmod.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,5 +1,5 @@\n //! Utilities for parsing DWARF-encoded data streams.\n-//! See http://www.dwarfstd.org,\n+//! See <http://www.dwarfstd.org>,\n //! DWARF-4 standard, Section 7 - \"Data Representation\"\n \n // This module is used only by x86_64-pc-windows-gnu for now, but we"}, {"sha": "18e9006468ef3500c6b7f4de3d79d2a440673013", "filename": "src/libpanic_unwind/emcc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibpanic_unwind%2Femcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibpanic_unwind%2Femcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Femcc.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,19 +1,19 @@\n-//! Unwinding for emscripten\n+//! Unwinding for *emscripten* target.\n //!\n //! Whereas Rust's usual unwinding implementation for Unix platforms\n-//! calls into the libunwind APIs directly, on emscripten we instead\n+//! calls into the libunwind APIs directly, on Emscripten we instead\n //! call into the C++ unwinding APIs. This is just an expedience since\n-//! emscripten's runtime always implements those APIs and does not\n+//! Emscripten's runtime always implements those APIs and does not\n //! implement libunwind.\n \n #![allow(private_no_mangle_fns)]\n \n use core::any::Any;\n use core::ptr;\n+use core::mem;\n use alloc::boxed::Box;\n use libc::{self, c_int};\n use unwind as uw;\n-use core::mem;\n \n pub fn payload() -> *mut u8 {\n     ptr::null_mut()"}, {"sha": "e2b743b379704b5faf18c1d96c14b6aae9a00f72", "filename": "src/libpanic_unwind/gcc.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibpanic_unwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibpanic_unwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fgcc.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,4 +1,4 @@\n-//! Implementation of panics backed by libgcc/libunwind (in some form)\n+//! Implementation of panics backed by libgcc/libunwind (in some form).\n //!\n //! For background on exception handling and stack unwinding please see\n //! \"Exception Handling in LLVM\" (llvm.org/docs/ExceptionHandling.html) and\n@@ -23,14 +23,14 @@\n //!\n //! In the search phase, the job of a personality routine is to examine\n //! exception object being thrown, and to decide whether it should be caught at\n-//! that stack frame.  Once the handler frame has been identified, cleanup phase\n+//! that stack frame. Once the handler frame has been identified, cleanup phase\n //! begins.\n //!\n //! In the cleanup phase, the unwinder invokes each personality routine again.\n //! This time it decides which (if any) cleanup code needs to be run for\n-//! the current stack frame.  If so, the control is transferred to a special\n+//! the current stack frame. If so, the control is transferred to a special\n //! branch in the function body, the \"landing pad\", which invokes destructors,\n-//! frees memory, etc.  At the end of the landing pad, control is transferred\n+//! frees memory, etc. At the end of the landing pad, control is transferred\n //! back to the unwinder and unwinding resumes.\n //!\n //! Once stack has been unwound down to the handler frame level, unwinding stops\n@@ -39,7 +39,7 @@\n //! ## `eh_personality` and `eh_unwind_resume`\n //!\n //! These language items are used by the compiler when generating unwind info.\n-//! The first one is the personality routine described above.  The second one\n+//! The first one is the personality routine described above. The second one\n //! allows compilation target to customize the process of resuming unwind at the\n //! end of the landing pads. `eh_unwind_resume` is used only if\n //! `custom_unwind_resume` flag in the target options is set.\n@@ -52,7 +52,7 @@ use alloc::boxed::Box;\n \n use unwind as uw;\n use libc::{c_int, uintptr_t};\n-use dwarf::eh::{self, EHContext, EHAction};\n+use crate::dwarf::eh::{self, EHContext, EHAction};\n \n #[repr(C)]\n struct Exception {"}, {"sha": "9d3d8f6185bb3e955b226ad29f2d70305b5d0561", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -14,11 +14,11 @@\n \n #![no_std]\n #![unstable(feature = \"panic_unwind\", issue = \"32837\")]\n-#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-       html_root_url = \"https://doc.rust-lang.org/nightly/\",\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\")]\n \n+#![deny(rust_2018_idioms)]\n+\n #![feature(allocator_api)]\n #![feature(alloc)]\n #![feature(core_intrinsics)]\n@@ -34,11 +34,6 @@\n #![panic_runtime]\n #![feature(panic_runtime)]\n \n-extern crate alloc;\n-extern crate libc;\n-#[cfg(not(any(target_env = \"msvc\", all(windows, target_arch = \"x86_64\", target_env = \"gnu\"))))]\n-extern crate unwind;\n-\n use alloc::boxed::Box;\n use core::intrinsics;\n use core::mem;\n@@ -89,7 +84,7 @@ pub unsafe extern \"C\" fn __rust_maybe_catch_panic(f: fn(*mut u8),\n                                                   vtable_ptr: *mut usize)\n                                                   -> u32 {\n     let mut payload = imp::payload();\n-    if intrinsics::try(f, data, &mut payload as *mut _ as *mut _) == 0 {\n+    if intrinsics::r#try(f, data, &mut payload as *mut _ as *mut _) == 0 {\n         0\n     } else {\n         let obj = mem::transmute::<_, raw::TraitObject>(imp::cleanup(payload));"}, {"sha": "996fdb931eff2d49000f7d56212adea96c5d0172", "filename": "src/libpanic_unwind/seh.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibpanic_unwind%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibpanic_unwind%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -52,7 +52,7 @@ use core::any::Any;\n use core::mem;\n use core::raw;\n \n-use windows as c;\n+use crate::windows as c;\n use libc::{c_int, c_uint};\n \n // First up, a whole bunch of type definitions. There's a few platform-specific\n@@ -301,5 +301,5 @@ pub unsafe fn cleanup(payload: [u64; 2]) -> Box<dyn Any + Send> {\n #[lang = \"eh_personality\"]\n #[cfg(not(test))]\n fn rust_eh_personality() {\n-    unsafe { ::core::intrinsics::abort() }\n+    unsafe { core::intrinsics::abort() }\n }"}, {"sha": "457ffcd34f9c7ad423cbeeed910b342e85655534", "filename": "src/libpanic_unwind/seh64_gnu.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh64_gnu.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -9,8 +9,8 @@ use alloc::boxed::Box;\n use core::any::Any;\n use core::intrinsics;\n use core::ptr;\n-use dwarf::eh::{EHContext, EHAction, find_eh_action};\n-use windows as c;\n+use crate::dwarf::eh::{EHContext, EHAction, find_eh_action};\n+use crate::windows as c;\n \n // Define our exception codes:\n // according to http://msdn.microsoft.com/en-us/library/het71c37(v=VS.80).aspx,"}, {"sha": "b3d0ee94f0e12f4ae52f3bc48ebb144dd2aca443", "filename": "src/libproc_macro/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibproc_macro%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibproc_macro%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2FCargo.toml?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -2,6 +2,7 @@\n authors = [\"The Rust Project Developers\"]\n name = \"proc_macro\"\n version = \"0.0.0\"\n+edition = \"2018\"\n \n [lib]\n path = \"lib.rs\""}, {"sha": "0d8cc552d61ab3cdbd86ec1d39f1d6527ddb3aa9", "filename": "src/libproc_macro/bridge/buffer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibproc_macro%2Fbridge%2Fbuffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibproc_macro%2Fbridge%2Fbuffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fbuffer.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -6,7 +6,7 @@ use std::ops::{Deref, DerefMut};\n use std::slice;\n \n #[repr(C)]\n-struct Slice<'a, T: 'a> {\n+struct Slice<'a, T> {\n     data: &'a [T; 0],\n     len: usize,\n }\n@@ -42,7 +42,7 @@ pub struct Buffer<T: Copy> {\n     data: *mut T,\n     len: usize,\n     capacity: usize,\n-    extend_from_slice: extern \"C\" fn(Buffer<T>, Slice<T>) -> Buffer<T>,\n+    extend_from_slice: extern \"C\" fn(Buffer<T>, Slice<'_, T>) -> Buffer<T>,\n     drop: extern \"C\" fn(Buffer<T>),\n }\n \n@@ -139,7 +139,7 @@ impl<T: Copy> From<Vec<T>> for Buffer<T> {\n             }\n         }\n \n-        extern \"C\" fn extend_from_slice<T: Copy>(b: Buffer<T>, xs: Slice<T>) -> Buffer<T> {\n+        extern \"C\" fn extend_from_slice<T: Copy>(b: Buffer<T>, xs: Slice<'_, T>) -> Buffer<T> {\n             let mut v = to_vec(b);\n             v.extend_from_slice(&xs);\n             Buffer::from(v)"}, {"sha": "b198bdb144699908a7c1feb4a2ed411722912d29", "filename": "src/libproc_macro/bridge/client.rs", "status": "modified", "additions": 35, "deletions": 27, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibproc_macro%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibproc_macro%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fclient.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -66,7 +66,7 @@ macro_rules! define_handles {\n             impl<S: server::Types> DecodeMut<'_, '_, HandleStore<server::MarkedTypes<S>>>\n                 for Marked<S::$oty, $oty>\n             {\n-                fn decode(r: &mut Reader, s: &mut HandleStore<server::MarkedTypes<S>>) -> Self {\n+                fn decode(r: &mut Reader<'_>, s: &mut HandleStore<server::MarkedTypes<S>>) -> Self {\n                     s.$oty.take(handle::Handle::decode(r, &mut ()))\n                 }\n             }\n@@ -80,7 +80,7 @@ macro_rules! define_handles {\n             impl<S: server::Types> Decode<'_, 's, HandleStore<server::MarkedTypes<S>>>\n                 for &'s Marked<S::$oty, $oty>\n             {\n-                fn decode(r: &mut Reader, s: &'s HandleStore<server::MarkedTypes<S>>) -> Self {\n+                fn decode(r: &mut Reader<'_>, s: &'s HandleStore<server::MarkedTypes<S>>) -> Self {\n                     &s.$oty[handle::Handle::decode(r, &mut ())]\n                 }\n             }\n@@ -94,7 +94,10 @@ macro_rules! define_handles {\n             impl<S: server::Types> DecodeMut<'_, 's, HandleStore<server::MarkedTypes<S>>>\n                 for &'s mut Marked<S::$oty, $oty>\n             {\n-                fn decode(r: &mut Reader, s: &'s mut HandleStore<server::MarkedTypes<S>>) -> Self {\n+                fn decode(\n+                    r: &mut Reader<'_>,\n+                    s: &'s mut HandleStore<server::MarkedTypes<S>>\n+                ) -> Self {\n                     &mut s.$oty[handle::Handle::decode(r, &mut ())]\n                 }\n             }\n@@ -108,7 +111,7 @@ macro_rules! define_handles {\n             }\n \n             impl<S> DecodeMut<'_, '_, S> for $oty {\n-                fn decode(r: &mut Reader, s: &mut S) -> Self {\n+                fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n                     $oty(handle::Handle::decode(r, s))\n                 }\n             }\n@@ -130,7 +133,7 @@ macro_rules! define_handles {\n             impl<S: server::Types> DecodeMut<'_, '_, HandleStore<server::MarkedTypes<S>>>\n                 for Marked<S::$ity, $ity>\n             {\n-                fn decode(r: &mut Reader, s: &mut HandleStore<server::MarkedTypes<S>>) -> Self {\n+                fn decode(r: &mut Reader<'_>, s: &mut HandleStore<server::MarkedTypes<S>>) -> Self {\n                     s.$ity.copy(handle::Handle::decode(r, &mut ()))\n                 }\n             }\n@@ -144,7 +147,7 @@ macro_rules! define_handles {\n             }\n \n             impl<S> DecodeMut<'_, '_, S> for $ity {\n-                fn decode(r: &mut Reader, s: &mut S) -> Self {\n+                fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n                     $ity(handle::Handle::decode(r, s))\n                 }\n             }\n@@ -200,7 +203,7 @@ impl Clone for Literal {\n \n // FIXME(eddyb) `Literal` should not expose internal `Debug` impls.\n impl fmt::Debug for Literal {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.write_str(&self.debug())\n     }\n }\n@@ -212,7 +215,7 @@ impl Clone for SourceFile {\n }\n \n impl fmt::Debug for Span {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.write_str(&self.debug())\n     }\n }\n@@ -275,7 +278,7 @@ impl BridgeState<'_> {\n     ///\n     /// N.B., while `f` is running, the thread-local state\n     /// is `BridgeState::InUse`.\n-    fn with<R>(f: impl FnOnce(&mut BridgeState) -> R) -> R {\n+    fn with<R>(f: impl FnOnce(&mut BridgeState<'_>) -> R) -> R {\n         BRIDGE_STATE.with(|state| {\n             state.replace(BridgeState::InUse, |mut state| {\n                 // FIXME(#52812) pass `f` directly to `replace` when `RefMutL` is gone\n@@ -306,7 +309,7 @@ impl Bridge<'_> {\n         BRIDGE_STATE.with(|state| state.set(BridgeState::Connected(self), f))\n     }\n \n-    fn with<R>(f: impl FnOnce(&mut Bridge) -> R) -> R {\n+    fn with<R>(f: impl FnOnce(&mut Bridge<'_>) -> R) -> R {\n         BridgeState::with(|state| match state {\n             BridgeState::NotConnected => {\n                 panic!(\"procedural macro API is used outside of a procedural macro\");\n@@ -331,15 +334,15 @@ impl Bridge<'_> {\n #[derive(Copy, Clone)]\n pub struct Client<F> {\n     pub(super) get_handle_counters: extern \"C\" fn() -> &'static HandleCounters,\n-    pub(super) run: extern \"C\" fn(Bridge, F) -> Buffer<u8>,\n+    pub(super) run: extern \"C\" fn(Bridge<'_>, F) -> Buffer<u8>,\n     pub(super) f: F,\n }\n \n // FIXME(#53451) public to work around `Cannot create local mono-item` ICE,\n // affecting not only the function itself, but also the `BridgeState` `thread_local!`.\n pub extern \"C\" fn __run_expand1(\n-    mut bridge: Bridge,\n-    f: fn(::TokenStream) -> ::TokenStream,\n+    mut bridge: Bridge<'_>,\n+    f: fn(crate::TokenStream) -> crate::TokenStream,\n ) -> Buffer<u8> {\n     // The initial `cached_buffer` contains the input.\n     let mut b = bridge.cached_buffer.take();\n@@ -352,7 +355,7 @@ pub extern \"C\" fn __run_expand1(\n             // Put the `cached_buffer` back in the `Bridge`, for requests.\n             Bridge::with(|bridge| bridge.cached_buffer = b.take());\n \n-            let output = f(::TokenStream(input)).0;\n+            let output = f(crate::TokenStream(input)).0;\n \n             // Take the `cached_buffer` back out, for the output value.\n             b = Bridge::with(|bridge| bridge.cached_buffer.take());\n@@ -378,8 +381,8 @@ pub extern \"C\" fn __run_expand1(\n     b\n }\n \n-impl Client<fn(::TokenStream) -> ::TokenStream> {\n-    pub const fn expand1(f: fn(::TokenStream) -> ::TokenStream) -> Self {\n+impl Client<fn(crate::TokenStream) -> crate::TokenStream> {\n+    pub const fn expand1(f: fn(crate::TokenStream) -> crate::TokenStream) -> Self {\n         Client {\n             get_handle_counters: HandleCounters::get,\n             run: __run_expand1,\n@@ -391,8 +394,8 @@ impl Client<fn(::TokenStream) -> ::TokenStream> {\n // FIXME(#53451) public to work around `Cannot create local mono-item` ICE,\n // affecting not only the function itself, but also the `BridgeState` `thread_local!`.\n pub extern \"C\" fn __run_expand2(\n-    mut bridge: Bridge,\n-    f: fn(::TokenStream, ::TokenStream) -> ::TokenStream,\n+    mut bridge: Bridge<'_>,\n+    f: fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream,\n ) -> Buffer<u8> {\n     // The initial `cached_buffer` contains the input.\n     let mut b = bridge.cached_buffer.take();\n@@ -406,7 +409,7 @@ pub extern \"C\" fn __run_expand2(\n             // Put the `cached_buffer` back in the `Bridge`, for requests.\n             Bridge::with(|bridge| bridge.cached_buffer = b.take());\n \n-            let output = f(::TokenStream(input), ::TokenStream(input2)).0;\n+            let output = f(crate::TokenStream(input), crate::TokenStream(input2)).0;\n \n             // Take the `cached_buffer` back out, for the output value.\n             b = Bridge::with(|bridge| bridge.cached_buffer.take());\n@@ -432,8 +435,10 @@ pub extern \"C\" fn __run_expand2(\n     b\n }\n \n-impl Client<fn(::TokenStream, ::TokenStream) -> ::TokenStream> {\n-    pub const fn expand2(f: fn(::TokenStream, ::TokenStream) -> ::TokenStream) -> Self {\n+impl Client<fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream> {\n+    pub const fn expand2(\n+        f: fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream\n+    ) -> Self {\n         Client {\n             get_handle_counters: HandleCounters::get,\n             run: __run_expand2,\n@@ -448,25 +453,25 @@ pub enum ProcMacro {\n     CustomDerive {\n         trait_name: &'static str,\n         attributes: &'static [&'static str],\n-        client: Client<fn(::TokenStream) -> ::TokenStream>,\n+        client: Client<fn(crate::TokenStream) -> crate::TokenStream>,\n     },\n \n     Attr {\n         name: &'static str,\n-        client: Client<fn(::TokenStream, ::TokenStream) -> ::TokenStream>,\n+        client: Client<fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream>,\n     },\n \n     Bang {\n         name: &'static str,\n-        client: Client<fn(::TokenStream) -> ::TokenStream>,\n+        client: Client<fn(crate::TokenStream) -> crate::TokenStream>,\n     },\n }\n \n impl ProcMacro {\n     pub const fn custom_derive(\n         trait_name: &'static str,\n         attributes: &'static [&'static str],\n-        expand: fn(::TokenStream) -> ::TokenStream,\n+        expand: fn(crate::TokenStream) -> crate::TokenStream,\n     ) -> Self {\n         ProcMacro::CustomDerive {\n             trait_name,\n@@ -477,15 +482,18 @@ impl ProcMacro {\n \n     pub const fn attr(\n         name: &'static str,\n-        expand: fn(::TokenStream, ::TokenStream) -> ::TokenStream,\n+        expand: fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream,\n     ) -> Self {\n         ProcMacro::Attr {\n             name,\n             client: Client::expand2(expand),\n         }\n     }\n \n-    pub const fn bang(name: &'static str, expand: fn(::TokenStream) -> ::TokenStream) -> Self {\n+    pub const fn bang(\n+        name: &'static str,\n+        expand: fn(crate::TokenStream) -> crate::TokenStream\n+    ) -> Self {\n         ProcMacro::Bang {\n             name,\n             client: Client::expand1(expand),"}, {"sha": "3173651b0395128bf59232f23578b63854881cc0", "filename": "src/libproc_macro/bridge/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibproc_macro%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibproc_macro%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fmod.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -17,7 +17,7 @@ use std::panic;\n use std::sync::atomic::AtomicUsize;\n use std::sync::Once;\n use std::thread;\n-use {Delimiter, Level, LineColumn, Spacing};\n+use crate::{Delimiter, Level, LineColumn, Spacing};\n \n /// Higher-order macro describing the server RPC API, allowing automatic\n /// generation of type-safe Rust APIs, both client-side and server-side.\n@@ -196,9 +196,9 @@ mod scoped_cell;\n #[forbid(unsafe_code)]\n pub mod server;\n \n-use self::buffer::Buffer;\n-pub use self::rpc::PanicMessage;\n-use self::rpc::{Decode, DecodeMut, Encode, Reader, Writer};\n+use buffer::Buffer;\n+pub use rpc::PanicMessage;\n+use rpc::{Decode, DecodeMut, Encode, Reader, Writer};\n \n /// An active connection between a server and a client.\n /// The server creates the bridge (`Bridge::run_server` in `server.rs`),"}, {"sha": "a3bc0d229084679e232db6d554c626647cac6022", "filename": "src/libproc_macro/bridge/rpc.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibproc_macro%2Fbridge%2Frpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibproc_macro%2Fbridge%2Frpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Frpc.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -40,7 +40,7 @@ macro_rules! rpc_encode_decode {\n         }\n \n         impl<S> DecodeMut<'_, '_, S> for $ty {\n-            fn decode(r: &mut Reader, s: &mut S) -> Self {\n+            fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n                 let mut byte = 0x80;\n                 let mut v = 0;\n                 let mut shift = 0;\n@@ -61,7 +61,7 @@ macro_rules! rpc_encode_decode {\n         }\n \n         impl<S> DecodeMut<'_, '_, S> for $name {\n-            fn decode(r: &mut Reader, s: &mut S) -> Self {\n+            fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n                 $name {\n                     $($field: DecodeMut::decode(r, s)),*\n                 }\n@@ -119,7 +119,7 @@ impl<S> Encode<S> for () {\n }\n \n impl<S> DecodeMut<'_, '_, S> for () {\n-    fn decode(_: &mut Reader, _: &mut S) -> Self {}\n+    fn decode(_: &mut Reader<'_>, _: &mut S) -> Self {}\n }\n \n impl<S> Encode<S> for u8 {\n@@ -129,7 +129,7 @@ impl<S> Encode<S> for u8 {\n }\n \n impl<S> DecodeMut<'_, '_, S> for u8 {\n-    fn decode(r: &mut Reader, _: &mut S) -> Self {\n+    fn decode(r: &mut Reader<'_>, _: &mut S) -> Self {\n         let x = r[0];\n         *r = &r[1..];\n         x\n@@ -146,7 +146,7 @@ impl<S> Encode<S> for bool {\n }\n \n impl<S> DecodeMut<'_, '_, S> for bool {\n-    fn decode(r: &mut Reader, s: &mut S) -> Self {\n+    fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n         match u8::decode(r, s) {\n             0 => false,\n             1 => true,\n@@ -162,7 +162,7 @@ impl<S> Encode<S> for char {\n }\n \n impl<S> DecodeMut<'_, '_, S> for char {\n-    fn decode(r: &mut Reader, s: &mut S) -> Self {\n+    fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n         char::from_u32(u32::decode(r, s)).unwrap()\n     }\n }\n@@ -174,7 +174,7 @@ impl<S> Encode<S> for NonZeroU32 {\n }\n \n impl<S> DecodeMut<'_, '_, S> for NonZeroU32 {\n-    fn decode(r: &mut Reader, s: &mut S) -> Self {\n+    fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n         Self::new(u32::decode(r, s)).unwrap()\n     }\n }\n@@ -251,7 +251,7 @@ impl<S> Encode<S> for String {\n }\n \n impl<S> DecodeMut<'_, '_, S> for String {\n-    fn decode(r: &mut Reader, s: &mut S) -> Self {\n+    fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n         <&str>::decode(r, s).to_string()\n     }\n }\n@@ -306,7 +306,7 @@ impl<S> Encode<S> for PanicMessage {\n }\n \n impl<S> DecodeMut<'_, '_, S> for PanicMessage {\n-    fn decode(r: &mut Reader, s: &mut S) -> Self {\n+    fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n         match Option::<String>::decode(r, s) {\n             Some(s) => PanicMessage::String(s),\n             None => PanicMessage::Unknown,"}, {"sha": "6f7965095b638504873c644ccc7a6804234cd6e4", "filename": "src/libproc_macro/bridge/scoped_cell.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibproc_macro%2Fbridge%2Fscoped_cell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibproc_macro%2Fbridge%2Fscoped_cell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fscoped_cell.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -38,7 +38,7 @@ impl<T: LambdaL> ScopedCell<T> {\n         ScopedCell(Cell::new(value))\n     }\n \n-    /// Set the value in `self` to `replacement` while\n+    /// Sets the value in `self` to `replacement` while\n     /// running `f`, which gets the old value, mutably.\n     /// The old value will be restored after `f` exits, even\n     /// by panic, including modifications made to it by `f`.\n@@ -73,7 +73,7 @@ impl<T: LambdaL> ScopedCell<T> {\n         f(RefMutL(put_back_on_drop.value.as_mut().unwrap()))\n     }\n \n-    /// Set the value in `self` to `value` while running `f`.\n+    /// Sets the value in `self` to `value` while running `f`.\n     pub fn set<'a, R>(&self, value: <T as ApplyL<'a>>::Out, f: impl FnOnce() -> R) -> R {\n         self.replace(value, |_| f())\n     }"}, {"sha": "75806eb9d17602edbae8da9143391ba067d81897", "filename": "src/libproc_macro/bridge/server.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibproc_macro%2Fbridge%2Fserver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibproc_macro%2Fbridge%2Fserver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fserver.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -131,7 +131,7 @@ pub trait ExecutionStrategy {\n         &self,\n         dispatcher: &mut impl DispatcherTrait,\n         input: Buffer<u8>,\n-        run_client: extern \"C\" fn(Bridge, D) -> Buffer<u8>,\n+        run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer<u8>,\n         client_data: D,\n     ) -> Buffer<u8>;\n }\n@@ -143,7 +143,7 @@ impl ExecutionStrategy for SameThread {\n         &self,\n         dispatcher: &mut impl DispatcherTrait,\n         input: Buffer<u8>,\n-        run_client: extern \"C\" fn(Bridge, D) -> Buffer<u8>,\n+        run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer<u8>,\n         client_data: D,\n     ) -> Buffer<u8> {\n         let mut dispatch = |b| dispatcher.dispatch(b);\n@@ -168,7 +168,7 @@ impl ExecutionStrategy for CrossThread1 {\n         &self,\n         dispatcher: &mut impl DispatcherTrait,\n         input: Buffer<u8>,\n-        run_client: extern \"C\" fn(Bridge, D) -> Buffer<u8>,\n+        run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer<u8>,\n         client_data: D,\n     ) -> Buffer<u8> {\n         use std::sync::mpsc::channel;\n@@ -206,7 +206,7 @@ impl ExecutionStrategy for CrossThread2 {\n         &self,\n         dispatcher: &mut impl DispatcherTrait,\n         input: Buffer<u8>,\n-        run_client: extern \"C\" fn(Bridge, D) -> Buffer<u8>,\n+        run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer<u8>,\n         client_data: D,\n     ) -> Buffer<u8> {\n         use std::sync::{Arc, Mutex};\n@@ -273,7 +273,7 @@ fn run_server<\n     handle_counters: &'static client::HandleCounters,\n     server: S,\n     input: I,\n-    run_client: extern \"C\" fn(Bridge, D) -> Buffer<u8>,\n+    run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer<u8>,\n     client_data: D,\n ) -> Result<O, PanicMessage> {\n     let mut dispatcher = Dispatcher {\n@@ -289,7 +289,7 @@ fn run_server<\n     Result::decode(&mut &b[..], &mut dispatcher.handle_store)\n }\n \n-impl client::Client<fn(::TokenStream) -> ::TokenStream> {\n+impl client::Client<fn(crate::TokenStream) -> crate::TokenStream> {\n     pub fn run<S: Server>(\n         &self,\n         strategy: &impl ExecutionStrategy,\n@@ -313,7 +313,7 @@ impl client::Client<fn(::TokenStream) -> ::TokenStream> {\n     }\n }\n \n-impl client::Client<fn(::TokenStream, ::TokenStream) -> ::TokenStream> {\n+impl client::Client<fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream> {\n     pub fn run<S: Server>(\n         &self,\n         strategy: &impl ExecutionStrategy,"}, {"sha": "65eebb5ec37374a47fcbf356ac7e5e390d8316b8", "filename": "src/libproc_macro/diagnostic.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibproc_macro%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibproc_macro%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fdiagnostic.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,4 +1,4 @@\n-use Span;\n+use crate::Span;\n \n /// An enum representing a diagnostic level.\n #[unstable(feature = \"proc_macro_diagnostic\", issue = \"54140\")]\n@@ -56,7 +56,7 @@ pub struct Diagnostic {\n \n macro_rules! diagnostic_child_methods {\n     ($spanned:ident, $regular:ident, $level:expr) => (\n-        /// Add a new child diagnostic message to `self` with the level\n+        /// Adds a new child diagnostic message to `self` with the level\n         /// identified by this method's name with the given `spans` and\n         /// `message`.\n         #[unstable(feature = \"proc_macro_diagnostic\", issue = \"54140\")]\n@@ -67,7 +67,7 @@ macro_rules! diagnostic_child_methods {\n             self\n         }\n \n-        /// Add a new child diagnostic message to `self` with the level\n+        /// Adds a new child diagnostic message to `self` with the level\n         /// identified by this method's name with the given `message`.\n         #[unstable(feature = \"proc_macro_diagnostic\", issue = \"54140\")]\n         pub fn $regular<T: Into<String>>(mut self, message: T) -> Diagnostic {\n@@ -80,7 +80,7 @@ macro_rules! diagnostic_child_methods {\n /// Iterator over the children diagnostics of a `Diagnostic`.\n #[derive(Debug, Clone)]\n #[unstable(feature = \"proc_macro_diagnostic\", issue = \"54140\")]\n-pub struct Children<'a>(::std::slice::Iter<'a, Diagnostic>);\n+pub struct Children<'a>(std::slice::Iter<'a, Diagnostic>);\n \n #[unstable(feature = \"proc_macro_diagnostic\", issue = \"54140\")]\n impl<'a> Iterator for Children<'a> {\n@@ -93,7 +93,7 @@ impl<'a> Iterator for Children<'a> {\n \n #[unstable(feature = \"proc_macro_diagnostic\", issue = \"54140\")]\n impl Diagnostic {\n-    /// Create a new diagnostic with the given `level` and `message`.\n+    /// Creates a new diagnostic with the given `level` and `message`.\n     #[unstable(feature = \"proc_macro_diagnostic\", issue = \"54140\")]\n     pub fn new<T: Into<String>>(level: Level, message: T) -> Diagnostic {\n         Diagnostic {\n@@ -104,7 +104,7 @@ impl Diagnostic {\n         }\n     }\n \n-    /// Create a new diagnostic with the given `level` and `message` pointing to\n+    /// Creates a new diagnostic with the given `level` and `message` pointing to\n     /// the given set of `spans`.\n     #[unstable(feature = \"proc_macro_diagnostic\", issue = \"54140\")]\n     pub fn spanned<S, T>(spans: S, level: Level, message: T) -> Diagnostic\n@@ -161,22 +161,22 @@ impl Diagnostic {\n \n     /// Returns an iterator over the children diagnostics of `self`.\n     #[unstable(feature = \"proc_macro_diagnostic\", issue = \"54140\")]\n-    pub fn children(&self) -> Children {\n+    pub fn children(&self) -> Children<'_> {\n         Children(self.children.iter())\n     }\n \n     /// Emit the diagnostic.\n     #[unstable(feature = \"proc_macro_diagnostic\", issue = \"54140\")]\n     pub fn emit(self) {\n-        fn to_internal(spans: Vec<Span>) -> ::bridge::client::MultiSpan {\n-            let mut multi_span = ::bridge::client::MultiSpan::new();\n+        fn to_internal(spans: Vec<Span>) -> crate::bridge::client::MultiSpan {\n+            let mut multi_span = crate::bridge::client::MultiSpan::new();\n             for span in spans {\n                 multi_span.push(span.0);\n             }\n             multi_span\n         }\n \n-        let mut diag = ::bridge::client::Diagnostic::new(\n+        let mut diag = crate::bridge::client::Diagnostic::new(\n             self.level,\n             &self.message[..],\n             to_internal(self.spans),"}, {"sha": "6c061189d00d7915002da588f0452ce5645a6227", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -5,18 +5,20 @@\n //! function-like macros `#[proc_macro]`, macro attributes `#[proc_macro_attribute]` and\n //! custom derive attributes`#[proc_macro_derive]`.\n //!\n-//! See [the book](../book/first-edition/procedural-macros.html) for more.\n+//! See [the book] for more.\n+//!\n+//! [the book]: ../book/ch19-06-macros.html#procedural-macros-for-generating-code-from-attributes\n \n #![stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n #![deny(missing_docs)]\n-#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-       html_root_url = \"https://doc.rust-lang.org/nightly/\",\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"https://play.rust-lang.org/\",\n        issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\",\n        test(no_crate_inject, attr(deny(warnings))),\n        test(attr(allow(dead_code, deprecated, unused_variables, unused_mut))))]\n \n+#![deny(rust_2018_idioms)]\n+\n #![feature(nll)]\n #![feature(staged_api)]\n #![feature(const_fn)]\n@@ -89,7 +91,7 @@ impl TokenStream {\n /// or characters not existing in the language.\n /// All tokens in the parsed stream get `Span::call_site()` spans.\n ///\n-/// NOTE: Some errors may cause panics instead of returning `LexError`. We reserve the right to\n+/// NOTE: some errors may cause panics instead of returning `LexError`. We reserve the right to\n /// change these errors into `LexError`s later.\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl FromStr for TokenStream {\n@@ -114,15 +116,15 @@ impl ToString for TokenStream {\n /// with `Delimiter::None` delimiters and negative numeric literals.\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl fmt::Display for TokenStream {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.write_str(&self.to_string())\n     }\n }\n \n /// Prints token in a form convenient for debugging.\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl fmt::Debug for TokenStream {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.write_str(\"TokenStream \")?;\n         f.debug_list().entries(self.clone()).finish()\n     }\n@@ -183,7 +185,7 @@ impl Extend<TokenStream> for TokenStream {\n /// Public implementation details for the `TokenStream` type, such as iterators.\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n pub mod token_stream {\n-    use {bridge, Group, Ident, Literal, Punct, TokenTree, TokenStream};\n+    use crate::{bridge, Group, Ident, Literal, Punct, TokenTree, TokenStream};\n \n     /// An iterator over `TokenStream`'s `TokenTree`s.\n     /// The iteration is \"shallow\", e.g., the iterator doesn't recurse into delimited groups,\n@@ -245,7 +247,7 @@ impl !Sync for Span {}\n \n macro_rules! diagnostic_method {\n     ($name:ident, $level:expr) => (\n-        /// Create a new `Diagnostic` with the given `message` at the span\n+        /// Creates a new `Diagnostic` with the given `message` at the span\n         /// `self`.\n         #[unstable(feature = \"proc_macro_diagnostic\", issue = \"54140\")]\n         pub fn $name<T: Into<String>>(self, message: T) -> Diagnostic {\n@@ -291,19 +293,19 @@ impl Span {\n         Span(self.0.source())\n     }\n \n-    /// Get the starting line/column in the source file for this span.\n+    /// Gets the starting line/column in the source file for this span.\n     #[unstable(feature = \"proc_macro_span\", issue = \"54725\")]\n     pub fn start(&self) -> LineColumn {\n         self.0.start()\n     }\n \n-    /// Get the ending line/column in the source file for this span.\n+    /// Gets the ending line/column in the source file for this span.\n     #[unstable(feature = \"proc_macro_span\", issue = \"54725\")]\n     pub fn end(&self) -> LineColumn {\n         self.0.end()\n     }\n \n-    /// Create a new span encompassing `self` and `other`.\n+    /// Creates a new span encompassing `self` and `other`.\n     ///\n     /// Returns `None` if `self` and `other` are from different files.\n     #[unstable(feature = \"proc_macro_span\", issue = \"54725\")]\n@@ -340,7 +342,7 @@ impl Span {\n /// Prints a span in a form convenient for debugging.\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Debug for Span {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         self.0.fmt(f)\n     }\n }\n@@ -369,7 +371,7 @@ impl !Sync for LineColumn {}\n pub struct SourceFile(bridge::client::SourceFile);\n \n impl SourceFile {\n-    /// Get the path to this source file.\n+    /// Gets the path to this source file.\n     ///\n     /// ### Note\n     /// If the code span associated with this `SourceFile` was generated by an external macro, this\n@@ -398,7 +400,7 @@ impl SourceFile {\n \n #[unstable(feature = \"proc_macro_span\", issue = \"54725\")]\n impl fmt::Debug for SourceFile {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_struct(\"SourceFile\")\n             .field(\"path\", &self.path())\n             .field(\"is_real\", &self.is_real())\n@@ -483,7 +485,7 @@ impl TokenTree {\n /// Prints token tree in a form convenient for debugging.\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Debug for TokenTree {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // Each of these has the name in the struct type in the derived debug,\n         // so don't bother with an extra layer of indirection\n         match *self {\n@@ -542,7 +544,7 @@ impl ToString for TokenTree {\n /// with `Delimiter::None` delimiters and negative numeric literals.\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Display for TokenTree {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.write_str(&self.to_string())\n     }\n }\n@@ -667,14 +669,14 @@ impl ToString for Group {\n /// with `Delimiter::None` delimiters.\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Display for Group {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.write_str(&self.to_string())\n     }\n }\n \n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Debug for Group {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_struct(\"Group\")\n             .field(\"delimiter\", &self.delimiter())\n             .field(\"stream\", &self.stream())\n@@ -763,14 +765,14 @@ impl ToString for Punct {\n /// back into the same character.\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Display for Punct {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.write_str(&self.to_string())\n     }\n }\n \n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Debug for Punct {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_struct(\"Punct\")\n             .field(\"ch\", &self.as_char())\n             .field(\"spacing\", &self.spacing())\n@@ -842,14 +844,14 @@ impl ToString for Ident {\n /// back into the same identifier.\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Display for Ident {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.write_str(&self.to_string())\n     }\n }\n \n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Debug for Ident {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_struct(\"Ident\")\n             .field(\"ident\", &self.to_string())\n             .field(\"span\", &self.span())\n@@ -1092,14 +1094,14 @@ impl ToString for Literal {\n /// back into the same literal (except for possible rounding for floating point literals).\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Display for Literal {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.write_str(&self.to_string())\n     }\n }\n \n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Debug for Literal {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // FIXME(eddyb) `Literal` should not expose internal `Debug` impls.\n         self.0.fmt(f)\n     }"}, {"sha": "e3d31b78f4a09258b398160bd9185d5f2671e80a", "filename": "src/libproc_macro/quote.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibproc_macro%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibproc_macro%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fquote.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -4,7 +4,7 @@\n //! This quasiquoter uses macros 2.0 hygiene to reliably access\n //! items from `proc_macro`, to build a `proc_macro::TokenStream`.\n \n-use {Delimiter, Group, Ident, Literal, Punct, Spacing, Span, TokenStream, TokenTree};\n+use crate::{Delimiter, Group, Ident, Literal, Punct, Spacing, Span, TokenStream, TokenTree};\n \n macro_rules! quote_tt {\n     (($($t:tt)*)) => { Group::new(Delimiter::Parenthesis, quote!($($t)*)) };\n@@ -63,7 +63,7 @@ macro_rules! quote {\n #[unstable(feature = \"proc_macro_quote\", issue = \"54722\")]\n pub fn quote(stream: TokenStream) -> TokenStream {\n     if stream.is_empty() {\n-        return quote!(::TokenStream::new());\n+        return quote!(crate::TokenStream::new());\n     }\n     let mut after_dollar = false;\n     let tokens = stream\n@@ -73,7 +73,7 @@ pub fn quote(stream: TokenStream) -> TokenStream {\n                 after_dollar = false;\n                 match tree {\n                     TokenTree::Ident(_) => {\n-                        return Some(quote!(Into::<::TokenStream>::into(\n+                        return Some(quote!(Into::<crate::TokenStream>::into(\n                         Clone::clone(&(@ tree))),));\n                     }\n                     TokenTree::Punct(ref tt) if tt.as_char() == '$' => {}\n@@ -86,33 +86,33 @@ pub fn quote(stream: TokenStream) -> TokenStream {\n                 }\n             }\n \n-            Some(quote!(::TokenStream::from((@ match tree {\n-                TokenTree::Punct(tt) => quote!(::TokenTree::Punct(::Punct::new(\n+            Some(quote!(crate::TokenStream::from((@ match tree {\n+                TokenTree::Punct(tt) => quote!(crate::TokenTree::Punct(crate::Punct::new(\n                     (@ TokenTree::from(Literal::character(tt.as_char()))),\n                     (@ match tt.spacing() {\n-                        Spacing::Alone => quote!(::Spacing::Alone),\n-                        Spacing::Joint => quote!(::Spacing::Joint),\n+                        Spacing::Alone => quote!(crate::Spacing::Alone),\n+                        Spacing::Joint => quote!(crate::Spacing::Joint),\n                     }),\n                 ))),\n-                TokenTree::Group(tt) => quote!(::TokenTree::Group(::Group::new(\n+                TokenTree::Group(tt) => quote!(crate::TokenTree::Group(crate::Group::new(\n                     (@ match tt.delimiter() {\n-                        Delimiter::Parenthesis => quote!(::Delimiter::Parenthesis),\n-                        Delimiter::Brace => quote!(::Delimiter::Brace),\n-                        Delimiter::Bracket => quote!(::Delimiter::Bracket),\n-                        Delimiter::None => quote!(::Delimiter::None),\n+                        Delimiter::Parenthesis => quote!(crate::Delimiter::Parenthesis),\n+                        Delimiter::Brace => quote!(crate::Delimiter::Brace),\n+                        Delimiter::Bracket => quote!(crate::Delimiter::Bracket),\n+                        Delimiter::None => quote!(crate::Delimiter::None),\n                     }),\n                     (@ quote(tt.stream())),\n                 ))),\n-                TokenTree::Ident(tt) => quote!(::TokenTree::Ident(::Ident::new(\n+                TokenTree::Ident(tt) => quote!(crate::TokenTree::Ident(crate::Ident::new(\n                     (@ TokenTree::from(Literal::string(&tt.to_string()))),\n                     (@ quote_span(tt.span())),\n                 ))),\n-                TokenTree::Literal(tt) => quote!(::TokenTree::Literal({\n+                TokenTree::Literal(tt) => quote!(crate::TokenTree::Literal({\n                     let mut iter = (@ TokenTree::from(Literal::string(&tt.to_string())))\n-                        .parse::<::TokenStream>()\n+                        .parse::<crate::TokenStream>()\n                         .unwrap()\n                         .into_iter();\n-                    if let (Some(::TokenTree::Literal(mut lit)), None) =\n+                    if let (Some(crate::TokenTree::Literal(mut lit)), None) =\n                         (iter.next(), iter.next())\n                     {\n                         lit.set_span((@ quote_span(tt.span())));\n@@ -129,12 +129,12 @@ pub fn quote(stream: TokenStream) -> TokenStream {\n         panic!(\"unexpected trailing `$` in `quote!`\");\n     }\n \n-    quote!([(@ tokens)].iter().cloned().collect::<::TokenStream>())\n+    quote!([(@ tokens)].iter().cloned().collect::<crate::TokenStream>())\n }\n \n /// Quote a `Span` into a `TokenStream`.\n /// This is needed to implement a custom quoter.\n #[unstable(feature = \"proc_macro_quote\", issue = \"54722\")]\n pub fn quote_span(_: Span) -> TokenStream {\n-    quote!(::Span::def_site())\n+    quote!(crate::Span::def_site())\n }"}, {"sha": "0d36bd0b39d76b69a3f7e835e5e5c579828425f4", "filename": "src/libprofiler_builtins/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibprofiler_builtins%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibprofiler_builtins%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibprofiler_builtins%2FCargo.toml?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -3,6 +3,7 @@ authors = [\"The Rust Project Developers\"]\n build = \"build.rs\"\n name = \"profiler_builtins\"\n version = \"0.0.0\"\n+edition = \"2018\"\n \n [lib]\n name = \"profiler_builtins\""}, {"sha": "ff52a03d9dd9725fc0fed1c280be447e1ff7dec9", "filename": "src/libprofiler_builtins/build.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibprofiler_builtins%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibprofiler_builtins%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibprofiler_builtins%2Fbuild.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -2,8 +2,6 @@\n //!\n //! See the build.rs for libcompiler_builtins crate for details.\n \n-extern crate cc;\n-\n use std::env;\n use std::path::Path;\n "}, {"sha": "2ce1a110b44c0c8f8d080599ee008f71a7f0dabb", "filename": "src/libprofiler_builtins/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibprofiler_builtins%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibprofiler_builtins%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibprofiler_builtins%2Flib.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -7,3 +7,4 @@\n #![allow(unused_features)]\n #![feature(nll)]\n #![feature(staged_api)]\n+#![deny(rust_2018_idioms)]"}, {"sha": "cb9eb32f8d21fda94fcc3e4d0d2ceb807e7f67e4", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -2,6 +2,7 @@\n authors = [\"The Rust Project Developers\"]\n name = \"rustc\"\n version = \"0.0.0\"\n+edition = \"2018\"\n \n [lib]\n name = \"rustc\"\n@@ -24,7 +25,7 @@ rustc-rayon-core = \"0.1.1\"\n rustc_apfloat = { path = \"../librustc_apfloat\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n-rustc_errors = { path = \"../librustc_errors\" }\n+errors = { path = \"../librustc_errors\", package = \"rustc_errors\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "f7ffbe8c65833af10c0a040c39df216296a7cd42", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,11 +1,11 @@\n-use cfg::*;\n-use middle::region;\n+use crate::cfg::*;\n+use crate::middle::region;\n use rustc_data_structures::graph::implementation as graph;\n use syntax::ptr::P;\n-use ty::{self, TyCtxt};\n+use crate::ty::{self, TyCtxt};\n \n-use hir::{self, PatKind};\n-use hir::def_id::DefId;\n+use crate::hir::{self, PatKind};\n+use crate::hir::def_id::DefId;\n \n struct CFGBuilder<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "969c38bd663298142a3501de55325566ca8f999f", "filename": "src/librustc/cfg/graphviz.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fgraphviz.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -4,9 +4,9 @@\n // For clarity, rename the graphviz crate locally to dot.\n use graphviz as dot;\n \n-use cfg;\n-use hir;\n-use ty::TyCtxt;\n+use crate::cfg;\n+use crate::hir;\n+use crate::ty::TyCtxt;\n \n pub type Node<'a> = (cfg::CFGIndex, &'a cfg::CFGNode);\n pub type Edge<'a> = &'a cfg::CFGEdge;"}, {"sha": "345dff88b5f0b14e1b481b9d9ff294ef9527e908", "filename": "src/librustc/cfg/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fmod.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -2,9 +2,9 @@\n //! Uses `Graph` as the underlying representation.\n \n use rustc_data_structures::graph::implementation as graph;\n-use ty::TyCtxt;\n-use hir;\n-use hir::def_id::DefId;\n+use crate::ty::TyCtxt;\n+use crate::hir;\n+use crate::hir::def_id::DefId;\n \n mod construct;\n pub mod graphviz;"}, {"sha": "13f6f9533297340d1b52c052f72cf32977d1e6e2", "filename": "src/librustc/dep_graph/cgu_reuse_tracker.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fdep_graph%2Fcgu_reuse_tracker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fdep_graph%2Fcgu_reuse_tracker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fcgu_reuse_tracker.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -2,7 +2,7 @@\n //! compilation. This is used for incremental compilation tests and debug\n //! output.\n \n-use session::Session;\n+use crate::session::Session;\n use rustc_data_structures::fx::FxHashMap;\n use std::sync::{Arc, Mutex};\n use syntax_pos::Span;"}, {"sha": "f18ee3dced72d10c0e47de8af2c0ba7ef341f630", "filename": "src/librustc/dep_graph/debug.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fdep_graph%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fdep_graph%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdebug.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -22,7 +22,7 @@ impl DepNodeFilter {\n         }\n     }\n \n-    /// True if all nodes always pass the filter.\n+    /// Returns `true` if all nodes always pass the filter.\n     pub fn accepts_all(&self) -> bool {\n         self.text.is_empty()\n     }"}, {"sha": "796739c8721741df37065610fe8e541524dd4bb7", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -49,25 +49,25 @@\n //! user of the `DepNode` API of having to know how to compute the expected\n //! fingerprint for a given set of node parameters.\n \n-use mir::interpret::GlobalId;\n-use hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX};\n-use hir::map::DefPathHash;\n-use hir::HirId;\n+use crate::mir::interpret::GlobalId;\n+use crate::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX};\n+use crate::hir::map::DefPathHash;\n+use crate::hir::HirId;\n \n-use ich::{Fingerprint, StableHashingContext};\n+use crate::ich::{Fingerprint, StableHashingContext};\n use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n use std::fmt;\n use std::hash::Hash;\n use syntax_pos::symbol::InternedString;\n-use traits;\n-use traits::query::{\n+use crate::traits;\n+use crate::traits::query::{\n     CanonicalProjectionGoal, CanonicalTyGoal, CanonicalTypeOpAscribeUserTypeGoal,\n     CanonicalTypeOpEqGoal, CanonicalTypeOpSubtypeGoal, CanonicalPredicateGoal,\n     CanonicalTypeOpProvePredicateGoal, CanonicalTypeOpNormalizeGoal,\n };\n-use ty::{TyCtxt, FnSig, Instance, InstanceDef,\n+use crate::ty::{TyCtxt, FnSig, Instance, InstanceDef,\n          ParamEnv, ParamEnvAnd, Predicate, PolyFnSig, PolyTraitRef, Ty};\n-use ty::subst::Substs;\n+use crate::ty::subst::Substs;\n \n // erase!() just makes tokens go away. It's used to specify which macro argument\n // is repeated (i.e., which sub-expression of the macro we are in) but don't need\n@@ -302,7 +302,7 @@ macro_rules! define_dep_nodes {\n                 }\n             }\n \n-            /// Create a new, parameterless DepNode. This method will assert\n+            /// Creates a new, parameterless DepNode. This method will assert\n             /// that the DepNode corresponding to the given DepKind actually\n             /// does not require any parameters.\n             #[inline(always)]\n@@ -314,7 +314,7 @@ macro_rules! define_dep_nodes {\n                 }\n             }\n \n-            /// Extract the DefId corresponding to this DepNode. This will work\n+            /// Extracts the DefId corresponding to this DepNode. This will work\n             /// if two conditions are met:\n             ///\n             /// 1. The Fingerprint of the DepNode actually is a DefPathHash, and\n@@ -389,7 +389,7 @@ impl fmt::Debug for DepNode {\n \n         write!(f, \"(\")?;\n \n-        ::ty::tls::with_opt(|opt_tcx| {\n+        crate::ty::tls::with_opt(|opt_tcx| {\n             if let Some(tcx) = opt_tcx {\n                 if let Some(def_id) = self.extract_def_id(tcx) {\n                     write!(f, \"{}\", tcx.def_path_debug_str(def_id))?;\n@@ -798,7 +798,7 @@ impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for HirId {\n }\n \n /// A \"work product\" corresponds to a `.o` (or other) file that we\n-/// save in between runs. These ids do not have a DefId but rather\n+/// save in between runs. These IDs do not have a `DefId` but rather\n /// some independent path or string that persists between runs without\n /// the need to be mapped or unmapped. (This ensures we can serialize\n /// them even in the absence of a tcx.)\n@@ -825,6 +825,6 @@ impl WorkProductId {\n     }\n }\n \n-impl_stable_hash_for!(struct ::dep_graph::WorkProductId {\n+impl_stable_hash_for!(struct crate::dep_graph::WorkProductId {\n     hash\n });"}, {"sha": "94b832bea628ef915287bb3e293191aa27764173", "filename": "src/librustc/dep_graph/dep_tracking_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -2,7 +2,7 @@ use rustc_data_structures::fx::FxHashMap;\n use std::cell::RefCell;\n use std::hash::Hash;\n use std::marker::PhantomData;\n-use util::common::MemoizationMap;\n+use crate::util::common::MemoizationMap;\n \n use super::{DepKind, DepNodeIndex, DepGraph};\n \n@@ -43,7 +43,7 @@ impl<M: DepTrackingMapConfig> MemoizationMap for RefCell<DepTrackingMap<M>> {\n     ///\n     /// Here, `[op]` represents whatever nodes `op` reads in the\n     /// course of execution; `Map(key)` represents the node for this\n-    /// map; and `CurrentTask` represents the current task when\n+    /// map, and `CurrentTask` represents the current task when\n     /// `memoize` is invoked.\n     ///\n     /// **Important:** when `op` is invoked, the current task will be"}, {"sha": "8a2f79e6793c0c8295385f6546fa72aefaba9ee7", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 96, "deletions": 62, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -7,11 +7,11 @@ use rustc_data_structures::sync::{Lrc, Lock, AtomicU32, Ordering};\n use std::env;\n use std::hash::Hash;\n use std::collections::hash_map::Entry;\n-use ty::{self, TyCtxt};\n-use util::common::{ProfileQueriesMsg, profq_msg};\n+use crate::ty::{self, TyCtxt};\n+use crate::util::common::{ProfileQueriesMsg, profq_msg};\n use parking_lot::{Mutex, Condvar};\n \n-use ich::{StableHashingContext, StableHashingContextProvider, Fingerprint};\n+use crate::ich::{StableHashingContext, StableHashingContextProvider, Fingerprint};\n \n use super::debug::EdgeFilter;\n use super::dep_node::{DepNode, DepKind, WorkProductId};\n@@ -61,13 +61,13 @@ struct DepGraphData {\n \n     colors: DepNodeColorMap,\n \n-    /// A set of loaded diagnostics which has been emitted.\n+    /// A set of loaded diagnostics that have been emitted.\n     emitted_diagnostics: Mutex<FxHashSet<DepNodeIndex>>,\n \n     /// Used to wait for diagnostics to be emitted.\n     emitted_diagnostics_cond_var: Condvar,\n \n-    /// When we load, there may be `.o` files, cached mir, or other such\n+    /// When we load, there may be `.o` files, cached MIR, or other such\n     /// things available to us. If we find that they are not dirty, we\n     /// load the path to the file storing those work-products here into\n     /// this map. We can later look for and extract that data.\n@@ -79,6 +79,16 @@ struct DepGraphData {\n     loaded_from_cache: Lock<FxHashMap<DepNodeIndex, bool>>,\n }\n \n+pub fn hash_result<R>(hcx: &mut StableHashingContext<'_>, result: &R) -> Option<Fingerprint>\n+where\n+    R: for<'a> HashStable<StableHashingContext<'a>>,\n+{\n+    let mut stable_hasher = StableHasher::new();\n+    result.hash_stable(hcx, &mut stable_hasher);\n+\n+    Some(stable_hasher.finish())\n+}\n+\n impl DepGraph {\n \n     pub fn new(prev_graph: PreviousDepGraph,\n@@ -105,7 +115,7 @@ impl DepGraph {\n         }\n     }\n \n-    /// True if we are actually building the full dep-graph.\n+    /// Returns `true` if we are actually building the full dep-graph, and `false` otherwise.\n     #[inline]\n     pub fn is_fully_enabled(&self) -> bool {\n         self.data.is_some()\n@@ -178,14 +188,16 @@ impl DepGraph {\n     ///   `arg` parameter.\n     ///\n     /// [rustc guide]: https://rust-lang.github.io/rustc-guide/incremental-compilation.html\n-    pub fn with_task<'gcx, C, A, R>(&self,\n-                                   key: DepNode,\n-                                   cx: C,\n-                                   arg: A,\n-                                   task: fn(C, A) -> R)\n-                                   -> (R, DepNodeIndex)\n-        where C: DepGraphSafe + StableHashingContextProvider<'gcx>,\n-              R: HashStable<StableHashingContext<'gcx>>,\n+    pub fn with_task<'a, C, A, R>(\n+        &self,\n+        key: DepNode,\n+        cx: C,\n+        arg: A,\n+        task: fn(C, A) -> R,\n+        hash_result: impl FnOnce(&mut StableHashingContext<'_>, &R) -> Option<Fingerprint>,\n+    ) -> (R, DepNodeIndex)\n+    where\n+        C: DepGraphSafe + StableHashingContextProvider<'a>,\n     {\n         self.with_task_impl(key, cx, arg, false, task,\n             |_key| Some(TaskDeps {\n@@ -196,17 +208,18 @@ impl DepGraph {\n             }),\n             |data, key, fingerprint, task| {\n                 data.borrow_mut().complete_task(key, task.unwrap(), fingerprint)\n-            })\n+            },\n+            hash_result)\n     }\n \n     /// Creates a new dep-graph input with value `input`\n-    pub fn input_task<'gcx, C, R>(&self,\n+    pub fn input_task<'a, C, R>(&self,\n                                    key: DepNode,\n                                    cx: C,\n                                    input: R)\n                                    -> (R, DepNodeIndex)\n-        where C: DepGraphSafe + StableHashingContextProvider<'gcx>,\n-              R: HashStable<StableHashingContext<'gcx>>,\n+        where C: DepGraphSafe + StableHashingContextProvider<'a>,\n+              R: for<'b> HashStable<StableHashingContext<'b>>,\n     {\n         fn identity_fn<C, A>(_: C, arg: A) -> A {\n             arg\n@@ -216,10 +229,11 @@ impl DepGraph {\n             |_| None,\n             |data, key, fingerprint, _| {\n                 data.borrow_mut().alloc_node(key, SmallVec::new(), fingerprint)\n-            })\n+            },\n+            hash_result::<R>)\n     }\n \n-    fn with_task_impl<'gcx, C, A, R>(\n+    fn with_task_impl<'a, C, A, R>(\n         &self,\n         key: DepNode,\n         cx: C,\n@@ -230,11 +244,11 @@ impl DepGraph {\n         finish_task_and_alloc_depnode: fn(&Lock<CurrentDepGraph>,\n                                           DepNode,\n                                           Fingerprint,\n-                                          Option<TaskDeps>) -> DepNodeIndex\n+                                          Option<TaskDeps>) -> DepNodeIndex,\n+        hash_result: impl FnOnce(&mut StableHashingContext<'_>, &R) -> Option<Fingerprint>,\n     ) -> (R, DepNodeIndex)\n     where\n-        C: DepGraphSafe + StableHashingContextProvider<'gcx>,\n-        R: HashStable<StableHashingContext<'gcx>>,\n+        C: DepGraphSafe + StableHashingContextProvider<'a>,\n     {\n         if let Some(ref data) = self.data {\n             let task_deps = create_task(key).map(|deps| Lock::new(deps));\n@@ -269,33 +283,50 @@ impl DepGraph {\n                 profq_msg(hcx.sess(), ProfileQueriesMsg::TaskEnd)\n             };\n \n-            let mut stable_hasher = StableHasher::new();\n-            result.hash_stable(&mut hcx, &mut stable_hasher);\n-\n-            let current_fingerprint = stable_hasher.finish();\n+            let current_fingerprint = hash_result(&mut hcx, &result);\n \n             let dep_node_index = finish_task_and_alloc_depnode(\n                 &data.current,\n                 key,\n-                current_fingerprint,\n+                current_fingerprint.unwrap_or(Fingerprint::ZERO),\n                 task_deps.map(|lock| lock.into_inner()),\n             );\n \n+            let print_status = cfg!(debug_assertions) && hcx.sess().opts.debugging_opts.dep_tasks;\n+\n             // Determine the color of the new DepNode.\n             if let Some(prev_index) = data.previous.node_to_index_opt(&key) {\n                 let prev_fingerprint = data.previous.fingerprint_by_index(prev_index);\n \n-                let color = if current_fingerprint == prev_fingerprint {\n-                    DepNodeColor::Green(dep_node_index)\n+                let color = if let Some(current_fingerprint) = current_fingerprint {\n+                    if current_fingerprint == prev_fingerprint {\n+                        if print_status {\n+                            eprintln!(\"[task::green] {:?}\", key);\n+                        }\n+                        DepNodeColor::Green(dep_node_index)\n+                    } else {\n+                        if print_status {\n+                            eprintln!(\"[task::red] {:?}\", key);\n+                        }\n+                        DepNodeColor::Red\n+                    }\n                 } else {\n+                    if print_status {\n+                        eprintln!(\"[task::unknown] {:?}\", key);\n+                    }\n+                    // Mark the node as Red if we can't hash the result\n                     DepNodeColor::Red\n                 };\n \n                 debug_assert!(data.colors.get(prev_index).is_none(),\n-                              \"DepGraph::with_task() - Duplicate DepNodeColor \\\n-                               insertion for {:?}\", key);\n+                            \"DepGraph::with_task() - Duplicate DepNodeColor \\\n+                            insertion for {:?}\", key);\n \n                 data.colors.insert(prev_index, color);\n+            } else {\n+                if print_status {\n+                    eprintln!(\"[task::new] {:?}\", key);\n+                }\n             }\n \n             (result, dep_node_index)\n@@ -304,8 +335,8 @@ impl DepGraph {\n         }\n     }\n \n-    /// Execute something within an \"anonymous\" task, that is, a task the\n-    /// DepNode of which is determined by the list of inputs it read from.\n+    /// Executes something within an \"anonymous\" task, that is, a task the\n+    /// `DepNode` of which is determined by the list of inputs it read from.\n     pub fn with_anon_task<OP,R>(&self, dep_kind: DepKind, op: OP) -> (R, DepNodeIndex)\n         where OP: FnOnce() -> R\n     {\n@@ -340,16 +371,18 @@ impl DepGraph {\n         }\n     }\n \n-    /// Execute something within an \"eval-always\" task which is a task\n-    // that runs whenever anything changes.\n-    pub fn with_eval_always_task<'gcx, C, A, R>(&self,\n-                                   key: DepNode,\n-                                   cx: C,\n-                                   arg: A,\n-                                   task: fn(C, A) -> R)\n-                                   -> (R, DepNodeIndex)\n-        where C: DepGraphSafe + StableHashingContextProvider<'gcx>,\n-              R: HashStable<StableHashingContext<'gcx>>,\n+    /// Executes something within an \"eval-always\" task which is a task\n+    /// that runs whenever anything changes.\n+    pub fn with_eval_always_task<'a, C, A, R>(\n+        &self,\n+        key: DepNode,\n+        cx: C,\n+        arg: A,\n+        task: fn(C, A) -> R,\n+        hash_result: impl FnOnce(&mut StableHashingContext<'_>, &R) -> Option<Fingerprint>,\n+    ) -> (R, DepNodeIndex)\n+    where\n+        C: DepGraphSafe + StableHashingContextProvider<'a>,\n     {\n         self.with_task_impl(key, cx, arg, false, task,\n             |_| None,\n@@ -359,7 +392,8 @@ impl DepGraph {\n                     &DepNode::new_no_params(DepKind::Krate)\n                 ];\n                 current.alloc_node(key, smallvec![krate_idx], fingerprint)\n-            })\n+            },\n+            hash_result)\n     }\n \n     #[inline]\n@@ -419,7 +453,7 @@ impl DepGraph {\n         self.data.as_ref().unwrap().previous.node_to_index(dep_node)\n     }\n \n-    /// Check whether a previous work product exists for `v` and, if\n+    /// Checks whether a previous work product exists for `v` and, if\n     /// so, return the path that leads to it. Used to skip doing work.\n     pub fn previous_work_product(&self, v: &WorkProductId) -> Option<WorkProduct> {\n         self.data\n@@ -570,7 +604,7 @@ impl DepGraph {\n         }\n     }\n \n-    /// Try to mark a dep-node which existed in the previous compilation session as green\n+    /// Try to mark a dep-node which existed in the previous compilation session as green.\n     fn try_mark_previous_green<'tcx>(\n         &self,\n         tcx: TyCtxt<'_, 'tcx, 'tcx>,\n@@ -669,7 +703,7 @@ impl DepGraph {\n                     // We failed to mark it green, so we try to force the query.\n                     debug!(\"try_mark_previous_green({:?}) --- trying to force \\\n                             dependency {:?}\", dep_node, dep_dep_node);\n-                    if ::ty::query::force_from_dep_node(tcx, dep_dep_node) {\n+                    if crate::ty::query::force_from_dep_node(tcx, dep_dep_node) {\n                         let dep_dep_node_color = data.colors.get(dep_dep_node_index);\n \n                         match dep_dep_node_color {\n@@ -754,8 +788,8 @@ impl DepGraph {\n         Some(dep_node_index)\n     }\n \n-    /// Atomically emits some loaded diagnotics assuming that this only gets called with\n-    /// did_allocation set to true on one thread\n+    /// Atomically emits some loaded diagnotics, assuming that this only gets called with\n+    /// `did_allocation` set to `true` on a single thread.\n     #[cold]\n     #[inline(never)]\n     fn emit_diagnostics<'tcx>(\n@@ -894,7 +928,7 @@ impl DepGraph {\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct WorkProduct {\n     pub cgu_name: String,\n-    /// Saved files associated with this CGU\n+    /// Saved files associated with this CGU.\n     pub saved_files: Vec<(WorkProductFileKind, String)>,\n }\n \n@@ -918,17 +952,17 @@ pub(super) struct CurrentDepGraph {\n     #[allow(dead_code)]\n     forbidden_edge: Option<EdgeFilter>,\n \n-    // Anonymous DepNodes are nodes the ID of which we compute from the list of\n-    // their edges. This has the beneficial side-effect that multiple anonymous\n-    // nodes can be coalesced into one without changing the semantics of the\n-    // dependency graph. However, the merging of nodes can lead to a subtle\n-    // problem during red-green marking: The color of an anonymous node from\n-    // the current session might \"shadow\" the color of the node with the same\n-    // ID from the previous session. In order to side-step this problem, we make\n-    // sure that anon-node IDs allocated in different sessions don't overlap.\n-    // This is implemented by mixing a session-key into the ID fingerprint of\n-    // each anon node. The session-key is just a random number generated when\n-    // the DepGraph is created.\n+    /// Anonymous `DepNode`s are nodes whose IDs we compute from the list of\n+    /// their edges. This has the beneficial side-effect that multiple anonymous\n+    /// nodes can be coalesced into one without changing the semantics of the\n+    /// dependency graph. However, the merging of nodes can lead to a subtle\n+    /// problem during red-green marking: The color of an anonymous node from\n+    /// the current session might \"shadow\" the color of the node with the same\n+    /// ID from the previous session. In order to side-step this problem, we make\n+    /// sure that anonymous `NodeId`s allocated in different sessions don't overlap.\n+    /// This is implemented by mixing a session-key into the ID fingerprint of\n+    /// each anon node. The session-key is just a random number generated when\n+    /// the `DepGraph` is created.\n     anon_id_seed: Fingerprint,\n \n     total_read_count: u64,"}, {"sha": "b84d2ad145889bf1fab96fc39d908e98c508a874", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -10,7 +10,7 @@ pub mod cgu_reuse_tracker;\n \n pub use self::dep_tracking_map::{DepTrackingMap, DepTrackingMapConfig};\n pub use self::dep_node::{DepNode, DepKind, DepConstructor, WorkProductId, label_strs};\n-pub use self::graph::{DepGraph, WorkProduct, DepNodeIndex, DepNodeColor, TaskDeps};\n+pub use self::graph::{DepGraph, WorkProduct, DepNodeIndex, DepNodeColor, TaskDeps, hash_result};\n pub use self::graph::WorkProductFileKind;\n pub use self::prev::PreviousDepGraph;\n pub use self::query::DepGraphQuery;"}, {"sha": "d971690bbe317788f2cd887289fd8fbabcc3c049", "filename": "src/librustc/dep_graph/prev.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fdep_graph%2Fprev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fdep_graph%2Fprev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fprev.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,4 +1,4 @@\n-use ich::Fingerprint;\n+use crate::ich::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n use super::dep_node::DepNode;\n use super::serialized::{SerializedDepGraph, SerializedDepNodeIndex};"}, {"sha": "fc767defe9c712b4aed37c0dc8fc89fe71149581", "filename": "src/librustc/dep_graph/safe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fdep_graph%2Fsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fdep_graph%2Fsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fsafe.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,9 +1,9 @@\n //! The `DepGraphSafe` trait\n \n-use hir::BodyId;\n-use hir::def_id::DefId;\n+use crate::hir::BodyId;\n+use crate::hir::def_id::DefId;\n use syntax::ast::NodeId;\n-use ty::TyCtxt;\n+use crate::ty::TyCtxt;\n \n /// The `DepGraphSafe` trait is used to specify what kinds of values\n /// are safe to \"leak\" into a task. The idea is that this should be"}, {"sha": "b64f71ed908d823b079ced68670c3ae55389755a", "filename": "src/librustc/dep_graph/serialized.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fserialized.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,7 +1,7 @@\n //! The data that we will serialize and deserialize.\n \n-use dep_graph::DepNode;\n-use ich::Fingerprint;\n+use crate::dep_graph::DepNode;\n+use crate::ich::Fingerprint;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n \n newtype_index! {"}, {"sha": "f46ff6f6062c2648037fbc0ecfe2ac3a665c6ea8", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,3 +1,4 @@\n+// ignore-tidy-linelength\n #![allow(non_snake_case)]\n \n // Error messages for EXXXX errors.\n@@ -410,7 +411,7 @@ fn baz<'a>(x: &'a str, y: &str) -> &str { }\n Lifetime elision in implementation headers was part of the lifetime elision\n RFC. It is, however, [currently unimplemented][iss15872].\n \n-[book-le]: https://doc.rust-lang.org/nightly/book/first-edition/lifetimes.html#lifetime-elision\n+[book-le]: https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-elision\n [iss15872]: https://github.com/rust-lang/rust/issues/15872\n \"##,\n \n@@ -646,7 +647,9 @@ attributes:\n #![no_std]\n ```\n \n-See also https://doc.rust-lang.org/book/first-edition/no-stdlib.html\n+See also the [unstable book][1].\n+\n+[1]: https://doc.rust-lang.org/unstable-book/language-features/lang-items.html#writing-an-executable-without-stdlib\n \"##,\n \n E0214: r##\"\n@@ -1713,7 +1716,7 @@ fn main() {\n ```\n \n To understand better how closures work in Rust, read:\n-https://doc.rust-lang.org/book/first-edition/closures.html\n+https://doc.rust-lang.org/book/ch13-01-closures.html\n \"##,\n \n E0580: r##\""}, {"sha": "ddc1eebe645ae4b3cbba047bea93ec7f47cd3749", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -5,12 +5,12 @@\n //! item.\n \n \n-use ty::TyCtxt;\n-use ty::query::Providers;\n+use crate::ty::TyCtxt;\n+use crate::ty::query::Providers;\n \n-use hir;\n-use hir::def_id::DefId;\n-use hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use crate::hir;\n+use crate::hir::def_id::DefId;\n+use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use std::fmt::{self, Display};\n use syntax_pos::Span;\n \n@@ -91,7 +91,7 @@ struct CheckAttrVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n-    /// Check any attribute.\n+    /// Checks any attribute.\n     fn check_attributes(&self, item: &hir::Item, target: Target) {\n         if target == Target::Fn || target == Target::Const {\n             self.tcx.codegen_fn_attrs(self.tcx.hir().local_def_id(item.id));\n@@ -115,7 +115,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n         self.check_used(item, target);\n     }\n \n-    /// Check if an `#[inline]` is applied to a function or a closure.\n+    /// Checks if an `#[inline]` is applied to a function or a closure.\n     fn check_inline(&self, attr: &hir::Attribute, span: &Span, target: Target) {\n         if target != Target::Fn && target != Target::Closure {\n             struct_span_err!(self.tcx.sess,\n@@ -127,7 +127,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n         }\n     }\n \n-    /// Check if the `#[non_exhaustive]` attribute on an `item` is valid.\n+    /// Checks if the `#[non_exhaustive]` attribute on an `item` is valid.\n     fn check_non_exhaustive(&self, attr: &hir::Attribute, item: &hir::Item, target: Target) {\n         match target {\n             Target::Struct | Target::Enum => { /* Valid */ },\n@@ -143,7 +143,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n         }\n     }\n \n-    /// Check if the `#[marker]` attribute on an `item` is valid.\n+    /// Checks if the `#[marker]` attribute on an `item` is valid.\n     fn check_marker(&self, attr: &hir::Attribute, item: &hir::Item, target: Target) {\n         match target {\n             Target::Trait => { /* Valid */ },\n@@ -157,7 +157,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n         }\n     }\n \n-    /// Check if the `#[repr]` attributes on `item` are valid.\n+    /// Checks if the `#[repr]` attributes on `item` are valid.\n     fn check_repr(&self, item: &hir::Item, target: Target) {\n         // Extract the names of all repr hints, e.g., [foo, bar, align] for:\n         // ```\n@@ -186,8 +186,8 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n             };\n \n             let (article, allowed_targets) = match &*name.as_str() {\n-                \"C\" => {\n-                    is_c = true;\n+                \"C\" | \"align\" => {\n+                    is_c |= name == \"C\";\n                     if target != Target::Struct &&\n                             target != Target::Union &&\n                             target != Target::Enum {\n@@ -212,14 +212,6 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n                         continue\n                     }\n                 }\n-                \"align\" => {\n-                    if target != Target::Struct &&\n-                            target != Target::Union {\n-                        (\"a\", \"struct or union\")\n-                    } else {\n-                        continue\n-                    }\n-                }\n                 \"transparent\" => {\n                     is_transparent = true;\n                     if target != Target::Struct {"}, {"sha": "b15bea017762ea277a443d94a2e1160cbf7d03c0", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,10 +1,10 @@\n-use hir::def_id::DefId;\n-use util::nodemap::{NodeMap, DefIdMap};\n+use crate::hir::def_id::DefId;\n+use crate::util::nodemap::{NodeMap, DefIdMap};\n use syntax::ast;\n use syntax::ext::base::MacroKind;\n use syntax_pos::Span;\n-use hir;\n-use ty;\n+use crate::hir;\n+use crate::ty;\n \n use self::Namespace::*;\n \n@@ -52,6 +52,7 @@ pub enum Def {\n     AssociatedExistential(DefId),\n     PrimTy(hir::PrimTy),\n     TyParam(DefId),\n+    ConstParam(DefId),\n     SelfTy(Option<DefId> /* trait */, Option<DefId> /* impl */),\n     ToolMod, // e.g., `rustfmt` in `#[rustfmt::skip]`\n \n@@ -181,7 +182,7 @@ impl<T> ::std::ops::IndexMut<Namespace> for PerNS<T> {\n }\n \n impl<T> PerNS<Option<T>> {\n-    /// Returns whether all the items in this collection are `None`.\n+    /// Returns `true` if all the items in this collection are `None`.\n     pub fn is_empty(&self) -> bool {\n         self.type_ns.is_none() && self.value_ns.is_none() && self.macro_ns.is_none()\n     }\n@@ -265,7 +266,8 @@ impl Def {\n             Def::Fn(id) | Def::Mod(id) | Def::Static(id, _) |\n             Def::Variant(id) | Def::VariantCtor(id, ..) | Def::Enum(id) |\n             Def::TyAlias(id) | Def::TraitAlias(id) |\n-            Def::AssociatedTy(id) | Def::TyParam(id) | Def::Struct(id) | Def::StructCtor(id, ..) |\n+            Def::AssociatedTy(id) | Def::TyParam(id) | Def::ConstParam(id) | Def::Struct(id) |\n+            Def::StructCtor(id, ..) |\n             Def::Union(id) | Def::Trait(id) | Def::Method(id) | Def::Const(id) |\n             Def::AssociatedConst(id) | Def::Macro(id, ..) |\n             Def::Existential(id) | Def::AssociatedExistential(id) | Def::ForeignTy(id) => {\n@@ -322,6 +324,7 @@ impl Def {\n             Def::Const(..) => \"constant\",\n             Def::AssociatedConst(..) => \"associated constant\",\n             Def::TyParam(..) => \"type parameter\",\n+            Def::ConstParam(..) => \"const parameter\",\n             Def::PrimTy(..) => \"builtin type\",\n             Def::Local(..) => \"local variable\",\n             Def::Upvar(..) => \"closure capture\","}, {"sha": "ed1c15a73c260fc33128cb19f9095c00c1464390", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,6 +1,6 @@\n-use ty;\n-use ty::TyCtxt;\n-use hir::map::definitions::FIRST_FREE_HIGH_DEF_INDEX;\n+use crate::ty;\n+use crate::ty::TyCtxt;\n+use crate::hir::map::definitions::FIRST_FREE_HIGH_DEF_INDEX;\n use rustc_data_structures::indexed_vec::Idx;\n use serialize;\n use std::fmt;\n@@ -229,7 +229,7 @@ impl fmt::Debug for DefId {\n }\n \n impl DefId {\n-    /// Make a local `DefId` with the given index.\n+    /// Makes a local `DefId` from the given `DefIndex`.\n     #[inline]\n     pub fn local(index: DefIndex) -> DefId {\n         DefId { krate: LOCAL_CRATE, index: index }"}, {"sha": "9436c600c9fd3a06c20f269d3a93a02ce6f8163d", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -4,7 +4,7 @@\n //! `super::itemlikevisit::ItemLikeVisitor` trait.**\n //!\n //! If you have decided to use this visitor, here are some general\n-//! notes on how to do it:\n+//! notes on how to do so:\n //!\n //! Each overridden visit method has full control over what\n //! happens with its node, it can do its own traversal of the node's children,\n@@ -33,9 +33,9 @@\n \n use syntax::ast::{NodeId, CRATE_NODE_ID, Ident, Name, Attribute};\n use syntax_pos::Span;\n-use hir::*;\n-use hir::def::Def;\n-use hir::map::Map;\n+use crate::hir::*;\n+use crate::hir::def::Def;\n+use crate::hir::map::Map;\n use super::itemlikevisit::DeepVisitor;\n \n #[derive(Copy, Clone)]\n@@ -86,7 +86,7 @@ pub enum NestedVisitorMap<'this, 'tcx: 'this> {\n     /// using this setting.\n     OnlyBodies(&'this Map<'tcx>),\n \n-    /// Visit all nested things, including item-likes.\n+    /// Visits all nested things, including item-likes.\n     ///\n     /// **This is an unusual choice.** It is used when you want to\n     /// process everything within their lexical context. Typically you\n@@ -96,7 +96,7 @@ pub enum NestedVisitorMap<'this, 'tcx: 'this> {\n \n impl<'this, 'tcx> NestedVisitorMap<'this, 'tcx> {\n     /// Returns the map to use for an \"intra item-like\" thing (if any).\n-    /// e.g., function body.\n+    /// E.g., function body.\n     pub fn intra(self) -> Option<&'this Map<'tcx>> {\n         match self {\n             NestedVisitorMap::None => None,\n@@ -106,7 +106,7 @@ impl<'this, 'tcx> NestedVisitorMap<'this, 'tcx> {\n     }\n \n     /// Returns the map to use for an \"item-like\" thing (if any).\n-    /// e.g., item, impl-item.\n+    /// E.g., item, impl-item.\n     pub fn inter(self) -> Option<&'this Map<'tcx>> {\n         match self {\n             NestedVisitorMap::None => None,\n@@ -117,7 +117,7 @@ impl<'this, 'tcx> NestedVisitorMap<'this, 'tcx> {\n }\n \n /// Each method of the Visitor trait is a hook to be potentially\n-/// overridden.  Each method's default implementation recursively visits\n+/// overridden. Each method's default implementation recursively visits\n /// the substructure of the input via the corresponding `walk` method;\n /// e.g., the `visit_mod` method by default calls `intravisit::walk_mod`.\n ///\n@@ -129,7 +129,7 @@ impl<'this, 'tcx> NestedVisitorMap<'this, 'tcx> {\n /// on `visit_nested_item` for details on how to visit nested items.\n ///\n /// If you want to ensure that your code handles every variant\n-/// explicitly, you need to override each method.  (And you also need\n+/// explicitly, you need to override each method. (And you also need\n /// to monitor future changes to `Visitor` in case a new method with a\n /// new default implementation gets introduced.)\n pub trait Visitor<'v> : Sized {\n@@ -203,7 +203,7 @@ pub trait Visitor<'v> : Sized {\n         }\n     }\n \n-    /// Visit the top-level item and (optionally) nested items / impl items. See\n+    /// Visits the top-level item and (optionally) nested items / impl items. See\n     /// `visit_nested_item` for details.\n     fn visit_item(&mut self, i: &'v Item) {\n         walk_item(self, i)\n@@ -214,7 +214,7 @@ pub trait Visitor<'v> : Sized {\n     }\n \n     /// When invoking `visit_all_item_likes()`, you need to supply an\n-    /// item-like visitor.  This method converts a \"intra-visit\"\n+    /// item-like visitor. This method converts a \"intra-visit\"\n     /// visitor into an item-like visitor that walks the entire tree.\n     /// If you use this, you probably don't want to process the\n     /// contents of nested item-like things, since the outer loop will"}, {"sha": "84487c40f874508f4d6ad469d941139d1109266f", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 114, "deletions": 73, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -3,24 +3,24 @@\n //! Since the AST and HIR are fairly similar, this is mostly a simple procedure,\n //! much like a fold. Where lowering involves a bit more work things get more\n //! interesting and there are some invariants you should know about. These mostly\n-//! concern spans and ids.\n+//! concern spans and IDs.\n //!\n //! Spans are assigned to AST nodes during parsing and then are modified during\n //! expansion to indicate the origin of a node and the process it went through\n-//! being expanded. Ids are assigned to AST nodes just before lowering.\n+//! being expanded. IDs are assigned to AST nodes just before lowering.\n //!\n-//! For the simpler lowering steps, ids and spans should be preserved. Unlike\n+//! For the simpler lowering steps, IDs and spans should be preserved. Unlike\n //! expansion we do not preserve the process of lowering in the spans, so spans\n //! should not be modified here. When creating a new node (as opposed to\n-//! 'folding' an existing one), then you create a new id using `next_id()`.\n+//! 'folding' an existing one), then you create a new ID using `next_id()`.\n //!\n-//! You must ensure that ids are unique. That means that you should only use the\n-//! id from an AST node in a single HIR node (you can assume that AST node ids\n-//! are unique). Every new node must have a unique id. Avoid cloning HIR nodes.\n-//! If you do, you must then set the new node's id to a fresh one.\n+//! You must ensure that IDs are unique. That means that you should only use the\n+//! ID from an AST node in a single HIR node (you can assume that AST node IDs\n+//! are unique). Every new node must have a unique ID. Avoid cloning HIR nodes.\n+//! If you do, you must then set the new node's ID to a fresh one.\n //!\n //! Spans are used for error messages and for tools to map semantics back to\n-//! source code. It is therefore not as important with spans as ids to be strict\n+//! source code. It is therefore not as important with spans as IDs to be strict\n //! about use (you can't break the compiler by screwing up a span). Obviously, a\n //! HIR node can only have a single span. But multiple nodes can have the same\n //! span and spans don't need to be kept in order, etc. Where code is preserved\n@@ -30,24 +30,25 @@\n //! get confused if the spans from leaf AST nodes occur in multiple places\n //! in the HIR, especially for multiple identifiers.\n \n-use dep_graph::DepGraph;\n-use errors::Applicability;\n-use hir::{self, ParamName};\n-use hir::HirVec;\n-use hir::map::{DefKey, DefPathData, Definitions};\n-use hir::def_id::{DefId, DefIndex, DefIndexAddressSpace, CRATE_DEF_INDEX};\n-use hir::def::{Def, PathResolution, PerNS};\n-use hir::GenericArg;\n-use lint::builtin::{self, PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES,\n+use crate::dep_graph::DepGraph;\n+use crate::hir::{self, ParamName};\n+use crate::hir::HirVec;\n+use crate::hir::map::{DefKey, DefPathData, Definitions};\n+use crate::hir::def_id::{DefId, DefIndex, DefIndexAddressSpace, CRATE_DEF_INDEX};\n+use crate::hir::def::{Def, PathResolution, PerNS};\n+use crate::hir::GenericArg;\n+use crate::lint::builtin::{self, PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES,\n                     ELIDED_LIFETIMES_IN_PATHS};\n-use middle::cstore::CrateStore;\n+use crate::middle::cstore::CrateStore;\n+use crate::session::Session;\n+use crate::session::config::nightly_options;\n+use crate::util::common::FN_OUTPUT_NAME;\n+use crate::util::nodemap::{DefIdMap, NodeMap};\n+use errors::Applicability;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::thin_vec::ThinVec;\n-use session::Session;\n-use session::config::nightly_options;\n-use util::common::FN_OUTPUT_NAME;\n-use util::nodemap::{DefIdMap, NodeMap};\n+use rustc_data_structures::sync::Lrc;\n \n use std::collections::{BTreeSet, BTreeMap};\n use std::fmt::Debug;\n@@ -144,7 +145,7 @@ pub trait Resolver {\n         is_value: bool,\n     ) -> hir::Path;\n \n-    /// Obtain the resolution for a node-id.\n+    /// Obtain the resolution for a `NodeId`.\n     fn get_resolution(&mut self, id: NodeId) -> Option<PathResolution>;\n \n     /// Obtain the possible resolutions for the given `use` statement.\n@@ -273,10 +274,10 @@ enum ParenthesizedGenericArgs {\n }\n \n /// What to do when we encounter an **anonymous** lifetime\n-/// reference. Anonymous lifetime references come in two flavors.  You\n+/// reference. Anonymous lifetime references come in two flavors. You\n /// have implicit, or fully elided, references to lifetimes, like the\n /// one in `&T` or `Ref<T>`, and you have `'_` lifetimes, like `&'_ T`\n-/// or `Ref<'_, T>`.  These often behave the same, but not always:\n+/// or `Ref<'_, T>`. These often behave the same, but not always:\n ///\n /// - certain usages of implicit references are deprecated, like\n ///   `Ref<T>`, and we sometimes just give hard errors in those cases\n@@ -681,13 +682,20 @@ impl<'a> LoweringContext<'a> {\n         Ident::with_empty_ctxt(Symbol::gensym(s))\n     }\n \n-    fn allow_internal_unstable(&self, reason: CompilerDesugaringKind, span: Span) -> Span {\n+    /// Reuses the span but adds information like the kind of the desugaring and features that are\n+    /// allowed inside this span.\n+    fn mark_span_with_reason(\n+        &self,\n+        reason: CompilerDesugaringKind,\n+        span: Span,\n+        allow_internal_unstable: Option<Lrc<[Symbol]>>,\n+    ) -> Span {\n         let mark = Mark::fresh(Mark::root());\n         mark.set_expn_info(source_map::ExpnInfo {\n             call_site: span,\n             def_site: Some(span),\n             format: source_map::CompilerDesugaring(reason),\n-            allow_internal_unstable: true,\n+            allow_internal_unstable,\n             allow_internal_unsafe: false,\n             local_inner_macros: false,\n             edition: source_map::hygiene::default_edition(),\n@@ -964,7 +972,13 @@ impl<'a> LoweringContext<'a> {\n             attrs: ThinVec::new(),\n         };\n \n-        let unstable_span = self.allow_internal_unstable(CompilerDesugaringKind::Async, span);\n+        let unstable_span = self.mark_span_with_reason(\n+            CompilerDesugaringKind::Async,\n+            span,\n+            Some(vec![\n+                Symbol::intern(\"gen_future\"),\n+            ].into()),\n+        );\n         let gen_future = self.expr_std_path(\n             unstable_span, &[\"future\", \"from_generator\"], None, ThinVec::new());\n         hir::ExprKind::Call(P(gen_future), hir_vec![generator])\n@@ -1157,6 +1171,15 @@ impl<'a> LoweringContext<'a> {\n         match arg {\n             ast::GenericArg::Lifetime(lt) => GenericArg::Lifetime(self.lower_lifetime(&lt)),\n             ast::GenericArg::Type(ty) => GenericArg::Type(self.lower_ty_direct(&ty, itctx)),\n+            ast::GenericArg::Const(ct) => {\n+                // FIXME(const_generics): const generics are not yet defined in the HIR.\n+                self.sess.struct_span_err(\n+                    ct.value.span,\n+                    \"const generics in any position are currently unsupported\",\n+                ).emit();\n+                self.sess.abort_if_errors();\n+                bug!();\n+            }\n         }\n     }\n \n@@ -1351,9 +1374,10 @@ impl<'a> LoweringContext<'a> {\n         // desugaring that explicitly states that we don't want to track that.\n         // Not tracking it makes lints in rustc and clippy very fragile as\n         // frequently opened issues show.\n-        let exist_ty_span = self.allow_internal_unstable(\n+        let exist_ty_span = self.mark_span_with_reason(\n             CompilerDesugaringKind::ExistentialReturnType,\n             span,\n+            None,\n         );\n \n         let exist_ty_def_index = self\n@@ -2441,7 +2465,7 @@ impl<'a> LoweringContext<'a> {\n             |this| this.lower_param_bounds(&param.bounds, itctx.reborrow()),\n         );\n \n-        match param.kind {\n+        let (name, kind) = match param.kind {\n             GenericParamKind::Lifetime => {\n                 let was_collecting_in_band = self.is_collecting_in_band_lifetimes;\n                 self.is_collecting_in_band_lifetimes = false;\n@@ -2457,22 +2481,14 @@ impl<'a> LoweringContext<'a> {\n                         | hir::LifetimeName::Static => hir::ParamName::Plain(lt.name.ident()),\n                     hir::LifetimeName::Error => ParamName::Error,\n                 };\n-                let param = hir::GenericParam {\n-                    id: lt.id,\n-                    hir_id: lt.hir_id,\n-                    name: param_name,\n-                    span: lt.span,\n-                    pure_wrt_drop: attr::contains_name(&param.attrs, \"may_dangle\"),\n-                    attrs: self.lower_attrs(&param.attrs),\n-                    bounds,\n-                    kind: hir::GenericParamKind::Lifetime {\n-                        kind: hir::LifetimeParamKind::Explicit,\n-                    }\n+\n+                let kind = hir::GenericParamKind::Lifetime {\n+                    kind: hir::LifetimeParamKind::Explicit\n                 };\n \n                 self.is_collecting_in_band_lifetimes = was_collecting_in_band;\n \n-                param\n+                (param_name, kind)\n             }\n             GenericParamKind::Type { ref default, .. } => {\n                 // Don't expose `Self` (recovered \"keyword used as ident\" parse error).\n@@ -2491,27 +2507,41 @@ impl<'a> LoweringContext<'a> {\n                                    .chain(params)\n                                    .collect();\n                 }\n-                let LoweredNodeId { node_id, hir_id } = self.lower_node_id(param.id);\n \n-                hir::GenericParam {\n-                    id: node_id,\n-                    hir_id,\n-                    name: hir::ParamName::Plain(ident),\n-                    pure_wrt_drop: attr::contains_name(&param.attrs, \"may_dangle\"),\n-                    attrs: self.lower_attrs(&param.attrs),\n-                    bounds,\n-                    span: ident.span,\n-                    kind: hir::GenericParamKind::Type {\n-                        default: default.as_ref().map(|x| {\n-                            self.lower_ty(x, ImplTraitContext::disallowed())\n-                        }),\n-                        synthetic: param.attrs.iter()\n-                                              .filter(|attr| attr.check_name(\"rustc_synthetic\"))\n-                                              .map(|_| hir::SyntheticTyParamKind::ImplTrait)\n-                                              .next(),\n-                    }\n-                }\n+                let kind = hir::GenericParamKind::Type {\n+                    default: default.as_ref().map(|x| {\n+                        self.lower_ty(x, ImplTraitContext::disallowed())\n+                    }),\n+                    synthetic: param.attrs.iter()\n+                                          .filter(|attr| attr.check_name(\"rustc_synthetic\"))\n+                                          .map(|_| hir::SyntheticTyParamKind::ImplTrait)\n+                                          .next(),\n+                };\n+\n+                (hir::ParamName::Plain(ident), kind)\n             }\n+            GenericParamKind::Const { .. } => {\n+                // FIXME(const_generics): const generics are not yet defined in the HIR.\n+                self.sess.struct_span_err(\n+                    param.ident.span,\n+                    \"const generics in any position are currently unsupported\",\n+                ).emit();\n+                self.sess.abort_if_errors();\n+                bug!();\n+            }\n+        };\n+\n+        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(param.id);\n+\n+        hir::GenericParam {\n+            id: node_id,\n+            hir_id,\n+            name,\n+            span: param.ident.span,\n+            pure_wrt_drop: attr::contains_name(&param.attrs, \"may_dangle\"),\n+            attrs: self.lower_attrs(&param.attrs),\n+            bounds,\n+            kind,\n         }\n     }\n \n@@ -3272,7 +3302,7 @@ impl<'a> LoweringContext<'a> {\n \n     /// Paths like the visibility path in `pub(super) use foo::{bar, baz}` are repeated\n     /// many times in the HIR tree; for each occurrence, we need to assign distinct\n-    /// node-ids. (See e.g., #56128.)\n+    /// `NodeId`s. (See, e.g., #56128.)\n     fn renumber_segment_ids(&mut self, path: &P<hir::Path>) -> P<hir::Path> {\n         debug!(\"renumber_segment_ids(path = {:?})\", path);\n         let mut path = path.clone();\n@@ -3829,15 +3859,15 @@ impl<'a> LoweringContext<'a> {\n                 hir::ExprKind::Call(f, args.iter().map(|x| self.lower_expr(x)).collect())\n             }\n             ExprKind::MethodCall(ref seg, ref args) => {\n-                let hir_seg = self.lower_path_segment(\n+                let hir_seg = P(self.lower_path_segment(\n                     e.span,\n                     seg,\n                     ParamMode::Optional,\n                     0,\n                     ParenthesizedGenericArgs::Err,\n                     ImplTraitContext::disallowed(),\n                     None,\n-                );\n+                ));\n                 let args = args.iter().map(|x| self.lower_expr(x)).collect();\n                 hir::ExprKind::MethodCall(hir_seg, seg.ident.span, args)\n             }\n@@ -3912,8 +3942,13 @@ impl<'a> LoweringContext<'a> {\n             }),\n             ExprKind::TryBlock(ref body) => {\n                 self.with_catch_scope(body.id, |this| {\n-                    let unstable_span =\n-                        this.allow_internal_unstable(CompilerDesugaringKind::TryBlock, body.span);\n+                    let unstable_span = this.mark_span_with_reason(\n+                        CompilerDesugaringKind::TryBlock,\n+                        body.span,\n+                        Some(vec![\n+                            Symbol::intern(\"try_trait\"),\n+                        ].into()),\n+                    );\n                     let mut block = this.lower_block(body, true).into_inner();\n                     let tail = block.expr.take().map_or_else(\n                         || {\n@@ -4113,7 +4148,7 @@ impl<'a> LoweringContext<'a> {\n                     node: if is_unit {\n                         hir::ExprKind::Path(struct_path)\n                     } else {\n-                        hir::ExprKind::Struct(struct_path, fields, None)\n+                        hir::ExprKind::Struct(P(struct_path), fields, None)\n                     },\n                     span: e.span,\n                     attrs: e.attrs.clone(),\n@@ -4185,13 +4220,13 @@ impl<'a> LoweringContext<'a> {\n                 hir::ExprKind::InlineAsm(P(hir_asm), outputs, inputs)\n             }\n             ExprKind::Struct(ref path, ref fields, ref maybe_expr) => hir::ExprKind::Struct(\n-                self.lower_qpath(\n+                P(self.lower_qpath(\n                     e.id,\n                     &None,\n                     path,\n                     ParamMode::Optional,\n                     ImplTraitContext::disallowed(),\n-                ),\n+                )),\n                 fields.iter().map(|x| self.lower_field(x)).collect(),\n                 maybe_expr.as_ref().map(|x| P(self.lower_expr(x))),\n             ),\n@@ -4345,9 +4380,10 @@ impl<'a> LoweringContext<'a> {\n                 // expand <head>\n                 let head = self.lower_expr(head);\n                 let head_sp = head.span;\n-                let desugared_span = self.allow_internal_unstable(\n+                let desugared_span = self.mark_span_with_reason(\n                     CompilerDesugaringKind::ForLoop,\n                     head_sp,\n+                    None,\n                 );\n \n                 let iter = self.str_to_ident(\"iter\");\n@@ -4510,8 +4546,13 @@ impl<'a> LoweringContext<'a> {\n                 //                 return Try::from_error(From::from(err)),\n                 // }\n \n-                let unstable_span =\n-                    self.allow_internal_unstable(CompilerDesugaringKind::QuestionMark, e.span);\n+                let unstable_span = self.mark_span_with_reason(\n+                    CompilerDesugaringKind::QuestionMark,\n+                    e.span,\n+                    Some(vec![\n+                        Symbol::intern(\"try_trait\")\n+                    ].into()),\n+                );\n \n                 // `Try::into_result(<expr>)`\n                 let discr = {"}, {"sha": "6919628c7675552c18863a5724712dca46295ab7", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,20 +1,20 @@\n //! This module provides a simplified abstraction for working with\n-//! code blocks identified by their integer node-id.  In particular,\n+//! code blocks identified by their integer `NodeId`. In particular,\n //! it captures a common set of attributes that all \"function-like\n-//! things\" (represented by `FnLike` instances) share.  For example,\n+//! things\" (represented by `FnLike` instances) share. For example,\n //! all `FnLike` instances have a type signature (be it explicit or\n-//! inferred).  And all `FnLike` instances have a body, i.e., the code\n+//! inferred). And all `FnLike` instances have a body, i.e., the code\n //! that is run when the function-like thing it represents is invoked.\n //!\n //! With the above abstraction in place, one can treat the program\n //! text as a collection of blocks of code (and most such blocks are\n //! nested within a uniquely determined `FnLike`), and users can ask\n //! for the `Code` associated with a particular NodeId.\n \n-use hir as ast;\n-use hir::map;\n-use hir::{Expr, FnDecl, Node};\n-use hir::intravisit::FnKind;\n+use crate::hir as ast;\n+use crate::hir::map;\n+use crate::hir::{Expr, FnDecl, Node};\n+use crate::hir::intravisit::FnKind;\n use syntax::ast::{Attribute, Ident, NodeId};\n use syntax_pos::Span;\n "}, {"sha": "37552f18f4a08112582e146ac9ede7d4d78a50a6", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,19 +1,19 @@\n use super::*;\n-use dep_graph::{DepGraph, DepKind, DepNodeIndex};\n-use hir;\n-use hir::def_id::{LOCAL_CRATE, CrateNum};\n-use hir::intravisit::{Visitor, NestedVisitorMap};\n+use crate::dep_graph::{DepGraph, DepKind, DepNodeIndex};\n+use crate::hir;\n+use crate::hir::def_id::{LOCAL_CRATE, CrateNum};\n+use crate::hir::intravisit::{Visitor, NestedVisitorMap};\n use rustc_data_structures::svh::Svh;\n-use ich::Fingerprint;\n-use middle::cstore::CrateStore;\n-use session::CrateDisambiguator;\n-use session::Session;\n+use crate::ich::Fingerprint;\n+use crate::middle::cstore::CrateStore;\n+use crate::session::CrateDisambiguator;\n+use crate::session::Session;\n use std::iter::repeat;\n use syntax::ast::{NodeId, CRATE_NODE_ID};\n use syntax::source_map::SourceMap;\n use syntax_pos::Span;\n \n-use ich::StableHashingContext;\n+use crate::ich::StableHashingContext;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n \n /// A Visitor that walks over the HIR and collects Nodes into a HIR map\n@@ -48,14 +48,14 @@ pub(super) struct NodeCollector<'a, 'hir> {\n     hir_body_nodes: Vec<(DefPathHash, Fingerprint)>,\n }\n \n-fn input_dep_node_and_hash<'a, I>(\n+fn input_dep_node_and_hash<I>(\n     dep_graph: &DepGraph,\n-    hcx: &mut StableHashingContext<'a>,\n+    hcx: &mut StableHashingContext<'_>,\n     dep_node: DepNode,\n     input: I,\n ) -> (DepNodeIndex, Fingerprint)\n where\n-    I: HashStable<StableHashingContext<'a>>,\n+    I: for<'a> HashStable<StableHashingContext<'a>>,\n {\n     let dep_node_index = dep_graph.input_task(dep_node, &mut *hcx, &input).1;\n \n@@ -70,15 +70,15 @@ where\n     (dep_node_index, hash)\n }\n \n-fn alloc_hir_dep_nodes<'a, I>(\n+fn alloc_hir_dep_nodes<I>(\n     dep_graph: &DepGraph,\n-    hcx: &mut StableHashingContext<'a>,\n+    hcx: &mut StableHashingContext<'_>,\n     def_path_hash: DefPathHash,\n     item_like: I,\n     hir_body_nodes: &mut Vec<(DefPathHash, Fingerprint)>,\n ) -> (DepNodeIndex, DepNodeIndex)\n where\n-    I: HashStable<StableHashingContext<'a>>,\n+    I: for<'a> HashStable<StableHashingContext<'a>>,\n {\n     let sig = dep_graph.input_task(\n         def_path_hash.to_dep_node(DepKind::Hir),\n@@ -253,7 +253,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n                     None => format!(\"{:?}\", node)\n                 };\n \n-                let forgot_str = if hir_id == ::hir::DUMMY_HIR_ID {\n+                let forgot_str = if hir_id == crate::hir::DUMMY_HIR_ID {\n                     format!(\"\\nMaybe you forgot to lower the node id {:?}?\", id)\n                 } else {\n                     String::new()\n@@ -286,7 +286,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         self.parent_node = parent_node;\n     }\n \n-    fn with_dep_node_owner<T: HashStable<StableHashingContext<'a>>,\n+    fn with_dep_node_owner<T: for<'b> HashStable<StableHashingContext<'b>>,\n                            F: FnOnce(&mut Self)>(&mut self,\n                                                  dep_node_owner: DefIndex,\n                                                  item_like: &T,"}, {"sha": "8fe10a85ef380de12a3e00b874dc3a6ed53adefd", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,6 +1,6 @@\n-use hir::map::definitions::*;\n-use hir::def_id::{CRATE_DEF_INDEX, DefIndex, DefIndexAddressSpace};\n-use session::CrateDisambiguator;\n+use crate::hir::map::definitions::*;\n+use crate::hir::def_id::{CRATE_DEF_INDEX, DefIndex, DefIndexAddressSpace};\n+use crate::session::CrateDisambiguator;\n \n use syntax::ast::*;\n use syntax::ext::hygiene::Mark;\n@@ -10,9 +10,9 @@ use syntax::symbol::Symbol;\n use syntax::parse::token::{self, Token};\n use syntax_pos::Span;\n \n-use hir::map::{ITEM_LIKE_SPACE, REGULAR_SPACE};\n+use crate::hir::map::{ITEM_LIKE_SPACE, REGULAR_SPACE};\n \n-/// Creates def ids for nodes in the AST.\n+/// Creates `DefId`s for nodes in the AST.\n pub struct DefCollector<'a> {\n     definitions: &'a mut Definitions,\n     parent_def: Option<DefIndex>,\n@@ -218,6 +218,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n         let def_path_data = match param.kind {\n             GenericParamKind::Lifetime { .. } => DefPathData::LifetimeParam(name),\n             GenericParamKind::Type { .. } => DefPathData::TypeParam(name),\n+            GenericParamKind::Const { .. } => DefPathData::ConstParam(name),\n         };\n         self.create_def(param.id, def_path_data, REGULAR_SPACE, param.ident.span);\n "}, {"sha": "f454d691d4188c41ad65c39980038ac9a0fe7ffe", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 37, "deletions": 33, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,26 +1,26 @@\n-//! For each definition, we track the following data.  A definition\n-//! here is defined somewhat circularly as \"something with a def-id\",\n+//! For each definition, we track the following data. A definition\n+//! here is defined somewhat circularly as \"something with a `DefId`\",\n //! but it generally corresponds to things like structs, enums, etc.\n //! There are also some rather random cases (like const initializer\n //! expressions) that are mostly just leftovers.\n \n-use hir;\n-use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE, DefIndexAddressSpace,\n+use crate::hir;\n+use crate::hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE, DefIndexAddressSpace,\n                   CRATE_DEF_INDEX};\n-use ich::Fingerprint;\n+use crate::ich::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::{IndexVec};\n use rustc_data_structures::stable_hasher::StableHasher;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n-use session::CrateDisambiguator;\n+use crate::session::CrateDisambiguator;\n use std::borrow::Borrow;\n use std::fmt::Write;\n use std::hash::Hash;\n use syntax::ast;\n use syntax::ext::hygiene::Mark;\n use syntax::symbol::{Symbol, InternedString};\n use syntax_pos::{Span, DUMMY_SP};\n-use util::nodemap::NodeMap;\n+use crate::util::nodemap::NodeMap;\n \n /// The DefPathTable maps DefIndexes to DefKeys and vice versa.\n /// Internally the DefPathTable holds a tree of DefKeys, where each DefKey\n@@ -163,10 +163,10 @@ pub struct Definitions {\n /// any) with a `DisambiguatedDefPathData`.\n #[derive(Clone, PartialEq, Debug, Hash, RustcEncodable, RustcDecodable)]\n pub struct DefKey {\n-    /// Parent path.\n+    /// The parent path.\n     pub parent: Option<DefIndex>,\n \n-    /// Identifier of this node.\n+    /// The identifier of this node.\n     pub disambiguated_data: DisambiguatedDefPathData,\n }\n \n@@ -207,12 +207,12 @@ impl DefKey {\n     }\n }\n \n-/// Pair of `DefPathData` and an integer disambiguator. The integer is\n+/// A pair of `DefPathData` and an integer disambiguator. The integer is\n /// normally 0, but in the event that there are multiple defs with the\n /// same `parent` and `data`, we use this field to disambiguate\n /// between them. This introduces some artificial ordering dependency\n /// but means that if you have (e.g.) two impls for the same type in\n-/// the same module, they do get distinct def-ids.\n+/// the same module, they do get distinct `DefId`s.\n #[derive(Clone, PartialEq, Debug, Hash, RustcEncodable, RustcDecodable)]\n pub struct DisambiguatedDefPathData {\n     pub data: DefPathData,\n@@ -221,10 +221,10 @@ pub struct DisambiguatedDefPathData {\n \n #[derive(Clone, Debug, Hash, RustcEncodable, RustcDecodable)]\n pub struct DefPath {\n-    /// the path leading from the crate root to the item\n+    /// The path leading from the crate root to the item.\n     pub data: Vec<DisambiguatedDefPathData>,\n \n-    /// what krate root is this path relative to?\n+    /// The crate root this path is relative to.\n     pub krate: CrateNum,\n }\n \n@@ -260,9 +260,9 @@ impl DefPath {\n         DefPath { data: data, krate: krate }\n     }\n \n-    /// Returns a string representation of the DefPath without\n+    /// Returns a string representation of the `DefPath` without\n     /// the crate-prefix. This method is useful if you don't have\n-    /// a TyCtxt available.\n+    /// a `TyCtxt` available.\n     pub fn to_string_no_crate(&self) -> String {\n         let mut s = String::with_capacity(self.data.len() * 16);\n \n@@ -277,7 +277,7 @@ impl DefPath {\n         s\n     }\n \n-    /// Return filename friendly string of the DefPah with the\n+    /// Returns a filename-friendly string for the `DefPath`, with the\n     /// crate-prefix.\n     pub fn to_string_friendly<F>(&self, crate_imported_name: F) -> String\n         where F: FnOnce(CrateNum) -> Symbol\n@@ -302,9 +302,9 @@ impl DefPath {\n         s\n     }\n \n-    /// Return filename friendly string of the DefPah without\n+    /// Returns a filename-friendly string of the `DefPath`, without\n     /// the crate-prefix. This method is useful if you don't have\n-    /// a TyCtxt available.\n+    /// a `TyCtxt` available.\n     pub fn to_filename_friendly_no_crate(&self) -> String {\n         let mut s = String::with_capacity(self.data.len() * 16);\n \n@@ -356,10 +356,12 @@ pub enum DefPathData {\n     /// A closure expression\n     ClosureExpr,\n     // Subportions of items\n-    /// A type parameter (generic parameter)\n+    /// A type (generic) parameter\n     TypeParam(InternedString),\n-    /// A lifetime definition\n+    /// A lifetime (generic) parameter\n     LifetimeParam(InternedString),\n+    /// A const (generic) parameter\n+    ConstParam(InternedString),\n     /// A variant of a enum\n     EnumVariant(InternedString),\n     /// A struct field\n@@ -392,18 +394,18 @@ impl Borrow<Fingerprint> for DefPathHash {\n }\n \n impl Definitions {\n-    /// Create new empty definition map.\n+    /// Creates new empty definition map.\n     ///\n-    /// The DefIndex returned from a new Definitions are as follows:\n-    /// 1. At DefIndexAddressSpace::Low,\n+    /// The `DefIndex` returned from a new `Definitions` are as follows:\n+    /// 1. At `DefIndexAddressSpace::Low`,\n     ///     CRATE_ROOT has index 0:0, and then new indexes are allocated in\n     ///     ascending order.\n-    /// 2. At DefIndexAddressSpace::High,\n-    ///     the first FIRST_FREE_HIGH_DEF_INDEX indexes are reserved for\n-    ///     internal use, then 1:FIRST_FREE_HIGH_DEF_INDEX are allocated in\n+    /// 2. At `DefIndexAddressSpace::High`,\n+    ///     the first `FIRST_FREE_HIGH_DEF_INDEX` indexes are reserved for\n+    ///     internal use, then `1:FIRST_FREE_HIGH_DEF_INDEX` are allocated in\n     ///     ascending order.\n-    ///\n-    /// FIXME: there is probably a better place to put this comment.\n+    //\n+    // FIXME: there is probably a better place to put this comment.\n     pub fn new() -> Self {\n         Self::default()\n     }\n@@ -412,7 +414,7 @@ impl Definitions {\n         &self.table\n     }\n \n-    /// Get the number of definitions.\n+    /// Gets the number of definitions.\n     pub fn def_index_counts_lo_hi(&self) -> (usize, usize) {\n         (self.table.index_to_key[DefIndexAddressSpace::Low.index()].len(),\n          self.table.index_to_key[DefIndexAddressSpace::High.index()].len())\n@@ -495,8 +497,8 @@ impl Definitions {\n         self.node_to_hir_id[node_id]\n     }\n \n-    /// Retrieve the span of the given `DefId` if `DefId` is in the local crate, the span exists and\n-    /// it's not DUMMY_SP\n+    /// Retrieves the span of the given `DefId` if `DefId` is in the local crate, the span exists\n+    /// and it's not `DUMMY_SP`.\n     #[inline]\n     pub fn opt_span(&self, def_id: DefId) -> Option<Span> {\n         if def_id.krate == LOCAL_CRATE {\n@@ -506,7 +508,7 @@ impl Definitions {\n         }\n     }\n \n-    /// Add a definition with a parent definition.\n+    /// Adds a root definition (no parent).\n     pub fn create_root_def(&mut self,\n                            crate_name: &str,\n                            crate_disambiguator: CrateDisambiguator)\n@@ -604,7 +606,7 @@ impl Definitions {\n         index\n     }\n \n-    /// Initialize the ast::NodeId to HirId mapping once it has been generated during\n+    /// Initialize the `ast::NodeId` to `HirId` mapping once it has been generated during\n     /// AST to HIR lowering.\n     pub fn init_node_id_to_hir_id_mapping(&mut self,\n                                           mapping: IndexVec<ast::NodeId, hir::HirId>) {\n@@ -641,6 +643,7 @@ impl DefPathData {\n             MacroDef(name) |\n             TypeParam(name) |\n             LifetimeParam(name) |\n+            ConstParam(name) |\n             EnumVariant(name) |\n             Field(name) |\n             GlobalMetaData(name) => Some(name),\n@@ -669,6 +672,7 @@ impl DefPathData {\n             MacroDef(name) |\n             TypeParam(name) |\n             LifetimeParam(name) |\n+            ConstParam(name) |\n             EnumVariant(name) |\n             Field(name) |\n             GlobalMetaData(name) => {"}, {"sha": "2c3ff4c9b5c05bdd48f40518939a47046ea60147", "filename": "src/librustc/hir/map/hir_id_validator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,7 +1,7 @@\n-use hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n-use hir::{self, intravisit, HirId, ItemLocalId};\n+use crate::hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n+use crate::hir::{self, intravisit, HirId, ItemLocalId};\n use syntax::ast::NodeId;\n-use hir::itemlikevisit::ItemLikeVisitor;\n+use crate::hir::itemlikevisit::ItemLikeVisitor;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{Lock, ParallelIterator, par_iter};\n "}, {"sha": "b6cf4c1b84d0c6454b91bfb8374518c31eef8756", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 118, "deletions": 34, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -3,11 +3,11 @@ pub use self::def_collector::{DefCollector, MacroInvocationData};\n pub use self::definitions::{Definitions, DefKey, DefPath, DefPathData,\n                             DisambiguatedDefPathData, DefPathHash};\n \n-use dep_graph::{DepGraph, DepNode, DepKind, DepNodeIndex};\n+use crate::dep_graph::{DepGraph, DepNode, DepKind, DepNodeIndex};\n \n-use hir::def_id::{CRATE_DEF_INDEX, DefId, LocalDefId, DefIndexAddressSpace};\n+use crate::hir::def_id::{CRATE_DEF_INDEX, DefId, LocalDefId, DefIndexAddressSpace};\n \n-use middle::cstore::CrateStoreDyn;\n+use crate::middle::cstore::CrateStoreDyn;\n \n use rustc_target::spec::abi::Abi;\n use rustc_data_structures::svh::Svh;\n@@ -17,15 +17,15 @@ use syntax::source_map::Spanned;\n use syntax::ext::base::MacroKind;\n use syntax_pos::{Span, DUMMY_SP};\n \n-use hir::*;\n-use hir::itemlikevisit::ItemLikeVisitor;\n-use hir::print::Nested;\n-use util::nodemap::FxHashMap;\n-use util::common::time;\n+use crate::hir::*;\n+use crate::hir::itemlikevisit::ItemLikeVisitor;\n+use crate::hir::print::Nested;\n+use crate::util::nodemap::FxHashMap;\n+use crate::util::common::time;\n \n use std::io;\n use std::result::Result::Err;\n-use ty::TyCtxt;\n+use crate::ty::TyCtxt;\n \n pub mod blocks;\n mod collector;\n@@ -36,7 +36,7 @@ mod hir_id_validator;\n pub const ITEM_LIKE_SPACE: DefIndexAddressSpace = DefIndexAddressSpace::Low;\n pub const REGULAR_SPACE: DefIndexAddressSpace = DefIndexAddressSpace::High;\n \n-/// Represents an entry and its parent NodeId.\n+/// Represents an entry and its parent `NodeId`.\n #[derive(Copy, Clone, Debug)]\n pub struct Entry<'hir> {\n     parent: NodeId,\n@@ -127,9 +127,9 @@ impl<'hir> Entry<'hir> {\n         }\n     }\n \n-    fn is_body_owner(self, node_id: NodeId) -> bool {\n+    fn is_body_owner(self, hir_id: HirId) -> bool {\n         match self.associated_body() {\n-            Some(b) => b.node_id == node_id,\n+            Some(b) => b.hir_id == hir_id,\n             None => false,\n         }\n     }\n@@ -162,8 +162,7 @@ impl Forest {\n     }\n }\n \n-/// Represents a mapping from Node IDs to AST elements and their parent\n-/// Node IDs\n+/// Represents a mapping from `NodeId`s to AST elements and their parent `NodeId`s.\n #[derive(Clone)]\n pub struct Map<'hir> {\n     /// The backing storage for all the AST nodes.\n@@ -371,16 +370,19 @@ impl<'hir> Map<'hir> {\n                 let def_id = self.local_def_id(variant.node.data.id());\n                 Some(Def::Variant(def_id))\n             }\n-            Node::Field(_) |\n+            Node::StructCtor(variant) => {\n+                let def_id = self.local_def_id(variant.id());\n+                Some(Def::StructCtor(def_id, def::CtorKind::from_hir(variant)))\n+            }\n             Node::AnonConst(_) |\n+            Node::Field(_) |\n             Node::Expr(_) |\n             Node::Stmt(_) |\n             Node::PathSegment(_) |\n             Node::Ty(_) |\n             Node::TraitRef(_) |\n             Node::Pat(_) |\n             Node::Binding(_) |\n-            Node::StructCtor(_) |\n             Node::Lifetime(_) |\n             Node::Visibility(_) |\n             Node::Block(_) |\n@@ -401,6 +403,12 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn describe_def_by_hir_id(&self, hir_id: HirId) -> Option<Def> {\n+        let node_id = self.hir_to_node_id(hir_id);\n+        self.describe_def(node_id)\n+    }\n+\n     fn entry_count(&self) -> usize {\n         self.map.len()\n     }\n@@ -430,7 +438,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn body(&self, id: BodyId) -> &'hir Body {\n-        self.read(id.node_id);\n+        self.read_by_hir_id(id.hir_id);\n \n         // N.B., intentionally bypass `self.forest.krate()` so that we\n         // do not trigger a read of the whole krate here\n@@ -445,20 +453,27 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn fn_decl_by_hir_id(&self, hir_id: HirId) -> Option<FnDecl> {\n+        let node_id = self.hir_to_node_id(hir_id);\n+        self.fn_decl(node_id)\n+    }\n+\n     /// Returns the `NodeId` that corresponds to the definition of\n     /// which this is the body of, i.e., a `fn`, `const` or `static`\n     /// item (possibly associated), a closure, or a `hir::AnonConst`.\n-    pub fn body_owner(&self, BodyId { node_id }: BodyId) -> NodeId {\n+    pub fn body_owner(&self, BodyId { hir_id }: BodyId) -> NodeId {\n+        let node_id = self.hir_to_node_id(hir_id);\n         let parent = self.get_parent_node(node_id);\n-        assert!(self.map[parent.as_usize()].map_or(false, |e| e.is_body_owner(node_id)));\n+        assert!(self.map[parent.as_usize()].map_or(false, |e| e.is_body_owner(hir_id)));\n         parent\n     }\n \n     pub fn body_owner_def_id(&self, id: BodyId) -> DefId {\n         self.local_def_id(self.body_owner(id))\n     }\n \n-    /// Given a node id, returns the `BodyId` associated with it,\n+    /// Given a `NodeId`, returns the `BodyId` associated with it,\n     /// if the node is a body owner, otherwise returns `None`.\n     pub fn maybe_body_owned_by(&self, id: NodeId) -> Option<BodyId> {\n         if let Some(entry) = self.find_entry(id) {\n@@ -474,6 +489,12 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn maybe_body_owned_by_by_hir_id(&self, id: HirId) -> Option<BodyId> {\n+        let node_id = self.hir_to_node_id(id);\n+        self.maybe_body_owned_by(node_id)\n+    }\n+\n     /// Given a body owner's id, returns the `BodyId` associated with it.\n     pub fn body_owned_by(&self, id: NodeId) -> BodyId {\n         self.maybe_body_owned_by(id).unwrap_or_else(|| {\n@@ -507,6 +528,12 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn body_owner_kind_by_hir_id(&self, id: HirId) -> BodyOwnerKind {\n+        let node_id = self.hir_to_node_id(id);\n+        self.body_owner_kind(node_id)\n+    }\n+\n     pub fn ty_param_owner(&self, id: NodeId) -> NodeId {\n         match self.get(id) {\n             Node::Item(&Item { node: ItemKind::Trait(..), .. }) => id,\n@@ -543,7 +570,7 @@ impl<'hir> Map<'hir> {\n         self.trait_auto_impl(trait_did).is_some()\n     }\n \n-    /// Get the attributes on the krate. This is preferable to\n+    /// Gets the attributes on the crate. This is preferable to\n     /// invoking `krate.attrs` because it registers a tighter\n     /// dep-graph access.\n     pub fn krate_attrs(&self) -> &'hir [ast::Attribute] {\n@@ -638,8 +665,7 @@ impl<'hir> Map<'hir> {\n         self.get_generics(id).map(|generics| generics.span).filter(|sp| *sp != DUMMY_SP)\n     }\n \n-    /// Retrieve the Node corresponding to `id`, returning None if\n-    /// cannot be found.\n+    /// Retrieves the `Node` corresponding to `id`, returning `None` if cannot be found.\n     pub fn find(&self, id: NodeId) -> Option<Node<'hir>> {\n         let result = self.find_entry(id).and_then(|entry| {\n             if let Node::Crate = entry.node {\n@@ -668,8 +694,8 @@ impl<'hir> Map<'hir> {\n     /// returns the enclosing item. Note that this might not be the actual parent\n     /// node in the AST - some kinds of nodes are not in the map and these will\n     /// never appear as the parent_node. So you can always walk the `parent_nodes`\n-    /// from a node to the root of the ast (unless you get the same id back here\n-    /// that can happen if the id is not in the map itself or is just weird).\n+    /// from a node to the root of the ast (unless you get the same ID back here\n+    /// that can happen if the ID is not in the map itself or is just weird).\n     pub fn get_parent_node(&self, id: NodeId) -> NodeId {\n         if self.dep_graph.is_fully_enabled() {\n             let hir_id_owner = self.node_to_hir_id(id).owner;\n@@ -710,7 +736,7 @@ impl<'hir> Map<'hir> {\n \n     /// If there is some error when walking the parents (e.g., a node does not\n     /// have a parent in the map or a node can't be found), then we return the\n-    /// last good node id we found. Note that reaching the crate root (`id == 0`),\n+    /// last good `NodeId` we found. Note that reaching the crate root (`id == 0`),\n     /// is not an error, since items in the crate module have the crate root as\n     /// parent.\n     fn walk_parent_nodes<F, F2>(&self,\n@@ -746,7 +772,7 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    /// Retrieve the `NodeId` for `id`'s enclosing method, unless there's a\n+    /// Retrieves the `NodeId` for `id`'s enclosing method, unless there's a\n     /// `while` or `loop` before reaching it, as block tail returns are not\n     /// available in them.\n     ///\n@@ -794,7 +820,7 @@ impl<'hir> Map<'hir> {\n         self.walk_parent_nodes(id, match_fn, match_non_returning_block).ok()\n     }\n \n-    /// Retrieve the `NodeId` for `id`'s parent item, or `id` itself if no\n+    /// Retrieves the `NodeId` for `id`'s parent item, or `id` itself if no\n     /// parent item is in this map. The \"parent item\" is the closest parent node\n     /// in the HIR which is recorded by the map and is an item, either an item\n     /// in a module, trait, or impl.\n@@ -824,6 +850,12 @@ impl<'hir> Map<'hir> {\n         self.local_def_id(self.get_module_parent_node(id))\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn get_module_parent_by_hir_id(&self, id: HirId) -> DefId {\n+        let node_id = self.hir_to_node_id(id);\n+        self.get_module_parent(node_id)\n+    }\n+\n     /// Returns the `NodeId` of `id`'s nearest module parent, or `id` itself if no\n     /// module parent is in this map.\n     pub fn get_module_parent_node(&self, id: NodeId) -> NodeId {\n@@ -855,6 +887,12 @@ impl<'hir> Map<'hir> {\n         self.local_def_id(self.get_parent(id))\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn get_parent_did_by_hir_id(&self, id: HirId) -> DefId {\n+        let node_id = self.hir_to_node_id(id);\n+        self.get_parent_did(node_id)\n+    }\n+\n     pub fn get_foreign_abi(&self, id: NodeId) -> Abi {\n         let parent = self.get_parent(id);\n         if let Some(entry) = self.find_entry(parent) {\n@@ -868,6 +906,12 @@ impl<'hir> Map<'hir> {\n         bug!(\"expected foreign mod or inlined parent, found {}\", self.node_to_string(parent))\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn get_foreign_abi_by_hir_id(&self, id: HirId) -> Abi {\n+        let node_id = self.hir_to_node_id(id);\n+        self.get_foreign_abi(node_id)\n+    }\n+\n     pub fn expect_item(&self, id: NodeId) -> &'hir Item {\n         match self.find(id) { // read recorded by `find`\n             Some(Node::Item(item)) => item,\n@@ -888,14 +932,28 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn expect_impl_item_by_hir_id(&self, id: HirId) -> &'hir ImplItem {\n+        let node_id = self.hir_to_node_id(id);\n+        self.expect_impl_item(node_id)\n+    }\n+\n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn expect_trait_item_by_hir_id(&self, id: HirId) -> &'hir TraitItem {\n+        let node_id = self.hir_to_node_id(id);\n+        self.expect_trait_item(node_id)\n+    }\n+\n     pub fn expect_trait_item(&self, id: NodeId) -> &'hir TraitItem {\n         match self.find(id) {\n             Some(Node::TraitItem(item)) => item,\n             _ => bug!(\"expected trait item, found {}\", self.node_to_string(id))\n         }\n     }\n \n-    pub fn expect_variant_data(&self, id: NodeId) -> &'hir VariantData {\n+    pub fn expect_variant_data(&self, id: HirId) -> &'hir VariantData {\n+        let id = self.hir_to_node_id(id); // FIXME(@ljedrz): remove when possible\n+\n         match self.find(id) {\n             Some(Node::Item(i)) => {\n                 match i.node {\n@@ -910,7 +968,9 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn expect_variant(&self, id: NodeId) -> &'hir Variant {\n+    pub fn expect_variant(&self, id: HirId) -> &'hir Variant {\n+        let id = self.hir_to_node_id(id); // FIXME(@ljedrz): remove when possible\n+\n         match self.find(id) {\n             Some(Node::Variant(variant)) => variant,\n             _ => bug!(\"expected variant, found {}\", self.node_to_string(id)),\n@@ -931,6 +991,12 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn expect_expr_by_hir_id(&self, id: HirId) -> &'hir Expr {\n+        let node_id = self.hir_to_node_id(id);\n+        self.expect_expr(node_id)\n+    }\n+\n     /// Returns the name associated with the given NodeId's AST.\n     pub fn name(&self, id: NodeId) -> Name {\n         match self.get(id) {\n@@ -948,6 +1014,12 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn name_by_hir_id(&self, id: HirId) -> Name {\n+        let node_id = self.hir_to_node_id(id);\n+        self.name(node_id)\n+    }\n+\n     /// Given a node ID, get a list of attributes associated with the AST\n     /// corresponding to the Node ID\n     pub fn attrs(&self, id: NodeId) -> &'hir [ast::Attribute] {\n@@ -970,6 +1042,12 @@ impl<'hir> Map<'hir> {\n         attrs.unwrap_or(&[])\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn attrs_by_hir_id(&self, id: HirId) -> &'hir [ast::Attribute] {\n+        let node_id = self.hir_to_node_id(id);\n+        self.attrs(node_id)\n+    }\n+\n     /// Returns an iterator that yields the node id's with paths that\n     /// match `parts`.  (Requires `parts` is non-empty.)\n     ///\n@@ -1019,6 +1097,12 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn span_by_hir_id(&self, id: HirId) -> Span {\n+        let node_id = self.hir_to_node_id(id);\n+        self.span(node_id)\n+    }\n+\n     pub fn span_if_local(&self, id: DefId) -> Option<Span> {\n         self.as_local_node_id(id).map(|id| self.span(id))\n     }\n@@ -1059,7 +1143,7 @@ pub struct NodesMatchingSuffix<'a, 'hir:'a> {\n }\n \n impl<'a, 'hir> NodesMatchingSuffix<'a, 'hir> {\n-    /// Returns true only if some suffix of the module path for parent\n+    /// Returns `true` only if some suffix of the module path for parent\n     /// matches `self.in_which`.\n     ///\n     /// In other words: let `[x_0,x_1,...,x_k]` be `self.in_which`;\n@@ -1152,13 +1236,13 @@ impl Named for StructField { fn name(&self) -> Name { self.ident.name } }\n impl Named for TraitItem { fn name(&self) -> Name { self.ident.name } }\n impl Named for ImplItem { fn name(&self) -> Name { self.ident.name } }\n \n-pub fn map_crate<'hir>(sess: &::session::Session,\n+pub fn map_crate<'hir>(sess: &crate::session::Session,\n                        cstore: &CrateStoreDyn,\n                        forest: &'hir Forest,\n                        definitions: &'hir Definitions)\n                        -> Map<'hir> {\n     let ((map, crate_hash), hir_to_node_id) = join(|| {\n-        let hcx = ::ich::StableHashingContext::new(sess, &forest.krate, definitions, cstore);\n+        let hcx = crate::ich::StableHashingContext::new(sess, &forest.krate, definitions, cstore);\n \n         let mut collector = NodeCollector::root(sess,\n                                                 &forest.krate,\n@@ -1269,7 +1353,7 @@ fn node_id_to_string(map: &Map<'_>, id: NodeId, include_id: bool) -> String {\n     let path_str = || {\n         // This functionality is used for debugging, try to use TyCtxt to get\n         // the user-friendly path, otherwise fall back to stringifying DefPath.\n-        ::ty::tls::with_opt(|tcx| {\n+        crate::ty::tls::with_opt(|tcx| {\n             if let Some(tcx) = tcx {\n                 tcx.node_path_str(id)\n             } else if let Some(path) = map.def_path_from_id(id) {"}, {"sha": "d774359fa79ec2fb8f9b242cab2416ddd6d79943", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 194, "deletions": 193, "changes": 387, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -10,12 +10,12 @@ pub use self::PrimTy::*;\n pub use self::UnOp::*;\n pub use self::UnsafeSource::*;\n \n-use errors::FatalError;\n-use hir::def::Def;\n-use hir::def_id::{DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX};\n-use util::nodemap::{NodeMap, FxHashSet};\n-use mir::mono::Linkage;\n+use crate::hir::def::Def;\n+use crate::hir::def_id::{DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX};\n+use crate::util::nodemap::{NodeMap, FxHashSet};\n+use crate::mir::mono::Linkage;\n \n+use errors::FatalError;\n use syntax_pos::{Span, DUMMY_SP, symbol::InternedString};\n use syntax::source_map::Spanned;\n use rustc_target::spec::abi::Abi;\n@@ -27,10 +27,10 @@ use syntax::ptr::P;\n use syntax::symbol::{Symbol, keywords};\n use syntax::tokenstream::TokenStream;\n use syntax::util::parser::ExprPrecedence;\n-use ty::AdtKind;\n-use ty::query::Providers;\n+use crate::ty::AdtKind;\n+use crate::ty::query::Providers;\n \n-use rustc_data_structures::sync::{ParallelIterator, par_iter, Send, Sync, scope};\n+use rustc_data_structures::sync::{ParallelIterator, par_iter, Send, Sync};\n use rustc_data_structures::thin_vec::ThinVec;\n \n use serialize::{self, Encoder, Encodable, Decoder, Decodable};\n@@ -62,17 +62,17 @@ pub mod map;\n pub mod pat_util;\n pub mod print;\n \n-/// A HirId uniquely identifies a node in the HIR of the current crate. It is\n-/// composed of the `owner`, which is the DefIndex of the directly enclosing\n-/// hir::Item, hir::TraitItem, or hir::ImplItem (i.e., the closest \"item-like\"),\n+/// Uniquely identifies a node in the HIR of the current crate. It is\n+/// composed of the `owner`, which is the `DefIndex` of the directly enclosing\n+/// `hir::Item`, `hir::TraitItem`, or `hir::ImplItem` (i.e., the closest \"item-like\"),\n /// and the `local_id` which is unique within the given owner.\n ///\n /// This two-level structure makes for more stable values: One can move an item\n /// around within the source code, or add or remove stuff before it, without\n-/// the local_id part of the HirId changing, which is a very useful property in\n+/// the `local_id` part of the `HirId` changing, which is a very useful property in\n /// incremental compilation where we have to persist things through changes to\n /// the code base.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, PartialOrd, Ord)]\n pub struct HirId {\n     pub owner: DefIndex,\n     pub local_id: ItemLocalId,\n@@ -130,7 +130,7 @@ mod item_local_id_inner {\n \n pub use self::item_local_id_inner::ItemLocalId;\n \n-/// The `HirId` corresponding to CRATE_NODE_ID and CRATE_DEF_INDEX\n+/// The `HirId` corresponding to `CRATE_NODE_ID` and `CRATE_DEF_INDEX`.\n pub const CRATE_HIR_ID: HirId = HirId {\n     owner: CRATE_DEF_INDEX,\n     local_id: ItemLocalId::from_u32_const(0)\n@@ -149,8 +149,8 @@ pub struct Lifetime {\n     pub hir_id: HirId,\n     pub span: Span,\n \n-    /// Either \"'a\", referring to a named lifetime definition,\n-    /// or \"\" (aka keywords::Invalid), for elision placeholders.\n+    /// Either \"`'a`\", referring to a named lifetime definition,\n+    /// or \"``\" (i.e., `keywords::Invalid`), for elision placeholders.\n     ///\n     /// HIR lowering inserts these placeholders in type paths that\n     /// refer to type definitions needing lifetime parameters,\n@@ -163,8 +163,9 @@ pub enum ParamName {\n     /// Some user-given name like `T` or `'x`.\n     Plain(Ident),\n \n-    /// Synthetic name generated when user elided a lifetime in an impl header,\n-    /// e.g., the lifetimes in cases like these:\n+    /// Synthetic name generated when user elided a lifetime in an impl header.\n+    ///\n+    /// E.g., the lifetimes in cases like these:\n     ///\n     ///     impl Foo for &u32\n     ///     impl Foo<'_> for u32\n@@ -180,7 +181,7 @@ pub enum ParamName {\n \n     /// Indicates an illegal name was given and an error has been\n     /// repored (so we should squelch other derived errors). Occurs\n-    /// when e.g., `'_` is used in the wrong place.\n+    /// when, e.g., `'_` is used in the wrong place.\n     Error,\n }\n \n@@ -205,17 +206,17 @@ pub enum LifetimeName {\n     /// User-given names or fresh (synthetic) names.\n     Param(ParamName),\n \n-    /// User typed nothing. e.g., the lifetime in `&u32`.\n+    /// User wrote nothing (e.g., the lifetime in `&u32`).\n     Implicit,\n \n     /// Indicates an error during lowering (usually `'_` in wrong place)\n     /// that was already reported.\n     Error,\n \n-    /// User typed `'_`.\n+    /// User wrote specifies `'_`.\n     Underscore,\n \n-    /// User wrote `'static`\n+    /// User wrote `'static`.\n     Static,\n }\n \n@@ -280,7 +281,7 @@ impl Lifetime {\n     }\n }\n \n-/// A \"Path\" is essentially Rust's notion of a name; for instance:\n+/// A `Path` is essentially Rust's notion of a name; for instance,\n /// `std::cmp::PartialEq`. It's represented as a sequence of identifiers,\n /// along with a bunch of supporting information.\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n@@ -340,7 +341,7 @@ pub struct PathSegment {\n }\n \n impl PathSegment {\n-    /// Convert an identifier to the corresponding segment.\n+    /// Converts an identifier to the corresponding segment.\n     pub fn from_ident(ident: Ident) -> PathSegment {\n         PathSegment {\n             ident,\n@@ -597,14 +598,14 @@ impl Generics {\n     }\n }\n \n-/// Synthetic Type Parameters are converted to an other form during lowering, this allows\n-/// to track the original form they had. Useful for error messages.\n+/// Synthetic type parameters are converted to another form during lowering; this allows\n+/// us to track the original form they had, and is useful for error messages.\n #[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum SyntheticTyParamKind {\n     ImplTrait\n }\n \n-/// A `where` clause in a definition\n+/// A where-clause in a definition.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct WhereClause {\n     pub id: NodeId,\n@@ -624,7 +625,7 @@ impl WhereClause {\n     }\n }\n \n-/// A single predicate in a `where` clause\n+/// A single predicate in a where-clause.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum WherePredicate {\n     /// A type binding (e.g., `for<'c> Foo: Send + Clone + 'c`).\n@@ -645,27 +646,27 @@ impl WherePredicate {\n     }\n }\n \n-/// A type bound, eg `for<'c> Foo: Send+Clone+'c`\n+/// A type bound (e.g., `for<'c> Foo: Send + Clone + 'c`).\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct WhereBoundPredicate {\n     pub span: Span,\n-    /// Any generics from a `for` binding\n+    /// Any generics from a `for` binding.\n     pub bound_generic_params: HirVec<GenericParam>,\n-    /// The type being bounded\n+    /// The type being bounded.\n     pub bounded_ty: P<Ty>,\n-    /// Trait and lifetime bounds (`Clone+Send+'static`)\n+    /// Trait and lifetime bounds (e.g., `Clone + Send + 'static`).\n     pub bounds: GenericBounds,\n }\n \n-/// A lifetime predicate, e.g., `'a: 'b+'c`\n+/// A lifetime predicate (e.g., `'a: 'b + 'c`).\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct WhereRegionPredicate {\n     pub span: Span,\n     pub lifetime: Lifetime,\n     pub bounds: GenericBounds,\n }\n \n-/// An equality predicate (unsupported), e.g., `T=int`\n+/// An equality predicate (e.g., `T = int`); currently unsupported.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct WhereEqPredicate {\n     pub id: NodeId,\n@@ -759,27 +760,21 @@ impl Crate {\n         }\n     }\n \n-    /// A parallel version of visit_all_item_likes\n+    /// A parallel version of `visit_all_item_likes`.\n     pub fn par_visit_all_item_likes<'hir, V>(&'hir self, visitor: &V)\n         where V: itemlikevisit::ParItemLikeVisitor<'hir> + Sync + Send\n     {\n-        scope(|s| {\n-            s.spawn(|_| {\n-                par_iter(&self.items).for_each(|(_, item)| {\n-                    visitor.visit_item(item);\n-                });\n+        parallel!({\n+            par_iter(&self.items).for_each(|(_, item)| {\n+                visitor.visit_item(item);\n             });\n-\n-            s.spawn(|_| {\n-                par_iter(&self.trait_items).for_each(|(_, trait_item)| {\n-                    visitor.visit_trait_item(trait_item);\n-                });\n+        }, {\n+            par_iter(&self.trait_items).for_each(|(_, trait_item)| {\n+                visitor.visit_trait_item(trait_item);\n             });\n-\n-            s.spawn(|_| {\n-                par_iter(&self.impl_items).for_each(|(_, impl_item)| {\n-                    visitor.visit_impl_item(impl_item);\n-                });\n+        }, {\n+            par_iter(&self.impl_items).for_each(|(_, impl_item)| {\n+                visitor.visit_impl_item(impl_item);\n             });\n         });\n     }\n@@ -806,14 +801,14 @@ pub struct MacroDef {\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Block {\n-    /// Statements in a block\n+    /// Statements in a block.\n     pub stmts: HirVec<Stmt>,\n     /// An expression at the end of the block\n-    /// without a semicolon, if any\n+    /// without a semicolon, if any.\n     pub expr: Option<P<Expr>>,\n     pub id: NodeId,\n     pub hir_id: HirId,\n-    /// Distinguishes between `unsafe { ... }` and `{ ... }`\n+    /// Distinguishes between `unsafe { ... }` and `{ ... }`.\n     pub rules: BlockCheckMode,\n     pub span: Span,\n     /// If true, then there may exist `break 'a` values that aim to\n@@ -880,18 +875,18 @@ impl Pat {\n     }\n }\n \n-/// A single field in a struct pattern\n+/// A single field in a struct pattern.\n ///\n /// Patterns like the fields of Foo `{ x, ref y, ref mut z }`\n /// are treated the same as` x: x, y: ref y, z: ref mut z`,\n-/// except is_shorthand is true\n+/// except `is_shorthand` is true.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct FieldPat {\n     pub id: NodeId,\n     pub hir_id: HirId,\n-    /// The identifier for the field\n+    /// The identifier for the field.\n     pub ident: Ident,\n-    /// The pattern the field is destructured to\n+    /// The pattern the field is destructured to.\n     pub pat: P<Pat>,\n     pub is_shorthand: bool,\n }\n@@ -928,41 +923,41 @@ pub enum RangeEnd {\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum PatKind {\n-    /// Represents a wildcard pattern (`_`)\n+    /// Represents a wildcard pattern (i.e., `_`).\n     Wild,\n \n     /// A fresh binding `ref mut binding @ OPT_SUBPATTERN`.\n     /// The `NodeId` is the canonical ID for the variable being bound,\n-    /// e.g., in `Ok(x) | Err(x)`, both `x` use the same canonical ID,\n+    /// (e.g., in `Ok(x) | Err(x)`, both `x` use the same canonical ID),\n     /// which is the pattern ID of the first `x`.\n     Binding(BindingAnnotation, NodeId, HirId, Ident, Option<P<Pat>>),\n \n-    /// A struct or struct variant pattern, e.g., `Variant {x, y, ..}`.\n+    /// A struct or struct variant pattern (e.g., `Variant {x, y, ..}`).\n     /// The `bool` is `true` in the presence of a `..`.\n     Struct(QPath, HirVec<Spanned<FieldPat>>, bool),\n \n     /// A tuple struct/variant pattern `Variant(x, y, .., z)`.\n     /// If the `..` pattern fragment is present, then `Option<usize>` denotes its position.\n-    /// 0 <= position <= subpats.len()\n+    /// `0 <= position <= subpats.len()`\n     TupleStruct(QPath, HirVec<P<Pat>>, Option<usize>),\n \n     /// A path pattern for an unit struct/variant or a (maybe-associated) constant.\n     Path(QPath),\n \n-    /// A tuple pattern `(a, b)`.\n+    /// A tuple pattern (e.g., `(a, b)`).\n     /// If the `..` pattern fragment is present, then `Option<usize>` denotes its position.\n-    /// 0 <= position <= subpats.len()\n+    /// `0 <= position <= subpats.len()`\n     Tuple(HirVec<P<Pat>>, Option<usize>),\n-    /// A `box` pattern\n+    /// A `box` pattern.\n     Box(P<Pat>),\n-    /// A reference pattern, e.g., `&mut (a, b)`\n+    /// A reference pattern (e.g., `&mut (a, b)`).\n     Ref(P<Pat>, Mutability),\n-    /// A literal\n+    /// A literal.\n     Lit(P<Expr>),\n-    /// A range pattern, e.g., `1...2` or `1..2`\n+    /// A range pattern (e.g., `1...2` or `1..2`).\n     Range(P<Expr>, P<Expr>, RangeEnd),\n     /// `[a, b, ..i, y, z]` is represented as:\n-    ///     `PatKind::Slice(box [a, b], Some(i), box [y, z])`\n+    ///     `PatKind::Slice(box [a, b], Some(i), box [y, z])`.\n     Slice(HirVec<P<Pat>>, Option<P<Pat>>, HirVec<P<Pat>>),\n }\n \n@@ -973,7 +968,7 @@ pub enum Mutability {\n }\n \n impl Mutability {\n-    /// Return MutMutable only if both arguments are mutable.\n+    /// Returns `MutMutable` only if both arguments are mutable.\n     pub fn and(self, other: Self) -> Self {\n         match self {\n             MutMutable => other,\n@@ -984,41 +979,41 @@ impl Mutability {\n \n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, Hash)]\n pub enum BinOpKind {\n-    /// The `+` operator (addition)\n+    /// The `+` operator (addition).\n     Add,\n-    /// The `-` operator (subtraction)\n+    /// The `-` operator (subtraction).\n     Sub,\n-    /// The `*` operator (multiplication)\n+    /// The `*` operator (multiplication).\n     Mul,\n-    /// The `/` operator (division)\n+    /// The `/` operator (division).\n     Div,\n-    /// The `%` operator (modulus)\n+    /// The `%` operator (modulus).\n     Rem,\n-    /// The `&&` operator (logical and)\n+    /// The `&&` operator (logical and).\n     And,\n-    /// The `||` operator (logical or)\n+    /// The `||` operator (logical or).\n     Or,\n-    /// The `^` operator (bitwise xor)\n+    /// The `^` operator (bitwise xor).\n     BitXor,\n-    /// The `&` operator (bitwise and)\n+    /// The `&` operator (bitwise and).\n     BitAnd,\n-    /// The `|` operator (bitwise or)\n+    /// The `|` operator (bitwise or).\n     BitOr,\n-    /// The `<<` operator (shift left)\n+    /// The `<<` operator (shift left).\n     Shl,\n-    /// The `>>` operator (shift right)\n+    /// The `>>` operator (shift right).\n     Shr,\n-    /// The `==` operator (equality)\n+    /// The `==` operator (equality).\n     Eq,\n-    /// The `<` operator (less than)\n+    /// The `<` operator (less than).\n     Lt,\n-    /// The `<=` operator (less than or equal to)\n+    /// The `<=` operator (less than or equal to).\n     Le,\n-    /// The `!=` operator (not equal to)\n+    /// The `!=` operator (not equal to).\n     Ne,\n-    /// The `>=` operator (greater than or equal to)\n+    /// The `>=` operator (greater than or equal to).\n     Ge,\n-    /// The `>` operator (greater than)\n+    /// The `>` operator (greater than).\n     Gt,\n }\n \n@@ -1083,7 +1078,7 @@ impl BinOpKind {\n         }\n     }\n \n-    /// Returns `true` if the binary operator takes its arguments by value\n+    /// Returns `true` if the binary operator takes its arguments by value.\n     pub fn is_by_value(self) -> bool {\n         !self.is_comparison()\n     }\n@@ -1118,11 +1113,11 @@ pub type BinOp = Spanned<BinOpKind>;\n \n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, Hash)]\n pub enum UnOp {\n-    /// The `*` operator for dereferencing\n+    /// The `*` operator (deferencing).\n     UnDeref,\n-    /// The `!` operator for logical inversion\n+    /// The `!` operator (logical negation).\n     UnNot,\n-    /// The `-` operator for negation\n+    /// The `-` operator (negation).\n     UnNeg,\n }\n \n@@ -1135,7 +1130,7 @@ impl UnOp {\n         }\n     }\n \n-    /// Returns `true` if the unary operator takes its argument by value\n+    /// Returns `true` if the unary operator takes its argument by value.\n     pub fn is_by_value(self) -> bool {\n         match self {\n             UnNeg | UnNot => true,\n@@ -1144,7 +1139,7 @@ impl UnOp {\n     }\n }\n \n-/// A statement\n+/// A statement.\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Stmt {\n     pub id: NodeId,\n@@ -1162,15 +1157,15 @@ impl fmt::Debug for Stmt {\n \n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub enum StmtKind {\n-    /// A local (let) binding:\n+    /// A local (`let`) binding.\n     Local(P<Local>),\n-    /// An item binding:\n+    /// An item binding.\n     Item(P<ItemId>),\n \n-    /// Expr without trailing semi-colon (must have unit type):\n+    /// An expression without a trailing semi-colon (must have unit type).\n     Expr(P<Expr>),\n \n-    /// Expr with trailing semi-colon (may have any type):\n+    /// An expression with a trailing semi-colon (may have any type).\n     Semi(P<Expr>),\n }\n \n@@ -1185,12 +1180,12 @@ impl StmtKind {\n     }\n }\n \n-/// Local represents a `let` statement, e.g., `let <pat>:<ty> = <expr>;`\n+/// Represents a `let` statement (i.e., `let <pat>:<ty> = <expr>;`).\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Local {\n     pub pat: P<Pat>,\n     pub ty: Option<P<Ty>>,\n-    /// Initializer expression to set the value, if any\n+    /// Initializer expression to set the value, if any.\n     pub init: Option<P<Expr>>,\n     pub id: NodeId,\n     pub hir_id: HirId,\n@@ -1199,7 +1194,7 @@ pub struct Local {\n     pub source: LocalSource,\n }\n \n-/// represents one arm of a 'match'\n+/// Represents a single arm of a `match` expression.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Arm {\n     pub attrs: HirVec<Attribute>,\n@@ -1239,7 +1234,7 @@ pub enum UnsafeSource {\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct BodyId {\n-    pub node_id: NodeId,\n+    pub hir_id: HirId,\n }\n \n /// The body of a function, closure, or constant value. In the case of\n@@ -1273,7 +1268,7 @@ pub struct Body {\n impl Body {\n     pub fn id(&self) -> BodyId {\n         BodyId {\n-            node_id: self.value.id\n+            hir_id: self.value.hir_id,\n         }\n     }\n }\n@@ -1324,6 +1319,10 @@ pub struct Expr {\n     pub hir_id: HirId,\n }\n \n+// `Expr` is used a lot. Make sure it doesn't unintentionally get bigger.\n+#[cfg(target_arch = \"x86_64\")]\n+static_assert!(MEM_SIZE_OF_EXPR: std::mem::size_of::<Expr>() == 72);\n+\n impl Expr {\n     pub fn precedence(&self) -> ExprPrecedence {\n         match self.node {\n@@ -1425,16 +1424,16 @@ impl fmt::Debug for Expr {\n pub enum ExprKind {\n     /// A `box x` expression.\n     Box(P<Expr>),\n-    /// An array (`[a, b, c, d]`)\n+    /// An array (e.g., `[a, b, c, d]`).\n     Array(HirVec<Expr>),\n-    /// A function call\n+    /// A function call.\n     ///\n     /// The first field resolves to the function itself (usually an `ExprKind::Path`),\n     /// and the second field is the list of arguments.\n     /// This also represents calling the constructor of\n     /// tuple-like ADTs such as tuple structs and enum variants.\n     Call(P<Expr>, HirVec<Expr>),\n-    /// A method call (`x.foo::<'static, Bar, Baz>(a, b, c, d)`)\n+    /// A method call (e.g., `x.foo::<'static, Bar, Baz>(a, b, c, d)`).\n     ///\n     /// The `PathSegment`/`Span` represent the method name and its generic arguments\n     /// (within the angle brackets).\n@@ -1443,64 +1442,65 @@ pub enum ExprKind {\n     /// and the remaining elements are the rest of the arguments.\n     /// Thus, `x.foo::<Bar, Baz>(a, b, c, d)` is represented as\n     /// `ExprKind::MethodCall(PathSegment { foo, [Bar, Baz] }, [x, a, b, c, d])`.\n-    MethodCall(PathSegment, Span, HirVec<Expr>),\n-    /// A tuple (`(a, b, c ,d)`)\n+    MethodCall(P<PathSegment>, Span, HirVec<Expr>),\n+    /// A tuple (e.g., `(a, b, c ,d)`).\n     Tup(HirVec<Expr>),\n-    /// A binary operation (For example: `a + b`, `a * b`)\n+    /// A binary operation (e.g., `a + b`, `a * b`).\n     Binary(BinOp, P<Expr>, P<Expr>),\n-    /// A unary operation (For example: `!x`, `*x`)\n+    /// A unary operation (e.g., `!x`, `*x`).\n     Unary(UnOp, P<Expr>),\n-    /// A literal (For example: `1`, `\"foo\"`)\n+    /// A literal (e.g., `1`, `\"foo\"`).\n     Lit(Lit),\n-    /// A cast (`foo as f64`)\n+    /// A cast (e.g., `foo as f64`).\n     Cast(P<Expr>, P<Ty>),\n+    /// A type reference (e.g., `Foo`).\n     Type(P<Expr>, P<Ty>),\n-    /// An `if` block, with an optional else block\n+    /// An `if` block, with an optional else block.\n     ///\n-    /// `if expr { expr } else { expr }`\n+    /// I.e., `if <expr> { <expr> } else { <expr> }`.\n     If(P<Expr>, P<Expr>, Option<P<Expr>>),\n     /// A while loop, with an optional label\n     ///\n-    /// `'label: while expr { block }`\n+    /// I.e., `'label: while expr { <block> }`.\n     While(P<Expr>, P<Block>, Option<Label>),\n-    /// Conditionless loop (can be exited with break, continue, or return)\n+    /// A conditionless loop (can be exited with `break`, `continue`, or `return`).\n     ///\n-    /// `'label: loop { block }`\n+    /// I.e., `'label: loop { <block> }`.\n     Loop(P<Block>, Option<Label>, LoopSource),\n     /// A `match` block, with a source that indicates whether or not it is\n     /// the result of a desugaring, and if so, which kind.\n     Match(P<Expr>, HirVec<Arm>, MatchSource),\n-    /// A closure (for example, `move |a, b, c| {a + b + c}`).\n+    /// A closure (e.g., `move |a, b, c| {a + b + c}`).\n     ///\n-    /// The final span is the span of the argument block `|...|`\n+    /// The final span is the span of the argument block `|...|`.\n     ///\n     /// This may also be a generator literal, indicated by the final boolean,\n-    /// in that case there is an GeneratorClause.\n+    /// in that case there is an `GeneratorClause`.\n     Closure(CaptureClause, P<FnDecl>, BodyId, Span, Option<GeneratorMovability>),\n-    /// A block (`'label: { ... }`)\n+    /// A block (e.g., `'label: { ... }`).\n     Block(P<Block>, Option<Label>),\n \n-    /// An assignment (`a = foo()`)\n+    /// An assignment (e.g., `a = foo()`).\n     Assign(P<Expr>, P<Expr>),\n-    /// An assignment with an operator\n+    /// An assignment with an operator.\n     ///\n-    /// For example, `a += 1`.\n+    /// E.g., `a += 1`.\n     AssignOp(BinOp, P<Expr>, P<Expr>),\n-    /// Access of a named (`obj.foo`) or unnamed (`obj.0`) struct or tuple field\n+    /// Access of a named (e.g., `obj.foo`) or unnamed (e.g., `obj.0`) struct or tuple field.\n     Field(P<Expr>, Ident),\n-    /// An indexing operation (`foo[2]`)\n+    /// An indexing operation (`foo[2]`).\n     Index(P<Expr>, P<Expr>),\n \n     /// Path to a definition, possibly containing lifetime or type parameters.\n     Path(QPath),\n \n-    /// A referencing operation (`&a` or `&mut a`)\n+    /// A referencing operation (i.e., `&a` or `&mut a`).\n     AddrOf(Mutability, P<Expr>),\n-    /// A `break`, with an optional label to break\n+    /// A `break`, with an optional label to break.\n     Break(Destination, Option<P<Expr>>),\n-    /// A `continue`, with an optional label\n+    /// A `continue`, with an optional label.\n     Continue(Destination),\n-    /// A `return`, with an optional value to be returned\n+    /// A `return`, with an optional value to be returned.\n     Ret(Option<P<Expr>>),\n \n     /// Inline assembly (from `asm!`), with its outputs and inputs.\n@@ -1510,18 +1510,18 @@ pub enum ExprKind {\n     ///\n     /// For example, `Foo {x: 1, y: 2}`, or\n     /// `Foo {x: 1, .. base}`, where `base` is the `Option<Expr>`.\n-    Struct(QPath, HirVec<Field>, Option<P<Expr>>),\n+    Struct(P<QPath>, HirVec<Field>, Option<P<Expr>>),\n \n     /// An array literal constructed from one repeated element.\n     ///\n     /// For example, `[1; 5]`. The first expression is the element\n     /// to be repeated; the second is the number of times to repeat it.\n     Repeat(P<Expr>, AnonConst),\n \n-    /// A suspension point for generators. This is `yield <expr>` in Rust.\n+    /// A suspension point for generators (i.e., `yield <expr>`).\n     Yield(P<Expr>),\n \n-    /// Placeholder for an expression that wasn't syntactically well formed in some way.\n+    /// A placeholder for an expression that wasn't syntactically well formed in some way.\n     Err,\n }\n \n@@ -1531,12 +1531,12 @@ pub enum QPath {\n     /// Path to a definition, optionally \"fully-qualified\" with a `Self`\n     /// type, if the path points to an associated item in a trait.\n     ///\n-    /// e.g., an unqualified path like `Clone::clone` has `None` for `Self`,\n+    /// E.g., an unqualified path like `Clone::clone` has `None` for `Self`,\n     /// while `<Vec<T> as Clone>::clone` has `Some(Vec<T>)` for `Self`,\n     /// even though they both have the same two-segment `Clone::clone` `Path`.\n     Resolved(Option<P<Ty>>, P<Path>),\n \n-    /// Type-related paths, e.g., `<T>::default` or `<T>::Output`.\n+    /// Type-related paths (e.g., `<T>::default` or `<T>::Output`).\n     /// Will be resolved by type-checking to an associated item.\n     ///\n     /// UFCS source paths can desugar into this, with `Vec::new` turning into\n@@ -1545,41 +1545,41 @@ pub enum QPath {\n     TypeRelative(P<Ty>, P<PathSegment>)\n }\n \n-/// Hints at the original code for a let statement\n+/// Hints at the original code for a let statement.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy)]\n pub enum LocalSource {\n-    /// A `match _ { .. }`\n+    /// A `match _ { .. }`.\n     Normal,\n-    /// A desugared `for _ in _ { .. }` loop\n+    /// A desugared `for _ in _ { .. }` loop.\n     ForLoopDesugar,\n }\n \n-/// Hints at the original code for a `match _ { .. }`\n+/// Hints at the original code for a `match _ { .. }`.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum MatchSource {\n-    /// A `match _ { .. }`\n+    /// A `match _ { .. }`.\n     Normal,\n-    /// An `if let _ = _ { .. }` (optionally with `else { .. }`)\n+    /// An `if let _ = _ { .. }` (optionally with `else { .. }`).\n     IfLetDesugar {\n         contains_else_clause: bool,\n     },\n     /// A `while let _ = _ { .. }` (which was desugared to a\n-    /// `loop { match _ { .. } }`)\n+    /// `loop { match _ { .. } }`).\n     WhileLetDesugar,\n-    /// A desugared `for _ in _ { .. }` loop\n+    /// A desugared `for _ in _ { .. }` loop.\n     ForLoopDesugar,\n-    /// A desugared `?` operator\n+    /// A desugared `?` operator.\n     TryDesugar,\n }\n \n-/// The loop type that yielded an ExprKind::Loop\n+/// The loop type that yielded an `ExprKind::Loop`.\n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n pub enum LoopSource {\n-    /// A `loop { .. }` loop\n+    /// A `loop { .. }` loop.\n     Loop,\n-    /// A `while let _ = _ { .. }` loop\n+    /// A `while let _ = _ { .. }` loop.\n     WhileLet,\n-    /// A `for _ in _ { .. }` loop\n+    /// A `for _ in _ { .. }` loop.\n     ForLoop,\n }\n \n@@ -1745,7 +1745,7 @@ impl fmt::Debug for Ty {\n     }\n }\n \n-/// Not represented directly in the AST, referred to by name through a ty_path.\n+/// Not represented directly in the AST; referred to by name through a `ty_path`.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum PrimTy {\n     Int(IntTy),\n@@ -1772,38 +1772,38 @@ pub struct ExistTy {\n     pub impl_trait_fn: Option<DefId>,\n }\n \n+/// The various kinds of types recognized by the compiler.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-/// The different kinds of types recognized by the compiler\n pub enum TyKind {\n-    /// A variable length slice (`[T]`)\n+    /// A variable length slice (i.e., `[T]`).\n     Slice(P<Ty>),\n-    /// A fixed length array (`[T; n]`)\n+    /// A fixed length array (i.e., `[T; n]`).\n     Array(P<Ty>, AnonConst),\n-    /// A raw pointer (`*const T` or `*mut T`)\n+    /// A raw pointer (i.e., `*const T` or `*mut T`).\n     Ptr(MutTy),\n-    /// A reference (`&'a T` or `&'a mut T`)\n+    /// A reference (i.e., `&'a T` or `&'a mut T`).\n     Rptr(Lifetime, MutTy),\n-    /// A bare function (e.g., `fn(usize) -> bool`)\n+    /// A bare function (e.g., `fn(usize) -> bool`).\n     BareFn(P<BareFnTy>),\n-    /// The never type (`!`)\n+    /// The never type (`!`).\n     Never,\n-    /// A tuple (`(A, B, C, D,...)`)\n+    /// A tuple (`(A, B, C, D,...)`).\n     Tup(HirVec<Ty>),\n     /// A path to a type definition (`module::module::...::Type`), or an\n-    /// associated type, e.g., `<Vec<T> as Trait>::Type` or `<T>::Target`.\n+    /// associated type (e.g., `<Vec<T> as Trait>::Type` or `<T>::Target`).\n     ///\n     /// Type parameters may be stored in each `PathSegment`.\n     Path(QPath),\n     /// A type definition itself. This is currently only used for the `existential type`\n     /// item that `impl Trait` in return position desugars to.\n     ///\n-    /// The generic arg list are the lifetimes (and in the future possibly parameters) that are\n-    /// actually bound on the `impl Trait`.\n+    /// The generic argument list contains the lifetimes (and in the future possibly parameters)\n+    /// that are actually bound on the `impl Trait`.\n     Def(ItemId, HirVec<GenericArg>),\n     /// A trait object type `Bound1 + Bound2 + Bound3`\n     /// where `Bound` is a trait or a lifetime.\n     TraitObject(HirVec<PolyTraitRef>, Lifetime),\n-    /// Unused for now\n+    /// Unused for now.\n     Typeof(AnonConst),\n     /// `TyKind::Infer` means the type should be inferred instead of it having been\n     /// specified. This can appear anywhere in a type.\n@@ -1833,15 +1833,15 @@ pub struct InlineAsm {\n     pub ctxt: SyntaxContext,\n }\n \n-/// represents an argument in a function header\n+/// Represents an argument in a function header.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Arg {\n     pub pat: P<Pat>,\n     pub id: NodeId,\n     pub hir_id: HirId,\n }\n \n-/// Represents the header (not the body) of a function declaration\n+/// Represents the header (not the body) of a function declaration.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct FnDecl {\n     pub inputs: HirVec<Ty>,\n@@ -1964,7 +1964,7 @@ pub enum FunctionRetTy {\n     /// closures default to inference. Span points to where return\n     /// type would be inserted.\n     DefaultReturn(Span),\n-    /// Everything else\n+    /// Everything else.\n     Return(P<Ty>),\n }\n \n@@ -2017,7 +2017,7 @@ pub struct VariantKind {\n     pub ident: Ident,\n     pub attrs: HirVec<Attribute>,\n     pub data: VariantData,\n-    /// Explicit discriminant, e.g., `Foo = 1`\n+    /// Explicit discriminant (e.g., `Foo = 1`).\n     pub disr_expr: Option<AnonConst>,\n }\n \n@@ -2053,7 +2053,7 @@ pub struct TraitRef {\n }\n \n impl TraitRef {\n-    /// Get the `DefId` of the referenced trait. It _must_ actually be a trait or trait alias.\n+    /// Gets the `DefId` of the referenced trait. It _must_ actually be a trait or trait alias.\n     pub fn trait_def_id(&self) -> DefId {\n         match self.path.def {\n             Def::Trait(did) => did,\n@@ -2068,10 +2068,10 @@ impl TraitRef {\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct PolyTraitRef {\n-    /// The `'a` in `<'a> Foo<&'a T>`\n+    /// The `'a` in `<'a> Foo<&'a T>`.\n     pub bound_generic_params: HirVec<GenericParam>,\n \n-    /// The `Foo<&'a T>` in `<'a> Foo<&'a T>`\n+    /// The `Foo<&'a T>` in `<'a> Foo<&'a T>`.\n     pub trait_ref: TraitRef,\n \n     pub span: Span,\n@@ -2229,7 +2229,7 @@ pub struct FnHeader {\n pub enum ItemKind {\n     /// An `extern crate` item, with optional *original* crate name if the crate was renamed.\n     ///\n-    /// e.g., `extern crate foo` or `extern crate foo_bar as foo`\n+    /// E.g., `extern crate foo` or `extern crate foo_bar as foo`.\n     ExternCrate(Option<Name>),\n \n     /// `use foo::bar::*;` or `use foo::bar::baz as quux;`\n@@ -2294,7 +2294,7 @@ impl ItemKind {\n             ItemKind::Union(..) => \"union\",\n             ItemKind::Trait(..) => \"trait\",\n             ItemKind::TraitAlias(..) => \"trait alias\",\n-            ItemKind::Impl(..) => \"item\",\n+            ItemKind::Impl(..) => \"impl\",\n         }\n     }\n \n@@ -2326,7 +2326,7 @@ impl ItemKind {\n /// contains the item's id, naturally, but also the item's name and\n /// some other high-level details (like whether it is an associated\n /// type or method, and whether it is public). This allows other\n-/// passes to find the impl they want without loading the id (which\n+/// passes to find the impl they want without loading the ID (which\n /// means fewer edges in the incremental compilation graph).\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct TraitItemRef {\n@@ -2338,10 +2338,10 @@ pub struct TraitItemRef {\n }\n \n /// A reference from an impl to one of its associated items. This\n-/// contains the item's id, naturally, but also the item's name and\n+/// contains the item's ID, naturally, but also the item's name and\n /// some other high-level details (like whether it is an associated\n /// type or method, and whether it is public). This allows other\n-/// passes to find the impl they want without loading the id (which\n+/// passes to find the impl they want without loading the ID (which\n /// means fewer edges in the incremental compilation graph).\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct ImplItemRef {\n@@ -2372,15 +2372,15 @@ pub struct ForeignItem {\n     pub vis: Visibility,\n }\n \n-/// An item within an `extern` block\n+/// An item within an `extern` block.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum ForeignItemKind {\n-    /// A foreign function\n+    /// A foreign function.\n     Fn(P<FnDecl>, HirVec<Ident>, Generics),\n     /// A foreign static item (`static ext: u8`), with optional mutability\n-    /// (the boolean is true when mutable)\n+    /// (the boolean is true when mutable).\n     Static(P<Ty>, bool),\n-    /// A foreign type\n+    /// A foreign type.\n     Type,\n }\n \n@@ -2464,36 +2464,37 @@ pub struct CodegenFnAttrs {\n bitflags! {\n     #[derive(RustcEncodable, RustcDecodable)]\n     pub struct CodegenFnAttrFlags: u32 {\n-        /// #[cold], a hint to LLVM that this function, when called, is never on\n-        /// the hot path\n+        /// `#[cold]`: a hint to LLVM that this function, when called, is never on\n+        /// the hot path.\n         const COLD                      = 1 << 0;\n-        /// #[allocator], a hint to LLVM that the pointer returned from this\n-        /// function is never null\n+        /// `#[allocator]`: a hint to LLVM that the pointer returned from this\n+        /// function is never null.\n         const ALLOCATOR                 = 1 << 1;\n-        /// #[unwind], an indicator that this function may unwind despite what\n-        /// its ABI signature may otherwise imply\n+        /// `#[unwind]`: an indicator that this function may unwind despite what\n+        /// its ABI signature may otherwise imply.\n         const UNWIND                    = 1 << 2;\n-        /// #[rust_allocator_nounwind], an indicator that an imported FFI\n+        /// `#[rust_allocator_nounwind]`, an indicator that an imported FFI\n         /// function will never unwind. Probably obsolete by recent changes with\n         /// #[unwind], but hasn't been removed/migrated yet\n         const RUSTC_ALLOCATOR_NOUNWIND  = 1 << 3;\n-        /// #[naked], indicates to LLVM that no function prologue/epilogue\n-        /// should be generated\n+        /// `#[naked]`: an indicator to LLVM that no function prologue/epilogue\n+        /// should be generated.\n         const NAKED                     = 1 << 4;\n-        /// #[no_mangle], the function's name should be the same as its symbol\n+        /// `#[no_mangle]`: an indicator that the function's name should be the same\n+        /// as its symbol.\n         const NO_MANGLE                 = 1 << 5;\n-        /// #[rustc_std_internal_symbol], and indicator that this symbol is a\n+        /// `#[rustc_std_internal_symbol]`: an indicator that this symbol is a\n         /// \"weird symbol\" for the standard library in that it has slightly\n         /// different linkage, visibility, and reachability rules.\n         const RUSTC_STD_INTERNAL_SYMBOL = 1 << 6;\n-        /// #[no_debug], indicates that no debugging information should be\n-        /// generated for this function by LLVM\n+        /// `#[no_debug]`: an indicator that no debugging information should be\n+        /// generated for this function by LLVM.\n         const NO_DEBUG                  = 1 << 7;\n-        /// #[thread_local], indicates a static is actually a thread local\n+        /// `#[thread_local]`: indicates a static is actually a thread local\n         /// piece of memory\n         const THREAD_LOCAL              = 1 << 8;\n-        /// #[used], indicates that LLVM can't eliminate this function (but the\n-        /// linker can!)\n+        /// `#[used]`: indicates that LLVM can't eliminate this function (but the\n+        /// linker can!).\n         const USED                      = 1 << 9;\n     }\n }\n@@ -2512,7 +2513,7 @@ impl CodegenFnAttrs {\n         }\n     }\n \n-    /// True if `#[inline]` or `#[inline(always)]` is present.\n+    /// Returns `true` if `#[inline]` or `#[inline(always)]` is present.\n     pub fn requests_inline(&self) -> bool {\n         match self.inline {\n             InlineAttr::Hint | InlineAttr::Always => true,"}, {"sha": "e2df290a455c4afb6f0118072d003f8b87e4f451", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,6 +1,6 @@\n-use hir::def::Def;\n-use hir::def_id::DefId;\n-use hir::{self, HirId, PatKind};\n+use crate::hir::def::Def;\n+use crate::hir::def_id::DefId;\n+use crate::hir::{self, HirId, PatKind};\n use syntax::ast;\n use syntax_pos::Span;\n \n@@ -129,7 +129,7 @@ impl hir::Pat {\n         }\n     }\n \n-    /// Return variants that are necessary to exist for the pattern to match.\n+    /// Returns variants that are necessary to exist for the pattern to match.\n     pub fn necessary_variants(&self) -> Vec<DefId> {\n         let mut variants = vec![];\n         self.walk(|p| {\n@@ -154,11 +154,9 @@ impl hir::Pat {\n \n     /// Checks if the pattern contains any `ref` or `ref mut` bindings, and if\n     /// yes whether it contains mutable or just immutables ones.\n-    ///\n-    /// FIXME(tschottdorf): this is problematic as the HIR is being scraped, but\n-    /// ref bindings are be implicit after #42640 (default match binding modes).\n-    ///\n-    /// See #44848.\n+    //\n+    // FIXME(tschottdorf): this is problematic as the HIR is being scraped, but\n+    // ref bindings are be implicit after #42640 (default match binding modes). See issue #44848.\n     pub fn contains_explicit_ref_binding(&self) -> Option<hir::Mutability> {\n         let mut result = None;\n         self.each_binding(|annotation, _, _, _| {"}, {"sha": "9b6fcf259be14ba49f0373fbc0a5be44db5c6216", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -11,9 +11,9 @@ use syntax::symbol::keywords;\n use syntax::util::parser::{self, AssocOp, Fixity};\n use syntax_pos::{self, BytePos, FileName};\n \n-use hir;\n-use hir::{PatKind, GenericBound, TraitBoundModifier, RangeEnd};\n-use hir::{GenericParam, GenericParamKind, GenericArg};\n+use crate::hir;\n+use crate::hir::{PatKind, GenericBound, TraitBoundModifier, RangeEnd};\n+use crate::hir::{GenericParam, GenericParamKind, GenericArg};\n \n use std::borrow::Cow;\n use std::cell::Cell;\n@@ -2401,7 +2401,7 @@ fn stmt_ends_with_semi(stmt: &hir::StmtKind) -> bool {\n }\n \n fn bin_op_to_assoc_op(op: hir::BinOpKind) -> AssocOp {\n-    use hir::BinOpKind::*;\n+    use crate::hir::BinOpKind::*;\n     match op {\n         Add => AssocOp::Add,\n         Sub => AssocOp::Subtract,"}, {"sha": "e60fdd62debd1f6249e6e1421db5d6d9f66d909a", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,11 +1,11 @@\n-use hir;\n-use hir::def_id::{DefId, DefIndex};\n-use hir::map::DefPathHash;\n-use hir::map::definitions::Definitions;\n-use ich::{self, CachingSourceMapView, Fingerprint};\n-use middle::cstore::CrateStore;\n-use ty::{TyCtxt, fast_reject};\n-use session::Session;\n+use crate::hir;\n+use crate::hir::def_id::{DefId, DefIndex};\n+use crate::hir::map::DefPathHash;\n+use crate::hir::map::definitions::Definitions;\n+use crate::ich::{self, CachingSourceMapView, Fingerprint};\n+use crate::middle::cstore::CrateStore;\n+use crate::ty::{TyCtxt, fast_reject};\n+use crate::session::Session;\n \n use std::cmp::Ord;\n use std::hash as std_hash;\n@@ -218,7 +218,7 @@ impl<'a> StableHashingContextProvider<'a> for StableHashingContext<'a> {\n     }\n }\n \n-impl<'a> ::dep_graph::DepGraphSafe for StableHashingContext<'a> {\n+impl<'a> crate::dep_graph::DepGraphSafe for StableHashingContext<'a> {\n }\n \n "}, {"sha": "17ed1a79d45e0ae293a3248b1b3d750e0995cdb5", "filename": "src/librustc/ich/impls_cstore.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fich%2Fimpls_cstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fich%2Fimpls_cstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_cstore.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,54 +1,52 @@\n //! This module contains `HashStable` implementations for various data types\n //! from rustc::middle::cstore in no particular order.\n \n-use middle;\n-\n-impl_stable_hash_for!(enum middle::cstore::DepKind {\n+impl_stable_hash_for!(enum crate::middle::cstore::DepKind {\n     UnexportedMacrosOnly,\n     MacrosOnly,\n     Implicit,\n     Explicit\n });\n \n-impl_stable_hash_for!(enum middle::cstore::NativeLibraryKind {\n+impl_stable_hash_for!(enum crate::middle::cstore::NativeLibraryKind {\n     NativeStatic,\n     NativeStaticNobundle,\n     NativeFramework,\n     NativeUnknown\n });\n \n-impl_stable_hash_for!(struct middle::cstore::NativeLibrary {\n+impl_stable_hash_for!(struct crate::middle::cstore::NativeLibrary {\n     kind,\n     name,\n     cfg,\n     foreign_module,\n     wasm_import_module\n });\n \n-impl_stable_hash_for!(struct middle::cstore::ForeignModule {\n+impl_stable_hash_for!(struct crate::middle::cstore::ForeignModule {\n     foreign_items,\n     def_id\n });\n \n-impl_stable_hash_for!(enum middle::cstore::LinkagePreference {\n+impl_stable_hash_for!(enum crate::middle::cstore::LinkagePreference {\n     RequireDynamic,\n     RequireStatic\n });\n \n-impl_stable_hash_for!(struct middle::cstore::ExternCrate {\n+impl_stable_hash_for!(struct crate::middle::cstore::ExternCrate {\n     src,\n     span,\n     path_len,\n     direct\n });\n \n-impl_stable_hash_for!(enum middle::cstore::ExternCrateSource {\n+impl_stable_hash_for!(enum crate::middle::cstore::ExternCrateSource {\n     Extern(def_id),\n     Use,\n     Path,\n });\n \n-impl_stable_hash_for!(struct middle::cstore::CrateSource {\n+impl_stable_hash_for!(struct crate::middle::cstore::CrateSource {\n     dylib,\n     rlib,\n     rmeta"}, {"sha": "b10e89373259798624d97801c4f5939b5967094b", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,10 +1,10 @@\n //! This module contains `HashStable` implementations for various HIR data\n //! types in no particular order.\n \n-use hir;\n-use hir::map::DefPathHash;\n-use hir::def_id::{DefId, LocalDefId, CrateNum, CRATE_DEF_INDEX};\n-use ich::{StableHashingContext, NodeIdHashingMode, Fingerprint};\n+use crate::hir;\n+use crate::hir::map::DefPathHash;\n+use crate::hir::def_id::{DefId, LocalDefId, CrateNum, CRATE_DEF_INDEX};\n+use crate::ich::{StableHashingContext, NodeIdHashingMode, Fingerprint};\n use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey,\n                                            StableHasher, StableHasherResult};\n use std::mem;\n@@ -619,7 +619,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::MatchSource {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n-        use hir::MatchSource;\n+        use crate::hir::MatchSource;\n \n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -989,8 +989,8 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::BodyId {\n     fn to_stable_hash_key(&self,\n                           hcx: &StableHashingContext<'a>)\n                           -> (DefPathHash, hir::ItemLocalId) {\n-        let hir::BodyId { node_id } = *self;\n-        node_id.to_stable_hash_key(hcx)\n+        let hir::BodyId { hir_id } = *self;\n+        hir_id.to_stable_hash_key(hcx)\n     }\n }\n \n@@ -1046,6 +1046,7 @@ impl_stable_hash_for!(enum hir::def::Def {\n     AssociatedExistential(def_id),\n     PrimTy(prim_ty),\n     TyParam(def_id),\n+    ConstParam(def_id),\n     SelfTy(trait_def_id, impl_def_id),\n     ForeignTy(def_id),\n     Fn(def_id),\n@@ -1116,20 +1117,20 @@ impl_stable_hash_for!(struct hir::def::Export {\n     span\n });\n \n-impl_stable_hash_for!(struct ::middle::lib_features::LibFeatures {\n+impl_stable_hash_for!(struct crate::middle::lib_features::LibFeatures {\n     stable,\n     unstable\n });\n \n-impl<'a> HashStable<StableHashingContext<'a>> for ::middle::lang_items::LangItem {\n+impl<'a> HashStable<StableHashingContext<'a>> for crate::middle::lang_items::LangItem {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           _: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         ::std::hash::Hash::hash(self, hasher);\n     }\n }\n \n-impl_stable_hash_for!(struct ::middle::lang_items::LanguageItems {\n+impl_stable_hash_for!(struct crate::middle::lang_items::LanguageItems {\n     items,\n     missing\n });"}, {"sha": "51fc78ffc866999844ffae550ed852d3d3de437d", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,8 +1,8 @@\n //! This module contains `HashStable` implementations for various MIR data\n //! types in no particular order.\n \n-use ich::StableHashingContext;\n-use mir;\n+use crate::ich::StableHashingContext;\n+use crate::mir;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n use std::mem;"}, {"sha": "8a388fafce5e8201717ca6262683abdb7dcc3f3d", "filename": "src/librustc/ich/impls_misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fich%2Fimpls_misc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fich%2Fimpls_misc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_misc.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,7 +1,7 @@\n //! This module contains `HashStable` implementations for various data types\n //! that don't fit into any of the other impls_xxx modules.\n \n-impl_stable_hash_for!(enum ::session::search_paths::PathKind {\n+impl_stable_hash_for!(enum crate::session::search_paths::PathKind {\n     Native,\n     Crate,\n     Dependency,"}, {"sha": "f34423ccca655b065b3fe1a3eb706106646ed355", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,7 +1,7 @@\n //! This module contains `HashStable` implementations for various data types\n //! from libsyntax in no particular order.\n \n-use ich::StableHashingContext;\n+use crate::ich::StableHashingContext;\n \n use std::hash as std_hash;\n use std::mem;\n@@ -13,7 +13,7 @@ use syntax::symbol::{InternedString, LocalInternedString};\n use syntax::tokenstream;\n use syntax_pos::SourceFile;\n \n-use hir::def_id::{DefId, CrateNum, CRATE_DEF_INDEX};\n+use crate::hir::def_id::{DefId, CrateNum, CRATE_DEF_INDEX};\n \n use smallvec::SmallVec;\n use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey,"}, {"sha": "6f04a68a6ed614e5283152b7f59437e7699b042f", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,18 +1,18 @@\n //! This module contains `HashStable` implementations for various data types\n //! from rustc::ty in no particular order.\n \n-use ich::{Fingerprint, StableHashingContext, NodeIdHashingMode};\n+use crate::ich::{Fingerprint, StableHashingContext, NodeIdHashingMode};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey,\n                                            StableHasher, StableHasherResult};\n use std::cell::RefCell;\n use std::hash as std_hash;\n use std::mem;\n-use middle::region;\n-use infer;\n-use traits;\n-use ty;\n-use mir;\n+use crate::middle::region;\n+use crate::infer;\n+use crate::traits;\n+use crate::ty;\n+use crate::mir;\n \n impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>>\n for &'gcx ty::List<T>\n@@ -206,6 +206,10 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::adjustment::AutoBorrow\n     }\n }\n \n+impl_stable_hash_for!(tuple_struct ty::util::NeedsDrop { value });\n+\n+impl_stable_hash_for!(tuple_struct ty::AdtSizedConstraint<'tcx> { list });\n+\n impl_stable_hash_for!(struct ty::UpvarPath { hir_id });\n \n impl_stable_hash_for!(struct ty::UpvarId { var_path, closure_expr_id });\n@@ -306,7 +310,7 @@ impl_stable_hash_for!(\n         ByRef(id, alloc, offset),\n     }\n );\n-impl_stable_hash_for!(struct ::mir::interpret::RawConst<'tcx> {\n+impl_stable_hash_for!(struct crate::mir::interpret::RawConst<'tcx> {\n     alloc_id,\n     ty,\n });\n@@ -512,20 +516,22 @@ impl_stable_hash_for!(enum ty::GenericParamDefKind {\n });\n \n impl_stable_hash_for!(\n-    impl<T> for enum ::middle::resolve_lifetime::Set1<T> [ ::middle::resolve_lifetime::Set1 ] {\n+    impl<T> for enum crate::middle::resolve_lifetime::Set1<T>\n+        [ crate::middle::resolve_lifetime::Set1 ]\n+    {\n         Empty,\n         Many,\n         One(value),\n     }\n );\n \n-impl_stable_hash_for!(enum ::middle::resolve_lifetime::LifetimeDefOrigin {\n+impl_stable_hash_for!(enum crate::middle::resolve_lifetime::LifetimeDefOrigin {\n     ExplicitOrElided,\n     InBand,\n     Error,\n });\n \n-impl_stable_hash_for!(enum ::middle::resolve_lifetime::Region {\n+impl_stable_hash_for!(enum crate::middle::resolve_lifetime::Region {\n     Static,\n     EarlyBound(index, decl, is_in_band),\n     LateBound(db_index, decl, is_in_band),\n@@ -547,9 +553,9 @@ impl_stable_hash_for!(enum ty::cast::CastKind {\n     FnPtrAddrCast\n });\n \n-impl_stable_hash_for!(struct ::middle::region::Scope { id, data });\n+impl_stable_hash_for!(struct crate::middle::region::Scope { id, data });\n \n-impl_stable_hash_for!(enum ::middle::region::ScopeData {\n+impl_stable_hash_for!(enum crate::middle::region::ScopeData {\n     Node,\n     CallSite,\n     Arguments,\n@@ -588,7 +594,7 @@ for ty::TyKind<'gcx>\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n-        use ty::TyKind::*;\n+        use crate::ty::TyKind::*;\n \n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -882,20 +888,20 @@ impl_stable_hash_for!(enum traits::Reveal {\n     All\n });\n \n-impl_stable_hash_for!(enum ::middle::privacy::AccessLevel {\n+impl_stable_hash_for!(enum crate::middle::privacy::AccessLevel {\n     ReachableFromImplTrait,\n     Reachable,\n     Exported,\n     Public\n });\n \n impl<'a> HashStable<StableHashingContext<'a>>\n-for ::middle::privacy::AccessLevels {\n+for crate::middle::privacy::AccessLevels {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-            let ::middle::privacy::AccessLevels {\n+            let crate::middle::privacy::AccessLevels {\n                 ref map\n             } = *self;\n \n@@ -908,14 +914,14 @@ impl_stable_hash_for!(struct ty::CrateInherentImpls {\n     inherent_impls\n });\n \n-impl_stable_hash_for!(enum ::session::CompileIncomplete {\n+impl_stable_hash_for!(enum crate::session::CompileIncomplete {\n     Stopped,\n     Errored(error_reported)\n });\n \n-impl_stable_hash_for!(struct ::util::common::ErrorReported {});\n+impl_stable_hash_for!(struct crate::util::common::ErrorReported {});\n \n-impl_stable_hash_for!(tuple_struct ::middle::reachable::ReachableSet {\n+impl_stable_hash_for!(tuple_struct crate::middle::reachable::ReachableSet {\n     reachable_set\n });\n \n@@ -924,7 +930,7 @@ for traits::Vtable<'gcx, N> where N: HashStable<StableHashingContext<'a>> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n-        use traits::Vtable::*;\n+        use crate::traits::Vtable::*;\n \n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -1105,7 +1111,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::WhereClause<'tcx\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n-        use traits::WhereClause::*;\n+        use crate::traits::WhereClause::*;\n \n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match self {\n@@ -1121,7 +1127,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::WellFormed<'tcx>\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n-        use traits::WellFormed::*;\n+        use crate::traits::WellFormed::*;\n \n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match self {\n@@ -1135,7 +1141,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::FromEnv<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n-        use traits::FromEnv::*;\n+        use crate::traits::FromEnv::*;\n \n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match self {\n@@ -1149,7 +1155,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::DomainGoal<'tcx>\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n-        use traits::DomainGoal::*;\n+        use crate::traits::DomainGoal::*;\n \n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match self {\n@@ -1165,7 +1171,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::Goal<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n-        use traits::GoalKind::*;\n+        use crate::traits::GoalKind::*;\n \n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match self {\n@@ -1208,7 +1214,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::Clause<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n-        use traits::Clause::*;\n+        use crate::traits::Clause::*;\n \n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match self {"}, {"sha": "34cd3ae5427e0ff849f6456615533a396bb3f5a6", "filename": "src/librustc/infer/at.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fat.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,6 +1,6 @@\n-//! A nice interface for working with the infcx.  The basic idea is to\n+//! A nice interface for working with the infcx. The basic idea is to\n //! do `infcx.at(cause, param_env)`, which sets the \"cause\" of the\n-//! operation as well as the surrounding parameter environment.  Then\n+//! operation as well as the surrounding parameter environment. Then\n //! you can do something like `.sub(a, b)` or `.eq(a, b)` to create a\n //! subtype or equality relationship respectively. The first argument\n //! is always the \"expected\" output from the POV of diagnostics.\n@@ -27,7 +27,7 @@\n \n use super::*;\n \n-use ty::relate::{Relate, TypeRelation};\n+use crate::ty::relate::{Relate, TypeRelation};\n \n pub struct At<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     pub infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n@@ -78,7 +78,7 @@ impl<'a, 'gcx, 'tcx> At<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Make `a <: b` where `a` may or may not be expected\n+    /// Makes `a <: b`, where `a` may or may not be expected.\n     pub fn sub_exp<T>(self,\n                       a_is_expected: bool,\n                       a: T,\n@@ -89,7 +89,7 @@ impl<'a, 'gcx, 'tcx> At<'a, 'gcx, 'tcx> {\n         self.trace_exp(a_is_expected, a, b).sub(&a, &b)\n     }\n \n-    /// Make `actual <: expected`. For example, if type-checking a\n+    /// Makes `actual <: expected`. For example, if type-checking a\n     /// call like `foo(x)`, where `foo: fn(i32)`, you might have\n     /// `sup(i32, x)`, since the \"expected\" type is the type that\n     /// appears in the signature.\n@@ -102,7 +102,7 @@ impl<'a, 'gcx, 'tcx> At<'a, 'gcx, 'tcx> {\n         self.sub_exp(false, actual, expected)\n     }\n \n-    /// Make `expected <: actual`\n+    /// Makes `expected <: actual`.\n     pub fn sub<T>(self,\n                   expected: T,\n                   actual: T)\n@@ -112,7 +112,7 @@ impl<'a, 'gcx, 'tcx> At<'a, 'gcx, 'tcx> {\n         self.sub_exp(true, expected, actual)\n     }\n \n-    /// Make `expected <: actual`\n+    /// Makes `expected <: actual`.\n     pub fn eq_exp<T>(self,\n                      a_is_expected: bool,\n                      a: T,\n@@ -123,7 +123,7 @@ impl<'a, 'gcx, 'tcx> At<'a, 'gcx, 'tcx> {\n         self.trace_exp(a_is_expected, a, b).eq(&a, &b)\n     }\n \n-    /// Make `expected <: actual`\n+    /// Makes `expected <: actual`.\n     pub fn eq<T>(self,\n                  expected: T,\n                  actual: T)\n@@ -155,7 +155,7 @@ impl<'a, 'gcx, 'tcx> At<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Compute the least-upper-bound, or mutual supertype, of two\n+    /// Computes the least-upper-bound, or mutual supertype, of two\n     /// values. The order of the arguments doesn't matter, but since\n     /// this can result in an error (e.g., if asked to compute LUB of\n     /// u32 and i32), it is meaningful to call one of them the\n@@ -169,7 +169,7 @@ impl<'a, 'gcx, 'tcx> At<'a, 'gcx, 'tcx> {\n         self.trace(expected, actual).lub(&expected, &actual)\n     }\n \n-    /// Compute the greatest-lower-bound, or mutual subtype, of two\n+    /// Computes the greatest-lower-bound, or mutual subtype, of two\n     /// values. As with `lub` order doesn't matter, except for error\n     /// cases.\n     pub fn glb<T>(self,\n@@ -210,9 +210,9 @@ impl<'a, 'gcx, 'tcx> At<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> Trace<'a, 'gcx, 'tcx> {\n-    /// Make `a <: b` where `a` may or may not be expected (if\n+    /// Makes `a <: b` where `a` may or may not be expected (if\n     /// `a_is_expected` is true, then `a` is expected).\n-    /// Make `expected <: actual`\n+    /// Makes `expected <: actual`.\n     pub fn sub<T>(self,\n                   a: &T,\n                   b: &T)\n@@ -229,7 +229,7 @@ impl<'a, 'gcx, 'tcx> Trace<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    /// Make `a == b`; the expectation is set by the call to\n+    /// Makes `a == b`; the expectation is set by the call to\n     /// `trace()`.\n     pub fn eq<T>(self,\n                  a: &T,"}, {"sha": "d06334c3ba64377dba6a44cbb9986d0d0c477fd9", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -5,15 +5,15 @@\n //!\n //! [c]: https://rust-lang.github.io/rustc-guide/traits/canonicalization.html\n \n-use infer::canonical::{\n+use crate::infer::canonical::{\n     Canonical, CanonicalTyVarKind, CanonicalVarInfo, CanonicalVarKind, Canonicalized,\n     OriginalQueryValues,\n };\n-use infer::InferCtxt;\n+use crate::infer::InferCtxt;\n use std::sync::atomic::Ordering;\n-use ty::fold::{TypeFoldable, TypeFolder};\n-use ty::subst::Kind;\n-use ty::{self, BoundVar, Lift, List, Ty, TyCtxt, TypeFlags};\n+use crate::ty::fold::{TypeFoldable, TypeFolder};\n+use crate::ty::subst::Kind;\n+use crate::ty::{self, BoundVar, Lift, List, Ty, TyCtxt, TypeFlags};\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -112,14 +112,14 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     }\n \n     /// A hacky variant of `canonicalize_query` that does not\n-    /// canonicalize `'static`.  Unfortunately, the existing leak\n+    /// canonicalize `'static`. Unfortunately, the existing leak\n     /// check treaks `'static` differently in some cases (see also\n     /// #33684), so if we are performing an operation that may need to\n     /// prove \"leak-check\" related things, we leave `'static`\n     /// alone.\n-    ///\n-    /// FIXME(#48536) -- once we have universes, we can remove this and just use\n-    /// `canonicalize_query`.\n+    //\n+    // FIXME(#48536): once we have universes, we can remove this and just use\n+    // `canonicalize_query`.\n     pub fn canonicalize_hr_query_hack<V>(\n         &self,\n         value: &V,\n@@ -595,7 +595,7 @@ impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n             .var_universe(vid)\n     }\n \n-    /// Create a canonical variable (with the given `info`)\n+    /// Creates a canonical variable (with the given `info`)\n     /// representing the region `r`; return a region referencing it.\n     fn canonical_var_for_region(\n         &mut self,"}, {"sha": "613e153ae33d4c73d0659f4c230aa715a3c594a4", "filename": "src/librustc/infer/canonical/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -21,16 +21,16 @@\n //!\n //! [c]: https://rust-lang.github.io/rustc-guide/traits/canonicalization.html\n \n-use infer::{InferCtxt, RegionVariableOrigin, TypeVariableOrigin};\n+use crate::infer::{InferCtxt, RegionVariableOrigin, TypeVariableOrigin};\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::sync::Lrc;\n use serialize::UseSpecializedDecodable;\n use smallvec::SmallVec;\n use std::ops::Index;\n use syntax::source_map::Span;\n-use ty::fold::TypeFoldable;\n-use ty::subst::Kind;\n-use ty::{self, BoundVar, Lift, List, Region, TyCtxt};\n+use crate::ty::fold::TypeFoldable;\n+use crate::ty::subst::Kind;\n+use crate::ty::{self, BoundVar, Lift, List, Region, TyCtxt};\n \n mod canonicalizer;\n \n@@ -289,7 +289,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     ///\n     /// This is only meant to be invoked as part of constructing an\n     /// inference context at the start of a query (see\n-    /// `InferCtxtBuilder::enter_with_canonical`).  It basically\n+    /// `InferCtxtBuilder::enter_with_canonical`). It basically\n     /// brings the canonical value \"into scope\" within your new infcx.\n     ///\n     /// At the end of processing, the substitution S (once\n@@ -393,14 +393,14 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n }\n \n CloneTypeFoldableAndLiftImpls! {\n-    ::infer::canonical::Certainty,\n-    ::infer::canonical::CanonicalVarInfo,\n-    ::infer::canonical::CanonicalVarKind,\n+    crate::infer::canonical::Certainty,\n+    crate::infer::canonical::CanonicalVarInfo,\n+    crate::infer::canonical::CanonicalVarKind,\n }\n \n CloneTypeFoldableImpls! {\n     for <'tcx> {\n-        ::infer::canonical::CanonicalVarInfos<'tcx>,\n+        crate::infer::canonical::CanonicalVarInfos<'tcx>,\n     }\n }\n \n@@ -424,14 +424,14 @@ impl<'tcx> CanonicalVarValues<'tcx> {\n         self.var_values.len()\n     }\n \n-    /// Make an identity substitution from this one: each bound var\n+    /// Makes an identity substitution from this one: each bound var\n     /// is matched to the same bound var, preserving the original kinds.\n     /// For example, if we have:\n     /// `self.var_values == [Type(u32), Lifetime('a), Type(u64)]`\n     /// we'll return a substitution `subst` with:\n     /// `subst.var_values == [Type(^0), Lifetime(^1), Type(^2)]`.\n     pub fn make_identity<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n-        use ty::subst::UnpackedKind;\n+        use crate::ty::subst::UnpackedKind;\n \n         CanonicalVarValues {\n             var_values: self.var_values.iter()"}, {"sha": "aef0152b6ed7332764057c554fcdc6b65c09cd43", "filename": "src/librustc/infer/canonical/query_response.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -7,26 +7,26 @@\n //!\n //! [c]: https://rust-lang.github.io/rustc-guide/traits/canonicalization.html\n \n-use infer::canonical::substitute::substitute_value;\n-use infer::canonical::{\n+use crate::infer::canonical::substitute::substitute_value;\n+use crate::infer::canonical::{\n     Canonical, CanonicalVarValues, CanonicalizedQueryResponse, Certainty,\n     OriginalQueryValues, QueryRegionConstraint, QueryResponse,\n };\n-use infer::region_constraints::{Constraint, RegionConstraintData};\n-use infer::InferCtxtBuilder;\n-use infer::{InferCtxt, InferOk, InferResult};\n+use crate::infer::region_constraints::{Constraint, RegionConstraintData};\n+use crate::infer::InferCtxtBuilder;\n+use crate::infer::{InferCtxt, InferOk, InferResult};\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::sync::Lrc;\n use std::fmt::Debug;\n use syntax_pos::DUMMY_SP;\n-use traits::query::{Fallible, NoSolution};\n-use traits::TraitEngine;\n-use traits::{Obligation, ObligationCause, PredicateObligation};\n-use ty::fold::TypeFoldable;\n-use ty::subst::{Kind, UnpackedKind};\n-use ty::{self, BoundVar, Lift, Ty, TyCtxt};\n-use util::captures::Captures;\n+use crate::traits::query::{Fallible, NoSolution};\n+use crate::traits::TraitEngine;\n+use crate::traits::{Obligation, ObligationCause, PredicateObligation};\n+use crate::ty::fold::TypeFoldable;\n+use crate::ty::subst::{Kind, UnpackedKind};\n+use crate::ty::{self, BoundVar, Lift, Ty, TyCtxt};\n+use crate::util::captures::Captures;\n \n impl<'cx, 'gcx, 'tcx> InferCtxtBuilder<'cx, 'gcx, 'tcx> {\n     /// The \"main method\" for a canonicalized trait query. Given the\n@@ -119,7 +119,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     /// If you DO want to keep track of pending obligations (which\n     /// include all region obligations, so this includes all cases\n     /// that care about regions) with this function, you have to\n-    /// do it yourself, by e.g. having them be a part of the answer.\n+    /// do it yourself, by e.g., having them be a part of the answer.\n     pub fn make_query_response_ignoring_pending_obligations<T>(\n         &self,\n         inference_vars: CanonicalVarValues<'tcx>,\n@@ -267,7 +267,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     ///   they should be ignored).\n     /// - It **can happen** (though it rarely does currently) that\n     ///   equating types and things will give rise to subobligations\n-    ///   that must be processed.  In this case, those subobligations\n+    ///   that must be processed. In this case, those subobligations\n     ///   are propagated back in the return value.\n     /// - Finally, the query result (of type `R`) is propagated back,\n     ///   after applying the substitution `S`.\n@@ -506,7 +506,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n \n     /// Given a \"guess\" at the values for the canonical variables in\n     /// the input, try to unify with the *actual* values found in the\n-    /// query result.  Often, but not always, this is a no-op, because\n+    /// query result. Often, but not always, this is a no-op, because\n     /// we already found the mapping in the \"guessing\" step.\n     ///\n     /// See also: `query_response_substitution_guess`"}, {"sha": "5af4e8366818bfee581c52356dba8c459462dd2e", "filename": "src/librustc/infer/canonical/substitute.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -6,10 +6,10 @@\n //!\n //! [c]: https://rust-lang.github.io/rustc-guide/traits/canonicalization.html\n \n-use infer::canonical::{Canonical, CanonicalVarValues};\n-use ty::fold::TypeFoldable;\n-use ty::subst::UnpackedKind;\n-use ty::{self, TyCtxt};\n+use crate::infer::canonical::{Canonical, CanonicalVarValues};\n+use crate::ty::fold::TypeFoldable;\n+use crate::ty::subst::UnpackedKind;\n+use crate::ty::{self, TyCtxt};\n \n impl<'tcx, V> Canonical<'tcx, V> {\n     /// Instantiate the wrapped value, replacing each canonical value"}, {"sha": "361fbfea09798efa0d3b9356f6fa878e0f55e459", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -29,13 +29,13 @@ use super::lub::Lub;\n use super::sub::Sub;\n use super::type_variable::TypeVariableValue;\n \n-use hir::def_id::DefId;\n-use ty::{IntType, UintType};\n-use ty::{self, Ty, TyCtxt};\n-use ty::error::TypeError;\n-use ty::relate::{self, Relate, RelateResult, TypeRelation};\n-use ty::subst::Substs;\n-use traits::{Obligation, PredicateObligations};\n+use crate::hir::def_id::DefId;\n+use crate::ty::{IntType, UintType};\n+use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::error::TypeError;\n+use crate::ty::relate::{self, Relate, RelateResult, TypeRelation};\n+use crate::ty::subst::Substs;\n+use crate::traits::{Obligation, PredicateObligations};\n \n use syntax::ast;\n use syntax_pos::Span;\n@@ -165,8 +165,8 @@ impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n         Glb::new(self, a_is_expected)\n     }\n \n-    /// Here dir is either EqTo, SubtypeOf, or SupertypeOf. The\n-    /// idea is that we should ensure that the type `a_ty` is equal\n+    /// Here, `dir` is either `EqTo`, `SubtypeOf`, or `SupertypeOf`.\n+    /// The idea is that we should ensure that the type `a_ty` is equal\n     /// to, a subtype of, or a supertype of (respectively) the type\n     /// to which `b_vid` is bound.\n     ///\n@@ -280,7 +280,7 @@ impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n struct Generalizer<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n \n-    /// Span, used when creating new type variables and things.\n+    /// The span, used when creating new type variables and things.\n     span: Span,\n \n     /// The vid of the type variable that is in the process of being\n@@ -310,7 +310,7 @@ struct Generalization<'tcx> {\n     /// particular around 'bivariant' type parameters that are only\n     /// constrained by a where-clause. As an example, imagine a type:\n     ///\n-    ///     struct Foo<A, B> where A: Iterator<Item=B> {\n+    ///     struct Foo<A, B> where A: Iterator<Item = B> {\n     ///         data: A\n     ///     }\n     ///\n@@ -323,7 +323,7 @@ struct Generalization<'tcx> {\n     /// <: ?C`, but no particular relationship between `?B` and `?D`\n     /// (after all, we do not know the variance of the normalized form\n     /// of `A::Item` with respect to `A`). If we do nothing else, this\n-    /// may mean that `?D` goes unconstrained (as in #41677).  So, in\n+    /// may mean that `?D` goes unconstrained (as in #41677). So, in\n     /// this scenario where we create a new type variable in a\n     /// bivariant context, we set the `needs_wf` flag to true. This\n     /// will force the calling code to check that `WF(Foo<?C, ?D>)`"}, {"sha": "a4b62307a60b861a39b455a43935fe433d137c17", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,12 +1,12 @@\n use super::combine::{CombineFields, RelationDir};\n use super::{Subtype};\n \n-use hir::def_id::DefId;\n+use crate::hir::def_id::DefId;\n \n-use ty::{self, Ty, TyCtxt};\n-use ty::TyVar;\n-use ty::subst::Substs;\n-use ty::relate::{self, Relate, RelateResult, TypeRelation};\n+use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::TyVar;\n+use crate::ty::subst::Substs;\n+use crate::ty::relate::{self, Relate, RelateResult, TypeRelation};\n \n /// Ensures `a` is made equal to `b`. Returns `a` on success.\n pub struct Equate<'combine, 'infcx: 'combine, 'gcx: 'infcx+'tcx, 'tcx: 'infcx> {"}, {"sha": "705d9c4cf93ea94acc0388fcaae8ffe867476452", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 42, "deletions": 35, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -48,19 +48,18 @@\n use super::lexical_region_resolve::RegionResolutionError;\n use super::region_constraints::GenericKind;\n use super::{InferCtxt, RegionVariableOrigin, SubregionOrigin, TypeTrace, ValuePairs};\n-use infer::{self, SuppressRegionErrors};\n-\n+use crate::infer::{self, SuppressRegionErrors};\n+\n+use crate::hir;\n+use crate::hir::def_id::DefId;\n+use crate::hir::Node;\n+use crate::middle::region;\n+use crate::traits::{ObligationCause, ObligationCauseCode};\n+use crate::ty::error::TypeError;\n+use crate::ty::{self, subst::Subst, Region, Ty, TyCtxt, TyKind, TypeFoldable};\n use errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString};\n-use hir;\n-use hir::def_id::DefId;\n-use hir::Node;\n-use middle::region;\n use std::{cmp, fmt};\n-use syntax::ast::DUMMY_NODE_ID;\n use syntax_pos::{Pos, Span};\n-use traits::{ObligationCause, ObligationCauseCode};\n-use ty::error::TypeError;\n-use ty::{self, subst::Subst, Region, Ty, TyCtxt, TyKind, TypeFoldable};\n \n mod note;\n \n@@ -182,8 +181,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let cm = self.sess.source_map();\n \n         let scope = region.free_region_binding_scope(self);\n-        let node = self.hir().as_local_node_id(scope).unwrap_or(DUMMY_NODE_ID);\n-        let tag = match self.hir().find(node) {\n+        let node = self.hir().as_local_hir_id(scope).unwrap_or(hir::DUMMY_HIR_ID);\n+        let tag = match self.hir().find_by_hir_id(node) {\n             Some(Node::Block(_)) | Some(Node::Expr(_)) => \"body\",\n             Some(Node::Item(it)) => Self::item_scope_tag(&it),\n             Some(Node::TraitItem(it)) => Self::trait_item_scope_tag(&it),\n@@ -192,7 +191,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         };\n         let (prefix, span) = match *region {\n             ty::ReEarlyBound(ref br) => {\n-                let mut sp = cm.def_span(self.hir().span(node));\n+                let mut sp = cm.def_span(self.hir().span_by_hir_id(node));\n                 if let Some(param) = self.hir()\n                     .get_generics(scope)\n                     .and_then(|generics| generics.get_named(&br.name))\n@@ -205,7 +204,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 bound_region: ty::BoundRegion::BrNamed(_, ref name),\n                 ..\n             }) => {\n-                let mut sp = cm.def_span(self.hir().span(node));\n+                let mut sp = cm.def_span(self.hir().span_by_hir_id(node));\n                 if let Some(param) = self.hir()\n                     .get_generics(scope)\n                     .and_then(|generics| generics.get_named(&name))\n@@ -217,15 +216,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             ty::ReFree(ref fr) => match fr.bound_region {\n                 ty::BrAnon(idx) => (\n                     format!(\"the anonymous lifetime #{} defined on\", idx + 1),\n-                    self.hir().span(node),\n+                    self.hir().span_by_hir_id(node),\n                 ),\n                 ty::BrFresh(_) => (\n                     \"an anonymous lifetime defined on\".to_owned(),\n-                    self.hir().span(node),\n+                    self.hir().span_by_hir_id(node),\n                 ),\n                 _ => (\n                     format!(\"the lifetime {} as defined on\", fr.bound_region),\n-                    cm.def_span(self.hir().span(node)),\n+                    cm.def_span(self.hir().span_by_hir_id(node)),\n                 ),\n             },\n             _ => bug!(),\n@@ -509,22 +508,31 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n-            ObligationCauseCode::MatchExpressionArm { arm_span, source } => match source {\n+            ObligationCauseCode::MatchExpressionArm {\n+                source,\n+                ref prior_arms,\n+                last_ty,\n+                ..\n+            } => match source {\n                 hir::MatchSource::IfLetDesugar { .. } => {\n-                    let msg = \"`if let` arm with an incompatible type\";\n-                    if self.tcx.sess.source_map().is_multiline(arm_span) {\n-                        err.span_note(arm_span, msg);\n-                    } else {\n-                        err.span_label(arm_span, msg);\n-                    }\n+                    let msg = \"`if let` arms have incompatible types\";\n+                    err.span_label(cause.span, msg);\n                 }\n                 hir::MatchSource::TryDesugar => {}\n                 _ => {\n-                    let msg = \"match arm with an incompatible type\";\n-                    if self.tcx.sess.source_map().is_multiline(arm_span) {\n-                        err.span_note(arm_span, msg);\n-                    } else {\n-                        err.span_label(arm_span, msg);\n+                    let msg = \"`match` arms have incompatible types\";\n+                    err.span_label(cause.span, msg);\n+                    if prior_arms.len() <= 4 {\n+                        for sp in prior_arms {\n+                            err.span_label(*sp, format!(\n+                                \"this is found to be of type `{}`\",\n+                                last_ty,\n+                            ));\n+                        }\n+                    } else if let Some(sp) = prior_arms.last() {\n+                        err.span_label(*sp, format!(\n+                            \"this and all prior arms are found to be of type `{}`\", last_ty,\n+                        ));\n                     }\n                 }\n             },\n@@ -660,7 +668,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         None\n     }\n \n-    /// Add a `,` to the type representation only if it is appropriate.\n+    /// Adds a `,` to the type representation only if it is appropriate.\n     fn push_comma(\n         &self,\n         value: &mut DiagnosticStyledString,\n@@ -716,7 +724,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         substs.truncate_to(self.tcx, &generics)\n     }\n \n-    /// Compare two given types, eliding parts that are the same between them and highlighting\n+    /// Compares two given types, eliding parts that are the same between them and highlighting\n     /// relevant differences, and return two representation of those types for highlighted printing.\n     fn cmp(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) -> (DiagnosticStyledString, DiagnosticStyledString) {\n         fn equals<'tcx>(a: &Ty<'tcx>, b: &Ty<'tcx>) -> bool {\n@@ -1451,8 +1459,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 format!(\" for lifetime parameter `{}` in coherence check\", name)\n             }\n             infer::UpvarRegion(ref upvar_id, _) => {\n-                let var_node_id = self.tcx.hir().hir_to_node_id(upvar_id.var_path.hir_id);\n-                let var_name = self.tcx.hir().name(var_node_id);\n+                let var_name = self.tcx.hir().name_by_hir_id(upvar_id.var_path.hir_id);\n                 format!(\" for capture of `{}` by closure\", var_name)\n             }\n             infer::NLL(..) => bug!(\"NLL variable found in lexical phase\"),\n@@ -1479,7 +1486,7 @@ enum FailureCode {\n impl<'tcx> ObligationCause<'tcx> {\n     fn as_failure_code(&self, terr: &TypeError<'tcx>) -> FailureCode {\n         use self::FailureCode::*;\n-        use traits::ObligationCauseCode::*;\n+        use crate::traits::ObligationCauseCode::*;\n         match self.code {\n             CompareImplMethodObligation { .. } => Error0308(\"method not compatible with trait\"),\n             MatchExpressionArm { source, .. } => Error0308(match source {\n@@ -1509,7 +1516,7 @@ impl<'tcx> ObligationCause<'tcx> {\n     }\n \n     fn as_requirement_str(&self) -> &'static str {\n-        use traits::ObligationCauseCode::*;\n+        use crate::traits::ObligationCauseCode::*;\n         match self.code {\n             CompareImplMethodObligation { .. } => \"method type is compatible with trait\",\n             ExprAssignable => \"expression is assignable\","}, {"sha": "9e0e48e474118fd14730ee363d1f804427b4b026", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,8 +1,8 @@\n-use hir::{self, Local, Pat, Body, HirId};\n-use hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use infer::InferCtxt;\n-use infer::type_variable::TypeVariableOrigin;\n-use ty::{self, Ty, Infer, TyVar};\n+use crate::hir::{self, Local, Pat, Body, HirId};\n+use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use crate::infer::InferCtxt;\n+use crate::infer::type_variable::TypeVariableOrigin;\n+use crate::ty::{self, Ty, Infer, TyVar};\n use syntax::source_map::CompilerDesugaringKind;\n use syntax_pos::Span;\n use errors::DiagnosticBuilder;\n@@ -16,9 +16,9 @@ struct FindLocalByTypeVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n }\n \n impl<'a, 'gcx, 'tcx> FindLocalByTypeVisitor<'a, 'gcx, 'tcx> {\n-    fn node_matches_type(&mut self, node_id: HirId) -> bool {\n+    fn node_matches_type(&mut self, hir_id: HirId) -> bool {\n         let ty_opt = self.infcx.in_progress_tables.and_then(|tables| {\n-            tables.borrow().node_id_to_type_opt(node_id)\n+            tables.borrow().node_type_opt(hir_id)\n         });\n         match ty_opt {\n             Some(ty) => {\n@@ -105,7 +105,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         if let Some(body_id) = body_id {\n-            let expr = self.tcx.hir().expect_expr(body_id.node_id);\n+            let expr = self.tcx.hir().expect_expr_by_hir_id(body_id.hir_id);\n             local_visitor.visit_expr(expr);\n         }\n "}, {"sha": "5d5a9b36087a256db4781bb480a52e94a9af2c12", "filename": "src/librustc/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,9 +1,9 @@\n //! Error Reporting for Anonymous Region Lifetime Errors\n //! where both the regions are anonymous.\n \n-use infer::error_reporting::nice_region_error::NiceRegionError;\n-use infer::error_reporting::nice_region_error::util::AnonymousArgInfo;\n-use util::common::ErrorReported;\n+use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n+use crate::infer::error_reporting::nice_region_error::util::AnonymousArgInfo;\n+use crate::util::common::ErrorReported;\n \n impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n     /// Print the error message for lifetime errors when both the concerned regions are anonymous.\n@@ -39,7 +39,7 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n     ///     x.push(y);\n     ///     ^ ...but data from `y` flows into `x` here\n     /// }\n-    /// ````\n+    /// ```\n     ///\n     /// It will later be extended to trait objects.\n     pub(super) fn try_report_anon_anon_conflict(&self) -> Option<ErrorReported> {"}, {"sha": "ea748874fc4e20a13e657fa68a0499119e5e22d1", "filename": "src/librustc/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,9 +1,9 @@\n-use hir;\n-use ty::{self, Region, TyCtxt};\n-use hir::Node;\n-use middle::resolve_lifetime as rl;\n-use hir::intravisit::{self, NestedVisitorMap, Visitor};\n-use infer::error_reporting::nice_region_error::NiceRegionError;\n+use crate::hir;\n+use crate::ty::{self, Region, TyCtxt};\n+use crate::hir::Node;\n+use crate::middle::resolve_lifetime as rl;\n+use crate::hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n \n impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n     /// This function calls the `visit_ty` method for the parameters"}, {"sha": "d995fe92337c4f66d398b0bedaaf14f7f8db817d", "filename": "src/librustc/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,9 +1,10 @@\n-use infer::InferCtxt;\n-use infer::lexical_region_resolve::RegionResolutionError;\n-use infer::lexical_region_resolve::RegionResolutionError::*;\n+use crate::infer::InferCtxt;\n+use crate::infer::lexical_region_resolve::RegionResolutionError;\n+use crate::infer::lexical_region_resolve::RegionResolutionError::*;\n+use crate::ty::{self, TyCtxt};\n+use crate::util::common::ErrorReported;\n+use errors::DiagnosticBuilder;\n use syntax::source_map::Span;\n-use ty::{self, TyCtxt};\n-use util::common::ErrorReported;\n \n mod different_lifetimes;\n mod find_anon_type;\n@@ -59,7 +60,7 @@ impl<'cx, 'gcx, 'tcx> NiceRegionError<'cx, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    pub fn try_report_from_nll(&self) -> Option<ErrorReported> {\n+    pub fn try_report_from_nll(&self) -> Option<DiagnosticBuilder<'cx>> {\n         // Due to the improved diagnostics returned by the MIR borrow checker, only a subset of\n         // the nice region errors are required when running under the MIR borrow checker.\n         self.try_report_named_anon_conflict()\n@@ -68,6 +69,7 @@ impl<'cx, 'gcx, 'tcx> NiceRegionError<'cx, 'gcx, 'tcx> {\n \n     pub fn try_report(&self) -> Option<ErrorReported> {\n         self.try_report_from_nll()\n+            .map(|mut diag| { diag.emit(); ErrorReported })\n             .or_else(|| self.try_report_anon_anon_conflict())\n             .or_else(|| self.try_report_outlives_closure())\n             .or_else(|| self.try_report_static_impl_trait())"}, {"sha": "3821484d38e5f9bd291d33d2f79bd6eaca568988", "filename": "src/librustc/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,14 +1,13 @@\n //! Error Reporting for Anonymous Region Lifetime Errors\n //! where one region is named and the other is anonymous.\n-use infer::error_reporting::nice_region_error::NiceRegionError;\n-use ty;\n-use util::common::ErrorReported;\n-use errors::Applicability;\n+use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n+use crate::ty;\n+use errors::{Applicability, DiagnosticBuilder};\n \n impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n     /// When given a `ConcreteFailure` for a function with arguments containing a named region and\n     /// an anonymous region, emit an descriptive diagnostic error.\n-    pub(super) fn try_report_named_anon_conflict(&self) -> Option<ErrorReported> {\n+    pub(super) fn try_report_named_anon_conflict(&self) -> Option<DiagnosticBuilder<'a>> {\n         let (span, sub, sup) = self.get_regions();\n \n         debug!(\n@@ -96,21 +95,23 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n             (\"parameter type\".to_owned(), \"type\".to_owned())\n         };\n \n-        struct_span_err!(\n+        let mut diag = struct_span_err!(\n             self.tcx().sess,\n             span,\n             E0621,\n             \"explicit lifetime required in {}\",\n             error_var\n-        ).span_suggestion(\n-            new_ty_span,\n-            &format!(\"add explicit lifetime `{}` to {}\", named, span_label_var),\n-            new_ty.to_string(),\n-            Applicability::Unspecified,\n-        )\n-        .span_label(span, format!(\"lifetime `{}` required\", named))\n-        .emit();\n-        return Some(ErrorReported);\n+        );\n+\n+        diag.span_suggestion(\n+                new_ty_span,\n+                &format!(\"add explicit lifetime `{}` to {}\", named, span_label_var),\n+                new_ty.to_string(),\n+                Applicability::Unspecified,\n+            )\n+            .span_label(span, format!(\"lifetime `{}` required\", named));\n+\n+        Some(diag)\n     }\n \n     // This method returns whether the given Region is Named"}, {"sha": "6432780de067032603fc247c36d942345e7c3089", "filename": "src/librustc/infer/error_reporting/nice_region_error/outlives_closure.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,13 +1,13 @@\n //! Error Reporting for Anonymous Region Lifetime Errors\n //! where both the regions are anonymous.\n \n-use infer::error_reporting::nice_region_error::NiceRegionError;\n-use infer::SubregionOrigin;\n-use ty::RegionKind;\n-use hir::{Expr, ExprKind::Closure};\n-use hir::Node;\n-use util::common::ErrorReported;\n-use infer::lexical_region_resolve::RegionResolutionError::SubSupConflict;\n+use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n+use crate::infer::SubregionOrigin;\n+use crate::ty::RegionKind;\n+use crate::hir::{Expr, ExprKind::Closure};\n+use crate::hir::Node;\n+use crate::util::common::ErrorReported;\n+use crate::infer::lexical_region_resolve::RegionResolutionError::SubSupConflict;\n \n impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n     /// Print the error message for lifetime errors when binding escapes a closure."}, {"sha": "3b2fb7d41008e55ca2d3077876ffa6f87d13e5a6", "filename": "src/librustc/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,20 +1,19 @@\n use errors::DiagnosticBuilder;\n-use hir::def_id::DefId;\n-use infer::error_reporting::nice_region_error::NiceRegionError;\n-use infer::lexical_region_resolve::RegionResolutionError;\n-use infer::ValuePairs;\n-use infer::{SubregionOrigin, TypeTrace};\n-use traits::{ObligationCause, ObligationCauseCode};\n-use ty;\n-use ty::error::ExpectedFound;\n-use ty::subst::Substs;\n-use util::common::ErrorReported;\n-use util::ppaux::RegionHighlightMode;\n+use crate::hir::def_id::DefId;\n+use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n+use crate::infer::lexical_region_resolve::RegionResolutionError;\n+use crate::infer::ValuePairs;\n+use crate::infer::{SubregionOrigin, TypeTrace};\n+use crate::traits::{ObligationCause, ObligationCauseCode};\n+use crate::ty;\n+use crate::ty::error::ExpectedFound;\n+use crate::ty::subst::Substs;\n+use crate::util::ppaux::RegionHighlightMode;\n \n impl NiceRegionError<'me, 'gcx, 'tcx> {\n     /// When given a `ConcreteFailure` for a function with arguments containing a named region and\n     /// an anonymous region, emit a descriptive diagnostic error.\n-    pub(super) fn try_report_placeholder_conflict(&self) -> Option<ErrorReported> {\n+    pub(super) fn try_report_placeholder_conflict(&self) -> Option<DiagnosticBuilder<'me>> {\n         match &self.error {\n             ///////////////////////////////////////////////////////////////////////////\n             // NB. The ordering of cases in this match is very\n@@ -178,7 +177,7 @@ impl NiceRegionError<'me, 'gcx, 'tcx> {\n         trait_def_id: DefId,\n         expected_substs: &'tcx Substs<'tcx>,\n         actual_substs: &'tcx Substs<'tcx>,\n-    ) -> ErrorReported {\n+    ) -> DiagnosticBuilder<'me> {\n         debug!(\n             \"try_report_placeholders_trait(\\\n              vid={:?}, \\\n@@ -295,8 +294,7 @@ impl NiceRegionError<'me, 'gcx, 'tcx> {\n             any_self_ty_has_vid,\n         );\n \n-        err.emit();\n-        ErrorReported\n+        err\n     }\n \n     /// Add notes with details about the expected and actual trait refs, with attention to cases"}, {"sha": "23acaeb31f8d4312cb04a66faf2c262611b37afb", "filename": "src/librustc/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,9 +1,9 @@\n //! Error Reporting for static impl Traits.\n \n-use infer::error_reporting::nice_region_error::NiceRegionError;\n-use infer::lexical_region_resolve::RegionResolutionError;\n-use ty::{BoundRegion, FreeRegion, RegionKind};\n-use util::common::ErrorReported;\n+use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n+use crate::infer::lexical_region_resolve::RegionResolutionError;\n+use crate::ty::{BoundRegion, FreeRegion, RegionKind};\n+use crate::util::common::ErrorReported;\n use errors::Applicability;\n \n impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {"}, {"sha": "6db1bc382afe9b4f00dcd1d43c08757ffa586f71", "filename": "src/librustc/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,10 +1,10 @@\n //! Helper functions corresponding to lifetime errors due to\n //! anonymous regions.\n \n-use hir;\n-use infer::error_reporting::nice_region_error::NiceRegionError;\n-use ty::{self, Region, Ty};\n-use hir::def_id::DefId;\n+use crate::hir;\n+use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n+use crate::ty::{self, Region, Ty};\n+use crate::hir::def_id::DefId;\n use syntax_pos::Span;\n \n // The struct contains the information about the anonymous region\n@@ -64,7 +64,7 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n                             // May return None; sometimes the tables are not yet populated.\n                             let ty_hir_id = fn_decl.inputs[index].hir_id;\n                             let arg_ty_span = hir.span(hir.hir_to_node_id(ty_hir_id));\n-                            let ty = tables.node_id_to_type_opt(arg.hir_id)?;\n+                            let ty = tables.node_type_opt(arg.hir_id)?;\n                             let mut found_anon_region = false;\n                             let new_arg_ty = self.tcx().fold_regions(&ty, &mut false, |r, _| {\n                                 if *r == *anon_region {"}, {"sha": "c05c6567bbefab50d49aa4a7a2dc827fb4753ba2", "filename": "src/librustc/infer/error_reporting/note.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,7 +1,7 @@\n-use infer::{self, InferCtxt, SubregionOrigin};\n-use middle::region;\n-use ty::{self, Region};\n-use ty::error::TypeError;\n+use crate::infer::{self, InferCtxt, SubregionOrigin};\n+use crate::middle::region;\n+use crate::ty::{self, Region};\n+use crate::ty::error::TypeError;\n use errors::DiagnosticBuilder;\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n@@ -31,8 +31,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                               \"...so that reference does not outlive borrowed content\");\n             }\n             infer::ReborrowUpvar(span, ref upvar_id) => {\n-                let var_node_id = self.tcx.hir().hir_to_node_id(upvar_id.var_path.hir_id);\n-                let var_name = self.tcx.hir().name(var_node_id);\n+                let var_name = self.tcx.hir().name_by_hir_id(upvar_id.var_path.hir_id);\n                 err.span_note(span,\n                               &format!(\"...so that closure can access `{}`\", var_name));\n             }\n@@ -164,8 +163,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 err\n             }\n             infer::ReborrowUpvar(span, ref upvar_id) => {\n-                let var_node_id = self.tcx.hir().hir_to_node_id(upvar_id.var_path.hir_id);\n-                let var_name = self.tcx.hir().name(var_node_id);\n+                let var_name = self.tcx.hir().name_by_hir_id(upvar_id.var_path.hir_id);\n                 let mut err = struct_span_err!(self.tcx.sess,\n                                                span,\n                                                E0313,"}, {"sha": "201717b34ee41abfb18b89a5854c2e6925b26d69", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -31,9 +31,9 @@\n //! variable only once, and it does so as soon as it can, so it is reasonable to ask what the type\n //! inferencer knows \"so far\".\n \n-use ty::{self, Ty, TyCtxt, TypeFoldable};\n-use ty::fold::TypeFolder;\n-use util::nodemap::FxHashMap;\n+use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use crate::ty::fold::TypeFolder;\n+use crate::util::nodemap::FxHashMap;\n \n use std::collections::hash_map::Entry;\n "}, {"sha": "5f6a8802b4defbe7a8b9f7b5e66a41d4384b6f80", "filename": "src/librustc/infer/fudge.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffudge.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,6 +1,6 @@\n-use infer::type_variable::TypeVariableMap;\n-use ty::{self, Ty, TyCtxt};\n-use ty::fold::{TypeFoldable, TypeFolder};\n+use crate::infer::type_variable::TypeVariableMap;\n+use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::fold::{TypeFoldable, TypeFolder};\n \n use super::InferCtxt;\n use super::RegionVariableOrigin;\n@@ -22,13 +22,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// closure `f`. In our example above, what this closure will do\n     /// is to unify the expectation (`Option<&[u32]>`) with the actual\n     /// return type (`Option<?T>`, where `?T` represents the variable\n-    /// instantiated for `T`).  This will cause `?T` to be unified\n+    /// instantiated for `T`). This will cause `?T` to be unified\n     /// with `&?a [u32]`, where `?a` is a fresh lifetime variable. The\n     /// input type (`?T`) is then returned by `f()`.\n     ///\n     /// At this point, `fudge_regions_if_ok` will normalize all type\n     /// variables, converting `?T` to `&?a [u32]` and end the\n-    /// snapshot.  The problem is that we can't just return this type\n+    /// snapshot. The problem is that we can't just return this type\n     /// out, because it references the region variable `?a`, and that\n     /// region variable was popped when we popped the snapshot.\n     ///"}, {"sha": "910c6571853dc078580721c9068b19672b41b876", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -3,9 +3,9 @@ use super::InferCtxt;\n use super::lattice::{self, LatticeDir};\n use super::Subtype;\n \n-use traits::ObligationCause;\n-use ty::{self, Ty, TyCtxt};\n-use ty::relate::{Relate, RelateResult, TypeRelation};\n+use crate::traits::ObligationCause;\n+use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::relate::{Relate, RelateResult, TypeRelation};\n \n /// \"Greatest lower bound\" (common subtype)\n pub struct Glb<'combine, 'infcx: 'combine, 'gcx: 'infcx+'tcx, 'tcx: 'infcx> {"}, {"sha": "7f01078737d73cd3af8e7f0ff8acd17df1faaf53", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -4,8 +4,8 @@\n use super::combine::CombineFields;\n use super::{HigherRankedType, InferCtxt, PlaceholderMap};\n \n-use ty::relate::{Relate, RelateResult, TypeRelation};\n-use ty::{self, Binder, TypeFoldable};\n+use crate::ty::relate::{Relate, RelateResult, TypeRelation};\n+use crate::ty::{self, Binder, TypeFoldable};\n \n impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n     pub fn higher_ranked_sub<T>(\n@@ -54,7 +54,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n-    /// Replace all regions (resp. types) bound by `binder` with placeholder\n+    /// Replaces all regions (resp. types) bound by `binder` with placeholder\n     /// regions (resp. types) and return a map indicating which bound-region\n     /// placeholder region. This is the first step of checking subtyping\n     /// when higher-ranked things are involved."}, {"sha": "e40bb9724076354dfc36734dcfd90b0d0832b2d3", "filename": "src/librustc/infer/lattice.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flattice.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,7 +1,7 @@\n //! # Lattice Variables\n //!\n //! This file contains generic code for operating on inference variables\n-//! that are characterized by an upper- and lower-bound.  The logic and\n+//! that are characterized by an upper- and lower-bound. The logic and\n //! reasoning is explained in detail in the large comment in `infer.rs`.\n //!\n //! The code in here is defined quite generically so that it can be\n@@ -13,7 +13,7 @@\n //!\n //! Although all the functions are generic, we generally write the\n //! comments in a way that is specific to type variables and the LUB\n-//! operation.  It's just easier that way.\n+//! operation. It's just easier that way.\n //!\n //! In general all of the functions are defined parametrically\n //! over a `LatticeValue`, which is a value defined with respect to\n@@ -22,10 +22,10 @@\n use super::InferCtxt;\n use super::type_variable::TypeVariableOrigin;\n \n-use traits::ObligationCause;\n-use ty::TyVar;\n-use ty::{self, Ty};\n-use ty::relate::{RelateResult, TypeRelation};\n+use crate::traits::ObligationCause;\n+use crate::ty::TyVar;\n+use crate::ty::{self, Ty};\n+use crate::ty::relate::{RelateResult, TypeRelation};\n \n pub trait LatticeDir<'f, 'gcx: 'f+'tcx, 'tcx: 'f> : TypeRelation<'f, 'gcx, 'tcx> {\n     fn infcx(&self) -> &'f InferCtxt<'f, 'gcx, 'tcx>;"}, {"sha": "073a3f74422c6ff2bdf82ca62f0e3fe2f7b4ecc6", "filename": "src/librustc/infer/lexical_region_resolve/graphviz.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -8,14 +8,14 @@\n /// For clarity, rename the graphviz crate locally to dot.\n use graphviz as dot;\n \n-use hir::def_id::DefIndex;\n-use ty;\n-use middle::free_region::RegionRelations;\n-use middle::region;\n+use crate::hir::def_id::DefIndex;\n+use crate::ty;\n+use crate::middle::free_region::RegionRelations;\n+use crate::middle::region;\n use super::Constraint;\n-use infer::SubregionOrigin;\n-use infer::region_constraints::RegionConstraintData;\n-use util::nodemap::{FxHashMap, FxHashSet};\n+use crate::infer::SubregionOrigin;\n+use crate::infer::region_constraints::RegionConstraintData;\n+use crate::util::nodemap::{FxHashMap, FxHashSet};\n \n use std::borrow::Cow;\n use std::collections::hash_map::Entry::Vacant;"}, {"sha": "03ade8825368273ff756a282d20cf7a6352bf8c4", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,13 +1,13 @@\n-//! The code to do lexical region resolution.\n-\n-use infer::region_constraints::Constraint;\n-use infer::region_constraints::GenericKind;\n-use infer::region_constraints::RegionConstraintData;\n-use infer::region_constraints::VarInfos;\n-use infer::region_constraints::VerifyBound;\n-use infer::RegionVariableOrigin;\n-use infer::SubregionOrigin;\n-use middle::free_region::RegionRelations;\n+//! Lexical region resolution.\n+\n+use crate::infer::region_constraints::Constraint;\n+use crate::infer::region_constraints::GenericKind;\n+use crate::infer::region_constraints::RegionConstraintData;\n+use crate::infer::region_constraints::VarInfos;\n+use crate::infer::region_constraints::VerifyBound;\n+use crate::infer::RegionVariableOrigin;\n+use crate::infer::SubregionOrigin;\n+use crate::middle::free_region::RegionRelations;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::implementation::{\n     Direction, Graph, NodeIndex, INCOMING, OUTGOING,\n@@ -16,11 +16,11 @@ use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use smallvec::SmallVec;\n use std::fmt;\n use std::u32;\n-use ty::fold::TypeFoldable;\n-use ty::{self, Ty, TyCtxt};\n-use ty::{ReEarlyBound, ReEmpty, ReErased, ReFree, ReStatic};\n-use ty::{ReLateBound, ReScope, RePlaceholder, ReVar};\n-use ty::{Region, RegionVid};\n+use crate::ty::fold::TypeFoldable;\n+use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::{ReEarlyBound, ReEmpty, ReErased, ReFree, ReStatic};\n+use crate::ty::{ReLateBound, ReScope, RePlaceholder, ReVar};\n+use crate::ty::{Region, RegionVid};\n \n mod graphviz;\n \n@@ -492,20 +492,20 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n             match *value {\n                 VarValue::Value(_) => { /* Inference successful */ }\n                 VarValue::ErrorValue => {\n-                    /* Inference impossible, this value contains\n+                    /* Inference impossible: this value contains\n                        inconsistent constraints.\n \n                        I think that in this case we should report an\n-                       error now---unlike the case above, we can't\n+                       error now -- unlike the case above, we can't\n                        wait to see whether the user needs the result\n-                       of this variable.  The reason is that the mere\n+                       of this variable. The reason is that the mere\n                        existence of this variable implies that the\n                        region graph is inconsistent, whether or not it\n                        is used.\n \n                        For example, we may have created a region\n                        variable that is the GLB of two other regions\n-                       which do not have a GLB.  Even if that variable\n+                       which do not have a GLB. Even if that variable\n                        is not used, it implies that those two regions\n                        *should* have a GLB.\n "}, {"sha": "f9eb60d82d17b5c38d6aa61e5514dc4f8c0b65a7", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -3,9 +3,9 @@ use super::InferCtxt;\n use super::lattice::{self, LatticeDir};\n use super::Subtype;\n \n-use traits::ObligationCause;\n-use ty::{self, Ty, TyCtxt};\n-use ty::relate::{Relate, RelateResult, TypeRelation};\n+use crate::traits::ObligationCause;\n+use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::relate::{Relate, RelateResult, TypeRelation};\n \n /// \"Least upper bound\" (common supertype)\n pub struct Lub<'combine, 'infcx: 'combine, 'gcx: 'infcx+'tcx, 'tcx: 'infcx> {"}, {"sha": "a61771b2a4eeab2884b672a2c33391e0ec67b96d", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 41, "deletions": 47, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -5,31 +5,33 @@ pub use self::LateBoundRegionConversionTime::*;\n pub use self::RegionVariableOrigin::*;\n pub use self::SubregionOrigin::*;\n pub use self::ValuePairs::*;\n-pub use ty::IntVarValue;\n+pub use crate::ty::IntVarValue;\n+\n+use crate::hir;\n+use crate::hir::def_id::DefId;\n+use crate::infer::canonical::{Canonical, CanonicalVarValues};\n+use crate::middle::free_region::RegionRelations;\n+use crate::middle::lang_items;\n+use crate::middle::region;\n+use crate::session::config::BorrowckMode;\n+use crate::traits::{self, ObligationCause, PredicateObligations, TraitEngine};\n+use crate::ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n+use crate::ty::fold::TypeFoldable;\n+use crate::ty::relate::RelateResult;\n+use crate::ty::subst::{Kind, Substs};\n+use crate::ty::{self, GenericParamDefKind, Ty, TyCtxt, CtxtInterners};\n+use crate::ty::{FloatVid, IntVid, TyVid};\n+use crate::util::nodemap::FxHashMap;\n \n use arena::SyncDroplessArena;\n use errors::DiagnosticBuilder;\n-use hir::def_id::DefId;\n-use infer::canonical::{Canonical, CanonicalVarValues};\n-use middle::free_region::RegionRelations;\n-use middle::lang_items;\n-use middle::region;\n use rustc_data_structures::unify as ut;\n-use session::config::BorrowckMode;\n use std::cell::{Cell, Ref, RefCell, RefMut};\n use std::collections::BTreeMap;\n use std::fmt;\n use syntax::ast;\n use syntax_pos::symbol::InternedString;\n-use syntax_pos::{self, Span};\n-use traits::{self, ObligationCause, PredicateObligations, TraitEngine};\n-use ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n-use ty::fold::TypeFoldable;\n-use ty::relate::RelateResult;\n-use ty::subst::{Kind, Substs};\n-use ty::{self, GenericParamDefKind, Ty, TyCtxt, CtxtInterners};\n-use ty::{FloatVid, IntVid, TyVid};\n-use util::nodemap::FxHashMap;\n+use syntax_pos::Span;\n \n use self::combine::CombineFields;\n use self::lexical_region_resolve::LexicalRegionResolutions;\n@@ -202,7 +204,7 @@ pub struct InferCtxt<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     // for each body-id in this map, which will process the\n     // obligations within. This is expected to be done 'late enough'\n     // that all type inference variables have been bound and so forth.\n-    pub region_obligations: RefCell<Vec<(ast::NodeId, RegionObligation<'tcx>)>>,\n+    pub region_obligations: RefCell<Vec<(hir::HirId, RegionObligation<'tcx>)>>,\n \n     /// What is the innermost universe we have created? Starts out as\n     /// `UniverseIndex::root()` but grows from there as we enter\n@@ -221,7 +223,7 @@ pub struct InferCtxt<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n /// replaced with.\n pub type PlaceholderMap<'tcx> = BTreeMap<ty::BoundRegion, ty::Region<'tcx>>;\n \n-/// See `error_reporting` module for more details\n+/// See the `error_reporting` module for more details.\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub enum ValuePairs<'tcx> {\n     Types(ExpectedFound<Ty<'tcx>>),\n@@ -233,7 +235,7 @@ pub enum ValuePairs<'tcx> {\n /// The trace designates the path through inference that we took to\n /// encounter an error or subtyping constraint.\n ///\n-/// See `error_reporting` module for more details.\n+/// See the `error_reporting` module for more details.\n #[derive(Clone)]\n pub struct TypeTrace<'tcx> {\n     cause: ObligationCause<'tcx>,\n@@ -454,9 +456,9 @@ impl fmt::Display for FixupError {\n     }\n }\n \n-/// Helper type of a temporary returned by tcx.infer_ctxt().\n+/// Helper type of a temporary returned by `tcx.infer_ctxt()`.\n /// Necessary because we can't write the following bound:\n-/// F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(InferCtxt<'b, 'gcx, 'tcx>).\n+/// `F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(InferCtxt<'b, 'gcx, 'tcx>)`.\n pub struct InferCtxtBuilder<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     global_tcx: TyCtxt<'a, 'gcx, 'gcx>,\n     arena: SyncDroplessArena,\n@@ -487,7 +489,7 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n     /// inference context that contains each of the bound values\n     /// within instantiated as a fresh variable. The `f` closure is\n     /// invoked with the new infcx, along with the instantiated value\n-    /// `V` and a substitution `S`.  This substitution `S` maps from\n+    /// `V` and a substitution `S`. This substitution `S` maps from\n     /// the bound values in `C` to their instantiated values in `V`\n     /// (in other words, `S(C) = V`).\n     pub fn enter_with_canonical<T, R>(\n@@ -563,7 +565,7 @@ impl<'tcx, T> InferOk<'tcx, T> {\n         }\n     }\n \n-    /// Extract `value`, registering any obligations into `fulfill_cx`\n+    /// Extracts `value`, registering any obligations into `fulfill_cx`.\n     pub fn into_value_registering_obligations(\n         self,\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n@@ -617,8 +619,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn type_is_unconstrained_numeric(&'a self, ty: Ty<'_>) -> UnconstrainedNumeric {\n-        use ty::error::UnconstrainedNumeric::Neither;\n-        use ty::error::UnconstrainedNumeric::{UnconstrainedFloat, UnconstrainedInt};\n+        use crate::ty::error::UnconstrainedNumeric::Neither;\n+        use crate::ty::error::UnconstrainedNumeric::{UnconstrainedFloat, UnconstrainedInt};\n         match ty.sty {\n             ty::Infer(ty::IntVar(vid)) => {\n                 if self.int_unification_table\n@@ -794,7 +796,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             .commit(region_constraints_snapshot);\n     }\n \n-    /// Execute `f` and commit the bindings\n+    /// Executes `f` and commit the bindings.\n     pub fn commit_unconditionally<R, F>(&self, f: F) -> R\n     where\n         F: FnOnce() -> R,\n@@ -806,7 +808,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         r\n     }\n \n-    /// Execute `f` and commit the bindings if closure `f` returns `Ok(_)`\n+    /// Executes `f` and commit the bindings if closure `f` returns `Ok(_)`.\n     pub fn commit_if_ok<T, E, F>(&self, f: F) -> Result<T, E>\n     where\n         F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> Result<T, E>,\n@@ -838,7 +840,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         r\n     }\n \n-    /// Execute `f` then unroll any bindings it creates\n+    /// Executes `f` then unroll any bindings it creates.\n     pub fn probe<R, F>(&self, f: F) -> R\n     where\n         F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> R,\n@@ -996,14 +998,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.float_unification_table.borrow_mut().new_key(None)\n     }\n \n-    /// Create a fresh region variable with the next available index.\n+    /// Creates a fresh region variable with the next available index.\n     /// The variable will be created in the maximum universe created\n     /// thus far, allowing it to name any region created thus far.\n     pub fn next_region_var(&self, origin: RegionVariableOrigin) -> ty::Region<'tcx> {\n         self.next_region_var_in_universe(origin, self.universe())\n     }\n \n-    /// Create a fresh region variable with the next available index\n+    /// Creates a fresh region variable with the next available index\n     /// in the given universe; typically, you can use\n     /// `next_region_var` and just use the maximal universe.\n     pub fn next_region_var_in_universe(\n@@ -1069,8 +1071,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         Substs::for_item(self.tcx, def_id, |param, _| self.var_for_def(span, param))\n     }\n \n-    /// True if errors have been reported since this infcx was\n-    /// created.  This is sometimes used as a heuristic to skip\n+    /// Returns `true` if errors have been reported since this infcx was\n+    /// created. This is sometimes used as a heuristic to skip\n     /// reporting errors that often occur as a result of earlier\n     /// errors, but where it's hard to be 100% sure (e.g., unresolved\n     /// inference variables, regionck errors).\n@@ -1278,7 +1280,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         value.fold_with(&mut r)\n     }\n \n-    /// Returns true if `T` contains unresolved type variables. In the\n+    /// Returns `true` if `T` contains unresolved type variables. In the\n     /// process of visiting `T`, this will resolve (where possible)\n     /// type variables in `T`, but it never constructs the final,\n     /// resolved type, so it's more efficient than\n@@ -1291,14 +1293,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         value.visit_with(&mut r)\n     }\n \n-    pub fn resolve_type_and_region_vars_if_possible<T>(&self, value: &T) -> T\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        let mut r = resolve::OpportunisticTypeAndRegionResolver::new(self);\n-        value.fold_with(&mut r)\n-    }\n-\n     pub fn fully_resolve<T: TypeFoldable<'tcx>>(&self, value: &T) -> FixupResult<T> {\n         /*!\n          * Attempts to resolve all type/region variables in\n@@ -1369,7 +1363,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.tcx.replace_bound_vars(value, fld_r, fld_t)\n     }\n \n-    /// See `verify_generic_bound` method in `region_constraints`\n+    /// See the [`region_constraints::verify_generic_bound`] method.\n     pub fn verify_generic_bound(\n         &self,\n         origin: SubregionOrigin<'tcx>,\n@@ -1421,7 +1415,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         closure_kind_ty.to_opt_closure_kind()\n     }\n \n-    /// Obtain the signature of a closure.  For closures, unlike\n+    /// Obtain the signature of a closure. For closures, unlike\n     /// `tcx.fn_sig(def_id)`, this method will work during the\n     /// type-checking of the enclosing function and return the closure\n     /// signature in its partially inferred state.\n@@ -1440,7 +1434,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn partially_normalize_associated_types_in<T>(\n         &self,\n         span: Span,\n-        body_id: ast::NodeId,\n+        body_id: hir::HirId,\n         param_env: ty::ParamEnv<'tcx>,\n         value: &T,\n     ) -> InferOk<'tcx, T>\n@@ -1466,8 +1460,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Clears the selection, evaluation, and projection caches. This is useful when\n-    /// repeatedly attempting to select an Obligation while changing only\n-    /// its ParamEnv, since FulfillmentContext doesn't use 'probe'\n+    /// repeatedly attempting to select an `Obligation` while changing only\n+    /// its `ParamEnv`, since `FulfillmentContext` doesn't use probing.\n     pub fn clear_caches(&self) {\n         self.selection_cache.clear();\n         self.evaluation_cache.clear();\n@@ -1478,7 +1472,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.universe.get()\n     }\n \n-    /// Create and return a fresh universe that extends all previous\n+    /// Creates and return a fresh universe that extends all previous\n     /// universes. Updates `self.universe` to that new universe.\n     pub fn create_next_universe(&self) -> ty::UniverseIndex {\n         let u = self.universe.get().next_universe();"}, {"sha": "f37e24b292e0351e172ad633fdc068df1ea75c3b", "filename": "src/librustc/infer/nll_relate/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -47,17 +47,17 @@ where\n \n     /// How are we relating `a` and `b`?\n     ///\n-    /// - covariant means `a <: b`\n-    /// - contravariant means `b <: a`\n-    /// - invariant means `a == b\n-    /// - bivariant means that it doesn't matter\n+    /// - Covariant means `a <: b`.\n+    /// - Contravariant means `b <: a`.\n+    /// - Invariant means `a == b.\n+    /// - Bivariant means that it doesn't matter.\n     ambient_variance: ty::Variance,\n \n     /// When we pass through a set of binders (e.g., when looking into\n-    /// a `fn` type), we push a new bound region scope onto here.  This\n+    /// a `fn` type), we push a new bound region scope onto here. This\n     /// will contain the instantiated region for each region in those\n     /// binders. When we then encounter a `ReLateBound(d, br)`, we can\n-    /// use the debruijn index `d` to find the right scope, and then\n+    /// use the De Bruijn index `d` to find the right scope, and then\n     /// bound region name `br` to find the specific instantiation from\n     /// within that scope. See `replace_bound_region`.\n     ///\n@@ -114,7 +114,7 @@ pub trait TypeRelatingDelegate<'tcx> {\n     /// Define the normalization strategy to use, eager or lazy.\n     fn normalization() -> NormalizationStrategy;\n \n-    /// Enable some optimizations if we do not expect inference variables\n+    /// Enables some optimizations if we do not expect inference variables\n     /// in the RHS of the relation.\n     fn forbid_inference_vars() -> bool;\n }\n@@ -208,7 +208,7 @@ where\n     /// When we encounter binders during the type traversal, we record\n     /// the value to substitute for each of the things contained in\n     /// that binder. (This will be either a universal placeholder or\n-    /// an existential inference variable.) Given the debruijn index\n+    /// an existential inference variable.) Given the De Bruijn index\n     /// `debruijn` (and name `br`) of some binder we have now\n     /// encountered, this routine finds the value that we instantiated\n     /// the region with; to do so, it indexes backwards into the list"}, {"sha": "1f81321d22d6ed1099dd7082ef905130050c1b3c", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,16 +1,16 @@\n-use hir::def_id::DefId;\n-use hir;\n-use hir::Node;\n-use infer::{self, InferCtxt, InferOk, TypeVariableOrigin};\n-use infer::outlives::free_region_map::FreeRegionRelations;\n+use crate::hir::def_id::DefId;\n+use crate::hir;\n+use crate::hir::Node;\n+use crate::infer::{self, InferCtxt, InferOk, TypeVariableOrigin};\n+use crate::infer::outlives::free_region_map::FreeRegionRelations;\n use rustc_data_structures::fx::FxHashMap;\n use syntax::ast;\n-use traits::{self, PredicateObligation};\n-use ty::{self, Ty, TyCtxt, GenericParamDefKind};\n-use ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder};\n-use ty::outlives::Component;\n-use ty::subst::{Kind, Substs, UnpackedKind};\n-use util::nodemap::DefIdMap;\n+use crate::traits::{self, PredicateObligation};\n+use crate::ty::{self, Ty, TyCtxt, GenericParamDefKind};\n+use crate::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder};\n+use crate::ty::outlives::Component;\n+use crate::ty::subst::{Kind, Substs, UnpackedKind};\n+use crate::util::nodemap::DefIdMap;\n \n pub type OpaqueTypeMap<'tcx> = DefIdMap<OpaqueTypeDecl<'tcx>>;\n \n@@ -46,7 +46,7 @@ pub struct OpaqueTypeDecl<'tcx> {\n     /// lifetime parameter on `foo`.)\n     pub concrete_ty: Ty<'tcx>,\n \n-    /// True if the `impl Trait` bounds include region bounds.\n+    /// Returns `true` if the `impl Trait` bounds include region bounds.\n     /// For example, this would be true for:\n     ///\n     ///     fn foo<'a, 'b, 'c>() -> impl Trait<'c> + 'a + 'b\n@@ -71,7 +71,7 @@ pub struct OpaqueTypeDecl<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n-    /// Replace all opaque types in `value` with fresh inference variables\n+    /// Replaces all opaque types in `value` with fresh inference variables\n     /// and creates appropriate obligations. For example, given the input:\n     ///\n     ///     impl Iterator<Item = impl Debug>\n@@ -88,7 +88,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     ///\n     /// # Parameters\n     ///\n-    /// - `parent_def_id` -- the def-id of the function in which the opaque type\n+    /// - `parent_def_id` -- the `DefId` of the function in which the opaque type\n     ///   is defined\n     /// - `body_id` -- the body-id with which the resulting obligations should\n     ///   be associated\n@@ -98,7 +98,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn instantiate_opaque_types<T: TypeFoldable<'tcx>>(\n         &self,\n         parent_def_id: DefId,\n-        body_id: ast::NodeId,\n+        body_id: hir::HirId,\n         param_env: ty::ParamEnv<'tcx>,\n         value: &T,\n     ) -> InferOk<'tcx, (T, OpaqueTypeMap<'tcx>)> {\n@@ -132,7 +132,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     ///\n     /// # The Problem\n     ///\n-    /// Let's work through an example to explain how it works.  Assume\n+    /// Let's work through an example to explain how it works. Assume\n     /// the current function is as follows:\n     ///\n     /// ```text\n@@ -164,7 +164,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// replace each of the references (`Foo1<'a>`, `Foo2<'b>`) with\n     /// fresh inference variables C1 and C2. We wish to use the values\n     /// of these variables to infer the underlying types of `Foo1` and\n-    /// `Foo2`.  That is, this gives rise to higher-order (pattern) unification\n+    /// `Foo2`. That is, this gives rise to higher-order (pattern) unification\n     /// constraints like:\n     ///\n     /// ```text\n@@ -199,7 +199,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     ///\n     /// Ordinarily, the subtyping rules would ensure that these are\n     /// sufficiently large. But since `impl Bar<'a>` isn't a specific\n-    /// type per se, we don't get such constraints by default.  This\n+    /// type per se, we don't get such constraints by default. This\n     /// is where this function comes into play. It adds extra\n     /// constraints to ensure that all the regions which appear in the\n     /// inferred type are regions that could validly appear.\n@@ -632,7 +632,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for ReverseMapper<'cx, 'gcx, 'tcx>\n struct Instantiator<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     parent_def_id: DefId,\n-    body_id: ast::NodeId,\n+    body_id: hir::HirId,\n     param_env: ty::ParamEnv<'tcx>,\n     opaque_types: OpaqueTypeMap<'tcx>,\n     obligations: Vec<PredicateObligation<'tcx>>,\n@@ -813,7 +813,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n     }\n }\n \n-/// Whether `opaque_node_id` is a sibling or a child of a sibling of `def_id`\n+/// Returns `true` if `opaque_node_id` is a sibling or a child of a sibling of `def_id`.\n ///\n /// ```rust\n /// pub mod foo {\n@@ -827,11 +827,10 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n /// }\n /// ```\n ///\n-/// Here, `def_id` will be the `DefId` of the existential type `Baz`.\n-/// `opaque_node_id` is the `NodeId` of the reference to Baz --\n-///  so either the return type of f1 or f2.\n-/// We will return true if the reference is within the same module as the existential type\n-/// So true for f1, false for f2.\n+/// Here, `def_id` is the `DefId` of the existential type `Baz` and `opaque_node_id` is the\n+/// `NodeId` of the reference to `Baz` (i.e., the return type of both `f1` and `f2`).\n+/// We return `true` if the reference is within the same module as the existential type\n+/// (i.e., `true` for `f1`, `false` for `f2`).\n pub fn may_define_existential_type(\n     tcx: TyCtxt<'_, '_, '_>,\n     def_id: DefId,"}, {"sha": "39aa51a95f793cb9bebe71b05f16bafc9f493df5", "filename": "src/librustc/infer/outlives/env.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,10 +1,10 @@\n-use infer::outlives::free_region_map::FreeRegionMap;\n-use infer::{GenericKind, InferCtxt};\n+use crate::infer::outlives::free_region_map::FreeRegionMap;\n+use crate::infer::{GenericKind, InferCtxt};\n+use crate::hir;\n use rustc_data_structures::fx::FxHashMap;\n-use syntax::ast;\n use syntax_pos::Span;\n-use traits::query::outlives_bounds::{self, OutlivesBound};\n-use ty::{self, Ty};\n+use crate::traits::query::outlives_bounds::{self, OutlivesBound};\n+use crate::ty::{self, Ty};\n \n /// The `OutlivesEnvironment` collects information about what outlives\n /// what in a given type-checking setting. For example, if we have a\n@@ -55,15 +55,15 @@ pub struct OutlivesEnvironment<'tcx> {\n     // results when proving outlives obligations like `T: 'x` later\n     // (e.g., if `T: 'x` must be proven within the body B1, then we\n     // know it is true if either `'a: 'x` or `'b: 'x`).\n-    region_bound_pairs_map: FxHashMap<ast::NodeId, RegionBoundPairs<'tcx>>,\n+    region_bound_pairs_map: FxHashMap<hir::HirId, RegionBoundPairs<'tcx>>,\n \n     // Used to compute `region_bound_pairs_map`: contains the set of\n     // in-scope region-bound pairs thus far.\n     region_bound_pairs_accum: RegionBoundPairs<'tcx>,\n }\n \n /// \"Region-bound pairs\" tracks outlives relations that are known to\n-/// be true, either because of explicit where clauses like `T: 'a` or\n+/// be true, either because of explicit where-clauses like `T: 'a` or\n /// because of implied bounds.\n pub type RegionBoundPairs<'tcx> = Vec<(ty::Region<'tcx>, GenericKind<'tcx>)>;\n \n@@ -87,7 +87,7 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a> OutlivesEnvironment<'tcx> {\n     }\n \n     /// Borrows current value of the `region_bound_pairs`.\n-    pub fn region_bound_pairs_map(&self) -> &FxHashMap<ast::NodeId, RegionBoundPairs<'tcx>> {\n+    pub fn region_bound_pairs_map(&self) -> &FxHashMap<hir::HirId, RegionBoundPairs<'tcx>> {\n         &self.region_bound_pairs_map\n     }\n \n@@ -162,7 +162,7 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a> OutlivesEnvironment<'tcx> {\n         &mut self,\n         infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n         fn_sig_tys: &[Ty<'tcx>],\n-        body_id: ast::NodeId,\n+        body_id: hir::HirId,\n         span: Span,\n     ) {\n         debug!(\"add_implied_bounds()\");\n@@ -176,7 +176,7 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a> OutlivesEnvironment<'tcx> {\n     }\n \n     /// Save the current set of region-bound pairs under the given `body_id`.\n-    pub fn save_implied_bounds(&mut self, body_id: ast::NodeId) {\n+    pub fn save_implied_bounds(&mut self, body_id: hir::HirId) {\n         let old = self.region_bound_pairs_map.insert(\n             body_id,\n             self.region_bound_pairs_accum.clone(),"}, {"sha": "78353e52ad46264b4ec1ce575ab84a9336e6feb3", "filename": "src/librustc/infer/outlives/free_region_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,4 +1,4 @@\n-use ty::{self, Lift, TyCtxt, Region};\n+use crate::ty::{self, Lift, TyCtxt, Region};\n use rustc_data_structures::transitive_relation::TransitiveRelation;\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, Default)]\n@@ -24,7 +24,7 @@ impl<'tcx> FreeRegionMap<'tcx> {\n         }\n     }\n \n-    /// Compute the least-upper-bound of two free regions. In some\n+    /// Computes the least-upper-bound of two free regions. In some\n     /// cases, this is more conservative than necessary, in order to\n     /// avoid making arbitrary choices. See\n     /// `TransitiveRelation::postdom_upper_bound` for more details."}, {"sha": "bbda3d2fdbf84d9ac15ebb7d186ac0e7cd65fd52", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -55,18 +55,18 @@\n //! fn foo<U, F: for<'a> FnMut(&'a U)>(_f: F) {}\n //! ```\n //!\n-//! the type of the closure's first argument would be `&'a ?U`.  We\n+//! the type of the closure's first argument would be `&'a ?U`. We\n //! might later infer `?U` to something like `&'b u32`, which would\n //! imply that `'b: 'a`.\n \n-use infer::outlives::env::RegionBoundPairs;\n-use infer::outlives::verify::VerifyBoundCx;\n-use infer::{self, GenericKind, InferCtxt, RegionObligation, SubregionOrigin, VerifyBound};\n+use crate::infer::outlives::env::RegionBoundPairs;\n+use crate::infer::outlives::verify::VerifyBoundCx;\n+use crate::infer::{self, GenericKind, InferCtxt, RegionObligation, SubregionOrigin, VerifyBound};\n use rustc_data_structures::fx::FxHashMap;\n-use syntax::ast;\n-use traits::ObligationCause;\n-use ty::outlives::Component;\n-use ty::{self, Region, Ty, TyCtxt, TypeFoldable};\n+use crate::hir;\n+use crate::traits::ObligationCause;\n+use crate::ty::outlives::Component;\n+use crate::ty::{self, Region, Ty, TyCtxt, TypeFoldable};\n \n impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     /// Registers that the given region obligation must be resolved\n@@ -76,7 +76,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     /// information).\n     pub fn register_region_obligation(\n         &self,\n-        body_id: ast::NodeId,\n+        body_id: hir::HirId,\n         obligation: RegionObligation<'tcx>,\n     ) {\n         debug!(\n@@ -110,7 +110,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     }\n \n     /// Trait queries just want to pass back type obligations \"as is\"\n-    pub fn take_registered_region_obligations(&self) -> Vec<(ast::NodeId, RegionObligation<'tcx>)> {\n+    pub fn take_registered_region_obligations(&self) -> Vec<(hir::HirId, RegionObligation<'tcx>)> {\n         ::std::mem::replace(&mut *self.region_obligations.borrow_mut(), vec![])\n     }\n \n@@ -149,7 +149,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     /// processed.\n     pub fn process_registered_region_obligations(\n         &self,\n-        region_bound_pairs_map: &FxHashMap<ast::NodeId, RegionBoundPairs<'tcx>>,\n+        region_bound_pairs_map: &FxHashMap<hir::HirId, RegionBoundPairs<'tcx>>,\n         implicit_region_bound: Option<ty::Region<'tcx>>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) {"}, {"sha": "494f708c6a7b79b4a0c27c8b455b7cd8ee438ed8", "filename": "src/librustc/infer/outlives/verify.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,10 +1,10 @@\n-use hir::def_id::DefId;\n-use infer::outlives::env::RegionBoundPairs;\n-use infer::{GenericKind, VerifyBound};\n-use traits;\n-use ty::subst::{Subst, Substs};\n-use ty::{self, Ty, TyCtxt};\n-use util::captures::Captures;\n+use crate::hir::def_id::DefId;\n+use crate::infer::outlives::env::RegionBoundPairs;\n+use crate::infer::{GenericKind, VerifyBound};\n+use crate::traits;\n+use crate::ty::subst::{Subst, Substs};\n+use crate::ty::{self, Ty, TyCtxt};\n+use crate::util::captures::Captures;\n \n /// The `TypeOutlives` struct has the job of \"lowering\" a `T: 'a`\n /// obligation into a series of `'a: 'b` constraints and \"verifys\", as\n@@ -74,7 +74,7 @@ impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n     /// This is an \"approximate\" check -- it may not find all\n     /// applicable bounds, and not all the bounds it returns can be\n     /// relied upon. In particular, this check ignores region\n-    /// identity.  So, for example, if we have `<T as\n+    /// identity. So, for example, if we have `<T as\n     /// Trait<'0>>::Item` where `'0` is a region variable, and the\n     /// user has `<T as Trait<'a>>::Item: 'b` in the environment, then\n     /// the clause from the environment only applies if `'0 = 'a`,\n@@ -96,7 +96,7 @@ impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n         })\n     }\n \n-    /// Searches the where clauses in scope for regions that\n+    /// Searches the where-clauses in scope for regions that\n     /// `projection_ty` is known to outlive. Currently requires an\n     /// exact match.\n     pub fn projection_declared_bounds_from_trait(\n@@ -251,7 +251,7 @@ impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n             .map(move |r| r.subst(tcx, projection_ty.substs))\n     }\n \n-    /// Given the def-id of an associated item, returns any region\n+    /// Given the `DefId` of an associated item, returns any region\n     /// bounds attached to that associated item from the trait definition.\n     ///\n     /// For example:\n@@ -262,7 +262,7 @@ impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n     /// }\n     /// ```\n     ///\n-    /// If we were given the def-id of `Foo::Bar`, we would return\n+    /// If we were given the `DefId` of `Foo::Bar`, we would return\n     /// `'a`. You could then apply the substitutions from the\n     /// projection to convert this into your namespace. This also\n     /// works if the user writes `where <Self as Foo<'a>>::Bar: 'a` on"}, {"sha": "65d25333c7179050b14bba2a3adc357c4d06fb34", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 49, "deletions": 39, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,4 +1,4 @@\n-//! See README.md\n+//! See `README.md`.\n \n use self::CombineMapType::*;\n use self::UndoLog::*;\n@@ -9,10 +9,10 @@ use super::{MiscVariable, RegionVariableOrigin, SubregionOrigin};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::unify as ut;\n-use ty::ReStatic;\n-use ty::{self, Ty, TyCtxt};\n-use ty::{BrFresh, ReLateBound, ReVar};\n-use ty::{Region, RegionVid};\n+use crate::ty::ReStatic;\n+use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::{BrFresh, ReLateBound, ReVar};\n+use crate::ty::{Region, RegionVid};\n \n use std::collections::BTreeMap;\n use std::{cmp, fmt, mem, u32};\n@@ -108,16 +108,16 @@ pub struct RegionConstraintData<'tcx> {\n     pub givens: FxHashSet<(Region<'tcx>, ty::RegionVid)>,\n }\n \n-/// A constraint that influences the inference process.\n+/// Represents a constraint that influences the inference process.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, PartialOrd, Ord)]\n pub enum Constraint<'tcx> {\n-    /// One region variable is subregion of another\n+    /// A region variable is a subregion of another.\n     VarSubVar(RegionVid, RegionVid),\n \n-    /// Concrete region is subregion of region variable\n+    /// A concrete region is a subregion of region variable.\n     RegSubVar(Region<'tcx>, RegionVid),\n \n-    /// Region variable is subregion of concrete region. This does not\n+    /// A region variable is a subregion of a concrete region. This does not\n     /// directly affect inference, but instead is checked after\n     /// inference is complete.\n     VarSubReg(RegionVid, Region<'tcx>),\n@@ -138,9 +138,9 @@ impl Constraint<'_> {\n     }\n }\n \n-/// VerifyGenericBound(T, _, R, RS): The parameter type `T` (or\n+/// `VerifyGenericBound(T, _, R, RS)`: the parameter type `T` (or\n /// associated type) must outlive the region `R`. `T` is known to\n-/// outlive `RS`. Therefore verify that `R <= RS[i]` for some\n+/// outlive `RS`. Therefore, verify that `R <= RS[i]` for some\n /// `i`. Inference variables may be involved (but this verification\n /// step doesn't influence inference).\n #[derive(Debug, Clone)]\n@@ -164,7 +164,7 @@ EnumTypeFoldableImpl! {\n     }\n }\n \n-/// Describes the things that some `GenericKind` value G is known to\n+/// Describes the things that some `GenericKind` value `G` is known to\n /// outlive. Each variant of `VerifyBound` can be thought of as a\n /// function:\n ///\n@@ -187,13 +187,15 @@ pub enum VerifyBound<'tcx> {\n     /// following, where `G` is the generic for which this verify\n     /// bound was created:\n     ///\n-    ///     fn(min) -> bool {\n-    ///       if G == K {\n+    /// ```rust\n+    /// fn(min) -> bool {\n+    ///     if G == K {\n     ///         B(min)\n-    ///       } else {\n+    ///     } else {\n     ///         false\n-    ///       }\n     ///     }\n+    /// }\n+    /// ```\n     ///\n     /// In other words, if the generic `G` that we are checking is\n     /// equal to `K`, then check the associated verify bound\n@@ -202,45 +204,52 @@ pub enum VerifyBound<'tcx> {\n     /// This is used when we have something in the environment that\n     /// may or may not be relevant, depending on the region inference\n     /// results. For example, we may have `where <T as\n-    /// Trait<'a>>::Item: 'b` in our where clauses. If we are\n+    /// Trait<'a>>::Item: 'b` in our where-clauses. If we are\n     /// generating the verify-bound for `<T as Trait<'0>>::Item`, then\n     /// this where-clause is only relevant if `'0` winds up inferred\n     /// to `'a`.\n     ///\n     /// So we would compile to a verify-bound like\n     ///\n-    ///     IfEq(<T as Trait<'a>>::Item, AnyRegion('a))\n+    /// ```\n+    /// IfEq(<T as Trait<'a>>::Item, AnyRegion('a))\n+    /// ```\n     ///\n     /// meaning, if the subject G is equal to `<T as Trait<'a>>::Item`\n     /// (after inference), and `'a: min`, then `G: min`.\n     IfEq(Ty<'tcx>, Box<VerifyBound<'tcx>>),\n \n     /// Given a region `R`, expands to the function:\n     ///\n-    ///     fn(min) -> bool {\n-    ///       R: min\n-    ///     }\n+    /// ```\n+    /// fn(min) -> bool {\n+    ///     R: min\n+    /// }\n+    /// ```\n     ///\n     /// This is used when we can establish that `G: R` -- therefore,\n     /// if `R: min`, then by transitivity `G: min`.\n     OutlivedBy(Region<'tcx>),\n \n     /// Given a set of bounds `B`, expands to the function:\n     ///\n-    ///     fn(min) -> bool {\n-    ///       exists (b in B) { b(min) }\n-    ///     }\n+    /// ```rust\n+    /// fn(min) -> bool {\n+    ///     exists (b in B) { b(min) }\n+    /// }\n+    /// ```\n     ///\n     /// In other words, if we meet some bound in `B`, that suffices.\n-    /// This is used when all the bounds in `B` are known to apply to\n-    /// G.\n+    /// This is used when all the bounds in `B` are known to apply to `G`.\n     AnyBound(Vec<VerifyBound<'tcx>>),\n \n     /// Given a set of bounds `B`, expands to the function:\n     ///\n-    ///     fn(min) -> bool {\n-    ///       forall (b in B) { b(min) }\n-    ///     }\n+    /// ```rust\n+    /// fn(min) -> bool {\n+    ///     forall (b in B) { b(min) }\n+    /// }\n+    /// ```\n     ///\n     /// In other words, if we meet *all* bounds in `B`, that suffices.\n     /// This is used when *some* bound in `B` is known to suffice, but\n@@ -256,19 +265,19 @@ struct TwoRegions<'tcx> {\n \n #[derive(Copy, Clone, PartialEq)]\n enum UndoLog<'tcx> {\n-    /// We added `RegionVid`\n+    /// We added `RegionVid`.\n     AddVar(RegionVid),\n \n-    /// We added the given `constraint`\n+    /// We added the given `constraint`.\n     AddConstraint(Constraint<'tcx>),\n \n-    /// We added the given `verify`\n+    /// We added the given `verify`.\n     AddVerify(usize),\n \n-    /// We added the given `given`\n+    /// We added the given `given`.\n     AddGiven(Region<'tcx>, ty::RegionVid),\n \n-    /// We added a GLB/LUB \"combination variable\"\n+    /// We added a GLB/LUB \"combination variable\".\n     AddCombination(CombineMapType, TwoRegions<'tcx>),\n \n     /// During skolemization, we sometimes purge entries from the undo\n@@ -303,7 +312,7 @@ pub struct RegionSnapshot {\n /// When working with placeholder regions, we often wish to find all of\n /// the regions that are either reachable from a placeholder region, or\n /// which can reach a placeholder region, or both. We call such regions\n-/// *tainted* regions.  This struct allows you to decide what set of\n+/// *tainted* regions. This struct allows you to decide what set of\n /// tainted regions you want.\n #[derive(Debug)]\n pub struct TaintDirections {\n@@ -359,7 +368,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n \n     /// Takes (and clears) the current set of constraints. Note that\n     /// the set of variables remains intact, but all relationships\n-    /// between them are reset.  This is used during NLL checking to\n+    /// between them are reset. This is used during NLL checking to\n     /// grab the set of constraints that arose from a particular\n     /// operation.\n     ///\n@@ -707,7 +716,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         }\n     }\n \n-    /// See `Verify::VerifyGenericBound`\n+    /// See [`Verify::VerifyGenericBound`].\n     pub fn verify_generic_bound(\n         &mut self,\n         origin: SubregionOrigin<'tcx>,\n@@ -837,7 +846,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n             }).collect()\n     }\n \n-    /// See [`RegionInference::region_constraints_added_in_snapshot`]\n+    /// See [`RegionInference::region_constraints_added_in_snapshot`].\n     pub fn region_constraints_added_in_snapshot(&self, mark: &RegionSnapshot) -> Option<bool> {\n         self.undo_log[mark.length..]\n             .iter()\n@@ -925,7 +934,8 @@ impl<'a, 'gcx, 'tcx> VerifyBound<'tcx> {\n }\n \n impl<'tcx> RegionConstraintData<'tcx> {\n-    /// True if this region constraint data contains no constraints.\n+    /// Returns `true` if this region constraint data contains no constraints, and `false`\n+    /// otherwise.\n     pub fn is_empty(&self) -> bool {\n         let RegionConstraintData {\n             constraints,"}, {"sha": "4a8f0c34ead111381181dc6d756d89bc62c7c713", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,6 +1,6 @@\n use super::{InferCtxt, FixupError, FixupResult};\n-use ty::{self, Ty, TyCtxt, TypeFoldable};\n-use ty::fold::{TypeFolder, TypeVisitor};\n+use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use crate::ty::fold::{TypeFolder, TypeVisitor};\n \n ///////////////////////////////////////////////////////////////////////////\n // OPPORTUNISTIC TYPE RESOLVER"}, {"sha": "0cff42742c30a813e74f74abab7da0209306e7c3", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,11 +1,11 @@\n use super::SubregionOrigin;\n use super::combine::{CombineFields, RelationDir};\n \n-use traits::Obligation;\n-use ty::{self, Ty, TyCtxt};\n-use ty::TyVar;\n-use ty::fold::TypeFoldable;\n-use ty::relate::{Cause, Relate, RelateResult, TypeRelation};\n+use crate::traits::Obligation;\n+use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::TyVar;\n+use crate::ty::fold::TypeFoldable;\n+use crate::ty::relate::{Cause, Relate, RelateResult, TypeRelation};\n use std::mem;\n \n /// Ensures `a` is made a subtype of `b`. Returns `a` on success."}, {"sha": "09a0a6ce9c97c56709b6af6b935b67fc4d518120", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,6 +1,6 @@\n use syntax::symbol::InternedString;\n use syntax_pos::Span;\n-use ty::{self, Ty};\n+use crate::ty::{self, Ty};\n \n use std::cmp;\n use std::marker::PhantomData;\n@@ -218,7 +218,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         self.sub_relations.find(vid)\n     }\n \n-    /// True if `a` and `b` have same \"sub-root\" (i.e., exists some\n+    /// Returns `true` if `a` and `b` have same \"sub-root\" (i.e., exists some\n     /// type X such that `forall i in {a, b}. (i <: X || X <: i)`.\n     pub fn sub_unified(&mut self, a: ty::TyVid, b: ty::TyVid) -> bool {\n         self.sub_root_var(a) == self.sub_root_var(b)\n@@ -245,9 +245,9 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         }\n     }\n \n-    /// Creates a snapshot of the type variable state.  This snapshot\n+    /// Creates a snapshot of the type variable state. This snapshot\n     /// must later be committed (`commit()`) or rolled back\n-    /// (`rollback_to()`).  Nested snapshots are permitted, but must\n+    /// (`rollback_to()`). Nested snapshots are permitted, but must\n     /// be processed in a stack-like fashion.\n     pub fn snapshot(&mut self) -> Snapshot<'tcx> {\n         Snapshot {\n@@ -306,7 +306,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n             .collect()\n     }\n \n-    /// Find the set of type variables that existed *before* `s`\n+    /// Finds the set of type variables that existed *before* `s`\n     /// but which have only been unified since `s` started, and\n     /// return the types with which they were unified. So if we had\n     /// a type variable `V0`, then we started the snapshot, then we"}, {"sha": "09f800d9f9bfc97d8fce3c80dfacc95279a77928", "filename": "src/librustc/infer/unify_key.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Funify_key.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,4 +1,4 @@\n-use ty::{self, FloatVarValue, IntVarValue, Ty, TyCtxt};\n+use crate::ty::{self, FloatVarValue, IntVarValue, Ty, TyCtxt};\n use rustc_data_structures::unify::{NoError, EqUnifyValue, UnifyKey, UnifyValue};\n \n pub trait ToType {"}, {"sha": "3d79b6777fa8b3c0bdd70cfe427419992e5070b0", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 12, "deletions": 29, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -26,9 +26,10 @@\n //!\n //! This API is completely unstable and subject to change.\n \n-#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+\n+#![deny(rust_2018_idioms)]\n+#![allow(explicit_outlives_requirements)]\n \n #![feature(box_patterns)]\n #![feature(box_syntax)]\n@@ -46,7 +47,6 @@\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_attrs)]\n #![feature(slice_patterns)]\n-#![feature(slice_sort_by_cached_key)]\n #![feature(specialization)]\n #![feature(unboxed_closures)]\n #![feature(thread_local)]\n@@ -64,41 +64,24 @@\n \n #![warn(elided_lifetimes_in_paths)]\n \n-extern crate arena;\n #[macro_use] extern crate bitflags;\n-extern crate core;\n-extern crate fmt_macros;\n extern crate getopts;\n-extern crate graphviz;\n-extern crate num_cpus;\n #[macro_use] extern crate lazy_static;\n #[macro_use] extern crate scoped_tls;\n #[cfg(windows)]\n extern crate libc;\n-extern crate polonius_engine;\n-extern crate rustc_target;\n #[macro_use] extern crate rustc_data_structures;\n-extern crate serialize;\n-extern crate parking_lot;\n-extern crate rustc_errors as errors;\n-extern crate rustc_rayon as rayon;\n-extern crate rustc_rayon_core as rayon_core;\n+\n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n-extern crate syntax_pos;\n-extern crate jobserver;\n-extern crate proc_macro;\n-extern crate chalk_engine;\n-extern crate rustc_fs_util;\n \n-extern crate serialize as rustc_serialize; // used by deriving\n+// FIXME: This import is used by deriving `RustcDecodable` and `RustcEncodable`. Removing this\n+// results in a bunch of \"failed to resolve\" errors. Hopefully, the compiler moves to serde or\n+// something, and we can get rid of this.\n+#[allow(rust_2018_idioms)]\n+extern crate serialize as rustc_serialize;\n \n-extern crate rustc_apfloat;\n-extern crate byteorder;\n-extern crate backtrace;\n-\n-#[macro_use]\n-extern crate smallvec;\n+#[macro_use] extern crate smallvec;\n \n // Note that librustc doesn't actually depend on these crates, see the note in\n // `Cargo.toml` for this crate about why these are here.\n@@ -166,7 +149,7 @@ pub mod util {\n // `libstd` uses the same trick.\n #[doc(hidden)]\n mod rustc {\n-    pub use lint;\n+    pub use crate::lint;\n }\n \n // FIXME(#27438): right now the unit tests of librustc don't refer to any actual"}, {"sha": "655707ff9bd0da0f962192f28c0bd5d0eb690818", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -4,9 +4,9 @@\n //! compiler code, rather than using their own custom pass. Those\n //! lints are all available in `rustc_lint::builtin`.\n \n+use crate::lint::{LintPass, LateLintPass, LintArray};\n+use crate::session::Session;\n use errors::{Applicability, DiagnosticBuilder};\n-use lint::{LintPass, LateLintPass, LintArray};\n-use session::Session;\n use syntax::ast;\n use syntax::source_map::Span;\n \n@@ -352,6 +352,12 @@ declare_lint! {\n     \"outlives requirements can be inferred\"\n }\n \n+declare_lint! {\n+    pub DUPLICATE_MATCHER_BINDING_NAME,\n+    Warn,\n+    \"duplicate macro matcher binding name\"\n+}\n+\n /// Some lints that are buffered from `libsyntax`. See `syntax::early_buffered_lints`.\n pub mod parser {\n     declare_lint! {\n@@ -467,6 +473,7 @@ pub enum BuiltinLintDiagnostics {\n     MacroExpandedMacroExportsAccessedByAbsolutePaths(Span),\n     ElidedLifetimesInPaths(usize, Span, bool, Span, String),\n     UnknownCrateTypes(Span, String, String),\n+    UnusedImports(String, Vec<(Span, String)>),\n }\n \n impl BuiltinLintDiagnostics {\n@@ -548,6 +555,15 @@ impl BuiltinLintDiagnostics {\n             BuiltinLintDiagnostics::UnknownCrateTypes(span, note, sugg) => {\n                 db.span_suggestion(span, &note, sugg, Applicability::MaybeIncorrect);\n             }\n+            BuiltinLintDiagnostics::UnusedImports(message, replaces) => {\n+                if !replaces.is_empty() {\n+                    db.tool_only_multipart_suggestion(\n+                        &message,\n+                        replaces,\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n         }\n     }\n }"}, {"sha": "9032fcf8b612aebed0e7ff227e777d0d6d02e017", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -3,41 +3,41 @@\n //! The lint checking is mostly consolidated into one pass which runs\n //! after all other analyses. Throughout compilation, lint warnings\n //! can be added via the `add_lint` method on the Session structure. This\n-//! requires a span and an id of the node that the lint is being added to. The\n+//! requires a span and an ID of the node that the lint is being added to. The\n //! lint isn't actually emitted at that time because it is unknown what the\n //! actual lint level at that location is.\n //!\n //! To actually emit lint warnings/errors, a separate pass is used.\n //! A context keeps track of the current state of all lint levels.\n //! Upon entering a node of the ast which can modify the lint settings, the\n //! previous lint state is pushed onto a stack and the ast is then recursed\n-//! upon.  As the ast is traversed, this keeps track of the current lint level\n+//! upon. As the ast is traversed, this keeps track of the current lint level\n //! for all lint attributes.\n \n use self::TargetLint::*;\n \n use std::slice;\n use rustc_data_structures::sync::ReadGuard;\n-use lint::{EarlyLintPass, EarlyLintPassObject, LateLintPassObject};\n-use lint::{LintArray, Level, Lint, LintId, LintPass, LintBuffer};\n-use lint::builtin::BuiltinLintDiagnostics;\n-use lint::levels::{LintLevelSets, LintLevelsBuilder};\n-use middle::privacy::AccessLevels;\n-use rustc_serialize::{Decoder, Decodable, Encoder, Encodable};\n-use session::{config, early_error, Session};\n-use ty::{self, TyCtxt, Ty};\n-use ty::layout::{LayoutError, LayoutOf, TyLayout};\n-use util::nodemap::FxHashMap;\n-use util::common::time;\n+use crate::lint::{EarlyLintPass, EarlyLintPassObject, LateLintPassObject};\n+use crate::lint::{LintArray, Level, Lint, LintId, LintPass, LintBuffer};\n+use crate::lint::builtin::BuiltinLintDiagnostics;\n+use crate::lint::levels::{LintLevelSets, LintLevelsBuilder};\n+use crate::middle::privacy::AccessLevels;\n+use crate::rustc_serialize::{Decoder, Decodable, Encoder, Encodable};\n+use crate::session::{config, early_error, Session};\n+use crate::ty::{self, TyCtxt, Ty};\n+use crate::ty::layout::{LayoutError, LayoutOf, TyLayout};\n+use crate::util::nodemap::FxHashMap;\n+use crate::util::common::time;\n \n use std::default::Default as StdDefault;\n use syntax::ast;\n use syntax::edition;\n use syntax_pos::{MultiSpan, Span, symbol::{LocalInternedString, Symbol}};\n use errors::DiagnosticBuilder;\n-use hir;\n-use hir::def_id::LOCAL_CRATE;\n-use hir::intravisit as hir_visit;\n+use crate::hir;\n+use crate::hir::def_id::LOCAL_CRATE;\n+use crate::hir::intravisit as hir_visit;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::visit as ast_visit;\n \n@@ -703,7 +703,7 @@ impl<'a, T: EarlyLintPass> EarlyContextAndPass<'a, T> {\n impl<'a, 'tcx> LintContext<'tcx> for LateContext<'a, 'tcx> {\n     type PassObject = LateLintPassObject;\n \n-    /// Get the overall compiler `Session` object.\n+    /// Gets the overall compiler `Session` object.\n     fn sess(&self) -> &Session {\n         &self.tcx.sess\n     }\n@@ -736,7 +736,7 @@ impl<'a, 'tcx> LintContext<'tcx> for LateContext<'a, 'tcx> {\n impl<'a> LintContext<'a> for EarlyContext<'a> {\n     type PassObject = EarlyLintPassObject;\n \n-    /// Get the overall compiler `Session` object.\n+    /// Gets the overall compiler `Session` object.\n     fn sess(&self) -> &Session {\n         &self.sess\n     }\n@@ -1200,7 +1200,7 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n }\n \n \n-/// Perform lint checking on a crate.\n+/// Performs lint checking on a crate.\n ///\n /// Consumes the `lint_store` field of the `Session`.\n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {"}, {"sha": "924aa3fde0a08fd7e5ea406b771c215912fa978a", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,20 +1,20 @@\n use std::cmp;\n \n+use crate::hir::HirId;\n+use crate::ich::StableHashingContext;\n+use crate::lint::builtin;\n+use crate::lint::context::CheckLintNameResult;\n+use crate::lint::{self, Lint, LintId, Level, LintSource};\n+use crate::session::Session;\n+use crate::util::nodemap::FxHashMap;\n use errors::{Applicability, DiagnosticBuilder};\n-use hir::HirId;\n-use ich::StableHashingContext;\n-use lint::builtin;\n-use lint::context::CheckLintNameResult;\n-use lint::{self, Lint, LintId, Level, LintSource};\n use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey,\n                                            StableHasher, StableHasherResult};\n-use session::Session;\n use syntax::ast;\n use syntax::attr;\n use syntax::feature_gate;\n use syntax::source_map::MultiSpan;\n use syntax::symbol::Symbol;\n-use util::nodemap::FxHashMap;\n \n pub struct LintLevelSets {\n     list: Vec<LintSet>,"}, {"sha": "859ceb4bd074d5e02345c79c5a135ebf82fc54cf", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -23,25 +23,25 @@ pub use self::LintSource::*;\n \n use rustc_data_structures::sync::{self, Lrc};\n \n+use crate::hir::def_id::{CrateNum, LOCAL_CRATE};\n+use crate::hir::intravisit;\n+use crate::hir;\n+use crate::lint::builtin::{BuiltinLintDiagnostics, DUPLICATE_MATCHER_BINDING_NAME};\n+use crate::lint::builtin::parser::{QUESTION_MARK_MACRO_SEP, ILL_FORMED_ATTRIBUTE_INPUT};\n+use crate::session::{Session, DiagnosticMessageId};\n+use crate::ty::TyCtxt;\n+use crate::ty::query::Providers;\n+use crate::util::nodemap::NodeMap;\n use errors::{DiagnosticBuilder, DiagnosticId};\n-use hir::def_id::{CrateNum, LOCAL_CRATE};\n-use hir::intravisit;\n-use hir;\n-use lint::builtin::BuiltinLintDiagnostics;\n-use lint::builtin::parser::{QUESTION_MARK_MACRO_SEP, ILL_FORMED_ATTRIBUTE_INPUT};\n-use session::{Session, DiagnosticMessageId};\n use std::{hash, ptr};\n use syntax::ast;\n use syntax::source_map::{MultiSpan, ExpnFormat};\n use syntax::early_buffered_lints::BufferedEarlyLintId;\n use syntax::edition::Edition;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n-use ty::TyCtxt;\n-use ty::query::Providers;\n-use util::nodemap::NodeMap;\n \n-pub use lint::context::{LateContext, EarlyContext, LintContext, LintStore,\n+pub use crate::lint::context::{LateContext, EarlyContext, LintContext, LintStore,\n                         check_crate, check_ast_crate, CheckLintNameResult,\n                         FutureIncompatibleInfo, BufferedEarlyLint};\n \n@@ -72,7 +72,7 @@ pub struct Lint {\n     /// `default_level`.\n     pub edition_lint_opts: Option<(Edition, Level)>,\n \n-    /// Whether this lint is reported even inside expansions of external macros\n+    /// `true` if this lint is reported even inside expansions of external macros.\n     pub report_in_external_macro: bool,\n }\n \n@@ -82,10 +82,11 @@ impl Lint {\n         match lint_id {\n             BufferedEarlyLintId::QuestionMarkMacroSep => QUESTION_MARK_MACRO_SEP,\n             BufferedEarlyLintId::IllFormedAttributeInput => ILL_FORMED_ATTRIBUTE_INPUT,\n+            BufferedEarlyLintId::DuplicateMacroMatcherBindingName => DUPLICATE_MATCHER_BINDING_NAME,\n         }\n     }\n \n-    /// Get the lint's name, with ASCII letters converted to lowercase.\n+    /// Gets the lint's name, with ASCII letters converted to lowercase.\n     pub fn name_lower(&self) -> String {\n         self.name.to_ascii_lowercase()\n     }\n@@ -98,7 +99,7 @@ impl Lint {\n     }\n }\n \n-/// Declare a static item of type `&'static Lint`.\n+/// Declares a static item of type `&'static Lint`.\n #[macro_export]\n macro_rules! declare_lint {\n     ($vis: vis $NAME: ident, $Level: ident, $desc: expr) => (\n@@ -149,7 +150,7 @@ macro_rules! declare_tool_lint {\n     );\n }\n \n-/// Declare a static `LintArray` and return it as an expression.\n+/// Declares a static `LintArray` and return it as an expression.\n #[macro_export]\n macro_rules! lint_array {\n     ($( $lint:expr ),* ,) => { lint_array!( $($lint),* ) };\n@@ -163,7 +164,7 @@ pub type LintArray = Vec<&'static Lint>;\n pub trait LintPass {\n     fn name(&self) -> &'static str;\n \n-    /// Get descriptions of the lints this `LintPass` object can emit.\n+    /// Gets descriptions of the lints this `LintPass` object can emit.\n     ///\n     /// N.B., there is no enforcement that the object only emits lints it registered.\n     /// And some `rustc` internal `LintPass`es register lints to be emitted by other\n@@ -486,7 +487,7 @@ impl hash::Hash for LintId {\n }\n \n impl LintId {\n-    /// Get the `LintId` for a `Lint`.\n+    /// Gets the `LintId` for a `Lint`.\n     pub fn of(lint: &'static Lint) -> LintId {\n         LintId {\n             lint,\n@@ -497,7 +498,7 @@ impl LintId {\n         self.lint.name\n     }\n \n-    /// Get the name of the lint.\n+    /// Gets the name of the lint.\n     pub fn to_string(&self) -> String {\n         self.lint.name_lower()\n     }\n@@ -517,7 +518,7 @@ impl_stable_hash_for!(enum self::Level {\n });\n \n impl Level {\n-    /// Convert a level to a lower-case string.\n+    /// Converts a level to a lower-case string.\n     pub fn as_str(self) -> &'static str {\n         match self {\n             Allow => \"allow\",\n@@ -527,7 +528,7 @@ impl Level {\n         }\n     }\n \n-    /// Convert a lower-case string to a level.\n+    /// Converts a lower-case string to a level.\n     pub fn from_str(x: &str) -> Option<Level> {\n         match x {\n             \"allow\" => Some(Allow),\n@@ -678,7 +679,7 @@ pub fn struct_lint_level<'a>(sess: &'a Session,\n             \"this was previously accepted by the compiler but is being phased out; \\\n              it will become a hard error\";\n \n-        let explanation = if lint_id == LintId::of(::lint::builtin::UNSTABLE_NAME_COLLISIONS) {\n+        let explanation = if lint_id == LintId::of(crate::lint::builtin::UNSTABLE_NAME_COLLISIONS) {\n             \"once this method is added to the standard library, \\\n              the ambiguity may cause an error or change in behavior!\"\n                 .to_owned()"}, {"sha": "ccae9d3ad5a82792a3d9e4a9e8de75014d6bfa1e", "filename": "src/librustc/macros.rs", "status": "modified", "additions": 26, "deletions": 30, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -62,38 +62,36 @@ macro_rules! __impl_stable_hash_field {\n #[macro_export]\n macro_rules! impl_stable_hash_for {\n     // Enums\n-    // FIXME(mark-i-m): Some of these should be `?` rather than `*`. See the git blame and change\n-    // them back when `?` is supported again.\n     (enum $enum_name:path {\n         $( $variant:ident\n            // this incorrectly allows specifying both tuple-like and struct-like fields, as in `Variant(a,b){c,d}`,\n            // when it should be only one or the other\n-           $( ( $($field:ident $(-> $delegate:tt)*),* ) )*\n-           $( { $($named_field:ident $(-> $named_delegate:tt)*),* } )*\n-        ),* $(,)*\n+           $( ( $($field:ident $(-> $delegate:tt)?),* ) )?\n+           $( { $($named_field:ident $(-> $named_delegate:tt)?),* } )?\n+        ),* $(,)?\n     }) => {\n         impl_stable_hash_for!(\n             impl<> for enum $enum_name [ $enum_name ] { $( $variant\n-                $( ( $($field $(-> $delegate)*),* ) )*\n-                $( { $($named_field $(-> $named_delegate)*),* } )*\n+                $( ( $($field $(-> $delegate)?),* ) )?\n+                $( { $($named_field $(-> $named_delegate)?),* } )?\n             ),* }\n         );\n     };\n     // We want to use the enum name both in the `impl ... for $enum_name` as well as for\n     // importing all the variants. Unfortunately it seems we have to take the name\n     // twice for this purpose\n-    (impl<$($lt:lifetime $(: $lt_bound:lifetime)* ),* $(,)* $($T:ident),* $(,)*>\n+    (impl<$($lt:lifetime $(: $lt_bound:lifetime)? ),* $(,)? $($T:ident),* $(,)?>\n         for enum $enum_name:path\n         [ $enum_path:path ]\n     {\n         $( $variant:ident\n            // this incorrectly allows specifying both tuple-like and struct-like fields, as in `Variant(a,b){c,d}`,\n            // when it should be only one or the other\n-           $( ( $($field:ident $(-> $delegate:tt)*),* ) )*\n-           $( { $($named_field:ident $(-> $named_delegate:tt)*),* } )*\n-        ),* $(,)*\n+           $( ( $($field:ident $(-> $delegate:tt)?),* ) )?\n+           $( { $($named_field:ident $(-> $named_delegate:tt)?),* } )?\n+        ),* $(,)?\n     }) => {\n-        impl<'a, $($lt $(: $lt_bound)*,)* $($T,)*>\n+        impl<'a, $($lt $(: $lt_bound)?,)* $($T,)*>\n             ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>>\n             for $enum_name\n             where $($T: ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>>),*\n@@ -107,26 +105,25 @@ macro_rules! impl_stable_hash_for {\n \n                 match *self {\n                     $(\n-                        $variant $( ( $(ref $field),* ) )* $( { $(ref $named_field),* } )* => {\n-                            $($( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)*) );*)*\n-                            $($( __impl_stable_hash_field!($named_field, __ctx, __hasher $(, $named_delegate)*) );*)*\n+                        $variant $( ( $(ref $field),* ) )? $( { $(ref $named_field),* } )? => {\n+                            $($( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)?) );*)?\n+                            $($( __impl_stable_hash_field!($named_field, __ctx, __hasher $(, $named_delegate)?) );*)?\n                         }\n                     )*\n                 }\n             }\n         }\n     };\n     // Structs\n-    // FIXME(mark-i-m): same here.\n-    (struct $struct_name:path { $($field:ident $(-> $delegate:tt)*),*  $(,)* }) => {\n+    (struct $struct_name:path { $($field:ident $(-> $delegate:tt)?),* $(,)? }) => {\n         impl_stable_hash_for!(\n-            impl<'tcx> for struct $struct_name { $($field $(-> $delegate)*),* }\n+            impl<'tcx> for struct $struct_name { $($field $(-> $delegate)?),* }\n         );\n     };\n-    (impl<$($lt:lifetime $(: $lt_bound:lifetime)* ),* $(,)* $($T:ident),* $(,)*> for struct $struct_name:path {\n-        $($field:ident $(-> $delegate:tt)*),* $(,)*\n+    (impl<$($lt:lifetime $(: $lt_bound:lifetime)? ),* $(,)? $($T:ident),* $(,)?> for struct $struct_name:path {\n+        $($field:ident $(-> $delegate:tt)?),* $(,)?\n     }) => {\n-        impl<'a, $($lt $(: $lt_bound)*,)* $($T,)*>\n+        impl<'a, $($lt $(: $lt_bound)?,)* $($T,)*>\n             ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>> for $struct_name\n             where $($T: ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>>),*\n         {\n@@ -138,21 +135,20 @@ macro_rules! impl_stable_hash_for {\n                     $(ref $field),*\n                 } = *self;\n \n-                $( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)*) );*\n+                $( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)?) );*\n             }\n         }\n     };\n     // Tuple structs\n-    // We cannot use normale parentheses here, the parser won't allow it\n-    // FIXME(mark-i-m): same here.\n-    (tuple_struct $struct_name:path { $($field:ident $(-> $delegate:tt)*),*  $(,)* }) => {\n+    // We cannot use normal parentheses here, the parser won't allow it\n+    (tuple_struct $struct_name:path { $($field:ident $(-> $delegate:tt)?),*  $(,)? }) => {\n         impl_stable_hash_for!(\n-            impl<'tcx> for tuple_struct $struct_name { $($field $(-> $delegate)*),* }\n+            impl<'tcx> for tuple_struct $struct_name { $($field $(-> $delegate)?),* }\n         );\n     };\n-    (impl<$($lt:lifetime $(: $lt_bound:lifetime)* ),* $(,)* $($T:ident),* $(,)*>\n-     for tuple_struct $struct_name:path { $($field:ident $(-> $delegate:tt)*),*  $(,)* }) => {\n-        impl<'a, $($lt $(: $lt_bound)*,)* $($T,)*>\n+    (impl<$($lt:lifetime $(: $lt_bound:lifetime)? ),* $(,)? $($T:ident),* $(,)?>\n+     for tuple_struct $struct_name:path { $($field:ident $(-> $delegate:tt)?),*  $(,)? }) => {\n+        impl<'a, $($lt $(: $lt_bound)?,)* $($T,)*>\n             ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>> for $struct_name\n             where $($T: ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>>),*\n         {\n@@ -164,7 +160,7 @@ macro_rules! impl_stable_hash_for {\n                     $(ref $field),*\n                 ) = *self;\n \n-                $( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)*) );*\n+                $( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)?) );*\n             }\n         }\n     };"}, {"sha": "2799f9424d9190e6d11ba028bdd96070ae786b1e", "filename": "src/librustc/middle/borrowck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,6 +1,6 @@\n-use ich::StableHashingContext;\n-use hir::HirId;\n-use util::nodemap::FxHashSet;\n+use crate::ich::StableHashingContext;\n+use crate::hir::HirId;\n+use crate::util::nodemap::FxHashSet;\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};"}, {"sha": "6e9552a1e920916038a4c0f652eae7a70887f746", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -2,13 +2,13 @@\n //! are *mostly* used as a part of that interface, but these should\n //! probably get a better home if someone can find one.\n \n-use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n-use hir::map as hir_map;\n-use hir::map::definitions::{DefKey, DefPathTable};\n+use crate::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use crate::hir::map as hir_map;\n+use crate::hir::map::definitions::{DefKey, DefPathTable};\n use rustc_data_structures::svh::Svh;\n-use ty::{self, TyCtxt};\n-use session::{Session, CrateDisambiguator};\n-use session::search_paths::PathKind;\n+use crate::ty::{self, TyCtxt};\n+use crate::session::{Session, CrateDisambiguator};\n+use crate::session::search_paths::PathKind;\n \n use std::any::Any;\n use std::path::{Path, PathBuf};"}, {"sha": "569968bd6d4bf53db834b77ef3af97044d6cfb59", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -2,18 +2,18 @@\n // closely. The idea is that all reachable symbols are live, codes called\n // from live codes are live, and everything else is dead.\n \n-use hir::Node;\n-use hir::{self, PatKind};\n-use hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use hir::itemlikevisit::ItemLikeVisitor;\n-\n-use hir::def::Def;\n-use hir::CodegenFnAttrFlags;\n-use hir::def_id::{DefId, LOCAL_CRATE};\n-use lint;\n-use middle::privacy;\n-use ty::{self, TyCtxt};\n-use util::nodemap::FxHashSet;\n+use crate::hir::Node;\n+use crate::hir::{self, PatKind};\n+use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use crate::hir::itemlikevisit::ItemLikeVisitor;\n+\n+use crate::hir::def::Def;\n+use crate::hir::CodegenFnAttrFlags;\n+use crate::hir::def_id::{DefId, LOCAL_CRATE};\n+use crate::lint;\n+use crate::middle::privacy;\n+use crate::ty::{self, TyCtxt};\n+use crate::util::nodemap::FxHashSet;\n \n use rustc_data_structures::fx::FxHashMap;\n \n@@ -112,7 +112,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n     fn handle_field_pattern_match(&mut self, lhs: &hir::Pat, def: Def,\n                                   pats: &[source_map::Spanned<hir::FieldPat>]) {\n-        let variant = match self.tables.node_id_to_type(lhs.hir_id).sty {\n+        let variant = match self.tables.node_type(lhs.hir_id).sty {\n             ty::Adt(adt, _) => adt.variant_of_def(def),\n             _ => span_bug!(lhs.span, \"non-ADT in struct pattern\")\n         };"}, {"sha": "a24d25cba118453d49758cd0376e26d1f59841c0", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -51,13 +51,13 @@\n //! Additionally, the algorithm is geared towards finding *any* solution rather\n //! than finding a number of solutions (there are normally quite a few).\n \n-use hir::def_id::CrateNum;\n+use crate::hir::def_id::CrateNum;\n \n-use session::config;\n-use ty::TyCtxt;\n-use middle::cstore::{self, DepKind};\n-use middle::cstore::LinkagePreference::{self, RequireStatic, RequireDynamic};\n-use util::nodemap::FxHashMap;\n+use crate::session::config;\n+use crate::ty::TyCtxt;\n+use crate::middle::cstore::{self, DepKind};\n+use crate::middle::cstore::LinkagePreference::{self, RequireStatic, RequireDynamic};\n+use crate::util::nodemap::FxHashMap;\n use rustc_target::spec::PanicStrategy;\n \n /// A list of dependencies for a certain crate type."}, {"sha": "2d0e6c3917bb84822fa6c060941dd968dfd85c31", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,15 +1,15 @@\n-use hir::map as hir_map;\n-use hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, LOCAL_CRATE};\n-use session::{config, Session};\n-use session::config::EntryFnType;\n+use crate::hir::map as hir_map;\n+use crate::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, LOCAL_CRATE};\n+use crate::session::{config, Session};\n+use crate::session::config::EntryFnType;\n use syntax::ast::NodeId;\n use syntax::attr;\n use syntax::entry::EntryPointType;\n use syntax_pos::Span;\n-use hir::{Item, ItemKind, ImplItem, TraitItem};\n-use hir::itemlikevisit::ItemLikeVisitor;\n-use ty::TyCtxt;\n-use ty::query::Providers;\n+use crate::hir::{Item, ItemKind, ImplItem, TraitItem};\n+use crate::hir::itemlikevisit::ItemLikeVisitor;\n+use crate::ty::TyCtxt;\n+use crate::ty::query::Providers;\n \n struct EntryContext<'a, 'tcx: 'a> {\n     session: &'a Session,"}, {"sha": "6c43068a227728428957817b188e2900b9c6f02c", "filename": "src/librustc/middle/exported_symbols.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,11 +1,11 @@\n-use hir::def_id::{DefId, LOCAL_CRATE};\n-use ich::StableHashingContext;\n+use crate::hir::def_id::{DefId, LOCAL_CRATE};\n+use crate::ich::StableHashingContext;\n use rustc_data_structures::stable_hasher::{StableHasher, HashStable,\n                                            StableHasherResult};\n use std::cmp;\n use std::mem;\n-use ty;\n-use ty::subst::Substs;\n+use crate::ty;\n+use crate::ty::subst::Substs;\n \n /// The SymbolExportLevel of a symbols specifies from which kinds of crates\n /// the symbol will be exported. `C` symbols will be exported from any"}, {"sha": "8da20ba426663f926d49610bd4d28ef29f4ba216", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,4 +1,4 @@\n-//! A different sort of visitor for walking fn bodies.  Unlike the\n+//! A different sort of visitor for walking fn bodies. Unlike the\n //! normal visitor, which just walks the entire body in one shot, the\n //! `ExprUseVisitor` determines how expressions are being used.\n \n@@ -9,20 +9,20 @@ pub use self::MatchMode::*;\n use self::TrackMatchMode::*;\n use self::OverloadedCallType::*;\n \n-use hir::def::Def;\n-use hir::def_id::DefId;\n-use infer::InferCtxt;\n-use middle::mem_categorization as mc;\n-use middle::region;\n-use ty::{self, TyCtxt, adjustment};\n+use crate::hir::def::Def;\n+use crate::hir::def_id::DefId;\n+use crate::infer::InferCtxt;\n+use crate::middle::mem_categorization as mc;\n+use crate::middle::region;\n+use crate::ty::{self, TyCtxt, adjustment};\n \n-use hir::{self, PatKind};\n+use crate::hir::{self, PatKind};\n use rustc_data_structures::sync::Lrc;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::ptr::P;\n use syntax_pos::Span;\n-use util::nodemap::ItemLocalSet;\n+use crate::util::nodemap::ItemLocalSet;\n \n ///////////////////////////////////////////////////////////////////////////\n // The Delegate trait\n@@ -800,8 +800,8 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         self.consume_expr(&arm.body);\n     }\n \n-    /// Walks a pat that occurs in isolation (i.e., top-level of fn\n-    /// arg or let binding.  *Not* a match arm or nested pat.)\n+    /// Walks a pat that occurs in isolation (i.e., top-level of fn argument or\n+    /// let binding, and *not* a match arm or nested pat.)\n     fn walk_irrefutable_pat(&mut self, cmt_discr: mc::cmt<'tcx>, pat: &hir::Pat) {\n         let mut mode = Unknown;\n         self.determine_pat_move_mode(cmt_discr.clone(), pat, &mut mode);"}, {"sha": "fc345df6551507bcea35dcd2c42e15529b8c8bdd", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,32 +1,30 @@\n-//! This file handles the relationships between free regions --\n-//! meaning lifetime parameters. Ordinarily, free regions are\n-//! unrelated to one another, but they can be related via implied or\n-//! explicit bounds.  In that case, we track the bounds using the\n-//! `TransitiveRelation` type and use that to decide when one free\n-//! region outlives another and so forth.\n+//! This module handles the relationships between \"free regions\", i.e., lifetime parameters.\n+//! Ordinarily, free regions are unrelated to one another, but they can be related via implied\n+//! or explicit bounds. In that case, we track the bounds using the `TransitiveRelation` type,\n+//! and use that to decide when one free region outlives another, and so forth.\n \n-use infer::outlives::free_region_map::{FreeRegionMap, FreeRegionRelations};\n-use hir::def_id::DefId;\n-use middle::region;\n-use ty::{self, TyCtxt, Region};\n+use crate::infer::outlives::free_region_map::{FreeRegionMap, FreeRegionRelations};\n+use crate::hir::def_id::DefId;\n+use crate::middle::region;\n+use crate::ty::{self, TyCtxt, Region};\n \n /// Combines a `region::ScopeTree` (which governs relationships between\n /// scopes) and a `FreeRegionMap` (which governs relationships between\n /// free regions) to yield a complete relation between concrete\n /// regions.\n ///\n /// This stuff is a bit convoluted and should be refactored, but as we\n-/// move to NLL it'll all go away anyhow.\n+/// transition to NLL, it'll all go away anyhow.\n pub struct RegionRelations<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n \n-    /// context used to fetch the region maps\n+    /// The context used to fetch the region maps.\n     pub context: DefId,\n \n-    /// region maps for the given context\n+    /// The region maps for the given context.\n     pub region_scope_tree: &'a region::ScopeTree,\n \n-    /// free-region relationships\n+    /// Free-region relationships.\n     pub free_regions: &'a FreeRegionMap<'tcx>,\n }\n \n@@ -45,7 +43,7 @@ impl<'a, 'gcx, 'tcx> RegionRelations<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Determines whether one region is a subregion of another.  This is intended to run *after\n+    /// Determines whether one region is a subregion of another. This is intended to run *after\n     /// inference* and sadly the logic is somewhat duplicated with the code in infer.rs.\n     pub fn is_subregion_of(&self,\n                            sub_region: ty::Region<'tcx>,\n@@ -86,7 +84,7 @@ impl<'a, 'gcx, 'tcx> RegionRelations<'a, 'gcx, 'tcx> {\n         result\n     }\n \n-    /// Determines whether this free-region is required to be 'static\n+    /// Determines whether this free region is required to be `'static`.\n     fn is_static(&self, super_region: ty::Region<'tcx>) -> bool {\n         debug!(\"is_static(super_region={:?})\", super_region);\n         match *super_region {"}, {"sha": "ce20ca39533b13737d81f72b41d9413be89253b6", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,14 +1,14 @@\n-use hir::def::Def;\n-use hir::def_id::DefId;\n-use ty::{self, Ty, TyCtxt};\n-use ty::layout::{LayoutError, Pointer, SizeSkeleton, VariantIdx};\n-use ty::query::Providers;\n+use crate::hir::def::Def;\n+use crate::hir::def_id::DefId;\n+use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::layout::{LayoutError, Pointer, SizeSkeleton, VariantIdx};\n+use crate::ty::query::Providers;\n \n use rustc_target::spec::abi::Abi::RustIntrinsic;\n use rustc_data_structures::indexed_vec::Idx;\n use syntax_pos::Span;\n-use hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use hir;\n+use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use crate::hir;\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     for &module in tcx.hir().krate().modules.keys() {\n@@ -165,7 +165,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ExprVisitor<'a, 'tcx> {\n         };\n         if let Def::Fn(did) = def {\n             if self.def_id_is_transmute(did) {\n-                let typ = self.tables.node_id_to_type(expr.hir_id);\n+                let typ = self.tables.node_type(expr.hir_id);\n                 let sig = typ.fn_sig(self.tcx);\n                 let from = sig.inputs().skip_binder()[0];\n                 let to = *sig.output().skip_binder();"}, {"sha": "3f9230ab551d55b82ae9a5002cd6cc1bd8ae117a", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -11,17 +11,17 @@\n \n pub use self::LangItem::*;\n \n-use hir::def_id::DefId;\n-use hir::check_attr::Target;\n-use ty::{self, TyCtxt};\n-use middle::weak_lang_items;\n-use util::nodemap::FxHashMap;\n+use crate::hir::def_id::DefId;\n+use crate::hir::check_attr::Target;\n+use crate::ty::{self, TyCtxt};\n+use crate::middle::weak_lang_items;\n+use crate::util::nodemap::FxHashMap;\n \n use syntax::ast;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n-use hir::itemlikevisit::ItemLikeVisitor;\n-use hir;\n+use crate::hir::itemlikevisit::ItemLikeVisitor;\n+use crate::hir;\n \n // The actual lang items defined come at the end of this file in one handy table.\n // So you probably just want to nip down to the end."}, {"sha": "331343e052dea322231458c5e592f35b63fe9a6f", "filename": "src/librustc/middle/lib_features.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flib_features.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -4,11 +4,11 @@\n // and `#[unstable (..)]`), but are not declared in one single location\n // (unlike lang features), which means we need to collect them instead.\n \n-use ty::TyCtxt;\n+use crate::ty::TyCtxt;\n+use crate::hir::intravisit::{self, NestedVisitorMap, Visitor};\n use syntax::symbol::Symbol;\n use syntax::ast::{Attribute, MetaItem, MetaItemKind};\n use syntax_pos::Span;\n-use hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use errors::DiagnosticId;\n "}, {"sha": "d3925f40e09e714cce9d2660828e4a619fc956a3", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 40, "deletions": 41, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,27 +1,27 @@\n-//! A classic liveness analysis based on dataflow over the AST.  Computes,\n+//! A classic liveness analysis based on dataflow over the AST. Computes,\n //! for each local variable in a function, whether that variable is live\n-//! at a given point.  Program execution points are identified by their\n-//! id.\n+//! at a given point. Program execution points are identified by their\n+//! IDs.\n //!\n //! # Basic idea\n //!\n-//! The basic model is that each local variable is assigned an index.  We\n+//! The basic model is that each local variable is assigned an index. We\n //! represent sets of local variables using a vector indexed by this\n-//! index.  The value in the vector is either 0, indicating the variable\n-//! is dead, or the id of an expression that uses the variable.\n+//! index. The value in the vector is either 0, indicating the variable\n+//! is dead, or the ID of an expression that uses the variable.\n //!\n-//! We conceptually walk over the AST in reverse execution order.  If we\n-//! find a use of a variable, we add it to the set of live variables.  If\n+//! We conceptually walk over the AST in reverse execution order. If we\n+//! find a use of a variable, we add it to the set of live variables. If\n //! we find an assignment to a variable, we remove it from the set of live\n-//! variables.  When we have to merge two flows, we take the union of\n-//! those two flows---if the variable is live on both paths, we simply\n-//! pick one id.  In the event of loops, we continue doing this until a\n+//! variables. When we have to merge two flows, we take the union of\n+//! those two flows -- if the variable is live on both paths, we simply\n+//! pick one ID. In the event of loops, we continue doing this until a\n //! fixed point is reached.\n //!\n //! ## Checking initialization\n //!\n-//! At the function entry point, all variables must be dead.  If this is\n-//! not the case, we can report an error using the id found in the set of\n+//! At the function entry point, all variables must be dead. If this is\n+//! not the case, we can report an error using the ID found in the set of\n //! live variables, which identifies a use of the variable which is not\n //! dominated by an assignment.\n //!\n@@ -38,20 +38,20 @@\n //!\n //! The actual implementation contains two (nested) walks over the AST.\n //! The outer walk has the job of building up the ir_maps instance for the\n-//! enclosing function.  On the way down the tree, it identifies those AST\n+//! enclosing function. On the way down the tree, it identifies those AST\n //! nodes and variable IDs that will be needed for the liveness analysis\n-//! and assigns them contiguous IDs.  The liveness id for an AST node is\n-//! called a `live_node` (it's a newtype'd u32) and the id for a variable\n-//! is called a `variable` (another newtype'd u32).\n+//! and assigns them contiguous IDs. The liveness ID for an AST node is\n+//! called a `live_node` (it's a newtype'd `u32`) and the ID for a variable\n+//! is called a `variable` (another newtype'd `u32`).\n //!\n //! On the way back up the tree, as we are about to exit from a function\n-//! declaration we allocate a `liveness` instance.  Now that we know\n+//! declaration we allocate a `liveness` instance. Now that we know\n //! precisely how many nodes and variables we need, we can allocate all\n-//! the various arrays that we will need to precisely the right size.  We then\n+//! the various arrays that we will need to precisely the right size. We then\n //! perform the actual propagation on the `liveness` instance.\n //!\n //! This propagation is encoded in the various `propagate_through_*()`\n-//! methods.  It effectively does a reverse walk of the AST; whenever we\n+//! methods. It effectively does a reverse walk of the AST; whenever we\n //! reach a loop node, we iterate until a fixed point is reached.\n //!\n //! ## The `RWU` struct\n@@ -60,21 +60,21 @@\n //! variable `V` (these are encapsulated in the `RWU` struct):\n //!\n //! - `reader`: the `LiveNode` ID of some node which will read the value\n-//!    that `V` holds on entry to `N`.  Formally: a node `M` such\n+//!    that `V` holds on entry to `N`. Formally: a node `M` such\n //!    that there exists a path `P` from `N` to `M` where `P` does not\n-//!    write `V`.  If the `reader` is `invalid_node()`, then the current\n+//!    write `V`. If the `reader` is `invalid_node()`, then the current\n //!    value will never be read (the variable is dead, essentially).\n //!\n //! - `writer`: the `LiveNode` ID of some node which will write the\n-//!    variable `V` and which is reachable from `N`.  Formally: a node `M`\n+//!    variable `V` and which is reachable from `N`. Formally: a node `M`\n //!    such that there exists a path `P` from `N` to `M` and `M` writes\n-//!    `V`.  If the `writer` is `invalid_node()`, then there is no writer\n+//!    `V`. If the `writer` is `invalid_node()`, then there is no writer\n //!    of `V` that follows `N`.\n //!\n-//! - `used`: a boolean value indicating whether `V` is *used*.  We\n+//! - `used`: a boolean value indicating whether `V` is *used*. We\n //!   distinguish a *read* from a *use* in that a *use* is some read that\n-//!   is not just used to generate a new value.  For example, `x += 1` is\n-//!   a read but not a use.  This is used to generate better warnings.\n+//!   is not just used to generate a new value. For example, `x += 1` is\n+//!   a read but not a use. This is used to generate better warnings.\n //!\n //! ## Special Variables\n //!\n@@ -87,7 +87,7 @@\n //! - `fallthrough_ln`: a live node that represents a fallthrough\n //!\n //! - `clean_exit_var`: a synthetic variable that is only 'read' from the\n-//!   fallthrough node.  It is only live if the function could converge\n+//!   fallthrough node. It is only live if the function could converge\n //!   via means other than an explicit `return` expression. That is, it is\n //!   only dead if the end of the function's block can never be reached.\n //!   It is the responsibility of typeck to ensure that there are no\n@@ -97,14 +97,14 @@ use self::LoopKind::*;\n use self::LiveNodeKind::*;\n use self::VarKind::*;\n \n-use hir::def::*;\n-use hir::Node;\n-use ty::{self, TyCtxt};\n-use ty::query::Providers;\n-use lint;\n-use errors::Applicability;\n-use util::nodemap::{NodeMap, HirIdMap, HirIdSet};\n+use crate::hir::def::*;\n+use crate::hir::Node;\n+use crate::ty::{self, TyCtxt};\n+use crate::ty::query::Providers;\n+use crate::lint;\n+use crate::util::nodemap::{NodeMap, HirIdMap, HirIdSet};\n \n+use errors::Applicability;\n use std::collections::{BTreeMap, VecDeque};\n use std::{fmt, u32};\n use std::io::prelude::*;\n@@ -115,10 +115,10 @@ use syntax::ptr::P;\n use syntax::symbol::keywords;\n use syntax_pos::Span;\n \n-use hir;\n-use hir::{Expr, HirId};\n-use hir::def_id::DefId;\n-use hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n+use crate::hir;\n+use crate::hir::{Expr, HirId};\n+use crate::hir::def_id::DefId;\n+use crate::hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n \n /// For use with `propagate_through_loop`.\n enum LoopKind<'a> {\n@@ -189,7 +189,6 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     for &module in tcx.hir().krate().modules.keys() {\n         tcx.ensure().check_mod_liveness(tcx.hir().local_def_id(module));\n     }\n-    tcx.sess.abort_if_errors();\n }\n \n pub fn provide(providers: &mut Providers<'_>) {\n@@ -406,7 +405,7 @@ fn add_from_pat<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, pat: &P<hir::Pat>) {\n     let mut pats = VecDeque::new();\n     pats.push_back(pat);\n     while let Some(pat) = pats.pop_front() {\n-        use hir::PatKind::*;\n+        use crate::hir::PatKind::*;\n         match pat.node {\n             Binding(_, _, _, _, ref inner_pat) => {\n                 pats.extend(inner_pat.iter());"}, {"sha": "231dcc9bfd272af8d1db2709639b5ceb4e89529a", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -3,7 +3,7 @@\n //! The job of the categorization module is to analyze an expression to\n //! determine what kind of memory is used in evaluating it (for example,\n //! where dereferences occur and what kind of pointer is dereferenced;\n-//! whether the memory is mutable; etc)\n+//! whether the memory is mutable, etc.).\n //!\n //! Categorization effectively transforms all of our expressions into\n //! expressions of the following forms (the actual enum has many more\n@@ -16,21 +16,21 @@\n //!       | E.comp    // access to an interior component\n //!\n //! Imagine a routine ToAddr(Expr) that evaluates an expression and returns an\n-//! address where the result is to be found.  If Expr is a place, then this\n-//! is the address of the place.  If Expr is an rvalue, this is the address of\n+//! address where the result is to be found. If Expr is a place, then this\n+//! is the address of the place. If `Expr` is an rvalue, this is the address of\n //! some temporary spot in memory where the result is stored.\n //!\n-//! Now, cat_expr() classifies the expression Expr and the address A=ToAddr(Expr)\n+//! Now, `cat_expr()` classifies the expression `Expr` and the address `A = ToAddr(Expr)`\n //! as follows:\n //!\n-//! - cat: what kind of expression was this?  This is a subset of the\n+//! - `cat`: what kind of expression was this? This is a subset of the\n //!   full expression forms which only includes those that we care about\n //!   for the purpose of the analysis.\n-//! - mutbl: mutability of the address A\n-//! - ty: the type of data found at the address A\n+//! - `mutbl`: mutability of the address `A`.\n+//! - `ty`: the type of data found at the address `A`.\n //!\n //! The resulting categorization tree differs somewhat from the expressions\n-//! themselves.  For example, auto-derefs are explicit.  Also, an index a[b] is\n+//! themselves. For example, auto-derefs are explicit. Also, an index a[b] is\n //! decomposed into two operations: a dereference to reach the array data and\n //! then an index to jump forward to the relevant item.\n //!\n@@ -58,19 +58,19 @@ pub use self::Note::*;\n \n use self::Aliasability::*;\n \n-use middle::region;\n-use hir::def_id::{DefId, LocalDefId};\n-use hir::Node;\n-use infer::InferCtxt;\n-use hir::def::{Def, CtorKind};\n-use ty::adjustment;\n-use ty::{self, Ty, TyCtxt};\n-use ty::fold::TypeFoldable;\n-use ty::layout::VariantIdx;\n-\n-use hir::{MutImmutable, MutMutable, PatKind};\n-use hir::pat_util::EnumerateAndAdjustIterator;\n-use hir;\n+use crate::middle::region;\n+use crate::hir::def_id::{DefId, LocalDefId};\n+use crate::hir::Node;\n+use crate::infer::InferCtxt;\n+use crate::hir::def::{Def, CtorKind};\n+use crate::ty::adjustment;\n+use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::fold::TypeFoldable;\n+use crate::ty::layout::VariantIdx;\n+\n+use crate::hir::{MutImmutable, MutMutable, PatKind};\n+use crate::hir::pat_util::EnumerateAndAdjustIterator;\n+use crate::hir;\n use syntax::ast::{self, Name};\n use syntax_pos::Span;\n \n@@ -80,7 +80,7 @@ use std::hash::{Hash, Hasher};\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::indexed_vec::Idx;\n use std::rc::Rc;\n-use util::nodemap::ItemLocalSet;\n+use crate::util::nodemap::ItemLocalSet;\n \n #[derive(Clone, Debug, PartialEq)]\n pub enum Categorization<'tcx> {\n@@ -174,7 +174,7 @@ pub enum Note {\n // which the value is stored.\n //\n // *WARNING* The field `cmt.type` is NOT necessarily the same as the\n-// result of `node_id_to_type(cmt.id)`.\n+// result of `node_type(cmt.id)`.\n //\n // (FIXME: rewrite the following comment given that `@x` managed\n // pointers have been obsolete for quite some time.)\n@@ -497,7 +497,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                    hir_id: hir::HirId)\n                    -> McResult<Ty<'tcx>> {\n         self.resolve_type_vars_or_error(hir_id,\n-                                        self.tables.node_id_to_type_opt(hir_id))\n+                                        self.tables.node_type_opt(hir_id))\n     }\n \n     pub fn expr_ty(&self, expr: &hir::Expr) -> McResult<Ty<'tcx>> {"}, {"sha": "1655d8356a5a7804755f3e4ea8181de00dbf5edd", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -2,7 +2,7 @@\n //! outside their scopes. This pass will also generate a set of exported items\n //! which are available for use externally when compiled as a library.\n \n-use util::nodemap::{DefIdSet, FxHashMap};\n+use crate::util::nodemap::{DefIdSet, FxHashMap};\n \n use std::hash::Hash;\n use std::fmt;"}, {"sha": "99d0c5e88d6385aeecc58226ad4e99d0ee0de229", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -5,24 +5,24 @@\n // makes all other generics or inline functions that it references\n // reachable as well.\n \n-use hir::{CodegenFnAttrs, CodegenFnAttrFlags};\n-use hir::Node;\n-use hir::def::Def;\n-use hir::def_id::{DefId, CrateNum};\n+use crate::hir::{CodegenFnAttrs, CodegenFnAttrFlags};\n+use crate::hir::Node;\n+use crate::hir::def::Def;\n+use crate::hir::def_id::{DefId, CrateNum};\n use rustc_data_structures::sync::Lrc;\n-use ty::{self, TyCtxt};\n-use ty::query::Providers;\n-use middle::privacy;\n-use session::config;\n-use util::nodemap::{NodeSet, FxHashSet};\n+use crate::ty::{self, TyCtxt};\n+use crate::ty::query::Providers;\n+use crate::middle::privacy;\n+use crate::session::config;\n+use crate::util::nodemap::{NodeSet, FxHashSet};\n \n use rustc_target::spec::abi::Abi;\n use syntax::ast;\n-use hir;\n-use hir::def_id::LOCAL_CRATE;\n-use hir::intravisit::{Visitor, NestedVisitorMap};\n-use hir::itemlikevisit::ItemLikeVisitor;\n-use hir::intravisit;\n+use crate::hir;\n+use crate::hir::def_id::LOCAL_CRATE;\n+use crate::hir::intravisit::{Visitor, NestedVisitorMap};\n+use crate::hir::itemlikevisit::ItemLikeVisitor;\n+use crate::hir::intravisit;\n \n // Returns true if the given item must be inlined because it may be\n // monomorphized or it was marked with `#[inline]`. This will only return\n@@ -177,8 +177,8 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                             // Check the impl. If the generics on the self\n                             // type of the impl require inlining, this method\n                             // does too.\n-                            let impl_node_id = self.tcx.hir().as_local_node_id(impl_did).unwrap();\n-                            match self.tcx.hir().expect_item(impl_node_id).node {\n+                            let impl_hir_id = self.tcx.hir().as_local_hir_id(impl_did).unwrap();\n+                            match self.tcx.hir().expect_item_by_hir_id(impl_hir_id).node {\n                                 hir::ItemKind::Impl(..) => {\n                                     let generics = self.tcx.generics_of(impl_did);\n                                     generics.requires_monomorphization(self.tcx)"}, {"sha": "ea077220e0be37680a22a8957b0951a733ef94d7", "filename": "src/librustc/middle/recursion_limit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -5,7 +5,7 @@\n // this via an attribute on the crate like `#![recursion_limit=\"22\"]`. This pass\n // just peeks and looks for that attribute.\n \n-use session::Session;\n+use crate::session::Session;\n use syntax::ast;\n \n use rustc_data_structures::sync::Once;"}, {"sha": "fd188b33d7e1fd253fb8785b6dddccf88e11212f", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -6,24 +6,24 @@\n //!\n //! [rustc guide]: https://rust-lang.github.io/rustc-guide/mir/borrowck.html\n \n-use ich::{StableHashingContext, NodeIdHashingMode};\n-use util::nodemap::{FxHashMap, FxHashSet};\n-use ty;\n+use crate::ich::{StableHashingContext, NodeIdHashingMode};\n+use crate::util::nodemap::{FxHashMap, FxHashSet};\n+use crate::ty;\n \n use std::mem;\n use std::fmt;\n use rustc_data_structures::sync::Lrc;\n use syntax::source_map;\n use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n-use ty::TyCtxt;\n-use ty::query::Providers;\n-\n-use hir;\n-use hir::Node;\n-use hir::def_id::DefId;\n-use hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use hir::{Block, Arm, Pat, PatKind, Stmt, Expr, Local};\n+use crate::ty::TyCtxt;\n+use crate::ty::query::Providers;\n+\n+use crate::hir;\n+use crate::hir::Node;\n+use crate::hir::def_id::DefId;\n+use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use crate::hir::{Block, Arm, Pat, PatKind, Stmt, Expr, Local};\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n@@ -85,11 +85,11 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n /// values live long enough; phrased another way, the starting point\n /// of each range is not really the important thing in the above\n /// picture, but rather the ending point.\n-///\n-/// FIXME (pnkfelix): This currently derives `PartialOrd` and `Ord` to\n-/// placate the same deriving in `ty::FreeRegion`, but we may want to\n-/// actually attach a more meaningful ordering to scopes than the one\n-/// generated via deriving here.\n+//\n+// FIXME(pnkfelix): this currently derives `PartialOrd` and `Ord` to\n+// placate the same deriving in `ty::FreeRegion`, but we may want to\n+// actually attach a more meaningful ordering to scopes than the one\n+// generated via deriving here.\n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Copy, RustcEncodable, RustcDecodable)]\n pub struct Scope {\n     pub id: hir::ItemLocalId,\n@@ -140,27 +140,27 @@ pub enum ScopeData {\n ///\n /// For example, given `{ let (a, b) = EXPR_1; let c = EXPR_2; ... }`:\n ///\n-/// * the subscope with `first_statement_index == 0` is scope of both\n+/// * The subscope with `first_statement_index == 0` is scope of both\n ///   `a` and `b`; it does not include EXPR_1, but does include\n ///   everything after that first `let`. (If you want a scope that\n ///   includes EXPR_1 as well, then do not use `Scope::Remainder`,\n ///   but instead another `Scope` that encompasses the whole block,\n ///   e.g., `Scope::Node`.\n ///\n-/// * the subscope with `first_statement_index == 1` is scope of `c`,\n+/// * The subscope with `first_statement_index == 1` is scope of `c`,\n ///   and thus does not include EXPR_2, but covers the `...`.\n \n newtype_index! {\n     pub struct FirstStatementIndex { .. }\n }\n \n-impl_stable_hash_for!(struct ::middle::region::FirstStatementIndex { private });\n+impl_stable_hash_for!(struct crate::middle::region::FirstStatementIndex { private });\n \n // compilation error if size of `ScopeData` is not the same as a `u32`\n static_assert!(ASSERT_SCOPE_DATA: mem::size_of::<ScopeData>() == 4);\n \n impl Scope {\n-    /// Returns a item-local id associated with this scope.\n+    /// Returns a item-local ID associated with this scope.\n     ///\n     /// N.B., likely to be replaced as API is refined; e.g., pnkfelix\n     /// anticipates `fn entry_node_id` and `fn each_exit_node_id`.\n@@ -180,8 +180,8 @@ impl Scope {\n         }\n     }\n \n-    /// Returns the span of this Scope.  Note that in general the\n-    /// returned span may not correspond to the span of any node id in\n+    /// Returns the span of this `Scope`. Note that in general the\n+    /// returned span may not correspond to the span of any `NodeId` in\n     /// the AST.\n     pub fn span(&self, tcx: TyCtxt<'_, '_, '_>, scope_tree: &ScopeTree) -> Span {\n         let node_id = self.node_id(tcx, scope_tree);\n@@ -225,19 +225,19 @@ pub struct ScopeTree {\n     /// have lifetime parameters free in this body.\n     root_parent: Option<ast::NodeId>,\n \n-    /// `parent_map` maps from a scope id to the enclosing scope id;\n+    /// `parent_map` maps from a scope ID to the enclosing scope id;\n     /// this is usually corresponding to the lexical nesting, though\n     /// in the case of closures the parent scope is the innermost\n     /// conditional expression or repeating block. (Note that the\n-    /// enclosing scope id for the block associated with a closure is\n+    /// enclosing scope ID for the block associated with a closure is\n     /// the closure itself.)\n     parent_map: FxHashMap<Scope, (Scope, ScopeDepth)>,\n \n-    /// `var_map` maps from a variable or binding id to the block in\n+    /// `var_map` maps from a variable or binding ID to the block in\n     /// which that variable is declared.\n     var_map: FxHashMap<hir::ItemLocalId, Scope>,\n \n-    /// maps from a node-id to the associated destruction scope (if any)\n+    /// maps from a `NodeId` to the associated destruction scope (if any)\n     destruction_scopes: FxHashMap<hir::ItemLocalId, Scope>,\n \n     /// `rvalue_scopes` includes entries for those expressions whose cleanup scope is\n@@ -252,8 +252,8 @@ pub struct ScopeTree {\n \n     /// Encodes the hierarchy of fn bodies. Every fn body (including\n     /// closures) forms its own distinct region hierarchy, rooted in\n-    /// the block that is the fn body. This map points from the id of\n-    /// that root block to the id of the root block for the enclosing\n+    /// the block that is the fn body. This map points from the ID of\n+    /// that root block to the ID of the root block for the enclosing\n     /// fn, if any. Thus the map structures the fn bodies into a\n     /// hierarchy based on their lexical mapping. This is used to\n     /// handle the relationships between regions in a fn and in a\n@@ -382,7 +382,7 @@ struct RegionResolutionVisitor<'a, 'tcx: 'a> {\n     /// upon exiting the parent scope, we cannot statically know how\n     /// many times the expression executed, and thus if the expression\n     /// creates temporaries we cannot know statically how many such\n-    /// temporaries we would have to cleanup. Therefore we ensure that\n+    /// temporaries we would have to cleanup. Therefore, we ensure that\n     /// the temporaries never outlast the conditional/repeating\n     /// expression, preventing the need for dynamic checks and/or\n     /// arbitrary amounts of stack space. Terminating scopes end\n@@ -465,7 +465,7 @@ impl<'tcx> ScopeTree {\n     }\n \n     /// Records that `sub_closure` is defined within `sup_closure`. These ids\n-    /// should be the id of the block that is the fn body, which is\n+    /// should be the ID of the block that is the fn body, which is\n     /// also the root of the region hierarchy for that fn.\n     fn record_closure_parent(&mut self,\n                              sub_closure: hir::ItemLocalId,\n@@ -551,8 +551,8 @@ impl<'tcx> ScopeTree {\n         self.is_subscope_of(scope2, scope1)\n     }\n \n-    /// Returns true if `subscope` is equal to or is lexically nested inside `superscope` and false\n-    /// otherwise.\n+    /// Returns `true` if `subscope` is equal to or is lexically nested inside `superscope`, and\n+    /// `false` otherwise.\n     pub fn is_subscope_of(&self,\n                           subscope: Scope,\n                           superscope: Scope)\n@@ -575,7 +575,7 @@ impl<'tcx> ScopeTree {\n         return true;\n     }\n \n-    /// Returns the id of the innermost containing body\n+    /// Returns the ID of the innermost containing body\n     pub fn containing_body(&self, mut scope: Scope) -> Option<hir::ItemLocalId> {\n         loop {\n             if let ScopeData::CallSite = scope.data {\n@@ -586,7 +586,7 @@ impl<'tcx> ScopeTree {\n         }\n     }\n \n-    /// Finds the nearest common ancestor of two scopes.  That is, finds the\n+    /// Finds the nearest common ancestor of two scopes. That is, finds the\n     /// smallest scope which is greater than or equal to both `scope_a` and\n     /// `scope_b`.\n     pub fn nearest_common_ancestor(&self, scope_a: Scope, scope_b: Scope) -> Scope {\n@@ -1051,7 +1051,7 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n         visitor.visit_pat(pat);\n     }\n \n-    /// True if `pat` match the `P&` nonterminal:\n+    /// Returns `true` if `pat` match the `P&` non-terminal.\n     ///\n     ///     P& = ref X\n     ///        | StructName { ..., P&, ... }"}, {"sha": "5f7b9cc33660f95191937e15d15573612d058579", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -3,18 +3,19 @@\n //! Name resolution for lifetimes follows MUCH simpler rules than the\n //! full resolve. For example, lifetime names are never exported or\n //! used between functions, and they operate in a purely top-down\n-//! way. Therefore we break lifetime name resolution into a separate pass.\n+//! way. Therefore, we break lifetime name resolution into a separate pass.\n \n-use hir::def::Def;\n-use hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n-use hir::map::Map;\n-use hir::{GenericArg, GenericParam, ItemLocalId, LifetimeName, Node, ParamName};\n-use ty::{self, DefIdTree, GenericParamDefKind, TyCtxt};\n+use crate::hir::def::Def;\n+use crate::hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n+use crate::hir::map::Map;\n+use crate::hir::{GenericArg, GenericParam, ItemLocalId, LifetimeName, Node, ParamName};\n+use crate::ty::{self, DefIdTree, GenericParamDefKind, TyCtxt};\n \n+use crate::rustc::lint;\n+use crate::session::Session;\n+use crate::util::nodemap::{DefIdMap, FxHashMap, FxHashSet, NodeMap, NodeSet};\n use errors::{Applicability, DiagnosticBuilder};\n-use rustc::lint;\n use rustc_data_structures::sync::Lrc;\n-use session::Session;\n use std::borrow::Cow;\n use std::cell::Cell;\n use std::mem::replace;\n@@ -23,10 +24,9 @@ use syntax::attr;\n use syntax::ptr::P;\n use syntax::symbol::keywords;\n use syntax_pos::Span;\n-use util::nodemap::{DefIdMap, FxHashMap, FxHashSet, NodeMap, NodeSet};\n \n-use hir::intravisit::{self, NestedVisitorMap, Visitor};\n-use hir::{self, GenericParamKind, LifetimeParamKind};\n+use crate::hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use crate::hir::{self, GenericParamKind, LifetimeParamKind};\n \n /// The origin of a named lifetime definition.\n ///\n@@ -207,7 +207,7 @@ struct NamedRegionMap {\n     pub object_lifetime_defaults: NodeMap<Vec<ObjectLifetimeDefault>>,\n }\n \n-/// See `NamedRegionMap`.\n+/// See [`NamedRegionMap`].\n #[derive(Default)]\n pub struct ResolveLifetimes {\n     defs: FxHashMap<LocalDefId, Lrc<FxHashMap<ItemLocalId, Region>>>,\n@@ -216,7 +216,7 @@ pub struct ResolveLifetimes {\n         FxHashMap<LocalDefId, Lrc<FxHashMap<ItemLocalId, Lrc<Vec<ObjectLifetimeDefault>>>>>,\n }\n \n-impl_stable_hash_for!(struct ::middle::resolve_lifetime::ResolveLifetimes {\n+impl_stable_hash_for!(struct crate::middle::resolve_lifetime::ResolveLifetimes {\n     defs,\n     late_bound,\n     object_lifetime_defaults\n@@ -227,21 +227,19 @@ struct LifetimeContext<'a, 'tcx: 'a> {\n     map: &'a mut NamedRegionMap,\n     scope: ScopeRef<'a>,\n \n-    /// Deep breath. Our representation for poly trait refs contains a single\n+    /// This is slightly complicated. Our representation for poly-trait-refs contains a single\n     /// binder and thus we only allow a single level of quantification. However,\n     /// the syntax of Rust permits quantification in two places, e.g., `T: for <'a> Foo<'a>`\n-    /// and `for <'a, 'b> &'b T: Foo<'a>`. In order to get the de Bruijn indices\n+    /// and `for <'a, 'b> &'b T: Foo<'a>`. In order to get the De Bruijn indices\n     /// correct when representing these constraints, we should only introduce one\n     /// scope. However, we want to support both locations for the quantifier and\n     /// during lifetime resolution we want precise information (so we can't\n     /// desugar in an earlier phase).\n     ///\n-    /// SO, if we encounter a quantifier at the outer scope, we set\n-    /// trait_ref_hack to true (and introduce a scope), and then if we encounter\n-    /// a quantifier at the inner scope, we error. If trait_ref_hack is false,\n+    /// So, if we encounter a quantifier at the outer scope, we set\n+    /// `trait_ref_hack` to `true` (and introduce a scope), and then if we encounter\n+    /// a quantifier at the inner scope, we error. If `trait_ref_hack` is `false`,\n     /// then we introduce the scope at the inner quantifier.\n-    ///\n-    /// I'm sorry.\n     trait_ref_hack: bool,\n \n     /// Used to disallow the use of in-band lifetimes in `fn` or `Fn` syntax.\n@@ -1248,12 +1246,12 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body) {\n                 } => {\n                     // FIXME (#24278): non-hygienic comparison\n                     if let Some(def) = lifetimes.get(&hir::ParamName::Plain(label.modern())) {\n-                        let node_id = tcx.hir().as_local_node_id(def.id().unwrap()).unwrap();\n+                        let hir_id = tcx.hir().as_local_hir_id(def.id().unwrap()).unwrap();\n \n                         signal_shadowing_problem(\n                             tcx,\n                             label.name,\n-                            original_lifetime(tcx.hir().span(node_id)),\n+                            original_lifetime(tcx.hir().span_by_hir_id(hir_id)),\n                             shadower_label(label.span),\n                         );\n                         return;\n@@ -1676,7 +1674,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     /// If early bound lifetimes are present, we separate them into their own list (and likewise\n     /// for late bound). They will be numbered sequentially, starting from the lowest index that is\n     /// already in scope (for a fn item, that will be 0, but for a method it might not be). Late\n-    /// bound lifetimes are resolved by name and associated with a binder id (`binder_id`), so the\n+    /// bound lifetimes are resolved by name and associated with a binder ID (`binder_id`), so the\n     /// ordering is not important there.\n     fn visit_early_late<F>(\n         &mut self,\n@@ -2593,12 +2591,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     ref lifetimes, s, ..\n                 } => {\n                     if let Some(&def) = lifetimes.get(&param.name.modern()) {\n-                        let node_id = self.tcx.hir().as_local_node_id(def.id().unwrap()).unwrap();\n+                        let hir_id = self.tcx.hir().as_local_hir_id(def.id().unwrap()).unwrap();\n \n                         signal_shadowing_problem(\n                             self.tcx,\n                             param.name.ident().name,\n-                            original_lifetime(self.tcx.hir().span(node_id)),\n+                            original_lifetime(self.tcx.hir().span_by_hir_id(hir_id)),\n                             shadower_lifetime(&param),\n                         );\n                         return;\n@@ -2610,7 +2608,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    /// Returns true if, in the current scope, replacing `'_` would be\n+    /// Returns `true` if, in the current scope, replacing `'_` would be\n     /// equivalent to a single-use lifetime.\n     fn track_lifetime_uses(&self) -> bool {\n         let mut scope = self.scope;\n@@ -2714,7 +2712,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n /// - it does not appear in a where-clause.\n ///\n /// \"Constrained\" basically means that it appears in any type but\n-/// not amongst the inputs to a projection.  In other words, `<&'a\n+/// not amongst the inputs to a projection. In other words, `<&'a\n /// T as Trait<''b>>::Foo` does not constrain `'a` or `'b`.\n fn insert_late_bound_lifetimes(\n     map: &mut NamedRegionMap,"}, {"sha": "30a43c7a92595c57c2b5a2ac25e14949a7d37ef5", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 33, "deletions": 55, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -3,23 +3,23 @@\n \n pub use self::StabilityLevel::*;\n \n-use lint::{self, Lint};\n-use hir::{self, Item, Generics, StructField, Variant, HirId};\n-use hir::def::Def;\n-use hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, LOCAL_CRATE};\n-use hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use ty::query::Providers;\n-use middle::privacy::AccessLevels;\n-use session::{DiagnosticMessageId, Session};\n+use crate::lint::{self, Lint};\n+use crate::hir::{self, Item, Generics, StructField, Variant, HirId};\n+use crate::hir::def::Def;\n+use crate::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, LOCAL_CRATE};\n+use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use crate::ty::query::Providers;\n+use crate::middle::privacy::AccessLevels;\n+use crate::session::{DiagnosticMessageId, Session};\n use syntax::symbol::Symbol;\n use syntax_pos::{Span, MultiSpan};\n use syntax::ast;\n use syntax::ast::{NodeId, Attribute};\n use syntax::errors::Applicability;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::attr::{self, Stability, Deprecation};\n-use ty::{self, TyCtxt};\n-use util::nodemap::{FxHashSet, FxHashMap};\n+use crate::ty::{self, TyCtxt};\n+use crate::util::nodemap::{FxHashSet, FxHashMap};\n \n use std::mem::replace;\n use std::cmp::Ordering;\n@@ -51,7 +51,7 @@ enum AnnotationKind {\n pub struct DeprecationEntry {\n     /// The metadata of the attribute associated with this entry.\n     pub attr: Deprecation,\n-    /// The def id where the attr was originally attached. `None` for non-local\n+    /// The `DefId` where the attr was originally attached. `None` for non-local\n     /// `DefId`'s.\n     origin: Option<HirId>,\n }\n@@ -322,14 +322,17 @@ struct MissingStabilityAnnotations<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx: 'a> MissingStabilityAnnotations<'a, 'tcx> {\n-    fn check_missing_stability(&self, id: NodeId, span: Span) {\n+    fn check_missing_stability(&self, id: NodeId, span: Span, name: &str) {\n         let hir_id = self.tcx.hir().node_to_hir_id(id);\n         let stab = self.tcx.stability().local_stability(hir_id);\n         let is_error = !self.tcx.sess.opts.test &&\n                         stab.is_none() &&\n                         self.access_levels.is_reachable(id);\n         if is_error {\n-            self.tcx.sess.span_err(span, \"This node does not have a stability attribute\");\n+            self.tcx.sess.span_err(\n+                span,\n+                &format!(\"{} has missing stability attribute\", name),\n+            );\n         }\n     }\n }\n@@ -347,42 +350,42 @@ impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n             // optional. They inherit stability from their parents when unannotated.\n             hir::ItemKind::Impl(.., None, _, _) | hir::ItemKind::ForeignMod(..) => {}\n \n-            _ => self.check_missing_stability(i.id, i.span)\n+            _ => self.check_missing_stability(i.id, i.span, i.node.descriptive_variant())\n         }\n \n         intravisit::walk_item(self, i)\n     }\n \n     fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem) {\n-        self.check_missing_stability(ti.id, ti.span);\n+        self.check_missing_stability(ti.id, ti.span, \"item\");\n         intravisit::walk_trait_item(self, ti);\n     }\n \n     fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n         let impl_def_id = self.tcx.hir().local_def_id(self.tcx.hir().get_parent(ii.id));\n         if self.tcx.impl_trait_ref(impl_def_id).is_none() {\n-            self.check_missing_stability(ii.id, ii.span);\n+            self.check_missing_stability(ii.id, ii.span, \"item\");\n         }\n         intravisit::walk_impl_item(self, ii);\n     }\n \n     fn visit_variant(&mut self, var: &'tcx Variant, g: &'tcx Generics, item_id: NodeId) {\n-        self.check_missing_stability(var.node.data.id(), var.span);\n+        self.check_missing_stability(var.node.data.id(), var.span, \"variant\");\n         intravisit::walk_variant(self, var, g, item_id);\n     }\n \n     fn visit_struct_field(&mut self, s: &'tcx StructField) {\n-        self.check_missing_stability(s.id, s.span);\n+        self.check_missing_stability(s.id, s.span, \"field\");\n         intravisit::walk_struct_field(self, s);\n     }\n \n     fn visit_foreign_item(&mut self, i: &'tcx hir::ForeignItem) {\n-        self.check_missing_stability(i.id, i.span);\n+        self.check_missing_stability(i.id, i.span, i.node.descriptive_variant());\n         intravisit::walk_foreign_item(self, i);\n     }\n \n     fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef) {\n-        self.check_missing_stability(md.id, md.span);\n+        self.check_missing_stability(md.id, md.span, \"macro\");\n     }\n }\n \n@@ -475,7 +478,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-/// Check whether an item marked with `deprecated(since=\"X\")` is currently\n+/// Checks whether an item marked with `deprecated(since=\"X\")` is currently\n /// deprecated (i.e., whether X is not greater than the current rustc version).\n pub fn deprecation_in_effect(since: &str) -> bool {\n     fn parse_version(ver: &str) -> Vec<u32> {\n@@ -561,11 +564,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// deprecated. If the item is indeed deprecated, we will emit a deprecation lint attached to\n     /// `id`.\n     pub fn eval_stability(self, def_id: DefId, id: Option<NodeId>, span: Span) -> EvalResult {\n-        if span.allows_unstable() {\n-            debug!(\"stability: skipping span={:?} since it is internal\", span);\n-            return EvalResult::Allow;\n-        }\n-\n         let lint_deprecated = |def_id: DefId,\n                                id: NodeId,\n                                note: Option<Symbol>,\n@@ -598,37 +596,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // Deprecated attributes apply in-crate and cross-crate.\n         if let Some(id) = id {\n             if let Some(depr_entry) = self.lookup_deprecation_entry(def_id) {\n-                // If the deprecation is scheduled for a future Rust\n-                // version, then we should display no warning message.\n-                let deprecated_in_future_version = if let Some(sym) = depr_entry.attr.since {\n-                    let since = sym.as_str();\n-                    if !deprecation_in_effect(&since) {\n-                        Some(since)\n-                    } else {\n-                        None\n-                    }\n-                } else {\n-                    None\n-                };\n-\n                 let parent_def_id = self.hir().local_def_id(self.hir().get_parent(id));\n                 let skip = self.lookup_deprecation_entry(parent_def_id)\n                                .map_or(false, |parent_depr| parent_depr.same_origin(&depr_entry));\n \n-                if let Some(since) = deprecated_in_future_version {\n-                    let path = self.item_path_str(def_id);\n-                    let message = format!(\"use of item '{}' \\\n-                                           that will be deprecated in future version {}\",\n-                                          path,\n-                                          since);\n-\n-                    lint_deprecated(def_id,\n-                                    id,\n-                                    depr_entry.attr.note,\n-                                    None,\n-                                    &message,\n-                                    lint::builtin::DEPRECATED_IN_FUTURE);\n-                } else if !skip {\n+                if !skip {\n                     let path = self.item_path_str(def_id);\n                     let message = format!(\"use of deprecated item '{}'\", path);\n                     lint_deprecated(def_id,\n@@ -694,6 +666,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         match stability {\n             Some(&Stability { level: attr::Unstable { reason, issue }, feature, .. }) => {\n+                if span.allows_unstable(&feature.as_str()) {\n+                    debug!(\"stability: skipping span={:?} since it is internal\", span);\n+                    return EvalResult::Allow;\n+                }\n                 if self.stability().active_features.contains(&feature) {\n                     return EvalResult::Allow;\n                 }\n@@ -765,7 +741,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n             EvalResult::Unmarked => {\n-                span_bug!(span, \"encountered unmarked API: {:?}\", def_id);\n+                // The API could be uncallable for other reasons, for example when a private module\n+                // was referenced.\n+                self.sess.delay_span_bug(span, &format!(\"encountered unmarked API: {:?}\", def_id));\n             }\n         }\n     }\n@@ -865,7 +843,7 @@ pub fn check_unused_or_stable_features<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n             tcx,\n             access_levels,\n         };\n-        missing.check_missing_stability(ast::CRATE_NODE_ID, krate.span);\n+        missing.check_missing_stability(ast::CRATE_NODE_ID, krate.span, \"crate\");\n         intravisit::walk_crate(&mut missing, krate);\n         krate.visit_all_item_likes(&mut missing.as_deep_visitor());\n     }"}, {"sha": "312924e5e90f549418a5bc7565f383f0912a8fc4", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,18 +1,18 @@\n //! Validity checking for weak lang items\n \n-use session::config;\n-use middle::lang_items;\n+use crate::session::config;\n+use crate::middle::lang_items;\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_target::spec::PanicStrategy;\n use syntax::ast;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n-use hir::def_id::DefId;\n-use hir::intravisit::{Visitor, NestedVisitorMap};\n-use hir::intravisit;\n-use hir;\n-use ty::TyCtxt;\n+use crate::hir::def_id::DefId;\n+use crate::hir::intravisit::{Visitor, NestedVisitorMap};\n+use crate::hir::intravisit;\n+use crate::hir;\n+use crate::ty::TyCtxt;\n \n macro_rules! weak_lang_items {\n     ($($name:ident, $item:ident, $sym:ident;)*) => (\n@@ -54,7 +54,7 @@ pub fn link_name(attrs: &[ast::Attribute]) -> Option<Symbol> {\n     })\n }\n \n-/// Returns whether the specified `lang_item` doesn't actually need to be\n+/// Returns `true` if the specified `lang_item` doesn't actually need to be\n /// present for this compilation.\n ///\n /// Not all lang items are always required for each compilation, particularly in"}, {"sha": "1cc927b1f720f3a549493b8d7b906f55fb97c349", "filename": "src/librustc/mir/cache.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -2,10 +2,10 @@ use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::sync::{RwLock, MappedReadGuard, ReadGuard};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n-use ich::StableHashingContext;\n-use mir::{Mir, BasicBlock};\n+use crate::ich::StableHashingContext;\n+use crate::mir::{Mir, BasicBlock};\n \n-use rustc_serialize as serialize;\n+use crate::rustc_serialize as serialize;\n \n #[derive(Clone, Debug)]\n pub struct Cache {"}, {"sha": "e96392edd64bfbb87b047a6d5f9578ea254d597f", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,14 +1,14 @@\n-//! The virtual memory representation of the MIR interpreter\n+//! The virtual memory representation of the MIR interpreter.\n \n use super::{\n     Pointer, EvalResult, AllocId, ScalarMaybeUndef, write_target_uint, read_target_uint, Scalar,\n     truncate,\n };\n \n-use ty::layout::{Size, Align};\n+use crate::ty::layout::{Size, Align};\n use syntax::ast::Mutability;\n use std::iter;\n-use mir;\n+use crate::mir;\n use std::ops::{Deref, DerefMut};\n use rustc_data_structures::sorted_map::SortedMap;\n use rustc_target::abi::HasDataLayout;\n@@ -54,7 +54,7 @@ pub trait AllocationExtra<Tag, MemoryExtra>: ::std::fmt::Debug + Clone {\n     /// Hook for performing extra checks on a memory read access.\n     ///\n     /// Takes read-only access to the allocation so we can keep all the memory read\n-    /// operations take `&self`.  Use a `RefCell` in `AllocExtra` if you\n+    /// operations take `&self`. Use a `RefCell` in `AllocExtra` if you\n     /// need to mutate.\n     #[inline(always)]\n     fn memory_read(\n@@ -133,7 +133,7 @@ impl<'tcx> ::serialize::UseSpecializedDecodable for &'tcx Allocation {}\n \n /// Alignment and bounds checks\n impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n-    /// Check if the pointer is \"in-bounds\". Notice that a pointer pointing at the end\n+    /// Checks if the pointer is \"in-bounds\". Notice that a pointer pointing at the end\n     /// of an allocation (i.e., at the first *inaccessible* location) *is* considered\n     /// in-bounds!  This follows C's/LLVM's rules.\n     /// If you want to check bounds before doing a memory access, better use `check_bounds`.\n@@ -145,7 +145,7 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n         ptr.check_in_alloc(Size::from_bytes(allocation_size), InboundsCheck::Live)\n     }\n \n-    /// Check if the memory range beginning at `ptr` and of size `Size` is \"in-bounds\".\n+    /// Checks if the memory range beginning at `ptr` and of size `Size` is \"in-bounds\".\n     #[inline(always)]\n     pub fn check_bounds(\n         &self,\n@@ -161,7 +161,7 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n /// Byte accessors\n impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n     /// The last argument controls whether we error out when there are undefined\n-    /// or pointer bytes.  You should never call this, call `get_bytes` or\n+    /// or pointer bytes. You should never call this, call `get_bytes` or\n     /// `get_bytes_with_undef_and_ptr` instead,\n     ///\n     /// This function also guarantees that the resulting pointer will remain stable\n@@ -462,7 +462,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n \n /// Relocations\n impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n-    /// Return all relocations overlapping with the given ptr-offset pair.\n+    /// Returns all relocations overlapping with the given ptr-offset pair.\n     pub fn relocations(\n         &self,\n         cx: &impl HasDataLayout,\n@@ -476,7 +476,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         self.relocations.range(Size::from_bytes(start)..end)\n     }\n \n-    /// Check that there are no relocations overlapping with the given range.\n+    /// Checks that there are no relocations overlapping with the given range.\n     #[inline(always)]\n     fn check_relocations(\n         &self,\n@@ -491,10 +491,10 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         }\n     }\n \n-    /// Remove all relocations inside the given range.\n+    /// Removes all relocations inside the given range.\n     /// If there are relocations overlapping with the edges, they\n     /// are removed as well *and* the bytes they cover are marked as\n-    /// uninitialized.  This is a somewhat odd \"spooky action at a distance\",\n+    /// uninitialized. This is a somewhat odd \"spooky action at a distance\",\n     /// but it allows strictly more code to run than if we would just error\n     /// immediately in that case.\n     fn clear_relocations(\n@@ -633,7 +633,7 @@ impl UndefMask {\n         m\n     }\n \n-    /// Check whether the range `start..end` (end-exclusive) is entirely defined.\n+    /// Checks whether the range `start..end` (end-exclusive) is entirely defined.\n     ///\n     /// Returns `Ok(())` if it's defined. Otherwise returns the index of the byte\n     /// at which the first undefined access begins."}, {"sha": "29beabdb2abdf580fc52d5b5078f4b003052f60a", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,16 +1,16 @@\n use std::{fmt, env};\n \n-use hir::map::definitions::DefPathData;\n-use mir;\n-use ty::{self, Ty, layout};\n-use ty::layout::{Size, Align, LayoutError};\n+use crate::hir::map::definitions::DefPathData;\n+use crate::mir;\n+use crate::ty::{self, Ty, layout};\n+use crate::ty::layout::{Size, Align, LayoutError};\n use rustc_target::spec::abi::Abi;\n \n use super::{RawConst, Pointer, InboundsCheck, ScalarMaybeUndef};\n \n use backtrace::Backtrace;\n \n-use ty::query::TyCtxtAt;\n+use crate::ty::query::TyCtxtAt;\n use errors::DiagnosticBuilder;\n \n use syntax_pos::{Pos, Span};\n@@ -19,7 +19,7 @@ use syntax::symbol::Symbol;\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n pub enum ErrorHandled {\n-    /// Already reported a lint or an error for this evaluation\n+    /// Already reported a lint or an error for this evaluation.\n     Reported,\n     /// Don't emit an error, the evaluation failed because the MIR was generic\n     /// and the substs didn't fully monomorphize it.\n@@ -42,7 +42,7 @@ pub type ConstEvalResult<'tcx> = Result<ty::Const<'tcx>, ErrorHandled>;\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct ConstEvalErr<'tcx> {\n     pub span: Span,\n-    pub error: ::mir::interpret::EvalErrorKind<'tcx, u64>,\n+    pub error: crate::mir::interpret::EvalErrorKind<'tcx, u64>,\n     pub stacktrace: Vec<FrameInfo<'tcx>>,\n }\n \n@@ -136,7 +136,7 @@ impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n                 .next()\n                 .unwrap_or(lint_root);\n             tcx.struct_span_lint_node(\n-                ::rustc::lint::builtin::CONST_ERR,\n+                crate::rustc::lint::builtin::CONST_ERR,\n                 node_id,\n                 tcx.span,\n                 message,\n@@ -212,7 +212,7 @@ pub type AssertMessage<'tcx> = EvalErrorKind<'tcx, mir::Operand<'tcx>>;\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub enum EvalErrorKind<'tcx, O> {\n     /// This variant is used by machines to signal their own errors that do not\n-    /// match an existing variant\n+    /// match an existing variant.\n     MachineError(String),\n \n     FunctionAbiMismatch(Abi, Abi),"}, {"sha": "0c43fe4a79faa7115ab343335dd080f6a9f1517f", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 37, "deletions": 22, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -25,17 +25,17 @@ pub use self::allocation::{\n pub use self::pointer::{Pointer, PointerArithmetic};\n \n use std::fmt;\n-use mir;\n-use hir::def_id::DefId;\n-use ty::{self, TyCtxt, Instance};\n-use ty::layout::{self, Size};\n+use crate::mir;\n+use crate::hir::def_id::DefId;\n+use crate::ty::{self, TyCtxt, Instance, subst::UnpackedKind};\n+use crate::ty::layout::{self, Size};\n use std::io;\n-use rustc_serialize::{Encoder, Decodable, Encodable};\n+use crate::rustc_serialize::{Encoder, Decodable, Encodable};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{Lock as Mutex, HashMapExt};\n use rustc_data_structures::tiny_list::TinyList;\n use byteorder::{WriteBytesExt, ReadBytesExt, LittleEndian, BigEndian};\n-use ty::codec::TyDecoder;\n+use crate::ty::codec::TyDecoder;\n use std::sync::atomic::{AtomicU32, Ordering};\n use std::num::NonZeroU32;\n \n@@ -53,8 +53,8 @@ pub struct GlobalId<'tcx> {\n #[derive(Copy, Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug)]\n pub struct AllocId(pub u64);\n \n-impl ::rustc_serialize::UseSpecializedEncodable for AllocId {}\n-impl ::rustc_serialize::UseSpecializedDecodable for AllocId {}\n+impl crate::rustc_serialize::UseSpecializedEncodable for AllocId {}\n+impl crate::rustc_serialize::UseSpecializedDecodable for AllocId {}\n \n #[derive(RustcDecodable, RustcEncodable)]\n enum AllocDiscriminant {\n@@ -260,23 +260,23 @@ impl fmt::Display for AllocId {\n \n #[derive(Debug, Clone, Eq, PartialEq, Hash, RustcDecodable, RustcEncodable)]\n pub enum AllocKind<'tcx> {\n-    /// The alloc id is used as a function pointer\n+    /// The alloc ID is used as a function pointer\n     Function(Instance<'tcx>),\n-    /// The alloc id points to a \"lazy\" static variable that did not get computed (yet).\n+    /// The alloc ID points to a \"lazy\" static variable that did not get computed (yet).\n     /// This is also used to break the cycle in recursive statics.\n     Static(DefId),\n-    /// The alloc id points to memory\n+    /// The alloc ID points to memory.\n     Memory(&'tcx Allocation),\n }\n \n pub struct AllocMap<'tcx> {\n-    /// Lets you know what an AllocId refers to\n+    /// Lets you know what an `AllocId` refers to.\n     id_to_kind: FxHashMap<AllocId, AllocKind<'tcx>>,\n \n-    /// Used to ensure that statics only get one associated AllocId\n+    /// Used to ensure that statics only get one associated `AllocId`.\n     type_interner: FxHashMap<AllocKind<'tcx>, AllocId>,\n \n-    /// The AllocId to assign to the next requested id.\n+    /// The `AllocId` to assign to the next requested ID.\n     /// Always incremented, never gets smaller.\n     next_id: AllocId,\n }\n@@ -318,14 +318,29 @@ impl<'tcx> AllocMap<'tcx> {\n         id\n     }\n \n-    /// Functions cannot be identified by pointers, as asm-equal functions can get deduplicated\n-    /// by the linker and functions can be duplicated across crates.\n-    /// We thus generate a new `AllocId` for every mention of a function. This means that\n-    /// `main as fn() == main as fn()` is false, while `let x = main as fn(); x == x` is true.\n     pub fn create_fn_alloc(&mut self, instance: Instance<'tcx>) -> AllocId {\n-        let id = self.reserve();\n-        self.id_to_kind.insert(id, AllocKind::Function(instance));\n-        id\n+        // Functions cannot be identified by pointers, as asm-equal functions can get deduplicated\n+        // by the linker (we set the \"unnamed_addr\" attribute for LLVM) and functions can be\n+        // duplicated across crates.\n+        // We thus generate a new `AllocId` for every mention of a function. This means that\n+        // `main as fn() == main as fn()` is false, while `let x = main as fn(); x == x` is true.\n+        // However, formatting code relies on function identity (see #58320), so we only do\n+        // this for generic functions.  Lifetime parameters are ignored.\n+        let is_generic = instance.substs.into_iter().any(|kind| {\n+            match kind.unpack() {\n+                UnpackedKind::Lifetime(_) => false,\n+                _ => true,\n+            }\n+        });\n+        if is_generic {\n+            // Get a fresh ID\n+            let id = self.reserve();\n+            self.id_to_kind.insert(id, AllocKind::Function(instance));\n+            id\n+        } else {\n+            // Deduplicate\n+            self.intern(AllocKind::Function(instance))\n+        }\n     }\n \n     /// Returns `None` in case the `AllocId` is dangling. An `EvalContext` can still have a\n@@ -345,7 +360,7 @@ impl<'tcx> AllocMap<'tcx> {\n         }\n     }\n \n-    /// Generate an `AllocId` for a static or return a cached one in case this function has been\n+    /// Generates an `AllocId` for a static or return a cached one in case this function has been\n     /// called on the same static before.\n     pub fn intern_static(&mut self, static_id: DefId) -> AllocId {\n         self.intern(AllocKind::Static(static_id))"}, {"sha": "551e7b2fd41ecd61053779c4eb12478a2f07b915", "filename": "src/librustc/mir/interpret/pointer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,5 +1,5 @@\n-use mir;\n-use ty::layout::{self, HasDataLayout, Size};\n+use crate::mir;\n+use crate::ty::layout::{self, HasDataLayout, Size};\n \n use super::{\n     AllocId, EvalResult, InboundsCheck,"}, {"sha": "5ec7de4308a13da5c888fc802d2981c327ff5a1e", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -13,25 +13,26 @@ pub struct RawConst<'tcx> {\n     pub ty: Ty<'tcx>,\n }\n \n-/// Represents a constant value in Rust. Scalar and ScalarPair are optimizations which\n-/// matches the LocalState optimizations for easy conversions between Value and ConstValue.\n+/// Represents a constant value in Rust. `Scalar` and `ScalarPair` are optimizations that\n+/// match the `LocalState` optimizations for easy conversions between `Value` and `ConstValue`.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash)]\n pub enum ConstValue<'tcx> {\n-    /// Used only for types with layout::abi::Scalar ABI and ZSTs\n+    /// Used only for types with `layout::abi::Scalar` ABI and ZSTs.\n     ///\n-    /// Not using the enum `Value` to encode that this must not be `Undef`\n+    /// Not using the enum `Value` to encode that this must not be `Undef`.\n     Scalar(Scalar),\n \n-    /// Used only for slices and strings (`&[T]`, `&str`, `*const [T]`, `*mut str`, `Box<str>`, ...)\n+    /// Used only for slices and strings (`&[T]`, `&str`, `*const [T]`, `*mut str`, `Box<str>`,\n+    /// etc.).\n     ///\n     /// Empty slices don't necessarily have an address backed by an `AllocId`, thus we also need to\n     /// enable integer pointers. The `Scalar` type covers exactly those two cases. While we could\n     /// create dummy-`AllocId`s, the additional code effort for the conversions doesn't seem worth\n     /// it.\n     Slice(Scalar, u64),\n \n-    /// An allocation + offset into the allocation.\n-    /// Invariant: The AllocId matches the allocation.\n+    /// An allocation together with an offset into the allocation.\n+    /// Invariant: the `AllocId` matches the allocation.\n     ByRef(AllocId, &'tcx Allocation, Size),\n }\n \n@@ -515,7 +516,7 @@ impl<'tcx, Tag> ScalarMaybeUndef<Tag> {\n     }\n }\n \n-impl_stable_hash_for!(enum ::mir::interpret::ScalarMaybeUndef {\n+impl_stable_hash_for!(enum crate::mir::interpret::ScalarMaybeUndef {\n     Scalar(v),\n     Undef\n });"}, {"sha": "3513d652b534672fb31fed9cf33dff7e251e9e6f", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -2,11 +2,11 @@\n //!\n //! [rustc guide]: https://rust-lang.github.io/rustc-guide/mir/index.html\n \n-use hir::def::CtorKind;\n-use hir::def_id::DefId;\n-use hir::{self, HirId, InlineAsm};\n-use mir::interpret::{ConstValue, EvalErrorKind, Scalar};\n-use mir::visit::MirVisitable;\n+use crate::hir::def::CtorKind;\n+use crate::hir::def_id::DefId;\n+use crate::hir::{self, HirId, InlineAsm};\n+use crate::mir::interpret::{ConstValue, EvalErrorKind, Scalar};\n+use crate::mir::visit::MirVisitable;\n use rustc_apfloat::ieee::{Double, Single};\n use rustc_apfloat::Float;\n use rustc_data_structures::fx::FxHashSet;\n@@ -15,7 +15,7 @@ use rustc_data_structures::graph::{self, GraphPredecessors, GraphSuccessors};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::sync::MappedReadGuard;\n-use rustc_serialize::{self as serialize};\n+use crate::rustc_serialize::{self as serialize};\n use smallvec::SmallVec;\n use std::borrow::Cow;\n use std::fmt::{self, Debug, Formatter, Write};\n@@ -26,16 +26,16 @@ use std::{iter, mem, option, u32};\n use syntax::ast::{self, Name};\n use syntax::symbol::InternedString;\n use syntax_pos::{Span, DUMMY_SP};\n-use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n-use ty::subst::{Subst, Substs};\n-use ty::layout::VariantIdx;\n-use ty::{\n+use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n+use crate::ty::subst::{Subst, Substs};\n+use crate::ty::layout::VariantIdx;\n+use crate::ty::{\n     self, AdtDef, CanonicalUserTypeAnnotations, ClosureSubsts, GeneratorSubsts, Region, Ty, TyCtxt,\n     UserTypeAnnotationIndex,\n };\n-use util::ppaux;\n+use crate::util::ppaux;\n \n-pub use mir::interpret::AssertMessage;\n+pub use crate::mir::interpret::AssertMessage;\n \n mod cache;\n pub mod interpret;\n@@ -108,7 +108,7 @@ pub struct Mir<'tcx> {\n     /// in scope, but a separate set of locals.\n     pub promoted: IndexVec<Promoted, Mir<'tcx>>,\n \n-    /// Yield type of the function, if it is a generator.\n+    /// Yields type of the function, if it is a generator.\n     pub yield_ty: Option<Ty<'tcx>>,\n \n     /// Generator drop glue\n@@ -380,7 +380,7 @@ impl<'tcx> Mir<'tcx> {\n         }\n     }\n \n-    /// Check if `sub` is a sub scope of `sup`\n+    /// Checks if `sub` is a sub scope of `sup`\n     pub fn is_sub_scope(&self, mut sub: SourceScope, sup: SourceScope) -> bool {\n         while sub != sup {\n             match self.source_scopes[sub].parent_scope {\n@@ -391,12 +391,12 @@ impl<'tcx> Mir<'tcx> {\n         true\n     }\n \n-    /// Return the return type, it always return first element from `local_decls` array\n+    /// Returns the return type, it always return first element from `local_decls` array\n     pub fn return_ty(&self) -> Ty<'tcx> {\n         self.local_decls[RETURN_PLACE].ty\n     }\n \n-    /// Get the location of the terminator for the given block\n+    /// Gets the location of the terminator for the given block\n     pub fn terminator_loc(&self, bb: BasicBlock) -> Location {\n         Location {\n             block: bb,\n@@ -526,7 +526,7 @@ pub enum BorrowKind {\n     /// We can also report errors with this kind of borrow differently.\n     Shallow,\n \n-    /// Data must be immutable but not aliasable.  This kind of borrow\n+    /// Data must be immutable but not aliasable. This kind of borrow\n     /// cannot currently be expressed by the user and is used only in\n     /// implicit closure bindings. It is needed when the closure is\n     /// borrowing or mutating a mutable referent, e.g.:\n@@ -565,8 +565,8 @@ pub enum BorrowKind {\n \n     /// Data is mutable and not aliasable.\n     Mut {\n-        /// True if this borrow arose from method-call auto-ref\n-        /// (i.e., `adjustment::Adjust::Borrow`)\n+        /// `true` if this borrow arose from method-call auto-ref\n+        /// (i.e., `adjustment::Adjust::Borrow`).\n         allow_two_phase_borrow: bool,\n     },\n }\n@@ -610,7 +610,7 @@ pub struct VarBindingForm<'tcx> {\n     /// If an explicit type was provided for this variable binding,\n     /// this holds the source Span of that type.\n     ///\n-    /// NOTE: If you want to change this to a `HirId`, be wary that\n+    /// NOTE: if you want to change this to a `HirId`, be wary that\n     /// doing so breaks incremental compilation (as of this writing),\n     /// while a `Span` does not cause our tests to fail.\n     pub opt_ty_info: Option<Span>,\n@@ -676,7 +676,7 @@ impl_stable_hash_for!(enum self::MirPhase {\n });\n \n mod binding_form_impl {\n-    use ich::StableHashingContext;\n+    use crate::ich::StableHashingContext;\n     use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n \n     impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for super::BindingForm<'tcx> {\n@@ -737,7 +737,7 @@ pub struct LocalDecl<'tcx> {\n     /// `ClearCrossCrate` as long as it carries as `HirId`.\n     pub is_user_variable: Option<ClearCrossCrate<BindingForm<'tcx>>>,\n \n-    /// True if this is an internal local\n+    /// `true` if this is an internal local.\n     ///\n     /// These locals are not based on types in the source code and are only used\n     /// for a few desugarings at the moment.\n@@ -864,7 +864,7 @@ pub struct LocalDecl<'tcx> {\n }\n \n impl<'tcx> LocalDecl<'tcx> {\n-    /// Returns true only if local is a binding that can itself be\n+    /// Returns `true` only if local is a binding that can itself be\n     /// made mutable via the addition of the `mut` keyword, namely\n     /// something like the occurrences of `x` in:\n     /// - `fn foo(x: Type) { ... }`,\n@@ -886,7 +886,7 @@ impl<'tcx> LocalDecl<'tcx> {\n         }\n     }\n \n-    /// Returns true if local is definitely not a `ref ident` or\n+    /// Returns `true` if local is definitely not a `ref ident` or\n     /// `ref mut ident` binding. (Such bindings cannot be made into\n     /// mutable bindings, but the inverse does not necessarily hold).\n     pub fn is_nonref_binding(&self) -> bool {\n@@ -904,7 +904,7 @@ impl<'tcx> LocalDecl<'tcx> {\n         }\n     }\n \n-    /// Create a new `LocalDecl` for a temporary.\n+    /// Creates a new `LocalDecl` for a temporary.\n     #[inline]\n     pub fn new_temp(ty: Ty<'tcx>, span: Span) -> Self {\n         Self::new_local(ty, Mutability::Mut, false, span)\n@@ -925,7 +925,7 @@ impl<'tcx> LocalDecl<'tcx> {\n         self\n     }\n \n-    /// Create a new `LocalDecl` for a internal temporary.\n+    /// Creates a new `LocalDecl` for a internal temporary.\n     #[inline]\n     pub fn new_internal(ty: Ty<'tcx>, span: Span) -> Self {\n         Self::new_local(ty, Mutability::Mut, true, span)\n@@ -1019,7 +1019,7 @@ pub struct BasicBlockData<'tcx> {\n \n     /// Terminator for this block.\n     ///\n-    /// NB. This should generally ONLY be `None` during construction.\n+    /// N.B., this should generally ONLY be `None` during construction.\n     /// Therefore, you should generally access it via the\n     /// `terminator()` or `terminator_mut()` methods. The only\n     /// exception is that certain passes, such as `simplify_cfg`, swap\n@@ -1637,7 +1637,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n         }\n     }\n \n-    /// Return the list of labels for the edges to the successor basic blocks.\n+    /// Returns the list of labels for the edges to the successor basic blocks.\n     pub fn fmt_successor_labels(&self) -> Vec<Cow<'static, str>> {\n         use self::TerminatorKind::*;\n         match *self {\n@@ -1760,7 +1760,7 @@ pub enum StatementKind<'tcx> {\n     /// error messages to these specific patterns.\n     ///\n     /// Note that this also is emitted for regular `let` bindings to ensure that locals that are\n-    /// never accessed still get some sanity checks for e.g. `let x: ! = ..;`\n+    /// never accessed still get some sanity checks for, e.g., `let x: ! = ..;`\n     FakeRead(FakeReadCause, Place<'tcx>),\n \n     /// Write the discriminant for a variant to the enum Place.\n@@ -1775,14 +1775,14 @@ pub enum StatementKind<'tcx> {\n     /// End the current live range for the storage of the local.\n     StorageDead(Local),\n \n-    /// Execute a piece of inline Assembly.\n+    /// Executes a piece of inline Assembly.\n     InlineAsm {\n         asm: Box<InlineAsm>,\n         outputs: Box<[Place<'tcx>]>,\n         inputs: Box<[(Span, Operand<'tcx>)]>,\n     },\n \n-    /// Retag references in the given place, ensuring they got fresh tags.  This is\n+    /// Retag references in the given place, ensuring they got fresh tags. This is\n     /// part of the Stacked Borrows model. These statements are currently only interpreted\n     /// by miri and only generated when \"-Z mir-emit-retag\" is passed.\n     /// See <https://internals.rust-lang.org/t/stacked-borrows-an-aliasing-model-for-rust/8153/>\n@@ -1904,7 +1904,7 @@ pub enum Place<'tcx> {\n     Projection(Box<PlaceProjection<'tcx>>),\n }\n \n-/// The def-id of a static, along with its normalized type (which is\n+/// The `DefId` of a static, along with its normalized type (which is\n /// stored to avoid requiring normalization when reading MIR).\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub struct Static<'tcx> {\n@@ -2009,10 +2009,10 @@ impl<'tcx> Place<'tcx> {\n         Place::Projection(Box::new(PlaceProjection { base: self, elem }))\n     }\n \n-    /// Find the innermost `Local` from this `Place`, *if* it is either a local itself or\n+    /// Finds the innermost `Local` from this `Place`, *if* it is either a local itself or\n     /// a single deref of a local.\n-    ///\n-    /// FIXME: can we safely swap the semantics of `fn base_local` below in here instead?\n+    //\n+    // FIXME: can we safely swap the semantics of `fn base_local` below in here instead?\n     pub fn local(&self) -> Option<Local> {\n         match self {\n             Place::Local(local) |\n@@ -2024,7 +2024,7 @@ impl<'tcx> Place<'tcx> {\n         }\n     }\n \n-    /// Find the innermost `Local` from this `Place`.\n+    /// Finds the innermost `Local` from this `Place`.\n     pub fn base_local(&self) -> Option<Local> {\n         match self {\n             Place::Local(local) => Some(*local),\n@@ -2141,7 +2141,7 @@ impl<'tcx> Debug for Operand<'tcx> {\n \n impl<'tcx> Operand<'tcx> {\n     /// Convenience helper to make a constant that refers to the fn\n-    /// with given def-id and substs. Since this is used to synthesize\n+    /// with given `DefId` and substs. Since this is used to synthesize\n     /// MIR, assumes `user_ty` is None.\n     pub fn function_handle<'a>(\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -2154,7 +2154,7 @@ impl<'tcx> Operand<'tcx> {\n             span,\n             ty,\n             user_ty: None,\n-            literal: tcx.intern_lazy_const(\n+            literal: tcx.mk_lazy_const(\n                 ty::LazyConst::Evaluated(ty::Const::zero_sized(ty)),\n             ),\n         })\n@@ -2199,7 +2199,7 @@ pub enum Rvalue<'tcx> {\n     /// be defined to return, say, a 0) if ADT is not an enum.\n     Discriminant(Place<'tcx>),\n \n-    /// Create an aggregate value, like a tuple or struct.  This is\n+    /// Creates an aggregate value, like a tuple or struct. This is\n     /// only needed because we want to distinguish `dest = Foo { x:\n     /// ..., y: ... }` from `dest.x = ...; dest.y = ...;` in the case\n     /// that `Foo` has a destructor. These rvalues can be optimized\n@@ -2211,13 +2211,13 @@ pub enum Rvalue<'tcx> {\n pub enum CastKind {\n     Misc,\n \n-    /// Convert unique, zero-sized type for a fn to fn()\n+    /// Converts unique, zero-sized type for a fn to fn()\n     ReifyFnPointer,\n \n-    /// Convert non capturing closure to fn()\n+    /// Converts non capturing closure to fn()\n     ClosureFnPointer,\n \n-    /// Convert safe fn() to unsafe fn()\n+    /// Converts safe fn() to unsafe fn()\n     UnsafeFnPointer,\n \n     /// \"Unsize\" -- convert a thin-or-fat pointer to a fat pointer.\n@@ -2301,9 +2301,9 @@ impl BinOp {\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub enum NullOp {\n-    /// Return the size of a value of that type\n+    /// Returns the size of a value of that type\n     SizeOf,\n-    /// Create a new uninitialized box for a value of that type\n+    /// Creates a new uninitialized box for a value of that type\n     Box,\n }\n \n@@ -2625,7 +2625,7 @@ CloneTypeFoldableAndLiftImpls! { ProjectionKind<'tcx>, }\n \n impl<'tcx> TypeFoldable<'tcx> for UserTypeProjection<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        use mir::ProjectionElem::*;\n+        use crate::mir::ProjectionElem::*;\n \n         let base = self.base.fold_with(folder);\n         let projs: Vec<_> = self.projs\n@@ -2671,7 +2671,7 @@ pub fn fmt_lazy_const_val(f: &mut impl Write, const_val: &ty::LazyConst<'_>) ->\n \n /// Write a `ConstValue` in a way closer to the original source code than the `Debug` output.\n pub fn fmt_const_val(f: &mut impl Write, const_val: ty::Const<'_>) -> fmt::Result {\n-    use ty::TyKind::*;\n+    use crate::ty::TyKind::*;\n     let value = const_val.val;\n     let ty = const_val.ty;\n     // print some primitives\n@@ -2847,7 +2847,7 @@ impl Location {\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum UnsafetyViolationKind {\n     General,\n-    /// Permitted in const fn and regular fns\n+    /// Permitted in const fn and regular fns.\n     GeneralAndConstFn,\n     ExternStatic(ast::NodeId),\n     BorrowPacked(ast::NodeId),\n@@ -2884,7 +2884,7 @@ pub struct BorrowCheckResult<'gcx> {\n \n /// After we borrow check a closure, we are left with various\n /// requirements that we have inferred between the free regions that\n-/// appear in the closure's signature or on its field types.  These\n+/// appear in the closure's signature or on its field types. These\n /// requirements are then verified and proved by the closure's\n /// creating function. This struct encodes those requirements.\n ///\n@@ -2934,7 +2934,7 @@ pub struct BorrowCheckResult<'gcx> {\n /// internally within the rest of the NLL code).\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct ClosureRegionRequirements<'gcx> {\n-    /// The number of external regions defined on the closure.  In our\n+    /// The number of external regions defined on the closure. In our\n     /// example above, it would be 3 -- one for `'static`, then `'1`\n     /// and `'2`. This is just used for a sanity check later on, to\n     /// make sure that the number of regions we see at the callsite\n@@ -3116,7 +3116,7 @@ EnumTypeFoldableImpl! {\n \n impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        use mir::TerminatorKind::*;\n+        use crate::mir::TerminatorKind::*;\n \n         let kind = match self.kind {\n             Goto { target } => Goto { target },\n@@ -3229,7 +3229,7 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        use mir::TerminatorKind::*;\n+        use crate::mir::TerminatorKind::*;\n \n         match self.kind {\n             SwitchInt {\n@@ -3301,7 +3301,7 @@ impl<'tcx> TypeFoldable<'tcx> for Place<'tcx> {\n \n impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        use mir::Rvalue::*;\n+        use crate::mir::Rvalue::*;\n         match *self {\n             Use(ref op) => Use(op.fold_with(folder)),\n             Repeat(ref op, len) => Repeat(op.fold_with(folder), len),\n@@ -3343,7 +3343,7 @@ impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        use mir::Rvalue::*;\n+        use crate::mir::Rvalue::*;\n         match *self {\n             Use(ref op) => op.visit_with(visitor),\n             Repeat(ref op, _) => op.visit_with(visitor),\n@@ -3395,7 +3395,7 @@ where\n     T: TypeFoldable<'tcx>,\n {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        use mir::ProjectionElem::*;\n+        use crate::mir::ProjectionElem::*;\n \n         let base = self.base.fold_with(folder);\n         let elem = match self.elem {\n@@ -3409,7 +3409,7 @@ where\n     }\n \n     fn super_visit_with<Vs: TypeVisitor<'tcx>>(&self, visitor: &mut Vs) -> bool {\n-        use mir::ProjectionElem::*;\n+        use crate::mir::ProjectionElem::*;\n \n         self.base.visit_with(visitor) || match self.elem {\n             Field(_, ref ty) => ty.visit_with(visitor),"}, {"sha": "2296fe5763c94740f291d7c7149254475dfae726", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,12 +1,12 @@\n-use hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n+use crate::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n use syntax::ast::NodeId;\n use syntax::symbol::{Symbol, InternedString};\n-use ty::{Instance, TyCtxt};\n-use util::nodemap::FxHashMap;\n+use crate::ty::{Instance, TyCtxt};\n+use crate::util::nodemap::FxHashMap;\n use rustc_data_structures::base_n;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasherResult,\n                                            StableHasher};\n-use ich::{Fingerprint, StableHashingContext, NodeIdHashingMode};\n+use crate::ich::{Fingerprint, StableHashingContext, NodeIdHashingMode};\n use std::fmt;\n use std::hash::Hash;\n \n@@ -57,7 +57,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for MonoItem<'tcx> {\n \n pub struct CodegenUnit<'tcx> {\n     /// A name for this CGU. Incremental compilation requires that\n-    /// name be unique amongst **all** crates.  Therefore, it should\n+    /// name be unique amongst **all** crates. Therefore, it should\n     /// contain something unique to this crate (e.g., a module path)\n     /// as well as the crate name and disambiguator.\n     name: InternedString,"}, {"sha": "bf4ac7496d2e76e25c929afcb45d9a857a8d646e", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -3,12 +3,12 @@\n  * building is complete.\n  */\n \n-use mir::*;\n-use ty::subst::{Subst, Substs};\n-use ty::{self, AdtDef, Ty, TyCtxt};\n-use ty::layout::VariantIdx;\n-use hir;\n-use ty::util::IntTypeExt;\n+use crate::mir::*;\n+use crate::ty::subst::{Subst, Substs};\n+use crate::ty::{self, AdtDef, Ty, TyCtxt};\n+use crate::ty::layout::VariantIdx;\n+use crate::hir;\n+use crate::ty::util::IntTypeExt;\n \n #[derive(Copy, Clone, Debug)]\n pub enum PlaceTy<'tcx> {\n@@ -278,7 +278,7 @@ impl<'tcx> Rvalue<'tcx> {\n     }\n \n     #[inline]\n-    /// Returns whether this rvalue is deeply initialized (most rvalues) or\n+    /// Returns `true` if this rvalue is deeply initialized (most rvalues) or\n     /// whether its only shallowly initialized (`Rvalue::Box`).\n     pub fn initialization_state(&self) -> RvalueInitializationState {\n         match *self {"}, {"sha": "e5828039ac29cb33fb1510aa05359a75a9a7a7d4", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 225, "deletions": 235, "changes": 460, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,7 +1,7 @@\n-use hir::def_id::DefId;\n-use ty::subst::Substs;\n-use ty::{CanonicalUserTypeAnnotation, ClosureSubsts, GeneratorSubsts, Region, Ty};\n-use mir::*;\n+use crate::hir::def_id::DefId;\n+use crate::ty::subst::Substs;\n+use crate::ty::{CanonicalUserTypeAnnotation, ClosureSubsts, GeneratorSubsts, Region, Ty};\n+use crate::mir::*;\n use syntax_pos::Span;\n \n // # The MIR Visitor\n@@ -38,10 +38,10 @@ use syntax_pos::Span;\n // ```rust\n // fn super_basic_block_data(&mut self,\n //                           block: BasicBlock,\n-//                           data: & $($mutability)* BasicBlockData<'tcx>) {\n+//                           data: & $($mutability)? BasicBlockData<'tcx>) {\n //     let BasicBlockData {\n-//         ref $($mutability)* statements,\n-//         ref $($mutability)* terminator,\n+//         statements,\n+//         terminator,\n //         is_cleanup: _\n //     } = *data;\n //\n@@ -67,111 +67,111 @@ use syntax_pos::Span;\n // `is_cleanup` above.\n \n macro_rules! make_mir_visitor {\n-    ($visitor_trait_name:ident, $($mutability:ident)*) => {\n+    ($visitor_trait_name:ident, $($mutability:ident)?) => {\n         pub trait $visitor_trait_name<'tcx> {\n             // Override these, and call `self.super_xxx` to revert back to the\n             // default behavior.\n \n-            fn visit_mir(&mut self, mir: & $($mutability)* Mir<'tcx>) {\n+            fn visit_mir(&mut self, mir: & $($mutability)? Mir<'tcx>) {\n                 self.super_mir(mir);\n             }\n \n             fn visit_basic_block_data(&mut self,\n                                       block: BasicBlock,\n-                                      data: & $($mutability)* BasicBlockData<'tcx>) {\n+                                      data: & $($mutability)? BasicBlockData<'tcx>) {\n                 self.super_basic_block_data(block, data);\n             }\n \n             fn visit_source_scope_data(&mut self,\n-                                           scope_data: & $($mutability)* SourceScopeData) {\n+                                           scope_data: & $($mutability)? SourceScopeData) {\n                 self.super_source_scope_data(scope_data);\n             }\n \n             fn visit_statement(&mut self,\n                                block: BasicBlock,\n-                               statement: & $($mutability)* Statement<'tcx>,\n+                               statement: & $($mutability)? Statement<'tcx>,\n                                location: Location) {\n                 self.super_statement(block, statement, location);\n             }\n \n             fn visit_assign(&mut self,\n                             block: BasicBlock,\n-                            place: & $($mutability)* Place<'tcx>,\n-                            rvalue: & $($mutability)* Rvalue<'tcx>,\n+                            place: & $($mutability)? Place<'tcx>,\n+                            rvalue: & $($mutability)? Rvalue<'tcx>,\n                             location: Location) {\n                 self.super_assign(block, place, rvalue, location);\n             }\n \n             fn visit_terminator(&mut self,\n                                 block: BasicBlock,\n-                                terminator: & $($mutability)* Terminator<'tcx>,\n+                                terminator: & $($mutability)? Terminator<'tcx>,\n                                 location: Location) {\n                 self.super_terminator(block, terminator, location);\n             }\n \n             fn visit_terminator_kind(&mut self,\n                                      block: BasicBlock,\n-                                     kind: & $($mutability)* TerminatorKind<'tcx>,\n+                                     kind: & $($mutability)? TerminatorKind<'tcx>,\n                                      location: Location) {\n                 self.super_terminator_kind(block, kind, location);\n             }\n \n             fn visit_assert_message(&mut self,\n-                                    msg: & $($mutability)* AssertMessage<'tcx>,\n+                                    msg: & $($mutability)? AssertMessage<'tcx>,\n                                     location: Location) {\n                 self.super_assert_message(msg, location);\n             }\n \n             fn visit_rvalue(&mut self,\n-                            rvalue: & $($mutability)* Rvalue<'tcx>,\n+                            rvalue: & $($mutability)? Rvalue<'tcx>,\n                             location: Location) {\n                 self.super_rvalue(rvalue, location);\n             }\n \n             fn visit_operand(&mut self,\n-                             operand: & $($mutability)* Operand<'tcx>,\n+                             operand: & $($mutability)? Operand<'tcx>,\n                              location: Location) {\n                 self.super_operand(operand, location);\n             }\n \n             fn visit_ascribe_user_ty(&mut self,\n-                                     place: & $($mutability)* Place<'tcx>,\n-                                     variance: & $($mutability)* ty::Variance,\n-                                     user_ty: & $($mutability)* UserTypeProjection<'tcx>,\n+                                     place: & $($mutability)? Place<'tcx>,\n+                                     variance: & $($mutability)? ty::Variance,\n+                                     user_ty: & $($mutability)? UserTypeProjection<'tcx>,\n                                      location: Location) {\n                 self.super_ascribe_user_ty(place, variance, user_ty, location);\n             }\n \n             fn visit_retag(&mut self,\n-                           kind: & $($mutability)* RetagKind,\n-                           place: & $($mutability)* Place<'tcx>,\n+                           kind: & $($mutability)? RetagKind,\n+                           place: & $($mutability)? Place<'tcx>,\n                            location: Location) {\n                 self.super_retag(kind, place, location);\n             }\n \n             fn visit_place(&mut self,\n-                            place: & $($mutability)* Place<'tcx>,\n+                            place: & $($mutability)? Place<'tcx>,\n                             context: PlaceContext<'tcx>,\n                             location: Location) {\n                 self.super_place(place, context, location);\n             }\n \n             fn visit_static(&mut self,\n-                            static_: & $($mutability)* Static<'tcx>,\n+                            static_: & $($mutability)? Static<'tcx>,\n                             context: PlaceContext<'tcx>,\n                             location: Location) {\n                 self.super_static(static_, context, location);\n             }\n \n             fn visit_projection(&mut self,\n-                                place: & $($mutability)* PlaceProjection<'tcx>,\n+                                place: & $($mutability)? PlaceProjection<'tcx>,\n                                 context: PlaceContext<'tcx>,\n                                 location: Location) {\n                 self.super_projection(place, context, location);\n             }\n \n             fn visit_projection_elem(&mut self,\n-                                     place: & $($mutability)* PlaceElem<'tcx>,\n+                                     place: & $($mutability)? PlaceElem<'tcx>,\n                                      location: Location) {\n                 self.super_projection_elem(place, location);\n             }\n@@ -183,101 +183,101 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn visit_constant(&mut self,\n-                              constant: & $($mutability)* Constant<'tcx>,\n+                              constant: & $($mutability)? Constant<'tcx>,\n                               location: Location) {\n                 self.super_constant(constant, location);\n             }\n \n             fn visit_def_id(&mut self,\n-                            def_id: & $($mutability)* DefId,\n+                            def_id: & $($mutability)? DefId,\n                             _: Location) {\n                 self.super_def_id(def_id);\n             }\n \n             fn visit_span(&mut self,\n-                          span: & $($mutability)* Span) {\n+                          span: & $($mutability)? Span) {\n                 self.super_span(span);\n             }\n \n             fn visit_source_info(&mut self,\n-                                 source_info: & $($mutability)* SourceInfo) {\n+                                 source_info: & $($mutability)? SourceInfo) {\n                 self.super_source_info(source_info);\n             }\n \n             fn visit_ty(&mut self,\n-                        ty: & $($mutability)* Ty<'tcx>,\n+                        ty: & $($mutability)? Ty<'tcx>,\n                         _: TyContext) {\n                 self.super_ty(ty);\n             }\n \n             fn visit_user_type_projection(\n                 &mut self,\n-                ty: & $($mutability)* UserTypeProjection<'tcx>,\n+                ty: & $($mutability)? UserTypeProjection<'tcx>,\n             ) {\n                 self.super_user_type_projection(ty);\n             }\n \n             fn visit_user_type_annotation(\n                 &mut self,\n                 index: UserTypeAnnotationIndex,\n-                ty: & $($mutability)* CanonicalUserTypeAnnotation<'tcx>,\n+                ty: & $($mutability)? CanonicalUserTypeAnnotation<'tcx>,\n             ) {\n                 self.super_user_type_annotation(index, ty);\n             }\n \n             fn visit_region(&mut self,\n-                            region: & $($mutability)* ty::Region<'tcx>,\n+                            region: & $($mutability)? ty::Region<'tcx>,\n                             _: Location) {\n                 self.super_region(region);\n             }\n \n             fn visit_const(&mut self,\n-                           constant: & $($mutability)* &'tcx ty::LazyConst<'tcx>,\n+                           constant: & $($mutability)? &'tcx ty::LazyConst<'tcx>,\n                            _: Location) {\n                 self.super_const(constant);\n             }\n \n             fn visit_substs(&mut self,\n-                            substs: & $($mutability)* &'tcx Substs<'tcx>,\n+                            substs: & $($mutability)? &'tcx Substs<'tcx>,\n                             _: Location) {\n                 self.super_substs(substs);\n             }\n \n             fn visit_closure_substs(&mut self,\n-                                    substs: & $($mutability)* ClosureSubsts<'tcx>,\n+                                    substs: & $($mutability)? ClosureSubsts<'tcx>,\n                                     _: Location) {\n                 self.super_closure_substs(substs);\n             }\n \n             fn visit_generator_substs(&mut self,\n-                                      substs: & $($mutability)* GeneratorSubsts<'tcx>,\n+                                      substs: & $($mutability)? GeneratorSubsts<'tcx>,\n                                     _: Location) {\n                 self.super_generator_substs(substs);\n             }\n \n             fn visit_local_decl(&mut self,\n                                 local: Local,\n-                                local_decl: & $($mutability)* LocalDecl<'tcx>) {\n+                                local_decl: & $($mutability)? LocalDecl<'tcx>) {\n                 self.super_local_decl(local, local_decl);\n             }\n \n             fn visit_local(&mut self,\n-                            _local: & $($mutability)* Local,\n+                            _local: & $($mutability)? Local,\n                             _context: PlaceContext<'tcx>,\n                             _location: Location) {\n             }\n \n             fn visit_source_scope(&mut self,\n-                                      scope: & $($mutability)* SourceScope) {\n+                                      scope: & $($mutability)? SourceScope) {\n                 self.super_source_scope(scope);\n             }\n \n             // The `super_xxx` methods comprise the default behavior and are\n             // not meant to be overridden.\n \n             fn super_mir(&mut self,\n-                         mir: & $($mutability)* Mir<'tcx>) {\n-                if let Some(yield_ty) = &$($mutability)* mir.yield_ty {\n+                         mir: & $($mutability)? Mir<'tcx>) {\n+                if let Some(yield_ty) = &$($mutability)? mir.yield_ty {\n                     self.visit_ty(yield_ty, TyContext::YieldTy(SourceInfo {\n                         span: mir.span,\n                         scope: OUTERMOST_SOURCE_SCOPE,\n@@ -291,45 +291,45 @@ macro_rules! make_mir_visitor {\n                     (mut) => (mir.basic_blocks_mut().iter_enumerated_mut());\n                     () => (mir.basic_blocks().iter_enumerated());\n                 };\n-                for (bb, data) in basic_blocks!($($mutability)*) {\n+                for (bb, data) in basic_blocks!($($mutability)?) {\n                     self.visit_basic_block_data(bb, data);\n                 }\n \n-                for scope in &$($mutability)* mir.source_scopes {\n+                for scope in &$($mutability)? mir.source_scopes {\n                     self.visit_source_scope_data(scope);\n                 }\n \n-                self.visit_ty(&$($mutability)* mir.return_ty(), TyContext::ReturnTy(SourceInfo {\n+                self.visit_ty(&$($mutability)? mir.return_ty(), TyContext::ReturnTy(SourceInfo {\n                     span: mir.span,\n                     scope: OUTERMOST_SOURCE_SCOPE,\n                 }));\n \n                 for local in mir.local_decls.indices() {\n-                    self.visit_local_decl(local, & $($mutability)* mir.local_decls[local]);\n+                    self.visit_local_decl(local, & $($mutability)? mir.local_decls[local]);\n                 }\n \n                 macro_rules! type_annotations {\n                     (mut) => (mir.user_type_annotations.iter_enumerated_mut());\n                     () => (mir.user_type_annotations.iter_enumerated());\n                 };\n \n-                for (index, annotation) in type_annotations!($($mutability)*) {\n+                for (index, annotation) in type_annotations!($($mutability)?) {\n                     self.visit_user_type_annotation(\n                         index, annotation\n                     );\n                 }\n \n-                self.visit_span(&$($mutability)* mir.span);\n+                self.visit_span(&$($mutability)? mir.span);\n             }\n \n             fn super_basic_block_data(&mut self,\n                                       block: BasicBlock,\n-                                      data: & $($mutability)* BasicBlockData<'tcx>) {\n+                                      data: & $($mutability)? BasicBlockData<'tcx>) {\n                 let BasicBlockData {\n-                    ref $($mutability)* statements,\n-                    ref $($mutability)* terminator,\n+                    statements,\n+                    terminator,\n                     is_cleanup: _\n-                } = *data;\n+                } = data;\n \n                 let mut index = 0;\n                 for statement in statements {\n@@ -338,92 +338,83 @@ macro_rules! make_mir_visitor {\n                     index += 1;\n                 }\n \n-                if let Some(ref $($mutability)* terminator) = *terminator {\n+                if let Some(terminator) = terminator {\n                     let location = Location { block: block, statement_index: index };\n                     self.visit_terminator(block, terminator, location);\n                 }\n             }\n \n-            fn super_source_scope_data(&mut self,\n-                                           scope_data: & $($mutability)* SourceScopeData) {\n+            fn super_source_scope_data(&mut self, scope_data: & $($mutability)? SourceScopeData) {\n                 let SourceScopeData {\n-                    ref $($mutability)* span,\n-                    ref $($mutability)* parent_scope,\n-                } = *scope_data;\n+                    span,\n+                    parent_scope,\n+                } = scope_data;\n \n                 self.visit_span(span);\n-                if let Some(ref $($mutability)* parent_scope) = *parent_scope {\n+                if let Some(parent_scope) = parent_scope {\n                     self.visit_source_scope(parent_scope);\n                 }\n             }\n \n             fn super_statement(&mut self,\n                                block: BasicBlock,\n-                               statement: & $($mutability)* Statement<'tcx>,\n+                               statement: & $($mutability)? Statement<'tcx>,\n                                location: Location) {\n                 let Statement {\n-                    ref $($mutability)* source_info,\n-                    ref $($mutability)* kind,\n-                } = *statement;\n+                    source_info,\n+                    kind,\n+                } = statement;\n \n                 self.visit_source_info(source_info);\n-                match *kind {\n-                    StatementKind::Assign(ref $($mutability)* place,\n-                                          ref $($mutability)* rvalue) => {\n+                match kind {\n+                    StatementKind::Assign(place, rvalue) => {\n                         self.visit_assign(block, place, rvalue, location);\n                     }\n-                    StatementKind::FakeRead(_, ref $($mutability)* place) => {\n+                    StatementKind::FakeRead(_, place) => {\n                         self.visit_place(\n                             place,\n                             PlaceContext::NonMutatingUse(NonMutatingUseContext::Inspect),\n                             location\n                         );\n                     }\n-                    StatementKind::SetDiscriminant{ ref $($mutability)* place, .. } => {\n+                    StatementKind::SetDiscriminant { place, .. } => {\n                         self.visit_place(\n                             place,\n                             PlaceContext::MutatingUse(MutatingUseContext::Store),\n                             location\n                         );\n                     }\n-                    StatementKind::StorageLive(ref $($mutability)* local) => {\n+                    StatementKind::StorageLive(local) => {\n                         self.visit_local(\n                             local,\n                             PlaceContext::NonUse(NonUseContext::StorageLive),\n                             location\n                         );\n                     }\n-                    StatementKind::StorageDead(ref $($mutability)* local) => {\n+                    StatementKind::StorageDead(local) => {\n                         self.visit_local(\n                             local,\n                             PlaceContext::NonUse(NonUseContext::StorageDead),\n                             location\n                         );\n                     }\n-                    StatementKind::InlineAsm { ref $($mutability)* outputs,\n-                                               ref $($mutability)* inputs,\n-                                               asm: _ } => {\n-                        for output in & $($mutability)* outputs[..] {\n+                    StatementKind::InlineAsm { outputs, inputs, asm: _ } => {\n+                        for output in & $($mutability)? outputs[..] {\n                             self.visit_place(\n                                 output,\n                                 PlaceContext::MutatingUse(MutatingUseContext::AsmOutput),\n                                 location\n                             );\n                         }\n-                        for (span, input) in & $($mutability)* inputs[..] {\n+                        for (span, input) in & $($mutability)? inputs[..] {\n                             self.visit_span(span);\n                             self.visit_operand(input, location);\n                         }\n                     }\n-                    StatementKind::Retag ( ref $($mutability)* kind,\n-                                           ref $($mutability)* place ) => {\n+                    StatementKind::Retag(kind, place) => {\n                         self.visit_retag(kind, place, location);\n                     }\n-                    StatementKind::AscribeUserType(\n-                        ref $($mutability)* place,\n-                        ref $($mutability)* variance,\n-                        ref $($mutability)* user_ty,\n-                    ) => {\n+                    StatementKind::AscribeUserType(place, variance, user_ty) => {\n                         self.visit_ascribe_user_ty(place, variance, user_ty, location);\n                     }\n                     StatementKind::Nop => {}\n@@ -432,8 +423,8 @@ macro_rules! make_mir_visitor {\n \n             fn super_assign(&mut self,\n                             _block: BasicBlock,\n-                            place: &$($mutability)* Place<'tcx>,\n-                            rvalue: &$($mutability)* Rvalue<'tcx>,\n+                            place: &$($mutability)? Place<'tcx>,\n+                            rvalue: &$($mutability)? Rvalue<'tcx>,\n                             location: Location) {\n                 self.visit_place(\n                     place,\n@@ -445,34 +436,33 @@ macro_rules! make_mir_visitor {\n \n             fn super_terminator(&mut self,\n                                 block: BasicBlock,\n-                                terminator: &$($mutability)* Terminator<'tcx>,\n+                                terminator: &$($mutability)? Terminator<'tcx>,\n                                 location: Location) {\n-                let Terminator {\n-                    ref $($mutability)* source_info,\n-                    ref $($mutability)* kind,\n-                } = *terminator;\n+                let Terminator { source_info, kind } = terminator;\n \n                 self.visit_source_info(source_info);\n                 self.visit_terminator_kind(block, kind, location);\n             }\n \n             fn super_terminator_kind(&mut self,\n                                      block: BasicBlock,\n-                                     kind: & $($mutability)* TerminatorKind<'tcx>,\n+                                     kind: & $($mutability)? TerminatorKind<'tcx>,\n                                      source_location: Location) {\n-                match *kind {\n+                match kind {\n                     TerminatorKind::Goto { target } => {\n-                        self.visit_branch(block, target);\n+                        self.visit_branch(block, *target);\n                     }\n \n-                    TerminatorKind::SwitchInt { ref $($mutability)* discr,\n-                                                ref $($mutability)* switch_ty,\n-                                                values: _,\n-                                                ref targets } => {\n+                    TerminatorKind::SwitchInt {\n+                        discr,\n+                        switch_ty,\n+                        values: _,\n+                        targets\n+                    } => {\n                         self.visit_operand(discr, source_location);\n                         self.visit_ty(switch_ty, TyContext::Location(source_location));\n-                        for &target in targets {\n-                            self.visit_branch(block, target);\n+                        for target in targets {\n+                            self.visit_branch(block, *target);\n                         }\n                     }\n \n@@ -483,113 +473,120 @@ macro_rules! make_mir_visitor {\n                     TerminatorKind::Unreachable => {\n                     }\n \n-                    TerminatorKind::Drop { ref $($mutability)* location,\n-                                           target,\n-                                           unwind } => {\n+                    TerminatorKind::Drop {\n+                        location,\n+                        target,\n+                        unwind,\n+                    } => {\n                         self.visit_place(\n                             location,\n                             PlaceContext::MutatingUse(MutatingUseContext::Drop),\n                             source_location\n                         );\n-                        self.visit_branch(block, target);\n+                        self.visit_branch(block, *target);\n                         unwind.map(|t| self.visit_branch(block, t));\n                     }\n \n-                    TerminatorKind::DropAndReplace { ref $($mutability)* location,\n-                                                     ref $($mutability)* value,\n-                                                     target,\n-                                                     unwind } => {\n+                    TerminatorKind::DropAndReplace {\n+                        location,\n+                        value,\n+                        target,\n+                        unwind,\n+                    } => {\n                         self.visit_place(\n                             location,\n                             PlaceContext::MutatingUse(MutatingUseContext::Drop),\n                             source_location\n                         );\n                         self.visit_operand(value, source_location);\n-                        self.visit_branch(block, target);\n+                        self.visit_branch(block, *target);\n                         unwind.map(|t| self.visit_branch(block, t));\n                     }\n \n-                    TerminatorKind::Call { ref $($mutability)* func,\n-                                           ref $($mutability)* args,\n-                                           ref $($mutability)* destination,\n-                                           cleanup,\n-                                           from_hir_call: _, } => {\n+                    TerminatorKind::Call {\n+                        func,\n+                        args,\n+                        destination,\n+                        cleanup,\n+                        from_hir_call: _,\n+                    } => {\n                         self.visit_operand(func, source_location);\n                         for arg in args {\n                             self.visit_operand(arg, source_location);\n                         }\n-                        if let Some((ref $($mutability)* destination, target)) = *destination {\n+                        if let Some((destination, target)) = destination {\n                             self.visit_place(\n                                 destination,\n                                 PlaceContext::MutatingUse(MutatingUseContext::Call),\n                                 source_location\n                             );\n-                            self.visit_branch(block, target);\n+                            self.visit_branch(block, *target);\n                         }\n                         cleanup.map(|t| self.visit_branch(block, t));\n                     }\n \n-                    TerminatorKind::Assert { ref $($mutability)* cond,\n-                                             expected: _,\n-                                             ref $($mutability)* msg,\n-                                             target,\n-                                             cleanup } => {\n+                    TerminatorKind::Assert {\n+                        cond,\n+                        expected: _,\n+                        msg,\n+                        target,\n+                        cleanup,\n+                    } => {\n                         self.visit_operand(cond, source_location);\n                         self.visit_assert_message(msg, source_location);\n-                        self.visit_branch(block, target);\n+                        self.visit_branch(block, *target);\n                         cleanup.map(|t| self.visit_branch(block, t));\n                     }\n \n-                    TerminatorKind::Yield { ref $($mutability)* value,\n-                                              resume,\n-                                              drop } => {\n+                    TerminatorKind::Yield {\n+                        value,\n+                        resume,\n+                        drop,\n+                    } => {\n                         self.visit_operand(value, source_location);\n-                        self.visit_branch(block, resume);\n+                        self.visit_branch(block, *resume);\n                         drop.map(|t| self.visit_branch(block, t));\n                     }\n \n-                    TerminatorKind::FalseEdges { real_target, ref imaginary_targets} => {\n-                        self.visit_branch(block, real_target);\n+                    TerminatorKind::FalseEdges { real_target, imaginary_targets } => {\n+                        self.visit_branch(block, *real_target);\n                         for target in imaginary_targets {\n                             self.visit_branch(block, *target);\n                         }\n                     }\n \n                     TerminatorKind::FalseUnwind { real_target, unwind } => {\n-                        self.visit_branch(block, real_target);\n+                        self.visit_branch(block, *real_target);\n                         if let Some(unwind) = unwind {\n-                            self.visit_branch(block, unwind);\n+                            self.visit_branch(block, *unwind);\n                         }\n                     }\n                 }\n             }\n \n             fn super_assert_message(&mut self,\n-                                    msg: & $($mutability)* AssertMessage<'tcx>,\n+                                    msg: & $($mutability)? AssertMessage<'tcx>,\n                                     location: Location) {\n-                use mir::interpret::EvalErrorKind::*;\n-                if let BoundsCheck {\n-                        ref $($mutability)* len,\n-                        ref $($mutability)* index\n-                    } = *msg {\n+                use crate::mir::interpret::EvalErrorKind::*;\n+                if let BoundsCheck { len, index } = msg {\n                     self.visit_operand(len, location);\n                     self.visit_operand(index, location);\n                 }\n             }\n \n             fn super_rvalue(&mut self,\n-                            rvalue: & $($mutability)* Rvalue<'tcx>,\n+                            rvalue: & $($mutability)? Rvalue<'tcx>,\n                             location: Location) {\n-                match *rvalue {\n-                    Rvalue::Use(ref $($mutability)* operand) => {\n+                match rvalue {\n+                    Rvalue::Use(operand) => {\n                         self.visit_operand(operand, location);\n                     }\n \n-                    Rvalue::Repeat(ref $($mutability)* value, _) => {\n+                    Rvalue::Repeat(value, _) => {\n                         self.visit_operand(value, location);\n                     }\n \n-                    Rvalue::Ref(ref $($mutability)* r, bk, ref $($mutability)* path) => {\n+                    Rvalue::Ref(r, bk, path) => {\n                         self.visit_region(r, location);\n                         let ctx = match bk {\n                             BorrowKind::Shared => PlaceContext::NonMutatingUse(\n@@ -607,71 +604,70 @@ macro_rules! make_mir_visitor {\n                         self.visit_place(path, ctx, location);\n                     }\n \n-                    Rvalue::Len(ref $($mutability)* path) => {\n+                    Rvalue::Len(path) => {\n                         self.visit_place(\n                             path,\n                             PlaceContext::NonMutatingUse(NonMutatingUseContext::Inspect),\n                             location\n                         );\n                     }\n \n-                    Rvalue::Cast(_cast_kind,\n-                                 ref $($mutability)* operand,\n-                                 ref $($mutability)* ty) => {\n+                    Rvalue::Cast(_cast_kind, operand, ty) => {\n                         self.visit_operand(operand, location);\n                         self.visit_ty(ty, TyContext::Location(location));\n                     }\n \n-                    Rvalue::BinaryOp(_bin_op,\n-                                     ref $($mutability)* lhs,\n-                                     ref $($mutability)* rhs) |\n-                    Rvalue::CheckedBinaryOp(_bin_op,\n-                                     ref $($mutability)* lhs,\n-                                     ref $($mutability)* rhs) => {\n+                    Rvalue::BinaryOp(_bin_op, lhs, rhs)\n+                    | Rvalue::CheckedBinaryOp(_bin_op, lhs, rhs) => {\n                         self.visit_operand(lhs, location);\n                         self.visit_operand(rhs, location);\n                     }\n \n-                    Rvalue::UnaryOp(_un_op, ref $($mutability)* op) => {\n+                    Rvalue::UnaryOp(_un_op, op) => {\n                         self.visit_operand(op, location);\n                     }\n \n-                    Rvalue::Discriminant(ref $($mutability)* place) => {\n+                    Rvalue::Discriminant(place) => {\n                         self.visit_place(\n                             place,\n                             PlaceContext::NonMutatingUse(NonMutatingUseContext::Inspect),\n                             location\n                         );\n                     }\n \n-                    Rvalue::NullaryOp(_op, ref $($mutability)* ty) => {\n+                    Rvalue::NullaryOp(_op, ty) => {\n                         self.visit_ty(ty, TyContext::Location(location));\n                     }\n \n-                    Rvalue::Aggregate(ref $($mutability)* kind,\n-                                      ref $($mutability)* operands) => {\n-                        let kind = &$($mutability)* **kind;\n-                        match *kind {\n-                            AggregateKind::Array(ref $($mutability)* ty) => {\n+                    Rvalue::Aggregate(kind, operands) => {\n+                        let kind = &$($mutability)? **kind;\n+                        match kind {\n+                            AggregateKind::Array(ty) => {\n                                 self.visit_ty(ty, TyContext::Location(location));\n                             }\n                             AggregateKind::Tuple => {\n                             }\n-                            AggregateKind::Adt(_adt_def,\n-                                               _variant_index,\n-                                               ref $($mutability)* substs,\n-                                               _user_substs,\n-                                               _active_field_index) => {\n+                            AggregateKind::Adt(\n+                                _adt_def,\n+                                _variant_index,\n+                                substs,\n+                                _user_substs,\n+                                _active_field_index\n+                            ) => {\n                                 self.visit_substs(substs, location);\n                             }\n-                            AggregateKind::Closure(ref $($mutability)* def_id,\n-                                                   ref $($mutability)* closure_substs) => {\n+                            AggregateKind::Closure(\n+                                def_id,\n+                                closure_substs\n+                            ) => {\n                                 self.visit_def_id(def_id, location);\n                                 self.visit_closure_substs(closure_substs, location);\n                             }\n-                            AggregateKind::Generator(ref $($mutability)* def_id,\n-                                                     ref $($mutability)* generator_substs,\n-                                                     _movability) => {\n+                            AggregateKind::Generator(\n+                                def_id,\n+                                generator_substs,\n+                                _movability,\n+                            ) => {\n                                 self.visit_def_id(def_id, location);\n                                 self.visit_generator_substs(generator_substs, location);\n                             }\n@@ -685,33 +681,33 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn super_operand(&mut self,\n-                             operand: & $($mutability)* Operand<'tcx>,\n+                             operand: & $($mutability)? Operand<'tcx>,\n                              location: Location) {\n-                match *operand {\n-                    Operand::Copy(ref $($mutability)* place) => {\n+                match operand {\n+                    Operand::Copy(place) => {\n                         self.visit_place(\n                             place,\n                             PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy),\n                             location\n                         );\n                     }\n-                    Operand::Move(ref $($mutability)* place) => {\n+                    Operand::Move(place) => {\n                         self.visit_place(\n                             place,\n                             PlaceContext::NonMutatingUse(NonMutatingUseContext::Move),\n                             location\n                         );\n                     }\n-                    Operand::Constant(ref $($mutability)* constant) => {\n+                    Operand::Constant(constant) => {\n                         self.visit_constant(constant, location);\n                     }\n                 }\n             }\n \n             fn super_ascribe_user_ty(&mut self,\n-                                     place: & $($mutability)* Place<'tcx>,\n-                                     _variance: & $($mutability)* ty::Variance,\n-                                     user_ty: & $($mutability)* UserTypeProjection<'tcx>,\n+                                     place: & $($mutability)? Place<'tcx>,\n+                                     _variance: & $($mutability)? ty::Variance,\n+                                     user_ty: & $($mutability)? UserTypeProjection<'tcx>,\n                                      location: Location) {\n                 self.visit_place(\n                     place,\n@@ -722,8 +718,8 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn super_retag(&mut self,\n-                           _kind: & $($mutability)* RetagKind,\n-                           place: & $($mutability)* Place<'tcx>,\n+                           _kind: & $($mutability)? RetagKind,\n+                           place: & $($mutability)? Place<'tcx>,\n                            location: Location) {\n                 self.visit_place(\n                     place,\n@@ -733,45 +729,39 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn super_place(&mut self,\n-                            place: & $($mutability)* Place<'tcx>,\n+                            place: & $($mutability)? Place<'tcx>,\n                             context: PlaceContext<'tcx>,\n                             location: Location) {\n-                match *place {\n-                    Place::Local(ref $($mutability)* local) => {\n+                match place {\n+                    Place::Local(local) => {\n                         self.visit_local(local, context, location);\n                     }\n-                    Place::Static(ref $($mutability)* static_) => {\n+                    Place::Static(static_) => {\n                         self.visit_static(static_, context, location);\n                     }\n-                    Place::Promoted(ref $($mutability)* promoted) => {\n-                        self.visit_ty(& $($mutability)* promoted.1, TyContext::Location(location));\n+                    Place::Promoted(promoted) => {\n+                        self.visit_ty(& $($mutability)? promoted.1, TyContext::Location(location));\n                     },\n-                    Place::Projection(ref $($mutability)* proj) => {\n+                    Place::Projection(proj) => {\n                         self.visit_projection(proj, context, location);\n                     }\n                 }\n             }\n \n             fn super_static(&mut self,\n-                            static_: & $($mutability)* Static<'tcx>,\n+                            static_: & $($mutability)? Static<'tcx>,\n                             _context: PlaceContext<'tcx>,\n                             location: Location) {\n-                let Static {\n-                    ref $($mutability)* def_id,\n-                    ref $($mutability)* ty,\n-                } = *static_;\n+                let Static { def_id, ty } = static_;\n                 self.visit_def_id(def_id, location);\n                 self.visit_ty(ty, TyContext::Location(location));\n             }\n \n             fn super_projection(&mut self,\n-                                proj: & $($mutability)* PlaceProjection<'tcx>,\n+                                proj: & $($mutability)? PlaceProjection<'tcx>,\n                                 context: PlaceContext<'tcx>,\n                                 location: Location) {\n-                let Projection {\n-                    ref $($mutability)* base,\n-                    ref $($mutability)* elem,\n-                } = *proj;\n+                let Projection { base, elem } = proj;\n                 let context = if context.is_mutating_use() {\n                     PlaceContext::MutatingUse(MutatingUseContext::Projection)\n                 } else {\n@@ -782,17 +772,17 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn super_projection_elem(&mut self,\n-                                     proj: & $($mutability)* PlaceElem<'tcx>,\n+                                     proj: & $($mutability)? PlaceElem<'tcx>,\n                                      location: Location) {\n-                match *proj {\n+                match proj {\n                     ProjectionElem::Deref => {\n                     }\n                     ProjectionElem::Subslice { from: _, to: _ } => {\n                     }\n-                    ProjectionElem::Field(_field, ref $($mutability)* ty) => {\n+                    ProjectionElem::Field(_field, ty) => {\n                         self.visit_ty(ty, TyContext::Location(location));\n                     }\n-                    ProjectionElem::Index(ref $($mutability)* local) => {\n+                    ProjectionElem::Index(local) => {\n                         self.visit_local(\n                             local,\n                             PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy),\n@@ -810,32 +800,32 @@ macro_rules! make_mir_visitor {\n \n             fn super_local_decl(&mut self,\n                                 local: Local,\n-                                local_decl: & $($mutability)* LocalDecl<'tcx>) {\n+                                local_decl: & $($mutability)? LocalDecl<'tcx>) {\n                 let LocalDecl {\n                     mutability: _,\n-                    ref $($mutability)* ty,\n-                    ref $($mutability)* user_ty,\n+                    ty,\n+                    user_ty,\n                     name: _,\n-                    ref $($mutability)* source_info,\n-                    ref $($mutability)* visibility_scope,\n+                    source_info,\n+                    visibility_scope,\n                     internal: _,\n                     is_user_variable: _,\n                     is_block_tail: _,\n-                } = *local_decl;\n+                } = local_decl;\n \n                 self.visit_ty(ty, TyContext::LocalDecl {\n                     local,\n                     source_info: *source_info,\n                 });\n-                for (user_ty, _) in & $($mutability)* user_ty.contents {\n+                for (user_ty, _) in & $($mutability)? user_ty.contents {\n                     self.visit_user_type_projection(user_ty);\n                 }\n                 self.visit_source_info(source_info);\n                 self.visit_source_scope(visibility_scope);\n             }\n \n             fn super_source_scope(&mut self,\n-                                      _scope: & $($mutability)* SourceScope) {\n+                                      _scope: & $($mutability)? SourceScope) {\n             }\n \n             fn super_branch(&mut self,\n@@ -844,82 +834,82 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn super_constant(&mut self,\n-                              constant: & $($mutability)* Constant<'tcx>,\n+                              constant: & $($mutability)? Constant<'tcx>,\n                               location: Location) {\n                 let Constant {\n-                    ref $($mutability)* span,\n-                    ref $($mutability)* ty,\n-                    ref $($mutability)* user_ty,\n-                    ref $($mutability)* literal,\n-                } = *constant;\n+                    span,\n+                    ty,\n+                    user_ty,\n+                    literal,\n+                } = constant;\n \n                 self.visit_span(span);\n                 self.visit_ty(ty, TyContext::Location(location));\n                 drop(user_ty); // no visit method for this\n                 self.visit_const(literal, location);\n             }\n \n-            fn super_def_id(&mut self, _def_id: & $($mutability)* DefId) {\n+            fn super_def_id(&mut self, _def_id: & $($mutability)? DefId) {\n             }\n \n-            fn super_span(&mut self, _span: & $($mutability)* Span) {\n+            fn super_span(&mut self, _span: & $($mutability)? Span) {\n             }\n \n-            fn super_source_info(&mut self, source_info: & $($mutability)* SourceInfo) {\n+            fn super_source_info(&mut self, source_info: & $($mutability)? SourceInfo) {\n                 let SourceInfo {\n-                    ref $($mutability)* span,\n-                    ref $($mutability)* scope,\n-                } = *source_info;\n+                    span,\n+                    scope,\n+                } = source_info;\n \n                 self.visit_span(span);\n                 self.visit_source_scope(scope);\n             }\n \n             fn super_user_type_projection(\n                 &mut self,\n-                _ty: & $($mutability)* UserTypeProjection<'tcx>,\n+                _ty: & $($mutability)? UserTypeProjection<'tcx>,\n             ) {\n             }\n \n             fn super_user_type_annotation(\n                 &mut self,\n                 _index: UserTypeAnnotationIndex,\n-                ty: & $($mutability)* CanonicalUserTypeAnnotation<'tcx>,\n+                ty: & $($mutability)? CanonicalUserTypeAnnotation<'tcx>,\n             ) {\n-                self.visit_span(& $($mutability)* ty.span);\n-                self.visit_ty(& $($mutability)* ty.inferred_ty, TyContext::UserTy(ty.span));\n+                self.visit_span(& $($mutability)? ty.span);\n+                self.visit_ty(& $($mutability)? ty.inferred_ty, TyContext::UserTy(ty.span));\n             }\n \n-            fn super_ty(&mut self, _ty: & $($mutability)* Ty<'tcx>) {\n+            fn super_ty(&mut self, _ty: & $($mutability)? Ty<'tcx>) {\n             }\n \n-            fn super_region(&mut self, _region: & $($mutability)* ty::Region<'tcx>) {\n+            fn super_region(&mut self, _region: & $($mutability)? ty::Region<'tcx>) {\n             }\n \n-            fn super_const(&mut self, _const: & $($mutability)* &'tcx ty::LazyConst<'tcx>) {\n+            fn super_const(&mut self, _const: & $($mutability)? &'tcx ty::LazyConst<'tcx>) {\n             }\n \n-            fn super_substs(&mut self, _substs: & $($mutability)* &'tcx Substs<'tcx>) {\n+            fn super_substs(&mut self, _substs: & $($mutability)? &'tcx Substs<'tcx>) {\n             }\n \n             fn super_generator_substs(&mut self,\n-                                      _substs: & $($mutability)* GeneratorSubsts<'tcx>) {\n+                                      _substs: & $($mutability)? GeneratorSubsts<'tcx>) {\n             }\n \n             fn super_closure_substs(&mut self,\n-                                    _substs: & $($mutability)* ClosureSubsts<'tcx>) {\n+                                    _substs: & $($mutability)? ClosureSubsts<'tcx>) {\n             }\n \n             // Convenience methods\n \n-            fn visit_location(&mut self, mir: & $($mutability)* Mir<'tcx>, location: Location) {\n-                let basic_block = & $($mutability)* mir[location.block];\n+            fn visit_location(&mut self, mir: & $($mutability)? Mir<'tcx>, location: Location) {\n+                let basic_block = & $($mutability)? mir[location.block];\n                 if basic_block.statements.len() == location.statement_index {\n-                    if let Some(ref $($mutability)* terminator) = basic_block.terminator {\n+                    if let Some(ref $($mutability)? terminator) = basic_block.terminator {\n                         self.visit_terminator(location.block, terminator, location)\n                     }\n                 } else {\n-                    let statement = & $($mutability)*\n+                    let statement = & $($mutability)?\n                         basic_block.statements[location.statement_index];\n                     self.visit_statement(location.block, statement, location)\n                 }"}, {"sha": "65da458efbfff3ee3249caa9f735c129dfe4e758", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 44, "deletions": 39, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -3,13 +3,13 @@\n \n use std::str::FromStr;\n \n-use session::{early_error, early_warn, Session};\n-use session::search_paths::SearchPath;\n+use crate::session::{early_error, early_warn, Session};\n+use crate::session::search_paths::SearchPath;\n \n use rustc_target::spec::{LinkerFlavor, MergeFunctions, PanicStrategy, RelroLevel};\n use rustc_target::spec::{Target, TargetTriple};\n-use lint;\n-use middle::cstore;\n+use crate::lint;\n+use crate::middle::cstore;\n \n use syntax::ast::{self, IntTy, UintTy, MetaItemKind};\n use syntax::source_map::{FileName, FilePathMapping};\n@@ -96,18 +96,18 @@ pub enum LtoCli {\n }\n \n #[derive(Clone, PartialEq, Hash)]\n-pub enum CrossLangLto {\n+pub enum LinkerPluginLto {\n     LinkerPlugin(PathBuf),\n     LinkerPluginAuto,\n     Disabled\n }\n \n-impl CrossLangLto {\n+impl LinkerPluginLto {\n     pub fn enabled(&self) -> bool {\n         match *self {\n-            CrossLangLto::LinkerPlugin(_) |\n-            CrossLangLto::LinkerPluginAuto => true,\n-            CrossLangLto::Disabled => false,\n+            LinkerPluginLto::LinkerPlugin(_) |\n+            LinkerPluginLto::LinkerPluginAuto => true,\n+            LinkerPluginLto::Disabled => false,\n         }\n     }\n }\n@@ -475,7 +475,7 @@ impl BorrowckMode {\n }\n \n pub enum Input {\n-    /// Load source from file\n+    /// Loads source from file\n     File(PathBuf),\n     Str {\n         /// String that is shown in place of a filename\n@@ -523,7 +523,7 @@ impl OutputFilenames {\n             .unwrap_or_else(|| self.temp_path(flavor, None))\n     }\n \n-    /// Get the path where a compilation artifact of the given type for the\n+    /// Gets the path where a compilation artifact of the given type for the\n     /// given codegen unit should be placed on disk. If codegen_unit_name is\n     /// None, a path distinct from those of any codegen unit will be generated.\n     pub fn temp_path(&self, flavor: OutputType, codegen_unit_name: Option<&str>) -> PathBuf {\n@@ -532,7 +532,7 @@ impl OutputFilenames {\n     }\n \n     /// Like temp_path, but also supports things where there is no corresponding\n-    /// OutputType, like no-opt-bitcode or lto-bitcode.\n+    /// OutputType, like noopt-bitcode or lto-bitcode.\n     pub fn temp_path_ext(&self, ext: &str, codegen_unit_name: Option<&str>) -> PathBuf {\n         let base = self.out_directory.join(&self.filestem());\n \n@@ -616,7 +616,7 @@ impl Default for Options {\n }\n \n impl Options {\n-    /// True if there is a reason to build the dep graph.\n+    /// Returns `true` if there is a reason to build the dep graph.\n     pub fn build_dep_graph(&self) -> bool {\n         self.incremental.is_some() || self.debugging_opts.dump_dep_graph\n             || self.debugging_opts.query_dep_graph\n@@ -632,7 +632,7 @@ impl Options {\n         FilePathMapping::new(self.remap_path_prefix.clone())\n     }\n \n-    /// True if there will be an output file generated\n+    /// Returns `true` if there will be an output file generated\n     pub fn will_create_output_file(&self) -> bool {\n         !self.debugging_opts.parse_only && // The file is just being parsed\n             !self.debugging_opts.ls // The file is just being queried\n@@ -812,7 +812,7 @@ macro_rules! options {\n         pub const parse_lto: Option<&str> =\n             Some(\"either a boolean (`yes`, `no`, `on`, `off`, etc), `thin`, \\\n                   `fat`, or omitted\");\n-        pub const parse_cross_lang_lto: Option<&str> =\n+        pub const parse_linker_plugin_lto: Option<&str> =\n             Some(\"either a boolean (`yes`, `no`, `on`, `off`, etc), \\\n                   or the path to the linker plugin\");\n         pub const parse_merge_functions: Option<&str> =\n@@ -821,7 +821,7 @@ macro_rules! options {\n \n     #[allow(dead_code)]\n     mod $mod_set {\n-        use super::{$struct_name, Passes, Sanitizer, LtoCli, CrossLangLto};\n+        use super::{$struct_name, Passes, Sanitizer, LtoCli, LinkerPluginLto};\n         use rustc_target::spec::{LinkerFlavor, MergeFunctions, PanicStrategy, RelroLevel};\n         use std::path::PathBuf;\n         use std::str::FromStr;\n@@ -1037,22 +1037,22 @@ macro_rules! options {\n             true\n         }\n \n-        fn parse_cross_lang_lto(slot: &mut CrossLangLto, v: Option<&str>) -> bool {\n+        fn parse_linker_plugin_lto(slot: &mut LinkerPluginLto, v: Option<&str>) -> bool {\n             if v.is_some() {\n                 let mut bool_arg = None;\n                 if parse_opt_bool(&mut bool_arg, v) {\n                     *slot = if bool_arg.unwrap() {\n-                        CrossLangLto::LinkerPluginAuto\n+                        LinkerPluginLto::LinkerPluginAuto\n                     } else {\n-                        CrossLangLto::Disabled\n+                        LinkerPluginLto::Disabled\n                     };\n                     return true\n                 }\n             }\n \n             *slot = match v {\n-                None => CrossLangLto::LinkerPluginAuto,\n-                Some(path) => CrossLangLto::LinkerPlugin(PathBuf::from(path)),\n+                None => LinkerPluginLto::LinkerPluginAuto,\n+                Some(path) => LinkerPluginLto::LinkerPlugin(PathBuf::from(path)),\n             };\n             true\n         }\n@@ -1145,6 +1145,10 @@ options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n         \"allow the linker to link its default libraries\"),\n     linker_flavor: Option<LinkerFlavor> = (None, parse_linker_flavor, [UNTRACKED],\n                                            \"Linker flavor\"),\n+    linker_plugin_lto: LinkerPluginLto = (LinkerPluginLto::Disabled,\n+        parse_linker_plugin_lto, [TRACKED],\n+        \"generate build artifacts that are compatible with linker-based LTO.\"),\n+\n }\n \n options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n@@ -1233,6 +1237,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"show extended diagnostic help\"),\n     continue_parse_after_error: bool = (false, parse_bool, [TRACKED],\n         \"attempt to recover from parse errors (experimental)\"),\n+    dep_tasks: bool = (false, parse_bool, [UNTRACKED],\n+        \"print tasks that execute and the color their dep node gets (requires debug build)\"),\n     incremental: Option<String> = (None, parse_opt_string, [UNTRACKED],\n         \"enable incremental compilation (experimental)\"),\n     incremental_queries: bool = (true, parse_bool, [UNTRACKED],\n@@ -1305,6 +1311,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"print some statistics about AST and HIR\"),\n     always_encode_mir: bool = (false, parse_bool, [TRACKED],\n         \"encode MIR of all functions into the crate metadata\"),\n+    unleash_the_miri_inside_of_you: bool = (false, parse_bool, [TRACKED],\n+        \"take the breaks off const evaluation. NOTE: this is unsound\"),\n     osx_rpath_install_name: bool = (false, parse_bool, [TRACKED],\n         \"pass `-install_name @rpath/...` to the macOS linker\"),\n     sanitizer: Option<Sanitizer> = (None, parse_sanitizer, [TRACKED],\n@@ -1381,8 +1389,6 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"make the current crate share its generic instantiations\"),\n     chalk: bool = (false, parse_bool, [TRACKED],\n         \"enable the experimental Chalk-based trait solving engine\"),\n-    cross_lang_lto: CrossLangLto = (CrossLangLto::Disabled, parse_cross_lang_lto, [TRACKED],\n-        \"generate build artifacts that are compatible with linker-based LTO.\"),\n     no_parallel_llvm: bool = (false, parse_bool, [UNTRACKED],\n         \"don't run LLVM in parallel (while keeping codegen-units and ThinLTO)\"),\n     no_leak_check: bool = (false, parse_bool, [UNTRACKED],\n@@ -2342,7 +2348,7 @@ pub mod nightly_options {\n     use getopts;\n     use syntax::feature_gate::UnstableFeatures;\n     use super::{ErrorOutputType, OptionStability, RustcOptGroup};\n-    use session::early_error;\n+    use crate::session::early_error;\n \n     pub fn is_unstable_enabled(matches: &getopts::Matches) -> bool {\n         is_nightly_build()\n@@ -2431,14 +2437,14 @@ impl fmt::Display for CrateType {\n /// we have an opt-in scheme here, so one is hopefully forced to think about\n /// how the hash should be calculated when adding a new command-line argument.\n mod dep_tracking {\n-    use lint;\n-    use middle::cstore;\n+    use crate::lint;\n+    use crate::middle::cstore;\n     use std::collections::BTreeMap;\n     use std::hash::Hash;\n     use std::path::PathBuf;\n     use std::collections::hash_map::DefaultHasher;\n     use super::{CrateType, DebugInfo, ErrorOutputType, OptLevel, OutputTypes,\n-                Passes, Sanitizer, LtoCli, CrossLangLto};\n+                Passes, Sanitizer, LtoCli, LinkerPluginLto};\n     use syntax::feature_gate::UnstableFeatures;\n     use rustc_target::spec::{MergeFunctions, PanicStrategy, RelroLevel, TargetTriple};\n     use syntax::edition::Edition;\n@@ -2505,7 +2511,7 @@ mod dep_tracking {\n     impl_dep_tracking_hash_via_hash!(Option<Sanitizer>);\n     impl_dep_tracking_hash_via_hash!(TargetTriple);\n     impl_dep_tracking_hash_via_hash!(Edition);\n-    impl_dep_tracking_hash_via_hash!(CrossLangLto);\n+    impl_dep_tracking_hash_via_hash!(LinkerPluginLto);\n \n     impl_dep_tracking_hash_for_sortable_vec_of!(String);\n     impl_dep_tracking_hash_for_sortable_vec_of!(PathBuf);\n@@ -2565,14 +2571,13 @@ mod dep_tracking {\n \n #[cfg(test)]\n mod tests {\n-    use errors;\n     use getopts;\n-    use lint;\n-    use middle::cstore;\n-    use session::config::{build_configuration, build_session_options_and_crate_config};\n-    use session::config::{LtoCli, CrossLangLto};\n-    use session::build_session;\n-    use session::search_paths::SearchPath;\n+    use crate::lint;\n+    use crate::middle::cstore;\n+    use crate::session::config::{build_configuration, build_session_options_and_crate_config};\n+    use crate::session::config::{LtoCli, LinkerPluginLto};\n+    use crate::session::build_session;\n+    use crate::session::search_paths::SearchPath;\n     use std::collections::{BTreeMap, BTreeSet};\n     use std::iter::FromIterator;\n     use std::path::PathBuf;\n@@ -3103,6 +3108,10 @@ mod tests {\n         opts = reference.clone();\n         opts.cg.panic = Some(PanicStrategy::Abort);\n         assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.cg.linker_plugin_lto = LinkerPluginLto::LinkerPluginAuto;\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n     }\n \n     #[test]\n@@ -3229,10 +3238,6 @@ mod tests {\n         opts.debugging_opts.relro_level = Some(RelroLevel::Full);\n         assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n \n-        opts = reference.clone();\n-        opts.debugging_opts.cross_lang_lto = CrossLangLto::LinkerPluginAuto;\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n         opts = reference.clone();\n         opts.debugging_opts.merge_functions = Some(MergeFunctions::Disabled);\n         assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());"}, {"sha": "77f190e281229bb314cc46a14151dc410f900102", "filename": "src/librustc/session/filesearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fsession%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fsession%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Ffilesearch.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -7,7 +7,7 @@ use std::env;\n use std::fs;\n use std::path::{Path, PathBuf};\n \n-use session::search_paths::{SearchPath, PathKind};\n+use crate::session::search_paths::{SearchPath, PathKind};\n use rustc_fs_util::fix_windows_verbatim_for_gcc;\n \n #[derive(Copy, Clone)]"}, {"sha": "833785f04076cb8c142ef4eedc28bbef7d32531a", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 31, "deletions": 45, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,27 +1,27 @@\n pub use self::code_stats::{DataTypeKind, SizeKind, FieldInfo, VariantInfo};\n use self::code_stats::CodeStats;\n \n-use dep_graph::cgu_reuse_tracker::CguReuseTracker;\n-use hir::def_id::CrateNum;\n+use crate::dep_graph::cgu_reuse_tracker::CguReuseTracker;\n+use crate::hir::def_id::CrateNum;\n use rustc_data_structures::fingerprint::Fingerprint;\n \n-use lint;\n-use lint::builtin::BuiltinLintDiagnostics;\n-use middle::allocator::AllocatorKind;\n-use middle::dependency_format;\n-use session::config::{OutputType, Lto};\n-use session::search_paths::{PathKind, SearchPath};\n-use util::nodemap::{FxHashMap, FxHashSet};\n-use util::common::{duration_to_secs_str, ErrorReported};\n-use util::common::ProfileQueriesMsg;\n+use crate::lint;\n+use crate::lint::builtin::BuiltinLintDiagnostics;\n+use crate::middle::allocator::AllocatorKind;\n+use crate::middle::dependency_format;\n+use crate::session::config::OutputType;\n+use crate::session::search_paths::{PathKind, SearchPath};\n+use crate::util::nodemap::{FxHashMap, FxHashSet};\n+use crate::util::common::{duration_to_secs_str, ErrorReported};\n+use crate::util::common::ProfileQueriesMsg;\n \n use rustc_data_structures::base_n;\n use rustc_data_structures::sync::{\n     self, Lrc, Lock, OneThread, Once, RwLock, AtomicU64, AtomicUsize, Ordering,\n     Ordering::SeqCst,\n };\n \n-use errors::{self, DiagnosticBuilder, DiagnosticId, Applicability};\n+use errors::{DiagnosticBuilder, DiagnosticId, Applicability};\n use errors::emitter::{Emitter, EmitterWriter};\n use syntax::ast::{self, NodeId};\n use syntax::edition::Edition;\n@@ -30,7 +30,7 @@ use syntax::json::JsonEmitter;\n use syntax::source_map;\n use syntax::parse::{self, ParseSess};\n use syntax_pos::{MultiSpan, Span};\n-use util::profiling::SelfProfiler;\n+use crate::util::profiling::SelfProfiler;\n \n use rustc_target::spec::{PanicStrategy, RelroLevel, Target, TargetTriple};\n use rustc_data_structures::flock;\n@@ -51,7 +51,7 @@ pub mod filesearch;\n pub mod search_paths;\n \n pub struct OptimizationFuel {\n-    /// If -zfuel=crate=n is specified, initially set to n. Otherwise 0.\n+    /// If `-zfuel=crate=n` is specified, initially set to `n`, otherwise `0`.\n     remaining: u64,\n     /// We're rejecting all further optimizations.\n     out_of_fuel: bool,\n@@ -64,7 +64,7 @@ pub struct Session {\n     pub host: Target,\n     pub opts: config::Options,\n     pub host_tlib_path: SearchPath,\n-    /// This is `None` if the host and target are the same.\n+    /// `None` if the host and target are the same.\n     pub target_tlib_path: Option<SearchPath>,\n     pub parse_sess: ParseSess,\n     pub sysroot: PathBuf,\n@@ -85,7 +85,7 @@ pub struct Session {\n     /// in order to avoid redundantly verbose output (Issue #24690, #44953).\n     pub one_time_diagnostics: Lock<FxHashSet<(DiagnosticMessageId, Option<Span>, String)>>,\n     pub plugin_llvm_passes: OneThread<RefCell<Vec<String>>>,\n-    pub plugin_attributes: OneThread<RefCell<Vec<(String, AttributeType)>>>,\n+    pub plugin_attributes: Lock<Vec<(String, AttributeType)>>,\n     pub crate_types: Once<Vec<config::CrateType>>,\n     pub dependency_formats: Once<dependency_format::Dependencies>,\n     /// The crate_disambiguator is constructed out of all the `-C metadata`\n@@ -104,7 +104,7 @@ pub struct Session {\n     /// The maximum length of types during monomorphization.\n     pub type_length_limit: Once<usize>,\n \n-    /// The maximum number of stackframes allowed in const eval\n+    /// The maximum number of stackframes allowed in const eval.\n     pub const_eval_stack_frame_limit: usize,\n \n     /// The metadata::creader module may inject an allocator/panic_runtime\n@@ -123,13 +123,13 @@ pub struct Session {\n     /// `-Zquery-dep-graph` is specified.\n     pub cgu_reuse_tracker: CguReuseTracker,\n \n-    /// Used by -Z profile-queries in util::common\n+    /// Used by `-Z profile-queries` in `util::common`.\n     pub profile_channel: Lock<Option<mpsc::Sender<ProfileQueriesMsg>>>,\n \n-    /// Used by -Z self-profile\n+    /// Used by `-Z self-profile`.\n     pub self_profiling_active: bool,\n \n-    /// Used by -Z self-profile\n+    /// Used by `-Z self-profile`.\n     pub self_profiling: Lock<SelfProfiler>,\n \n     /// Some measurements that are being gathered during compilation.\n@@ -140,14 +140,14 @@ pub struct Session {\n \n     next_node_id: OneThread<Cell<ast::NodeId>>,\n \n-    /// If -zfuel=crate=n is specified, Some(crate).\n+    /// If `-zfuel=crate=n` is specified, `Some(crate)`.\n     optimization_fuel_crate: Option<String>,\n \n-    /// Tracks fuel info if If -zfuel=crate=n is specified\n+    /// Tracks fuel info if `-zfuel=crate=n` is specified.\n     optimization_fuel: Lock<OptimizationFuel>,\n \n     // The next two are public because the driver needs to read them.\n-    /// If -zprint-fuel=crate, Some(crate).\n+    /// If `-zprint-fuel=crate`, `Some(crate)`.\n     pub print_fuel_crate: Option<String>,\n     /// Always set to zero and incremented so that we can print fuel expended by a crate.\n     pub print_fuel: AtomicU64,\n@@ -156,20 +156,20 @@ pub struct Session {\n     /// false positives about a job server in our environment.\n     pub jobserver: Client,\n \n-    /// Metadata about the allocators for the current crate being compiled\n+    /// Metadata about the allocators for the current crate being compiled.\n     pub has_global_allocator: Once<bool>,\n \n-    /// Metadata about the panic handlers for the current crate being compiled\n+    /// Metadata about the panic handlers for the current crate being compiled.\n     pub has_panic_handler: Once<bool>,\n \n     /// Cap lint level specified by a driver specifically.\n     pub driver_lint_caps: FxHashMap<lint::LintId, lint::Level>,\n }\n \n pub struct PerfStats {\n-    /// The accumulated time spent on computing symbol hashes\n+    /// The accumulated time spent on computing symbol hashes.\n     pub symbol_hash_time: Lock<Duration>,\n-    /// The accumulated time spent decoding def path tables from metadata\n+    /// The accumulated time spent decoding def path tables from metadata.\n     pub decode_def_path_tables_time: Lock<Duration>,\n     /// Total number of values canonicalized queries constructed.\n     pub queries_canonicalized: AtomicUsize,\n@@ -539,7 +539,7 @@ impl Session {\n         self.opts.debugging_opts.print_llvm_passes\n     }\n \n-    /// Get the features enabled for the current compilation session.\n+    /// Gets the features enabled for the current compilation session.\n     /// DO NOT USE THIS METHOD if there is a TyCtxt available, as it circumvents\n     /// dependency tracking. Use tcx.features() instead.\n     #[inline]\n@@ -989,7 +989,7 @@ impl Session {\n         self.opts.edition\n     }\n \n-    /// True if we cannot skip the PLT for shared library calls.\n+    /// Returns `true` if we cannot skip the PLT for shared library calls.\n     pub fn needs_plt(&self) -> bool {\n         // Check if the current target usually needs PLT to be enabled.\n         // The user can use the command line flag to override it.\n@@ -1178,7 +1178,7 @@ pub fn build_session_(\n         buffered_lints: Lock::new(Some(Default::default())),\n         one_time_diagnostics: Default::default(),\n         plugin_llvm_passes: OneThread::new(RefCell::new(Vec::new())),\n-        plugin_attributes: OneThread::new(RefCell::new(Vec::new())),\n+        plugin_attributes: Lock::new(Vec::new()),\n         crate_types: Once::new(),\n         dependency_formats: Once::new(),\n         crate_disambiguator: Once::new(),\n@@ -1246,28 +1246,14 @@ pub fn build_session_(\n // If it is useful to have a Session available already for validating a\n // commandline argument, you can do so here.\n fn validate_commandline_args_with_session_available(sess: &Session) {\n-\n-    if sess.opts.incremental.is_some() {\n-        match sess.lto() {\n-            Lto::Thin |\n-            Lto::Fat => {\n-                sess.err(\"can't perform LTO when compiling incrementally\");\n-            }\n-            Lto::ThinLocal |\n-            Lto::No => {\n-                // This is fine\n-            }\n-        }\n-    }\n-\n     // Since we don't know if code in an rlib will be linked to statically or\n     // dynamically downstream, rustc generates `__imp_` symbols that help the\n     // MSVC linker deal with this lack of knowledge (#27438). Unfortunately,\n     // these manually generated symbols confuse LLD when it tries to merge\n     // bitcode during ThinLTO. Therefore we disallow dynamic linking on MSVC\n     // when compiling for LLD ThinLTO. This way we can validly just not generate\n     // the `dllimport` attributes and `__imp_` symbols in that case.\n-    if sess.opts.debugging_opts.cross_lang_lto.enabled() &&\n+    if sess.opts.cg.linker_plugin_lto.enabled() &&\n        sess.opts.cg.prefer_dynamic &&\n        sess.target.target.options.is_like_msvc {\n         sess.err(\"Linker plugin based LTO is not supported together with \\"}, {"sha": "a950258cefd0cb90d82b684bac801d776eec9931", "filename": "src/librustc/session/search_paths.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fsearch_paths.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,6 +1,6 @@\n use std::path::{Path, PathBuf};\n-use session::{early_error, config};\n-use session::filesearch::make_target_lib_path;\n+use crate::session::{early_error, config};\n+use crate::session::filesearch::make_target_lib_path;\n \n #[derive(Clone, Debug)]\n pub struct SearchPath {"}, {"sha": "8957bbaa4ad7d9eb3df9793e8398b28e2e6e56fd", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -6,12 +6,12 @@ use super::*;\n use std::collections::hash_map::Entry;\n use std::collections::VecDeque;\n \n-use infer::region_constraints::{Constraint, RegionConstraintData};\n-use infer::InferCtxt;\n+use crate::infer::region_constraints::{Constraint, RegionConstraintData};\n+use crate::infer::InferCtxt;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n \n-use ty::fold::TypeFolder;\n-use ty::{Region, RegionVid};\n+use crate::ty::fold::TypeFolder;\n+use crate::ty::{Region, RegionVid};\n \n // FIXME(twk): this is obviously not nice to duplicate like that\n #[derive(Eq, PartialEq, Hash, Copy, Clone, Debug)]\n@@ -57,7 +57,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         AutoTraitFinder { tcx }\n     }\n \n-    /// Make a best effort to determine whether and under which conditions an auto trait is\n+    /// Makes a best effort to determine whether and under which conditions an auto trait is\n     /// implemented for a type. For example, if you have\n     ///\n     /// ```\n@@ -202,7 +202,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 full_env,\n                 ty,\n                 trait_did,\n-                ObligationCause::misc(DUMMY_SP, ast::DUMMY_NODE_ID),\n+                ObligationCause::misc(DUMMY_SP, hir::DUMMY_HIR_ID),\n             );\n             fulfill.select_all_or_error(&infcx).unwrap_or_else(|e| {\n                 panic!(\n@@ -315,7 +315,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             user_env.caller_bounds.iter().cloned().collect();\n \n         let mut new_env = param_env.clone();\n-        let dummy_cause = ObligationCause::misc(DUMMY_SP, ast::DUMMY_NODE_ID);\n+        let dummy_cause = ObligationCause::misc(DUMMY_SP, hir::DUMMY_HIR_ID);\n \n         while let Some(pred) = predicates.pop_front() {\n             infcx.clear_caches();\n@@ -669,7 +669,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         select: &mut SelectionContext<'c, 'd, 'cx>,\n         only_projections: bool,\n     ) -> bool {\n-        let dummy_cause = ObligationCause::misc(DUMMY_SP, ast::DUMMY_NODE_ID);\n+        let dummy_cause = ObligationCause::misc(DUMMY_SP, hir::DUMMY_HIR_ID);\n \n         for (obligation, mut predicate) in nested\n             .map(|o| (o.clone(), o.predicate.clone()))"}, {"sha": "d9eb6d8157dfbdd3590af1e35eecd1fe10eb9510", "filename": "src/librustc/traits/chalk_fulfill.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Ftraits%2Fchalk_fulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Ftraits%2Fchalk_fulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fchalk_fulfill.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,4 +1,4 @@\n-use traits::{\n+use crate::traits::{\n     Environment,\n     InEnvironment,\n     TraitEngine,\n@@ -8,10 +8,10 @@ use traits::{\n     FulfillmentErrorCode,\n     SelectionError,\n };\n-use traits::query::NoSolution;\n-use infer::InferCtxt;\n-use infer::canonical::{Canonical, OriginalQueryValues};\n-use ty::{self, Ty};\n+use crate::traits::query::NoSolution;\n+use crate::infer::InferCtxt;\n+use crate::infer::canonical::{Canonical, OriginalQueryValues};\n+use crate::ty::{self, Ty};\n use rustc_data_structures::fx::FxHashSet;\n \n pub type CanonicalGoal<'tcx> = Canonical<'tcx, InEnvironment<'tcx, ty::Predicate<'tcx>>>;"}, {"sha": "d6b7b3b99cacd8c18bcaf974a6c39bed6b136767", "filename": "src/librustc/traits/codegen/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -3,19 +3,19 @@\n // seems likely that they should eventually be merged into more\n // general routines.\n \n-use dep_graph::{DepKind, DepTrackingMapConfig};\n+use crate::dep_graph::{DepKind, DepTrackingMapConfig};\n use std::marker::PhantomData;\n use syntax_pos::DUMMY_SP;\n-use infer::InferCtxt;\n+use crate::infer::InferCtxt;\n use syntax_pos::Span;\n-use traits::{FulfillmentContext, Obligation, ObligationCause, SelectionContext,\n+use crate::traits::{FulfillmentContext, Obligation, ObligationCause, SelectionContext,\n              TraitEngine, Vtable};\n-use ty::{self, Ty, TyCtxt};\n-use ty::subst::{Subst, Substs};\n-use ty::fold::TypeFoldable;\n+use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::subst::{Subst, Substs};\n+use crate::ty::fold::TypeFoldable;\n \n-/// Attempts to resolve an obligation to a vtable.. The result is\n-/// a shallow vtable resolution -- meaning that we do not\n+/// Attempts to resolve an obligation to a vtable. The result is\n+/// a shallow vtable resolution, meaning that we do not\n /// (necessarily) resolve all nested obligations on the impl. Note\n /// that type check should guarantee to us that all nested\n /// obligations *could be* resolved if we wanted to."}, {"sha": "35d8e2beef55787688c70612d9530b429ec36e66", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,20 +1,20 @@\n-//! See rustc guide chapters on [trait-resolution] and [trait-specialization] for more info on how\n+//! See Rustc Guide chapters on [trait-resolution] and [trait-specialization] for more info on how\n //! this works.\n //!\n //! [trait-resolution]: https://rust-lang.github.io/rustc-guide/traits/resolution.html\n //! [trait-specialization]: https://rust-lang.github.io/rustc-guide/traits/specialization.html\n \n-use infer::CombinedSnapshot;\n-use hir::def_id::{DefId, LOCAL_CRATE};\n+use crate::infer::CombinedSnapshot;\n+use crate::hir::def_id::{DefId, LOCAL_CRATE};\n use syntax_pos::DUMMY_SP;\n-use traits::{self, Normalized, SelectionContext, Obligation, ObligationCause};\n-use traits::IntercrateMode;\n-use traits::select::IntercrateAmbiguityCause;\n-use ty::{self, Ty, TyCtxt};\n-use ty::fold::TypeFoldable;\n-use ty::subst::Subst;\n+use crate::traits::{self, Normalized, SelectionContext, Obligation, ObligationCause};\n+use crate::traits::IntercrateMode;\n+use crate::traits::select::IntercrateAmbiguityCause;\n+use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::fold::TypeFoldable;\n+use crate::ty::subst::Subst;\n \n-use infer::{InferOk};\n+use crate::infer::{InferOk};\n \n /// Whether we do the orphan check relative to this crate or\n /// to some remote crate.\n@@ -34,12 +34,12 @@ pub struct OverlapResult<'tcx> {\n     pub impl_header: ty::ImplHeader<'tcx>,\n     pub intercrate_ambiguity_causes: Vec<IntercrateAmbiguityCause>,\n \n-    /// True if the overlap might've been permitted before the shift\n+    /// `true` if the overlap might've been permitted before the shift\n     /// to universes.\n     pub involves_placeholder: bool,\n }\n \n-pub fn add_placeholder_note(err: &mut ::errors::DiagnosticBuilder<'_>) {\n+pub fn add_placeholder_note(err: &mut errors::DiagnosticBuilder<'_>) {\n     err.note(&format!(\n         \"this behavior recently changed as a result of a bug fix; \\\n          see rust-lang/rust#56105 for details\"\n@@ -111,7 +111,7 @@ fn with_fresh_ty_vars<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, '\n }\n \n /// Can both impl `a` and impl `b` be satisfied by a common type (including\n-/// `where` clauses)? If so, returns an `ImplHeader` that unifies the two impls.\n+/// where-clauses)? If so, returns an `ImplHeader` that unifies the two impls.\n fn overlap<'cx, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     a_def_id: DefId,\n@@ -242,7 +242,7 @@ pub enum OrphanCheckErr<'tcx> {\n }\n \n /// Checks the coherence orphan rules. `impl_def_id` should be the\n-/// def-id of a trait impl. To pass, either the trait must be local, or else\n+/// `DefId` of a trait impl. To pass, either the trait must be local, or else\n /// two conditions must be satisfied:\n ///\n /// 1. All type parameters in `Self` must be \"covered\" by some local type constructor.\n@@ -268,7 +268,7 @@ pub fn orphan_check<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     orphan_check_trait_ref(tcx, trait_ref, InCrate::Local)\n }\n \n-/// Check whether a trait-ref is potentially implementable by a crate.\n+/// Checks whether a trait-ref is potentially implementable by a crate.\n ///\n /// The current rule is that a trait-ref orphan checks in a crate C:\n ///"}, {"sha": "2f019d823ff5d2a7a5f3b6d02684d58ad502bd9b", "filename": "src/librustc/traits/engine.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fengine.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,7 +1,7 @@\n-use infer::InferCtxt;\n-use ty::{self, Ty, TyCtxt, ToPredicate};\n-use traits::Obligation;\n-use hir::def_id::DefId;\n+use crate::infer::InferCtxt;\n+use crate::ty::{self, Ty, TyCtxt, ToPredicate};\n+use crate::traits::Obligation;\n+use crate::hir::def_id::DefId;\n \n use super::{ChalkFulfillmentContext, FulfillmentContext, FulfillmentError};\n use super::{ObligationCause, PredicateObligation};"}, {"sha": "eb284645d36c827a2ae549bae3308f8c30b07e84", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -17,24 +17,24 @@ use super::{\n     Overflow,\n };\n \n+use crate::hir;\n+use crate::hir::Node;\n+use crate::hir::def_id::DefId;\n+use crate::infer::{self, InferCtxt};\n+use crate::infer::type_variable::TypeVariableOrigin;\n+use crate::session::DiagnosticMessageId;\n+use crate::ty::{self, AdtKind, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n+use crate::ty::GenericParamDefKind;\n+use crate::ty::error::ExpectedFound;\n+use crate::ty::fast_reject;\n+use crate::ty::fold::TypeFolder;\n+use crate::ty::subst::Subst;\n+use crate::ty::SubtypePredicate;\n+use crate::util::nodemap::{FxHashMap, FxHashSet};\n+\n use errors::{Applicability, DiagnosticBuilder};\n-use hir;\n-use hir::Node;\n-use hir::def_id::DefId;\n-use infer::{self, InferCtxt};\n-use infer::type_variable::TypeVariableOrigin;\n use std::fmt;\n use syntax::ast;\n-use session::DiagnosticMessageId;\n-use ty::{self, AdtKind, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n-use ty::GenericParamDefKind;\n-use ty::error::ExpectedFound;\n-use ty::fast_reject;\n-use ty::fold::TypeFolder;\n-use ty::subst::Subst;\n-use ty::SubtypePredicate;\n-use util::nodemap::{FxHashMap, FxHashSet};\n-\n use syntax_pos::{DUMMY_SP, Span, ExpnInfo, ExpnFormat};\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n@@ -583,7 +583,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n \n-    /// Get the parent trait chain start\n+    /// Gets the parent trait chain start\n     fn get_parent_trait_ref(&self, code: &ObligationCauseCode<'tcx>) -> Option<String> {\n         match code {\n             &ObligationCauseCode::BuiltinDerivedObligation(ref data) => {\n@@ -1035,7 +1035,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                  ).collect::<Vec<_>>())\n             }\n             Node::StructCtor(ref variant_data) => {\n-                (self.tcx.sess.source_map().def_span(self.tcx.hir().span(variant_data.id())),\n+                (self.tcx.sess.source_map().def_span(\n+                    self.tcx.hir().span_by_hir_id(variant_data.hir_id())),\n                  vec![ArgKind::empty(); variant_data.fields().len()])\n             }\n             _ => panic!(\"non-FnLike node found: {:?}\", node),\n@@ -1375,7 +1376,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Returns whether the trait predicate may apply for *some* assignment\n+    /// Returns `true` if the trait predicate may apply for *some* assignment\n     /// to the type parameters.\n     fn predicate_can_apply(&self,\n                            param_env: ty::ParamEnv<'tcx>,"}, {"sha": "587f57bb09dee7f0e4201e575563910ccbf12b41", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,7 +1,7 @@\n-use infer::InferCtxt;\n-use mir::interpret::{GlobalId, ErrorHandled};\n-use ty::{self, Ty, TypeFoldable, ToPolyTraitRef};\n-use ty::error::ExpectedFound;\n+use crate::infer::InferCtxt;\n+use crate::mir::interpret::{GlobalId, ErrorHandled};\n+use crate::ty::{self, Ty, TypeFoldable, ToPolyTraitRef};\n+use crate::ty::error::ExpectedFound;\n use rustc_data_structures::obligation_forest::{DoCompleted, Error, ForestObligation};\n use rustc_data_structures::obligation_forest::{ObligationForest, ObligationProcessor};\n use rustc_data_structures::obligation_forest::{ProcessResult};\n@@ -23,7 +23,7 @@ impl<'tcx> ForestObligation for PendingPredicateObligation<'tcx> {\n     fn as_predicate(&self) -> &Self::Predicate { &self.obligation.predicate }\n }\n \n-/// The fulfillment context is used to drive trait resolution.  It\n+/// The fulfillment context is used to drive trait resolution. It\n /// consists of a list of obligations that must be (eventually)\n /// satisfied. The job is to track which are satisfied, which yielded\n /// errors, and which are still pending. At any point, users can call\n@@ -140,7 +140,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n     /// creating a fresh type variable `$0` as well as a projection\n     /// predicate `<SomeType as SomeTrait>::X == $0`. When the\n     /// inference engine runs, it will attempt to find an impl of\n-    /// `SomeTrait` or a where clause that lets us unify `$0` with\n+    /// `SomeTrait` or a where-clause that lets us unify `$0` with\n     /// something concrete. If this fails, we'll unify `$0` with\n     /// `projection_ty` again.\n     fn normalize_projection_type<'a, 'gcx>(&mut self,\n@@ -509,7 +509,7 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n     }\n }\n \n-/// Return the set of type variables contained in a trait ref\n+/// Returns the set of type variables contained in a trait ref\n fn trait_ref_type_vars<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n                                        t: ty::PolyTraitRef<'tcx>) -> Vec<Ty<'tcx>>\n {"}, {"sha": "99d1e32d52398cdb15b7b048601c4f9e665cb820", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 59, "deletions": 57, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -20,20 +20,20 @@ mod util;\n pub mod query;\n \n use chalk_engine;\n-use hir;\n-use hir::def_id::DefId;\n-use infer::{InferCtxt, SuppressRegionErrors};\n-use infer::outlives::env::OutlivesEnvironment;\n-use middle::region;\n-use mir::interpret::ErrorHandled;\n+use crate::hir;\n+use crate::hir::def_id::DefId;\n+use crate::infer::{InferCtxt, SuppressRegionErrors};\n+use crate::infer::outlives::env::OutlivesEnvironment;\n+use crate::middle::region;\n+use crate::mir::interpret::ErrorHandled;\n use rustc_data_structures::sync::Lrc;\n use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n-use ty::subst::Substs;\n-use ty::{self, AdtKind, List, Ty, TyCtxt, GenericParamDefKind, ToPredicate};\n-use ty::error::{ExpectedFound, TypeError};\n-use ty::fold::{TypeFolder, TypeFoldable, TypeVisitor};\n-use util::common::ErrorReported;\n+use crate::ty::subst::Substs;\n+use crate::ty::{self, AdtKind, List, Ty, TyCtxt, GenericParamDefKind, ToPredicate};\n+use crate::ty::error::{ExpectedFound, TypeError};\n+use crate::ty::fold::{TypeFolder, TypeFoldable, TypeVisitor};\n+use crate::util::common::ErrorReported;\n \n use std::fmt::Debug;\n use std::rc::Rc;\n@@ -73,14 +73,14 @@ pub use self::FulfillmentErrorCode::*;\n pub use self::SelectionError::*;\n pub use self::Vtable::*;\n \n-// Whether to enable bug compatibility with issue #43355\n+/// Whether to enable bug compatibility with issue #43355.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum IntercrateMode {\n     Issue43355,\n     Fixed\n }\n \n-// The mode that trait queries run in\n+/// The mode that trait queries run in.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum TraitQueryMode {\n     // Standard/un-canonicalized queries get accurate\n@@ -93,46 +93,46 @@ pub enum TraitQueryMode {\n     Canonical,\n }\n \n-/// An `Obligation` represents some trait reference (e.g., `int:Eq`) for\n-/// which the vtable must be found.  The process of finding a vtable is\n+/// An `Obligation` represents some trait reference (e.g., `int: Eq`) for\n+/// which the vtable must be found. The process of finding a vtable is\n /// called \"resolving\" the `Obligation`. This process consists of\n /// either identifying an `impl` (e.g., `impl Eq for int`) that\n /// provides the required vtable, or else finding a bound that is in\n /// scope. The eventual result is usually a `Selection` (defined below).\n #[derive(Clone, PartialEq, Eq, Hash)]\n pub struct Obligation<'tcx, T> {\n-    /// Why do we have to prove this thing?\n+    /// The reason we have to prove this thing.\n     pub cause: ObligationCause<'tcx>,\n \n-    /// In which environment should we prove this thing?\n+    /// The environment in which we should prove this thing.\n     pub param_env: ty::ParamEnv<'tcx>,\n \n-    /// What are we trying to prove?\n+    /// The thing we are trying to prove.\n     pub predicate: T,\n \n     /// If we started proving this as a result of trying to prove\n     /// something else, track the total depth to ensure termination.\n     /// If this goes over a certain threshold, we abort compilation --\n     /// in such cases, we can not say whether or not the predicate\n-    /// holds for certain. Stupid halting problem. Such a drag.\n+    /// holds for certain. Stupid halting problem; such a drag.\n     pub recursion_depth: usize,\n }\n \n pub type PredicateObligation<'tcx> = Obligation<'tcx, ty::Predicate<'tcx>>;\n pub type TraitObligation<'tcx> = Obligation<'tcx, ty::PolyTraitPredicate<'tcx>>;\n \n-/// Why did we incur this obligation? Used for error reporting.\n+/// The reason why we incurred this obligation; used for error reporting.\n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n pub struct ObligationCause<'tcx> {\n     pub span: Span,\n \n-    // The id of the fn body that triggered this obligation. This is\n-    // used for region obligations to determine the precise\n-    // environment in which the region obligation should be evaluated\n-    // (in particular, closures can add new assumptions). See the\n-    // field `region_obligations` of the `FulfillmentContext` for more\n-    // information.\n-    pub body_id: ast::NodeId,\n+    /// The ID of the fn body that triggered this obligation. This is\n+    /// used for region obligations to determine the precise\n+    /// environment in which the region obligation should be evaluated\n+    /// (in particular, closures can add new assumptions). See the\n+    /// field `region_obligations` of the `FulfillmentContext` for more\n+    /// information.\n+    pub body_id: hir::HirId,\n \n     pub code: ObligationCauseCode<'tcx>\n }\n@@ -145,27 +145,28 @@ impl<'tcx> ObligationCause<'tcx> {\n             ObligationCauseCode::StartFunctionType => {\n                 tcx.sess.source_map().def_span(self.span)\n             }\n+            ObligationCauseCode::MatchExpressionArm { arm_span, .. } => arm_span,\n             _ => self.span,\n         }\n     }\n }\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n pub enum ObligationCauseCode<'tcx> {\n-    /// Not well classified or should be obvious from span.\n+    /// Not well classified or should be obvious from the span.\n     MiscObligation,\n \n-    /// A slice or array is WF only if `T: Sized`\n+    /// A slice or array is WF only if `T: Sized`.\n     SliceOrArrayElem,\n \n-    /// A tuple is WF only if its middle elements are Sized\n+    /// A tuple is WF only if its middle elements are `Sized`.\n     TupleElem,\n \n-    /// This is the trait reference from the given projection\n+    /// This is the trait reference from the given projection.\n     ProjectionWf(ty::ProjectionTy<'tcx>),\n \n-    /// In an impl of trait X for type Y, type Y must\n-    /// also implement all supertraits of X.\n+    /// In an impl of trait `X` for type `Y`, type `Y` must\n+    /// also implement all supertraits of `X`.\n     ItemObligation(DefId),\n \n     /// A type like `&'a T` is WF only if `T: 'a`.\n@@ -223,6 +224,8 @@ pub enum ObligationCauseCode<'tcx> {\n     MatchExpressionArm {\n         arm_span: Span,\n         source: hir::MatchSource,\n+        prior_arms: Vec<Span>,\n+        last_ty: Ty<'tcx>,\n     },\n \n     /// Computing common supertype in the pattern guard for the arms of a match expression\n@@ -271,7 +274,7 @@ pub struct DerivedObligationCause<'tcx> {\n     /// directly.\n     parent_trait_ref: ty::PolyTraitRef<'tcx>,\n \n-    /// The parent trait had this cause\n+    /// The parent trait had this cause.\n     parent_code: Rc<ObligationCauseCode<'tcx>>\n }\n \n@@ -280,14 +283,14 @@ pub type PredicateObligations<'tcx> = Vec<PredicateObligation<'tcx>>;\n pub type TraitObligations<'tcx> = Vec<TraitObligation<'tcx>>;\n \n /// The following types:\n-/// * `WhereClause`\n-/// * `WellFormed`\n-/// * `FromEnv`\n-/// * `DomainGoal`\n-/// * `Goal`\n-/// * `Clause`\n-/// * `Environment`\n-/// * `InEnvironment`\n+/// * `WhereClause`,\n+/// * `WellFormed`,\n+/// * `FromEnv`,\n+/// * `DomainGoal`,\n+/// * `Goal`,\n+/// * `Clause`,\n+/// * `Environment`,\n+/// * `InEnvironment`,\n /// are used for representing the trait system in the form of\n /// logic programming clauses. They are part of the interface\n /// for the chalk SLG solver.\n@@ -399,10 +402,10 @@ pub type Clauses<'tcx> = &'tcx List<Clause<'tcx>>;\n /// with the goal to solve and proceeds from there).\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct ProgramClause<'tcx> {\n-    /// This goal will be considered true...\n+    /// This goal will be considered true ...\n     pub goal: DomainGoal<'tcx>,\n \n-    /// ...if we can prove these hypotheses (there may be no hypotheses at all):\n+    /// ... if we can prove these hypotheses (there may be no hypotheses at all):\n     pub hypotheses: Goals<'tcx>,\n \n     /// Useful for filtering clauses.\n@@ -485,7 +488,6 @@ pub type SelectionResult<'tcx, T> = Result<Option<T>, SelectionError<'tcx>>;\n /// For example, the vtable may be tied to a specific impl (case A),\n /// or it may be relative to some bound that is in scope (case B).\n ///\n-///\n /// ```\n /// impl<T:Clone> Clone<T> for Option<T> { ... } // Impl_1\n /// impl<T:Clone> Clone<T> for Box<T> { ... }    // Impl_2\n@@ -517,7 +519,7 @@ pub enum Vtable<'tcx, N> {\n     /// Vtable identifying a particular impl.\n     VtableImpl(VtableImplData<'tcx, N>),\n \n-    /// Vtable for auto trait implementations\n+    /// Vtable for auto trait implementations.\n     /// This carries the information and nested obligations with regards\n     /// to an auto implementation for a trait `Trait`. The nested obligations\n     /// ensure the trait implementation holds for all the constituent types.\n@@ -529,18 +531,18 @@ pub enum Vtable<'tcx, N> {\n     /// any).\n     VtableParam(Vec<N>),\n \n-    /// Virtual calls through an object\n+    /// Virtual calls through an object.\n     VtableObject(VtableObjectData<'tcx, N>),\n \n     /// Successful resolution for a builtin trait.\n     VtableBuiltin(VtableBuiltinData<N>),\n \n-    /// Vtable automatically generated for a closure. The def ID is the ID\n+    /// Vtable automatically generated for a closure. The `DefId` is the ID\n     /// of the closure expression. This is a `VtableImpl` in spirit, but the\n     /// impl is generated by the compiler and does not appear in the source.\n     VtableClosure(VtableClosureData<'tcx, N>),\n \n-    /// Same as above, but for a fn pointer type with the given signature.\n+    /// Same as above, but for a function pointer type with the given signature.\n     VtableFnPointer(VtableFnPointerData<'tcx, N>),\n \n     /// Vtable automatically generated for a generator.\n@@ -655,7 +657,7 @@ pub fn type_known_to_meet_bound_modulo_regions<'a, 'gcx, 'tcx>(\n     };\n     let obligation = Obligation {\n         param_env,\n-        cause: ObligationCause::misc(span, ast::DUMMY_NODE_ID),\n+        cause: ObligationCause::misc(span, hir::DUMMY_HIR_ID),\n         recursion_depth: 0,\n         predicate: trait_ref.to_predicate(),\n     };\n@@ -678,7 +680,7 @@ pub fn type_known_to_meet_bound_modulo_regions<'a, 'gcx, 'tcx>(\n         // We can use a dummy node-id here because we won't pay any mind\n         // to region obligations that arise (there shouldn't really be any\n         // anyhow).\n-        let cause = ObligationCause::misc(span, ast::DUMMY_NODE_ID);\n+        let cause = ObligationCause::misc(span, hir::DUMMY_HIR_ID);\n \n         fulfill_cx.register_bound(infcx, param_env, ty, def_id, cause);\n \n@@ -1058,7 +1060,7 @@ impl<'tcx,O> Obligation<'tcx,O> {\n     }\n \n     pub fn misc(span: Span,\n-                body_id: ast::NodeId,\n+                body_id: hir::HirId,\n                 param_env: ty::ParamEnv<'tcx>,\n                 trait_ref: O)\n                 -> Obligation<'tcx, O> {\n@@ -1076,18 +1078,18 @@ impl<'tcx,O> Obligation<'tcx,O> {\n impl<'tcx> ObligationCause<'tcx> {\n     #[inline]\n     pub fn new(span: Span,\n-               body_id: ast::NodeId,\n+               body_id: hir::HirId,\n                code: ObligationCauseCode<'tcx>)\n                -> ObligationCause<'tcx> {\n-        ObligationCause { span: span, body_id: body_id, code: code }\n+        ObligationCause { span, body_id, code }\n     }\n \n-    pub fn misc(span: Span, body_id: ast::NodeId) -> ObligationCause<'tcx> {\n-        ObligationCause { span: span, body_id: body_id, code: MiscObligation }\n+    pub fn misc(span: Span, body_id: hir::HirId) -> ObligationCause<'tcx> {\n+        ObligationCause { span, body_id, code: MiscObligation }\n     }\n \n     pub fn dummy() -> ObligationCause<'tcx> {\n-        ObligationCause { span: DUMMY_SP, body_id: ast::CRATE_NODE_ID, code: MiscObligation }\n+        ObligationCause { span: DUMMY_SP, body_id: hir::CRATE_HIR_ID, code: MiscObligation }\n     }\n }\n "}, {"sha": "b31aa5998f3654ec2c29e155d06c751176189f8d", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -6,33 +6,33 @@\n //!   - have a suitable receiver from which we can extract a vtable and coerce to a \"thin\" version\n //!     that doesn't contain the vtable;\n //!   - not reference the erased type `Self` except for in this receiver;\n-//!   - not have generic type parameters\n+//!   - not have generic type parameters.\n \n use super::elaborate_predicates;\n \n-use hir::def_id::DefId;\n-use lint;\n-use traits::{self, Obligation, ObligationCause};\n-use ty::{self, Ty, TyCtxt, TypeFoldable, Predicate, ToPredicate};\n-use ty::subst::{Subst, Substs};\n+use crate::hir::def_id::DefId;\n+use crate::lint;\n+use crate::traits::{self, Obligation, ObligationCause};\n+use crate::ty::{self, Ty, TyCtxt, TypeFoldable, Predicate, ToPredicate};\n+use crate::ty::subst::{Subst, Substs};\n use std::borrow::Cow;\n use std::iter::{self};\n use syntax::ast::{self, Name};\n use syntax_pos::Span;\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub enum ObjectSafetyViolation {\n-    /// Self : Sized declared on the trait\n+    /// `Self: Sized` declared on the trait.\n     SizedSelf,\n \n     /// Supertrait reference references `Self` an in illegal location\n-    /// (e.g., `trait Foo : Bar<Self>`)\n+    /// (e.g., `trait Foo : Bar<Self>`).\n     SupertraitSelf,\n \n-    /// Method has something illegal\n+    /// Method has something illegal.\n     Method(ast::Name, MethodViolationCode),\n \n-    /// Associated const\n+    /// Associated const.\n     AssociatedConst(ast::Name),\n }\n \n@@ -84,7 +84,7 @@ pub enum MethodViolationCode {\n impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n \n     /// Returns the object safety violations that affect\n-    /// astconv - currently, Self in supertraits. This is needed\n+    /// astconv -- currently, `Self` in supertraits. This is needed\n     /// because `object_safety_violations` can't be used during\n     /// type collection.\n     pub fn astconv_object_safety_violations(self, trait_def_id: DefId)\n@@ -341,7 +341,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n             } else {\n                 // sanity check to make sure the receiver actually has the layout of a pointer\n \n-                use ty::layout::Abi;\n+                use crate::ty::layout::Abi;\n \n                 let param_env = self.param_env(method.def_id);\n \n@@ -399,8 +399,8 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         None\n     }\n \n-    /// performs a type substitution to produce the version of receiver_ty when `Self = self_ty`\n-    /// e.g., for receiver_ty = `Rc<Self>` and self_ty = `Foo`, returns `Rc<Foo>`\n+    /// Performs a type substitution to produce the version of receiver_ty when `Self = self_ty`\n+    /// e.g., for receiver_ty = `Rc<Self>` and self_ty = `Foo`, returns `Rc<Foo>`.\n     fn receiver_for_self_ty(\n         self, receiver_ty: Ty<'tcx>, self_ty: Ty<'tcx>, method_def_id: DefId\n     ) -> Ty<'tcx> {\n@@ -419,9 +419,9 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         result\n     }\n \n-    /// creates the object type for the current trait. For example,\n+    /// Creates the object type for the current trait. For example,\n     /// if the current trait is `Deref`, then this will be\n-    /// `dyn Deref<Target=Self::Target> + 'static`\n+    /// `dyn Deref<Target = Self::Target> + 'static`.\n     fn object_ty_for_trait(self, trait_def_id: DefId, lifetime: ty::Region<'tcx>) -> Ty<'tcx> {\n         debug!(\"object_ty_for_trait: trait_def_id={:?}\", trait_def_id);\n \n@@ -470,25 +470,27 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         object_ty\n     }\n \n-    /// checks the method's receiver (the `self` argument) can be dispatched on when `Self` is a\n+    /// Checks the method's receiver (the `self` argument) can be dispatched on when `Self` is a\n     /// trait object. We require that `DispatchableFromDyn` be implemented for the receiver type\n     /// in the following way:\n-    /// - let `Receiver` be the type of the `self` argument, i.e `Self`, `&Self`, `Rc<Self>`\n+    /// - let `Receiver` be the type of the `self` argument, i.e `Self`, `&Self`, `Rc<Self>`,\n     /// - require the following bound:\n     ///\n-    ///        Receiver[Self => T]: DispatchFromDyn<Receiver[Self => dyn Trait]>\n+    ///   ```\n+    ///   Receiver[Self => T]: DispatchFromDyn<Receiver[Self => dyn Trait]>\n+    ///   ```\n     ///\n-    ///    where `Foo[X => Y]` means \"the same type as `Foo`, but with `X` replaced with `Y`\"\n+    ///   where `Foo[X => Y]` means \"the same type as `Foo`, but with `X` replaced with `Y`\"\n     ///   (substitution notation).\n     ///\n-    /// some examples of receiver types and their required obligation\n-    /// - `&'a mut self` requires `&'a mut Self: DispatchFromDyn<&'a mut dyn Trait>`\n-    /// - `self: Rc<Self>` requires `Rc<Self>: DispatchFromDyn<Rc<dyn Trait>>`\n-    /// - `self: Pin<Box<Self>>` requires `Pin<Box<Self>>: DispatchFromDyn<Pin<Box<dyn Trait>>>`\n+    /// Some examples of receiver types and their required obligation:\n+    /// - `&'a mut self` requires `&'a mut Self: DispatchFromDyn<&'a mut dyn Trait>`,\n+    /// - `self: Rc<Self>` requires `Rc<Self>: DispatchFromDyn<Rc<dyn Trait>>`,\n+    /// - `self: Pin<Box<Self>>` requires `Pin<Box<Self>>: DispatchFromDyn<Pin<Box<dyn Trait>>>`.\n     ///\n     /// The only case where the receiver is not dispatchable, but is still a valid receiver\n     /// type (just not object-safe), is when there is more than one level of pointer indirection.\n-    /// e.g., `self: &&Self`, `self: &Rc<Self>`, `self: Box<Box<Self>>`. In these cases, there\n+    /// E.g., `self: &&Self`, `self: &Rc<Self>`, `self: Box<Box<Self>>`. In these cases, there\n     /// is no way, or at least no inexpensive way, to coerce the receiver from the version where\n     /// `Self = dyn Trait` to the version where `Self = T`, where `T` is the unknown erased type\n     /// contained by the trait object, because the object that needs to be coerced is behind"}, {"sha": "f61c32614cc931847700973c160074ef25b08314", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,9 +1,9 @@\n use fmt_macros::{Parser, Piece, Position};\n \n-use hir::def_id::DefId;\n-use ty::{self, TyCtxt, GenericParamDefKind};\n-use util::common::ErrorReported;\n-use util::nodemap::FxHashMap;\n+use crate::hir::def_id::DefId;\n+use crate::ty::{self, TyCtxt, GenericParamDefKind};\n+use crate::util::common::ErrorReported;\n+use crate::util::nodemap::FxHashMap;\n \n use syntax::ast::{MetaItem, NestedMetaItem};\n use syntax::attr;"}, {"sha": "5a44d886e3c0a893100b755490578bf7e4983901", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -12,16 +12,16 @@ use super::SelectionError;\n use super::{VtableImplData, VtableClosureData, VtableGeneratorData, VtableFnPointerData};\n use super::util;\n \n-use hir::def_id::DefId;\n-use infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n-use infer::type_variable::TypeVariableOrigin;\n-use mir::interpret::{GlobalId};\n+use crate::hir::def_id::DefId;\n+use crate::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n+use crate::infer::type_variable::TypeVariableOrigin;\n+use crate::mir::interpret::{GlobalId};\n use rustc_data_structures::snapshot_map::{Snapshot, SnapshotMap};\n use syntax::ast::Ident;\n-use ty::subst::{Subst, Substs};\n-use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt};\n-use ty::fold::{TypeFoldable, TypeFolder};\n-use util::common::FN_OUTPUT_NAME;\n+use crate::ty::subst::{Subst, Substs};\n+use crate::ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt};\n+use crate::ty::fold::{TypeFoldable, TypeFolder};\n+use crate::util::common::FN_OUTPUT_NAME;\n \n /// Depending on the stage of compilation, we want projection to be\n /// more or less conservative.\n@@ -55,7 +55,7 @@ pub enum Reveal {\n     /// Also, `impl Trait` is normalized to the concrete type,\n     /// which has to be already collected by type-checking.\n     ///\n-    /// NOTE: As `impl Trait`'s concrete type should *never*\n+    /// NOTE: as `impl Trait`'s concrete type should *never*\n     /// be observable directly by the user, `Reveal::All`\n     /// should not be used by checks which may expose\n     /// type equality or type contents to the user.\n@@ -408,7 +408,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n                         if let Ok(evaluated) = tcx.const_eval(param_env.and(cid)) {\n                             let substs = tcx.lift_to_global(&substs).unwrap();\n                             let evaluated = evaluated.subst(tcx, substs);\n-                            return tcx.intern_lazy_const(ty::LazyConst::Evaluated(evaluated));\n+                            return tcx.mk_lazy_const(ty::LazyConst::Evaluated(evaluated));\n                         }\n                     }\n                 } else {\n@@ -420,7 +420,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n                                 promoted: None\n                             };\n                             if let Ok(evaluated) = tcx.const_eval(param_env.and(cid)) {\n-                                return tcx.intern_lazy_const(ty::LazyConst::Evaluated(evaluated));\n+                                return tcx.mk_lazy_const(ty::LazyConst::Evaluated(evaluated));\n                             }\n                         }\n                     }\n@@ -751,9 +751,9 @@ fn prune_cache_value_obligations<'a, 'gcx, 'tcx>(infcx: &'a InferCtxt<'a, 'gcx,\n ///\n /// Concern #2. Even within the snapshot, if those original\n /// obligations are not yet proven, then we are able to do projections\n-/// that may yet turn out to be wrong.  This *may* lead to some sort\n+/// that may yet turn out to be wrong. This *may* lead to some sort\n /// of trouble, though we don't have a concrete example of how that\n-/// can occur yet.  But it seems risky at best.\n+/// can occur yet. But it seems risky at best.\n fn get_paranoid_cache_value_obligation<'a, 'gcx, 'tcx>(\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -786,7 +786,7 @@ fn get_paranoid_cache_value_obligation<'a, 'gcx, 'tcx>(\n /// cycles to arise, where you basically had a setup like `<MyType<$0>\n /// as Trait>::Foo == $0`. Here, normalizing `<MyType<$0> as\n /// Trait>::Foo> to `[type error]` would lead to an obligation of\n-/// `<MyType<[type error]> as Trait>::Foo`.  We are supposed to report\n+/// `<MyType<[type error]> as Trait>::Foo`. We are supposed to report\n /// an error for this obligation, but we legitimately should not,\n /// because it contains `[type error]`. Yuck! (See issue #29857 for\n /// one case where this arose.)\n@@ -844,7 +844,7 @@ impl<'tcx> Progress<'tcx> {\n     }\n }\n \n-/// Compute the result of a projection type (if we can).\n+/// Computes the result of a projection type (if we can).\n ///\n /// IMPORTANT:\n /// - `obligation` must be fully normalized\n@@ -1553,7 +1553,7 @@ fn assoc_ty_def<'cx, 'gcx, 'tcx>(\n // # Cache\n \n /// The projection cache. Unlike the standard caches, this can include\n-/// infcx-dependent type variables - therefore, we have to roll the\n+/// infcx-dependent type variables, therefore we have to roll the\n /// cache back each time we roll a snapshot back, to avoid assumptions\n /// on yet-unresolved inference variables. Types with placeholder\n /// regions also have to be removed when the respective snapshot ends.\n@@ -1564,9 +1564,9 @@ fn assoc_ty_def<'cx, 'gcx, 'tcx>(\n /// (for the lifetime of the infcx).\n ///\n /// Entries in the projection cache might contain inference variables\n-/// that will be resolved by obligations on the projection cache entry - e.g.\n+/// that will be resolved by obligations on the projection cache entry (e.g.,\n /// when a type parameter in the associated type is constrained through\n-/// an \"RFC 447\" projection on the impl.\n+/// an \"RFC 447\" projection on the impl).\n ///\n /// When working with a fulfillment context, the derived obligations of each\n /// projection cache entry will be registered on the fulfillcx, so any users\n@@ -1578,10 +1578,9 @@ fn assoc_ty_def<'cx, 'gcx, 'tcx>(\n /// If that is done, after evaluation the obligations, it is a good idea to\n /// call `ProjectionCache::complete` to make sure the obligations won't be\n /// re-evaluated and avoid an exponential worst-case.\n-///\n-/// FIXME: we probably also want some sort of cross-infcx cache here to\n-/// reduce the amount of duplication. Let's see what we get with the Chalk\n-/// reforms.\n+//\n+// FIXME: we probably also want some sort of cross-infcx cache here to\n+// reduce the amount of duplication. Let's see what we get with the Chalk reforms.\n #[derive(Default)]\n pub struct ProjectionCache<'tcx> {\n     map: SnapshotMap<ProjectionCacheKey<'tcx>, ProjectionCacheEntry<'tcx>>,"}, {"sha": "e6f9c7ebe6fe4931885ec1cbf609600b9e3ae8d2", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,10 +1,10 @@\n-use infer::at::At;\n-use infer::InferOk;\n-use infer::canonical::OriginalQueryValues;\n+use crate::infer::at::At;\n+use crate::infer::InferOk;\n+use crate::infer::canonical::OriginalQueryValues;\n use std::iter::FromIterator;\n use syntax::source_map::Span;\n-use ty::subst::Kind;\n-use ty::{self, Ty, TyCtxt};\n+use crate::ty::subst::Kind;\n+use crate::ty::{self, Ty, TyCtxt};\n \n impl<'cx, 'gcx, 'tcx> At<'cx, 'gcx, 'tcx> {\n     /// Given a type `ty` of some value being dropped, computes a set\n@@ -184,7 +184,7 @@ impl_stable_hash_for!(struct DtorckConstraint<'tcx> {\n /// outlive. This is similar but not *quite* the same as the\n /// `needs_drop` test in the compiler already -- that is, for every\n /// type T for which this function return true, needs-drop would\n-/// return false. But the reverse does not hold: in particular,\n+/// return `false`. But the reverse does not hold: in particular,\n /// `needs_drop` returns false for `PhantomData`, but it is not\n /// trivial for dropck-outlives.\n ///"}, {"sha": "d5230f15c256536bf36d8a80333fa7eee52770a0", "filename": "src/librustc/traits/query/evaluate_obligation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,6 +1,6 @@\n-use infer::InferCtxt;\n-use infer::canonical::OriginalQueryValues;\n-use traits::{EvaluationResult, PredicateObligation, SelectionContext,\n+use crate::infer::InferCtxt;\n+use crate::infer::canonical::OriginalQueryValues;\n+use crate::traits::{EvaluationResult, PredicateObligation, SelectionContext,\n              TraitQueryMode, OverflowError};\n \n impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {"}, {"sha": "6b9bdfd63f4d0a9e28b62e5fcabe7ee65eb38565", "filename": "src/librustc/traits/query/method_autoderef.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -1,6 +1,6 @@\n use rustc_data_structures::sync::Lrc;\n-use infer::canonical::{Canonical, QueryResponse};\n-use ty::Ty;\n+use crate::infer::canonical::{Canonical, QueryResponse};\n+use crate::ty::Ty;\n \n #[derive(Debug)]\n pub struct CandidateStep<'tcx> {"}, {"sha": "112a1d0e09c944e0b4281ebd34e3b1a51a4e8cd9", "filename": "src/librustc/traits/query/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -5,9 +5,9 @@\n //! The providers for the queries defined here can be found in\n //! `librustc_traits`.\n \n-use infer::canonical::Canonical;\n-use ty::error::TypeError;\n-use ty::{self, Ty};\n+use crate::infer::canonical::Canonical;\n+use crate::ty::error::TypeError;\n+use crate::ty::{self, Ty};\n \n pub mod dropck_outlives;\n pub mod evaluate_obligation;"}, {"sha": "224076ce17e72c29c114233c3083d3c9b7923276", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -2,15 +2,15 @@\n //! which folds deeply, invoking the underlying\n //! `normalize_projection_ty` query when it encounters projections.\n \n-use infer::at::At;\n-use infer::canonical::OriginalQueryValues;\n-use infer::{InferCtxt, InferOk};\n-use mir::interpret::GlobalId;\n-use traits::project::Normalized;\n-use traits::{Obligation, ObligationCause, PredicateObligation, Reveal};\n-use ty::fold::{TypeFoldable, TypeFolder};\n-use ty::subst::{Subst, Substs};\n-use ty::{self, Ty, TyCtxt};\n+use crate::infer::at::At;\n+use crate::infer::canonical::OriginalQueryValues;\n+use crate::infer::{InferCtxt, InferOk};\n+use crate::mir::interpret::GlobalId;\n+use crate::traits::project::Normalized;\n+use crate::traits::{Obligation, ObligationCause, PredicateObligation, Reveal};\n+use crate::ty::fold::{TypeFoldable, TypeFolder};\n+use crate::ty::subst::{Subst, Substs};\n+use crate::ty::{self, Ty, TyCtxt};\n \n use super::NoSolution;\n \n@@ -24,7 +24,7 @@ impl<'cx, 'gcx, 'tcx> At<'cx, 'gcx, 'tcx> {\n     /// the normalized value along with various outlives relations (in\n     /// the form of obligations that must be discharged).\n     ///\n-    /// NB. This will *eventually* be the main means of\n+    /// N.B., this will *eventually* be the main means of\n     /// normalizing, but for now should be used only when we actually\n     /// know that normalization will succeed, since error reporting\n     /// and other details are still \"under development\".\n@@ -203,7 +203,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx\n                         if let Ok(evaluated) = tcx.const_eval(param_env.and(cid)) {\n                             let substs = tcx.lift_to_global(&substs).unwrap();\n                             let evaluated = evaluated.subst(tcx, substs);\n-                            return tcx.intern_lazy_const(ty::LazyConst::Evaluated(evaluated));\n+                            return tcx.mk_lazy_const(ty::LazyConst::Evaluated(evaluated));\n                         }\n                     }\n                 } else {\n@@ -215,7 +215,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx\n                                 promoted: None,\n                             };\n                             if let Ok(evaluated) = tcx.const_eval(param_env.and(cid)) {\n-                                return tcx.intern_lazy_const(ty::LazyConst::Evaluated(evaluated));\n+                                return tcx.mk_lazy_const(ty::LazyConst::Evaluated(evaluated));\n                             }\n                         }\n                     }"}, {"sha": "0c1252680c1dbb861058ebcbfc4d5f880136a04e", "filename": "src/librustc/traits/query/normalize_erasing_regions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01bebdf19321a1597f35c2fc2130f1627e944bcf/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize_erasing_regions.rs?ref=01bebdf19321a1597f35c2fc2130f1627e944bcf", "patch": "@@ -7,8 +7,8 @@\n //! `normalize_ty_after_erasing_regions` query for each type found\n //! within. (This underlying query is what is cached.)\n \n-use ty::{self, Ty, TyCtxt};\n-use ty::fold::{TypeFoldable, TypeFolder};\n+use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::fold::{TypeFoldable, TypeFolder};\n \n impl<'cx, 'tcx> TyCtxt<'cx, 'tcx, 'tcx> {\n     /// Erase the regions in `value` and then fully normalize all the\n@@ -45,7 +45,7 @@ impl<'cx, 'tcx> TyCtxt<'cx, 'tcx, 'tcx> {\n     /// a `T` (with regions erased). This is appropriate when the\n     /// binder is being instantiated at the call site.\n     ///\n-    /// NB. Currently, higher-ranked type bounds inhibit\n+    /// N.B., currently, higher-ranked type bounds inhibit\n     /// normalization. Therefore, each time we erase them in\n     /// codegen, we need to normalize the contents.\n     pub fn normalize_erasing_late_bound_regions<T>("}]}