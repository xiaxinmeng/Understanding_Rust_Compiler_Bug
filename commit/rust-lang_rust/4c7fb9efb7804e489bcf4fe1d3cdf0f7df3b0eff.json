{"sha": "4c7fb9efb7804e489bcf4fe1d3cdf0f7df3b0eff", "node_id": "C_kwDOAAsO6NoAKDRjN2ZiOWVmYjc4MDRlNDg5YmNmNGZlMWQzY2RmMGY3ZGYzYjBlZmY", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-02-25T16:01:44Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-03-01T10:43:11Z"}, "message": "Add helper function to suggest multiple constraints\n\nAdd `rustc_middle::ty::suggest_constraining_type_params` that suggests\nadding multiple constraints.\n\n`suggest_constraining_type_param` now just forwards params to this new\nfunction.", "tree": {"sha": "a7c429f66aec036c452faac796a9298e136cccd9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7c429f66aec036c452faac796a9298e136cccd9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c7fb9efb7804e489bcf4fe1d3cdf0f7df3b0eff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c7fb9efb7804e489bcf4fe1d3cdf0f7df3b0eff", "html_url": "https://github.com/rust-lang/rust/commit/4c7fb9efb7804e489bcf4fe1d3cdf0f7df3b0eff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c7fb9efb7804e489bcf4fe1d3cdf0f7df3b0eff/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97cde9fe08804a3a5208d77f6870ad7d43f8c9c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/97cde9fe08804a3a5208d77f6870ad7d43f8c9c3", "html_url": "https://github.com/rust-lang/rust/commit/97cde9fe08804a3a5208d77f6870ad7d43f8c9c3"}], "stats": {"total": 399, "additions": 236, "deletions": 163}, "files": [{"sha": "f977b0fffebb665cdf53258d9914e60abd15b297", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4c7fb9efb7804e489bcf4fe1d3cdf0f7df3b0eff/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7fb9efb7804e489bcf4fe1d3cdf0f7df3b0eff/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=4c7fb9efb7804e489bcf4fe1d3cdf0f7df3b0eff", "patch": "@@ -56,6 +56,7 @@\n #![feature(nonzero_ops)]\n #![feature(unwrap_infallible)]\n #![feature(decl_macro)]\n+#![feature(drain_filter)]\n #![recursion_limit = \"512\"]\n #![allow(rustc::potential_query_instability)]\n "}, {"sha": "99a3d4c7fe4f7c11f301e6e17621909103c4d343", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 235, "deletions": 163, "changes": 398, "blob_url": "https://github.com/rust-lang/rust/blob/4c7fb9efb7804e489bcf4fe1d3cdf0f7df3b0eff/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7fb9efb7804e489bcf4fe1d3cdf0f7df3b0eff/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=4c7fb9efb7804e489bcf4fe1d3cdf0f7df3b0eff", "patch": "@@ -7,6 +7,7 @@ use crate::ty::{\n     ProjectionTy, Term, Ty, TyCtxt, TypeAndMut,\n };\n \n+use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{Applicability, Diagnostic};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n@@ -157,9 +158,17 @@ pub fn suggest_arbitrary_trait_bound(\n     true\n }\n \n+#[derive(Debug)]\n+enum SuggestChangingConstraintsMessage<'a> {\n+    RestrictBoundFurther,\n+    RestrictType { ty: &'a str },\n+    RestrictTypeFurther { ty: &'a str },\n+    RemovingQSized,\n+}\n+\n fn suggest_removing_unsized_bound(\n     generics: &hir::Generics<'_>,\n-    err: &mut Diagnostic,\n+    suggestions: &mut Vec<(Span, String, SuggestChangingConstraintsMessage<'_>)>,\n     param_name: &str,\n     param: &hir::GenericParam<'_>,\n     def_id: Option<DefId>,\n@@ -221,13 +230,12 @@ fn suggest_removing_unsized_bound(\n                         //             ^^^^^^^^^\n                         (_, pos, _, _) => bounds[pos - 1].span().shrink_to_hi().to(bound.span()),\n                     };\n-                    err.span_suggestion_verbose(\n+\n+                    suggestions.push((\n                         sp,\n-                        \"consider removing the `?Sized` bound to make the \\\n-                            type parameter `Sized`\",\n                         String::new(),\n-                        Applicability::MaybeIncorrect,\n-                    );\n+                        SuggestChangingConstraintsMessage::RemovingQSized,\n+                    ));\n                 }\n             }\n             _ => {}\n@@ -249,13 +257,12 @@ fn suggest_removing_unsized_bound(\n                     //       ^^^^^^^^^\n                     (_, pos) => param.bounds[pos - 1].span().shrink_to_hi().to(bound.span()),\n                 };\n-                err.span_suggestion_verbose(\n+\n+                suggestions.push((\n                     sp,\n-                    \"consider removing the `?Sized` bound to make the type parameter \\\n-                        `Sized`\",\n                     String::new(),\n-                    Applicability::MaybeIncorrect,\n-                );\n+                    SuggestChangingConstraintsMessage::RemovingQSized,\n+                ));\n             }\n             _ => {}\n         }\n@@ -271,184 +278,249 @@ pub fn suggest_constraining_type_param(\n     constraint: &str,\n     def_id: Option<DefId>,\n ) -> bool {\n-    let param = generics.params.iter().find(|p| p.name.ident().as_str() == param_name);\n+    suggest_constraining_type_params(\n+        tcx,\n+        generics,\n+        err,\n+        [(param_name, constraint, def_id)].into_iter(),\n+    )\n+}\n \n-    let Some(param) = param else {\n-        return false;\n-    };\n+/// Suggest restricting a type param with a new bound.\n+pub fn suggest_constraining_type_params<'a>(\n+    tcx: TyCtxt<'_>,\n+    generics: &hir::Generics<'_>,\n+    err: &mut Diagnostic,\n+    param_names_and_constraints: impl Iterator<Item = (&'a str, &'a str, Option<DefId>)>,\n+) -> bool {\n+    let mut grouped = FxHashMap::default();\n+    param_names_and_constraints.for_each(|(param_name, constraint, def_id)| {\n+        grouped.entry(param_name).or_insert(Vec::new()).push((constraint, def_id))\n+    });\n \n-    const MSG_RESTRICT_BOUND_FURTHER: &str = \"consider further restricting this bound\";\n-    let msg_restrict_type = format!(\"consider restricting type parameter `{}`\", param_name);\n-    let msg_restrict_type_further =\n-        format!(\"consider further restricting type parameter `{}`\", param_name);\n+    let mut applicability = Applicability::MachineApplicable;\n+    let mut suggestions = Vec::new();\n \n-    if def_id == tcx.lang_items().sized_trait() {\n-        // Type parameters are already `Sized` by default.\n-        err.span_label(param.span, &format!(\"this type parameter needs to be `{}`\", constraint));\n-        suggest_removing_unsized_bound(generics, err, param_name, param, def_id);\n-        return true;\n-    }\n-    let mut suggest_restrict = |span| {\n-        err.span_suggestion_verbose(\n-            span,\n-            MSG_RESTRICT_BOUND_FURTHER,\n-            format!(\" + {}\", constraint),\n-            Applicability::MachineApplicable,\n-        );\n-    };\n+    for (param_name, mut constraints) in grouped {\n+        let param = generics.params.iter().find(|p| p.name.ident().as_str() == param_name);\n+        let Some(param) = param else { return false };\n \n-    if param_name.starts_with(\"impl \") {\n-        // If there's an `impl Trait` used in argument position, suggest\n-        // restricting it:\n-        //\n-        //   fn foo(t: impl Foo) { ... }\n-        //             --------\n-        //             |\n-        //             help: consider further restricting this bound with `+ Bar`\n-        //\n-        // Suggestion for tools in this case is:\n-        //\n-        //   fn foo(t: impl Foo) { ... }\n-        //             --------\n-        //             |\n-        //             replace with: `impl Foo + Bar`\n-\n-        suggest_restrict(param.span.shrink_to_hi());\n-        return true;\n-    }\n+        {\n+            let mut sized_constraints =\n+                constraints.drain_filter(|(_, def_id)| *def_id == tcx.lang_items().sized_trait());\n+            if let Some((constraint, def_id)) = sized_constraints.next() {\n+                applicability = Applicability::MaybeIncorrect;\n \n-    if generics.where_clause.predicates.is_empty()\n-        // Given `trait Base<T = String>: Super<T>` where `T: Copy`, suggest restricting in the\n-        // `where` clause instead of `trait Base<T: Copy = String>: Super<T>`.\n-        && !matches!(param.kind, hir::GenericParamKind::Type { default: Some(_), .. })\n-    {\n-        if let Some(span) = param.bounds_span_for_suggestions() {\n-            // If user has provided some bounds, suggest restricting them:\n+                err.span_label(\n+                    param.span,\n+                    &format!(\"this type parameter needs to be `{}`\", constraint),\n+                );\n+                suggest_removing_unsized_bound(\n+                    generics,\n+                    &mut suggestions,\n+                    param_name,\n+                    param,\n+                    def_id,\n+                );\n+            }\n+        }\n+\n+        if constraints.is_empty() {\n+            continue;\n+        }\n+\n+        let constraint = constraints.iter().map(|&(c, _)| c).collect::<Vec<_>>().join(\" + \");\n+        let mut suggest_restrict = |span| {\n+            suggestions.push((\n+                span,\n+                format!(\" + {}\", constraint),\n+                SuggestChangingConstraintsMessage::RestrictBoundFurther,\n+            ))\n+        };\n+\n+        if param_name.starts_with(\"impl \") {\n+            // If there's an `impl Trait` used in argument position, suggest\n+            // restricting it:\n             //\n-            //   fn foo<T: Foo>(t: T) { ... }\n-            //             ---\n+            //   fn foo(t: impl Foo) { ... }\n+            //             --------\n             //             |\n             //             help: consider further restricting this bound with `+ Bar`\n             //\n             // Suggestion for tools in this case is:\n             //\n-            //   fn foo<T: Foo>(t: T) { ... }\n-            //          --\n-            //          |\n-            //          replace with: `T: Bar +`\n-            suggest_restrict(span);\n-        } else {\n-            // If user hasn't provided any bounds, suggest adding a new one:\n-            //\n-            //   fn foo<T>(t: T) { ... }\n-            //          - help: consider restricting this type parameter with `T: Foo`\n-            err.span_suggestion_verbose(\n-                param.span.shrink_to_hi(),\n-                &msg_restrict_type,\n-                format!(\": {}\", constraint),\n-                Applicability::MachineApplicable,\n-            );\n+            //   fn foo(t: impl Foo) { ... }\n+            //             --------\n+            //             |\n+            //             replace with: `impl Foo + Bar`\n+\n+            suggest_restrict(param.span.shrink_to_hi());\n+            continue;\n         }\n \n-        true\n-    } else {\n-        // This part is a bit tricky, because using the `where` clause user can\n-        // provide zero, one or many bounds for the same type parameter, so we\n-        // have following cases to consider:\n-        //\n-        // 1) When the type parameter has been provided zero bounds\n-        //\n-        //    Message:\n-        //      fn foo<X, Y>(x: X, y: Y) where Y: Foo { ... }\n-        //             - help: consider restricting this type parameter with `where X: Bar`\n-        //\n-        //    Suggestion:\n-        //      fn foo<X, Y>(x: X, y: Y) where Y: Foo { ... }\n-        //                                           - insert: `, X: Bar`\n-        //\n-        //\n-        // 2) When the type parameter has been provided one bound\n-        //\n-        //    Message:\n-        //      fn foo<T>(t: T) where T: Foo { ... }\n-        //                            ^^^^^^\n-        //                            |\n-        //                            help: consider further restricting this bound with `+ Bar`\n-        //\n-        //    Suggestion:\n-        //      fn foo<T>(t: T) where T: Foo { ... }\n-        //                            ^^\n-        //                            |\n-        //                            replace with: `T: Bar +`\n-        //\n-        //\n-        // 3) When the type parameter has been provided many bounds\n-        //\n-        //    Message:\n-        //      fn foo<T>(t: T) where T: Foo, T: Bar {... }\n-        //             - help: consider further restricting this type parameter with `where T: Zar`\n-        //\n-        //    Suggestion:\n-        //      fn foo<T>(t: T) where T: Foo, T: Bar {... }\n-        //                                          - insert: `, T: Zar`\n-        //\n-        // Additionally, there may be no `where` clause whatsoever in the case that this was\n-        // reached because the generic parameter has a default:\n-        //\n-        //    Message:\n-        //      trait Foo<T=()> {... }\n-        //             - help: consider further restricting this type parameter with `where T: Zar`\n-        //\n-        //    Suggestion:\n-        //      trait Foo<T=()> where T: Zar {... }\n-        //                     - insert: `where T: Zar`\n-\n-        if matches!(param.kind, hir::GenericParamKind::Type { default: Some(_), .. })\n-            && generics.where_clause.predicates.len() == 0\n+        if generics.where_clause.predicates.is_empty()\n+        // Given `trait Base<T = String>: Super<T>` where `T: Copy`, suggest restricting in the\n+        // `where` clause instead of `trait Base<T: Copy = String>: Super<T>`.\n+        && !matches!(param.kind, hir::GenericParamKind::Type { default: Some(_), .. })\n         {\n-            // Suggest a bound, but there is no existing `where` clause *and* the type param has a\n-            // default (`<T=Foo>`), so we suggest adding `where T: Bar`.\n-            err.span_suggestion_verbose(\n-                generics.where_clause.tail_span_for_suggestion(),\n-                &msg_restrict_type_further,\n-                format!(\" where {}: {}\", param_name, constraint),\n-                Applicability::MachineApplicable,\n-            );\n+            if let Some(span) = param.bounds_span_for_suggestions() {\n+                // If user has provided some bounds, suggest restricting them:\n+                //\n+                //   fn foo<T: Foo>(t: T) { ... }\n+                //             ---\n+                //             |\n+                //             help: consider further restricting this bound with `+ Bar`\n+                //\n+                // Suggestion for tools in this case is:\n+                //\n+                //   fn foo<T: Foo>(t: T) { ... }\n+                //          --\n+                //          |\n+                //          replace with: `T: Bar +`\n+                suggest_restrict(span);\n+            } else {\n+                // If user hasn't provided any bounds, suggest adding a new one:\n+                //\n+                //   fn foo<T>(t: T) { ... }\n+                //          - help: consider restricting this type parameter with `T: Foo`\n+                suggestions.push((\n+                    param.span.shrink_to_hi(),\n+                    format!(\": {}\", constraint),\n+                    SuggestChangingConstraintsMessage::RestrictType { ty: param_name },\n+                ));\n+            }\n         } else {\n-            let mut param_spans = Vec::new();\n+            // This part is a bit tricky, because using the `where` clause user can\n+            // provide zero, one or many bounds for the same type parameter, so we\n+            // have following cases to consider:\n+            //\n+            // 1) When the type parameter has been provided zero bounds\n+            //\n+            //    Message:\n+            //      fn foo<X, Y>(x: X, y: Y) where Y: Foo { ... }\n+            //             - help: consider restricting this type parameter with `where X: Bar`\n+            //\n+            //    Suggestion:\n+            //      fn foo<X, Y>(x: X, y: Y) where Y: Foo { ... }\n+            //                                           - insert: `, X: Bar`\n+            //\n+            //\n+            // 2) When the type parameter has been provided one bound\n+            //\n+            //    Message:\n+            //      fn foo<T>(t: T) where T: Foo { ... }\n+            //                            ^^^^^^\n+            //                            |\n+            //                            help: consider further restricting this bound with `+ Bar`\n+            //\n+            //    Suggestion:\n+            //      fn foo<T>(t: T) where T: Foo { ... }\n+            //                            ^^\n+            //                            |\n+            //                            replace with: `T: Bar +`\n+            //\n+            //\n+            // 3) When the type parameter has been provided many bounds\n+            //\n+            //    Message:\n+            //      fn foo<T>(t: T) where T: Foo, T: Bar {... }\n+            //             - help: consider further restricting this type parameter with `where T: Zar`\n+            //\n+            //    Suggestion:\n+            //      fn foo<T>(t: T) where T: Foo, T: Bar {... }\n+            //                                          - insert: `, T: Zar`\n+            //\n+            // Additionally, there may be no `where` clause whatsoever in the case that this was\n+            // reached because the generic parameter has a default:\n+            //\n+            //    Message:\n+            //      trait Foo<T=()> {... }\n+            //             - help: consider further restricting this type parameter with `where T: Zar`\n+            //\n+            //    Suggestion:\n+            //      trait Foo<T=()> where T: Zar {... }\n+            //                     - insert: `where T: Zar`\n \n-            for predicate in generics.where_clause.predicates {\n-                if let WherePredicate::BoundPredicate(WhereBoundPredicate {\n-                    span,\n-                    bounded_ty,\n-                    ..\n-                }) = predicate\n-                {\n-                    if let TyKind::Path(QPath::Resolved(_, path)) = &bounded_ty.kind {\n-                        if let Some(segment) = path.segments.first() {\n-                            if segment.ident.to_string() == param_name {\n-                                param_spans.push(span);\n+            if matches!(param.kind, hir::GenericParamKind::Type { default: Some(_), .. })\n+                && generics.where_clause.predicates.len() == 0\n+            {\n+                // Suggest a bound, but there is no existing `where` clause *and* the type param has a\n+                // default (`<T=Foo>`), so we suggest adding `where T: Bar`.\n+                suggestions.push((\n+                    generics.where_clause.tail_span_for_suggestion(),\n+                    format!(\" where {}: {}\", param_name, constraint),\n+                    SuggestChangingConstraintsMessage::RestrictTypeFurther { ty: param_name },\n+                ));\n+            } else {\n+                let mut param_spans = Vec::new();\n+\n+                for predicate in generics.where_clause.predicates {\n+                    if let WherePredicate::BoundPredicate(WhereBoundPredicate {\n+                        span,\n+                        bounded_ty,\n+                        ..\n+                    }) = predicate\n+                    {\n+                        if let TyKind::Path(QPath::Resolved(_, path)) = &bounded_ty.kind {\n+                            if let Some(segment) = path.segments.first() {\n+                                if segment.ident.to_string() == param_name {\n+                                    param_spans.push(span);\n+                                }\n                             }\n                         }\n                     }\n                 }\n-            }\n \n-            match param_spans[..] {\n-                [&param_span] => suggest_restrict(param_span.shrink_to_hi()),\n-                _ => {\n-                    err.span_suggestion_verbose(\n-                        generics.where_clause.tail_span_for_suggestion(),\n-                        &msg_restrict_type_further,\n-                        format!(\", {}: {}\", param_name, constraint),\n-                        Applicability::MachineApplicable,\n-                    );\n+                match param_spans[..] {\n+                    [&param_span] => suggest_restrict(param_span.shrink_to_hi()),\n+                    _ => {\n+                        suggestions.push((\n+                            generics.where_clause.tail_span_for_suggestion(),\n+                            constraints\n+                                .iter()\n+                                .map(|&(constraint, _)| format!(\", {}: {}\", param_name, constraint))\n+                                .collect::<String>(),\n+                            SuggestChangingConstraintsMessage::RestrictTypeFurther {\n+                                ty: param_name,\n+                            },\n+                        ));\n+                    }\n                 }\n             }\n         }\n+    }\n \n-        true\n+    if suggestions.len() == 1 {\n+        let (span, suggestion, msg) = suggestions.pop().unwrap();\n+\n+        let s;\n+        let msg = match msg {\n+            SuggestChangingConstraintsMessage::RestrictBoundFurther => {\n+                \"consider further restricting this bound\"\n+            }\n+            SuggestChangingConstraintsMessage::RestrictType { ty } => {\n+                s = format!(\"consider restricting type parameter `{}`\", ty);\n+                &s\n+            }\n+            SuggestChangingConstraintsMessage::RestrictTypeFurther { ty } => {\n+                s = format!(\"consider further restricting type parameter `{}`\", ty);\n+                &s\n+            }\n+            SuggestChangingConstraintsMessage::RemovingQSized => {\n+                \"consider removing the `?Sized` bound to make the type parameter `Sized`\"\n+            }\n+        };\n+\n+        err.span_suggestion_verbose(span, msg, suggestion, applicability);\n+    } else {\n+        err.multipart_suggestion_verbose(\n+            \"consider restricting type parameters\",\n+            suggestions.into_iter().map(|(span, suggestion, _)| (span, suggestion)).collect(),\n+            applicability,\n+        );\n     }\n+\n+    true\n }\n \n /// Collect al types that have an implicit `'static` obligation that we could suggest `'_` for."}]}