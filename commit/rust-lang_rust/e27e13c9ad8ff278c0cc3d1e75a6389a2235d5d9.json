{"sha": "e27e13c9ad8ff278c0cc3d1e75a6389a2235d5d9", "node_id": "C_kwDOAAsO6NoAKGUyN2UxM2M5YWQ4ZmYyNzhjMGNjM2QxZTc1YTYzODlhMjIzNWQ1ZDk", "commit": {"author": {"name": "Gary Guo", "email": "gary@garyguo.net", "date": "2022-10-27T17:49:07Z"}, "committer": {"name": "Gary Guo", "email": "gary@garyguo.net", "date": "2022-10-27T17:49:07Z"}, "message": "Ensure new_ret_no_self is not fired if `impl Trait<Self>` is returned.", "tree": {"sha": "88cb4a62ef337fe20808271106939ea09e89297b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88cb4a62ef337fe20808271106939ea09e89297b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e27e13c9ad8ff278c0cc3d1e75a6389a2235d5d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e27e13c9ad8ff278c0cc3d1e75a6389a2235d5d9", "html_url": "https://github.com/rust-lang/rust/commit/e27e13c9ad8ff278c0cc3d1e75a6389a2235d5d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e27e13c9ad8ff278c0cc3d1e75a6389a2235d5d9/comments", "author": {"login": "nbdd0121", "id": 4065244, "node_id": "MDQ6VXNlcjQwNjUyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4065244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nbdd0121", "html_url": "https://github.com/nbdd0121", "followers_url": "https://api.github.com/users/nbdd0121/followers", "following_url": "https://api.github.com/users/nbdd0121/following{/other_user}", "gists_url": "https://api.github.com/users/nbdd0121/gists{/gist_id}", "starred_url": "https://api.github.com/users/nbdd0121/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nbdd0121/subscriptions", "organizations_url": "https://api.github.com/users/nbdd0121/orgs", "repos_url": "https://api.github.com/users/nbdd0121/repos", "events_url": "https://api.github.com/users/nbdd0121/events{/privacy}", "received_events_url": "https://api.github.com/users/nbdd0121/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nbdd0121", "id": 4065244, "node_id": "MDQ6VXNlcjQwNjUyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4065244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nbdd0121", "html_url": "https://github.com/nbdd0121", "followers_url": "https://api.github.com/users/nbdd0121/followers", "following_url": "https://api.github.com/users/nbdd0121/following{/other_user}", "gists_url": "https://api.github.com/users/nbdd0121/gists{/gist_id}", "starred_url": "https://api.github.com/users/nbdd0121/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nbdd0121/subscriptions", "organizations_url": "https://api.github.com/users/nbdd0121/orgs", "repos_url": "https://api.github.com/users/nbdd0121/repos", "events_url": "https://api.github.com/users/nbdd0121/events{/privacy}", "received_events_url": "https://api.github.com/users/nbdd0121/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40af5be525903f0df63cd738eff97c17baafa2a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/40af5be525903f0df63cd738eff97c17baafa2a1", "html_url": "https://github.com/rust-lang/rust/commit/40af5be525903f0df63cd738eff97c17baafa2a1"}], "stats": {"total": 82, "additions": 54, "deletions": 28}, "files": [{"sha": "6665329d1148f6701997a8773bcea42e584e1a68", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 2, "deletions": 28, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e27e13c9ad8ff278c0cc3d1e75a6389a2235d5d9/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e27e13c9ad8ff278c0cc3d1e75a6389a2235d5d9/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=e27e13c9ad8ff278c0cc3d1e75a6389a2235d5d9", "patch": "@@ -103,7 +103,7 @@ mod zst_offset;\n use bind_instead_of_map::BindInsteadOfMap;\n use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help};\n-use clippy_utils::ty::{contains_adt_constructor, implements_trait, is_copy, is_type_diagnostic_item};\n+use clippy_utils::ty::{contains_ty_adt_constructor_opaque, implements_trait, is_copy, is_type_diagnostic_item};\n use clippy_utils::{contains_return, is_trait_method, iter_input_pats, meets_msrv, msrvs, return_ty};\n use if_chain::if_chain;\n use rustc_hir as hir;\n@@ -3394,36 +3394,10 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n         if let hir::ImplItemKind::Fn(_, _) = impl_item.kind {\n             let ret_ty = return_ty(cx, impl_item.hir_id());\n \n-            // walk the return type and check for Self (this does not check associated types)\n-            if let Some(self_adt) = self_ty.ty_adt_def() {\n-                if contains_adt_constructor(ret_ty, self_adt) {\n-                    return;\n-                }\n-            } else if ret_ty.contains(self_ty) {\n+            if contains_ty_adt_constructor_opaque(cx, ret_ty, self_ty) {\n                 return;\n             }\n \n-            // if return type is impl trait, check the associated types\n-            if let ty::Opaque(def_id, _) = *ret_ty.kind() {\n-                // one of the associated types must be Self\n-                for &(predicate, _span) in cx.tcx.explicit_item_bounds(def_id) {\n-                    if let ty::PredicateKind::Projection(projection_predicate) = predicate.kind().skip_binder() {\n-                        let assoc_ty = match projection_predicate.term.unpack() {\n-                            ty::TermKind::Ty(ty) => ty,\n-                            ty::TermKind::Const(_c) => continue,\n-                        };\n-                        // walk the associated type and check for Self\n-                        if let Some(self_adt) = self_ty.ty_adt_def() {\n-                            if contains_adt_constructor(assoc_ty, self_adt) {\n-                                return;\n-                            }\n-                        } else if assoc_ty.contains(self_ty) {\n-                            return;\n-                        }\n-                    }\n-                }\n-            }\n-\n             if name == \"new\" && ret_ty != self_ty {\n                 span_lint(\n                     cx,"}, {"sha": "2dd8c826ab38288fa47e9d18ff6df193dbbb7334", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e27e13c9ad8ff278c0cc3d1e75a6389a2235d5d9/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e27e13c9ad8ff278c0cc3d1e75a6389a2235d5d9/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=e27e13c9ad8ff278c0cc3d1e75a6389a2235d5d9", "patch": "@@ -59,6 +59,58 @@ pub fn contains_adt_constructor<'tcx>(ty: Ty<'tcx>, adt: AdtDef<'tcx>) -> bool {\n     })\n }\n \n+/// Walks into `ty` and returns `true` if any inner type is an instance of the given type, or adt\n+/// constructor of the same type.\n+///\n+/// This method also recurses into opaque type predicates, so call it with `impl Trait<U>` and `U`\n+/// will also return `true`.\n+pub fn contains_ty_adt_constructor_opaque<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, needle: Ty<'tcx>) -> bool {\n+    ty.walk().any(|inner| match inner.unpack() {\n+        GenericArgKind::Type(inner_ty) => {\n+            if inner_ty == needle {\n+                return true;\n+            }\n+\n+            if inner_ty.ty_adt_def() == needle.ty_adt_def() {\n+                return true;\n+            }\n+\n+            if let ty::Opaque(def_id, _) = *inner_ty.kind() {\n+                for &(predicate, _span) in cx.tcx.explicit_item_bounds(def_id) {\n+                    match predicate.kind().skip_binder() {\n+                        // For `impl Trait<U>`, it will register a predicate of `T: Trait<U>`, so we go through\n+                        // and check substituions to find `U`.\n+                        ty::PredicateKind::Trait(trait_predicate) => {\n+                            if trait_predicate\n+                                .trait_ref\n+                                .substs\n+                                .types()\n+                                .skip(1) // Skip the implicit `Self` generic parameter\n+                                .any(|ty| contains_ty_adt_constructor_opaque(cx, ty, needle))\n+                            {\n+                                return true;\n+                            }\n+                        },\n+                        // For `impl Trait<Assoc=U>`, it will register a predicate of `<T as Trait>::Assoc = U`,\n+                        // so we check the term for `U`.\n+                        ty::PredicateKind::Projection(projection_predicate) => {\n+                            if let ty::TermKind::Ty(ty) = projection_predicate.term.unpack() {\n+                                if contains_ty_adt_constructor_opaque(cx, ty, needle) {\n+                                    return true;\n+                                }\n+                            };\n+                        },\n+                        _ => (),\n+                    }\n+                }\n+            }\n+\n+            false\n+        },\n+        GenericArgKind::Lifetime(_) | GenericArgKind::Const(_) => false,\n+    })\n+}\n+\n /// Resolves `<T as Iterator>::Item` for `T`\n /// Do not invoke without first verifying that the type implements `Iterator`\n pub fn get_iterator_item_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {"}]}