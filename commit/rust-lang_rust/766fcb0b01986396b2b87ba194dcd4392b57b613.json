{"sha": "766fcb0b01986396b2b87ba194dcd4392b57b613", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2NmZjYjBiMDE5ODYzOTZiMmI4N2JhMTk0ZGNkNDM5MmI1N2I2MTM=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-08-20T21:34:40Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-08-22T18:14:07Z"}, "message": "Refactor dynamic library error checking on *nix\n\nThe old code was checking `dlerror` more often than necessary, since the\nreturn value of `dlopen` indicates whether an error occurred.", "tree": {"sha": "88f8a9aef7c0325a8793c269edb89da36921a619", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88f8a9aef7c0325a8793c269edb89da36921a619"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/766fcb0b01986396b2b87ba194dcd4392b57b613", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/766fcb0b01986396b2b87ba194dcd4392b57b613", "html_url": "https://github.com/rust-lang/rust/commit/766fcb0b01986396b2b87ba194dcd4392b57b613", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/766fcb0b01986396b2b87ba194dcd4392b57b613/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "527a685e40d8fbe61442bdbd510c2b4e1d248019", "url": "https://api.github.com/repos/rust-lang/rust/commits/527a685e40d8fbe61442bdbd510c2b4e1d248019", "html_url": "https://github.com/rust-lang/rust/commit/527a685e40d8fbe61442bdbd510c2b4e1d248019"}], "stats": {"total": 95, "additions": 61, "deletions": 34}, "files": [{"sha": "6867097d37294ee4e50ecd2dc6eb56ef0ea44db0", "filename": "src/librustc_metadata/dynamic_lib.rs", "status": "modified", "additions": 60, "deletions": 34, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/766fcb0b01986396b2b87ba194dcd4392b57b613/src%2Flibrustc_metadata%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/766fcb0b01986396b2b87ba194dcd4392b57b613/src%2Flibrustc_metadata%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdynamic_lib.rs?ref=766fcb0b01986396b2b87ba194dcd4392b57b613", "patch": "@@ -51,51 +51,77 @@ mod tests;\n \n #[cfg(unix)]\n mod dl {\n-    use std::ffi::{CStr, CString, OsStr};\n+    use std::ffi::{CString, OsStr};\n     use std::os::unix::prelude::*;\n-    use std::ptr;\n-    use std::str;\n \n-    pub(super) fn open(filename: &OsStr) -> Result<*mut u8, String> {\n-        check_for_errors_in(|| unsafe {\n-            let s = CString::new(filename.as_bytes()).unwrap();\n-            libc::dlopen(s.as_ptr(), libc::RTLD_LAZY) as *mut u8\n-        })\n-    }\n+    // `dlerror` is process global, so we can only allow a single thread at a\n+    // time to call `dlsym` and `dlopen` if we want to check the error message.\n+    mod error {\n+        use std::ffi::CStr;\n+        use std::lazy::SyncLazy;\n+        use std::sync::{Mutex, MutexGuard};\n \n-    fn check_for_errors_in<T, F>(f: F) -> Result<T, String>\n-    where\n-        F: FnOnce() -> T,\n-    {\n-        use std::sync::{Mutex, Once};\n-        static INIT: Once = Once::new();\n-        static mut LOCK: *mut Mutex<()> = ptr::null_mut();\n-        unsafe {\n-            INIT.call_once(|| {\n-                LOCK = Box::into_raw(Box::new(Mutex::new(())));\n-            });\n-            // dlerror isn't thread safe, so we need to lock around this entire\n-            // sequence\n-            let _guard = (*LOCK).lock();\n-            let _old_error = libc::dlerror();\n-\n-            let result = f();\n-\n-            let last_error = libc::dlerror() as *const _;\n-            if ptr::null() == last_error {\n-                Ok(result)\n-            } else {\n-                let s = CStr::from_ptr(last_error).to_bytes();\n-                Err(str::from_utf8(s).unwrap().to_owned())\n+        pub fn lock() -> MutexGuard<'static, Guard> {\n+            static LOCK: SyncLazy<Mutex<Guard>> = SyncLazy::new(|| Mutex::new(Guard { _priv: () }));\n+            LOCK.lock().unwrap()\n+        }\n+\n+        pub struct Guard {\n+            _priv: (),\n+        }\n+\n+        impl Guard {\n+            pub fn get(&mut self) -> Result<(), String> {\n+                let msg = unsafe { libc::dlerror() };\n+                if msg.is_null() {\n+                    Ok(())\n+                } else {\n+                    let msg = unsafe { CStr::from_ptr(msg as *const _) };\n+                    Err(msg.to_string_lossy().into_owned())\n+                }\n             }\n+\n+            pub fn clear(&mut self) {\n+                let _ = unsafe { libc::dlerror() };\n+            }\n+        }\n+    }\n+\n+    pub(super) fn open(filename: &OsStr) -> Result<*mut u8, String> {\n+        let s = CString::new(filename.as_bytes()).unwrap();\n+\n+        let mut dlerror = error::lock();\n+        let ret = unsafe { libc::dlopen(s.as_ptr(), libc::RTLD_LAZY) } as *mut u8;\n+\n+        if !ret.is_null() {\n+            return Ok(ret);\n         }\n+\n+        // A NULL return from `dlopen` indicates that an error has\n+        // definitely occurred, so if nothing is in `dlerror`, we are\n+        // racing with another thread that has stolen our error message.\n+        dlerror.get().and_then(|()| Err(\"Unknown error\".to_string()))\n     }\n \n     pub(super) unsafe fn symbol(\n         handle: *mut u8,\n         symbol: *const libc::c_char,\n     ) -> Result<*mut u8, String> {\n-        check_for_errors_in(|| libc::dlsym(handle as *mut libc::c_void, symbol) as *mut u8)\n+        let mut dlerror = error::lock();\n+\n+        // Flush `dlerror` since we need to use it to determine whether the subsequent call to\n+        // `dlsym` is successful.\n+        dlerror.clear();\n+\n+        let ret = libc::dlsym(handle as *mut libc::c_void, symbol) as *mut u8;\n+\n+        // A non-NULL return value *always* indicates success. There's no need\n+        // to check `dlerror`.\n+        if !ret.is_null() {\n+            return Ok(ret);\n+        }\n+\n+        dlerror.get().map(|()| ret)\n     }\n \n     pub(super) unsafe fn close(handle: *mut u8) {"}, {"sha": "85490f5f6e91ab1e1b956e4753440c7cb343a740", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/766fcb0b01986396b2b87ba194dcd4392b57b613/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/766fcb0b01986396b2b87ba194dcd4392b57b613/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=766fcb0b01986396b2b87ba194dcd4392b57b613", "patch": "@@ -5,6 +5,7 @@\n #![feature(drain_filter)]\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n+#![feature(once_cell)]\n #![feature(or_patterns)]\n #![feature(proc_macro_internals)]\n #![feature(min_specialization)]"}]}