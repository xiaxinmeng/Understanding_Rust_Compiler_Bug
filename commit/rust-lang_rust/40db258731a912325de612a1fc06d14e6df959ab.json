{"sha": "40db258731a912325de612a1fc06d14e6df959ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwZGIyNTg3MzFhOTEyMzI1ZGU2MTJhMWZjMDZkMTRlNmRmOTU5YWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-15T04:48:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-15T04:48:42Z"}, "message": "Auto merge of #87974 - steffahn:slice_split_size_hints, r=dtolnay\n\nTest and fix `size_hint` for slice\u2019s [r]split* iterators\n\nAdds extensive test (of `size_hint`) for all the _[r]split*_ iterators.\nFixes `size_hint` upper bound for _split_inclusive*_ iterators which was one higher than necessary for non-empty slices.\nFixes `size_hint` lower bound for _[r]splitn*_ iterators when _n == 0_, which was one too high.\n\n**Lower bound being one too high was a logic error, violating the correctness condition of `size_hint`.**\n\n_Edit:_ I\u2019ve opened an issue for that bug, so this PR fixes #87978", "tree": {"sha": "5a141a959a90ddb968f6dd3fe002615bb37e8c1c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a141a959a90ddb968f6dd3fe002615bb37e8c1c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40db258731a912325de612a1fc06d14e6df959ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40db258731a912325de612a1fc06d14e6df959ab", "html_url": "https://github.com/rust-lang/rust/commit/40db258731a912325de612a1fc06d14e6df959ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40db258731a912325de612a1fc06d14e6df959ab/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85109e257ac97a0904106cafaf6e014c1d812326", "url": "https://api.github.com/repos/rust-lang/rust/commits/85109e257ac97a0904106cafaf6e014c1d812326", "html_url": "https://github.com/rust-lang/rust/commit/85109e257ac97a0904106cafaf6e014c1d812326"}, {"sha": "3f0d04e97b6e595fdff4895dfc4a35a2bd39f739", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f0d04e97b6e595fdff4895dfc4a35a2bd39f739", "html_url": "https://github.com/rust-lang/rust/commit/3f0d04e97b6e595fdff4895dfc4a35a2bd39f739"}], "stats": {"total": 94, "additions": 86, "deletions": 8}, "files": [{"sha": "13b8c059e37aef11756719ea9ac3bf00e2457d9b", "filename": "library/alloc/tests/slice.rs", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/40db258731a912325de612a1fc06d14e6df959ab/library%2Falloc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40db258731a912325de612a1fc06d14e6df959ab/library%2Falloc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fslice.rs?ref=40db258731a912325de612a1fc06d14e6df959ab", "patch": "@@ -1,6 +1,7 @@\n use std::cell::Cell;\n use std::cmp::Ordering::{self, Equal, Greater, Less};\n use std::convert::identity;\n+use std::fmt;\n use std::mem;\n use std::panic;\n use std::rc::Rc;\n@@ -993,6 +994,66 @@ fn test_rsplitnator() {\n     assert!(xs.rsplitn(0, |x| *x % 2 == 0).next().is_none());\n }\n \n+#[test]\n+fn test_split_iterators_size_hint() {\n+    #[derive(Copy, Clone)]\n+    enum Bounds {\n+        Lower,\n+        Upper,\n+    }\n+    fn assert_tight_size_hints(mut it: impl Iterator, which: Bounds, ctx: impl fmt::Display) {\n+        match which {\n+            Bounds::Lower => {\n+                let mut lower_bounds = vec![it.size_hint().0];\n+                while let Some(_) = it.next() {\n+                    lower_bounds.push(it.size_hint().0);\n+                }\n+                let target: Vec<_> = (0..lower_bounds.len()).rev().collect();\n+                assert_eq!(lower_bounds, target, \"lower bounds incorrect or not tight: {}\", ctx);\n+            }\n+            Bounds::Upper => {\n+                let mut upper_bounds = vec![it.size_hint().1];\n+                while let Some(_) = it.next() {\n+                    upper_bounds.push(it.size_hint().1);\n+                }\n+                let target: Vec<_> = (0..upper_bounds.len()).map(Some).rev().collect();\n+                assert_eq!(upper_bounds, target, \"upper bounds incorrect or not tight: {}\", ctx);\n+            }\n+        }\n+    }\n+\n+    for len in 0..=2 {\n+        let mut v: Vec<u8> = (0..len).collect();\n+\n+        // p: predicate, b: bound selection\n+        for (p, b) in [\n+            // with a predicate always returning false, the split*-iterators\n+            // become maximally short, so the size_hint lower bounds are tight\n+            ((|_| false) as fn(&_) -> _, Bounds::Lower),\n+            // with a predicate always returning true, the split*-iterators\n+            // become maximally long, so the size_hint upper bounds are tight\n+            ((|_| true) as fn(&_) -> _, Bounds::Upper),\n+        ] {\n+            use assert_tight_size_hints as a;\n+            use format_args as f;\n+\n+            a(v.split(p), b, \"split\");\n+            a(v.split_mut(p), b, \"split_mut\");\n+            a(v.split_inclusive(p), b, \"split_inclusive\");\n+            a(v.split_inclusive_mut(p), b, \"split_inclusive_mut\");\n+            a(v.rsplit(p), b, \"rsplit\");\n+            a(v.rsplit_mut(p), b, \"rsplit_mut\");\n+\n+            for n in 0..=3 {\n+                a(v.splitn(n, p), b, f!(\"splitn, n = {}\", n));\n+                a(v.splitn_mut(n, p), b, f!(\"splitn_mut, n = {}\", n));\n+                a(v.rsplitn(n, p), b, f!(\"rsplitn, n = {}\", n));\n+                a(v.rsplitn_mut(n, p), b, f!(\"rsplitn_mut, n = {}\", n));\n+            }\n+        }\n+    }\n+}\n+\n #[test]\n fn test_windowsator() {\n     let v = &[1, 2, 3, 4];"}, {"sha": "c0dfba490eca7dd7b12f5204ad052b34d206f85d", "filename": "library/core/src/slice/iter.rs", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/40db258731a912325de612a1fc06d14e6df959ab/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40db258731a912325de612a1fc06d14e6df959ab/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs?ref=40db258731a912325de612a1fc06d14e6df959ab", "patch": "@@ -400,7 +400,13 @@ where\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        if self.finished { (0, Some(0)) } else { (1, Some(self.v.len() + 1)) }\n+        if self.finished {\n+            (0, Some(0))\n+        } else {\n+            // If the predicate doesn't match anything, we yield one slice.\n+            // If it matches every element, we yield `len() + 1` empty slices.\n+            (1, Some(self.v.len() + 1))\n+        }\n     }\n }\n \n@@ -525,7 +531,14 @@ where\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        if self.finished { (0, Some(0)) } else { (1, Some(self.v.len() + 1)) }\n+        if self.finished {\n+            (0, Some(0))\n+        } else {\n+            // If the predicate doesn't match anything, we yield one slice.\n+            // If it matches every element, we yield `len()` one-element slices,\n+            // or a single empty slice.\n+            (1, Some(cmp::max(1, self.v.len())))\n+        }\n     }\n }\n \n@@ -647,8 +660,8 @@ where\n         if self.finished {\n             (0, Some(0))\n         } else {\n-            // if the predicate doesn't match anything, we yield one slice\n-            // if it matches every element, we yield len+1 empty slices.\n+            // If the predicate doesn't match anything, we yield one slice.\n+            // If it matches every element, we yield `len() + 1` empty slices.\n             (1, Some(self.v.len() + 1))\n         }\n     }\n@@ -763,9 +776,10 @@ where\n         if self.finished {\n             (0, Some(0))\n         } else {\n-            // if the predicate doesn't match anything, we yield one slice\n-            // if it matches every element, we yield len+1 empty slices.\n-            (1, Some(self.v.len() + 1))\n+            // If the predicate doesn't match anything, we yield one slice.\n+            // If it matches every element, we yield `len()` one-element slices,\n+            // or a single empty slice.\n+            (1, Some(cmp::max(1, self.v.len())))\n         }\n     }\n }\n@@ -1008,7 +1022,10 @@ impl<T, I: SplitIter<Item = T>> Iterator for GenericSplitN<I> {\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         let (lower, upper_opt) = self.iter.size_hint();\n-        (lower, upper_opt.map(|upper| cmp::min(self.count, upper)))\n+        (\n+            cmp::min(self.count, lower),\n+            Some(upper_opt.map_or(self.count, |upper| cmp::min(self.count, upper))),\n+        )\n     }\n }\n "}]}