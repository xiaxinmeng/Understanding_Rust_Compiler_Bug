{"sha": "0d0f753955afe5c79d260b03f7fbe68ee53d4950", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkMGY3NTM5NTVhZmU1Yzc5ZDI2MGIwM2Y3ZmJlNjhlZTUzZDQ5NTA=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-24T21:45:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-24T21:45:24Z"}, "message": "Rollup merge of #64698 - Centril:infer-const-with-stash, r=estebank\n\nRecover on `const X = 42;` and infer type + Error Stash API\n\nHere we:\n\n1. Introduce a notion of the \"error stash\".\n\n   This is a map in the `Handler` to which you can `err.stash(...)` away your diagnostics and then steal them in a later \"phase\" of the compiler (e.g. stash in parser, steal in typeck) to enrich them with more information that isn't available in the previous \"phase\".\n\n    I believe I've covered all the bases to make sure these diagnostics are actually emitted eventually even under `#[cfg(FALSE)]` but please check my logic.\n\n2. Recover when parsing `[const | static mut?] $ident = $expr;` which has a missing type.\n\n    Use the \"error stash\" to stash away the error and later steal the error in typeck where we emit the error as `MachineApplicable` with the actual inferred type. This builds on https://github.com/rust-lang/rust/pull/62804.\n\ncc https://github.com/rust-lang/rfcs/pull/2545\n\nr? @estebank", "tree": {"sha": "4369c406a21e29ac2ecda87881d7c0a6bb5d60c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4369c406a21e29ac2ecda87881d7c0a6bb5d60c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d0f753955afe5c79d260b03f7fbe68ee53d4950", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdio51CRBK7hj4Ov3rIwAAdHIIAGWRcTKJZxSjSRrvfqQhMYgb\ngtgYAdjIgbiqrrD/k28zTu1csY+TeLVQHt6Lna0e9ZzfNm0nGLFMMyy+kQgbh46e\n40Uyw5wm1qVNkXM2lDUbcEHRhJyVurFRRvj+ypHii+s5Khxr48T1r/3BhVnoC93V\nOsM0dYtLUhR2G6nhf6u82BH2/d9nYEuEjG0eiLl/VSnTPtF+tSmhkHqzJ5HtHLNz\n7fhLIuh38mI3TSU6E6u+JG7bK+PY5h5fde1QlCRWMoSsg62CM71olBfZghyqjMW6\n3NEYDKCiw3UsJ1L+eKg3sAhocxY3mGG4xJYRgKnz4Z5BErDX8sAOM8VU+thKl+E=\n=tcOX\n-----END PGP SIGNATURE-----\n", "payload": "tree 4369c406a21e29ac2ecda87881d7c0a6bb5d60c0\nparent 6a4be432123209051f7769a6f9101a4470c3798d\nparent f70665a84692a80a820fccdaed19df5dde94c533\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1569361524 +0200\ncommitter GitHub <noreply@github.com> 1569361524 +0200\n\nRollup merge of #64698 - Centril:infer-const-with-stash, r=estebank\n\nRecover on `const X = 42;` and infer type + Error Stash API\n\nHere we:\n\n1. Introduce a notion of the \"error stash\".\n\n   This is a map in the `Handler` to which you can `err.stash(...)` away your diagnostics and then steal them in a later \"phase\" of the compiler (e.g. stash in parser, steal in typeck) to enrich them with more information that isn't available in the previous \"phase\".\n\n    I believe I've covered all the bases to make sure these diagnostics are actually emitted eventually even under `#[cfg(FALSE)]` but please check my logic.\n\n2. Recover when parsing `[const | static mut?] $ident = $expr;` which has a missing type.\n\n    Use the \"error stash\" to stash away the error and later steal the error in typeck where we emit the error as `MachineApplicable` with the actual inferred type. This builds on https://github.com/rust-lang/rust/pull/62804.\n\ncc https://github.com/rust-lang/rfcs/pull/2545\n\nr? @estebank\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d0f753955afe5c79d260b03f7fbe68ee53d4950", "html_url": "https://github.com/rust-lang/rust/commit/0d0f753955afe5c79d260b03f7fbe68ee53d4950", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d0f753955afe5c79d260b03f7fbe68ee53d4950/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a4be432123209051f7769a6f9101a4470c3798d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a4be432123209051f7769a6f9101a4470c3798d", "html_url": "https://github.com/rust-lang/rust/commit/6a4be432123209051f7769a6f9101a4470c3798d"}, {"sha": "f70665a84692a80a820fccdaed19df5dde94c533", "url": "https://api.github.com/repos/rust-lang/rust/commits/f70665a84692a80a820fccdaed19df5dde94c533", "html_url": "https://github.com/rust-lang/rust/commit/f70665a84692a80a820fccdaed19df5dde94c533"}], "stats": {"total": 635, "additions": 447, "deletions": 188}, "files": [{"sha": "49342d95fdb0359727a9d557a26341cf53762f39", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d0f753955afe5c79d260b03f7fbe68ee53d4950/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d0f753955afe5c79d260b03f7fbe68ee53d4950/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=0d0f753955afe5c79d260b03f7fbe68ee53d4950", "patch": "@@ -321,6 +321,7 @@ impl Session {\n     }\n     pub fn compile_status(&self) -> Result<(), ErrorReported> {\n         if self.has_errors() {\n+            self.diagnostic().emit_stashed_diagnostics();\n             Err(ErrorReported)\n         } else {\n             Ok(())"}, {"sha": "4a8681367410e3cd76c66feb5244df6dd922d013", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0d0f753955afe5c79d260b03f7fbe68ee53d4950/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d0f753955afe5c79d260b03f7fbe68ee53d4950/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=0d0f753955afe5c79d260b03f7fbe68ee53d4950", "patch": "@@ -296,7 +296,6 @@ pub fn run_compiler(\n                     );\n                     Ok(())\n                 })?;\n-                return sess.compile_status();\n             } else {\n                 let mut krate = compiler.parse()?.take();\n                 pretty::visit_crate(sess, &mut krate, ppm);\n@@ -307,8 +306,8 @@ pub fn run_compiler(\n                     ppm,\n                     compiler.output_file().as_ref().map(|p| &**p),\n                 );\n-                return sess.compile_status();\n             }\n+            return sess.compile_status();\n         }\n \n         if callbacks.after_parsing(compiler) == Compilation::Stop {"}, {"sha": "cc60bf89c7ecac3dd3104d89577a7ab6c07d5234", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0d0f753955afe5c79d260b03f7fbe68ee53d4950/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d0f753955afe5c79d260b03f7fbe68ee53d4950/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=0d0f753955afe5c79d260b03f7fbe68ee53d4950", "patch": "@@ -1,10 +1,6 @@\n-use crate::Diagnostic;\n-use crate::DiagnosticId;\n-use crate::DiagnosticStyledString;\n-use crate::Applicability;\n+use crate::{Diagnostic, DiagnosticId, DiagnosticStyledString};\n+use crate::{Applicability, Level, Handler, StashKey};\n \n-use crate::Level;\n-use crate::Handler;\n use std::fmt::{self, Debug};\n use std::ops::{Deref, DerefMut};\n use std::thread::panicking;\n@@ -117,18 +113,30 @@ impl<'a> DiagnosticBuilder<'a> {\n         }\n     }\n \n-    /// Buffers the diagnostic for later emission, unless handler\n-    /// has disabled such buffering.\n-    pub fn buffer(mut self, buffered_diagnostics: &mut Vec<Diagnostic>) {\n+    /// Stashes diagnostic for possible later improvement in a different,\n+    /// later stage of the compiler. The diagnostic can be accessed with\n+    /// the provided `span` and `key` through `.steal_diagnostic` on `Handler`.\n+    ///\n+    /// As with `buffer`, this is unless the handler has disabled such buffering.\n+    pub fn stash(self, span: Span, key: StashKey) {\n+        if let Some((diag, handler)) = self.into_diagnostic() {\n+            handler.stash_diagnostic(span, key, diag);\n+        }\n+    }\n+\n+    /// Converts the builder to a `Diagnostic` for later emission,\n+    /// unless handler has disabled such buffering.\n+    pub fn into_diagnostic(mut self) -> Option<(Diagnostic, &'a Handler)> {\n         if self.0.handler.flags.dont_buffer_diagnostics ||\n             self.0.handler.flags.treat_err_as_bug.is_some()\n         {\n             self.emit();\n-            return;\n+            return None;\n         }\n \n-        // We need to use `ptr::read` because `DiagnosticBuilder`\n-        // implements `Drop`.\n+        let handler = self.0.handler;\n+\n+        // We need to use `ptr::read` because `DiagnosticBuilder` implements `Drop`.\n         let diagnostic;\n         unsafe {\n             diagnostic = std::ptr::read(&self.0.diagnostic);\n@@ -137,7 +145,14 @@ impl<'a> DiagnosticBuilder<'a> {\n         // Logging here is useful to help track down where in logs an error was\n         // actually emitted.\n         debug!(\"buffer: diagnostic={:?}\", diagnostic);\n-        buffered_diagnostics.push(diagnostic);\n+\n+        Some((diagnostic, handler))\n+    }\n+\n+    /// Buffers the diagnostic for later emission,\n+    /// unless handler has disabled such buffering.\n+    pub fn buffer(self, buffered_diagnostics: &mut Vec<Diagnostic>) {\n+        buffered_diagnostics.extend(self.into_diagnostic().map(|(diag, _)| diag));\n     }\n \n     /// Convenience function for internal use, clients should use one of the"}, {"sha": "c01dcd94c725e449e7ee87de5444866e19d762a5", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 249, "deletions": 149, "changes": 398, "blob_url": "https://github.com/rust-lang/rust/blob/0d0f753955afe5c79d260b03f7fbe68ee53d4950/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d0f753955afe5c79d260b03f7fbe68ee53d4950/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=0d0f753955afe5c79d260b03f7fbe68ee53d4950", "patch": "@@ -17,7 +17,7 @@ use emitter::{Emitter, EmitterWriter};\n use registry::Registry;\n \n use rustc_data_structures::sync::{self, Lrc, Lock};\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::{FxHashSet, FxIndexMap};\n use rustc_data_structures::stable_hasher::StableHasher;\n \n use std::borrow::Cow;\n@@ -302,6 +302,9 @@ pub struct Handler {\n     inner: Lock<HandlerInner>,\n }\n \n+/// This inner struct exists to keep it all behind a single lock;\n+/// this is done to prevent possible deadlocks in a multi-threaded compiler,\n+/// as well as inconsistent state observation.\n struct HandlerInner {\n     flags: HandlerFlags,\n     /// The number of errors that have been emitted, including duplicates.\n@@ -326,6 +329,18 @@ struct HandlerInner {\n     /// this handler. These hashes is used to avoid emitting the same error\n     /// twice.\n     emitted_diagnostics: FxHashSet<u128>,\n+\n+    /// Stashed diagnostics emitted in one stage of the compiler that may be\n+    /// stolen by other stages (e.g. to improve them and add more information).\n+    /// The stashed diagnostics count towards the total error count.\n+    /// When `.abort_if_errors()` is called, these are also emitted.\n+    stashed_diagnostics: FxIndexMap<(Span, StashKey), Diagnostic>,\n+}\n+\n+/// A key denoting where from a diagnostic was stashed.\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+pub enum StashKey {\n+    ItemNoType,\n }\n \n fn default_track_diagnostic(_: &Diagnostic) {}\n@@ -354,7 +369,9 @@ pub struct HandlerFlags {\n \n impl Drop for HandlerInner {\n     fn drop(&mut self) {\n-        if self.err_count == 0 {\n+        self.emit_stashed_diagnostics();\n+\n+        if !self.has_errors() {\n             let bugs = std::mem::replace(&mut self.delayed_span_bugs, Vec::new());\n             let has_bugs = !bugs.is_empty();\n             for bug in bugs {\n@@ -368,57 +385,71 @@ impl Drop for HandlerInner {\n }\n \n impl Handler {\n-    pub fn with_tty_emitter(color_config: ColorConfig,\n-                            can_emit_warnings: bool,\n-                            treat_err_as_bug: Option<usize>,\n-                            cm: Option<Lrc<SourceMapperDyn>>)\n-                            -> Handler {\n-        Handler::with_tty_emitter_and_flags(\n+    pub fn with_tty_emitter(\n+        color_config: ColorConfig,\n+        can_emit_warnings: bool,\n+        treat_err_as_bug: Option<usize>,\n+        cm: Option<Lrc<SourceMapperDyn>>,\n+    ) -> Self {\n+        Self::with_tty_emitter_and_flags(\n             color_config,\n             cm,\n             HandlerFlags {\n                 can_emit_warnings,\n                 treat_err_as_bug,\n                 .. Default::default()\n-            })\n+            },\n+        )\n     }\n \n-    pub fn with_tty_emitter_and_flags(color_config: ColorConfig,\n-                                      cm: Option<Lrc<SourceMapperDyn>>,\n-                                      flags: HandlerFlags)\n-                                      -> Handler {\n+    pub fn with_tty_emitter_and_flags(\n+        color_config: ColorConfig,\n+        cm: Option<Lrc<SourceMapperDyn>>,\n+        flags: HandlerFlags,\n+    ) -> Self {\n         let emitter = Box::new(EmitterWriter::stderr(\n-            color_config, cm, false, false, None, flags.external_macro_backtrace));\n-        Handler::with_emitter_and_flags(emitter, flags)\n-    }\n-\n-    pub fn with_emitter(can_emit_warnings: bool,\n-                        treat_err_as_bug: Option<usize>,\n-                        e: Box<dyn Emitter + sync::Send>)\n-                        -> Handler {\n+            color_config,\n+            cm,\n+            false,\n+            false,\n+            None,\n+            flags.external_macro_backtrace,\n+        ));\n+        Self::with_emitter_and_flags(emitter, flags)\n+    }\n+\n+    pub fn with_emitter(\n+        can_emit_warnings: bool,\n+        treat_err_as_bug: Option<usize>,\n+        emitter: Box<dyn Emitter + sync::Send>,\n+    ) -> Self {\n         Handler::with_emitter_and_flags(\n-            e,\n+            emitter,\n             HandlerFlags {\n                 can_emit_warnings,\n                 treat_err_as_bug,\n                 .. Default::default()\n-            })\n+            },\n+        )\n     }\n \n-    pub fn with_emitter_and_flags(e: Box<dyn Emitter + sync::Send>, flags: HandlerFlags) -> Handler\n-    {\n-        Handler {\n+    pub fn with_emitter_and_flags(\n+        emitter: Box<dyn Emitter + sync::Send>,\n+        flags: HandlerFlags\n+    ) -> Self {\n+        Self {\n             flags,\n             inner: Lock::new(HandlerInner {\n                 flags,\n                 err_count: 0,\n                 deduplicated_err_count: 0,\n-                emitter: e,\n+                emitter,\n                 continue_after_error: true,\n                 delayed_span_bugs: Vec::new(),\n                 taught_diagnostics: Default::default(),\n                 emitted_diagnostic_codes: Default::default(),\n                 emitted_diagnostics: Default::default(),\n+                stashed_diagnostics: Default::default(),\n             }),\n         }\n     }\n@@ -445,197 +476,239 @@ impl Handler {\n         inner.emitted_diagnostics = Default::default();\n         inner.deduplicated_err_count = 0;\n         inner.err_count = 0;\n+        inner.stashed_diagnostics.clear();\n+    }\n+\n+    /// Stash a given diagnostic with the given `Span` and `StashKey` as the key for later stealing.\n+    /// If the diagnostic with this `(span, key)` already exists, this will result in an ICE.\n+    pub fn stash_diagnostic(&self, span: Span, key: StashKey, diag: Diagnostic) {\n+        let mut inner = self.inner.borrow_mut();\n+        if let Some(mut old_diag) = inner.stashed_diagnostics.insert((span, key), diag) {\n+            // We are removing a previously stashed diagnostic which should not happen.\n+            old_diag.level = Bug;\n+            old_diag.note(&format!(\n+                \"{}:{}: already existing stashed diagnostic with (span = {:?}, key = {:?})\",\n+                file!(), line!(), span, key\n+            ));\n+            inner.emit_diag_at_span(old_diag, span);\n+            panic!(ExplicitBug);\n+        }\n+    }\n+\n+    /// Steal a previously stashed diagnostic with the given `Span` and `StashKey` as the key.\n+    pub fn steal_diagnostic(&self, span: Span, key: StashKey) -> Option<DiagnosticBuilder<'_>> {\n+        self.inner\n+            .borrow_mut()\n+            .stashed_diagnostics\n+            .remove(&(span, key))\n+            .map(|diag| DiagnosticBuilder::new_diagnostic(self, diag))\n+    }\n+\n+    /// Emit all stashed diagnostics.\n+    pub fn emit_stashed_diagnostics(&self) {\n+        self.inner.borrow_mut().emit_stashed_diagnostics();\n     }\n \n+    /// Construct a dummy builder with `Level::Cancelled`.\n+    ///\n+    /// Using this will neither report anything to the user (e.g. a warning),\n+    /// nor will compilation cancel as a result.\n     pub fn struct_dummy(&self) -> DiagnosticBuilder<'_> {\n         DiagnosticBuilder::new(self, Level::Cancelled, \"\")\n     }\n \n-    pub fn struct_span_warn<S: Into<MultiSpan>>(&self,\n-                                                sp: S,\n-                                                msg: &str)\n-                                                -> DiagnosticBuilder<'_> {\n-        let mut result = DiagnosticBuilder::new(self, Level::Warning, msg);\n-        result.set_span(sp);\n-        if !self.flags.can_emit_warnings {\n-            result.cancel();\n-        }\n+    /// Construct a builder at the `Warning` level at the given `span` and with the `msg`.\n+    pub fn struct_span_warn(&self, span: impl Into<MultiSpan>, msg: &str) -> DiagnosticBuilder<'_> {\n+        let mut result = self.struct_warn(msg);\n+        result.set_span(span);\n         result\n     }\n-    pub fn struct_span_warn_with_code<S: Into<MultiSpan>>(&self,\n-                                                          sp: S,\n-                                                          msg: &str,\n-                                                          code: DiagnosticId)\n-                                                          -> DiagnosticBuilder<'_> {\n-        let mut result = DiagnosticBuilder::new(self, Level::Warning, msg);\n-        result.set_span(sp);\n+\n+    /// Construct a builder at the `Warning` level at the given `span` and with the `msg`.\n+    /// Also include a code.\n+    pub fn struct_span_warn_with_code(\n+        &self,\n+        span: impl Into<MultiSpan>,\n+        msg: &str,\n+        code: DiagnosticId,\n+    ) -> DiagnosticBuilder<'_> {\n+        let mut result = self.struct_span_warn(span, msg);\n         result.code(code);\n-        if !self.flags.can_emit_warnings {\n-            result.cancel();\n-        }\n         result\n     }\n+\n+    /// Construct a builder at the `Warning` level with the `msg`.\n     pub fn struct_warn(&self, msg: &str) -> DiagnosticBuilder<'_> {\n         let mut result = DiagnosticBuilder::new(self, Level::Warning, msg);\n         if !self.flags.can_emit_warnings {\n             result.cancel();\n         }\n         result\n     }\n-    pub fn struct_span_err<S: Into<MultiSpan>>(&self,\n-                                               sp: S,\n-                                               msg: &str)\n-                                               -> DiagnosticBuilder<'_> {\n-        let mut result = DiagnosticBuilder::new(self, Level::Error, msg);\n-        result.set_span(sp);\n+\n+    /// Construct a builder at the `Error` level at the given `span` and with the `msg`.\n+    pub fn struct_span_err(&self, span: impl Into<MultiSpan>, msg: &str) -> DiagnosticBuilder<'_> {\n+        let mut result = self.struct_err(msg);\n+        result.set_span(span);\n         result\n     }\n-    pub fn struct_span_err_with_code<S: Into<MultiSpan>>(&self,\n-                                                         sp: S,\n-                                                         msg: &str,\n-                                                         code: DiagnosticId)\n-                                                         -> DiagnosticBuilder<'_> {\n-        let mut result = DiagnosticBuilder::new(self, Level::Error, msg);\n-        result.set_span(sp);\n+\n+    /// Construct a builder at the `Error` level at the given `span`, with the `msg`, and `code`.\n+    pub fn struct_span_err_with_code(\n+        &self,\n+        span: impl Into<MultiSpan>,\n+        msg: &str,\n+        code: DiagnosticId,\n+    ) -> DiagnosticBuilder<'_> {\n+        let mut result = self.struct_span_err(span, msg);\n         result.code(code);\n         result\n     }\n+\n+    /// Construct a builder at the `Error` level with the `msg`.\n     // FIXME: This method should be removed (every error should have an associated error code).\n     pub fn struct_err(&self, msg: &str) -> DiagnosticBuilder<'_> {\n         DiagnosticBuilder::new(self, Level::Error, msg)\n     }\n-    pub fn struct_err_with_code(\n-        &self,\n-        msg: &str,\n-        code: DiagnosticId,\n-    ) -> DiagnosticBuilder<'_> {\n-        let mut result = DiagnosticBuilder::new(self, Level::Error, msg);\n+\n+    /// Construct a builder at the `Error` level with the `msg` and the `code`.\n+    pub fn struct_err_with_code(&self, msg: &str, code: DiagnosticId) -> DiagnosticBuilder<'_> {\n+        let mut result = self.struct_err(msg);\n         result.code(code);\n         result\n     }\n-    pub fn struct_span_fatal<S: Into<MultiSpan>>(&self,\n-                                                 sp: S,\n-                                                 msg: &str)\n-                                                 -> DiagnosticBuilder<'_> {\n-        let mut result = DiagnosticBuilder::new(self, Level::Fatal, msg);\n-        result.set_span(sp);\n+\n+    /// Construct a builder at the `Fatal` level at the given `span` and with the `msg`.\n+    pub fn struct_span_fatal(\n+        &self,\n+        span: impl Into<MultiSpan>,\n+        msg: &str,\n+    ) -> DiagnosticBuilder<'_> {\n+        let mut result = self.struct_fatal(msg);\n+        result.set_span(span);\n         result\n     }\n-    pub fn struct_span_fatal_with_code<S: Into<MultiSpan>>(&self,\n-                                                           sp: S,\n-                                                           msg: &str,\n-                                                           code: DiagnosticId)\n-                                                           -> DiagnosticBuilder<'_> {\n-        let mut result = DiagnosticBuilder::new(self, Level::Fatal, msg);\n-        result.set_span(sp);\n+\n+    /// Construct a builder at the `Fatal` level at the given `span`, with the `msg`, and `code`.\n+    pub fn struct_span_fatal_with_code(\n+        &self,\n+        span: impl Into<MultiSpan>,\n+        msg: &str,\n+        code: DiagnosticId,\n+    ) -> DiagnosticBuilder<'_> {\n+        let mut result = self.struct_span_fatal(span, msg);\n         result.code(code);\n         result\n     }\n+\n+    /// Construct a builder at the `Error` level with the `msg`.\n     pub fn struct_fatal(&self, msg: &str) -> DiagnosticBuilder<'_> {\n         DiagnosticBuilder::new(self, Level::Fatal, msg)\n     }\n \n-    pub fn span_fatal<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> FatalError {\n-        self.emit_diagnostic(Diagnostic::new(Fatal, msg).set_span(sp));\n-        self.abort_if_errors_and_should_abort();\n+    pub fn span_fatal(&self, span: impl Into<MultiSpan>, msg: &str) -> FatalError {\n+        self.emit_diag_at_span(Diagnostic::new(Fatal, msg), span);\n         FatalError\n     }\n-    pub fn span_fatal_with_code<S: Into<MultiSpan>>(&self,\n-                                                    sp: S,\n-                                                    msg: &str,\n-                                                    code: DiagnosticId)\n-                                                    -> FatalError {\n-        self.emit_diagnostic(Diagnostic::new_with_code(Fatal, Some(code), msg).set_span(sp));\n-        self.abort_if_errors_and_should_abort();\n+\n+    pub fn span_fatal_with_code(\n+        &self,\n+        span: impl Into<MultiSpan>,\n+        msg: &str,\n+        code: DiagnosticId,\n+    ) -> FatalError {\n+        self.emit_diag_at_span(Diagnostic::new_with_code(Fatal, Some(code), msg), span);\n         FatalError\n     }\n-    pub fn span_err<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n-        self.emit_diagnostic(Diagnostic::new(Error, msg).set_span(sp));\n-        self.abort_if_errors_and_should_abort();\n-    }\n-    pub fn mut_span_err<S: Into<MultiSpan>>(&self,\n-                                            sp: S,\n-                                            msg: &str)\n-                                            -> DiagnosticBuilder<'_> {\n-        let mut result = DiagnosticBuilder::new(self, Level::Error, msg);\n-        result.set_span(sp);\n-        result\n+\n+    pub fn span_err(&self, span: impl Into<MultiSpan>, msg: &str) {\n+        self.emit_diag_at_span(Diagnostic::new(Error, msg), span);\n     }\n-    pub fn span_err_with_code<S: Into<MultiSpan>>(&self, sp: S, msg: &str, code: DiagnosticId) {\n-        self.emit_diagnostic(Diagnostic::new_with_code(Error, Some(code), msg).set_span(sp));\n-        self.abort_if_errors_and_should_abort();\n+\n+    pub fn span_err_with_code(&self, span: impl Into<MultiSpan>, msg: &str, code: DiagnosticId) {\n+        self.emit_diag_at_span(Diagnostic::new_with_code(Error, Some(code), msg), span);\n     }\n-    pub fn span_warn<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n-        self.emit_diagnostic(Diagnostic::new(Warning, msg).set_span(sp));\n-        self.abort_if_errors_and_should_abort();\n+\n+    pub fn span_warn(&self, span: impl Into<MultiSpan>, msg: &str) {\n+        self.emit_diag_at_span(Diagnostic::new(Warning, msg), span);\n     }\n-    pub fn span_warn_with_code<S: Into<MultiSpan>>(&self, sp: S, msg: &str, code: DiagnosticId) {\n-        self.emit_diagnostic(Diagnostic::new_with_code(Warning, Some(code), msg).set_span(sp));\n-        self.abort_if_errors_and_should_abort();\n+\n+    pub fn span_warn_with_code(&self, span: impl Into<MultiSpan>, msg: &str, code: DiagnosticId) {\n+        self.emit_diag_at_span(Diagnostic::new_with_code(Warning, Some(code), msg), span);\n     }\n-    pub fn span_bug<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> ! {\n-        self.inner.borrow_mut().span_bug(sp, msg)\n+\n+    pub fn span_bug(&self, span: impl Into<MultiSpan>, msg: &str) -> ! {\n+        self.inner.borrow_mut().span_bug(span, msg)\n     }\n-    pub fn delay_span_bug<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n-        self.inner.borrow_mut().delay_span_bug(sp, msg)\n+\n+    pub fn delay_span_bug(&self, span: impl Into<MultiSpan>, msg: &str) {\n+        self.inner.borrow_mut().delay_span_bug(span, msg)\n     }\n-    pub fn span_bug_no_panic<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n-        self.emit_diagnostic(Diagnostic::new(Bug, msg).set_span(sp));\n-        self.abort_if_errors_and_should_abort();\n+\n+    pub fn span_bug_no_panic(&self, span: impl Into<MultiSpan>, msg: &str) {\n+        self.emit_diag_at_span(Diagnostic::new(Bug, msg), span);\n     }\n-    pub fn span_note_without_error<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n-        self.emit_diagnostic(Diagnostic::new(Note, msg).set_span(sp));\n-        self.abort_if_errors_and_should_abort();\n+\n+    pub fn span_note_without_error(&self, span: impl Into<MultiSpan>, msg: &str) {\n+        self.emit_diag_at_span(Diagnostic::new(Note, msg), span);\n     }\n-    pub fn span_note_diag(&self,\n-                          sp: Span,\n-                          msg: &str)\n-                          -> DiagnosticBuilder<'_> {\n+\n+    pub fn span_note_diag(&self, span: Span, msg: &str) -> DiagnosticBuilder<'_> {\n         let mut db = DiagnosticBuilder::new(self, Note, msg);\n-        db.set_span(sp);\n+        db.set_span(span);\n         db\n     }\n+\n     pub fn failure(&self, msg: &str) {\n         self.inner.borrow_mut().failure(msg);\n     }\n+\n     pub fn fatal(&self, msg: &str) -> FatalError {\n         self.inner.borrow_mut().fatal(msg)\n     }\n+\n     pub fn err(&self, msg: &str) {\n         self.inner.borrow_mut().err(msg);\n     }\n+\n     pub fn warn(&self, msg: &str) {\n         let mut db = DiagnosticBuilder::new(self, Warning, msg);\n         db.emit();\n     }\n+\n     pub fn note_without_error(&self, msg: &str) {\n-        let mut db = DiagnosticBuilder::new(self, Note, msg);\n-        db.emit();\n+        DiagnosticBuilder::new(self, Note, msg).emit();\n     }\n+\n     pub fn bug(&self, msg: &str) -> ! {\n         self.inner.borrow_mut().bug(msg)\n     }\n \n     pub fn err_count(&self) -> usize {\n-        self.inner.borrow().err_count\n+        self.inner.borrow().err_count()\n     }\n \n     pub fn has_errors(&self) -> bool {\n-        self.err_count() > 0\n+        self.inner.borrow().has_errors()\n     }\n \n     pub fn print_error_count(&self, registry: &Registry) {\n         self.inner.borrow_mut().print_error_count(registry)\n     }\n \n     pub fn abort_if_errors(&self) {\n-        self.inner.borrow().abort_if_errors()\n+        self.inner.borrow_mut().abort_if_errors()\n     }\n \n     pub fn abort_if_errors_and_should_abort(&self) {\n-        self.inner.borrow().abort_if_errors_and_should_abort()\n+        self.inner.borrow_mut().abort_if_errors_and_should_abort()\n     }\n \n+    /// `true` if we haven't taught a diagnostic with this code already.\n+    /// The caller must then teach the user about such a diagnostic.\n+    ///\n+    /// Used to suppress emitting the same error multiple times with extended explanation when\n+    /// calling `-Zteach`.\n     pub fn must_teach(&self, code: &DiagnosticId) -> bool {\n         self.inner.borrow_mut().must_teach(code)\n     }\n@@ -648,6 +721,12 @@ impl Handler {\n         self.inner.borrow_mut().emit_diagnostic(diagnostic)\n     }\n \n+    fn emit_diag_at_span(&self, mut diag: Diagnostic, sp: impl Into<MultiSpan>) {\n+        let mut inner = self.inner.borrow_mut();\n+        inner.emit_diagnostic(diag.set_span(sp));\n+        inner.abort_if_errors_and_should_abort();\n+    }\n+\n     pub fn emit_artifact_notification(&self, path: &Path, artifact_type: &str) {\n         self.inner.borrow_mut().emit_artifact_notification(path, artifact_type)\n     }\n@@ -658,11 +737,6 @@ impl Handler {\n }\n \n impl HandlerInner {\n-    /// `true` if we haven't taught a diagnostic with this code already.\n-    /// The caller must then teach the user about such a diagnostic.\n-    ///\n-    /// Used to suppress emitting the same error multiple times with extended explanation when\n-    /// calling `-Zteach`.\n     fn must_teach(&mut self, code: &DiagnosticId) -> bool {\n         self.taught_diagnostics.insert(code.clone())\n     }\n@@ -671,6 +745,12 @@ impl HandlerInner {\n         self.emitter.emit_diagnostic(&db);\n     }\n \n+    /// Emit all stashed diagnostics.\n+    fn emit_stashed_diagnostics(&mut self) {\n+        let diags = self.stashed_diagnostics.drain(..).map(|x| x.1).collect::<Vec<_>>();\n+        diags.iter().for_each(|diag| self.emit_diagnostic(diag));\n+    }\n+\n     fn emit_diagnostic(&mut self, diagnostic: &Diagnostic) {\n         if diagnostic.cancelled() {\n             return;\n@@ -713,10 +793,12 @@ impl HandlerInner {\n     }\n \n     fn treat_err_as_bug(&self) -> bool {\n-        self.flags.treat_err_as_bug.map(|c| self.err_count >= c).unwrap_or(false)\n+        self.flags.treat_err_as_bug.map(|c| self.err_count() >= c).unwrap_or(false)\n     }\n \n     fn print_error_count(&mut self, registry: &Registry) {\n+        self.emit_stashed_diagnostics();\n+\n         let s = match self.deduplicated_err_count {\n             0 => return,\n             1 => \"aborting due to previous error\".to_string(),\n@@ -760,25 +842,41 @@ impl HandlerInner {\n         }\n     }\n \n-    fn abort_if_errors_and_should_abort(&self) {\n-        if self.err_count > 0 && !self.continue_after_error {\n+    fn err_count(&self) -> usize {\n+        self.err_count + self.stashed_diagnostics.len()\n+    }\n+\n+    fn has_errors(&self) -> bool {\n+        self.err_count() > 0\n+    }\n+\n+    fn abort_if_errors_and_should_abort(&mut self) {\n+        self.emit_stashed_diagnostics();\n+\n+        if self.has_errors() && !self.continue_after_error {\n             FatalError.raise();\n         }\n     }\n \n-    fn abort_if_errors(&self) {\n-        if self.err_count > 0 {\n+    fn abort_if_errors(&mut self) {\n+        self.emit_stashed_diagnostics();\n+\n+        if self.has_errors() {\n             FatalError.raise();\n         }\n     }\n \n-    fn span_bug<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> ! {\n-        self.emit_diagnostic(Diagnostic::new(Bug, msg).set_span(sp));\n-        self.abort_if_errors_and_should_abort();\n+    fn span_bug(&mut self, sp: impl Into<MultiSpan>, msg: &str) -> ! {\n+        self.emit_diag_at_span(Diagnostic::new(Bug, msg), sp);\n         panic!(ExplicitBug);\n     }\n \n-    fn delay_span_bug<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) {\n+    fn emit_diag_at_span(&mut self, mut diag: Diagnostic, sp: impl Into<MultiSpan>) {\n+        self.emit_diagnostic(diag.set_span(sp));\n+        self.abort_if_errors_and_should_abort();\n+    }\n+\n+    fn delay_span_bug(&mut self, sp: impl Into<MultiSpan>, msg: &str) {\n         if self.treat_err_as_bug() {\n             // FIXME: don't abort here if report_delayed_bugs is off\n             self.span_bug(sp, msg);\n@@ -793,18 +891,20 @@ impl HandlerInner {\n     }\n \n     fn fatal(&mut self, msg: &str) -> FatalError {\n-        if self.treat_err_as_bug() {\n-            self.bug(msg);\n-        }\n-        self.emit_diagnostic(&Diagnostic::new(Fatal, msg));\n+        self.emit_error(Fatal, msg);\n         FatalError\n     }\n \n     fn err(&mut self, msg: &str) {\n+        self.emit_error(Error, msg);\n+    }\n+\n+    /// Emit an error; level should be `Error` or `Fatal`.\n+    fn emit_error(&mut self, level: Level, msg: &str,) {\n         if self.treat_err_as_bug() {\n             self.bug(msg);\n         }\n-        self.emit_diagnostic(&Diagnostic::new(Error, msg));\n+        self.emit_diagnostic(&Diagnostic::new(level, msg));\n     }\n \n     fn bug(&mut self, msg: &str) -> ! {\n@@ -826,7 +926,7 @@ impl HandlerInner {\n \n     fn panic_if_treat_err_as_bug(&self) {\n         if self.treat_err_as_bug() {\n-            let s = match (self.err_count, self.flags.treat_err_as_bug.unwrap_or(0)) {\n+            let s = match (self.err_count(), self.flags.treat_err_as_bug.unwrap_or(0)) {\n                 (0, _) => return,\n                 (1, 1) => \"aborting due to `-Z treat-err-as-bug=1`\".to_string(),\n                 (1, _) => return,"}, {"sha": "f7e766bb84d5740197ae84d16b64effcc475a877", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d0f753955afe5c79d260b03f7fbe68ee53d4950/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d0f753955afe5c79d260b03f7fbe68ee53d4950/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=0d0f753955afe5c79d260b03f7fbe68ee53d4950", "patch": "@@ -832,7 +832,7 @@ fn check_method_receiver<'fcx, 'tcx>(\n }\n \n fn e0307(fcx: &FnCtxt<'fcx, 'tcx>, span: Span, receiver_ty: Ty<'_>) {\n-    fcx.tcx.sess.diagnostic().mut_span_err(\n+    fcx.tcx.sess.diagnostic().struct_span_err(\n         span,\n         &format!(\"invalid `self` parameter type: {:?}\", receiver_ty)\n     ).note(\"type of `self` must be `Self` or a type that dereferences to it\")"}, {"sha": "e6e0cb88fbd23435f030d3b7aad2079cc3042673", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 36, "deletions": 13, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/0d0f753955afe5c79d260b03f7fbe68ee53d4950/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d0f753955afe5c79d260b03f7fbe68ee53d4950/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=0d0f753955afe5c79d260b03f7fbe68ee53d4950", "patch": "@@ -46,7 +46,7 @@ use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc::hir::GenericParamKind;\n use rustc::hir::{self, CodegenFnAttrFlags, CodegenFnAttrs, Unsafety};\n \n-use errors::{Applicability, DiagnosticId};\n+use errors::{Applicability, DiagnosticId, StashKey};\n \n struct OnlySelfBounds(bool);\n \n@@ -1149,18 +1149,41 @@ fn infer_placeholder_type(\n     def_id: DefId,\n     body_id: hir::BodyId,\n     span: Span,\n+    item_ident: Ident,\n ) -> Ty<'_> {\n     let ty = tcx.typeck_tables_of(def_id).node_type(body_id.hir_id);\n-    let mut diag = bad_placeholder_type(tcx, span);\n-    if ty != tcx.types.err {\n-        diag.span_suggestion(\n-            span,\n-            \"replace `_` with the correct type\",\n-            ty.to_string(),\n-            Applicability::MaybeIncorrect,\n-        );\n+\n+    // If this came from a free `const` or `static mut?` item,\n+    // then the user may have written e.g. `const A = 42;`.\n+    // In this case, the parser has stashed a diagnostic for\n+    // us to improve in typeck so we do that now.\n+    match tcx.sess.diagnostic().steal_diagnostic(span, StashKey::ItemNoType) {\n+        Some(mut err) => {\n+            // The parser provided a sub-optimal `HasPlaceholders` suggestion for the type.\n+            // We are typeck and have the real type, so remove that and suggest the actual type.\n+            err.suggestions.clear();\n+            err.span_suggestion(\n+                span,\n+                \"provide a type for the item\",\n+                format!(\"{}: {}\", item_ident, ty),\n+                Applicability::MachineApplicable,\n+            )\n+            .emit();\n+        }\n+        None => {\n+            let mut diag = bad_placeholder_type(tcx, span);\n+            if ty != tcx.types.err {\n+                diag.span_suggestion(\n+                    span,\n+                    \"replace `_` with the correct type\",\n+                    ty.to_string(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+            diag.emit();\n+        }\n     }\n-    diag.emit();\n+\n     ty\n }\n \n@@ -1192,7 +1215,7 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n             TraitItemKind::Const(ref ty, body_id)  => {\n                 body_id.and_then(|body_id| {\n                     if let hir::TyKind::Infer = ty.node {\n-                        Some(infer_placeholder_type(tcx, def_id, body_id, ty.span))\n+                        Some(infer_placeholder_type(tcx, def_id, body_id, ty.span, item.ident))\n                     } else {\n                         None\n                     }\n@@ -1214,7 +1237,7 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n             }\n             ImplItemKind::Const(ref ty, body_id) => {\n                 if let hir::TyKind::Infer = ty.node {\n-                    infer_placeholder_type(tcx, def_id, body_id, ty.span)\n+                    infer_placeholder_type(tcx, def_id, body_id, ty.span, item.ident)\n                 } else {\n                     icx.to_ty(ty)\n                 }\n@@ -1246,7 +1269,7 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n                 ItemKind::Static(ref ty, .., body_id)\n                 | ItemKind::Const(ref ty, body_id) => {\n                     if let hir::TyKind::Infer = ty.node {\n-                        infer_placeholder_type(tcx, def_id, body_id, ty.span)\n+                        infer_placeholder_type(tcx, def_id, body_id, ty.span, item.ident)\n                     } else {\n                         icx.to_ty(ty)\n                     }"}, {"sha": "aa76667c2e90189d7bcbcabc92f0492d8d72a094", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d0f753955afe5c79d260b03f7fbe68ee53d4950/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d0f753955afe5c79d260b03f7fbe68ee53d4950/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=0d0f753955afe5c79d260b03f7fbe68ee53d4950", "patch": "@@ -1017,10 +1017,6 @@ impl<'a> ExtCtxt<'a> {\n     pub fn span_err_with_code<S: Into<MultiSpan>>(&self, sp: S, msg: &str, code: DiagnosticId) {\n         self.parse_sess.span_diagnostic.span_err_with_code(sp, msg, code);\n     }\n-    pub fn mut_span_err<S: Into<MultiSpan>>(&self, sp: S, msg: &str)\n-                        -> DiagnosticBuilder<'a> {\n-        self.parse_sess.span_diagnostic.mut_span_err(sp, msg)\n-    }\n     pub fn span_warn<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n         self.parse_sess.span_diagnostic.span_warn(sp, msg);\n     }"}, {"sha": "c8078d2bb712e0c82929c958221cdfcd31c6785d", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d0f753955afe5c79d260b03f7fbe68ee53d4950/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d0f753955afe5c79d260b03f7fbe68ee53d4950/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=0d0f753955afe5c79d260b03f7fbe68ee53d4950", "patch": "@@ -384,7 +384,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         let attr = attr::find_by_name(item.attrs(), sym::derive)\n                             .expect(\"`derive` attribute should exist\");\n                         let span = attr.span;\n-                        let mut err = self.cx.mut_span_err(span,\n+                        let mut err = self.cx.struct_span_err(span,\n                             \"`derive` may only be applied to structs, enums and unions\");\n                         if let ast::AttrStyle::Inner = attr.style {\n                             let trait_list = derives.iter()"}, {"sha": "0d073f0cc97b135315bcc7fed64a94d524ecfbf6", "filename": "src/libsyntax/parse/parser/item.rs", "status": "modified", "additions": 44, "deletions": 3, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/0d0f753955afe5c79d260b03f7fbe68ee53d4950/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d0f753955afe5c79d260b03f7fbe68ee53d4950/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs?ref=0d0f753955afe5c79d260b03f7fbe68ee53d4950", "patch": "@@ -24,7 +24,7 @@ use crate::symbol::{kw, sym};\n use std::mem;\n use log::debug;\n use rustc_target::spec::abi::Abi;\n-use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n+use errors::{Applicability, DiagnosticBuilder, DiagnosticId, StashKey};\n \n /// Whether the type alias or associated type is a concrete type or an opaque type.\n #[derive(Debug)]\n@@ -1477,10 +1477,23 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    /// Parse `[\"const\" | (\"static\" \"mut\"?)] $ident \":\" $ty = $expr` with\n+    /// `[\"const\" | (\"static\" \"mut\"?)]` already parsed and stored in `m`.\n+    ///\n+    /// When `m` is `\"const\"`, `$ident` may also be `\"_\"`.\n     fn parse_item_const(&mut self, m: Option<Mutability>) -> PResult<'a, ItemInfo> {\n         let id = if m.is_none() { self.parse_ident_or_underscore() } else { self.parse_ident() }?;\n-        self.expect(&token::Colon)?;\n-        let ty = self.parse_ty()?;\n+\n+        // Parse the type of a `const` or `static mut?` item.\n+        // That is, the `\":\" $ty` fragment.\n+        let ty = if self.token == token::Eq {\n+            self.recover_missing_const_type(id, m)\n+        } else {\n+            // Not `=` so expect `\":\"\" $ty` as usual.\n+            self.expect(&token::Colon)?;\n+            self.parse_ty()?\n+        };\n+\n         self.expect(&token::Eq)?;\n         let e = self.parse_expr()?;\n         self.expect(&token::Semi)?;\n@@ -1491,6 +1504,34 @@ impl<'a> Parser<'a> {\n         Ok((id, item, None))\n     }\n \n+    /// We were supposed to parse `:` but instead, we're already at `=`.\n+    /// This means that the type is missing.\n+    fn recover_missing_const_type(&mut self, id: Ident, m: Option<Mutability>) -> P<Ty> {\n+        // Construct the error and stash it away with the hope\n+        // that typeck will later enrich the error with a type.\n+        let kind = match m {\n+            Some(Mutability::Mutable) => \"static mut\",\n+            Some(Mutability::Immutable) => \"static\",\n+            None => \"const\",\n+        };\n+        let mut err = self.struct_span_err(id.span, &format!(\"missing type for `{}` item\", kind));\n+        err.span_suggestion(\n+            id.span,\n+            \"provide a type for the item\",\n+            format!(\"{}: <type>\", id),\n+            Applicability::HasPlaceholders,\n+        );\n+        err.stash(id.span, StashKey::ItemNoType);\n+\n+        // The user intended that the type be inferred,\n+        // so treat this as if the user wrote e.g. `const A: _ = expr;`.\n+        P(Ty {\n+            node: TyKind::Infer,\n+            span: id.span,\n+            id: ast::DUMMY_NODE_ID,\n+        })\n+    }\n+\n     /// Parses `type Foo = Bar;` or returns `None`\n     /// without modifying the parser state.\n     fn eat_type(&mut self) -> Option<PResult<'a, (Ident, AliasKind, Generics)>> {"}, {"sha": "2765346b333cf3e9fe68571574441322727955d2", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d0f753955afe5c79d260b03f7fbe68ee53d4950/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d0f753955afe5c79d260b03f7fbe68ee53d4950/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=0d0f753955afe5c79d260b03f7fbe68ee53d4950", "patch": "@@ -295,7 +295,7 @@ impl<'a, 'b> Context<'a, 'b> {\n             .filter(|fmt| fmt.precision_span.is_some())\n             .count();\n         if self.names.is_empty() && !numbered_position_args && count != self.args.len() {\n-            e = self.ecx.mut_span_err(\n+            e = self.ecx.struct_span_err(\n                 sp,\n                 &format!(\n                     \"{} positional argument{} in format string, but {}\",\n@@ -336,7 +336,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 sp = MultiSpan::from_span(self.fmtsp);\n             }\n \n-            e = self.ecx.mut_span_err(sp,\n+            e = self.ecx.struct_span_err(sp,\n                 &format!(\"invalid reference to positional {} ({})\",\n                          arg_list,\n                          self.describe_num_args()));"}, {"sha": "99200a965dd2160b58e2f3d43e8d0324ba0340f4", "filename": "src/test/ui/suggestions/const-no-type.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0d0f753955afe5c79d260b03f7fbe68ee53d4950/src%2Ftest%2Fui%2Fsuggestions%2Fconst-no-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d0f753955afe5c79d260b03f7fbe68ee53d4950/src%2Ftest%2Fui%2Fsuggestions%2Fconst-no-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fconst-no-type.rs?ref=0d0f753955afe5c79d260b03f7fbe68ee53d4950", "patch": "@@ -0,0 +1,46 @@\n+// In the cases below, the type is missing from the `const` and `static` items.\n+//\n+// Here, we test that we:\n+//\n+// a) Perform parser recovery.\n+//\n+// b) Emit a diagnostic with the actual inferred type to RHS of `=` as the suggestion.\n+\n+fn main() {}\n+\n+// These will not reach typeck:\n+\n+#[cfg(FALSE)]\n+const C2 = 42;\n+//~^ ERROR missing type for `const` item\n+//~| HELP provide a type for the item\n+//~| SUGGESTION C2: <type>\n+\n+#[cfg(FALSE)]\n+static S2 = \"abc\";\n+//~^ ERROR missing type for `static` item\n+//~| HELP provide a type for the item\n+//~| SUGGESTION S2: <type>\n+\n+#[cfg(FALSE)]\n+static mut SM2 = \"abc\";\n+//~^ ERROR missing type for `static mut` item\n+//~| HELP provide a type for the item\n+//~| SUGGESTION SM2: <type>\n+\n+// These will, so the diagnostics should be stolen by typeck:\n+\n+const C = 42;\n+//~^ ERROR missing type for `const` item\n+//~| HELP provide a type for the item\n+//~| SUGGESTION C: i32\n+\n+static S = Vec::<String>::new();\n+//~^ ERROR missing type for `static` item\n+//~| HELP provide a type for the item\n+//~| SUGGESTION S: std::vec::Vec<std::string::String>\n+\n+static mut SM = \"abc\";\n+//~^ ERROR missing type for `static mut` item\n+//~| HELP provide a type for the item\n+//~| SUGGESTION &'static str"}, {"sha": "c4f17109dc5c75e48c558bbaa7c3e54268c45e87", "filename": "src/test/ui/suggestions/const-no-type.stderr", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0d0f753955afe5c79d260b03f7fbe68ee53d4950/src%2Ftest%2Fui%2Fsuggestions%2Fconst-no-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0d0f753955afe5c79d260b03f7fbe68ee53d4950/src%2Ftest%2Fui%2Fsuggestions%2Fconst-no-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fconst-no-type.stderr?ref=0d0f753955afe5c79d260b03f7fbe68ee53d4950", "patch": "@@ -0,0 +1,38 @@\n+error: missing type for `const` item\n+  --> $DIR/const-no-type.rs:33:7\n+   |\n+LL | const C = 42;\n+   |       ^ help: provide a type for the item: `C: i32`\n+\n+error: missing type for `static` item\n+  --> $DIR/const-no-type.rs:38:8\n+   |\n+LL | static S = Vec::<String>::new();\n+   |        ^ help: provide a type for the item: `S: std::vec::Vec<std::string::String>`\n+\n+error: missing type for `static mut` item\n+  --> $DIR/const-no-type.rs:43:12\n+   |\n+LL | static mut SM = \"abc\";\n+   |            ^^ help: provide a type for the item: `SM: &'static str`\n+\n+error: missing type for `const` item\n+  --> $DIR/const-no-type.rs:14:7\n+   |\n+LL | const C2 = 42;\n+   |       ^^ help: provide a type for the item: `C2: <type>`\n+\n+error: missing type for `static` item\n+  --> $DIR/const-no-type.rs:20:8\n+   |\n+LL | static S2 = \"abc\";\n+   |        ^^ help: provide a type for the item: `S2: <type>`\n+\n+error: missing type for `static mut` item\n+  --> $DIR/const-no-type.rs:26:12\n+   |\n+LL | static mut SM2 = \"abc\";\n+   |            ^^^ help: provide a type for the item: `SM2: <type>`\n+\n+error: aborting due to 6 previous errors\n+"}]}