{"sha": "71c7798d66953e9f53192d54985a6a46736f5ca5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxYzc3OThkNjY5NTNlOWY1MzE5MmQ1NDk4NWE2YTQ2NzM2ZjVjYTU=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2013-09-15T19:23:53Z"}, "committer": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2013-09-17T06:17:47Z"}, "message": "std: clean up Dir/FileInfo inheritence and flesh out Dir Info", "tree": {"sha": "b2d7ba35e62d7322e9e70d7a0af84b6915aad2f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b2d7ba35e62d7322e9e70d7a0af84b6915aad2f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71c7798d66953e9f53192d54985a6a46736f5ca5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71c7798d66953e9f53192d54985a6a46736f5ca5", "html_url": "https://github.com/rust-lang/rust/commit/71c7798d66953e9f53192d54985a6a46736f5ca5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71c7798d66953e9f53192d54985a6a46736f5ca5/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "daf497462844a55678e12545114bcc75d5ce8ebc", "url": "https://api.github.com/repos/rust-lang/rust/commits/daf497462844a55678e12545114bcc75d5ce8ebc", "html_url": "https://github.com/rust-lang/rust/commit/daf497462844a55678e12545114bcc75d5ce8ebc"}], "stats": {"total": 188, "additions": 129, "deletions": 59}, "files": [{"sha": "af202a729e3d4b678d13029ff5bb917efb5b391e", "filename": "src/libstd/rt/io/file.rs", "status": "modified", "additions": 121, "deletions": 57, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/71c7798d66953e9f53192d54985a6a46736f5ca5/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71c7798d66953e9f53192d54985a6a46736f5ca5/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ffile.rs?ref=71c7798d66953e9f53192d54985a6a46736f5ca5", "patch": "@@ -15,7 +15,9 @@ use super::{SeekStyle,SeekSet, SeekCur, SeekEnd,\n             Open, Read, Write, Create, ReadWrite};\n use rt::rtio::{RtioFileStream, IoFactory, IoFactoryObject};\n use rt::io::{io_error, read_error, EndOfFile,\n-            FileMode, FileAccess, FileStat};\n+            FileMode, FileAccess, FileStat, IoError,\n+            PathAlreadyExists, PathDoesntExist,\n+            MismatchedFileTypeForOperation};\n use rt::local::Local;\n use option::{Some, None};\n use path::Path;\n@@ -100,7 +102,7 @@ pub fn stat<P: PathLike>(path: &P) -> Option<FileStat> {\n             Some(p)\n         },\n         Err(ioerr) => {\n-            read_error::cond.raise(ioerr);\n+            io_error::cond.raise(ioerr);\n             None\n         }\n     }\n@@ -230,41 +232,53 @@ impl Seek for FileStream {\n     }\n }\n \n-/// Represents passive information about a file (primarily exposed\n-/// via the `stat()` method. Also provides methods for opening\n-/// a file in various modes/permissions.\n-pub trait FileInfo<'self> {\n-    /// Get the filesystem path that this `FileInfo` points at,\n-    /// whether it is valid or not. This way, it can be used to\n-    /// to specify a file path of a non-existent file which it\n-    /// later create\n-    fn get_file_path(&'self self) -> &'self Path;\n-\n-    /// Ask the operating system for information about the file\n+// helper for grabbing a stat and ignoring any\n+// error.. used in Info wrappers\n+fn suppressed_stat(cb: &fn() -> Option<FileStat>) -> Option<FileStat> {\n+    do io_error::cond.trap(|_| {\n+        // just swallow the error.. downstream users\n+        // who can make a decision based on a None result\n+        // won't care\n+    }).inside {\n+        cb()\n+    }\n+}\n+\n+/// Shared functionality between `FileInfo` and `DirectoryInfo`\n+pub trait FileSystemInfo {\n+    /// Get the filesystem path that this instance points at,\n+    /// whether it is valid or not. In this way, it can be used to\n+    /// to specify a path of a non-existent file which it\n+    /// later creates\n+    fn get_path<'a>(&'a self) -> &'a Path;\n+\n+    /// Ask the operating system for information about the path,\n+    /// will raise a condition if an error occurs during the process\n     fn stat(&self) -> Option<FileStat> {\n-        use mod_stat = super::file::stat;\n-        do read_error::cond.trap(|_| {\n-            // FIXME: can we do something more useful here?\n-        }).inside {\n-            mod_stat(self.get_file_path())\n-        }\n+        stat(self.get_path())\n     }\n \n     /// returns `true` if the location pointed at by the enclosing\n     /// exists on the filesystem\n-    fn file_exists(&self) -> bool {\n-        match self.stat() {\n+    fn exists(&self) -> bool {\n+        match suppressed_stat(|| self.stat()) {\n             Some(_) => true,\n             None => false\n         }\n     }\n \n-    /// Whether the underlying implemention (be it a file path\n-    /// or active file descriptor) is a \"regular file\". Will return\n+}\n+\n+/// Represents passive information about a file (primarily exposed\n+/// via the `stat()` method. Also provides methods for opening\n+/// a file in various modes/permissions.\n+pub trait FileInfo : FileSystemInfo {\n+    /// Whether the underlying implemention (be it a file path,\n+    /// or something else) points at a \"regular file\" on the FS. Will return\n     /// false for paths to non-existent locations or directories or\n     /// other non-regular files (named pipes, etc).\n     fn is_file(&self) -> bool {\n-        match self.stat() {\n+        match suppressed_stat(|| self.stat()) {\n             Some(s) => s.is_file,\n             None => false\n         }\n@@ -273,12 +287,12 @@ pub trait FileInfo<'self> {\n     /// Attempts to open a regular file for reading/writing based\n     /// on provided inputs\n     fn open_stream(&self, mode: FileMode, access: FileAccess) -> Option<FileStream> {\n-        match self.stat() {\n+        match suppressed_stat(|| self.stat()) {\n             Some(s) => match s.is_file {\n-                true => open(self.get_file_path(), mode, access),\n+                true => open(self.get_path(), mode, access),\n                 false => None // FIXME: raise condition, not a regular file..\n             },\n-            None => open(self.get_file_path(), mode, access)\n+            None => open(self.get_path(), mode, access)\n         }\n     }\n     /// Attempts to open a regular file for reading-only based\n@@ -302,45 +316,82 @@ pub trait FileInfo<'self> {\n     /// Attempt to remove a file from the filesystem, pending the closing\n     /// of any open file descriptors pointing to the file\n     fn unlink(&self) {\n-        unlink(self.get_file_path());\n+        unlink(self.get_path());\n     }\n }\n \n-/// `FileInfo` implementation for `Path`s \n-impl<'self> FileInfo<'self> for Path {\n-    fn get_file_path(&'self self) -> &'self Path { self }\n+/// `FileSystemInfo` implementation for `Path`s \n+impl FileSystemInfo for Path {\n+    fn get_path<'a>(&'a self) -> &'a Path { self }\n }\n+/// `FileInfo` implementation for `Path`s \n+impl FileInfo for Path { }\n \n-/*\n-/// FIXME: DOCS\n-impl DirectoryInfo<'self> {\n-    fn new<P: PathLike>(path: &P) -> FileInfo {\n-        FileInfo(Path(path.path_as_str()))\n-    }\n-    // FIXME #8873 can't put this in FileSystemInfo\n-    fn get_path(&'self self) -> &'self Path {\n-        &*self\n+trait DirectoryInfo : FileSystemInfo {\n+    /// Whether the underlying implemention (be it a file path,\n+    /// or something else) points at a directory file\" on the FS. Will return\n+    /// false for paths to non-existent locations or if the item is\n+    /// not a directory (eg files, named pipes, links, etc)\n+    fn is_dir(&self) -> bool {\n+        match suppressed_stat(|| self.stat()) {\n+            Some(s) => s.is_dir,\n+            None => false\n+        }\n     }\n-    fn stat(&self) -> Option<FileStat> {\n-        file::stat(self.get_path())\n+    /// Create a directory at the location pointed to by the\n+    /// type underlying the given `DirectoryInfo`. Raises a\n+    /// condition if a file, directory, etc already exists\n+    /// at that location or if some other error occurs during\n+    /// the mkdir operation\n+    fn mkdir(&self) {\n+        match suppressed_stat(|| self.stat()) {\n+            Some(_) => {\n+                io_error::cond.raise(IoError {\n+                    kind: PathAlreadyExists,\n+                    desc: \"path already exists\",\n+                    detail:\n+                        Some(fmt!(\"%s already exists; can't mkdir it\", self.get_path().to_str()))\n+                })\n+            },\n+            None => mkdir(self.get_path())\n+        }\n     }\n-    fn exists(&self) -> bool {\n-        do io_error::cond.trap(|_| {\n-        }).inside {\n-            match self.stat() {\n-                Some(_) => true,\n-                None => false\n-            }\n+    /// Remove a directory at the given location pointed to by\n+    /// the type underlying the given `DirectoryInfo`. Will fail\n+    /// if there is no directory at the given location or if\n+    fn rmdir(&self) {\n+        match suppressed_stat(|| self.stat()) {\n+            Some(s) => {\n+                match s.is_dir {\n+                    true => rmdir(self.get_path()),\n+                    false => {\n+                        let ioerr = IoError {\n+                            kind: MismatchedFileTypeForOperation,\n+                            desc: \"Cannot do rmdir() on a non-directory\",\n+                            detail:\n+                                Some(fmt!(\"%s is a non-directory; can't rmdir it\", self.get_path().to_str()))\n+                        };\n+                        io_error::cond.raise(ioerr);\n+                    }\n+                }\n+            },\n+            None =>\n+                io_error::cond.raise(IoError {\n+                    kind: PathDoesntExist,\n+                    desc: \"path doesn't exist\",\n+                    detail: Some(fmt!(\"%s doesn't exist; can't rmdir it\", self.get_path().to_str()))\n+                })\n         }\n     }\n-    fn is_dir(&self) -> bool {\n-        \n+    fn readdir(&self) -> ~[~str] {\n+        ~[]\n     }\n-    fn create(&self);\n-    fn get_subdirs(&self, filter: &str) -> ~[Path];\n-    fn get_files(&self, filter: &str) -> ~[Path];\n+    //fn get_subdirs(&self, filter: &str) -> ~[Path];\n+    //fn get_files(&self, filter: &str) -> ~[Path];\n }\n-*/\n+\n+/// FIXME: DOCS\n+impl DirectoryInfo for Path { }\n \n fn file_test_smoke_test_impl() {\n     do run_in_mt_newsched_task {\n@@ -594,8 +645,21 @@ fn file_test_fileinfo_check_exists_before_and_after_file_creation() {\n             let mut w = file.open_writer(Create);\n             w.write(msg);\n         }\n-        assert!(file.file_exists());\n+        assert!(file.exists());\n         file.unlink();\n-        assert!(!file.file_exists());\n+        assert!(!file.exists());\n+    }\n+}\n+\n+#[test]\n+fn file_test_directoryinfo_check_exists_before_and_after_mkdir() {\n+    do run_in_mt_newsched_task {\n+        let dir = &Path(\"./tmp/before_and_after_dir\");\n+        assert!(!dir.exists());\n+        dir.mkdir();\n+        assert!(dir.exists());\n+        assert!(dir.is_dir());\n+        dir.rmdir();\n+        assert!(!dir.exists());\n     }\n }"}, {"sha": "16c8a9deea0dbd85a2e8f7584a4fee56985cbe2f", "filename": "src/libstd/rt/io/mod.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/71c7798d66953e9f53192d54985a6a46736f5ca5/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71c7798d66953e9f53192d54985a6a46736f5ca5/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmod.rs?ref=71c7798d66953e9f53192d54985a6a46736f5ca5", "patch": "@@ -358,7 +358,10 @@ pub enum IoErrorKind {\n     Closed,\n     ConnectionRefused,\n     ConnectionReset,\n-    BrokenPipe\n+    BrokenPipe,\n+    PathAlreadyExists,\n+    PathDoesntExist,\n+    MismatchedFileTypeForOperation\n }\n \n // FIXME: #8242 implementing manually because deriving doesn't work for some reason\n@@ -374,7 +377,10 @@ impl ToStr for IoErrorKind {\n             Closed => ~\"Closed\",\n             ConnectionRefused => ~\"ConnectionRefused\",\n             ConnectionReset => ~\"ConnectionReset\",\n-            BrokenPipe => ~\"BrokenPipe\"\n+            BrokenPipe => ~\"BrokenPipe\",\n+            PathAlreadyExists => ~\"PathAlreadyExists\",\n+            PathDoesntExist => ~\"PathDoesntExist\",\n+            MismatchedFileTypeForOperation => ~\"MismatchedFileTypeForOperation\"\n         }\n     }\n }"}]}