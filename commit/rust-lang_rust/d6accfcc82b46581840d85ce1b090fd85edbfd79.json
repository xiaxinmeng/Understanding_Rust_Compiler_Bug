{"sha": "d6accfcc82b46581840d85ce1b090fd85edbfd79", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2YWNjZmNjODJiNDY1ODE4NDBkODVjZTFiMDkwZmQ4NWVkYmZkNzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-28T07:26:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-28T07:26:04Z"}, "message": "Auto merge of #4808 - euclio:string-lit-as-bytes, r=phansch\n\ntrigger string_lit_as_bytes when literal has escapes\n\n---\n\nchangelog: fix string_lit_as_bytes false negative\n\nDepends on rust-lang/rust#66349.\n\nFixes #4796.", "tree": {"sha": "609315d294e160bdf9b2c44039d9d8576dc79d36", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/609315d294e160bdf9b2c44039d9d8576dc79d36"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6accfcc82b46581840d85ce1b090fd85edbfd79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6accfcc82b46581840d85ce1b090fd85edbfd79", "html_url": "https://github.com/rust-lang/rust/commit/d6accfcc82b46581840d85ce1b090fd85edbfd79", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6accfcc82b46581840d85ce1b090fd85edbfd79/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f745dabd99d20b3c8296689695eed8ff898190a", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f745dabd99d20b3c8296689695eed8ff898190a", "html_url": "https://github.com/rust-lang/rust/commit/7f745dabd99d20b3c8296689695eed8ff898190a"}, {"sha": "d33ad45d7da3da94514351b322aba5052a393202", "url": "https://api.github.com/repos/rust-lang/rust/commits/d33ad45d7da3da94514351b322aba5052a393202", "html_url": "https://github.com/rust-lang/rust/commit/d33ad45d7da3da94514351b322aba5052a393202"}], "stats": {"total": 99, "additions": 52, "deletions": 47}, "files": [{"sha": "00e2441becf8129f8b6e283fb7e23eea8e74daa2", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 41, "deletions": 46, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/d6accfcc82b46581840d85ce1b090fd85edbfd79/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6accfcc82b46581840d85ce1b090fd85edbfd79/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=d6accfcc82b46581840d85ce1b090fd85edbfd79", "patch": "@@ -4,6 +4,8 @@ use rustc::{declare_lint_pass, declare_tool_lint};\n use rustc_errors::Applicability;\n use syntax::source_map::Spanned;\n \n+use if_chain::if_chain;\n+\n use crate::utils::SpanlessEq;\n use crate::utils::{get_parent_expr, is_allowed, match_type, paths, span_lint, span_lint_and_sugg, walk_ptrs_ty};\n \n@@ -146,53 +148,46 @@ declare_lint_pass!(StringLitAsBytes => [STRING_LIT_AS_BYTES]);\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringLitAsBytes {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         use crate::utils::{snippet, snippet_with_applicability};\n-        use syntax::ast::{LitKind, StrStyle};\n+        use syntax::ast::LitKind;\n \n-        if let ExprKind::MethodCall(ref path, _, ref args) = e.kind {\n-            if path.ident.name == sym!(as_bytes) {\n-                if let ExprKind::Lit(ref lit) = args[0].kind {\n-                    if let LitKind::Str(ref lit_content, style) = lit.node {\n-                        let callsite = snippet(cx, args[0].span.source_callsite(), r#\"\"foo\"\"#);\n-                        let expanded = if let StrStyle::Raw(n) = style {\n-                            let term = \"#\".repeat(usize::from(n));\n-                            format!(\"r{0}\\\"{1}\\\"{0}\", term, lit_content.as_str())\n-                        } else {\n-                            format!(\"\\\"{}\\\"\", lit_content.as_str())\n-                        };\n-                        let mut applicability = Applicability::MachineApplicable;\n-                        if callsite.starts_with(\"include_str!\") {\n-                            span_lint_and_sugg(\n-                                cx,\n-                                STRING_LIT_AS_BYTES,\n-                                e.span,\n-                                \"calling `as_bytes()` on `include_str!(..)`\",\n-                                \"consider using `include_bytes!(..)` instead\",\n-                                snippet_with_applicability(cx, args[0].span, r#\"\"foo\"\"#, &mut applicability).replacen(\n-                                    \"include_str\",\n-                                    \"include_bytes\",\n-                                    1,\n-                                ),\n-                                applicability,\n-                            );\n-                        } else if callsite == expanded\n-                            && lit_content.as_str().chars().all(|c| c.is_ascii())\n-                            && lit_content.as_str().len() <= MAX_LENGTH_BYTE_STRING_LIT\n-                            && !args[0].span.from_expansion()\n-                        {\n-                            span_lint_and_sugg(\n-                                cx,\n-                                STRING_LIT_AS_BYTES,\n-                                e.span,\n-                                \"calling `as_bytes()` on a string literal\",\n-                                \"consider using a byte string literal instead\",\n-                                format!(\n-                                    \"b{}\",\n-                                    snippet_with_applicability(cx, args[0].span, r#\"\"foo\"\"#, &mut applicability)\n-                                ),\n-                                applicability,\n-                            );\n-                        }\n-                    }\n+        if_chain! {\n+            if let ExprKind::MethodCall(path, _, args) = &e.kind;\n+            if path.ident.name == sym!(as_bytes);\n+            if let ExprKind::Lit(lit) = &args[0].kind;\n+            if let LitKind::Str(lit_content, _) = &lit.node;\n+            then {\n+                let callsite = snippet(cx, args[0].span.source_callsite(), r#\"\"foo\"\"#);\n+                let mut applicability = Applicability::MachineApplicable;\n+                if callsite.starts_with(\"include_str!\") {\n+                    span_lint_and_sugg(\n+                        cx,\n+                        STRING_LIT_AS_BYTES,\n+                        e.span,\n+                        \"calling `as_bytes()` on `include_str!(..)`\",\n+                        \"consider using `include_bytes!(..)` instead\",\n+                        snippet_with_applicability(cx, args[0].span, r#\"\"foo\"\"#, &mut applicability).replacen(\n+                            \"include_str\",\n+                            \"include_bytes\",\n+                            1,\n+                        ),\n+                        applicability,\n+                    );\n+                } else if lit_content.as_str().is_ascii()\n+                    && lit_content.as_str().len() <= MAX_LENGTH_BYTE_STRING_LIT\n+                    && !args[0].span.from_expansion()\n+                {\n+                    span_lint_and_sugg(\n+                        cx,\n+                        STRING_LIT_AS_BYTES,\n+                        e.span,\n+                        \"calling `as_bytes()` on a string literal\",\n+                        \"consider using a byte string literal instead\",\n+                        format!(\n+                            \"b{}\",\n+                            snippet_with_applicability(cx, args[0].span, r#\"\"foo\"\"#, &mut applicability)\n+                        ),\n+                        applicability,\n+                    );\n                 }\n             }\n         }"}, {"sha": "7ad272ade5f9c6bb6fbde13e3182a28b47cff0a3", "filename": "tests/ui/string_lit_as_bytes.fixed", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6accfcc82b46581840d85ce1b090fd85edbfd79/tests%2Fui%2Fstring_lit_as_bytes.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d6accfcc82b46581840d85ce1b090fd85edbfd79/tests%2Fui%2Fstring_lit_as_bytes.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstring_lit_as_bytes.fixed?ref=d6accfcc82b46581840d85ce1b090fd85edbfd79", "patch": "@@ -15,6 +15,8 @@ fn str_lit_as_bytes() {\n     let strify = stringify!(foobar).as_bytes();\n \n     let includestr = include_bytes!(\"entry_unfixable.rs\");\n+\n+    let _ = b\"string with newline\\t\\n\";\n }\n \n fn main() {}"}, {"sha": "1bf4538b7c94f25069289340e53ae4d8819b9142", "filename": "tests/ui/string_lit_as_bytes.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6accfcc82b46581840d85ce1b090fd85edbfd79/tests%2Fui%2Fstring_lit_as_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6accfcc82b46581840d85ce1b090fd85edbfd79/tests%2Fui%2Fstring_lit_as_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstring_lit_as_bytes.rs?ref=d6accfcc82b46581840d85ce1b090fd85edbfd79", "patch": "@@ -15,6 +15,8 @@ fn str_lit_as_bytes() {\n     let strify = stringify!(foobar).as_bytes();\n \n     let includestr = include_str!(\"entry_unfixable.rs\").as_bytes();\n+\n+    let _ = \"string with newline\\t\\n\".as_bytes();\n }\n \n fn main() {}"}, {"sha": "ff6e3346dfc756e6112e9a8d1f6128236b0261e1", "filename": "tests/ui/string_lit_as_bytes.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d6accfcc82b46581840d85ce1b090fd85edbfd79/tests%2Fui%2Fstring_lit_as_bytes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d6accfcc82b46581840d85ce1b090fd85edbfd79/tests%2Fui%2Fstring_lit_as_bytes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstring_lit_as_bytes.stderr?ref=d6accfcc82b46581840d85ce1b090fd85edbfd79", "patch": "@@ -18,5 +18,11 @@ error: calling `as_bytes()` on `include_str!(..)`\n LL |     let includestr = include_str!(\"entry_unfixable.rs\").as_bytes();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `include_bytes!(..)` instead: `include_bytes!(\"entry_unfixable.rs\")`\n \n-error: aborting due to 3 previous errors\n+error: calling `as_bytes()` on a string literal\n+  --> $DIR/string_lit_as_bytes.rs:19:13\n+   |\n+LL |     let _ = \"string with newline/t/n\".as_bytes();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using a byte string literal instead: `b\"string with newline/t/n\"`\n+\n+error: aborting due to 4 previous errors\n "}]}