{"sha": "414f3c7d252fcd54562c0c8a85499d7d07f5e612", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxNGYzYzdkMjUyZmNkNTQ1NjJjMGM4YTg1NDk5ZDdkMDdmNWU2MTI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-05T00:30:31Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-14T21:52:06Z"}, "message": "core::rt: Add a simple channel type for passing buffered messages between Scheduler and Task\n\nCalled 'Tube' for lack of anything better.", "tree": {"sha": "a54ab1c7ea84529b6efa9b2e21429b717cdbc376", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a54ab1c7ea84529b6efa9b2e21429b717cdbc376"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/414f3c7d252fcd54562c0c8a85499d7d07f5e612", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/414f3c7d252fcd54562c0c8a85499d7d07f5e612", "html_url": "https://github.com/rust-lang/rust/commit/414f3c7d252fcd54562c0c8a85499d7d07f5e612", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/414f3c7d252fcd54562c0c8a85499d7d07f5e612/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40a9de5ebc8bea4d0a42a89e657a35a5b07d4042", "url": "https://api.github.com/repos/rust-lang/rust/commits/40a9de5ebc8bea4d0a42a89e657a35a5b07d4042", "html_url": "https://github.com/rust-lang/rust/commit/40a9de5ebc8bea4d0a42a89e657a35a5b07d4042"}], "stats": {"total": 220, "additions": 212, "deletions": 8}, "files": [{"sha": "4308d22548f434abba308f6d68e687dc505c1b7a", "filename": "src/libcore/logging.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/414f3c7d252fcd54562c0c8a85499d7d07f5e612/src%2Flibcore%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/414f3c7d252fcd54562c0c8a85499d7d07f5e612/src%2Flibcore%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flogging.rs?ref=414f3c7d252fcd54562c0c8a85499d7d07f5e612", "patch": "@@ -19,6 +19,7 @@ use libc;\n use repr;\n use vec;\n use cast;\n+use str;\n \n /// Turns on logging to stdout globally\n pub fn console_on() {\n@@ -57,7 +58,7 @@ pub fn log_type<T>(level: u32, object: &T) {\n         }\n         _ => {\n             // XXX: Bad allocation\n-            let msg = bytes.to_str();\n+            let msg = str::from_bytes(bytes);\n             newsched_log_str(msg);\n         }\n     }"}, {"sha": "b2ba6d7d3c407a63d244f8d9bf64e5cfda1fca8c", "filename": "src/libcore/rt/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/414f3c7d252fcd54562c0c8a85499d7d07f5e612/src%2Flibcore%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/414f3c7d252fcd54562c0c8a85499d7d07f5e612/src%2Flibcore%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fmod.rs?ref=414f3c7d252fcd54562c0c8a85499d7d07f5e612", "patch": "@@ -18,7 +18,7 @@ use libc::c_char;\n mod sched;\n \n /// Thread-local access to the current Scheduler\n-mod local_sched;\n+pub mod local_sched;\n \n /// Synchronous I/O\n #[path = \"io/mod.rs\"]\n@@ -68,6 +68,10 @@ pub mod test;\n /// Reference counting\n pub mod rc;\n \n+/// A simple single-threaded channel type for passing buffered data between\n+/// scheduler and task context\n+pub mod tube;\n+\n /// Set up a default runtime configuration, given compiler-supplied arguments.\n ///\n /// This is invoked by the `start` _language item_ (unstable::lang) to"}, {"sha": "ef376199fcbdc6945ae12f3d7c5568117a7e0938", "filename": "src/libcore/rt/tube.rs", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/414f3c7d252fcd54562c0c8a85499d7d07f5e612/src%2Flibcore%2Frt%2Ftube.rs", "raw_url": "https://github.com/rust-lang/rust/raw/414f3c7d252fcd54562c0c8a85499d7d07f5e612/src%2Flibcore%2Frt%2Ftube.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Ftube.rs?ref=414f3c7d252fcd54562c0c8a85499d7d07f5e612", "patch": "@@ -0,0 +1,182 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A very simple unsynchronized channel type for sending buffered data from\n+//! scheduler context to task context.\n+//!\n+//! XXX: This would be safer to use if split into two types like Port/Chan\n+\n+use option::*;\n+use clone::Clone;\n+use super::rc::RC;\n+use rt::sched::Task;\n+use rt::{context, TaskContext, SchedulerContext};\n+use rt::local_sched;\n+\n+struct TubeState<T> {\n+    blocked_task: Option<~Task>,\n+    buf: ~[T]\n+}\n+\n+pub struct Tube<T> {\n+    p: RC<TubeState<T>>\n+}\n+\n+impl<T> Tube<T> {\n+    pub fn new() -> Tube<T> {\n+        Tube {\n+            p: RC::new(TubeState {\n+                blocked_task: None,\n+                buf: ~[]\n+            })\n+        }\n+    }\n+\n+    pub fn send(&mut self, val: T) {\n+        rtdebug!(\"tube send\");\n+        assert!(context() == SchedulerContext);\n+\n+        unsafe {\n+            let state = self.p.unsafe_borrow_mut();\n+            (*state).buf.push(val);\n+\n+            if (*state).blocked_task.is_some() {\n+                // There's a waiting task. Wake it up\n+                rtdebug!(\"waking blocked tube\");\n+                let task = (*state).blocked_task.swap_unwrap();\n+                let sched = local_sched::take();\n+                sched.resume_task_immediately(task);\n+            }\n+        }\n+    }\n+\n+    pub fn recv(&mut self) -> T {\n+        assert!(context() == TaskContext);\n+\n+        unsafe {\n+            let state = self.p.unsafe_borrow_mut();\n+            if !(*state).buf.is_empty() {\n+                return (*state).buf.shift();\n+            } else {\n+                // Block and wait for the next message\n+                rtdebug!(\"blocking on tube recv\");\n+                assert!(self.p.refcount() > 1); // There better be somebody to wake us up\n+                assert!((*state).blocked_task.is_none());\n+                let sched = local_sched::take();\n+                do sched.deschedule_running_task_and_then |task| {\n+                    (*state).blocked_task = Some(task);\n+                }\n+                rtdebug!(\"waking after tube recv\");\n+                let buf = &mut (*state).buf;\n+                assert!(!buf.is_empty());\n+                return buf.shift();\n+            }\n+        }\n+    }\n+}\n+\n+impl<T> Clone for Tube<T> {\n+    fn clone(&self) -> Tube<T> {\n+        Tube { p: self.p.clone() }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use int;\n+    use cell::Cell;\n+    use rt::local_sched;\n+    use rt::test::*;\n+    use rt::rtio::EventLoop;\n+    use super::*;\n+\n+    #[test]\n+    fn simple_test() {\n+        do run_in_newsched_task {\n+            let mut tube: Tube<int> = Tube::new();\n+            let tube_clone = tube.clone();\n+            let tube_clone_cell = Cell(tube_clone);\n+            let sched = local_sched::take();\n+            do sched.deschedule_running_task_and_then |task| {\n+                let mut tube_clone = tube_clone_cell.take();\n+                tube_clone.send(1);\n+                let sched = local_sched::take();\n+                sched.resume_task_immediately(task);\n+            }\n+\n+            assert!(tube.recv() == 1);\n+        }\n+    }\n+\n+    #[test]\n+    fn blocking_test() {\n+        do run_in_newsched_task {\n+            let mut tube: Tube<int> = Tube::new();\n+            let tube_clone = tube.clone();\n+            let tube_clone = Cell(Cell(Cell(tube_clone)));\n+            let sched = local_sched::take();\n+            do sched.deschedule_running_task_and_then |task| {\n+                let tube_clone = tube_clone.take();\n+                do local_sched::borrow |sched| {\n+                    let tube_clone = tube_clone.take();\n+                    do sched.event_loop.callback {\n+                        let mut tube_clone = tube_clone.take();\n+                        // The task should be blocked on this now and\n+                        // sending will wake it up.\n+                        tube_clone.send(1);\n+                    }\n+                }\n+                let sched = local_sched::take();\n+                sched.resume_task_immediately(task);\n+            }\n+\n+            assert!(tube.recv() == 1);\n+        }\n+    }\n+\n+    #[test]\n+    fn many_blocking_test() {\n+        static MAX: int = 100;\n+\n+        do run_in_newsched_task {\n+            let mut tube: Tube<int> = Tube::new();\n+            let tube_clone = tube.clone();\n+            let tube_clone = Cell(tube_clone);\n+            let sched = local_sched::take();\n+            do sched.deschedule_running_task_and_then |task| {\n+                callback_send(tube_clone.take(), 0);\n+\n+                fn callback_send(tube: Tube<int>, i: int) {\n+                    if i == 100 { return; }\n+\n+                    let tube = Cell(Cell(tube));\n+                    do local_sched::borrow |sched| {\n+                        let tube = tube.take();\n+                        do sched.event_loop.callback {\n+                            let mut tube = tube.take();\n+                            // The task should be blocked on this now and\n+                            // sending will wake it up.\n+                            tube.send(i);\n+                            callback_send(tube, i + 1);\n+                        }\n+                    }\n+                }\n+\n+                let sched = local_sched::take();\n+                sched.resume_task_immediately(task);\n+            }\n+\n+            for int::range(0, MAX) |i| {\n+                let j = tube.recv();\n+                assert!(j == i);\n+            }\n+        }\n+    }\n+}"}, {"sha": "50a739ec67df7616268578fb6c0f5fca7a2542e4", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/414f3c7d252fcd54562c0c8a85499d7d07f5e612/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/414f3c7d252fcd54562c0c8a85499d7d07f5e612/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=414f3c7d252fcd54562c0c8a85499d7d07f5e612", "patch": "@@ -202,10 +202,12 @@ impl FailWithCause for &'static str {\n \n // FIXME #4427: Temporary until rt::rt_fail_ goes away\n pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n-    use rt::{context, OldTaskContext};\n-    use rt::local_services::unsafe_borrow_local_services;\n+    use option::Option;\n+    use rt::{context, OldTaskContext, TaskContext};\n+    use rt::local_services::{unsafe_borrow_local_services, Unwinder};\n \n-    match context() {\n+    let context = context();\n+    match context {\n         OldTaskContext => {\n             unsafe {\n                 gc::cleanup_stack_for_failure();\n@@ -214,11 +216,26 @@ pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n             }\n         }\n         _ => {\n-            // XXX: Need to print the failure message\n-            gc::cleanup_stack_for_failure();\n             unsafe {\n+                // XXX: Bad re-allocations. fail! needs some refactoring\n+                let msg = str::raw::from_c_str(msg);\n+                let file = str::raw::from_c_str(file);\n+\n+                let outmsg = fmt!(\"%s at line %i of file %s\", msg, line as int, file);\n+\n+                // XXX: Logging doesn't work correctly in non-task context because it\n+                // invokes the local heap\n+                if context == TaskContext {\n+                    error!(outmsg);\n+                } else {\n+                    rtdebug!(\"%s\", outmsg);\n+                }\n+\n+                gc::cleanup_stack_for_failure();\n+\n                 let local_services = unsafe_borrow_local_services();\n-                match (*local_services).unwinder {\n+                let unwinder: &mut Option<Unwinder> = &mut (*local_services).unwinder;\n+                match *unwinder {\n                     Some(ref mut unwinder) => unwinder.begin_unwind(),\n                     None => abort!(\"failure without unwinder. aborting process\")\n                 }"}]}