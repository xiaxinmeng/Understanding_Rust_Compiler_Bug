{"sha": "a2c2720e09202e1f988ff568efa4dcac8a71a504", "node_id": "C_kwDOAAsO6NoAKGEyYzI3MjBlMDkyMDJlMWY5ODhmZjU2OGVmYTRkY2FjOGE3MWE1MDQ", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-05-18T06:41:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-05-18T06:41:18Z"}, "message": "Rollup merge of #97123 - ricked-twice:issue-96223-clean-fix, r=jackh726\n\nClean fix for #96223\n\nOkay, so here we are (hopefully) :+1:\n\nCloses #96223\n\nThanks a lot to `@jackh726` for your help and explanation :pray:\n\n- Modified `InferCtxt::mk_trait_obligation_with_new_self_ty` to take as argument a `Binder<(TraitPredicate, Ty)>` instead of a `Binder<TraitPredicate>` and a separate `Ty` with no bound vars.\n\n- Modified all call places to avoid calling `Binder::no_bounds_var` or `Binder::skip_binder` when it is not safe.\n\nr? `@jackh726`", "tree": {"sha": "540179ca7bc9385501adc59c6ade1586bc03364a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/540179ca7bc9385501adc59c6ade1586bc03364a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2c2720e09202e1f988ff568efa4dcac8a71a504", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJihJUOCRBK7hj4Ov3rIwAAedAIAGsWFhWkjvaFotBl5kYbPd9/\n5fHo78dtPffmhgzI8v6cC/mdP3fgUCrXgKC6b8oHK6N/f0qoKByek8bV9dC9Kgdc\nMWpqWsCWYsME+Qa3s0qQa2hbVDpapR4t/I1TAlBFX9eCY6hv23ZoXG6UIxWfxWMi\nXtyuVvYf+1QWDN2Ze3vOiO+yvanYdLBeocrPn2h/5Q/VMTYLCLo+sIjjm0OvJ0yZ\nfTY5q0CfuDvoI77Oyay6sPpBqNUbdZUDclbMunbjpJwnbJ5xuwD5XfvpdQgtJPZR\nx/tBY7QBFd7SHSQ/+vV5KieCNIoVjQcfIAv2jL/2bcK9Z8OGDf83try0PkznPd8=\n=9G1O\n-----END PGP SIGNATURE-----\n", "payload": "tree 540179ca7bc9385501adc59c6ade1586bc03364a\nparent 2d95c6acab4a8988ede533e52710d960d11ae038\nparent ac5366b669b5a4f9a6c7e231ac6f99e709c44fe9\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1652856078 +0200\ncommitter GitHub <noreply@github.com> 1652856078 +0200\n\nRollup merge of #97123 - ricked-twice:issue-96223-clean-fix, r=jackh726\n\nClean fix for #96223\n\nOkay, so here we are (hopefully) :+1:\n\nCloses #96223\n\nThanks a lot to `@jackh726` for your help and explanation :pray:\n\n- Modified `InferCtxt::mk_trait_obligation_with_new_self_ty` to take as argument a `Binder<(TraitPredicate, Ty)>` instead of a `Binder<TraitPredicate>` and a separate `Ty` with no bound vars.\n\n- Modified all call places to avoid calling `Binder::no_bounds_var` or `Binder::skip_binder` when it is not safe.\n\nr? `@jackh726`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2c2720e09202e1f988ff568efa4dcac8a71a504", "html_url": "https://github.com/rust-lang/rust/commit/a2c2720e09202e1f988ff568efa4dcac8a71a504", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2c2720e09202e1f988ff568efa4dcac8a71a504/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d95c6acab4a8988ede533e52710d960d11ae038", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d95c6acab4a8988ede533e52710d960d11ae038", "html_url": "https://github.com/rust-lang/rust/commit/2d95c6acab4a8988ede533e52710d960d11ae038"}, {"sha": "ac5366b669b5a4f9a6c7e231ac6f99e709c44fe9", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac5366b669b5a4f9a6c7e231ac6f99e709c44fe9", "html_url": "https://github.com/rust-lang/rust/commit/ac5366b669b5a4f9a6c7e231ac6f99e709c44fe9"}], "stats": {"total": 273, "additions": 135, "deletions": 138}, "files": [{"sha": "266fcc777ef565738b1d83cdc3b6a6af4e76e7c8", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a2c2720e09202e1f988ff568efa4dcac8a71a504/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c2720e09202e1f988ff568efa4dcac8a71a504/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=a2c2720e09202e1f988ff568efa4dcac8a71a504", "patch": "@@ -1384,8 +1384,7 @@ trait InferCtxtPrivExt<'hir, 'tcx> {\n     fn mk_trait_obligation_with_new_self_ty(\n         &self,\n         param_env: ty::ParamEnv<'tcx>,\n-        trait_ref: ty::PolyTraitPredicate<'tcx>,\n-        new_self_ty: Ty<'tcx>,\n+        trait_ref_and_ty: ty::Binder<'tcx, (ty::TraitPredicate<'tcx>, Ty<'tcx>)>,\n     ) -> PredicateObligation<'tcx>;\n \n     fn maybe_report_ambiguity(\n@@ -1923,14 +1922,11 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n     fn mk_trait_obligation_with_new_self_ty(\n         &self,\n         param_env: ty::ParamEnv<'tcx>,\n-        trait_ref: ty::PolyTraitPredicate<'tcx>,\n-        new_self_ty: Ty<'tcx>,\n+        trait_ref_and_ty: ty::Binder<'tcx, (ty::TraitPredicate<'tcx>, Ty<'tcx>)>,\n     ) -> PredicateObligation<'tcx> {\n-        assert!(!new_self_ty.has_escaping_bound_vars());\n-\n-        let trait_pred = trait_ref.map_bound_ref(|tr| ty::TraitPredicate {\n+        let trait_pred = trait_ref_and_ty.map_bound_ref(|(tr, new_self_ty)| ty::TraitPredicate {\n             trait_ref: ty::TraitRef {\n-                substs: self.tcx.mk_substs_trait(new_self_ty, &tr.trait_ref.substs[1..]),\n+                substs: self.tcx.mk_substs_trait(*new_self_ty, &tr.trait_ref.substs[1..]),\n                 ..tr.trait_ref\n             },\n             ..*tr"}, {"sha": "c3ee849d857165346ce33eeddb69f73c2da7d49e", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 126, "deletions": 120, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/a2c2720e09202e1f988ff568efa4dcac8a71a504/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c2720e09202e1f988ff568efa4dcac8a71a504/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=a2c2720e09202e1f988ff568efa4dcac8a71a504", "patch": "@@ -628,17 +628,21 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             if let Some(parent_trait_pred) = parent_trait_pred {\n                 real_trait_pred = parent_trait_pred;\n             }\n-            let Some(real_ty) = real_trait_pred.self_ty().no_bound_vars() else {\n-                continue;\n-            };\n+\n+            // Skipping binder here, remapping below\n+            let real_ty = real_trait_pred.self_ty().skip_binder();\n \n             if let ty::Ref(region, base_ty, mutbl) = *real_ty.kind() {\n                 let mut autoderef = Autoderef::new(self, param_env, body_id, span, base_ty, span);\n                 if let Some(steps) = autoderef.find_map(|(ty, steps)| {\n                     // Re-add the `&`\n                     let ty = self.tcx.mk_ref(region, TypeAndMut { ty, mutbl });\n-                    let obligation =\n-                        self.mk_trait_obligation_with_new_self_ty(param_env, real_trait_pred, ty);\n+\n+                    // Remapping bound vars here\n+                    let real_trait_pred_and_ty =\n+                        real_trait_pred.map_bound(|inner_trait_pred| (inner_trait_pred, ty));\n+                    let obligation = self\n+                        .mk_trait_obligation_with_new_self_ty(param_env, real_trait_pred_and_ty);\n                     Some(steps).filter(|_| self.predicate_may_hold(&obligation))\n                 }) {\n                     if steps > 0 {\n@@ -659,10 +663,13 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     }\n                 } else if real_trait_pred != trait_pred {\n                     // This branch addresses #87437.\n+\n+                    // Remapping bound vars here\n+                    let real_trait_pred_and_base_ty =\n+                        real_trait_pred.map_bound(|inner_trait_pred| (inner_trait_pred, base_ty));\n                     let obligation = self.mk_trait_obligation_with_new_self_ty(\n                         param_env,\n-                        real_trait_pred,\n-                        base_ty,\n+                        real_trait_pred_and_base_ty,\n                     );\n                     if self.predicate_may_hold(&obligation) {\n                         err.span_suggestion_verbose(\n@@ -720,9 +727,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) -> bool {\n-        let Some(self_ty) = trait_pred.self_ty().no_bound_vars() else {\n-            return false;\n-        };\n+        // Skipping binder here, remapping below\n+        let self_ty = trait_pred.self_ty().skip_binder();\n \n         let (def_id, output_ty, callable) = match *self_ty.kind() {\n             ty::Closure(def_id, substs) => (def_id, substs.as_closure().sig().output(), \"closure\"),\n@@ -731,14 +737,15 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         };\n         let msg = format!(\"use parentheses to call the {}\", callable);\n \n-        // `mk_trait_obligation_with_new_self_ty` only works for types with no escaping bound\n-        // variables, so bail out if we have any.\n-        let Some(output_ty) = output_ty.no_bound_vars() else {\n-            return false;\n-        };\n+        // \"We should really create a single list of bound vars from the combined vars\n+        // from the predicate and function, but instead we just liberate the function bound vars\"\n+        let output_ty = self.tcx.liberate_late_bound_regions(def_id, output_ty);\n+\n+        // Remapping bound vars here\n+        let trait_pred_and_self = trait_pred.map_bound(|trait_pred| (trait_pred, output_ty));\n \n         let new_obligation =\n-            self.mk_trait_obligation_with_new_self_ty(obligation.param_env, trait_pred, output_ty);\n+            self.mk_trait_obligation_with_new_self_ty(obligation.param_env, trait_pred_and_self);\n \n         match self.evaluate_obligation(&new_obligation) {\n             Ok(\n@@ -842,96 +849,97 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         let param_env = obligation.param_env;\n \n         // Try to apply the original trait binding obligation by borrowing.\n-        let mut try_borrowing = |old_pred: ty::PolyTraitPredicate<'tcx>,\n-                                 blacklist: &[DefId]|\n-         -> bool {\n-            if blacklist.contains(&old_pred.def_id()) {\n-                return false;\n-            }\n-\n-            // This is a quick fix to resolve an ICE (#96223).\n-            // This change should probably be deeper.\n-            // As suggested by @jackh726, `mk_trait_obligation_with_new_self_ty` could take a `Binder<(TraitRef, Ty)>\n-            // instead of `Binder<Ty>` leading to some changes to its call places.\n-            let Some(orig_ty) = old_pred.self_ty().no_bound_vars() else {\n-                return false;\n-            };\n-            let mk_result = |new_ty| {\n-                let obligation =\n-                    self.mk_trait_obligation_with_new_self_ty(param_env, old_pred, new_ty);\n-                self.predicate_must_hold_modulo_regions(&obligation)\n-            };\n-            let imm_result = mk_result(self.tcx.mk_imm_ref(self.tcx.lifetimes.re_static, orig_ty));\n-            let mut_result = mk_result(self.tcx.mk_mut_ref(self.tcx.lifetimes.re_static, orig_ty));\n-\n-            if imm_result || mut_result {\n-                if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n-                    // We have a very specific type of error, where just borrowing this argument\n-                    // might solve the problem. In cases like this, the important part is the\n-                    // original type obligation, not the last one that failed, which is arbitrary.\n-                    // Because of this, we modify the error to refer to the original obligation and\n-                    // return early in the caller.\n-\n-                    let msg = format!(\n-                        \"the trait bound `{}: {}` is not satisfied\",\n-                        orig_ty,\n-                        old_pred.print_modifiers_and_trait_path(),\n-                    );\n-                    if has_custom_message {\n-                        err.note(&msg);\n-                    } else {\n-                        err.message =\n-                            vec![(rustc_errors::DiagnosticMessage::Str(msg), Style::NoStyle)];\n-                    }\n-                    if snippet.starts_with('&') {\n-                        // This is already a literal borrow and the obligation is failing\n-                        // somewhere else in the obligation chain. Do not suggest non-sense.\n-                        return false;\n-                    }\n-                    err.span_label(\n-                        span,\n-                        &format!(\n-                            \"expected an implementor of trait `{}`\",\n-                            old_pred.print_modifiers_and_trait_path(),\n-                        ),\n-                    );\n+        let mut try_borrowing =\n+            |old_pred: ty::PolyTraitPredicate<'tcx>, blacklist: &[DefId]| -> bool {\n+                if blacklist.contains(&old_pred.def_id()) {\n+                    return false;\n+                }\n+                // We map bounds to `&T` and `&mut T`\n+                let trait_pred_and_imm_ref = old_pred.map_bound(|trait_pred| {\n+                    (\n+                        trait_pred,\n+                        self.tcx.mk_imm_ref(self.tcx.lifetimes.re_static, trait_pred.self_ty()),\n+                    )\n+                });\n+                let trait_pred_and_mut_ref = old_pred.map_bound(|trait_pred| {\n+                    (\n+                        trait_pred,\n+                        self.tcx.mk_mut_ref(self.tcx.lifetimes.re_static, trait_pred.self_ty()),\n+                    )\n+                });\n \n-                    // This if is to prevent a special edge-case\n-                    if matches!(\n-                        span.ctxt().outer_expn_data().kind,\n-                        ExpnKind::Root | ExpnKind::Desugaring(DesugaringKind::ForLoop)\n-                    ) {\n-                        // We don't want a borrowing suggestion on the fields in structs,\n-                        // ```\n-                        // struct Foo {\n-                        //  the_foos: Vec<Foo>\n-                        // }\n-                        // ```\n-\n-                        if imm_result && mut_result {\n-                            err.span_suggestions(\n-                                span.shrink_to_lo(),\n-                                \"consider borrowing here\",\n-                                [\"&\".to_string(), \"&mut \".to_string()].into_iter(),\n-                                Applicability::MaybeIncorrect,\n-                            );\n+                let mk_result = |trait_pred_and_new_ty| {\n+                    let obligation =\n+                        self.mk_trait_obligation_with_new_self_ty(param_env, trait_pred_and_new_ty);\n+                    self.predicate_must_hold_modulo_regions(&obligation)\n+                };\n+                let imm_result = mk_result(trait_pred_and_imm_ref);\n+                let mut_result = mk_result(trait_pred_and_mut_ref);\n+\n+                if imm_result || mut_result {\n+                    if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n+                        // We have a very specific type of error, where just borrowing this argument\n+                        // might solve the problem. In cases like this, the important part is the\n+                        // original type obligation, not the last one that failed, which is arbitrary.\n+                        // Because of this, we modify the error to refer to the original obligation and\n+                        // return early in the caller.\n+\n+                        let msg = format!(\"the trait bound `{}` is not satisfied\", old_pred);\n+                        if has_custom_message {\n+                            err.note(&msg);\n                         } else {\n-                            err.span_suggestion_verbose(\n-                                span.shrink_to_lo(),\n-                                &format!(\n-                                    \"consider{} borrowing here\",\n-                                    if mut_result { \" mutably\" } else { \"\" }\n-                                ),\n-                                format!(\"&{}\", if mut_result { \"mut \" } else { \"\" }),\n-                                Applicability::MaybeIncorrect,\n-                            );\n+                            err.message =\n+                                vec![(rustc_errors::DiagnosticMessage::Str(msg), Style::NoStyle)];\n                         }\n+                        if snippet.starts_with('&') {\n+                            // This is already a literal borrow and the obligation is failing\n+                            // somewhere else in the obligation chain. Do not suggest non-sense.\n+                            return false;\n+                        }\n+                        err.span_label(\n+                            span,\n+                            &format!(\n+                                \"expected an implementor of trait `{}`\",\n+                                old_pred.print_modifiers_and_trait_path(),\n+                            ),\n+                        );\n+\n+                        // This if is to prevent a special edge-case\n+                        if matches!(\n+                            span.ctxt().outer_expn_data().kind,\n+                            ExpnKind::Root | ExpnKind::Desugaring(DesugaringKind::ForLoop)\n+                        ) {\n+                            // We don't want a borrowing suggestion on the fields in structs,\n+                            // ```\n+                            // struct Foo {\n+                            //  the_foos: Vec<Foo>\n+                            // }\n+                            // ```\n+\n+                            if imm_result && mut_result {\n+                                err.span_suggestions(\n+                                    span.shrink_to_lo(),\n+                                    \"consider borrowing here\",\n+                                    [\"&\".to_string(), \"&mut \".to_string()].into_iter(),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                            } else {\n+                                err.span_suggestion_verbose(\n+                                    span.shrink_to_lo(),\n+                                    &format!(\n+                                        \"consider{} borrowing here\",\n+                                        if mut_result { \" mutably\" } else { \"\" }\n+                                    ),\n+                                    format!(\"&{}\", if mut_result { \"mut \" } else { \"\" }),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                            }\n+                        }\n+                        return true;\n                     }\n-                    return true;\n                 }\n-            }\n-            return false;\n-        };\n+                return false;\n+            };\n \n         if let ObligationCauseCode::ImplDerivedObligation(cause) = &*code {\n             try_borrowing(cause.derived.parent_trait_pred, &[])\n@@ -992,20 +1000,22 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 return false;\n             }\n \n-            let Some(mut suggested_ty) = trait_pred.self_ty().no_bound_vars() else {\n-                return false;\n-            };\n+            // Skipping binder here, remapping below\n+            let mut suggested_ty = trait_pred.self_ty().skip_binder();\n \n             for refs_remaining in 0..refs_number {\n                 let ty::Ref(_, inner_ty, _) = suggested_ty.kind() else {\n                     break;\n                 };\n                 suggested_ty = *inner_ty;\n \n+                // Remapping bound vars here\n+                let trait_pred_and_suggested_ty =\n+                    trait_pred.map_bound(|trait_pred| (trait_pred, suggested_ty));\n+\n                 let new_obligation = self.mk_trait_obligation_with_new_self_ty(\n                     obligation.param_env,\n-                    trait_pred,\n-                    suggested_ty,\n+                    trait_pred_and_suggested_ty,\n                 );\n \n                 if self.predicate_may_hold(&new_obligation) {\n@@ -1125,26 +1135,21 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 return;\n             }\n \n+            // Skipping binder here, remapping below\n             if let ty::Ref(region, t_type, mutability) = *trait_pred.skip_binder().self_ty().kind()\n             {\n-                if region.is_late_bound() || t_type.has_escaping_bound_vars() {\n-                    // Avoid debug assertion in `mk_obligation_for_def_id`.\n-                    //\n-                    // If the self type has escaping bound vars then it's not\n-                    // going to be the type of an expression, so the suggestion\n-                    // probably won't apply anyway.\n-                    return;\n-                }\n-\n                 let suggested_ty = match mutability {\n                     hir::Mutability::Mut => self.tcx.mk_imm_ref(region, t_type),\n                     hir::Mutability::Not => self.tcx.mk_mut_ref(region, t_type),\n                 };\n \n+                // Remapping bound vars here\n+                let trait_pred_and_suggested_ty =\n+                    trait_pred.map_bound(|trait_pred| (trait_pred, suggested_ty));\n+\n                 let new_obligation = self.mk_trait_obligation_with_new_self_ty(\n                     obligation.param_env,\n-                    trait_pred,\n-                    suggested_ty,\n+                    trait_pred_and_suggested_ty,\n                 );\n                 let suggested_ty_would_satisfy_obligation = self\n                     .evaluate_obligation_no_overflow(&new_obligation)\n@@ -1195,7 +1200,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             // Only suggest this if the expression behind the semicolon implements the predicate\n             && let Some(typeck_results) = self.in_progress_typeck_results\n             && let Some(ty) = typeck_results.borrow().expr_ty_opt(expr)\n-            && self.predicate_may_hold(&self.mk_trait_obligation_with_new_self_ty(obligation.param_env, trait_pred, ty))\n+            && self.predicate_may_hold(&self.mk_trait_obligation_with_new_self_ty(\n+                obligation.param_env, trait_pred.map_bound(|trait_pred| (trait_pred, ty))\n+            ))\n         {\n             err.span_label(\n                 expr.span,\n@@ -2727,8 +2734,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 );\n                 let try_obligation = self.mk_trait_obligation_with_new_self_ty(\n                     obligation.param_env,\n-                    trait_pred,\n-                    normalized_ty.ty().unwrap(),\n+                    trait_pred.map_bound(|trait_pred| (trait_pred, normalized_ty.ty().unwrap())),\n                 );\n                 debug!(\"suggest_await_before_try: try_trait_obligation {:?}\", try_obligation);\n                 if self.predicate_may_hold(&try_obligation)"}, {"sha": "68303b842088ecadca31671af29cf1e884c719e6", "filename": "src/test/ui/binop/issue-77910-1.stderr", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a2c2720e09202e1f988ff568efa4dcac8a71a504/src%2Ftest%2Fui%2Fbinop%2Fissue-77910-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a2c2720e09202e1f988ff568efa4dcac8a71a504/src%2Ftest%2Fui%2Fbinop%2Fissue-77910-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fissue-77910-1.stderr?ref=a2c2720e09202e1f988ff568efa4dcac8a71a504", "patch": "@@ -12,20 +12,14 @@ LL |     assert_eq!(foo, y);\n error[E0277]: `for<'r> fn(&'r i32) -> &'r i32 {foo}` doesn't implement `Debug`\n   --> $DIR/issue-77910-1.rs:8:5\n    |\n+LL | fn foo(s: &i32) -> &i32 {\n+   |    --- consider calling this function\n+...\n LL |     assert_eq!(foo, y);\n    |     ^^^^^^^^^^^^^^^^^^ `for<'r> fn(&'r i32) -> &'r i32 {foo}` cannot be formatted using `{:?}` because it doesn't implement `Debug`\n    |\n    = help: the trait `Debug` is not implemented for `for<'r> fn(&'r i32) -> &'r i32 {foo}`\n-   = help: the following other types implement trait `Debug`:\n-             extern \"C\" fn() -> Ret\n-             extern \"C\" fn(A) -> Ret\n-             extern \"C\" fn(A, ...) -> Ret\n-             extern \"C\" fn(A, B) -> Ret\n-             extern \"C\" fn(A, B, ...) -> Ret\n-             extern \"C\" fn(A, B, C) -> Ret\n-             extern \"C\" fn(A, B, C, ...) -> Ret\n-             extern \"C\" fn(A, B, C, D) -> Ret\n-           and 68 others\n+   = help: use parentheses to call the function: `foo(s)`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 2 previous errors"}, {"sha": "ba6af8f15fa89658915f1ddad572cbfd4c52fe3f", "filename": "src/test/ui/suggestions/imm-ref-trait-object-literal-bound-regions.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2c2720e09202e1f988ff568efa4dcac8a71a504/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object-literal-bound-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a2c2720e09202e1f988ff568efa4dcac8a71a504/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object-literal-bound-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object-literal-bound-regions.stderr?ref=a2c2720e09202e1f988ff568efa4dcac8a71a504", "patch": "@@ -5,6 +5,7 @@ LL |     foo::<S>(s);\n    |     ^^^^^^^^ the trait `for<'b> Trait` is not implemented for `&'b S`\n    |\n    = help: the trait `Trait` is implemented for `&'a mut S`\n+   = note: `for<'b> Trait` is implemented for `&'b mut S`, but not for `&'b S`\n note: required by a bound in `foo`\n   --> $DIR/imm-ref-trait-object-literal-bound-regions.rs:11:20\n    |"}]}