{"sha": "3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhMjE5MGE5Y2Q0ZTM4YTk1NDNmZjY5N2RkNTFjYThiNmI2OGY1MGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-25T01:04:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-25T01:04:12Z"}, "message": "Auto merge of #53438 - matthewjasper:permissive-match-access, r=pnkfelix\n\n[NLL] Be more permissive when checking access due to Match\n\nPartially addresses #53114. notably, we should now have parity with AST borrowck. Matching on uninitialized values is still forbidden.\n\n* ~~Give fake borrows for match their own `BorrowKind`~~\n* ~~Allow borrows with this kind to happen on values that are already mutably borrowed.~~\n* ~~Track borrows with this type even behind shared reference dereferences and consider all accesses to be deep when checking for conflicts with this borrow type. See [src/test/ui/issues/issue-27282-mutate-before-diverging-arm-3.rs](https://github.com/rust-lang/rust/commit/cb5c989598178af505fb215dd97afca8cc2b659f#diff-a2126cd3263a1f5342e2ecd5e699fbc6) for an example soundness issue this fixes (a case of #27282 that wasn't handled correctly).~~\n* Create a new `BorrowKind`: `Shallow` (name can be bike-shed)\n* `Shallow` borrows differ from shared borrows in that\n  * When we check for access we treat them as a `Shallow(Some(_))` read\n  * When we check for conflicts with them, if the borrow place is a strict prefix of the access place then we don't consider that a conflict.\n    * For example, a `Shallow` borrow of `x` does not conflict with any access or borrow of `x.0` or `*x`\n* Remove the current fake borrow in matches.\n* When building matches, we take a `Shallow` borrow of any `Place` that we switch on or bind in a match, and any prefix of those places. (There are some optimizations where we do fewer borrows, but this shouldn't change semantics)\n  * `match x { &Some(1) => (),  _ => (), }` would `Shallow` borrow `x`, `*x` and `(*x as Some).0` (the `*x` borrow is unnecessary, but I'm not sure how easy it would be to remove.)\n* Replace the fake discriminant read with a `ReadForMatch`.\n* Change ReadForMatch to only check for initializedness (to prevent `let x: !; match x {}`), but not conflicting borrows. It is still considered a use for liveness and `unsafe` checking.\n* Give special cased error messages for this kind of borrow.\n\nTable from the above issue after this PR\n\n| Thing | AST | MIR | Want | Example |\n| --- | --- | --- | --- |---|\n| `let _ = <unsafe-field>` | \ud83d\udc9a  | \ud83d\udc9a  | \u274c |  [playground](https://play.rust-lang.org/?gist=bb7843e42fa5318c1043d04bd72abfe4&version=nightly&mode=debug&edition=2015) |\n| `match <unsafe_field> { _ => () }` | \u274c  | \u274c | \u274c | [playground](https://play.rust-lang.org/?gist=3e3af05fbf1fae28fab2aaf9412fb2ea&version=nightly&mode=debug&edition=2015) |\n| `let _ = <moved>` | \ud83d\udc9a  | \ud83d\udc9a | \ud83d\udc9a | [playground](https://play.rust-lang.org/?gist=91a6efde8288558e584aaeee0a50558b&version=nightly&mode=debug&edition=2015) |\n| `match <moved> { _ => () }` | \u274c | \u274c  | \ud83d\udc9a | [playground](https://play.rust-lang.org/?gist=804f8185040b2fe131f2c4a64b3048ca&version=nightly&mode=debug&edition=2015) |\n| `let _ = <borrowed>` | \ud83d\udc9a  | \ud83d\udc9a | \ud83d\udc9a | [playground](https://play.rust-lang.org/?gist=0e487c2893b89cb772ec2f2b7c5da876&version=nightly&mode=debug&edition=2015) |\n| `match <borrowed> { _ => () }` | \ud83d\udc9a  | \ud83d\udc9a | \ud83d\udc9a | [playground](https://play.rust-lang.org/?gist=0e487c2893b89cb772ec2f2b7c5da876&version=nightly&mode=debug&edition=2015) |\n\nr? @nikomatsakis", "tree": {"sha": "fdf86e21d868b4f8851f7aee915cf383d33cc240", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fdf86e21d868b4f8851f7aee915cf383d33cc240"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "html_url": "https://github.com/rust-lang/rust/commit/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c875d93855c6d577962b0f74f17374f37b219c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c875d93855c6d577962b0f74f17374f37b219c9", "html_url": "https://github.com/rust-lang/rust/commit/5c875d93855c6d577962b0f74f17374f37b219c9"}, {"sha": "a830732090d49c799b3e97e70c1c4e5c011a784c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a830732090d49c799b3e97e70c1c4e5c011a784c", "html_url": "https://github.com/rust-lang/rust/commit/a830732090d49c799b3e97e70c1c4e5c011a784c"}], "stats": {"total": 2103, "additions": 1197, "deletions": 906}, "files": [{"sha": "ec54613d1dbacfd41871ab4a6166e298549e561f", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -46,6 +46,7 @@ for mir::BorrowKind {\n \n         match *self {\n             mir::BorrowKind::Shared |\n+            mir::BorrowKind::Shallow |\n             mir::BorrowKind::Unique => {}\n             mir::BorrowKind::Mut { allow_two_phase_borrow } => {\n                 allow_two_phase_borrow.hash_stable(hcx, hasher);\n@@ -272,7 +273,7 @@ for mir::StatementKind<'gcx> {\n     }\n }\n \n-impl_stable_hash_for!(enum mir::FakeReadCause { ForMatch, ForLet });\n+impl_stable_hash_for!(enum mir::FakeReadCause { ForMatchGuard, ForMatchedPlace, ForLet });\n \n impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>>\n     for mir::ValidationOperand<'gcx, T>"}, {"sha": "f856475c3376ddbc9bdecee7c311e24c8dc78f45", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 33, "deletions": 7, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -451,11 +451,32 @@ impl From<Mutability> for hir::Mutability {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable)]\n pub enum BorrowKind {\n     /// Data must be immutable and is aliasable.\n     Shared,\n \n+    /// The immediately borrowed place must be immutable, but projections from\n+    /// it don't need to be. For example, a shallow borrow of `a.b` doesn't\n+    /// conflict with a mutable borrow of `a.b.c`.\n+    ///\n+    /// This is used when lowering matches: when matching on a place we want to\n+    /// ensure that place have the same value from the start of the match until\n+    /// an arm is selected. This prevents this code from compiling:\n+    ///\n+    ///     let mut x = &Some(0);\n+    ///     match *x {\n+    ///         None => (),\n+    ///         Some(_) if { x = &None; false } => (),\n+    ///         Some(_) => (),\n+    ///     }\n+    ///\n+    /// This can't be a shared borrow because mutably borrowing (*x as Some).0\n+    /// should not prevent `if let None = x { ... }`, for example, becase the\n+    /// mutating `(*x as Some).0` can't affect the discriminant of `x`.\n+    /// We can also report errors with this kind of borrow differently.\n+    Shallow,\n+\n     /// Data must be immutable but not aliasable.  This kind of borrow\n     /// cannot currently be expressed by the user and is used only in\n     /// implicit closure bindings. It is needed when the closure is\n@@ -504,7 +525,7 @@ pub enum BorrowKind {\n impl BorrowKind {\n     pub fn allows_two_phase_borrow(&self) -> bool {\n         match *self {\n-            BorrowKind::Shared | BorrowKind::Unique => false,\n+            BorrowKind::Shared | BorrowKind::Shallow | BorrowKind::Unique => false,\n             BorrowKind::Mut {\n                 allow_two_phase_borrow,\n             } => allow_two_phase_borrow,\n@@ -1672,7 +1693,11 @@ pub enum FakeReadCause {\n     ///\n     /// This should ensure that you cannot change the variant for an enum\n     /// while you are in the midst of matching on it.\n-    ForMatch,\n+    ForMatchGuard,\n+\n+    /// `let x: !; match x {}` doesn't generate any read of x so we need to\n+    /// generate a read of x to check that it is initialized and safe.\n+    ForMatchedPlace,\n \n     /// Officially, the semantics of\n     ///\n@@ -1773,7 +1798,7 @@ impl<'tcx> Debug for Statement<'tcx> {\n \n /// A path to a value; something that can be evaluated without\n /// changing or disturbing program state.\n-#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub enum Place<'tcx> {\n     /// local variable\n     Local(Local),\n@@ -1790,7 +1815,7 @@ pub enum Place<'tcx> {\n \n /// The def-id of a static, along with its normalized type (which is\n /// stored to avoid requiring normalization when reading MIR).\n-#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub struct Static<'tcx> {\n     pub def_id: DefId,\n     pub ty: Ty<'tcx>,\n@@ -1805,13 +1830,13 @@ impl_stable_hash_for!(struct Static<'tcx> {\n /// or `*B` or `B[index]`. Note that it is parameterized because it is\n /// shared between `Constant` and `Place`. See the aliases\n /// `PlaceProjection` etc below.\n-#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub struct Projection<'tcx, B, V, T> {\n     pub base: B,\n     pub elem: ProjectionElem<'tcx, V, T>,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub enum ProjectionElem<'tcx, V, T> {\n     Deref,\n     Field(Field, T),\n@@ -2198,6 +2223,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n             Ref(region, borrow_kind, ref place) => {\n                 let kind_str = match borrow_kind {\n                     BorrowKind::Shared => \"\",\n+                    BorrowKind::Shallow => \"shallow \",\n                     BorrowKind::Mut { .. } | BorrowKind::Unique => \"mut \",\n                 };\n "}, {"sha": "2a25e057a71493ef7bcb65298ba6393b4e72ee2b", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -287,6 +287,10 @@ impl BorrowKind {\n             // use `&mut`. It gives all the capabilities of an `&uniq`\n             // and hence is a safe \"over approximation\".\n             BorrowKind::Unique => hir::MutMutable,\n+\n+            // We have no type corresponding to a shallow borrow, so use\n+            // `&` as an approximation.\n+            BorrowKind::Shallow => hir::MutImmutable,\n         }\n     }\n }"}, {"sha": "6de7e2215bf41bb426530d7f522f81871ccba221", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -963,6 +963,7 @@ impl<'tcx> PlaceContext<'tcx> {\n \n             PlaceContext::Inspect |\n             PlaceContext::Borrow { kind: BorrowKind::Shared, .. } |\n+            PlaceContext::Borrow { kind: BorrowKind::Shallow, .. } |\n             PlaceContext::Borrow { kind: BorrowKind::Unique, .. } |\n             PlaceContext::Projection(Mutability::Not) |\n             PlaceContext::Copy | PlaceContext::Move |\n@@ -974,7 +975,9 @@ impl<'tcx> PlaceContext<'tcx> {\n     /// Returns true if this place context represents a use that does not change the value.\n     pub fn is_nonmutating_use(&self) -> bool {\n         match *self {\n-            PlaceContext::Inspect | PlaceContext::Borrow { kind: BorrowKind::Shared, .. } |\n+            PlaceContext::Inspect |\n+            PlaceContext::Borrow { kind: BorrowKind::Shared, .. } |\n+            PlaceContext::Borrow { kind: BorrowKind::Shallow, .. } |\n             PlaceContext::Borrow { kind: BorrowKind::Unique, .. } |\n             PlaceContext::Projection(Mutability::Not) |\n             PlaceContext::Copy | PlaceContext::Move => true,"}, {"sha": "bcf377221301498b5b98a3853350ea82e242ae1b", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -87,6 +87,7 @@ impl<'tcx> fmt::Display for BorrowData<'tcx> {\n     fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result {\n         let kind = match self.kind {\n             mir::BorrowKind::Shared => \"\",\n+            mir::BorrowKind::Shallow => \"shallow \",\n             mir::BorrowKind::Unique => \"uniq \",\n             mir::BorrowKind::Mut { .. } => \"mut \",\n         };\n@@ -287,7 +288,8 @@ impl<'a, 'gcx, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'gcx, 'tcx> {\n                     borrow_data.activation_location = match context {\n                         // The use of TMP in a shared borrow does not\n                         // count as an actual activation.\n-                        PlaceContext::Borrow { kind: mir::BorrowKind::Shared, .. } => {\n+                        PlaceContext::Borrow { kind: mir::BorrowKind::Shared, .. }\n+                        | PlaceContext::Borrow { kind: mir::BorrowKind::Shallow, .. } => {\n                             TwoPhaseActivation::NotActivated\n                         }\n                         _ => {"}, {"sha": "b775fc81d4f614a4177494100c98885bc1af208c", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 47, "deletions": 7, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -333,6 +333,27 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     Origin::Mir,\n                 ),\n \n+            (BorrowKind::Mut { .. }, _, _, BorrowKind::Shallow, _, _)\n+            | (BorrowKind::Unique, _, _, BorrowKind::Shallow, _, _) => {\n+                let mut err = tcx.cannot_mutate_in_match_guard(\n+                    span,\n+                    issued_span,\n+                    &desc_place,\n+                    \"mutably borrow\",\n+                    Origin::Mir,\n+                );\n+                borrow_spans.var_span_label(\n+                    &mut err,\n+                    format!(\n+                        \"borrow occurs due to use of `{}` in closure\",\n+                        desc_place\n+                    ),\n+                );\n+                err.buffer(&mut self.errors_buffer);\n+\n+                return;\n+            }\n+\n             (BorrowKind::Unique, _, _, _, _, _) => tcx.cannot_uniquely_borrow_by_one_closure(\n                 span,\n                 &desc_place,\n@@ -368,7 +389,16 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     Origin::Mir,\n                 ),\n \n-            (BorrowKind::Shared, _, _, BorrowKind::Shared, _, _) => unreachable!(),\n+            (BorrowKind::Shallow, _, _, BorrowKind::Unique, _, _)\n+            | (BorrowKind::Shallow, _, _, BorrowKind::Mut { .. }, _, _) => {\n+                // Shallow borrows are uses from the user's point of view.\n+                self.report_use_while_mutably_borrowed(context, (place, span), issued_borrow);\n+                return\n+            }\n+            (BorrowKind::Shared, _, _, BorrowKind::Shared, _, _)\n+            | (BorrowKind::Shared, _, _, BorrowKind::Shallow, _, _)\n+            | (BorrowKind::Shallow, _, _, BorrowKind::Shared, _, _)\n+            | (BorrowKind::Shallow, _, _, BorrowKind::Shallow, _, _) => unreachable!(),\n         };\n \n         if issued_spans == borrow_spans {\n@@ -780,12 +810,22 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let loan_span = loan_spans.args_or_use();\n \n         let tcx = self.infcx.tcx;\n-        let mut err = tcx.cannot_assign_to_borrowed(\n-            span,\n-            loan_span,\n-            &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n-            Origin::Mir,\n-        );\n+        let mut err = if loan.kind == BorrowKind::Shallow {\n+            tcx.cannot_mutate_in_match_guard(\n+                span,\n+                loan_span,\n+                &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n+                \"assign\",\n+                Origin::Mir,\n+            )\n+        } else {\n+            tcx.cannot_assign_to_borrowed(\n+                span,\n+                loan_span,\n+                &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n+                Origin::Mir,\n+            )\n+        };\n \n         loan_spans.var_span_label(&mut err, \"borrow occurs due to use in closure\");\n "}, {"sha": "06394ee44ccbecbecbc28e2be83aa4f1bb5c0be6", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 48, "deletions": 12, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -499,11 +499,20 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 );\n             }\n             StatementKind::FakeRead(_, ref place) => {\n-                self.access_place(\n+                // Read for match doesn't access any memory and is used to\n+                // assert that a place is safe and live. So we don't have to\n+                // do any checks here.\n+                //\n+                // FIXME: Remove check that the place is initialized. This is\n+                // needed for now because matches don't have never patterns yet.\n+                // So this is the only place we prevent\n+                //      let x: !;\n+                //      match x {};\n+                // from compiling.\n+                self.check_if_path_or_subpath_is_moved(\n                     ContextKind::FakeRead.new(location),\n+                    InitializationRequiringAction::Use,\n                     (place, span),\n-                    (Deep, Read(ReadKind::Borrow(BorrowKind::Shared))),\n-                    LocalMutationIsAllowed::No,\n                     flow_state,\n                 );\n             }\n@@ -755,6 +764,7 @@ use self::AccessDepth::{Deep, Shallow};\n enum ArtificialField {\n     Discriminant,\n     ArrayLength,\n+    ShallowBorrow,\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n@@ -835,6 +845,7 @@ enum LocalMutationIsAllowed {\n enum InitializationRequiringAction {\n     Update,\n     Borrow,\n+    MatchOn,\n     Use,\n     Assignment,\n }\n@@ -849,6 +860,7 @@ impl InitializationRequiringAction {\n         match self {\n             InitializationRequiringAction::Update => \"update\",\n             InitializationRequiringAction::Borrow => \"borrow\",\n+            InitializationRequiringAction::MatchOn => \"use\", // no good noun\n             InitializationRequiringAction::Use => \"use\",\n             InitializationRequiringAction::Assignment => \"assign\",\n         }\n@@ -858,6 +870,7 @@ impl InitializationRequiringAction {\n         match self {\n             InitializationRequiringAction::Update => \"updated\",\n             InitializationRequiringAction::Borrow => \"borrowed\",\n+            InitializationRequiringAction::MatchOn => \"matched on\",\n             InitializationRequiringAction::Use => \"used\",\n             InitializationRequiringAction::Assignment => \"assigned\",\n         }\n@@ -972,7 +985,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     Control::Continue\n                 }\n \n-                (Read(_), BorrowKind::Shared) | (Reservation(..), BorrowKind::Shared) => {\n+                (Read(_), BorrowKind::Shared) | (Reservation(..), BorrowKind::Shared)\n+                | (Read(_), BorrowKind::Shallow) | (Reservation(..), BorrowKind::Shallow) => {\n+                    Control::Continue\n+                }\n+\n+                (Write(WriteKind::Move), BorrowKind::Shallow) => {\n+                    // Handled by initialization checks.\n                     Control::Continue\n                 }\n \n@@ -984,7 +1003,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     }\n \n                     match kind {\n-                        ReadKind::Copy => {\n+                        ReadKind::Copy  => {\n                             error_reported = true;\n                             this.report_use_while_mutably_borrowed(context, place_span, borrow)\n                         }\n@@ -1108,6 +1127,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         match *rvalue {\n             Rvalue::Ref(_ /*rgn*/, bk, ref place) => {\n                 let access_kind = match bk {\n+                    BorrowKind::Shallow => {\n+                        (Shallow(Some(ArtificialField::ShallowBorrow)), Read(ReadKind::Borrow(bk)))\n+                    },\n                     BorrowKind::Shared => (Deep, Read(ReadKind::Borrow(bk))),\n                     BorrowKind::Unique | BorrowKind::Mut { .. } => {\n                         let wk = WriteKind::MutableBorrow(bk);\n@@ -1127,9 +1149,15 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     flow_state,\n                 );\n \n+                let action = if bk == BorrowKind::Shallow {\n+                    InitializationRequiringAction::MatchOn\n+                } else {\n+                    InitializationRequiringAction::Borrow\n+                };\n+\n                 self.check_if_path_or_subpath_is_moved(\n                     context,\n-                    InitializationRequiringAction::Borrow,\n+                    action,\n                     (place, span),\n                     flow_state,\n                 );\n@@ -1315,11 +1343,16 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             return;\n         }\n \n-        // FIXME: replace this with a proper borrow_conflicts_with_place when\n-        // that is merged.\n         let sd = if might_be_alive { Deep } else { Shallow(None) };\n \n-        if places_conflict::places_conflict(self.infcx.tcx, self.mir, place, root_place, sd) {\n+        if places_conflict::borrow_conflicts_with_place(\n+            self.infcx.tcx,\n+            self.mir,\n+            place,\n+            borrow.kind,\n+            root_place,\n+            sd\n+        ) {\n             debug!(\"check_for_invalidation_at_exit({:?}): INVALID\", place);\n             // FIXME: should be talking about the region lifetime instead\n             // of just a span here.\n@@ -1369,7 +1402,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n             // only mutable borrows should be 2-phase\n             assert!(match borrow.kind {\n-                BorrowKind::Shared => false,\n+                BorrowKind::Shared | BorrowKind::Shallow => false,\n                 BorrowKind::Unique | BorrowKind::Mut { .. } => true,\n             });\n \n@@ -1669,7 +1702,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 let is_local_mutation_allowed = match borrow_kind {\n                     BorrowKind::Unique => LocalMutationIsAllowed::Yes,\n                     BorrowKind::Mut { .. } => is_local_mutation_allowed,\n-                    BorrowKind::Shared => unreachable!(),\n+                    BorrowKind::Shared | BorrowKind::Shallow => unreachable!(),\n                 };\n                 match self.is_mutable(place, is_local_mutation_allowed) {\n                     Ok(root_place) => {\n@@ -1699,8 +1732,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             | Write(wk @ WriteKind::Move)\n             | Reservation(wk @ WriteKind::StorageDeadOrDrop)\n             | Reservation(wk @ WriteKind::MutableBorrow(BorrowKind::Shared))\n+            | Reservation(wk @ WriteKind::MutableBorrow(BorrowKind::Shallow))\n             | Write(wk @ WriteKind::StorageDeadOrDrop)\n-            | Write(wk @ WriteKind::MutableBorrow(BorrowKind::Shared)) => {\n+            | Write(wk @ WriteKind::MutableBorrow(BorrowKind::Shared))\n+            | Write(wk @ WriteKind::MutableBorrow(BorrowKind::Shallow)) => {\n                 if let Err(_place_err) = self.is_mutable(place, is_local_mutation_allowed) {\n                     if self.infcx.tcx.migrate_borrowck() {\n                         // rust-lang/rust#46908: In pure NLL mode this\n@@ -1743,6 +1778,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Read(ReadKind::Borrow(BorrowKind::Unique))\n             | Read(ReadKind::Borrow(BorrowKind::Mut { .. }))\n             | Read(ReadKind::Borrow(BorrowKind::Shared))\n+            | Read(ReadKind::Borrow(BorrowKind::Shallow))\n             | Read(ReadKind::Copy) => {\n                 // Access authorized\n                 return false;"}, {"sha": "1246f7120c4fb58313ab673d8304bca9f9f89e03", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -329,6 +329,9 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cx, 'tcx, 'gcx> {\n         match *rvalue {\n             Rvalue::Ref(_ /*rgn*/, bk, ref place) => {\n                 let access_kind = match bk {\n+                    BorrowKind::Shallow => {\n+                        (Shallow(Some(ArtificialField::ShallowBorrow)), Read(ReadKind::Borrow(bk)))\n+                    },\n                     BorrowKind::Shared => (Deep, Read(ReadKind::Borrow(bk))),\n                     BorrowKind::Unique | BorrowKind::Mut { .. } => {\n                         let wk = WriteKind::MutableBorrow(bk);\n@@ -439,8 +442,9 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cx, 'tcx, 'gcx> {\n                         // have already taken the reservation\n                     }\n \n-                    (Read(_), BorrowKind::Shared) | (Reservation(..), BorrowKind::Shared) => {\n-                        // Reads/reservations don't invalidate shared borrows\n+                    (Read(_), BorrowKind::Shallow) | (Reservation(..), BorrowKind::Shallow)\n+                    | (Read(_), BorrowKind::Shared) | (Reservation(..), BorrowKind::Shared) => {\n+                        // Reads/reservations don't invalidate shared or shallow borrows\n                     }\n \n                     (Read(_), BorrowKind::Unique) | (Read(_), BorrowKind::Mut { .. }) => {"}, {"sha": "9250c04969f989eeb94b76883cdc0762ef70b130", "filename": "src/librustc_mir/borrow_check/path_utils.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -61,7 +61,14 @@ pub(super) fn each_borrow_involving_path<'a, 'tcx, 'gcx: 'tcx, F, I, S> (\n     for i in candidates {\n         let borrowed = &borrow_set[i];\n \n-        if places_conflict::places_conflict(tcx, mir, &borrowed.borrowed_place, place, access) {\n+        if places_conflict::borrow_conflicts_with_place(\n+            tcx,\n+            mir,\n+            &borrowed.borrowed_place,\n+            borrowed.kind,\n+            place,\n+            access,\n+        ) {\n             debug!(\n                 \"each_borrow_involving_path: {:?} @ {:?} vs. {:?}/{:?}\",\n                 i, borrowed, place, access"}, {"sha": "c0f059619a4974b59e5264c1e8f7a4ee4c980a3f", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 30, "deletions": 18, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -12,20 +12,21 @@ use borrow_check::ArtificialField;\n use borrow_check::Overlap;\n use borrow_check::{Deep, Shallow, AccessDepth};\n use rustc::hir;\n-use rustc::mir::{Mir, Place};\n+use rustc::mir::{BorrowKind, Mir, Place};\n use rustc::mir::{Projection, ProjectionElem};\n use rustc::ty::{self, TyCtxt};\n use std::cmp::max;\n \n-pub(super) fn places_conflict<'gcx, 'tcx>(\n+pub(super) fn borrow_conflicts_with_place<'gcx, 'tcx>(\n     tcx: TyCtxt<'_, 'gcx, 'tcx>,\n     mir: &Mir<'tcx>,\n     borrow_place: &Place<'tcx>,\n+    borrow_kind: BorrowKind,\n     access_place: &Place<'tcx>,\n     access: AccessDepth,\n ) -> bool {\n     debug!(\n-        \"places_conflict({:?},{:?},{:?})\",\n+        \"borrow_conflicts_with_place({:?},{:?},{:?})\",\n         borrow_place, access_place, access\n     );\n \n@@ -39,7 +40,14 @@ pub(super) fn places_conflict<'gcx, 'tcx>(\n \n     unroll_place(borrow_place, None, |borrow_components| {\n         unroll_place(access_place, None, |access_components| {\n-            place_components_conflict(tcx, mir, borrow_components, access_components, access)\n+            place_components_conflict(\n+                tcx,\n+                mir,\n+                borrow_components,\n+                borrow_kind,\n+                access_components,\n+                access\n+            )\n         })\n     })\n }\n@@ -48,6 +56,7 @@ fn place_components_conflict<'gcx, 'tcx>(\n     tcx: TyCtxt<'_, 'gcx, 'tcx>,\n     mir: &Mir<'tcx>,\n     mut borrow_components: PlaceComponentsIter<'_, 'tcx>,\n+    borrow_kind: BorrowKind,\n     mut access_components: PlaceComponentsIter<'_, 'tcx>,\n     access: AccessDepth,\n ) -> bool {\n@@ -95,10 +104,10 @@ fn place_components_conflict<'gcx, 'tcx>(\n     loop {\n         // loop invariant: borrow_c is always either equal to access_c or disjoint from it.\n         if let Some(borrow_c) = borrow_components.next() {\n-            debug!(\"places_conflict: borrow_c = {:?}\", borrow_c);\n+            debug!(\"borrow_conflicts_with_place: borrow_c = {:?}\", borrow_c);\n \n             if let Some(access_c) = access_components.next() {\n-                debug!(\"places_conflict: access_c = {:?}\", access_c);\n+                debug!(\"borrow_conflicts_with_place: access_c = {:?}\", access_c);\n \n                 // Borrow and access path both have more components.\n                 //\n@@ -127,7 +136,7 @@ fn place_components_conflict<'gcx, 'tcx>(\n                         // idea, at least for now, so just give up and\n                         // report a conflict. This is unsafe code anyway so\n                         // the user could always use raw pointers.\n-                        debug!(\"places_conflict: arbitrary -> conflict\");\n+                        debug!(\"borrow_conflicts_with_place: arbitrary -> conflict\");\n                         return true;\n                     }\n                     Overlap::EqualOrDisjoint => {\n@@ -136,7 +145,7 @@ fn place_components_conflict<'gcx, 'tcx>(\n                     Overlap::Disjoint => {\n                         // We have proven the borrow disjoint - further\n                         // projections will remain disjoint.\n-                        debug!(\"places_conflict: disjoint\");\n+                        debug!(\"borrow_conflicts_with_place: disjoint\");\n                         return false;\n                     }\n                 }\n@@ -157,7 +166,8 @@ fn place_components_conflict<'gcx, 'tcx>(\n \n                 match (elem, &base_ty.sty, access) {\n                     (_, _, Shallow(Some(ArtificialField::Discriminant)))\n-                    | (_, _, Shallow(Some(ArtificialField::ArrayLength))) => {\n+                    | (_, _, Shallow(Some(ArtificialField::ArrayLength)))\n+                    | (_, _, Shallow(Some(ArtificialField::ShallowBorrow))) => {\n                         // The discriminant and array length are like\n                         // additional fields on the type; they do not\n                         // overlap any existing data there. Furthermore,\n@@ -167,15 +177,15 @@ fn place_components_conflict<'gcx, 'tcx>(\n                         //\n                         // e.g. a (mutable) borrow of `a[5]` while we read the\n                         // array length of `a`.\n-                        debug!(\"places_conflict: implicit field\");\n+                        debug!(\"borrow_conflicts_with_place: implicit field\");\n                         return false;\n                     }\n \n                     (ProjectionElem::Deref, _, Shallow(None)) => {\n                         // e.g. a borrow of `*x.y` while we shallowly access `x.y` or some\n                         // prefix thereof - the shallow access can't touch anything behind\n                         // the pointer.\n-                        debug!(\"places_conflict: shallow access behind ptr\");\n+                        debug!(\"borrow_conflicts_with_place: shallow access behind ptr\");\n                         return false;\n                     }\n                     (ProjectionElem::Deref, ty::Ref(_, _, hir::MutImmutable), _) => {\n@@ -185,7 +195,7 @@ fn place_components_conflict<'gcx, 'tcx>(\n                     (ProjectionElem::Deref, ty::Ref(_, _, hir::MutMutable), AccessDepth::Drop) => {\n                         // Values behind a mutatble reference are not access either by Dropping a\n                         // value, or by StorageDead\n-                        debug!(\"places_conflict: drop access behind ptr\");\n+                        debug!(\"borrow_conflicts_with_place: drop access behind ptr\");\n                         return false;\n                     }\n \n@@ -225,11 +235,13 @@ fn place_components_conflict<'gcx, 'tcx>(\n             // If the second example, where we did, then we still know\n             // that the borrow can access a *part* of our place that\n             // our access cares about, so we still have a conflict.\n-            //\n-            // FIXME: Differs from AST-borrowck; includes drive-by fix\n-            // to #38899. Will probably need back-compat mode flag.\n-            debug!(\"places_conflict: full borrow, CONFLICT\");\n-            return true;\n+            if borrow_kind == BorrowKind::Shallow && access_components.next().is_some() {\n+                debug!(\"borrow_conflicts_with_place: shallow borrow\");\n+                return false;\n+            } else {\n+                debug!(\"borrow_conflicts_with_place: full borrow, CONFLICT\");\n+                return true;\n+            }\n         }\n     }\n }\n@@ -241,7 +253,7 @@ fn place_components_conflict<'gcx, 'tcx>(\n ///\n /// NB: This particular impl strategy is not the most obvious.  It was\n /// chosen because it makes a measurable difference to NLL\n-/// performance, as this code (`places_conflict`) is somewhat hot.\n+/// performance, as this code (`borrow_conflicts_with_place`) is somewhat hot.\n struct PlaceComponents<'p, 'tcx: 'p> {\n     component: &'p Place<'tcx>,\n     next: Option<&'p PlaceComponents<'p, 'tcx>>,"}, {"sha": "e40ed51f7d3544677832cf48b6fd564b6b90b4ec", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 163, "deletions": 52, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -57,39 +57,22 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // See issue #47412 for this hole being discovered in the wild.\n         //\n         // HACK(eddyb) Work around the above issue by adding a dummy inspection\n-        // of `discriminant_place`, specifically by applying `Rvalue::Discriminant`\n-        // (which will work regardless of type) and storing the result in a temp.\n+        // of `discriminant_place`, specifically by applying `ReadForMatch`.\n         //\n-        // NOTE: Under NLL, the above issue should no longer occur because it\n-        // injects a borrow of the matched input, which should have the same effect\n-        // as eddyb's hack. Once NLL is the default, we can remove the hack.\n-\n-        let dummy_source_info = self.source_info(discriminant_span);\n-        let dummy_access = Rvalue::Discriminant(discriminant_place.clone());\n-        let dummy_ty = dummy_access.ty(&self.local_decls, tcx);\n-        let dummy_temp = self.temp(dummy_ty, dummy_source_info.span);\n-        self.cfg\n-            .push_assign(block, dummy_source_info, &dummy_temp, dummy_access);\n+        // NOTE: ReadForMatch also checks that the discriminant is initialized.\n+        // This is currently needed to not allow matching on an uninitialized,\n+        // uninhabited value. If we get never patterns, those will check that\n+        // the place is initialized, and so this read would only be used to\n+        // check safety.\n \n         let source_info = self.source_info(discriminant_span);\n-        let borrowed_input_temp = if tcx.generate_borrow_of_any_match_input() {\n-            // The region is unknown at this point; we rely on NLL\n-            // inference to find an appropriate one. Therefore you can\n-            // only use this when NLL is turned on.\n-            assert!(tcx.use_mir_borrowck());\n-            let borrowed_input = Rvalue::Ref(\n-                tcx.types.re_empty,\n-                BorrowKind::Shared,\n+        self.cfg.push(block, Statement {\n+            source_info,\n+            kind: StatementKind::FakeRead(\n+                FakeReadCause::ForMatchedPlace,\n                 discriminant_place.clone(),\n-            );\n-            let borrowed_input_ty = borrowed_input.ty(&self.local_decls, tcx);\n-            let borrowed_input_temp = self.temp(borrowed_input_ty, span);\n-            self.cfg\n-                .push_assign(block, source_info, &borrowed_input_temp, borrowed_input);\n-            Some(borrowed_input_temp)\n-        } else {\n-            None\n-        };\n+            ),\n+        });\n \n         let mut arm_blocks = ArmBlocks {\n             blocks: arms.iter().map(|_| self.cfg.start_new_block()).collect(),\n@@ -118,6 +101,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             .map(|_| self.cfg.start_new_block())\n             .collect();\n \n+        let mut has_guard = false;\n+\n         // assemble a list of candidates: there is one candidate per\n         // pattern, which means there may be more than one candidate\n         // *per arm*. These candidates are kept sorted such that the\n@@ -140,24 +125,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             .map(\n                 |(\n                     (arm_index, pat_index, pattern, guard),\n-                    (pre_binding_block, next_candidate_pre_binding_block),\n+                    (pre_binding_block, next_candidate_pre_binding_block)\n                 )| {\n-                    if let (true, Some(borrow_temp)) =\n-                        (tcx.emit_read_for_match(), borrowed_input_temp.clone())\n-                    {\n-                        // Inject a fake read, see comments on `FakeReadCause::ForMatch`.\n-                        let pattern_source_info = self.source_info(pattern.span);\n-                        self.cfg.push(\n-                            *pre_binding_block,\n-                            Statement {\n-                                source_info: pattern_source_info,\n-                                kind: StatementKind::FakeRead(\n-                                    FakeReadCause::ForMatch,\n-                                    borrow_temp.clone(),\n-                                ),\n-                            },\n-                        );\n-                    }\n+                    has_guard |= guard.is_some();\n \n                     // One might ask: why not build up the match pair such that it\n                     // matches via `borrowed_input_temp.deref()` instead of\n@@ -202,9 +172,31 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             TerminatorKind::Unreachable,\n         );\n \n+        // Maps a place to the kind of Fake borrow that we want to perform on\n+        // it: either Shallow or Shared, depending on whether the place is\n+        // bound in the match, or just switched on.\n+        // If there are no match guards then we don't need any fake borrows,\n+        // so don't track them.\n+        let mut fake_borrows = if has_guard && tcx.generate_borrow_of_any_match_input() {\n+            Some(FxHashMap())\n+        } else {\n+            None\n+        };\n+\n+        let pre_binding_blocks: Vec<_> = candidates\n+            .iter()\n+            .map(|cand| (cand.pre_binding_block, cand.span))\n+            .collect();\n+\n         // this will generate code to test discriminant_place and\n         // branch to the appropriate arm block\n-        let otherwise = self.match_candidates(span, &mut arm_blocks, candidates, block);\n+        let otherwise = self.match_candidates(\n+            discriminant_span,\n+            &mut arm_blocks,\n+            candidates,\n+            block,\n+            &mut fake_borrows,\n+        );\n \n         if !otherwise.is_empty() {\n             // All matches are exhaustive. However, because some matches\n@@ -224,6 +216,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n         }\n \n+        if let Some(fake_borrows) = fake_borrows {\n+            self.add_fake_borrows(&pre_binding_blocks, fake_borrows, source_info, block);\n+        }\n+\n         // all the arm blocks will rejoin here\n         let end_block = self.cfg.start_new_block();\n \n@@ -714,12 +710,16 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// up the list of candidates and recurse with a non-exhaustive\n     /// list. This is important to keep the size of the generated code\n     /// under control. See `test_candidates` for more details.\n+    ///\n+    /// If `add_fake_borrows` is true, then places which need fake borrows\n+    /// will be added to it.\n     fn match_candidates<'pat>(\n         &mut self,\n         span: Span,\n         arm_blocks: &mut ArmBlocks,\n         mut candidates: Vec<Candidate<'pat, 'tcx>>,\n         mut block: BasicBlock,\n+        fake_borrows: &mut Option<FxHashMap<Place<'tcx>, BorrowKind>>,\n     ) -> Vec<BasicBlock> {\n         debug!(\n             \"matched_candidate(span={:?}, block={:?}, candidates={:?})\",\n@@ -747,6 +747,15 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         );\n         let mut unmatched_candidates = candidates.split_off(fully_matched);\n \n+        // Insert a *Shared* borrow of any places that are bound.\n+        if let Some(fake_borrows) = fake_borrows {\n+            for Binding { source, .. }\n+                in candidates.iter().flat_map(|candidate| &candidate.bindings)\n+            {\n+                fake_borrows.insert(source.clone(), BorrowKind::Shared);\n+            }\n+        }\n+\n         let fully_matched_with_guard = candidates.iter().take_while(|c| c.guard.is_some()).count();\n \n         let unreachable_candidates = if fully_matched_with_guard + 1 < candidates.len() {\n@@ -783,7 +792,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     return vec![];\n                 } else {\n                     let target = self.cfg.start_new_block();\n-                    return self.match_candidates(span, arm_blocks, unmatched_candidates, target);\n+                    return self.match_candidates(\n+                        span,\n+                        arm_blocks,\n+                        unmatched_candidates,\n+                        target,\n+                        &mut None,\n+                    );\n                 }\n             }\n         }\n@@ -796,7 +811,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         // Test candidates where possible.\n         let (otherwise, tested_candidates) =\n-            self.test_candidates(span, arm_blocks, &unmatched_candidates, block);\n+            self.test_candidates(span, arm_blocks, &unmatched_candidates, block, fake_borrows);\n \n         // If the target candidates were exhaustive, then we are done.\n         // But for borrowck continue build decision tree.\n@@ -810,7 +825,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         // Otherwise, let's process those remaining candidates.\n         let join_block = self.join_otherwise_blocks(span, otherwise);\n-        self.match_candidates(span, arm_blocks, untested_candidates, join_block)\n+        self.match_candidates(span, arm_blocks, untested_candidates, join_block, &mut None)\n     }\n \n     fn join_otherwise_blocks(&mut self, span: Span, mut otherwise: Vec<BasicBlock>) -> BasicBlock {\n@@ -950,6 +965,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         arm_blocks: &mut ArmBlocks,\n         candidates: &[Candidate<'pat, 'tcx>],\n         block: BasicBlock,\n+        fake_borrows: &mut Option<FxHashMap<Place<'tcx>, BorrowKind>>,\n     ) -> (Vec<BasicBlock>, usize) {\n         // extract the match-pair from the highest priority candidate\n         let match_pair = &candidates.first().unwrap().match_pairs[0];\n@@ -990,6 +1006,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             _ => {}\n         }\n \n+        // Insert a Shallow borrow of any places that is switched on.\n+        fake_borrows.as_mut().map(|fb| {\n+            fb.entry(match_pair.place.clone()).or_insert(BorrowKind::Shallow)\n+        });\n+\n         // perform the test, branching to one of N blocks. For each of\n         // those N possible outcomes, create a (initially empty)\n         // vector of candidates. Those are the candidates that still\n@@ -1026,7 +1047,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             .into_iter()\n             .zip(target_candidates)\n             .flat_map(|(target_block, target_candidates)| {\n-                self.match_candidates(span, arm_blocks, target_candidates, target_block)\n+                self.match_candidates(\n+                    span,\n+                    arm_blocks,\n+                    target_candidates,\n+                    target_block,\n+                    fake_borrows,\n+                )\n             })\n             .collect();\n \n@@ -1363,7 +1390,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     // borrow of the whole match input. See additional\n                     // discussion on rust-lang/rust#49870.\n                     let borrow_kind = match borrow_kind {\n-                        BorrowKind::Shared | BorrowKind::Unique => borrow_kind,\n+                        BorrowKind::Shared\n+                        | BorrowKind::Shallow\n+                        | BorrowKind::Unique => borrow_kind,\n                         BorrowKind::Mut { .. } => BorrowKind::Mut {\n                             allow_two_phase_borrow: true,\n                         },\n@@ -1502,4 +1531,86 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         debug!(\"declare_binding: vars={:?}\", locals);\n         self.var_indices.insert(var_id, locals);\n     }\n+\n+    // Determine the fake borrows that are needed to ensure that the place\n+    // will evaluate to the same thing until an arm has been chosen.\n+    fn add_fake_borrows<'pat>(\n+        &mut self,\n+        pre_binding_blocks: &[(BasicBlock, Span)],\n+        fake_borrows: FxHashMap<Place<'tcx>, BorrowKind>,\n+        source_info: SourceInfo,\n+        start_block: BasicBlock,\n+    ) {\n+        let tcx = self.hir.tcx();\n+\n+        debug!(\"add_fake_borrows pre_binding_blocks = {:?}, fake_borrows = {:?}\",\n+               pre_binding_blocks, fake_borrows);\n+\n+        let mut all_fake_borrows = Vec::with_capacity(fake_borrows.len());\n+\n+        // Insert a Shallow borrow of the prefixes of any fake borrows.\n+        for (place, borrow_kind) in fake_borrows\n+        {\n+            {\n+                let mut prefix_cursor = &place;\n+                while let Place::Projection(box Projection { base, elem }) = prefix_cursor {\n+                    if let ProjectionElem::Deref = elem {\n+                        // Insert a shallow borrow after a deref. For other\n+                        // projections the borrow of prefix_cursor will\n+                        // conflict with any mutation of base.\n+                        all_fake_borrows.push((base.clone(), BorrowKind::Shallow));\n+                    }\n+                    prefix_cursor = base;\n+                }\n+            }\n+\n+            all_fake_borrows.push((place, borrow_kind));\n+        }\n+\n+        // Deduplicate and ensure a deterministic order.\n+        all_fake_borrows.sort();\n+        all_fake_borrows.dedup();\n+\n+        debug!(\"add_fake_borrows all_fake_borrows = {:?}\", all_fake_borrows);\n+\n+        // Add fake borrows to the start of the match and reads of them before\n+        // the start of each arm.\n+        let mut borrowed_input_temps = Vec::with_capacity(all_fake_borrows.len());\n+\n+        for (matched_place, borrow_kind) in all_fake_borrows {\n+            let borrowed_input =\n+                Rvalue::Ref(tcx.types.re_empty, borrow_kind, matched_place.clone());\n+            let borrowed_input_ty = borrowed_input.ty(&self.local_decls, tcx);\n+            let borrowed_input_temp = self.temp(borrowed_input_ty, source_info.span);\n+            self.cfg.push_assign(\n+                start_block,\n+                source_info,\n+                &borrowed_input_temp,\n+                borrowed_input\n+            );\n+            borrowed_input_temps.push(borrowed_input_temp);\n+        }\n+\n+        // FIXME: This could be a lot of reads (#fake borrows * #patterns).\n+        // The false edges that we currently generate would allow us to only do\n+        // this on the last Candidate, but it's possible that there might not be\n+        // so many false edges in the future, so we read for all Candidates for\n+        // now.\n+        // Another option would be to make our own block and add our own false\n+        // edges to it.\n+        if tcx.emit_read_for_match() {\n+            for &(pre_binding_block, span) in pre_binding_blocks {\n+                let pattern_source_info = self.source_info(span);\n+                for temp in &borrowed_input_temps {\n+                    self.cfg.push(pre_binding_block, Statement {\n+                        source_info: pattern_source_info,\n+                        kind: StatementKind::FakeRead(\n+                            FakeReadCause::ForMatchGuard,\n+                            temp.clone(),\n+                        ),\n+                    });\n+                }\n+            }\n+        }\n+    }\n }"}, {"sha": "0c31e5c4da8ac605ca65eb25d1512253f39a2ec7", "filename": "src/librustc_mir/diagnostics.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Flibrustc_mir%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Flibrustc_mir%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdiagnostics.rs?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -1991,6 +1991,26 @@ fn main() {\n ```\n \"##,\n \n+E0510: r##\"\n+Cannot mutate place in this match guard.\n+\n+When matching on a variable it cannot be mutated in the match guards, as this\n+could cause the match to be non-exhaustive:\n+\n+```compile_fail,E0510\n+#![feature(nll, bind_by_move_pattern_guards)]\n+let mut x = Some(0);\n+match x {\n+    None => (),\n+    Some(v) if { x = None; false } => (),\n+    Some(_) => (), // No longer matches\n+}\n+```\n+\n+Here executing `x = None` would modify the value being matched and require us\n+to go \"back in time\" to the `None` arm.\n+\"##,\n+\n E0579: r##\"\n When matching against an exclusive range, the compiler verifies that the range\n is non-empty. Exclusive range patterns include the start point but not the end"}, {"sha": "a2d70bc05c1d49c9eb7ee18556a961a153fabdf1", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -14,7 +14,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n \n */\n \n-#![cfg_attr(not(stage0), feature(nll))]\n+#![feature(nll)]\n #![feature(in_band_lifetimes)]\n #![feature(impl_header_lifetime_elision)]\n #![feature(slice_patterns)]"}, {"sha": "aaba7ab8418f539ded32e4974d91a73b02dbd00e", "filename": "src/librustc_mir/transform/cleanup_post_borrowck.rs", "status": "modified", "additions": 61, "deletions": 1, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -33,7 +33,8 @@\n use rustc_data_structures::fx::FxHashSet;\n \n use rustc::middle::region;\n-use rustc::mir::{BasicBlock, Location, Mir, Rvalue, Statement, StatementKind};\n+use rustc::mir::{BasicBlock, FakeReadCause, Local, Location, Mir, Place};\n+use rustc::mir::{Rvalue, Statement, StatementKind};\n use rustc::mir::visit::{MutVisitor, Visitor, TyContext};\n use rustc::ty::{Ty, RegionKind, TyCtxt};\n use transform::{MirPass, MirSource};\n@@ -135,3 +136,62 @@ impl<'tcx> MutVisitor<'tcx> for DeleteAscribeUserType {\n         self.super_statement(block, statement, location);\n     }\n }\n+\n+pub struct CleanFakeReadsAndBorrows;\n+\n+pub struct DeleteAndRecordFakeReads {\n+    fake_borrow_temporaries: FxHashSet<Local>,\n+}\n+\n+pub struct DeleteFakeBorrows {\n+    fake_borrow_temporaries: FxHashSet<Local>,\n+}\n+\n+// Removes any FakeReads from the MIR\n+impl MirPass for CleanFakeReadsAndBorrows {\n+    fn run_pass<'a, 'tcx>(&self,\n+                          _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          _source: MirSource,\n+                          mir: &mut Mir<'tcx>) {\n+        let mut delete_reads = DeleteAndRecordFakeReads {\n+            fake_borrow_temporaries: FxHashSet(),\n+        };\n+        delete_reads.visit_mir(mir);\n+        let mut delete_borrows = DeleteFakeBorrows {\n+            fake_borrow_temporaries: delete_reads.fake_borrow_temporaries,\n+        };\n+        delete_borrows.visit_mir(mir);\n+    }\n+}\n+\n+impl<'tcx> MutVisitor<'tcx> for DeleteAndRecordFakeReads {\n+    fn visit_statement(&mut self,\n+                       block: BasicBlock,\n+                       statement: &mut Statement<'tcx>,\n+                       location: Location) {\n+        if let StatementKind::FakeRead(cause, ref place) = statement.kind {\n+            if let FakeReadCause::ForMatchGuard = cause {\n+                match *place {\n+                    Place::Local(local) => self.fake_borrow_temporaries.insert(local),\n+                    _ => bug!(\"Fake match guard read of non-local: {:?}\", place),\n+                };\n+            }\n+            statement.make_nop();\n+        }\n+        self.super_statement(block, statement, location);\n+    }\n+}\n+\n+impl<'tcx> MutVisitor<'tcx> for DeleteFakeBorrows {\n+    fn visit_statement(&mut self,\n+                       block: BasicBlock,\n+                       statement: &mut Statement<'tcx>,\n+                       location: Location) {\n+        if let StatementKind::Assign(Place::Local(local), _) = statement.kind {\n+            if self.fake_borrow_temporaries.contains(&local) {\n+                statement.make_nop();\n+            }\n+        }\n+        self.super_statement(block, statement, location);\n+    }\n+}"}, {"sha": "d18836999dccfe7629c1c8221274c6a161571443", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -237,9 +237,12 @@ fn optimized_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx\n         no_landing_pads::NoLandingPads,\n         simplify_branches::SimplifyBranches::new(\"initial\"),\n         remove_noop_landing_pads::RemoveNoopLandingPads,\n-        simplify::SimplifyCfg::new(\"early-opt\"),\n         // Remove all `AscribeUserType` statements.\n         cleanup_post_borrowck::CleanAscribeUserType,\n+        // Remove all `FakeRead` statements and the borrows that are only\n+        // used for checking matches\n+        cleanup_post_borrowck::CleanFakeReadsAndBorrows,\n+        simplify::SimplifyCfg::new(\"early-opt\"),\n \n         // These next passes must be executed together\n         add_call_guards::CriticalCallEdges,"}, {"sha": "6d5d3ba88f2f6e7d6a9171d31c096f93b8dbca36", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -555,6 +555,29 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         self.cannot_borrow_path_as_mutable_because(span, path, \"\", o)\n     }\n \n+    fn cannot_mutate_in_match_guard(\n+        self,\n+        mutate_span: Span,\n+        match_span: Span,\n+        match_place: &str,\n+        action: &str,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        let mut err = struct_span_err!(\n+            self,\n+            mutate_span,\n+            E0510,\n+            \"cannot {} `{}` in match guard{OGN}\",\n+            action,\n+            match_place,\n+            OGN = o\n+        );\n+        err.span_label(mutate_span, format!(\"cannot {}\", action));\n+        err.span_label(match_span, format!(\"value is immutable in match guard\"));\n+\n+        self.cancel_if_wrong_origin(err, o)\n+    }\n+\n     fn cannot_borrow_across_generator_yield(\n         self,\n         span: Span,"}, {"sha": "8390a0d19ae7b51e416d624c3bec8000d636e30e", "filename": "src/test/mir-opt/box_expr.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fmir-opt%2Fbox_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fmir-opt%2Fbox_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbox_expr.rs?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -63,7 +63,6 @@ impl Drop for S {\n //\n //     bb4: {\n //         StorageDead(_2);\n-//         FakeRead(ForLet, _1);\n //         StorageLive(_4);\n //         _4 = move _1;\n //         _3 = const std::mem::drop(move _4) -> [return: bb5, unwind: bb7];"}, {"sha": "f9024b67063344aee2d545f3ad760727fa47aafd", "filename": "src/test/mir-opt/issue-49232.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fmir-opt%2Fissue-49232.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fmir-opt%2Fissue-49232.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-49232.rs?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -34,10 +34,9 @@ fn main() {\n //     }\n //     let mut _1: ();\n //     let mut _3: bool;\n-//     let mut _4: u8;\n-//     let mut _5: !;\n-//     let mut _6: ();\n-//     let mut _7: &i32;\n+//     let mut _4: !;\n+//     let mut _5: ();\n+//     let mut _6: &i32;\n //     bb0: {\n //         goto -> bb1;\n //     }\n@@ -51,7 +50,7 @@ fn main() {\n //         StorageLive(_2);\n //         StorageLive(_3);\n //         _3 = const true;\n-//         _4 = discriminant(_3);\n+//         FakeRead(ForMatchedPlace, _3);\n //         switchInt(_3) -> [false: bb11, otherwise: bb10];\n //     }\n //     bb4: {\n@@ -89,9 +88,9 @@ fn main() {\n //     bb14: {\n //         FakeRead(ForLet, _2);\n //         StorageDead(_3);\n-//         StorageLive(_7);\n-//         _7 = &_2;\n-//         _6 = const std::mem::drop(move _7) -> [return: bb28, unwind: bb4];\n+//         StorageLive(_6);\n+//         _6 = &_2;\n+//         _5 = const std::mem::drop(move _6) -> [return: bb28, unwind: bb4];\n //     }\n //     bb15: {\n //         goto -> bb16;\n@@ -129,15 +128,15 @@ fn main() {\n //         goto -> bb2;\n //     }\n //     bb26: {\n-//         _5 = ();\n+//         _4 = ();\n //         unreachable;\n //     }\n //     bb27: {\n-//         StorageDead(_5);\n+//         StorageDead(_4);\n //         goto -> bb14;\n //     }\n //     bb28: {\n-//         StorageDead(_7);\n+//         StorageDead(_6);\n //         _1 = ();\n //         StorageDead(_2);\n //         goto -> bb1;"}, {"sha": "9ccf03713994537ef9e1393ba45d6c7221e68a4c", "filename": "src/test/mir-opt/match_false_edges.rs", "status": "modified", "additions": 78, "deletions": 65, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -53,10 +53,11 @@ fn main() {\n //  bb0: {\n //      ...\n //      _2 = std::option::Option<i32>::Some(const 42i32,);\n-//      _3 = discriminant(_2);\n-//      _4 = &(promoted[1]: std::option::Option<i32>);\n-//      _9 = discriminant(_2);\n-//      switchInt(move _9) -> [0isize: bb5, 1isize: bb3, otherwise: bb7];\n+//      FakeRead(ForMatchedPlace, _2);\n+//      _7 = discriminant(_2);\n+//      _9 = &shallow (promoted[2]: std::option::Option<i32>);\n+//      _10 = &(((promoted[1]: std::option::Option<i32>) as Some).0: i32);\n+//      switchInt(move _7) -> [0isize: bb5, 1isize: bb3, otherwise: bb7];\n //  }\n //  bb1: {\n //      resume;\n@@ -66,15 +67,18 @@ fn main() {\n //      goto -> bb13;\n //  }\n //  bb3: { // binding3(empty) and arm3\n-//      FakeRead(ForMatch, _4);\n+//      FakeRead(ForMatchGuard, _9);\n+//      FakeRead(ForMatchGuard, _10);\n //      falseEdges -> [real: bb8, imaginary: bb4]; //pre_binding1\n //  }\n //  bb4: {\n-//      FakeRead(ForMatch, _4);\n+//      FakeRead(ForMatchGuard, _9);\n+//      FakeRead(ForMatchGuard, _10);\n //      falseEdges -> [real: bb12, imaginary: bb5]; //pre_binding2\n //  }\n //  bb5: {\n-//      FakeRead(ForMatch, _4);\n+//      FakeRead(ForMatchGuard, _9);\n+//      FakeRead(ForMatchGuard, _10);\n //      falseEdges -> [real: bb2, imaginary: bb6]; //pre_binding3\n //  }\n //  bb6: {\n@@ -84,31 +88,31 @@ fn main() {\n //      unreachable;\n //  }\n //  bb8: { // binding1 and guard\n-//      StorageLive(_7);\n-//      _7 = &(((promoted[0]: std::option::Option<i32>) as Some).0: i32);\n-//      StorageLive(_10);\n-//      _10 = const guard() -> [return: bb9, unwind: bb1];\n+//      StorageLive(_5);\n+//      _5 = &(((promoted[0]: std::option::Option<i32>) as Some).0: i32);\n+//      StorageLive(_8);\n+//      _8 = const guard() -> [return: bb9, unwind: bb1];\n //  }\n //  bb9: {\n-//      switchInt(move _10) -> [false: bb10, otherwise: bb11];\n+//      switchInt(move _8) -> [false: bb10, otherwise: bb11];\n //  }\n //  bb10: { // to pre_binding2\n //      falseEdges -> [real: bb4, imaginary: bb4];\n //  }\n //  bb11: { // bindingNoLandingPads.before.mir2 and arm2\n-//      StorageLive(_5);\n-//      _5 = ((_2 as Some).0: i32);\n+//      StorageLive(_3);\n+//      _3 = ((_2 as Some).0: i32);\n //      StorageLive(_11);\n-//      _11 = _5;\n+//      _11 = _3;\n //      _1 = (const 1i32, move _11);\n //      StorageDead(_11);\n //      goto -> bb13;\n //  }\n //  bb12: {\n-//      StorageLive(_8);\n-//      _8 = ((_2 as Some).0: i32);\n+//      StorageLive(_6);\n+//      _6 = ((_2 as Some).0: i32);\n //      StorageLive(_12);\n-//      _12 = _8;\n+//      _12 = _6;\n //      _1 = (const 2i32, move_12);\n //      StorageDead(_12);\n //      goto -> bb13;\n@@ -123,10 +127,11 @@ fn main() {\n //  bb0: {\n //      ...\n //      _2 = std::option::Option<i32>::Some(const 42i32,);\n-//      _3 = discriminant(_2);\n-//      _4 = &_2;\n-//      _9 = discriminant(_2);\n-//      switchInt(move _9) -> [0isize: bb4, 1isize: bb3, otherwise: bb7];\n+//      FakeRead(ForMatchedPlace, _2);\n+//      _7 = discriminant(_2);\n+//      _9 = &shallow _2;\n+//      _10 = &((_2 as Some).0: i32);\n+//      switchInt(move _7) -> [0isize: bb4, 1isize: bb3, otherwise: bb7];\n //  }\n //  bb1: {\n //      resume;\n@@ -136,15 +141,18 @@ fn main() {\n //      goto -> bb13;\n //  }\n //  bb3: {\n-//      FakeRead(ForMatch, _4);\n+//      FakeRead(ForMatchGuard, _9);\n+//      FakeRead(ForMatchGuard, _10);\n //      falseEdges -> [real: bb8, imaginary: bb4]; //pre_binding1\n //  }\n //  bb4: {\n-//      FakeRead(ForMatch, _4);\n+//      FakeRead(ForMatchGuard, _9);\n+//      FakeRead(ForMatchGuard, _10);\n //      falseEdges -> [real: bb2, imaginary: bb5]; //pre_binding2\n //  }\n //  bb5: {\n-//      FakeRead(ForMatch, _4);\n+//      FakeRead(ForMatchGuard, _9);\n+//      FakeRead(ForMatchGuard, _10);\n //      falseEdges -> [real: bb12, imaginary: bb6]; //pre_binding3\n //  }\n //  bb6: {\n@@ -154,31 +162,31 @@ fn main() {\n //      unreachable;\n //  }\n //  bb8: { // binding1 and guard\n-//      StorageLive(_7);\n-//      _7 = &((_2 as Some).0: i32);\n-//      StorageLive(_10);\n-//      _10 = const guard() -> [return: bb9, unwind: bb1];\n+//      StorageLive(_5);\n+//      _5 = &((_2 as Some).0: i32);\n+//      StorageLive(_8);\n+//      _8 = const guard() -> [return: bb9, unwind: bb1];\n //  }\n //  bb9: { // end of guard\n-//      switchInt(move _10) -> [false: bb10, otherwise: bb11];\n+//      switchInt(move _8) -> [false: bb10, otherwise: bb11];\n //  }\n //  bb10: { // to pre_binding3 (can skip 2 since this is `Some`)\n //      falseEdges -> [real: bb5, imaginary: bb4];\n //  }\n //  bb11: { // arm1\n-//      StorageLive(_5);\n-//      _5 = ((_2 as Some).0: i32);\n+//      StorageLive(_3);\n+//      _3 = ((_2 as Some).0: i32);\n //      StorageLive(_11);\n-//      _11 = _5;\n+//      _11 = _3;\n //      _1 = (const 1i32, move _11);\n //      StorageDead(_11);\n //      goto -> bb13;\n //  }\n //  bb12: { // binding3 and arm3\n-//      StorageLive(_8);\n-//      _8 = ((_2 as Some).0: i32);\n+//      StorageLive(_6);\n+//      _6 = ((_2 as Some).0: i32);\n //      StorageLive(_12);\n-//      _12 = _8;\n+//      _12 = _6;\n //      _1 = (const 2i32, move _12);\n //      StorageDead(_12);\n //      goto -> bb13;\n@@ -193,81 +201,86 @@ fn main() {\n // bb0: {\n //     ...\n //     _2 = std::option::Option<i32>::Some(const 1i32,);\n-//     _3 = discriminant(_2);\n-//     _4 = &_2;\n-//     _13 = discriminant(_2);\n-//     switchInt(move _13) -> [1isize: bb2, otherwise: bb3];\n+//     FakeRead(ForMatchedPlace, _2);\n+//     _11 = discriminant(_2);\n+//    _16 = &shallow _2;\n+//    _17 = &((_2 as Some).0: i32);\n+//     switchInt(move _11) -> [1isize: bb2, otherwise: bb3];\n // }\n // bb1: {\n //     resume;\n // }\n // bb2: {\n-//     FakeRead(ForMatch, _4);\n+//      FakeRead(ForMatchGuard, _16);\n+//      FakeRead(ForMatchGuard, _17);\n //     falseEdges -> [real: bb7, imaginary: bb3]; //pre_binding1\n // }\n // bb3: {\n-//     FakeRead(ForMatch, _4);\n+//      FakeRead(ForMatchGuard, _16);\n+//      FakeRead(ForMatchGuard, _17);\n //     falseEdges -> [real: bb11, imaginary: bb4]; //pre_binding2\n // }\n // bb4: {\n-//     FakeRead(ForMatch, _4);\n+//      FakeRead(ForMatchGuard, _16);\n+//      FakeRead(ForMatchGuard, _17);\n //     falseEdges -> [real: bb12, imaginary: bb5]; //pre_binding3\n // }\n // bb5: {\n-//     FakeRead(ForMatch, _4);\n+//      FakeRead(ForMatchGuard, _16);\n+//      FakeRead(ForMatchGuard, _17);\n //     falseEdges -> [real: bb16, imaginary: bb6]; //pre_binding4\n // }\n // bb6: {\n //     unreachable;\n // }\n // bb7: { // binding1: Some(w) if guard()\n-//     StorageLive(_7);\n-//     _7 = &((_2 as Some).0: i32);\n-//     StorageLive(_14);\n-//     _14 = const guard() -> [return: bb8, unwind: bb1];\n+//     StorageLive(_5);\n+//     _5 = &((_2 as Some).0: i32);\n+//     StorageLive(_12);\n+//     _12 = const guard() -> [return: bb8, unwind: bb1];\n // }\n // bb8: { //end of guard\n-//     switchInt(move _14) -> [false: bb9, otherwise: bb10];\n+//     switchInt(move _12) -> [false: bb9, otherwise: bb10];\n // }\n // bb9: { // to pre_binding2\n //     falseEdges -> [real: bb3, imaginary: bb3];\n // }\n // bb10: { // set up bindings for arm1\n-//     StorageLive(_5);\n-//     _5 = ((_2 as Some).0: i32);\n+//     StorageLive(_3);\n+//     _3 = ((_2 as Some).0: i32);\n //     _1 = const 1i32;\n //     goto -> bb17;\n // }\n // bb11: { // binding2 & arm2\n-//     StorageLive(_8);\n-//     _8 = _2;\n+//     StorageLive(_6);\n+//     _6 = _2;\n //     _1 = const 2i32;\n //     goto -> bb17;\n // }\n // bb12: { // binding3: Some(y) if guard2(y)\n-//     StorageLive(_11);\n-//     _11 = &((_2 as Some).0: i32);\n-//     StorageLive(_16);\n-//     StorageLive(_17);\n-//     _17 = (*_11);\n-//     _16 = const guard2(move _17) -> [return: bb13, unwind: bb1];\n+//     StorageLive(_9);\n+//     _9 = &((_2 as Some).0: i32);\n+//     StorageLive(_14);\n+//     StorageLive(_15);\n+//     _15 = (*_9);\n+//     _14 = const guard2(move _15) -> [return: bb13, unwind: bb1];\n // }\n // bb13: { // end of guard2\n-//     StorageDead(_17);\n-//     switchInt(move _16) -> [false: bb14, otherwise: bb15];\n+//     StorageDead(_15);\n+//     switchInt(move _14) -> [false: bb14, otherwise: bb15];\n // }\n // bb14: { // to pre_binding4\n //     falseEdges -> [real: bb5, imaginary: bb5];\n // }\n // bb15: { // set up bindings for arm3\n-//     StorageLive(_9);\n-//     _9 = ((_2 as Some).0: i32);\n+//     StorageLive(_7);\n+//     _7 = ((_2 as Some).0: i32);\n //     _1 = const 3i32;\n //     goto -> bb17;\n // }\n // bb16: { // binding4 & arm4\n-//     StorageLive(_12);\n-//     _12 = _2;\n+//     StorageLive(_10);\n+//     _10 = _2;\n //     _1 = const 4i32;\n //     goto -> bb17;\n // }"}, {"sha": "8411fba02e97766244669818182bd50866855617", "filename": "src/test/mir-opt/remove_fake_borrows.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fmir-opt%2Fremove_fake_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fmir-opt%2Fremove_fake_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fremove_fake_borrows.rs?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -0,0 +1,122 @@\n+// Test that the fake borrows for matches are removed after borrow checking.\n+\n+// ignore-wasm32-bare\n+\n+#![feature(nll)]\n+\n+fn match_guard(x: Option<&&i32>) -> i32 {\n+    match x {\n+        Some(0) if true => 0,\n+        _ => 1,\n+    }\n+}\n+\n+fn main() {\n+    match_guard(None);\n+}\n+\n+// END RUST SOURCE\n+\n+// START rustc.match_guard.CleanFakeReadsAndBorrows.before.mir\n+// bb0: {\n+//     FakeRead(ForMatchedPlace, _1);\n+//     _2 = discriminant(_1);\n+//     _3 = &shallow _1;\n+//     _4 = &shallow ((_1 as Some).0: &'<empty> &'<empty> i32);\n+//     _5 = &shallow (*((_1 as Some).0: &'<empty> &'<empty> i32));\n+//     _6 = &shallow (*(*((_1 as Some).0: &'<empty> &'<empty> i32)));\n+//     switchInt(move _2) -> [1isize: bb6, otherwise: bb4];\n+// }\n+// bb1: {\n+//     _0 = const 0i32;\n+//     goto -> bb9;\n+// }\n+// bb2: {\n+//     _0 = const 1i32;\n+//     goto -> bb9;\n+// }\n+// bb3: {\n+//     FakeRead(ForMatchGuard, _3);\n+//     FakeRead(ForMatchGuard, _4);\n+//     FakeRead(ForMatchGuard, _5);\n+//     FakeRead(ForMatchGuard, _6);\n+//     goto -> bb7;\n+// }\n+// bb4: {\n+//     FakeRead(ForMatchGuard, _3);\n+//     FakeRead(ForMatchGuard, _4);\n+//     FakeRead(ForMatchGuard, _5);\n+//     FakeRead(ForMatchGuard, _6);\n+//     goto -> bb2;\n+// }\n+// bb5: {\n+//     unreachable;\n+// }\n+// bb6: {\n+//     switchInt((*(*((_1 as Some).0: &'<empty> &'<empty> i32)))) -> [0i32: bb3, otherwise: bb4];\n+// }\n+// bb7: {\n+//     goto -> bb1;\n+// }\n+// bb8: {\n+//     goto -> bb4;\n+// }\n+// bb9: {\n+//     return;\n+// }\n+// bb10: {\n+//     resume;\n+// }\n+// END rustc.match_guard.CleanFakeReadsAndBorrows.before.mir\n+\n+// START rustc.match_guard.CleanFakeReadsAndBorrows.after.mir\n+// bb0: {\n+//     nop;\n+//     _2 = discriminant(_1);\n+//     nop;\n+//     nop;\n+//     nop;\n+//     nop;\n+//     switchInt(move _2) -> [1isize: bb6, otherwise: bb4];\n+// }\n+// bb1: {\n+//     _0 = const 0i32;\n+//     goto -> bb9;\n+// }\n+// bb2: {\n+//     _0 = const 1i32;\n+//     goto -> bb9;\n+// }\n+// bb3: {\n+//     nop;\n+//     nop;\n+//     nop;\n+//     nop;\n+//     goto -> bb7;\n+// }\n+// bb4: {\n+//     nop;\n+//     nop;\n+//     nop;\n+//     nop;\n+//     goto -> bb2;\n+// }\n+// bb5: {\n+//     unreachable;\n+// }\n+// bb6: {\n+//     switchInt((*(*((_1 as Some).0: &'<empty> &'<empty> i32)))) -> [0i32: bb3, otherwise: bb4];\n+// }\n+// bb7: {\n+//     goto -> bb1;\n+// }\n+// bb8: {\n+//     goto -> bb4;\n+// }\n+// bb9: {\n+//     return;\n+// }\n+// bb10: {\n+//     resume;\n+// }\n+// END rustc.match_guard.CleanFakeReadsAndBorrows.after.mir"}, {"sha": "882579c571086ab8e48566a942abece6c3dcbdc4", "filename": "src/test/mir-opt/validate_1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -67,7 +67,6 @@ fn main() {\n //         Validate(Suspend(ReScope(Remainder { block: ItemLocalId(25), first_statement_index: 0 })), [(*_2): i32]);\n //         _3 = &ReErased (*_2);\n //         Validate(Acquire, [(*_3): i32/ReScope(Remainder { block: ItemLocalId(25), first_statement_index: 0 }) (imm)]);\n-//         FakeRead(ForLet, _3);\n //         _0 = (*_3);\n //         EndRegion(ReScope(Remainder { block: ItemLocalId(25), first_statement_index: 0 }));\n //         StorageDead(_3);"}, {"sha": "3776a11b3ab825ceb53ad5241d1bfdd3be2b83f0", "filename": "src/test/mir-opt/validate_2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fmir-opt%2Fvalidate_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fmir-opt%2Fvalidate_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_2.rs?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -28,7 +28,6 @@ fn main() {\n //         Validate(Acquire, [_1: std::boxed::Box<[i32]>]);\n //         StorageDead(_2);\n //         StorageDead(_3);\n-//         FakeRead(ForLet, _1);\n //         _0 = ();\n //         Validate(Release, [_1: std::boxed::Box<[i32]>]);\n //         drop(_1) -> [return: bb2, unwind: bb3];"}, {"sha": "07f5b2aa84b7dda57e8dbb2958867272ac44981d", "filename": "src/test/mir-opt/validate_3.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fmir-opt%2Fvalidate_3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fmir-opt%2Fvalidate_3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_3.rs?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -47,12 +47,10 @@ fn main() {\n //     bb0: {\n //         StorageLive(_1);\n //         _1 = Test { x: const 0i32 };\n-//         FakeRead(ForLet, _1);\n //         StorageLive(_2);\n //         Validate(Suspend(ReScope(Remainder { block: ItemLocalId(20), first_statement_index: 3 })), [_1: Test]);\n //         _2 = &ReErased _1;\n //         Validate(Acquire, [(*_2): Test/ReScope(Remainder { block: ItemLocalId(20), first_statement_index: 3 }) (imm)]);\n-//         FakeRead(ForLet, _2);\n //         StorageLive(_4);\n //         StorageLive(_5);\n //         Validate(Suspend(ReScope(Node(ItemLocalId(18)))), [((*_2).0: i32): i32/ReScope(Remainder { block: ItemLocalId(20), first_statement_index: 3 }) (imm)]);"}, {"sha": "963a89ed44da6dc00d49a3d59ae2362b97cd53c7", "filename": "src/test/ui/borrowck/borrowck-anon-fields-struct.nll.stderr", "status": "modified", "additions": 2, "deletions": 27, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-anon-fields-struct.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-anon-fields-struct.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-anon-fields-struct.nll.stderr?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -1,27 +1,3 @@\n-error[E0502]: cannot borrow `y` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-anon-fields-struct.rs:23:19\n-   |\n-LL |         Y(ref mut a, _) => a\n-   |           --------- mutable borrow occurs here\n-...\n-LL |     let b = match y {\n-   |                   ^ immutable borrow occurs here\n-...\n-LL |     *a += 1;\n-   |     ------- borrow later used here\n-\n-error[E0502]: cannot borrow `y` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-anon-fields-struct.rs:38:19\n-   |\n-LL |         Y(ref mut a, _) => a\n-   |           --------- mutable borrow occurs here\n-...\n-LL |     let b = match y {\n-   |                   ^ immutable borrow occurs here\n-...\n-LL |     *a += 1;\n-   |     ------- borrow later used here\n-\n error[E0499]: cannot borrow `y.0` as mutable more than once at a time\n   --> $DIR/borrowck-anon-fields-struct.rs:39:11\n    |\n@@ -34,7 +10,6 @@ LL |         Y(ref mut b, _) => b //~ ERROR cannot borrow\n LL |     *a += 1;\n    |     ------- borrow later used here\n \n-error: aborting due to 3 previous errors\n+error: aborting due to previous error\n \n-Some errors occurred: E0499, E0502.\n-For more information about an error, try `rustc --explain E0499`.\n+For more information about this error, try `rustc --explain E0499`."}, {"sha": "f06822f7bb6e4ae0bf116a0352aecc05cb02f8e3", "filename": "src/test/ui/borrowck/borrowck-anon-fields-tuple.nll.stderr", "status": "modified", "additions": 2, "deletions": 27, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-anon-fields-tuple.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-anon-fields-tuple.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-anon-fields-tuple.nll.stderr?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -1,27 +1,3 @@\n-error[E0502]: cannot borrow `y` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-anon-fields-tuple.rs:21:19\n-   |\n-LL |         (ref mut a, _) => a\n-   |          --------- mutable borrow occurs here\n-...\n-LL |     let b = match y {\n-   |                   ^ immutable borrow occurs here\n-...\n-LL |     *a += 1;\n-   |     ------- borrow later used here\n-\n-error[E0502]: cannot borrow `y` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-anon-fields-tuple.rs:36:19\n-   |\n-LL |         (ref mut a, _) => a\n-   |          --------- mutable borrow occurs here\n-...\n-LL |     let b = match y {\n-   |                   ^ immutable borrow occurs here\n-...\n-LL |     *a += 1;\n-   |     ------- borrow later used here\n-\n error[E0499]: cannot borrow `y.0` as mutable more than once at a time\n   --> $DIR/borrowck-anon-fields-tuple.rs:37:10\n    |\n@@ -34,7 +10,6 @@ LL |         (ref mut b, _) => b //~ ERROR cannot borrow\n LL |     *a += 1;\n    |     ------- borrow later used here\n \n-error: aborting due to 3 previous errors\n+error: aborting due to previous error\n \n-Some errors occurred: E0499, E0502.\n-For more information about an error, try `rustc --explain E0499`.\n+For more information about this error, try `rustc --explain E0499`."}, {"sha": "05197205e814c0b931e2030dc242e85669ab93d3", "filename": "src/test/ui/borrowck/borrowck-anon-fields-variant.nll.stderr", "status": "modified", "additions": 2, "deletions": 27, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-anon-fields-variant.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-anon-fields-variant.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-anon-fields-variant.nll.stderr?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -1,27 +1,3 @@\n-error[E0502]: cannot borrow `y` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-anon-fields-variant.rs:26:19\n-   |\n-LL |       Foo::Y(ref mut a, _) => a,\n-   |              --------- mutable borrow occurs here\n-...\n-LL |     let b = match y {\n-   |                   ^ immutable borrow occurs here\n-...\n-LL |     *a += 1;\n-   |     ------- borrow later used here\n-\n-error[E0502]: cannot borrow `y` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-anon-fields-variant.rs:43:19\n-   |\n-LL |       Foo::Y(ref mut a, _) => a,\n-   |              --------- mutable borrow occurs here\n-...\n-LL |     let b = match y {\n-   |                   ^ immutable borrow occurs here\n-...\n-LL |     *a += 1;\n-   |     ------- borrow later used here\n-\n error[E0499]: cannot borrow `y.0` as mutable more than once at a time\n   --> $DIR/borrowck-anon-fields-variant.rs:44:14\n    |\n@@ -34,7 +10,6 @@ LL |       Foo::Y(ref mut b, _) => b, //~ ERROR cannot borrow\n LL |     *a += 1;\n    |     ------- borrow later used here\n \n-error: aborting due to 3 previous errors\n+error: aborting due to previous error\n \n-Some errors occurred: E0499, E0502.\n-For more information about an error, try `rustc --explain E0499`.\n+For more information about this error, try `rustc --explain E0499`."}, {"sha": "603f4d63f7f4a78505c6ef8f094a98f4ff5124ba", "filename": "src/test/ui/borrowck/borrowck-borrow-from-owned-ptr.nll.stderr", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-borrow-from-owned-ptr.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-borrow-from-owned-ptr.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-borrow-from-owned-ptr.nll.stderr?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -28,17 +28,6 @@ LL |     let _bar2 = &mut foo.bar1;  //~ ERROR cannot borrow\n LL |     *bar1;\n    |     ----- borrow later used here\n \n-error[E0502]: cannot borrow `*foo` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-borrow-from-owned-ptr.rs:72:11\n-   |\n-LL |     let bar1 = &mut foo.bar1;\n-   |                ------------- mutable borrow occurs here\n-LL |     match *foo {\n-   |           ^^^^ immutable borrow occurs here\n-...\n-LL |     *bar1;\n-   |     ----- borrow later used here\n-\n error[E0499]: cannot borrow `foo.bar1` as mutable more than once at a time\n   --> $DIR/borrowck-borrow-from-owned-ptr.rs:73:21\n    |\n@@ -121,7 +110,7 @@ LL |     let foo = make_foo();\n LL |     let bar1 = &mut foo.bar1; //~ ERROR cannot borrow\n    |                ^^^^^^^^^^^^^ cannot borrow as mutable\n \n-error: aborting due to 12 previous errors\n+error: aborting due to 11 previous errors\n \n Some errors occurred: E0499, E0502, E0596.\n For more information about an error, try `rustc --explain E0499`."}, {"sha": "3a215f2336aefec6d294a0aeb1090e45056b8202", "filename": "src/test/ui/borrowck/borrowck-borrow-from-stack-variable.nll.stderr", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-borrow-from-stack-variable.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-borrow-from-stack-variable.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-borrow-from-stack-variable.nll.stderr?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -28,17 +28,6 @@ LL |     let _bar2 = &mut foo.bar1;  //~ ERROR cannot borrow\n LL |     *bar1;\n    |     ----- borrow later used here\n \n-error[E0502]: cannot borrow `foo` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-borrow-from-stack-variable.rs:70:11\n-   |\n-LL |     let bar1 = &mut foo.bar1;\n-   |                ------------- mutable borrow occurs here\n-LL |     match foo {\n-   |           ^^^ immutable borrow occurs here\n-...\n-LL |     *bar1;\n-   |     ----- borrow later used here\n-\n error[E0499]: cannot borrow `foo.bar1` as mutable more than once at a time\n   --> $DIR/borrowck-borrow-from-stack-variable.rs:71:21\n    |\n@@ -121,7 +110,7 @@ LL |     let foo = make_foo();\n LL |     let bar1 = &mut foo.bar1; //~ ERROR cannot borrow\n    |                ^^^^^^^^^^^^^ cannot borrow as mutable\n \n-error: aborting due to 12 previous errors\n+error: aborting due to 11 previous errors\n \n Some errors occurred: E0499, E0502, E0596.\n For more information about an error, try `rustc --explain E0499`."}, {"sha": "e417dadf6df163efebbf9d4694bee5095f00a1dd", "filename": "src/test/ui/borrowck/borrowck-describe-lvalue.ast.nll.stderr", "status": "modified", "additions": 9, "deletions": 170, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-describe-lvalue.ast.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-describe-lvalue.ast.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-describe-lvalue.ast.nll.stderr?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -72,23 +72,12 @@ LL |              //[mir]~^ ERROR cannot use `h.0` because it was mutably borrow\n LL |         drop(x);\n    |              - borrow later used here\n \n-error[E0503]: cannot use `e` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:77:15\n-   |\n-LL |         let x = e.x();\n-   |                 - borrow of `e` occurs here\n-LL |         match e { //[mir]~ ERROR cannot use `e` because it was mutably borrowed\n-   |               ^ use of borrowed `e`\n-...\n-LL |         drop(x);\n-   |              - borrow later used here\n-\n error[E0503]: cannot use `e.0` because it was mutably borrowed\n   --> $DIR/borrowck-describe-lvalue.rs:78:20\n    |\n LL |         let x = e.x();\n    |                 - borrow of `e` occurs here\n-LL |         match e { //[mir]~ ERROR cannot use `e` because it was mutably borrowed\n+LL |         match e {\n LL |             Baz::X(value) => value\n    |                    ^^^^^ use of borrowed `e`\n ...\n@@ -139,23 +128,12 @@ LL |              //[mir]~^ ERROR cannot use `h.0` because it was mutably borrow\n LL |         drop(x);\n    |              - borrow later used here\n \n-error[E0503]: cannot use `*e` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:120:15\n-   |\n-LL |         let x = e.x();\n-   |                 - borrow of `*e` occurs here\n-LL |         match *e { //[mir]~ ERROR cannot use `*e` because it was mutably borrowed\n-   |               ^^ use of borrowed `*e`\n-...\n-LL |         drop(x);\n-   |              - borrow later used here\n-\n error[E0503]: cannot use `e.0` because it was mutably borrowed\n   --> $DIR/borrowck-describe-lvalue.rs:121:20\n    |\n LL |         let x = e.x();\n    |                 - borrow of `*e` occurs here\n-LL |         match *e { //[mir]~ ERROR cannot use `*e` because it was mutably borrowed\n+LL |         match *e {\n LL |             Baz::X(value) => value\n    |                    ^^^^^ use of borrowed `*e`\n ...\n@@ -173,41 +151,18 @@ LL |              //[mir]~^ ERROR cannot use `u.a` because it was mutably borrow\n LL |         drop(x);\n    |              - borrow later used here\n \n-error[E0503]: cannot use `v` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:139:15\n-   |\n-LL |         let x = &mut v;\n-   |                 ------ borrow of `v` occurs here\n-LL |         match v { //[mir]~ ERROR cannot use `v` because it was mutably borrowed\n-   |               ^ use of borrowed `v`\n-...\n-LL |         drop(x);\n-   |              - borrow later used here\n-\n error[E0503]: cannot use `v[..]` because it was mutably borrowed\n   --> $DIR/borrowck-describe-lvalue.rs:140:15\n    |\n LL |         let x = &mut v;\n    |                 ------ borrow of `v` occurs here\n-LL |         match v { //[mir]~ ERROR cannot use `v` because it was mutably borrowed\n+LL |         match v {\n LL |             &[x, _, .., _, _] => println!(\"{}\", x),\n    |               ^ use of borrowed `v`\n ...\n LL |         drop(x);\n    |              - borrow later used here\n \n-error[E0503]: cannot use `v` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:145:15\n-   |\n-LL |         let x = &mut v;\n-   |                 ------ borrow of `v` occurs here\n-...\n-LL |         match v { //[mir]~ ERROR cannot use `v` because it was mutably borrowed\n-   |               ^ use of borrowed `v`\n-...\n-LL |         drop(x);\n-   |              - borrow later used here\n-\n error[E0503]: cannot use `v[..]` because it was mutably borrowed\n   --> $DIR/borrowck-describe-lvalue.rs:146:18\n    |\n@@ -220,18 +175,6 @@ LL |             &[_, x, .., _, _] => println!(\"{}\", x),\n LL |         drop(x);\n    |              - borrow later used here\n \n-error[E0503]: cannot use `v` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:151:15\n-   |\n-LL |         let x = &mut v;\n-   |                 ------ borrow of `v` occurs here\n-...\n-LL |         match v { //[mir]~ ERROR cannot use `v` because it was mutably borrowed\n-   |               ^ use of borrowed `v`\n-...\n-LL |         drop(x);\n-   |              - borrow later used here\n-\n error[E0503]: cannot use `v[..]` because it was mutably borrowed\n   --> $DIR/borrowck-describe-lvalue.rs:152:25\n    |\n@@ -244,18 +187,6 @@ LL |             &[_, _, .., x, _] => println!(\"{}\", x),\n LL |         drop(x);\n    |              - borrow later used here\n \n-error[E0503]: cannot use `v` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:157:15\n-   |\n-LL |         let x = &mut v;\n-   |                 ------ borrow of `v` occurs here\n-...\n-LL |         match v { //[mir]~ ERROR cannot use `v` because it was mutably borrowed\n-   |               ^ use of borrowed `v`\n-...\n-LL |         drop(x);\n-   |              - borrow later used here\n-\n error[E0503]: cannot use `v[..]` because it was mutably borrowed\n   --> $DIR/borrowck-describe-lvalue.rs:158:28\n    |\n@@ -268,41 +199,18 @@ LL |             &[_, _, .., _, x] => println!(\"{}\", x),\n LL |         drop(x);\n    |              - borrow later used here\n \n-error[E0503]: cannot use `v` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:169:15\n-   |\n-LL |         let x = &mut v;\n-   |                 ------ borrow of `v` occurs here\n-LL |         match v { //[mir]~ ERROR cannot use `v` because it was mutably borrowed\n-   |               ^ use of borrowed `v`\n-...\n-LL |         drop(x);\n-   |              - borrow later used here\n-\n error[E0503]: cannot use `v[..]` because it was mutably borrowed\n   --> $DIR/borrowck-describe-lvalue.rs:170:15\n    |\n LL |         let x = &mut v;\n    |                 ------ borrow of `v` occurs here\n-LL |         match v { //[mir]~ ERROR cannot use `v` because it was mutably borrowed\n+LL |         match v {\n LL |             &[x..] => println!(\"{:?}\", x),\n    |               ^ use of borrowed `v`\n ...\n LL |         drop(x);\n    |              - borrow later used here\n \n-error[E0503]: cannot use `v` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:175:15\n-   |\n-LL |         let x = &mut v;\n-   |                 ------ borrow of `v` occurs here\n-...\n-LL |         match v { //[mir]~ ERROR cannot use `v` because it was mutably borrowed\n-   |               ^ use of borrowed `v`\n-...\n-LL |         drop(x);\n-   |              - borrow later used here\n-\n error[E0503]: cannot use `v[..]` because it was mutably borrowed\n   --> $DIR/borrowck-describe-lvalue.rs:176:18\n    |\n@@ -315,18 +223,6 @@ LL |             &[_, x..] => println!(\"{:?}\", x),\n LL |         drop(x);\n    |              - borrow later used here\n \n-error[E0503]: cannot use `v` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:181:15\n-   |\n-LL |         let x = &mut v;\n-   |                 ------ borrow of `v` occurs here\n-...\n-LL |         match v { //[mir]~ ERROR cannot use `v` because it was mutably borrowed\n-   |               ^ use of borrowed `v`\n-...\n-LL |         drop(x);\n-   |              - borrow later used here\n-\n error[E0503]: cannot use `v[..]` because it was mutably borrowed\n   --> $DIR/borrowck-describe-lvalue.rs:182:15\n    |\n@@ -339,18 +235,6 @@ LL |             &[x.., _] => println!(\"{:?}\", x),\n LL |         drop(x);\n    |              - borrow later used here\n \n-error[E0503]: cannot use `v` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:187:15\n-   |\n-LL |         let x = &mut v;\n-   |                 ------ borrow of `v` occurs here\n-...\n-LL |         match v { //[mir]~ ERROR cannot use `v` because it was mutably borrowed\n-   |               ^ use of borrowed `v`\n-...\n-LL |         drop(x);\n-   |              - borrow later used here\n-\n error[E0503]: cannot use `v[..]` because it was mutably borrowed\n   --> $DIR/borrowck-describe-lvalue.rs:188:18\n    |\n@@ -363,23 +247,12 @@ LL |             &[_, x.., _] => println!(\"{:?}\", x),\n LL |         drop(x);\n    |              - borrow later used here\n \n-error[E0503]: cannot use `e` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:201:15\n-   |\n-LL |         let x = &mut e;\n-   |                 ------ borrow of `e` occurs here\n-LL |         match e { //[mir]~ ERROR cannot use `e` because it was mutably borrowed\n-   |               ^ use of borrowed `e`\n-...\n-LL |         drop(x);\n-   |              - borrow later used here\n-\n error[E0503]: cannot use `e` because it was mutably borrowed\n   --> $DIR/borrowck-describe-lvalue.rs:202:13\n    |\n LL |         let x = &mut e;\n    |                 ------ borrow of `e` occurs here\n-LL |         match e { //[mir]~ ERROR cannot use `e` because it was mutably borrowed\n+LL |         match e {\n LL |             E::A(ref ax) =>\n    |             ^^^^^^^^^^^^ use of borrowed `e`\n ...\n@@ -391,7 +264,7 @@ error[E0502]: cannot borrow `e.0` as immutable because it is also borrowed as mu\n    |\n LL |         let x = &mut e;\n    |                 ------ mutable borrow occurs here\n-LL |         match e { //[mir]~ ERROR cannot use `e` because it was mutably borrowed\n+LL |         match e {\n LL |             E::A(ref ax) =>\n    |                  ^^^^^^ immutable borrow occurs here\n ...\n@@ -410,41 +283,18 @@ LL |             E::B { x: ref bx } =>\n LL |         drop(x);\n    |              - borrow later used here\n \n-error[E0503]: cannot use `s` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:220:15\n-   |\n-LL |         let x = &mut s;\n-   |                 ------ borrow of `s` occurs here\n-LL |         match s { //[mir]~ ERROR cannot use `s` because it was mutably borrowed\n-   |               ^ use of borrowed `s`\n-...\n-LL |         drop(x);\n-   |              - borrow later used here\n-\n error[E0502]: cannot borrow `s.y.0` as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-describe-lvalue.rs:221:22\n    |\n LL |         let x = &mut s;\n    |                 ------ mutable borrow occurs here\n-LL |         match s { //[mir]~ ERROR cannot use `s` because it was mutably borrowed\n+LL |         match s {\n LL |             S  { y: (ref y0, _), .. } =>\n    |                      ^^^^^^ immutable borrow occurs here\n ...\n LL |         drop(x);\n    |              - borrow later used here\n \n-error[E0503]: cannot use `s` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:227:15\n-   |\n-LL |         let x = &mut s;\n-   |                 ------ borrow of `s` occurs here\n-...\n-LL |         match s { //[mir]~ ERROR cannot use `s` because it was mutably borrowed\n-   |               ^ use of borrowed `s`\n-...\n-LL |         drop(x);\n-   |              - borrow later used here\n-\n error[E0502]: cannot borrow `s.x.y` as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-describe-lvalue.rs:228:28\n    |\n@@ -479,23 +329,12 @@ LL |         v[0].y;\n LL |         drop(x);\n    |              - borrow later used here\n \n-error[E0503]: cannot use `v` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:282:15\n-   |\n-LL |         let x = &mut v;\n-   |                 ------ borrow of `v` occurs here\n-LL |         match v { //[mir]~ ERROR cannot use `v` because it was mutably borrowed\n-   |               ^ use of borrowed `v`\n-...\n-LL |         drop(x);\n-   |              - borrow later used here\n-\n error[E0502]: cannot borrow `v[..].x` as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-describe-lvalue.rs:283:24\n    |\n LL |         let x = &mut v;\n    |                 ------ mutable borrow occurs here\n-LL |         match v { //[mir]~ ERROR cannot use `v` because it was mutably borrowed\n+LL |         match v {\n LL |             &[_, F {x: ref xf, ..}] => println!(\"{}\", xf),\n    |                        ^^^^^^ immutable borrow occurs here\n ...\n@@ -534,7 +373,7 @@ LL |                 drop(x); //[ast]~ ERROR use of moved value: `x`\n    |\n    = note: move occurs because `x` has type `std::vec::Vec<i32>`, which does not implement the `Copy` trait\n \n-error: aborting due to 46 previous errors\n+error: aborting due to 32 previous errors\n \n Some errors occurred: E0382, E0499, E0502, E0503.\n For more information about an error, try `rustc --explain E0382`."}, {"sha": "bc6385ffd920bbe5cef005a293138b0f632ad0ee", "filename": "src/test/ui/borrowck/borrowck-describe-lvalue.ast.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-describe-lvalue.ast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-describe-lvalue.ast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-describe-lvalue.ast.stderr?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -27,7 +27,7 @@ error[E0503]: cannot use `e.0` because it was mutably borrowed\n    |\n LL |         let x = e.x();\n    |                 - borrow of `e` occurs here\n-LL |         match e { //[mir]~ ERROR cannot use `e` because it was mutably borrowed\n+LL |         match e {\n LL |             Baz::X(value) => value\n    |                    ^^^^^ use of borrowed `e`\n \n@@ -68,7 +68,7 @@ error[E0503]: cannot use `e.0` because it was mutably borrowed\n    |\n LL |         let x = e.x();\n    |                 - borrow of `*e` occurs here\n-LL |         match *e { //[mir]~ ERROR cannot use `*e` because it was mutably borrowed\n+LL |         match *e {\n LL |             Baz::X(value) => value\n    |                    ^^^^^ use of borrowed `*e`\n \n@@ -85,7 +85,7 @@ error[E0503]: cannot use `v[..]` because it was mutably borrowed\n    |\n LL |         let x = &mut v;\n    |                      - borrow of `v` occurs here\n-LL |         match v { //[mir]~ ERROR cannot use `v` because it was mutably borrowed\n+LL |         match v {\n LL |             &[x, _, .., _, _] => println!(\"{}\", x),\n    |               ^ use of borrowed `v`\n \n@@ -121,7 +121,7 @@ error[E0503]: cannot use `v[..]` because it was mutably borrowed\n    |\n LL |         let x = &mut v;\n    |                      - borrow of `v` occurs here\n-LL |         match v { //[mir]~ ERROR cannot use `v` because it was mutably borrowed\n+LL |         match v {\n LL |             &[x..] => println!(\"{:?}\", x),\n    |               ^ use of borrowed `v`\n \n@@ -157,7 +157,7 @@ error[E0502]: cannot borrow `e.0` as immutable because `e` is also borrowed as m\n    |\n LL |         let x = &mut e;\n    |                      - mutable borrow occurs here\n-LL |         match e { //[mir]~ ERROR cannot use `e` because it was mutably borrowed\n+LL |         match e {\n LL |             E::A(ref ax) =>\n    |                  ^^^^^^ immutable borrow occurs here\n ...\n@@ -181,7 +181,7 @@ error[E0502]: cannot borrow `s.y.0` as immutable because `s` is also borrowed as\n    |\n LL |         let x = &mut s;\n    |                      - mutable borrow occurs here\n-LL |         match s { //[mir]~ ERROR cannot use `s` because it was mutably borrowed\n+LL |         match s {\n LL |             S  { y: (ref y0, _), .. } =>\n    |                      ^^^^^^ immutable borrow occurs here\n ..."}, {"sha": "e417dadf6df163efebbf9d4694bee5095f00a1dd", "filename": "src/test/ui/borrowck/borrowck-describe-lvalue.mir.stderr", "status": "modified", "additions": 9, "deletions": 170, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-describe-lvalue.mir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-describe-lvalue.mir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-describe-lvalue.mir.stderr?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -72,23 +72,12 @@ LL |              //[mir]~^ ERROR cannot use `h.0` because it was mutably borrow\n LL |         drop(x);\n    |              - borrow later used here\n \n-error[E0503]: cannot use `e` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:77:15\n-   |\n-LL |         let x = e.x();\n-   |                 - borrow of `e` occurs here\n-LL |         match e { //[mir]~ ERROR cannot use `e` because it was mutably borrowed\n-   |               ^ use of borrowed `e`\n-...\n-LL |         drop(x);\n-   |              - borrow later used here\n-\n error[E0503]: cannot use `e.0` because it was mutably borrowed\n   --> $DIR/borrowck-describe-lvalue.rs:78:20\n    |\n LL |         let x = e.x();\n    |                 - borrow of `e` occurs here\n-LL |         match e { //[mir]~ ERROR cannot use `e` because it was mutably borrowed\n+LL |         match e {\n LL |             Baz::X(value) => value\n    |                    ^^^^^ use of borrowed `e`\n ...\n@@ -139,23 +128,12 @@ LL |              //[mir]~^ ERROR cannot use `h.0` because it was mutably borrow\n LL |         drop(x);\n    |              - borrow later used here\n \n-error[E0503]: cannot use `*e` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:120:15\n-   |\n-LL |         let x = e.x();\n-   |                 - borrow of `*e` occurs here\n-LL |         match *e { //[mir]~ ERROR cannot use `*e` because it was mutably borrowed\n-   |               ^^ use of borrowed `*e`\n-...\n-LL |         drop(x);\n-   |              - borrow later used here\n-\n error[E0503]: cannot use `e.0` because it was mutably borrowed\n   --> $DIR/borrowck-describe-lvalue.rs:121:20\n    |\n LL |         let x = e.x();\n    |                 - borrow of `*e` occurs here\n-LL |         match *e { //[mir]~ ERROR cannot use `*e` because it was mutably borrowed\n+LL |         match *e {\n LL |             Baz::X(value) => value\n    |                    ^^^^^ use of borrowed `*e`\n ...\n@@ -173,41 +151,18 @@ LL |              //[mir]~^ ERROR cannot use `u.a` because it was mutably borrow\n LL |         drop(x);\n    |              - borrow later used here\n \n-error[E0503]: cannot use `v` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:139:15\n-   |\n-LL |         let x = &mut v;\n-   |                 ------ borrow of `v` occurs here\n-LL |         match v { //[mir]~ ERROR cannot use `v` because it was mutably borrowed\n-   |               ^ use of borrowed `v`\n-...\n-LL |         drop(x);\n-   |              - borrow later used here\n-\n error[E0503]: cannot use `v[..]` because it was mutably borrowed\n   --> $DIR/borrowck-describe-lvalue.rs:140:15\n    |\n LL |         let x = &mut v;\n    |                 ------ borrow of `v` occurs here\n-LL |         match v { //[mir]~ ERROR cannot use `v` because it was mutably borrowed\n+LL |         match v {\n LL |             &[x, _, .., _, _] => println!(\"{}\", x),\n    |               ^ use of borrowed `v`\n ...\n LL |         drop(x);\n    |              - borrow later used here\n \n-error[E0503]: cannot use `v` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:145:15\n-   |\n-LL |         let x = &mut v;\n-   |                 ------ borrow of `v` occurs here\n-...\n-LL |         match v { //[mir]~ ERROR cannot use `v` because it was mutably borrowed\n-   |               ^ use of borrowed `v`\n-...\n-LL |         drop(x);\n-   |              - borrow later used here\n-\n error[E0503]: cannot use `v[..]` because it was mutably borrowed\n   --> $DIR/borrowck-describe-lvalue.rs:146:18\n    |\n@@ -220,18 +175,6 @@ LL |             &[_, x, .., _, _] => println!(\"{}\", x),\n LL |         drop(x);\n    |              - borrow later used here\n \n-error[E0503]: cannot use `v` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:151:15\n-   |\n-LL |         let x = &mut v;\n-   |                 ------ borrow of `v` occurs here\n-...\n-LL |         match v { //[mir]~ ERROR cannot use `v` because it was mutably borrowed\n-   |               ^ use of borrowed `v`\n-...\n-LL |         drop(x);\n-   |              - borrow later used here\n-\n error[E0503]: cannot use `v[..]` because it was mutably borrowed\n   --> $DIR/borrowck-describe-lvalue.rs:152:25\n    |\n@@ -244,18 +187,6 @@ LL |             &[_, _, .., x, _] => println!(\"{}\", x),\n LL |         drop(x);\n    |              - borrow later used here\n \n-error[E0503]: cannot use `v` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:157:15\n-   |\n-LL |         let x = &mut v;\n-   |                 ------ borrow of `v` occurs here\n-...\n-LL |         match v { //[mir]~ ERROR cannot use `v` because it was mutably borrowed\n-   |               ^ use of borrowed `v`\n-...\n-LL |         drop(x);\n-   |              - borrow later used here\n-\n error[E0503]: cannot use `v[..]` because it was mutably borrowed\n   --> $DIR/borrowck-describe-lvalue.rs:158:28\n    |\n@@ -268,41 +199,18 @@ LL |             &[_, _, .., _, x] => println!(\"{}\", x),\n LL |         drop(x);\n    |              - borrow later used here\n \n-error[E0503]: cannot use `v` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:169:15\n-   |\n-LL |         let x = &mut v;\n-   |                 ------ borrow of `v` occurs here\n-LL |         match v { //[mir]~ ERROR cannot use `v` because it was mutably borrowed\n-   |               ^ use of borrowed `v`\n-...\n-LL |         drop(x);\n-   |              - borrow later used here\n-\n error[E0503]: cannot use `v[..]` because it was mutably borrowed\n   --> $DIR/borrowck-describe-lvalue.rs:170:15\n    |\n LL |         let x = &mut v;\n    |                 ------ borrow of `v` occurs here\n-LL |         match v { //[mir]~ ERROR cannot use `v` because it was mutably borrowed\n+LL |         match v {\n LL |             &[x..] => println!(\"{:?}\", x),\n    |               ^ use of borrowed `v`\n ...\n LL |         drop(x);\n    |              - borrow later used here\n \n-error[E0503]: cannot use `v` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:175:15\n-   |\n-LL |         let x = &mut v;\n-   |                 ------ borrow of `v` occurs here\n-...\n-LL |         match v { //[mir]~ ERROR cannot use `v` because it was mutably borrowed\n-   |               ^ use of borrowed `v`\n-...\n-LL |         drop(x);\n-   |              - borrow later used here\n-\n error[E0503]: cannot use `v[..]` because it was mutably borrowed\n   --> $DIR/borrowck-describe-lvalue.rs:176:18\n    |\n@@ -315,18 +223,6 @@ LL |             &[_, x..] => println!(\"{:?}\", x),\n LL |         drop(x);\n    |              - borrow later used here\n \n-error[E0503]: cannot use `v` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:181:15\n-   |\n-LL |         let x = &mut v;\n-   |                 ------ borrow of `v` occurs here\n-...\n-LL |         match v { //[mir]~ ERROR cannot use `v` because it was mutably borrowed\n-   |               ^ use of borrowed `v`\n-...\n-LL |         drop(x);\n-   |              - borrow later used here\n-\n error[E0503]: cannot use `v[..]` because it was mutably borrowed\n   --> $DIR/borrowck-describe-lvalue.rs:182:15\n    |\n@@ -339,18 +235,6 @@ LL |             &[x.., _] => println!(\"{:?}\", x),\n LL |         drop(x);\n    |              - borrow later used here\n \n-error[E0503]: cannot use `v` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:187:15\n-   |\n-LL |         let x = &mut v;\n-   |                 ------ borrow of `v` occurs here\n-...\n-LL |         match v { //[mir]~ ERROR cannot use `v` because it was mutably borrowed\n-   |               ^ use of borrowed `v`\n-...\n-LL |         drop(x);\n-   |              - borrow later used here\n-\n error[E0503]: cannot use `v[..]` because it was mutably borrowed\n   --> $DIR/borrowck-describe-lvalue.rs:188:18\n    |\n@@ -363,23 +247,12 @@ LL |             &[_, x.., _] => println!(\"{:?}\", x),\n LL |         drop(x);\n    |              - borrow later used here\n \n-error[E0503]: cannot use `e` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:201:15\n-   |\n-LL |         let x = &mut e;\n-   |                 ------ borrow of `e` occurs here\n-LL |         match e { //[mir]~ ERROR cannot use `e` because it was mutably borrowed\n-   |               ^ use of borrowed `e`\n-...\n-LL |         drop(x);\n-   |              - borrow later used here\n-\n error[E0503]: cannot use `e` because it was mutably borrowed\n   --> $DIR/borrowck-describe-lvalue.rs:202:13\n    |\n LL |         let x = &mut e;\n    |                 ------ borrow of `e` occurs here\n-LL |         match e { //[mir]~ ERROR cannot use `e` because it was mutably borrowed\n+LL |         match e {\n LL |             E::A(ref ax) =>\n    |             ^^^^^^^^^^^^ use of borrowed `e`\n ...\n@@ -391,7 +264,7 @@ error[E0502]: cannot borrow `e.0` as immutable because it is also borrowed as mu\n    |\n LL |         let x = &mut e;\n    |                 ------ mutable borrow occurs here\n-LL |         match e { //[mir]~ ERROR cannot use `e` because it was mutably borrowed\n+LL |         match e {\n LL |             E::A(ref ax) =>\n    |                  ^^^^^^ immutable borrow occurs here\n ...\n@@ -410,41 +283,18 @@ LL |             E::B { x: ref bx } =>\n LL |         drop(x);\n    |              - borrow later used here\n \n-error[E0503]: cannot use `s` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:220:15\n-   |\n-LL |         let x = &mut s;\n-   |                 ------ borrow of `s` occurs here\n-LL |         match s { //[mir]~ ERROR cannot use `s` because it was mutably borrowed\n-   |               ^ use of borrowed `s`\n-...\n-LL |         drop(x);\n-   |              - borrow later used here\n-\n error[E0502]: cannot borrow `s.y.0` as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-describe-lvalue.rs:221:22\n    |\n LL |         let x = &mut s;\n    |                 ------ mutable borrow occurs here\n-LL |         match s { //[mir]~ ERROR cannot use `s` because it was mutably borrowed\n+LL |         match s {\n LL |             S  { y: (ref y0, _), .. } =>\n    |                      ^^^^^^ immutable borrow occurs here\n ...\n LL |         drop(x);\n    |              - borrow later used here\n \n-error[E0503]: cannot use `s` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:227:15\n-   |\n-LL |         let x = &mut s;\n-   |                 ------ borrow of `s` occurs here\n-...\n-LL |         match s { //[mir]~ ERROR cannot use `s` because it was mutably borrowed\n-   |               ^ use of borrowed `s`\n-...\n-LL |         drop(x);\n-   |              - borrow later used here\n-\n error[E0502]: cannot borrow `s.x.y` as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-describe-lvalue.rs:228:28\n    |\n@@ -479,23 +329,12 @@ LL |         v[0].y;\n LL |         drop(x);\n    |              - borrow later used here\n \n-error[E0503]: cannot use `v` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:282:15\n-   |\n-LL |         let x = &mut v;\n-   |                 ------ borrow of `v` occurs here\n-LL |         match v { //[mir]~ ERROR cannot use `v` because it was mutably borrowed\n-   |               ^ use of borrowed `v`\n-...\n-LL |         drop(x);\n-   |              - borrow later used here\n-\n error[E0502]: cannot borrow `v[..].x` as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-describe-lvalue.rs:283:24\n    |\n LL |         let x = &mut v;\n    |                 ------ mutable borrow occurs here\n-LL |         match v { //[mir]~ ERROR cannot use `v` because it was mutably borrowed\n+LL |         match v {\n LL |             &[_, F {x: ref xf, ..}] => println!(\"{}\", xf),\n    |                        ^^^^^^ immutable borrow occurs here\n ...\n@@ -534,7 +373,7 @@ LL |                 drop(x); //[ast]~ ERROR use of moved value: `x`\n    |\n    = note: move occurs because `x` has type `std::vec::Vec<i32>`, which does not implement the `Copy` trait\n \n-error: aborting due to 46 previous errors\n+error: aborting due to 32 previous errors\n \n Some errors occurred: E0382, E0499, E0502, E0503.\n For more information about an error, try `rustc --explain E0382`."}, {"sha": "2ef08e75cfda3898baf185f7daad39f9ef7d5a9b", "filename": "src/test/ui/borrowck/borrowck-describe-lvalue.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-describe-lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-describe-lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-describe-lvalue.rs?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -74,7 +74,7 @@ fn main() {\n     {\n         let mut e = Baz::X(2);\n         let x = e.x();\n-        match e { //[mir]~ ERROR cannot use `e` because it was mutably borrowed\n+        match e {\n             Baz::X(value) => value\n             //[ast]~^ ERROR cannot use `e.0` because it was mutably borrowed\n             //[mir]~^^ ERROR cannot use `e.0` because it was mutably borrowed\n@@ -117,7 +117,7 @@ fn main() {\n     {\n         let mut e = Box::new(Baz::X(3));\n         let x = e.x();\n-        match *e { //[mir]~ ERROR cannot use `*e` because it was mutably borrowed\n+        match *e {\n             Baz::X(value) => value\n             //[ast]~^ ERROR cannot use `e.0` because it was mutably borrowed\n             //[mir]~^^ ERROR cannot use `e.0` because it was mutably borrowed\n@@ -136,25 +136,25 @@ fn main() {\n     {\n         let mut v = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n         let x = &mut v;\n-        match v { //[mir]~ ERROR cannot use `v` because it was mutably borrowed\n+        match v {\n             &[x, _, .., _, _] => println!(\"{}\", x),\n                 //[ast]~^ ERROR cannot use `v[..]` because it was mutably borrowed\n                 //[mir]~^^ ERROR cannot use `v[..]` because it was mutably borrowed\n                             _ => panic!(\"other case\"),\n         }\n-        match v { //[mir]~ ERROR cannot use `v` because it was mutably borrowed\n+        match v {\n             &[_, x, .., _, _] => println!(\"{}\", x),\n                 //[ast]~^ ERROR cannot use `v[..]` because it was mutably borrowed\n                 //[mir]~^^ ERROR cannot use `v[..]` because it was mutably borrowed\n                             _ => panic!(\"other case\"),\n         }\n-        match v { //[mir]~ ERROR cannot use `v` because it was mutably borrowed\n+        match v {\n             &[_, _, .., x, _] => println!(\"{}\", x),\n                 //[ast]~^ ERROR cannot use `v[..]` because it was mutably borrowed\n                 //[mir]~^^ ERROR cannot use `v[..]` because it was mutably borrowed\n                             _ => panic!(\"other case\"),\n         }\n-        match v { //[mir]~ ERROR cannot use `v` because it was mutably borrowed\n+        match v {\n             &[_, _, .., _, x] => println!(\"{}\", x),\n                 //[ast]~^ ERROR cannot use `v[..]` because it was mutably borrowed\n                 //[mir]~^^ ERROR cannot use `v[..]` because it was mutably borrowed\n@@ -166,25 +166,25 @@ fn main() {\n     {\n         let mut v = &[1, 2, 3, 4, 5];\n         let x = &mut v;\n-        match v { //[mir]~ ERROR cannot use `v` because it was mutably borrowed\n+        match v {\n             &[x..] => println!(\"{:?}\", x),\n                 //[ast]~^ ERROR cannot use `v[..]` because it was mutably borrowed\n                 //[mir]~^^ ERROR cannot use `v[..]` because it was mutably borrowed\n             _ => panic!(\"other case\"),\n         }\n-        match v { //[mir]~ ERROR cannot use `v` because it was mutably borrowed\n+        match v {\n             &[_, x..] => println!(\"{:?}\", x),\n                 //[ast]~^ ERROR cannot use `v[..]` because it was mutably borrowed\n                 //[mir]~^^ ERROR cannot use `v[..]` because it was mutably borrowed\n             _ => panic!(\"other case\"),\n         }\n-        match v { //[mir]~ ERROR cannot use `v` because it was mutably borrowed\n+        match v {\n             &[x.., _] => println!(\"{:?}\", x),\n                 //[ast]~^ ERROR cannot use `v[..]` because it was mutably borrowed\n                 //[mir]~^^ ERROR cannot use `v[..]` because it was mutably borrowed\n             _ => panic!(\"other case\"),\n         }\n-        match v { //[mir]~ ERROR cannot use `v` because it was mutably borrowed\n+        match v {\n             &[_, x.., _] => println!(\"{:?}\", x),\n                 //[ast]~^ ERROR cannot use `v[..]` because it was mutably borrowed\n                 //[mir]~^^ ERROR cannot use `v[..]` because it was mutably borrowed\n@@ -198,7 +198,7 @@ fn main() {\n \n         let mut e = E::A(3);\n         let x = &mut e;\n-        match e { //[mir]~ ERROR cannot use `e` because it was mutably borrowed\n+        match e {\n             E::A(ref ax) =>\n                 //[ast]~^ ERROR cannot borrow `e.0` as immutable because `e` is also borrowed as mutable\n                 //[mir]~^^ ERROR cannot borrow `e.0` as immutable because it is also borrowed as mutable\n@@ -217,14 +217,14 @@ fn main() {\n         struct S { x: F, y: (u32, u32), };\n         let mut s = S { x: F { x: 1, y: 2}, y: (999, 998) };\n         let x = &mut s;\n-        match s { //[mir]~ ERROR cannot use `s` because it was mutably borrowed\n+        match s {\n             S  { y: (ref y0, _), .. } =>\n                 //[ast]~^ ERROR cannot borrow `s.y.0` as immutable because `s` is also borrowed as mutable\n                 //[mir]~^^ ERROR cannot borrow `s.y.0` as immutable because it is also borrowed as mutable\n                 println!(\"y0: {:?}\", y0),\n             _ => panic!(\"other case\"),\n         }\n-        match s { //[mir]~ ERROR cannot use `s` because it was mutably borrowed\n+        match s {\n             S  { x: F { y: ref x0, .. }, .. } =>\n                 //[ast]~^ ERROR cannot borrow `s.x.y` as immutable because `s` is also borrowed as mutable\n                 //[mir]~^^ ERROR cannot borrow `s.x.y` as immutable because it is also borrowed as mutable\n@@ -279,7 +279,7 @@ fn main() {\n         struct F {x: u32, y: u32};\n         let mut v = &[F{x: 1, y: 2}, F{x: 3, y: 4}];\n         let x = &mut v;\n-        match v { //[mir]~ ERROR cannot use `v` because it was mutably borrowed\n+        match v {\n             &[_, F {x: ref xf, ..}] => println!(\"{}\", xf),\n             //[mir]~^ ERROR cannot borrow `v[..].x` as immutable because it is also borrowed as mutable\n             // No errors in AST"}, {"sha": "0853018bae9428f5d7b5c5a64e2201d64de9daa5", "filename": "src/test/ui/borrowck/borrowck-match-already-borrowed.ast.nll.stderr", "status": "modified", "additions": 3, "deletions": 25, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-match-already-borrowed.ast.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-match-already-borrowed.ast.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-match-already-borrowed.ast.nll.stderr?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -1,20 +1,9 @@\n-error[E0503]: cannot use `foo` because it was mutably borrowed\n-  --> $DIR/borrowck-match-already-borrowed.rs:22:19\n-   |\n-LL |     let p = &mut foo;\n-   |             -------- borrow of `foo` occurs here\n-LL |     let _ = match foo { //[mir]~ ERROR [E0503]\n-   |                   ^^^ use of borrowed `foo`\n-...\n-LL |     drop(p);\n-   |          - borrow later used here\n-\n error[E0503]: cannot use `foo` because it was mutably borrowed\n   --> $DIR/borrowck-match-already-borrowed.rs:23:9\n    |\n LL |     let p = &mut foo;\n    |             -------- borrow of `foo` occurs here\n-LL |     let _ = match foo { //[mir]~ ERROR [E0503]\n+LL |     let _ = match foo {\n LL |         Foo::B => 1, //[mir]~ ERROR [E0503]\n    |         ^^^^^^ use of borrowed `foo`\n ...\n@@ -33,23 +22,12 @@ LL |         Foo::A(x) => x //[ast]~ ERROR [E0503]\n LL |     drop(p);\n    |          - borrow later used here\n \n-error[E0503]: cannot use `x` because it was mutably borrowed\n-  --> $DIR/borrowck-match-already-borrowed.rs:35:19\n-   |\n-LL |     let r = &mut x;\n-   |             ------ borrow of `x` occurs here\n-LL |     let _ = match x { //[mir]~ ERROR [E0503]\n-   |                   ^ use of borrowed `x`\n-...\n-LL |     drop(r);\n-   |          - borrow later used here\n-\n error[E0503]: cannot use `x` because it was mutably borrowed\n   --> $DIR/borrowck-match-already-borrowed.rs:36:9\n    |\n LL |     let r = &mut x;\n    |             ------ borrow of `x` occurs here\n-LL |     let _ = match x { //[mir]~ ERROR [E0503]\n+LL |     let _ = match x {\n LL |         x => x + 1, //[ast]~ ERROR [E0503]\n    |         ^ use of borrowed `x`\n ...\n@@ -68,6 +46,6 @@ LL |         y => y + 2, //[ast]~ ERROR [E0503]\n LL |     drop(r);\n    |          - borrow later used here\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0503`."}, {"sha": "5ba2f26e2203a6b52e0cb1de5418234a6ea22b82", "filename": "src/test/ui/borrowck/borrowck-match-already-borrowed.ast.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-match-already-borrowed.ast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-match-already-borrowed.ast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-match-already-borrowed.ast.stderr?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -12,7 +12,7 @@ error[E0503]: cannot use `x` because it was mutably borrowed\n    |\n LL |     let r = &mut x;\n    |                  - borrow of `x` occurs here\n-LL |     let _ = match x { //[mir]~ ERROR [E0503]\n+LL |     let _ = match x {\n LL |         x => x + 1, //[ast]~ ERROR [E0503]\n    |         ^ use of borrowed `x`\n "}, {"sha": "0853018bae9428f5d7b5c5a64e2201d64de9daa5", "filename": "src/test/ui/borrowck/borrowck-match-already-borrowed.mir.stderr", "status": "modified", "additions": 3, "deletions": 25, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-match-already-borrowed.mir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-match-already-borrowed.mir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-match-already-borrowed.mir.stderr?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -1,20 +1,9 @@\n-error[E0503]: cannot use `foo` because it was mutably borrowed\n-  --> $DIR/borrowck-match-already-borrowed.rs:22:19\n-   |\n-LL |     let p = &mut foo;\n-   |             -------- borrow of `foo` occurs here\n-LL |     let _ = match foo { //[mir]~ ERROR [E0503]\n-   |                   ^^^ use of borrowed `foo`\n-...\n-LL |     drop(p);\n-   |          - borrow later used here\n-\n error[E0503]: cannot use `foo` because it was mutably borrowed\n   --> $DIR/borrowck-match-already-borrowed.rs:23:9\n    |\n LL |     let p = &mut foo;\n    |             -------- borrow of `foo` occurs here\n-LL |     let _ = match foo { //[mir]~ ERROR [E0503]\n+LL |     let _ = match foo {\n LL |         Foo::B => 1, //[mir]~ ERROR [E0503]\n    |         ^^^^^^ use of borrowed `foo`\n ...\n@@ -33,23 +22,12 @@ LL |         Foo::A(x) => x //[ast]~ ERROR [E0503]\n LL |     drop(p);\n    |          - borrow later used here\n \n-error[E0503]: cannot use `x` because it was mutably borrowed\n-  --> $DIR/borrowck-match-already-borrowed.rs:35:19\n-   |\n-LL |     let r = &mut x;\n-   |             ------ borrow of `x` occurs here\n-LL |     let _ = match x { //[mir]~ ERROR [E0503]\n-   |                   ^ use of borrowed `x`\n-...\n-LL |     drop(r);\n-   |          - borrow later used here\n-\n error[E0503]: cannot use `x` because it was mutably borrowed\n   --> $DIR/borrowck-match-already-borrowed.rs:36:9\n    |\n LL |     let r = &mut x;\n    |             ------ borrow of `x` occurs here\n-LL |     let _ = match x { //[mir]~ ERROR [E0503]\n+LL |     let _ = match x {\n LL |         x => x + 1, //[ast]~ ERROR [E0503]\n    |         ^ use of borrowed `x`\n ...\n@@ -68,6 +46,6 @@ LL |         y => y + 2, //[ast]~ ERROR [E0503]\n LL |     drop(r);\n    |          - borrow later used here\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0503`."}, {"sha": "cabce08429e57a5a7232f4e40c52e1ed6fa5c557", "filename": "src/test/ui/borrowck/borrowck-match-already-borrowed.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-match-already-borrowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-match-already-borrowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-match-already-borrowed.rs?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -19,7 +19,7 @@ enum Foo {\n fn match_enum() {\n     let mut foo = Foo::B;\n     let p = &mut foo;\n-    let _ = match foo { //[mir]~ ERROR [E0503]\n+    let _ = match foo {\n         Foo::B => 1, //[mir]~ ERROR [E0503]\n         _ => 2,\n         Foo::A(x) => x //[ast]~ ERROR [E0503]\n@@ -32,7 +32,7 @@ fn match_enum() {\n fn main() {\n     let mut x = 1;\n     let r = &mut x;\n-    let _ = match x { //[mir]~ ERROR [E0503]\n+    let _ = match x {\n         x => x + 1, //[ast]~ ERROR [E0503]\n                     //[mir]~^ ERROR [E0503]\n         y => y + 2, //[ast]~ ERROR [E0503]"}, {"sha": "86287e1299729f14fcb5b6ae61ffc3d43cf44c12", "filename": "src/test/ui/consts/const-eval/conditional_array_execution.nll.stderr", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/5c875d93855c6d577962b0f74f17374f37b219c9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconditional_array_execution.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c875d93855c6d577962b0f74f17374f37b219c9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconditional_array_execution.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconditional_array_execution.nll.stderr?ref=5c875d93855c6d577962b0f74f17374f37b219c9", "patch": "@@ -1,47 +0,0 @@\n-warning: this constant cannot be used\n-  --> $DIR/conditional_array_execution.rs:15:1\n-   |\n-LL | const FOO: u32 = [X - Y, Y - X][(X < Y) as usize];\n-   | ^^^^^^^^^^^^^^^^^^-----^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |                   |\n-   |                   attempt to subtract with overflow\n-   |\n-note: lint level defined here\n-  --> $DIR/conditional_array_execution.rs:11:9\n-   |\n-LL | #![warn(const_err)]\n-   |         ^^^^^^^^^\n-\n-error[E0080]: referenced constant has errors\n-  --> $DIR/conditional_array_execution.rs:19:14\n-   |\n-LL | const FOO: u32 = [X - Y, Y - X][(X < Y) as usize];\n-   |                   ----- attempt to subtract with overflow\n-...\n-LL |     println!(\"{}\", FOO);\n-   |              ^^^^\n-\n-error[E0080]: erroneous constant used\n-  --> $DIR/conditional_array_execution.rs:19:14\n-   |\n-LL |     println!(\"{}\", FOO);\n-   |              ^^^^  --- referenced constant has errors\n-\n-error[E0080]: referenced constant has errors\n-  --> $DIR/conditional_array_execution.rs:19:20\n-   |\n-LL | const FOO: u32 = [X - Y, Y - X][(X < Y) as usize];\n-   |                   ----- attempt to subtract with overflow\n-...\n-LL |     println!(\"{}\", FOO);\n-   |                    ^^^\n-\n-error[E0080]: erroneous constant used\n-  --> $DIR/conditional_array_execution.rs:19:20\n-   |\n-LL |     println!(\"{}\", FOO);\n-   |                    ^^^ referenced constant has errors\n-\n-error: aborting due to 4 previous errors\n-\n-For more information about this error, try `rustc --explain E0080`."}, {"sha": "732fe459834603d098f08a69efce47f1a999ac1c", "filename": "src/test/ui/consts/const-eval/issue-43197.nll.stderr", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/5c875d93855c6d577962b0f74f17374f37b219c9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-43197.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c875d93855c6d577962b0f74f17374f37b219c9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-43197.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-43197.nll.stderr?ref=5c875d93855c6d577962b0f74f17374f37b219c9", "patch": "@@ -1,70 +0,0 @@\n-warning: this constant cannot be used\n-  --> $DIR/issue-43197.rs:20:5\n-   |\n-LL |     const X: u32 = 0-1;\n-   |     ^^^^^^^^^^^^^^^---^\n-   |                    |\n-   |                    attempt to subtract with overflow\n-   |\n-note: lint level defined here\n-  --> $DIR/issue-43197.rs:11:9\n-   |\n-LL | #![warn(const_err)]\n-   |         ^^^^^^^^^\n-\n-warning: this constant cannot be used\n-  --> $DIR/issue-43197.rs:22:5\n-   |\n-LL |     const Y: u32 = foo(0-1);\n-   |     ^^^^^^^^^^^^^^^^^^^---^^\n-   |                        |\n-   |                        attempt to subtract with overflow\n-\n-error[E0080]: referenced constant has errors\n-  --> $DIR/issue-43197.rs:24:14\n-   |\n-LL |     const X: u32 = 0-1;\n-   |                    --- attempt to subtract with overflow\n-...\n-LL |     println!(\"{} {}\", X, Y);\n-   |              ^^^^^^^\n-\n-error[E0080]: erroneous constant used\n-  --> $DIR/issue-43197.rs:24:14\n-   |\n-LL |     println!(\"{} {}\", X, Y);\n-   |              ^^^^^^^  - referenced constant has errors\n-\n-error[E0080]: referenced constant has errors\n-  --> $DIR/issue-43197.rs:24:26\n-   |\n-LL |     const Y: u32 = foo(0-1);\n-   |                        --- attempt to subtract with overflow\n-LL |     //~^ WARN this constant cannot be used\n-LL |     println!(\"{} {}\", X, Y);\n-   |                          ^\n-\n-error[E0080]: erroneous constant used\n-  --> $DIR/issue-43197.rs:24:26\n-   |\n-LL |     println!(\"{} {}\", X, Y);\n-   |                          ^ referenced constant has errors\n-\n-error[E0080]: referenced constant has errors\n-  --> $DIR/issue-43197.rs:24:23\n-   |\n-LL |     const X: u32 = 0-1;\n-   |                    --- attempt to subtract with overflow\n-...\n-LL |     println!(\"{} {}\", X, Y);\n-   |                       ^\n-\n-error[E0080]: erroneous constant used\n-  --> $DIR/issue-43197.rs:24:23\n-   |\n-LL |     println!(\"{} {}\", X, Y);\n-   |                       ^ referenced constant has errors\n-\n-error: aborting due to 6 previous errors\n-\n-For more information about this error, try `rustc --explain E0080`."}, {"sha": "da040747991a418fd619964fb25b49f3638439d0", "filename": "src/test/ui/consts/const-eval/issue-44578.nll.stderr", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5c875d93855c6d577962b0f74f17374f37b219c9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-44578.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c875d93855c6d577962b0f74f17374f37b219c9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-44578.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-44578.nll.stderr?ref=5c875d93855c6d577962b0f74f17374f37b219c9", "patch": "@@ -1,33 +0,0 @@\n-error[E0080]: referenced constant has errors\n-  --> $DIR/issue-44578.rs:35:14\n-   |\n-LL |     const AMT: usize = [A::AMT][(A::AMT > B::AMT) as usize];\n-   |                        ------------------------------------ index out of bounds: the len is 1 but the index is 1\n-...\n-LL |     println!(\"{}\", <Bar<u16, u8> as Foo>::AMT);\n-   |              ^^^^\n-\n-error[E0080]: erroneous constant used\n-  --> $DIR/issue-44578.rs:35:14\n-   |\n-LL |     println!(\"{}\", <Bar<u16, u8> as Foo>::AMT);\n-   |              ^^^^  -------------------------- referenced constant has errors\n-\n-error[E0080]: referenced constant has errors\n-  --> $DIR/issue-44578.rs:35:20\n-   |\n-LL |     const AMT: usize = [A::AMT][(A::AMT > B::AMT) as usize];\n-   |                        ------------------------------------ index out of bounds: the len is 1 but the index is 1\n-...\n-LL |     println!(\"{}\", <Bar<u16, u8> as Foo>::AMT);\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0080]: erroneous constant used\n-  --> $DIR/issue-44578.rs:35:20\n-   |\n-LL |     println!(\"{}\", <Bar<u16, u8> as Foo>::AMT);\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^ referenced constant has errors\n-\n-error: aborting due to 4 previous errors\n-\n-For more information about this error, try `rustc --explain E0080`."}, {"sha": "909c369354bc377ea2d0b8e0c6861786a1b9abc9", "filename": "src/test/ui/issues/issue-27282-move-match-input-into-guard.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fissues%2Fissue-27282-move-match-input-into-guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fissues%2Fissue-27282-move-match-input-into-guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-27282-move-match-input-into-guard.rs?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -24,7 +24,6 @@ fn main() {\n     match b {\n         &mut false => {},\n         _ if { (|| { let bar = b; *bar = false; })();\n-                     //~^ ERROR cannot move out of `b` because it is borrowed [E0505]\n                      false } => { },\n         &mut true => { println!(\"You might think we should get here\"); },\n         //~^ ERROR use of moved value: `*b` [E0382]"}, {"sha": "0b783e37615ee93646a45f78e9fa7b26c52248bc", "filename": "src/test/ui/issues/issue-27282-move-match-input-into-guard.stderr", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fissues%2Fissue-27282-move-match-input-into-guard.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fissues%2Fissue-27282-move-match-input-into-guard.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-27282-move-match-input-into-guard.stderr?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -1,29 +1,14 @@\n-error[E0505]: cannot move out of `b` because it is borrowed\n-  --> $DIR/issue-27282-move-match-input-into-guard.rs:26:17\n-   |\n-LL |     match b {\n-   |           - borrow of `b` occurs here\n-LL |         &mut false => {},\n-LL |         _ if { (|| { let bar = b; *bar = false; })();\n-   |                 ^^             - move occurs due to use in closure\n-   |                 |\n-   |                 move out of `b` occurs here\n-...\n-LL |         &mut true => { println!(\"You might think we should get here\"); },\n-   |         --------- borrow later used here\n-\n error[E0382]: use of moved value: `*b`\n-  --> $DIR/issue-27282-move-match-input-into-guard.rs:29:14\n+  --> $DIR/issue-27282-move-match-input-into-guard.rs:28:14\n    |\n LL |         _ if { (|| { let bar = b; *bar = false; })();\n    |                 --             - variable moved due to use in closure\n    |                 |\n    |                 value moved into closure here\n-...\n+LL |                      false } => { },\n LL |         &mut true => { println!(\"You might think we should get here\"); },\n    |              ^^^^ value used here after move\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors occurred: E0382, E0505.\n-For more information about an error, try `rustc --explain E0382`.\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "2ebfb995d8ca97e6b6523d2c8de380dd32c9e475", "filename": "src/test/ui/issues/issue-27282-mutate-before-diverging-arm-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fissues%2Fissue-27282-mutate-before-diverging-arm-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fissues%2Fissue-27282-mutate-before-diverging-arm-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-27282-mutate-before-diverging-arm-1.rs?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -31,7 +31,7 @@ fn main() {\n         &mut Some(&_) if {\n             // ForceFnOnce needed to exploit #27282\n             (|| { *x = None; drop(force_fn_once); })();\n-            //~^ ERROR closure requires unique access to `x` but it is already borrowed [E0500]\n+            //~^ ERROR cannot mutably borrow `x` in match guard [E0510]\n             false\n         } => {}\n         &mut Some(&a) if { // this binds to garbage if we've corrupted discriminant"}, {"sha": "2ecbb25fd3e47a7eb8816be1d906c262f0643420", "filename": "src/test/ui/issues/issue-27282-mutate-before-diverging-arm-1.stderr", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fissues%2Fissue-27282-mutate-before-diverging-arm-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fissues%2Fissue-27282-mutate-before-diverging-arm-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-27282-mutate-before-diverging-arm-1.stderr?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -1,17 +1,14 @@\n-error[E0500]: closure requires unique access to `x` but it is already borrowed\n+error[E0510]: cannot mutably borrow `x` in match guard\n   --> $DIR/issue-27282-mutate-before-diverging-arm-1.rs:33:14\n    |\n LL |     match x {\n-   |           - borrow occurs here\n+   |           - value is immutable in match guard\n ...\n LL |             (|| { *x = None; drop(force_fn_once); })();\n-   |              ^^    - second borrow occurs due to use of `x` in closure\n+   |              ^^    - borrow occurs due to use of `x` in closure\n    |              |\n-   |              closure construction occurs here\n-...\n-LL |         &mut Some(&a) if { // this binds to garbage if we've corrupted discriminant\n-   |         ------------- borrow later used here\n+   |              cannot mutably borrow\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0500`.\n+For more information about this error, try `rustc --explain E0510`."}, {"sha": "6b50973e04d06f425809ba3101a9b1a788be91e2", "filename": "src/test/ui/issues/issue-27282-mutate-before-diverging-arm-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fissues%2Fissue-27282-mutate-before-diverging-arm-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fissues%2Fissue-27282-mutate-before-diverging-arm-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-27282-mutate-before-diverging-arm-2.rs?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -36,7 +36,7 @@ fn main() {\n             if {\n                 // ForceFnOnce needed to exploit #27282\n                 (|| { *x = None; drop(force_fn_once); })();\n-                //~^ ERROR closure requires unique access to `x` but it is already borrowed [E0500]\n+                //~^ ERROR cannot mutably borrow `x` in match guard [E0510]\n                 false\n             } => {}\n "}, {"sha": "6feef95300e05f72f96ca8d33030914acaebea48", "filename": "src/test/ui/issues/issue-27282-mutate-before-diverging-arm-2.stderr", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fissues%2Fissue-27282-mutate-before-diverging-arm-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fissues%2Fissue-27282-mutate-before-diverging-arm-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-27282-mutate-before-diverging-arm-2.stderr?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -1,17 +1,14 @@\n-error[E0500]: closure requires unique access to `x` but it is already borrowed\n+error[E0510]: cannot mutably borrow `x` in match guard\n   --> $DIR/issue-27282-mutate-before-diverging-arm-2.rs:38:18\n    |\n LL |     match x {\n-   |           - borrow occurs here\n+   |           - value is immutable in match guard\n ...\n LL |                 (|| { *x = None; drop(force_fn_once); })();\n-   |                  ^^    - second borrow occurs due to use of `x` in closure\n+   |                  ^^    - borrow occurs due to use of `x` in closure\n    |                  |\n-   |                  closure construction occurs here\n-...\n-LL |         &mut Some(&2)\n-   |         ------------- borrow later used here\n+   |                  cannot mutably borrow\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0500`.\n+For more information about this error, try `rustc --explain E0510`."}, {"sha": "4cf5bcd6b4f683fb71cea3ab0c5a3ac3451685eb", "filename": "src/test/ui/issues/issue-27282-mutate-before-diverging-arm-3.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fissues%2Fissue-27282-mutate-before-diverging-arm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fissues%2Fissue-27282-mutate-before-diverging-arm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-27282-mutate-before-diverging-arm-3.rs?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -0,0 +1,30 @@\n+// This is testing an attempt to corrupt the discriminant of the match\n+// arm in a guard, followed by an attempt to continue matching on that\n+// corrupted discriminant in the remaining match arms.\n+//\n+// Basically this is testing that our new NLL feature of emitting a\n+// fake read on each match arm is catching cases like this.\n+//\n+// This case is interesting because a borrow of **x is untracked, because **x is\n+// immutable. However, for matches we care that **x refers to the same value\n+// until we have chosen a match arm.\n+#![feature(nll)]\n+struct ForceFnOnce;\n+fn main() {\n+    let mut x = &mut &Some(&2);\n+    let force_fn_once = ForceFnOnce;\n+    match **x {\n+        None => panic!(\"unreachable\"),\n+        Some(&_) if {\n+            // ForceFnOnce needed to exploit #27282\n+            (|| { *x = &None; drop(force_fn_once); })();\n+            //~^ ERROR cannot mutably borrow `x` in match guard [E0510]\n+            false\n+        } => {}\n+        Some(&a) if { // this binds to garbage if we've corrupted discriminant\n+            println!(\"{}\", a);\n+            panic!()\n+        } => {}\n+        _ => panic!(\"unreachable\"),\n+    }\n+}"}, {"sha": "f46a42d7508176853d3c7e07edc9abd4b075008c", "filename": "src/test/ui/issues/issue-27282-mutate-before-diverging-arm-3.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fissues%2Fissue-27282-mutate-before-diverging-arm-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fissues%2Fissue-27282-mutate-before-diverging-arm-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-27282-mutate-before-diverging-arm-3.stderr?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -0,0 +1,14 @@\n+error[E0510]: cannot mutably borrow `x` in match guard\n+  --> $DIR/issue-27282-mutate-before-diverging-arm-3.rs:20:14\n+   |\n+LL |     match **x {\n+   |           --- value is immutable in match guard\n+...\n+LL |             (|| { *x = &None; drop(force_fn_once); })();\n+   |              ^^    - borrow occurs due to use of `x` in closure\n+   |              |\n+   |              cannot mutably borrow\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0510`."}, {"sha": "8688bfa86dc6f069af46c5320f0c470c54fa78f3", "filename": "src/test/ui/nll/borrowed-match-issue-45045.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fnll%2Fborrowed-match-issue-45045.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fnll%2Fborrowed-match-issue-45045.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fborrowed-match-issue-45045.rs?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -21,7 +21,7 @@ fn main() {\n     let mut e = Xyz::A;\n     let f = &mut e;\n     let g = f;\n-    match e { //~ cannot use `e` because it was mutably borrowed [E0503]\n+    match e {\n         Xyz::A => println!(\"a\"),\n         //~^ cannot use `e` because it was mutably borrowed [E0503]\n         Xyz::B => println!(\"b\"),"}, {"sha": "ded773165c6fe7e709c00e08476dbf48e6776f3c", "filename": "src/test/ui/nll/borrowed-match-issue-45045.stderr", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fnll%2Fborrowed-match-issue-45045.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fnll%2Fborrowed-match-issue-45045.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fborrowed-match-issue-45045.stderr?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -1,15 +1,3 @@\n-error[E0503]: cannot use `e` because it was mutably borrowed\n-  --> $DIR/borrowed-match-issue-45045.rs:24:11\n-   |\n-LL |     let f = &mut e;\n-   |             ------ borrow of `e` occurs here\n-LL |     let g = f;\n-LL |     match e { //~ cannot use `e` because it was mutably borrowed [E0503]\n-   |           ^ use of borrowed `e`\n-...\n-LL |     *g = Xyz::B;\n-   |     ----------- borrow later used here\n-\n error[E0503]: cannot use `e` because it was mutably borrowed\n   --> $DIR/borrowed-match-issue-45045.rs:25:9\n    |\n@@ -22,6 +10,6 @@ LL |         Xyz::A => println!(\"a\"),\n LL |     *g = Xyz::B;\n    |     ----------- borrow later used here\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0503`."}, {"sha": "49846f620f0c010cbfd339f3d2a9651a54074679", "filename": "src/test/ui/nll/match-guards-partially-borrow.rs", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fnll%2Fmatch-guards-partially-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fnll%2Fmatch-guards-partially-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmatch-guards-partially-borrow.rs?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -0,0 +1,164 @@\n+// Test that a (partially) mutably borrowed place can be matched on, so long as\n+// we don't have to read any values that are mutably borrowed to determine\n+// which arm to take.\n+//\n+// Test that we don't allow mutating the value being matched on in a way that\n+// changes which patterns it matches, until we have chosen an arm.\n+\n+// compile-flags: -Zdisable-ast-check-for-mutation-in-guard\n+\n+#![feature(nll)]\n+\n+fn ok_mutation_in_guard(mut q: i32) {\n+    match q {\n+        // OK, mutation doesn't change which patterns g matches\n+        _ if { q = 1; false } => (),\n+        _ => (),\n+    }\n+}\n+\n+fn ok_indirect_mutation_in_guard(mut p: &bool) {\n+    match *p {\n+        // OK, mutation doesn't change which patterns s matches\n+        _ if {\n+            p = &true;\n+            false\n+        } => (),\n+        _ => (),\n+    }\n+}\n+\n+fn mutation_invalidates_pattern_in_guard(mut q: bool) {\n+    match q {\n+        // s doesn't match the pattern with the guard by the end of the guard.\n+        false if {\n+            q = true; //~ ERROR\n+            true\n+        } => (),\n+        _ => (),\n+    }\n+}\n+\n+fn mutation_invalidates_previous_pattern_in_guard(mut r: bool) {\n+    match r {\n+        // s matches a previous pattern by the end of the guard.\n+        true => (),\n+        _ if {\n+            r = true; //~ ERROR\n+            true\n+        } => (),\n+        _ => (),\n+    }\n+}\n+\n+fn match_on_borrowed_early_end(mut s: bool) {\n+    let h = &mut s;\n+    match s { //~ ERROR\n+        // s changes value between the start of the match and when its value is checked.\n+        _ if {\n+            *h = !*h;\n+            false\n+        } => (),\n+        true => (),\n+        false => (),\n+    }\n+}\n+\n+fn bad_mutation_in_guard(mut t: bool) {\n+    match t {\n+        true => (),\n+        false if {\n+            t = true; //~ ERROR\n+            false\n+        } => (),\n+        false => (),\n+    }\n+}\n+\n+fn bad_mutation_in_guard2(mut u: bool) {\n+    match u {\n+        // Guard changes the value bound in the last pattern.\n+        _ => (),\n+        _ if {\n+            u = true; //~ ERROR\n+            false\n+        } => (),\n+        x => (),\n+    }\n+}\n+\n+pub fn bad_mutation_in_guard3(mut x: Option<Option<&i32>>) {\n+    // Check that nested patterns are checked.\n+    match x {\n+        None => (),\n+        Some(None) => (),\n+        _ if {\n+            match x {\n+                Some(ref mut r) => *r = None, //~ ERROR\n+                _ => return,\n+            };\n+            false\n+        } => (),\n+        Some(Some(r)) => println!(\"{}\", r),\n+    }\n+}\n+\n+\n+fn bad_mutation_in_guard4(mut w: (&mut bool,)) {\n+    match w {\n+        // Guard changes the value bound in the last pattern.\n+        _ => (),\n+        _ if {\n+            *w.0 = true; //~ ERROR\n+            false\n+        } => (),\n+        x => (),\n+    }\n+}\n+\n+fn bad_indirect_mutation_in_guard(mut y: &bool) {\n+    match *y {\n+        true => (),\n+        false if {\n+            y = &true; //~ ERROR\n+            false\n+        } => (),\n+        false => (),\n+    }\n+}\n+\n+fn bad_indirect_mutation_in_guard2(mut z: &bool) {\n+    match z {\n+        &true => (),\n+        &false if {\n+            z = &true; //~ ERROR\n+            false\n+        } => (),\n+        &false => (),\n+    }\n+}\n+\n+fn bad_indirect_mutation_in_guard3(mut a: &bool) {\n+    // Same as bad_indirect_mutation_in_guard2, but using match ergonomics\n+    match a {\n+        true => (),\n+        false if {\n+            a = &true; //~ ERROR\n+            false\n+        } => (),\n+        false => (),\n+    }\n+}\n+\n+fn bad_indirect_mutation_in_guard4(mut b: &bool) {\n+    match b {\n+        &_ => (),\n+        &_ if {\n+            b = &true; //~ ERROR\n+            false\n+        } => (),\n+        &b => (),\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "2cbfeb886b57238558e766267ce696e4b31f32df", "filename": "src/test/ui/nll/match-guards-partially-borrow.stderr", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fnll%2Fmatch-guards-partially-borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fnll%2Fmatch-guards-partially-borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmatch-guards-partially-borrow.stderr?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -0,0 +1,132 @@\n+error[E0510]: cannot assign `q` in match guard\n+  --> $DIR/match-guards-partially-borrow.rs:35:13\n+   |\n+LL |     match q {\n+   |           - value is immutable in match guard\n+...\n+LL |             q = true; //~ ERROR\n+   |             ^^^^^^^^ cannot assign\n+...\n+LL |         _ => (),\n+   |         - borrow later used here\n+\n+error[E0510]: cannot assign `r` in match guard\n+  --> $DIR/match-guards-partially-borrow.rs:47:13\n+   |\n+LL |     match r {\n+   |           - value is immutable in match guard\n+...\n+LL |             r = true; //~ ERROR\n+   |             ^^^^^^^^ cannot assign\n+...\n+LL |         _ => (),\n+   |         - borrow later used here\n+\n+error[E0503]: cannot use `s` because it was mutably borrowed\n+  --> $DIR/match-guards-partially-borrow.rs:56:11\n+   |\n+LL |     let h = &mut s;\n+   |             ------ borrow of `s` occurs here\n+LL |     match s { //~ ERROR\n+   |           ^ use of borrowed `s`\n+...\n+LL |             *h = !*h;\n+   |                   -- borrow later used here\n+\n+error[E0510]: cannot assign `t` in match guard\n+  --> $DIR/match-guards-partially-borrow.rs:71:13\n+   |\n+LL |     match t {\n+   |           - value is immutable in match guard\n+...\n+LL |             t = true; //~ ERROR\n+   |             ^^^^^^^^ cannot assign\n+...\n+LL |         false => (),\n+   |         ----- borrow later used here\n+\n+error[E0506]: cannot assign to `u` because it is borrowed\n+  --> $DIR/match-guards-partially-borrow.rs:83:13\n+   |\n+LL |     match u {\n+   |           - borrow of `u` occurs here\n+...\n+LL |             u = true; //~ ERROR\n+   |             ^^^^^^^^ assignment to borrowed `u` occurs here\n+...\n+LL |         x => (),\n+   |         - borrow later used here\n+\n+error[E0510]: cannot mutably borrow `x.0` in match guard\n+  --> $DIR/match-guards-partially-borrow.rs:97:22\n+   |\n+LL |     match x {\n+   |           - value is immutable in match guard\n+...\n+LL |                 Some(ref mut r) => *r = None, //~ ERROR\n+   |                      ^^^^^^^^^ cannot mutably borrow\n+\n+error[E0506]: cannot assign to `*w.0` because it is borrowed\n+  --> $DIR/match-guards-partially-borrow.rs:112:13\n+   |\n+LL |     match w {\n+   |           - borrow of `*w.0` occurs here\n+...\n+LL |             *w.0 = true; //~ ERROR\n+   |             ^^^^^^^^^^^ assignment to borrowed `*w.0` occurs here\n+...\n+LL |         x => (),\n+   |         - borrow later used here\n+\n+error[E0510]: cannot assign `y` in match guard\n+  --> $DIR/match-guards-partially-borrow.rs:123:13\n+   |\n+LL |     match *y {\n+   |           -- value is immutable in match guard\n+...\n+LL |             y = &true; //~ ERROR\n+   |             ^^^^^^^^^ cannot assign\n+...\n+LL |         false => (),\n+   |         ----- borrow later used here\n+\n+error[E0510]: cannot assign `z` in match guard\n+  --> $DIR/match-guards-partially-borrow.rs:134:13\n+   |\n+LL |     match z {\n+   |           - value is immutable in match guard\n+...\n+LL |             z = &true; //~ ERROR\n+   |             ^^^^^^^^^ cannot assign\n+...\n+LL |         &false => (),\n+   |         ------ borrow later used here\n+\n+error[E0510]: cannot assign `a` in match guard\n+  --> $DIR/match-guards-partially-borrow.rs:146:13\n+   |\n+LL |     match a {\n+   |           - value is immutable in match guard\n+...\n+LL |             a = &true; //~ ERROR\n+   |             ^^^^^^^^^ cannot assign\n+...\n+LL |         false => (),\n+   |         ----- borrow later used here\n+\n+error[E0510]: cannot assign `b` in match guard\n+  --> $DIR/match-guards-partially-borrow.rs:157:13\n+   |\n+LL |     match b {\n+   |           - value is immutable in match guard\n+...\n+LL |             b = &true; //~ ERROR\n+   |             ^^^^^^^^^ cannot assign\n+...\n+LL |         &b => (),\n+   |         -- borrow later used here\n+\n+error: aborting due to 11 previous errors\n+\n+Some errors occurred: E0503, E0506, E0510.\n+For more information about an error, try `rustc --explain E0503`."}, {"sha": "6a8ce03e8fd255cba0ec950ed7fc8e1924f7e944", "filename": "src/test/ui/nll/match-on-borrowed.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fnll%2Fmatch-on-borrowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fnll%2Fmatch-on-borrowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmatch-on-borrowed.rs?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -0,0 +1,95 @@\n+// Test that a (partially) mutably borrowed place can be matched on, so long as\n+// we don't have to read any values that are mutably borrowed to determine\n+// which arm to take.\n+//\n+// Test that we don't allow mutating the value being matched on in a way that\n+// changes which patterns it matches, until we have chosen an arm.\n+\n+#![feature(nll)]\n+\n+struct A(i32, i32);\n+\n+fn struct_example(mut a: A) {\n+    let x = &mut a.0;\n+    match a { // OK, no access of borrowed data\n+        _ if false => (),\n+        A(_, r) => (),\n+    }\n+    x;\n+}\n+\n+fn indirect_struct_example(mut b: &mut A) {\n+    let x = &mut b.0;\n+    match *b { // OK, no access of borrowed data\n+        _ if false => (),\n+        A(_, r) => (),\n+    }\n+    x;\n+}\n+\n+fn underscore_example(mut c: i32) {\n+    let r = &mut c;\n+    match c { // OK, no access of borrowed data (or any data at all)\n+        _ if false => (),\n+        _ => (),\n+    }\n+    r;\n+}\n+\n+enum E {\n+    V(i32, i32),\n+    W,\n+}\n+\n+fn enum_example(mut e: E) {\n+    let x = match e {\n+        E::V(ref mut x, _) => x,\n+        E::W => panic!(),\n+    };\n+    match e { // OK, no access of borrowed data\n+        _ if false => (),\n+        E::V(_, r) => (),\n+        E::W => (),\n+    }\n+    x;\n+}\n+\n+fn indirect_enum_example(mut f: &mut E) {\n+    let x = match *f {\n+        E::V(ref mut x, _) => x,\n+        E::W => panic!(),\n+    };\n+    match f { // OK, no access of borrowed data\n+        _ if false => (),\n+        E::V(_, r) => (),\n+        E::W => (),\n+    }\n+    x;\n+}\n+\n+fn match_on_muatbly_borrowed_ref(mut p: &bool) {\n+    let r = &mut p;\n+    match *p { // OK, no access at all\n+        _ if false => (),\n+        _ => (),\n+    }\n+    r;\n+}\n+\n+fn match_on_borrowed(mut t: bool) {\n+    let x = &mut t;\n+    match t {\n+        true => (), //~ ERROR\n+        false => (),\n+    }\n+    x;\n+}\n+\n+enum Never {}\n+\n+fn never_init() {\n+    let n: Never;\n+    match n {} //~ ERROR\n+}\n+\n+fn main() {}"}, {"sha": "cdff29d44b85bf904ca22917546ea6f07c2b4965", "filename": "src/test/ui/nll/match-on-borrowed.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fnll%2Fmatch-on-borrowed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d/src%2Ftest%2Fui%2Fnll%2Fmatch-on-borrowed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmatch-on-borrowed.stderr?ref=3a2190a9cd4e38a9543ff697dd51ca8b6b68f50d", "patch": "@@ -0,0 +1,22 @@\n+error[E0503]: cannot use `t` because it was mutably borrowed\n+  --> $DIR/match-on-borrowed.rs:82:9\n+   |\n+LL |     let x = &mut t;\n+   |             ------ borrow of `t` occurs here\n+LL |     match t {\n+LL |         true => (), //~ ERROR\n+   |         ^^^^ use of borrowed `t`\n+...\n+LL |     x;\n+   |     - borrow later used here\n+\n+error[E0381]: use of possibly uninitialized variable: `n`\n+  --> $DIR/match-on-borrowed.rs:92:11\n+   |\n+LL |     match n {} //~ ERROR\n+   |           ^ use of possibly uninitialized `n`\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors occurred: E0381, E0503.\n+For more information about an error, try `rustc --explain E0381`."}]}