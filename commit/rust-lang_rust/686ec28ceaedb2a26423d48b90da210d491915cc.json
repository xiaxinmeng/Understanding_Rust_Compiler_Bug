{"sha": "686ec28ceaedb2a26423d48b90da210d491915cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4NmVjMjhjZWFlZGIyYTI2NDIzZDQ4YjkwZGEyMTBkNDkxOTE1Y2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-29T15:04:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-29T15:04:31Z"}, "message": "Auto merge of #42527 - qnighy:unsized-tuple-coercions, r=arielb1\n\nUnsized tuple coercions\n\nPart of #18469. Fixes #32702.\n\n#37685 and #34451 might also be related.\n\nThis PR does the following:\n\n- Introduce explicit `Sized` constraints on tuple initializers, similar to that of record-struct initializers. Not much relevant to the main contribution but I noticed this when making tests for unsized tuple coercions.\n- Implement `(.., T): Unsize<(.., U)>` where `T: Unsize<U>`.\n- Assume `(.., T)` is MaybeUnsizedUnivariant.\n- Modify `src/librustc/ty/util.rs` and `src/librustc_trans/glue.rs` so that tuples and structs are uniformly traversed when translating.", "tree": {"sha": "c6010b7391aba410170fad64d310b1dc3eee2f13", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c6010b7391aba410170fad64d310b1dc3eee2f13"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/686ec28ceaedb2a26423d48b90da210d491915cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/686ec28ceaedb2a26423d48b90da210d491915cc", "html_url": "https://github.com/rust-lang/rust/commit/686ec28ceaedb2a26423d48b90da210d491915cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/686ec28ceaedb2a26423d48b90da210d491915cc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0e0f53376766308850d3f79ec6ed0b12dc10e49", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0e0f53376766308850d3f79ec6ed0b12dc10e49", "html_url": "https://github.com/rust-lang/rust/commit/d0e0f53376766308850d3f79ec6ed0b12dc10e49"}, {"sha": "94862c601be15a8edd93539244177f5a9145374d", "url": "https://api.github.com/repos/rust-lang/rust/commits/94862c601be15a8edd93539244177f5a9145374d", "html_url": "https://github.com/rust-lang/rust/commit/94862c601be15a8edd93539244177f5a9145374d"}], "stats": {"total": 726, "additions": 707, "deletions": 19}, "files": [{"sha": "200a9c19462caa8a97c2d37449f785b80eab6ade", "filename": "src/doc/unstable-book/src/language-features/unsized-tuple-coercion.md", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funsized-tuple-coercion.md", "raw_url": "https://github.com/rust-lang/rust/raw/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funsized-tuple-coercion.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funsized-tuple-coercion.md?ref=686ec28ceaedb2a26423d48b90da210d491915cc", "patch": "@@ -0,0 +1,27 @@\n+# `unsized_tuple_coercion`\n+\n+The tracking issue for this feature is: [#42877]\n+\n+[#42877]: https://github.com/rust-lang/rust/issues/42877\n+\n+------------------------\n+\n+This is a part of [RFC0401]. According to the RFC, there should be an implementation like this:\n+\n+```rust\n+impl<..., T, U: ?Sized> Unsized<(..., U)> for (..., T) where T: Unsized<U> {}\n+```\n+\n+This implementation is currently gated behind `#[feature(unsized_tuple_coercion)]` to avoid insta-stability. Therefore you can use it like this:\n+\n+```rust\n+#![feature(unsized_tuple_coercion)]\n+\n+fn main() {\n+    let x : ([i32; 3], [i32; 3]) = ([1, 2, 3], [4, 5, 6]);\n+    let y : &([i32; 3], [i32]) = &x;\n+    assert_eq!(y.1[0], 4);\n+}\n+```\n+\n+[RFC0401]: https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md"}, {"sha": "0bf0e21baaf93e2973ff6886bb1e6a6cd55dbf62", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=686ec28ceaedb2a26423d48b90da210d491915cc", "patch": "@@ -1060,7 +1060,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 err.note(\"slice and array elements must have `Sized` type\");\n             }\n             ObligationCauseCode::TupleElem => {\n-                err.note(\"tuple elements must have `Sized` type\");\n+                err.note(\"only the last element of a tuple may have a dynamically sized type\");\n             }\n             ObligationCauseCode::ProjectionWf(data) => {\n                 err.note(&format!(\"required so that the projection `{}` is well-formed\",\n@@ -1097,6 +1097,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             ObligationCauseCode::AssignmentLhsSized => {\n                 err.note(\"the left-hand-side of an assignment must have a statically known size\");\n             }\n+            ObligationCauseCode::TupleInitializerSized => {\n+                err.note(\"tuples must have a statically known size to be initialized\");\n+            }\n             ObligationCauseCode::StructInitializerSized => {\n                 err.note(\"structs must have a statically known size to be initialized\");\n             }"}, {"sha": "16c41c816b4ebc8852d864fe119e135d54dca035", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=686ec28ceaedb2a26423d48b90da210d491915cc", "patch": "@@ -121,6 +121,8 @@ pub enum ObligationCauseCode<'tcx> {\n     // Various cases where expressions must be sized/copy/etc:\n     /// L = X implies that L is Sized\n     AssignmentLhsSized,\n+    /// (x1, .., xn) must be Sized\n+    TupleInitializerSized,\n     /// S { ... } must be Sized\n     StructInitializerSized,\n     /// Type of each variable must be Sized"}, {"sha": "856fea7c2c437188fe97402e74924c96c2f65e11", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=686ec28ceaedb2a26423d48b90da210d491915cc", "patch": "@@ -1651,6 +1651,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 def_id_a == def_id_b\n             }\n \n+            // (.., T) -> (.., U).\n+            (&ty::TyTuple(tys_a, _), &ty::TyTuple(tys_b, _)) => {\n+                tys_a.len() == tys_b.len()\n+            }\n+\n             _ => false\n         };\n \n@@ -2591,8 +2596,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 let inner_source = field.subst(tcx, substs_a);\n                 let inner_target = field.subst(tcx, substs_b);\n \n-                // Check that the source structure with the target's\n-                // type parameters is a subtype of the target.\n+                // Check that the source struct with the target's\n+                // unsized parameters is equal to the target.\n                 let params = substs_a.iter().enumerate().map(|(i, &k)| {\n                     if ty_params.contains(i) {\n                         Kind::from(substs_b.type_at(i))\n@@ -2617,6 +2622,37 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     &[inner_target]));\n             }\n \n+            // (.., T) -> (.., U).\n+            (&ty::TyTuple(tys_a, _), &ty::TyTuple(tys_b, _)) => {\n+                assert_eq!(tys_a.len(), tys_b.len());\n+\n+                // The last field of the tuple has to exist.\n+                let (a_last, a_mid) = if let Some(x) = tys_a.split_last() {\n+                    x\n+                } else {\n+                    return Err(Unimplemented);\n+                };\n+                let b_last = tys_b.last().unwrap();\n+\n+                // Check that the source tuple with the target's\n+                // last element is equal to the target.\n+                let new_tuple = tcx.mk_tup(a_mid.iter().chain(Some(b_last)), false);\n+                let InferOk { obligations, .. } =\n+                    self.infcx.at(&obligation.cause, obligation.param_env)\n+                              .eq(target, new_tuple)\n+                              .map_err(|_| Unimplemented)?;\n+                self.inferred_obligations.extend(obligations);\n+\n+                // Construct the nested T: Unsize<U> predicate.\n+                nested.push(tcx.predicate_for_trait_def(\n+                    obligation.param_env,\n+                    obligation.cause.clone(),\n+                    obligation.predicate.def_id(),\n+                    obligation.recursion_depth + 1,\n+                    a_last,\n+                    &[b_last]));\n+            }\n+\n             _ => bug!()\n         };\n "}, {"sha": "c4479e6903267a5f5d3036bdc9d62a25aa46f85c", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=686ec28ceaedb2a26423d48b90da210d491915cc", "patch": "@@ -189,6 +189,7 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n                 tcx.lift(&ty).map(super::ObjectCastObligation)\n             }\n             super::AssignmentLhsSized => Some(super::AssignmentLhsSized),\n+            super::TupleInitializerSized => Some(super::TupleInitializerSized),\n             super::StructInitializerSized => Some(super::StructInitializerSized),\n             super::VariableType(id) => Some(super::VariableType(id)),\n             super::ReturnType(id) => Some(super::ReturnType(id)),\n@@ -476,6 +477,7 @@ impl<'tcx> TypeFoldable<'tcx> for traits::ObligationCauseCode<'tcx> {\n             super::TupleElem |\n             super::ItemObligation(_) |\n             super::AssignmentLhsSized |\n+            super::TupleInitializerSized |\n             super::StructInitializerSized |\n             super::VariableType(_) |\n             super::ReturnType(_) |\n@@ -523,6 +525,7 @@ impl<'tcx> TypeFoldable<'tcx> for traits::ObligationCauseCode<'tcx> {\n             super::TupleElem |\n             super::ItemObligation(_) |\n             super::AssignmentLhsSized |\n+            super::TupleInitializerSized |\n             super::StructInitializerSized |\n             super::VariableType(_) |\n             super::ReturnType(_) |"}, {"sha": "e1aa89078a33b5456973752d268e4422b2f01f0e", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=686ec28ceaedb2a26423d48b90da210d491915cc", "patch": "@@ -1220,12 +1220,16 @@ impl<'a, 'tcx> Layout {\n             }\n \n             ty::TyTuple(tys, _) => {\n-                // FIXME(camlorn): if we ever allow unsized tuples, this needs to be checked.\n-                // See the univariant case below to learn how.\n+                let kind = if tys.len() == 0 {\n+                    StructKind::AlwaysSizedUnivariant\n+                } else {\n+                    StructKind::MaybeUnsizedUnivariant\n+                };\n+\n                 let st = Struct::new(dl,\n                     &tys.iter().map(|ty| ty.layout(tcx, param_env))\n                       .collect::<Result<Vec<_>, _>>()?,\n-                    &ReprOptions::default(), StructKind::AlwaysSizedUnivariant, ty)?;\n+                    &ReprOptions::default(), kind, ty)?;\n                 Univariant { variant: st, non_zero: false }\n             }\n "}, {"sha": "df4bbad3859f4ecc46623ed3b7bf30911dc814c4", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=686ec28ceaedb2a26423d48b90da210d491915cc", "patch": "@@ -317,15 +317,26 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                  target: Ty<'tcx>)\n                                  -> (Ty<'tcx>, Ty<'tcx>) {\n         let (mut a, mut b) = (source, target);\n-        while let (&TyAdt(a_def, a_substs), &TyAdt(b_def, b_substs)) = (&a.sty, &b.sty) {\n-            if a_def != b_def || !a_def.is_struct() {\n-                break;\n-            }\n-            match a_def.struct_variant().fields.last() {\n-                Some(f) => {\n-                    a = f.ty(self, a_substs);\n-                    b = f.ty(self, b_substs);\n-                }\n+        loop {\n+            match (&a.sty, &b.sty) {\n+                (&TyAdt(a_def, a_substs), &TyAdt(b_def, b_substs))\n+                        if a_def == b_def && a_def.is_struct() => {\n+                    if let Some(f) = a_def.struct_variant().fields.last() {\n+                        a = f.ty(self, a_substs);\n+                        b = f.ty(self, b_substs);\n+                    } else {\n+                        break;\n+                    }\n+                },\n+                (&TyTuple(a_tys, _), &TyTuple(b_tys, _))\n+                        if a_tys.len() == b_tys.len() => {\n+                    if let Some(a_last) = a_tys.last() {\n+                        a = a_last;\n+                        b = b_tys.last().unwrap();\n+                    } else {\n+                        break;\n+                    }\n+                },\n                 _ => break,\n             }\n         }"}, {"sha": "c2f44c089a2d6a7f8cd7b0fcbffd817490e2b038", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=686ec28ceaedb2a26423d48b90da210d491915cc", "patch": "@@ -76,7 +76,7 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n     }\n     assert!(!info.is_null());\n     match t.sty {\n-        ty::TyAdt(def, substs) => {\n+        ty::TyAdt(..) | ty::TyTuple(..) => {\n             let ccx = bcx.ccx;\n             // First get the size of all statically known fields.\n             // Don't use size_of because it also rounds up to alignment, which we\n@@ -101,8 +101,14 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n \n             // Recurse to get the size of the dynamically sized field (must be\n             // the last field).\n-            let last_field = def.struct_variant().fields.last().unwrap();\n-            let field_ty = monomorphize::field_ty(bcx.tcx(), substs, last_field);\n+            let field_ty = match t.sty {\n+                ty::TyAdt(def, substs) => {\n+                    let last_field = def.struct_variant().fields.last().unwrap();\n+                    monomorphize::field_ty(bcx.tcx(), substs, last_field)\n+                },\n+                ty::TyTuple(tys, _) => tys.last().unwrap(),\n+                _ => unreachable!(),\n+            };\n             let (unsized_size, unsized_align) = size_and_align_of_dst(bcx, field_ty, info);\n \n             // FIXME (#26403, #27023): We should be adding padding"}, {"sha": "968e893b9a00b422862e26713fcd6aabbbfb0767", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=686ec28ceaedb2a26423d48b90da210d491915cc", "patch": "@@ -76,6 +76,7 @@ use rustc::ty::relate::RelateResult;\n use rustc::ty::subst::Subst;\n use errors::DiagnosticBuilder;\n use syntax::abi;\n+use syntax::feature_gate;\n use syntax::ptr::P;\n use syntax_pos;\n \n@@ -520,14 +521,24 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                                                          coerce_source,\n                                                          &[coerce_target]));\n \n+        let mut has_unsized_tuple_coercion = false;\n+\n         // Keep resolving `CoerceUnsized` and `Unsize` predicates to avoid\n         // emitting a coercion in cases like `Foo<$1>` -> `Foo<$2>`, where\n         // inference might unify those two inner type variables later.\n         let traits = [coerce_unsized_did, unsize_did];\n         while let Some(obligation) = queue.pop_front() {\n             debug!(\"coerce_unsized resolve step: {:?}\", obligation);\n             let trait_ref = match obligation.predicate {\n-                ty::Predicate::Trait(ref tr) if traits.contains(&tr.def_id()) => tr.clone(),\n+                ty::Predicate::Trait(ref tr) if traits.contains(&tr.def_id()) => {\n+                    if unsize_did == tr.def_id() {\n+                        if let ty::TyTuple(..) = tr.0.input_types().nth(1).unwrap().sty {\n+                            debug!(\"coerce_unsized: found unsized tuple coercion\");\n+                            has_unsized_tuple_coercion = true;\n+                        }\n+                    }\n+                    tr.clone()\n+                }\n                 _ => {\n                     coercion.obligations.push(obligation);\n                     continue;\n@@ -557,6 +568,14 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             }\n         }\n \n+        if has_unsized_tuple_coercion && !self.tcx.sess.features.borrow().unsized_tuple_coercion {\n+            feature_gate::emit_feature_err(&self.tcx.sess.parse_sess,\n+                                           \"unsized_tuple_coercion\",\n+                                           self.cause.span,\n+                                           feature_gate::GateIssue::Language,\n+                                           feature_gate::EXPLAIN_UNSIZED_TUPLE_COERCION);\n+        }\n+\n         Ok(coercion)\n     }\n "}, {"sha": "967df57e153002f273f292fa51d6be0106b451bd", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=686ec28ceaedb2a26423d48b90da210d491915cc", "patch": "@@ -3854,6 +3854,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             if tuple.references_error() {\n                 tcx.types.err\n             } else {\n+                self.require_type_is_sized(tuple, expr.span, traits::TupleInitializerSized);\n                 tuple\n             }\n           }"}, {"sha": "df8ee189d21b3d23a7040896e26b4d91396db97e", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=686ec28ceaedb2a26423d48b90da210d491915cc", "patch": "@@ -357,6 +357,9 @@ declare_features! (\n \n     // Allows a test to fail without failing the whole suite\n     (active, allow_fail, \"1.19.0\", Some(42219)),\n+\n+    // Allows unsized tuple coercion.\n+    (active, unsized_tuple_coercion, \"1.20.0\", Some(42877)),\n );\n \n declare_features! (\n@@ -1041,6 +1044,9 @@ pub const EXPLAIN_VIS_MATCHER: &'static str =\n pub const EXPLAIN_PLACEMENT_IN: &'static str =\n     \"placement-in expression syntax is experimental and subject to change.\";\n \n+pub const EXPLAIN_UNSIZED_TUPLE_COERCION: &'static str =\n+    \"Unsized tuple coercion is not stable enough for use and is subject to change\";\n+\n struct PostExpansionVisitor<'a> {\n     context: &'a Context<'a>,\n }"}, {"sha": "1c3bad5ba56434357fd5e9eef7588ef058f70e13", "filename": "src/test/compile-fail/dst-bad-assign-3.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign-3.rs?ref=686ec28ceaedb2a26423d48b90da210d491915cc", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Forbid assignment into a dynamically sized type.\n+\n+#![feature(unsized_tuple_coercion)]\n+\n+type Fat<T: ?Sized> = (isize, &'static str, T);\n+//~^ WARNING trait bounds are not (yet) enforced\n+\n+#[derive(PartialEq,Eq)]\n+struct Bar;\n+\n+#[derive(PartialEq,Eq)]\n+struct Bar1 {\n+    f: isize\n+}\n+\n+trait ToBar {\n+    fn to_bar(&self) -> Bar;\n+    fn to_val(&self) -> isize;\n+}\n+\n+impl ToBar for Bar1 {\n+    fn to_bar(&self) -> Bar {\n+        Bar\n+    }\n+    fn to_val(&self) -> isize {\n+        self.f\n+    }\n+}\n+\n+pub fn main() {\n+    // Assignment.\n+    let f5: &mut Fat<ToBar> = &mut (5, \"some str\", Bar1 {f :42});\n+    let z: Box<ToBar> = Box::new(Bar1 {f: 36});\n+    f5.2 = Bar1 {f: 36};\n+    //~^ ERROR mismatched types\n+    //~| expected type `ToBar`\n+    //~| found type `Bar1`\n+    //~| expected trait ToBar, found struct `Bar1`\n+    //~| ERROR `ToBar: std::marker::Sized` is not satisfied\n+}"}, {"sha": "b0de84a53007258bd394517b85cc4d58c4a1f7b7", "filename": "src/test/compile-fail/dst-bad-coerce1.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs?ref=686ec28ceaedb2a26423d48b90da210d491915cc", "patch": "@@ -10,6 +10,8 @@\n \n // Attempt to change the type as well as unsizing.\n \n+#![feature(unsized_tuple_coercion)]\n+\n struct Fat<T: ?Sized> {\n     ptr: T\n }\n@@ -29,4 +31,16 @@ pub fn main() {\n     let f2: &Fat<Foo> = &f1;\n     let f3: &Fat<Bar> = f2;\n     //~^ ERROR `Foo: Bar` is not satisfied\n+\n+    // Tuple with a vec of isize.\n+    let f1 = ([1, 2, 3],);\n+    let f2: &([isize; 3],) = &f1;\n+    let f3: &([usize],) = f2;\n+    //~^ ERROR mismatched types\n+\n+    // Tuple with a trait.\n+    let f1 = (Foo,);\n+    let f2: &(Foo,) = &f1;\n+    let f3: &(Bar,) = f2;\n+    //~^ ERROR `Foo: Bar` is not satisfied\n }"}, {"sha": "9e92f649b2d5696acd2d8d67fbddf0bed421eca6", "filename": "src/test/compile-fail/dst-bad-coerce2.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce2.rs?ref=686ec28ceaedb2a26423d48b90da210d491915cc", "patch": "@@ -28,4 +28,14 @@ pub fn main() {\n     let f1 = Fat { ptr: Foo };\n     let f2: &Fat<Foo> = &f1;\n     let f3: &mut Fat<Bar> = f2; //~ ERROR mismatched types\n+\n+    // Tuple with a vec of ints.\n+    let f1 = ([1, 2, 3],);\n+    let f2: &([isize; 3],) = &f1;\n+    let f3: &mut ([isize],) = f2; //~ ERROR mismatched types\n+\n+    // Tuple with a trait.\n+    let f1 = (Foo,);\n+    let f2: &(Foo,) = &f1;\n+    let f3: &mut (Bar,) = f2; //~ ERROR mismatched types\n }"}, {"sha": "35a147c15bb433beb6baf7f168a3b98dbb4d3af5", "filename": "src/test/compile-fail/dst-bad-coerce3.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce3.rs?ref=686ec28ceaedb2a26423d48b90da210d491915cc", "patch": "@@ -10,6 +10,8 @@\n \n // Attempt to extend the lifetime as well as unsizing.\n \n+#![feature(unsized_tuple_coercion)]\n+\n struct Fat<T: ?Sized> {\n     ptr: T\n }\n@@ -28,6 +30,16 @@ fn baz<'a>() {\n     let f1 = Fat { ptr: Foo };\n     let f2: &Fat<Foo> = &f1; //~ ERROR `f1` does not live long enough\n     let f3: &'a Fat<Bar> = f2;\n+\n+    // Tuple with a vec of ints.\n+    let f1 = ([1, 2, 3],);\n+    let f2: &([isize; 3],) = &f1; //~ ERROR `f1` does not live long enough\n+    let f3: &'a ([isize],) = f2;\n+\n+    // Tuple with a trait.\n+    let f1 = (Foo,);\n+    let f2: &(Foo,) = &f1; //~ ERROR `f1` does not live long enough\n+    let f3: &'a (Bar,) = f2;\n }\n \n pub fn main() {"}, {"sha": "874b7588ff9bb572a2a01530c48ac43389568d25", "filename": "src/test/compile-fail/dst-bad-coerce4.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce4.rs?ref=686ec28ceaedb2a26423d48b90da210d491915cc", "patch": "@@ -10,6 +10,8 @@\n \n // Attempt to coerce from unsized to sized.\n \n+#![feature(unsized_tuple_coercion)]\n+\n struct Fat<T: ?Sized> {\n     ptr: T\n }\n@@ -22,4 +24,12 @@ pub fn main() {\n     //~| expected type `&Fat<[isize; 3]>`\n     //~| found type `&Fat<[isize]>`\n     //~| expected array of 3 elements, found slice\n+\n+    // Tuple with a vec of isizes.\n+    let f1: &([isize],) = &([1, 2, 3],);\n+    let f2: &([isize; 3],) = f1;\n+    //~^ ERROR mismatched types\n+    //~| expected type `&([isize; 3],)`\n+    //~| found type `&([isize],)`\n+    //~| expected array of 3 elements, found slice\n }"}, {"sha": "0c812b1d815ab000da92254d3c9cf6d4affb9a6e", "filename": "src/test/compile-fail/dst-bad-deep-2.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Ftest%2Fcompile-fail%2Fdst-bad-deep-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Ftest%2Fcompile-fail%2Fdst-bad-deep-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-deep-2.rs?ref=686ec28ceaedb2a26423d48b90da210d491915cc", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Try to initialise a DST struct where the lost information is deeply nested.\n+// This is an error because it requires an unsized rvalue. This is a problem\n+// because it would require stack allocation of an unsized temporary (*g in the\n+// test).\n+\n+#![feature(unsized_tuple_coercion)]\n+\n+pub fn main() {\n+    let f: ([isize; 3],) = ([5, 6, 7],);\n+    let g: &([isize],) = &f;\n+    let h: &(([isize],),) = &(*g,);\n+    //~^ ERROR `[isize]: std::marker::Sized` is not satisfied\n+}"}, {"sha": "4ddde01126363524b22040d662bd5d792d28a411", "filename": "src/test/compile-fail/feature-gate-unsized_tuple_coercion.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Ftest%2Fcompile-fail%2Ffeature-gate-unsized_tuple_coercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Ftest%2Fcompile-fail%2Ffeature-gate-unsized_tuple_coercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-unsized_tuple_coercion.rs?ref=686ec28ceaedb2a26423d48b90da210d491915cc", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let _ : &(Send,) = &((),);\n+    //~^ ERROR Unsized tuple coercion is not stable enough\n+}"}, {"sha": "e96e0ea3aec3623ec0d57b2a3e4aae3927c2adaf", "filename": "src/test/compile-fail/unsized3.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Ftest%2Fcompile-fail%2Funsized3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Ftest%2Fcompile-fail%2Funsized3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized3.rs?ref=686ec28ceaedb2a26423d48b90da210d491915cc", "patch": "@@ -54,6 +54,7 @@ fn f9<X: ?Sized>(x1: Box<S<X>>) {\n fn f10<X: ?Sized>(x1: Box<S<X>>) {\n     f5(&(32, *x1));\n     //~^ ERROR `X: std::marker::Sized` is not satisfied\n+    //~| ERROR `X: std::marker::Sized` is not satisfied\n }\n \n pub fn main() {"}, {"sha": "1ae66a28a849ea4fa85c5810dc0ce1e100219d97", "filename": "src/test/run-pass-valgrind/dst-dtor-3.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Ftest%2Frun-pass-valgrind%2Fdst-dtor-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Ftest%2Frun-pass-valgrind%2Fdst-dtor-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-valgrind%2Fdst-dtor-3.rs?ref=686ec28ceaedb2a26423d48b90da210d491915cc", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![feature(unsized_tuple_coercion)]\n+\n+static mut DROP_RAN: bool = false;\n+\n+struct Foo;\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        unsafe { DROP_RAN = true; }\n+    }\n+}\n+\n+trait Trait { fn dummy(&self) { } }\n+impl Trait for Foo {}\n+\n+pub fn main() {\n+    {\n+        let _x: Box<(i32, Trait)> = Box::<(i32, Foo)>::new((42, Foo));\n+    }\n+    unsafe {\n+        assert!(DROP_RAN);\n+    }\n+}"}, {"sha": "e416f25bc03a0141ae35f566316f565a060bb6c6", "filename": "src/test/run-pass-valgrind/dst-dtor-4.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Ftest%2Frun-pass-valgrind%2Fdst-dtor-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Ftest%2Frun-pass-valgrind%2Fdst-dtor-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-valgrind%2Fdst-dtor-4.rs?ref=686ec28ceaedb2a26423d48b90da210d491915cc", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![feature(unsized_tuple_coercion)]\n+\n+static mut DROP_RAN: isize = 0;\n+\n+struct Foo;\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        unsafe { DROP_RAN += 1; }\n+    }\n+}\n+\n+pub fn main() {\n+    {\n+        let _x: Box<(i32, [Foo])> = Box::<(i32, [Foo; 3])>::new((42, [Foo, Foo, Foo]));\n+    }\n+    unsafe {\n+        assert_eq!(DROP_RAN, 3);\n+    }\n+}"}, {"sha": "b1d6c732e7fbb0a9caecb48a8733a84cd11751ff", "filename": "src/test/run-pass/dst-irrefutable-bind.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Ftest%2Frun-pass%2Fdst-irrefutable-bind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Ftest%2Frun-pass%2Fdst-irrefutable-bind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-irrefutable-bind.rs?ref=686ec28ceaedb2a26423d48b90da210d491915cc", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(unsized_tuple_coercion)]\n+\n struct Test<T: ?Sized>(T);\n \n fn main() {\n@@ -21,4 +23,14 @@ fn main() {\n     let slice = &[1,2,3];\n     let x = Test(&slice);\n     let Test(&_slice) = x;\n+\n+\n+    let x = (10, [1,2,3]);\n+    let x : &(i32, [i32]) = &x;\n+\n+    let & ref _y = x;\n+\n+    let slice = &[1,2,3];\n+    let x = (10, &slice);\n+    let (_, &_slice) = x;\n }"}, {"sha": "9ebfbee8a330213363a9906b518d9685cf13694e", "filename": "src/test/run-pass/dst-raw.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Ftest%2Frun-pass%2Fdst-raw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Ftest%2Frun-pass%2Fdst-raw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-raw.rs?ref=686ec28ceaedb2a26423d48b90da210d491915cc", "patch": "@@ -11,6 +11,8 @@\n // Test DST raw pointers\n \n \n+#![feature(unsized_tuple_coercion)]\n+\n trait Trait {\n     fn foo(&self) -> isize;\n }\n@@ -45,6 +47,14 @@ pub fn main() {\n     };\n     assert_eq!(r, 42);\n \n+    // raw DST tuple\n+    let p = (A { f: 42 },);\n+    let o: *const (Trait,) = &p;\n+    let r = unsafe {\n+        (&*o).0.foo()\n+    };\n+    assert_eq!(r, 42);\n+\n     // raw slice\n     let a: *const [_] = &[1, 2, 3];\n     unsafe {\n@@ -72,6 +82,15 @@ pub fn main() {\n         assert_eq!(len, 3);\n     }\n \n+    // raw DST tuple with slice\n+    let c: *const ([_],) = &([1, 2, 3],);\n+    unsafe {\n+        let b = (&*c).0[0];\n+        assert_eq!(b, 1);\n+        let len = (&*c).0.len();\n+        assert_eq!(len, 3);\n+    }\n+\n     // all of the above with *mut\n     let mut x = A { f: 42 };\n     let z: *mut Trait = &mut x;\n@@ -87,6 +106,13 @@ pub fn main() {\n     };\n     assert_eq!(r, 42);\n \n+    let mut p = (A { f: 42 },);\n+    let o: *mut (Trait,) = &mut p;\n+    let r = unsafe {\n+        (&*o).0.foo()\n+    };\n+    assert_eq!(r, 42);\n+\n     let a: *mut [_] = &mut [1, 2, 3];\n     unsafe {\n         let b = (*a)[2];\n@@ -110,4 +136,12 @@ pub fn main() {\n         let len = (&*c).f.len();\n         assert_eq!(len, 3);\n     }\n+\n+    let c: *mut ([_],) = &mut ([1, 2, 3],);\n+    unsafe {\n+        let b = (&*c).0[0];\n+        assert_eq!(b, 1);\n+        let len = (&*c).0.len();\n+        assert_eq!(len, 3);\n+    }\n }"}, {"sha": "9803e26f5f8591a47cad98b813f10702b1100de1", "filename": "src/test/run-pass/dst-trait-tuple.rs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Ftest%2Frun-pass%2Fdst-trait-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Ftest%2Frun-pass%2Fdst-trait-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-trait-tuple.rs?ref=686ec28ceaedb2a26423d48b90da210d491915cc", "patch": "@@ -0,0 +1,111 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+#![allow(unused_features)]\n+#![feature(box_syntax)]\n+#![feature(unsized_tuple_coercion)]\n+\n+type Fat<T: ?Sized> = (isize, &'static str, T);\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+struct Bar;\n+\n+#[derive(Copy, Clone, PartialEq, Eq)]\n+struct Bar1 {\n+    f: isize\n+}\n+\n+trait ToBar {\n+    fn to_bar(&self) -> Bar;\n+    fn to_val(&self) -> isize;\n+}\n+\n+impl ToBar for Bar {\n+    fn to_bar(&self) -> Bar {\n+        *self\n+    }\n+    fn to_val(&self) -> isize {\n+        0\n+    }\n+}\n+impl ToBar for Bar1 {\n+    fn to_bar(&self) -> Bar {\n+        Bar\n+    }\n+    fn to_val(&self) -> isize {\n+        self.f\n+    }\n+}\n+\n+// x is a fat pointer\n+fn foo(x: &Fat<ToBar>) {\n+    assert_eq!(x.0, 5);\n+    assert_eq!(x.1, \"some str\");\n+    assert_eq!(x.2.to_bar(), Bar);\n+    assert_eq!(x.2.to_val(), 42);\n+\n+    let y = &x.2;\n+    assert_eq!(y.to_bar(), Bar);\n+    assert_eq!(y.to_val(), 42);\n+}\n+\n+fn bar(x: &ToBar) {\n+    assert_eq!(x.to_bar(), Bar);\n+    assert_eq!(x.to_val(), 42);\n+}\n+\n+fn baz(x: &Fat<Fat<ToBar>>) {\n+    assert_eq!(x.0, 5);\n+    assert_eq!(x.1, \"some str\");\n+    assert_eq!((x.2).0, 8);\n+    assert_eq!((x.2).1, \"deep str\");\n+    assert_eq!((x.2).2.to_bar(), Bar);\n+    assert_eq!((x.2).2.to_val(), 42);\n+\n+    let y = &(x.2).2;\n+    assert_eq!(y.to_bar(), Bar);\n+    assert_eq!(y.to_val(), 42);\n+\n+}\n+\n+pub fn main() {\n+    let f1 = (5, \"some str\", Bar1 {f :42});\n+    foo(&f1);\n+    let f2 = &f1;\n+    foo(f2);\n+    let f3: &Fat<ToBar> = f2;\n+    foo(f3);\n+    let f4: &Fat<ToBar> = &f1;\n+    foo(f4);\n+    let f5: &Fat<ToBar> = &(5, \"some str\", Bar1 {f :42});\n+    foo(f5);\n+\n+    // Zero size object.\n+    let f6: &Fat<ToBar> = &(5, \"some str\", Bar);\n+    assert_eq!(f6.2.to_bar(), Bar);\n+\n+    // &*\n+    //\n+    let f7: Box<ToBar> = Box::new(Bar1 {f :42});\n+    bar(&*f7);\n+\n+    // Deep nesting\n+    let f1 = (5, \"some str\", (8, \"deep str\", Bar1 {f :42}));\n+    baz(&f1);\n+    let f2 = &f1;\n+    baz(f2);\n+    let f3: &Fat<Fat<ToBar>> = f2;\n+    baz(f3);\n+    let f4: &Fat<Fat<ToBar>> = &f1;\n+    baz(f4);\n+    let f5: &Fat<Fat<ToBar>> = &(5, \"some str\", (8, \"deep str\", Bar1 {f :42}));\n+    baz(f5);\n+}"}, {"sha": "a788e25218eb46c044da5ba6d4e10335eeb6ee2c", "filename": "src/test/run-pass/dst-tuple-sole.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Ftest%2Frun-pass%2Fdst-tuple-sole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Ftest%2Frun-pass%2Fdst-tuple-sole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-tuple-sole.rs?ref=686ec28ceaedb2a26423d48b90da210d491915cc", "patch": "@@ -0,0 +1,85 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// As dst-tuple.rs, but the unsized field is the only field in the tuple.\n+\n+\n+#![feature(unsized_tuple_coercion)]\n+\n+type Fat<T: ?Sized> = (T,);\n+\n+// x is a fat pointer\n+fn foo(x: &Fat<[isize]>) {\n+    let y = &x.0;\n+    assert_eq!(x.0.len(), 3);\n+    assert_eq!(y[0], 1);\n+    assert_eq!(x.0[1], 2);\n+}\n+\n+fn foo2<T:ToBar>(x: &Fat<[T]>) {\n+    let y = &x.0;\n+    let bar = Bar;\n+    assert_eq!(x.0.len(), 3);\n+    assert_eq!(y[0].to_bar(), bar);\n+    assert_eq!(x.0[1].to_bar(), bar);\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+struct Bar;\n+\n+trait ToBar {\n+    fn to_bar(&self) -> Bar;\n+}\n+\n+impl ToBar for Bar {\n+    fn to_bar(&self) -> Bar {\n+        *self\n+    }\n+}\n+\n+pub fn main() {\n+    // With a vec of ints.\n+    let f1 = ([1, 2, 3],);\n+    foo(&f1);\n+    let f2 = &f1;\n+    foo(f2);\n+    let f3: &Fat<[isize]> = f2;\n+    foo(f3);\n+    let f4: &Fat<[isize]> = &f1;\n+    foo(f4);\n+    let f5: &Fat<[isize]> = &([1, 2, 3],);\n+    foo(f5);\n+\n+    // With a vec of Bars.\n+    let bar = Bar;\n+    let f1 = ([bar, bar, bar],);\n+    foo2(&f1);\n+    let f2 = &f1;\n+    foo2(f2);\n+    let f3: &Fat<[Bar]> = f2;\n+    foo2(f3);\n+    let f4: &Fat<[Bar]> = &f1;\n+    foo2(f4);\n+    let f5: &Fat<[Bar]> = &([bar, bar, bar],);\n+    foo2(f5);\n+\n+    // Assignment.\n+    let f5: &mut Fat<[isize]> = &mut ([1, 2, 3],);\n+    f5.0[1] = 34;\n+    assert_eq!(f5.0[0], 1);\n+    assert_eq!(f5.0[1], 34);\n+    assert_eq!(f5.0[2], 3);\n+\n+    // Zero size vec.\n+    let f5: &Fat<[isize]> = &([],);\n+    assert!(f5.0.is_empty());\n+    let f5: &Fat<[Bar]> = &([],);\n+    assert!(f5.0.is_empty());\n+}"}, {"sha": "2f5b28495b8aed7c3d8b3b0745dadcbf57b18ec1", "filename": "src/test/run-pass/dst-tuple.rs", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Ftest%2Frun-pass%2Fdst-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686ec28ceaedb2a26423d48b90da210d491915cc/src%2Ftest%2Frun-pass%2Fdst-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-tuple.rs?ref=686ec28ceaedb2a26423d48b90da210d491915cc", "patch": "@@ -0,0 +1,129 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+#![allow(unknown_features)]\n+#![feature(box_syntax)]\n+#![feature(unsized_tuple_coercion)]\n+\n+type Fat<T: ?Sized> = (isize, &'static str, T);\n+\n+// x is a fat pointer\n+fn foo(x: &Fat<[isize]>) {\n+    let y = &x.2;\n+    assert_eq!(x.2.len(), 3);\n+    assert_eq!(y[0], 1);\n+    assert_eq!(x.2[1], 2);\n+    assert_eq!(x.0, 5);\n+    assert_eq!(x.1, \"some str\");\n+}\n+\n+fn foo2<T:ToBar>(x: &Fat<[T]>) {\n+    let y = &x.2;\n+    let bar = Bar;\n+    assert_eq!(x.2.len(), 3);\n+    assert_eq!(y[0].to_bar(), bar);\n+    assert_eq!(x.2[1].to_bar(), bar);\n+    assert_eq!(x.0, 5);\n+    assert_eq!(x.1, \"some str\");\n+}\n+\n+fn foo3(x: &Fat<Fat<[isize]>>) {\n+    let y = &(x.2).2;\n+    assert_eq!(x.0, 5);\n+    assert_eq!(x.1, \"some str\");\n+    assert_eq!((x.2).0, 8);\n+    assert_eq!((x.2).1, \"deep str\");\n+    assert_eq!((x.2).2.len(), 3);\n+    assert_eq!(y[0], 1);\n+    assert_eq!((x.2).2[1], 2);\n+}\n+\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+struct Bar;\n+\n+trait ToBar {\n+    fn to_bar(&self) -> Bar;\n+}\n+\n+impl ToBar for Bar {\n+    fn to_bar(&self) -> Bar {\n+        *self\n+    }\n+}\n+\n+pub fn main() {\n+    // With a vec of ints.\n+    let f1 = (5, \"some str\", [1, 2, 3]);\n+    foo(&f1);\n+    let f2 = &f1;\n+    foo(f2);\n+    let f3: &Fat<[isize]> = f2;\n+    foo(f3);\n+    let f4: &Fat<[isize]> = &f1;\n+    foo(f4);\n+    let f5: &Fat<[isize]> = &(5, \"some str\", [1, 2, 3]);\n+    foo(f5);\n+\n+    // With a vec of Bars.\n+    let bar = Bar;\n+    let f1 = (5, \"some str\", [bar, bar, bar]);\n+    foo2(&f1);\n+    let f2 = &f1;\n+    foo2(f2);\n+    let f3: &Fat<[Bar]> = f2;\n+    foo2(f3);\n+    let f4: &Fat<[Bar]> = &f1;\n+    foo2(f4);\n+    let f5: &Fat<[Bar]> = &(5, \"some str\", [bar, bar, bar]);\n+    foo2(f5);\n+\n+    // Assignment.\n+    let f5: &mut Fat<[isize]> = &mut (5, \"some str\", [1, 2, 3]);\n+    f5.2[1] = 34;\n+    assert_eq!(f5.2[0], 1);\n+    assert_eq!(f5.2[1], 34);\n+    assert_eq!(f5.2[2], 3);\n+\n+    // Zero size vec.\n+    let f5: &Fat<[isize]> = &(5, \"some str\", []);\n+    assert!(f5.2.is_empty());\n+    let f5: &Fat<[Bar]> = &(5, \"some str\", []);\n+    assert!(f5.2.is_empty());\n+\n+    // Deeply nested.\n+    let f1 = (5, \"some str\", (8, \"deep str\", [1, 2, 3]));\n+    foo3(&f1);\n+    let f2 = &f1;\n+    foo3(f2);\n+    let f3: &Fat<Fat<[isize]>> = f2;\n+    foo3(f3);\n+    let f4: &Fat<Fat<[isize]>> = &f1;\n+    foo3(f4);\n+    let f5: &Fat<Fat<[isize]>> = &(5, \"some str\", (8, \"deep str\", [1, 2, 3]));\n+    foo3(f5);\n+\n+    // Box.\n+    let f1 = Box::new([1, 2, 3]);\n+    assert_eq!((*f1)[1], 2);\n+    let f2: Box<[isize]> = f1;\n+    assert_eq!((*f2)[1], 2);\n+\n+    // Nested Box.\n+    let f1 : Box<Fat<[isize; 3]>> = box (5, \"some str\", [1, 2, 3]);\n+    foo(&*f1);\n+    let f2 : Box<Fat<[isize]>> = f1;\n+    foo(&*f2);\n+\n+    let f3 : Box<Fat<[isize]>> =\n+        Box::<Fat<[_; 3]>>::new((5, \"some str\", [1, 2, 3]));\n+    foo(&*f3);\n+}"}]}