{"sha": "730381d936ddbfff12a9bf5c83a75623b14e5bad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczMDM4MWQ5MzZkZGJmZmYxMmE5YmY1YzgzYTc1NjIzYjE0ZTViYWQ=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-06-14T19:04:05Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-06-14T19:04:05Z"}, "message": "Annotate and fix FIXMEs in typeck", "tree": {"sha": "521a84bdc80c2f639bc753d7c8c8d42743ef207a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/521a84bdc80c2f639bc753d7c8c8d42743ef207a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/730381d936ddbfff12a9bf5c83a75623b14e5bad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/730381d936ddbfff12a9bf5c83a75623b14e5bad", "html_url": "https://github.com/rust-lang/rust/commit/730381d936ddbfff12a9bf5c83a75623b14e5bad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/730381d936ddbfff12a9bf5c83a75623b14e5bad/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87af3f3ccab541a59996f289c39ccf7ddad1e29f", "url": "https://api.github.com/repos/rust-lang/rust/commits/87af3f3ccab541a59996f289c39ccf7ddad1e29f", "html_url": "https://github.com/rust-lang/rust/commit/87af3f3ccab541a59996f289c39ccf7ddad1e29f"}], "stats": {"total": 81, "additions": 40, "deletions": 41}, "files": [{"sha": "c05e95650ab2c624dc8e98818a799f49f739141c", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/730381d936ddbfff12a9bf5c83a75623b14e5bad/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/730381d936ddbfff12a9bf5c83a75623b14e5bad/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=730381d936ddbfff12a9bf5c83a75623b14e5bad", "patch": "@@ -120,8 +120,6 @@ type crate_ctxt = {impl_map: resolve::impl_map,\n                    vtable_map: vtable_map,\n                    tcx: ty::ctxt};\n \n-type class_map = hashmap<ast::node_id, ty::t>;\n-\n // Functions that write types into the node type table\n fn write_ty_to_tcx(tcx: ty::ctxt, node_id: ast::node_id, ty: ty::t) {\n     #debug[\"write_ty_to_tcx(%d, %s)\", node_id, ty_to_str(tcx, ty)];"}, {"sha": "cc2fa54ea1018e55f659c42ffa474f411250af25", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 40, "deletions": 39, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/730381d936ddbfff12a9bf5c83a75623b14e5bad/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/730381d936ddbfff12a9bf5c83a75623b14e5bad/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=730381d936ddbfff12a9bf5c83a75623b14e5bad", "patch": "@@ -99,6 +99,23 @@ type fn_ctxt =\n \n      ccx: @crate_ctxt};\n \n+// Used by check_const and check_enum_variants\n+fn blank_fn_ctxt(ccx: @crate_ctxt, rty: ty::t) -> @fn_ctxt {\n+// It's kind of a kludge to manufacture a fake function context\n+// and statement context, but we might as well do write the code only once\n+    @{self_ty: none,\n+      ret_ty: rty,\n+      indirect_ret_ty: none,\n+      purity: ast::pure_fn,\n+      infcx: infer::new_infer_ctxt(ccx.tcx),\n+      locals: int_hash(),\n+      mut blocks: [],\n+      in_scope_regions: @nil,\n+      node_types: smallintmap::mk(),\n+      node_type_substs: map::int_hash(),\n+      ccx: ccx}\n+}\n+\n // a list of mapping from in-scope-region-names (\"isr\") to the\n // corresponding ty::region\n type isr_alist = @list<(ty::bound_region, ty::region)>;\n@@ -705,7 +722,7 @@ fn impl_self_ty(fcx: @fn_ctxt, did: ast::def_id) -> ty_param_substs_and_ty {\n }\n \n // Only for fields! Returns <none> for methods>\n-// FIXME: privacy flags\n+// Indifferent to privacy flags\n fn lookup_field_ty(tcx: ty::ctxt, class_id: ast::def_id,\n                    items:[ty::field_ty], fieldname: ast::ident,\n                    substs: ty::substs) -> option<ty::t> {\n@@ -1390,7 +1407,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         alt structure_of(fcx, expr.span, fty) {\n           // FIXME:\n           // probably need to munge the constrs to drop constraints\n-          // for any bound args\n+          // for any bound args (contingent on #2588 not getting accepted)\n           ty::ty_fn(f) {\n             proto = f.proto;\n             arg_tys = f.inputs;\n@@ -1460,7 +1477,11 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             if type_is_c_like_enum(fcx,expr.span,t_e) && t_1_is_scalar {\n                 /* this case is allowed */\n             } else if !(type_is_scalar(fcx,expr.span,t_e) && t_1_is_scalar) {\n-                // FIXME there are more forms of cast to support, eventually.\n+                /*\n+                If more type combinations should be supported than are\n+                supported here, then file an enhancement issue and record the\n+                issue number in this comment.\n+                */\n                 tcx.sess.span_err(expr.span,\n                                   \"non-scalar cast: \" +\n                                   ty_to_str(tcx, t_e) + \" as \" +\n@@ -1516,14 +1537,13 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n           }\n           some(bexpr) {\n             let bexpr_t = fcx.expr_ty(bexpr);\n-            let mut base_fields; // FIXME remove mut after snapshot\n-            alt structure_of(fcx, expr.span, bexpr_t) {\n-              ty::ty_rec(flds) { base_fields = flds; }\n+            let base_fields =  alt structure_of(fcx, expr.span, bexpr_t) {\n+              ty::ty_rec(flds) { flds }\n               _ {\n                 tcx.sess.span_fatal(expr.span,\n                                     \"record update has non-record base\");\n               }\n-            }\n+            };\n             fcx.write_ty(id, bexpr_t);\n             for fields_t.each {|f|\n                 let mut found = false;\n@@ -1586,7 +1606,6 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n               alt lookup_field_ty(tcx, base_id, cls_items, field, substs) {\n                  some(field_ty) {\n                     // (2) look up what field's type is, and return it\n-                    // FIXME: actually instantiate any type params\n                      fcx.write_ty(id, field_ty);\n                      handled = true;\n                  }\n@@ -1843,21 +1862,8 @@ fn check_block(fcx0: @fn_ctxt, blk: ast::blk) -> bool {\n }\n \n fn check_const(ccx: @crate_ctxt, _sp: span, e: @ast::expr, id: ast::node_id) {\n-    // FIXME: this is kinda a kludge; we manufacture a fake function context\n-    // and statement context for checking the initializer expression.\n     let rty = ty::node_id_to_type(ccx.tcx, id);\n-    let fcx: @fn_ctxt =\n-        @{self_ty: none,\n-          ret_ty: rty,\n-          indirect_ret_ty: none,\n-          purity: ast::pure_fn,\n-          infcx: infer::new_infer_ctxt(ccx.tcx),\n-          locals: int_hash(),\n-          mut blocks: [],\n-          in_scope_regions: @nil,\n-          node_types: smallintmap::mk(),\n-          node_type_substs: map::int_hash(),\n-          ccx: ccx};\n+    let fcx = blank_fn_ctxt(ccx, rty);\n     check_expr(fcx, e, none);\n     let cty = fcx.expr_ty(e);\n     let declty = fcx.ccx.tcx.tcache.get(local_def(id)).ty;\n@@ -1882,21 +1888,8 @@ fn check_enum_variants(ccx: @crate_ctxt,\n                        sp: span,\n                        vs: [ast::variant],\n                        id: ast::node_id) {\n-    // FIXME: this is kinda a kludge; we manufacture a fake function context\n-    // and statement context for checking the initializer expression.\n     let rty = ty::node_id_to_type(ccx.tcx, id);\n-    let fcx: @fn_ctxt =\n-        @{self_ty: none,\n-          ret_ty: rty,\n-          indirect_ret_ty: none,\n-          purity: ast::pure_fn,\n-          infcx: infer::new_infer_ctxt(ccx.tcx),\n-          locals: int_hash(),\n-          mut blocks: [],\n-          in_scope_regions: @nil,\n-          node_types: smallintmap::mk(),\n-          node_type_substs: map::int_hash(),\n-          ccx: ccx};\n+    let fcx = blank_fn_ctxt(ccx, rty);\n     let mut disr_vals: [int] = [];\n     let mut disr_val = 0;\n     for vs.each {|v|\n@@ -2140,9 +2133,17 @@ fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n       ast::def_upvar(_, inner, _) {\n         ret ty_param_bounds_and_ty_for_def(fcx, sp, *inner);\n       }\n-      _ {\n-        // FIXME: handle other names.\n-        fcx.ccx.tcx.sess.unimpl(\"definition variant\");\n+      ast::def_ty_param(did, n) {\n+        ret no_params(ty::mk_param(fcx.ccx.tcx, n, did));\n+      }\n+      ast::def_mod(*) | ast::def_native_mod(*) {\n+        fcx.ccx.tcx.sess.span_fatal(sp, \"expected value but found module\");\n+      }\n+      ast::def_use(*) {\n+        fcx.ccx.tcx.sess.span_fatal(sp, \"expected value but found use\");\n+      }\n+      ast::def_region(*) {\n+        fcx.ccx.tcx.sess.span_fatal(sp, \"expected value but found region\");\n       }\n     }\n }"}]}