{"sha": "e2a6c9e375c1d160133aadb202a948245e73e750", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyYTZjOWUzNzVjMWQxNjAxMzNhYWRiMjAyYTk0ODI0NWU3M2U3NTA=", "commit": {"author": {"name": "Pyriphlegethon", "email": "pyriphlegethon.github@gmail.com", "date": "2015-09-29T16:43:38Z"}, "committer": {"name": "Pyriphlegethon", "email": "pyriphlegethon.github@gmail.com", "date": "2015-09-29T16:46:16Z"}, "message": "Add unnecessary mut passed lint for methods", "tree": {"sha": "b2dd2f1af6a70111d01d355085971f3283d59d72", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b2dd2f1af6a70111d01d355085971f3283d59d72"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2a6c9e375c1d160133aadb202a948245e73e750", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2a6c9e375c1d160133aadb202a948245e73e750", "html_url": "https://github.com/rust-lang/rust/commit/e2a6c9e375c1d160133aadb202a948245e73e750", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2a6c9e375c1d160133aadb202a948245e73e750/comments", "author": {"login": "Pyriphlegethon", "id": 13908830, "node_id": "MDQ6VXNlcjEzOTA4ODMw", "avatar_url": "https://avatars.githubusercontent.com/u/13908830?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Pyriphlegethon", "html_url": "https://github.com/Pyriphlegethon", "followers_url": "https://api.github.com/users/Pyriphlegethon/followers", "following_url": "https://api.github.com/users/Pyriphlegethon/following{/other_user}", "gists_url": "https://api.github.com/users/Pyriphlegethon/gists{/gist_id}", "starred_url": "https://api.github.com/users/Pyriphlegethon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Pyriphlegethon/subscriptions", "organizations_url": "https://api.github.com/users/Pyriphlegethon/orgs", "repos_url": "https://api.github.com/users/Pyriphlegethon/repos", "events_url": "https://api.github.com/users/Pyriphlegethon/events{/privacy}", "received_events_url": "https://api.github.com/users/Pyriphlegethon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Pyriphlegethon", "id": 13908830, "node_id": "MDQ6VXNlcjEzOTA4ODMw", "avatar_url": "https://avatars.githubusercontent.com/u/13908830?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Pyriphlegethon", "html_url": "https://github.com/Pyriphlegethon", "followers_url": "https://api.github.com/users/Pyriphlegethon/followers", "following_url": "https://api.github.com/users/Pyriphlegethon/following{/other_user}", "gists_url": "https://api.github.com/users/Pyriphlegethon/gists{/gist_id}", "starred_url": "https://api.github.com/users/Pyriphlegethon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Pyriphlegethon/subscriptions", "organizations_url": "https://api.github.com/users/Pyriphlegethon/orgs", "repos_url": "https://api.github.com/users/Pyriphlegethon/repos", "events_url": "https://api.github.com/users/Pyriphlegethon/events{/privacy}", "received_events_url": "https://api.github.com/users/Pyriphlegethon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40e180d8c777a7689b20033b9c9eba982a9cebda", "url": "https://api.github.com/repos/rust-lang/rust/commits/40e180d8c777a7689b20033b9c9eba982a9cebda", "html_url": "https://github.com/rust-lang/rust/commit/40e180d8c777a7689b20033b9c9eba982a9cebda"}], "stats": {"total": 76, "additions": 53, "deletions": 23}, "files": [{"sha": "16973ea987ab15bf08deb8745b1f29cd67901ac1", "filename": "src/mut_reference.rs", "status": "modified", "additions": 53, "deletions": 23, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/e2a6c9e375c1d160133aadb202a948245e73e750/src%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a6c9e375c1d160133aadb202a948245e73e750/src%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmut_reference.rs?ref=e2a6c9e375c1d160133aadb202a948245e73e750", "patch": "@@ -1,12 +1,12 @@\n use rustc::lint::*;\n use rustc_front::hir::*;\n use utils::span_lint;\n-use rustc::middle::ty::{TypeAndMut, TypeVariants};\n+use rustc::middle::ty::{TypeAndMut, TypeVariants, MethodCall};\n \n declare_lint! {\n     pub UNNECESSARY_MUT_PASSED,\n     Warn,\n-    \"an argument is passed as a mutable reference although the function only demands an \\\n+    \"an argument is passed as a mutable reference although the function/method only demands an \\\n      immutable reference\"\n }\n \n@@ -22,32 +22,62 @@ impl LintPass for UnnecessaryMutPassed {\n \n impl LateLintPass for UnnecessaryMutPassed {\n     fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n-        if let &ExprCall(ref fn_expr, ref arguments) = &e.node {\n-            let borrowed_table = cx.tcx.tables.borrow();\n-            let funtion_type = match borrowed_table.node_types.get(&fn_expr.id) {\n-                Some(funtion_type) => funtion_type,\n-                None => unreachable!(), // A function with unknown type is called.\n-                                        // If this happened the compiler would have aborted the\n-                                        // compilation long ago.\n-            };\n-            if let TypeVariants::TyBareFn(_, ref b) = funtion_type.sty {\n-                let parameters = b.sig.skip_binder().inputs.clone();\n-                for (argument, parameter) in arguments.iter().zip(parameters.iter()) {\n-                    match parameter.sty {\n-                        TypeVariants::TyRef(_, TypeAndMut {ty: _, mutbl: MutImmutable}) | \n-                        TypeVariants::TyRawPtr(TypeAndMut {ty: _, mutbl: MutImmutable}) => {\n-                            if let Expr_::ExprAddrOf(MutMutable, _) = argument.node {\n-                                if let ExprPath(_, path) = fn_expr.node.clone() {\n+        match e.node {\n+            ExprCall(ref fn_expr, ref arguments) => {\n+                let borrowed_table = cx.tcx.tables.borrow();\n+                let funtion_type = match borrowed_table.node_types.get(&fn_expr.id) {\n+                    Some(funtion_type) => funtion_type,\n+                    None => unreachable!(), // A function with unknown type is called.\n+                                            // If this happened the compiler would have aborted the\n+                                            // compilation long ago.\n+                };\n+                if let TypeVariants::TyBareFn(_, ref b) = funtion_type.sty {\n+                    let parameters = b.sig.skip_binder().inputs.clone();\n+                    for (argument, parameter) in arguments.iter().zip(parameters.iter()) {\n+                        match parameter.sty {\n+                            TypeVariants::TyRef(_, TypeAndMut {ty: _, mutbl: MutImmutable}) | \n+                            TypeVariants::TyRawPtr(TypeAndMut {ty: _, mutbl: MutImmutable}) => {\n+                                if let Expr_::ExprAddrOf(MutMutable, _) = argument.node {\n+                                    if let ExprPath(_, path) = fn_expr.node.clone() {\n+                                        span_lint(cx, UNNECESSARY_MUT_PASSED, \n+                                                  argument.span, &format!(\"This argument of the \\\n+                                                  function \\\"{}\\\" doesn't need to be mutable\", path));\n+                                    }\n+                                }\n+                            },\n+                            _ => {}\n+                        }\n+                    }\n+                }\n+            },\n+            ExprMethodCall(ref name, _, ref arguments) => {\n+                let method_call = MethodCall::expr(e.id);\n+                let borrowed_table = cx.tcx.tables.borrow();\n+                let method_type = match borrowed_table.method_map.get(&method_call) {\n+                    Some(method_type) => method_type,\n+                    None => unreachable!(), // Just like above, this should never happen.\n+                };\n+                if let TypeVariants::TyBareFn(_, ref b) = method_type.ty.sty {\n+                    let parameters = b.sig.skip_binder().inputs.iter().clone();\n+                    for (argument, parameter) in arguments.iter().zip(parameters).skip(1) {\n+                        // Skip the first argument and the first parameter because it is the\n+                        // struct the function is called on.\n+                        match parameter.sty {\n+                            TypeVariants::TyRef(_, TypeAndMut {ty: _, mutbl: MutImmutable}) |\n+                            TypeVariants::TyRawPtr(TypeAndMut {ty: _, mutbl: MutImmutable}) => {\n+                                if let Expr_::ExprAddrOf(MutMutable, _) = argument.node {\n                                     span_lint(cx, UNNECESSARY_MUT_PASSED, \n                                               argument.span, &format!(\"This argument of the \\\n-                                              function \\\"{}\\\" doesn't need to be mutable\", path));\n+                                              method \\\"{}\\\" doesn't need to be mutable\", \n+                                              name.node.as_str()));\n                                 }\n-                            }\n-                        },\n-                        _ => {}\n+                            },\n+                            _ => {}\n+                        }\n                     }\n                 }\n-            }\n+            },\n+            _ => {}\n         }\n     }\n }"}]}