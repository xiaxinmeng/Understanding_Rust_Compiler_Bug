{"sha": "dc6ffaebd5b56793f86443a0a50c06f025321198", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjNmZmYWViZDViNTY3OTNmODY0NDNhMGE1MGMwNmYwMjUzMjExOTg=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-06-01T08:15:17Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-06-12T07:43:53Z"}, "message": "make miri InterpCx TyCtxtAt a TyCtxt, and separately remember the root span of the evaluation", "tree": {"sha": "efc7e72899235980de397f82bdd740c9fd569e57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/efc7e72899235980de397f82bdd740c9fd569e57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc6ffaebd5b56793f86443a0a50c06f025321198", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc6ffaebd5b56793f86443a0a50c06f025321198", "html_url": "https://github.com/rust-lang/rust/commit/dc6ffaebd5b56793f86443a0a50c06f025321198", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc6ffaebd5b56793f86443a0a50c06f025321198/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "871513d02cf4d5c40689052aa7a1f3681fc3fdcc", "url": "https://api.github.com/repos/rust-lang/rust/commits/871513d02cf4d5c40689052aa7a1f3681fc3fdcc", "html_url": "https://github.com/rust-lang/rust/commit/871513d02cf4d5c40689052aa7a1f3681fc3fdcc"}], "stats": {"total": 232, "additions": 123, "deletions": 109}, "files": [{"sha": "29da7ff0850656176e45f08b89e0c2c858471bd7", "filename": "src/librustc_middle/ty/util.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dc6ffaebd5b56793f86443a0a50c06f025321198/src%2Flibrustc_middle%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc6ffaebd5b56793f86443a0a50c06f025321198/src%2Flibrustc_middle%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Futil.rs?ref=dc6ffaebd5b56793f86443a0a50c06f025321198", "patch": "@@ -705,6 +705,7 @@ impl<'tcx> ty::TyS<'tcx> {\n     /// optimization as well as the rules around static values. Note\n     /// that the `Freeze` trait is not exposed to end users and is\n     /// effectively an implementation detail.\n+    // FIXME: use `TyCtxtAt` instead of separate `Span`.\n     pub fn is_freeze(\n         &'tcx self,\n         tcx: TyCtxt<'tcx>,"}, {"sha": "2aafafd8205d1c9a8ab85fc1e82d871d79bf6eb0", "filename": "src/librustc_mir/const_eval/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc6ffaebd5b56793f86443a0a50c06f025321198/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc6ffaebd5b56793f86443a0a50c06f025321198/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs?ref=dc6ffaebd5b56793f86443a0a50c06f025321198", "patch": "@@ -56,5 +56,5 @@ pub fn error_to_const_error<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>>(\n ) -> ConstEvalErr<'tcx> {\n     error.print_backtrace();\n     let stacktrace = ecx.generate_stacktrace();\n-    ConstEvalErr { error: error.kind, stacktrace, span: ecx.tcx.span }\n+    ConstEvalErr { error: error.kind, stacktrace, span: ecx.cur_span() }\n }"}, {"sha": "4101ea77c90808b08a079cff44eb3eece86cc75f", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/dc6ffaebd5b56793f86443a0a50c06f025321198/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc6ffaebd5b56793f86443a0a50c06f025321198/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=dc6ffaebd5b56793f86443a0a50c06f025321198", "patch": "@@ -27,7 +27,7 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n     body: &'mir mir::Body<'tcx>,\n ) -> InterpResult<'tcx, MPlaceTy<'tcx>> {\n     debug!(\"eval_body_using_ecx: {:?}, {:?}\", cid, ecx.param_env);\n-    let tcx = ecx.tcx.tcx;\n+    let tcx = ecx.tcx;\n     let layout = ecx.layout_of(body.return_ty().subst(tcx, cid.instance.substs))?;\n     assert!(!layout.is_unsized());\n     let ret = ecx.allocate(layout, MemoryKind::Stack);\n@@ -81,13 +81,14 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n /// parameter. These bounds are passed to `mk_eval_cx` via the `ParamEnv` argument.\n pub(super) fn mk_eval_cx<'mir, 'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    span: Span,\n+    root_span: Span,\n     param_env: ty::ParamEnv<'tcx>,\n     can_access_statics: bool,\n ) -> CompileTimeEvalContext<'mir, 'tcx> {\n     debug!(\"mk_eval_cx: {:?}\", param_env);\n     InterpCx::new(\n-        tcx.at(span),\n+        tcx,\n+        root_span,\n         param_env,\n         CompileTimeInterpreter::new(tcx.sess.const_eval_limit()),\n         MemoryExtra { can_access_statics },\n@@ -163,7 +164,7 @@ pub(super) fn op_to_const<'tcx>(\n                         0,\n                     ),\n                 };\n-                let len = b.to_machine_usize(&ecx.tcx.tcx).unwrap();\n+                let len = b.to_machine_usize(ecx).unwrap();\n                 let start = start.try_into().unwrap();\n                 let len: usize = len.try_into().unwrap();\n                 ConstValue::Slice { data, start, end: start + len }\n@@ -213,7 +214,7 @@ fn validate_and_turn_into_const<'tcx>(\n \n     val.map_err(|error| {\n         let err = error_to_const_error(&ecx, error);\n-        err.struct_error(ecx.tcx, \"it is undefined behavior to use this value\", |mut diag| {\n+        err.struct_error(ecx.tcx_at(), \"it is undefined behavior to use this value\", |mut diag| {\n             diag.note(note_on_undefined_behavior_error());\n             diag.emit();\n         })\n@@ -299,9 +300,9 @@ pub fn const_eval_raw_provider<'tcx>(\n \n     let is_static = tcx.is_static(def_id);\n \n-    let span = tcx.def_span(cid.instance.def_id());\n     let mut ecx = InterpCx::new(\n-        tcx.at(span),\n+        tcx,\n+        tcx.def_span(cid.instance.def_id()),\n         key.param_env,\n         CompileTimeInterpreter::new(tcx.sess.const_eval_limit()),\n         MemoryExtra { can_access_statics: is_static },\n@@ -316,7 +317,7 @@ pub fn const_eval_raw_provider<'tcx>(\n             if is_static {\n                 // Ensure that if the above error was either `TooGeneric` or `Reported`\n                 // an error must be reported.\n-                let v = err.report_as_error(ecx.tcx, \"could not evaluate static initializer\");\n+                let v = err.report_as_error(ecx.tcx_at(), \"could not evaluate static initializer\");\n \n                 // If this is `Reveal:All`, then we need to make sure an error is reported but if\n                 // this is `Reveal::UserFacing`, then it's expected that we could get a\n@@ -372,13 +373,13 @@ pub fn const_eval_raw_provider<'tcx>(\n                         // anything else (array lengths, enum initializers, constant patterns) are\n                         // reported as hard errors\n                         } else {\n-                            err.report_as_error(ecx.tcx, \"evaluation of constant value failed\")\n+                            err.report_as_error(ecx.tcx_at(), \"evaluation of constant value failed\")\n                         }\n                     }\n                 }\n             } else {\n                 // use of broken constant from other crate\n-                err.report_as_error(ecx.tcx, \"could not evaluate constant\")\n+                err.report_as_error(ecx.tcx_at(), \"could not evaluate constant\")\n             }\n         })\n }"}, {"sha": "287b43ac50f96614ec20e97f4c53a897fb8189a6", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dc6ffaebd5b56793f86443a0a50c06f025321198/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc6ffaebd5b56793f86443a0a50c06f025321198/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=dc6ffaebd5b56793f86443a0a50c06f025321198", "patch": "@@ -56,7 +56,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         }\n \n                         let instance = ty::Instance::resolve_for_fn_ptr(\n-                            *self.tcx,\n+                            self.tcx,\n                             self.param_env,\n                             def_id,\n                             substs,\n@@ -91,7 +91,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         }\n \n                         let instance = ty::Instance::resolve_closure(\n-                            *self.tcx,\n+                            self.tcx,\n                             def_id,\n                             substs,\n                             ty::ClosureKind::FnOnce,\n@@ -140,7 +140,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // Handle cast from a univariant (ZST) enum.\n         match src.layout.variants {\n             Variants::Single { index } => {\n-                if let Some(discr) = src.layout.ty.discriminant_for_variant(*self.tcx, index) {\n+                if let Some(discr) = src.layout.ty.discriminant_for_variant(self.tcx, index) {\n                     assert!(src.layout.is_zst());\n                     let discr_layout = self.layout_of(discr.ty)?;\n                     return Ok(self.cast_from_scalar(discr.val, discr_layout, cast_ty).into());\n@@ -270,7 +270,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // u64 cast is from usize to u64, which is always good\n                 let val = Immediate::new_slice(\n                     ptr,\n-                    length.eval_usize(self.tcx.tcx, self.param_env),\n+                    length.eval_usize(self.tcx, self.param_env),\n                     self,\n                 );\n                 self.write_immediate(val, dest)"}, {"sha": "1715b6fede9629365fd2e922d28b2e0c4a5aad30", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 38, "deletions": 22, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/dc6ffaebd5b56793f86443a0a50c06f025321198/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc6ffaebd5b56793f86443a0a50c06f025321198/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=dc6ffaebd5b56793f86443a0a50c06f025321198", "patch": "@@ -33,7 +33,11 @@ pub struct InterpCx<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     pub machine: M,\n \n     /// The results of the type checker, from rustc.\n-    pub tcx: TyCtxtAt<'tcx>,\n+    pub tcx: TyCtxt<'tcx>,\n+\n+    /// The span of the \"root\" of the evaluation, i.e., the const\n+    /// we are evaluating (if this is CTFE).\n+    pub(super) root_span: Span,\n \n     /// Bounds in scope for polymorphic evaluations.\n     pub(crate) param_env: ty::ParamEnv<'tcx>,\n@@ -196,7 +200,7 @@ where\n {\n     #[inline]\n     fn tcx(&self) -> TyCtxt<'tcx> {\n-        *self.tcx\n+        self.tcx\n     }\n }\n \n@@ -209,13 +213,13 @@ where\n     }\n }\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> LayoutOf for InterpCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> LayoutOf for InterpCx<'mir, 'tcx, M> {\n     type Ty = Ty<'tcx>;\n     type TyAndLayout = InterpResult<'tcx, TyAndLayout<'tcx>>;\n \n     #[inline]\n     fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyAndLayout {\n-        self.tcx\n+        self.tcx_at()\n             .layout_of(self.param_env.and(ty))\n             .map_err(|layout| err_inval!(Layout(layout)).into())\n     }\n@@ -292,23 +296,35 @@ pub(super) fn from_known_layout<'tcx>(\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn new(\n-        tcx: TyCtxtAt<'tcx>,\n+        tcx: TyCtxt<'tcx>,\n+        root_span: Span,\n         param_env: ty::ParamEnv<'tcx>,\n         machine: M,\n         memory_extra: M::MemoryExtra,\n     ) -> Self {\n         InterpCx {\n             machine,\n             tcx,\n+            root_span,\n             param_env,\n-            memory: Memory::new(*tcx, memory_extra),\n+            memory: Memory::new(tcx, memory_extra),\n             vtables: FxHashMap::default(),\n         }\n     }\n \n     #[inline(always)]\n-    pub fn set_span(&mut self, span: Span) {\n-        self.tcx.span = span;\n+    pub fn cur_span(&self) -> Span {\n+        self\n+            .stack()\n+            .last()\n+            .and_then(|f| f.current_source_info())\n+            .map(|si| si.span)\n+            .unwrap_or(self.root_span)\n+    }\n+\n+    #[inline(always)]\n+    pub fn tcx_at(&self) -> TyCtxtAt<'tcx> {\n+        self.tcx.at(self.cur_span())\n     }\n \n     #[inline(always)]\n@@ -386,12 +402,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     #[inline]\n     pub fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n-        ty.is_sized(self.tcx, self.param_env)\n+        ty.is_sized(self.tcx_at(), self.param_env)\n     }\n \n     #[inline]\n     pub fn type_is_freeze(&self, ty: Ty<'tcx>) -> bool {\n-        ty.is_freeze(*self.tcx, self.param_env, DUMMY_SP)\n+        ty.is_freeze(self.tcx, self.param_env, self.cur_span())\n     }\n \n     pub fn load_mir(\n@@ -402,20 +418,20 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // do not continue if typeck errors occurred (can only occur in local crate)\n         let did = instance.def_id();\n         if let Some(did) = did.as_local() {\n-            if self.tcx.has_typeck_tables(did) {\n-                if let Some(error_reported) = self.tcx.typeck_tables_of(did).tainted_by_errors {\n+            if self.tcx_at().has_typeck_tables(did) {\n+                if let Some(error_reported) = self.tcx_at().typeck_tables_of(did).tainted_by_errors {\n                     throw_inval!(TypeckError(error_reported))\n                 }\n             }\n         }\n         trace!(\"load mir(instance={:?}, promoted={:?})\", instance, promoted);\n         if let Some(promoted) = promoted {\n-            return Ok(&self.tcx.promoted_mir(did)[promoted]);\n+            return Ok(&self.tcx_at().promoted_mir(did)[promoted]);\n         }\n         match instance {\n             ty::InstanceDef::Item(def_id) => {\n-                if self.tcx.is_mir_available(did) {\n-                    Ok(self.tcx.optimized_mir(did))\n+                if self.tcx_at().is_mir_available(did) {\n+                    Ok(self.tcx_at().optimized_mir(did))\n                 } else {\n                     throw_unsup!(NoMirFor(def_id))\n                 }\n@@ -456,7 +472,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         trace!(\"resolve: {:?}, {:#?}\", def_id, substs);\n         trace!(\"param_env: {:#?}\", self.param_env);\n         trace!(\"substs: {:#?}\", substs);\n-        match ty::Instance::resolve(*self.tcx, self.param_env, def_id, substs) {\n+        match ty::Instance::resolve(self.tcx, self.param_env, def_id, substs) {\n             Ok(Some(instance)) => Ok(instance),\n             Ok(None) => throw_inval!(TooGeneric),\n \n@@ -475,7 +491,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // have to support that case (mostly by skipping all caching).\n         match frame.locals.get(local).and_then(|state| state.layout.get()) {\n             None => {\n-                let layout = from_known_layout(self.tcx, layout, || {\n+                let layout = from_known_layout(self.tcx_at(), layout, || {\n                     let local_ty = frame.body.local_decls[local].ty;\n                     let local_ty =\n                         self.subst_from_frame_and_normalize_erasing_regions(frame, local_ty);\n@@ -560,7 +576,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let size = size.align_to(align);\n \n                 // Check if this brought us over the size limit.\n-                if size.bytes() >= self.tcx.data_layout().obj_size_bound() {\n+                if size.bytes() >= self.tcx.data_layout.obj_size_bound() {\n                     throw_ub!(InvalidMeta(\"total size is bigger than largest supported object\"));\n                 }\n                 Ok(Some((size, align)))\n@@ -576,7 +592,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let elem = layout.field(self, 0)?;\n \n                 // Make sure the slice is not too big.\n-                let size = elem.size.checked_mul(len, &*self.tcx).ok_or_else(|| {\n+                let size = elem.size.checked_mul(len, self).ok_or_else(|| {\n                     err_ub!(InvalidMeta(\"slice is bigger than largest supported object\"))\n                 })?;\n                 Ok(Some((size, elem.align.abi)))\n@@ -627,7 +643,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let mut locals = IndexVec::from_elem(dummy, &body.local_decls);\n \n         // Now mark those locals as dead that we do not want to initialize\n-        match self.tcx.def_kind(instance.def_id()) {\n+        match self.tcx_at().def_kind(instance.def_id()) {\n             // statics and constants don't have `Storage*` statements, no need to look for them\n             //\n             // FIXME: The above is likely untrue. See\n@@ -842,7 +858,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         } else {\n             self.param_env\n         };\n-        let val = self.tcx.const_eval_global_id(param_env, gid, Some(self.tcx.span))?;\n+        let val = self.tcx.const_eval_global_id(param_env, gid, Some(self.cur_span()))?;\n \n         // Even though `ecx.const_eval` is called from `eval_const_to_op` we can never have a\n         // recursion deeper than one level, because the `tcx.const_eval` above is guaranteed to not\n@@ -873,7 +889,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // FIXME: We can hit delay_span_bug if this is an invalid const, interning finds\n         // that problem, but we never run validation to show an error. Can we ensure\n         // this does not happen?\n-        let val = self.tcx.const_eval_raw(param_env.and(gid))?;\n+        let val = self.tcx_at().const_eval_raw(param_env.and(gid))?;\n         self.raw_const_to_mplace(val)\n     }\n "}, {"sha": "284a1d5ea61ef9359337e57a4cf2f0d097bc4d62", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dc6ffaebd5b56793f86443a0a50c06f025321198/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc6ffaebd5b56793f86443a0a50c06f025321198/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=dc6ffaebd5b56793f86443a0a50c06f025321198", "patch": "@@ -93,7 +93,7 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>>(\n             // in the value the dangling reference lies.\n             // The `delay_span_bug` ensures that we don't forget such a check in validation.\n             if tcx.get_global_alloc(alloc_id).is_none() {\n-                tcx.sess.delay_span_bug(ecx.tcx.span, \"tried to intern dangling pointer\");\n+                tcx.sess.delay_span_bug(ecx.root_span, \"tried to intern dangling pointer\");\n             }\n             // treat dangling pointers like other statics\n             // just to stop trying to recurse into them\n@@ -111,7 +111,7 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>>(\n     if let InternMode::Static(mutability) = mode {\n         // For this, we need to take into account `UnsafeCell`. When `ty` is `None`, we assume\n         // no interior mutability.\n-        let frozen = ty.map_or(true, |ty| ty.is_freeze(ecx.tcx.tcx, ecx.param_env, ecx.tcx.span));\n+        let frozen = ty.map_or(true, |ty| ty.is_freeze(ecx.tcx, ecx.param_env, ecx.root_span));\n         // For statics, allocation mutability is the combination of the place mutability and\n         // the type mutability.\n         // The entire allocation needs to be mutable if it contains an `UnsafeCell` anywhere.\n@@ -174,7 +174,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n                     // they caused.  It also helps us to find cases where const-checking\n                     // failed to prevent an `UnsafeCell` (but as `ignore_interior_mut_in_const`\n                     // shows that part is not airtight).\n-                    mutable_memory_in_const(self.ecx.tcx, \"`UnsafeCell`\");\n+                    mutable_memory_in_const(self.ecx.tcx_at(), \"`UnsafeCell`\");\n                 }\n                 // We are crossing over an `UnsafeCell`, we can mutate again. This means that\n                 // References we encounter inside here are interned as pointing to mutable\n@@ -192,7 +192,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n     fn visit_value(&mut self, mplace: MPlaceTy<'tcx>) -> InterpResult<'tcx> {\n         // Handle Reference types, as these are the only relocations supported by const eval.\n         // Raw pointers (and boxes) are handled by the `leftover_relocations` logic.\n-        let tcx = self.ecx.tcx;\n+        let tcx = self.ecx.tcx.at(self.ecx.root_span);\n         let ty = mplace.layout.ty;\n         if let ty::Ref(_, referenced_ty, ref_mutability) = ty.kind {\n             let value = self.ecx.read_immediate(mplace.into())?;\n@@ -254,7 +254,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n                         if ref_mutability == Mutability::Mut {\n                             match referenced_ty.kind {\n                                 ty::Array(_, n)\n-                                    if n.eval_usize(tcx.tcx, self.ecx.param_env) == 0 => {}\n+                                    if n.eval_usize(self.ecx.tcx, self.ecx.param_env) == 0 => {}\n                                 ty::Slice(_)\n                                     if mplace.meta.unwrap_meta().to_machine_usize(self.ecx)?\n                                         == 0 => {}\n@@ -358,7 +358,7 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n             Ok(()) => {}\n             Err(error) => {\n                 ecx.tcx.sess.delay_span_bug(\n-                    ecx.tcx.span,\n+                    ecx.root_span,\n                     \"error during interning should later cause validation failure\",\n                 );\n                 // Some errors shouldn't come up because creating them causes\n@@ -407,7 +407,7 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n                     // such as `const CONST_RAW: *const Vec<i32> = &Vec::new() as *const _;`.\n                     ecx.tcx\n                         .sess\n-                        .span_err(ecx.tcx.span, \"untyped pointers are not allowed in constant\");\n+                        .span_err(ecx.root_span, \"untyped pointers are not allowed in constant\");\n                     // For better errors later, mark the allocation as immutable.\n                     alloc.mutability = Mutability::Not;\n                 }\n@@ -422,11 +422,11 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n         } else if ecx.memory.dead_alloc_map.contains_key(&alloc_id) {\n             // Codegen does not like dangling pointers, and generally `tcx` assumes that\n             // all allocations referenced anywhere actually exist. So, make sure we error here.\n-            ecx.tcx.sess.span_err(ecx.tcx.span, \"encountered dangling pointer in final constant\");\n+            ecx.tcx.sess.span_err(ecx.root_span, \"encountered dangling pointer in final constant\");\n         } else if ecx.tcx.get_global_alloc(alloc_id).is_none() {\n             // We have hit an `AllocId` that is neither in local or global memory and isn't\n             // marked as dangling by local memory.  That should be impossible.\n-            span_bug!(ecx.tcx.span, \"encountered unknown alloc id {:?}\", alloc_id);\n+            span_bug!(ecx.root_span, \"encountered unknown alloc id {:?}\", alloc_id);\n         }\n     }\n }"}, {"sha": "c62fd316dc58426bb2aa017f61beba0e70a65a5c", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc6ffaebd5b56793f86443a0a50c06f025321198/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc6ffaebd5b56793f86443a0a50c06f025321198/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=dc6ffaebd5b56793f86443a0a50c06f025321198", "patch": "@@ -347,7 +347,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let index = u64::from(self.read_scalar(args[1])?.to_u32()?);\n                 let elem = args[2];\n                 let input = args[0];\n-                let (len, e_ty) = input.layout.ty.simd_size_and_type(self.tcx.tcx);\n+                let (len, e_ty) = input.layout.ty.simd_size_and_type(self.tcx);\n                 assert!(\n                     index < len,\n                     \"Index `{}` must be in bounds of vector type `{}`: `[0, {})`\",\n@@ -374,7 +374,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n             sym::simd_extract => {\n                 let index = u64::from(self.read_scalar(args[1])?.to_u32()?);\n-                let (len, e_ty) = args[0].layout.ty.simd_size_and_type(self.tcx.tcx);\n+                let (len, e_ty) = args[0].layout.ty.simd_size_and_type(self.tcx);\n                 assert!(\n                     index < len,\n                     \"index `{}` is out-of-bounds of vector type `{}` with length `{}`\","}, {"sha": "193d38dc5523e18a59030f24583f7cf8e434a684", "filename": "src/librustc_mir/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc6ffaebd5b56793f86443a0a50c06f025321198/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc6ffaebd5b56793f86443a0a50c06f025321198/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=dc6ffaebd5b56793f86443a0a50c06f025321198", "patch": "@@ -25,7 +25,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     \"find_closest_untracked_caller_location: checking frame {:?}\",\n                     frame.instance\n                 );\n-                !frame.instance.def.requires_caller_location(*self.tcx)\n+                !frame.instance.def.requires_caller_location(self.tcx)\n             })\n             // Assert that there is always such a frame.\n             .unwrap();\n@@ -58,7 +58,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let loc_ty = self\n             .tcx\n             .type_of(self.tcx.require_lang_item(PanicLocationLangItem, None))\n-            .subst(*self.tcx, self.tcx.mk_substs([self.tcx.lifetimes.re_erased.into()].iter()));\n+            .subst(self.tcx, self.tcx.mk_substs([self.tcx.lifetimes.re_erased.into()].iter()));\n         let loc_layout = self.layout_of(loc_ty).unwrap();\n         let location = self.allocate(loc_layout, MemoryKind::CallerLocation);\n "}, {"sha": "8af1a8ac608ac8f2a56f4bb61d0c4d455a2a037b", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc6ffaebd5b56793f86443a0a50c06f025321198/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc6ffaebd5b56793f86443a0a50c06f025321198/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=dc6ffaebd5b56793f86443a0a50c06f025321198", "patch": "@@ -14,7 +14,7 @@ use std::ptr;\n \n use rustc_ast::ast::Mutability;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_middle::ty::{self, TyCtxt, Instance, ParamEnv};\n+use rustc_middle::ty::{self, Instance, ParamEnv, TyCtxt};\n use rustc_target::abi::{Align, HasDataLayout, Size, TargetDataLayout};\n \n use super::{"}, {"sha": "c9250098fedba4f3b002bcd122313019a6d60806", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dc6ffaebd5b56793f86443a0a50c06f025321198/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc6ffaebd5b56793f86443a0a50c06f025321198/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=dc6ffaebd5b56793f86443a0a50c06f025321198", "patch": "@@ -471,9 +471,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         trace!(\"eval_place_to_op: got {:?}\", *op);\n         // Sanity-check the type we ended up with.\n         debug_assert!(mir_assign_valid_types(\n-            *self.tcx,\n+            self.tcx,\n             self.layout_of(self.subst_from_current_frame_and_normalize_erasing_regions(\n-                place.ty(&self.frame().body.local_decls, *self.tcx).ty\n+                place.ty(&self.frame().body.local_decls, self.tcx).ty\n             ))?,\n             op.layout,\n         ));\n@@ -554,7 +554,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // documentation).\n         let val_val = M::adjust_global_const(self, val_val)?;\n         // Other cases need layout.\n-        let layout = from_known_layout(self.tcx, layout, || self.layout_of(val.ty))?;\n+        let layout = from_known_layout(self.tcx_at(), layout, || self.layout_of(val.ty))?;\n         let op = match val_val {\n             ConstValue::ByRef { alloc, offset } => {\n                 let id = self.tcx.create_memory_alloc(alloc);\n@@ -589,7 +589,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         trace!(\"read_discriminant_value {:#?}\", op.layout);\n \n         // Get type and layout of the discriminant.\n-        let discr_layout = self.layout_of(op.layout.ty.discriminant_ty(*self.tcx))?;\n+        let discr_layout = self.layout_of(op.layout.ty.discriminant_ty(self.tcx))?;\n         trace!(\"discriminant type: {:?}\", discr_layout.ty);\n \n         // We use \"discriminant\" to refer to the value associated with a particular enum variant.\n@@ -601,7 +601,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // rather confusing.\n         let (tag_scalar_layout, tag_kind, tag_index) = match op.layout.variants {\n             Variants::Single { index } => {\n-                let discr = match op.layout.ty.discriminant_for_variant(*self.tcx, index) {\n+                let discr = match op.layout.ty.discriminant_for_variant(self.tcx, index) {\n                     Some(discr) => {\n                         // This type actually has discriminants.\n                         assert_eq!(discr.ty, discr_layout.ty);\n@@ -630,7 +630,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         //   may be a pointer. This is `tag_val.layout`; we just use it for sanity checks.\n \n         // Get layout for tag.\n-        let tag_layout = self.layout_of(tag_scalar_layout.value.to_int_ty(*self.tcx))?;\n+        let tag_layout = self.layout_of(tag_scalar_layout.value.to_int_ty(self.tcx))?;\n \n         // Read tag and sanity-check `tag_layout`.\n         let tag_val = self.read_immediate(self.operand_field(op, tag_index)?)?;\n@@ -651,12 +651,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // Convert discriminant to variant index, and catch invalid discriminants.\n                 let index = match op.layout.ty.kind {\n                     ty::Adt(adt, _) => {\n-                        adt.discriminants(self.tcx.tcx).find(|(_, var)| var.val == discr_bits)\n+                        adt.discriminants(self.tcx).find(|(_, var)| var.val == discr_bits)\n                     }\n                     ty::Generator(def_id, substs, _) => {\n                         let substs = substs.as_generator();\n                         substs\n-                            .discriminants(def_id, self.tcx.tcx)\n+                            .discriminants(def_id, self.tcx)\n                             .find(|(_, var)| var.val == discr_bits)\n                     }\n                     _ => bug!(\"tagged layout for non-adt non-generator\"),"}, {"sha": "0b4e92574a0665ad5baad98958c3a9d7abc57763", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/dc6ffaebd5b56793f86443a0a50c06f025321198/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc6ffaebd5b56793f86443a0a50c06f025321198/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=dc6ffaebd5b56793f86443a0a50c06f025321198", "patch": "@@ -404,7 +404,7 @@ where\n                     // to get some code to work that probably ought to work.\n                     field_layout.align.abi\n                 }\n-                None => bug!(\"Cannot compute offset for extern type field at non-0 offset\"),\n+                None => span_bug!(self.cur_span(), \"cannot compute offset for extern type field at non-0 offset\"),\n             };\n             (base.meta, offset.align_to(align))\n         } else {\n@@ -440,7 +440,7 @@ where\n                 assert!(!field_layout.is_unsized());\n                 base.offset(offset, MemPlaceMeta::None, field_layout, self)\n             }\n-            _ => bug!(\"`mplace_index` called on non-array type {:?}\", base.layout.ty),\n+            _ => span_bug!(self.cur_span(), \"`mplace_index` called on non-array type {:?}\", base.layout.ty),\n         }\n     }\n \n@@ -454,7 +454,7 @@ where\n         let len = base.len(self)?; // also asserts that we have a type where this makes sense\n         let stride = match base.layout.fields {\n             FieldsShape::Array { stride, .. } => stride,\n-            _ => bug!(\"mplace_array_fields: expected an array layout\"),\n+            _ => span_bug!(self.cur_span(), \"mplace_array_fields: expected an array layout\"),\n         };\n         let layout = base.layout.field(self, 0)?;\n         let dl = &self.tcx.data_layout;\n@@ -484,7 +484,7 @@ where\n         // (that have count 0 in their layout).\n         let from_offset = match base.layout.fields {\n             FieldsShape::Array { stride, .. } => stride * from, // `Size` multiplication is checked\n-            _ => bug!(\"Unexpected layout of index access: {:#?}\", base.layout),\n+            _ => span_bug!(self.cur_span(), \"unexpected layout of index access: {:#?}\", base.layout),\n         };\n \n         // Compute meta and new layout\n@@ -497,7 +497,7 @@ where\n                 let len = Scalar::from_machine_usize(inner_len, self);\n                 (MemPlaceMeta::Meta(len), base.layout.ty)\n             }\n-            _ => bug!(\"cannot subslice non-array type: `{:?}`\", base.layout.ty),\n+            _ => span_bug!(self.cur_span(), \"cannot subslice non-array type: `{:?}`\", base.layout.ty),\n         };\n         let layout = self.layout_of(ty)?;\n         base.offset(from_offset, meta, layout, self)\n@@ -640,9 +640,9 @@ where\n         self.dump_place(place_ty.place);\n         // Sanity-check the type we ended up with.\n         debug_assert!(mir_assign_valid_types(\n-            *self.tcx,\n+            self.tcx,\n             self.layout_of(self.subst_from_current_frame_and_normalize_erasing_regions(\n-                place.ty(&self.frame().body.local_decls, *self.tcx).ty\n+                place.ty(&self.frame().body.local_decls, self.tcx).ty\n             ))?,\n             place_ty.layout,\n         ));\n@@ -768,7 +768,7 @@ where\n             None => return Ok(()), // zero-sized access\n         };\n \n-        let tcx = &*self.tcx;\n+        let tcx = self.tcx;\n         // FIXME: We should check that there are dest.layout.size many bytes available in\n         // memory.  The code below is not sufficient, with enough padding it might not\n         // cover all the bytes!\n@@ -777,11 +777,11 @@ where\n                 match dest.layout.abi {\n                     Abi::Scalar(_) => {} // fine\n                     _ => {\n-                        bug!(\"write_immediate_to_mplace: invalid Scalar layout: {:#?}\", dest.layout)\n+                        span_bug!(self.cur_span(), \"write_immediate_to_mplace: invalid Scalar layout: {:#?}\", dest.layout)\n                     }\n                 }\n                 self.memory.get_raw_mut(ptr.alloc_id)?.write_scalar(\n-                    tcx,\n+                    &tcx,\n                     ptr,\n                     scalar,\n                     dest.layout.size,\n@@ -793,7 +793,8 @@ where\n                 // which `ptr.offset(b_offset)` cannot possibly fail to satisfy.\n                 let (a, b) = match dest.layout.abi {\n                     Abi::ScalarPair(ref a, ref b) => (&a.value, &b.value),\n-                    _ => bug!(\n+                    _ => span_bug!(\n+                        self.cur_span(),\n                         \"write_immediate_to_mplace: invalid ScalarPair layout: {:#?}\",\n                         dest.layout\n                     ),\n@@ -806,8 +807,8 @@ where\n                 // but that does not work: We could be a newtype around a pair, then the\n                 // fields do not match the `ScalarPair` components.\n \n-                self.memory.get_raw_mut(ptr.alloc_id)?.write_scalar(tcx, ptr, a_val, a_size)?;\n-                self.memory.get_raw_mut(b_ptr.alloc_id)?.write_scalar(tcx, b_ptr, b_val, b_size)\n+                self.memory.get_raw_mut(ptr.alloc_id)?.write_scalar(&tcx, ptr, a_val, a_size)?;\n+                self.memory.get_raw_mut(b_ptr.alloc_id)?.write_scalar(&tcx, b_ptr, b_val, b_size)\n             }\n         }\n     }\n@@ -841,9 +842,9 @@ where\n     ) -> InterpResult<'tcx> {\n         // We do NOT compare the types for equality, because well-typed code can\n         // actually \"transmute\" `&mut T` to `&T` in an assignment without a cast.\n-        if !mir_assign_valid_types(self.tcx.tcx, src.layout, dest.layout) {\n+        if !mir_assign_valid_types(self.tcx, src.layout, dest.layout) {\n             span_bug!(\n-                self.tcx.span,\n+                self.cur_span(),\n                 \"type mismatch when copying!\\nsrc: {:?},\\ndest: {:?}\",\n                 src.layout.ty,\n                 dest.layout.ty,\n@@ -898,7 +899,7 @@ where\n         src: OpTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n-        if mir_assign_valid_types(self.tcx.tcx, src.layout, dest.layout) {\n+        if mir_assign_valid_types(self.tcx, src.layout, dest.layout) {\n             // Fast path: Just use normal `copy_op`\n             return self.copy_op(src, dest);\n         }\n@@ -910,7 +911,7 @@ where\n             // on `typeck_tables().has_errors` at all const eval entry points.\n             debug!(\"Size mismatch when transmuting!\\nsrc: {:#?}\\ndest: {:#?}\", src, dest);\n             self.tcx.sess.delay_span_bug(\n-                self.tcx.span,\n+                self.cur_span(),\n                 \"size-changing transmute, should have been caught by transmute checking\",\n             );\n             throw_inval!(TransmuteSizeDiff(src.layout.ty, dest.layout.ty));\n@@ -1056,7 +1057,7 @@ where\n                 // `TyAndLayout::for_variant()` call earlier already checks the variant is valid.\n \n                 let discr_val =\n-                    dest.layout.ty.discriminant_for_variant(*self.tcx, variant_index).unwrap().val;\n+                    dest.layout.ty.discriminant_for_variant(self.tcx, variant_index).unwrap().val;\n \n                 // raw discriminants for enums are isize or bigger during\n                 // their computation, but the in-memory tag is the smallest possible\n@@ -1085,7 +1086,7 @@ where\n                         .expect(\"overflow computing relative variant idx\");\n                     // We need to use machine arithmetic when taking into account `niche_start`:\n                     // discr_val = variant_index_relative + niche_start_val\n-                    let discr_layout = self.layout_of(discr_layout.value.to_int_ty(*self.tcx))?;\n+                    let discr_layout = self.layout_of(discr_layout.value.to_int_ty(self.tcx))?;\n                     let niche_start_val = ImmTy::from_uint(niche_start, discr_layout);\n                     let variant_index_relative_val =\n                         ImmTy::from_uint(variant_index_relative, discr_layout);"}, {"sha": "16c6396799e634eedbb067b7409966875ccb2208", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc6ffaebd5b56793f86443a0a50c06f025321198/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc6ffaebd5b56793f86443a0a50c06f025321198/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=dc6ffaebd5b56793f86443a0a50c06f025321198", "patch": "@@ -76,7 +76,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     fn statement(&mut self, stmt: &mir::Statement<'tcx>) -> InterpResult<'tcx> {\n         info!(\"{:?}\", stmt);\n-        self.set_span(stmt.source_info.span);\n \n         use rustc_middle::mir::StatementKind::*;\n \n@@ -279,7 +278,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     fn terminator(&mut self, terminator: &mir::Terminator<'tcx>) -> InterpResult<'tcx> {\n         info!(\"{:?}\", terminator.kind);\n-        self.set_span(terminator.source_info.span);\n \n         self.eval_terminator(terminator)?;\n         if !self.stack().is_empty() {"}, {"sha": "9a4dd0a5204f98ad6d88e75d57a116aad446d09e", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dc6ffaebd5b56793f86443a0a50c06f025321198/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc6ffaebd5b56793f86443a0a50c06f025321198/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=dc6ffaebd5b56793f86443a0a50c06f025321198", "patch": "@@ -69,7 +69,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         (fn_val, caller_abi)\n                     }\n                     ty::FnDef(def_id, substs) => {\n-                        let sig = func.layout.ty.fn_sig(*self.tcx);\n+                        let sig = func.layout.ty.fn_sig(self.tcx);\n                         (FnVal::Instance(self.resolve(def_id, substs)?), sig.abi())\n                     }\n                     _ => span_bug!(\n@@ -96,7 +96,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let ty = place.layout.ty;\n                 trace!(\"TerminatorKind::drop: {:?}, type {}\", location, ty);\n \n-                let instance = Instance::resolve_drop_in_place(*self.tcx, ty);\n+                let instance = Instance::resolve_drop_in_place(self.tcx, ty);\n                 self.drop_in_place(place, instance, target, unwind)?;\n             }\n \n@@ -227,9 +227,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // ABI check\n         {\n             let callee_abi = {\n-                let instance_ty = instance.ty_env(*self.tcx, self.param_env);\n+                let instance_ty = instance.ty_env(self.tcx, self.param_env);\n                 match instance_ty.kind {\n-                    ty::FnDef(..) => instance_ty.fn_sig(*self.tcx).abi(),\n+                    ty::FnDef(..) => instance_ty.fn_sig(self.tcx).abi(),\n                     ty::Closure(..) => Abi::RustCall,\n                     ty::Generator(..) => Abi::Rust,\n                     _ => bug!(\"unexpected callee ty: {:?}\", instance_ty),"}, {"sha": "87493a8d383ec6fed8eb81bd13b051cfd60eafde", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/dc6ffaebd5b56793f86443a0a50c06f025321198/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc6ffaebd5b56793f86443a0a50c06f025321198/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=dc6ffaebd5b56793f86443a0a50c06f025321198", "patch": "@@ -2,7 +2,7 @@ use std::convert::TryFrom;\n \n use rustc_middle::mir::interpret::{InterpResult, Pointer, PointerArithmetic, Scalar};\n use rustc_middle::ty::{self, Instance, Ty, TypeFoldable};\n-use rustc_target::abi::{Align, HasDataLayout, LayoutOf, Size};\n+use rustc_target::abi::{Align, LayoutOf, Size};\n \n use super::{FnVal, InterpCx, Machine, MemoryKind};\n \n@@ -36,10 +36,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n \n         let methods = if let Some(poly_trait_ref) = poly_trait_ref {\n-            let trait_ref = poly_trait_ref.with_self_ty(*self.tcx, ty);\n+            let trait_ref = poly_trait_ref.with_self_ty(self.tcx, ty);\n             let trait_ref = self.tcx.erase_regions(&trait_ref);\n \n-            self.tcx.vtable_methods(trait_ref)\n+            self.tcx_at().vtable_methods(trait_ref)\n         } else {\n             &[]\n         };\n@@ -49,8 +49,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let size = layout.size.bytes();\n         let align = layout.align.abi.bytes();\n \n+        let tcx = self.tcx;\n         let ptr_size = self.pointer_size();\n-        let ptr_align = self.tcx.data_layout.pointer_align.abi;\n+        let ptr_align = tcx.data_layout.pointer_align.abi;\n         // /////////////////////////////////////////////////////////////////////////////////////////\n         // If you touch this code, be sure to also make the corresponding changes to\n         // `get_vtable` in `rust_codegen_llvm/meth.rs`.\n@@ -60,33 +61,32 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             ptr_align,\n             MemoryKind::Vtable,\n         );\n-        let tcx = &*self.tcx;\n \n-        let drop = Instance::resolve_drop_in_place(*tcx, ty);\n+        let drop = Instance::resolve_drop_in_place(tcx, ty);\n         let drop = self.memory.create_fn_alloc(FnVal::Instance(drop));\n \n         // No need to do any alignment checks on the memory accesses below, because we know the\n         // allocation is correctly aligned as we created it above. Also we're only offsetting by\n         // multiples of `ptr_align`, which means that it will stay aligned to `ptr_align`.\n         let vtable_alloc = self.memory.get_raw_mut(vtable.alloc_id)?;\n-        vtable_alloc.write_ptr_sized(tcx, vtable, drop.into())?;\n+        vtable_alloc.write_ptr_sized(&tcx, vtable, drop.into())?;\n \n-        let size_ptr = vtable.offset(ptr_size, tcx)?;\n-        vtable_alloc.write_ptr_sized(tcx, size_ptr, Scalar::from_uint(size, ptr_size).into())?;\n-        let align_ptr = vtable.offset(ptr_size * 2, tcx)?;\n-        vtable_alloc.write_ptr_sized(tcx, align_ptr, Scalar::from_uint(align, ptr_size).into())?;\n+        let size_ptr = vtable.offset(ptr_size, &tcx)?;\n+        vtable_alloc.write_ptr_sized(&tcx, size_ptr, Scalar::from_uint(size, ptr_size).into())?;\n+        let align_ptr = vtable.offset(ptr_size * 2, &tcx)?;\n+        vtable_alloc.write_ptr_sized(&tcx, align_ptr, Scalar::from_uint(align, ptr_size).into())?;\n \n         for (i, method) in methods.iter().enumerate() {\n             if let Some((def_id, substs)) = *method {\n                 // resolve for vtable: insert shims where needed\n                 let instance =\n-                    ty::Instance::resolve_for_vtable(*tcx, self.param_env, def_id, substs)\n+                    ty::Instance::resolve_for_vtable(tcx, self.param_env, def_id, substs)\n                         .ok_or_else(|| err_inval!(TooGeneric))?;\n                 let fn_ptr = self.memory.create_fn_alloc(FnVal::Instance(instance));\n                 // We cannot use `vtable_allic` as we are creating fn ptrs in this loop.\n-                let method_ptr = vtable.offset(ptr_size * (3 + i as u64), tcx)?;\n+                let method_ptr = vtable.offset(ptr_size * (3 + i as u64), &tcx)?;\n                 self.memory.get_raw_mut(vtable.alloc_id)?.write_ptr_sized(\n-                    tcx,\n+                    &tcx,\n                     method_ptr,\n                     fn_ptr.into(),\n                 )?;\n@@ -142,7 +142,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // to determine the type.\n         let drop_instance = self.memory.get_fn(drop_fn)?.as_instance()?;\n         trace!(\"Found drop fn: {:?}\", drop_instance);\n-        let fn_sig = drop_instance.ty_env(*self.tcx, self.param_env).fn_sig(*self.tcx);\n+        let fn_sig = drop_instance.ty_env(self.tcx, self.param_env).fn_sig(self.tcx);\n         let fn_sig = self.tcx.normalize_erasing_late_bound_regions(self.param_env, &fn_sig);\n         // The drop function takes `*mut T` where `T` is the type being dropped, so get that.\n         let args = fn_sig.inputs();\n@@ -171,7 +171,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             alloc.read_ptr_sized(self, vtable.offset(pointer_size * 2, self)?)?.not_undef()?;\n         let align = u64::try_from(self.force_bits(align, pointer_size)?).unwrap();\n \n-        if size >= self.tcx.data_layout().obj_size_bound() {\n+        if size >= self.tcx.data_layout.obj_size_bound() {\n             throw_ub_format!(\n                 \"invalid vtable: \\\n                 size is bigger than largest supported object\""}, {"sha": "133c05fc2f92bbb7f5baec4a8df89415ae548b31", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/dc6ffaebd5b56793f86443a0a50c06f025321198/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc6ffaebd5b56793f86443a0a50c06f025321198/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=dc6ffaebd5b56793f86443a0a50c06f025321198", "patch": "@@ -313,7 +313,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         let param_env = tcx.param_env(def_id).with_reveal_all();\n \n         let span = tcx.def_span(def_id);\n-        let mut ecx = InterpCx::new(tcx.at(span), param_env, ConstPropMachine::new(), ());\n+        let mut ecx = InterpCx::new(tcx, span, param_env, ConstPropMachine::new(), ());\n         let can_const_prop = CanConstProp::check(body);\n \n         let ret = ecx\n@@ -404,8 +404,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         match self.ecx.eval_const_to_op(c.literal, None) {\n             Ok(op) => Some(op),\n             Err(error) => {\n-                // Make sure errors point at the constant.\n-                self.ecx.set_span(c.span);\n+                let tcx = self.ecx.tcx.at(c.span);\n                 let err = error_to_const_error(&self.ecx, error);\n                 if let Some(lint_root) = self.lint_root(source_info) {\n                     let lint_only = match c.literal.val {\n@@ -419,16 +418,16 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                         // Out of backwards compatibility we cannot report hard errors in unused\n                         // generic functions using associated constants of the generic parameters.\n                         err.report_as_lint(\n-                            self.ecx.tcx,\n+                            tcx,\n                             \"erroneous constant used\",\n                             lint_root,\n                             Some(c.span),\n                         );\n                     } else {\n-                        err.report_as_error(self.ecx.tcx, \"erroneous constant used\");\n+                        err.report_as_error(tcx, \"erroneous constant used\");\n                     }\n                 } else {\n-                    err.report_as_error(self.ecx.tcx, \"erroneous constant used\");\n+                    err.report_as_error(tcx, \"erroneous constant used\");\n                 }\n                 None\n             }\n@@ -851,7 +850,6 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n     fn visit_statement(&mut self, statement: &mut Statement<'tcx>, location: Location) {\n         trace!(\"visit_statement: {:?}\", statement);\n         let source_info = statement.source_info;\n-        self.ecx.set_span(source_info.span);\n         self.source_info = Some(source_info);\n         if let StatementKind::Assign(box (place, ref mut rval)) = statement.kind {\n             let place_ty: Ty<'tcx> = place.ty(&self.local_decls, self.tcx).ty;\n@@ -864,7 +862,7 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                         if let Some(value) = self.get_const(place) {\n                             if self.should_const_prop(value) {\n                                 trace!(\"replacing {:?} with {:?}\", rval, value);\n-                                self.replace_with_const(rval, value, statement.source_info);\n+                                self.replace_with_const(rval, value, source_info);\n                                 if can_const_prop == ConstPropMode::FullConstProp\n                                     || can_const_prop == ConstPropMode::OnlyInsideOwnBlock\n                                 {\n@@ -927,7 +925,6 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n \n     fn visit_terminator(&mut self, terminator: &mut Terminator<'tcx>, location: Location) {\n         let source_info = terminator.source_info;\n-        self.ecx.set_span(source_info.span);\n         self.source_info = Some(source_info);\n         self.super_terminator(terminator, location);\n         match &mut terminator.kind {"}]}