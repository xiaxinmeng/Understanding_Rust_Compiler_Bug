{"sha": "86188da3483b35ffd3d118600d55437c5233438c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2MTg4ZGEzNDgzYjM1ZmZkM2QxMTg2MDBkNTU0MzdjNTIzMzQzOGM=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-12-21T00:23:49Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-12-21T00:26:38Z"}, "message": "Mop up cases of s/copy/take/, remove 'binding' terminology, whitespace police, and make obj/fn structural.", "tree": {"sha": "f78e3dcdf0ad3fa0e78f527e673ce92825190ebc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f78e3dcdf0ad3fa0e78f527e673ce92825190ebc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86188da3483b35ffd3d118600d55437c5233438c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86188da3483b35ffd3d118600d55437c5233438c", "html_url": "https://github.com/rust-lang/rust/commit/86188da3483b35ffd3d118600d55437c5233438c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86188da3483b35ffd3d118600d55437c5233438c/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e70c695ab9a910f4079088c439a2efbf5ab9c447", "url": "https://api.github.com/repos/rust-lang/rust/commits/e70c695ab9a910f4079088c439a2efbf5ab9c447", "html_url": "https://github.com/rust-lang/rust/commit/e70c695ab9a910f4079088c439a2efbf5ab9c447"}], "stats": {"total": 78, "additions": 37, "deletions": 41}, "files": [{"sha": "3fae601bdab3647fa23e95de306b0f204db03e44", "filename": "src/comp/back/abi.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/86188da3483b35ffd3d118600d55437c5233438c/src%2Fcomp%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86188da3483b35ffd3d118600d55437c5233438c/src%2Fcomp%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fabi.rs?ref=86188da3483b35ffd3d118600d55437c5233438c", "patch": "@@ -31,7 +31,7 @@ const int vec_elt_data = 3;\n const int tydesc_field_first_param = 0;\n const int tydesc_field_size = 1;\n const int tydesc_field_align = 2;\n-const int tydesc_field_copy_glue_off = 3;\n+const int tydesc_field_take_glue_off = 3;\n const int tydesc_field_drop_glue_off = 4;\n const int tydesc_field_free_glue_off = 5;\n const int tydesc_field_sever_glue_off = 6;\n@@ -40,22 +40,14 @@ const int tydesc_field_obj_drop_glue_off = 8;\n const int tydesc_field_is_stateful = 9;\n \n \n-/* Both obj and fn are two-word \"bindings\": One word points to some static\n- * dispatch information (vtbl, thunk, callee), and the other points to some\n- * box of bound data (object-body or closure).\n- */\n-\n-const int binding_field_dispatch = 0;\n-const int binding_field_bound_data = 1;\n-\n-const int obj_field_vtbl = binding_field_dispatch;\n-const int obj_field_box = binding_field_bound_data;\n+const int obj_field_vtbl = 0;\n+const int obj_field_box = 1;\n \n const int obj_body_elt_tydesc = 0;\n const int obj_body_elt_fields = 1;\n \n-const int fn_field_code = binding_field_dispatch;\n-const int fn_field_box = binding_field_bound_data;\n+const int fn_field_code = 0;\n+const int fn_field_box = 1;\n \n const int worst_case_glue_call_args = 7;\n "}, {"sha": "af314843dbeafd5f4420d762f2d0001acc029415", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 30, "deletions": 19, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/86188da3483b35ffd3d118600d55437c5233438c/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86188da3483b35ffd3d118600d55437c5233438c/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=86188da3483b35ffd3d118600d55437c5233438c", "patch": "@@ -57,8 +57,6 @@ type tag_info = rec(type_handle th,\n                     mutable vec[tup(ast.def_id,arity)] variants,\n                     mutable uint size);\n \n-type ty_info = rec(ValueRef take_glue, ValueRef drop_glue);\n-\n state type crate_ctxt = rec(session.session sess,\n                             ModuleRef llmod,\n                             target_data td,\n@@ -222,7 +220,7 @@ fn T_tydesc() -> TypeRef {\n     ret T_struct(vec(pvoid,             // first_param\n                      T_int(),           // size\n                      T_int(),           // align\n-                     glue_fn_ty,        // copy_glue_off\n+                     glue_fn_ty,        // take_glue_off\n                      glue_fn_ty,        // drop_glue_off\n                      glue_fn_ty,        // free_glue_off\n                      glue_fn_ty,        // sever_glue_off\n@@ -375,7 +373,7 @@ fn type_of_inner(@crate_ctxt cx, @typeck.ty t) -> TypeRef {\n             let TypeRef vtbl = T_struct(mtys);\n             let TypeRef pair =\n                 T_struct(vec(T_ptr(vtbl),\n-                             T_ptr(T_box(T_opaque()))));\n+                             T_ptr(T_box(T_nil()))));\n             ret pair;\n         }\n         case (typeck.ty_var(_)) {\n@@ -614,7 +612,7 @@ fn make_tydesc(@crate_ctxt cx, @typeck.ty ty) {\n     auto tydesc = C_struct(vec(C_null(pvoid),\n                                size_of(llty),\n                                align_of(llty),\n-                               take_glue,             // copy_glue_off\n+                               take_glue,             // take_glue_off\n                                drop_glue,             // drop_glue_off\n                                C_null(glue_fn_ty),    // free_glue_off\n                                C_null(glue_fn_ty),    // sever_glue_off\n@@ -665,9 +663,6 @@ fn make_take_glue(@block_ctxt cx, ValueRef v, @typeck.ty t) -> result {\n     if (typeck.type_is_boxed(t)) {\n         ret incr_refcnt_of_boxed(cx, v);\n \n-    } else if (typeck.type_is_binding(t)) {\n-        cx.fcx.ccx.sess.unimpl(\"binding type in trans.incr_all_refcnts\");\n-\n     } else if (typeck.type_is_structural(t)) {\n         ret iter_structural_ty(cx, v, t,\n                                bind incr_all_refcnts(_, _, _));\n@@ -739,10 +734,6 @@ fn make_drop_glue(@block_ctxt cx, ValueRef v, @typeck.ty t) -> result {\n                 ret iter_structural_ty(cx, v, t,\n                                        bind drop_ty(_, _, _));\n \n-            } else if (typeck.type_is_binding(t)) {\n-                cx.fcx.ccx.sess.unimpl(\"binding type in \" +\n-                                       \"trans.make_drop_glue_inner\");\n-\n             } else if (typeck.type_is_scalar(t) ||\n                        typeck.type_is_nil(t)) {\n                 ret res(cx, C_nil());\n@@ -813,13 +804,14 @@ fn type_of_variant(@crate_ctxt cx, &ast.variant v) -> TypeRef {\n type val_and_ty_fn =\n     fn(@block_ctxt cx, ValueRef v, @typeck.ty t) -> result;\n \n-// Iterates through the elements of a box, tup, rec or tag.\n+// Iterates through the elements of a structural type.\n fn iter_structural_ty(@block_ctxt cx,\n                       ValueRef v,\n                       @typeck.ty t,\n                       val_and_ty_fn f)\n     -> result {\n     let result r = res(cx, C_nil());\n+\n     alt (t.struct) {\n         case (typeck.ty_tup(?args)) {\n             let int i = 0;\n@@ -922,6 +914,26 @@ fn iter_structural_ty(@block_ctxt cx,\n \n             ret res(next_cx, C_nil());\n         }\n+        case (typeck.ty_fn(_,_)) {\n+            auto box_cell =\n+                cx.build.GEP(v,\n+                             vec(C_int(0),\n+                                 C_int(abi.fn_field_box)));\n+            auto box_ptr = cx.build.Load(box_cell);\n+            auto tnil = typeck.plain_ty(typeck.ty_nil);\n+            auto tbox = typeck.plain_ty(typeck.ty_box(tnil));\n+            ret f(cx, box_ptr, tbox);\n+        }\n+        case (typeck.ty_obj(_)) {\n+            auto box_cell =\n+                cx.build.GEP(v,\n+                             vec(C_int(0),\n+                                 C_int(abi.obj_field_box)));\n+            auto box_ptr = cx.build.Load(box_cell);\n+            auto tnil = typeck.plain_ty(typeck.ty_nil);\n+            auto tbox = typeck.plain_ty(typeck.ty_box(tnil));\n+            ret f(cx, box_ptr, tbox);\n+        }\n         case (_) {\n             cx.fcx.ccx.sess.unimpl(\"type in iter_structural_ty\");\n         }\n@@ -1004,9 +1016,10 @@ fn iter_sequence(@block_ctxt cx,\n fn incr_all_refcnts(@block_ctxt cx,\n                     ValueRef v,\n                     @typeck.ty t) -> result {\n+\n     if (!typeck.type_is_scalar(t)) {\n         auto llrawptr = cx.build.BitCast(v, T_ptr(T_i8()));\n-        auto llfnptr = field_of_tydesc(cx, t, abi.tydesc_field_copy_glue_off);\n+        auto llfnptr = field_of_tydesc(cx, t, abi.tydesc_field_take_glue_off);\n         auto llfn = cx.build.Load(llfnptr);\n         cx.build.FastCall(llfn, vec(cx.fcx.lltaskptr, llrawptr));\n     }\n@@ -1028,6 +1041,7 @@ fn drop_slot(@block_ctxt cx,\n fn drop_ty(@block_ctxt cx,\n            ValueRef v,\n            @typeck.ty t) -> result {\n+\n     if (!typeck.type_is_scalar(t)) {\n         auto llrawptr = cx.build.BitCast(v, T_ptr(T_i8()));\n         auto llfnptr = field_of_tydesc(cx, t, abi.tydesc_field_drop_glue_off);\n@@ -1072,9 +1086,6 @@ fn copy_ty(@block_ctxt cx,\n     } else if (typeck.type_is_nil(t)) {\n         ret res(cx, C_nil());\n \n-    } else if (typeck.type_is_binding(t)) {\n-        cx.fcx.ccx.sess.unimpl(\"binding type in trans.copy_ty\");\n-\n     } else if (typeck.type_is_boxed(t)) {\n         auto r = incr_all_refcnts(cx, src, t);\n         if (! is_init) {\n@@ -1452,7 +1463,7 @@ impure fn trans_pat_match(@block_ctxt cx, @ast.pat pat, ValueRef llval,\n         case (ast.pat_tag(?id, ?subpats, ?vdef_opt, ?ann)) {\n             auto lltagptr = cx.build.GEP(llval, vec(C_int(0), C_int(0)));\n             auto lltag = cx.build.Load(lltagptr);\n-            \n+\n             auto vdef = option.get[ast.variant_def](vdef_opt);\n             auto variant_id = vdef._1;\n             auto tinfo = cx.fcx.ccx.tags.get(vdef._0);\n@@ -2423,7 +2434,7 @@ impure fn trans_obj(@crate_ctxt cx, &ast._obj ob, ast.def_id oid,\n                                    vec(C_int(0),\n                                        C_int(abi.obj_field_vtbl)));\n     bcx.build.Store(vtbl, pair_vtbl);\n-    bcx.build.Ret(pair);\n+    bcx.build.Ret(bcx.build.Load(pair));\n }\n \n fn trans_tag_variant(@crate_ctxt cx, ast.def_id tag_id,"}, {"sha": "3770c0b88cff88b41fac46503f78513af356f5a8", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/86188da3483b35ffd3d118600d55437c5233438c/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86188da3483b35ffd3d118600d55437c5233438c/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=86188da3483b35ffd3d118600d55437c5233438c", "patch": "@@ -861,15 +861,8 @@ fn type_is_structural(@ty t) -> bool {\n         case (ty_tup(_)) { ret true; }\n         case (ty_rec(_)) { ret true; }\n         case (ty_tag(_)) { ret true; }\n-        case (_) { ret false; }\n-    }\n-    fail;\n-}\n-\n-fn type_is_binding(@ty t) -> bool {\n-    alt (t.struct) {\n-        // FIXME: cover obj when we support it.\n         case (ty_fn(_,_)) { ret true; }\n+        case (ty_obj(_)) { ret true; }\n         case (_) { ret false; }\n     }\n     fail;\n@@ -1007,7 +1000,7 @@ fn count_ty_params(@ty t) -> uint {\n             ret t;\n         }\n     }\n-  \n+\n     let vec[ast.def_id] param_ids_inner = vec();\n     let @mutable vec[ast.def_id] param_ids = @mutable param_ids_inner;\n     fold_ty(ty_param_counter(param_ids), t);"}]}