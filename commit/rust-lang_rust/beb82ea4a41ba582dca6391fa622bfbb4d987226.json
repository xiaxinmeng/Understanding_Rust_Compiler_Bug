{"sha": "beb82ea4a41ba582dca6391fa622bfbb4d987226", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlYjgyZWE0YTQxYmE1ODJkY2E2MzkxZmE2MjJiZmJiNGQ5ODcyMjY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-02-23T17:48:38Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-02-23T17:52:12Z"}, "message": "add private helper trait for fs shim", "tree": {"sha": "eeff097f20c8888b06ba2db03c5cc7f04565e158", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eeff097f20c8888b06ba2db03c5cc7f04565e158"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/beb82ea4a41ba582dca6391fa622bfbb4d987226", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/beb82ea4a41ba582dca6391fa622bfbb4d987226", "html_url": "https://github.com/rust-lang/rust/commit/beb82ea4a41ba582dca6391fa622bfbb4d987226", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/beb82ea4a41ba582dca6391fa622bfbb4d987226/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d3554898524c01bb85a12367fc9e36f27bcfe05", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d3554898524c01bb85a12367fc9e36f27bcfe05", "html_url": "https://github.com/rust-lang/rust/commit/5d3554898524c01bb85a12367fc9e36f27bcfe05"}], "stats": {"total": 195, "additions": 100, "deletions": 95}, "files": [{"sha": "aa562926686dc542aa133475c45968cb7ba8d8b5", "filename": "src/shims/fs.rs", "status": "modified", "additions": 100, "deletions": 95, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/beb82ea4a41ba582dca6391fa622bfbb4d987226/src%2Fshims%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/beb82ea4a41ba582dca6391fa622bfbb4d987226/src%2Fshims%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ffs.rs?ref=beb82ea4a41ba582dca6391fa622bfbb4d987226", "patch": "@@ -63,6 +63,105 @@ impl FileHandler {\n     }\n }\n \n+impl<'mir, 'tcx> EvalContextExtPrivate<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n+trait EvalContextExtPrivate<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+    /// Emulate `stat` or `lstat` on the `macos` platform. This function is not intended to be\n+    /// called directly from `emulate_foreign_item_by_name`, so it does not check if isolation is\n+    /// disabled or if the target platform is the correct one. Please use `macos_stat` or\n+    /// `macos_lstat` instead.\n+    fn macos_stat_or_lstat(\n+        &mut self,\n+        follow_symlink: bool,\n+        path_op: OpTy<'tcx, Tag>,\n+        buf_op: OpTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        let path_scalar = this.read_scalar(path_op)?.not_undef()?;\n+        let path: PathBuf = this.read_os_str_from_c_str(path_scalar)?.into();\n+\n+        let metadata = match FileMetadata::from_path(this, path, follow_symlink)? {\n+            Some(metadata) => metadata,\n+            None => return Ok(-1),\n+        };\n+        this.macos_stat_write_buf(metadata, buf_op)\n+    }\n+\n+    fn macos_stat_write_buf(\n+        &mut self,\n+        metadata: FileMetadata,\n+        buf_op: OpTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        let mode: u16 = metadata.mode.to_u16()?;\n+\n+        let (access_sec, access_nsec) = metadata.accessed.unwrap_or((0, 0));\n+        let (created_sec, created_nsec) = metadata.created.unwrap_or((0, 0));\n+        let (modified_sec, modified_nsec) = metadata.modified.unwrap_or((0, 0));\n+\n+        let dev_t_layout = this.libc_ty_layout(\"dev_t\")?;\n+        let mode_t_layout = this.libc_ty_layout(\"mode_t\")?;\n+        let nlink_t_layout = this.libc_ty_layout(\"nlink_t\")?;\n+        let ino_t_layout = this.libc_ty_layout(\"ino_t\")?;\n+        let uid_t_layout = this.libc_ty_layout(\"uid_t\")?;\n+        let gid_t_layout = this.libc_ty_layout(\"gid_t\")?;\n+        let time_t_layout = this.libc_ty_layout(\"time_t\")?;\n+        let long_layout = this.libc_ty_layout(\"c_long\")?;\n+        let off_t_layout = this.libc_ty_layout(\"off_t\")?;\n+        let blkcnt_t_layout = this.libc_ty_layout(\"blkcnt_t\")?;\n+        let blksize_t_layout = this.libc_ty_layout(\"blksize_t\")?;\n+        let uint32_t_layout = this.libc_ty_layout(\"uint32_t\")?;\n+\n+        // We need to add 32 bits of padding after `st_rdev` if we are on a 64-bit platform.\n+        let pad_layout = if this.tcx.sess.target.ptr_width == 64 {\n+            uint32_t_layout\n+        } else {\n+            this.layout_of(this.tcx.mk_unit())?\n+        };\n+\n+        let imms = [\n+            immty_from_uint_checked(0u128, dev_t_layout)?, // st_dev\n+            immty_from_uint_checked(mode, mode_t_layout)?, // st_mode\n+            immty_from_uint_checked(0u128, nlink_t_layout)?, // st_nlink\n+            immty_from_uint_checked(0u128, ino_t_layout)?, // st_ino\n+            immty_from_uint_checked(0u128, uid_t_layout)?, // st_uid\n+            immty_from_uint_checked(0u128, gid_t_layout)?, // st_gid\n+            immty_from_uint_checked(0u128, dev_t_layout)?, // st_rdev\n+            immty_from_uint_checked(0u128, pad_layout)?, // padding for 64-bit targets\n+            immty_from_uint_checked(access_sec, time_t_layout)?, // st_atime\n+            immty_from_uint_checked(access_nsec, long_layout)?, // st_atime_nsec\n+            immty_from_uint_checked(modified_sec, time_t_layout)?, // st_mtime\n+            immty_from_uint_checked(modified_nsec, long_layout)?, // st_mtime_nsec\n+            immty_from_uint_checked(0u128, time_t_layout)?, // st_ctime\n+            immty_from_uint_checked(0u128, long_layout)?, // st_ctime_nsec\n+            immty_from_uint_checked(created_sec, time_t_layout)?, // st_birthtime\n+            immty_from_uint_checked(created_nsec, long_layout)?, // st_birthtime_nsec\n+            immty_from_uint_checked(metadata.size, off_t_layout)?, // st_size\n+            immty_from_uint_checked(0u128, blkcnt_t_layout)?, // st_blocks\n+            immty_from_uint_checked(0u128, blksize_t_layout)?, // st_blksize\n+            immty_from_uint_checked(0u128, uint32_t_layout)?, // st_flags\n+            immty_from_uint_checked(0u128, uint32_t_layout)?, // st_gen\n+        ];\n+\n+        let buf = this.deref_operand(buf_op)?;\n+        this.write_packed_immediates(buf, &imms)?;\n+\n+        Ok(0)\n+    }\n+\n+    /// Function used when a handle is not found inside `FileHandler`. It returns `Ok(-1)`and sets\n+    /// the last OS error to `libc::EBADF` (invalid file descriptor). This function uses\n+    /// `T: From<i32>` instead of `i32` directly because some fs functions return different integer\n+    /// types (like `read`, that returns an `i64`).\n+    fn handle_not_found<T: From<i32>>(&mut self) -> InterpResult<'tcx, T> {\n+        let this = self.eval_context_mut();\n+        let ebadf = this.eval_libc(\"EBADF\")?;\n+        this.set_last_error(ebadf)?;\n+        Ok((-1).into())\n+    }\n+}\n+\n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n     fn open(\n@@ -432,29 +531,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             Some(metadata) => metadata,\n             None => return Ok(-1),\n         };\n-        macos_stat_write_buf(this, metadata, buf_op)\n-    }\n-\n-    /// Emulate `stat` or `lstat` on the `macos` platform. This function is not intended to be\n-    /// called directly from `emulate_foreign_item_by_name`, so it does not check if isolation is\n-    /// disabled or if the target platform is the correct one. Please use `macos_stat` or\n-    /// `macos_lstat` instead.\n-    fn macos_stat_or_lstat(\n-        &mut self,\n-        follow_symlink: bool,\n-        path_op: OpTy<'tcx, Tag>,\n-        buf_op: OpTy<'tcx, Tag>,\n-    ) -> InterpResult<'tcx, i32> {\n-        let this = self.eval_context_mut();\n-\n-        let path_scalar = this.read_scalar(path_op)?.not_undef()?;\n-        let path: PathBuf = this.read_os_str_from_c_str(path_scalar)?.into();\n-\n-        let metadata = match FileMetadata::from_path(this, path, follow_symlink)? {\n-            Some(metadata) => metadata,\n-            None => return Ok(-1),\n-        };\n-        macos_stat_write_buf(this, metadata, buf_op)\n+        this.macos_stat_write_buf(metadata, buf_op)\n     }\n \n     fn linux_statx(\n@@ -620,17 +697,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(0)\n     }\n \n-    /// Function used when a handle is not found inside `FileHandler`. It returns `Ok(-1)`and sets\n-    /// the last OS error to `libc::EBADF` (invalid file descriptor). This function uses\n-    /// `T: From<i32>` instead of `i32` directly because some fs functions return different integer\n-    /// types (like `read`, that returns an `i64`).\n-    fn handle_not_found<T: From<i32>>(&mut self) -> InterpResult<'tcx, T> {\n-        let this = self.eval_context_mut();\n-        let ebadf = this.eval_libc(\"EBADF\")?;\n-        this.set_last_error(ebadf)?;\n-        Ok((-1).into())\n-    }\n-\n     fn rename(\n         &mut self,\n         oldpath_op: OpTy<'tcx, Tag>,\n@@ -743,64 +809,3 @@ impl FileMetadata {\n         Ok(Some(FileMetadata { mode, size, created, accessed, modified }))\n     }\n }\n-\n-fn macos_stat_write_buf<'tcx, 'mir>(\n-    ecx: &mut MiriEvalContext<'mir, 'tcx>,\n-    metadata: FileMetadata,\n-    buf_op: OpTy<'tcx, Tag>,\n-) -> InterpResult<'tcx, i32> {\n-    let mode: u16 = metadata.mode.to_u16()?;\n-\n-    let (access_sec, access_nsec) = metadata.accessed.unwrap_or((0, 0));\n-    let (created_sec, created_nsec) = metadata.created.unwrap_or((0, 0));\n-    let (modified_sec, modified_nsec) = metadata.modified.unwrap_or((0, 0));\n-\n-    let dev_t_layout = ecx.libc_ty_layout(\"dev_t\")?;\n-    let mode_t_layout = ecx.libc_ty_layout(\"mode_t\")?;\n-    let nlink_t_layout = ecx.libc_ty_layout(\"nlink_t\")?;\n-    let ino_t_layout = ecx.libc_ty_layout(\"ino_t\")?;\n-    let uid_t_layout = ecx.libc_ty_layout(\"uid_t\")?;\n-    let gid_t_layout = ecx.libc_ty_layout(\"gid_t\")?;\n-    let time_t_layout = ecx.libc_ty_layout(\"time_t\")?;\n-    let long_layout = ecx.libc_ty_layout(\"c_long\")?;\n-    let off_t_layout = ecx.libc_ty_layout(\"off_t\")?;\n-    let blkcnt_t_layout = ecx.libc_ty_layout(\"blkcnt_t\")?;\n-    let blksize_t_layout = ecx.libc_ty_layout(\"blksize_t\")?;\n-    let uint32_t_layout = ecx.libc_ty_layout(\"uint32_t\")?;\n-\n-    // We need to add 32 bits of padding after `st_rdev` if we are on a 64-bit platform.\n-    let pad_layout = if ecx.tcx.sess.target.ptr_width == 64 {\n-        uint32_t_layout\n-    } else {\n-        ecx.layout_of(ecx.tcx.mk_unit())?\n-    };\n-\n-    let imms = [\n-        immty_from_uint_checked(0u128, dev_t_layout)?, // st_dev\n-        immty_from_uint_checked(mode, mode_t_layout)?, // st_mode\n-        immty_from_uint_checked(0u128, nlink_t_layout)?, // st_nlink\n-        immty_from_uint_checked(0u128, ino_t_layout)?, // st_ino\n-        immty_from_uint_checked(0u128, uid_t_layout)?, // st_uid\n-        immty_from_uint_checked(0u128, gid_t_layout)?, // st_gid\n-        immty_from_uint_checked(0u128, dev_t_layout)?, // st_rdev\n-        immty_from_uint_checked(0u128, pad_layout)?, // padding for 64-bit targets\n-        immty_from_uint_checked(access_sec, time_t_layout)?, // st_atime\n-        immty_from_uint_checked(access_nsec, long_layout)?, // st_atime_nsec\n-        immty_from_uint_checked(modified_sec, time_t_layout)?, // st_mtime\n-        immty_from_uint_checked(modified_nsec, long_layout)?, // st_mtime_nsec\n-        immty_from_uint_checked(0u128, time_t_layout)?, // st_ctime\n-        immty_from_uint_checked(0u128, long_layout)?, // st_ctime_nsec\n-        immty_from_uint_checked(created_sec, time_t_layout)?, // st_birthtime\n-        immty_from_uint_checked(created_nsec, long_layout)?, // st_birthtime_nsec\n-        immty_from_uint_checked(metadata.size, off_t_layout)?, // st_size\n-        immty_from_uint_checked(0u128, blkcnt_t_layout)?, // st_blocks\n-        immty_from_uint_checked(0u128, blksize_t_layout)?, // st_blksize\n-        immty_from_uint_checked(0u128, uint32_t_layout)?, // st_flags\n-        immty_from_uint_checked(0u128, uint32_t_layout)?, // st_gen\n-    ];\n-\n-    let buf = ecx.deref_operand(buf_op)?;\n-    ecx.write_packed_immediates(buf, &imms)?;\n-\n-    Ok(0)\n-}"}]}