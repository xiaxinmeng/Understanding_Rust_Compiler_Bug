{"sha": "1796cc0e6c43f1958d746c94608503c900b3a28e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3OTZjYzBlNmM0M2YxOTU4ZDc0NmM5NDYwODUwM2M5MDBiM2EyOGU=", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2021-03-13T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2021-03-15T22:26:03Z"}, "message": "Make source-based code coverage compatible with MIR inlining\n\nWhen codegenning code coverage use the instance that coverage data was\noriginally generated for, to ensure basic level of compatibility with\nMIR inlining.", "tree": {"sha": "fdb3668caaed6a272c90ecffc699ef6296a23aa0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fdb3668caaed6a272c90ecffc699ef6296a23aa0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1796cc0e6c43f1958d746c94608503c900b3a28e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1796cc0e6c43f1958d746c94608503c900b3a28e", "html_url": "https://github.com/rust-lang/rust/commit/1796cc0e6c43f1958d746c94608503c900b3a28e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1796cc0e6c43f1958d746c94608503c900b3a28e/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "107896c32d5dda4db508968ff34997a39d286966", "url": "https://api.github.com/repos/rust-lang/rust/commits/107896c32d5dda4db508968ff34997a39d286966", "html_url": "https://github.com/rust-lang/rust/commit/107896c32d5dda4db508968ff34997a39d286966"}], "stats": {"total": 119, "additions": 68, "deletions": 51}, "files": [{"sha": "1cea927f50c45a00467d4564d3e48811e911d444", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mapgen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1796cc0e6c43f1958d746c94608503c900b3a28e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1796cc0e6c43f1958d746c94608503c900b3a28e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs?ref=1796cc0e6c43f1958d746c94608503c900b3a28e", "patch": "@@ -254,7 +254,7 @@ fn save_function_record(\n ///\n /// 1. The file name of an \"Unreachable\" function must match the file name of the existing\n ///    codegenned (covered) function to which the unreachable code regions will be added.\n-/// 2. The function to which the unreachable code regions will be added must not be a genaric\n+/// 2. The function to which the unreachable code regions will be added must not be a generic\n ///    function (must not have type parameters) because the coverage tools will get confused\n ///    if the codegenned function has more than one instantiation and additional `CodeRegion`s\n ///    attached to only one of those instantiations."}, {"sha": "af6482fdbc24fb00a0e7b7361600691b4b3a72ef", "filename": "compiler/rustc_codegen_ssa/src/coverageinfo/map.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1796cc0e6c43f1958d746c94608503c900b3a28e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1796cc0e6c43f1958d746c94608503c900b3a28e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmap.rs?ref=1796cc0e6c43f1958d746c94608503c900b3a28e", "patch": "@@ -8,7 +8,7 @@ use rustc_middle::mir::coverage::{\n use rustc_middle::ty::Instance;\n use rustc_middle::ty::TyCtxt;\n \n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, PartialEq)]\n pub struct Expression {\n     lhs: ExpressionOperandId,\n     op: Op,\n@@ -64,7 +64,9 @@ impl<'tcx> FunctionCoverage<'tcx> {\n \n     /// Adds a code region to be counted by an injected counter intrinsic.\n     pub fn add_counter(&mut self, id: CounterValueReference, region: CodeRegion) {\n-        self.counters[id].replace(region).expect_none(\"add_counter called with duplicate `id`\");\n+        if let Some(previous_region) = self.counters[id].replace(region.clone()) {\n+            assert_eq!(previous_region, region, \"add_counter: code region for id changed\");\n+        }\n     }\n \n     /// Both counters and \"counter expressions\" (or simply, \"expressions\") can be operands in other\n@@ -94,9 +96,18 @@ impl<'tcx> FunctionCoverage<'tcx> {\n             expression_id, lhs, op, rhs, region\n         );\n         let expression_index = self.expression_index(u32::from(expression_id));\n-        self.expressions[expression_index]\n-            .replace(Expression { lhs, op, rhs, region })\n-            .expect_none(\"add_counter_expression called with duplicate `id_descending_from_max`\");\n+        if let Some(previous_expression) = self.expressions[expression_index].replace(Expression {\n+            lhs,\n+            op,\n+            rhs,\n+            region: region.clone(),\n+        }) {\n+            assert_eq!(\n+                previous_expression,\n+                Expression { lhs, op, rhs, region },\n+                \"add_counter_expression: expression for id changed\"\n+            );\n+        }\n     }\n \n     /// Add a region that will be marked as \"unreachable\", with a constant \"zero counter\"."}, {"sha": "5ab1baafb57de3b587be796d19ea9c4959ee875f", "filename": "compiler/rustc_codegen_ssa/src/mir/coverageinfo.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1796cc0e6c43f1958d746c94608503c900b3a28e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1796cc0e6c43f1958d746c94608503c900b3a28e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs?ref=1796cc0e6c43f1958d746c94608503c900b3a28e", "patch": "@@ -2,27 +2,38 @@ use crate::traits::*;\n \n use rustc_middle::mir::coverage::*;\n use rustc_middle::mir::Coverage;\n+use rustc_middle::mir::SourceScope;\n \n use super::FunctionCx;\n \n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n-    pub fn codegen_coverage(&self, bx: &mut Bx, coverage: Coverage) {\n+    pub fn codegen_coverage(&self, bx: &mut Bx, coverage: Coverage, scope: SourceScope) {\n+        // Determine the instance that coverage data was originally generated for.\n+        let scope_data = &self.mir.source_scopes[scope];\n+        let instance = if let Some((inlined_instance, _)) = scope_data.inlined {\n+            self.monomorphize(inlined_instance)\n+        } else if let Some(inlined_scope) = scope_data.inlined_parent_scope {\n+            self.monomorphize(self.mir.source_scopes[inlined_scope].inlined.unwrap().0)\n+        } else {\n+            self.instance\n+        };\n+\n         let Coverage { kind, code_region } = coverage;\n         match kind {\n             CoverageKind::Counter { function_source_hash, id } => {\n-                if bx.set_function_source_hash(self.instance, function_source_hash) {\n+                if bx.set_function_source_hash(instance, function_source_hash) {\n                     // If `set_function_source_hash()` returned true, the coverage map is enabled,\n                     // so continue adding the counter.\n                     if let Some(code_region) = code_region {\n                         // Note: Some counters do not have code regions, but may still be referenced\n                         // from expressions. In that case, don't add the counter to the coverage map,\n                         // but do inject the counter intrinsic.\n-                        bx.add_coverage_counter(self.instance, id, code_region);\n+                        bx.add_coverage_counter(instance, id, code_region);\n                     }\n \n-                    let coverageinfo = bx.tcx().coverageinfo(self.instance.def_id());\n+                    let coverageinfo = bx.tcx().coverageinfo(instance.def_id());\n \n-                    let fn_name = bx.create_pgo_func_name_var(self.instance);\n+                    let fn_name = bx.create_pgo_func_name_var(instance);\n                     let hash = bx.const_u64(function_source_hash);\n                     let num_counters = bx.const_u32(coverageinfo.num_counters);\n                     let index = bx.const_u32(u32::from(id));\n@@ -34,11 +45,11 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 }\n             }\n             CoverageKind::Expression { id, lhs, op, rhs } => {\n-                bx.add_coverage_counter_expression(self.instance, id, lhs, op, rhs, code_region);\n+                bx.add_coverage_counter_expression(instance, id, lhs, op, rhs, code_region);\n             }\n             CoverageKind::Unreachable => {\n                 bx.add_coverage_unreachable(\n-                    self.instance,\n+                    instance,\n                     code_region.expect(\"unreachable regions always have code regions\"),\n                 );\n             }"}, {"sha": "fe7f6288adb273913a8545f0ee4160d54395a244", "filename": "compiler/rustc_codegen_ssa/src/mir/statement.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1796cc0e6c43f1958d746c94608503c900b3a28e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1796cc0e6c43f1958d746c94608503c900b3a28e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs?ref=1796cc0e6c43f1958d746c94608503c900b3a28e", "patch": "@@ -112,7 +112,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 bx\n             }\n             mir::StatementKind::Coverage(box ref coverage) => {\n-                self.codegen_coverage(&mut bx, coverage.clone());\n+                self.codegen_coverage(&mut bx, coverage.clone(), statement.source_info.scope);\n                 bx\n             }\n             mir::StatementKind::CopyNonOverlapping(box mir::CopyNonOverlapping {"}, {"sha": "de8447f1974e7f038f09a56f6e7382541dc23862", "filename": "compiler/rustc_mir/src/transform/coverage/query.rs", "status": "modified", "additions": 32, "deletions": 9, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/1796cc0e6c43f1958d746c94608503c900b3a28e/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1796cc0e6c43f1958d746c94608503c900b3a28e/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fquery.rs?ref=1796cc0e6c43f1958d746c94608503c900b3a28e", "patch": "@@ -1,8 +1,7 @@\n use super::*;\n \n use rustc_middle::mir::coverage::*;\n-use rustc_middle::mir::visit::Visitor;\n-use rustc_middle::mir::{self, Coverage, CoverageInfo, Location};\n+use rustc_middle::mir::{self, Body, Coverage, CoverageInfo};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::def_id::DefId;\n@@ -85,10 +84,21 @@ impl CoverageVisitor {\n             }\n         }\n     }\n-}\n \n-impl Visitor<'_> for CoverageVisitor {\n-    fn visit_coverage(&mut self, coverage: &Coverage, _location: Location) {\n+    fn visit_body(&mut self, body: &Body<'_>) {\n+        for bb_data in body.basic_blocks().iter() {\n+            for statement in bb_data.statements.iter() {\n+                if let StatementKind::Coverage(box ref coverage) = statement.kind {\n+                    if is_inlined(body, statement) {\n+                        continue;\n+                    }\n+                    self.visit_coverage(coverage);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn visit_coverage(&mut self, coverage: &Coverage) {\n         if self.add_missing_operands {\n             match coverage.kind {\n                 CoverageKind::Expression { lhs, rhs, .. } => {\n@@ -129,10 +139,14 @@ fn coverageinfo_from_mir<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> CoverageInfo\n }\n \n fn covered_file_name<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Option<Symbol> {\n-    for bb_data in mir_body(tcx, def_id).basic_blocks().iter() {\n+    let body = mir_body(tcx, def_id);\n+    for bb_data in body.basic_blocks().iter() {\n         for statement in bb_data.statements.iter() {\n             if let StatementKind::Coverage(box ref coverage) = statement.kind {\n                 if let Some(code_region) = coverage.code_region.as_ref() {\n+                    if is_inlined(body, statement) {\n+                        continue;\n+                    }\n                     return Some(code_region.file_name);\n                 }\n             }\n@@ -151,17 +165,26 @@ fn mir_body<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx mir::Body<'tcx> {\n }\n \n fn covered_code_regions<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Vec<&'tcx CodeRegion> {\n-    mir_body(tcx, def_id)\n-        .basic_blocks()\n+    let body = mir_body(tcx, def_id);\n+    body.basic_blocks()\n         .iter()\n         .map(|data| {\n             data.statements.iter().filter_map(|statement| match statement.kind {\n                 StatementKind::Coverage(box ref coverage) => {\n-                    coverage.code_region.as_ref() // may be None\n+                    if is_inlined(body, statement) {\n+                        None\n+                    } else {\n+                        coverage.code_region.as_ref() // may be None\n+                    }\n                 }\n                 _ => None,\n             })\n         })\n         .flatten()\n         .collect()\n }\n+\n+fn is_inlined(body: &Body<'_>, statement: &Statement<'_>) -> bool {\n+    let scope_data = &body.source_scopes[statement.source_info.scope];\n+    scope_data.inlined.is_some() || scope_data.inlined_parent_scope.is_some()\n+}"}, {"sha": "26e7555a61d23fbb1724c359e4814a40534422b3", "filename": "compiler/rustc_mir/src/transform/inline.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1796cc0e6c43f1958d746c94608503c900b3a28e/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1796cc0e6c43f1958d746c94608503c900b3a28e/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs?ref=1796cc0e6c43f1958d746c94608503c900b3a28e", "patch": "@@ -39,15 +39,6 @@ struct CallSite<'tcx> {\n \n /// Returns true if MIR inlining is enabled in the current compilation session.\n crate fn is_enabled(tcx: TyCtxt<'_>) -> bool {\n-    if tcx.sess.opts.debugging_opts.instrument_coverage {\n-        // Since `Inline` happens after `InstrumentCoverage`, the function-specific coverage\n-        // counters can be invalidated, such as by merging coverage counter statements from\n-        // a pre-inlined function into a different function. This kind of change is invalid,\n-        // so inlining must be skipped. Note: This check is performed here so inlining can\n-        // be disabled without preventing other optimizations (regardless of `mir_opt_level`).\n-        return false;\n-    }\n-\n     if let Some(enabled) = tcx.sess.opts.debugging_opts.inline_mir {\n         return enabled;\n     }"}, {"sha": "75078a12311630b4c8fde27b58752b5f3a6cc6a3", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1796cc0e6c43f1958d746c94608503c900b3a28e/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1796cc0e6c43f1958d746c94608503c900b3a28e/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=1796cc0e6c43f1958d746c94608503c900b3a28e", "patch": "@@ -1937,25 +1937,6 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n             }\n             Some(SymbolManglingVersion::V0) => {}\n         }\n-\n-        if let Some(mir_opt_level) = debugging_opts.mir_opt_level {\n-            if mir_opt_level > 1 {\n-                // Functions inlined during MIR transform can, at best, make it impossible to\n-                // effectively cover inlined functions, and, at worst, break coverage map generation\n-                // during LLVM codegen. For example, function counter IDs are only unique within a\n-                // function. Inlining after these counters are injected can produce duplicate counters,\n-                // resulting in an invalid coverage map (and ICE); so this option combination is not\n-                // allowed.\n-                early_warn(\n-                    error_format,\n-                    &format!(\n-                        \"`-Z mir-opt-level={}` (or any level > 1) enables function inlining, which \\\n-                    is incompatible with `-Z instrument-coverage`. Inlining will be disabled.\",\n-                        mir_opt_level,\n-                    ),\n-                );\n-            }\n-        }\n     }\n \n     if let Ok(graphviz_font) = std::env::var(\"RUSTC_GRAPHVIZ_FONT\") {"}]}