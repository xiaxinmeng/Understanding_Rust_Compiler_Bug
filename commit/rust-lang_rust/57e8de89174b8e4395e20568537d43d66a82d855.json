{"sha": "57e8de89174b8e4395e20568537d43d66a82d855", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3ZThkZTg5MTc0YjhlNDM5NWUyMDU2ODUzN2Q0M2Q2NmE4MmQ4NTU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-07-19T00:34:59Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-07-19T00:34:59Z"}, "message": "rustc: Implement multiple-traits-per-impl for cross-crate stuff", "tree": {"sha": "db8adef5627b20e01dcd0230d6976db906c54cd9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db8adef5627b20e01dcd0230d6976db906c54cd9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57e8de89174b8e4395e20568537d43d66a82d855", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57e8de89174b8e4395e20568537d43d66a82d855", "html_url": "https://github.com/rust-lang/rust/commit/57e8de89174b8e4395e20568537d43d66a82d855", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57e8de89174b8e4395e20568537d43d66a82d855/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "635a95936394107d2511130d451ce9148300d6a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/635a95936394107d2511130d451ce9148300d6a4", "html_url": "https://github.com/rust-lang/rust/commit/635a95936394107d2511130d451ce9148300d6a4"}], "stats": {"total": 106, "additions": 46, "deletions": 60}, "files": [{"sha": "7f97583fe3d2f49cf064e3ca93561af68bd47627", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/57e8de89174b8e4395e20568537d43d66a82d855/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e8de89174b8e4395e20568537d43d66a82d855/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=57e8de89174b8e4395e20568537d43d66a82d855", "patch": "@@ -27,7 +27,7 @@ export get_trait_methods;\n export get_method_names_if_trait;\n export each_path;\n export get_type;\n-export get_impl_trait;\n+export get_impl_traits;\n export get_impl_method;\n export get_item_path;\n export maybe_get_item_ast, found_ast, found, found_parent, not_found;\n@@ -187,12 +187,13 @@ fn get_field_type(tcx: ty::ctxt, class_id: ast::def_id,\n     ret {bounds: @~[], rp: false, ty: ty};\n }\n \n-// Given a def_id for an impl or class, return the trait it implements,\n-// or none if it's not for an impl or for a class that implements traits\n-fn get_impl_trait(tcx: ty::ctxt, def: ast::def_id) -> option<ty::t> {\n+// Given a def_id for an impl or class, return the traits it implements,\n+// or the empty vector if it's not for an impl or for a class that implements\n+// traits\n+fn get_impl_traits(tcx: ty::ctxt, def: ast::def_id) -> ~[ty::t] {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n-    decoder::get_impl_trait(cdata, def.node, tcx)\n+    decoder::get_impl_traits(cdata, def.node, tcx)\n }\n \n fn get_impl_method(cstore: cstore::cstore,"}, {"sha": "3ff9ded3f1ef34a845566b70f9f7a9319e7a9900", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/57e8de89174b8e4395e20568537d43d66a82d855/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e8de89174b8e4395e20568537d43d66a82d855/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=57e8de89174b8e4395e20568537d43d66a82d855", "patch": "@@ -24,7 +24,7 @@ export get_enum_variants;\n export get_type;\n export get_region_param;\n export get_type_param_count;\n-export get_impl_trait;\n+export get_impl_traits;\n export get_class_method;\n export get_impl_method;\n export lookup_def;\n@@ -168,13 +168,12 @@ fn item_type(item_id: ast::def_id, item: ebml::doc,\n     } else { t }\n }\n \n-fn item_impl_trait(item: ebml::doc, tcx: ty::ctxt, cdata: cmd)\n-    -> option<ty::t> {\n-    let mut result = none;\n+fn item_impl_traits(item: ebml::doc, tcx: ty::ctxt, cdata: cmd) -> ~[ty::t] {\n+    let mut results = ~[];\n     do ebml::tagged_docs(item, tag_impl_trait) |ity| {\n-        result = some(doc_type(ity, tcx, cdata));\n+        vec::push(results, doc_type(ity, tcx, cdata));\n     };\n-    result\n+    results\n }\n \n fn item_ty_param_bounds(item: ebml::doc, tcx: ty::ctxt, cdata: cmd)\n@@ -333,9 +332,8 @@ fn get_type_param_count(data: @~[u8], id: ast::node_id) -> uint {\n     item_ty_param_count(lookup_item(id, data))\n }\n \n-fn get_impl_trait(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n-    -> option<ty::t> {\n-    item_impl_trait(lookup_item(id, cdata.data), tcx, cdata)\n+fn get_impl_traits(cdata: cmd, id: ast::node_id, tcx: ty::ctxt) -> ~[ty::t] {\n+    item_impl_traits(lookup_item(id, cdata.data), tcx, cdata)\n }\n \n fn get_impl_method(cdata: cmd, id: ast::node_id,"}, {"sha": "d92bed8a0df0df17f67db6369d076f72cc92a0e7", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/57e8de89174b8e4395e20568537d43d66a82d855/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e8de89174b8e4395e20568537d43d66a82d855/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=57e8de89174b8e4395e20568537d43d66a82d855", "patch": "@@ -2507,15 +2507,7 @@ fn impl_traits(cx: ctxt, id: ast::def_id) -> ~[t] {\n            _ { ~[] }\n         }\n     } else {\n-        // XXX: csearch::get_impl_trait should return a vector.\n-        alt csearch::get_impl_trait(cx, id) {\n-            none {\n-                ~[]\n-            }\n-            some(trait_ref) {\n-                ~[trait_ref]\n-            }\n-        }\n+        csearch::get_impl_traits(cx, id)\n     }\n }\n "}, {"sha": "43f86ed926811356a4a38b8aa30d5d45d3429e67", "filename": "src/rustc/middle/typeck/coherence.rs", "status": "modified", "additions": 32, "deletions": 37, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/57e8de89174b8e4395e20568537d43d66a82d855/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e8de89174b8e4395e20568537d43d66a82d855/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=57e8de89174b8e4395e20568537d43d66a82d855", "patch": "@@ -4,7 +4,7 @@\n // has at most one implementation for each type. Then we build a mapping from\n // each trait in the system to its implementations.\n \n-import metadata::csearch::{each_path, get_impl_trait, get_impls_for_mod};\n+import metadata::csearch::{each_path, get_impl_traits, get_impls_for_mod};\n import metadata::cstore::{cstore, iter_crate_data};\n import metadata::decoder::{dl_def, dl_field, dl_impl};\n import middle::resolve3::Impl;\n@@ -546,45 +546,40 @@ class CoherenceChecker {\n \n             let self_type = lookup_item_type(self.crate_context.tcx,\n                                              implementation.did);\n-            let optional_trait =\n-                get_impl_trait(self.crate_context.tcx,\n-                               implementation.did);\n-            alt optional_trait {\n-                none {\n-                    // This is an inherent method. There should be\n-                    // no problems here, but perform a sanity check\n-                    // anyway.\n-\n-                    alt get_base_type_def_id(self.inference_context,\n-                                             dummy_sp(),\n-                                             self_type.ty) {\n-                        none {\n-                            let session = self.crate_context.tcx.sess;\n-                            session.bug(#fmt(\"no base type for \\\n-                                              external impl with no \\\n-                                              trait: %s (type %s)!\",\n-                                             *implementation.ident,\n-                                             ty_to_str\n-                                             (self.crate_context.tcx,\n-                                              self_type.ty)));\n-                        }\n-                        some(_) {\n-                            // Nothing to do.\n-                        }\n+            let associated_traits = get_impl_traits(self.crate_context.tcx,\n+                                                    implementation.did);\n+\n+            // Do a sanity check to make sure that inherent methods have base\n+            // types.\n+\n+            if associated_traits.len() == 0 {\n+                alt get_base_type_def_id(self.inference_context,\n+                                         dummy_sp(),\n+                                         self_type.ty) {\n+                    none {\n+                        let session = self.crate_context.tcx.sess;\n+                        session.bug(#fmt(\"no base type for external impl \\\n+                                          with no trait: %s (type %s)!\",\n+                                         *implementation.ident,\n+                                         ty_to_str(self.crate_context.tcx,\n+                                                   self_type.ty)));\n+                    }\n+                    some(_) {\n+                        // Nothing to do.\n                     }\n                 }\n+            }\n \n-                some(trait_type) {\n-                    alt get(trait_type).struct {\n-                        ty_trait(trait_id, _) {\n-                            self.add_trait_method(trait_id,\n-                                                  implementation);\n-                        }\n-                        _ {\n-                            self.crate_context.tcx.sess\n-                                .bug(~\"trait type returned is not a \\\n-                                       trait\");\n-                        }\n+            // Record all the trait methods.\n+            for associated_traits.each |trait_type| {\n+                alt get(trait_type).struct {\n+                    ty_trait(trait_id, _) {\n+                        self.add_trait_method(trait_id, implementation);\n+                    }\n+                    _ {\n+                        self.crate_context.tcx.sess.bug(~\"trait type \\\n+                                                          returned is not a \\\n+                                                          trait\");\n                     }\n                 }\n             }"}]}