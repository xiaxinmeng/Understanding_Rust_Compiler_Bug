{"sha": "bce5ab2c7864aa553aa70115336271586daba21c", "node_id": "C_kwDOAAsO6NoAKGJjZTVhYjJjNzg2NGFhNTUzYWE3MDExNTMzNjI3MTU4NmRhYmEyMWM", "commit": {"author": {"name": "Esteban Kuber", "email": "esteban@kuber.com.ar", "date": "2022-04-30T02:40:36Z"}, "committer": {"name": "Esteban Kuber", "email": "esteban@kuber.com.ar", "date": "2022-04-30T02:40:36Z"}, "message": "Use newtype `enum`s instead of `bool`", "tree": {"sha": "4a8fb599f2fefd684dd4925a6fc73416f5cc9688", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a8fb599f2fefd684dd4925a6fc73416f5cc9688"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bce5ab2c7864aa553aa70115336271586daba21c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bce5ab2c7864aa553aa70115336271586daba21c", "html_url": "https://github.com/rust-lang/rust/commit/bce5ab2c7864aa553aa70115336271586daba21c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bce5ab2c7864aa553aa70115336271586daba21c/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09f3ea16928d7a61ef8805bc2ad69a3bd2f7db18", "url": "https://api.github.com/repos/rust-lang/rust/commits/09f3ea16928d7a61ef8805bc2ad69a3bd2f7db18", "html_url": "https://github.com/rust-lang/rust/commit/09f3ea16928d7a61ef8805bc2ad69a3bd2f7db18"}], "stats": {"total": 64, "additions": 43, "deletions": 21}, "files": [{"sha": "e0a83ba8c0d4ac95ce65bcd3983dbdb3ca1314c3", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 43, "deletions": 21, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/bce5ab2c7864aa553aa70115336271586daba21c/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bce5ab2c7864aa553aa70115336271586daba21c/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=bce5ab2c7864aa553aa70115336271586daba21c", "patch": "@@ -123,7 +123,7 @@ impl<'a> Resolver<'a> {\n             let (span, found_use) = if let Some(def_id) = def_id.as_local() {\n                 UsePlacementFinder::check(krate, self.def_id_to_node_id[def_id])\n             } else {\n-                (None, false)\n+                (None, FoundUse::No)\n             };\n             if !candidates.is_empty() {\n                 show_candidates(\n@@ -132,9 +132,9 @@ impl<'a> Resolver<'a> {\n                     &mut err,\n                     span,\n                     &candidates,\n-                    instead,\n+                    if instead { Instead::Yes } else { Instead::No },\n                     found_use,\n-                    false,\n+                    IsPattern::No,\n                 );\n             } else if let Some((span, msg, sugg, appl)) = suggestion {\n                 err.span_suggestion(span, msg, sugg, appl);\n@@ -702,9 +702,9 @@ impl<'a> Resolver<'a> {\n                         &mut err,\n                         Some(span),\n                         &import_suggestions,\n-                        false,\n-                        true,\n-                        true,\n+                        Instead::No,\n+                        FoundUse::Yes,\n+                        IsPattern::Yes,\n                     );\n                 }\n                 err\n@@ -1482,9 +1482,9 @@ impl<'a> Resolver<'a> {\n             err,\n             None,\n             &import_suggestions,\n-            false,\n-            true,\n-            false,\n+            Instead::No,\n+            FoundUse::Yes,\n+            IsPattern::No,\n         );\n \n         if macro_kind == MacroKind::Derive && (ident.name == sym::Send || ident.name == sym::Sync) {\n@@ -2420,6 +2420,27 @@ fn find_span_immediately_after_crate_name(\n     (next_left_bracket == after_second_colon, from_second_colon)\n }\n \n+/// A suggestion has already been emitted, change the wording slightly to clarify that both are\n+/// independent options.\n+enum Instead {\n+    Yes,\n+    No,\n+}\n+\n+/// Whether an existing place with an `use` item was found.\n+enum FoundUse {\n+    Yes,\n+    No,\n+}\n+\n+/// Whether a binding is part of a pattern or an expression. Used for diagnostics.\n+enum IsPattern {\n+    /// The binding is part of a pattern\n+    Yes,\n+    /// The binding is part of an expression\n+    No,\n+}\n+\n /// When an entity with a given name is not available in scope, we search for\n /// entities with that name in all crates. This method allows outputting the\n /// results of this search in a programmer-friendly way\n@@ -2430,9 +2451,9 @@ fn show_candidates(\n     // This is `None` if all placement locations are inside expansions\n     use_placement_span: Option<Span>,\n     candidates: &[ImportSuggestion],\n-    instead: bool,\n-    found_use: bool,\n-    is_pattern: bool,\n+    instead: Instead,\n+    found_use: FoundUse,\n+    is_pattern: IsPattern,\n ) {\n     if candidates.is_empty() {\n         return;\n@@ -2465,8 +2486,8 @@ fn show_candidates(\n             (\"one of these\", \"items\", String::new())\n         };\n \n-        let instead = if instead { \" instead\" } else { \"\" };\n-        let mut msg = if is_pattern {\n+        let instead = if let Instead::Yes = instead { \" instead\" } else { \"\" };\n+        let mut msg = if let IsPattern::Yes = is_pattern {\n             format!(\n                 \"if you meant to match on {}{}{}, use the full path in the pattern\",\n                 kind, instead, name\n@@ -2479,7 +2500,7 @@ fn show_candidates(\n             err.note(note);\n         }\n \n-        if let (true, Some(span)) = (is_pattern, use_placement_span) {\n+        if let (IsPattern::Yes, Some(span)) = (is_pattern, use_placement_span) {\n             err.span_suggestions(\n                 span,\n                 &msg,\n@@ -2490,7 +2511,7 @@ fn show_candidates(\n             for candidate in &mut accessible_path_strings {\n                 // produce an additional newline to separate the new use statement\n                 // from the directly following item.\n-                let additional_newline = if found_use { \"\" } else { \"\\n\" };\n+                let additional_newline = if let FoundUse::Yes = found_use { \"\" } else { \"\\n\" };\n                 candidate.0 = format!(\"use {};\\n{}\", &candidate.0, additional_newline);\n             }\n \n@@ -2513,15 +2534,16 @@ fn show_candidates(\n     } else {\n         assert!(!inaccessible_path_strings.is_empty());\n \n-        let prefix = if is_pattern { \"you might have meant to match on \" } else { \"\" };\n+        let prefix =\n+            if let IsPattern::Yes = is_pattern { \"you might have meant to match on \" } else { \"\" };\n         if inaccessible_path_strings.len() == 1 {\n             let (name, descr, def_id, note) = &inaccessible_path_strings[0];\n             let msg = format!(\n                 \"{}{} `{}`{} exists but is inaccessible\",\n                 prefix,\n                 descr,\n                 name,\n-                if is_pattern { \", which\" } else { \"\" }\n+                if let IsPattern::Yes = is_pattern { \", which\" } else { \"\" }\n             );\n \n             if let Some(local_def_id) = def_id.and_then(|did| did.as_local()) {\n@@ -2589,14 +2611,14 @@ struct UsePlacementFinder {\n }\n \n impl UsePlacementFinder {\n-    fn check(krate: &Crate, target_module: NodeId) -> (Option<Span>, bool) {\n+    fn check(krate: &Crate, target_module: NodeId) -> (Option<Span>, FoundUse) {\n         let mut finder =\n             UsePlacementFinder { target_module, first_legal_span: None, first_use_span: None };\n         finder.visit_crate(krate);\n         if let Some(use_span) = finder.first_use_span {\n-            (Some(use_span), true)\n+            (Some(use_span), FoundUse::Yes)\n         } else {\n-            (finder.first_legal_span, false)\n+            (finder.first_legal_span, FoundUse::No)\n         }\n     }\n }"}]}