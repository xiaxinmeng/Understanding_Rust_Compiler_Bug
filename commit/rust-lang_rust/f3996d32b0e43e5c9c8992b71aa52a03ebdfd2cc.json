{"sha": "f3996d32b0e43e5c9c8992b71aa52a03ebdfd2cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzOTk2ZDMyYjBlNDNlNWM5Yzg5OTJiNzFhYTUyYTAzZWJkZmQyY2M=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-06-16T19:19:27Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-06-16T21:21:42Z"}, "message": "rustc: Parse inner attributes of modules\n\nIssue #487", "tree": {"sha": "e57bfae550114d15b040240f48a48a9194f6d261", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e57bfae550114d15b040240f48a48a9194f6d261"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3996d32b0e43e5c9c8992b71aa52a03ebdfd2cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3996d32b0e43e5c9c8992b71aa52a03ebdfd2cc", "html_url": "https://github.com/rust-lang/rust/commit/f3996d32b0e43e5c9c8992b71aa52a03ebdfd2cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3996d32b0e43e5c9c8992b71aa52a03ebdfd2cc/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0efd7fac8a3dbcf7c8bd19ea2ace05e4898bafae", "url": "https://api.github.com/repos/rust-lang/rust/commits/0efd7fac8a3dbcf7c8bd19ea2ace05e4898bafae", "html_url": "https://github.com/rust-lang/rust/commit/0efd7fac8a3dbcf7c8bd19ea2ace05e4898bafae"}], "stats": {"total": 110, "additions": 93, "deletions": 17}, "files": [{"sha": "44a6e1abb5dfb6a5de0c9885604eb20f223b6494", "filename": "src/comp/front/eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3996d32b0e43e5c9c8992b71aa52a03ebdfd2cc/src%2Fcomp%2Ffront%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3996d32b0e43e5c9c8992b71aa52a03ebdfd2cc/src%2Fcomp%2Ffront%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Feval.rs?ref=f3996d32b0e43e5c9c8992b71aa52a03ebdfd2cc", "patch": "@@ -287,7 +287,7 @@ fn eval_crate_directive(ctx cx, env e, @ast::crate_directive cdir, str prefix,\n             auto p0 =\n                 new_parser(cx.sess, e, start_id, full_path, cx.chpos,\n                            cx.next_ann);\n-            auto m0 = parse_mod_items(p0, token::EOF);\n+            auto m0 = parse_mod_items(p0, token::EOF, []);\n             auto next_id = p0.next_def_id();\n             // Thread defids and chpos through the parsers\n "}, {"sha": "39ceb7a6540a625837016447974712848dc8d70a", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 48, "deletions": 16, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/f3996d32b0e43e5c9c8992b71aa52a03ebdfd2cc/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3996d32b0e43e5c9c8992b71aa52a03ebdfd2cc/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=f3996d32b0e43e5c9c8992b71aa52a03ebdfd2cc", "patch": "@@ -955,10 +955,10 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n fn parse_syntax_ext(&parser p) -> @ast::expr {\n     auto lo = p.get_lo_pos();\n     expect(p, token::POUND);\n-    ret parse_syntax_ext_inner(p, lo);\n+    ret parse_syntax_ext_naked(p, lo);\n }\n \n-fn parse_syntax_ext_inner(&parser p, uint lo) -> @ast::expr {\n+fn parse_syntax_ext_naked(&parser p, uint lo) -> @ast::expr {\n     auto pth = parse_path(p);\n     auto es = parse_seq(token::LPAREN, token::RPAREN,\n                         some(token::COMMA), parse_expr, p);\n@@ -1496,7 +1496,7 @@ fn parse_source_stmt(&parser p) -> @ast::stmt {\n     } else {\n \n         auto item_attrs;\n-        alt (parse_attrs_or_ext(p)) {\n+        alt (parse_outer_attrs_or_ext(p)) {\n             case (none) {\n                 item_attrs = [];\n             }\n@@ -1799,11 +1799,14 @@ fn parse_item_obj(&parser p, ast::layer lyr, vec[ast::attribute] attrs) ->\n                                                 p.next_def_id()), attrs);\n }\n \n-fn parse_mod_items(&parser p, token::token term) -> ast::_mod {\n+fn parse_mod_items(&parser p, token::token term,\n+                   vec[ast::attribute] first_item_attrs) -> ast::_mod {\n     auto view_items = parse_view(p);\n     let vec[@ast::item] items = [];\n+    auto initial_attrs = first_item_attrs;\n     while (p.peek() != term) {\n-        auto attrs = parse_attributes(p);\n+        auto attrs = initial_attrs + parse_outer_attributes(p);\n+        initial_attrs = [];\n         alt (parse_item(p, attrs)) {\n             case (got_item(?i)) { vec::push(items, i); }\n             case (_) {\n@@ -1830,10 +1833,13 @@ fn parse_item_mod(&parser p, vec[ast::attribute] attrs) -> @ast::item {\n     auto lo = p.get_last_lo_pos();\n     auto id = parse_ident(p);\n     expect(p, token::LBRACE);\n-    auto m = parse_mod_items(p, token::RBRACE);\n+    auto inner_attrs = parse_inner_attributes(p);\n+    auto first_item_outer_attrs = inner_attrs._1;\n+    auto m = parse_mod_items(p, token::RBRACE,\n+                             first_item_outer_attrs);\n     auto hi = p.get_hi_pos();\n     expect(p, token::RBRACE);\n-    ret mk_item(p, lo, hi, id, ast::item_mod(m), attrs);\n+    ret mk_item(p, lo, hi, id, ast::item_mod(m), attrs + inner_attrs._0);\n }\n \n fn parse_item_native_type(&parser p) -> @ast::native_item {\n@@ -2039,41 +2045,67 @@ fn parse_item(&parser p, vec[ast::attribute] attrs) -> parsed_item {\n type attr_or_ext = option::t[either::t[vec[ast::attribute],\n                                        @ast::expr]];\n \n-fn parse_attrs_or_ext(&parser p) -> attr_or_ext {\n+fn parse_outer_attrs_or_ext(&parser p) -> attr_or_ext {\n     if (p.peek() == token::POUND) {\n         auto lo = p.get_lo_pos();\n         p.bump();\n         if (p.peek() == token::LBRACKET) {\n-            auto first_attr = parse_attribute_inner(p, lo);\n-            ret some(left([first_attr] + parse_attributes(p)));\n+            auto first_attr = parse_attribute_naked(p, lo);\n+            ret some(left([first_attr] + parse_outer_attributes(p)));\n         } else {\n-            ret some(right(parse_syntax_ext_inner(p, lo)));\n+            ret some(right(parse_syntax_ext_naked(p, lo)));\n         }\n     } else {\n         ret none;\n     }\n }\n \n-fn parse_attributes(&parser p) -> vec[ast::attribute] {\n+// Parse attributes that appear before an item\n+fn parse_outer_attributes(&parser p) -> vec[ast::attribute] {\n     let vec[ast::attribute] attrs = [];\n-    while (p.peek() == token::POUND) { attrs += [parse_attribute(p)]; }\n+    while (p.peek() == token::POUND) {\n+        attrs += [parse_attribute(p)];\n+    }\n     ret attrs;\n }\n \n fn parse_attribute(&parser p) -> ast::attribute {\n     auto lo = p.get_lo_pos();\n     expect(p, token::POUND);\n-    ret parse_attribute_inner(p, lo);\n+    ret parse_attribute_naked(p, lo);\n }\n \n-fn parse_attribute_inner(&parser p, uint lo) -> ast::attribute {\n+fn parse_attribute_naked(&parser p, uint lo) -> ast::attribute {\n     expect(p, token::LBRACKET);\n     auto meta_item = parse_meta_item(p);\n     expect(p, token::RBRACKET);\n     auto hi = p.get_hi_pos();\n     ret spanned(lo, hi, rec(style=ast::attr_outer, value=*meta_item));\n }\n \n+// Parse attributes that appear after the opening of an item, each terminated\n+// by a semicolon. In addition to a vector of inner attributes, this function\n+// also returns a vector that may contain the first outer attribute of the\n+// next item (since we can't know whether the attribute is an inner attribute\n+// of the containing item or an outer attribute of the first contained item\n+// until we see the semi).\n+fn parse_inner_attributes(&parser p) -> tup(vec[ast::attribute],\n+                                            vec[ast::attribute]) {\n+    let vec[ast::attribute] inner_attrs = [];\n+    let vec[ast::attribute] next_outer_attrs = [];\n+    while (p.peek() == token::POUND) {\n+        auto attr = parse_attribute(p);\n+        if (p.peek() == token::SEMI) {\n+            p.bump();\n+            inner_attrs += [attr];\n+        } else {\n+            next_outer_attrs += [attr];\n+            break;\n+        }\n+    }\n+    ret tup(inner_attrs, next_outer_attrs);\n+}\n+\n fn parse_meta_item(&parser p) -> @ast::meta_item {\n     auto lo = p.get_lo_pos();\n     auto ident = parse_ident(p);\n@@ -2234,7 +2266,7 @@ fn parse_native_view(&parser p) -> vec[@ast::view_item] {\n \n fn parse_crate_from_source_file(&parser p) -> @ast::crate {\n     auto lo = p.get_lo_pos();\n-    auto m = parse_mod_items(p, token::EOF);\n+    auto m = parse_mod_items(p, token::EOF, []);\n     let vec[@ast::crate_directive] cdirs = [];\n     ret @spanned(lo, p.get_lo_pos(), rec(directives=cdirs, module=m));\n }"}, {"sha": "39f96499e92975bdec807c6ac5650509b8b64bd3", "filename": "src/test/run-pass/item-attributes.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f3996d32b0e43e5c9c8992b71aa52a03ebdfd2cc/src%2Ftest%2Frun-pass%2Fitem-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3996d32b0e43e5c9c8992b71aa52a03ebdfd2cc/src%2Ftest%2Frun-pass%2Fitem-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fitem-attributes.rs?ref=f3996d32b0e43e5c9c8992b71aa52a03ebdfd2cc", "patch": "@@ -116,5 +116,49 @@ mod test_stmt_multi_attr_outer {\n     }\n }\n \n+mod test_attr_inner {\n+\n+    mod m {\n+        // This is an attribute of mod m\n+        #[attr = \"val\"];\n+    }\n+}\n+\n+mod test_attr_inner_then_outer {\n+\n+    mod m {\n+        // This is an attribute of mod m\n+        #[attr = \"val\"];\n+        // This is an attribute of fn f\n+        #[attr = \"val\"]\n+        fn f() {\n+        }\n+    }\n+}\n+\n+mod test_attr_inner_then_outer_multi {\n+    mod m {\n+        // This is an attribute of mod m\n+        #[attr1 = \"val\"];\n+        #[attr2 = \"val\"];\n+        // This is an attribute of fn f\n+        #[attr1 = \"val\"]\n+        #[attr2 = \"val\"]\n+        fn f() {\n+        }\n+    }\n+}\n+\n fn main() {\n }\n+\n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:\n+//"}]}