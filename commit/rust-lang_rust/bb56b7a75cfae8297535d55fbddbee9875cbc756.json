{"sha": "bb56b7a75cfae8297535d55fbddbee9875cbc756", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiNTZiN2E3NWNmYWU4Mjk3NTM1ZDU1ZmJkZGJlZTk4NzVjYmM3NTY=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-03-30T16:27:16Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-03-30T16:27:16Z"}, "message": "Use new new docs string source mapping in goto_def and hover", "tree": {"sha": "d367c18dddc65d4442679680ea728f5b06280ea5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d367c18dddc65d4442679680ea728f5b06280ea5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb56b7a75cfae8297535d55fbddbee9875cbc756", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb56b7a75cfae8297535d55fbddbee9875cbc756", "html_url": "https://github.com/rust-lang/rust/commit/bb56b7a75cfae8297535d55fbddbee9875cbc756", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb56b7a75cfae8297535d55fbddbee9875cbc756/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a327311e4a9b9102528751e052c63266c00c6bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a327311e4a9b9102528751e052c63266c00c6bd", "html_url": "https://github.com/rust-lang/rust/commit/9a327311e4a9b9102528751e052c63266c00c6bd"}], "stats": {"total": 192, "additions": 73, "deletions": 119}, "files": [{"sha": "9a9a411138797d1eb133c292d05128cf84b14e6f", "filename": "crates/ide/src/doc_links.rs", "status": "modified", "additions": 43, "deletions": 74, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/bb56b7a75cfae8297535d55fbddbee9875cbc756/crates%2Fide%2Fsrc%2Fdoc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb56b7a75cfae8297535d55fbddbee9875cbc756/crates%2Fide%2Fsrc%2Fdoc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdoc_links.rs?ref=bb56b7a75cfae8297535d55fbddbee9875cbc756", "patch": "@@ -15,10 +15,7 @@ use ide_db::{\n     defs::{Definition, NameClass, NameRefClass},\n     RootDatabase,\n };\n-use syntax::{\n-    ast, match_ast, AstNode, AstToken, SyntaxKind::*, SyntaxNode, SyntaxToken, TextRange, TextSize,\n-    TokenAtOffset, T,\n-};\n+use syntax::{ast, match_ast, AstNode, SyntaxKind::*, SyntaxNode, SyntaxToken, TokenAtOffset, T};\n \n use crate::{FilePosition, Semantics};\n \n@@ -119,77 +116,22 @@ pub(crate) fn external_docs(\n pub(crate) fn extract_definitions_from_markdown(\n     markdown: &str,\n ) -> Vec<(Range<usize>, String, Option<hir::Namespace>)> {\n-    extract_definitions_from_markdown_(markdown, &mut broken_link_clone_cb).collect()\n-}\n-\n-fn extract_definitions_from_markdown_<'a>(\n-    markdown: &'a str,\n-    cb: &'a mut dyn FnMut(BrokenLink<'_>) -> Option<(CowStr<'a>, CowStr<'a>)>,\n-) -> impl Iterator<Item = (Range<usize>, String, Option<hir::Namespace>)> + 'a {\n-    Parser::new_with_broken_link_callback(markdown, Options::empty(), Some(cb))\n-        .into_offset_iter()\n-        .filter_map(|(event, range)| {\n-            if let Event::Start(Tag::Link(_, target, title)) = event {\n-                let link = if target.is_empty() { title } else { target };\n-                let (link, ns) = parse_intra_doc_link(&link);\n-                Some((range, link.to_string(), ns))\n-            } else {\n-                None\n-            }\n-        })\n-}\n-\n-/// Extracts a link from a comment at the given position returning the spanning range, link and\n-/// optionally it's namespace.\n-pub(crate) fn extract_positioned_link_from_comment(\n-    position: TextSize,\n-    comment: &ast::Comment,\n-    docs: hir::Documentation,\n-) -> Option<(TextRange, String, Option<hir::Namespace>)> {\n-    let doc_comment = comment.doc_comment()?.to_string() + \"\\n\" + docs.as_str();\n-    let comment_start =\n-        comment.syntax().text_range().start() + TextSize::from(comment.prefix().len() as u32);\n-    let len = comment.syntax().text_range().len().into();\n-    let mut cb = broken_link_clone_cb;\n-    // because pulldown_cmarks lifetimes are wrong we gotta dance around a few temporaries here\n-    let res = extract_definitions_from_markdown_(&doc_comment, &mut cb)\n-        .take_while(|&(Range { end, .. }, ..)| end < len)\n-        .find_map(|(Range { start, end }, def_link, ns)| {\n-            let range = TextRange::at(\n-                comment_start + TextSize::from(start as u32),\n-                TextSize::from((end - start) as u32),\n-            );\n-            range.contains(position).then(|| (range, def_link, ns))\n-        });\n-    res\n-}\n-\n-/// Turns a syntax node into it's [`Definition`] if it can hold docs.\n-pub(crate) fn doc_owner_to_def(\n-    sema: &Semantics<RootDatabase>,\n-    item: &SyntaxNode,\n-) -> Option<Definition> {\n-    let res: hir::ModuleDef = match_ast! {\n-        match item {\n-            ast::SourceFile(_it) => sema.scope(item).module()?.into(),\n-            ast::Fn(it) => sema.to_def(&it)?.into(),\n-            ast::Struct(it) => sema.to_def(&it)?.into(),\n-            ast::Enum(it) => sema.to_def(&it)?.into(),\n-            ast::Union(it) => sema.to_def(&it)?.into(),\n-            ast::Trait(it) => sema.to_def(&it)?.into(),\n-            ast::Const(it) => sema.to_def(&it)?.into(),\n-            ast::Static(it) => sema.to_def(&it)?.into(),\n-            ast::TypeAlias(it) => sema.to_def(&it)?.into(),\n-            ast::Variant(it) => sema.to_def(&it)?.into(),\n-            ast::Trait(it) => sema.to_def(&it)?.into(),\n-            ast::Impl(it) => return sema.to_def(&it).map(Definition::SelfType),\n-            ast::Macro(it) => return sema.to_def(&it).map(Definition::Macro),\n-            ast::TupleField(it) => return sema.to_def(&it).map(Definition::Field),\n-            ast::RecordField(it) => return sema.to_def(&it).map(Definition::Field),\n-            _ => return None,\n+    Parser::new_with_broken_link_callback(\n+        markdown,\n+        Options::empty(),\n+        Some(&mut broken_link_clone_cb),\n+    )\n+    .into_offset_iter()\n+    .filter_map(|(event, range)| {\n+        if let Event::Start(Tag::Link(_, target, title)) = event {\n+            let link = if target.is_empty() { title } else { target };\n+            let (link, ns) = parse_intra_doc_link(&link);\n+            Some((range, link.to_string(), ns))\n+        } else {\n+            None\n         }\n-    };\n-    Some(Definition::ModuleDef(res))\n+    })\n+    .collect()\n }\n \n pub(crate) fn resolve_doc_path_for_def(\n@@ -219,6 +161,33 @@ pub(crate) fn resolve_doc_path_for_def(\n     }\n }\n \n+pub(crate) fn doc_attributes(\n+    sema: &Semantics<RootDatabase>,\n+    node: &SyntaxNode,\n+) -> Option<(hir::AttrsWithOwner, Definition)> {\n+    match_ast! {\n+        match node {\n+            ast::SourceFile(it)  => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Module(def)))),\n+            ast::Module(it)      => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Module(def)))),\n+            ast::Fn(it)          => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Function(def)))),\n+            ast::Struct(it)      => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Struct(def))))),\n+            ast::Union(it)       => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Union(def))))),\n+            ast::Enum(it)        => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Enum(def))))),\n+            ast::Variant(it)     => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Variant(def)))),\n+            ast::Trait(it)       => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Trait(def)))),\n+            ast::Static(it)      => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Static(def)))),\n+            ast::Const(it)       => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Const(def)))),\n+            ast::TypeAlias(it)   => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::TypeAlias(def)))),\n+            ast::Impl(it)        => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::SelfType(def))),\n+            ast::RecordField(it) => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::Field(def))),\n+            ast::TupleField(it)  => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::Field(def))),\n+            ast::Macro(it)       => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::Macro(def))),\n+            // ast::Use(it) => sema.to_def(&it).map(|def| (Box::new(it) as _, def.attrs(sema.db))),\n+            _ => return None\n+        }\n+    }\n+}\n+\n fn broken_link_clone_cb<'a, 'b>(link: BrokenLink<'a>) -> Option<(CowStr<'b>, CowStr<'b>)> {\n     // These allocations are actually unnecessary but the lifetimes on BrokenLinkCallback are wrong\n     // this is fixed in the repo but not on the crates.io release yet"}, {"sha": "780bdd40d81d7429121f9054b87b5f509e5fa585", "filename": "crates/ide/src/goto_definition.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bb56b7a75cfae8297535d55fbddbee9875cbc756/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb56b7a75cfae8297535d55fbddbee9875cbc756/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=bb56b7a75cfae8297535d55fbddbee9875cbc756", "patch": "@@ -1,5 +1,5 @@\n use either::Either;\n-use hir::Semantics;\n+use hir::{InFile, Semantics};\n use ide_db::{\n     defs::{NameClass, NameRefClass},\n     RootDatabase,\n@@ -8,7 +8,7 @@ use syntax::{ast, match_ast, AstNode, AstToken, SyntaxKind::*, SyntaxToken, Toke\n \n use crate::{\n     display::TryToNav,\n-    doc_links::{doc_owner_to_def, extract_positioned_link_from_comment, resolve_doc_path_for_def},\n+    doc_links::{doc_attributes, extract_definitions_from_markdown, resolve_doc_path_for_def},\n     FilePosition, NavigationTarget, RangeInfo,\n };\n \n@@ -30,11 +30,16 @@ pub(crate) fn goto_definition(\n     let original_token = pick_best(file.token_at_offset(position.offset))?;\n     let token = sema.descend_into_macros(original_token.clone());\n     let parent = token.parent()?;\n-    if let Some(comment) = ast::Comment::cast(token) {\n-        let docs = doc_owner_to_def(&sema, &parent)?.docs(db)?;\n-\n-        let (_, link, ns) = extract_positioned_link_from_comment(position.offset, &comment, docs)?;\n-        let def = doc_owner_to_def(&sema, &parent)?;\n+    if let Some(_) = ast::Comment::cast(token) {\n+        let (attributes, def) = doc_attributes(&sema, &parent)?;\n+\n+        let (docs, doc_mapping) = attributes.docs_with_rangemap(db)?;\n+        let (_, link, ns) =\n+            extract_definitions_from_markdown(docs.as_str()).into_iter().find(|(range, ..)| {\n+                doc_mapping.map(range.clone()).map_or(false, |InFile { file_id, value: range }| {\n+                    file_id == position.file_id.into() && range.contains(position.offset)\n+                })\n+            })?;\n         let nav = resolve_doc_path_for_def(db, def, &link, ns)?.try_to_nav(db)?;\n         return Some(RangeInfo::new(original_token.text_range(), vec![nav]));\n     }"}, {"sha": "1e66219e4b1fba00b73dc03657394bc86739d2aa", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bb56b7a75cfae8297535d55fbddbee9875cbc756/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb56b7a75cfae8297535d55fbddbee9875cbc756/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=bb56b7a75cfae8297535d55fbddbee9875cbc756", "patch": "@@ -1,6 +1,6 @@\n use either::Either;\n use hir::{\n-    AsAssocItem, AssocItemContainer, GenericParam, HasAttrs, HasSource, HirDisplay, Module,\n+    AsAssocItem, AssocItemContainer, GenericParam, HasAttrs, HasSource, HirDisplay, InFile, Module,\n     ModuleDef, Semantics,\n };\n use ide_db::{\n@@ -16,8 +16,8 @@ use syntax::{ast, match_ast, AstNode, AstToken, SyntaxKind::*, SyntaxToken, Toke\n use crate::{\n     display::{macro_label, TryToNav},\n     doc_links::{\n-        doc_owner_to_def, extract_positioned_link_from_comment, remove_links,\n-        resolve_doc_path_for_def, rewrite_links,\n+        doc_attributes, extract_definitions_from_markdown, remove_links, resolve_doc_path_for_def,\n+        rewrite_links,\n     },\n     markdown_remove::remove_markdown,\n     markup::Markup,\n@@ -114,11 +114,18 @@ pub(crate) fn hover(\n             ),\n \n             _ => ast::Comment::cast(token.clone())\n-                .and_then(|comment| {\n-                    let def = doc_owner_to_def(&sema, &node)?;\n-                    let docs = def.docs(db)?;\n+                .and_then(|_| {\n+                    let (attributes, def) = doc_attributes(&sema, &node)?;\n+                    let (docs, doc_mapping) = attributes.docs_with_rangemap(db)?;\n                     let (idl_range, link, ns) =\n-                        extract_positioned_link_from_comment(position.offset, &comment, docs)?;\n+                        extract_definitions_from_markdown(docs.as_str()).into_iter().find_map(|(range, link, ns)| {\n+                            let InFile { file_id, value: range } = doc_mapping.map(range.clone())?;\n+                            if file_id == position.file_id.into() && range.contains(position.offset) {\n+                                Some((range, link, ns))\n+                            } else {\n+                                None\n+                            }\n+                        })?;\n                     range = Some(idl_range);\n                     resolve_doc_path_for_def(db, def, &link, ns)\n                 })"}, {"sha": "04fafd244f847b10b6b933c568cd34d113a4adc8", "filename": "crates/ide/src/syntax_highlighting/inject.rs", "status": "modified", "additions": 4, "deletions": 31, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/bb56b7a75cfae8297535d55fbddbee9875cbc756/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb56b7a75cfae8297535d55fbddbee9875cbc756/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs?ref=bb56b7a75cfae8297535d55fbddbee9875cbc756", "patch": "@@ -3,15 +3,15 @@\n use std::mem;\n \n use either::Either;\n-use hir::{HasAttrs, InFile, Semantics};\n-use ide_db::{call_info::ActiveParameter, defs::Definition, SymbolKind};\n+use hir::{InFile, Semantics};\n+use ide_db::{call_info::ActiveParameter, SymbolKind};\n use syntax::{\n     ast::{self, AstNode},\n-    match_ast, AstToken, NodeOrToken, SyntaxNode, SyntaxToken, TextRange, TextSize,\n+    AstToken, NodeOrToken, SyntaxNode, SyntaxToken, TextRange, TextSize,\n };\n \n use crate::{\n-    doc_links::{extract_definitions_from_markdown, resolve_doc_path_for_def},\n+    doc_links::{doc_attributes, extract_definitions_from_markdown, resolve_doc_path_for_def},\n     Analysis, HlMod, HlRange, HlTag, RootDatabase,\n };\n \n@@ -90,33 +90,6 @@ const RUSTDOC_FENCE_TOKENS: &[&'static str] = &[\n     \"edition2021\",\n ];\n \n-fn doc_attributes<'node>(\n-    sema: &Semantics<RootDatabase>,\n-    node: &'node SyntaxNode,\n-) -> Option<(hir::AttrsWithOwner, Definition)> {\n-    match_ast! {\n-        match node {\n-            ast::SourceFile(it)  => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Module(def)))),\n-            ast::Module(it)      => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Module(def)))),\n-            ast::Fn(it)          => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Function(def)))),\n-            ast::Struct(it)      => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Struct(def))))),\n-            ast::Union(it)       => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Union(def))))),\n-            ast::Enum(it)        => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Enum(def))))),\n-            ast::Variant(it)     => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Variant(def)))),\n-            ast::Trait(it)       => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Trait(def)))),\n-            ast::Static(it)      => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Static(def)))),\n-            ast::Const(it)       => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Const(def)))),\n-            ast::TypeAlias(it)   => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::TypeAlias(def)))),\n-            ast::Impl(it)        => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::SelfType(def))),\n-            ast::RecordField(it) => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::Field(def))),\n-            ast::TupleField(it)  => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::Field(def))),\n-            ast::Macro(it)       => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::Macro(def))),\n-            // ast::Use(it) => sema.to_def(&it).map(|def| (Box::new(it) as _, def.attrs(sema.db))),\n-            _ => return None\n-        }\n-    }\n-}\n-\n /// Injection of syntax highlighting of doctests.\n pub(super) fn doc_comment(\n     hl: &mut Highlights,"}]}