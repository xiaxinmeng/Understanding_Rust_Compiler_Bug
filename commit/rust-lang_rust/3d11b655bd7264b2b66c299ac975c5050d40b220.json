{"sha": "3d11b655bd7264b2b66c299ac975c5050d40b220", "node_id": "C_kwDOAAsO6NoAKDNkMTFiNjU1YmQ3MjY0YjJiNjZjMjk5YWM5NzVjNTA1MGQ0MGIyMjA", "commit": {"author": {"name": "Markus Everling", "email": "markuseverling@gmail.com", "date": "2023-01-31T16:37:03Z"}, "committer": {"name": "Markus Everling", "email": "markuseverling@gmail.com", "date": "2023-05-24T00:38:20Z"}, "message": "Add Median of Medians fallback to introselect", "tree": {"sha": "ae0b7d296ed6c5f89e35fe9fa62cf003fe04c6c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae0b7d296ed6c5f89e35fe9fa62cf003fe04c6c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d11b655bd7264b2b66c299ac975c5050d40b220", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d11b655bd7264b2b66c299ac975c5050d40b220", "html_url": "https://github.com/rust-lang/rust/commit/3d11b655bd7264b2b66c299ac975c5050d40b220", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d11b655bd7264b2b66c299ac975c5050d40b220/comments", "author": {"login": "Sp00ph", "id": 61327188, "node_id": "MDQ6VXNlcjYxMzI3MTg4", "avatar_url": "https://avatars.githubusercontent.com/u/61327188?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Sp00ph", "html_url": "https://github.com/Sp00ph", "followers_url": "https://api.github.com/users/Sp00ph/followers", "following_url": "https://api.github.com/users/Sp00ph/following{/other_user}", "gists_url": "https://api.github.com/users/Sp00ph/gists{/gist_id}", "starred_url": "https://api.github.com/users/Sp00ph/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Sp00ph/subscriptions", "organizations_url": "https://api.github.com/users/Sp00ph/orgs", "repos_url": "https://api.github.com/users/Sp00ph/repos", "events_url": "https://api.github.com/users/Sp00ph/events{/privacy}", "received_events_url": "https://api.github.com/users/Sp00ph/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Sp00ph", "id": 61327188, "node_id": "MDQ6VXNlcjYxMzI3MTg4", "avatar_url": "https://avatars.githubusercontent.com/u/61327188?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Sp00ph", "html_url": "https://github.com/Sp00ph", "followers_url": "https://api.github.com/users/Sp00ph/followers", "following_url": "https://api.github.com/users/Sp00ph/following{/other_user}", "gists_url": "https://api.github.com/users/Sp00ph/gists{/gist_id}", "starred_url": "https://api.github.com/users/Sp00ph/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Sp00ph/subscriptions", "organizations_url": "https://api.github.com/users/Sp00ph/orgs", "repos_url": "https://api.github.com/users/Sp00ph/repos", "events_url": "https://api.github.com/users/Sp00ph/events{/privacy}", "received_events_url": "https://api.github.com/users/Sp00ph/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3d597b31c0f101a02c230798afa31a36bdacbc6", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3d597b31c0f101a02c230798afa31a36bdacbc6", "html_url": "https://github.com/rust-lang/rust/commit/f3d597b31c0f101a02c230798afa31a36bdacbc6"}], "stats": {"total": 441, "additions": 301, "deletions": 140}, "files": [{"sha": "425c13c752c8f679576a0d6c7d7b09e8c12f3c26", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3d11b655bd7264b2b66c299ac975c5050d40b220/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d11b655bd7264b2b66c299ac975c5050d40b220/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=3d11b655bd7264b2b66c299ac975c5050d40b220", "patch": "@@ -42,6 +42,7 @@ mod index;\n mod iter;\n mod raw;\n mod rotate;\n+mod select;\n mod specialize;\n \n #[unstable(feature = \"str_internals\", issue = \"none\")]\n@@ -2776,7 +2777,7 @@ impl<T> [T] {\n     where\n         T: Ord,\n     {\n-        sort::partition_at_index(self, index, T::lt)\n+        select::partition_at_index(self, index, T::lt)\n     }\n \n     /// Reorder the slice with a comparator function such that the element at `index` is at its\n@@ -2831,7 +2832,7 @@ impl<T> [T] {\n     where\n         F: FnMut(&T, &T) -> Ordering,\n     {\n-        sort::partition_at_index(self, index, |a: &T, b: &T| compare(a, b) == Less)\n+        select::partition_at_index(self, index, |a: &T, b: &T| compare(a, b) == Less)\n     }\n \n     /// Reorder the slice with a key extraction function such that the element at `index` is at its\n@@ -2887,7 +2888,7 @@ impl<T> [T] {\n         F: FnMut(&T) -> K,\n         K: Ord,\n     {\n-        sort::partition_at_index(self, index, |a: &T, b: &T| f(a).lt(&f(b)))\n+        select::partition_at_index(self, index, |a: &T, b: &T| f(a).lt(&f(b)))\n     }\n \n     /// Moves all consecutive repeated elements to the end of the slice according to the"}, {"sha": "ff88cb89a7405388036aeedb9c7a699f8611f960", "filename": "library/core/src/slice/select.rs", "status": "added", "additions": 292, "deletions": 0, "changes": 292, "blob_url": "https://github.com/rust-lang/rust/blob/3d11b655bd7264b2b66c299ac975c5050d40b220/library%2Fcore%2Fsrc%2Fslice%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d11b655bd7264b2b66c299ac975c5050d40b220/library%2Fcore%2Fsrc%2Fslice%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fselect.rs?ref=3d11b655bd7264b2b66c299ac975c5050d40b220", "patch": "@@ -0,0 +1,292 @@\n+//! Slice selection\n+//!\n+//! This module contains the implementation for `slice::select_nth_unstable`.\n+//! It uses an introselect algorithm based on Orson Peters' pattern-defeating quicksort,\n+//! published at: <https://github.com/orlp/pdqsort>\n+//!\n+//! The fallback algorithm used for introselect is Median of Medians using Tukey's Ninther\n+//! for pivot selection. Using this as a fallback ensures O(n) worst case running time with\n+//! better performance than one would get using heapsort as fallback.\n+\n+use crate::cmp;\n+use crate::mem::{self, SizedTypeProperties};\n+use crate::slice::sort::{\n+    break_patterns, choose_pivot, insertion_sort_shift_left, partition, partition_equal,\n+};\n+\n+// For slices of up to this length it's probably faster to simply sort them.\n+// Defined at the module scope because it's used in multiple functions.\n+const MAX_INSERTION: usize = 10;\n+\n+fn partition_at_index_loop<'a, T, F>(\n+    mut v: &'a mut [T],\n+    mut index: usize,\n+    is_less: &mut F,\n+    mut pred: Option<&'a T>,\n+) where\n+    F: FnMut(&T, &T) -> bool,\n+{\n+    // Limit the amount of iterations and fall back to fast deterministic selection\n+    // to ensure O(n) worst case running time. This limit needs to be constant, because\n+    // using `ilog2(len)` like in `sort` would result in O(n log n) time complexity.\n+    // The exact value of the limit is chosen somewhat arbitrarily, but for most inputs bad pivot\n+    // selections should be relatively rare, so the limit usually shouldn't be reached\n+    // anyways.\n+    let mut limit = 16;\n+\n+    // True if the last partitioning was reasonably balanced.\n+    let mut was_balanced = true;\n+\n+    loop {\n+        if v.len() <= MAX_INSERTION {\n+            if v.len() > 1 {\n+                insertion_sort_shift_left(v, 1, is_less);\n+            }\n+            return;\n+        }\n+\n+        if limit == 0 {\n+            median_of_medians(v, is_less, index);\n+            return;\n+        }\n+\n+        // If the last partitioning was imbalanced, try breaking patterns in the slice by shuffling\n+        // some elements around. Hopefully we'll choose a better pivot this time.\n+        if !was_balanced {\n+            break_patterns(v);\n+            limit -= 1;\n+        }\n+\n+        // Choose a pivot\n+        let (pivot, _) = choose_pivot(v, is_less);\n+\n+        // If the chosen pivot is equal to the predecessor, then it's the smallest element in the\n+        // slice. Partition the slice into elements equal to and elements greater than the pivot.\n+        // This case is usually hit when the slice contains many duplicate elements.\n+        if let Some(p) = pred {\n+            if !is_less(p, &v[pivot]) {\n+                let mid = partition_equal(v, pivot, is_less);\n+\n+                // If we've passed our index, then we're good.\n+                if mid > index {\n+                    return;\n+                }\n+\n+                // Otherwise, continue sorting elements greater than the pivot.\n+                v = &mut v[mid..];\n+                index = index - mid;\n+                pred = None;\n+                continue;\n+            }\n+        }\n+\n+        let (mid, _) = partition(v, pivot, is_less);\n+        was_balanced = cmp::min(mid, v.len() - mid) >= v.len() / 8;\n+\n+        // Split the slice into `left`, `pivot`, and `right`.\n+        let (left, right) = v.split_at_mut(mid);\n+        let (pivot, right) = right.split_at_mut(1);\n+        let pivot = &pivot[0];\n+\n+        if mid < index {\n+            v = right;\n+            index = index - mid - 1;\n+            pred = Some(pivot);\n+        } else if mid > index {\n+            v = left;\n+        } else {\n+            // If mid == index, then we're done, since partition() guaranteed that all elements\n+            // after mid are greater than or equal to mid.\n+            return;\n+        }\n+    }\n+}\n+\n+/// Reorder the slice such that the element at `index` is at its final sorted position.\n+pub fn partition_at_index<T, F>(\n+    v: &mut [T],\n+    index: usize,\n+    mut is_less: F,\n+) -> (&mut [T], &mut T, &mut [T])\n+where\n+    F: FnMut(&T, &T) -> bool,\n+{\n+    if index >= v.len() {\n+        panic!(\"partition_at_index index {} greater than length of slice {}\", index, v.len());\n+    }\n+\n+    if T::IS_ZST {\n+        // Sorting has no meaningful behavior on zero-sized types. Do nothing.\n+    } else if index == v.len() - 1 {\n+        // Find max element and place it in the last position of the array. We're free to use\n+        // `unwrap()` here because we know v must not be empty.\n+        let (max_index, _) = v.iter().enumerate().max_by(from_is_less(&mut is_less)).unwrap();\n+        v.swap(max_index, index);\n+    } else if index == 0 {\n+        // Find min element and place it in the first position of the array. We're free to use\n+        // `unwrap()` here because we know v must not be empty.\n+        let (min_index, _) = v.iter().enumerate().min_by(from_is_less(&mut is_less)).unwrap();\n+        v.swap(min_index, index);\n+    } else {\n+        partition_at_index_loop(v, index, &mut is_less, None);\n+    }\n+\n+    let (left, right) = v.split_at_mut(index);\n+    let (pivot, right) = right.split_at_mut(1);\n+    let pivot = &mut pivot[0];\n+    (left, pivot, right)\n+}\n+\n+/// helper function used to find the index of the min/max element\n+/// using e.g. `slice.iter().enumerate().min_by(from_is_less(&mut is_less)).unwrap()`\n+fn from_is_less<T>(\n+    is_less: &mut impl FnMut(&T, &T) -> bool,\n+) -> impl FnMut(&(usize, &T), &(usize, &T)) -> cmp::Ordering + '_ {\n+    |&(_, x), &(_, y)| {\n+        if is_less(x, y) { cmp::Ordering::Less } else { cmp::Ordering::Greater }\n+    }\n+}\n+\n+/// Selection algorithm to select the k-th element from the slice in guaranteed O(n) time.\n+/// This is essentially a quickselect that uses Tukey's Ninther for pivot selection\n+fn median_of_medians<T, F: FnMut(&T, &T) -> bool>(mut v: &mut [T], is_less: &mut F, mut k: usize) {\n+    // Since this function isn't public, it should never be called with an out-of-bounds index.\n+    debug_assert!(k < v.len());\n+\n+    // If T is as ZST, `partition_at_index` will already return early.\n+    debug_assert!(!T::IS_ZST);\n+\n+    // We now know that `k < v.len() <= isize::MAX`\n+    loop {\n+        if v.len() <= MAX_INSERTION {\n+            if v.len() > 1 {\n+                insertion_sort_shift_left(v, 1, is_less);\n+            }\n+            return;\n+        }\n+\n+        // `median_of_{minima,maxima}` can't handle the extreme cases of the first/last element,\n+        // so we catch them here and just do a linear search.\n+        if k == v.len() - 1 {\n+            // Find max element and place it in the last position of the array. We're free to use\n+            // `unwrap()` here because we know v must not be empty.\n+            let (max_index, _) = v.iter().enumerate().max_by(from_is_less(is_less)).unwrap();\n+            v.swap(max_index, k);\n+            return;\n+        } else if k == 0 {\n+            // Find min element and place it in the first position of the array. We're free to use\n+            // `unwrap()` here because we know v must not be empty.\n+            let (min_index, _) = v.iter().enumerate().min_by(from_is_less(is_less)).unwrap();\n+            v.swap(min_index, k);\n+            return;\n+        }\n+\n+        let p = median_of_ninthers(v, is_less);\n+\n+        if p == k {\n+            return;\n+        } else if p > k {\n+            v = &mut v[..p];\n+        } else {\n+            // Since `p < k < v.len()`, `p + 1` doesn't overflow and is\n+            // a valid index into the slice.\n+            v = &mut v[p + 1..];\n+            k -= p + 1;\n+        }\n+    }\n+}\n+\n+// Optimized for when `k` lies somewhere in the middle of the slice. Selects a pivot\n+// as close as possible to the median of the slice. For more details on how the algorithm\n+// operates, refer to the paper <https://drops.dagstuhl.de/opus/volltexte/2017/7612/pdf/LIPIcs-SEA-2017-24.pdf>.\n+fn median_of_ninthers<T, F: FnMut(&T, &T) -> bool>(v: &mut [T], is_less: &mut F) -> usize {\n+    // use `saturating_mul` so the multiplication doesn't overflow on 16-bit platforms.\n+    let frac = if v.len() <= 1024 {\n+        v.len() / 12\n+    } else if v.len() <= 128_usize.saturating_mul(1024) {\n+        v.len() / 64\n+    } else {\n+        v.len() / 1024\n+    };\n+\n+    let pivot = frac / 2;\n+    let lo = v.len() / 2 - pivot;\n+    let hi = frac + lo;\n+    let gap = (v.len() - 9 * frac) / 4;\n+    let mut a = lo - 4 * frac - gap;\n+    let mut b = hi + gap;\n+    for i in lo..hi {\n+        ninther(v, is_less, a, i - frac, b, a + 1, i, b + 1, a + 2, i + frac, b + 2);\n+        a += 3;\n+        b += 3;\n+    }\n+\n+    median_of_medians(&mut v[lo..lo + frac], is_less, pivot);\n+    partition(v, lo + pivot, is_less).0\n+}\n+\n+/// Moves around the 9 elements at the indices a..i, such that\n+/// `v[d]` contains the median of the 9 elements and the other\n+/// elements are partitioned around it.\n+fn ninther<T, F: FnMut(&T, &T) -> bool>(\n+    v: &mut [T],\n+    is_less: &mut F,\n+    a: usize,\n+    mut b: usize,\n+    c: usize,\n+    mut d: usize,\n+    e: usize,\n+    mut f: usize,\n+    g: usize,\n+    mut h: usize,\n+    i: usize,\n+) {\n+    b = median_idx(v, is_less, a, b, c);\n+    h = median_idx(v, is_less, g, h, i);\n+    if is_less(&v[h], &v[b]) {\n+        mem::swap(&mut b, &mut h);\n+    }\n+    if is_less(&v[f], &v[d]) {\n+        mem::swap(&mut d, &mut f);\n+    }\n+    if is_less(&v[e], &v[d]) {\n+        // do nothing\n+    } else if is_less(&v[f], &v[e]) {\n+        d = f;\n+    } else {\n+        if is_less(&v[e], &v[b]) {\n+            v.swap(e, b);\n+        } else if is_less(&v[h], &v[e]) {\n+            v.swap(e, h);\n+        }\n+        return;\n+    }\n+    if is_less(&v[d], &v[b]) {\n+        d = b;\n+    } else if is_less(&v[h], &v[d]) {\n+        d = h;\n+    }\n+\n+    v.swap(d, e);\n+}\n+\n+/// returns the index pointing to the median of the 3\n+/// elements `v[a]`, `v[b]` and `v[c]`\n+fn median_idx<T, F: FnMut(&T, &T) -> bool>(\n+    v: &[T],\n+    is_less: &mut F,\n+    mut a: usize,\n+    b: usize,\n+    mut c: usize,\n+) -> usize {\n+    if is_less(&v[c], &v[a]) {\n+        mem::swap(&mut a, &mut c);\n+    }\n+    if is_less(&v[c], &v[b]) {\n+        return c;\n+    }\n+    if is_less(&v[b], &v[a]) {\n+        return a;\n+    }\n+    b\n+}"}, {"sha": "db76d26257aac8d7d416d1e25613c9e11c1b3351", "filename": "library/core/src/slice/sort.rs", "status": "modified", "additions": 5, "deletions": 137, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/3d11b655bd7264b2b66c299ac975c5050d40b220/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d11b655bd7264b2b66c299ac975c5050d40b220/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs?ref=3d11b655bd7264b2b66c299ac975c5050d40b220", "patch": "@@ -145,7 +145,7 @@ where\n /// Never inline this function to avoid code bloat. It still optimizes nicely and has practically no\n /// performance impact. Even improving performance in some cases.\n #[inline(never)]\n-fn insertion_sort_shift_left<T, F>(v: &mut [T], offset: usize, is_less: &mut F)\n+pub(super) fn insertion_sort_shift_left<T, F>(v: &mut [T], offset: usize, is_less: &mut F)\n where\n     F: FnMut(&T, &T) -> bool,\n {\n@@ -557,7 +557,7 @@ where\n ///\n /// 1. Number of elements smaller than `v[pivot]`.\n /// 2. True if `v` was already partitioned.\n-fn partition<T, F>(v: &mut [T], pivot: usize, is_less: &mut F) -> (usize, bool)\n+pub(super) fn partition<T, F>(v: &mut [T], pivot: usize, is_less: &mut F) -> (usize, bool)\n where\n     F: FnMut(&T, &T) -> bool,\n {\n@@ -612,7 +612,7 @@ where\n ///\n /// Returns the number of elements equal to the pivot. It is assumed that `v` does not contain\n /// elements smaller than the pivot.\n-fn partition_equal<T, F>(v: &mut [T], pivot: usize, is_less: &mut F) -> usize\n+pub(super) fn partition_equal<T, F>(v: &mut [T], pivot: usize, is_less: &mut F) -> usize\n where\n     F: FnMut(&T, &T) -> bool,\n {\n@@ -670,7 +670,7 @@ where\n /// Scatters some elements around in an attempt to break patterns that might cause imbalanced\n /// partitions in quicksort.\n #[cold]\n-fn break_patterns<T>(v: &mut [T]) {\n+pub(super) fn break_patterns<T>(v: &mut [T]) {\n     let len = v.len();\n     if len >= 8 {\n         let mut seed = len;\n@@ -719,7 +719,7 @@ fn break_patterns<T>(v: &mut [T]) {\n /// Chooses a pivot in `v` and returns the index and `true` if the slice is likely already sorted.\n ///\n /// Elements in `v` might be reordered in the process.\n-fn choose_pivot<T, F>(v: &mut [T], is_less: &mut F) -> (usize, bool)\n+pub(super) fn choose_pivot<T, F>(v: &mut [T], is_less: &mut F) -> (usize, bool)\n where\n     F: FnMut(&T, &T) -> bool,\n {\n@@ -897,138 +897,6 @@ where\n     recurse(v, &mut is_less, None, limit);\n }\n \n-fn partition_at_index_loop<'a, T, F>(\n-    mut v: &'a mut [T],\n-    mut index: usize,\n-    is_less: &mut F,\n-    mut pred: Option<&'a T>,\n-) where\n-    F: FnMut(&T, &T) -> bool,\n-{\n-    // Limit the amount of iterations and fall back to heapsort, similarly to `slice::sort_unstable`.\n-    // This lowers the worst case running time from O(n^2) to O(n log n).\n-    // FIXME: Investigate whether it would be better to use something like Median of Medians\n-    // or Fast Deterministic Selection to guarantee O(n) worst case.\n-    let mut limit = usize::BITS - v.len().leading_zeros();\n-\n-    // True if the last partitioning was reasonably balanced.\n-    let mut was_balanced = true;\n-\n-    loop {\n-        let len = v.len();\n-\n-        // For slices of up to this length it's probably faster to simply sort them.\n-        const MAX_INSERTION: usize = 10;\n-        if len <= MAX_INSERTION {\n-            if len >= 2 {\n-                insertion_sort_shift_left(v, 1, is_less);\n-            }\n-            return;\n-        }\n-\n-        if limit == 0 {\n-            heapsort(v, is_less);\n-            return;\n-        }\n-\n-        // If the last partitioning was imbalanced, try breaking patterns in the slice by shuffling\n-        // some elements around. Hopefully we'll choose a better pivot this time.\n-        if !was_balanced {\n-            break_patterns(v);\n-            limit -= 1;\n-        }\n-\n-        // Choose a pivot\n-        let (pivot, _) = choose_pivot(v, is_less);\n-\n-        // If the chosen pivot is equal to the predecessor, then it's the smallest element in the\n-        // slice. Partition the slice into elements equal to and elements greater than the pivot.\n-        // This case is usually hit when the slice contains many duplicate elements.\n-        if let Some(p) = pred {\n-            if !is_less(p, &v[pivot]) {\n-                let mid = partition_equal(v, pivot, is_less);\n-\n-                // If we've passed our index, then we're good.\n-                if mid > index {\n-                    return;\n-                }\n-\n-                // Otherwise, continue sorting elements greater than the pivot.\n-                v = &mut v[mid..];\n-                index = index - mid;\n-                pred = None;\n-                continue;\n-            }\n-        }\n-\n-        let (mid, _) = partition(v, pivot, is_less);\n-        was_balanced = cmp::min(mid, len - mid) >= len / 8;\n-\n-        // Split the slice into `left`, `pivot`, and `right`.\n-        let (left, right) = v.split_at_mut(mid);\n-        let (pivot, right) = right.split_at_mut(1);\n-        let pivot = &pivot[0];\n-\n-        if mid < index {\n-            v = right;\n-            index = index - mid - 1;\n-            pred = Some(pivot);\n-        } else if mid > index {\n-            v = left;\n-        } else {\n-            // If mid == index, then we're done, since partition() guaranteed that all elements\n-            // after mid are greater than or equal to mid.\n-            return;\n-        }\n-    }\n-}\n-\n-/// Reorder the slice such that the element at `index` is at its final sorted position.\n-pub fn partition_at_index<T, F>(\n-    v: &mut [T],\n-    index: usize,\n-    mut is_less: F,\n-) -> (&mut [T], &mut T, &mut [T])\n-where\n-    F: FnMut(&T, &T) -> bool,\n-{\n-    use cmp::Ordering::Greater;\n-    use cmp::Ordering::Less;\n-\n-    if index >= v.len() {\n-        panic!(\"partition_at_index index {} greater than length of slice {}\", index, v.len());\n-    }\n-\n-    if T::IS_ZST {\n-        // Sorting has no meaningful behavior on zero-sized types. Do nothing.\n-    } else if index == v.len() - 1 {\n-        // Find max element and place it in the last position of the array. We're free to use\n-        // `unwrap()` here because we know v must not be empty.\n-        let (max_index, _) = v\n-            .iter()\n-            .enumerate()\n-            .max_by(|&(_, x), &(_, y)| if is_less(x, y) { Less } else { Greater })\n-            .unwrap();\n-        v.swap(max_index, index);\n-    } else if index == 0 {\n-        // Find min element and place it in the first position of the array. We're free to use\n-        // `unwrap()` here because we know v must not be empty.\n-        let (min_index, _) = v\n-            .iter()\n-            .enumerate()\n-            .min_by(|&(_, x), &(_, y)| if is_less(x, y) { Less } else { Greater })\n-            .unwrap();\n-        v.swap(min_index, index);\n-    } else {\n-        partition_at_index_loop(v, index, &mut is_less, None);\n-    }\n-\n-    let (left, right) = v.split_at_mut(index);\n-    let (pivot, right) = right.split_at_mut(1);\n-    let pivot = &mut pivot[0];\n-    (left, pivot, right)\n-}\n-\n /// Merges non-decreasing runs `v[..mid]` and `v[mid..]` using `buf` as temporary storage, and\n /// stores the result into `v[..]`.\n ///"}]}