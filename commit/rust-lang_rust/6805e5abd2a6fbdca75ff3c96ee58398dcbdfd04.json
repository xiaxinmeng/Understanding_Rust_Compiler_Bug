{"sha": "6805e5abd2a6fbdca75ff3c96ee58398dcbdfd04", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4MDVlNWFiZDJhNmZiZGNhNzVmZjNjOTZlZTU4Mzk4ZGNiZGZkMDQ=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-04-24T20:56:57Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-04-25T10:26:47Z"}, "message": "Update comments to UFCS style", "tree": {"sha": "8564a87d912a670629b7f319a160d4053a88dbf5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8564a87d912a670629b7f319a160d4053a88dbf5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6805e5abd2a6fbdca75ff3c96ee58398dcbdfd04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6805e5abd2a6fbdca75ff3c96ee58398dcbdfd04", "html_url": "https://github.com/rust-lang/rust/commit/6805e5abd2a6fbdca75ff3c96ee58398dcbdfd04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6805e5abd2a6fbdca75ff3c96ee58398dcbdfd04/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98e3e82ecea8b3b2100362e6fa87dc76779855bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/98e3e82ecea8b3b2100362e6fa87dc76779855bc", "html_url": "https://github.com/rust-lang/rust/commit/98e3e82ecea8b3b2100362e6fa87dc76779855bc"}], "stats": {"total": 35, "additions": 24, "deletions": 11}, "files": [{"sha": "2b3930063f369028e9c23122ff398e1885d61c0a", "filename": "src/libsyntax_ext/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6805e5abd2a6fbdca75ff3c96ee58398dcbdfd04/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6805e5abd2a6fbdca75ff3c96ee58398dcbdfd04/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=6805e5abd2a6fbdca75ff3c96ee58398dcbdfd04", "patch": "@@ -14,7 +14,7 @@ use deriving::{path_local, pathvec_std, path_std};\n use deriving::generic::*;\n use deriving::generic::ty::*;\n \n-use syntax::ast::{self, BinOpKind, Expr, MetaItem, Ident};\n+use syntax::ast::{self, BinOpKind, Expr, MetaItem};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::ptr::P;\n@@ -231,32 +231,45 @@ fn cs_op(less: bool,\n             // `ast::lt`\n             //\n             // ```\n-            // self.f1.partial_cmp(other.f1).unwrap_or(Ordering::Equal)\n-            //     .then_with(|| self.f2.partial_cmp(other.f2).unwrap_or(Ordering::Equal))\n+            // Ordering::then_with(\n+            //    Option::unwrap_or(\n+            //        PartialOrd::partial_cmp(self.f1, other.f1), Ordering::Equal)\n+            //    ),\n+            //    Option::unwrap_or(\n+            //        PartialOrd::partial_cmp(self.f2, other.f2), Ordering::Greater)\n+            //    )\n+            // )\n             // == Ordering::Less\n             // ```\n             //\n             // and for op ==\n             // `ast::le`\n             //\n             // ```\n-            // self.f1.partial_cmp(other.f1).unwrap_or(Ordering::Equal)\n-            //     .then_with(|| self.f2.partial_cmp(other.f2).unwrap_or(Ordering::Equal))\n+            // Ordering::then_with(\n+            //    Option::unwrap_or(\n+            //        PartialOrd::partial_cmp(self.f1, other.f1), Ordering::Equal)\n+            //    ),\n+            //    Option::unwrap_or(\n+            //        PartialOrd::partial_cmp(self.f2, other.f2), Ordering::Greater)\n+            //    )\n+            // )\n             // != Ordering::Greater\n             // ```\n             //\n             // The optimiser should remove the redundancy. We explicitly\n             // get use the binops to avoid auto-deref dereferencing too many\n             // layers of pointers, if the type includes pointers.\n \n-            // `self.fi.partial_cmp(other.fi).unwrap_or(Ordering::Equal)`\n+            // `Option::unwrap_or(PartialOrd::partial_cmp(self.fi, other.fi), Ordering::Equal)`\n             let par_cmp = par_cmp(cx, span, self_f, other_fs, \"Equal\");\n \n-            // `self.fi.partial_cmp(other.fi).unwrap_or(Ordering::Equal).then_with(...)`\n-            cx.expr_method_call(span,\n-                                par_cmp,\n-                                Ident::from_str(\"then_with\"),\n-                                vec![cx.lambda0(span, subexpr)])\n+            // `Ordering::then_with(Option::unwrap_or(..), ..)`\n+            let then_with_path = cx.expr_path(cx.path_global(span,\n+                                                             cx.std_path(&[\"cmp\",\n+                                                                           \"Ordering\",\n+                                                                           \"then_with\"])));\n+            cx.expr_call(span, then_with_path, vec![par_cmp, cx.lambda0(span, subexpr)])\n         },\n         |cx, args| {\n             match args {"}]}