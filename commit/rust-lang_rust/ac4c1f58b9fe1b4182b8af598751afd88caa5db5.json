{"sha": "ac4c1f58b9fe1b4182b8af598751afd88caa5db5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjNGMxZjU4YjlmZTFiNDE4MmI4YWY1OTg3NTFhZmQ4OGNhYTVkYjU=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-11-13T21:05:05Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-11-13T21:35:56Z"}, "message": "rustc_resolve: Make `macro_rules` scope chain compression lazy", "tree": {"sha": "1399ffd0802b5a56cf31dbbbb6012056ded6a997", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1399ffd0802b5a56cf31dbbbb6012056ded6a997"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac4c1f58b9fe1b4182b8af598751afd88caa5db5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac4c1f58b9fe1b4182b8af598751afd88caa5db5", "html_url": "https://github.com/rust-lang/rust/commit/ac4c1f58b9fe1b4182b8af598751afd88caa5db5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac4c1f58b9fe1b4182b8af598751afd88caa5db5/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89bce3e9080a995c59149cc36962048cd9f56f63", "url": "https://api.github.com/repos/rust-lang/rust/commits/89bce3e9080a995c59149cc36962048cd9f56f63", "html_url": "https://github.com/rust-lang/rust/commit/89bce3e9080a995c59149cc36962048cd9f56f63"}], "stats": {"total": 57, "additions": 21, "deletions": 36}, "files": [{"sha": "493b9f15271ef8258fbf63f8846bdc75fb85690d", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac4c1f58b9fe1b4182b8af598751afd88caa5db5/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4c1f58b9fe1b4182b8af598751afd88caa5db5/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=ac4c1f58b9fe1b4182b8af598751afd88caa5db5", "patch": "@@ -1163,9 +1163,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         let old_parent_scope = self.r.invocation_parent_scopes.insert(invoc_id, self.parent_scope);\n         assert!(old_parent_scope.is_none(), \"invocation data is reset for an invocation\");\n \n-        let scope = self.r.arenas.alloc_macro_rules_scope(MacroRulesScope::Invocation(invoc_id));\n-        self.r.invocation_macro_rules_scopes.entry(invoc_id).or_default().insert(scope);\n-        scope\n+        self.r.arenas.alloc_macro_rules_scope(MacroRulesScope::Invocation(invoc_id))\n     }\n \n     fn proc_macro_stub(&self, item: &ast::Item) -> Option<(MacroKind, Ident, Span)> {"}, {"sha": "d18335ef2e63a205d755e3a85241d75a96a12461", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ac4c1f58b9fe1b4182b8af598751afd88caa5db5/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4c1f58b9fe1b4182b8af598751afd88caa5db5/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=ac4c1f58b9fe1b4182b8af598751afd88caa5db5", "patch": "@@ -976,9 +976,6 @@ pub struct Resolver<'a> {\n     /// `macro_rules` scopes *produced* by expanding the macro invocations,\n     /// include all the `macro_rules` items and other invocations generated by them.\n     output_macro_rules_scopes: FxHashMap<ExpnId, MacroRulesScopeRef<'a>>,\n-    /// References to all `MacroRulesScope::Invocation(invoc_id)`s, used to update such scopes\n-    /// when their corresponding `invoc_id`s get expanded.\n-    invocation_macro_rules_scopes: FxHashMap<ExpnId, FxHashSet<MacroRulesScopeRef<'a>>>,\n     /// Helper attributes that are in scope for the given expansion.\n     helper_attrs: FxHashMap<ExpnId, Vec<Ident>>,\n \n@@ -1310,7 +1307,6 @@ impl<'a> Resolver<'a> {\n             non_macro_attrs: [non_macro_attr(false), non_macro_attr(true)],\n             invocation_parent_scopes: Default::default(),\n             output_macro_rules_scopes: Default::default(),\n-            invocation_macro_rules_scopes: Default::default(),\n             helper_attrs: Default::default(),\n             local_macro_def_scopes: FxHashMap::default(),\n             name_already_seen: FxHashMap::default(),\n@@ -1680,7 +1676,20 @@ impl<'a> Resolver<'a> {\n                     !(expn_id == parent_scope.expansion && macro_kind == Some(MacroKind::Derive))\n                 }\n                 Scope::DeriveHelpersCompat => true,\n-                Scope::MacroRules(..) => true,\n+                Scope::MacroRules(macro_rules_scope) => {\n+                    // Use \"path compression\" on `macro_rules` scope chains. This is an optimization\n+                    // used to avoid long scope chains, see the comments on `MacroRulesScopeRef`.\n+                    // As another consequence of this optimization visitors never observe invocation\n+                    // scopes for macros that were already expanded.\n+                    while let MacroRulesScope::Invocation(invoc_id) = macro_rules_scope.get() {\n+                        if let Some(next_scope) = self.output_macro_rules_scopes.get(&invoc_id) {\n+                            macro_rules_scope.set(next_scope.get());\n+                        } else {\n+                            break;\n+                        }\n+                    }\n+                    true\n+                }\n                 Scope::CrateRoot => true,\n                 Scope::Module(..) => true,\n                 Scope::RegisteredAttrs => use_prelude,\n@@ -1716,11 +1725,9 @@ impl<'a> Resolver<'a> {\n                     MacroRulesScope::Binding(binding) => {\n                         Scope::MacroRules(binding.parent_macro_rules_scope)\n                     }\n-                    MacroRulesScope::Invocation(invoc_id) => Scope::MacroRules(\n-                        self.output_macro_rules_scopes.get(&invoc_id).cloned().unwrap_or_else(\n-                            || self.invocation_parent_scopes[&invoc_id].macro_rules,\n-                        ),\n-                    ),\n+                    MacroRulesScope::Invocation(invoc_id) => {\n+                        Scope::MacroRules(self.invocation_parent_scopes[&invoc_id].macro_rules)\n+                    }\n                     MacroRulesScope::Empty => Scope::Module(module),\n                 },\n                 Scope::CrateRoot => match ns {"}, {"sha": "e052b6b334529c036ee4ba29e5f443f96abe4023", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 3, "deletions": 23, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ac4c1f58b9fe1b4182b8af598751afd88caa5db5/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4c1f58b9fe1b4182b8af598751afd88caa5db5/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=ac4c1f58b9fe1b4182b8af598751afd88caa5db5", "patch": "@@ -62,8 +62,8 @@ pub enum MacroRulesScope<'a> {\n }\n \n /// `macro_rules!` scopes are always kept by reference and inside a cell.\n-/// The reason is that we update all scopes with value `MacroRulesScope::Invocation(invoc_id)`\n-/// in-place immediately after `invoc_id` gets expanded.\n+/// The reason is that we update scopes with value `MacroRulesScope::Invocation(invoc_id)`\n+/// in-place after `invoc_id` gets expanded.\n /// This helps to avoid uncontrollable growth of `macro_rules!` scope chains,\n /// which usually grow lineraly with the number of macro invocations\n /// in a module (including derives) and hurt performance.\n@@ -173,22 +173,6 @@ impl<'a> ResolverExpand for Resolver<'a> {\n         let output_macro_rules_scope = self.build_reduced_graph(fragment, parent_scope);\n         self.output_macro_rules_scopes.insert(expansion, output_macro_rules_scope);\n \n-        // Update all `macro_rules` scopes referring to this invocation. This is an optimization\n-        // used to avoid long scope chains, see the comments on `MacroRulesScopeRef`.\n-        if let Some(invocation_scopes) = self.invocation_macro_rules_scopes.remove(&expansion) {\n-            for invocation_scope in &invocation_scopes {\n-                invocation_scope.set(output_macro_rules_scope.get());\n-            }\n-            // All `macro_rules` scopes that previously referred to `expansion`\n-            // are now rerouted to its output scope, if it's also an invocation.\n-            if let MacroRulesScope::Invocation(invoc_id) = output_macro_rules_scope.get() {\n-                self.invocation_macro_rules_scopes\n-                    .entry(invoc_id)\n-                    .or_default()\n-                    .extend(invocation_scopes);\n-            }\n-        }\n-\n         parent_scope.module.unexpanded_invocations.borrow_mut().remove(&expansion);\n     }\n \n@@ -687,11 +671,7 @@ impl<'a> Resolver<'a> {\n                         {\n                             Ok((macro_rules_binding.binding, Flags::MACRO_RULES))\n                         }\n-                        MacroRulesScope::Invocation(invoc_id)\n-                            if !this.output_macro_rules_scopes.contains_key(&invoc_id) =>\n-                        {\n-                            Err(Determinacy::Undetermined)\n-                        }\n+                        MacroRulesScope::Invocation(_) => Err(Determinacy::Undetermined),\n                         _ => Err(Determinacy::Determined),\n                     },\n                     Scope::CrateRoot => {"}]}