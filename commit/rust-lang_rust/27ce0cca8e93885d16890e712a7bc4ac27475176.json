{"sha": "27ce0cca8e93885d16890e712a7bc4ac27475176", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3Y2UwY2NhOGU5Mzg4NWQxNjg5MGU3MTJhN2JjNGFjMjc0NzUxNzY=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-06-20T20:34:34Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-07-01T15:14:21Z"}, "message": "Moved region inference error reporting into own module.", "tree": {"sha": "e9a970eec983df4a827d3802b37c60b1fd11df71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9a970eec983df4a827d3802b37c60b1fd11df71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27ce0cca8e93885d16890e712a7bc4ac27475176", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEWwgxPGhT5b/6kagXAXYLT59T8VQFAls4780ACgkQAXYLT59T\n8VT8HA/+MAgxfwZp/d2giCklNU9vyidkccHh/eXiFNVNf4tnksIpvr6UezAF0UWg\nQVJQ2tPOhTcH1gtMVC3hV3g2EF1nPlDtx2lr36Lrcnjm5TJCZaOJKzZ+RXG1eTAD\nkDRl7U56dhUwUi6KRiFcAQmTh4eAIK3xHranujEMLOQ9+Vz6NOvKih0jc0QdpMS5\na6CoERhIl36jrv2NcyxbFS7PayMRQQt3uF3ppMmAGEZqRL2oV0NiTwW24aMfRSWz\n6E6j0uKcdcFsq/0Nhz6X2i27DXnRznbpWIuL703W9Lu5qLv9jqIxXuwGXM3ob3uP\nFASSdVVSoTCPP0x2xYxPuvbo+TE0wSiI4u0GOOLhQK9b9Js1WUAOGIm+trR9U6g4\nawLCPx8L+/oipCi4/yclH/ofYg4MwmNJ7UxkC6aS+jOC2gmCqnL2ffbLPH0DklsN\nqThuCqjVCa1zVOirFMRixa1mEMr8v62KqL7hKXEtfS/xRfg5B4D5uII/6ChXKiXd\nrDnqhRoXUxykkvAzY4HzH0Nnc9vgY54udU8/BJiGdsZf98UE+0tXUuRFFpHqd4GP\nuKty3DuRZ+UcZV/GEyMS2MUDZL4WfKZ0BWQXJHwZRTPvxlOnlCF9NUIikmve7i25\n9Dh3LKzV4tmKR+YR2qRQBFiUTlM2rI1Kj3ibJvZhZW6UFGlR13A=\n=QGth\n-----END PGP SIGNATURE-----", "payload": "tree e9a970eec983df4a827d3802b37c60b1fd11df71\nparent 58a723209d170634ecc4f9be02e9bc3659541125\nauthor David Wood <david@davidtw.co> 1529526874 +0100\ncommitter David Wood <david@davidtw.co> 1530458061 +0100\n\nMoved region inference error reporting into own module.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27ce0cca8e93885d16890e712a7bc4ac27475176", "html_url": "https://github.com/rust-lang/rust/commit/27ce0cca8e93885d16890e712a7bc4ac27475176", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27ce0cca8e93885d16890e712a7bc4ac27475176/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58a723209d170634ecc4f9be02e9bc3659541125", "url": "https://api.github.com/repos/rust-lang/rust/commits/58a723209d170634ecc4f9be02e9bc3659541125", "html_url": "https://github.com/rust-lang/rust/commit/58a723209d170634ecc4f9be02e9bc3659541125"}], "stats": {"total": 636, "additions": 328, "deletions": 308}, "files": [{"sha": "3bdf78ff3db54dc323ee1c178d22689ae887d464", "filename": "src/librustc_mir/borrow_check/nll/constraint_set.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/27ce0cca8e93885d16890e712a7bc4ac27475176/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27ce0cca8e93885d16890e712a7bc4ac27475176/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_set.rs?ref=27ce0cca8e93885d16890e712a7bc4ac27475176", "patch": "@@ -109,14 +109,4 @@ impl fmt::Debug for OutlivesConstraint {\n     }\n }\n \n-/// Constraints that are considered interesting can be categorized to\n-/// determine why they are interesting.\n-#[derive(Debug, Eq, PartialEq, Ord, PartialOrd)]\n-crate enum ConstraintCategory {\n-    Assignment,\n-    CallArgument,\n-    Cast,\n-    Other,\n-}\n-\n newtype_index!(ConstraintIndex { DEBUG_FORMAT = \"ConstraintIndex({})\" });"}, {"sha": "261bc31b6f60600b27c4b6e3c944f8d4bc88b11f", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting.rs", "status": "added", "additions": 324, "deletions": 0, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/27ce0cca8e93885d16890e712a7bc4ac27475176/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27ce0cca8e93885d16890e712a7bc4ac27475176/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting.rs?ref=27ce0cca8e93885d16890e712a7bc4ac27475176", "patch": "@@ -0,0 +1,324 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use borrow_check::nll::region_infer::{Cause, ConstraintIndex, RegionInferenceContext};\n+use borrow_check::nll::region_infer::values::ToElementIndex;\n+use borrow_check::nll::type_check::Locations;\n+use rustc::hir::def_id::DefId;\n+use rustc::infer::InferCtxt;\n+use rustc::infer::error_reporting::nice_region_error::NiceRegionError;\n+use rustc::mir::{Location, Mir, StatementKind, TerminatorKind, Rvalue};\n+use rustc::ty::RegionVid;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::indexed_vec::IndexVec;\n+use syntax_pos::Span;\n+\n+/// Constraints that are considered interesting can be categorized to\n+/// determine why they are interesting.\n+#[derive(Debug, Eq, PartialEq, PartialOrd, Ord)]\n+enum ConstraintCategory {\n+    Assignment,\n+    Cast,\n+    CallArgument,\n+    Other,\n+}\n+\n+impl<'tcx> RegionInferenceContext<'tcx> {\n+    /// When reporting an error, it is useful to be able to determine which constraints influenced\n+    /// the region being reported as an error. This function finds all of the paths from the\n+    /// constraint.\n+    fn find_constraint_paths_from_region(\n+        &self,\n+        r0: RegionVid\n+    ) -> Vec<Vec<ConstraintIndex>> {\n+        let constraints = self.constraints.clone();\n+\n+        // Mapping of regions to the previous region and constraint index that led to it.\n+        let mut previous = FxHashMap();\n+        // Regions yet to be visited.\n+        let mut next = vec! [ r0 ];\n+        // Regions that have been visited.\n+        let mut visited = FxHashSet();\n+        // Ends of paths.\n+        let mut end_regions: Vec<RegionVid> = Vec::new();\n+\n+        // When we've still got points to visit...\n+        while let Some(current) = next.pop() {\n+            // ...take the next point...\n+            debug!(\"find_constraint_paths_from_region: current={:?} next={:?}\", current, next);\n+\n+            // ...find the edges containing it...\n+            let mut upcoming = Vec::new();\n+            for (index, constraint) in constraints.iter_enumerated() {\n+                if constraint.sub == current {\n+                    // ...add the regions that join us with to the path we've taken...\n+                    debug!(\"find_constraint_paths_from_region: index={:?} constraint={:?}\",\n+                           index, constraint);\n+                    let next_region = constraint.sup.clone();\n+\n+                    // ...unless we've visited it since this was added...\n+                    if visited.contains(&next_region) {\n+                        debug!(\"find_constraint_paths_from_region: skipping as visited\");\n+                        continue;\n+                    }\n+\n+                    previous.insert(next_region, (index, Some(current)));\n+                    upcoming.push(next_region);\n+                }\n+            }\n+\n+            if upcoming.is_empty() {\n+                // If we didn't find any edges then this is the end of a path...\n+                debug!(\"find_constraint_paths_from_region: new end region current={:?}\", current);\n+                end_regions.push(current);\n+            } else {\n+                // ...but, if we did find edges, then add these to the regions yet to visit...\n+                debug!(\"find_constraint_paths_from_region: extend next upcoming={:?}\", upcoming);\n+                next.extend(upcoming);\n+            }\n+\n+            // ...and don't visit it again.\n+            visited.insert(current.clone());\n+            debug!(\"find_constraint_paths_from_region: next={:?} visited={:?}\", next, visited);\n+        }\n+\n+        // Now we've visited each point, compute the final paths.\n+        let mut paths: Vec<Vec<ConstraintIndex>> = Vec::new();\n+        debug!(\"find_constraint_paths_from_region: end_regions={:?}\", end_regions);\n+        for end_region in end_regions {\n+            debug!(\"find_constraint_paths_from_region: end_region={:?}\", end_region);\n+\n+            // Get the constraint and region that led to this end point.\n+            // We can unwrap as we know if end_point was in the vector that it\n+            // must also be in our previous map.\n+            let (mut index, mut region) = previous.get(&end_region).unwrap();\n+            debug!(\"find_constraint_paths_from_region: index={:?} region={:?}\", index, region);\n+\n+            // Keep track of the indices.\n+            let mut path: Vec<ConstraintIndex> = vec![index];\n+\n+            while region.is_some() && region != Some(r0) {\n+                let p = previous.get(&region.unwrap()).unwrap();\n+                index = p.0;\n+                region = p.1;\n+\n+                debug!(\"find_constraint_paths_from_region: index={:?} region={:?}\", index, region);\n+                path.push(index);\n+            }\n+\n+            // Add to our paths.\n+            paths.push(path);\n+        }\n+\n+        debug!(\"find_constraint_paths_from_region: paths={:?}\", paths);\n+        paths\n+    }\n+\n+    /// This function will return true if a constraint is interesting and false if a constraint\n+    /// is not. It is useful in filtering constraint paths to only interesting points.\n+    fn constraint_is_interesting(&self, index: &ConstraintIndex) -> bool {\n+        self.constraints.get(*index).filter(|constraint| {\n+            debug!(\"constraint_is_interesting: locations={:?} constraint={:?}\",\n+                   constraint.locations, constraint);\n+            if let Locations::Interesting(_) = constraint.locations { true } else { false }\n+        }).is_some()\n+    }\n+\n+    /// This function classifies a constraint from a location.\n+    fn classify_constraint(&self, location: Location, mir: &Mir<'tcx>) -> ConstraintCategory {\n+        let data = &mir[location.block];\n+        if location.statement_index == data.statements.len() {\n+            if let Some(ref terminator) = data.terminator {\n+                match terminator.kind {\n+                    TerminatorKind::DropAndReplace { .. } => ConstraintCategory::Assignment,\n+                    TerminatorKind::Call { .. } => ConstraintCategory::CallArgument,\n+                    _ => ConstraintCategory::Other,\n+                }\n+            } else {\n+                ConstraintCategory::Other\n+            }\n+        } else {\n+            let statement = &data.statements[location.statement_index];\n+            match statement.kind {\n+                StatementKind::Assign(_, ref rvalue) => match rvalue {\n+                    Rvalue::Cast(..) => ConstraintCategory::Cast,\n+                    Rvalue::Use(..) => ConstraintCategory::Assignment,\n+                    _ => ConstraintCategory::Other,\n+                },\n+                _ => ConstraintCategory::Other,\n+            }\n+        }\n+    }\n+\n+    /// Report an error because the universal region `fr` was required to outlive\n+    /// `outlived_fr` but it is not known to do so. For example:\n+    ///\n+    /// ```\n+    /// fn foo<'a, 'b>(x: &'a u32) -> &'b u32 { x }\n+    /// ```\n+    ///\n+    /// Here we would be invoked with `fr = 'a` and `outlived_fr = `'b`.\n+    pub(super) fn report_error(\n+        &self,\n+        mir: &Mir<'tcx>,\n+        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        mir_def_id: DefId,\n+        fr: RegionVid,\n+        outlived_fr: RegionVid,\n+        blame_span: Span,\n+    ) {\n+        // Obviously uncool error reporting.\n+\n+        let fr_name = self.to_error_region(fr);\n+        let outlived_fr_name = self.to_error_region(outlived_fr);\n+\n+        if let (Some(f), Some(o)) = (fr_name, outlived_fr_name) {\n+            let tables = infcx.tcx.typeck_tables_of(mir_def_id);\n+            let nice = NiceRegionError::new_from_span(infcx.tcx, blame_span, o, f, Some(tables));\n+            if let Some(_error_reported) = nice.try_report() {\n+                return;\n+            }\n+        }\n+\n+        let constraints = self.find_constraint_paths_from_region(fr.clone());\n+        let path = constraints.iter().min_by_key(|p| p.len()).unwrap();\n+        debug!(\"report_error: path={:?}\", path);\n+\n+        let path = path.iter()\n+            .filter(|index| self.constraint_is_interesting(index))\n+            .collect::<Vec<&ConstraintIndex>>();\n+        debug!(\"report_error: path={:?}\", path);\n+\n+        let mut categorized_path = path.iter().filter_map(|index| {\n+            self.constraints.get(**index).iter().filter_map(|constraint| {\n+                let span = constraint.locations.span(mir);\n+                constraint.locations.from_location().iter().filter_map(|location| {\n+                    let classification = self.classify_constraint(*location, mir);\n+                    Some((classification, span))\n+                }).next()\n+            }).next()\n+        }).collect::<Vec<(ConstraintCategory, Span)>>();\n+        debug!(\"report_error: categorized_path={:?}\", categorized_path);\n+\n+        categorized_path.sort_by(|p0, p1| p0.0.cmp(&p1.0));\n+        debug!(\"report_error: sorted_path={:?}\", categorized_path);\n+\n+        if categorized_path.len() > 0 {\n+            let blame_constraint = &categorized_path[0];\n+\n+            let mut diag = infcx.tcx.sess.struct_span_err(\n+                blame_constraint.1,\n+                &format!(\"{:?}\", blame_constraint.0),\n+            );\n+\n+            for secondary in categorized_path.iter().skip(1) {\n+                diag.span_label(secondary.1, format!(\"{:?}\", secondary.0));\n+            }\n+\n+            diag.emit();\n+        } else {\n+            let fr_string = match fr_name {\n+                Some(r) => format!(\"free region `{}`\", r),\n+                None => format!(\"free region `{:?}`\", fr),\n+            };\n+\n+            let outlived_fr_string = match outlived_fr_name {\n+                Some(r) => format!(\"free region `{}`\", r),\n+                None => format!(\"free region `{:?}`\", outlived_fr),\n+            };\n+\n+            let mut diag = infcx.tcx.sess.struct_span_err(\n+                blame_span,\n+                &format!(\"{} does not outlive {}\", fr_string, outlived_fr_string,),\n+            );\n+\n+            diag.emit();\n+        }\n+    }\n+\n+    crate fn why_region_contains_point(&self, fr1: RegionVid, elem: Location) -> Option<Cause> {\n+        // Find some constraint `X: Y` where:\n+        // - `fr1: X` transitively\n+        // - and `Y` is live at `elem`\n+        let index = self.blame_constraint(fr1, elem);\n+        let region_sub = self.constraints[index].sub;\n+\n+        // then return why `Y` was live at `elem`\n+        self.liveness_constraints.cause(region_sub, elem)\n+    }\n+\n+    /// Tries to finds a good span to blame for the fact that `fr1`\n+    /// contains `fr2`.\n+    pub(super) fn blame_constraint(&self, fr1: RegionVid,\n+                                   elem: impl ToElementIndex) -> ConstraintIndex {\n+        // Find everything that influenced final value of `fr`.\n+        let influenced_fr1 = self.dependencies(fr1);\n+\n+        // Try to find some outlives constraint `'X: fr2` where `'X`\n+        // influenced `fr1`. Blame that.\n+        //\n+        // NB, this is a pretty bad choice most of the time. In\n+        // particular, the connection between `'X` and `fr1` may not\n+        // be obvious to the user -- not to mention the naive notion\n+        // of dependencies, which doesn't account for the locations of\n+        // contraints at all. But it will do for now.\n+        let relevant_constraint = self.constraints\n+            .iter_enumerated()\n+            .filter_map(|(i, constraint)| {\n+                if !self.liveness_constraints.contains(constraint.sub, elem) {\n+                    None\n+                } else {\n+                    influenced_fr1[constraint.sup]\n+                        .map(|distance| (distance, i))\n+                }\n+            })\n+            .min() // constraining fr1 with fewer hops *ought* to be more obvious\n+            .map(|(_dist, i)| i);\n+\n+        relevant_constraint.unwrap_or_else(|| {\n+            bug!(\n+                \"could not find any constraint to blame for {:?}: {:?}\",\n+                fr1,\n+                elem,\n+            );\n+        })\n+    }\n+\n+    /// Finds all regions whose values `'a` may depend on in some way.\n+    /// For each region, returns either `None` (does not influence\n+    /// `'a`) or `Some(d)` which indicates that it influences `'a`\n+    /// with distinct `d` (minimum number of edges that must be\n+    /// traversed).\n+    ///\n+    /// Used during error reporting, extremely naive and inefficient.\n+    fn dependencies(&self, r0: RegionVid) -> IndexVec<RegionVid, Option<usize>> {\n+        let mut result_set = IndexVec::from_elem(None, &self.definitions);\n+        let mut changed = true;\n+        result_set[r0] = Some(0); // distance 0 from `r0`\n+\n+        while changed {\n+            changed = false;\n+            for constraint in &*self.constraints {\n+                if let Some(n) = result_set[constraint.sup] {\n+                    let m = n + 1;\n+                    if result_set[constraint.sub]\n+                        .map(|distance| m < distance)\n+                        .unwrap_or(true)\n+                    {\n+                        result_set[constraint.sub] = Some(m);\n+                        changed = true;\n+                    }\n+                }\n+            }\n+        }\n+\n+        result_set\n+    }\n+}"}, {"sha": "09e425ff55508c7c7179badce5f2849499f86c22", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 4, "deletions": 298, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/27ce0cca8e93885d16890e712a7bc4ac27475176/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27ce0cca8e93885d16890e712a7bc4ac27475176/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=27ce0cca8e93885d16890e712a7bc4ac27475176", "patch": "@@ -9,32 +9,28 @@\n // except according to those terms.\n \n use super::universal_regions::UniversalRegions;\n-use borrow_check::nll::region_infer::values::ToElementIndex;\n-use borrow_check::nll::constraint_set::{ConstraintIndex, ConstraintCategory, ConstraintSet};\n-use borrow_check::nll::constraint_set::{OutlivesConstraint};\n+use borrow_check::nll::constraint_set::{ConstraintIndex, ConstraintSet, OutlivesConstraint};\n use borrow_check::nll::type_check::Locations;\n use rustc::hir::def_id::DefId;\n use rustc::infer::canonical::QueryRegionConstraint;\n-use rustc::infer::error_reporting::nice_region_error::NiceRegionError;\n use rustc::infer::region_constraints::{GenericKind, VarInfos};\n use rustc::infer::InferCtxt;\n use rustc::infer::NLLRegionVariableOrigin;\n use rustc::infer::RegionVariableOrigin;\n use rustc::mir::{\n     ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements, Local, Location,\n-    Mir, StatementKind, TerminatorKind, Rvalue\n+    Mir\n };\n use rustc::ty::{self, RegionVid, Ty, TyCtxt, TypeFoldable};\n-use rustc::util::common::{self, ErrorReported};\n+use rustc::util::common;\n use rustc_data_structures::bitvec::BitVector;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n \n use std::rc::Rc;\n-use syntax_pos::Span;\n \n mod annotation;\n mod dump_mir;\n+mod error_reporting;\n mod graphviz;\n mod values;\n use self::values::{RegionValueElements, RegionValues};\n@@ -966,296 +962,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             self.report_error(mir, infcx, mir_def_id, longer_fr, shorter_fr, blame_span);\n         }\n     }\n-\n-    /// When reporting an error, it is useful to be able to determine which constraints influenced\n-    /// the region being reported as an error. This function finds all of the paths from the\n-    /// constraint.\n-    fn find_constraint_paths_from_region(\n-        &self,\n-        r0: RegionVid\n-    ) -> Vec<Vec<ConstraintIndex>> {\n-        let constraints = self.constraints.clone();\n-\n-        // Mapping of regions to the previous region and constraint index that led to it.\n-        let mut previous = FxHashMap();\n-        // Regions yet to be visited.\n-        let mut next = vec! [ r0 ];\n-        // Regions that have been visited.\n-        let mut visited = FxHashSet();\n-        // Ends of paths.\n-        let mut end_regions: Vec<RegionVid> = Vec::new();\n-\n-        // When we've still got points to visit...\n-        while let Some(current) = next.pop() {\n-            // ...take the next point...\n-            debug!(\"find_constraint_paths_from_region: current={:?} next={:?}\", current, next);\n-\n-            // ...find the edges containing it...\n-            let mut upcoming = Vec::new();\n-            for (index, constraint) in constraints.iter_enumerated() {\n-                if constraint.sub == current {\n-                    // ...add the regions that join us with to the path we've taken...\n-                    debug!(\"find_constraint_paths_from_region: index={:?} constraint={:?}\",\n-                           index, constraint);\n-                    let next_region = constraint.sup.clone();\n-\n-                    // ...unless we've visited it since this was added...\n-                    if visited.contains(&next_region) {\n-                        debug!(\"find_constraint_paths_from_region: skipping as visited\");\n-                        continue;\n-                    }\n-\n-                    previous.insert(next_region, (index, Some(current)));\n-                    upcoming.push(next_region);\n-                }\n-            }\n-\n-            if upcoming.is_empty() {\n-                // If we didn't find any edges then this is the end of a path...\n-                debug!(\"find_constraint_paths_from_region: new end region current={:?}\", current);\n-                end_regions.push(current);\n-            } else {\n-                // ...but, if we did find edges, then add these to the regions yet to visit...\n-                debug!(\"find_constraint_paths_from_region: extend next upcoming={:?}\", upcoming);\n-                next.extend(upcoming);\n-            }\n-\n-            // ...and don't visit it again.\n-            visited.insert(current.clone());\n-            debug!(\"find_constraint_paths_from_region: next={:?} visited={:?}\", next, visited);\n-        }\n-\n-        // Now we've visited each point, compute the final paths.\n-        let mut paths: Vec<Vec<ConstraintIndex>> = Vec::new();\n-        debug!(\"find_constraint_paths_from_region: end_regions={:?}\", end_regions);\n-        for end_region in end_regions {\n-            debug!(\"find_constraint_paths_from_region: end_region={:?}\", end_region);\n-\n-            // Get the constraint and region that led to this end point.\n-            // We can unwrap as we know if end_point was in the vector that it\n-            // must also be in our previous map.\n-            let (mut index, mut region) = previous.get(&end_region).unwrap();\n-            debug!(\"find_constraint_paths_from_region: index={:?} region={:?}\", index, region);\n-\n-            // Keep track of the indices.\n-            let mut path: Vec<ConstraintIndex> = vec![index];\n-\n-            while region.is_some() && region != Some(r0) {\n-                let p = previous.get(&region.unwrap()).unwrap();\n-                index = p.0;\n-                region = p.1;\n-\n-                debug!(\"find_constraint_paths_from_region: index={:?} region={:?}\", index, region);\n-                path.push(index);\n-            }\n-\n-            // Add to our paths.\n-            paths.push(path);\n-        }\n-\n-        debug!(\"find_constraint_paths_from_region: paths={:?}\", paths);\n-        paths\n-    }\n-\n-    /// This function will return true if a constraint is interesting and false if a constraint\n-    /// is not. It is useful in filtering constraint paths to only interesting points.\n-    fn constraint_is_interesting(&self, index: &ConstraintIndex) -> bool {\n-        self.constraints.get(*index).filter(|constraint| {\n-            debug!(\"constraint_is_interesting: locations={:?} constraint={:?}\",\n-                   constraint.locations, constraint);\n-            if let Locations::Interesting(_) = constraint.locations { true } else { false }\n-        }).is_some()\n-    }\n-\n-    /// This function classifies a constraint from a location.\n-    fn classify_constraint(&self, location: Location, mir: &Mir<'tcx>) -> ConstraintCategory {\n-        let data = &mir[location.block];\n-        if location.statement_index == data.statements.len() {\n-            if let Some(ref terminator) = data.terminator {\n-                match terminator.kind {\n-                    TerminatorKind::DropAndReplace { .. } => ConstraintCategory::Assignment,\n-                    TerminatorKind::Call { .. } => ConstraintCategory::CallArgument,\n-                    _ => ConstraintCategory::Other,\n-                }\n-            } else {\n-                ConstraintCategory::Other\n-            }\n-        } else {\n-            let statement = &data.statements[location.statement_index];\n-            match statement.kind {\n-                StatementKind::Assign(_, ref rvalue) => match rvalue {\n-                    Rvalue::Cast(..) => ConstraintCategory::Cast,\n-                    Rvalue::Use(..) => ConstraintCategory::Assignment,\n-                    _ => ConstraintCategory::Other,\n-                },\n-                _ => ConstraintCategory::Other,\n-            }\n-        }\n-    }\n-\n-    /// Report an error because the universal region `fr` was required to outlive\n-    /// `outlived_fr` but it is not known to do so. For example:\n-    ///\n-    /// ```\n-    /// fn foo<'a, 'b>(x: &'a u32) -> &'b u32 { x }\n-    /// ```\n-    ///\n-    /// Here we would be invoked with `fr = 'a` and `outlived_fr = `'b`.\n-    fn report_error(\n-        &self,\n-        mir: &Mir<'tcx>,\n-        infcx: &InferCtxt<'_, '_, 'tcx>,\n-        mir_def_id: DefId,\n-        fr: RegionVid,\n-        outlived_fr: RegionVid,\n-        blame_span: Span,\n-    ) {\n-        // Obviously uncool error reporting.\n-\n-        let fr_name = self.to_error_region(fr);\n-        let outlived_fr_name = self.to_error_region(outlived_fr);\n-\n-        if let (Some(f), Some(o)) = (fr_name, outlived_fr_name) {\n-            let tables = infcx.tcx.typeck_tables_of(mir_def_id);\n-            let nice = NiceRegionError::new_from_span(infcx.tcx, blame_span, o, f, Some(tables));\n-            if let Some(ErrorReported) = nice.try_report() {\n-                return;\n-            }\n-        }\n-\n-        let constraints = self.find_constraint_paths_from_region(fr.clone());\n-        let path = constraints.iter().min_by_key(|p| p.len()).unwrap();\n-        debug!(\"report_error: path={:?}\", path);\n-\n-        let path = path.iter()\n-            .filter(|index| self.constraint_is_interesting(index))\n-            .collect::<Vec<&ConstraintIndex>>();\n-        debug!(\"report_error: path={:?}\", path);\n-\n-        let mut categorized_path = path.iter().filter_map(|index| {\n-            self.constraints.get(**index).iter().filter_map(|constraint| {\n-                let span = constraint.locations.span(mir);\n-                constraint.locations.from_location().iter().filter_map(|location| {\n-                    let classification = self.classify_constraint(*location, mir);\n-                    Some((classification, span))\n-                }).next()\n-            }).next()\n-        }).collect::<Vec<(ConstraintCategory, Span)>>();\n-        debug!(\"report_error: categorized_path={:?}\", categorized_path);\n-\n-        categorized_path.sort_by(|p0, p1| p0.0.cmp(&p1.0));\n-        debug!(\"report_error: sorted_path={:?}\", categorized_path);\n-\n-        if categorized_path.len() > 0 {\n-            let blame_constraint = &categorized_path[0];\n-\n-            let mut diag = infcx.tcx.sess.struct_span_err(\n-                blame_constraint.1,\n-                &format!(\"{:?}\", blame_constraint.0),\n-            );\n-\n-            for secondary in categorized_path.iter().skip(1) {\n-                diag.span_label(secondary.1, format!(\"{:?}\", secondary.0));\n-            }\n-\n-            diag.emit();\n-        } else {\n-            let fr_string = match fr_name {\n-                Some(r) => format!(\"free region `{}`\", r),\n-                None => format!(\"free region `{:?}`\", fr),\n-            };\n-\n-            let outlived_fr_string = match outlived_fr_name {\n-                Some(r) => format!(\"free region `{}`\", r),\n-                None => format!(\"free region `{:?}`\", outlived_fr),\n-            };\n-\n-            let mut diag = infcx.tcx.sess.struct_span_err(\n-                blame_span,\n-                &format!(\"{} does not outlive {}\", fr_string, outlived_fr_string,),\n-            );\n-\n-            diag.emit();\n-        }\n-    }\n-\n-    crate fn why_region_contains_point(&self, fr1: RegionVid, elem: Location) -> Option<Cause> {\n-        // Find some constraint `X: Y` where:\n-        // - `fr1: X` transitively\n-        // - and `Y` is live at `elem`\n-        let index = self.blame_constraint(fr1, elem);\n-        let region_sub = self.constraints[index].sub;\n-\n-        // then return why `Y` was live at `elem`\n-        self.liveness_constraints.cause(region_sub, elem)\n-    }\n-\n-    /// Tries to finds a good span to blame for the fact that `fr1`\n-    /// contains `fr2`.\n-    fn blame_constraint(&self, fr1: RegionVid, elem: impl ToElementIndex) -> ConstraintIndex {\n-        // Find everything that influenced final value of `fr`.\n-        let influenced_fr1 = self.dependencies(fr1);\n-\n-        // Try to find some outlives constraint `'X: fr2` where `'X`\n-        // influenced `fr1`. Blame that.\n-        //\n-        // NB, this is a pretty bad choice most of the time. In\n-        // particular, the connection between `'X` and `fr1` may not\n-        // be obvious to the user -- not to mention the naive notion\n-        // of dependencies, which doesn't account for the locations of\n-        // contraints at all. But it will do for now.\n-        let relevant_constraint = self.constraints\n-            .iter_enumerated()\n-            .filter_map(|(i, constraint)| {\n-                if !self.liveness_constraints.contains(constraint.sub, elem) {\n-                    None\n-                } else {\n-                    influenced_fr1[constraint.sup]\n-                        .map(|distance| (distance, i))\n-                }\n-            })\n-            .min() // constraining fr1 with fewer hops *ought* to be more obvious\n-            .map(|(_dist, i)| i);\n-\n-        relevant_constraint.unwrap_or_else(|| {\n-            bug!(\n-                \"could not find any constraint to blame for {:?}: {:?}\",\n-                fr1,\n-                elem,\n-            );\n-        })\n-    }\n-\n-    /// Finds all regions whose values `'a` may depend on in some way.\n-    /// For each region, returns either `None` (does not influence\n-    /// `'a`) or `Some(d)` which indicates that it influences `'a`\n-    /// with distinct `d` (minimum number of edges that must be\n-    /// traversed).\n-    ///\n-    /// Used during error reporting, extremely naive and inefficient.\n-    fn dependencies(&self, r0: RegionVid) -> IndexVec<RegionVid, Option<usize>> {\n-        let mut result_set = IndexVec::from_elem(None, &self.definitions);\n-        let mut changed = true;\n-        result_set[r0] = Some(0); // distance 0 from `r0`\n-\n-        while changed {\n-            changed = false;\n-            for constraint in self.constraints.iter() {\n-                if let Some(n) = result_set[constraint.sup] {\n-                    let m = n + 1;\n-                    if result_set[constraint.sub]\n-                        .map(|distance| m < distance)\n-                        .unwrap_or(true)\n-                    {\n-                        result_set[constraint.sub] = Some(m);\n-                        changed = true;\n-                    }\n-                }\n-            }\n-        }\n-\n-        result_set\n-    }\n }\n \n impl<'tcx> RegionDefinition<'tcx> {"}]}