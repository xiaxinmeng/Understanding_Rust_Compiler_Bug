{"sha": "a5b8a3088a61a564fb2e4de97d4d26e321eb66bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1YjhhMzA4OGE2MWE1NjRmYjJlNGRlOTdkNGQyNmUzMjFlYjY2YmQ=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-11-08T22:11:03Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-11-27T19:28:15Z"}, "message": "Simplify fields of `MemCategorizationContext`", "tree": {"sha": "e09f378dbac2678b1bf5f7a9957b3ee949e0b4d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e09f378dbac2678b1bf5f7a9957b3ee949e0b4d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5b8a3088a61a564fb2e4de97d4d26e321eb66bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5b8a3088a61a564fb2e4de97d4d26e321eb66bd", "html_url": "https://github.com/rust-lang/rust/commit/a5b8a3088a61a564fb2e4de97d4d26e321eb66bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5b8a3088a61a564fb2e4de97d4d26e321eb66bd/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4195b60323046c86d9431e82665de6d2f71a2289", "url": "https://api.github.com/repos/rust-lang/rust/commits/4195b60323046c86d9431e82665de6d2f71a2289", "html_url": "https://github.com/rust-lang/rust/commit/4195b60323046c86d9431e82665de6d2f71a2289"}], "stats": {"total": 200, "additions": 57, "deletions": 143}, "files": [{"sha": "214f435351f008b025fcc630393eec94c18c9f2a", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 11, "deletions": 41, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a5b8a3088a61a564fb2e4de97d4d26e321eb66bd/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5b8a3088a61a564fb2e4de97d4d26e321eb66bd/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=a5b8a3088a61a564fb2e4de97d4d26e321eb66bd", "patch": "@@ -10,7 +10,6 @@ use crate::hir::def_id::DefId;\n use crate::hir::ptr::P;\n use crate::infer::InferCtxt;\n use crate::middle::mem_categorization as mc;\n-use crate::middle::region;\n use crate::ty::{self, TyCtxt, adjustment};\n \n use crate::hir::{self, PatKind};\n@@ -85,7 +84,6 @@ impl OverloadedCallType {\n pub struct ExprUseVisitor<'a, 'tcx> {\n     mc: mc::MemCategorizationContext<'a, 'tcx>,\n     delegate: &'a mut dyn Delegate<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n }\n \n // If the MC results in an error, it's because the type check\n@@ -112,49 +110,22 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     ///\n     /// - `delegate` -- who receives the callbacks\n     /// - `param_env` --- parameter environment for trait lookups (esp. pertaining to `Copy`)\n-    /// - `region_scope_tree` --- region scope tree for the code being analyzed\n     /// - `tables` --- typeck results for the code being analyzed\n-    ///\n-    /// See also `with_infer`, which is used *during* typeck.\n     pub fn new(\n-        delegate: &'a mut (dyn Delegate<'tcx> + 'a),\n-        tcx: TyCtxt<'tcx>,\n-        body_owner: DefId,\n-        param_env: ty::ParamEnv<'tcx>,\n-        region_scope_tree: &'a region::ScopeTree,\n-        tables: &'a ty::TypeckTables<'tcx>,\n-    ) -> Self {\n-        ExprUseVisitor {\n-            mc: mc::MemCategorizationContext::new(tcx,\n-                                                  param_env,\n-                                                  body_owner,\n-                                                  region_scope_tree,\n-                                                  tables),\n-            delegate,\n-            param_env,\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n-    pub fn with_infer(\n         delegate: &'a mut (dyn Delegate<'tcx> + 'a),\n         infcx: &'a InferCtxt<'a, 'tcx>,\n         body_owner: DefId,\n         param_env: ty::ParamEnv<'tcx>,\n-        region_scope_tree: &'a region::ScopeTree,\n         tables: &'a ty::TypeckTables<'tcx>,\n     ) -> Self {\n         ExprUseVisitor {\n-            mc: mc::MemCategorizationContext::with_infer(\n+            mc: mc::MemCategorizationContext::new(\n                 infcx,\n                 param_env,\n                 body_owner,\n-                region_scope_tree,\n                 tables,\n             ),\n             delegate,\n-            param_env,\n         }\n     }\n \n@@ -177,14 +148,14 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     }\n \n     fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.mc.tcx\n+        self.mc.tcx()\n     }\n \n-    fn delegate_consume(&mut self, cmt: &mc::Place<'tcx>) {\n-        debug!(\"delegate_consume(cmt={:?})\", cmt);\n+    fn delegate_consume(&mut self, place: &mc::Place<'tcx>) {\n+        debug!(\"delegate_consume(place={:?})\", place);\n \n-        let mode = copy_or_move(&self.mc, self.param_env, cmt);\n-        self.delegate.consume(cmt, mode);\n+        let mode = copy_or_move(&self.mc, place);\n+        self.delegate.consume(place, mode);\n     }\n \n     fn consume_exprs(&mut self, exprs: &[hir::Expr]) {\n@@ -573,7 +544,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         debug!(\"walk_pat(cmt_discr={:?}, pat={:?})\", cmt_discr, pat);\n \n         let tcx = self.tcx();\n-        let ExprUseVisitor { ref mc, ref mut delegate, param_env } = *self;\n+        let ExprUseVisitor { ref mc, ref mut delegate } = *self;\n         return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |cmt_pat, pat| {\n             if let PatKind::Binding(_, canonical_id, ..) = pat.kind {\n                 debug!(\n@@ -602,7 +573,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                             delegate.borrow(&cmt_pat, bk);\n                         }\n                         ty::BindByValue(..) => {\n-                            let mode = copy_or_move(mc, param_env, &cmt_pat);\n+                            let mode = copy_or_move(mc, &cmt_pat);\n                             debug!(\"walk_pat binding consuming pat\");\n                             delegate.consume(&cmt_pat, mode);\n                         }\n@@ -630,7 +601,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                                                                    var_id));\n                 match upvar_capture {\n                     ty::UpvarCapture::ByValue => {\n-                        let mode = copy_or_move(&self.mc, self.param_env, &cmt_var);\n+                        let mode = copy_or_move(&self.mc, &cmt_var);\n                         self.delegate.consume(&cmt_var, mode);\n                     }\n                     ty::UpvarCapture::ByRef(upvar_borrow) => {\n@@ -655,10 +626,9 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n \n fn copy_or_move<'a, 'tcx>(\n     mc: &mc::MemCategorizationContext<'a, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    cmt: &mc::Place<'tcx>,\n+    place: &mc::Place<'tcx>,\n ) -> ConsumeMode {\n-    if !mc.type_is_copy_modulo_regions(param_env, cmt.ty, cmt.span) {\n+    if !mc.type_is_copy_modulo_regions(place.ty, place.span) {\n         Move\n     } else {\n         Copy"}, {"sha": "f6ce052f96be56e372256a4e7c651ca4dc07aa7c", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 43, "deletions": 96, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/a5b8a3088a61a564fb2e4de97d4d26e321eb66bd/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5b8a3088a61a564fb2e4de97d4d26e321eb66bd/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=a5b8a3088a61a564fb2e4de97d4d26e321eb66bd", "patch": "@@ -58,7 +58,6 @@ pub use self::Note::*;\n \n use self::Aliasability::*;\n \n-use crate::middle::region;\n use crate::hir::def_id::{DefId, LocalDefId};\n use crate::hir::Node;\n use crate::infer::InferCtxt;\n@@ -212,13 +211,11 @@ impl HirNode for hir::Pat {\n \n #[derive(Clone)]\n pub struct MemCategorizationContext<'a, 'tcx> {\n-    pub tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    pub body_owner: DefId,\n-    pub upvars: Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>>,\n-    pub region_scope_tree: &'a region::ScopeTree,\n     pub tables: &'a ty::TypeckTables<'tcx>,\n-    infcx: Option<&'a InferCtxt<'a, 'tcx>>,\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    body_owner: DefId,\n+    upvars: Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>>,\n }\n \n pub type McResult<T> = Result<T, ()>;\n@@ -327,81 +324,42 @@ impl MutabilityCategory {\n }\n \n impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n+    /// Creates a `MemCategorizationContext`.\n     pub fn new(\n-        tcx: TyCtxt<'tcx>,\n+        infcx: &'a InferCtxt<'a, 'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         body_owner: DefId,\n-        region_scope_tree: &'a region::ScopeTree,\n         tables: &'a ty::TypeckTables<'tcx>,\n     ) -> MemCategorizationContext<'a, 'tcx> {\n         MemCategorizationContext {\n-            tcx,\n-            body_owner,\n-            upvars: tcx.upvars(body_owner),\n-            region_scope_tree,\n             tables,\n-            infcx: None,\n+            infcx,\n             param_env,\n+            body_owner,\n+            upvars: infcx.tcx.upvars(body_owner),\n         }\n     }\n-}\n \n-impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n-    /// Creates a `MemCategorizationContext` during type inference.\n-    /// This is used during upvar analysis and a few other places.\n-    /// Because the typeck tables are not yet complete, the results\n-    /// from the analysis must be used with caution:\n-    ///\n-    /// - rvalue promotions are not known, so the lifetimes of\n-    ///   temporaries may be overly conservative;\n-    /// - similarly, as the results of upvar analysis are not yet\n-    ///   known, the results around upvar accesses may be incorrect.\n-    pub fn with_infer(\n-        infcx: &'a InferCtxt<'a, 'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        body_owner: DefId,\n-        region_scope_tree: &'a region::ScopeTree,\n-        tables: &'a ty::TypeckTables<'tcx>,\n-    ) -> MemCategorizationContext<'a, 'tcx> {\n-        let tcx = infcx.tcx;\n-\n-        MemCategorizationContext {\n-            tcx,\n-            body_owner,\n-            upvars: tcx.upvars(body_owner),\n-            region_scope_tree,\n-            tables,\n-            infcx: Some(infcx),\n-            param_env,\n-        }\n+    crate fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.infcx.tcx\n     }\n \n-    pub fn type_is_copy_modulo_regions(\n+    crate fn type_is_copy_modulo_regions(\n         &self,\n-        param_env: ty::ParamEnv<'tcx>,\n         ty: Ty<'tcx>,\n         span: Span,\n     ) -> bool {\n-        self.infcx.map(|infcx| infcx.type_is_copy_modulo_regions(param_env, ty, span))\n-            .or_else(|| {\n-                if (param_env, ty).has_local_value() {\n-                    None\n-                } else {\n-                    Some(ty.is_copy_modulo_regions(self.tcx, param_env, span))\n-                }\n-            })\n-            .unwrap_or(true)\n+        self.infcx.type_is_copy_modulo_regions(self.param_env, ty, span)\n     }\n \n     fn resolve_vars_if_possible<T>(&self, value: &T) -> T\n         where T: TypeFoldable<'tcx>\n     {\n-        self.infcx.map(|infcx| infcx.resolve_vars_if_possible(value))\n-            .unwrap_or_else(|| value.clone())\n+        self.infcx.resolve_vars_if_possible(value)\n     }\n \n     fn is_tainted_by_errors(&self) -> bool {\n-        self.infcx.map_or(false, |infcx| infcx.is_tainted_by_errors())\n+        self.infcx.is_tainted_by_errors()\n     }\n \n     fn resolve_type_vars_or_error(&self,\n@@ -422,23 +380,20 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             None if self.is_tainted_by_errors() => Err(()),\n             None => {\n                 bug!(\"no type for node {}: {} in mem_categorization\",\n-                     id, self.tcx.hir().node_to_string(id));\n+                     id, self.tcx().hir().node_to_string(id));\n             }\n         }\n     }\n \n-    pub fn node_ty(&self,\n-                   hir_id: hir::HirId)\n-                   -> McResult<Ty<'tcx>> {\n-        self.resolve_type_vars_or_error(hir_id,\n-                                        self.tables.node_type_opt(hir_id))\n+    crate fn node_ty(&self, hir_id: hir::HirId) -> McResult<Ty<'tcx>> {\n+        self.resolve_type_vars_or_error(hir_id, self.tables.node_type_opt(hir_id))\n     }\n \n-    pub fn expr_ty(&self, expr: &hir::Expr) -> McResult<Ty<'tcx>> {\n+    fn expr_ty(&self, expr: &hir::Expr) -> McResult<Ty<'tcx>> {\n         self.resolve_type_vars_or_error(expr.hir_id, self.tables.expr_ty_opt(expr))\n     }\n \n-    pub fn expr_ty_adjusted(&self, expr: &hir::Expr) -> McResult<Ty<'tcx>> {\n+    crate fn expr_ty_adjusted(&self, expr: &hir::Expr) -> McResult<Ty<'tcx>> {\n         self.resolve_type_vars_or_error(expr.hir_id, self.tables.expr_ty_adjusted_opt(expr))\n     }\n \n@@ -452,7 +407,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n     ///   implicit deref patterns attached (e.g., it is really\n     ///   `&Some(x)`). In that case, we return the \"outermost\" type\n     ///   (e.g., `&Option<T>).\n-    pub fn pat_ty_adjusted(&self, pat: &hir::Pat) -> McResult<Ty<'tcx>> {\n+    pub(super) fn pat_ty_adjusted(&self, pat: &hir::Pat) -> McResult<Ty<'tcx>> {\n         // Check for implicit `&` types wrapping the pattern; note\n         // that these are never attached to binding patterns, so\n         // actually this is somewhat \"disjoint\" from the code below\n@@ -542,7 +497,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             adjustment::Adjust::Deref(overloaded) => {\n                 // Equivalent to *expr or something similar.\n                 let base = Rc::new(if let Some(deref) = overloaded {\n-                    let ref_ty = self.tcx.mk_ref(deref.region, ty::TypeAndMut {\n+                    let ref_ty = self.tcx().mk_ref(deref.region, ty::TypeAndMut {\n                         ty: target,\n                         mutbl: deref.mutbl,\n                     });\n@@ -582,7 +537,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                        expr.hir_id,\n                        expr,\n                        base_cmt);\n-                let f_index = self.tcx.field_index(expr.hir_id, self.tables);\n+                let f_index = self.tcx().field_index(expr.hir_id, self.tables);\n                 Ok(self.cat_field(expr, base_cmt, f_index, f_ident, expr_ty))\n             }\n \n@@ -648,7 +603,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             Res::Def(DefKind::Static, def_id) => {\n                 // `#[thread_local]` statics may not outlive the current function, but\n                 // they also cannot be moved out of.\n-                let is_thread_local = self.tcx.get_attrs(def_id)[..]\n+                let is_thread_local = self.tcx().get_attrs(def_id)[..]\n                     .iter()\n                     .any(|attr| attr.check_name(sym::thread_local));\n \n@@ -662,7 +617,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                     hir_id,\n                     span,\n                     cat,\n-                    mutbl: match self.tcx.static_mutability(def_id).unwrap() {\n+                    mutbl: match self.tcx().static_mutability(def_id).unwrap() {\n                         Mutability::Immutable => McImmutable,\n                         Mutability::Mutable => McDeclared,\n                     },\n@@ -679,7 +634,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                         hir_id,\n                         span,\n                         cat: Categorization::Local(var_id),\n-                        mutbl: MutabilityCategory::from_local(self.tcx, self.tables, var_id),\n+                        mutbl: MutabilityCategory::from_local(self.tcx(), self.tables, var_id),\n                         ty: expr_ty,\n                         note: NoteNone\n                     })\n@@ -722,25 +677,17 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         // FnOnce         | copied               | upvar -> &'up bk\n \n         let closure_expr_def_id = self.body_owner;\n-        let fn_hir_id = self.tcx.hir().local_def_id_to_hir_id(\n+        let fn_hir_id = self.tcx().hir().local_def_id_to_hir_id(\n             LocalDefId::from_def_id(closure_expr_def_id),\n         );\n         let ty = self.node_ty(fn_hir_id)?;\n         let kind = match ty.kind {\n             ty::Generator(..) => ty::ClosureKind::FnOnce,\n             ty::Closure(closure_def_id, substs) => {\n-                match self.infcx {\n-                    // During upvar inference we may not know the\n-                    // closure kind, just use the LATTICE_BOTTOM value.\n-                    Some(infcx) =>\n-                        infcx.closure_kind(\n-                            closure_def_id,\n-                            substs\n-                        ).unwrap_or(ty::ClosureKind::LATTICE_BOTTOM),\n-\n-                    None =>\n-                        substs.as_closure().kind(closure_def_id, self.tcx),\n-                }\n+                self.infcx.closure_kind(\n+                    closure_def_id,\n+                    substs\n+                ).unwrap_or(ty::ClosureKind::LATTICE_BOTTOM)\n             }\n             _ => span_bug!(span, \"unexpected type for fn in mem_categorization: {:?}\", ty),\n         };\n@@ -753,7 +700,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         let var_ty = self.node_ty(var_id)?;\n \n         // Mutability of original variable itself\n-        let var_mutbl = MutabilityCategory::from_local(self.tcx, self.tables, var_id);\n+        let var_mutbl = MutabilityCategory::from_local(self.tcx(), self.tables, var_id);\n \n         // Construct the upvar. This represents access to the field\n         // from the environment (perhaps we should eventually desugar\n@@ -818,7 +765,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                  -> Place<'tcx>\n     {\n         // Region of environment pointer\n-        let env_region = self.tcx.mk_region(ty::ReFree(ty::FreeRegion {\n+        let env_region = self.tcx().mk_region(ty::ReFree(ty::FreeRegion {\n             // The environment of a closure is guaranteed to\n             // outlive any bindings introduced in the body of the\n             // closure itself.\n@@ -839,7 +786,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         // one.\n         let cmt_result = Place {\n             mutbl: McImmutable,\n-            ty: self.tcx.types.err,\n+            ty: self.tcx().types.err,\n             ..cmt_result\n         };\n \n@@ -936,7 +883,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             ty::Ref(region, _, mutbl) => (region, mutbl),\n             _ => span_bug!(expr.span, \"cat_overloaded_place: base is not a reference\")\n         };\n-        let ref_ty = self.tcx.mk_ref(region, ty::TypeAndMut {\n+        let ref_ty = self.tcx().mk_ref(region, ty::TypeAndMut {\n             ty: place_ty,\n             mutbl,\n         });\n@@ -1037,8 +984,8 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                                              variant_did: DefId)\n                                              -> cmt<'tcx> {\n         // univariant enums do not need downcasts\n-        let base_did = self.tcx.parent(variant_did).unwrap();\n-        if self.tcx.adt_def(base_did).variants.len() != 1 {\n+        let base_did = self.tcx().parent(variant_did).unwrap();\n+        if self.tcx().adt_def(base_did).variants.len() != 1 {\n             let base_ty = base_cmt.ty;\n             let ret = Rc::new(Place {\n                 hir_id: node.hir_id(),\n@@ -1179,10 +1126,10 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                         return Err(())\n                     }\n                     Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fn), variant_ctor_did) => {\n-                        let variant_did = self.tcx.parent(variant_ctor_did).unwrap();\n-                        let enum_did = self.tcx.parent(variant_did).unwrap();\n+                        let variant_did = self.tcx().parent(variant_ctor_did).unwrap();\n+                        let enum_did = self.tcx().parent(variant_did).unwrap();\n                         (self.cat_downcast_if_needed(pat, cmt, variant_did),\n-                         self.tcx.adt_def(enum_did)\n+                         self.tcx().adt_def(enum_did)\n                              .variant_with_ctor_id(variant_ctor_did).fields.len())\n                     }\n                     Res::Def(DefKind::Ctor(CtorOf::Struct, CtorKind::Fn), _)\n@@ -1204,7 +1151,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                             def,\n                             pat.span,\n                         );\n-                        self.tcx.sess.delay_span_bug(pat.span, &format!(\n+                        self.tcx().sess.delay_span_bug(pat.span, &format!(\n                             \"tuple struct pattern didn't resolve to variant or struct {:?}\",\n                             def,\n                         ));\n@@ -1230,7 +1177,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                         return Err(())\n                     }\n                     Res::Def(DefKind::Ctor(CtorOf::Variant, _), variant_ctor_did) => {\n-                        let variant_did = self.tcx.parent(variant_ctor_did).unwrap();\n+                        let variant_did = self.tcx().parent(variant_ctor_did).unwrap();\n                         self.cat_downcast_if_needed(pat, cmt, variant_did)\n                     }\n                     Res::Def(DefKind::Variant, variant_did) => {\n@@ -1241,7 +1188,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n \n                 for fp in field_pats {\n                     let field_ty = self.pat_ty_adjusted(&fp.pat)?; // see (*2)\n-                    let f_index = self.tcx.field_index(fp.hir_id, self.tables);\n+                    let f_index = self.tcx().field_index(fp.hir_id, self.tables);\n                     let cmt_field = Rc::new(self.cat_field(pat, cmt.clone(), f_index,\n                                                            fp.ident, field_ty));\n                     self.cat_pattern_(cmt_field, &fp.pat, op)?;"}, {"sha": "b1813f50468401b971e024b2f00b55e790e41140", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a5b8a3088a61a564fb2e4de97d4d26e321eb66bd/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5b8a3088a61a564fb2e4de97d4d26e321eb66bd/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=a5b8a3088a61a564fb2e4de97d4d26e321eb66bd", "patch": "@@ -814,11 +814,10 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     where\n         F: for<'b> FnOnce(mc::MemCategorizationContext<'b, 'tcx>) -> R,\n     {\n-        f(mc::MemCategorizationContext::with_infer(\n+        f(mc::MemCategorizationContext::new(\n             &self.infcx,\n             self.outlives_environment.param_env,\n             self.body_owner,\n-            &self.region_scope_tree,\n             &self.tables.borrow(),\n         ))\n     }"}, {"sha": "185902142c7481c10a5a1c64d19c320d77301476", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a5b8a3088a61a564fb2e4de97d4d26e321eb66bd/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5b8a3088a61a564fb2e4de97d4d26e321eb66bd/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=a5b8a3088a61a564fb2e4de97d4d26e321eb66bd", "patch": "@@ -171,20 +171,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let body_owner_def_id = self.tcx.hir().body_owner_def_id(body.id());\n         assert_eq!(body_owner_def_id, closure_def_id);\n-        let region_scope_tree = &self.tcx.region_scope_tree(body_owner_def_id);\n         let mut delegate = InferBorrowKind {\n             fcx: self,\n-            closure_def_id: closure_def_id,\n+            closure_def_id,\n             current_closure_kind: ty::ClosureKind::LATTICE_BOTTOM,\n             current_origin: None,\n             adjust_upvar_captures: ty::UpvarCaptureMap::default(),\n         };\n-        euv::ExprUseVisitor::with_infer(\n+        euv::ExprUseVisitor::new(\n             &mut delegate,\n             &self.infcx,\n             body_owner_def_id,\n             self.param_env,\n-            region_scope_tree,\n             &self.tables.borrow(),\n         )\n         .consume_body(body);"}]}