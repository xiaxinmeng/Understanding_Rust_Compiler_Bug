{"sha": "fb0896fe7bc0a8a0a37a1bc71ed1befb1905acd7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiMDg5NmZlN2JjMGE4YTBhMzdhMWJjNzFlZDFiZWZiMTkwNWFjZDc=", "commit": {"author": {"name": "Elly Jones", "email": "elly@leptoquark.net", "date": "2011-12-20T21:52:04Z"}, "committer": {"name": "Elly Jones", "email": "elly@leptoquark.net", "date": "2011-12-20T21:52:04Z"}, "message": "rustdoc: Add.\n\nParses #[doc] attributes on top-level module items and generates Markdown.\n\nSigned-off-by: Elly Jones <elly@leptoquark.net>", "tree": {"sha": "9197948d1737c4967f179e37391f9997b49be7af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9197948d1737c4967f179e37391f9997b49be7af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb0896fe7bc0a8a0a37a1bc71ed1befb1905acd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb0896fe7bc0a8a0a37a1bc71ed1befb1905acd7", "html_url": "https://github.com/rust-lang/rust/commit/fb0896fe7bc0a8a0a37a1bc71ed1befb1905acd7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb0896fe7bc0a8a0a37a1bc71ed1befb1905acd7/comments", "author": null, "committer": null, "parents": [{"sha": "3bc4da96f16298c0575ae82904a2552f7ee1547c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bc4da96f16298c0575ae82904a2552f7ee1547c", "html_url": "https://github.com/rust-lang/rust/commit/3bc4da96f16298c0575ae82904a2552f7ee1547c"}], "stats": {"total": 205, "additions": 205, "deletions": 0}, "files": [{"sha": "9d119d208f4131bc3133af56bc8577d2940e17d7", "filename": "src/rustdoc/rustdoc.rs", "status": "added", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/fb0896fe7bc0a8a0a37a1bc71ed1befb1905acd7/src%2Frustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb0896fe7bc0a8a0a37a1bc71ed1befb1905acd7/src%2Frustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Frustdoc.rs?ref=fb0896fe7bc0a8a0a37a1bc71ed1befb1905acd7", "patch": "@@ -0,0 +1,205 @@\n+/* rustdoc - rust->markdown translator\n+ *\n+ * Copyright 2011 Google Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+use std;\n+use rustc;\n+\n+import option;\n+import option::{some, none};\n+import rustc::syntax::ast;\n+import rustc::syntax::codemap;\n+import rustc::syntax::parse::parser;\n+import rustc::syntax::print::pprust;\n+import rustc::syntax::visit;\n+import std::io;\n+import std::map;\n+\n+type rustdoc = {\n+    ps: pprust::ps,\n+    w: io::writer\n+};\n+\n+type fndoc = {\n+    brief: str,\n+    desc: option::t<str>,\n+    return: option::t<str>,\n+    args: map::hashmap<str, str>\n+};\n+\n+#[doc(\n+  brief = \"Documents a single function.\",\n+  args(rd = \"Rustdoc context\",\n+       ident = \"Identifier for this function\",\n+       doc = \"Function docs extracted from attributes\",\n+       _fn = \"AST object representing this function\")\n+)]\n+fn doc_fn(rd: rustdoc, ident: str, doc: fndoc, _fn: ast::_fn) {\n+    rd.w.write_line(\"## Function `\" + ident + \"`\");\n+    rd.w.write_line(doc.brief);\n+    alt doc.desc {\n+        some(_d) {\n+            rd.w.write_line(\"\");\n+            rd.w.write_line(_d);\n+            rd.w.write_line(\"\");\n+        }\n+        none. { }\n+    }\n+    for arg: ast::arg in _fn.decl.inputs {\n+        rd.w.write_str(\"### Argument `\" + arg.ident + \"`: \");\n+        rd.w.write_line(\"`\" + pprust::ty_to_str(arg.ty) + \"`\");\n+        alt doc.args.find(arg.ident) {\n+            some(_d) {\n+                rd.w.write_line(_d);\n+            }\n+            none. { }\n+        };\n+    }\n+    rd.w.write_line(\"### Returns `\" + pprust::ty_to_str(_fn.decl.output) + \"`\");\n+    alt doc.return {\n+        some(_r) { rd.w.write_line(_r); }\n+        none. { }\n+    }\n+}\n+\n+#[doc(\n+  brief = \"Parses function docs from a complex #[doc] attribute.\",\n+  desc = \"Supported attributes:\n+\n+* `brief`: Brief description\n+* `desc`: Long description\n+* `return`: Description of return value\n+* `args`: List of argname = argdesc pairs\n+\",\n+  args(items = \"Doc attribute contents\"),\n+  return = \"Parsed function docs.\"\n+)]\n+fn parse_compound_fndoc(items: [@ast::meta_item]) -> fndoc {\n+    let brief = none;\n+    let desc = none;\n+    let return = none;\n+    let argdocs = map::new_str_hash::<str>();\n+    let argdocsfound = none;\n+    for item: @ast::meta_item in items {\n+        alt item.node {\n+            ast::meta_name_value(\"brief\", {node: ast::lit_str(value),\n+                                           span: _}) {\n+                brief = some(value);\n+            }\n+            ast::meta_name_value(\"desc\", {node: ast::lit_str(value),\n+                                              span: _}) {\n+                desc = some(value);\n+            }\n+            ast::meta_name_value(\"return\", {node: ast::lit_str(value),\n+                                            span: _}) {\n+                return = some(value);\n+            }\n+            ast::meta_list(\"args\", args) {\n+                argdocsfound = some(args);\n+            }\n+            _ { }\n+        }\n+    }\n+\n+    alt argdocsfound {\n+        none. { }\n+        some(ds) {\n+            for d: @ast::meta_item in ds {\n+                alt d.node {\n+                    ast::meta_name_value(key, {node: ast::lit_str(value),\n+                                               span: _}) {\n+                        argdocs.insert(key, value);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    let _brief = alt brief {\n+        some(_b) { _b }\n+        none. { \"_undocumented_\" }\n+    };\n+\n+    { brief: _brief, desc: desc, return: return, args: argdocs }\n+}\n+\n+#[doc(\n+  brief = \"Documents a single crate item.\",\n+  args(rd = \"Rustdoc context\",\n+       item = \"AST item to document\")\n+)]\n+fn doc_item(rd: rustdoc, item: @ast::item) {\n+    let _fndoc = none;\n+    let noargdocs = map::new_str_hash::<str>();\n+    for attr: ast::attribute in item.attrs {\n+        alt attr.node.value.node {\n+            ast::meta_name_value(\"doc\", {node: ast::lit_str(value), span: _}) {\n+                _fndoc = some({ brief: value,\n+                                desc: none,\n+                                return: none,\n+                                args: noargdocs });\n+            }\n+            ast::meta_list(\"doc\", docs) {\n+                _fndoc = some(parse_compound_fndoc(docs));\n+            }\n+        }\n+    }\n+\n+    let _fndoc0 = alt _fndoc {\n+        some(_d) { _d }\n+        none. { { brief: \"_undocumented_\", desc: none, return: none, args: noargdocs } }\n+    };\n+\n+    alt item.node {\n+        ast::item_const(ty, expr) { }\n+        ast::item_fn(_fn, _) {\n+            doc_fn(rd, item.ident, _fndoc0, _fn);\n+        }\n+        ast::item_mod(_mod) { }\n+        ast::item_ty(ty, typarams) { }\n+        ast::item_tag(variant, typarams) { }\n+        ast::item_obj(_obj, typarams, node_id) { }\n+        ast::item_res(dtor, dtorid, typarams, ctorid) { }\n+    };\n+}\n+\n+#[doc(\n+  brief = \"Generate a crate document header.\",\n+  args(rd = \"Rustdoc context\",\n+       name = \"Crate name\")\n+)]\n+fn doc_header(rd: rustdoc, name: str) {\n+    rd.w.write_line(\"# Crate \" + name);\n+}\n+\n+#[doc(\n+  brief = \"Main function.\",\n+  desc = \"Command-line arguments:\n+\n+*  argv[1]: crate file name\",\n+  args(argv = \"Command-line arguments.\")\n+)]\n+fn main(argv: [str]) {\n+    let sess = @{cm: codemap::new_codemap(), mutable next_id: 0};\n+    let w = io::stdout();\n+    let rd = { ps: pprust::rust_printer(w), w: w };\n+    doc_header(rd, argv[1]);\n+    let p = parser::parse_crate_from_source_file(argv[1], [], sess);\n+    let v = visit::mk_simple_visitor(@{\n+        visit_item: bind doc_item(rd, _)\n+        with *visit::default_simple_visitor()});\n+    visit::visit_crate(*p, (), v);\n+}"}]}