{"sha": "1f0621d04ee9d938ba7d07df76837b86f43c6158", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmMDYyMWQwNGVlOWQ5MzhiYTdkMDdkZjc2ODM3Yjg2ZjQzYzYxNTg=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-09-21T23:22:32Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-09-21T23:22:32Z"}, "message": "Begin teaching rustc to parse literals, atoms, stmts, blocks, items, modules, crates.", "tree": {"sha": "85c1a6034f9858156d6188d1690abb68cb128d36", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85c1a6034f9858156d6188d1690abb68cb128d36"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f0621d04ee9d938ba7d07df76837b86f43c6158", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f0621d04ee9d938ba7d07df76837b86f43c6158", "html_url": "https://github.com/rust-lang/rust/commit/1f0621d04ee9d938ba7d07df76837b86f43c6158", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f0621d04ee9d938ba7d07df76837b86f43c6158/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8beb118df442679c3afd2934b370c294a1df3046", "url": "https://api.github.com/repos/rust-lang/rust/commits/8beb118df442679c3afd2934b370c294a1df3046", "html_url": "https://github.com/rust-lang/rust/commit/8beb118df442679c3afd2934b370c294a1df3046"}], "stats": {"total": 220, "additions": 182, "deletions": 38}, "files": [{"sha": "d00d2e6853d657c08f9bd7dbb07ddbfe55b6c6f8", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1f0621d04ee9d938ba7d07df76837b86f43c6158/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f0621d04ee9d938ba7d07df76837b86f43c6158/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=1f0621d04ee9d938ba7d07df76837b86f43c6158", "patch": "@@ -27,22 +27,12 @@ fn main(vec[str] args) {\n   auto i = 0;\n   auto sess = session.session();\n   for (str filename in args) {\n-    if (i > 0) {\n-        auto p = parser.new_parser(sess, filename);\n-        log \"opened file: \" + filename;\n-        auto tok = p.peek();\n-        while (true) {\n-            alt (tok) {\n-                case (token.EOF()) { ret; }\n-                case (_) {\n-                    log token.to_str(tok);\n-                    p.bump();\n-                    tok = p.peek();\n-                }\n-            }\n-        }\n-    }\n-    i += 1;\n+      if (i > 0) {\n+          auto p = parser.new_parser(sess, filename);\n+          log \"opened file: \" + filename;\n+          auto crate = parser.parse_crate(p);\n+      }\n+      i += 1;\n   }\n \n   // Test LLVM module-writing. Nothing interesting yet."}, {"sha": "327570d696a430d20d7a1a1be7d705268a54b584", "filename": "src/comp/fe/ast.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1f0621d04ee9d938ba7d07df76837b86f43c6158/src%2Fcomp%2Ffe%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f0621d04ee9d938ba7d07df76837b86f43c6158/src%2Fcomp%2Ffe%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffe%2Fast.rs?ref=1f0621d04ee9d938ba7d07df76837b86f43c6158", "patch": "@@ -5,15 +5,15 @@ import util.common.span;\n \n type ident = str;\n \n-type crate = rec( str filename,\n-                  _mod module);\n+type crate = rec(_mod module);\n \n type block = vec[@stmt];\n \n tag stmt {\n     stmt_block(block);\n     stmt_decl(@decl);\n     stmt_ret(option[@lval]);\n+    stmt_log(@atom);\n }\n \n \n@@ -36,6 +36,7 @@ tag atom {\n tag lit {\n     lit_char(char);\n     lit_int(int);\n+    lit_uint(uint);\n     lit_nil;\n     lit_bool(bool);\n }\n@@ -44,7 +45,11 @@ tag ty {\n     ty_nil;\n     ty_bool;\n     ty_int;\n+    ty_uint;\n+    ty_machine(util.common.ty_mach);\n     ty_char;\n+    ty_str;\n+    ty_box(@ty);\n }\n \n tag mode {"}, {"sha": "d058db4a82def9d179d339b3295d0740be27958c", "filename": "src/comp/fe/lexer.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1f0621d04ee9d938ba7d07df76837b86f43c6158/src%2Fcomp%2Ffe%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f0621d04ee9d938ba7d07df76837b86f43c6158/src%2Fcomp%2Ffe%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffe%2Flexer.rs?ref=1f0621d04ee9d938ba7d07df76837b86f43c6158", "patch": "@@ -3,12 +3,7 @@ import std._str;\n import std.map;\n import std.map.hashmap;\n import util.common;\n-\n-fn new_str_hash[V]() -> map.hashmap[str,V] {\n-    let map.hashfn[str] hasher = _str.hash;\n-    let map.eqfn[str] eqer = _str.eq;\n-    ret map.mk_hashmap[str,V](hasher, eqer);\n-}\n+import util.common.new_str_hash;\n \n state type reader = state obj {\n                           fn is_eof() -> bool;"}, {"sha": "248d60f438369fc5d473c1cf0e9f77a7b4711b49", "filename": "src/comp/fe/parser.rs", "status": "modified", "additions": 161, "deletions": 14, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/1f0621d04ee9d938ba7d07df76837b86f43c6158/src%2Fcomp%2Ffe%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f0621d04ee9d938ba7d07df76837b86f43c6158/src%2Fcomp%2Ffe%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffe%2Fparser.rs?ref=1f0621d04ee9d938ba7d07df76837b86f43c6158", "patch": "@@ -1,6 +1,16 @@\n import std._io;\n import driver.session;\n import util.common;\n+import util.common.new_str_hash;\n+\n+// FIXME: import std.util.option and use it here.\n+// import std.util.option;\n+\n+tag option[T] {\n+  none;\n+  some(T);\n+}\n+\n \n state type parser =\n     state obj {\n@@ -19,6 +29,7 @@ state fn new_parser(session.session sess, str path) -> parser {\n                            lexer.reader rdr)\n         {\n             state fn peek() -> token.token {\n+                log token.to_str(tok);\n                 ret tok;\n             }\n \n@@ -56,40 +67,176 @@ state fn expect(parser p, token.token t) {\n         let str s = \"expecting \";\n         s += token.to_str(t);\n         s += \", found \";\n-        s += token.to_str(t);\n+        s += token.to_str(p.peek());\n         p.err(s);\n     }\n }\n \n state fn parse_ident(parser p) -> ast.ident {\n     alt (p.peek()) {\n-        case (token.IDENT(?i)) { ret i; }\n+        case (token.IDENT(?i)) { p.bump(); ret i; }\n         case (_) {\n             p.err(\"expecting ident\");\n             fail;\n         }\n     }\n }\n \n-state fn parse_item(parser p) -> tup(ast.ident, ast.item) {\n+state fn parse_ty(parser p) -> ast.ty {\n+    alt (p.peek()) {\n+        case (token.INT) { p.bump(); ret ast.ty_int; }\n+        case (token.UINT) { p.bump(); ret ast.ty_int; }\n+        case (token.STR) { p.bump(); ret ast.ty_str; }\n+        case (token.CHAR) { p.bump(); ret ast.ty_char; }\n+        case (token.MACH(?tm)) { p.bump(); ret ast.ty_machine(tm); }\n+    }\n+    p.err(\"expecting type\");\n+    fail;\n+}\n+\n+state fn parse_slot(parser p) -> ast.slot {\n+    let ast.mode m = ast.val;\n+    if (p.peek() == token.BINOP(token.AND)) {\n+        m = ast.alias;\n+        p.bump();\n+    }\n+    let ast.ty t = parse_ty(p);\n+    ret rec(ty=t, mode=m);\n+}\n+\n+state fn parse_seq[T](token.token bra,\n+                      token.token ket,\n+                      option[token.token] sep,\n+                      (state fn(parser) -> T) f,\n+                      parser p) -> vec[T] {\n+    let bool first = true;\n+    expect(p, bra);\n+    let vec[T] v = vec();\n+    while (p.peek() != ket) {\n+        alt(sep) {\n+            case (some[token.token](?t)) {\n+                if (first) {\n+                    first = false;\n+                } else {\n+                    expect(p, t);\n+                }\n+            }\n+            case (_) {\n+            }\n+        }\n+        // FIXME: v += f(p) doesn't work at the moment.\n+        let T t = f(p);\n+        v += vec(t);\n+    }\n+    expect(p, ket);\n+    ret v;\n+}\n+\n+state fn parse_lit(parser p) -> ast.lit {\n     alt (p.peek()) {\n-        case (token.FN()) {\n+        case (token.LIT_INT(?i)) {\n+            p.bump();\n+            ret ast.lit_int(i);\n+        }\n+        case (token.LIT_UINT(?u)) {\n             p.bump();\n-            auto id = parse_ident(p);\n-            expect(p, token.LPAREN);\n-            let vec[rec(ast.slot slot, ast.ident ident)] inputs = vec();\n-            let vec[@ast.stmt] body = vec();\n-            auto output = rec(ty = ast.ty_nil, mode = ast.val );\n-            let ast._fn f = rec(inputs = inputs,\n-                                output = output,\n-                                body = body);\n-            ret tup(id, ast.item_fn(@f));\n+            ret ast.lit_uint(u);\n+        }\n+        case (token.LIT_CHAR(?c)) {\n+            p.bump();\n+            ret ast.lit_char(c);\n+        }\n+        case (token.LIT_BOOL(?b)) {\n+            p.bump();\n+            ret ast.lit_bool(b);\n         }\n     }\n-    p.err(\"expecting item\");\n+    p.err(\"expected literal\");\n     fail;\n }\n \n+state fn parse_atom(parser p) -> ast.atom {\n+    ret ast.atom_lit(@parse_lit(p));\n+}\n+\n+state fn parse_stmt(parser p) -> @ast.stmt {\n+    alt (p.peek()) {\n+        case (token.LOG) {\n+            p.bump();\n+            auto a = @parse_atom(p);\n+            expect(p, token.SEMI);\n+            ret @ast.stmt_log(a);\n+        }\n+    }\n+    p.err(\"expected statement\");\n+    fail;\n+}\n+\n+state fn parse_block(parser p) -> ast.block {\n+    auto f = parse_stmt;\n+    // FIXME: passing parse_stmt as an lval doesn't work at the moment.\n+    ret parse_seq[@ast.stmt](token.LBRACE,\n+                             token.RBRACE,\n+                             none[token.token],\n+                             f, p);\n+}\n+\n+state fn parse_slot_ident_pair(parser p) ->\n+    rec(ast.slot slot, ast.ident ident) {\n+    auto s = parse_slot(p);\n+    auto i =  parse_ident(p);\n+    ret rec(slot=s, ident=i);\n+}\n+\n+state fn parse_fn(parser p) -> tup(ast.ident, ast.item) {\n+    expect(p, token.FN);\n+    auto id = parse_ident(p);\n+    auto pf = parse_slot_ident_pair;\n+    auto inputs =\n+        // FIXME: passing parse_slot_ident_pair as an lval doesn't work at the\n+        // moment.\n+        parse_seq[rec(ast.slot slot, ast.ident ident)]\n+        (token.LPAREN,\n+         token.RPAREN,\n+         some(token.COMMA),\n+         pf, p);\n+\n+    auto output;\n+    if (p.peek() == token.RARROW) {\n+        p.bump();\n+        output = rec(ty=parse_ty(p), mode=ast.val);\n+    } else {\n+        output = rec(ty=ast.ty_nil, mode=ast.val);\n+    }\n+\n+    auto body = parse_block(p);\n+\n+    let ast._fn f = rec(inputs = inputs,\n+                        output = output,\n+                        body = body);\n+\n+    ret tup(id, ast.item_fn(@f));\n+}\n+\n+state fn parse_item(parser p) -> tup(ast.ident, ast.item) {\n+    alt (p.peek()) {\n+        case (token.FN) {\n+            ret parse_fn(p);\n+        }\n+    }\n+    p.err(\"expectied item\");\n+    fail;\n+}\n+\n+state fn parse_crate(parser p) -> ast.crate {\n+    let ast._mod m = new_str_hash[ast.item]();\n+    while (p.peek() != token.EOF) {\n+        auto i = parse_item(p);\n+        m.insert(i._0, i._1);\n+    }\n+    ret rec(module=m);\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "b9b2fa07fa44c905d29311542ca027f2933d6e9f", "filename": "src/comp/fe/token.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1f0621d04ee9d938ba7d07df76837b86f43c6158/src%2Fcomp%2Ffe%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f0621d04ee9d938ba7d07df76837b86f43c6158/src%2Fcomp%2Ffe%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffe%2Ftoken.rs?ref=1f0621d04ee9d938ba7d07df76837b86f43c6158", "patch": "@@ -1,5 +1,6 @@\n import util.common.ty_mach;\n import util.common.ty_mach_to_str;\n+import util.common.new_str_hash;\n import std._int;\n import std._uint;\n "}, {"sha": "9952c89b1ff381d19c22d6af97550dcd78797180", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1f0621d04ee9d938ba7d07df76837b86f43c6158/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f0621d04ee9d938ba7d07df76837b86f43c6158/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=1f0621d04ee9d938ba7d07df76837b86f43c6158", "patch": "@@ -35,6 +35,12 @@ fn ty_mach_to_str(ty_mach tm) -> str {\n     }\n }\n \n+fn new_str_hash[V]() -> std.map.hashmap[str,V] {\n+    let std.map.hashfn[str] hasher = std._str.hash;\n+    let std.map.eqfn[str] eqer = std._str.eq;\n+    ret std.map.mk_hashmap[str,V](hasher, eqer);\n+}\n+\n //\n // Local Variables:\n // mode: rust"}]}