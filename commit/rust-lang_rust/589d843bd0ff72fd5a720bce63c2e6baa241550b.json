{"sha": "589d843bd0ff72fd5a720bce63c2e6baa241550b", "node_id": "C_kwDOAAsO6NoAKDU4OWQ4NDNiZDBmZjcyZmQ1YTcyMGJjZTYzYzJlNmJhYTI0MTU1MGI", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-11-21T23:01:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-21T23:01:09Z"}, "message": "Rollup merge of #104559 - nnethercote:split-MacArgs, r=petrochenkov\n\nSplit `MacArgs` in two.\n\n`MacArgs` is an enum with three variants: `Empty`, `Delimited`, and `Eq`. It's used in two ways:\n- For representing attribute macro arguments (e.g. in `AttrItem`), where all three variants are used.\n- For representing function-like macros (e.g. in `MacCall` and `MacroDef`), where only the `Delimited` variant is used.\n\nIn other words, `MacArgs` is used in two quite different places due to them having partial overlap. I find this makes the code hard to read. It also leads to various unreachable code paths, and allows invalid values (such as accidentally using `MacArgs::Empty` in a `MacCall`).\n\nThis commit splits `MacArgs` in two:\n- `DelimArgs` is a new struct just for the \"delimited arguments\" case. It is now used in `MacCall` and `MacroDef`.\n- `AttrArgs` is a renaming of the old `MacArgs` enum for the attribute macro case. Its `Delimited` variant now contains a `DelimArgs`.\n\nVarious other related things are renamed as well.\n\nThese changes make the code clearer, avoids several unreachable paths, and disallows the invalid values.\n\nr? `@petrochenkov`", "tree": {"sha": "424891b591ec967fdaf52ebdadb12243d0851486", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/424891b591ec967fdaf52ebdadb12243d0851486"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/589d843bd0ff72fd5a720bce63c2e6baa241550b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjfAM1CRBK7hj4Ov3rIwAAixwIAHw6GnFmJZMEVhwf0P31Juql\n+wrlpYBod+vD0gMCuddFKPBtMwWx7+Pys5kIJcrB4O1RUZDFS2fMTSrPkj4uy4i0\nfXjtosiWMHvdqf0osrXEvqXaGFTdJ/iT8EmYNJreUvZnA+oNBbx7EeVJshUSfcVk\nVhnWIemVsiHg8fiiF2B7lILILFaUYIKroLotft6SM4A3cK2KOTh68RJcoABFbKc3\nIhGKQZtRwcMMhlPgUrmtT5gbxrVn/VxnH4JlvTlQmQVbr7PuWI4WZeCn1br/lrPf\nh5zTEzI/4OWcjY+ypHVQyukNgPXAnRFuGsxrebjOpal1U4rLC3VnGodBRvdGUFM=\n=7bMo\n-----END PGP SIGNATURE-----\n", "payload": "tree 424891b591ec967fdaf52ebdadb12243d0851486\nparent ba135ee568e4f7718b9d270fa20999b785dad9aa\nparent 3e3a4192d8cda0c308ea87b2e8f6f1e8dcc74739\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1669071669 +0100\ncommitter GitHub <noreply@github.com> 1669071669 +0100\n\nRollup merge of #104559 - nnethercote:split-MacArgs, r=petrochenkov\n\nSplit `MacArgs` in two.\n\n`MacArgs` is an enum with three variants: `Empty`, `Delimited`, and `Eq`. It's used in two ways:\n- For representing attribute macro arguments (e.g. in `AttrItem`), where all three variants are used.\n- For representing function-like macros (e.g. in `MacCall` and `MacroDef`), where only the `Delimited` variant is used.\n\nIn other words, `MacArgs` is used in two quite different places due to them having partial overlap. I find this makes the code hard to read. It also leads to various unreachable code paths, and allows invalid values (such as accidentally using `MacArgs::Empty` in a `MacCall`).\n\nThis commit splits `MacArgs` in two:\n- `DelimArgs` is a new struct just for the \"delimited arguments\" case. It is now used in `MacCall` and `MacroDef`.\n- `AttrArgs` is a renaming of the old `MacArgs` enum for the attribute macro case. Its `Delimited` variant now contains a `DelimArgs`.\n\nVarious other related things are renamed as well.\n\nThese changes make the code clearer, avoids several unreachable paths, and disallows the invalid values.\n\nr? `@petrochenkov`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/589d843bd0ff72fd5a720bce63c2e6baa241550b", "html_url": "https://github.com/rust-lang/rust/commit/589d843bd0ff72fd5a720bce63c2e6baa241550b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/589d843bd0ff72fd5a720bce63c2e6baa241550b/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba135ee568e4f7718b9d270fa20999b785dad9aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba135ee568e4f7718b9d270fa20999b785dad9aa", "html_url": "https://github.com/rust-lang/rust/commit/ba135ee568e4f7718b9d270fa20999b785dad9aa"}, {"sha": "3e3a4192d8cda0c308ea87b2e8f6f1e8dcc74739", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e3a4192d8cda0c308ea87b2e8f6f1e8dcc74739", "html_url": "https://github.com/rust-lang/rust/commit/3e3a4192d8cda0c308ea87b2e8f6f1e8dcc74739"}], "stats": {"total": 498, "additions": 251, "deletions": 247}, "files": [{"sha": "fa745a8e08b95db68f74e9c3f343eaa8abd1e717", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 57, "deletions": 46, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=589d843bd0ff72fd5a720bce63c2e6baa241550b", "patch": "@@ -1544,55 +1544,48 @@ pub enum ClosureBinder {\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct MacCall {\n     pub path: Path,\n-    pub args: P<MacArgs>,\n+    pub args: P<DelimArgs>,\n     pub prior_type_ascription: Option<(Span, bool)>,\n }\n \n impl MacCall {\n     pub fn span(&self) -> Span {\n-        self.path.span.to(self.args.span().unwrap_or(self.path.span))\n+        self.path.span.to(self.args.dspan.entire())\n     }\n }\n \n-/// Arguments passed to an attribute or a function-like macro.\n+/// Arguments passed to an attribute macro.\n #[derive(Clone, Encodable, Decodable, Debug)]\n-pub enum MacArgs {\n-    /// No arguments - `#[attr]`.\n+pub enum AttrArgs {\n+    /// No arguments: `#[attr]`.\n     Empty,\n-    /// Delimited arguments - `#[attr()/[]/{}]` or `mac!()/[]/{}`.\n-    Delimited(DelimSpan, MacDelimiter, TokenStream),\n-    /// Arguments of a key-value attribute - `#[attr = \"value\"]`.\n+    /// Delimited arguments: `#[attr()/[]/{}]`.\n+    Delimited(DelimArgs),\n+    /// Arguments of a key-value attribute: `#[attr = \"value\"]`.\n     Eq(\n         /// Span of the `=` token.\n         Span,\n         /// The \"value\".\n-        MacArgsEq,\n+        AttrArgsEq,\n     ),\n }\n \n-// The RHS of a `MacArgs::Eq` starts out as an expression. Once macro expansion\n-// is completed, all cases end up either as a literal, which is the form used\n-// after lowering to HIR, or as an error.\n+// The RHS of an `AttrArgs::Eq` starts out as an expression. Once macro\n+// expansion is completed, all cases end up either as a literal, which is the\n+// form used after lowering to HIR, or as an error.\n #[derive(Clone, Encodable, Decodable, Debug)]\n-pub enum MacArgsEq {\n+pub enum AttrArgsEq {\n     Ast(P<Expr>),\n     Hir(Lit),\n }\n \n-impl MacArgs {\n-    pub fn delim(&self) -> Option<Delimiter> {\n-        match self {\n-            MacArgs::Delimited(_, delim, _) => Some(delim.to_token()),\n-            MacArgs::Empty | MacArgs::Eq(..) => None,\n-        }\n-    }\n-\n+impl AttrArgs {\n     pub fn span(&self) -> Option<Span> {\n         match self {\n-            MacArgs::Empty => None,\n-            MacArgs::Delimited(dspan, ..) => Some(dspan.entire()),\n-            MacArgs::Eq(eq_span, MacArgsEq::Ast(expr)) => Some(eq_span.to(expr.span)),\n-            MacArgs::Eq(_, MacArgsEq::Hir(lit)) => {\n+            AttrArgs::Empty => None,\n+            AttrArgs::Delimited(args) => Some(args.dspan.entire()),\n+            AttrArgs::Eq(eq_span, AttrArgsEq::Ast(expr)) => Some(eq_span.to(expr.span)),\n+            AttrArgs::Eq(_, AttrArgsEq::Hir(lit)) => {\n                 unreachable!(\"in literal form when getting span: {:?}\", lit);\n             }\n         }\n@@ -1602,46 +1595,64 @@ impl MacArgs {\n     /// Proc macros see these tokens, for example.\n     pub fn inner_tokens(&self) -> TokenStream {\n         match self {\n-            MacArgs::Empty => TokenStream::default(),\n-            MacArgs::Delimited(.., tokens) => tokens.clone(),\n-            MacArgs::Eq(_, MacArgsEq::Ast(expr)) => TokenStream::from_ast(expr),\n-            MacArgs::Eq(_, MacArgsEq::Hir(lit)) => {\n+            AttrArgs::Empty => TokenStream::default(),\n+            AttrArgs::Delimited(args) => args.tokens.clone(),\n+            AttrArgs::Eq(_, AttrArgsEq::Ast(expr)) => TokenStream::from_ast(expr),\n+            AttrArgs::Eq(_, AttrArgsEq::Hir(lit)) => {\n                 unreachable!(\"in literal form when getting inner tokens: {:?}\", lit)\n             }\n         }\n     }\n-\n-    /// Whether a macro with these arguments needs a semicolon\n-    /// when used as a standalone item or statement.\n-    pub fn need_semicolon(&self) -> bool {\n-        !matches!(self, MacArgs::Delimited(_, MacDelimiter::Brace, _))\n-    }\n }\n \n-impl<CTX> HashStable<CTX> for MacArgs\n+impl<CTX> HashStable<CTX> for AttrArgs\n where\n     CTX: crate::HashStableContext,\n {\n     fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         mem::discriminant(self).hash_stable(ctx, hasher);\n         match self {\n-            MacArgs::Empty => {}\n-            MacArgs::Delimited(dspan, delim, tokens) => {\n-                dspan.hash_stable(ctx, hasher);\n-                delim.hash_stable(ctx, hasher);\n-                tokens.hash_stable(ctx, hasher);\n-            }\n-            MacArgs::Eq(_eq_span, MacArgsEq::Ast(expr)) => {\n+            AttrArgs::Empty => {}\n+            AttrArgs::Delimited(args) => args.hash_stable(ctx, hasher),\n+            AttrArgs::Eq(_eq_span, AttrArgsEq::Ast(expr)) => {\n                 unreachable!(\"hash_stable {:?}\", expr);\n             }\n-            MacArgs::Eq(eq_span, MacArgsEq::Hir(lit)) => {\n+            AttrArgs::Eq(eq_span, AttrArgsEq::Hir(lit)) => {\n                 eq_span.hash_stable(ctx, hasher);\n                 lit.hash_stable(ctx, hasher);\n             }\n         }\n     }\n }\n \n+/// Delimited arguments, as used in `#[attr()/[]/{}]` or `mac!()/[]/{}`.\n+#[derive(Clone, Encodable, Decodable, Debug)]\n+pub struct DelimArgs {\n+    pub dspan: DelimSpan,\n+    pub delim: MacDelimiter,\n+    pub tokens: TokenStream,\n+}\n+\n+impl DelimArgs {\n+    /// Whether a macro with these arguments needs a semicolon\n+    /// when used as a standalone item or statement.\n+    pub fn need_semicolon(&self) -> bool {\n+        !matches!(self, DelimArgs { delim: MacDelimiter::Brace, .. })\n+    }\n+}\n+\n+impl<CTX> HashStable<CTX> for DelimArgs\n+where\n+    CTX: crate::HashStableContext,\n+{\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n+        let DelimArgs { dspan, delim, tokens } = self;\n+        dspan.hash_stable(ctx, hasher);\n+        delim.hash_stable(ctx, hasher);\n+        tokens.hash_stable(ctx, hasher);\n+    }\n+}\n+\n #[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum MacDelimiter {\n     Parenthesis,\n@@ -1671,7 +1682,7 @@ impl MacDelimiter {\n /// Represents a macro definition.\n #[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct MacroDef {\n-    pub body: P<MacArgs>,\n+    pub body: P<DelimArgs>,\n     /// `true` if macro was defined with `macro_rules`.\n     pub macro_rules: bool,\n }\n@@ -2534,7 +2545,7 @@ impl<D: Decoder> Decodable<D> for AttrId {\n #[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct AttrItem {\n     pub path: Path,\n-    pub args: MacArgs,\n+    pub args: AttrArgs,\n     pub tokens: Option<LazyAttrTokenStream>,\n }\n "}, {"sha": "2f7c7a29492814a9d037d9db46633a56d4682dc0", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=589d843bd0ff72fd5a720bce63c2e6baa241550b", "patch": "@@ -1,9 +1,9 @@\n //! Functions dealing with attributes and meta items.\n \n use crate::ast;\n-use crate::ast::{AttrId, AttrItem, AttrKind, AttrStyle, Attribute};\n-use crate::ast::{Lit, LitKind};\n-use crate::ast::{MacArgs, MacArgsEq, MacDelimiter, MetaItem, MetaItemKind, NestedMetaItem};\n+use crate::ast::{AttrArgs, AttrArgsEq, AttrId, AttrItem, AttrKind, AttrStyle, Attribute};\n+use crate::ast::{DelimArgs, Lit, LitKind};\n+use crate::ast::{MacDelimiter, MetaItem, MetaItemKind, NestedMetaItem};\n use crate::ast::{Path, PathSegment};\n use crate::ptr::P;\n use crate::token::{self, CommentKind, Delimiter, Token};\n@@ -158,7 +158,7 @@ impl Attribute {\n \n     pub fn is_word(&self) -> bool {\n         if let AttrKind::Normal(normal) = &self.kind {\n-            matches!(normal.item.args, MacArgs::Empty)\n+            matches!(normal.item.args, AttrArgs::Empty)\n         } else {\n             false\n         }\n@@ -223,13 +223,13 @@ impl AttrItem {\n     pub fn meta(&self, span: Span) -> Option<MetaItem> {\n         Some(MetaItem {\n             path: self.path.clone(),\n-            kind: MetaItemKind::from_mac_args(&self.args)?,\n+            kind: MetaItemKind::from_attr_args(&self.args)?,\n             span,\n         })\n     }\n \n     pub fn meta_kind(&self) -> Option<MetaItemKind> {\n-        MetaItemKind::from_mac_args(&self.args)\n+        MetaItemKind::from_attr_args(&self.args)\n     }\n }\n \n@@ -390,7 +390,7 @@ pub fn mk_attr(\n     g: &AttrIdGenerator,\n     style: AttrStyle,\n     path: Path,\n-    args: MacArgs,\n+    args: AttrArgs,\n     span: Span,\n ) -> Attribute {\n     mk_attr_from_item(g, AttrItem { path, args, tokens: None }, None, style, span)\n@@ -413,12 +413,12 @@ pub fn mk_attr_from_item(\n \n /// Returns an inner attribute with the given value and span.\n pub fn mk_attr_inner(g: &AttrIdGenerator, item: MetaItem) -> Attribute {\n-    mk_attr(g, AttrStyle::Inner, item.path, item.kind.mac_args(item.span), item.span)\n+    mk_attr(g, AttrStyle::Inner, item.path, item.kind.attr_args(item.span), item.span)\n }\n \n /// Returns an outer attribute with the given value and span.\n pub fn mk_attr_outer(g: &AttrIdGenerator, item: MetaItem) -> Attribute {\n-    mk_attr(g, AttrStyle::Outer, item.path, item.kind.mac_args(item.span), item.span)\n+    mk_attr(g, AttrStyle::Outer, item.path, item.kind.attr_args(item.span), item.span)\n }\n \n pub fn mk_doc_comment(\n@@ -524,9 +524,9 @@ impl MetaItemKind {\n         }\n     }\n \n-    pub fn mac_args(&self, span: Span) -> MacArgs {\n+    pub fn attr_args(&self, span: Span) -> AttrArgs {\n         match self {\n-            MetaItemKind::Word => MacArgs::Empty,\n+            MetaItemKind::Word => AttrArgs::Empty,\n             MetaItemKind::NameValue(lit) => {\n                 let expr = P(ast::Expr {\n                     id: ast::DUMMY_NODE_ID,\n@@ -535,7 +535,7 @@ impl MetaItemKind {\n                     attrs: ast::AttrVec::new(),\n                     tokens: None,\n                 });\n-                MacArgs::Eq(span, MacArgsEq::Ast(expr))\n+                AttrArgs::Eq(span, AttrArgsEq::Ast(expr))\n             }\n             MetaItemKind::List(list) => {\n                 let mut tts = Vec::new();\n@@ -545,11 +545,11 @@ impl MetaItemKind {\n                     }\n                     tts.extend(item.token_trees())\n                 }\n-                MacArgs::Delimited(\n-                    DelimSpan::from_single(span),\n-                    MacDelimiter::Parenthesis,\n-                    TokenStream::new(tts),\n-                )\n+                AttrArgs::Delimited(DelimArgs {\n+                    dspan: DelimSpan::from_single(span),\n+                    delim: MacDelimiter::Parenthesis,\n+                    tokens: TokenStream::new(tts),\n+                })\n             }\n         }\n     }\n@@ -608,20 +608,22 @@ impl MetaItemKind {\n         }\n     }\n \n-    fn from_mac_args(args: &MacArgs) -> Option<MetaItemKind> {\n+    fn from_attr_args(args: &AttrArgs) -> Option<MetaItemKind> {\n         match args {\n-            MacArgs::Empty => Some(MetaItemKind::Word),\n-            MacArgs::Delimited(_, MacDelimiter::Parenthesis, tokens) => {\n-                MetaItemKind::list_from_tokens(tokens.clone())\n-            }\n-            MacArgs::Delimited(..) => None,\n-            MacArgs::Eq(_, MacArgsEq::Ast(expr)) => match expr.kind {\n+            AttrArgs::Empty => Some(MetaItemKind::Word),\n+            AttrArgs::Delimited(DelimArgs {\n+                dspan: _,\n+                delim: MacDelimiter::Parenthesis,\n+                tokens,\n+            }) => MetaItemKind::list_from_tokens(tokens.clone()),\n+            AttrArgs::Delimited(..) => None,\n+            AttrArgs::Eq(_, AttrArgsEq::Ast(expr)) => match expr.kind {\n                 ast::ExprKind::Lit(token_lit) => Some(MetaItemKind::NameValue(\n-                    Lit::from_token_lit(token_lit, expr.span).expect(\"token_lit in from_mac_args\"),\n+                    Lit::from_token_lit(token_lit, expr.span).expect(\"token_lit in from_attr_args\"),\n                 )),\n                 _ => None,\n             },\n-            MacArgs::Eq(_, MacArgsEq::Hir(lit)) => Some(MetaItemKind::NameValue(lit.clone())),\n+            AttrArgs::Eq(_, AttrArgsEq::Hir(lit)) => Some(MetaItemKind::NameValue(lit.clone())),\n         }\n     }\n "}, {"sha": "4e1dcb2842f67cf0c7d13004ec0d16360d9ff24e", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=589d843bd0ff72fd5a720bce63c2e6baa241550b", "patch": "@@ -367,23 +367,27 @@ pub fn visit_fn_sig<T: MutVisitor>(FnSig { header, decl, span }: &mut FnSig, vis\n }\n \n // No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n-pub fn visit_mac_args<T: MutVisitor>(args: &mut MacArgs, vis: &mut T) {\n+pub fn visit_attr_args<T: MutVisitor>(args: &mut AttrArgs, vis: &mut T) {\n     match args {\n-        MacArgs::Empty => {}\n-        MacArgs::Delimited(dspan, _delim, tokens) => {\n-            visit_delim_span(dspan, vis);\n-            visit_tts(tokens, vis);\n-        }\n-        MacArgs::Eq(eq_span, MacArgsEq::Ast(expr)) => {\n+        AttrArgs::Empty => {}\n+        AttrArgs::Delimited(args) => visit_delim_args(args, vis),\n+        AttrArgs::Eq(eq_span, AttrArgsEq::Ast(expr)) => {\n             vis.visit_span(eq_span);\n             vis.visit_expr(expr);\n         }\n-        MacArgs::Eq(_, MacArgsEq::Hir(lit)) => {\n+        AttrArgs::Eq(_, AttrArgsEq::Hir(lit)) => {\n             unreachable!(\"in literal form when visiting mac args eq: {:?}\", lit)\n         }\n     }\n }\n \n+// No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n+pub fn visit_delim_args<T: MutVisitor>(args: &mut DelimArgs, vis: &mut T) {\n+    let DelimArgs { dspan, delim: _, tokens } = args;\n+    visit_delim_span(dspan, vis);\n+    visit_tts(tokens, vis);\n+}\n+\n pub fn visit_delim_span<T: MutVisitor>(dspan: &mut DelimSpan, vis: &mut T) {\n     vis.visit_span(&mut dspan.open);\n     vis.visit_span(&mut dspan.close);\n@@ -601,7 +605,7 @@ pub fn noop_visit_attribute<T: MutVisitor>(attr: &mut Attribute, vis: &mut T) {\n             let NormalAttr { item: AttrItem { path, args, tokens }, tokens: attr_tokens } =\n                 &mut **normal;\n             vis.visit_path(path);\n-            visit_mac_args(args, vis);\n+            visit_attr_args(args, vis);\n             visit_lazy_tts(tokens, vis);\n             visit_lazy_tts(attr_tokens, vis);\n         }\n@@ -613,12 +617,12 @@ pub fn noop_visit_attribute<T: MutVisitor>(attr: &mut Attribute, vis: &mut T) {\n pub fn noop_visit_mac<T: MutVisitor>(mac: &mut MacCall, vis: &mut T) {\n     let MacCall { path, args, prior_type_ascription: _ } = mac;\n     vis.visit_path(path);\n-    visit_mac_args(args, vis);\n+    visit_delim_args(args, vis);\n }\n \n pub fn noop_visit_macro_def<T: MutVisitor>(macro_def: &mut MacroDef, vis: &mut T) {\n     let MacroDef { body, macro_rules: _ } = macro_def;\n-    visit_mac_args(body, vis);\n+    visit_delim_args(body, vis);\n }\n \n pub fn noop_visit_meta_list_item<T: MutVisitor>(li: &mut NestedMetaItem, vis: &mut T) {\n@@ -792,7 +796,7 @@ pub fn visit_nonterminal<T: MutVisitor>(nt: &mut token::Nonterminal, vis: &mut T\n         token::NtMeta(item) => {\n             let AttrItem { path, args, tokens } = item.deref_mut();\n             vis.visit_path(path);\n-            visit_mac_args(args, vis);\n+            visit_attr_args(args, vis);\n             visit_lazy_tts(tokens, vis);\n         }\n         token::NtPath(path) => vis.visit_path(path),"}, {"sha": "5c69e53521275bfbf91585cea786bcb362661c26", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=589d843bd0ff72fd5a720bce63c2e6baa241550b", "patch": "@@ -926,17 +926,17 @@ pub fn walk_vis<'a, V: Visitor<'a>>(visitor: &mut V, vis: &'a Visibility) {\n \n pub fn walk_attribute<'a, V: Visitor<'a>>(visitor: &mut V, attr: &'a Attribute) {\n     match &attr.kind {\n-        AttrKind::Normal(normal) => walk_mac_args(visitor, &normal.item.args),\n+        AttrKind::Normal(normal) => walk_attr_args(visitor, &normal.item.args),\n         AttrKind::DocComment(..) => {}\n     }\n }\n \n-pub fn walk_mac_args<'a, V: Visitor<'a>>(visitor: &mut V, args: &'a MacArgs) {\n+pub fn walk_attr_args<'a, V: Visitor<'a>>(visitor: &mut V, args: &'a AttrArgs) {\n     match args {\n-        MacArgs::Empty => {}\n-        MacArgs::Delimited(_dspan, _delim, _tokens) => {}\n-        MacArgs::Eq(_eq_span, MacArgsEq::Ast(expr)) => visitor.visit_expr(expr),\n-        MacArgs::Eq(_, MacArgsEq::Hir(lit)) => {\n+        AttrArgs::Empty => {}\n+        AttrArgs::Delimited(_) => {}\n+        AttrArgs::Eq(_eq_span, AttrArgsEq::Ast(expr)) => visitor.visit_expr(expr),\n+        AttrArgs::Eq(_, AttrArgsEq::Hir(lit)) => {\n             unreachable!(\"in literal form when walking mac args eq: {:?}\", lit)\n         }\n     }"}, {"sha": "3ab42497d6d4f0938a92362b4acf484fc03e748f", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=589d843bd0ff72fd5a720bce63c2e6baa241550b", "patch": "@@ -671,7 +671,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     kind: AttrKind::Normal(ptr::P(NormalAttr {\n                         item: AttrItem {\n                             path: Path::from_ident(Ident::new(sym::track_caller, span)),\n-                            args: MacArgs::Empty,\n+                            args: AttrArgs::Empty,\n                             tokens: None,\n                         },\n                         tokens: None,"}, {"sha": "99b3ac864ddfd5d17deebfdc700a80149fb696f2", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=589d843bd0ff72fd5a720bce63c2e6baa241550b", "patch": "@@ -470,7 +470,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 hir::ItemKind::TraitAlias(generics, bounds)\n             }\n             ItemKind::MacroDef(MacroDef { ref body, macro_rules }) => {\n-                let body = P(self.lower_mac_args(body));\n+                let body = P(self.lower_delim_args(body));\n                 let macro_kind = self.resolver.decl_macro_kind(self.local_def_id(id));\n                 hir::ItemKind::Macro(ast::MacroDef { body, macro_rules }, macro_kind)\n             }"}, {"sha": "ce81a0ae9596b31c331279f19abb4cac80eac6cf", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 11, "deletions": 25, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=589d843bd0ff72fd5a720bce63c2e6baa241550b", "patch": "@@ -911,7 +911,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             AttrKind::Normal(ref normal) => AttrKind::Normal(P(NormalAttr {\n                 item: AttrItem {\n                     path: normal.item.path.clone(),\n-                    args: self.lower_mac_args(&normal.item.args),\n+                    args: self.lower_attr_args(&normal.item.args),\n                     tokens: None,\n                 },\n                 tokens: None,\n@@ -931,32 +931,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n     }\n \n-    fn lower_mac_args(&self, args: &MacArgs) -> MacArgs {\n+    fn lower_attr_args(&self, args: &AttrArgs) -> AttrArgs {\n         match *args {\n-            MacArgs::Empty => MacArgs::Empty,\n-            MacArgs::Delimited(dspan, delim, ref tokens) => {\n-                // This is either a non-key-value attribute, or a `macro_rules!` body.\n-                // We either not have any nonterminals present (in the case of an attribute),\n-                // or have tokens available for all nonterminals in the case of a nested\n-                // `macro_rules`: e.g:\n-                //\n-                // ```rust\n-                // macro_rules! outer {\n-                //     ($e:expr) => {\n-                //         macro_rules! inner {\n-                //             () => { $e }\n-                //         }\n-                //     }\n-                // }\n-                // ```\n-                //\n-                // In both cases, we don't want to synthesize any tokens\n-                MacArgs::Delimited(dspan, delim, tokens.flattened())\n-            }\n+            AttrArgs::Empty => AttrArgs::Empty,\n+            AttrArgs::Delimited(ref args) => AttrArgs::Delimited(self.lower_delim_args(args)),\n             // This is an inert key-value attribute - it will never be visible to macros\n             // after it gets lowered to HIR. Therefore, we can extract literals to handle\n             // nonterminals in `#[doc]` (e.g. `#[doc = $e]`).\n-            MacArgs::Eq(eq_span, MacArgsEq::Ast(ref expr)) => {\n+            AttrArgs::Eq(eq_span, AttrArgsEq::Ast(ref expr)) => {\n                 // In valid code the value always ends up as a single literal. Otherwise, a dummy\n                 // literal suffices because the error is handled elsewhere.\n                 let lit = if let ExprKind::Lit(token_lit) = expr.kind {\n@@ -975,14 +957,18 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         span: DUMMY_SP,\n                     }\n                 };\n-                MacArgs::Eq(eq_span, MacArgsEq::Hir(lit))\n+                AttrArgs::Eq(eq_span, AttrArgsEq::Hir(lit))\n             }\n-            MacArgs::Eq(_, MacArgsEq::Hir(ref lit)) => {\n+            AttrArgs::Eq(_, AttrArgsEq::Hir(ref lit)) => {\n                 unreachable!(\"in literal form when lowering mac args eq: {:?}\", lit)\n             }\n         }\n     }\n \n+    fn lower_delim_args(&self, args: &DelimArgs) -> DelimArgs {\n+        DelimArgs { dspan: args.dspan, delim: args.delim, tokens: args.tokens.flattened() }\n+    }\n+\n     /// Given an associated type constraint like one of these:\n     ///\n     /// ```ignore (illustrative)"}, {"sha": "991f6e0ba224340024055395ae91454109117a40", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=589d843bd0ff72fd5a720bce63c2e6baa241550b", "patch": "@@ -11,10 +11,9 @@ use rustc_ast::tokenstream::{TokenStream, TokenTree};\n use rustc_ast::util::classify;\n use rustc_ast::util::comments::{gather_comments, Comment, CommentStyle};\n use rustc_ast::util::parser;\n-use rustc_ast::{self as ast, BlockCheckMode, Mutability, PatKind, RangeEnd, RangeSyntax};\n-use rustc_ast::{attr, BindingAnnotation, ByRef, Term};\n-use rustc_ast::{GenericArg, MacArgs, MacArgsEq};\n-use rustc_ast::{GenericBound, SelfKind, TraitBoundModifier};\n+use rustc_ast::{self as ast, AttrArgs, AttrArgsEq, BlockCheckMode, Mutability, PatKind};\n+use rustc_ast::{attr, BindingAnnotation, ByRef, DelimArgs, RangeEnd, RangeSyntax, Term};\n+use rustc_ast::{GenericArg, GenericBound, SelfKind, TraitBoundModifier};\n use rustc_ast::{InlineAsmOperand, InlineAsmRegOrRegClass};\n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_span::edition::Edition;\n@@ -466,26 +465,26 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n     fn print_attr_item(&mut self, item: &ast::AttrItem, span: Span) {\n         self.ibox(0);\n         match &item.args {\n-            MacArgs::Delimited(_, delim, tokens) => self.print_mac_common(\n+            AttrArgs::Delimited(DelimArgs { dspan: _, delim, tokens }) => self.print_mac_common(\n                 Some(MacHeader::Path(&item.path)),\n                 false,\n                 None,\n-                Some(delim.to_token()),\n+                delim.to_token(),\n                 tokens,\n                 true,\n                 span,\n             ),\n-            MacArgs::Empty => {\n+            AttrArgs::Empty => {\n                 self.print_path(&item.path, false, 0);\n             }\n-            MacArgs::Eq(_, MacArgsEq::Ast(expr)) => {\n+            AttrArgs::Eq(_, AttrArgsEq::Ast(expr)) => {\n                 self.print_path(&item.path, false, 0);\n                 self.space();\n                 self.word_space(\"=\");\n                 let token_str = self.expr_to_string(expr);\n                 self.word(token_str);\n             }\n-            MacArgs::Eq(_, MacArgsEq::Hir(lit)) => {\n+            AttrArgs::Eq(_, AttrArgsEq::Hir(lit)) => {\n                 self.print_path(&item.path, false, 0);\n                 self.space();\n                 self.word_space(\"=\");\n@@ -544,7 +543,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n                     None,\n                     false,\n                     None,\n-                    Some(*delim),\n+                    *delim,\n                     tts,\n                     convert_dollar_crate,\n                     dspan.entire(),\n@@ -570,12 +569,12 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n         header: Option<MacHeader<'_>>,\n         has_bang: bool,\n         ident: Option<Ident>,\n-        delim: Option<Delimiter>,\n+        delim: Delimiter,\n         tts: &TokenStream,\n         convert_dollar_crate: bool,\n         span: Span,\n     ) {\n-        if delim == Some(Delimiter::Brace) {\n+        if delim == Delimiter::Brace {\n             self.cbox(INDENT_UNIT);\n         }\n         match header {\n@@ -591,7 +590,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n             self.print_ident(ident);\n         }\n         match delim {\n-            Some(Delimiter::Brace) => {\n+            Delimiter::Brace => {\n                 if header.is_some() || has_bang || ident.is_some() {\n                     self.nbsp();\n                 }\n@@ -605,7 +604,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n                 let empty = tts.is_empty();\n                 self.bclose(span, empty);\n             }\n-            Some(delim) => {\n+            delim => {\n                 let token_str = self.token_kind_to_string(&token::OpenDelim(delim));\n                 self.word(token_str);\n                 self.ibox(0);\n@@ -614,11 +613,6 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n                 let token_str = self.token_kind_to_string(&token::CloseDelim(delim));\n                 self.word(token_str);\n             }\n-            None => {\n-                self.ibox(0);\n-                self.print_tts(tts, convert_dollar_crate);\n-                self.end();\n-            }\n         }\n     }\n \n@@ -639,8 +633,8 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n             Some(MacHeader::Keyword(kw)),\n             has_bang,\n             Some(*ident),\n-            macro_def.body.delim(),\n-            &macro_def.body.inner_tokens(),\n+            macro_def.body.delim.to_token(),\n+            &macro_def.body.tokens.clone(),\n             true,\n             sp,\n         );\n@@ -1230,8 +1224,8 @@ impl<'a> State<'a> {\n             Some(MacHeader::Path(&m.path)),\n             true,\n             None,\n-            m.args.delim(),\n-            &m.args.inner_tokens(),\n+            m.args.delim.to_token(),\n+            &m.args.tokens.clone(),\n             true,\n             m.span(),\n         );"}, {"sha": "8555c3593b3339f1d7a490d662de358d14b660e1", "filename": "compiler/rustc_builtin_macros/src/assert.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs?ref=589d843bd0ff72fd5a720bce63c2e6baa241550b", "patch": "@@ -4,7 +4,7 @@ use crate::edition_panic::use_panic_2021;\n use rustc_ast::ptr::P;\n use rustc_ast::token;\n use rustc_ast::tokenstream::{DelimSpan, TokenStream};\n-use rustc_ast::{Expr, ExprKind, MacArgs, MacCall, MacDelimiter, Path, PathSegment, UnOp};\n+use rustc_ast::{DelimArgs, Expr, ExprKind, MacCall, MacDelimiter, Path, PathSegment, UnOp};\n use rustc_ast_pretty::pprust;\n use rustc_errors::{Applicability, PResult};\n use rustc_expand::base::{DummyResult, ExtCtxt, MacEager, MacResult};\n@@ -54,11 +54,11 @@ pub fn expand_assert<'cx>(\n             call_site_span,\n             ExprKind::MacCall(P(MacCall {\n                 path: panic_path(),\n-                args: P(MacArgs::Delimited(\n-                    DelimSpan::from_single(call_site_span),\n-                    MacDelimiter::Parenthesis,\n+                args: P(DelimArgs {\n+                    dspan: DelimSpan::from_single(call_site_span),\n+                    delim: MacDelimiter::Parenthesis,\n                     tokens,\n-                )),\n+                }),\n                 prior_type_ascription: None,\n             })),\n         );"}, {"sha": "220b7a8ad0fcd236b3fb369ae2abfaebc7a0916f", "filename": "compiler/rustc_builtin_macros/src/assert/context.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs?ref=589d843bd0ff72fd5a720bce63c2e6baa241550b", "patch": "@@ -3,7 +3,7 @@ use rustc_ast::{\n     ptr::P,\n     token,\n     tokenstream::{DelimSpan, TokenStream, TokenTree},\n-    BinOpKind, BorrowKind, Expr, ExprKind, ItemKind, MacArgs, MacCall, MacDelimiter, MethodCall,\n+    BinOpKind, BorrowKind, DelimArgs, Expr, ExprKind, ItemKind, MacCall, MacDelimiter, MethodCall,\n     Mutability, Path, PathSegment, Stmt, StructRest, UnOp, UseTree, UseTreeKind, DUMMY_NODE_ID,\n };\n use rustc_ast_pretty::pprust;\n@@ -181,11 +181,11 @@ impl<'cx, 'a> Context<'cx, 'a> {\n             self.span,\n             ExprKind::MacCall(P(MacCall {\n                 path: panic_path,\n-                args: P(MacArgs::Delimited(\n-                    DelimSpan::from_single(self.span),\n-                    MacDelimiter::Parenthesis,\n-                    initial.into_iter().chain(captures).collect::<TokenStream>(),\n-                )),\n+                args: P(DelimArgs {\n+                    dspan: DelimSpan::from_single(self.span),\n+                    delim: MacDelimiter::Parenthesis,\n+                    tokens: initial.into_iter().chain(captures).collect::<TokenStream>(),\n+                }),\n                 prior_type_ascription: None,\n             })),\n         )"}, {"sha": "cae648cd11aff98dd8275acddb908459ff14c4a5", "filename": "compiler/rustc_builtin_macros/src/edition_panic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_builtin_macros%2Fsrc%2Fedition_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_builtin_macros%2Fsrc%2Fedition_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fedition_panic.rs?ref=589d843bd0ff72fd5a720bce63c2e6baa241550b", "patch": "@@ -58,11 +58,11 @@ fn expand<'cx>(\n                         .collect(),\n                     tokens: None,\n                 },\n-                args: P(MacArgs::Delimited(\n-                    DelimSpan::from_single(sp),\n-                    MacDelimiter::Parenthesis,\n-                    tts,\n-                )),\n+                args: P(DelimArgs {\n+                    dspan: DelimSpan::from_single(sp),\n+                    delim: MacDelimiter::Parenthesis,\n+                    tokens: tts,\n+                }),\n                 prior_type_ascription: None,\n             })),\n         ),"}, {"sha": "15dcc584738fba7d4346d7c6b04f85313ab7b8e9", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=589d843bd0ff72fd5a720bce63c2e6baa241550b", "patch": "@@ -11,9 +11,9 @@ use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter};\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n-use rustc_ast::{AssocItemKind, AstNodeWrapper, AttrStyle, AttrVec, ExprKind, ForeignItemKind};\n-use rustc_ast::{HasAttrs, HasNodeId};\n-use rustc_ast::{Inline, ItemKind, MacArgs, MacStmtStyle, MetaItemKind, ModKind};\n+use rustc_ast::{AssocItemKind, AstNodeWrapper, AttrArgs, AttrStyle, AttrVec, ExprKind};\n+use rustc_ast::{ForeignItemKind, HasAttrs, HasNodeId};\n+use rustc_ast::{Inline, ItemKind, MacStmtStyle, MetaItemKind, ModKind};\n use rustc_ast::{NestedMetaItem, NodeId, PatKind, StmtKind, TyKind};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::map_in_place::MapInPlace;\n@@ -654,15 +654,15 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         ExpandResult::Ready(match invoc.kind {\n             InvocationKind::Bang { mac, .. } => match ext {\n                 SyntaxExtensionKind::Bang(expander) => {\n-                    let Ok(tok_result) = expander.expand(self.cx, span, mac.args.inner_tokens()) else {\n+                    let Ok(tok_result) = expander.expand(self.cx, span, mac.args.tokens.clone()) else {\n                         return ExpandResult::Ready(fragment_kind.dummy(span));\n                     };\n                     self.parse_ast_fragment(tok_result, fragment_kind, &mac.path, span)\n                 }\n                 SyntaxExtensionKind::LegacyBang(expander) => {\n                     let prev = self.cx.current_expansion.prior_type_ascription;\n                     self.cx.current_expansion.prior_type_ascription = mac.prior_type_ascription;\n-                    let tok_result = expander.expand(self.cx, span, mac.args.inner_tokens());\n+                    let tok_result = expander.expand(self.cx, span, mac.args.tokens.clone());\n                     let result = if let Some(result) = fragment_kind.make_from(tok_result) {\n                         result\n                     } else {\n@@ -706,7 +706,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         _ => item.to_tokens(),\n                     };\n                     let attr_item = attr.unwrap_normal_item();\n-                    if let MacArgs::Eq(..) = attr_item.args {\n+                    if let AttrArgs::Eq(..) = attr_item.args {\n                         self.cx.span_err(span, \"key-value macro attributes are not supported\");\n                     }\n                     let inner_tokens = attr_item.args.inner_tokens();"}, {"sha": "5da410e41a7d9a69b37787f740ceef1841fee6e2", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=589d843bd0ff72fd5a720bce63c2e6baa241550b", "patch": "@@ -577,7 +577,7 @@ pub fn compile_declarative_macro(\n \n     // Parse the macro_rules! invocation\n     let (macro_rules, body) = match &def.kind {\n-        ast::ItemKind::MacroDef(def) => (def.macro_rules, def.body.inner_tokens()),\n+        ast::ItemKind::MacroDef(def) => (def.macro_rules, def.body.tokens.clone()),\n         _ => unreachable!(),\n     };\n "}, {"sha": "e49f112bf20a69a2ec01c6d29f346ae9504d3d47", "filename": "compiler/rustc_expand/src/parse/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_expand%2Fsrc%2Fparse%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_expand%2Fsrc%2Fparse%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fparse%2Ftests.rs?ref=589d843bd0ff72fd5a720bce63c2e6baa241550b", "patch": "@@ -291,7 +291,7 @@ fn ttdelim_span() {\n         .unwrap();\n \n         let tts: Vec<_> = match expr.kind {\n-            ast::ExprKind::MacCall(ref mac) => mac.args.inner_tokens().into_trees().collect(),\n+            ast::ExprKind::MacCall(ref mac) => mac.args.tokens.clone().into_trees().collect(),\n             _ => panic!(\"not a macro\"),\n         };\n "}, {"sha": "03bb5c1dfe45fbe9b2bdba1317858280237a0783", "filename": "compiler/rustc_expand/src/placeholders.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs?ref=589d843bd0ff72fd5a720bce63c2e6baa241550b", "patch": "@@ -16,7 +16,11 @@ pub fn placeholder(\n     fn mac_placeholder() -> P<ast::MacCall> {\n         P(ast::MacCall {\n             path: ast::Path { span: DUMMY_SP, segments: ThinVec::new(), tokens: None },\n-            args: P(ast::MacArgs::Empty),\n+            args: P(ast::DelimArgs {\n+                dspan: ast::tokenstream::DelimSpan::dummy(),\n+                delim: ast::MacDelimiter::Parenthesis,\n+                tokens: ast::tokenstream::TokenStream::new(Vec::new()),\n+            }),\n             prior_type_ascription: None,\n         })\n     }"}, {"sha": "8c779579a4f1dc435bb306ac8c9076e0b52de349", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=589d843bd0ff72fd5a720bce63c2e6baa241550b", "patch": "@@ -2030,10 +2030,10 @@ impl KeywordIdents {\n \n impl EarlyLintPass for KeywordIdents {\n     fn check_mac_def(&mut self, cx: &EarlyContext<'_>, mac_def: &ast::MacroDef) {\n-        self.check_tokens(cx, mac_def.body.inner_tokens());\n+        self.check_tokens(cx, mac_def.body.tokens.clone());\n     }\n     fn check_mac(&mut self, cx: &EarlyContext<'_>, mac: &ast::MacCall) {\n-        self.check_tokens(cx, mac.args.inner_tokens());\n+        self.check_tokens(cx, mac.args.tokens.clone());\n     }\n     fn check_ident(&mut self, cx: &EarlyContext<'_>, ident: Ident) {\n         self.check_ident_token(cx, UnderMacro(false), ident);"}, {"sha": "ba6a3aeb20935d5cbbbc2d3528c0079ac502e59c", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=589d843bd0ff72fd5a720bce63c2e6baa241550b", "patch": "@@ -400,7 +400,7 @@ define_tables! {\n     assoc_container: Table<DefIndex, ty::AssocItemContainer>,\n     // Slot is full when macro is macro_rules.\n     macro_rules: Table<DefIndex, ()>,\n-    macro_definition: Table<DefIndex, LazyValue<ast::MacArgs>>,\n+    macro_definition: Table<DefIndex, LazyValue<ast::DelimArgs>>,\n     proc_macro: Table<DefIndex, MacroKind>,\n     module_reexports: Table<DefIndex, LazyArray<ModChild>>,\n     deduced_param_attrs: Table<DefIndex, LazyArray<DeducedParamAttrs>>,"}, {"sha": "d6025248081dbcb33f724eb88acb7c1bf74647b6", "filename": "compiler/rustc_middle/src/ty/parameterized.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs?ref=589d843bd0ff72fd5a720bce63c2e6baa241550b", "patch": "@@ -70,7 +70,7 @@ trivially_parameterized_over_tcx! {\n     ty::adjustment::CoerceUnsizedInfo,\n     ty::fast_reject::SimplifiedTypeGen<DefId>,\n     rustc_ast::Attribute,\n-    rustc_ast::MacArgs,\n+    rustc_ast::DelimArgs,\n     rustc_attr::ConstStability,\n     rustc_attr::DefaultBodyStability,\n     rustc_attr::Deprecation,"}, {"sha": "b49a01d75ed547fa6fde8ef302336fe7b844b2aa", "filename": "compiler/rustc_parse/src/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flib.rs?ref=589d843bd0ff72fd5a720bce63c2e6baa241550b", "patch": "@@ -15,8 +15,7 @@ extern crate tracing;\n use rustc_ast as ast;\n use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n-use rustc_ast::Attribute;\n-use rustc_ast::{AttrItem, MetaItem};\n+use rustc_ast::{AttrItem, Attribute, MetaItem};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, Diagnostic, FatalError, Level, PResult};\n@@ -257,10 +256,12 @@ pub fn parse_cfg_attr(\n     parse_sess: &ParseSess,\n ) -> Option<(MetaItem, Vec<(AttrItem, Span)>)> {\n     match attr.get_normal_item().args {\n-        ast::MacArgs::Delimited(dspan, delim, ref tts) if !tts.is_empty() => {\n+        ast::AttrArgs::Delimited(ast::DelimArgs { dspan, delim, ref tokens })\n+            if !tokens.is_empty() =>\n+        {\n             let msg = \"wrong `cfg_attr` delimiters\";\n             crate::validate_attr::check_meta_bad_delim(parse_sess, dspan, delim, msg);\n-            match parse_in(parse_sess, tts.clone(), \"`cfg_attr` input\", |p| p.parse_cfg_attr()) {\n+            match parse_in(parse_sess, tokens.clone(), \"`cfg_attr` input\", |p| p.parse_cfg_attr()) {\n                 Ok(r) => return Some(r),\n                 Err(mut e) => {\n                     e.help(&format!(\"the valid syntax is `{}`\", CFG_ATTR_GRAMMAR_HELP))"}, {"sha": "ba73fbd3e12fb724d29dc7d3e667119b94058a05", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=589d843bd0ff72fd5a720bce63c2e6baa241550b", "patch": "@@ -1501,7 +1501,7 @@ impl<'a> Parser<'a> {\n             let lo = path.span;\n             let mac = P(MacCall {\n                 path,\n-                args: self.parse_mac_args()?,\n+                args: self.parse_delim_args()?,\n                 prior_type_ascription: self.last_type_ascription,\n             });\n             (lo.to(self.prev_token.span), ExprKind::MacCall(mac))"}, {"sha": "20b01f554f27a254c469d2e050a5cb42a079e883", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=589d843bd0ff72fd5a720bce63c2e6baa241550b", "patch": "@@ -13,7 +13,7 @@ use rustc_ast::{Async, Const, Defaultness, IsAuto, Mutability, Unsafe, UseTree,\n use rustc_ast::{BindingAnnotation, Block, FnDecl, FnSig, Param, SelfKind};\n use rustc_ast::{EnumDef, FieldDef, Generics, TraitRef, Ty, TyKind, Variant, VariantData};\n use rustc_ast::{FnHeader, ForeignItem, Path, PathSegment, Visibility, VisibilityKind};\n-use rustc_ast::{MacArgs, MacCall, MacDelimiter};\n+use rustc_ast::{MacCall, MacDelimiter};\n use rustc_ast_pretty::pprust;\n use rustc_errors::{struct_span_err, Applicability, IntoDiagnostic, PResult, StashKey};\n use rustc_span::edition::Edition;\n@@ -471,7 +471,7 @@ impl<'a> Parser<'a> {\n     fn parse_item_macro(&mut self, vis: &Visibility) -> PResult<'a, MacCall> {\n         let path = self.parse_path(PathStyle::Mod)?; // `foo::bar`\n         self.expect(&token::Not)?; // `!`\n-        match self.parse_mac_args() {\n+        match self.parse_delim_args() {\n             // `( .. )` or `[ .. ]` (followed by `;`), or `{ .. }`.\n             Ok(args) => {\n                 self.eat_semi_for_macro_if_needed(&args);\n@@ -1867,7 +1867,7 @@ impl<'a> Parser<'a> {\n     fn parse_item_decl_macro(&mut self, lo: Span) -> PResult<'a, ItemInfo> {\n         let ident = self.parse_ident()?;\n         let body = if self.check(&token::OpenDelim(Delimiter::Brace)) {\n-            self.parse_mac_args()? // `MacBody`\n+            self.parse_delim_args()? // `MacBody`\n         } else if self.check(&token::OpenDelim(Delimiter::Parenthesis)) {\n             let params = self.parse_token_tree(); // `MacParams`\n             let pspan = params.span();\n@@ -1880,7 +1880,7 @@ impl<'a> Parser<'a> {\n             let arrow = TokenTree::token_alone(token::FatArrow, pspan.between(bspan)); // `=>`\n             let tokens = TokenStream::new(vec![params, arrow, body]);\n             let dspan = DelimSpan::from_pair(pspan.shrink_to_lo(), bspan.shrink_to_hi());\n-            P(MacArgs::Delimited(dspan, MacDelimiter::Brace, tokens))\n+            P(DelimArgs { dspan, delim: MacDelimiter::Brace, tokens })\n         } else {\n             return self.unexpected();\n         };\n@@ -1935,7 +1935,7 @@ impl<'a> Parser<'a> {\n                 .emit();\n         }\n \n-        let body = self.parse_mac_args()?;\n+        let body = self.parse_delim_args()?;\n         self.eat_semi_for_macro_if_needed(&body);\n         self.complain_if_pub_macro(vis, true);\n \n@@ -1974,14 +1974,14 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn eat_semi_for_macro_if_needed(&mut self, args: &MacArgs) {\n+    fn eat_semi_for_macro_if_needed(&mut self, args: &DelimArgs) {\n         if args.need_semicolon() && !self.eat(&token::Semi) {\n             self.report_invalid_macro_expansion_item(args);\n         }\n     }\n \n-    fn report_invalid_macro_expansion_item(&self, args: &MacArgs) {\n-        let span = args.span().expect(\"undelimited macro call\");\n+    fn report_invalid_macro_expansion_item(&self, args: &DelimArgs) {\n+        let span = args.dspan.entire();\n         let mut err = self.struct_span_err(\n             span,\n             \"macros that expand to items must be delimited with braces or followed by a semicolon\",\n@@ -1990,10 +1990,7 @@ impl<'a> Parser<'a> {\n         // macros within the same crate (that we can fix), which is sad.\n         if !span.from_expansion() {\n             if self.unclosed_delims.is_empty() {\n-                let DelimSpan { open, close } = match args {\n-                    MacArgs::Empty | MacArgs::Eq(..) => unreachable!(),\n-                    MacArgs::Delimited(dspan, ..) => *dspan,\n-                };\n+                let DelimSpan { open, close } = args.dspan;\n                 err.multipart_suggestion(\n                     \"change the delimiters to curly braces\",\n                     vec![(open, \"{\".to_string()), (close, '}'.to_string())],"}, {"sha": "8878c404c58f4014500238a0353ca2abfc106f6d", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=589d843bd0ff72fd5a720bce63c2e6baa241550b", "patch": "@@ -25,8 +25,8 @@ use rustc_ast::tokenstream::{TokenStream, TokenTree};\n use rustc_ast::util::case::Case;\n use rustc_ast::AttrId;\n use rustc_ast::DUMMY_NODE_ID;\n-use rustc_ast::{self as ast, AnonConst, AttrStyle, AttrVec, Const, Extern};\n-use rustc_ast::{Async, Expr, ExprKind, MacArgs, MacArgsEq, MacDelimiter, Mutability, StrLit};\n+use rustc_ast::{self as ast, AnonConst, AttrStyle, AttrVec, Const, DelimArgs, Extern};\n+use rustc_ast::{Async, AttrArgs, AttrArgsEq, Expr, ExprKind, MacDelimiter, Mutability, StrLit};\n use rustc_ast::{HasAttrs, HasTokens, Unsafe, Visibility, VisibilityKind};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashMap;\n@@ -1249,39 +1249,40 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn parse_mac_args(&mut self) -> PResult<'a, P<MacArgs>> {\n-        self.parse_mac_args_common(true).map(P)\n+    fn parse_delim_args(&mut self) -> PResult<'a, P<DelimArgs>> {\n+        if let Some(args) = self.parse_delim_args_inner() { Ok(P(args)) } else { self.unexpected() }\n     }\n \n-    fn parse_attr_args(&mut self) -> PResult<'a, MacArgs> {\n-        self.parse_mac_args_common(false)\n+    fn parse_attr_args(&mut self) -> PResult<'a, AttrArgs> {\n+        Ok(if let Some(args) = self.parse_delim_args_inner() {\n+            AttrArgs::Delimited(args)\n+        } else {\n+            if self.eat(&token::Eq) {\n+                let eq_span = self.prev_token.span;\n+                AttrArgs::Eq(eq_span, AttrArgsEq::Ast(self.parse_expr_force_collect()?))\n+            } else {\n+                AttrArgs::Empty\n+            }\n+        })\n     }\n \n-    fn parse_mac_args_common(&mut self, delimited_only: bool) -> PResult<'a, MacArgs> {\n-        Ok(\n-            if self.check(&token::OpenDelim(Delimiter::Parenthesis))\n-                || self.check(&token::OpenDelim(Delimiter::Bracket))\n-                || self.check(&token::OpenDelim(Delimiter::Brace))\n-            {\n-                match self.parse_token_tree() {\n-                    TokenTree::Delimited(dspan, delim, tokens) =>\n-                    // We've confirmed above that there is a delimiter so unwrapping is OK.\n-                    {\n-                        MacArgs::Delimited(dspan, MacDelimiter::from_token(delim).unwrap(), tokens)\n-                    }\n-                    _ => unreachable!(),\n-                }\n-            } else if !delimited_only {\n-                if self.eat(&token::Eq) {\n-                    let eq_span = self.prev_token.span;\n-                    MacArgs::Eq(eq_span, MacArgsEq::Ast(self.parse_expr_force_collect()?))\n-                } else {\n-                    MacArgs::Empty\n-                }\n-            } else {\n-                return self.unexpected();\n-            },\n-        )\n+    fn parse_delim_args_inner(&mut self) -> Option<DelimArgs> {\n+        if self.check(&token::OpenDelim(Delimiter::Parenthesis))\n+            || self.check(&token::OpenDelim(Delimiter::Bracket))\n+            || self.check(&token::OpenDelim(Delimiter::Brace))\n+        {\n+            match self.parse_token_tree() {\n+                // We've confirmed above that there is a delimiter so unwrapping is OK.\n+                TokenTree::Delimited(dspan, delim, tokens) => Some(DelimArgs {\n+                    dspan,\n+                    delim: MacDelimiter::from_token(delim).unwrap(),\n+                    tokens,\n+                }),\n+                _ => unreachable!(),\n+            }\n+        } else {\n+            None\n+        }\n     }\n \n     fn parse_or_use_outer_attributes("}, {"sha": "bf52febb1076d3a0d9844e48cde0020cbe81643b", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=589d843bd0ff72fd5a720bce63c2e6baa241550b", "patch": "@@ -693,7 +693,7 @@ impl<'a> Parser<'a> {\n     /// Parse macro invocation\n     fn parse_pat_mac_invoc(&mut self, path: Path) -> PResult<'a, PatKind> {\n         self.bump();\n-        let args = self.parse_mac_args()?;\n+        let args = self.parse_delim_args()?;\n         let mac = P(MacCall { path, args, prior_type_ascription: self.last_type_ascription });\n         Ok(PatKind::MacCall(mac))\n     }"}, {"sha": "73de86820d852847da4e60f4b3e093da5a305947", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=589d843bd0ff72fd5a720bce63c2e6baa241550b", "patch": "@@ -167,14 +167,13 @@ impl<'a> Parser<'a> {\n     /// Parses a statement macro `mac!(args)` provided a `path` representing `mac`.\n     /// At this point, the `!` token after the path has already been eaten.\n     fn parse_stmt_mac(&mut self, lo: Span, attrs: AttrVec, path: ast::Path) -> PResult<'a, Stmt> {\n-        let args = self.parse_mac_args()?;\n-        let delim = args.delim();\n+        let args = self.parse_delim_args()?;\n+        let delim = args.delim.to_token();\n         let hi = self.prev_token.span;\n \n         let style = match delim {\n-            Some(Delimiter::Brace) => MacStmtStyle::Braces,\n-            Some(_) => MacStmtStyle::NoBraces,\n-            None => unreachable!(),\n+            Delimiter::Brace => MacStmtStyle::Braces,\n+            _ => MacStmtStyle::NoBraces,\n         };\n \n         let mac = P(MacCall { path, args, prior_type_ascription: self.last_type_ascription });"}, {"sha": "fecf67cb596edfa2e6bc047586f55c3d153f9182", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=589d843bd0ff72fd5a720bce63c2e6baa241550b", "patch": "@@ -665,7 +665,7 @@ impl<'a> Parser<'a> {\n             // Macro invocation in type position\n             Ok(TyKind::MacCall(P(MacCall {\n                 path,\n-                args: self.parse_mac_args()?,\n+                args: self.parse_delim_args()?,\n                 prior_type_ascription: self.last_type_ascription,\n             })))\n         } else if allow_plus == AllowPlus::Yes && self.check_plus() {"}, {"sha": "e2f95d74a3d2293c6cb7dba3e3c917798655a8ea", "filename": "compiler/rustc_parse/src/validate_attr.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_parse%2Fsrc%2Fvalidate_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589d843bd0ff72fd5a720bce63c2e6baa241550b/compiler%2Frustc_parse%2Fsrc%2Fvalidate_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fvalidate_attr.rs?ref=589d843bd0ff72fd5a720bce63c2e6baa241550b", "patch": "@@ -3,7 +3,8 @@\n use crate::parse_in;\n \n use rustc_ast::tokenstream::DelimSpan;\n-use rustc_ast::{self as ast, Attribute, MacArgs, MacArgsEq, MacDelimiter, MetaItem, MetaItemKind};\n+use rustc_ast::MetaItemKind;\n+use rustc_ast::{self as ast, AttrArgs, AttrArgsEq, Attribute, DelimArgs, MacDelimiter, MetaItem};\n use rustc_ast_pretty::pprust;\n use rustc_errors::{Applicability, FatalError, PResult};\n use rustc_feature::{AttributeTemplate, BuiltinAttribute, BUILTIN_ATTRIBUTE_MAP};\n@@ -24,7 +25,7 @@ pub fn check_meta(sess: &ParseSess, attr: &Attribute) {\n         Some(BuiltinAttribute { name, template, .. }) if *name != sym::rustc_dummy => {\n             check_builtin_attribute(sess, attr, *name, *template)\n         }\n-        _ if let MacArgs::Eq(..) = attr.get_normal_item().args => {\n+        _ if let AttrArgs::Eq(..) = attr.get_normal_item().args => {\n             // All key-value attributes are restricted to meta-item syntax.\n             parse_meta(sess, attr)\n                 .map_err(|mut err| {\n@@ -42,13 +43,13 @@ pub fn parse_meta<'a>(sess: &'a ParseSess, attr: &Attribute) -> PResult<'a, Meta\n         span: attr.span,\n         path: item.path.clone(),\n         kind: match &item.args {\n-            MacArgs::Empty => MetaItemKind::Word,\n-            MacArgs::Delimited(dspan, delim, t) => {\n+            AttrArgs::Empty => MetaItemKind::Word,\n+            AttrArgs::Delimited(DelimArgs { dspan, delim, tokens }) => {\n                 check_meta_bad_delim(sess, *dspan, *delim, \"wrong meta list delimiters\");\n-                let nmis = parse_in(sess, t.clone(), \"meta list\", |p| p.parse_meta_seq_top())?;\n+                let nmis = parse_in(sess, tokens.clone(), \"meta list\", |p| p.parse_meta_seq_top())?;\n                 MetaItemKind::List(nmis)\n             }\n-            MacArgs::Eq(_, MacArgsEq::Ast(expr)) => {\n+            AttrArgs::Eq(_, AttrArgsEq::Ast(expr)) => {\n                 if let ast::ExprKind::Lit(token_lit) = expr.kind\n                     && let Ok(lit) = ast::Lit::from_token_lit(token_lit, expr.span)\n                 {\n@@ -78,7 +79,7 @@ pub fn parse_meta<'a>(sess: &'a ParseSess, attr: &Attribute) -> PResult<'a, Meta\n                     return Err(err);\n                 }\n             }\n-            MacArgs::Eq(_, MacArgsEq::Hir(lit)) => MetaItemKind::NameValue(lit.clone()),\n+            AttrArgs::Eq(_, AttrArgsEq::Hir(lit)) => MetaItemKind::NameValue(lit.clone()),\n         },\n     })\n }"}, {"sha": "35e2720fdff897f8bcbe66da633ad652a9996dca", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/589d843bd0ff72fd5a720bce63c2e6baa241550b/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589d843bd0ff72fd5a720bce63c2e6baa241550b/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=589d843bd0ff72fd5a720bce63c2e6baa241550b", "patch": "@@ -580,7 +580,7 @@ pub(super) fn display_macro_source(\n     def_id: DefId,\n     vis: ty::Visibility<DefId>,\n ) -> String {\n-    let tts: Vec<_> = def.body.inner_tokens().into_trees().collect();\n+    let tts: Vec<_> = def.body.tokens.clone().into_trees().collect();\n     // Extract the spans of all matchers. They represent the \"interface\" of the macro.\n     let matchers = tts.chunks(4).map(|arm| &arm[0]);\n "}, {"sha": "b2fe0386f945dd82f8531f7643a6e5c06869f75f", "filename": "src/tools/clippy/clippy_lints/src/crate_in_macro_def.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/589d843bd0ff72fd5a720bce63c2e6baa241550b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcrate_in_macro_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589d843bd0ff72fd5a720bce63c2e6baa241550b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcrate_in_macro_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcrate_in_macro_def.rs?ref=589d843bd0ff72fd5a720bce63c2e6baa241550b", "patch": "@@ -55,7 +55,7 @@ impl EarlyLintPass for CrateInMacroDef {\n         if_chain! {\n             if item.attrs.iter().any(is_macro_export);\n             if let ItemKind::MacroDef(macro_def) = &item.kind;\n-            let tts = macro_def.body.inner_tokens();\n+            let tts = macro_def.body.tokens.clone();\n             if let Some(span) = contains_unhygienic_crate_reference(&tts);\n             then {\n                 span_lint_and_sugg("}, {"sha": "87b378bfd1982517ad2d9e53b600c71ff1e5ff14", "filename": "src/tools/clippy/clippy_utils/src/ast_utils.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/589d843bd0ff72fd5a720bce63c2e6baa241550b/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589d843bd0ff72fd5a720bce63c2e6baa241550b/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs?ref=589d843bd0ff72fd5a720bce63c2e6baa241550b", "patch": "@@ -388,7 +388,7 @@ pub fn eq_item_kind(l: &ItemKind, r: &ItemKind) -> bool {\n                 && over(li, ri, |l, r| eq_item(l, r, eq_assoc_item_kind))\n         },\n         (MacCall(l), MacCall(r)) => eq_mac_call(l, r),\n-        (MacroDef(l), MacroDef(r)) => l.macro_rules == r.macro_rules && eq_mac_args(&l.body, &r.body),\n+        (MacroDef(l), MacroDef(r)) => l.macro_rules == r.macro_rules && eq_delim_args(&l.body, &r.body),\n         _ => false,\n     }\n }\n@@ -709,26 +709,30 @@ pub fn eq_assoc_constraint(l: &AssocConstraint, r: &AssocConstraint) -> bool {\n }\n \n pub fn eq_mac_call(l: &MacCall, r: &MacCall) -> bool {\n-    eq_path(&l.path, &r.path) && eq_mac_args(&l.args, &r.args)\n+    eq_path(&l.path, &r.path) && eq_delim_args(&l.args, &r.args)\n }\n \n pub fn eq_attr(l: &Attribute, r: &Attribute) -> bool {\n     use AttrKind::*;\n     l.style == r.style\n         && match (&l.kind, &r.kind) {\n             (DocComment(l1, l2), DocComment(r1, r2)) => l1 == r1 && l2 == r2,\n-            (Normal(l), Normal(r)) => eq_path(&l.item.path, &r.item.path) && eq_mac_args(&l.item.args, &r.item.args),\n+            (Normal(l), Normal(r)) => eq_path(&l.item.path, &r.item.path) && eq_attr_args(&l.item.args, &r.item.args),\n             _ => false,\n         }\n }\n \n-pub fn eq_mac_args(l: &MacArgs, r: &MacArgs) -> bool {\n-    use MacArgs::*;\n+pub fn eq_attr_args(l: &AttrArgs, r: &AttrArgs) -> bool {\n+    use AttrArgs::*;\n     match (l, r) {\n         (Empty, Empty) => true,\n-        (Delimited(_, ld, lts), Delimited(_, rd, rts)) => ld == rd && lts.eq_unspanned(rts),\n-        (Eq(_, MacArgsEq::Ast(le)), Eq(_, MacArgsEq::Ast(re))) => eq_expr(le, re),\n-        (Eq(_, MacArgsEq::Hir(ll)), Eq(_, MacArgsEq::Hir(rl))) => ll.kind == rl.kind,\n+        (Delimited(la), Delimited(ra)) => eq_delim_args(la, ra),\n+        (Eq(_, AttrArgsEq::Ast(le)), Eq(_, AttrArgsEq::Ast(re))) => eq_expr(le, re),\n+        (Eq(_, AttrArgsEq::Hir(ll)), Eq(_, AttrArgsEq::Hir(rl))) => ll.kind == rl.kind,\n         _ => false,\n     }\n }\n+\n+pub fn eq_delim_args(l: &DelimArgs, r: &DelimArgs) -> bool {\n+    l.delim == r.delim && l.tokens.eq_unspanned(&r.tokens)\n+}"}, {"sha": "d5611082f01030048acbfca4e587271d777a3d8a", "filename": "src/tools/rustfmt/src/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/589d843bd0ff72fd5a720bce63c2e6baa241550b/src%2Ftools%2Frustfmt%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589d843bd0ff72fd5a720bce63c2e6baa241550b/src%2Ftools%2Frustfmt%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fexpr.rs?ref=589d843bd0ff72fd5a720bce63c2e6baa241550b", "patch": "@@ -1341,7 +1341,7 @@ pub(crate) fn can_be_overflowed_expr(\n         }\n         ast::ExprKind::MacCall(ref mac) => {\n             match (\n-                rustc_ast::ast::MacDelimiter::from_token(mac.args.delim().unwrap()),\n+                rustc_ast::ast::MacDelimiter::from_token(mac.args.delim.to_token()),\n                 context.config.overflow_delimited_expr(),\n             ) {\n                 (Some(ast::MacDelimiter::Bracket), true)"}, {"sha": "df949388037880dfbf3dbde847b83807561b1269", "filename": "src/tools/rustfmt/src/macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/589d843bd0ff72fd5a720bce63c2e6baa241550b/src%2Ftools%2Frustfmt%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589d843bd0ff72fd5a720bce63c2e6baa241550b/src%2Ftools%2Frustfmt%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fmacros.rs?ref=589d843bd0ff72fd5a720bce63c2e6baa241550b", "patch": "@@ -208,7 +208,7 @@ fn rewrite_macro_inner(\n         original_style\n     };\n \n-    let ts = mac.args.inner_tokens();\n+    let ts = mac.args.tokens.clone();\n     let has_comment = contains_comment(context.snippet(mac.span()));\n     if ts.is_empty() && !has_comment {\n         return match style {\n@@ -392,7 +392,7 @@ pub(crate) fn rewrite_macro_def(\n         return snippet;\n     }\n \n-    let ts = def.body.inner_tokens();\n+    let ts = def.body.tokens.clone();\n     let mut parser = MacroParser::new(ts.into_trees());\n     let parsed_def = match parser.parse() {\n         Some(def) => def,\n@@ -1087,7 +1087,7 @@ pub(crate) fn convert_try_mac(\n ) -> Option<ast::Expr> {\n     let path = &pprust::path_to_string(&mac.path);\n     if path == \"try\" || path == \"r#try\" {\n-        let ts = mac.args.inner_tokens();\n+        let ts = mac.args.tokens.clone();\n \n         Some(ast::Expr {\n             id: ast::NodeId::root(), // dummy value"}, {"sha": "01edfab36547cc615f6f0f8e2e3a7de60cc78d9d", "filename": "src/tools/rustfmt/src/parse/macros/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/589d843bd0ff72fd5a720bce63c2e6baa241550b/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589d843bd0ff72fd5a720bce63c2e6baa241550b/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Fasm.rs?ref=589d843bd0ff72fd5a720bce63c2e6baa241550b", "patch": "@@ -5,7 +5,7 @@ use crate::rewrite::RewriteContext;\n \n #[allow(dead_code)]\n pub(crate) fn parse_asm(context: &RewriteContext<'_>, mac: &ast::MacCall) -> Option<AsmArgs> {\n-    let ts = mac.args.inner_tokens();\n+    let ts = mac.args.tokens.clone();\n     let mut parser = super::build_parser(context, ts);\n     parse_asm_args(&mut parser, context.parse_sess.inner(), mac.span(), false).ok()\n }"}, {"sha": "ace1a76b3fe7d12babfb0530b105279e7b81abe2", "filename": "src/tools/rustfmt/src/parse/macros/cfg_if.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/589d843bd0ff72fd5a720bce63c2e6baa241550b/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Fcfg_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/589d843bd0ff72fd5a720bce63c2e6baa241550b/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Fcfg_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Fcfg_if.rs?ref=589d843bd0ff72fd5a720bce63c2e6baa241550b", "patch": "@@ -23,7 +23,7 @@ fn parse_cfg_if_inner<'a>(\n     sess: &'a ParseSess,\n     mac: &'a ast::MacCall,\n ) -> Result<Vec<ast::Item>, &'static str> {\n-    let ts = mac.args.inner_tokens();\n+    let ts = mac.args.tokens.clone();\n     let mut parser = build_stream_parser(sess.inner(), ts);\n \n     let mut items = vec![];"}]}