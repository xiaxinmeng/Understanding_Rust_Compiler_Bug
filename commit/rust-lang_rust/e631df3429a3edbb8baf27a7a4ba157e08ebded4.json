{"sha": "e631df3429a3edbb8baf27a7a4ba157e08ebded4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2MzFkZjM0MjlhM2VkYmI4YmFmMjdhN2E0YmExNTdlMDhlYmRlZDQ=", "commit": {"author": {"name": "Roland Tanglao", "email": "roland@rolandtanglao.com", "date": "2012-01-17T06:24:56Z"}, "committer": {"name": "Roland Tanglao", "email": "roland@rolandtanglao.com", "date": "2012-01-17T06:24:56Z"}, "message": "add spaces before newlines in rustdocs", "tree": {"sha": "0332fe7a910da77bca604a552feac2b0f2331c18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0332fe7a910da77bca604a552feac2b0f2331c18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e631df3429a3edbb8baf27a7a4ba157e08ebded4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e631df3429a3edbb8baf27a7a4ba157e08ebded4", "html_url": "https://github.com/rust-lang/rust/commit/e631df3429a3edbb8baf27a7a4ba157e08ebded4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e631df3429a3edbb8baf27a7a4ba157e08ebded4/comments", "author": {"login": "rtanglao", "id": 45195, "node_id": "MDQ6VXNlcjQ1MTk1", "avatar_url": "https://avatars.githubusercontent.com/u/45195?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rtanglao", "html_url": "https://github.com/rtanglao", "followers_url": "https://api.github.com/users/rtanglao/followers", "following_url": "https://api.github.com/users/rtanglao/following{/other_user}", "gists_url": "https://api.github.com/users/rtanglao/gists{/gist_id}", "starred_url": "https://api.github.com/users/rtanglao/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rtanglao/subscriptions", "organizations_url": "https://api.github.com/users/rtanglao/orgs", "repos_url": "https://api.github.com/users/rtanglao/repos", "events_url": "https://api.github.com/users/rtanglao/events{/privacy}", "received_events_url": "https://api.github.com/users/rtanglao/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rtanglao", "id": 45195, "node_id": "MDQ6VXNlcjQ1MTk1", "avatar_url": "https://avatars.githubusercontent.com/u/45195?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rtanglao", "html_url": "https://github.com/rtanglao", "followers_url": "https://api.github.com/users/rtanglao/followers", "following_url": "https://api.github.com/users/rtanglao/following{/other_user}", "gists_url": "https://api.github.com/users/rtanglao/gists{/gist_id}", "starred_url": "https://api.github.com/users/rtanglao/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rtanglao/subscriptions", "organizations_url": "https://api.github.com/users/rtanglao/orgs", "repos_url": "https://api.github.com/users/rtanglao/repos", "events_url": "https://api.github.com/users/rtanglao/events{/privacy}", "received_events_url": "https://api.github.com/users/rtanglao/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca55a4b421195d2432ee8e78d34676cb33f896c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca55a4b421195d2432ee8e78d34676cb33f896c8", "html_url": "https://github.com/rust-lang/rust/commit/ca55a4b421195d2432ee8e78d34676cb33f896c8"}], "stats": {"total": 80, "additions": 40, "deletions": 40}, "files": [{"sha": "b92536db9946611b4352bbac5a4ccbe42ac82da6", "filename": "src/libcore/char.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e631df3429a3edbb8baf27a7a4ba157e08ebded4/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e631df3429a3edbb8baf27a7a4ba157e08ebded4/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=e631df3429a3edbb8baf27a7a4ba157e08ebded4", "patch": "@@ -45,24 +45,24 @@ import is_XID_continue = unicode::derived_property::XID_Continue;\n \n \n #[doc(\n-  brief = \"Indicates whether a character is in lower case, defined\\\n+  brief = \"Indicates whether a character is in lower case, defined \\\n            in terms of the Unicode General Category 'Ll'.\"\n )]\n pure fn is_lowercase(c: char) -> bool {\n     ret unicode::general_category::Ll(c);\n }\n \n #[doc(\n-  brief = \"Indicates whether a character is in upper case, defined\\\n+  brief = \"Indicates whether a character is in upper case, defined \\\n            in terms of the Unicode General Category 'Lu'.\"\n )]\n pure fn is_uppercase(c: char) -> bool {\n     ret unicode::general_category::Lu(c);\n }\n \n #[doc(\n-  brief = \"Indicates whether a character is whitespace, defined in\\\n-           terms of the Unicode General Categories 'Zs', 'Zl', 'Zp'\\\n+  brief = \"Indicates whether a character is whitespace, defined in \\\n+           terms of the Unicode General Categories 'Zs', 'Zl', 'Zp' \\\n            additional 'Cc'-category control codes in the range [0x09, 0x0d]\"\n )]\n pure fn is_whitespace(c: char) -> bool {\n@@ -73,8 +73,8 @@ pure fn is_whitespace(c: char) -> bool {\n }\n \n #[doc(\n-  brief = \"Indicates whether a character is alphanumeric, defined\\\n-            in terms of the Unicode General Categories 'Nd',\\\n+  brief = \"Indicates whether a character is alphanumeric, defined \\\n+            in terms of the Unicode General Categories 'Nd', \\\n             'Nl', 'No' and the Derived Core Property 'Alphabetic'.\"\n )]\n pure fn is_alphanumeric(c: char) -> bool {\n@@ -86,10 +86,10 @@ pure fn is_alphanumeric(c: char) -> bool {\n \n \n #[doc(\n-  brief = \"Convert a char to the corresponding digit.\\\n+  brief = \"Convert a char to the corresponding digit. \\\n            Safety note: This function fails if `c` is not a valid char\",\n-  return = \"If `c` is between '0' and '9', the corresponding value\\\n-            between 0 and 9. If `c` is 'a' or 'A', 10. If `c` is\\\n+  return = \"If `c` is between '0' and '9', the corresponding value \\\n+            between 0 and 9. If `c` is 'a' or 'A', 10. If `c` is \\\n             'b' or 'B', 11, etc.\"\n )]\n pure fn to_digit(c: char) -> u8 unsafe {\n@@ -100,7 +100,7 @@ pure fn to_digit(c: char) -> u8 unsafe {\n }\n \n #[doc(\n-  brief = \"Convert a char to the corresponding digit. Returns none when\\\n+  brief = \"Convert a char to the corresponding digit. Returns none when \\\n            character is not a valid hexadecimal digit.\"\n )]\n pure fn maybe_digit(c: char) -> option::t<u8> {"}, {"sha": "211741aa3c58ed9b6f22f3c9ad46162d1d6a6ef9", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e631df3429a3edbb8baf27a7a4ba157e08ebded4/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e631df3429a3edbb8baf27a7a4ba157e08ebded4/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=e631df3429a3edbb8baf27a7a4ba157e08ebded4", "patch": "@@ -1,19 +1,19 @@\n #[doc(\n   brief = \"Communication between tasks\",\n-  desc  = \"Communication between tasks is facilitated by ports (in the\\\n-           receiving task), and channels (in the sending task). Any\\\n-           number of channels may feed into a single port.\\\n-           Ports and channels may only transmit values of unique\\\n-           types; that is, values that are statically guaranteed to\\\n-           be accessed by a single 'owner' at a time.  Unique types\\\n-           include scalars, vectors, strings, and records, tags,\\\n-           tuples and unique boxes (~T) thereof. Most notably,\\\n-           shared boxes (@T) may not be transmitted across channels.\\\n-           Example:\\\n-               let p = comm::port();\\\n-               task::spawn(comm::chan(p), fn (c: chan<str>) {\\\n-                   comm::send(c, \\\"Hello, World\\\");\\\n-               });\\\n+  desc  = \"Communication between tasks is facilitated by ports (in the \\\n+           receiving task), and channels (in the sending task). Any \\\n+           number of channels may feed into a single port. \\\n+           Ports and channels may only transmit values of unique \\\n+           types; that is, values that are statically guaranteed to \\\n+           be accessed by a single 'owner' at a time.  Unique types \\\n+           include scalars, vectors, strings, and records, tags, \\\n+           tuples and unique boxes (~T) thereof. Most notably, \\\n+           shared boxes (@T) may not be transmitted across channels. \\\n+           Example: \\\n+               let p = comm::port(); \\\n+               task::spawn(comm::chan(p), fn (c: chan&lt;str>) { \\\n+                   comm::send(c, \\\"Hello, World\\\"); \\\n+               }); \\\n                io::println(comm::recv(p));\"\n )];\n \n@@ -82,18 +82,18 @@ resource port_ptr<T: send>(po: *rustrt::rust_port) {\n }\n \n #[doc(\n-  brief = \"A communication endpoint that can receive messages.\\\n+  brief = \"A communication endpoint that can receive messages. \\\n            Ports receive messages from channels.\",\n-  desc = \"Each port has a unique per-task identity and may not\\\n-          be replicated or transmitted. If a port value is\\\n-          copied, both copies refer to the same port.\\\n+  desc = \"Each port has a unique per-task identity and may not \\\n+          be replicated or transmitted. If a port value is \\\n+          copied, both copies refer to the same port. \\\n           Ports may be associated with multiple &lt;chan>s.\"\n )]\n tag port<T: send> { port_t(@port_ptr<T>); }\n \n #[doc(\n-  brief = \"Sends data over a channel. The sent data is moved\\\n-           into the channel, whereupon the caller loses\\\n+  brief = \"Sends data over a channel. The sent data is moved \\\n+           into the channel, whereupon the caller loses \\\n            access to it.\"\n )]\n fn send<T: send>(ch: chan<T>, -data: T) {\n@@ -114,8 +114,8 @@ fn port<T: send>() -> port<T> {\n }\n \n #[doc(\n-  brief = \"Receive from a port.\\\n-           If no data is available on the port then the task will\\\n+  brief = \"Receive from a port. \\\n+           If no data is available on the port then the task will \\\n            block until data becomes available.\"\n )]\n fn recv<T: send>(p: port<T>) -> T { recv_(***p) }"}, {"sha": "38ca8ac2a0c3971472bd7b02edb88a1e29d93840", "filename": "src/libcore/ctypes.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e631df3429a3edbb8baf27a7a4ba157e08ebded4/src%2Flibcore%2Fctypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e631df3429a3edbb8baf27a7a4ba157e08ebded4/src%2Flibcore%2Fctypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fctypes.rs?ref=e631df3429a3edbb8baf27a7a4ba157e08ebded4", "patch": "@@ -52,24 +52,24 @@ type ulong = uint;\n type ulonglong = u64;\n \n #[doc(\n-  brief = \"A signed integer with the same size as a pointer.\\\n-           This is guaranteed to always be the same type as a\\\n+  brief = \"A signed integer with the same size as a pointer. \\\n+           This is guaranteed to always be the same type as a \\\n             Rust `int`.\"\n )]\n type intptr_t = uint; // FIXME: int\n \n #[doc(\n-  brief = \"An unsigned integer with the same size as a pointer.\\\n-           This is guaranteed to always be the same type as a Rust\\\n+  brief = \"An unsigned integer with the same size as a pointer. \\\n+           This is guaranteed to always be the same type as a Rust \\\n            `uint`.\"\n )]\n type uintptr_t = uint;\n type uint32_t = u32;\n \n #[doc(\n   brief = \"A type, a pointer to which can be used as C `void *`.\",\n-  desc = \"The void type cannot be constructed or destructured,\\\n-         but using pointers to this type when interoperating\\\n+  desc = \"The void type cannot be constructed or destructured, \\\n+         but using pointers to this type when interoperating \\\n          with C void pointers can help in documentation.\"\n )]\n tag void {\n@@ -116,8 +116,8 @@ type fd_t = i32;      // not actually a C type, but should be.\n type pid_t = i32;\n \n #[doc(\n-  brief = \"An unsigned integer with the same size as a C enum.\\\n-           enum is implementation-defined, but is 32-bits in\\\n+  brief = \"An unsigned integer with the same size as a C enum. \\\n+           enum is implementation-defined, but is 32-bits in \\\n            practice\"\n )]\n type enum = u32;"}]}