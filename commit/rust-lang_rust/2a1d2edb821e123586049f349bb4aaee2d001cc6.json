{"sha": "2a1d2edb821e123586049f349bb4aaee2d001cc6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhMWQyZWRiODIxZTEyMzU4NjA0OWYzNDliYjRhYWVlMmQwMDFjYzY=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2017-03-18T01:55:51Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2017-05-25T05:51:06Z"}, "message": "Declarative macros 2.0 without hygiene.", "tree": {"sha": "ea86b6b7403e222132be53f01949f393b31a41d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea86b6b7403e222132be53f01949f393b31a41d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a1d2edb821e123586049f349bb4aaee2d001cc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a1d2edb821e123586049f349bb4aaee2d001cc6", "html_url": "https://github.com/rust-lang/rust/commit/2a1d2edb821e123586049f349bb4aaee2d001cc6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a1d2edb821e123586049f349bb4aaee2d001cc6/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c6430b3257a96d587349d85aa7596d3f4704c28", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c6430b3257a96d587349d85aa7596d3f4704c28", "html_url": "https://github.com/rust-lang/rust/commit/9c6430b3257a96d587349d85aa7596d3f4704c28"}], "stats": {"total": 162, "additions": 116, "deletions": 46}, "files": [{"sha": "4700b252e2d1af63e4fee26986d127995cfc797b", "filename": "src/doc/unstable-book/src/language-features/decl-macro.md", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d2edb821e123586049f349bb4aaee2d001cc6/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fdecl-macro.md", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d2edb821e123586049f349bb4aaee2d001cc6/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fdecl-macro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fdecl-macro.md?ref=2a1d2edb821e123586049f349bb4aaee2d001cc6", "patch": "@@ -0,0 +1,10 @@\n+# `decl_macro`\n+\n+The tracking issue for this feature is: [#39412]\n+\n+[#39412]: https://github.com/rust-lang/rust/issues/39412\n+\n+------------------------\n+\n+\n+"}, {"sha": "5ec8dd0156ab11496fcdbfdb753020420c961de9", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d2edb821e123586049f349bb4aaee2d001cc6/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d2edb821e123586049f349bb4aaee2d001cc6/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=2a1d2edb821e123586049f349bb4aaee2d001cc6", "patch": "@@ -1502,10 +1502,11 @@ impl<'a> LoweringContext<'a> {\n     pub fn lower_item(&mut self, i: &Item) -> Option<hir::Item> {\n         let mut name = i.ident.name;\n         let attrs = self.lower_attrs(&i.attrs);\n-        if let ItemKind::MacroDef(ref tts) = i.node {\n-            if i.attrs.iter().any(|attr| attr.path == \"macro_export\") {\n+        if let ItemKind::MacroDef(ref def) = i.node {\n+            if !def.legacy || i.attrs.iter().any(|attr| attr.path == \"macro_export\") {\n+                let (body, legacy) = (def.stream(), def.legacy);\n                 self.exported_macros.push(hir::MacroDef {\n-                    name: name, attrs: attrs, id: i.id, span: i.span, body: tts.stream(),\n+                    name: name, attrs: attrs, id: i.id, span: i.span, body: body, legacy: legacy,\n                 });\n             }\n             return None;"}, {"sha": "6c355608f134d7a7bf1af3f5d0c14ed5b20b4f39", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d2edb821e123586049f349bb4aaee2d001cc6/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d2edb821e123586049f349bb4aaee2d001cc6/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=2a1d2edb821e123586049f349bb4aaee2d001cc6", "patch": "@@ -536,6 +536,7 @@ pub struct MacroDef {\n     pub id: NodeId,\n     pub span: Span,\n     pub body: TokenStream,\n+    pub legacy: bool,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]"}, {"sha": "f9758ceea1e8b8ea3aaf92801851e8b5b110c400", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d2edb821e123586049f349bb4aaee2d001cc6/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d2edb821e123586049f349bb4aaee2d001cc6/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=2a1d2edb821e123586049f349bb4aaee2d001cc6", "patch": "@@ -332,6 +332,7 @@ impl_stable_hash_for!(struct hir::MacroDef {\n     attrs,\n     id,\n     span,\n+    legacy,\n     body\n });\n "}, {"sha": "4e16c97ca4d86d3ece589af54ba78c342991fa81", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d2edb821e123586049f349bb4aaee2d001cc6/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d2edb821e123586049f349bb4aaee2d001cc6/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=2a1d2edb821e123586049f349bb4aaee2d001cc6", "patch": "@@ -388,6 +388,7 @@ impl CrateStore for cstore::CStore {\n             attrs: attrs.iter().cloned().collect(),\n             node: ast::ItemKind::MacroDef(ast::MacroDef {\n                 tokens: body.into(),\n+                legacy: true,\n             }),\n             vis: ast::Visibility::Inherited,\n         })"}, {"sha": "b7b75f8af73e0cfbe90864db4ec370ec70a9f360", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d2edb821e123586049f349bb4aaee2d001cc6/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d2edb821e123586049f349bb4aaee2d001cc6/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=2a1d2edb821e123586049f349bb4aaee2d001cc6", "patch": "@@ -77,7 +77,7 @@ struct LegacyMacroImports {\n impl<'a> Resolver<'a> {\n     /// Defines `name` in namespace `ns` of module `parent` to be `def` if it is not yet defined;\n     /// otherwise, reports an error.\n-    fn define<T>(&mut self, parent: Module<'a>, ident: Ident, ns: Namespace, def: T)\n+    pub fn define<T>(&mut self, parent: Module<'a>, ident: Ident, ns: Namespace, def: T)\n         where T: ToNameBinding<'a>,\n     {\n         let binding = def.to_name_binding(self.arenas);\n@@ -730,7 +730,7 @@ impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n     fn visit_item(&mut self, item: &'a Item) {\n         let macro_use = match item.node {\n             ItemKind::MacroDef(..) => {\n-                self.resolver.define_macro(item, &mut self.legacy_scope);\n+                self.resolver.define_macro(item, self.expansion, &mut self.legacy_scope);\n                 return\n             }\n             ItemKind::Mac(..) => {"}, {"sha": "500277e78e61dafc255bc466bcfbc724c22dc99f", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d2edb821e123586049f349bb4aaee2d001cc6/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d2edb821e123586049f349bb4aaee2d001cc6/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=2a1d2edb821e123586049f349bb4aaee2d001cc6", "patch": "@@ -1058,6 +1058,13 @@ impl<'a> NameBinding<'a> {\n             _ => true,\n         }\n     }\n+\n+    fn is_macro_def(&self) -> bool {\n+        match self.kind {\n+            NameBindingKind::Def(Def::Macro(..)) => true,\n+            _ => false,\n+        }\n+    }\n }\n \n /// Interns the names of the primitive types.\n@@ -1377,8 +1384,9 @@ impl<'a> Resolver<'a> {\n                 vis: ty::Visibility::Public,\n             }),\n \n-            // `#![feature(proc_macro)]` implies `#[feature(extern_macros)]`\n-            use_extern_macros: features.use_extern_macros || features.proc_macro,\n+            // The `proc_macro` and `decl_macro` features imply `use_extern_macros`\n+            use_extern_macros:\n+                features.use_extern_macros || features.proc_macro || features.decl_macro,\n \n             crate_loader: crate_loader,\n             macro_names: FxHashSet(),"}, {"sha": "bf21344330bcaf3c663077e6e30e67a2f2e396b1", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d2edb821e123586049f349bb4aaee2d001cc6/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d2edb821e123586049f349bb4aaee2d001cc6/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=2a1d2edb821e123586049f349bb4aaee2d001cc6", "patch": "@@ -687,7 +687,10 @@ impl<'a> Resolver<'a> {\n         });\n     }\n \n-    pub fn define_macro(&mut self, item: &ast::Item, legacy_scope: &mut LegacyScope<'a>) {\n+    pub fn define_macro(&mut self,\n+                        item: &ast::Item,\n+                        expansion: Mark,\n+                        legacy_scope: &mut LegacyScope<'a>) {\n         self.local_macro_def_scopes.insert(item.id, self.current_module);\n         let ident = item.ident;\n         if ident.name == \"macro_rules\" {\n@@ -699,16 +702,24 @@ impl<'a> Resolver<'a> {\n                                                &self.session.features,\n                                                item));\n         self.macro_map.insert(def_id, ext);\n-        *legacy_scope = LegacyScope::Binding(self.arenas.alloc_legacy_binding(LegacyBinding {\n-            parent: Cell::new(*legacy_scope), name: ident.name, def_id: def_id, span: item.span,\n-        }));\n-        self.macro_names.insert(ident.name);\n \n-        if attr::contains_name(&item.attrs, \"macro_export\") {\n-            let def = Def::Macro(def_id, MacroKind::Bang);\n-            self.macro_exports.push(Export { name: ident.name, def: def, span: item.span });\n+        let def = match item.node { ast::ItemKind::MacroDef(ref def) => def, _ => unreachable!() };\n+        if def.legacy {\n+            self.macro_names.insert(ident.name);\n+            *legacy_scope = LegacyScope::Binding(self.arenas.alloc_legacy_binding(LegacyBinding {\n+                parent: Cell::new(*legacy_scope), name: ident.name, def_id: def_id, span: item.span,\n+            }));\n+            if attr::contains_name(&item.attrs, \"macro_export\") {\n+                let def = Def::Macro(def_id, MacroKind::Bang);\n+                self.macro_exports.push(Export { name: ident.name, def: def, span: item.span });\n+            } else {\n+                self.unused_macros.insert(def_id);\n+            }\n         } else {\n-            self.unused_macros.insert(def_id);\n+            let module = self.current_module;\n+            let def = Def::Macro(def_id, MacroKind::Bang);\n+            let vis = self.resolve_visibility(&item.vis);\n+            self.define(module, ident, MacroNS, (def, vis, item.span, expansion));\n         }\n     }\n "}, {"sha": "fdca931ad4784c6b9c216c6664d90ac18d715e14", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d2edb821e123586049f349bb4aaee2d001cc6/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d2edb821e123586049f349bb4aaee2d001cc6/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=2a1d2edb821e123586049f349bb4aaee2d001cc6", "patch": "@@ -803,7 +803,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             };\n \n             if binding.vis == ty::Visibility::Public &&\n-               (binding.is_import() || binding.is_extern_crate()) {\n+               (binding.is_import() || binding.is_macro_def()) {\n                 let def = binding.def();\n                 if def != Def::Err {\n                     if !def.def_id().is_local() {"}, {"sha": "3dcb77a0497110e58abc7e9663af20a0c45d820e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d2edb821e123586049f349bb4aaee2d001cc6/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d2edb821e123586049f349bb4aaee2d001cc6/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=2a1d2edb821e123586049f349bb4aaee2d001cc6", "patch": "@@ -1022,6 +1022,7 @@ impl Mac_ {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct MacroDef {\n     pub tokens: ThinTokenStream,\n+    pub legacy: bool,\n }\n \n impl MacroDef {"}, {"sha": "ad09d5837341297105b83532b61916dddc5c1ae5", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d2edb821e123586049f349bb4aaee2d001cc6/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d2edb821e123586049f349bb4aaee2d001cc6/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=2a1d2edb821e123586049f349bb4aaee2d001cc6", "patch": "@@ -162,6 +162,12 @@ pub fn compile(sess: &ParseSess, features: &RefCell<Features>, def: &ast::Item)\n     let lhs_nm = ast::Ident::with_empty_ctxt(Symbol::gensym(\"lhs\"));\n     let rhs_nm = ast::Ident::with_empty_ctxt(Symbol::gensym(\"rhs\"));\n \n+    // Parse the macro_rules! invocation\n+    let body = match def.node {\n+        ast::ItemKind::MacroDef(ref body) => body,\n+        _ => unreachable!(),\n+    };\n+\n     // The pattern that macro_rules matches.\n     // The grammar for macro_rules! is:\n     // $( $lhs:tt => $rhs:tt );+\n@@ -174,7 +180,7 @@ pub fn compile(sess: &ParseSess, features: &RefCell<Features>, def: &ast::Item)\n                 quoted::TokenTree::Token(DUMMY_SP, token::FatArrow),\n                 quoted::TokenTree::MetaVarDecl(DUMMY_SP, rhs_nm, ast::Ident::from_str(\"tt\")),\n             ],\n-            separator: Some(token::Semi),\n+            separator: Some(if body.legacy { token::Semi } else { token::Comma }),\n             op: quoted::KleeneOp::OneOrMore,\n             num_captures: 2,\n         })),\n@@ -187,12 +193,7 @@ pub fn compile(sess: &ParseSess, features: &RefCell<Features>, def: &ast::Item)\n         })),\n     ];\n \n-    // Parse the macro_rules! invocation\n-    let body = match def.node {\n-        ast::ItemKind::MacroDef(ref body) => body.stream(),\n-        _ => unreachable!(),\n-    };\n-    let argument_map = match parse(sess, body, &argument_gram, None, true) {\n+    let argument_map = match parse(sess, body.stream(), &argument_gram, None, true) {\n         Success(m) => m,\n         Failure(sp, tok) => {\n             let s = parse_failure_msg(tok);"}, {"sha": "076639a31eac7155eb90290e2117d5c04bca4d4c", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d2edb821e123586049f349bb4aaee2d001cc6/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d2edb821e123586049f349bb4aaee2d001cc6/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=2a1d2edb821e123586049f349bb4aaee2d001cc6", "patch": "@@ -309,9 +309,12 @@ declare_features! (\n     // The `unadjusted` ABI. Perma unstable.\n     (active, abi_unadjusted, \"1.16.0\", None),\n \n-    // Macros 1.1\n+    // Procedural macros 2.0.\n     (active, proc_macro, \"1.16.0\", Some(38356)),\n \n+    // Declarative macros 2.0 (`macro`).\n+    (active, decl_macro, \"1.17.0\", Some(39412)),\n+\n     // Allows attributes on struct literal fields.\n     (active, struct_field_attributes, \"1.16.0\", Some(38814)),\n \n@@ -1229,6 +1232,11 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 }\n             }\n \n+            ast::ItemKind::MacroDef(ast::MacroDef { legacy: false, .. }) => {\n+                let msg = \"`macro` is experimental\";\n+                gate_feature_post!(&self, decl_macro, i.span, msg);\n+            }\n+\n             _ => {}\n         }\n "}, {"sha": "1d1e46cf576d1a32571da2dfef635c1a47b0346b", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d2edb821e123586049f349bb4aaee2d001cc6/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d2edb821e123586049f349bb4aaee2d001cc6/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=2a1d2edb821e123586049f349bb4aaee2d001cc6", "patch": "@@ -522,6 +522,7 @@ pub fn noop_fold_mac<T: Folder>(Spanned {node, span}: Mac, fld: &mut T) -> Mac {\n pub fn noop_fold_macro_def<T: Folder>(def: MacroDef, fld: &mut T) -> MacroDef {\n     MacroDef {\n         tokens: fld.fold_tts(def.tokens.into()).into(),\n+        legacy: def.legacy,\n     }\n }\n "}, {"sha": "bc9be809ca48600ba14ce71beb0ff2af1bfdad7f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 47, "deletions": 21, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/2a1d2edb821e123586049f349bb4aaee2d001cc6/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a1d2edb821e123586049f349bb4aaee2d001cc6/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=2a1d2edb821e123586049f349bb4aaee2d001cc6", "patch": "@@ -3758,33 +3758,59 @@ impl<'a> Parser<'a> {\n     fn eat_macro_def(&mut self, attrs: &[Attribute], vis: &Visibility)\n                      -> PResult<'a, Option<P<Item>>> {\n         let lo = self.span;\n-        match self.token {\n-            token::Ident(ident) if ident.name == \"macro_rules\" => {\n-                if self.look_ahead(1, |t| *t == token::Not) {\n-                    let prev_span = self.prev_span;\n-                    self.complain_if_pub_macro(vis, prev_span);\n-                    self.bump();\n-                    self.bump();\n+        let (ident, def) = match self.token {\n+            token::Ident(ident) if ident.name == keywords::Macro.name() => {\n+                self.bump();\n+                let ident = self.parse_ident()?;\n+                let tokens = if self.check(&token::OpenDelim(token::Brace)) {\n+                    match self.parse_token_tree() {\n+                        TokenTree::Delimited(_, ref delimited) => delimited.stream(),\n+                        _ => unreachable!(),\n+                    }\n+                } else if self.check(&token::OpenDelim(token::Paren)) {\n+                    let args = self.parse_token_tree();\n+                    let body = if self.check(&token::OpenDelim(token::Brace)) {\n+                        self.parse_token_tree()\n+                    } else {\n+                        self.unexpected()?;\n+                        unreachable!()\n+                    };\n+                    TokenStream::concat(vec![\n+                        args.into(),\n+                        TokenTree::Token(lo.to(self.prev_span), token::FatArrow).into(),\n+                        body.into(),\n+                    ])\n+                } else {\n+                    self.unexpected()?;\n+                    unreachable!()\n+                };\n+\n+                (ident, ast::MacroDef { tokens: tokens.into(), legacy: false })\n+            }\n+            token::Ident(ident) if ident.name == \"macro_rules\" &&\n+                                   self.look_ahead(1, |t| *t == token::Not) => {\n+                let prev_span = self.prev_span;\n+                self.complain_if_pub_macro(vis, prev_span);\n+                self.bump();\n+                self.bump();\n+\n+                let ident = self.parse_ident()?;\n+                let (delim, tokens) = self.expect_delimited_token_tree()?;\n+                if delim != token::Brace {\n+                    if !self.eat(&token::Semi) {\n+                        let msg = \"macros that expand to items must either \\\n+                                   be surrounded with braces or followed by a semicolon\";\n+                        self.span_err(self.prev_span, msg);\n+                    }\n                 }\n+\n+                (ident, ast::MacroDef { tokens: tokens, legacy: true })\n             }\n             _ => return Ok(None),\n         };\n \n-        let id = self.parse_ident()?;\n-        let (delim, tts) = self.expect_delimited_token_tree()?;\n-        if delim != token::Brace {\n-            if !self.eat(&token::Semi) {\n-                let msg = \"macros that expand to items must either be surrounded with braces \\\n-                           or followed by a semicolon\";\n-                self.span_err(self.prev_span, msg);\n-            }\n-        }\n-\n         let span = lo.to(self.prev_span);\n-        let kind = ItemKind::MacroDef(ast::MacroDef {\n-            tokens: tts,\n-        });\n-        Ok(Some(self.mk_item(span, id, kind, Visibility::Inherited, attrs.to_owned())))\n+        Ok(Some(self.mk_item(span, ident, ItemKind::MacroDef(def), vis.clone(), attrs.to_vec())))\n     }\n \n     fn parse_stmt_without_recovery(&mut self,"}]}