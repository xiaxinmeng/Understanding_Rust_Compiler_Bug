{"sha": "c0b7b41cff2b40d430befefc8688fb8ad847bcd4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwYjdiNDFjZmYyYjQwZDQzMGJlZmVmYzg2ODhmYjhhZDg0N2JjZDQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-01-29T00:57:24Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-02-05T00:27:08Z"}, "message": "parse_ty_common: use `enum`s instead of `bool`s.", "tree": {"sha": "e8d53c19a4dbbad8c50be8c06833b1249216ee8b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8d53c19a4dbbad8c50be8c06833b1249216ee8b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0b7b41cff2b40d430befefc8688fb8ad847bcd4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0b7b41cff2b40d430befefc8688fb8ad847bcd4", "html_url": "https://github.com/rust-lang/rust/commit/c0b7b41cff2b40d430befefc8688fb8ad847bcd4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0b7b41cff2b40d430befefc8688fb8ad847bcd4/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9290dceee2cb6b882b26ec6e294560e51ef0853", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9290dceee2cb6b882b26ec6e294560e51ef0853", "html_url": "https://github.com/rust-lang/rust/commit/c9290dceee2cb6b882b26ec6e294560e51ef0853"}], "stats": {"total": 81, "additions": 52, "deletions": 29}, "files": [{"sha": "5f148fa6ba2d328211741c0f3c6074b65568d99a", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7b41cff2b40d430befefc8688fb8ad847bcd4/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7b41cff2b40d430befefc8688fb8ad847bcd4/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=c0b7b41cff2b40d430befefc8688fb8ad847bcd4", "patch": "@@ -1,3 +1,4 @@\n+use super::ty::AllowPlus;\n use super::{BlockMode, Parser, PathStyle, SemiColonMode, SeqSep, TokenExpectType, TokenType};\n \n use rustc_ast_pretty::pprust;\n@@ -693,11 +694,11 @@ impl<'a> Parser<'a> {\n \n     pub(super) fn maybe_report_ambiguous_plus(\n         &mut self,\n-        allow_plus: bool,\n+        allow_plus: AllowPlus,\n         impl_dyn_multi: bool,\n         ty: &Ty,\n     ) {\n-        if !allow_plus && impl_dyn_multi {\n+        if matches!(allow_plus, AllowPlus::No) && impl_dyn_multi {\n             let sum_with_parens = format!(\"({})\", pprust::ty_to_string(&ty));\n             self.struct_span_err(ty.span, \"ambiguous `+` in a type\")\n                 .span_suggestion(\n@@ -712,11 +713,11 @@ impl<'a> Parser<'a> {\n \n     pub(super) fn maybe_recover_from_bad_type_plus(\n         &mut self,\n-        allow_plus: bool,\n+        allow_plus: AllowPlus,\n         ty: &Ty,\n     ) -> PResult<'a, ()> {\n         // Do not add `+` to expected tokens.\n-        if !allow_plus || !self.token.is_like_plus() {\n+        if matches!(allow_plus, AllowPlus::No) || !self.token.is_like_plus() {\n             return Ok(());\n         }\n "}, {"sha": "d98321416957db33e9b42562860cb5733667e5e8", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7b41cff2b40d430befefc8688fb8ad847bcd4/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7b41cff2b40d430befefc8688fb8ad847bcd4/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=c0b7b41cff2b40d430befefc8688fb8ad847bcd4", "patch": "@@ -1,4 +1,5 @@\n use super::pat::{GateOr, PARAM_EXPECTED};\n+use super::ty::{AllowPlus, RecoverQPath};\n use super::{BlockMode, Parser, PathStyle, PrevTokenKind, Restrictions, TokenType};\n use super::{SemiColonMode, SeqSep, TokenExpectType};\n use crate::maybe_recover_from_interpolated_ty_qpath;\n@@ -1399,7 +1400,7 @@ impl<'a> Parser<'a> {\n             self.expect_or()?;\n             args\n         };\n-        let output = self.parse_ret_ty(true, true)?;\n+        let output = self.parse_ret_ty(AllowPlus::Yes, RecoverQPath::Yes)?;\n \n         Ok(P(FnDecl { inputs, output }))\n     }"}, {"sha": "87a6aa76f577747c3856a27280d4d52b116f6dbb", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7b41cff2b40d430befefc8688fb8ad847bcd4/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7b41cff2b40d430befefc8688fb8ad847bcd4/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=c0b7b41cff2b40d430befefc8688fb8ad847bcd4", "patch": "@@ -1,4 +1,5 @@\n use super::diagnostics::{dummy_arg, ConsumeClosingDelim, Error};\n+use super::ty::{AllowPlus, RecoverQPath};\n use super::{FollowedByType, Parser, PathStyle};\n \n use crate::maybe_whole;\n@@ -1839,7 +1840,7 @@ impl<'a> Parser<'a> {\n     fn parse_fn_sig(&mut self, cfg: &ParamCfg) -> PResult<'a, (Ident, P<FnDecl>, Generics)> {\n         let ident = self.parse_ident()?;\n         let mut generics = self.parse_generics()?;\n-        let decl = self.parse_fn_decl(cfg, true)?;\n+        let decl = self.parse_fn_decl(cfg, AllowPlus::Yes)?;\n         generics.where_clause = self.parse_where_clause()?;\n         Ok((ident, decl, generics))\n     }\n@@ -1848,11 +1849,11 @@ impl<'a> Parser<'a> {\n     pub(super) fn parse_fn_decl(\n         &mut self,\n         cfg: &ParamCfg,\n-        ret_allow_plus: bool,\n+        ret_allow_plus: AllowPlus,\n     ) -> PResult<'a, P<FnDecl>> {\n         Ok(P(FnDecl {\n             inputs: self.parse_fn_params(cfg)?,\n-            output: self.parse_ret_ty(ret_allow_plus, true)?,\n+            output: self.parse_ret_ty(ret_allow_plus, RecoverQPath::Yes)?,\n         }))\n     }\n "}, {"sha": "cb14ffb4bd028ef713321868052a27dbb5c22a4b", "filename": "src/librustc_parse/parser/path.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7b41cff2b40d430befefc8688fb8ad847bcd4/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7b41cff2b40d430befefc8688fb8ad847bcd4/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpath.rs?ref=c0b7b41cff2b40d430befefc8688fb8ad847bcd4", "patch": "@@ -1,3 +1,4 @@\n+use super::ty::{AllowPlus, RecoverQPath};\n use super::{Parser, TokenType};\n use crate::maybe_whole;\n use rustc_errors::{pluralize, Applicability, PResult};\n@@ -224,7 +225,7 @@ impl<'a> Parser<'a> {\n                     // `(T, U) -> R`\n                     let (inputs, _) = self.parse_paren_comma_seq(|p| p.parse_ty())?;\n                     let span = ident.span.to(self.prev_span);\n-                    let output = self.parse_ret_ty(false, false)?;\n+                    let output = self.parse_ret_ty(AllowPlus::No, RecoverQPath::No)?;\n                     ParenthesizedArgs { inputs, output, span }.into()\n                 };\n "}, {"sha": "1ed80ed7350a92a1738d46e39b7e55d637002c05", "filename": "src/librustc_parse/parser/ty.rs", "status": "modified", "additions": 39, "deletions": 20, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/c0b7b41cff2b40d430befefc8688fb8ad847bcd4/src%2Flibrustc_parse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b7b41cff2b40d430befefc8688fb8ad847bcd4/src%2Flibrustc_parse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fty.rs?ref=c0b7b41cff2b40d430befefc8688fb8ad847bcd4", "patch": "@@ -36,6 +36,23 @@ impl BoundModifiers {\n     }\n }\n \n+#[derive(Copy, Clone)]\n+pub(super) enum AllowPlus {\n+    Yes,\n+    No,\n+}\n+\n+pub(super) enum RecoverQPath {\n+    Yes,\n+    No,\n+}\n+\n+// Is `...` (`CVarArgs`) legal at this level of type parsing?\n+enum AllowCVariadic {\n+    Yes,\n+    No,\n+}\n+\n /// Returns `true` if `IDENT t` can start a type -- `IDENT::a::b`, `IDENT<u8, u8>`,\n /// `IDENT<<u8 as Trait>::AssocTy>`.\n ///\n@@ -48,14 +65,14 @@ fn can_continue_type_after_non_fn_ident(t: &Token) -> bool {\n impl<'a> Parser<'a> {\n     /// Parses a type.\n     pub fn parse_ty(&mut self) -> PResult<'a, P<Ty>> {\n-        self.parse_ty_common(true, true, false)\n+        self.parse_ty_common(AllowPlus::Yes, RecoverQPath::Yes, AllowCVariadic::No)\n     }\n \n     /// Parse a type suitable for a function or function pointer parameter.\n     /// The difference from `parse_ty` is that this version allows `...`\n     /// (`CVarArgs`) at the top level of the the type.\n     pub(super) fn parse_ty_for_param(&mut self) -> PResult<'a, P<Ty>> {\n-        self.parse_ty_common(true, true, true)\n+        self.parse_ty_common(AllowPlus::Yes, RecoverQPath::Yes, AllowCVariadic::Yes)\n     }\n \n     /// Parses a type in restricted contexts where `+` is not permitted.\n@@ -65,30 +82,31 @@ impl<'a> Parser<'a> {\n     /// Example 2: `value1 as TYPE + value2`\n     ///     `+` is prohibited to avoid interactions with expression grammar.\n     pub(super) fn parse_ty_no_plus(&mut self) -> PResult<'a, P<Ty>> {\n-        self.parse_ty_common(false, true, false)\n+        self.parse_ty_common(AllowPlus::No, RecoverQPath::Yes, AllowCVariadic::No)\n     }\n \n     /// Parses an optional return type `[ -> TY ]` in a function declaration.\n     pub(super) fn parse_ret_ty(\n         &mut self,\n-        allow_plus: bool,\n-        allow_qpath_recovery: bool,\n+        allow_plus: AllowPlus,\n+        recover_qpath: RecoverQPath,\n     ) -> PResult<'a, FunctionRetTy> {\n         Ok(if self.eat(&token::RArrow) {\n             // FIXME(Centril): Can we unconditionally `allow_plus`?\n-            FunctionRetTy::Ty(self.parse_ty_common(allow_plus, allow_qpath_recovery, false)?)\n+            let ty = self.parse_ty_common(allow_plus, recover_qpath, AllowCVariadic::No)?;\n+            FunctionRetTy::Ty(ty)\n         } else {\n             FunctionRetTy::Default(self.token.span.shrink_to_lo())\n         })\n     }\n \n     fn parse_ty_common(\n         &mut self,\n-        allow_plus: bool,\n-        allow_qpath_recovery: bool,\n-        // Is `...` (`CVarArgs`) legal in the immediate top level call?\n-        allow_c_variadic: bool,\n+        allow_plus: AllowPlus,\n+        recover_qpath: RecoverQPath,\n+        allow_c_variadic: AllowCVariadic,\n     ) -> PResult<'a, P<Ty>> {\n+        let allow_qpath_recovery = matches!(recover_qpath, RecoverQPath::Yes);\n         maybe_recover_from_interpolated_ty_qpath!(self, allow_qpath_recovery);\n         maybe_whole!(self, NtTy, |x| x);\n \n@@ -124,7 +142,7 @@ impl<'a> Parser<'a> {\n                 self.parse_ty_bare_fn(lifetime_defs)?\n             } else {\n                 let path = self.parse_path(PathStyle::Type)?;\n-                let parse_plus = allow_plus && self.check_plus();\n+                let parse_plus = matches!(allow_plus, AllowPlus::Yes) && self.check_plus();\n                 self.parse_remaining_bounds(lifetime_defs, path, lo, parse_plus)?\n             }\n         } else if self.eat_keyword(kw::Impl) {\n@@ -144,7 +162,7 @@ impl<'a> Parser<'a> {\n         } else if self.token.is_path_start() {\n             self.parse_path_start_ty(lo, allow_plus)?\n         } else if self.eat(&token::DotDotDot) {\n-            if allow_c_variadic {\n+            if let AllowCVariadic::Yes = allow_c_variadic {\n                 TyKind::CVarArgs\n             } else {\n                 // FIXME(Centril): Should we just allow `...` syntactically\n@@ -172,7 +190,7 @@ impl<'a> Parser<'a> {\n     /// Parses either:\n     /// - `(TYPE)`, a parenthesized type.\n     /// - `(TYPE,)`, a tuple with a single field of type TYPE.\n-    fn parse_ty_tuple_or_parens(&mut self, lo: Span, allow_plus: bool) -> PResult<'a, TyKind> {\n+    fn parse_ty_tuple_or_parens(&mut self, lo: Span, allow_plus: AllowPlus) -> PResult<'a, TyKind> {\n         let mut trailing_plus = false;\n         let (ts, trailing) = self.parse_paren_comma_seq(|p| {\n             let ty = p.parse_ty()?;\n@@ -182,7 +200,7 @@ impl<'a> Parser<'a> {\n \n         if ts.len() == 1 && !trailing {\n             let ty = ts.into_iter().nth(0).unwrap().into_inner();\n-            let maybe_bounds = allow_plus && self.token.is_like_plus();\n+            let maybe_bounds = matches!(allow_plus, AllowPlus::Yes) && self.token.is_like_plus();\n             match ty.kind {\n                 // `(TY_BOUND_NOPAREN) + BOUND + ...`.\n                 TyKind::Path(None, path) if maybe_bounds => {\n@@ -288,7 +306,8 @@ impl<'a> Parser<'a> {\n         let unsafety = self.parse_unsafety();\n         let ext = self.parse_extern()?;\n         self.expect_keyword(kw::Fn)?;\n-        let decl = self.parse_fn_decl(&ParamCfg { is_name_required: |_| false }, false)?;\n+        let cfg = ParamCfg { is_name_required: |_| false };\n+        let decl = self.parse_fn_decl(&cfg, AllowPlus::No)?;\n         Ok(TyKind::BareFn(P(BareFnTy { ext, unsafety, generic_params, decl })))\n     }\n \n@@ -326,7 +345,7 @@ impl<'a> Parser<'a> {\n     /// 1. a type macro, `mac!(...)`,\n     /// 2. a bare trait object, `B0 + ... + Bn`,\n     /// 3. or a path, `path::to::MyType`.\n-    fn parse_path_start_ty(&mut self, lo: Span, allow_plus: bool) -> PResult<'a, TyKind> {\n+    fn parse_path_start_ty(&mut self, lo: Span, allow_plus: AllowPlus) -> PResult<'a, TyKind> {\n         // Simple path\n         let path = self.parse_path(PathStyle::Type)?;\n         if self.eat(&token::Not) {\n@@ -336,7 +355,7 @@ impl<'a> Parser<'a> {\n                 args: self.parse_mac_args()?,\n                 prior_type_ascription: self.last_type_ascription,\n             }))\n-        } else if allow_plus && self.check_plus() {\n+        } else if matches!(allow_plus, AllowPlus::Yes) && self.check_plus() {\n             // `Trait1 + Trait2 + 'a`\n             self.parse_remaining_bounds(Vec::new(), path, lo, true)\n         } else {\n@@ -359,15 +378,15 @@ impl<'a> Parser<'a> {\n         &mut self,\n         colon_span: Option<Span>,\n     ) -> PResult<'a, GenericBounds> {\n-        self.parse_generic_bounds_common(true, colon_span)\n+        self.parse_generic_bounds_common(AllowPlus::Yes, colon_span)\n     }\n \n     /// Parses bounds of a type parameter `BOUND + BOUND + ...`, possibly with trailing `+`.\n     ///\n     /// See `parse_generic_bound` for the `BOUND` grammar.\n     fn parse_generic_bounds_common(\n         &mut self,\n-        allow_plus: bool,\n+        allow_plus: AllowPlus,\n         colon_span: Option<Span>,\n     ) -> PResult<'a, GenericBounds> {\n         let mut bounds = Vec::new();\n@@ -377,7 +396,7 @@ impl<'a> Parser<'a> {\n                 Ok(bound) => bounds.push(bound),\n                 Err(neg_sp) => negative_bounds.push(neg_sp),\n             }\n-            if !allow_plus || !self.eat_plus() {\n+            if matches!(allow_plus, AllowPlus::No) || !self.eat_plus() {\n                 break;\n             }\n         }"}]}