{"sha": "2f96c22a21299cfe5860b0bb6fdd1af8ac500b11", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmOTZjMjJhMjEyOTljZmU1ODYwYjBiYjZmZGQxYWY4YWM1MDBiMTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-17T00:55:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-17T00:55:46Z"}, "message": "auto merge of #9231 : cmr/rust/enum_encoding, r=catamorphism", "tree": {"sha": "e59d320266889c4933d29f42cce423484133c8fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e59d320266889c4933d29f42cce423484133c8fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f96c22a21299cfe5860b0bb6fdd1af8ac500b11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f96c22a21299cfe5860b0bb6fdd1af8ac500b11", "html_url": "https://github.com/rust-lang/rust/commit/2f96c22a21299cfe5860b0bb6fdd1af8ac500b11", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f96c22a21299cfe5860b0bb6fdd1af8ac500b11/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38d4f48f0a185cc27769a6526668baa31aeee6b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/38d4f48f0a185cc27769a6526668baa31aeee6b9", "html_url": "https://github.com/rust-lang/rust/commit/38d4f48f0a185cc27769a6526668baa31aeee6b9"}, {"sha": "d0e0c336d081005da157882e95f4bb57f3bd70b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0e0c336d081005da157882e95f4bb57f3bd70b8", "html_url": "https://github.com/rust-lang/rust/commit/d0e0c336d081005da157882e95f4bb57f3bd70b8"}], "stats": {"total": 183, "additions": 146, "deletions": 37}, "files": [{"sha": "e0e860d102e056da13346c1d2e383fc0edfc8be4", "filename": "src/libextra/json.rs", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2f96c22a21299cfe5860b0bb6fdd1af8ac500b11/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f96c22a21299cfe5860b0bb6fdd1af8ac500b11/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=2f96c22a21299cfe5860b0bb6fdd1af8ac500b11", "patch": "@@ -135,18 +135,21 @@ impl serialize::Encoder for Encoder {\n                          _id: uint,\n                          cnt: uint,\n                          f: &fn(&mut Encoder)) {\n-        // enums are encoded as strings or vectors:\n+        // enums are encoded as strings or objects\n         // Bunny => \"Bunny\"\n-        // Kangaroo(34,\"William\") => [\"Kangaroo\",[34,\"William\"]]\n-\n+        // Kangaroo(34,\"William\") => {\"variant\": \"Kangaroo\", \"fields\": [34,\"William\"]}\n         if cnt == 0 {\n             self.wr.write_str(escape_str(name));\n         } else {\n-            self.wr.write_char('[');\n+            self.wr.write_char('{');\n+            self.wr.write_str(\"\\\"variant\\\"\");\n+            self.wr.write_char(':');\n             self.wr.write_str(escape_str(name));\n             self.wr.write_char(',');\n+            self.wr.write_str(\"\\\"fields\\\"\");\n+            self.wr.write_str(\":[\");\n             f(self);\n-            self.wr.write_char(']');\n+            self.wr.write_str(\"]}\");\n         }\n     }\n \n@@ -947,14 +950,20 @@ impl serialize::Decoder for Decoder {\n         debug!(\"read_enum_variant(names=%?)\", names);\n         let name = match self.stack.pop() {\n             String(s) => s,\n-            List(list) => {\n-                for v in list.move_rev_iter() {\n-                    self.stack.push(v);\n-                }\n-                match self.stack.pop() {\n-                    String(s) => s,\n-                    value => fail!(\"invalid variant name: %?\", value),\n+            Object(o) => {\n+                let n = match o.find(&~\"variant\").expect(\"invalidly encoded json\") {\n+                    &String(ref s) => s.clone(),\n+                    _ => fail!(\"invalidly encoded json\"),\n+                };\n+                match o.find(&~\"fields\").expect(\"invalidly encoded json\") {\n+                    &List(ref l) => {\n+                        for field in l.rev_iter() {\n+                            self.stack.push(field.clone());\n+                        }\n+                    },\n+                    _ => fail!(\"invalidly encoded json\")\n                 }\n+                n\n             }\n             ref json => fail!(\"invalid variant: %?\", *json),\n         };\n@@ -1517,7 +1526,7 @@ mod tests {\n                 let mut encoder = Encoder(wr);\n                 animal.encode(&mut encoder);\n             },\n-            ~\"[\\\"Frog\\\",\\\"Henry\\\",349]\"\n+            ~\"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\"\n         );\n         assert_eq!(\n             do io::with_str_writer |wr| {\n@@ -1921,14 +1930,14 @@ mod tests {\n         assert_eq!(value, Dog);\n \n         let mut decoder =\n-            Decoder(from_str(\"[\\\"Frog\\\",\\\"Henry\\\",349]\").unwrap());\n+            Decoder(from_str(\"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\").unwrap());\n         let value: Animal = Decodable::decode(&mut decoder);\n         assert_eq!(value, Frog(~\"Henry\", 349));\n     }\n \n     #[test]\n     fn test_decode_map() {\n-        let s = ~\"{\\\"a\\\": \\\"Dog\\\", \\\"b\\\": [\\\"Frog\\\", \\\"Henry\\\", 349]}\";\n+        let s = ~\"{\\\"a\\\": \\\"Dog\\\", \\\"b\\\": {\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\", 349]}}\";\n         let mut decoder = Decoder(from_str(s).unwrap());\n         let mut map: TreeMap<~str, Animal> = Decodable::decode(&mut decoder);\n "}, {"sha": "9645dab4e8b7b847c72c00b8296d03fa8cdaab73", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 122, "deletions": 22, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/2f96c22a21299cfe5860b0bb6fdd1af8ac500b11/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f96c22a21299cfe5860b0bb6fdd1af8ac500b11/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=2f96c22a21299cfe5860b0bb6fdd1af8ac500b11", "patch": "@@ -398,30 +398,130 @@ mod test {\n     #[test] fn string_to_tts_1 () {\n         let (tts,_ps) = string_to_tts_and_sess(@\"fn a (b : int) { b; }\");\n         assert_eq!(to_json_str(@tts),\n-                   ~\"[\\\n-                [\\\"tt_tok\\\",null,[\\\"IDENT\\\",\\\"fn\\\",false]],\\\n-                [\\\"tt_tok\\\",null,[\\\"IDENT\\\",\\\"a\\\",false]],\\\n-                [\\\n-                    \\\"tt_delim\\\",\\\n-                    [\\\n-                        [\\\"tt_tok\\\",null,\\\"LPAREN\\\"],\\\n-                        [\\\"tt_tok\\\",null,[\\\"IDENT\\\",\\\"b\\\",false]],\\\n-                        [\\\"tt_tok\\\",null,\\\"COLON\\\"],\\\n-                        [\\\"tt_tok\\\",null,[\\\"IDENT\\\",\\\"int\\\",false]],\\\n-                        [\\\"tt_tok\\\",null,\\\"RPAREN\\\"]\\\n+        ~\"[\\\n+    {\\\n+        \\\"variant\\\":\\\"tt_tok\\\",\\\n+        \\\"fields\\\":[\\\n+            null,\\\n+            {\\\n+                \\\"variant\\\":\\\"IDENT\\\",\\\n+                \\\"fields\\\":[\\\n+                    \\\"fn\\\",\\\n+                    false\\\n+                ]\\\n+            }\\\n+        ]\\\n+    },\\\n+    {\\\n+        \\\"variant\\\":\\\"tt_tok\\\",\\\n+        \\\"fields\\\":[\\\n+            null,\\\n+            {\\\n+                \\\"variant\\\":\\\"IDENT\\\",\\\n+                \\\"fields\\\":[\\\n+                    \\\"a\\\",\\\n+                    false\\\n+                ]\\\n+            }\\\n+        ]\\\n+    },\\\n+    {\\\n+        \\\"variant\\\":\\\"tt_delim\\\",\\\n+        \\\"fields\\\":[\\\n+            [\\\n+                {\\\n+                    \\\"variant\\\":\\\"tt_tok\\\",\\\n+                    \\\"fields\\\":[\\\n+                        null,\\\n+                        \\\"LPAREN\\\"\\\n                     ]\\\n-                ],\\\n-                [\\\n-                    \\\"tt_delim\\\",\\\n-                    [\\\n-                        [\\\"tt_tok\\\",null,\\\"LBRACE\\\"],\\\n-                        [\\\"tt_tok\\\",null,[\\\"IDENT\\\",\\\"b\\\",false]],\\\n-                        [\\\"tt_tok\\\",null,\\\"SEMI\\\"],\\\n-                        [\\\"tt_tok\\\",null,\\\"RBRACE\\\"]\\\n+                },\\\n+                {\\\n+                    \\\"variant\\\":\\\"tt_tok\\\",\\\n+                    \\\"fields\\\":[\\\n+                        null,\\\n+                        {\\\n+                            \\\"variant\\\":\\\"IDENT\\\",\\\n+                            \\\"fields\\\":[\\\n+                                \\\"b\\\",\\\n+                                false\\\n+                            ]\\\n+                        }\\\n                     ]\\\n-                ]\\\n-            ]\"\n-                  );\n+                },\\\n+                {\\\n+                    \\\"variant\\\":\\\"tt_tok\\\",\\\n+                    \\\"fields\\\":[\\\n+                        null,\\\n+                        \\\"COLON\\\"\\\n+                    ]\\\n+                },\\\n+                {\\\n+                    \\\"variant\\\":\\\"tt_tok\\\",\\\n+                    \\\"fields\\\":[\\\n+                        null,\\\n+                        {\\\n+                            \\\"variant\\\":\\\"IDENT\\\",\\\n+                            \\\"fields\\\":[\\\n+                                \\\"int\\\",\\\n+                                false\\\n+                            ]\\\n+                        }\\\n+                    ]\\\n+                },\\\n+                {\\\n+                    \\\"variant\\\":\\\"tt_tok\\\",\\\n+                    \\\"fields\\\":[\\\n+                        null,\\\n+                        \\\"RPAREN\\\"\\\n+                    ]\\\n+                }\\\n+            ]\\\n+        ]\\\n+    },\\\n+    {\\\n+        \\\"variant\\\":\\\"tt_delim\\\",\\\n+        \\\"fields\\\":[\\\n+            [\\\n+                {\\\n+                    \\\"variant\\\":\\\"tt_tok\\\",\\\n+                    \\\"fields\\\":[\\\n+                        null,\\\n+                        \\\"LBRACE\\\"\\\n+                    ]\\\n+                },\\\n+                {\\\n+                    \\\"variant\\\":\\\"tt_tok\\\",\\\n+                    \\\"fields\\\":[\\\n+                        null,\\\n+                        {\\\n+                            \\\"variant\\\":\\\"IDENT\\\",\\\n+                            \\\"fields\\\":[\\\n+                                \\\"b\\\",\\\n+                                false\\\n+                            ]\\\n+                        }\\\n+                    ]\\\n+                },\\\n+                {\\\n+                    \\\"variant\\\":\\\"tt_tok\\\",\\\n+                    \\\"fields\\\":[\\\n+                        null,\\\n+                        \\\"SEMI\\\"\\\n+                    ]\\\n+                },\\\n+                {\\\n+                    \\\"variant\\\":\\\"tt_tok\\\",\\\n+                    \\\"fields\\\":[\\\n+                        null,\\\n+                        \\\"RBRACE\\\"\\\n+                    ]\\\n+                }\\\n+            ]\\\n+        ]\\\n+    }\\\n+]\"\n+        );\n     }\n \n     #[test] fn ret_expr() {"}]}