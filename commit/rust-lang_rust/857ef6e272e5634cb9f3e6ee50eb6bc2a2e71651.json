{"sha": "857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1N2VmNmUyNzJlNTYzNGNiOWYzZTZlZTUwZWI2YmMyYTJlNzE2NTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-27T16:45:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-27T16:45:21Z"}, "message": "Auto merge of #23606 - quantheory:associated_const, r=nikomatsakis\n\nCloses #17841.\r\n\r\nThe majority of the work should be done, e.g. trait and inherent impls, different forms of UFCS syntax, defaults, and cross-crate usage. It's probably enough to replace the constants in `f32`, `i8`, and so on, or close to good enough.\r\n\r\nThere is still some significant functionality missing from this commit:\r\n\r\n - ~~Associated consts can't be used in match patterns at all. This is simply because I haven't updated the relevant bits in the parser or `resolve`, but it's *probably* not hard to get working.~~\r\n - Since you can't select an impl for trait-associated consts until partway through type-checking, there are some problems with code that assumes that you can check constants earlier. Associated consts that are not in inherent impls cause ICEs if you try to use them in array sizes or match ranges. For similar reasons, `check_static_recursion` doesn't check them properly, so the stack goes ka-blooey if you use an associated constant that's recursively defined. That's a bit trickier to solve; I'm not entirely sure what the best approach is yet.\r\n - Dealing with consts associated with type parameters will raise some new issues (e.g. if you have a `T: Int` type parameter and want to use `<T>::ZERO`). See rust-lang/rfcs#865.\r\n - ~~Unused associated consts don't seem to trigger the `dead_code` lint when they should. Probably easy to fix.~~\r\n\r\nAlso, this is the first time I've been spelunking in rustc to such a large extent, so I've probably done some silly things in a couple of places.", "tree": {"sha": "4ac530a87a187d61ae509897694089d908050033", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ac530a87a187d61ae509897694089d908050033"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "html_url": "https://github.com/rust-lang/rust/commit/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32f9f4276271bac1b8c3bc569ceed5cfaf992f29", "url": "https://api.github.com/repos/rust-lang/rust/commits/32f9f4276271bac1b8c3bc569ceed5cfaf992f29", "html_url": "https://github.com/rust-lang/rust/commit/32f9f4276271bac1b8c3bc569ceed5cfaf992f29"}, {"sha": "4c0ac6d5ef8aed2cbe0cc687d5e7f8a8c04961a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c0ac6d5ef8aed2cbe0cc687d5e7f8a8c04961a3", "html_url": "https://github.com/rust-lang/rust/commit/4c0ac6d5ef8aed2cbe0cc687d5e7f8a8c04961a3"}], "stats": {"total": 3525, "additions": 2801, "deletions": 724}, "files": [{"sha": "a71f8cf4250a6465f5ce6a0799f409a509032f30", "filename": "src/doc/reference.md", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -2135,7 +2135,10 @@ The currently implemented features of the reference compiler are:\n           semantics are likely to change, so this macro usage must be opted\n           into.\n \n-* `associated_types` - Allows type aliases in traits. Experimental.\n+* `associated_consts` - Allows constants to be defined in `impl` and `trait`\n+                        blocks, so that they can be associated with a type or\n+                        trait in a similar manner to methods and associated\n+                        types.\n \n * `box_patterns` - Allows `box` patterns, the exact semantics of which\n                    is subject to change."}, {"sha": "27e15bc2f0eeaa044a8e7a8dd301e232c28e3b3e", "filename": "src/grammar/parser-lalr.y", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Fgrammar%2Fparser-lalr.y", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Fgrammar%2Fparser-lalr.y", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fparser-lalr.y?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -505,10 +505,20 @@ trait_items\n ;\n \n trait_item\n-: trait_type\n+: trait_const\n+| trait_type\n | trait_method\n ;\n \n+trait_const\n+: maybe_outer_attrs CONST ident maybe_const_default ';' { $$ = mk_node(\"ConstTraitItem\", 3, $1, $3, $4); }\n+;\n+\n+maybe_const_default\n+: '=' expr { $$ = mk_node(\"ConstDefault\", 1, $2); }\n+| %empty   { $$ = mk_none(); }\n+;\n+\n trait_type\n : maybe_outer_attrs TYPE ty_param ';' { $$ = mk_node(\"TypeTraitItem\", 2, $1, $3); }\n ;\n@@ -611,7 +621,16 @@ impl_items\n impl_item\n : impl_method\n | item_macro\n-| trait_type\n+| impl_const\n+| impl_type\n+;\n+\n+impl_const\n+: attrs_and_vis item_const { $$ = mk_node(\"ImplConst\", 1, $1, $2); }\n+;\n+\n+impl_type\n+: attrs_and_vis TYPE ident generic_params '=' ty_sum ';'  { $$ = mk_node(\"ImplType\", 4, $1, $3, $4, $6); }\n ;\n \n item_fn"}, {"sha": "93056d949dbb07bfde8188d0823058ae0899c788", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -175,6 +175,13 @@ pub fn get_provided_trait_methods<'tcx>(tcx: &ty::ctxt<'tcx>,\n     decoder::get_provided_trait_methods(cstore.intr.clone(), &*cdata, def.node, tcx)\n }\n \n+pub fn get_associated_consts<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId)\n+                                   -> Vec<Rc<ty::AssociatedConst<'tcx>>> {\n+    let cstore = &tcx.sess.cstore;\n+    let cdata = cstore.get_crate_data(def.krate);\n+    decoder::get_associated_consts(cstore.intr.clone(), &*cdata, def.node, tcx)\n+}\n+\n pub fn get_type_name_if_impl(cstore: &cstore::CStore, def: ast::DefId)\n                           -> Option<ast::Name> {\n     let cdata = cstore.get_crate_data(def.krate);"}, {"sha": "f03a2d342d7be0d567562ab380070d4f4d3ffc48", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 65, "deletions": 6, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -305,7 +305,25 @@ fn item_to_def_like(item: rbml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n     -> DefLike {\n     let fam = item_family(item);\n     match fam {\n-        Constant  => DlDef(def::DefConst(did)),\n+        Constant  => {\n+            // Check whether we have an associated const item.\n+            if item_sort(item) == Some('C') {\n+                // Check whether the associated const is from a trait or impl.\n+                // See the comment for methods below.\n+                let provenance = if reader::maybe_get_doc(\n+                      item, tag_item_trait_parent_sort).is_some() {\n+                    def::FromTrait(item_reqd_and_translated_parent_item(cnum,\n+                                                                        item))\n+                } else {\n+                    def::FromImpl(item_reqd_and_translated_parent_item(cnum,\n+                                                                       item))\n+                };\n+                DlDef(def::DefAssociatedConst(did, provenance))\n+            } else {\n+                // Regular const item.\n+                DlDef(def::DefConst(did))\n+            }\n+        }\n         ImmStatic => DlDef(def::DefStatic(did, false)),\n         MutStatic => DlDef(def::DefStatic(did, true)),\n         Struct    => DlDef(def::DefStruct(did)),\n@@ -826,6 +844,7 @@ pub fn get_impl_items(cdata: Cmd, impl_id: ast::NodeId)\n                         tag_item_impl_item, |doc| {\n         let def_id = item_def_id(doc, cdata);\n         match item_sort(doc) {\n+            Some('C') => impl_items.push(ty::ConstTraitItemId(def_id)),\n             Some('r') | Some('p') => {\n                 impl_items.push(ty::MethodTraitItemId(def_id))\n             }\n@@ -877,6 +896,18 @@ pub fn get_impl_or_trait_item<'tcx>(intr: Rc<IdentInterner>,\n     let vis = item_visibility(method_doc);\n \n     match item_sort(method_doc) {\n+        Some('C') => {\n+            let ty = doc_type(method_doc, tcx, cdata);\n+            let default = get_provided_source(method_doc, cdata);\n+            ty::ConstTraitItem(Rc::new(ty::AssociatedConst {\n+                name: name,\n+                ty: ty,\n+                vis: vis,\n+                def_id: def_id,\n+                container: container,\n+                default: default,\n+            }))\n+        }\n         Some('r') | Some('p') => {\n             let generics = doc_generics(method_doc, tcx, cdata, tag_method_ty_generics);\n             let predicates = doc_predicates(method_doc, tcx, cdata, tag_method_ty_generics);\n@@ -914,6 +945,7 @@ pub fn get_trait_item_def_ids(cdata: Cmd, id: ast::NodeId)\n     reader::tagged_docs(item, tag_item_trait_item, |mth| {\n         let def_id = item_def_id(mth, cdata);\n         match item_sort(mth) {\n+            Some('C') => result.push(ty::ConstTraitItemId(def_id)),\n             Some('r') | Some('p') => {\n                 result.push(ty::MethodTraitItemId(def_id));\n             }\n@@ -951,11 +983,8 @@ pub fn get_provided_trait_methods<'tcx>(intr: Rc<IdentInterner>,\n                                                     cdata,\n                                                     did.node,\n                                                     tcx);\n-            match trait_item {\n-                ty::MethodTraitItem(ref method) => {\n-                    result.push((*method).clone())\n-                }\n-                ty::TypeTraitItem(_) => {}\n+            if let ty::MethodTraitItem(ref method) = trait_item {\n+                result.push((*method).clone())\n             }\n         }\n         true\n@@ -964,6 +993,36 @@ pub fn get_provided_trait_methods<'tcx>(intr: Rc<IdentInterner>,\n     return result;\n }\n \n+pub fn get_associated_consts<'tcx>(intr: Rc<IdentInterner>,\n+                                   cdata: Cmd,\n+                                   id: ast::NodeId,\n+                                   tcx: &ty::ctxt<'tcx>)\n+                                   -> Vec<Rc<ty::AssociatedConst<'tcx>>> {\n+    let data = cdata.data();\n+    let item = lookup_item(id, data);\n+    let mut result = Vec::new();\n+\n+    for &tag in &[tag_item_trait_item, tag_item_impl_item] {\n+        reader::tagged_docs(item, tag, |ac_id| {\n+            let did = item_def_id(ac_id, cdata);\n+            let ac_doc = lookup_item(did.node, data);\n+\n+            if item_sort(ac_doc) == Some('C') {\n+                let trait_item = get_impl_or_trait_item(intr.clone(),\n+                                                        cdata,\n+                                                        did.node,\n+                                                        tcx);\n+                if let ty::ConstTraitItem(ref ac) = trait_item {\n+                    result.push((*ac).clone())\n+                }\n+            }\n+            true\n+        });\n+    }\n+\n+    return result;\n+}\n+\n pub fn get_type_name_if_impl(cdata: Cmd,\n                              node_id: ast::NodeId) -> Option<ast::Name> {\n     let item = lookup_item(node_id, cdata.data());"}, {"sha": "bcbb350fc34ee7b12489c9d0ee23dd771865d7a1", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 82, "deletions": 11, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -378,14 +378,11 @@ fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n                     let impl_item = ty::impl_or_trait_item(\n                         ecx.tcx,\n                         method_did.def_id());\n-                    match impl_item {\n-                        ty::MethodTraitItem(ref m) => {\n-                            encode_reexported_static_method(rbml_w,\n-                                                            exp,\n-                                                            m.def_id,\n-                                                            m.name);\n-                        }\n-                        ty::TypeTraitItem(_) => {}\n+                    if let ty::MethodTraitItem(ref m) = impl_item {\n+                        encode_reexported_static_method(rbml_w,\n+                                                        exp,\n+                                                        m.def_id,\n+                                                        m.name);\n                     }\n                 }\n             }\n@@ -802,6 +799,43 @@ fn encode_method_ty_fields<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     encode_provided_source(rbml_w, method_ty.provided_source);\n }\n \n+fn encode_info_for_associated_const(ecx: &EncodeContext,\n+                                    rbml_w: &mut Encoder,\n+                                    associated_const: &ty::AssociatedConst,\n+                                    impl_path: PathElems,\n+                                    parent_id: NodeId,\n+                                    impl_item_opt: Option<&ast::ImplItem>) {\n+    debug!(\"encode_info_for_associated_const({:?},{:?})\",\n+           associated_const.def_id,\n+           token::get_name(associated_const.name));\n+\n+    rbml_w.start_tag(tag_items_data_item);\n+\n+    encode_def_id(rbml_w, associated_const.def_id);\n+    encode_name(rbml_w, associated_const.name);\n+    encode_visibility(rbml_w, associated_const.vis);\n+    encode_family(rbml_w, 'C');\n+    encode_provided_source(rbml_w, associated_const.default);\n+\n+    encode_parent_item(rbml_w, local_def(parent_id));\n+    encode_item_sort(rbml_w, 'C');\n+\n+    encode_bounds_and_type_for_item(rbml_w, ecx, associated_const.def_id.local_id());\n+\n+    let stab = stability::lookup(ecx.tcx, associated_const.def_id);\n+    encode_stability(rbml_w, stab);\n+\n+    let elem = ast_map::PathName(associated_const.name);\n+    encode_path(rbml_w, impl_path.chain(Some(elem).into_iter()));\n+\n+    if let Some(ii) = impl_item_opt {\n+        encode_attributes(rbml_w, &ii.attrs);\n+        encode_inlined_item(ecx, rbml_w, IIImplItemRef(local_def(parent_id), ii));\n+    }\n+\n+    rbml_w.end_tag();\n+}\n+\n fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                     rbml_w: &mut Encoder,\n                                     m: &ty::Method<'tcx>,\n@@ -1195,6 +1229,10 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         for &item_def_id in items {\n             rbml_w.start_tag(tag_item_impl_item);\n             match item_def_id {\n+                ty::ConstTraitItemId(item_def_id) => {\n+                    encode_def_id(rbml_w, item_def_id);\n+                    encode_item_sort(rbml_w, 'C');\n+                }\n                 ty::MethodTraitItemId(item_def_id) => {\n                     encode_def_id(rbml_w, item_def_id);\n                     encode_item_sort(rbml_w, 'r');\n@@ -1232,6 +1270,14 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             });\n \n             match ty::impl_or_trait_item(tcx, trait_item_def_id.def_id()) {\n+                ty::ConstTraitItem(ref associated_const) => {\n+                    encode_info_for_associated_const(ecx,\n+                                                     rbml_w,\n+                                                     &*associated_const,\n+                                                     path.clone(),\n+                                                     item.id,\n+                                                     ast_item)\n+                }\n                 ty::MethodTraitItem(ref method_type) => {\n                     encode_info_for_method(ecx,\n                                            rbml_w,\n@@ -1276,6 +1322,10 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         for &method_def_id in &*ty::trait_item_def_ids(tcx, def_id) {\n             rbml_w.start_tag(tag_item_trait_item);\n             match method_def_id {\n+                ty::ConstTraitItemId(const_def_id) => {\n+                    encode_def_id(rbml_w, const_def_id);\n+                    encode_item_sort(rbml_w, 'C');\n+                }\n                 ty::MethodTraitItemId(method_def_id) => {\n                     encode_def_id(rbml_w, method_def_id);\n                     encode_item_sort(rbml_w, 'r');\n@@ -1321,6 +1371,25 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                 ty::impl_or_trait_item(tcx, item_def_id.def_id());\n             let is_nonstatic_method;\n             match trait_item_type {\n+                ty::ConstTraitItem(associated_const) => {\n+                    encode_name(rbml_w, associated_const.name);\n+                    encode_def_id(rbml_w, associated_const.def_id);\n+                    encode_visibility(rbml_w, associated_const.vis);\n+\n+                    encode_provided_source(rbml_w, associated_const.default);\n+\n+                    let elem = ast_map::PathName(associated_const.name);\n+                    encode_path(rbml_w,\n+                                path.clone().chain(Some(elem).into_iter()));\n+\n+                    encode_item_sort(rbml_w, 'C');\n+                    encode_family(rbml_w, 'C');\n+\n+                    encode_bounds_and_type_for_item(rbml_w, ecx,\n+                                                    associated_const.def_id.local_id());\n+\n+                    is_nonstatic_method = false;\n+                }\n                 ty::MethodTraitItem(method_ty) => {\n                     let method_def_id = item_def_id.def_id();\n \n@@ -1365,6 +1434,10 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             let trait_item = &*ms[i];\n             encode_attributes(rbml_w, &trait_item.attrs);\n             match trait_item.node {\n+                ast::ConstTraitItem(_, _) => {\n+                    encode_inlined_item(ecx, rbml_w,\n+                                        IITraitItemRef(def_id, trait_item));\n+                }\n                 ast::MethodTraitItem(ref sig, ref body) => {\n                     // If this is a static method, we've already\n                     // encoded this.\n@@ -1384,9 +1457,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                     encode_method_argument_names(rbml_w, &sig.decl);\n                 }\n \n-                ast::TypeTraitItem(..) => {\n-                    encode_item_sort(rbml_w, 't');\n-                }\n+                ast::TypeTraitItem(..) => {}\n             }\n \n             rbml_w.end_tag();"}, {"sha": "3ef22ba8158b0ce69f93e622627cfcc7591cd59e", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -465,6 +465,9 @@ impl tr for def::Def {\n           def::DefForeignMod(did) => { def::DefForeignMod(did.tr(dcx)) }\n           def::DefStatic(did, m) => { def::DefStatic(did.tr(dcx), m) }\n           def::DefConst(did) => { def::DefConst(did.tr(dcx)) }\n+          def::DefAssociatedConst(did, p) => {\n+              def::DefAssociatedConst(did.tr(dcx), p.map(|did2| did2.tr(dcx)))\n+          }\n           def::DefLocal(nid) => { def::DefLocal(dcx.tr_id(nid)) }\n           def::DefVariant(e_did, v_did, is_s) => {\n             def::DefVariant(e_did.tr(dcx), v_did.tr(dcx), is_s)"}, {"sha": "a7950a701f8c4fce0c96045d6ca81dcfa2c24db2", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -105,6 +105,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         match pat.node {\n             ast::PatIdent(_, _, None) |\n             ast::PatEnum(_, None) |\n+            ast::PatQPath(..) |\n             ast::PatLit(..) |\n             ast::PatRange(..) |\n             ast::PatWild(_) => {"}, {"sha": "80326229618c23d05a28312c194c8506cc6675a6", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -223,6 +223,28 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n         }\n     }\n \n+    fn visit_trait_item(&mut self, t: &'v ast::TraitItem) {\n+        match t.node {\n+            ast::ConstTraitItem(_, ref default) => {\n+                if let Some(ref expr) = *default {\n+                    self.global_expr(Mode::Const, &*expr);\n+                } else {\n+                    visit::walk_trait_item(self, t);\n+                }\n+            }\n+            _ => self.with_mode(Mode::Var, |v| visit::walk_trait_item(v, t)),\n+        }\n+    }\n+\n+    fn visit_impl_item(&mut self, i: &'v ast::ImplItem) {\n+        match i.node {\n+            ast::ConstImplItem(_, ref expr) => {\n+                self.global_expr(Mode::Const, &*expr);\n+            }\n+            _ => self.with_mode(Mode::Var, |v| visit::walk_impl_item(v, i)),\n+        }\n+    }\n+\n     fn visit_fn(&mut self,\n                 fk: visit::FnKind<'v>,\n                 fd: &'v ast::FnDecl,\n@@ -468,13 +490,16 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                         Mode::Var => v.add_qualif(NOT_CONST)\n                     }\n                 }\n-                Some(def::DefConst(did)) => {\n-                    if let Some(expr) = const_eval::lookup_const_by_id(v.tcx, did) {\n+                Some(def::DefConst(did)) |\n+                Some(def::DefAssociatedConst(did, _)) => {\n+                    if let Some(expr) = const_eval::lookup_const_by_id(v.tcx, did,\n+                                                                       Some(e.id)) {\n                         let inner = v.global_expr(Mode::Const, expr);\n                         v.add_qualif(inner);\n                     } else {\n-                        v.tcx.sess.span_bug(e.span, \"DefConst doesn't point \\\n-                                                     to an ItemConst\");\n+                        v.tcx.sess.span_bug(e.span,\n+                                            \"DefConst or DefAssociatedConst \\\n+                                             doesn't point to a constant\");\n                     }\n                 }\n                 def => {"}, {"sha": "a5ea3629abc84ad8fcce386d44764463b80bbd74", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -439,10 +439,11 @@ impl<'map> ast_util::IdVisitingOperation for RenamingRecorder<'map> {\n impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n     fn fold_pat(&mut self, pat: P<Pat>) -> P<Pat> {\n         return match pat.node {\n-            ast::PatIdent(..) | ast::PatEnum(..) => {\n+            ast::PatIdent(..) | ast::PatEnum(..) | ast::PatQPath(..) => {\n                 let def = self.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def());\n                 match def {\n-                    Some(DefConst(did)) => match lookup_const_by_id(self.tcx, did) {\n+                    Some(DefAssociatedConst(did, _)) |\n+                    Some(DefConst(did)) => match lookup_const_by_id(self.tcx, did, Some(pat.id)) {\n                         Some(const_expr) => {\n                             const_expr_to_pat(self.tcx, const_expr, pat.span).map(|new_pat| {\n \n@@ -746,7 +747,7 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n     match pat.node {\n         ast::PatIdent(..) =>\n             match cx.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n-                Some(DefConst(..)) =>\n+                Some(DefConst(..)) | Some(DefAssociatedConst(..)) =>\n                     cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n                                                     been rewritten\"),\n                 Some(DefStruct(_)) => vec!(Single),\n@@ -755,15 +756,18 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n             },\n         ast::PatEnum(..) =>\n             match cx.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n-                Some(DefConst(..)) =>\n+                Some(DefConst(..)) | Some(DefAssociatedConst(..)) =>\n                     cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n                                                     been rewritten\"),\n                 Some(DefVariant(_, id, _)) => vec!(Variant(id)),\n                 _ => vec!(Single)\n             },\n+        ast::PatQPath(..) =>\n+            cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n+                                            been rewritten\"),\n         ast::PatStruct(..) =>\n             match cx.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n-                Some(DefConst(..)) =>\n+                Some(DefConst(..)) | Some(DefAssociatedConst(..)) =>\n                     cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n                                                     been rewritten\"),\n                 Some(DefVariant(_, id, _)) => vec!(Variant(id)),\n@@ -861,7 +865,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n         ast::PatIdent(_, _, _) => {\n             let opt_def = cx.tcx.def_map.borrow().get(&pat_id).map(|d| d.full_def());\n             match opt_def {\n-                Some(DefConst(..)) =>\n+                Some(DefConst(..)) | Some(DefAssociatedConst(..)) =>\n                     cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n                                                     been rewritten\"),\n                 Some(DefVariant(_, id, _)) => if *constructor == Variant(id) {\n@@ -876,7 +880,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n         ast::PatEnum(_, ref args) => {\n             let def = cx.tcx.def_map.borrow().get(&pat_id).unwrap().full_def();\n             match def {\n-                DefConst(..) =>\n+                DefConst(..) | DefAssociatedConst(..) =>\n                     cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n                                                     been rewritten\"),\n                 DefVariant(_, id, _) if *constructor != Variant(id) => None,\n@@ -890,11 +894,16 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             }\n         }\n \n+        ast::PatQPath(_, _) => {\n+            cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n+                                            been rewritten\")\n+        }\n+\n         ast::PatStruct(_, ref pattern_fields, _) => {\n             // Is this a struct or an enum variant?\n             let def = cx.tcx.def_map.borrow().get(&pat_id).unwrap().full_def();\n             let class_id = match def {\n-                DefConst(..) =>\n+                DefConst(..) | DefAssociatedConst(..) =>\n                     cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n                                                     been rewritten\"),\n                 DefVariant(_, variant_id, _) => if *constructor == Variant(variant_id) {"}, {"sha": "a521c4531c9a7e50e932eb81596c520754e0618d", "filename": "src/librustc/middle/check_static_recursion.rs", "status": "modified", "additions": 75, "deletions": 37, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -12,10 +12,11 @@\n // recursively.\n \n use session::Session;\n-use middle::def::{DefStatic, DefConst, DefMap};\n+use middle::def::{DefStatic, DefConst, DefAssociatedConst, DefMap};\n \n use syntax::ast;\n use syntax::{ast_util, ast_map};\n+use syntax::codemap::Span;\n use syntax::visit::Visitor;\n use syntax::visit;\n \n@@ -26,8 +27,43 @@ struct CheckCrateVisitor<'a, 'ast: 'a> {\n }\n \n impl<'v, 'a, 'ast> Visitor<'v> for CheckCrateVisitor<'a, 'ast> {\n-    fn visit_item(&mut self, i: &ast::Item) {\n-        check_item(self, i);\n+    fn visit_item(&mut self, it: &ast::Item) {\n+        match it.node {\n+            ast::ItemStatic(_, _, ref expr) |\n+            ast::ItemConst(_, ref expr) => {\n+                let mut recursion_visitor =\n+                    CheckItemRecursionVisitor::new(self, &it.span);\n+                recursion_visitor.visit_item(it);\n+                visit::walk_expr(self, &*expr)\n+            },\n+            _ => visit::walk_item(self, it)\n+        }\n+    }\n+\n+    fn visit_trait_item(&mut self, ti: &ast::TraitItem) {\n+        match ti.node {\n+            ast::ConstTraitItem(_, ref default) => {\n+                if let Some(ref expr) = *default {\n+                    let mut recursion_visitor =\n+                        CheckItemRecursionVisitor::new(self, &ti.span);\n+                    recursion_visitor.visit_trait_item(ti);\n+                    visit::walk_expr(self, &*expr)\n+                }\n+            }\n+            _ => visit::walk_trait_item(self, ti)\n+        }\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &ast::ImplItem) {\n+        match ii.node {\n+            ast::ConstImplItem(_, ref expr) => {\n+                let mut recursion_visitor =\n+                    CheckItemRecursionVisitor::new(self, &ii.span);\n+                recursion_visitor.visit_impl_item(ii);\n+                visit::walk_expr(self, &*expr)\n+            }\n+            _ => visit::walk_impl_item(self, ii)\n+        }\n     }\n }\n \n@@ -44,63 +80,65 @@ pub fn check_crate<'ast>(sess: &Session,\n     sess.abort_if_errors();\n }\n \n-fn check_item(v: &mut CheckCrateVisitor, it: &ast::Item) {\n-    match it.node {\n-        ast::ItemStatic(_, _, ref ex) |\n-        ast::ItemConst(_, ref ex) => {\n-            check_item_recursion(v.sess, v.ast_map, v.def_map, it);\n-            visit::walk_expr(v, &**ex)\n-        },\n-        _ => visit::walk_item(v, it)\n-    }\n-}\n-\n struct CheckItemRecursionVisitor<'a, 'ast: 'a> {\n-    root_it: &'a ast::Item,\n+    root_span: &'a Span,\n     sess: &'a Session,\n     ast_map: &'a ast_map::Map<'ast>,\n     def_map: &'a DefMap,\n     idstack: Vec<ast::NodeId>\n }\n \n-// Make sure a const item doesn't recursively refer to itself\n-// FIXME: Should use the dependency graph when it's available (#1356)\n-pub fn check_item_recursion<'a>(sess: &'a Session,\n-                                ast_map: &'a ast_map::Map,\n-                                def_map: &'a DefMap,\n-                                it: &'a ast::Item) {\n-\n-    let mut visitor = CheckItemRecursionVisitor {\n-        root_it: it,\n-        sess: sess,\n-        ast_map: ast_map,\n-        def_map: def_map,\n-        idstack: Vec::new()\n-    };\n-    visitor.visit_item(it);\n+impl<'a, 'ast: 'a> CheckItemRecursionVisitor<'a, 'ast> {\n+    fn new(v: &CheckCrateVisitor<'a, 'ast>, span: &'a Span)\n+           -> CheckItemRecursionVisitor<'a, 'ast> {\n+        CheckItemRecursionVisitor {\n+            root_span: span,\n+            sess: v.sess,\n+            ast_map: v.ast_map,\n+            def_map: v.def_map,\n+            idstack: Vec::new()\n+        }\n+    }\n+    fn with_item_id_pushed<F>(&mut self, id: ast::NodeId, f: F)\n+          where F: Fn(&mut Self) {\n+        if self.idstack.iter().any(|x| x == &(id)) {\n+            span_err!(self.sess, *self.root_span, E0265, \"recursive constant\");\n+            return;\n+        }\n+        self.idstack.push(id);\n+        f(self);\n+        self.idstack.pop();\n+    }\n }\n \n impl<'a, 'ast, 'v> Visitor<'v> for CheckItemRecursionVisitor<'a, 'ast> {\n     fn visit_item(&mut self, it: &ast::Item) {\n-        if self.idstack.iter().any(|x| x == &(it.id)) {\n-            span_err!(self.sess, self.root_it.span, E0265, \"recursive constant\");\n-            return;\n-        }\n-        self.idstack.push(it.id);\n-        visit::walk_item(self, it);\n-        self.idstack.pop();\n+        self.with_item_id_pushed(it.id, |v| visit::walk_item(v, it));\n+    }\n+\n+    fn visit_trait_item(&mut self, ti: &ast::TraitItem) {\n+        self.with_item_id_pushed(ti.id, |v| visit::walk_trait_item(v, ti));\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &ast::ImplItem) {\n+        self.with_item_id_pushed(ii.id, |v| visit::walk_impl_item(v, ii));\n     }\n \n     fn visit_expr(&mut self, e: &ast::Expr) {\n         match e.node {\n             ast::ExprPath(..) => {\n                 match self.def_map.borrow().get(&e.id).map(|d| d.base_def) {\n                     Some(DefStatic(def_id, _)) |\n+                    Some(DefAssociatedConst(def_id, _)) |\n                     Some(DefConst(def_id)) if\n                             ast_util::is_local(def_id) => {\n                         match self.ast_map.get(def_id.node) {\n                           ast_map::NodeItem(item) =>\n                             self.visit_item(item),\n+                          ast_map::NodeTraitItem(item) =>\n+                            self.visit_trait_item(item),\n+                          ast_map::NodeImplItem(item) =>\n+                            self.visit_impl_item(item),\n                           ast_map::NodeForeignItem(_) => {},\n                           _ => {\n                             span_err!(self.sess, e.span, E0266,"}, {"sha": "916874f1c51a8ec2eeb24e79ed30e60c89f1b367", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 164, "deletions": 9, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -16,11 +16,12 @@ pub use self::const_val::*;\n use self::ErrKind::*;\n \n use metadata::csearch;\n-use middle::{astencode, def};\n+use middle::{astencode, def, infer, subst, traits};\n use middle::pat_util::def_to_path;\n use middle::ty::{self, Ty};\n use middle::astconv_util::ast_ty_to_prim_ty;\n use util::num::ToPrimitive;\n+use util::ppaux::Repr;\n \n use syntax::ast::{self, Expr};\n use syntax::codemap::Span;\n@@ -39,8 +40,9 @@ use std::rc::Rc;\n fn lookup_const<'a>(tcx: &'a ty::ctxt, e: &Expr) -> Option<&'a Expr> {\n     let opt_def = tcx.def_map.borrow().get(&e.id).map(|d| d.full_def());\n     match opt_def {\n-        Some(def::DefConst(def_id)) => {\n-            lookup_const_by_id(tcx, def_id)\n+        Some(def::DefConst(def_id)) |\n+        Some(def::DefAssociatedConst(def_id, _)) => {\n+            lookup_const_by_id(tcx, def_id, Some(e.id))\n         }\n         Some(def::DefVariant(enum_def, variant_def, _)) => {\n             lookup_variant_by_id(tcx, enum_def, variant_def)\n@@ -101,14 +103,46 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::ctxt,\n     }\n }\n \n-pub fn lookup_const_by_id<'a>(tcx: &'a ty::ctxt, def_id: ast::DefId)\n-                          -> Option<&'a Expr> {\n+pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n+                                        def_id: ast::DefId,\n+                                        maybe_ref_id: Option<ast::NodeId>)\n+                                        -> Option<&'tcx Expr> {\n     if ast_util::is_local(def_id) {\n         match tcx.map.find(def_id.node) {\n             None => None,\n             Some(ast_map::NodeItem(it)) => match it.node {\n                 ast::ItemConst(_, ref const_expr) => {\n-                    Some(&**const_expr)\n+                    Some(&*const_expr)\n+                }\n+                _ => None\n+            },\n+            Some(ast_map::NodeTraitItem(ti)) => match ti.node {\n+                ast::ConstTraitItem(_, _) => {\n+                    match maybe_ref_id {\n+                        // If we have a trait item, and we know the expression\n+                        // that's the source of the obligation to resolve it,\n+                        // `resolve_trait_associated_const` will select an impl\n+                        // or the default.\n+                        Some(ref_id) => {\n+                            let trait_id = ty::trait_of_item(tcx, def_id)\n+                                              .unwrap();\n+                            resolve_trait_associated_const(tcx, ti, trait_id,\n+                                                           ref_id)\n+                        }\n+                        // Technically, without knowing anything about the\n+                        // expression that generates the obligation, we could\n+                        // still return the default if there is one. However,\n+                        // it's safer to return `None` than to return some value\n+                        // that may differ from what you would get from\n+                        // correctly selecting an impl.\n+                        None => None\n+                    }\n+                }\n+                _ => None\n+            },\n+            Some(ast_map::NodeImplItem(ii)) => match ii.node {\n+                ast::ConstImplItem(_, ref expr) => {\n+                    Some(&*expr)\n                 }\n                 _ => None\n             },\n@@ -122,16 +156,44 @@ pub fn lookup_const_by_id<'a>(tcx: &'a ty::ctxt, def_id: ast::DefId)\n             }\n             None => {}\n         }\n+        let mut used_ref_id = false;\n         let expr_id = match csearch::maybe_get_item_ast(tcx, def_id,\n             Box::new(|a, b, c, d| astencode::decode_inlined_item(a, b, c, d))) {\n             csearch::FoundAst::Found(&ast::IIItem(ref item)) => match item.node {\n                 ast::ItemConst(_, ref const_expr) => Some(const_expr.id),\n                 _ => None\n             },\n+            csearch::FoundAst::Found(&ast::IITraitItem(trait_id, ref ti)) => match ti.node {\n+                ast::ConstTraitItem(_, _) => {\n+                    used_ref_id = true;\n+                    match maybe_ref_id {\n+                        // As mentioned in the comments above for in-crate\n+                        // constants, we only try to find the expression for\n+                        // a trait-associated const if the caller gives us\n+                        // the expression that refers to it.\n+                        Some(ref_id) => {\n+                            resolve_trait_associated_const(tcx, ti, trait_id,\n+                                                           ref_id).map(|e| e.id)\n+                        }\n+                        None => None\n+                    }\n+                }\n+                _ => None\n+            },\n+            csearch::FoundAst::Found(&ast::IIImplItem(_, ref ii)) => match ii.node {\n+                ast::ConstImplItem(_, ref expr) => Some(expr.id),\n+                _ => None\n+            },\n             _ => None\n         };\n-        tcx.extern_const_statics.borrow_mut().insert(def_id,\n-                                                     expr_id.unwrap_or(ast::DUMMY_NODE_ID));\n+        // If we used the reference expression, particularly to choose an impl\n+        // of a trait-associated const, don't cache that, because the next\n+        // lookup with the same def_id may yield a different result.\n+        if !used_ref_id {\n+            tcx.extern_const_statics\n+               .borrow_mut().insert(def_id,\n+                                    expr_id.unwrap_or(ast::DUMMY_NODE_ID));\n+        }\n         expr_id.map(|id| tcx.map.expect_expr(id))\n     }\n }\n@@ -755,7 +817,35 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                           _ => (None, None)\n                       }\n                   } else {\n-                      (lookup_const_by_id(tcx, def_id), None)\n+                      (lookup_const_by_id(tcx, def_id, Some(e.id)), None)\n+                  }\n+              }\n+              Some(def::DefAssociatedConst(def_id, provenance)) => {\n+                  if ast_util::is_local(def_id) {\n+                      match provenance {\n+                          def::FromTrait(trait_id) => match tcx.map.find(def_id.node) {\n+                              Some(ast_map::NodeTraitItem(ti)) => match ti.node {\n+                                  ast::ConstTraitItem(ref ty, _) => {\n+                                      (resolve_trait_associated_const(tcx, ti,\n+                                                                      trait_id, e.id),\n+                                       Some(&**ty))\n+                                  }\n+                                  _ => (None, None)\n+                              },\n+                              _ => (None, None)\n+                          },\n+                          def::FromImpl(_) => match tcx.map.find(def_id.node) {\n+                              Some(ast_map::NodeImplItem(ii)) => match ii.node {\n+                                  ast::ConstImplItem(ref ty, ref expr) => {\n+                                      (Some(&**expr), Some(&**ty))\n+                                  }\n+                                  _ => (None, None)\n+                              },\n+                              _ => (None, None)\n+                          },\n+                      }\n+                  } else {\n+                      (lookup_const_by_id(tcx, def_id, Some(e.id)), None)\n                   }\n               }\n               Some(def::DefVariant(enum_def, variant_def, _)) => {\n@@ -833,6 +923,71 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n     Ok(result)\n }\n \n+fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n+                                                ti: &'tcx ast::TraitItem,\n+                                                trait_id: ast::DefId,\n+                                                ref_id: ast::NodeId)\n+                                                -> Option<&'tcx Expr>\n+{\n+    let rcvr_substs = ty::node_id_item_substs(tcx, ref_id).substs;\n+    let subst::SeparateVecsPerParamSpace {\n+        types: rcvr_type,\n+        selfs: rcvr_self,\n+        fns: _,\n+    } = rcvr_substs.types.split();\n+    let trait_substs =\n+        subst::Substs::erased(subst::VecPerParamSpace::new(rcvr_type,\n+                                                           rcvr_self,\n+                                                           Vec::new()));\n+    let trait_substs = tcx.mk_substs(trait_substs);\n+    debug!(\"resolve_trait_associated_const: trait_substs={}\",\n+           trait_substs.repr(tcx));\n+    let trait_ref = ty::Binder(Rc::new(ty::TraitRef { def_id: trait_id,\n+                                                      substs: trait_substs }));\n+\n+    ty::populate_implementations_for_trait_if_necessary(tcx, trait_ref.def_id());\n+    let infcx = infer::new_infer_ctxt(tcx);\n+\n+    let param_env = ty::empty_parameter_environment(tcx);\n+    let mut selcx = traits::SelectionContext::new(&infcx, &param_env);\n+    let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n+                                             trait_ref.to_poly_trait_predicate());\n+    let selection = match selcx.select(&obligation) {\n+        Ok(Some(vtable)) => vtable,\n+        // Still ambiguous, so give up and let the caller decide whether this\n+        // expression is really needed yet. Some associated constant values\n+        // can't be evaluated until monomorphization is done in trans.\n+        Ok(None) => {\n+            return None\n+        }\n+        Err(e) => {\n+            tcx.sess.span_bug(ti.span,\n+                              &format!(\"Encountered error `{}` when trying \\\n+                                        to select an implementation for \\\n+                                        constant trait item reference.\",\n+                                       e.repr(tcx)))\n+        }\n+    };\n+\n+    match selection {\n+        traits::VtableImpl(ref impl_data) => {\n+            match ty::associated_consts(tcx, impl_data.impl_def_id)\n+                     .iter().find(|ic| ic.name == ti.ident.name) {\n+                Some(ic) => lookup_const_by_id(tcx, ic.def_id, None),\n+                None => match ti.node {\n+                    ast::ConstTraitItem(_, Some(ref expr)) => Some(&*expr),\n+                    _ => None,\n+                },\n+            }\n+        }\n+        _ => {\n+            tcx.sess.span_bug(\n+                ti.span,\n+                &format!(\"resolve_trait_associated_const: unexpected vtable type\"))\n+        }\n+    }\n+}\n+\n fn cast_const<'tcx>(tcx: &ty::ctxt<'tcx>, val: const_val, ty: Ty) -> CastResult {\n     macro_rules! convert_val {\n         ($intermediate_ty:ty, $const_type:ident, $target_ty:ty) => {"}, {"sha": "1aa2ca9115d2f61429d3d62b36921c1254138db2", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 34, "deletions": 29, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -72,7 +72,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     fn lookup_and_handle_definition(&mut self, id: &ast::NodeId) {\n         self.tcx.def_map.borrow().get(id).map(|def| {\n             match def.full_def() {\n-                def::DefConst(_) => {\n+                def::DefConst(_) | def::DefAssociatedConst(..) => {\n                     self.check_def_id(def.def_id())\n                 }\n                 _ if self.ignore_non_const_paths => (),\n@@ -114,14 +114,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                         let trait_item = ty::trait_item(self.tcx,\n                                                         trait_ref.def_id,\n                                                         index);\n-                        match trait_item {\n-                            ty::MethodTraitItem(method) => {\n-                                self.check_def_id(method.def_id);\n-                            }\n-                            ty::TypeTraitItem(typedef) => {\n-                                self.check_def_id(typedef.def_id);\n-                            }\n-                        }\n+                        self.check_def_id(trait_item.def_id());\n                     }\n                 }\n             }\n@@ -353,6 +346,7 @@ impl<'v> Visitor<'v> for LifeSeeder {\n             ast::ItemTrait(_, _, _, ref trait_items) => {\n                 for trait_item in trait_items {\n                     match trait_item.node {\n+                        ast::ConstTraitItem(_, Some(_)) |\n                         ast::MethodTraitItem(_, Some(_)) => {\n                             if has_allow_dead_code_or_lang_attr(&trait_item.attrs) {\n                                 self.worklist.push(trait_item.id);\n@@ -365,6 +359,7 @@ impl<'v> Visitor<'v> for LifeSeeder {\n             ast::ItemImpl(_, _, _, ref opt_trait, _, ref impl_items) => {\n                 for impl_item in impl_items {\n                     match impl_item.node {\n+                        ast::ConstImplItem(..) |\n                         ast::MethodImplItem(..) => {\n                             if opt_trait.is_some() ||\n                                     has_allow_dead_code_or_lang_attr(&impl_item.attrs) {\n@@ -406,7 +401,7 @@ fn create_and_seed_worklist(tcx: &ty::ctxt,\n         None => ()\n     }\n \n-    // Seed implemented trait methods\n+    // Seed implemented trait items\n     let mut life_seeder = LifeSeeder {\n         worklist: worklist\n     };\n@@ -487,7 +482,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n                              |ctor| self.live_symbols.contains(&ctor)) {\n             return true;\n         }\n-        // If it's a type whose methods are live, then it's live, too.\n+        // If it's a type whose items are live, then it's live, too.\n         // This is done to handle the case where, for example, the static\n         // method of a private type is used, but the type itself is never\n         // called directly.\n@@ -557,21 +552,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n         visit::walk_foreign_item(self, fi);\n     }\n \n-    fn visit_fn(&mut self, fk: visit::FnKind<'v>,\n-                _: &'v ast::FnDecl, block: &'v ast::Block,\n-                span: codemap::Span, id: ast::NodeId) {\n-        // Have to warn method here because methods are not ast::Item\n-        match fk {\n-            visit::FkMethod(name, _, _) => {\n-                if !self.symbol_is_live(id, None) {\n-                    self.warn_dead_code(id, span, name.name, \"method\");\n-                }\n-            }\n-            _ => ()\n-        }\n-        visit::walk_block(self, block);\n-    }\n-\n     fn visit_struct_field(&mut self, field: &ast::StructField) {\n         if self.should_warn_about_field(&field.node) {\n             self.warn_dead_code(field.node.id, field.span,\n@@ -581,12 +561,37 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n         visit::walk_struct_field(self, field);\n     }\n \n-    // Overwrite so that we don't warn the trait method itself.\n-    fn visit_trait_item(&mut self, trait_method: &ast::TraitItem) {\n-        match trait_method.node {\n+    fn visit_impl_item(&mut self, impl_item: &ast::ImplItem) {\n+        match impl_item.node {\n+            ast::ConstImplItem(_, ref expr) => {\n+                if !self.symbol_is_live(impl_item.id, None) {\n+                    self.warn_dead_code(impl_item.id, impl_item.span,\n+                                        impl_item.ident.name, \"associated const\");\n+                }\n+                visit::walk_expr(self, expr)\n+            }\n+            ast::MethodImplItem(_, ref body) => {\n+                if !self.symbol_is_live(impl_item.id, None) {\n+                    self.warn_dead_code(impl_item.id, impl_item.span,\n+                                        impl_item.ident.name, \"method\");\n+                }\n+                visit::walk_block(self, body)\n+            }\n+            ast::TypeImplItem(..) |\n+            ast::MacImplItem(..) => {}\n+        }\n+    }\n+\n+    // Overwrite so that we don't warn the trait item itself.\n+    fn visit_trait_item(&mut self, trait_item: &ast::TraitItem) {\n+        match trait_item.node {\n+            ast::ConstTraitItem(_, Some(ref expr)) => {\n+                visit::walk_expr(self, expr)\n+            }\n             ast::MethodTraitItem(_, Some(ref body)) => {\n                 visit::walk_block(self, body)\n             }\n+            ast::ConstTraitItem(_, None) |\n             ast::MethodTraitItem(_, None) |\n             ast::TypeTraitItem(..) => {}\n         }"}, {"sha": "bce246fa4af866dbd2ec1f974dbdd4158ee5f0f0", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -28,6 +28,7 @@ pub enum Def {\n     DefForeignMod(ast::DefId),\n     DefStatic(ast::DefId, bool /* is_mutbl */),\n     DefConst(ast::DefId),\n+    DefAssociatedConst(ast::DefId /* const */, MethodProvenance),\n     DefLocal(ast::NodeId),\n     DefVariant(ast::DefId /* enum */, ast::DefId /* variant */, bool /* is_structure */),\n     DefTy(ast::DefId, bool /* is_enum */),\n@@ -140,7 +141,8 @@ impl Def {\n             DefFn(id, _) | DefMod(id) | DefForeignMod(id) | DefStatic(id, _) |\n             DefVariant(_, id, _) | DefTy(id, _) | DefAssociatedTy(_, id) |\n             DefTyParam(_, _, id, _) | DefUse(id) | DefStruct(id) | DefTrait(id) |\n-            DefMethod(id, _) | DefConst(id) | DefSelfTy(Some(id), None)=> {\n+            DefMethod(id, _) | DefConst(id) | DefAssociatedConst(id, _) |\n+            DefSelfTy(Some(id), None)=> {\n                 id\n             }\n             DefLocal(id) |"}, {"sha": "d740d24e23672d9016e8c76a9a9f8f60884733e1", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -234,7 +234,7 @@ impl OverloadedCallType {\n             ty::MethodTraitItem(ref method_descriptor) => {\n                 (*method_descriptor).clone()\n             }\n-            ty::TypeTraitItem(_) => {\n+            _ => {\n                 tcx.sess.bug(\"overloaded call method wasn't in method map\")\n             }\n         };\n@@ -1147,7 +1147,8 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             let tcx = typer.tcx();\n \n             match pat.node {\n-                ast::PatEnum(_, _) | ast::PatIdent(_, _, None) | ast::PatStruct(..) => {\n+                ast::PatEnum(_, _) | ast::PatQPath(..) |\n+                ast::PatIdent(_, _, None) | ast::PatStruct(..) => {\n                     match def_map.get(&pat.id).map(|d| d.full_def()) {\n                         None => {\n                             // no definition found: pat is not a\n@@ -1183,6 +1184,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                         }\n \n                         Some(def::DefConst(..)) |\n+                        Some(def::DefAssociatedConst(..)) |\n                         Some(def::DefLocal(..)) => {\n                             // This is a leaf (i.e. identifier binding\n                             // or constant value to match); thus no"}, {"sha": "22e3376e09ea8f4a46ba4cd8bcabd84c597b8412", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -843,8 +843,8 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                   Some(&sig.explicit_self.node),\n                                   item.span))\n                         }\n-                        ast::TypeImplItem(_) => None,\n-                        ast::MacImplItem(_) => self.tcx.sess.bug(\"unexpanded macro\")\n+                        ast::MacImplItem(_) => self.tcx.sess.bug(\"unexpanded macro\"),\n+                        _ => None,\n                     }\n                 },\n                 ast_map::NodeTraitItem(item) => {\n@@ -1723,8 +1723,8 @@ fn lifetimes_in_scope(tcx: &ty::ctxt,\n                         taken.push_all(&sig.generics.lifetimes);\n                         Some(ii.id)\n                     }\n-                    ast::TypeImplItem(_) => None,\n-                    ast::MacImplItem(_) => tcx.sess.bug(\"unexpanded macro\")\n+                    ast::MacImplItem(_) => tcx.sess.bug(\"unexpanded macro\"),\n+                    _ => None,\n                 }\n             }\n             _ => None"}, {"sha": "587194bafada48acfa17742614d982f44821f933", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -589,7 +589,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n         match def {\n           def::DefStruct(..) | def::DefVariant(..) | def::DefConst(..) |\n-          def::DefFn(..) | def::DefMethod(..) => {\n+          def::DefAssociatedConst(..) | def::DefFn(..) | def::DefMethod(..) => {\n                 Ok(self.cat_rvalue_node(id, span, expr_ty))\n           }\n           def::DefMod(_) | def::DefForeignMod(_) | def::DefUse(_) |\n@@ -1286,7 +1286,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                         try!(self.cat_pattern_(cmt_field, &**subpat, op));\n                     }\n                 }\n-                Some(def::DefConst(..)) => {\n+                Some(def::DefConst(..)) | Some(def::DefAssociatedConst(..)) => {\n                     for subpat in subpats {\n                         try!(self.cat_pattern_(cmt.clone(), &**subpat, op));\n                     }\n@@ -1299,6 +1299,10 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             }\n           }\n \n+          ast::PatQPath(..) => {\n+              // Lone constant: ignore\n+          }\n+\n           ast::PatIdent(_, _, Some(ref subpat)) => {\n               try!(self.cat_pattern_(cmt, &**subpat, op));\n           }"}, {"sha": "27a30f5cf253cf97da67691b72b29ec2863119cc", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -30,7 +30,7 @@ pub fn pat_id_map(dm: &DefMap, pat: &ast::Pat) -> PatIdMap {\n \n pub fn pat_is_refutable(dm: &DefMap, pat: &ast::Pat) -> bool {\n     match pat.node {\n-        ast::PatLit(_) | ast::PatRange(_, _) => true,\n+        ast::PatLit(_) | ast::PatRange(_, _) | ast::PatQPath(..) => true,\n         ast::PatEnum(_, _) |\n         ast::PatIdent(_, _, None) |\n         ast::PatStruct(..) => {\n@@ -60,9 +60,25 @@ pub fn pat_is_variant_or_struct(dm: &DefMap, pat: &ast::Pat) -> bool {\n \n pub fn pat_is_const(dm: &DefMap, pat: &ast::Pat) -> bool {\n     match pat.node {\n-        ast::PatIdent(_, _, None) | ast::PatEnum(..) => {\n+        ast::PatIdent(_, _, None) | ast::PatEnum(..) | ast::PatQPath(..) => {\n             match dm.borrow().get(&pat.id).map(|d| d.full_def()) {\n-                Some(DefConst(..)) => true,\n+                Some(DefConst(..)) | Some(DefAssociatedConst(..)) => true,\n+                _ => false\n+            }\n+        }\n+        _ => false\n+    }\n+}\n+\n+// Same as above, except that partially-resolved defs cause `false` to be\n+// returned instead of a panic.\n+pub fn pat_is_resolved_const(dm: &DefMap, pat: &ast::Pat) -> bool {\n+    match pat.node {\n+        ast::PatIdent(_, _, None) | ast::PatEnum(..) | ast::PatQPath(..) => {\n+            match dm.borrow().get(&pat.id)\n+                    .and_then(|d| if d.depth == 0 { Some(d.base_def) }\n+                                  else { None } ) {\n+                Some(DefConst(..)) | Some(DefAssociatedConst(..)) => true,\n                 _ => false\n             }\n         }"}, {"sha": "b532dc88df4cb5c939c6935ddd20bd1edbd2fba8", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -113,7 +113,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n                             // If this path leads to a constant, then we need to\n                             // recurse into the constant to continue finding\n                             // items that are reachable.\n-                            def::DefConst(..) => {\n+                            def::DefConst(..) | def::DefAssociatedConst(..) => {\n                                 self.worklist.push(def_id.node);\n                             }\n \n@@ -183,12 +183,14 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             }\n             Some(ast_map::NodeTraitItem(trait_method)) => {\n                 match trait_method.node {\n+                    ast::ConstTraitItem(_, ref default) => default.is_some(),\n                     ast::MethodTraitItem(_, ref body) => body.is_some(),\n                     ast::TypeTraitItem(..) => false,\n                 }\n             }\n             Some(ast_map::NodeImplItem(impl_item)) => {\n                 match impl_item.node {\n+                    ast::ConstImplItem(..) => true,\n                     ast::MethodImplItem(ref sig, _) => {\n                         if generics_require_inlining(&sig.generics) ||\n                                 attr::requests_inline(&impl_item.attrs) {\n@@ -303,9 +305,13 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             }\n             ast_map::NodeTraitItem(trait_method) => {\n                 match trait_method.node {\n+                    ast::ConstTraitItem(_, None) |\n                     ast::MethodTraitItem(_, None) => {\n                         // Keep going, nothing to get exported\n                     }\n+                    ast::ConstTraitItem(_, Some(ref expr)) => {\n+                        self.visit_expr(&*expr);\n+                    }\n                     ast::MethodTraitItem(_, Some(ref body)) => {\n                         visit::walk_block(self, body);\n                     }\n@@ -314,6 +320,9 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             }\n             ast_map::NodeImplItem(impl_item) => {\n                 match impl_item.node {\n+                    ast::ConstImplItem(_, ref expr) => {\n+                        self.visit_expr(&*expr);\n+                    }\n                     ast::MethodImplItem(ref sig, ref body) => {\n                         let did = self.tcx.map.get_parent_did(search_item);\n                         if method_might_be_inlined(self.tcx, sig, impl_item, did) {"}, {"sha": "3d6ed3c34406118fdea3f0bedfc381d78e7e7c6e", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -100,9 +100,7 @@ fn object_safety_violations_for_trait<'tcx>(tcx: &ty::ctxt<'tcx>,\n                         .map(|code| ObjectSafetyViolation::Method(m.clone(), code))\n                         .into_iter()\n                 }\n-                ty::TypeTraitItem(_) => {\n-                    None.into_iter()\n-                }\n+                _ => None.into_iter(),\n             }\n         })\n         .collect();"}, {"sha": "9cdae21868ed3393ec4493ca2c7cb06fce921c80", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -863,7 +863,7 @@ fn confirm_impl_candidate<'cx,'tcx>(\n     for impl_item in impl_items {\n         let assoc_type = match *impl_or_trait_items_map.get(&impl_item.def_id()).unwrap() {\n             ty::TypeTraitItem(ref assoc_type) => assoc_type.clone(),\n-            ty::MethodTraitItem(..) => { continue; }\n+            ty::ConstTraitItem(..) | ty::MethodTraitItem(..) => { continue; }\n         };\n \n         if assoc_type.name != obligation.predicate.item_name {"}, {"sha": "6ecff3b7faabe9178064a6676be5deaf85124cf5", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -434,7 +434,7 @@ pub fn get_vtable_index_of_object_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         for trait_item in &**trait_items {\n             match *trait_item {\n                 ty::MethodTraitItem(_) => method_count += 1,\n-                ty::TypeTraitItem(_) => {}\n+                _ => {}\n             }\n         }\n     }\n@@ -445,14 +445,14 @@ pub fn get_vtable_index_of_object_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     for trait_item in trait_items.iter().take(method_offset_in_trait) {\n         match *trait_item {\n             ty::MethodTraitItem(_) => method_count += 1,\n-            ty::TypeTraitItem(_) => {}\n+            _ => {}\n         }\n     }\n \n     // the item at the offset we were given really ought to be a method\n     assert!(match trait_items[method_offset_in_trait] {\n         ty::MethodTraitItem(_) => true,\n-        ty::TypeTraitItem(_) => false\n+        _ => false\n     });\n \n     method_count"}, {"sha": "f172815a4d1437734225dd399aea80ad4c07f16b", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 117, "deletions": 15, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -80,7 +80,7 @@ use std::vec::IntoIter;\n use collections::enum_set::{EnumSet, CLike};\n use std::collections::{HashMap, HashSet};\n use syntax::abi;\n-use syntax::ast::{CrateNum, DefId, ItemTrait, LOCAL_CRATE};\n+use syntax::ast::{CrateNum, DefId, ItemImpl, ItemTrait, LOCAL_CRATE};\n use syntax::ast::{MutImmutable, MutMutable, Name, NamedField, NodeId};\n use syntax::ast::{StmtExpr, StmtSemi, StructField, UnnamedField, Visibility};\n use syntax::ast_util::{self, is_local, lit_is_str, local_def};\n@@ -133,13 +133,17 @@ impl ImplOrTraitItemContainer {\n \n #[derive(Clone, Debug)]\n pub enum ImplOrTraitItem<'tcx> {\n+    ConstTraitItem(Rc<AssociatedConst<'tcx>>),\n     MethodTraitItem(Rc<Method<'tcx>>),\n     TypeTraitItem(Rc<AssociatedType>),\n }\n \n impl<'tcx> ImplOrTraitItem<'tcx> {\n     fn id(&self) -> ImplOrTraitItemId {\n         match *self {\n+            ConstTraitItem(ref associated_const) => {\n+                ConstTraitItemId(associated_const.def_id)\n+            }\n             MethodTraitItem(ref method) => MethodTraitItemId(method.def_id),\n             TypeTraitItem(ref associated_type) => {\n                 TypeTraitItemId(associated_type.def_id)\n@@ -149,20 +153,31 @@ impl<'tcx> ImplOrTraitItem<'tcx> {\n \n     pub fn def_id(&self) -> ast::DefId {\n         match *self {\n+            ConstTraitItem(ref associated_const) => associated_const.def_id,\n             MethodTraitItem(ref method) => method.def_id,\n             TypeTraitItem(ref associated_type) => associated_type.def_id,\n         }\n     }\n \n     pub fn name(&self) -> ast::Name {\n         match *self {\n+            ConstTraitItem(ref associated_const) => associated_const.name,\n             MethodTraitItem(ref method) => method.name,\n             TypeTraitItem(ref associated_type) => associated_type.name,\n         }\n     }\n \n+    pub fn vis(&self) -> ast::Visibility {\n+        match *self {\n+            ConstTraitItem(ref associated_const) => associated_const.vis,\n+            MethodTraitItem(ref method) => method.vis,\n+            TypeTraitItem(ref associated_type) => associated_type.vis,\n+        }\n+    }\n+\n     pub fn container(&self) -> ImplOrTraitItemContainer {\n         match *self {\n+            ConstTraitItem(ref associated_const) => associated_const.container,\n             MethodTraitItem(ref method) => method.container,\n             TypeTraitItem(ref associated_type) => associated_type.container,\n         }\n@@ -171,20 +186,22 @@ impl<'tcx> ImplOrTraitItem<'tcx> {\n     pub fn as_opt_method(&self) -> Option<Rc<Method<'tcx>>> {\n         match *self {\n             MethodTraitItem(ref m) => Some((*m).clone()),\n-            TypeTraitItem(_) => None\n+            _ => None,\n         }\n     }\n }\n \n #[derive(Clone, Copy, Debug)]\n pub enum ImplOrTraitItemId {\n+    ConstTraitItemId(ast::DefId),\n     MethodTraitItemId(ast::DefId),\n     TypeTraitItemId(ast::DefId),\n }\n \n impl ImplOrTraitItemId {\n     pub fn def_id(&self) -> ast::DefId {\n         match *self {\n+            ConstTraitItemId(def_id) => def_id,\n             MethodTraitItemId(def_id) => def_id,\n             TypeTraitItemId(def_id) => def_id,\n         }\n@@ -238,6 +255,16 @@ impl<'tcx> Method<'tcx> {\n     }\n }\n \n+#[derive(Clone, Copy, Debug)]\n+pub struct AssociatedConst<'tcx> {\n+    pub name: ast::Name,\n+    pub ty: Ty<'tcx>,\n+    pub vis: ast::Visibility,\n+    pub def_id: ast::DefId,\n+    pub container: ImplOrTraitItemContainer,\n+    pub default: Option<ast::DefId>,\n+}\n+\n #[derive(Clone, Copy, Debug)]\n pub struct AssociatedType {\n     pub name: ast::Name,\n@@ -2291,6 +2318,16 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n         match cx.map.find(id) {\n             Some(ast_map::NodeImplItem(ref impl_item)) => {\n                 match impl_item.node {\n+                    ast::ConstImplItem(_, _) => {\n+                        let def_id = ast_util::local_def(id);\n+                        let scheme = lookup_item_type(cx, def_id);\n+                        let predicates = lookup_predicates(cx, def_id);\n+                        construct_parameter_environment(cx,\n+                                                        impl_item.span,\n+                                                        &scheme.generics,\n+                                                        &predicates,\n+                                                        id)\n+                    }\n                     ast::MethodImplItem(_, ref body) => {\n                         let method_def_id = ast_util::local_def(id);\n                         match ty::impl_or_trait_item(cx, method_def_id) {\n@@ -2304,11 +2341,10 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                                     method_bounds,\n                                     body.id)\n                             }\n-                            TypeTraitItem(_) => {\n+                            _ => {\n                                 cx.sess\n                                   .bug(\"ParameterEnvironment::for_item(): \\\n-                                        can't create a parameter environment \\\n-                                        for type trait items\")\n+                                        got non-method item from impl method?!\")\n                             }\n                         }\n                     }\n@@ -2322,6 +2358,25 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n             }\n             Some(ast_map::NodeTraitItem(trait_item)) => {\n                 match trait_item.node {\n+                    ast::ConstTraitItem(_, ref default) => {\n+                        match *default {\n+                            Some(_) => {\n+                                let def_id = ast_util::local_def(id);\n+                                let scheme = lookup_item_type(cx, def_id);\n+                                let predicates = lookup_predicates(cx, def_id);\n+                                construct_parameter_environment(cx,\n+                                                                trait_item.span,\n+                                                                &scheme.generics,\n+                                                                &predicates,\n+                                                                id)\n+                            }\n+                            None => {\n+                                cx.sess.bug(\"ParameterEnvironment::from_item(): \\\n+                                             can't create a parameter environment \\\n+                                             for const trait items without defaults\")\n+                            }\n+                        }\n+                    }\n                     ast::MethodTraitItem(_, None) => {\n                         cx.sess.span_bug(trait_item.span,\n                                          \"ParameterEnvironment::for_item():\n@@ -2342,11 +2397,11 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                                     method_bounds,\n                                     body.id)\n                             }\n-                            TypeTraitItem(_) => {\n+                            _ => {\n                                 cx.sess\n                                   .bug(\"ParameterEnvironment::for_item(): \\\n-                                        can't create a parameter environment \\\n-                                        for type trait items\")\n+                                        got non-method item from provided \\\n+                                        method?!\")\n                             }\n                         }\n                     }\n@@ -4719,7 +4774,8 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n                 def::DefUpvar(..) |\n                 def::DefLocal(..) => LvalueExpr,\n \n-                def::DefConst(..) => RvalueDatumExpr,\n+                def::DefConst(..) |\n+                def::DefAssociatedConst(..) => RvalueDatumExpr,\n \n                 def => {\n                     tcx.sess.span_bug(\n@@ -5070,10 +5126,10 @@ pub fn provided_trait_methods<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                 if let ast::MethodTraitItem(_, Some(_)) = ti.node {\n                     match impl_or_trait_item(cx, ast_util::local_def(ti.id)) {\n                         MethodTraitItem(m) => Some(m),\n-                        TypeTraitItem(_) => {\n+                        _ => {\n                             cx.sess.bug(\"provided_trait_methods(): \\\n-                                         associated type found from \\\n-                                         looking up ProvidedMethod?!\")\n+                                         non-method item found from \\\n+                                         looking up provided method?!\")\n                         }\n                     }\n                 } else {\n@@ -5088,6 +5144,52 @@ pub fn provided_trait_methods<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n     }\n }\n \n+pub fn associated_consts<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n+                               -> Vec<Rc<AssociatedConst<'tcx>>> {\n+    if is_local(id) {\n+        match cx.map.expect_item(id.node).node {\n+            ItemTrait(_, _, _, ref tis) => {\n+                tis.iter().filter_map(|ti| {\n+                    if let ast::ConstTraitItem(_, _) = ti.node {\n+                        match impl_or_trait_item(cx, ast_util::local_def(ti.id)) {\n+                            ConstTraitItem(ac) => Some(ac),\n+                            _ => {\n+                                cx.sess.bug(\"associated_consts(): \\\n+                                             non-const item found from \\\n+                                             looking up a constant?!\")\n+                            }\n+                        }\n+                    } else {\n+                        None\n+                    }\n+                }).collect()\n+            }\n+            ItemImpl(_, _, _, _, _, ref iis) => {\n+                iis.iter().filter_map(|ii| {\n+                    if let ast::ConstImplItem(_, _) = ii.node {\n+                        match impl_or_trait_item(cx, ast_util::local_def(ii.id)) {\n+                            ConstTraitItem(ac) => Some(ac),\n+                            _ => {\n+                                cx.sess.bug(\"associated_consts(): \\\n+                                             non-const item found from \\\n+                                             looking up a constant?!\")\n+                            }\n+                        }\n+                    } else {\n+                        None\n+                    }\n+                }).collect()\n+            }\n+            _ => {\n+                cx.sess.bug(&format!(\"associated_consts: `{:?}` is not a trait \\\n+                                      or impl\", id))\n+            }\n+        }\n+    } else {\n+        csearch::get_associated_consts(cx, id)\n+    }\n+}\n+\n /// Helper for looking things up in the various maps that are populated during\n /// typeck::collect (e.g., `cx.impl_or_trait_items`, `cx.tcache`, etc).  All of\n /// these share the pattern that if the id is local, it should have been loaded\n@@ -5174,7 +5276,7 @@ pub fn is_associated_type(cx: &ctxt, id: ast::DefId) -> bool {\n                 Some(ref item) => {\n                     match **item {\n                         TypeTraitItem(_) => true,\n-                        MethodTraitItem(_) => false,\n+                        _ => false,\n                     }\n                 }\n                 None => false,\n@@ -6188,7 +6290,7 @@ pub fn populate_implementations_for_type_if_necessary(tcx: &ctxt,\n                            .insert(method_def_id, source);\n                     }\n                 }\n-                TypeTraitItem(_) => {}\n+                _ => {}\n             }\n         }\n \n@@ -6240,7 +6342,7 @@ pub fn populate_implementations_for_trait_if_necessary(\n                             .insert(method_def_id, source);\n                     }\n                 }\n-                TypeTraitItem(_) => {}\n+                _ => {}\n             }\n         }\n "}, {"sha": "3d56371dd52cafc56ae365b786a0b623e1504548", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -830,6 +830,7 @@ impl<'tcx> Repr<'tcx> for ty::TraitDef<'tcx> {\n impl<'tcx> Repr<'tcx> for ast::TraitItem {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         let kind = match self.node {\n+            ast::ConstTraitItem(..) => \"ConstTraitItem\",\n             ast::MethodTraitItem(..) => \"MethodTraitItem\",\n             ast::TypeTraitItem(..) => \"TypeTraitItem\",\n         };\n@@ -1054,9 +1055,39 @@ impl<'tcx> Repr<'tcx> for ty::Variance {\n     }\n }\n \n+impl<'tcx> Repr<'tcx> for ty::ImplOrTraitItem<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+        format!(\"ImplOrTraitItem({})\",\n+                match *self {\n+                    ty::ImplOrTraitItem::MethodTraitItem(ref i) => i.repr(tcx),\n+                    ty::ImplOrTraitItem::ConstTraitItem(ref i) => i.repr(tcx),\n+                    ty::ImplOrTraitItem::TypeTraitItem(ref i) => i.repr(tcx),\n+                })\n+    }\n+}\n+\n+impl<'tcx> Repr<'tcx> for ty::AssociatedConst<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+        format!(\"AssociatedConst(name: {}, ty: {}, vis: {}, def_id: {})\",\n+                self.name.repr(tcx),\n+                self.ty.repr(tcx),\n+                self.vis.repr(tcx),\n+                self.def_id.repr(tcx))\n+    }\n+}\n+\n+impl<'tcx> Repr<'tcx> for ty::AssociatedType {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+        format!(\"AssociatedType(name: {}, vis: {}, def_id: {})\",\n+                self.name.repr(tcx),\n+                self.vis.repr(tcx),\n+                self.def_id.repr(tcx))\n+    }\n+}\n+\n impl<'tcx> Repr<'tcx> for ty::Method<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"method(name: {}, generics: {}, predicates: {}, fty: {}, \\\n+        format!(\"Method(name: {}, generics: {}, predicates: {}, fty: {}, \\\n                  explicit_self: {}, vis: {}, def_id: {})\",\n                 self.name.repr(tcx),\n                 self.generics.repr(tcx),"}, {"sha": "27adf5bf21b63297a5491ba94efd3bea8f50867d", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -77,6 +77,20 @@ impl<'a, 'tcx, 'v> Visitor<'v> for BorrowckCtxt<'a, 'tcx> {\n     fn visit_item(&mut self, item: &ast::Item) {\n         borrowck_item(self, item);\n     }\n+\n+    fn visit_trait_item(&mut self, ti: &ast::TraitItem) {\n+        if let ast::ConstTraitItem(_, Some(ref expr)) = ti.node {\n+            gather_loans::gather_loans_in_static_initializer(self, &*expr);\n+        }\n+        visit::walk_trait_item(self, ti);\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &ast::ImplItem) {\n+        if let ast::ConstImplItem(_, ref expr) = ii.node {\n+            gather_loans::gather_loans_in_static_initializer(self, &*expr);\n+        }\n+        visit::walk_impl_item(self, ii);\n+    }\n }\n \n pub fn check_crate(tcx: &ty::ctxt) {"}, {"sha": "b8032bda8d070ede99791322e5f2ba00c49abc14", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -35,6 +35,7 @@ use syntax::codemap;\n use syntax::fold::{self, Folder};\n use syntax::print::{pp, pprust};\n use syntax::ptr::P;\n+use syntax::util::small_vector::SmallVector;\n \n use graphviz as dot;\n \n@@ -475,6 +476,29 @@ impl fold::Folder for ReplaceBodyWithLoop {\n         }\n     }\n \n+    fn fold_trait_item(&mut self, i: P<ast::TraitItem>) -> SmallVector<P<ast::TraitItem>> {\n+        match i.node {\n+            ast::ConstTraitItem(..) => {\n+                self.within_static_or_const = true;\n+                let ret = fold::noop_fold_trait_item(i, self);\n+                self.within_static_or_const = false;\n+                return ret;\n+            }\n+            _ => fold::noop_fold_trait_item(i, self),\n+        }\n+    }\n+\n+    fn fold_impl_item(&mut self, i: P<ast::ImplItem>) -> SmallVector<P<ast::ImplItem>> {\n+        match i.node {\n+            ast::ConstImplItem(..) => {\n+                self.within_static_or_const = true;\n+                let ret = fold::noop_fold_impl_item(i, self);\n+                self.within_static_or_const = false;\n+                return ret;\n+            }\n+            _ => fold::noop_fold_impl_item(i, self),\n+        }\n+    }\n \n     fn fold_block(&mut self, b: P<ast::Block>) -> P<ast::Block> {\n         fn expr_to_block(rules: ast::BlockCheckMode,"}, {"sha": "1d5c5fb86cbd5988b783d19c69ac28f5b06ca8b0", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -1068,6 +1068,26 @@ impl LintPass for NonUpperCaseGlobals {\n         }\n     }\n \n+    fn check_trait_item(&mut self, cx: &Context, ti: &ast::TraitItem) {\n+        match ti.node {\n+            ast::ConstTraitItem(..) => {\n+                NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\",\n+                                                      ti.ident, ti.span);\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn check_impl_item(&mut self, cx: &Context, ii: &ast::ImplItem) {\n+        match ii.node {\n+            ast::ConstImplItem(..) => {\n+                NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\",\n+                                                      ii.ident, ii.span);\n+            }\n+            _ => {}\n+        }\n+    }\n+\n     fn check_pat(&mut self, cx: &Context, p: &ast::Pat) {\n         // Lint for constants that look like binding identifiers (#7526)\n         match (&p.node, cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def())) {\n@@ -1584,8 +1604,9 @@ impl LintPass for MissingDoc {\n         if self.private_traits.contains(&trait_item.id) { return }\n \n         let desc = match trait_item.node {\n+            ast::ConstTraitItem(..) => \"an associated constant\",\n             ast::MethodTraitItem(..) => \"a trait method\",\n-            ast::TypeTraitItem(..) => \"an associated type\"\n+            ast::TypeTraitItem(..) => \"an associated type\",\n         };\n \n         self.check_missing_docs_attrs(cx, Some(trait_item.id),\n@@ -1600,9 +1621,10 @@ impl LintPass for MissingDoc {\n         }\n \n         let desc = match impl_item.node {\n+            ast::ConstImplItem(..) => \"an associated constant\",\n             ast::MethodImplItem(..) => \"a method\",\n             ast::TypeImplItem(_) => \"an associated type\",\n-            ast::MacImplItem(_) => \"an impl item macro\"\n+            ast::MacImplItem(_) => \"an impl item macro\",\n         };\n         self.check_missing_docs_attrs(cx, Some(impl_item.id),\n                                       &impl_item.attrs,"}, {"sha": "128e29ee76e7d6ec17acc19c8b9216cacef514b2", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 62, "deletions": 12, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -119,6 +119,15 @@ impl<'v> Visitor<'v> for ParentVisitor {\n         visit::walk_fn(self, a, b, c, d);\n     }\n \n+    fn visit_impl_item(&mut self, ii: &'v ast::ImplItem) {\n+        // visit_fn handles methods, but associated consts have to be handled\n+        // here.\n+        if !self.parents.contains_key(&ii.id) {\n+            self.parents.insert(ii.id, self.curparent);\n+        }\n+        visit::walk_impl_item(self, ii);\n+    }\n+\n     fn visit_struct_def(&mut self, s: &ast::StructDef, _: ast::Ident,\n                         _: &'v ast::Generics, n: ast::NodeId) {\n         // Struct constructors are parented to their struct definitions because\n@@ -272,6 +281,12 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n                 if public_ty || public_trait {\n                     for impl_item in impl_items {\n                         match impl_item.node {\n+                            ast::ConstImplItem(..) => {\n+                                if (public_ty && impl_item.vis == ast::Public)\n+                                    || tr.is_some() {\n+                                    self.exported_items.insert(impl_item.id);\n+                                }\n+                            }\n                             ast::MethodImplItem(ref sig, _) => {\n                                 let meth_public = match sig.explicit_self.node {\n                                     ast::SelfStatic => public_ty,\n@@ -399,6 +414,33 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             debug!(\"privacy - is {:?} a public method\", did);\n \n             return match self.tcx.impl_or_trait_items.borrow().get(&did) {\n+                Some(&ty::ConstTraitItem(ref ac)) => {\n+                    debug!(\"privacy - it's a const: {:?}\", *ac);\n+                    match ac.container {\n+                        ty::TraitContainer(id) => {\n+                            debug!(\"privacy - recursing on trait {:?}\", id);\n+                            self.def_privacy(id)\n+                        }\n+                        ty::ImplContainer(id) => {\n+                            match ty::impl_trait_ref(self.tcx, id) {\n+                                Some(t) => {\n+                                    debug!(\"privacy - impl of trait {:?}\", id);\n+                                    self.def_privacy(t.def_id)\n+                                }\n+                                None => {\n+                                    debug!(\"privacy - found inherent \\\n+                                            associated constant {:?}\",\n+                                            ac.vis);\n+                                    if ac.vis == ast::Public {\n+                                        Allowable\n+                                    } else {\n+                                        ExternallyDenied\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n                 Some(&ty::MethodTraitItem(ref meth)) => {\n                     debug!(\"privacy - well at least it's a method: {:?}\",\n                            *meth);\n@@ -490,6 +532,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                 //               where the method was defined?\n                 Some(ast_map::NodeImplItem(ii)) => {\n                     match ii.node {\n+                        ast::ConstImplItem(..) |\n                         ast::MethodImplItem(..) => {\n                             let imp = self.tcx.map\n                                           .get_parent_did(closest_private_id);\n@@ -693,7 +736,11 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             ty::MethodTraitItem(method_type) => {\n                 method_type.provided_source.unwrap_or(method_id)\n             }\n-            ty::TypeTraitItem(_) => method_id,\n+            _ => {\n+                self.tcx.sess\n+                    .span_bug(span,\n+                              \"got non-method item in check_static_method\")\n+            }\n         };\n \n         let string = token::get_name(name);\n@@ -787,6 +834,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             def::DefFn(..) => ck(\"function\"),\n             def::DefStatic(..) => ck(\"static\"),\n             def::DefConst(..) => ck(\"const\"),\n+            def::DefAssociatedConst(..) => ck(\"associated const\"),\n             def::DefVariant(..) => ck(\"variant\"),\n             def::DefTy(_, false) => ck(\"type\"),\n             def::DefTy(_, true) => ck(\"enum\"),\n@@ -1128,8 +1176,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n                         ast::MethodImplItem(..) => {\n                             check_inherited(tcx, impl_item.span, impl_item.vis);\n                         }\n-                        ast::TypeImplItem(_) |\n-                        ast::MacImplItem(_) => {}\n+                        _ => {}\n                     }\n                 }\n             }\n@@ -1307,6 +1354,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                     impl_items.iter()\n                               .any(|impl_item| {\n                                   match impl_item.node {\n+                                      ast::ConstImplItem(..) |\n                                       ast::MethodImplItem(..) => {\n                                           self.exported_items.contains(&impl_item.id)\n                                       }\n@@ -1330,6 +1378,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                                 // don't erroneously report errors for private\n                                 // types in private items.\n                                 match impl_item.node {\n+                                    ast::ConstImplItem(..) |\n                                     ast::MethodImplItem(..)\n                                         if self.item_is_public(&impl_item.id, impl_item.vis) =>\n                                     {\n@@ -1360,12 +1409,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n \n                             // Those in 3. are warned with this call.\n                             for impl_item in impl_items {\n-                                match impl_item.node {\n-                                    ast::TypeImplItem(ref ty) => {\n-                                        self.visit_ty(ty);\n-                                    }\n-                                    ast::MethodImplItem(..) |\n-                                    ast::MacImplItem(_) => {},\n+                                if let ast::TypeImplItem(ref ty) = impl_item.node {\n+                                    self.visit_ty(ty);\n                                 }\n                             }\n                         }\n@@ -1376,15 +1421,20 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                     let mut found_pub_static = false;\n                     for impl_item in impl_items {\n                         match impl_item.node {\n+                            ast::ConstImplItem(..) => {\n+                                if self.item_is_public(&impl_item.id, impl_item.vis) {\n+                                    found_pub_static = true;\n+                                    visit::walk_impl_item(self, impl_item);\n+                                }\n+                            }\n                             ast::MethodImplItem(ref sig, _) => {\n                                 if sig.explicit_self.node == ast::SelfStatic &&\n-                                        self.item_is_public(&impl_item.id, impl_item.vis) {\n+                                      self.item_is_public(&impl_item.id, impl_item.vis) {\n                                     found_pub_static = true;\n                                     visit::walk_impl_item(self, impl_item);\n                                 }\n                             }\n-                            ast::TypeImplItem(_) |\n-                            ast::MacImplItem(_) => {}\n+                            _ => {}\n                         }\n                     }\n                     if found_pub_static {"}, {"sha": "0d25700d2b7f101f69f3ffb7adc7e671ae076b48", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -530,6 +530,12 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                         trait_item.span);\n \n                     match trait_item.node {\n+                        ast::ConstTraitItem(..) => {\n+                            let def = DefAssociatedConst(local_def(trait_item.id),\n+                                                         FromTrait(local_def(item.id)));\n+                            // NB: not IMPORTABLE\n+                            name_bindings.define_value(def, trait_item.span, PUBLIC);\n+                        }\n                         ast::MethodTraitItem(..) => {\n                             let def = DefMethod(local_def(trait_item.id),\n                                                 FromTrait(local_def(item.id)));\n@@ -703,7 +709,8 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 csearch::get_tuple_struct_definition_if_ctor(&self.session.cstore, ctor_id)\n                     .map_or(def, |_| DefStruct(ctor_id)), DUMMY_SP, modifiers);\n           }\n-          DefFn(..) | DefStatic(..) | DefConst(..) | DefMethod(..) => {\n+          DefFn(..) | DefStatic(..) | DefConst(..) | DefAssociatedConst(..) |\n+          DefMethod(..) => {\n             debug!(\"(building reduced graph for external \\\n                     crate) building value (fn/static) {}\", final_ident);\n             // impl methods have already been defined with the correct importability modifier"}, {"sha": "61eab4ce9b285e0128cfb57b6311bde190ff93be", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 192, "deletions": 75, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -41,6 +41,7 @@ use self::TypeParameters::*;\n use self::RibKind::*;\n use self::UseLexicalScopeFlag::*;\n use self::ModulePrefixResult::*;\n+use self::AssocItemResolveResult::*;\n use self::NameSearchType::*;\n use self::BareIdentifierPatternResolution::*;\n use self::ParentLink::*;\n@@ -60,7 +61,8 @@ use rustc::middle::ty::{Freevar, FreevarMap, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, NodeSet, DefIdSet, FnvHashMap};\n use rustc::util::lev_distance::lev_distance;\n \n-use syntax::ast::{Arm, BindByRef, BindByValue, BindingMode, Block, Crate, CrateNum};\n+use syntax::ast::{Arm, BindByRef, BindByValue, BindingMode, Block};\n+use syntax::ast::{ConstImplItem, Crate, CrateNum};\n use syntax::ast::{DefId, Expr, ExprAgain, ExprBreak, ExprField};\n use syntax::ast::{ExprLoop, ExprWhile, ExprMethodCall};\n use syntax::ast::{ExprPath, ExprStruct, FnDecl};\n@@ -69,7 +71,7 @@ use syntax::ast::{Ident, ImplItem, Item, ItemConst, ItemEnum, ItemExternCrate};\n use syntax::ast::{ItemFn, ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic, ItemDefaultImpl};\n use syntax::ast::{ItemStruct, ItemTrait, ItemTy, ItemUse};\n use syntax::ast::{Local, MethodImplItem, Name, NodeId};\n-use syntax::ast::{Pat, PatEnum, PatIdent, PatLit};\n+use syntax::ast::{Pat, PatEnum, PatIdent, PatLit, PatQPath};\n use syntax::ast::{PatRange, PatStruct, Path, PrimTy};\n use syntax::ast::{TraitRef, Ty, TyBool, TyChar, TyF32};\n use syntax::ast::{TyF64, TyFloat, TyIs, TyI8, TyI16, TyI32, TyI64, TyInt};\n@@ -330,6 +332,15 @@ enum ModulePrefixResult {\n     PrefixFound(Rc<Module>, usize)\n }\n \n+#[derive(Copy, Clone)]\n+enum AssocItemResolveResult {\n+    /// Syntax such as `<T>::item`, which can't be resolved until type\n+    /// checking.\n+    TypecheckRequired,\n+    /// We should have been able to resolve the associated item.\n+    ResolveAttempt(Option<PathResolution>),\n+}\n+\n #[derive(Copy, Clone, PartialEq)]\n enum NameSearchType {\n     /// We're doing a name search in order to resolve a `use` directive.\n@@ -1830,21 +1841,36 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             //\n                             // FIXME #4951: Do we need a node ID here?\n \n-                            let type_parameters = match trait_item.node {\n+                            match trait_item.node {\n+                                ast::ConstTraitItem(_, ref default) => {\n+                                    // Only impose the restrictions of\n+                                    // ConstRibKind if there's an actual constant\n+                                    // expression in a provided default.\n+                                    if default.is_some() {\n+                                        this.with_constant_rib(|this| {\n+                                            visit::walk_trait_item(this, trait_item)\n+                                        });\n+                                    } else {\n+                                        visit::walk_trait_item(this, trait_item)\n+                                    }\n+                                }\n                                 ast::MethodTraitItem(ref sig, _) => {\n-                                    HasTypeParameters(&sig.generics,\n-                                                      FnSpace,\n-                                                      MethodRibKind)\n+                                    let type_parameters =\n+                                        HasTypeParameters(&sig.generics,\n+                                                          FnSpace,\n+                                                          MethodRibKind);\n+                                    this.with_type_parameter_rib(type_parameters, |this| {\n+                                        visit::walk_trait_item(this, trait_item)\n+                                    });\n                                 }\n                                 ast::TypeTraitItem(..) => {\n                                     this.check_if_primitive_type_name(trait_item.ident.name,\n                                                                       trait_item.span);\n-                                    NoTypeParameters\n+                                    this.with_type_parameter_rib(NoTypeParameters, |this| {\n+                                        visit::walk_trait_item(this, trait_item)\n+                                    });\n                                 }\n                             };\n-                            this.with_type_parameter_rib(type_parameters, |this| {\n-                                visit::walk_trait_item(this, trait_item)\n-                            });\n                         }\n                     });\n                 });\n@@ -2094,6 +2120,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     this.with_current_self_type(self_type, |this| {\n                         for impl_item in impl_items {\n                             match impl_item.node {\n+                                ConstImplItem(..) => {\n+                                    // If this is a trait impl, ensure the method\n+                                    // exists in trait\n+                                    this.check_trait_item(impl_item.ident.name,\n+                                                          impl_item.span);\n+                                    this.with_constant_rib(|this| {\n+                                        visit::walk_impl_item(this, impl_item);\n+                                    });\n+                                }\n                                 MethodImplItem(ref sig, _) => {\n                                     // If this is a trait impl, ensure the method\n                                     // exists in trait\n@@ -2280,31 +2315,21 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     fn resolve_type(&mut self, ty: &Ty) {\n         match ty.node {\n-            // `<T>::a::b::c` is resolved by typeck alone.\n-            TyPath(Some(ast::QSelf { position: 0, .. }), _) => {}\n-\n             TyPath(ref maybe_qself, ref path) => {\n-                let max_assoc_types = if let Some(ref qself) = *maybe_qself {\n-                    // Make sure the trait is valid.\n-                    let _ = self.resolve_trait_reference(ty.id, path, 1);\n-                    path.segments.len() - qself.position\n-                } else {\n-                    path.segments.len()\n-                };\n-\n-                let mut resolution = None;\n-                for depth in 0..max_assoc_types {\n-                    self.with_no_errors(|this| {\n-                        resolution = this.resolve_path(ty.id, path, depth, TypeNS, true);\n-                    });\n-                    if resolution.is_some() {\n-                        break;\n-                    }\n-                }\n-                if let Some(DefMod(_)) = resolution.map(|r| r.base_def) {\n-                    // A module is not a valid type.\n-                    resolution = None;\n-                }\n+                let resolution =\n+                    match self.resolve_possibly_assoc_item(ty.id,\n+                                                           maybe_qself.as_ref(),\n+                                                           path,\n+                                                           TypeNS,\n+                                                           true) {\n+                        // `<T>::a::b::c` is resolved by typeck alone.\n+                        TypecheckRequired => {\n+                            // Resolve embedded types.\n+                            visit::walk_ty(self, ty);\n+                            return;\n+                        }\n+                        ResolveAttempt(resolution) => resolution,\n+                    };\n \n                 // This is a path in the type namespace. Walk through scopes\n                 // looking for it.\n@@ -2464,7 +2489,22 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                 PatEnum(ref path, _) => {\n                     // This must be an enum variant, struct or const.\n-                    if let Some(path_res) = self.resolve_path(pat_id, path, 0, ValueNS, false) {\n+                    let resolution =\n+                        match self.resolve_possibly_assoc_item(pat_id, None,\n+                                                               path, ValueNS,\n+                                                               false) {\n+                            // The below shouldn't happen because all\n+                            // qualified paths should be in PatQPath.\n+                            TypecheckRequired =>\n+                                self.session.span_bug(\n+                                    path.span,\n+                                    \"resolve_possibly_assoc_item claimed\n+                                     that a path in PatEnum requires typecheck\n+                                     to resolve, but qualified paths should be\n+                                     PatQPath\"),\n+                            ResolveAttempt(resolution) => resolution,\n+                        };\n+                    if let Some(path_res) = resolution {\n                         match path_res.base_def {\n                             DefVariant(..) | DefStruct(..) | DefConst(..) => {\n                                 self.record_def(pattern.id, path_res);\n@@ -2475,19 +2515,70 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                     referenced in a pattern, \\\n                                                     use a `const` instead\");\n                             }\n+                            _ => {\n+                                // If anything ends up here entirely resolved,\n+                                // it's an error. If anything ends up here\n+                                // partially resolved, that's OK, because it may\n+                                // be a `T::CONST` that typeck will resolve to\n+                                // an inherent impl.\n+                                if path_res.depth == 0 {\n+                                    self.resolve_error(\n+                                        path.span,\n+                                        &format!(\"`{}` is not an enum variant, struct or const\",\n+                                                 token::get_ident(\n+                                                     path.segments.last().unwrap().identifier)));\n+                                } else {\n+                                    self.record_def(pattern.id, path_res);\n+                                }\n+                            }\n+                        }\n+                    } else {\n+                        self.resolve_error(path.span,\n+                            &format!(\"unresolved enum variant, struct or const `{}`\",\n+                                token::get_ident(path.segments.last().unwrap().identifier)));\n+                    }\n+                    visit::walk_path(self, path);\n+                }\n+\n+                PatQPath(ref qself, ref path) => {\n+                    // Associated constants only.\n+                    let resolution =\n+                        match self.resolve_possibly_assoc_item(pat_id, Some(qself),\n+                                                               path, ValueNS,\n+                                                               false) {\n+                            TypecheckRequired => {\n+                                // All `<T>::CONST` should end up here, and will\n+                                // require use of the trait map to resolve\n+                                // during typechecking.\n+                                let const_name = path.segments.last().unwrap()\n+                                                     .identifier.name;\n+                                let traits = self.get_traits_containing_item(const_name);\n+                                self.trait_map.insert(pattern.id, traits);\n+                                visit::walk_pat(self, pattern);\n+                                return true;\n+                            }\n+                            ResolveAttempt(resolution) => resolution,\n+                        };\n+                    if let Some(path_res) = resolution {\n+                        match path_res.base_def {\n+                            // All `<T as Trait>::CONST` should end up here, and\n+                            // have the trait already selected.\n+                            DefAssociatedConst(..) => {\n+                                self.record_def(pattern.id, path_res);\n+                            }\n                             _ => {\n                                 self.resolve_error(path.span,\n-                                    &format!(\"`{}` is not an enum variant, struct or const\",\n+                                    &format!(\"`{}` is not an associated const\",\n                                         token::get_ident(\n                                             path.segments.last().unwrap().identifier)));\n                             }\n                         }\n                     } else {\n                         self.resolve_error(path.span,\n-                            &format!(\"unresolved enum variant, struct or const `{}`\",\n+                            &format!(\"unresolved associated const `{}`\",\n                                 token::get_ident(path.segments.last().unwrap().identifier)));\n                     }\n-                    visit::walk_path(self, path);\n+                    visit::walk_pat(self, pattern);\n                 }\n \n                 PatStruct(ref path, _, _) => {\n@@ -2542,7 +2633,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             def @ DefVariant(..) | def @ DefStruct(..) => {\n                                 return FoundStructOrEnumVariant(def, LastMod(AllPublic));\n                             }\n-                            def @ DefConst(..) => {\n+                            def @ DefConst(..) | def @ DefAssociatedConst(..) => {\n                                 return FoundConst(def, LastMod(AllPublic));\n                             }\n                             DefStatic(..) => {\n@@ -2579,6 +2670,47 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n     }\n \n+    /// Handles paths that may refer to associated items\n+    fn resolve_possibly_assoc_item(&mut self,\n+                                   id: NodeId,\n+                                   maybe_qself: Option<&ast::QSelf>,\n+                                   path: &Path,\n+                                   namespace: Namespace,\n+                                   check_ribs: bool)\n+                                   -> AssocItemResolveResult\n+    {\n+        match maybe_qself {\n+            Some(&ast::QSelf { position: 0, .. }) =>\n+                return TypecheckRequired,\n+            _ => {}\n+        }\n+        let max_assoc_types = if let Some(qself) = maybe_qself {\n+            // Make sure the trait is valid.\n+            let _ = self.resolve_trait_reference(id, path, 1);\n+            path.segments.len() - qself.position\n+        } else {\n+            path.segments.len()\n+        };\n+\n+        let mut resolution = self.with_no_errors(|this| {\n+            this.resolve_path(id, path, 0, namespace, check_ribs)\n+        });\n+        for depth in 1..max_assoc_types {\n+            if resolution.is_some() {\n+                break;\n+            }\n+            self.with_no_errors(|this| {\n+                resolution = this.resolve_path(id, path, depth,\n+                                               TypeNS, true);\n+            });\n+        }\n+        if let Some(DefMod(_)) = resolution.map(|r| r.base_def) {\n+            // A module is not a valid type or value.\n+            resolution = None;\n+        }\n+        ResolveAttempt(resolution)\n+    }\n+\n     /// If `check_ribs` is true, checks the local definitions first; i.e.\n     /// doesn't skip straight to the containing module.\n     /// Skips `path_depth` trailing segments, which is also reflected in the\n@@ -3093,38 +3225,23 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         // Next, resolve the node.\n         match expr.node {\n-            // `<T>::a::b::c` is resolved by typeck alone.\n-            ExprPath(Some(ast::QSelf { position: 0, .. }), ref path) => {\n-                let method_name = path.segments.last().unwrap().identifier.name;\n-                let traits = self.search_for_traits_containing_method(method_name);\n-                self.trait_map.insert(expr.id, traits);\n-                visit::walk_expr(self, expr);\n-            }\n-\n             ExprPath(ref maybe_qself, ref path) => {\n-                let max_assoc_types = if let Some(ref qself) = *maybe_qself {\n-                    // Make sure the trait is valid.\n-                    let _ = self.resolve_trait_reference(expr.id, path, 1);\n-                    path.segments.len() - qself.position\n-                } else {\n-                    path.segments.len()\n-                };\n-\n-                let mut resolution = self.with_no_errors(|this| {\n-                    this.resolve_path(expr.id, path, 0, ValueNS, true)\n-                });\n-                for depth in 1..max_assoc_types {\n-                    if resolution.is_some() {\n-                        break;\n-                    }\n-                    self.with_no_errors(|this| {\n-                        resolution = this.resolve_path(expr.id, path, depth, TypeNS, true);\n-                    });\n-                }\n-                if let Some(DefMod(_)) = resolution.map(|r| r.base_def) {\n-                    // A module is not a valid type or value.\n-                    resolution = None;\n-                }\n+                let resolution =\n+                    match self.resolve_possibly_assoc_item(expr.id,\n+                                                           maybe_qself.as_ref(),\n+                                                           path,\n+                                                           ValueNS,\n+                                                           true) {\n+                        // `<T>::a::b::c` is resolved by typeck alone.\n+                        TypecheckRequired => {\n+                            let method_name = path.segments.last().unwrap().identifier.name;\n+                            let traits = self.get_traits_containing_item(method_name);\n+                            self.trait_map.insert(expr.id, traits);\n+                            visit::walk_expr(self, expr);\n+                            return;\n+                        }\n+                        ResolveAttempt(resolution) => resolution,\n+                    };\n \n                 // This is a local path in the value namespace. Walk through\n                 // scopes looking for it.\n@@ -3155,7 +3272,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         // so they can be completed during typeck.\n                         if path_res.depth != 0 {\n                             let method_name = path.segments.last().unwrap().identifier.name;\n-                            let traits = self.search_for_traits_containing_method(method_name);\n+                            let traits = self.get_traits_containing_item(method_name);\n                             self.trait_map.insert(expr.id, traits);\n                         }\n \n@@ -3313,14 +3430,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 // field, we need to add any trait methods we find that match\n                 // the field name so that we can do some nice error reporting\n                 // later on in typeck.\n-                let traits = self.search_for_traits_containing_method(ident.node.name);\n+                let traits = self.get_traits_containing_item(ident.node.name);\n                 self.trait_map.insert(expr.id, traits);\n             }\n             ExprMethodCall(ident, _, _) => {\n                 debug!(\"(recording candidate traits for expr) recording \\\n                         traits for {}\",\n                        expr.id);\n-                let traits = self.search_for_traits_containing_method(ident.node.name);\n+                let traits = self.get_traits_containing_item(ident.node.name);\n                 self.trait_map.insert(expr.id, traits);\n             }\n             _ => {\n@@ -3329,8 +3446,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n     }\n \n-    fn search_for_traits_containing_method(&mut self, name: Name) -> Vec<DefId> {\n-        debug!(\"(searching for traits containing method) looking for '{}'\",\n+    fn get_traits_containing_item(&mut self, name: Name) -> Vec<DefId> {\n+        debug!(\"(getting traits containing item) looking for '{}'\",\n                token::get_name(name));\n \n         fn add_trait_info(found_traits: &mut Vec<DefId>,"}, {"sha": "39cfac42011aba8fe8c92d786ca9353c4aa2e15f", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 38, "deletions": 23, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -242,6 +242,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             def::DefTrait(_) => Some(recorder::TypeRef),\n             def::DefStatic(_, _) |\n             def::DefConst(_) |\n+            def::DefAssociatedConst(..) |\n             def::DefLocal(_) |\n             def::DefVariant(_, _, _) |\n             def::DefUpvar(..) => Some(recorder::VarRef),\n@@ -359,14 +360,10 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         // record the decl for this def (if it has one)\n         let decl_id = ty::trait_item_of_item(&self.analysis.ty_cx,\n                                              ast_util::local_def(id))\n-            .and_then(|def_id| {\n-                if match def_id {\n-                    ty::MethodTraitItemId(def_id) => {\n-                        def_id.node != 0 && def_id != ast_util::local_def(id)\n-                    }\n-                    ty::TypeTraitItemId(_) => false,\n-                } {\n-                    Some(def_id.def_id())\n+            .and_then(|new_id| {\n+                let def_id = new_id.def_id();\n+                if def_id.node != 0 && def_id != ast_util::local_def(id) {\n+                    Some(def_id)\n                 } else {\n                     None\n                 }\n@@ -542,25 +539,27 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n     }\n \n     fn process_const(&mut self,\n-                      item: &ast::Item,\n-                      typ: &ast::Ty,\n-                      expr: &ast::Expr)\n+                     id: ast::NodeId,\n+                     ident: &ast::Ident,\n+                     span: Span,\n+                     typ: &ast::Ty,\n+                     expr: &ast::Expr)\n     {\n-        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n+        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(id));\n \n-        let sub_span = self.span.sub_span_after_keyword(item.span,\n+        let sub_span = self.span.sub_span_after_keyword(span,\n                                                         keywords::Const);\n-        self.fmt.static_str(item.span,\n+        self.fmt.static_str(span,\n                             sub_span,\n-                            item.id,\n-                            &get_ident(item.ident),\n+                            id,\n+                            &get_ident((*ident).clone()),\n                             &qualname[..],\n                             \"\",\n                             &ty_to_string(&*typ),\n                             self.cur_scope);\n \n         // walk type and init value\n-        self.visit_ty(&*typ);\n+        self.visit_ty(typ);\n         self.visit_expr(expr);\n     }\n \n@@ -800,6 +799,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             def::DefLocal(..) |\n             def::DefStatic(..) |\n             def::DefConst(..) |\n+            def::DefAssociatedConst(..) |\n             def::DefVariant(..) => self.fmt.ref_str(ref_kind.unwrap_or(recorder::VarRef),\n                                                     span,\n                                                     sub_span,\n@@ -883,6 +883,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             def::DefLocal(_) |\n             def::DefStatic(_,_) |\n             def::DefConst(..) |\n+            def::DefAssociatedConst(..) |\n             def::DefStruct(_) |\n             def::DefVariant(..) |\n             def::DefFn(..) => self.write_sub_paths_truncated(path, false),\n@@ -966,7 +967,10 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     ty::MethodTraitItem(method) => {\n                         method.provided_source.unwrap_or(def_id)\n                     }\n-                    ty::TypeTraitItem(_) => def_id,\n+                    _ => self.sess\n+                             .span_bug(ex.span,\n+                                       \"save::process_method_call: non-method \\\n+                                        DefId in MethodStatic or MethodStaticClosure\"),\n                 };\n                 (Some(def_id), decl_id)\n             }\n@@ -1008,7 +1012,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n \n                 let def = self.analysis.ty_cx.def_map.borrow().get(&p.id).unwrap().full_def();\n                 let struct_def = match def {\n-                    def::DefConst(..) => None,\n+                    def::DefConst(..) | def::DefAssociatedConst(..) => None,\n                     def::DefVariant(_, variant_id, _) => Some(variant_id),\n                     _ => {\n                         match ty::ty_to_def_id(ty::node_id_to_type(&self.analysis.ty_cx, p.id)) {\n@@ -1040,7 +1044,8 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     }\n                 }\n             }\n-            ast::PatEnum(ref path, _) => {\n+            ast::PatEnum(ref path, _) |\n+            ast::PatQPath(_, ref path) => {\n                 self.collected_paths.push((p.id, path.clone(), false, recorder::VarRef));\n                 visit::walk_pat(self, p);\n             }\n@@ -1186,7 +1191,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n             ast::ItemStatic(ref typ, mt, ref expr) =>\n                 self.process_static(item, &**typ, mt, &**expr),\n             ast::ItemConst(ref typ, ref expr) =>\n-                self.process_const(item, &**typ, &**expr),\n+                self.process_const(item.id, &item.ident, item.span, &*typ, &*expr),\n             ast::ItemStruct(ref def, ref ty_params) => self.process_struct(item, &**def, ty_params),\n             ast::ItemEnum(ref def, ref ty_params) => self.process_enum(item, def, ty_params),\n             ast::ItemImpl(_, _,\n@@ -1236,16 +1241,25 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n \n     fn visit_trait_item(&mut self, trait_item: &ast::TraitItem) {\n         match trait_item.node {\n+            ast::ConstTraitItem(ref ty, Some(ref expr)) => {\n+                self.process_const(trait_item.id, &trait_item.ident,\n+                                   trait_item.span, &*ty, &*expr);\n+            }\n             ast::MethodTraitItem(ref sig, ref body) => {\n                 self.process_method(sig, body.as_ref().map(|x| &**x),\n                                     trait_item.id, trait_item.ident.name, trait_item.span);\n             }\n+            ast::ConstTraitItem(_, None) |\n             ast::TypeTraitItem(..) => {}\n         }\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &ast::ImplItem) {\n         match impl_item.node {\n+            ast::ConstImplItem(ref ty, ref expr) => {\n+                self.process_const(impl_item.id, &impl_item.ident,\n+                                   impl_item.span, &*ty, &*expr);\n+            }\n             ast::MethodImplItem(ref sig, ref body) => {\n                 self.process_method(sig, Some(body), impl_item.id,\n                                     impl_item.ident.name, impl_item.span);\n@@ -1432,8 +1446,9 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                     paths_to_process.push((id, p.clone(), Some(ref_kind)))\n                 }\n                 // FIXME(nrc) what are these doing here?\n-                def::DefStatic(_, _) => {}\n-                def::DefConst(..) => {}\n+                def::DefStatic(_, _) |\n+                def::DefConst(..) |\n+                def::DefAssociatedConst(..) => {}\n                 _ => error!(\"unexpected definition kind when processing collected paths: {:?}\",\n                             def)\n             }"}, {"sha": "b93068c88c8be22cd23d941d4594580a4fab3258", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -1809,7 +1809,8 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ast::PatMac(..) => {\n             bcx.sess().span_bug(pat.span, \"unexpanded macro\");\n         }\n-        ast::PatWild(_) | ast::PatLit(_) | ast::PatRange(_, _) => ()\n+        ast::PatQPath(..) | ast::PatWild(_) | ast::PatLit(_) |\n+        ast::PatRange(_, _) => ()\n     }\n     return bcx;\n }"}, {"sha": "1ceba3c8230d21f9e761ecdb830f87254a80d09e", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 13, "deletions": 23, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -1078,25 +1078,17 @@ fn build_cfg(tcx: &ty::ctxt, id: ast::NodeId) -> (ast::NodeId, Option<cfg::CFG>)\n         Some(ast_map::NodeTraitItem(trait_item)) => {\n             match trait_item.node {\n                 ast::MethodTraitItem(_, Some(ref body)) => body,\n-                ast::MethodTraitItem(_, None) => {\n-                    tcx.sess.bug(\"unexpected variant: required trait method \\\n-                                  in has_nested_returns\")\n-                }\n-                ast::TypeTraitItem(..) => {\n-                    tcx.sess.bug(\"unexpected variant: associated type trait item in \\\n-                                  has_nested_returns\")\n+                _ => {\n+                    tcx.sess.bug(\"unexpected variant: trait item other than a \\\n+                                  provided method in has_nested_returns\")\n                 }\n             }\n         }\n         Some(ast_map::NodeImplItem(impl_item)) => {\n             match impl_item.node {\n                 ast::MethodImplItem(_, ref body) => body,\n-                ast::TypeImplItem(_) => {\n-                    tcx.sess.bug(\"unexpected variant: associated type impl item in \\\n-                                  has_nested_returns\")\n-                }\n-                ast::MacImplItem(_) => {\n-                    tcx.sess.bug(\"unexpected variant: unexpanded macro impl item in \\\n+                _ => {\n+                    tcx.sess.bug(\"unexpected variant: non-method impl item in \\\n                                   has_nested_returns\")\n                 }\n             }\n@@ -2363,13 +2355,14 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n         ast_map::NodeTraitItem(trait_item) => {\n             debug!(\"get_item_val(): processing a NodeTraitItem\");\n             match trait_item.node {\n-                ast::MethodTraitItem(_, None) | ast::TypeTraitItem(..) => {\n-                    ccx.sess().span_bug(trait_item.span,\n-                        \"unexpected variant: required trait method in get_item_val()\");\n-                }\n                 ast::MethodTraitItem(_, Some(_)) => {\n                     register_method(ccx, id, &trait_item.attrs, trait_item.span)\n                 }\n+                _ => {\n+                    ccx.sess().span_bug(trait_item.span,\n+                        \"unexpected variant: trait item other than a provided \\\n+                         method in get_item_val()\");\n+                }\n             }\n         }\n \n@@ -2378,13 +2371,10 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                 ast::MethodImplItem(..) => {\n                     register_method(ccx, id, &impl_item.attrs, impl_item.span)\n                 }\n-                ast::TypeImplItem(_) => {\n-                    ccx.sess().span_bug(impl_item.span,\n-                        \"unexpected variant: associated type in get_item_val()\")\n-                }\n-                ast::MacImplItem(_) => {\n+                _ => {\n                     ccx.sess().span_bug(impl_item.span,\n-                        \"unexpected variant: unexpanded macro in get_item_val()\")\n+                        \"unexpected variant: non-method impl item in \\\n+                         get_item_val()\");\n                 }\n             }\n         }"}, {"sha": "0e4680723073f50881e8a0b0b0389ea221996d1a", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -202,6 +202,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n             }\n             def::DefStatic(..) |\n             def::DefConst(..) |\n+            def::DefAssociatedConst(..) |\n             def::DefLocal(..) |\n             def::DefUpvar(..) => {\n                 datum_callee(bcx, ref_expr)\n@@ -465,9 +466,9 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n \n                     (true, source_id, new_substs)\n                 }\n-                ty::TypeTraitItem(_) => {\n+                _ => {\n                     tcx.sess.bug(\"trans_fn_ref_with_vtables() tried \\\n-                                  to translate an associated type?!\")\n+                                  to translate a non-method?!\")\n                 }\n             }\n         }"}, {"sha": "9932899ed8f0f64da56f4075ceeb3f6553418892", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -173,13 +173,11 @@ pub fn get_const_expr<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                             \"cross crate constant could not be inlined\");\n     }\n \n-    let item = ccx.tcx().map.expect_item(def_id.node);\n-    if let ast::ItemConst(_, ref expr) = item.node {\n-        &**expr\n-    } else {\n-        ccx.sess().span_bug(ref_expr.span,\n-                            &format!(\"get_const_expr given non-constant item {}\",\n-                                     item.repr(ccx.tcx())));\n+    match const_eval::lookup_const_by_id(ccx.tcx(), def_id, Some(ref_expr.id)) {\n+        Some(ref expr) => expr,\n+        None => {\n+            ccx.sess().span_bug(ref_expr.span, \"constant item not found\")\n+        }\n     }\n }\n \n@@ -201,7 +199,7 @@ pub fn get_const_expr_as_global<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ast::ExprPath(..) => {\n             let def = ccx.tcx().def_map.borrow().get(&expr.id).unwrap().full_def();\n             match def {\n-                def::DefConst(def_id) => {\n+                def::DefConst(def_id) | def::DefAssociatedConst(def_id, _) => {\n                     if !ccx.tcx().adjustments.borrow().contains_key(&expr.id) {\n                         return get_const_val(ccx, def_id, expr);\n                     }\n@@ -774,7 +772,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 def::DefFn(..) | def::DefMethod(..) => {\n                     expr::trans_def_fn_unadjusted(cx, e, def, param_substs).val\n                 }\n-                def::DefConst(def_id) => {\n+                def::DefConst(def_id) | def::DefAssociatedConst(def_id, _) => {\n                     const_deref_ptr(cx, get_const_val(cx, def_id, e))\n                 }\n                 def::DefVariant(enum_did, variant_did, _) => {"}, {"sha": "516ff443dacb94d87514417f7a6a8ff9ad198fd3", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -1314,15 +1314,10 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                      impl_item.span,\n                      true)\n                 }\n-                ast::TypeImplItem(_) => {\n-                    cx.sess().span_bug(impl_item.span,\n-                                       \"create_function_debug_context() \\\n-                                        called on associated type?!\")\n-                }\n-                ast::MacImplItem(_) => {\n+                _ => {\n                     cx.sess().span_bug(impl_item.span,\n                                        \"create_function_debug_context() \\\n-                                        called on unexpanded macro?!\")\n+                                        called on non-method impl item?!\")\n                 }\n             }\n         }\n@@ -3442,6 +3437,10 @@ fn create_scope_map(cx: &CrateContext,\n                 }\n             }\n \n+            ast::PatQPath(..) => {\n+                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+            }\n+\n             ast::PatStruct(_, ref field_pats, _) => {\n                 scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n "}, {"sha": "3f44bc40f356b7f51362525272d4123adade4c39", "filename": "src/librustc_trans/trans/inline.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Finline.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -134,6 +134,14 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n \n             ccx.stats().n_inlines.set(ccx.stats().n_inlines.get() + 1);\n \n+            // Associated consts already have to be evaluated in `typeck`, so\n+            // the logic to do that already exists in `middle`. In order to\n+            // reuse that code, it needs to be able to look up the traits for\n+            // inlined items.\n+            let ty_trait_item = ty::impl_or_trait_item(ccx.tcx(), fn_id).clone();\n+            ccx.tcx().impl_or_trait_items.borrow_mut()\n+                     .insert(local_def(trait_item.id), ty_trait_item);\n+\n             // If this is a default method, we can't look up the\n             // impl type. But we aren't going to translate anyways, so\n             // don't."}, {"sha": "fda931fde6e6c8b14a03acf55092f3ea5cbfdea5", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -74,8 +74,7 @@ pub fn trans_impl(ccx: &CrateContext,\n                 ast::MethodImplItem(..) => {\n                     visit::walk_impl_item(&mut v, impl_item);\n                 }\n-                ast::TypeImplItem(_) |\n-                ast::MacImplItem(_) => {}\n+                _ => {}\n             }\n         }\n         return;\n@@ -98,8 +97,7 @@ pub fn trans_impl(ccx: &CrateContext,\n                 }\n                 visit::walk_impl_item(&mut v, impl_item);\n             }\n-            ast::TypeImplItem(_) |\n-            ast::MacImplItem(_) => {}\n+            _ => {}\n         }\n     }\n }\n@@ -336,9 +334,9 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let impl_did = vtable_impl.impl_def_id;\n             let mname = match ty::trait_item(ccx.tcx(), trait_id, n_method) {\n                 ty::MethodTraitItem(method) => method.name,\n-                ty::TypeTraitItem(_) => {\n-                    bcx.tcx().sess.bug(\"can't monomorphize an associated \\\n-                                        type\")\n+                _ => {\n+                    bcx.tcx().sess.bug(\"can't monomorphize a non-method trait \\\n+                                        item\")\n                 }\n             };\n             let mth_id = method_with_name(bcx.ccx(), impl_did, mname);\n@@ -579,8 +577,8 @@ pub fn trans_object_shim<'a, 'tcx>(\n     // Lookup the type of this method as declared in the trait and apply substitutions.\n     let method_ty = match ty::trait_item(tcx, trait_id, method_offset_in_trait) {\n         ty::MethodTraitItem(method) => method,\n-        ty::TypeTraitItem(_) => {\n-            tcx.sess.bug(\"can't create a method shim for an associated type\")\n+        _ => {\n+            tcx.sess.bug(\"can't create a method shim for a non-method item\")\n         }\n     };\n     let fty = monomorphize::apply_param_substs(tcx, &object_substs, &method_ty.fty);\n@@ -789,11 +787,11 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     trait_item_def_ids\n         .iter()\n \n-        // Filter out the associated types.\n+        // Filter out non-method items.\n         .filter_map(|item_def_id| {\n             match *item_def_id {\n                 ty::MethodTraitItemId(def_id) => Some(def_id),\n-                ty::TypeTraitItemId(_) => None,\n+                _ => None,\n             }\n         })\n \n@@ -806,7 +804,7 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n             let trait_method_type = match ty::impl_or_trait_item(tcx, trait_method_def_id) {\n                 ty::MethodTraitItem(m) => m,\n-                ty::TypeTraitItem(_) => ccx.sess().bug(\"should be a method, not assoc type\")\n+                _ => ccx.sess().bug(\"should be a method, not other assoc item\"),\n             };\n             let name = trait_method_type.name;\n \n@@ -824,7 +822,7 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             let impl_method_def_id = method_with_name(ccx, impl_id, name);\n             let impl_method_type = match ty::impl_or_trait_item(tcx, impl_method_def_id) {\n                 ty::MethodTraitItem(m) => m,\n-                ty::TypeTraitItem(_) => ccx.sess().bug(\"should be a method, not assoc type\")\n+                _ => ccx.sess().bug(\"should be a method, not other assoc item\"),\n             };\n \n             debug!(\"emit_vtable_methods: impl_method_type={}\","}, {"sha": "03fdd0c45c16ae6aa37d19e01b8673ca26956ed5", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -236,11 +236,9 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     }\n                     d\n                 }\n-                ast::TypeImplItem(_) => {\n-                    ccx.sess().bug(\"can't monomorphize an associated type\")\n-                }\n-                ast::MacImplItem(_) => {\n-                    ccx.sess().bug(\"can't monomorphize an unexpanded macro\")\n+                _ => {\n+                    ccx.sess().bug(&format!(\"can't monomorphize a {:?}\",\n+                                           map_node))\n                 }\n             }\n         }"}, {"sha": "1f4d6cc2fd471b4b8e04539edcb12438dedc6c36", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 81, "deletions": 6, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -11,12 +11,14 @@\n use middle::const_eval;\n use middle::def;\n use middle::infer;\n-use middle::pat_util::{PatIdMap, pat_id_map, pat_is_binding, pat_is_const};\n+use middle::pat_util::{PatIdMap, pat_id_map, pat_is_binding};\n+use middle::pat_util::pat_is_resolved_const;\n+use middle::privacy::{AllPublic, LastMod};\n use middle::subst::Substs;\n use middle::ty::{self, Ty};\n use check::{check_expr, check_expr_has_type, check_expr_with_expectation};\n use check::{check_expr_coercable_to_type, demand, FnCtxt, Expectation};\n-use check::{instantiate_path, structurally_resolved_type};\n+use check::{instantiate_path, resolve_ty_and_def_ufcs, structurally_resolved_type};\n use require_same_types;\n use util::nodemap::FnvHashMap;\n use util::ppaux::Repr;\n@@ -118,7 +120,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             // subtyping doesn't matter here, as the value is some kind of scalar\n             demand::eqtype(fcx, pat.span, expected, lhs_ty);\n         }\n-        ast::PatEnum(..) | ast::PatIdent(..) if pat_is_const(&tcx.def_map, pat) => {\n+        ast::PatEnum(..) | ast::PatIdent(..) if pat_is_resolved_const(&tcx.def_map, pat) => {\n             let const_did = tcx.def_map.borrow().get(&pat.id).unwrap().def_id();\n             let const_scheme = ty::lookup_item_type(tcx, const_did);\n             assert!(const_scheme.generics.is_empty());\n@@ -181,6 +183,37 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             let subpats = subpats.as_ref().map(|v| &v[..]);\n             check_pat_enum(pcx, pat, path, subpats, expected);\n         }\n+        ast::PatQPath(ref qself, ref path) => {\n+            let self_ty = fcx.to_ty(&qself.ty);\n+            let path_res = if let Some(&d) = tcx.def_map.borrow().get(&pat.id) {\n+                d\n+            } else if qself.position == 0 {\n+                def::PathResolution {\n+                    // This is just a sentinel for finish_resolving_def_to_ty.\n+                    base_def: def::DefMod(ast_util::local_def(ast::CRATE_NODE_ID)),\n+                    last_private: LastMod(AllPublic),\n+                    depth: path.segments.len()\n+                }\n+            } else {\n+                tcx.sess.span_bug(pat.span,\n+                                  &format!(\"unbound path {}\", pat.repr(tcx)))\n+            };\n+            if let Some((opt_ty, segments, def)) =\n+                    resolve_ty_and_def_ufcs(fcx, path_res, Some(self_ty),\n+                                            path, pat.span, pat.id) {\n+                if check_assoc_item_is_const(pcx, def, pat.span) {\n+                    let scheme = ty::lookup_item_type(tcx, def.def_id());\n+                    let predicates = ty::lookup_predicates(tcx, def.def_id());\n+                    instantiate_path(fcx, segments,\n+                                     scheme, &predicates,\n+                                     opt_ty, def, pat.span, pat.id);\n+                    let const_ty = fcx.node_ty(pat.id);\n+                    demand::suptype(fcx, pat.span, expected, const_ty);\n+                } else {\n+                    fcx.write_error(pat.id)\n+                }\n+            }\n+        }\n         ast::PatStruct(ref path, ref fields, etc) => {\n             check_pat_struct(pcx, pat, path, fields, etc, expected);\n         }\n@@ -331,6 +364,21 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     // subtyping.\n }\n \n+fn check_assoc_item_is_const(pcx: &pat_ctxt, def: def::Def, span: Span) -> bool {\n+    match def {\n+        def::DefAssociatedConst(..) => true,\n+        def::DefMethod(..) => {\n+            span_err!(pcx.fcx.ccx.tcx.sess, span, E0327,\n+                      \"associated items in match patterns must be constants\");\n+            false\n+        }\n+        _ => {\n+            pcx.fcx.ccx.tcx.sess.span_bug(span, \"non-associated item in\n+                                                 check_assoc_item_is_const\");\n+        }\n+    }\n+}\n+\n pub fn check_dereferencable<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                                       span: Span, expected: Ty<'tcx>,\n                                       inner: &ast::Pat) -> bool {\n@@ -532,7 +580,24 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n-    let def = tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n+    let path_res = *tcx.def_map.borrow().get(&pat.id).unwrap();\n+\n+    let (opt_ty, segments, def) = match resolve_ty_and_def_ufcs(fcx, path_res,\n+                                                                None, path,\n+                                                                pat.span, pat.id) {\n+        Some(resolution) => resolution,\n+        // Error handling done inside resolve_ty_and_def_ufcs, so if\n+        // resolution fails just return.\n+        None => {return;}\n+    };\n+\n+    // Items that were partially resolved before should have been resolved to\n+    // associated constants (i.e. not methods).\n+    if path_res.depth != 0 && !check_assoc_item_is_const(pcx, def, pat.span) {\n+        fcx.write_error(pat.id);\n+        return;\n+    }\n+\n     let enum_def = def.variant_def_ids()\n         .map_or_else(|| def.def_id(), |(enum_def, _)| enum_def);\n \n@@ -547,13 +612,23 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     } else {\n         ctor_scheme\n     };\n-    instantiate_path(pcx.fcx, &path.segments,\n+    instantiate_path(pcx.fcx, segments,\n                      path_scheme, &ctor_predicates,\n-                     None, def, pat.span, pat.id);\n+                     opt_ty, def, pat.span, pat.id);\n+\n+    // If we didn't have a fully resolved path to start with, we had an\n+    // associated const, and we should quit now, since the rest of this\n+    // function uses checks specific to structs and enums.\n+    if path_res.depth != 0 {\n+        let pat_ty = fcx.node_ty(pat.id);\n+        demand::suptype(fcx, pat.span, expected, pat_ty);\n+        return;\n+    }\n \n     let pat_ty = fcx.node_ty(pat.id);\n     demand::eqtype(fcx, pat.span, expected, pat_ty);\n \n+\n     let real_path_ty = fcx.node_ty(pat.id);\n     let (arg_tys, kind_name): (Vec<_>, &'static str) = match real_path_ty.sty {\n         ty::ty_enum(enum_def_id, expected_substs)"}, {"sha": "b3267a5be495b4df92f5157913b5ff93bee04b76", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -412,3 +412,85 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         return true;\n     }\n }\n+\n+pub fn compare_const_impl<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                impl_c: &ty::AssociatedConst<'tcx>,\n+                                impl_c_span: Span,\n+                                trait_c: &ty::AssociatedConst<'tcx>,\n+                                impl_trait_ref: &ty::TraitRef<'tcx>) {\n+    debug!(\"compare_const_impl(impl_trait_ref={})\",\n+           impl_trait_ref.repr(tcx));\n+\n+    let infcx = infer::new_infer_ctxt(tcx);\n+    let mut fulfillment_cx = traits::FulfillmentContext::new();\n+\n+    // The below is for the most part highly similar to the procedure\n+    // for methods above. It is simpler in many respects, especially\n+    // because we shouldn't really have to deal with lifetimes or\n+    // predicates. In fact some of this should probably be put into\n+    // shared functions because of DRY violations...\n+    let trait_to_impl_substs = &impl_trait_ref.substs;\n+\n+    // Create a parameter environment that represents the implementation's\n+    // method.\n+    let impl_param_env =\n+        ty::ParameterEnvironment::for_item(tcx, impl_c.def_id.node);\n+\n+    // Create mapping from impl to skolemized.\n+    let impl_to_skol_substs = &impl_param_env.free_substs;\n+\n+    // Create mapping from trait to skolemized.\n+    let trait_to_skol_substs =\n+        trait_to_impl_substs\n+        .subst(tcx, impl_to_skol_substs)\n+        .with_method(impl_to_skol_substs.types.get_slice(subst::FnSpace).to_vec(),\n+                     impl_to_skol_substs.regions().get_slice(subst::FnSpace).to_vec());\n+    debug!(\"compare_const_impl: trait_to_skol_substs={}\",\n+           trait_to_skol_substs.repr(tcx));\n+\n+    // Compute skolemized form of impl and trait const tys.\n+    let impl_ty = impl_c.ty.subst(tcx, impl_to_skol_substs);\n+    let trait_ty = trait_c.ty.subst(tcx, &trait_to_skol_substs);\n+\n+    let err = infcx.commit_if_ok(|_| {\n+        let origin = infer::Misc(impl_c_span);\n+\n+        // There is no \"body\" here, so just pass dummy id.\n+        let impl_ty =\n+            assoc::normalize_associated_types_in(&infcx,\n+                                                 &impl_param_env,\n+                                                 &mut fulfillment_cx,\n+                                                 impl_c_span,\n+                                                 0,\n+                                                 &impl_ty);\n+        debug!(\"compare_const_impl: impl_ty={}\",\n+               impl_ty.repr(tcx));\n+\n+        let trait_ty =\n+            assoc::normalize_associated_types_in(&infcx,\n+                                                 &impl_param_env,\n+                                                 &mut fulfillment_cx,\n+                                                 impl_c_span,\n+                                                 0,\n+                                                 &trait_ty);\n+        debug!(\"compare_const_impl: trait_ty={}\",\n+               trait_ty.repr(tcx));\n+\n+        infer::mk_subty(&infcx, false, origin, impl_ty, trait_ty)\n+    });\n+\n+    match err {\n+        Ok(()) => { }\n+        Err(terr) => {\n+            debug!(\"checking associated const for compatibility: impl ty {}, trait ty {}\",\n+                   impl_ty.repr(tcx),\n+                   trait_ty.repr(tcx));\n+            span_err!(tcx.sess, impl_c_span, E0326,\n+                      \"implemented const `{}` has an incompatible type for \\\n+                      trait: {}\",\n+                      token::get_name(trait_c.name),\n+                      ty::type_err_to_str(tcx, &terr));\n+            return;\n+        }\n+    }\n+}"}, {"sha": "cf1323e71bd0e94806d8ab03db4b9ff273af31db", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -109,10 +109,11 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         self.add_obligations(&pick, &all_substs, &method_predicates);\n \n         // Create the final `MethodCallee`.\n+        let method_ty = pick.item.as_opt_method().unwrap();\n         let fty = ty::mk_bare_fn(self.tcx(), None, self.tcx().mk_bare_fn(ty::BareFnTy {\n             sig: ty::Binder(method_sig),\n-            unsafety: pick.method_ty.fty.unsafety,\n-            abi: pick.method_ty.fty.abi.clone(),\n+            unsafety: method_ty.fty.unsafety,\n+            abi: method_ty.fty.abi.clone(),\n         }));\n         let callee = MethodCallee {\n             origin: method_origin,\n@@ -204,7 +205,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                         \"impl {:?} is not an inherent impl\", impl_def_id);\n                 let impl_polytype = check::impl_self_ty(self.fcx, self.span, impl_def_id);\n \n-                (impl_polytype.substs, MethodStatic(pick.method_ty.def_id))\n+                (impl_polytype.substs, MethodStatic(pick.item.def_id()))\n             }\n \n             probe::ObjectPick(trait_def_id, method_num, vtable_index) => {\n@@ -336,7 +337,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         // If they were not explicitly supplied, just construct fresh\n         // variables.\n         let num_supplied_types = supplied_method_types.len();\n-        let num_method_types = pick.method_ty.generics.types.len(subst::FnSpace);\n+        let num_method_types = pick.item.as_opt_method().unwrap()\n+                                   .generics.types.len(subst::FnSpace);\n         let method_types = {\n             if num_supplied_types == 0 {\n                 self.fcx.infcx().next_ty_vars(num_method_types)\n@@ -360,7 +362,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         let method_regions =\n             self.fcx.infcx().region_vars_for_defs(\n                 self.span,\n-                pick.method_ty.generics.regions.get_slice(subst::FnSpace));\n+                pick.item.as_opt_method().unwrap()\n+                    .generics.regions.get_slice(subst::FnSpace));\n \n         (method_types, method_regions)\n     }\n@@ -397,7 +400,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         // Instantiate the bounds on the method with the\n         // type/early-bound-regions substitutions performed. There can\n         // be no late-bound regions appearing here.\n-        let method_predicates = pick.method_ty.predicates.instantiate(self.tcx(), &all_substs);\n+        let method_predicates = pick.item.as_opt_method().unwrap()\n+                                    .predicates.instantiate(self.tcx(), &all_substs);\n         let method_predicates = self.fcx.normalize_associated_types_in(self.span,\n                                                                        &method_predicates);\n \n@@ -410,7 +414,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         // NB: Instantiate late-bound regions first so that\n         // `instantiate_type_scheme` can normalize associated types that\n         // may reference those regions.\n-        let method_sig = self.replace_late_bound_regions_with_fresh_var(&pick.method_ty.fty.sig);\n+        let method_sig = self.replace_late_bound_regions_with_fresh_var(\n+            &pick.item.as_opt_method().unwrap().fty.sig);\n         debug!(\"late-bound lifetimes from method instantiated, method_sig={}\",\n                method_sig.repr(self.tcx()));\n \n@@ -616,7 +621,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n \n     fn enforce_illegal_method_limitations(&self, pick: &probe::Pick) {\n         // Disallow calls to the method `drop` defined in the `Drop` trait.\n-        match pick.method_ty.container {\n+        match pick.item.container() {\n             ty::TraitContainer(trait_def_id) => {\n                 callee::check_legal_trait_for_method_call(self.fcx.ccx, self.span, trait_def_id)\n             }\n@@ -625,7 +630,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                 // potential calls to it will wind up in the other\n                 // arm. But just to be sure, check that the method id\n                 // does not appear in the list of destructors.\n-                assert!(!self.tcx().destructors.borrow().contains(&pick.method_ty.def_id));\n+                assert!(!self.tcx().destructors.borrow().contains(&pick.item.def_id()));\n             }\n         }\n     }"}, {"sha": "c5d8e2758ba5c6a9c3538538862bc261c6646470", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -58,7 +58,7 @@ pub enum CandidateSource {\n     TraitSource(/* trait id */ ast::DefId),\n }\n \n-type MethodIndex = usize; // just for doc purposes\n+type ItemIndex = usize; // just for doc purposes\n \n /// Determines whether the type `self_ty` supports a method name `method_name` or not.\n pub fn exists<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n@@ -312,18 +312,25 @@ pub fn resolve_ufcs<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n {\n     let mode = probe::Mode::Path;\n     let pick = try!(probe::probe(fcx, span, mode, method_name, self_ty, expr_id));\n-    let def_id = pick.method_ty.def_id;\n+    let def_id = pick.item.def_id();\n     let mut lp = LastMod(AllPublic);\n     let provenance = match pick.kind {\n         probe::InherentImplPick(impl_def_id) => {\n-            if pick.method_ty.vis != ast::Public {\n+            if pick.item.vis() != ast::Public {\n                 lp = LastMod(DependsOn(def_id));\n             }\n             def::FromImpl(impl_def_id)\n         }\n-        _ => def::FromTrait(pick.method_ty.container.id())\n+        _ => def::FromTrait(pick.item.container().id())\n     };\n-    Ok((def::DefMethod(def_id, provenance), lp))\n+    let def_result = match pick.item {\n+        ImplOrTraitItem::MethodTraitItem(..) => def::DefMethod(def_id, provenance),\n+        ImplOrTraitItem::ConstTraitItem(..) => def::DefAssociatedConst(def_id, provenance),\n+        ImplOrTraitItem::TypeTraitItem(..) => {\n+            fcx.tcx().sess.span_bug(span, \"resolve_ufcs: probe picked associated type\");\n+        }\n+    };\n+    Ok((def_result, lp))\n }\n \n "}, {"sha": "7ff1355184b56ade0e49fc903c3b849dc06e7cdb", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 142, "deletions": 134, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use super::MethodError;\n-use super::MethodIndex;\n+use super::ItemIndex;\n use super::{CandidateSource,ImplSource,TraitSource};\n use super::suggest;\n \n@@ -37,7 +37,7 @@ struct ProbeContext<'a, 'tcx:'a> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n     span: Span,\n     mode: Mode,\n-    method_name: ast::Name,\n+    item_name: ast::Name,\n     steps: Rc<Vec<CandidateStep<'tcx>>>,\n     opt_simplified_steps: Option<Vec<fast_reject::SimplifiedType>>,\n     inherent_candidates: Vec<Candidate<'tcx>>,\n@@ -54,22 +54,22 @@ struct CandidateStep<'tcx> {\n \n struct Candidate<'tcx> {\n     xform_self_ty: Ty<'tcx>,\n-    method_ty: Rc<ty::Method<'tcx>>,\n+    item: ty::ImplOrTraitItem<'tcx>,\n     kind: CandidateKind<'tcx>,\n }\n \n enum CandidateKind<'tcx> {\n     InherentImplCandidate(/* Impl */ ast::DefId, subst::Substs<'tcx>),\n     ObjectCandidate(/* Trait */ ast::DefId, /* method_num */ usize, /* vtable index */ usize),\n     ExtensionImplCandidate(/* Impl */ ast::DefId, Rc<ty::TraitRef<'tcx>>,\n-                           subst::Substs<'tcx>, MethodIndex),\n-    ClosureCandidate(/* Trait */ ast::DefId, MethodIndex),\n-    WhereClauseCandidate(ty::PolyTraitRef<'tcx>, MethodIndex),\n-    ProjectionCandidate(ast::DefId, MethodIndex),\n+                           subst::Substs<'tcx>, ItemIndex),\n+    ClosureCandidate(/* Trait */ ast::DefId, ItemIndex),\n+    WhereClauseCandidate(ty::PolyTraitRef<'tcx>, ItemIndex),\n+    ProjectionCandidate(ast::DefId, ItemIndex),\n }\n \n pub struct Pick<'tcx> {\n-    pub method_ty: Rc<ty::Method<'tcx>>,\n+    pub item: ty::ImplOrTraitItem<'tcx>,\n     pub kind: PickKind<'tcx>,\n \n     // Indicates that the source expression should be autoderef'd N times\n@@ -94,20 +94,20 @@ pub struct Pick<'tcx> {\n pub enum PickKind<'tcx> {\n     InherentImplPick(/* Impl */ ast::DefId),\n     ObjectPick(/* Trait */ ast::DefId, /* method_num */ usize, /* real_index */ usize),\n-    ExtensionImplPick(/* Impl */ ast::DefId, MethodIndex),\n-    TraitPick(/* Trait */ ast::DefId, MethodIndex),\n-    WhereClausePick(/* Trait */ ty::PolyTraitRef<'tcx>, MethodIndex),\n+    ExtensionImplPick(/* Impl */ ast::DefId, ItemIndex),\n+    TraitPick(/* Trait */ ast::DefId, ItemIndex),\n+    WhereClausePick(/* Trait */ ty::PolyTraitRef<'tcx>, ItemIndex),\n }\n \n pub type PickResult<'tcx> = Result<Pick<'tcx>, MethodError>;\n \n-#[derive(PartialEq, Eq, Copy, Clone)]\n+#[derive(PartialEq, Eq, Copy, Clone, Debug)]\n pub enum Mode {\n     // An expression of the form `receiver.method_name(...)`.\n     // Autoderefs are performed on `receiver`, lookup is done based on the\n     // `self` argument  of the method, and static methods aren't considered.\n     MethodCall,\n-    // An expression of the form `Type::method` or `<T>::method`.\n+    // An expression of the form `Type::item` or `<T>::item`.\n     // No autoderefs are performed, lookup is done based on the type each\n     // implementation is for, and static methods are included.\n     Path\n@@ -116,14 +116,14 @@ pub enum Mode {\n pub fn probe<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                        span: Span,\n                        mode: Mode,\n-                       method_name: ast::Name,\n+                       item_name: ast::Name,\n                        self_ty: Ty<'tcx>,\n                        scope_expr_id: ast::NodeId)\n                        -> PickResult<'tcx>\n {\n-    debug!(\"probe(self_ty={}, method_name={}, scope_expr_id={})\",\n+    debug!(\"probe(self_ty={}, item_name={}, scope_expr_id={})\",\n            self_ty.repr(fcx.tcx()),\n-           method_name,\n+           item_name,\n            scope_expr_id);\n \n     // FIXME(#18741) -- right now, creating the steps involves evaluating the\n@@ -171,7 +171,7 @@ pub fn probe<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         let mut probe_cx = ProbeContext::new(fcx,\n                                              span,\n                                              mode,\n-                                             method_name,\n+                                             item_name,\n                                              steps,\n                                              opt_simplified_steps);\n         probe_cx.assemble_inherent_candidates();\n@@ -221,7 +221,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     fn new(fcx: &'a FnCtxt<'a,'tcx>,\n            span: Span,\n            mode: Mode,\n-           method_name: ast::Name,\n+           item_name: ast::Name,\n            steps: Vec<CandidateStep<'tcx>>,\n            opt_simplified_steps: Option<Vec<fast_reject::SimplifiedType>>)\n            -> ProbeContext<'a,'tcx>\n@@ -230,7 +230,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             fcx: fcx,\n             span: span,\n             mode: mode,\n-            method_name: method_name,\n+            item_name: item_name,\n             inherent_candidates: Vec::new(),\n             extension_candidates: Vec::new(),\n             impl_dups: HashSet::new(),\n@@ -387,12 +387,12 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n         debug!(\"assemble_inherent_impl_probe {:?}\", impl_def_id);\n \n-        let method = match impl_method(self.tcx(), impl_def_id, self.method_name) {\n+        let item = match impl_item(self.tcx(), impl_def_id, self.item_name) {\n             Some(m) => m,\n             None => { return; } // No method with correct name on this impl\n         };\n \n-        if !self.has_applicable_self(&*method) {\n+        if !self.has_applicable_self(&item) {\n             // No receiver declared. Not a candidate.\n             return self.record_static_candidate(ImplSource(impl_def_id));\n         }\n@@ -402,11 +402,11 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n         // Determine the receiver type that the method itself expects.\n         let xform_self_ty =\n-            self.xform_self_ty(&method, impl_ty, &impl_substs);\n+            self.xform_self_ty(&item, impl_ty, &impl_substs);\n \n         self.inherent_candidates.push(Candidate {\n             xform_self_ty: xform_self_ty,\n-            method_ty: method,\n+            item: item,\n             kind: InherentImplCandidate(impl_def_id, impl_substs)\n         });\n     }\n@@ -427,23 +427,23 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         // itself. Hence, a `&self` method will wind up with an\n         // argument type like `&Trait`.\n         let trait_ref = data.principal_trait_ref_with_self_ty(self.tcx(), self_ty);\n-        self.elaborate_bounds(&[trait_ref.clone()], |this, new_trait_ref, m, method_num| {\n+        self.elaborate_bounds(&[trait_ref.clone()], |this, new_trait_ref, item, item_num| {\n             let new_trait_ref = this.erase_late_bound_regions(&new_trait_ref);\n \n             let vtable_index =\n                 traits::get_vtable_index_of_object_method(tcx,\n                                                           trait_ref.clone(),\n                                                           new_trait_ref.def_id,\n-                                                          method_num);\n+                                                          item_num);\n \n-            let xform_self_ty = this.xform_self_ty(&m,\n+            let xform_self_ty = this.xform_self_ty(&item,\n                                                    new_trait_ref.self_ty(),\n                                                    new_trait_ref.substs);\n \n             this.inherent_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n-                method_ty: m,\n-                kind: ObjectCandidate(new_trait_ref.def_id, method_num, vtable_index)\n+                item: item,\n+                kind: ObjectCandidate(new_trait_ref.def_id, item_num, vtable_index)\n             });\n         });\n     }\n@@ -476,27 +476,29 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             })\n             .collect();\n \n-        self.elaborate_bounds(&bounds, |this, poly_trait_ref, m, method_num| {\n+        self.elaborate_bounds(&bounds, |this, poly_trait_ref, item, item_num| {\n             let trait_ref =\n                 this.erase_late_bound_regions(&poly_trait_ref);\n \n             let xform_self_ty =\n-                this.xform_self_ty(&m,\n+                this.xform_self_ty(&item,\n                                    trait_ref.self_ty(),\n                                    trait_ref.substs);\n \n-            debug!(\"found match: trait_ref={} substs={} m={}\",\n-                   trait_ref.repr(this.tcx()),\n-                   trait_ref.substs.repr(this.tcx()),\n-                   m.repr(this.tcx()));\n-            assert_eq!(m.generics.types.get_slice(subst::TypeSpace).len(),\n-                       trait_ref.substs.types.get_slice(subst::TypeSpace).len());\n-            assert_eq!(m.generics.regions.get_slice(subst::TypeSpace).len(),\n-                       trait_ref.substs.regions().get_slice(subst::TypeSpace).len());\n-            assert_eq!(m.generics.types.get_slice(subst::SelfSpace).len(),\n-                       trait_ref.substs.types.get_slice(subst::SelfSpace).len());\n-            assert_eq!(m.generics.regions.get_slice(subst::SelfSpace).len(),\n-                       trait_ref.substs.regions().get_slice(subst::SelfSpace).len());\n+            if let Some(ref m) = item.as_opt_method() {\n+                debug!(\"found match: trait_ref={} substs={} m={}\",\n+                       trait_ref.repr(this.tcx()),\n+                       trait_ref.substs.repr(this.tcx()),\n+                       m.repr(this.tcx()));\n+                assert_eq!(m.generics.types.get_slice(subst::TypeSpace).len(),\n+                           trait_ref.substs.types.get_slice(subst::TypeSpace).len());\n+                assert_eq!(m.generics.regions.get_slice(subst::TypeSpace).len(),\n+                           trait_ref.substs.regions().get_slice(subst::TypeSpace).len());\n+                assert_eq!(m.generics.types.get_slice(subst::SelfSpace).len(),\n+                           trait_ref.substs.types.get_slice(subst::SelfSpace).len());\n+                assert_eq!(m.generics.regions.get_slice(subst::SelfSpace).len(),\n+                           trait_ref.substs.regions().get_slice(subst::SelfSpace).len());\n+            }\n \n             // Because this trait derives from a where-clause, it\n             // should not contain any inference variables or other\n@@ -507,8 +509,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n             this.inherent_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n-                method_ty: m,\n-                kind: WhereClauseCandidate(poly_trait_ref, method_num)\n+                item: item,\n+                kind: WhereClauseCandidate(poly_trait_ref, item_num)\n             });\n         });\n     }\n@@ -523,25 +525,25 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         F: for<'b> FnMut(\n             &mut ProbeContext<'b, 'tcx>,\n             ty::PolyTraitRef<'tcx>,\n-            Rc<ty::Method<'tcx>>,\n+            ty::ImplOrTraitItem<'tcx>,\n             usize,\n         ),\n     {\n         debug!(\"elaborate_bounds(bounds={})\", bounds.repr(self.tcx()));\n \n         let tcx = self.tcx();\n         for bound_trait_ref in traits::transitive_bounds(tcx, bounds) {\n-            let (pos, method) = match trait_method(tcx,\n-                                                   bound_trait_ref.def_id(),\n-                                                   self.method_name) {\n+            let (pos, item) = match trait_item(tcx,\n+                                               bound_trait_ref.def_id(),\n+                                               self.item_name) {\n                 Some(v) => v,\n                 None => { continue; }\n             };\n \n-            if !self.has_applicable_self(&*method) {\n+            if !self.has_applicable_self(&item) {\n                 self.record_static_candidate(TraitSource(bound_trait_ref.def_id()));\n             } else {\n-                mk_cand(self, bound_trait_ref, method, pos);\n+                mk_cand(self, bound_trait_ref, item, pos);\n             }\n         }\n     }\n@@ -584,46 +586,43 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             ty::trait_items(self.tcx(), trait_def_id);\n         let matching_index =\n             trait_items.iter()\n-                       .position(|item| item.name() == self.method_name);\n+                       .position(|item| item.name() == self.item_name);\n         let matching_index = match matching_index {\n             Some(i) => i,\n             None => { return Ok(()); }\n         };\n-        let method = match (&*trait_items)[matching_index].as_opt_method() {\n-            Some(m) => m,\n-            None => { return Ok(()); }\n-        };\n+        let ref item = (&*trait_items)[matching_index];\n \n         // Check whether `trait_def_id` defines a method with suitable name:\n-        if !self.has_applicable_self(&*method) {\n+        if !self.has_applicable_self(item) {\n             debug!(\"method has inapplicable self\");\n             self.record_static_candidate(TraitSource(trait_def_id));\n             return Ok(());\n         }\n \n         self.assemble_extension_candidates_for_trait_impls(trait_def_id,\n-                                                           method.clone(),\n+                                                           item.clone(),\n                                                            matching_index);\n \n         try!(self.assemble_closure_candidates(trait_def_id,\n-                                              method.clone(),\n+                                              item.clone(),\n                                               matching_index));\n \n         self.assemble_projection_candidates(trait_def_id,\n-                                            method.clone(),\n+                                            item.clone(),\n                                             matching_index);\n \n         self.assemble_where_clause_candidates(trait_def_id,\n-                                              method,\n+                                              item.clone(),\n                                               matching_index);\n \n         Ok(())\n     }\n \n     fn assemble_extension_candidates_for_trait_impls(&mut self,\n                                                      trait_def_id: ast::DefId,\n-                                                     method: Rc<ty::Method<'tcx>>,\n-                                                     method_index: usize)\n+                                                     item: ty::ImplOrTraitItem<'tcx>,\n+                                                     item_index: usize)\n     {\n         ty::populate_implementations_for_trait_if_necessary(self.tcx(),\n                                                             trait_def_id);\n@@ -657,16 +656,16 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n             // Determine the receiver type that the method itself expects.\n             let xform_self_ty =\n-                self.xform_self_ty(&method,\n+                self.xform_self_ty(&item,\n                                    impl_trait_ref.self_ty(),\n                                    impl_trait_ref.substs);\n \n             debug!(\"xform_self_ty={}\", xform_self_ty.repr(self.tcx()));\n \n             self.extension_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n-                method_ty: method.clone(),\n-                kind: ExtensionImplCandidate(impl_def_id, impl_trait_ref, impl_substs, method_index)\n+                item: item.clone(),\n+                kind: ExtensionImplCandidate(impl_def_id, impl_trait_ref, impl_substs, item_index)\n             });\n         }\n     }\n@@ -689,8 +688,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     fn assemble_closure_candidates(&mut self,\n                                    trait_def_id: ast::DefId,\n-                                   method_ty: Rc<ty::Method<'tcx>>,\n-                                   method_index: usize)\n+                                   item: ty::ImplOrTraitItem<'tcx>,\n+                                   item_index: usize)\n                                    -> Result<(),MethodError>\n     {\n         // Check if this is one of the Fn,FnMut,FnOnce traits.\n@@ -736,13 +735,13 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                                                              &trait_def.generics,\n                                                              step.self_ty);\n \n-            let xform_self_ty = self.xform_self_ty(&method_ty,\n+            let xform_self_ty = self.xform_self_ty(&item,\n                                                    step.self_ty,\n                                                    &substs);\n             self.inherent_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n-                method_ty: method_ty.clone(),\n-                kind: ClosureCandidate(trait_def_id, method_index)\n+                item: item.clone(),\n+                kind: ClosureCandidate(trait_def_id, item_index)\n             });\n         }\n \n@@ -751,16 +750,16 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     fn assemble_projection_candidates(&mut self,\n                                       trait_def_id: ast::DefId,\n-                                      method: Rc<ty::Method<'tcx>>,\n-                                      method_index: usize)\n+                                      item: ty::ImplOrTraitItem<'tcx>,\n+                                      item_index: usize)\n     {\n         debug!(\"assemble_projection_candidates(\\\n                trait_def_id={}, \\\n-               method={}, \\\n-               method_index={})\",\n+               item={}, \\\n+               item_index={})\",\n                trait_def_id.repr(self.tcx()),\n-               method.repr(self.tcx()),\n-               method_index);\n+               item.repr(self.tcx()),\n+               item_index);\n \n         for step in &*self.steps {\n             debug!(\"assemble_projection_candidates: step={}\",\n@@ -792,7 +791,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                        bound.repr(self.tcx()));\n \n                 if self.infcx().can_equate(&step.self_ty, &bound.self_ty()).is_ok() {\n-                    let xform_self_ty = self.xform_self_ty(&method,\n+                    let xform_self_ty = self.xform_self_ty(&item,\n                                                            bound.self_ty(),\n                                                            bound.substs);\n \n@@ -802,8 +801,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n                     self.extension_candidates.push(Candidate {\n                         xform_self_ty: xform_self_ty,\n-                        method_ty: method.clone(),\n-                        kind: ProjectionCandidate(trait_def_id, method_index)\n+                        item: item.clone(),\n+                        kind: ProjectionCandidate(trait_def_id, item_index)\n                     });\n                 }\n             }\n@@ -812,8 +811,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     fn assemble_where_clause_candidates(&mut self,\n                                         trait_def_id: ast::DefId,\n-                                        method_ty: Rc<ty::Method<'tcx>>,\n-                                        method_index: usize)\n+                                        item: ty::ImplOrTraitItem<'tcx>,\n+                                        item_index: usize)\n     {\n         debug!(\"assemble_where_clause_candidates(trait_def_id={})\",\n                trait_def_id.repr(self.tcx()));\n@@ -824,7 +823,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                           .filter(|b| b.def_id() == trait_def_id)\n         {\n             let bound = self.erase_late_bound_regions(&poly_bound);\n-            let xform_self_ty = self.xform_self_ty(&method_ty,\n+            let xform_self_ty = self.xform_self_ty(&item,\n                                                    bound.self_ty(),\n                                                    bound.substs);\n \n@@ -834,8 +833,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n             self.extension_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n-                method_ty: method_ty.clone(),\n-                kind: WhereClauseCandidate(poly_bound, method_index)\n+                item: item.clone(),\n+                kind: WhereClauseCandidate(poly_bound, item_index)\n             });\n         }\n     }\n@@ -860,7 +859,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         try!(self.assemble_extension_candidates_for_all_traits());\n \n         let out_of_scope_traits = match self.pick_core() {\n-            Some(Ok(p)) => vec![p.method_ty.container.id()],\n+            Some(Ok(p)) => vec![p.item.container().id()],\n             Some(Err(MethodError::Ambiguity(v))) => v.into_iter().map(|source| {\n                 match source {\n                     TraitSource(id) => id,\n@@ -1099,11 +1098,11 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         }\n \n         // If so, just use this trait and call it a day.\n-        let (trait_def_id, method_num) = trait_data;\n-        let method_ty = probes[0].method_ty.clone();\n+        let (trait_def_id, item_num) = trait_data;\n+        let item = probes[0].item.clone();\n         Some(Pick {\n-            method_ty: method_ty,\n-            kind: TraitPick(trait_def_id, method_num),\n+            item: item,\n+            kind: TraitPick(trait_def_id, item_num),\n             autoderefs: 0,\n             autoref: None,\n             unsize: None\n@@ -1117,39 +1116,49 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         self.infcx().sub_types(false, infer::Misc(DUMMY_SP), sub, sup)\n     }\n \n-    fn has_applicable_self(&self, method: &ty::Method) -> bool {\n+    fn has_applicable_self(&self, item: &ty::ImplOrTraitItem) -> bool {\n         // \"fast track\" -- check for usage of sugar\n-        match method.explicit_self {\n-            ty::StaticExplicitSelfCategory => {\n-                if self.mode == Mode::Path {\n-                    return true;\n-                }\n-            }\n-            ty::ByValueExplicitSelfCategory |\n-            ty::ByReferenceExplicitSelfCategory(..) |\n-            ty::ByBoxExplicitSelfCategory => {\n-                return true;\n-            }\n+        match *item {\n+            ty::ImplOrTraitItem::MethodTraitItem(ref method) =>\n+                match method.explicit_self {\n+                    ty::StaticExplicitSelfCategory => self.mode == Mode::Path,\n+                    ty::ByValueExplicitSelfCategory |\n+                    ty::ByReferenceExplicitSelfCategory(..) |\n+                    ty::ByBoxExplicitSelfCategory => true,\n+                },\n+            ty::ImplOrTraitItem::ConstTraitItem(..) => self.mode == Mode::Path,\n+            _ => false,\n         }\n-\n         // FIXME -- check for types that deref to `Self`,\n         // like `Rc<Self>` and so on.\n         //\n         // Note also that the current code will break if this type\n         // includes any of the type parameters defined on the method\n         // -- but this could be overcome.\n-        return false;\n     }\n \n     fn record_static_candidate(&mut self, source: CandidateSource) {\n         self.static_candidates.push(source);\n     }\n \n     fn xform_self_ty(&self,\n-                     method: &Rc<ty::Method<'tcx>>,\n+                     item: &ty::ImplOrTraitItem<'tcx>,\n                      impl_ty: Ty<'tcx>,\n                      substs: &subst::Substs<'tcx>)\n                      -> Ty<'tcx>\n+    {\n+        match item.as_opt_method() {\n+            Some(ref method) => self.xform_method_self_ty(method, impl_ty,\n+                                                          substs),\n+            None => impl_ty,\n+        }\n+    }\n+\n+    fn xform_method_self_ty(&self,\n+                            method: &Rc<ty::Method<'tcx>>,\n+                            impl_ty: Ty<'tcx>,\n+                            substs: &subst::Substs<'tcx>)\n+                            -> Ty<'tcx>\n     {\n         debug!(\"xform_self_ty(impl_ty={}, self_ty={}, substs={})\",\n                impl_ty.repr(self.tcx()),\n@@ -1245,46 +1254,45 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     }\n }\n \n-fn impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                     impl_def_id: ast::DefId,\n-                     method_name: ast::Name)\n-                     -> Option<Rc<ty::Method<'tcx>>>\n+fn impl_item<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                   impl_def_id: ast::DefId,\n+                   item_name: ast::Name)\n+                   -> Option<ty::ImplOrTraitItem<'tcx>>\n {\n     let impl_items = tcx.impl_items.borrow();\n     let impl_items = impl_items.get(&impl_def_id).unwrap();\n     impl_items\n         .iter()\n         .map(|&did| ty::impl_or_trait_item(tcx, did.def_id()))\n-        .find(|m| m.name() == method_name)\n-        .and_then(|item| item.as_opt_method())\n+        .find(|item| item.name() == item_name)\n }\n \n-/// Find method with name `method_name` defined in `trait_def_id` and return it, along with its\n-/// index (or `None`, if no such method).\n-fn trait_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                      trait_def_id: ast::DefId,\n-                      method_name: ast::Name)\n-                      -> Option<(usize, Rc<ty::Method<'tcx>>)>\n+/// Find item with name `item_name` defined in `trait_def_id` and return it,\n+/// along with its index (or `None`, if no such item).\n+fn trait_item<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                    trait_def_id: ast::DefId,\n+                    item_name: ast::Name)\n+                    -> Option<(usize, ty::ImplOrTraitItem<'tcx>)>\n {\n     let trait_items = ty::trait_items(tcx, trait_def_id);\n     debug!(\"trait_method; items: {:?}\", trait_items);\n     trait_items\n         .iter()\n         .enumerate()\n-        .find(|&(_, ref item)| item.name() == method_name)\n-        .and_then(|(idx, item)| item.as_opt_method().map(|m| (idx, m)))\n+        .find(|&(_, ref item)| item.name() == item_name)\n+        .map(|(num, ref item)| (num, (*item).clone()))\n }\n \n impl<'tcx> Candidate<'tcx> {\n     fn to_unadjusted_pick(&self) -> Pick<'tcx> {\n         Pick {\n-            method_ty: self.method_ty.clone(),\n+            item: self.item.clone(),\n             kind: match self.kind {\n                 InherentImplCandidate(def_id, _) => {\n                     InherentImplPick(def_id)\n                 }\n-                ObjectCandidate(def_id, method_num, real_index) => {\n-                    ObjectPick(def_id, method_num, real_index)\n+                ObjectCandidate(def_id, item_num, real_index) => {\n+                    ObjectPick(def_id, item_num, real_index)\n                 }\n                 ExtensionImplCandidate(def_id, _, _, index) => {\n                     ExtensionImplPick(def_id, index)\n@@ -1323,25 +1331,25 @@ impl<'tcx> Candidate<'tcx> {\n         }\n     }\n \n-    fn to_trait_data(&self) -> Option<(ast::DefId,MethodIndex)> {\n+    fn to_trait_data(&self) -> Option<(ast::DefId, ItemIndex)> {\n         match self.kind {\n             InherentImplCandidate(..) => {\n                 None\n             }\n-            ObjectCandidate(trait_def_id, method_num, _) => {\n-                Some((trait_def_id, method_num))\n+            ObjectCandidate(trait_def_id, item_num, _) => {\n+                Some((trait_def_id, item_num))\n             }\n-            ClosureCandidate(trait_def_id, method_num) => {\n-                Some((trait_def_id, method_num))\n+            ClosureCandidate(trait_def_id, item_num) => {\n+                Some((trait_def_id, item_num))\n             }\n-            ExtensionImplCandidate(_, ref trait_ref, _, method_num) => {\n-                Some((trait_ref.def_id, method_num))\n+            ExtensionImplCandidate(_, ref trait_ref, _, item_num) => {\n+                Some((trait_ref.def_id, item_num))\n             }\n-            WhereClauseCandidate(ref trait_ref, method_num) => {\n-                Some((trait_ref.def_id(), method_num))\n+            WhereClauseCandidate(ref trait_ref, item_num) => {\n+                Some((trait_ref.def_id(), item_num))\n             }\n-            ProjectionCandidate(trait_def_id, method_num) => {\n-                Some((trait_def_id, method_num))\n+            ProjectionCandidate(trait_def_id, item_num) => {\n+                Some((trait_def_id, item_num))\n             }\n         }\n     }\n@@ -1392,9 +1400,9 @@ impl<'tcx> Repr<'tcx> for PickKind<'tcx> {\n \n impl<'tcx> Repr<'tcx> for Pick<'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        format!(\"Pick(method_ty={}, autoderefs={},\n+        format!(\"Pick(item={}, autoderefs={},\n                  autoref={}, unsize={}, kind={:?})\",\n-                self.method_ty.repr(tcx),\n+                self.item.repr(tcx),\n                 self.autoderefs,\n                 self.autoref.repr(tcx),\n                 self.unsize.repr(tcx),"}, {"sha": "f9c78cd36e6ac1d93e3d3093337443363468201f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 160, "deletions": 62, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -78,7 +78,7 @@ type parameter).\n \n pub use self::LvaluePreference::*;\n pub use self::Expectation::*;\n-pub use self::compare_method::compare_impl_method;\n+pub use self::compare_method::{compare_impl_method, compare_const_impl};\n use self::TupleArgumentsFlag::*;\n \n use astconv::{self, ast_region_to_region, ast_ty_to_ty, AstConv, PathParamMode};\n@@ -807,6 +807,9 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n \n         for impl_item in impl_items {\n             match impl_item.node {\n+                ast::ConstImplItem(_, ref expr) => {\n+                    check_const(ccx, impl_item.span, &*expr, impl_item.id)\n+                }\n                 ast::MethodImplItem(ref sig, ref body) => {\n                     check_method_body(ccx, &impl_pty.generics, sig, body,\n                                       impl_item.id, impl_item.span);\n@@ -822,14 +825,15 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n         let trait_def = ty::lookup_trait_def(ccx.tcx, local_def(it.id));\n         for trait_item in trait_items {\n             match trait_item.node {\n-                ast::MethodTraitItem(_, None) => {\n-                    // Nothing to do, since required methods don't have\n-                    // bodies to check.\n+                ast::ConstTraitItem(_, Some(ref expr)) => {\n+                    check_const(ccx, trait_item.span, &*expr, trait_item.id)\n                 }\n                 ast::MethodTraitItem(ref sig, Some(ref body)) => {\n                     check_method_body(ccx, &trait_def.generics, sig, body,\n                                       trait_item.id, trait_item.span);\n                 }\n+                ast::ConstTraitItem(_, None) |\n+                ast::MethodTraitItem(_, None) |\n                 ast::TypeTraitItem(..) => {\n                     // Nothing to do.\n                 }\n@@ -919,6 +923,48 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // and compatible with trait signature\n     for impl_item in impl_items {\n         match impl_item.node {\n+            ast::ConstImplItem(..) => {\n+                let impl_const_def_id = local_def(impl_item.id);\n+                let impl_const_ty = ty::impl_or_trait_item(ccx.tcx,\n+                                                           impl_const_def_id);\n+\n+                // Find associated const definition.\n+                let opt_associated_const =\n+                    trait_items.iter()\n+                               .find(|ac| ac.name() == impl_const_ty.name());\n+                match opt_associated_const {\n+                    Some(associated_const) => {\n+                        match (associated_const, &impl_const_ty) {\n+                            (&ty::ConstTraitItem(ref const_trait),\n+                             &ty::ConstTraitItem(ref const_impl)) => {\n+                                compare_const_impl(ccx.tcx,\n+                                                   &const_impl,\n+                                                   impl_item.span,\n+                                                   &const_trait,\n+                                                   &*impl_trait_ref);\n+                            }\n+                            _ => {\n+                                span_err!(tcx.sess, impl_item.span, E0323,\n+                                          \"item `{}` is an associated const, \\\n+                                          which doesn't match its trait `{}`\",\n+                                          token::get_name(impl_const_ty.name()),\n+                                          impl_trait_ref.repr(tcx))\n+                            }\n+                        }\n+                    }\n+                    None => {\n+                        // This is `span_bug` as it should have already been\n+                        // caught in resolve.\n+                        tcx.sess.span_bug(\n+                            impl_item.span,\n+                            &format!(\n+                                \"associated const `{}` is not a member of \\\n+                                 trait `{}`\",\n+                                token::get_name(impl_const_ty.name()),\n+                                impl_trait_ref.repr(tcx)));\n+                    }\n+                }\n+            }\n             ast::MethodImplItem(_, ref body) => {\n                 let impl_method_def_id = local_def(impl_item.id);\n                 let impl_item_ty = ty::impl_or_trait_item(ccx.tcx,\n@@ -942,13 +988,11 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                     &*impl_trait_ref);\n                             }\n                             _ => {\n-                                // This is span_bug as it should have already been\n-                                // caught in resolve.\n-                                tcx.sess.span_bug(\n-                                    impl_item.span,\n-                                    &format!(\"item `{}` is of a different kind from its trait `{}`\",\n-                                             token::get_name(impl_item_ty.name()),\n-                                             impl_trait_ref.repr(tcx)));\n+                                span_err!(tcx.sess, impl_item.span, E0324,\n+                                          \"item `{}` is an associated method, \\\n+                                          which doesn't match its trait `{}`\",\n+                                          token::get_name(impl_item_ty.name()),\n+                                          impl_trait_ref.repr(tcx))\n                             }\n                         }\n                     }\n@@ -978,13 +1022,11 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         match (associated_type, &typedef_ty) {\n                             (&ty::TypeTraitItem(_), &ty::TypeTraitItem(_)) => {}\n                             _ => {\n-                                // This is `span_bug` as it should have\n-                                // already been caught in resolve.\n-                                tcx.sess.span_bug(\n-                                    impl_item.span,\n-                                    &format!(\"item `{}` is of a different kind from its trait `{}`\",\n-                                             token::get_name(typedef_ty.name()),\n-                                             impl_trait_ref.repr(tcx)));\n+                                span_err!(tcx.sess, impl_item.span, E0325,\n+                                          \"item `{}` is an associated type, \\\n+                                          which doesn't match its trait `{}`\",\n+                                          token::get_name(typedef_ty.name()),\n+                                          impl_trait_ref.repr(tcx))\n                             }\n                         }\n                     }\n@@ -1008,18 +1050,35 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     // Check for missing items from trait\n     let provided_methods = ty::provided_trait_methods(tcx, impl_trait_ref.def_id);\n+    let associated_consts = ty::associated_consts(tcx, impl_trait_ref.def_id);\n     let mut missing_methods = Vec::new();\n     for trait_item in &*trait_items {\n         match *trait_item {\n+            ty::ConstTraitItem(ref associated_const) => {\n+                let is_implemented = impl_items.iter().any(|ii| {\n+                    match ii.node {\n+                        ast::ConstImplItem(..) => {\n+                            ii.ident.name == associated_const.name\n+                        }\n+                        _ => false,\n+                    }\n+                });\n+                let is_provided =\n+                    associated_consts.iter().any(|ac| ac.default.is_some() &&\n+                                                 ac.name == associated_const.name);\n+                if !is_implemented && !is_provided {\n+                    missing_methods.push(format!(\"`{}`\",\n+                                                 token::get_name(associated_const.name)));\n+                }\n+            }\n             ty::MethodTraitItem(ref trait_method) => {\n                 let is_implemented =\n                     impl_items.iter().any(|ii| {\n                         match ii.node {\n                             ast::MethodImplItem(..) => {\n                                 ii.ident.name == trait_method.name\n                             }\n-                            ast::TypeImplItem(_) |\n-                            ast::MacImplItem(_) => false,\n+                            _ => false,\n                         }\n                     });\n                 let is_provided =\n@@ -1034,8 +1093,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         ast::TypeImplItem(_) => {\n                             ii.ident.name == associated_type.name\n                         }\n-                        ast::MethodImplItem(..) |\n-                        ast::MacImplItem(_) => false,\n+                        _ => false,\n                     }\n                 });\n                 if !is_implemented {\n@@ -3171,53 +3229,20 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                 &format!(\"unbound path {}\", expr.repr(tcx)))\n           };\n \n-          let def = path_res.base_def;\n-          if path_res.depth == 0 {\n+          if let Some((opt_ty, segments, def)) =\n+                  resolve_ty_and_def_ufcs(fcx, path_res, opt_self_ty, path,\n+                                          expr.span, expr.id) {\n               let (scheme, predicates) = type_scheme_and_predicates_for_def(fcx,\n                                                                             expr.span,\n                                                                             def);\n               instantiate_path(fcx,\n-                               &path.segments,\n+                               segments,\n                                scheme,\n                                &predicates,\n-                               opt_self_ty,\n+                               opt_ty,\n                                def,\n                                expr.span,\n                                id);\n-          } else {\n-              let ty_segments = path.segments.init();\n-              let base_ty_end = path.segments.len() - path_res.depth;\n-              let ty = astconv::finish_resolving_def_to_ty(fcx,\n-                                                           fcx,\n-                                                           expr.span,\n-                                                           PathParamMode::Optional,\n-                                                           &def,\n-                                                           opt_self_ty,\n-                                                           &ty_segments[..base_ty_end],\n-                                                           &ty_segments[base_ty_end..]);\n-              let method_segment = path.segments.last().unwrap();\n-              let method_name = method_segment.identifier.name;\n-              match method::resolve_ufcs(fcx, expr.span, method_name, ty, id) {\n-                  Ok((def, lp)) => {\n-                      // Write back the new resolution.\n-                      tcx.def_map.borrow_mut().insert(id, def::PathResolution {\n-                          base_def: def,\n-                          last_private: path_res.last_private.or(lp),\n-                          depth: 0\n-                      });\n-\n-                      let (scheme, predicates) =\n-                          type_scheme_and_predicates_for_def(fcx, expr.span, def);\n-                      instantiate_path(fcx, slice::ref_slice(method_segment),\n-                                       scheme, &predicates,\n-                                       Some(ty), def, expr.span, id);\n-                  }\n-                  Err(error) => {\n-                      method::report_error(fcx, expr.span, ty,\n-                                           method_name, None, error);\n-                      fcx.write_error(id);\n-                  }\n-              }\n           }\n \n           // We always require that the type provided as the value for\n@@ -3679,6 +3704,52 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n     unifier();\n }\n \n+pub fn resolve_ty_and_def_ufcs<'a, 'b, 'tcx>(fcx: &FnCtxt<'b, 'tcx>,\n+                                             path_res: def::PathResolution,\n+                                             opt_self_ty: Option<Ty<'tcx>>,\n+                                             path: &'a ast::Path,\n+                                             span: Span,\n+                                             node_id: ast::NodeId)\n+                                             -> Option<(Option<Ty<'tcx>>,\n+                                                        &'a [ast::PathSegment],\n+                                                        def::Def)>\n+{\n+    // If fully resolved already, we don't have to do anything.\n+    if path_res.depth == 0 {\n+        Some((opt_self_ty, &path.segments, path_res.base_def))\n+    } else {\n+        let mut def = path_res.base_def;\n+        let ty_segments = path.segments.init();\n+        let base_ty_end = path.segments.len() - path_res.depth;\n+        let ty = astconv::finish_resolving_def_to_ty(fcx, fcx, span,\n+                                                     PathParamMode::Optional,\n+                                                     &mut def,\n+                                                     opt_self_ty,\n+                                                     &ty_segments[..base_ty_end],\n+                                                     &ty_segments[base_ty_end..]);\n+        let item_segment = path.segments.last().unwrap();\n+        let item_name = item_segment.identifier.name;\n+        match method::resolve_ufcs(fcx, span, item_name, ty, node_id) {\n+            Ok((def, lp)) => {\n+                // Write back the new resolution.\n+                fcx.ccx.tcx.def_map.borrow_mut()\n+                       .insert(node_id, def::PathResolution {\n+                   base_def: def,\n+                   last_private: path_res.last_private.or(lp),\n+                   depth: 0\n+                });\n+                Some((Some(ty), slice::ref_slice(item_segment), def))\n+            }\n+            Err(error) => {\n+                method::report_error(fcx, span, ty,\n+                                     item_name, None, error);\n+                fcx.write_error(node_id);\n+                None\n+            }\n+        }\n+    }\n+}\n+\n fn constrain_path_type_parameters(fcx: &FnCtxt,\n                                   expr: &ast::Expr)\n {\n@@ -4207,7 +4278,7 @@ fn type_scheme_and_predicates_for_def<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n         def::DefFn(id, _) | def::DefMethod(id, _) |\n         def::DefStatic(id, _) | def::DefVariant(_, id, _) |\n-        def::DefStruct(id) | def::DefConst(id) => {\n+        def::DefStruct(id) | def::DefConst(id) | def::DefAssociatedConst(id, _) => {\n             (ty::lookup_item_type(fcx.tcx(), id), ty::lookup_predicates(fcx.tcx(), id))\n         }\n         def::DefTrait(_) |\n@@ -4249,7 +4320,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // Luckily, we can (at least for now) deduce the intermediate steps\n     // just from the end-point.\n     //\n-    // There are basically three cases to consider:\n+    // There are basically four cases to consider:\n     //\n     // 1. Reference to a *type*, such as a struct or enum:\n     //\n@@ -4299,6 +4370,16 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     //    `SomeStruct::<A>`, contains parameters in TypeSpace, and the\n     //    final segment, `foo::<B>` contains parameters in fn space.\n     //\n+    // 4. Reference to an *associated const*:\n+    //\n+    // impl<A> AnotherStruct<A> {\n+    // const FOO: B = BAR;\n+    // }\n+    //\n+    // The path in this case will look like\n+    // `a::b::AnotherStruct::<A>::FOO`, so the penultimate segment\n+    // only will have parameters in TypeSpace.\n+    //\n     // The first step then is to categorize the segments appropriately.\n \n     assert!(!segments.is_empty());\n@@ -4350,6 +4431,23 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             }\n         }\n \n+        def::DefAssociatedConst(_, provenance) => {\n+            match provenance {\n+                def::FromTrait(trait_did) => {\n+                    callee::check_legal_trait_for_method_call(fcx.ccx, span, trait_did)\n+                }\n+                def::FromImpl(_) => {}\n+            }\n+\n+            if segments.len() >= 2 {\n+                segment_spaces = repeat(None).take(segments.len() - 2).collect();\n+                segment_spaces.push(Some(subst::TypeSpace));\n+                segment_spaces.push(None);\n+            } else {\n+                segment_spaces = vec![None];\n+            }\n+        }\n+\n         // Other cases. Various nonsense that really shouldn't show up\n         // here. If they do, an error will have been reported\n         // elsewhere. (I hope)"}, {"sha": "fbfe73674e16088eb95388debd7338ffe97c53d9", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -20,8 +20,9 @@ use metadata::csearch::{each_impl, get_impl_trait};\n use metadata::csearch;\n use middle::subst::{self, Subst};\n use middle::ty::RegionEscape;\n-use middle::ty::{ImplContainer, ImplOrTraitItemId, MethodTraitItemId};\n-use middle::ty::{ParameterEnvironment, TypeTraitItemId, lookup_item_type};\n+use middle::ty::{ImplContainer, ImplOrTraitItemId, ConstTraitItemId};\n+use middle::ty::{MethodTraitItemId, TypeTraitItemId};\n+use middle::ty::{ParameterEnvironment, lookup_item_type};\n use middle::ty::{Ty, ty_bool, ty_char, ty_enum, ty_err};\n use middle::ty::{ty_param, TypeScheme, ty_ptr};\n use middle::ty::{ty_rptr, ty_struct, ty_trait, ty_tup};\n@@ -278,6 +279,9 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                 let mut items: Vec<ImplOrTraitItemId> =\n                         impl_items.iter().map(|impl_item| {\n                     match impl_item.node {\n+                        ast::ConstImplItem(..) => {\n+                            ConstTraitItemId(local_def(impl_item.id))\n+                        }\n                         ast::MethodImplItem(..) => {\n                             MethodTraitItemId(local_def(impl_item.id))\n                         }\n@@ -348,7 +352,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                            .insert(item_def_id.def_id(), source);\n                     }\n                 }\n-                ty::TypeTraitItem(_) => {}\n+                _ => {}\n             }\n         }\n "}, {"sha": "6cb6df008c1cf7e505ae8c8616809a5dcf37dd8b", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 112, "deletions": 56, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -197,7 +197,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n         let def_id = local_def(method_id);\n         match *self.tcx.impl_or_trait_items.borrow().get(&def_id).unwrap() {\n             ty::MethodTraitItem(ref mty) => mty.clone(),\n-            ty::TypeTraitItem(..) => {\n+            _ => {\n                 self.tcx.sess.bug(&format!(\"method with id {} has the wrong type\", method_id));\n             }\n         }\n@@ -692,11 +692,37 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n+fn convert_associated_const<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                      container: ImplOrTraitItemContainer,\n+                                      ident: ast::Ident,\n+                                      id: ast::NodeId,\n+                                      vis: ast::Visibility,\n+                                      ty: ty::Ty<'tcx>,\n+                                      default: Option<&ast::Expr>)\n+{\n+    ccx.tcx.predicates.borrow_mut().insert(local_def(id),\n+                                           ty::GenericPredicates::empty());\n+\n+    write_ty_to_tcx(ccx.tcx, id, ty);\n+    let default_id = default.map(|expr| local_def(expr.id));\n+\n+    let associated_const = Rc::new(ty::AssociatedConst {\n+        name: ident.name,\n+        vis: vis,\n+        def_id: local_def(id),\n+        container: container,\n+        ty: ty,\n+        default: default_id,\n+    });\n+    ccx.tcx.impl_or_trait_items.borrow_mut()\n+       .insert(local_def(id), ty::ConstTraitItem(associated_const));\n+}\n+\n fn as_refsociated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                     container: ImplOrTraitItemContainer,\n-                                     ident: ast::Ident,\n-                                     id: ast::NodeId,\n-                                     vis: ast::Visibility)\n+                                 container: ImplOrTraitItemContainer,\n+                                 ident: ast::Ident,\n+                                 id: ast::NodeId,\n+                                 vis: ast::Visibility)\n {\n     let associated_type = Rc::new(ty::AssociatedType {\n         name: ident.name,\n@@ -829,45 +855,56 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                 it.vis\n             };\n \n-            // Convert all the associated types.\n+            // Convert all the associated consts.\n             for impl_item in impl_items {\n-                match impl_item.node {\n-                    ast::TypeImplItem(ref ty) => {\n-                        if opt_trait_ref.is_none() {\n-                            span_err!(tcx.sess, impl_item.span, E0202,\n-                                              \"associated items are not allowed in inherent impls\");\n-                        }\n-\n-                        as_refsociated_type(ccx, ImplContainer(local_def(it.id)),\n-                                                impl_item.ident, impl_item.id, impl_item.vis);\n+                if let ast::ConstImplItem(ref ty, ref expr) = impl_item.node {\n+                    let ty = ccx.icx(&ty_predicates)\n+                                .to_ty(&ExplicitRscope, &*ty);\n+                    tcx.tcache.borrow_mut().insert(local_def(impl_item.id),\n+                                                   TypeScheme {\n+                                                       generics: ty_generics.clone(),\n+                                                       ty: ty,\n+                                                   });\n+                    convert_associated_const(ccx, ImplContainer(local_def(it.id)),\n+                                             impl_item.ident, impl_item.id,\n+                                             impl_item.vis.inherit_from(parent_visibility),\n+                                             ty, Some(&*expr));\n+                }\n+            }\n \n-                        let typ = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, ty);\n-                        tcx.tcache.borrow_mut().insert(local_def(impl_item.id),\n-                                                       TypeScheme {\n-                                                           generics: ty::Generics::empty(),\n-                                                           ty: typ,\n-                                                       });\n-                        tcx.predicates.borrow_mut().insert(local_def(impl_item.id),\n-                                                           ty::GenericPredicates::empty());\n-                        write_ty_to_tcx(tcx, impl_item.id, typ);\n+            // Convert all the associated types.\n+            for impl_item in impl_items {\n+                if let ast::TypeImplItem(ref ty) = impl_item.node {\n+                    if opt_trait_ref.is_none() {\n+                        span_err!(tcx.sess, impl_item.span, E0202,\n+                                  \"associated items are not allowed in inherent impls\");\n                     }\n-                    ast::MethodImplItem(..) |\n-                    ast::MacImplItem(_) => {}\n+\n+                    as_refsociated_type(ccx, ImplContainer(local_def(it.id)),\n+                                        impl_item.ident, impl_item.id, impl_item.vis);\n+\n+                    let typ = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, ty);\n+                    tcx.tcache.borrow_mut().insert(local_def(impl_item.id),\n+                                                   TypeScheme {\n+                                                       generics: ty::Generics::empty(),\n+                                                       ty: typ,\n+                                                   });\n+                    tcx.predicates.borrow_mut().insert(local_def(impl_item.id),\n+                                                       ty::GenericPredicates::empty());\n+                    write_ty_to_tcx(tcx, impl_item.id, typ);\n                 }\n             }\n \n             let methods = impl_items.iter().filter_map(|ii| {\n-                match ii.node {\n-                    ast::MethodImplItem(ref sig, _) => {\n-                        // if the method specifies a visibility, use that, otherwise\n-                        // inherit the visibility from the impl (so `foo` in `pub impl\n-                        // { fn foo(); }` is public, but private in `priv impl { fn\n-                        // foo(); }`).\n-                        let method_vis = ii.vis.inherit_from(parent_visibility);\n-                        Some((sig, ii.id, ii.ident, method_vis, ii.span))\n-                    }\n-                    ast::TypeImplItem(_) |\n-                    ast::MacImplItem(_) => None\n+                if let ast::MethodImplItem(ref sig, _) = ii.node {\n+                    // if the method specifies a visibility, use that, otherwise\n+                    // inherit the visibility from the impl (so `foo` in `pub impl\n+                    // { fn foo(); }` is public, but private in `priv impl { fn\n+                    // foo(); }`).\n+                    let method_vis = ii.vis.inherit_from(parent_visibility);\n+                    Some((sig, ii.id, ii.ident, method_vis, ii.span))\n+                } else {\n+                    None\n                 }\n             });\n             convert_methods(ccx,\n@@ -878,18 +915,14 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                             &ty_predicates);\n \n             for impl_item in impl_items {\n-                match impl_item.node {\n-                    ast::MethodImplItem(ref sig, ref body) => {\n-                        let body_id = body.id;\n-                        check_method_self_type(ccx,\n-                                               &BindingRscope::new(),\n-                                               ccx.method_ty(impl_item.id),\n-                                               selfty,\n-                                               &sig.explicit_self,\n-                                               body_id);\n-                    }\n-                    ast::TypeImplItem(_) |\n-                    ast::MacImplItem(_) => {}\n+                if let ast::MethodImplItem(ref sig, ref body) = impl_item.node {\n+                    let body_id = body.id;\n+                    check_method_self_type(ccx,\n+                                           &BindingRscope::new(),\n+                                           ccx.method_ty(impl_item.id),\n+                                           selfty,\n+                                           &sig.explicit_self,\n+                                           body_id);\n                 }\n             }\n \n@@ -920,18 +953,37 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n             // Convert all the associated types.\n             for trait_item in trait_items {\n                 match trait_item.node {\n-                    ast::MethodTraitItem(..) => {}\n+                    ast::ConstTraitItem(ref ty, ref default) => {\n+                        let ty = ccx.icx(&trait_predicates)\n+                                    .to_ty(&ExplicitRscope, ty);\n+                        tcx.tcache.borrow_mut().insert(local_def(trait_item.id),\n+                                                       TypeScheme {\n+                                                           generics: trait_def.generics.clone(),\n+                                                           ty: ty,\n+                                                       });\n+                        convert_associated_const(ccx, TraitContainer(local_def(it.id)),\n+                                                 trait_item.ident, trait_item.id,\n+                                                 ast::Public, ty, default.as_ref().map(|d| &**d));\n+                    }\n+                    _ => {}\n+                }\n+            };\n+\n+            // Convert all the associated types.\n+            for trait_item in trait_items {\n+                match trait_item.node {\n                     ast::TypeTraitItem(..) => {\n                         as_refsociated_type(ccx, TraitContainer(local_def(it.id)),\n                                                 trait_item.ident, trait_item.id, ast::Public);\n                     }\n+                    _ => {}\n                 }\n             };\n \n             let methods = trait_items.iter().filter_map(|ti| {\n                 let sig = match ti.node {\n                     ast::MethodTraitItem(ref sig, _) => sig,\n-                    ast::TypeTraitItem(..) => return None,\n+                    _ => return None,\n                 };\n                 Some((sig, ti.id, ti.ident, ast::Inherited, ti.span))\n             });\n@@ -948,6 +1000,9 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n             let trait_item_def_ids = Rc::new(trait_items.iter().map(|trait_item| {\n                 let def_id = local_def(trait_item.id);\n                 match trait_item.node {\n+                    ast::ConstTraitItem(..) => {\n+                        ty::ConstTraitItemId(def_id)\n+                    }\n                     ast::MethodTraitItem(..) => {\n                         ty::MethodTraitItemId(def_id)\n                     }\n@@ -963,7 +1018,7 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n             for trait_item in trait_items {\n                 let sig = match trait_item.node {\n                     ast::MethodTraitItem(ref sig, _) => sig,\n-                    ast::TypeTraitItem(..) => continue\n+                    _ => continue\n                 };\n                 check_method_self_type(ccx,\n                                        &BindingRscope::new(),\n@@ -1186,8 +1241,8 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     let associated_type_names: Vec<_> = items.iter().filter_map(|trait_item| {\n         match trait_item.node {\n-            ast::MethodTraitItem(..) => None,\n             ast::TypeTraitItem(..) => Some(trait_item.ident.name),\n+            _ => None,\n         }\n     }).collect();\n \n@@ -1261,7 +1316,7 @@ fn trait_defines_associated_type_named(ccx: &CrateCtxt,\n     trait_items.iter().any(|trait_item| {\n         match trait_item.node {\n             ast::TypeTraitItem(..) => trait_item.ident.name == assoc_name,\n-            ast::MethodTraitItem(..) => false,\n+            _ => false,\n         }\n     })\n }\n@@ -1321,7 +1376,7 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n         trait_items.iter().flat_map(|trait_item| {\n             let bounds = match trait_item.node {\n                 ast::TypeTraitItem(ref bounds, _) => bounds,\n-                ast::MethodTraitItem(..) => {\n+                _ => {\n                     return vec!().into_iter();\n                 }\n             };\n@@ -2237,7 +2292,8 @@ fn enforce_impl_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n         impl_items.iter()\n                   .filter_map(|item| match item.node {\n                       ast::TypeImplItem(..) => Some(ty::node_id_to_type(tcx, item.id)),\n-                      ast::MethodImplItem(..) | ast::MacImplItem(..) => None,\n+                      ast::ConstImplItem(..) | ast::MethodImplItem(..) |\n+                      ast::MacImplItem(..) => None,\n                   })\n                   .flat_map(|ty| ctp::parameters_for_type(ty).into_iter())\n                   .filter_map(|p| match p {"}, {"sha": "46cc4628e2eeb36022f7782bd7d89af67c72cee7", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -176,6 +176,11 @@ register_diagnostics! {\n     E0320, // recursive overflow during dropck\n     E0321, // extended coherence rules for defaulted traits violated\n     E0322, // cannot implement Sized explicitly\n+    E0323, // implemented an associated const when another trait item expected\n+    E0324, // implemented a method when another trait item expected\n+    E0325, // implemented an associated type when another trait item expected\n+    E0326, // associated const implemented with different type from trait\n+    E0327, // referred to method instead of constant in match pattern\n     E0366, // dropck forbid specialization to concrete type or region\n     E0367, // dropck forbid specialization to predicate not in struct/enum\n     E0368, // binary operation `<op>=` cannot be applied to types"}, {"sha": "0d59577a6d802ce1552cd45cf9267dad1c06f9f5", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -22,12 +22,13 @@ use rustc::middle::def;\n use rustc::middle::ty;\n use rustc::middle::subst;\n use rustc::middle::stability;\n+use rustc::middle::const_eval;\n \n use core::DocContext;\n use doctree;\n use clean;\n \n-use super::Clean;\n+use super::{Clean, ToSource};\n \n /// Attempt to inline the definition of a local node id into this AST.\n ///\n@@ -106,7 +107,7 @@ fn try_inline_def(cx: &DocContext, tcx: &ty::ctxt,\n             record_extern_fqn(cx, did, clean::TypeStatic);\n             clean::StaticItem(build_static(cx, tcx, did, mtbl))\n         }\n-        def::DefConst(did) => {\n+        def::DefConst(did) | def::DefAssociatedConst(did, _) => {\n             record_extern_fqn(cx, did, clean::TypeConst);\n             clean::ConstantItem(build_const(cx, tcx, did))\n         }\n@@ -312,6 +313,27 @@ pub fn build_impl(cx: &DocContext,\n         let did = did.def_id();\n         let impl_item = ty::impl_or_trait_item(tcx, did);\n         match impl_item {\n+            ty::ConstTraitItem(ref assoc_const) => {\n+                let did = assoc_const.def_id;\n+                let type_scheme = ty::lookup_item_type(tcx, did);\n+                let default = match assoc_const.default {\n+                    Some(_) => Some(const_eval::lookup_const_by_id(tcx, did, None)\n+                                               .unwrap().span.to_src(cx)),\n+                    None => None,\n+                };\n+                Some(clean::Item {\n+                    name: Some(assoc_const.name.clean(cx)),\n+                    inner: clean::AssociatedConstItem(\n+                        type_scheme.ty.clean(cx),\n+                        default,\n+                    ),\n+                    source: clean::Span::empty(),\n+                    attrs: vec![],\n+                    visibility: None,\n+                    stability: stability::lookup(tcx, did).clean(cx),\n+                    def_id: did\n+                })\n+            }\n             ty::MethodTraitItem(method) => {\n                 if method.vis != ast::Public && associated_trait.is_none() {\n                     return None\n@@ -443,7 +465,7 @@ fn build_const(cx: &DocContext, tcx: &ty::ctxt,\n     use rustc::middle::const_eval;\n     use syntax::print::pprust;\n \n-    let expr = const_eval::lookup_const_by_id(tcx, did).unwrap_or_else(|| {\n+    let expr = const_eval::lookup_const_by_id(tcx, did, None).unwrap_or_else(|| {\n         panic!(\"expected lookup_const_by_id to succeed for {:?}\", did);\n     });\n     debug!(\"converting constant expr {:?} to snippet\", expr);"}, {"sha": "1e6e9a7562a7c1be287fe5e69e42ff7f49dce460", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -361,6 +361,7 @@ pub enum ItemEnum {\n     ForeignStaticItem(Static),\n     MacroItem(Macro),\n     PrimitiveItem(PrimitiveType),\n+    AssociatedConstItem(Type, Option<String>),\n     AssociatedTypeItem(Vec<TyParamBound>, Option<Type>),\n     DefaultImplItem(DefaultImpl),\n }\n@@ -1235,6 +1236,11 @@ impl Clean<PolyTrait> for ast::PolyTraitRef {\n impl Clean<Item> for ast::TraitItem {\n     fn clean(&self, cx: &DocContext) -> Item {\n         let inner = match self.node {\n+            ast::ConstTraitItem(ref ty, ref default) => {\n+                AssociatedConstItem(ty.clean(cx),\n+                                    default.as_ref().map(|expr|\n+                                                         expr.span.to_src(cx)))\n+            }\n             ast::MethodTraitItem(ref sig, Some(_)) => {\n                 MethodItem(sig.clean(cx))\n             }\n@@ -1260,6 +1266,12 @@ impl Clean<Item> for ast::TraitItem {\n impl Clean<Item> for ast::ImplItem {\n     fn clean(&self, cx: &DocContext) -> Item {\n         let inner = match self.node {\n+            ast::ConstImplItem(ref ty, ref expr) => {\n+                ConstantItem(Constant{\n+                    type_: ty.clean(cx),\n+                    expr: expr.span.to_src(cx),\n+                })\n+            }\n             ast::MethodImplItem(ref sig, _) => {\n                 MethodItem(sig.clean(cx))\n             }\n@@ -1363,6 +1375,7 @@ impl<'tcx> Clean<Item> for ty::Method<'tcx> {\n impl<'tcx> Clean<Item> for ty::ImplOrTraitItem<'tcx> {\n     fn clean(&self, cx: &DocContext) -> Item {\n         match *self {\n+            ty::ConstTraitItem(ref cti) => cti.clean(cx),\n             ty::MethodTraitItem(ref mti) => mti.clean(cx),\n             ty::TypeTraitItem(ref tti) => tti.clean(cx),\n         }\n@@ -2509,6 +2522,8 @@ fn name_from_pat(p: &ast::Pat) -> String {\n         PatWild(PatWildMulti) => \"..\".to_string(),\n         PatIdent(_, ref p, _) => token::get_ident(p.node).to_string(),\n         PatEnum(ref p, _) => path_to_string(p),\n+        PatQPath(..) => panic!(\"tried to get argument name from PatQPath, \\\n+                                which is not allowed in function arguments\"),\n         PatStruct(ref name, ref fields, etc) => {\n             format!(\"{} {{ {}{} }}\", path_to_string(name),\n                 fields.iter().map(|&Spanned { node: ref fp, .. }|\n@@ -2672,6 +2687,20 @@ impl Clean<Stability> for attr::Stability {\n     }\n }\n \n+impl<'tcx> Clean<Item> for ty::AssociatedConst<'tcx> {\n+    fn clean(&self, cx: &DocContext) -> Item {\n+        Item {\n+            source: DUMMY_SP.clean(cx),\n+            name: Some(self.name.clean(cx)),\n+            attrs: Vec::new(),\n+            inner: AssociatedConstItem(self.ty.clean(cx), None),\n+            visibility: None,\n+            def_id: self.def_id,\n+            stability: None,\n+        }\n+    }\n+}\n+\n impl Clean<Item> for ty::AssociatedType {\n     fn clean(&self, cx: &DocContext) -> Item {\n         // When loading a cross-crate associated type, the bounds for this type"}, {"sha": "afc93f41172e84498729ceece2adebcc6845022d", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -39,6 +39,7 @@ pub enum ItemType {\n     Primitive       = 15,\n     AssociatedType  = 16,\n     Constant        = 17,\n+    AssociatedConst = 18,\n }\n \n impl ItemType {\n@@ -63,6 +64,7 @@ impl ItemType {\n             clean::ForeignStaticItem(..)   => ItemType::Static, // no ForeignStatic\n             clean::MacroItem(..)           => ItemType::Macro,\n             clean::PrimitiveItem(..)       => ItemType::Primitive,\n+            clean::AssociatedConstItem(..) => ItemType::AssociatedConst,\n             clean::AssociatedTypeItem(..)  => ItemType::AssociatedType,\n             clean::DefaultImplItem(..)     => ItemType::Impl,\n         }\n@@ -102,6 +104,7 @@ impl ItemType {\n             ItemType::Primitive       => \"primitive\",\n             ItemType::AssociatedType  => \"associatedtype\",\n             ItemType::Constant        => \"constant\",\n+            ItemType::AssociatedConst => \"associatedconstant\",\n         }\n     }\n }"}, {"sha": "9a26a925847e41dbb045b32b809ce24f4009b537", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 61, "deletions": 38, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -1629,6 +1629,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                 ItemType::Macro           => (\"macros\", \"Macros\"),\n                 ItemType::Primitive       => (\"primitives\", \"Primitive Types\"),\n                 ItemType::AssociatedType  => (\"associated-types\", \"Associated Types\"),\n+                ItemType::AssociatedConst => (\"associated-consts\", \"Associated Constants\"),\n             };\n             try!(write!(w,\n                         \"<h2 id='{id}' class='section-header'>\\\n@@ -1799,23 +1800,23 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         try!(write!(w, \"{{\\n\"));\n         for t in &types {\n             try!(write!(w, \"    \"));\n-            try!(render_method(w, t, MethodLink::Anchor));\n+            try!(render_assoc_item(w, t, AssocItemLink::Anchor));\n             try!(write!(w, \";\\n\"));\n         }\n         if !types.is_empty() && !required.is_empty() {\n             try!(w.write_str(\"\\n\"));\n         }\n         for m in &required {\n             try!(write!(w, \"    \"));\n-            try!(render_method(w, m, MethodLink::Anchor));\n+            try!(render_assoc_item(w, m, AssocItemLink::Anchor));\n             try!(write!(w, \";\\n\"));\n         }\n         if !required.is_empty() && !provided.is_empty() {\n             try!(w.write_str(\"\\n\"));\n         }\n         for m in &provided {\n             try!(write!(w, \"    \"));\n-            try!(render_method(w, m, MethodLink::Anchor));\n+            try!(render_assoc_item(w, m, AssocItemLink::Anchor));\n             try!(write!(w, \" {{ ... }}\\n\"));\n         }\n         try!(write!(w, \"}}\"));\n@@ -1831,7 +1832,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                     ty = shortty(m),\n                     name = *m.name.as_ref().unwrap(),\n                     stab = m.stability_class()));\n-        try!(render_method(w, m, MethodLink::Anchor));\n+        try!(render_assoc_item(w, m, AssocItemLink::Anchor));\n         try!(write!(w, \"</code></h3>\"));\n         try!(document(w, m));\n         Ok(())\n@@ -1871,7 +1872,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     }\n \n     // If there are methods directly on this trait object, render them here.\n-    try!(render_methods(w, it.def_id, MethodRender::All));\n+    try!(render_assoc_items(w, it.def_id, AssocItemRender::All));\n \n     let cache = cache();\n     try!(write!(w, \"\n@@ -1903,6 +1904,17 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     Ok(())\n }\n \n+fn assoc_const(w: &mut fmt::Formatter, it: &clean::Item,\n+               ty: &clean::Type, default: &Option<String>)\n+               -> fmt::Result {\n+    try!(write!(w, \"const {}\", it.name.as_ref().unwrap()));\n+    try!(write!(w, \": {}\", ty));\n+    if let Some(ref default) = *default {\n+        try!(write!(w, \" = {}\", default));\n+    }\n+    Ok(())\n+}\n+\n fn assoc_type(w: &mut fmt::Formatter, it: &clean::Item,\n               bounds: &Vec<clean::TyParamBound>,\n               default: &Option<clean::Type>)\n@@ -1917,19 +1929,19 @@ fn assoc_type(w: &mut fmt::Formatter, it: &clean::Item,\n     Ok(())\n }\n \n-fn render_method(w: &mut fmt::Formatter, meth: &clean::Item,\n-                 link: MethodLink) -> fmt::Result {\n+fn render_assoc_item(w: &mut fmt::Formatter, meth: &clean::Item,\n+                     link: AssocItemLink) -> fmt::Result {\n     fn method(w: &mut fmt::Formatter, it: &clean::Item,\n               unsafety: ast::Unsafety, abi: abi::Abi,\n               g: &clean::Generics, selfty: &clean::SelfTy,\n-              d: &clean::FnDecl, link: MethodLink) -> fmt::Result {\n+              d: &clean::FnDecl, link: AssocItemLink) -> fmt::Result {\n         use syntax::abi::Abi;\n \n         let name = it.name.as_ref().unwrap();\n         let anchor = format!(\"#{}.{}\", shortty(it), name);\n         let href = match link {\n-            MethodLink::Anchor => anchor,\n-            MethodLink::GotoSource(did) => {\n+            AssocItemLink::Anchor => anchor,\n+            AssocItemLink::GotoSource(did) => {\n                 href(did).map(|p| format!(\"{}{}\", p.0, anchor)).unwrap_or(anchor)\n             }\n         };\n@@ -1958,10 +1970,13 @@ fn render_method(w: &mut fmt::Formatter, meth: &clean::Item,\n             method(w, meth, m.unsafety, m.abi, &m.generics, &m.self_, &m.decl,\n                    link)\n         }\n+        clean::AssociatedConstItem(ref ty, ref default) => {\n+            assoc_const(w, meth, ty, default)\n+        }\n         clean::AssociatedTypeItem(ref bounds, ref default) => {\n             assoc_type(w, meth, bounds, default)\n         }\n-        _ => panic!(\"render_method called on non-method\")\n+        _ => panic!(\"render_assoc_item called on non-associated-item\")\n     }\n }\n \n@@ -2001,7 +2016,7 @@ fn item_struct(w: &mut fmt::Formatter, it: &clean::Item,\n             try!(write!(w, \"</table>\"));\n         }\n     }\n-    render_methods(w, it.def_id, MethodRender::All)\n+    render_assoc_items(w, it.def_id, AssocItemRender::All)\n }\n \n fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n@@ -2100,7 +2115,7 @@ fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n         try!(write!(w, \"</table>\"));\n \n     }\n-    try!(render_methods(w, it.def_id, MethodRender::All));\n+    try!(render_assoc_items(w, it.def_id, AssocItemRender::All));\n     Ok(())\n }\n \n@@ -2184,19 +2199,19 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n }\n \n #[derive(Copy, Clone)]\n-enum MethodLink {\n+enum AssocItemLink {\n     Anchor,\n     GotoSource(ast::DefId),\n }\n \n-enum MethodRender<'a> {\n+enum AssocItemRender<'a> {\n     All,\n     DerefFor { trait_: &'a clean::Type, type_: &'a clean::Type },\n }\n \n-fn render_methods(w: &mut fmt::Formatter,\n-                  it: ast::DefId,\n-                  what: MethodRender) -> fmt::Result {\n+fn render_assoc_items(w: &mut fmt::Formatter,\n+                      it: ast::DefId,\n+                      what: AssocItemRender) -> fmt::Result {\n     let c = cache();\n     let v = match c.impls.get(&it) {\n         Some(v) => v,\n@@ -2207,21 +2222,21 @@ fn render_methods(w: &mut fmt::Formatter,\n     });\n     if !non_trait.is_empty() {\n         let render_header = match what {\n-            MethodRender::All => {\n+            AssocItemRender::All => {\n                 try!(write!(w, \"<h2 id='methods'>Methods</h2>\"));\n                 true\n             }\n-            MethodRender::DerefFor { trait_, type_ } => {\n+            AssocItemRender::DerefFor { trait_, type_ } => {\n                 try!(write!(w, \"<h2 id='deref-methods'>Methods from \\\n                                     {}&lt;Target={}&gt;</h2>\", trait_, type_));\n                 false\n             }\n         };\n         for i in &non_trait {\n-            try!(render_impl(w, i, MethodLink::Anchor, render_header));\n+            try!(render_impl(w, i, AssocItemLink::Anchor, render_header));\n         }\n     }\n-    if let MethodRender::DerefFor { .. } = what {\n+    if let AssocItemRender::DerefFor { .. } = what {\n         return Ok(())\n     }\n     if !traits.is_empty() {\n@@ -2243,15 +2258,15 @@ fn render_methods(w: &mut fmt::Formatter,\n         });\n         for i in &manual {\n             let did = i.trait_did().unwrap();\n-            try!(render_impl(w, i, MethodLink::GotoSource(did), true));\n+            try!(render_impl(w, i, AssocItemLink::GotoSource(did), true));\n         }\n         if !derived.is_empty() {\n             try!(write!(w, \"<h3 id='derived_implementations'>\\\n                 Derived Implementations \\\n             </h3>\"));\n             for i in &derived {\n                 let did = i.trait_did().unwrap();\n-                try!(render_impl(w, i, MethodLink::GotoSource(did), true));\n+                try!(render_impl(w, i, AssocItemLink::GotoSource(did), true));\n             }\n         }\n     }\n@@ -2266,22 +2281,22 @@ fn render_deref_methods(w: &mut fmt::Formatter, impl_: &Impl) -> fmt::Result {\n             _ => None,\n         }\n     }).next().unwrap();\n-    let what = MethodRender::DerefFor { trait_: deref_type, type_: target };\n+    let what = AssocItemRender::DerefFor { trait_: deref_type, type_: target };\n     match *target {\n-        clean::ResolvedPath { did, .. } => render_methods(w, did, what),\n+        clean::ResolvedPath { did, .. } => render_assoc_items(w, did, what),\n         _ => {\n             if let Some(prim) = target.primitive_type() {\n                 if let Some(c) = cache().primitive_locations.get(&prim) {\n                     let did = ast::DefId { krate: *c, node: prim.to_node_id() };\n-                    try!(render_methods(w, did, what));\n+                    try!(render_assoc_items(w, did, what));\n                 }\n             }\n             Ok(())\n         }\n     }\n }\n \n-fn render_impl(w: &mut fmt::Formatter, i: &Impl, link: MethodLink,\n+fn render_impl(w: &mut fmt::Formatter, i: &Impl, link: AssocItemLink,\n                render_header: bool) -> fmt::Result {\n     if render_header {\n         try!(write!(w, \"<h3 class='impl'><code>impl{} \",\n@@ -2300,13 +2315,13 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl, link: MethodLink,\n     }\n \n     fn doctraititem(w: &mut fmt::Formatter, item: &clean::Item,\n-                    link: MethodLink) -> fmt::Result {\n+                    link: AssocItemLink) -> fmt::Result {\n         match item.inner {\n             clean::MethodItem(..) | clean::TyMethodItem(..) => {\n                 try!(write!(w, \"<h4 id='method.{}' class='{}'><code>\",\n                             *item.name.as_ref().unwrap(),\n                             shortty(item)));\n-                try!(render_method(w, item, link));\n+                try!(render_assoc_item(w, item, link));\n                 try!(write!(w, \"</code></h4>\\n\"));\n             }\n             clean::TypedefItem(ref tydef) => {\n@@ -2317,6 +2332,14 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl, link: MethodLink,\n                 try!(write!(w, \"type {} = {}\", name, tydef.type_));\n                 try!(write!(w, \"</code></h4>\\n\"));\n             }\n+            clean::AssociatedConstItem(ref ty, ref default) => {\n+                let name = item.name.as_ref().unwrap();\n+                try!(write!(w, \"<h4 id='assoc_const.{}' class='{}'><code>\",\n+                            *name,\n+                            shortty(item)));\n+                try!(assoc_const(w, item, ty, default));\n+                try!(write!(w, \"</code></h4>\\n\"));\n+            }\n             clean::AssociatedTypeItem(ref bounds, ref default) => {\n                 let name = item.name.as_ref().unwrap();\n                 try!(write!(w, \"<h4 id='assoc_type.{}' class='{}'><code>\",\n@@ -2327,7 +2350,7 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl, link: MethodLink,\n             }\n             _ => panic!(\"can't make docs for trait item with name {:?}\", item.name)\n         }\n-        if let MethodLink::Anchor = link {\n+        if let AssocItemLink::Anchor = link {\n             document(w, item)\n         } else {\n             Ok(())\n@@ -2339,18 +2362,18 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl, link: MethodLink,\n         try!(doctraititem(w, trait_item, link));\n     }\n \n-    fn render_default_methods(w: &mut fmt::Formatter,\n-                              did: ast::DefId,\n-                              t: &clean::Trait,\n-                              i: &clean::Impl) -> fmt::Result {\n+    fn render_default_items(w: &mut fmt::Formatter,\n+                            did: ast::DefId,\n+                            t: &clean::Trait,\n+                            i: &clean::Impl) -> fmt::Result {\n         for trait_item in &t.items {\n             let n = trait_item.name.clone();\n             match i.items.iter().find(|m| { m.name == n }) {\n                 Some(..) => continue,\n                 None => {}\n             }\n \n-            try!(doctraititem(w, trait_item, MethodLink::GotoSource(did)));\n+            try!(doctraititem(w, trait_item, AssocItemLink::GotoSource(did)));\n         }\n         Ok(())\n     }\n@@ -2361,7 +2384,7 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl, link: MethodLink,\n     // for them work.\n     if let Some(clean::ResolvedPath { did, .. }) = i.impl_.trait_ {\n         if let Some(t) = cache().traits.get(&did) {\n-            try!(render_default_methods(w, did, t, &i.impl_));\n+            try!(render_default_items(w, did, t, &i.impl_));\n         }\n     }\n     try!(write!(w, \"</div>\"));\n@@ -2458,7 +2481,7 @@ fn item_primitive(w: &mut fmt::Formatter,\n                   it: &clean::Item,\n                   _p: &clean::PrimitiveType) -> fmt::Result {\n     try!(document(w, it));\n-    render_methods(w, it.def_id, MethodRender::All)\n+    render_assoc_items(w, it.def_id, AssocItemRender::All)\n }\n \n fn get_basic_keywords() -> &'static str {"}, {"sha": "74c16127f41ccac87c3bf3aba6d2acb37b644c7e", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -184,7 +184,8 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n             // Primitives are never stripped\n             clean::PrimitiveItem(..) => {}\n \n-            // Associated types are never stripped\n+            // Associated consts and types are never stripped\n+            clean::AssociatedConstItem(..) |\n             clean::AssociatedTypeItem(..) => {}\n         }\n "}, {"sha": "3b7bfb1043a35acc543fb9851df9422d8c45d1f3", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -593,6 +593,12 @@ pub enum Pat_ {\n     /// \"None\" means a * pattern where we don't bind the fields to names.\n     PatEnum(Path, Option<Vec<P<Pat>>>),\n \n+    /// An associated const named using the qualified path `<T>::CONST` or\n+    /// `<T as Trait>::CONST`. Associated consts from inherent impls can be\n+    /// refered to as simply `T::CONST`, in which case they will end up as\n+    /// PatEnum, and the resolver will have to sort that out.\n+    PatQPath(QSelf, Path),\n+\n     /// Destructuring of a struct, e.g. `Foo {x, y, ..}`\n     /// The `bool` is `true` in the presence of a `..`\n     PatStruct(Path, Vec<Spanned<FieldPat>>, bool),\n@@ -1230,6 +1236,7 @@ pub struct TraitItem {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum TraitItem_ {\n+    ConstTraitItem(P<Ty>, Option<P<Expr>>),\n     MethodTraitItem(MethodSig, Option<P<Block>>),\n     TypeTraitItem(TyParamBounds, Option<P<Ty>>),\n }\n@@ -1246,6 +1253,7 @@ pub struct ImplItem {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum ImplItem_ {\n+    ConstImplItem(P<Ty>, P<Expr>),\n     MethodImplItem(MethodSig, P<Block>),\n     TypeImplItem(P<Ty>),\n     MacImplItem(Mac),"}, {"sha": "36a7f3a93817c127b966e56ea6099ee55446e08e", "filename": "src/libsyntax/ast_map/blocks.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fblocks.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -222,8 +222,7 @@ impl<'a> FnLikeNode<'a> {\n                     ast::MethodImplItem(ref sig, ref body) => {\n                         method(ii.id, ii.ident, sig, Some(ii.vis), body, ii.span)\n                     }\n-                    ast::TypeImplItem(_) |\n-                    ast::MacImplItem(_) => {\n+                    _ => {\n                         panic!(\"impl method FnLikeNode that is not fn-like\")\n                     }\n                 }"}, {"sha": "795391d4009144cea3a2682086d5497b725a50a7", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -940,6 +940,12 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n         }\n         Some(NodeImplItem(ii)) => {\n             match ii.node {\n+                ConstImplItem(..) => {\n+                    format!(\"assoc const {} in {}{}\",\n+                            token::get_ident(ii.ident),\n+                            map.path_to_string(id),\n+                            id_str)\n+                }\n                 MethodImplItem(..) => {\n                     format!(\"method {} in {}{}\",\n                             token::get_ident(ii.ident),\n@@ -959,9 +965,9 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n         }\n         Some(NodeTraitItem(ti)) => {\n             let kind = match ti.node {\n+                ConstTraitItem(..) => \"assoc constant\",\n                 MethodTraitItem(..) => \"trait method\",\n                 TypeTraitItem(..) => \"assoc type\",\n-//                 ConstTraitItem(..) => \"assoc constant\"\n             };\n \n             format!(\"{} {} in {}{}\","}, {"sha": "8471fef3487e62f53af6d48d68eaab0fa040d444", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -579,7 +579,7 @@ pub fn walk_pat<F>(pat: &Pat, mut it: F) -> bool where F: FnMut(&Pat) -> bool {\n             }\n             PatMac(_) => panic!(\"attempted to analyze unexpanded pattern\"),\n             PatWild(_) | PatLit(_) | PatRange(_, _) | PatIdent(_, _, _) |\n-            PatEnum(_, _) => {\n+            PatEnum(_, _) | PatQPath(_, _) => {\n                 true\n             }\n         }"}, {"sha": "60b1d4797d5212ff19c61eeb2fbd6394d845cbe8", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -155,6 +155,10 @@ const KNOWN_FEATURES: &'static [(&'static str, &'static str, Status)] = &[\n \n     // Allows use of unary negate on unsigned integers, e.g. -e for e: u8\n     (\"negate_unsigned\", \"1.0.0\", Active),\n+\n+    // Allows the definition of associated constants in `trait` or `impl`\n+    // blocks.\n+    (\"associated_consts\", \"1.0.0\", Active),\n ];\n // (changing above list without updating src/doc/reference.md makes @cmr sad)\n \n@@ -659,6 +663,30 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n         }\n         visit::walk_fn(self, fn_kind, fn_decl, block, span);\n     }\n+\n+    fn visit_trait_item(&mut self, ti: &'v ast::TraitItem) {\n+        match ti.node {\n+            ast::ConstTraitItem(..) => {\n+                self.gate_feature(\"associated_consts\",\n+                                  ti.span,\n+                                  \"associated constants are experimental\")\n+            }\n+            _ => {}\n+        }\n+        visit::walk_trait_item(self, ti);\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &'v ast::ImplItem) {\n+        match ii.node {\n+            ast::ConstImplItem(..) => {\n+                self.gate_feature(\"associated_consts\",\n+                                  ii.span,\n+                                  \"associated constants are experimental\")\n+            }\n+            _ => {}\n+        }\n+        visit::walk_impl_item(self, ii);\n+    }\n }\n \n fn check_crate_inner<F>(cm: &CodeMap, span_handler: &SpanHandler,"}, {"sha": "adfda988b23b747a05c13329b097e2f4af80f8b7", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -980,6 +980,10 @@ pub fn noop_fold_trait_item<T: Folder>(i: P<TraitItem>, folder: &mut T)\n         ident: folder.fold_ident(ident),\n         attrs: fold_attrs(attrs, folder),\n         node: match node {\n+            ConstTraitItem(ty, default) => {\n+                ConstTraitItem(folder.fold_ty(ty),\n+                               default.map(|x| folder.fold_expr(x)))\n+            }\n             MethodTraitItem(sig, body) => {\n                 MethodTraitItem(noop_fold_method_sig(sig, folder),\n                                 body.map(|x| folder.fold_block(x)))\n@@ -1001,6 +1005,9 @@ pub fn noop_fold_impl_item<T: Folder>(i: P<ImplItem>, folder: &mut T)\n         attrs: fold_attrs(attrs, folder),\n         vis: vis,\n         node: match node  {\n+            ConstImplItem(ty, expr) => {\n+                ConstImplItem(folder.fold_ty(ty), folder.fold_expr(expr))\n+            }\n             MethodImplItem(sig, body) => {\n                 MethodImplItem(noop_fold_method_sig(sig, folder),\n                                folder.fold_block(body))\n@@ -1134,6 +1141,10 @@ pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n                 PatEnum(folder.fold_path(pth),\n                         pats.map(|pats| pats.move_map(|x| folder.fold_pat(x))))\n             }\n+            PatQPath(qself, pth) => {\n+                let qself = QSelf {ty: folder.fold_ty(qself.ty), .. qself};\n+                PatQPath(qself, folder.fold_path(pth))\n+            }\n             PatStruct(pth, fields, etc) => {\n                 let pth = folder.fold_path(pth);\n                 let fs = fields.move_map(|f| {"}, {"sha": "f76de1f04ce2ce2f5517ad2dd2bac5d349727f35", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 134, "deletions": 81, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -17,8 +17,8 @@ use ast::{Public, Unsafety};\n use ast::{Mod, BiAdd, Arg, Arm, Attribute, BindByRef, BindByValue};\n use ast::{BiBitAnd, BiBitOr, BiBitXor, BiRem, BiLt, BiGt, Block};\n use ast::{BlockCheckMode, CaptureByRef, CaptureByValue, CaptureClause};\n-use ast::{Crate, CrateConfig, Decl, DeclItem};\n-use ast::{DeclLocal, DefaultBlock, DefaultReturn};\n+use ast::{ConstImplItem, ConstTraitItem, Crate, CrateConfig};\n+use ast::{Decl, DeclItem, DeclLocal, DefaultBlock, DefaultReturn};\n use ast::{UnDeref, BiDiv, EMPTY_CTXT, EnumDef, ExplicitSelf};\n use ast::{Expr, Expr_, ExprAddrOf, ExprMatch, ExprAgain};\n use ast::{ExprAssign, ExprAssignOp, ExprBinary, ExprBlock, ExprBox};\n@@ -40,8 +40,9 @@ use ast::{MacStmtWithBraces, MacStmtWithSemicolon, MacStmtWithoutBraces};\n use ast::{MutImmutable, MutMutable, Mac_, MacInvocTT, MatchSource};\n use ast::{MutTy, BiMul, Mutability};\n use ast::{MethodImplItem, NamedField, UnNeg, NoReturn, UnNot};\n-use ast::{Pat, PatBox, PatEnum, PatIdent, PatLit, PatMac, PatRange, PatRegion};\n-use ast::{PatStruct, PatTup, PatVec, PatWild, PatWildMulti, PatWildSingle};\n+use ast::{Pat, PatBox, PatEnum, PatIdent, PatLit, PatQPath, PatMac, PatRange};\n+use ast::{PatRegion, PatStruct, PatTup, PatVec, PatWild, PatWildMulti};\n+use ast::PatWildSingle;\n use ast::{PolyTraitRef, QSelf};\n use ast::{Return, BiShl, BiShr, Stmt, StmtDecl};\n use ast::{StmtExpr, StmtSemi, StmtMac, StructDef, StructField};\n@@ -109,6 +110,15 @@ pub enum PathParsingMode {\n     LifetimeAndTypesWithColons,\n }\n \n+/// How to parse a qualified path, whether to allow trailing parameters.\n+#[derive(Copy, Clone, PartialEq)]\n+pub enum QPathParsingMode {\n+    /// No trailing parameters, e.g. `<T as Trait>::Item`\n+    NoParameters,\n+    /// Optional parameters, e.g. `<T as Trait>::item::<'a, U>`\n+    MaybeParameters,\n+}\n+\n /// How to parse a bound, whether to allow bound modifiers such as `?`.\n #[derive(Copy, Clone, PartialEq)]\n pub enum BoundParsingMode {\n@@ -1161,6 +1171,20 @@ impl<'a> Parser<'a> {\n                 let TyParam {ident, bounds, default, ..} = try!(p.parse_ty_param());\n                 try!(p.expect(&token::Semi));\n                 (ident, TypeTraitItem(bounds, default))\n+            } else if try!(p.eat_keyword(keywords::Const)) {\n+                let ident = try!(p.parse_ident());\n+                try!(p.expect(&token::Colon));\n+                let ty = try!(p.parse_ty_sum());\n+                let default = if p.check(&token::Eq) {\n+                    try!(p.bump());\n+                    let expr = try!(p.parse_expr_nopanic());\n+                    try!(p.commit_expr_expecting(&expr, token::Semi));\n+                    Some(expr)\n+                } else {\n+                    try!(p.expect(&token::Semi));\n+                    None\n+                };\n+                (ident, ConstTraitItem(ty, default))\n             } else {\n                 let style = try!(p.parse_unsafety());\n                 let abi = if try!(p.eat_keyword(keywords::Extern)) {\n@@ -1334,36 +1358,9 @@ impl<'a> Parser<'a> {\n             try!(self.expect(&token::CloseDelim(token::Paren)));\n             TyTypeof(e)\n         } else if try!(self.eat_lt()) {\n-            // QUALIFIED PATH `<TYPE as TRAIT_REF>::item`\n-            let self_type = try!(self.parse_ty_sum());\n \n-            let mut path = if try!(self.eat_keyword(keywords::As) ){\n-                try!(self.parse_path(LifetimeAndTypesWithoutColons))\n-            } else {\n-                ast::Path {\n-                    span: self.span,\n-                    global: false,\n-                    segments: vec![]\n-                }\n-            };\n-\n-            let qself = QSelf {\n-                ty: self_type,\n-                position: path.segments.len()\n-            };\n-\n-            try!(self.expect(&token::Gt));\n-            try!(self.expect(&token::ModSep));\n-\n-            path.segments.push(ast::PathSegment {\n-                identifier: try!(self.parse_ident()),\n-                parameters: ast::PathParameters::none()\n-            });\n-\n-            if path.segments.len() == 1 {\n-                path.span.lo = self.last_span.lo;\n-            }\n-            path.span.hi = self.last_span.hi;\n+            let (qself, path) =\n+                 try!(self.parse_qualified_path(QPathParsingMode::NoParameters));\n \n             TyPath(Some(qself), path)\n         } else if self.check(&token::ModSep) ||\n@@ -1580,6 +1577,61 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    // QUALIFIED PATH `<TYPE [as TRAIT_REF]>::IDENT[::<PARAMS>]`\n+    // Assumes that the leading `<` has been parsed already.\n+    pub fn parse_qualified_path(&mut self, mode: QPathParsingMode)\n+                                -> PResult<(QSelf, ast::Path)> {\n+        let self_type = try!(self.parse_ty_sum());\n+        let mut path = if try!(self.eat_keyword(keywords::As)) {\n+            try!(self.parse_path(LifetimeAndTypesWithoutColons))\n+        } else {\n+            ast::Path {\n+                span: self.span,\n+                global: false,\n+                segments: vec![]\n+            }\n+        };\n+\n+        let qself = QSelf {\n+            ty: self_type,\n+            position: path.segments.len()\n+        };\n+\n+        try!(self.expect(&token::Gt));\n+        try!(self.expect(&token::ModSep));\n+\n+        let item_name = try!(self.parse_ident());\n+        let parameters = match mode {\n+            QPathParsingMode::NoParameters => ast::PathParameters::none(),\n+            QPathParsingMode::MaybeParameters => {\n+                if try!(self.eat(&token::ModSep)) {\n+                    try!(self.expect_lt());\n+                    // Consumed `item::<`, go look for types\n+                    let (lifetimes, types, bindings) =\n+                        try!(self.parse_generic_values_after_lt());\n+                    ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n+                        lifetimes: lifetimes,\n+                        types: OwnedSlice::from_vec(types),\n+                        bindings: OwnedSlice::from_vec(bindings),\n+                    })\n+                } else {\n+                    ast::PathParameters::none()\n+                }\n+            }\n+        };\n+        path.segments.push(ast::PathSegment {\n+            identifier: item_name,\n+            parameters: parameters\n+        });\n+\n+        if path.segments.len() == 1 {\n+            path.span.lo = self.last_span.lo;\n+        }\n+        path.span.hi = self.last_span.hi;\n+\n+        Ok((qself, path))\n+    }\n+\n     /// Parses a path and optional type parameter bounds, depending on the\n     /// mode. The `mode` parameter determines whether lifetimes, types, and/or\n     /// bounds are permitted and whether `::` must precede type parameter\n@@ -2043,49 +2095,10 @@ impl<'a> Parser<'a> {\n             }\n             _ => {\n                 if try!(self.eat_lt()){\n-                    // QUALIFIED PATH `<TYPE as TRAIT_REF>::item::<'a, T>`\n-                    let self_type = try!(self.parse_ty_sum());\n-                    let mut path = if try!(self.eat_keyword(keywords::As) ){\n-                        try!(self.parse_path(LifetimeAndTypesWithoutColons))\n-                    } else {\n-                        ast::Path {\n-                            span: self.span,\n-                            global: false,\n-                            segments: vec![]\n-                        }\n-                    };\n-                    let qself = QSelf {\n-                        ty: self_type,\n-                        position: path.segments.len()\n-                    };\n-                    try!(self.expect(&token::Gt));\n-                    try!(self.expect(&token::ModSep));\n-\n-                    let item_name = try!(self.parse_ident());\n-                    let parameters = if try!(self.eat(&token::ModSep) ){\n-                        try!(self.expect_lt());\n-                        // Consumed `item::<`, go look for types\n-                        let (lifetimes, types, bindings) =\n-                            try!(self.parse_generic_values_after_lt());\n-                        ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n-                            lifetimes: lifetimes,\n-                            types: OwnedSlice::from_vec(types),\n-                            bindings: OwnedSlice::from_vec(bindings),\n-                        })\n-                    } else {\n-                        ast::PathParameters::none()\n-                    };\n-                    path.segments.push(ast::PathSegment {\n-                        identifier: item_name,\n-                        parameters: parameters\n-                    });\n \n-                    if path.segments.len() == 1 {\n-                        path.span.lo = self.last_span.lo;\n-                    }\n-                    path.span.hi = self.last_span.hi;\n+                    let (qself, path) =\n+                        try!(self.parse_qualified_path(QPathParsingMode::MaybeParameters));\n \n-                    let hi = self.span.hi;\n                     return Ok(self.mk_expr(lo, hi, ExprPath(Some(qself), path)));\n                 }\n                 if try!(self.eat_keyword(keywords::Move) ){\n@@ -3158,16 +3171,25 @@ impl<'a> Parser<'a> {\n     fn parse_pat_range_end(&mut self) -> PResult<P<Expr>> {\n         if self.is_path_start() {\n             let lo = self.span.lo;\n-            let path = try!(self.parse_path(LifetimeAndTypesWithColons));\n+            let (qself, path) = if try!(self.eat_lt()) {\n+                // Parse a qualified path\n+                let (qself, path) =\n+                    try!(self.parse_qualified_path(QPathParsingMode::NoParameters));\n+                (Some(qself), path)\n+            } else {\n+                // Parse an unqualified path\n+                (None, try!(self.parse_path(LifetimeAndTypesWithColons)))\n+            };\n             let hi = self.last_span.hi;\n-            Ok(self.mk_expr(lo, hi, ExprPath(None, path)))\n+            Ok(self.mk_expr(lo, hi, ExprPath(qself, path)))\n         } else {\n             self.parse_literal_maybe_minus()\n         }\n     }\n \n     fn is_path_start(&self) -> bool {\n-        (self.token == token::ModSep || self.token.is_ident() || self.token.is_path())\n+        (self.token == token::Lt || self.token == token::ModSep\n+            || self.token.is_ident() || self.token.is_path())\n             && !self.token.is_keyword(keywords::True) && !self.token.is_keyword(keywords::False)\n     }\n \n@@ -3243,25 +3265,44 @@ impl<'a> Parser<'a> {\n                         pat = try!(self.parse_pat_ident(BindByValue(MutImmutable)));\n                     }\n                 } else {\n-                    // Parse as a general path\n-                    let path = try!(self.parse_path(LifetimeAndTypesWithColons));\n+                    let (qself, path) = if try!(self.eat_lt()) {\n+                        // Parse a qualified path\n+                        let (qself, path) =\n+                            try!(self.parse_qualified_path(QPathParsingMode::NoParameters));\n+                        (Some(qself), path)\n+                    } else {\n+                        // Parse an unqualified path\n+                        (None, try!(self.parse_path(LifetimeAndTypesWithColons)))\n+                    };\n                     match self.token {\n                       token::DotDotDot => {\n                         // Parse range\n                         let hi = self.last_span.hi;\n-                        let begin = self.mk_expr(lo, hi, ExprPath(None, path));\n+                        let begin = self.mk_expr(lo, hi, ExprPath(qself, path));\n                         try!(self.bump());\n                         let end = try!(self.parse_pat_range_end());\n                         pat = PatRange(begin, end);\n                       }\n                       token::OpenDelim(token::Brace) => {\n-                        // Parse struct pattern\n+                         if qself.is_some() {\n+                            let span = self.span;\n+                            self.span_err(span,\n+                                          \"unexpected `{` after qualified path\");\n+                            self.abort_if_errors();\n+                        }\n+                       // Parse struct pattern\n                         try!(self.bump());\n                         let (fields, etc) = try!(self.parse_pat_fields());\n                         try!(self.bump());\n                         pat = PatStruct(path, fields, etc);\n                       }\n                       token::OpenDelim(token::Paren) => {\n+                        if qself.is_some() {\n+                            let span = self.span;\n+                            self.span_err(span,\n+                                          \"unexpected `(` after qualified path\");\n+                            self.abort_if_errors();\n+                        }\n                         // Parse tuple struct or enum pattern\n                         if self.look_ahead(1, |t| *t == token::DotDot) {\n                             // This is a \"top constructor only\" pat\n@@ -3278,6 +3319,10 @@ impl<'a> Parser<'a> {\n                             pat = PatEnum(path, Some(args));\n                         }\n                       }\n+                      _ if qself.is_some() => {\n+                        // Parse qualified path\n+                        pat = PatQPath(qself.unwrap(), path);\n+                      }\n                       _ => {\n                         // Parse nullary enum\n                         pat = PatEnum(path, Some(vec![]));\n@@ -4349,6 +4394,14 @@ impl<'a> Parser<'a> {\n             let typ = try!(self.parse_ty_sum());\n             try!(self.expect(&token::Semi));\n             (name, TypeImplItem(typ))\n+        } else if try!(self.eat_keyword(keywords::Const)) {\n+            let name = try!(self.parse_ident());\n+            try!(self.expect(&token::Colon));\n+            let typ = try!(self.parse_ty_sum());\n+            try!(self.expect(&token::Eq));\n+            let expr = try!(self.parse_expr_nopanic());\n+            try!(self.commit_expr_expecting(&expr, token::Semi));\n+            (name, ConstImplItem(typ, expr))\n         } else {\n             let (name, inner_attrs, node) = try!(self.parse_impl_method(vis));\n             attrs.extend(inner_attrs.into_iter());"}, {"sha": "87c164f7550f9a5e56b3a3f3918af47dc0ac43ec", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -761,6 +761,26 @@ impl<'a> State<'a> {\n         }\n     }\n \n+    fn print_associated_const(&mut self,\n+                              ident: ast::Ident,\n+                              ty: &ast::Ty,\n+                              default: Option<&ast::Expr>,\n+                              vis: ast::Visibility)\n+                              -> io::Result<()>\n+    {\n+        try!(word(&mut self.s, &visibility_qualified(vis, \"\")));\n+        try!(self.word_space(\"const\"));\n+        try!(self.print_ident(ident));\n+        try!(self.word_space(\":\"));\n+        try!(self.print_type(ty));\n+        if let Some(expr) = default {\n+            try!(space(&mut self.s));\n+            try!(self.word_space(\"=\"));\n+            try!(self.print_expr(expr));\n+        }\n+        word(&mut self.s, \";\")\n+    }\n+\n     fn print_associated_type(&mut self,\n                              ident: ast::Ident,\n                              bounds: Option<&ast::TyParamBounds>,\n@@ -1234,6 +1254,11 @@ impl<'a> State<'a> {\n         try!(self.maybe_print_comment(ti.span.lo));\n         try!(self.print_outer_attributes(&ti.attrs));\n         match ti.node {\n+            ast::ConstTraitItem(ref ty, ref default) => {\n+                try!(self.print_associated_const(ti.ident, &ty,\n+                                                 default.as_ref().map(|expr| &**expr),\n+                                                 ast::Inherited));\n+            }\n             ast::MethodTraitItem(ref sig, ref body) => {\n                 if body.is_some() {\n                     try!(self.head(\"\"));\n@@ -1260,6 +1285,9 @@ impl<'a> State<'a> {\n         try!(self.maybe_print_comment(ii.span.lo));\n         try!(self.print_outer_attributes(&ii.attrs));\n         match ii.node {\n+            ast::ConstImplItem(ref ty, ref expr) => {\n+                try!(self.print_associated_const(ii.ident, &ty, Some(&expr), ii.vis));\n+            }\n             ast::MethodImplItem(ref sig, ref body) => {\n                 try!(self.head(\"\"));\n                 try!(self.print_method_sig(ii.ident, sig, ii.vis));\n@@ -2152,6 +2180,9 @@ impl<'a> State<'a> {\n                     }\n                 }\n             }\n+            ast::PatQPath(ref qself, ref path) => {\n+                try!(self.print_qpath(path, qself, false));\n+            }\n             ast::PatStruct(ref path, ref fields, etc) => {\n                 try!(self.print_path(path, true, 0));\n                 try!(self.nbsp());"}, {"sha": "6cf791b10be67612eaa75ad146d630fafb1a5602", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -464,6 +464,10 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n                 }\n             }\n         }\n+        PatQPath(ref qself, ref path) => {\n+            visitor.visit_ty(&qself.ty);\n+            visitor.visit_path(path, pattern.id)\n+        }\n         PatStruct(ref path, ref fields, _) => {\n             visitor.visit_path(path, pattern.id);\n             for field in fields {\n@@ -619,6 +623,12 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n         visitor.visit_attribute(attr);\n     }\n     match trait_item.node {\n+        ConstTraitItem(ref ty, ref default) => {\n+            visitor.visit_ty(ty);\n+            if let Some(ref expr) = *default {\n+                visitor.visit_expr(expr);\n+            }\n+        }\n         MethodTraitItem(ref sig, None) => {\n             visitor.visit_explicit_self(&sig.explicit_self);\n             visitor.visit_generics(&sig.generics);\n@@ -641,6 +651,10 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n         visitor.visit_attribute(attr);\n     }\n     match impl_item.node {\n+        ConstImplItem(ref ty, ref expr) => {\n+            visitor.visit_ty(ty);\n+            visitor.visit_expr(expr);\n+        }\n         MethodImplItem(ref sig, ref body) => {\n             visitor.visit_fn(FkMethod(impl_item.ident, sig, Some(impl_item.vis)), &sig.decl,\n                              body, impl_item.span, impl_item.id);"}, {"sha": "1fd8fee0117c5c31b287405a19faa33526a258f3", "filename": "src/test/auxiliary/associated-const-cc-lib.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Fauxiliary%2Fassociated-const-cc-lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Fauxiliary%2Fassociated-const-cc-lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fassociated-const-cc-lib.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_consts)]\n+\n+#![crate_type=\"lib\"]\n+\n+// These items are for testing that associated consts work cross-crate.\n+pub trait Foo {\n+    const BAR: usize;\n+}\n+\n+pub struct FooNoDefault;\n+\n+impl Foo for FooNoDefault {\n+    const BAR: usize = 0;\n+}\n+\n+// These test that defaults and default resolution work cross-crate.\n+pub trait FooDefault {\n+    const BAR: usize = 1;\n+}\n+\n+pub struct FooOverwriteDefault;\n+\n+impl FooDefault for FooOverwriteDefault {\n+    const BAR: usize = 2;\n+}\n+\n+pub struct FooUseDefault;\n+\n+impl FooDefault for FooUseDefault {}\n+\n+// Test inherent impls.\n+pub struct InherentBar;\n+\n+impl InherentBar {\n+    pub const BAR: usize = 3;\n+}"}, {"sha": "1ed156d45f5507644323e2302b9aa37436d6d9f5", "filename": "src/test/compile-fail/associated-const-dead-code.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Fcompile-fail%2Fassociated-const-dead-code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Fcompile-fail%2Fassociated-const-dead-code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-const-dead-code.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_consts)]\n+#![deny(dead_code)]\n+\n+struct MyFoo;\n+\n+impl MyFoo {\n+    const BAR: u32 = 1;\n+    //~^ ERROR associated const is never used: `BAR`\n+}\n+\n+fn main() {\n+    let _: MyFoo = MyFoo;\n+}"}, {"sha": "4f20d9e78ebd010a74269a7f7598a42cc69693b2", "filename": "src/test/compile-fail/associated-const-impl-wrong-type.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Fcompile-fail%2Fassociated-const-impl-wrong-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Fcompile-fail%2Fassociated-const-impl-wrong-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-const-impl-wrong-type.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_consts)]\n+\n+trait Foo {\n+    const BAR: u32;\n+}\n+\n+struct SignedBar;\n+\n+impl Foo for SignedBar {\n+    const BAR: i32 = -1;\n+    //~^ ERROR E0326\n+}\n+\n+fn main() {}"}, {"sha": "be949db0281d28ebd70ef01c944450c89cfff47b", "filename": "src/test/compile-fail/associated-const-private-impl.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Fcompile-fail%2Fassociated-const-private-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Fcompile-fail%2Fassociated-const-private-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-const-private-impl.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_consts)]\n+\n+mod bar1 {\n+    pub use self::bar2::Foo;\n+    mod bar2 {\n+        pub struct Foo;\n+\n+        impl Foo {\n+            const ID: i32 = 1;\n+        }\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(1, bar1::Foo::ID);\n+    //~^ERROR associated const `ID` is private\n+}"}, {"sha": "752691fa1c5500f691654a6357a360b28d8c25b9", "filename": "src/test/compile-fail/associated-const-upper-case-lint.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Fcompile-fail%2Fassociated-const-upper-case-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Fcompile-fail%2Fassociated-const-upper-case-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-const-upper-case-lint.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_consts)]\n+#![deny(non_upper_case_globals)]\n+#![allow(dead_code)]\n+\n+struct Foo;\n+\n+impl Foo {\n+    const not_upper: bool = true;\n+}\n+//~^^ ERROR associated constant `not_upper` should have an upper case name such as `NOT_UPPER`\n+\n+fn main() {}"}, {"sha": "21672b18bde449fe631a9413bcf270ce884d98ab", "filename": "src/test/compile-fail/gated-associated_consts.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Fcompile-fail%2Fgated-associated_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Fcompile-fail%2Fgated-associated_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgated-associated_consts.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait MyTrait {\n+    const C: bool;\n+    //~^ associated constants are experimental\n+    //~| add #![feature(associated_consts)] to the crate attributes to enable\n+}\n+\n+struct Foo;\n+\n+impl Foo {\n+    const C: bool = true;\n+    //~^ associated constants are experimental\n+    //~| add #![feature(associated_consts)] to the crate attributes to enable\n+}"}, {"sha": "9b3e28cbc01ee4eaa4cf98d746a6a9731c914a3c", "filename": "src/test/compile-fail/impl-wrong-item-for-trait.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Fcompile-fail%2Fimpl-wrong-item-for-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Fcompile-fail%2Fimpl-wrong-item-for-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-wrong-item-for-trait.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_consts)]\n+\n+trait Foo {\n+    fn bar(&self);\n+    const MY_CONST: u32;\n+}\n+\n+pub struct FooConstForMethod;\n+\n+impl Foo for FooConstForMethod {\n+    //~^ ERROR E0046\n+    const bar: u64 = 1;\n+    //~^ ERROR E0323\n+    const MY_CONST: u32 = 1;\n+}\n+\n+pub struct FooMethodForConst;\n+\n+impl Foo for FooMethodForConst {\n+    //~^ ERROR E0046\n+    fn bar(&self) {}\n+    fn MY_CONST() {}\n+    //~^ ERROR E0324\n+}\n+\n+pub struct FooTypeForMethod;\n+\n+impl Foo for FooTypeForMethod {\n+    //~^ ERROR E0046\n+    type bar = u64;\n+    //~^ ERROR E0325\n+    const MY_CONST: u32 = 1;\n+}\n+\n+fn main () {}"}, {"sha": "faf6d255c9afc38c2b26ba93b5ea0105fbbcb59b", "filename": "src/test/compile-fail/method-path-in-pattern.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Fcompile-fail%2Fmethod-path-in-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Fcompile-fail%2Fmethod-path-in-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-path-in-pattern.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo;\n+\n+impl Foo {\n+    fn bar(&self) {}\n+}\n+\n+trait MyTrait {\n+    fn trait_bar() {}\n+}\n+\n+impl MyTrait for Foo {}\n+\n+fn main() {\n+    match 0u32 {\n+        Foo::bar => {} //~ ERROR E0327\n+    }\n+    match 0u32 {\n+        <Foo>::bar => {} //~ ERROR E0327\n+    }\n+    match 0u32 {\n+        <Foo>::trait_bar => {} //~ ERROR E0327\n+    }\n+}"}, {"sha": "0df824e7f535bd4b83185bad9b2ebe32c4ff1a47", "filename": "src/test/compile-fail/method-resolvable-path-in-pattern.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Fcompile-fail%2Fmethod-resolvable-path-in-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Fcompile-fail%2Fmethod-resolvable-path-in-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-resolvable-path-in-pattern.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo;\n+\n+trait MyTrait {\n+    fn trait_bar() {}\n+}\n+\n+impl MyTrait for Foo {}\n+\n+fn main() {\n+    match 0u32 {\n+        <Foo as MyTrait>::trait_bar => {}\n+        //~^ ERROR `trait_bar` is not an associated const\n+    }\n+}"}, {"sha": "66f462df05ac9d05b04d0ad9f288448efa7c4eb3", "filename": "src/test/parse-fail/brace-after-qualified-path-in-match.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Fparse-fail%2Fbrace-after-qualified-path-in-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Fparse-fail%2Fbrace-after-qualified-path-in-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fbrace-after-qualified-path-in-match.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn foo() {\n+    match x {\n+        <T as Trait>::Type{key: value} => (),\n+        //~^ ERROR unexpected `{` after qualified path\n+        _ => (),\n+    }\n+}"}, {"sha": "be6bd516d6fe439388160260d61fc3c4f824d302", "filename": "src/test/parse-fail/issue-20711-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Fparse-fail%2Fissue-20711-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Fparse-fail%2Fissue-20711-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-20711-2.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -16,6 +16,6 @@ impl Foo {\n     fn foo() {}\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-} //~ ERROR expected one of `extern`, `fn`, `pub`, `type`, or `unsafe`, found `}`\n+} //~ ERROR expected one of `const`, `extern`, `fn`, `pub`, `type`, or `unsafe`, found `}`\n \n fn main() {}"}, {"sha": "d1d8d3acf91871bc581d3799380a47aca6d1126f", "filename": "src/test/parse-fail/issue-20711.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Fparse-fail%2Fissue-20711.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Fparse-fail%2Fissue-20711.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-20711.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -14,6 +14,6 @@ struct Foo;\n \n impl Foo {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-} //~ ERROR expected one of `extern`, `fn`, `pub`, `type`, or `unsafe`, found `}`\n+} //~ ERROR expected one of `const`, `extern`, `fn`, `pub`, `type`, or `unsafe`, found `}`\n \n fn main() {}"}, {"sha": "76a4687f544da3578a553d654818dd5783e9506e", "filename": "src/test/parse-fail/issue-21153.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Fparse-fail%2Fissue-21153.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Fparse-fail%2Fissue-21153.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-21153.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -11,5 +11,5 @@\n // compile-flags: -Z parse-only\n \n trait MyTrait<T>: Iterator {\n-    Item = T; //~ ERROR expected one of `extern`, `fn`, `type`, or `unsafe`, found `Item`\n+    Item = T; //~ ERROR expected one of `const`, `extern`, `fn`, `type`, or `unsafe`, found `Item`\n }"}, {"sha": "d06fd2bb4e704846f4344df39a6b61c40439774f", "filename": "src/test/parse-fail/paren-after-qualified-path-in-match.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Fparse-fail%2Fparen-after-qualified-path-in-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Fparse-fail%2Fparen-after-qualified-path-in-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fparen-after-qualified-path-in-match.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn foo() {\n+    match x {\n+        <T as Trait>::Type(2) => (),\n+        //~^ ERROR unexpected `(` after qualified path\n+        _ => (),\n+    }\n+}"}, {"sha": "7b6caad86b6ccc0b6005dc41c869648a065650ec", "filename": "src/test/parse-fail/removed-syntax-static-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Fparse-fail%2Fremoved-syntax-static-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Fparse-fail%2Fremoved-syntax-static-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fremoved-syntax-static-fn.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -14,5 +14,5 @@ struct S;\n \n impl S {\n     static fn f() {}\n-    //~^ ERROR expected one of `extern`, `fn`, `pub`, `type`, `unsafe`, or `}`, found `static`\n }\n+//~^^ ERROR expected one of `const`, `extern`, `fn`, `pub`, `type`, `unsafe`, or `}`, found `static`"}, {"sha": "adce0d7bbf4b62cee86f61ce85758ea11d468aa0", "filename": "src/test/parse-fail/trait-pub-assoc-const.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Fparse-fail%2Ftrait-pub-assoc-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Fparse-fail%2Ftrait-pub-assoc-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Ftrait-pub-assoc-const.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Foo {\n+    pub const Foo: u32;\n+     //~^ ERROR expected one of `const`, `extern`, `fn`, `type`, or `unsafe`, found `pub`\n+}\n+\n+fn main() {}"}, {"sha": "dab6c433aba4c187fac25a0323d0438332d4af96", "filename": "src/test/parse-fail/trait-pub-assoc-ty.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Fparse-fail%2Ftrait-pub-assoc-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Fparse-fail%2Ftrait-pub-assoc-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Ftrait-pub-assoc-ty.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -9,7 +9,8 @@\n // except according to those terms.\n \n trait Foo {\n-    pub type Foo; //~ ERROR expected one of `extern`, `fn`, `type`, or `unsafe`, found `pub`\n+    pub type Foo;\n+    //~^ ERROR expected one of `const`, `extern`, `fn`, `type`, or `unsafe`, found `pub`\n }\n \n fn main() {}"}, {"sha": "7cb9363830c43ab28b3d9f3089ba3b86d583d0b4", "filename": "src/test/parse-fail/trait-pub-method.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Fparse-fail%2Ftrait-pub-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Fparse-fail%2Ftrait-pub-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Ftrait-pub-method.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -9,7 +9,8 @@\n // except according to those terms.\n \n trait Foo {\n-    pub fn foo(); //~ ERROR expected one of `extern`, `fn`, `type`, or `unsafe`, found `pub`\n+    pub fn foo();\n+    //~^ ERROR expected one of `const`, `extern`, `fn`, `type`, or `unsafe`, found `pub`\n }\n \n fn main() {}"}, {"sha": "92d2aae61c8e526d440b091be762cd2e8ccecc1d", "filename": "src/test/run-pass/associated-const-cross-crate-defaults.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Frun-pass%2Fassociated-const-cross-crate-defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Frun-pass%2Fassociated-const-cross-crate-defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-const-cross-crate-defaults.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:associated-const-cc-lib.rs\n+\n+#![feature(associated_consts)]\n+\n+extern crate associated_const_cc_lib as foolib;\n+\n+pub struct LocalFooUseDefault;\n+\n+impl foolib::FooDefault for LocalFooUseDefault {}\n+\n+pub struct LocalFooOverwriteDefault;\n+\n+impl foolib::FooDefault for LocalFooOverwriteDefault {\n+    const BAR: usize = 4;\n+}\n+\n+fn main() {\n+    assert_eq!(1, <foolib::FooUseDefault as foolib::FooDefault>::BAR);\n+    assert_eq!(2, <foolib::FooOverwriteDefault as foolib::FooDefault>::BAR);\n+    assert_eq!(1, <LocalFooUseDefault as foolib::FooDefault>::BAR);\n+    assert_eq!(4, <LocalFooOverwriteDefault as foolib::FooDefault>::BAR);\n+}"}, {"sha": "73d5dc5df96f6949b60ba63064eb2fd5875f6091", "filename": "src/test/run-pass/associated-const-cross-crate.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Frun-pass%2Fassociated-const-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Frun-pass%2Fassociated-const-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-const-cross-crate.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:associated-const-cc-lib.rs\n+\n+#![feature(associated_consts)]\n+\n+extern crate associated_const_cc_lib as foolib;\n+\n+pub struct LocalFoo;\n+\n+impl foolib::Foo for LocalFoo {\n+    const BAR: usize = 1;\n+}\n+\n+fn main() {\n+    assert_eq!(0, <foolib::FooNoDefault as foolib::Foo>::BAR);\n+    assert_eq!(1, <LocalFoo as foolib::Foo>::BAR);\n+    assert_eq!(3, foolib::InherentBar::BAR);\n+}"}, {"sha": "e3a1e29d20f54387a7a83e8318264b430faf09cd", "filename": "src/test/run-pass/associated-const-in-global-const.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Frun-pass%2Fassociated-const-in-global-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Frun-pass%2Fassociated-const-in-global-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-const-in-global-const.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_consts)]\n+\n+struct Foo;\n+\n+impl Foo {\n+    const BAR: f32 = 1.5;\n+}\n+\n+const FOOBAR: f32 = <Foo>::BAR;\n+\n+fn main() {\n+    assert_eq!(1.5f32, FOOBAR);\n+}"}, {"sha": "5c9abf982b158253145f73a729a5404e1b07ba1e", "filename": "src/test/run-pass/associated-const-inherent-impl.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Frun-pass%2Fassociated-const-inherent-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Frun-pass%2Fassociated-const-inherent-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-const-inherent-impl.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_consts)]\n+\n+struct Foo;\n+\n+impl Foo {\n+    const ID: i32 = 1;\n+}\n+\n+fn main() {\n+    assert_eq!(1, Foo::ID);\n+}"}, {"sha": "ea91a95312983a17cbe62723e1704d4b1e27ec1f", "filename": "src/test/run-pass/associated-const-marks-live-code.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Frun-pass%2Fassociated-const-marks-live-code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Frun-pass%2Fassociated-const-marks-live-code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-const-marks-live-code.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_consts)]\n+\n+#![deny(dead_code)]\n+\n+const GLOBAL_BAR: u32 = 1;\n+\n+struct Foo;\n+\n+impl Foo {\n+    const BAR: u32 = GLOBAL_BAR;\n+}\n+\n+pub fn main() {\n+    let _: u32 = Foo::BAR;\n+}"}, {"sha": "eeaacbf9dcc788be5daf25e1ace2968314894e3e", "filename": "src/test/run-pass/associated-const-match-patterns.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Frun-pass%2Fassociated-const-match-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Frun-pass%2Fassociated-const-match-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-const-match-patterns.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_consts)]\n+\n+struct Foo;\n+\n+enum Bar {\n+    Var1,\n+    Var2,\n+}\n+\n+// Use inherent and trait impls to test UFCS syntax.\n+impl Foo {\n+    const MYBAR: Bar = Bar::Var2;\n+}\n+\n+trait HasBar {\n+    const THEBAR: Bar;\n+}\n+\n+impl HasBar for Foo {\n+    const THEBAR: Bar = Bar::Var1;\n+}\n+\n+fn main() {\n+    // Inherent impl\n+    assert!(match Bar::Var2 {\n+        Foo::MYBAR => true,\n+        _ => false,\n+    });\n+    assert!(match Bar::Var2 {\n+        <Foo>::MYBAR => true,\n+        _ => false,\n+    });\n+    // Trait impl\n+    assert!(match Bar::Var1 {\n+        <Foo>::THEBAR => true,\n+        _ => false,\n+    });\n+    assert!(match Bar::Var1 {\n+        <Foo as HasBar>::THEBAR => true,\n+        _ => false,\n+    });\n+}"}, {"sha": "0846ad9a571b34a9106ef35261ba2c0bb6a31cb0", "filename": "src/test/run-pass/associated-const-overwrite-default.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Frun-pass%2Fassociated-const-overwrite-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Frun-pass%2Fassociated-const-overwrite-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-const-overwrite-default.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_consts)]\n+\n+trait Foo {\n+    const ID: i32 = 2;\n+}\n+\n+impl Foo for i32 {\n+    const ID: i32 = 1;\n+}\n+\n+fn main() {\n+    assert_eq!(1, <i32 as Foo>::ID);\n+}"}, {"sha": "b1d071799e1a8b3e5db41598a34e2336ddce1efb", "filename": "src/test/run-pass/associated-const-public-impl.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Frun-pass%2Fassociated-const-public-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Frun-pass%2Fassociated-const-public-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-const-public-impl.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_consts)]\n+\n+mod bar1 {\n+    pub use self::bar2::Foo;\n+    mod bar2 {\n+        pub struct Foo;\n+\n+        impl Foo {\n+            pub const ID: i32 = 1;\n+        }\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(1, bar1::Foo::ID);\n+}"}, {"sha": "98b7164ab74ad142846e20d56c42f71eb2a293bf", "filename": "src/test/run-pass/associated-const-resolution-order.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Frun-pass%2Fassociated-const-resolution-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Frun-pass%2Fassociated-const-resolution-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-const-resolution-order.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_consts)]\n+\n+struct MyType;\n+\n+impl MyType {\n+    const IMPL_IS_INHERENT: bool = true;\n+}\n+\n+trait MyTrait {\n+    const IMPL_IS_INHERENT: bool;\n+    const IMPL_IS_ON_TRAIT: bool;\n+}\n+\n+impl MyTrait for MyType {\n+    const IMPL_IS_INHERENT: bool = false;\n+    const IMPL_IS_ON_TRAIT: bool = true;\n+}\n+\n+fn main() {\n+    // Check that the inherent impl is used before the trait, but that the trait\n+    // can still be accessed.\n+    assert!(<MyType>::IMPL_IS_INHERENT);\n+    assert!(!<MyType as MyTrait>::IMPL_IS_INHERENT);\n+    assert!(<MyType>::IMPL_IS_ON_TRAIT);\n+}"}, {"sha": "d3add976b5af871202d780e29b1f78f45aecb35d", "filename": "src/test/run-pass/associated-const-self-type.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Frun-pass%2Fassociated-const-self-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Frun-pass%2Fassociated-const-self-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-const-self-type.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_consts)]\n+\n+trait MyInt {\n+    const ONE: Self;\n+}\n+\n+impl MyInt for i32 {\n+    const ONE: i32 = 1;\n+}\n+\n+fn main() {\n+    assert_eq!(1, <i32>::ONE);\n+}"}, {"sha": "aa3e14a939784cee9620f6f20dd19937a6c76a30", "filename": "src/test/run-pass/associated-const-ufcs-infer-trait.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Frun-pass%2Fassociated-const-ufcs-infer-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Frun-pass%2Fassociated-const-ufcs-infer-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-const-ufcs-infer-trait.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_consts)]\n+\n+trait Foo {\n+    const ID: i32;\n+}\n+\n+impl Foo for i32 {\n+    const ID: i32 = 1;\n+}\n+\n+fn main() {\n+    assert_eq!(1, <i32>::ID);\n+}"}, {"sha": "5813d86742532b7943148f4a0a5d9fdb26ab5db7", "filename": "src/test/run-pass/associated-const-use-default.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Frun-pass%2Fassociated-const-use-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Frun-pass%2Fassociated-const-use-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-const-use-default.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_consts)]\n+\n+trait Foo {\n+    const ID: i32 = 1;\n+}\n+\n+impl Foo for i32 {}\n+\n+fn main() {\n+    assert_eq!(1, <i32 as Foo>::ID);\n+}"}, {"sha": "62658470baa525631c3429f8b703a5b2d85b1492", "filename": "src/test/run-pass/associated-const-use-impl-of-same-trait.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Frun-pass%2Fassociated-const-use-impl-of-same-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Frun-pass%2Fassociated-const-use-impl-of-same-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-const-use-impl-of-same-trait.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_consts)]\n+\n+// The main purpose of this test is to ensure that different impls of the same\n+// trait can refer to each other without setting off the static recursion check\n+// (as long as there's no actual recursion).\n+\n+trait Foo {\n+    const BAR: u32;\n+}\n+\n+struct IsFoo1;\n+\n+impl Foo for IsFoo1 {\n+    const BAR: u32 = 1;\n+}\n+\n+struct IsFoo2;\n+\n+impl Foo for IsFoo2 {\n+    const BAR: u32 = <IsFoo1 as Foo>::BAR;\n+}\n+\n+fn main() {\n+    assert_eq!(<IsFoo1>::BAR, <IsFoo2 as Foo>::BAR);\n+}"}, {"sha": "d9065445009312697a80bb44e877efe45d726d21", "filename": "src/test/run-pass/associated-const.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Frun-pass%2Fassociated-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651/src%2Ftest%2Frun-pass%2Fassociated-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-const.rs?ref=857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_consts)]\n+\n+trait Foo {\n+    const ID: i32;\n+}\n+\n+impl Foo for i32 {\n+    const ID: i32 = 1;\n+}\n+\n+fn main() {\n+    assert_eq!(1, <i32 as Foo>::ID);\n+}"}]}