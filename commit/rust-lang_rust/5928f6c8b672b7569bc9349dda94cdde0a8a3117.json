{"sha": "5928f6c8b672b7569bc9349dda94cdde0a8a3117", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5MjhmNmM4YjY3MmI3NTY5YmM5MzQ5ZGRhOTRjZGRlMGE4YTMxMTc=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-10-13T20:03:42Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-11-21T21:18:04Z"}, "message": "Fix various deprecation warnings from char changes", "tree": {"sha": "e9c3e642774625f1cba67613a4ce438b3f66421a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9c3e642774625f1cba67613a4ce438b3f66421a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5928f6c8b672b7569bc9349dda94cdde0a8a3117", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5928f6c8b672b7569bc9349dda94cdde0a8a3117", "html_url": "https://github.com/rust-lang/rust/commit/5928f6c8b672b7569bc9349dda94cdde0a8a3117", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5928f6c8b672b7569bc9349dda94cdde0a8a3117/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b577e4c8d8abfccb82269855701e1e8f10dff9ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/b577e4c8d8abfccb82269855701e1e8f10dff9ff", "html_url": "https://github.com/rust-lang/rust/commit/b577e4c8d8abfccb82269855701e1e8f10dff9ff"}], "stats": {"total": 140, "additions": 75, "deletions": 65}, "files": [{"sha": "36cd394ed15e423d928f01110f929585b2884237", "filename": "src/libcore/char.rs", "status": "modified", "additions": 66, "deletions": 56, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/5928f6c8b672b7569bc9349dda94cdde0a8a3117/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5928f6c8b672b7569bc9349dda94cdde0a8a3117/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=5928f6c8b672b7569bc9349dda94cdde0a8a3117", "patch": "@@ -100,10 +100,7 @@ pub fn from_u32(i: u32) -> Option<char> {\n #[inline]\n #[deprecated = \"use the Char::is_digit method\"]\n pub fn is_digit_radix(c: char, radix: uint) -> bool {\n-    match to_digit(c, radix) {\n-        Some(_) => true,\n-        None    => false,\n-    }\n+    c.is_digit(radix)\n }\n \n ///\n@@ -123,17 +120,7 @@ pub fn is_digit_radix(c: char, radix: uint) -> bool {\n #[inline]\n #[deprecated = \"use the Char::to_digit method\"]\n pub fn to_digit(c: char, radix: uint) -> Option<uint> {\n-    if radix > 36 {\n-        panic!(\"to_digit: radix is too high (maximum 36)\");\n-    }\n-    let val = match c {\n-      '0' ... '9' => c as uint - ('0' as uint),\n-      'a' ... 'z' => c as uint + 10u - ('a' as uint),\n-      'A' ... 'Z' => c as uint + 10u - ('A' as uint),\n-      _ => return None,\n-    };\n-    if val < radix { Some(val) }\n-    else { None }\n+    c.to_digit(radix)\n }\n \n ///\n@@ -178,23 +165,7 @@ pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n ///\n #[deprecated = \"use the Char::escape_unicode method\"]\n pub fn escape_unicode(c: char, f: |char|) {\n-    // avoid calling str::to_str_radix because we don't really need to allocate\n-    // here.\n-    f('\\\\');\n-    let pad = match () {\n-        _ if c <= '\\x7f'    => { f('x'); 2 }\n-        _ if c <= '\\uffff'  => { f('u'); 4 }\n-        _                   => { f('U'); 8 }\n-    };\n-    for offset in range_step::<i32>(4 * (pad - 1), -1, -4) {\n-        let offset = offset as uint;\n-        unsafe {\n-            match ((c as i32) >> offset) & 0xf {\n-                i @ 0 ... 9 => { f(transmute('0' as i32 + i)); }\n-                i => { f(transmute('a' as i32 + (i - 10))); }\n-            }\n-        }\n-    }\n+    c.escape_unicode(f)\n }\n \n ///\n@@ -211,29 +182,14 @@ pub fn escape_unicode(c: char, f: |char|) {\n ///\n #[deprecated = \"use the Char::escape_default method\"]\n pub fn escape_default(c: char, f: |char|) {\n-    match c {\n-        '\\t' => { f('\\\\'); f('t'); }\n-        '\\r' => { f('\\\\'); f('r'); }\n-        '\\n' => { f('\\\\'); f('n'); }\n-        '\\\\' => { f('\\\\'); f('\\\\'); }\n-        '\\'' => { f('\\\\'); f('\\''); }\n-        '\"'  => { f('\\\\'); f('\"'); }\n-        '\\x20' ... '\\x7e' => { f(c); }\n-        _ => c.escape_unicode(f),\n-    }\n+    c.escape_default(f)\n }\n \n /// Returns the amount of bytes this `char` would need if encoded in UTF-8\n #[inline]\n #[deprecated = \"use the Char::len_utf8 method\"]\n pub fn len_utf8_bytes(c: char) -> uint {\n-    let code = c as u32;\n-    match () {\n-        _ if code < MAX_ONE_B   => 1u,\n-        _ if code < MAX_TWO_B   => 2u,\n-        _ if code < MAX_THREE_B => 3u,\n-        _  => 4u,\n-    }\n+    c.len_utf8()\n }\n \n /// Basic `char` manipulations.\n@@ -362,13 +318,30 @@ pub trait Char {\n #[experimental = \"trait is experimental\"]\n impl Char for char {\n     #[deprecated = \"use is_digit\"]\n-    fn is_digit_radix(&self, radix: uint) -> bool { is_digit_radix(*self, radix) }\n+    fn is_digit_radix(&self, radix: uint) -> bool { self.is_digit(radix) }\n \n     #[unstable = \"pending trait organization\"]\n-    fn is_digit(&self, radix: uint) -> bool { is_digit_radix(*self, radix) }\n+    fn is_digit(&self, radix: uint) -> bool {\n+        match self.to_digit(radix) {\n+            Some(_) => true,\n+            None    => false,\n+        }\n+    }\n \n     #[unstable = \"pending trait organization\"]\n-    fn to_digit(&self, radix: uint) -> Option<uint> { to_digit(*self, radix) }\n+    fn to_digit(&self, radix: uint) -> Option<uint> {\n+        if radix > 36 {\n+            panic!(\"to_digit: radix is too high (maximum 36)\");\n+        }\n+        let val = match *self {\n+          '0' ... '9' => *self as uint - ('0' as uint),\n+          'a' ... 'z' => *self as uint + 10u - ('a' as uint),\n+          'A' ... 'Z' => *self as uint + 10u - ('A' as uint),\n+          _ => return None,\n+        };\n+        if val < radix { Some(val) }\n+        else { None }\n+    }\n \n     #[deprecated = \"use the char::from_digit free function\"]\n     fn from_digit(num: uint, radix: uint) -> Option<char> { from_digit(num, radix) }\n@@ -378,18 +351,55 @@ impl Char for char {\n     fn from_u32(i: u32) -> Option<char> { from_u32(i) }\n \n     #[unstable = \"pending error conventions, trait organization\"]\n-    fn escape_unicode(&self, f: |char|) { escape_unicode(*self, f) }\n+    fn escape_unicode(&self, f: |char|) {\n+        // avoid calling str::to_str_radix because we don't really need to allocate\n+        // here.\n+        f('\\\\');\n+        let pad = match () {\n+            _ if *self <= '\\xff'    => { f('x'); 2 }\n+            _ if *self <= '\\uffff'  => { f('u'); 4 }\n+            _                   => { f('U'); 8 }\n+        };\n+        for offset in range_step::<i32>(4 * (pad - 1), -1, -4) {\n+            let offset = offset as uint;\n+            unsafe {\n+                match ((*self as i32) >> offset) & 0xf {\n+                    i @ 0 ... 9 => { f(transmute('0' as i32 + i)); }\n+                    i => { f(transmute('a' as i32 + (i - 10))); }\n+                }\n+            }\n+        }\n+    }\n \n     #[unstable = \"pending error conventions, trait organization\"]\n-    fn escape_default(&self, f: |char|) { escape_default(*self, f) }\n+    fn escape_default(&self, f: |char|) {\n+        match *self {\n+            '\\t' => { f('\\\\'); f('t'); }\n+            '\\r' => { f('\\\\'); f('r'); }\n+            '\\n' => { f('\\\\'); f('n'); }\n+            '\\\\' => { f('\\\\'); f('\\\\'); }\n+            '\\'' => { f('\\\\'); f('\\''); }\n+            '\"'  => { f('\\\\'); f('\"'); }\n+            '\\x20' ... '\\x7e' => { f(*self); }\n+            _ => self.escape_unicode(f),\n+        }\n+    }\n \n     #[inline]\n     #[deprecated = \"use len_utf8\"]\n-    fn len_utf8_bytes(&self) -> uint { len_utf8_bytes(*self) }\n+    fn len_utf8_bytes(&self) -> uint { self.len_utf8() }\n \n     #[inline]\n     #[unstable = \"pending trait organization\"]\n-    fn len_utf8(&self) -> uint { len_utf8_bytes(*self) }\n+    fn len_utf8(&self) -> uint {\n+        let code = *self as u32;\n+        match () {\n+            _ if code < MAX_ONE_B   => 1u,\n+            _ if code < MAX_TWO_B   => 2u,\n+            _ if code < MAX_THREE_B => 3u,\n+            _  => 4u,\n+        }\n+    }\n \n     #[inline]\n     #[unstable = \"pending trait organization\"]"}, {"sha": "1760c4d8e6616953953754f0f9572cce830ba2af", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5928f6c8b672b7569bc9349dda94cdde0a8a3117/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5928f6c8b672b7569bc9349dda94cdde0a8a3117/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=5928f6c8b672b7569bc9349dda94cdde0a8a3117", "patch": "@@ -15,6 +15,7 @@ pub use self::SignificantDigits::*;\n pub use self::SignFormat::*;\n \n use char;\n+use char::Char;\n use fmt;\n use iter::{range, DoubleEndedIterator};\n use num::{Float, FPNaN, FPInfinite, ToPrimitive};\n@@ -222,7 +223,7 @@ pub fn float_to_str_bytes_common<T: Float, U>(\n         // round the remaining ones.\n         if limit_digits && dig == digit_count {\n             let ascii2value = |chr: u8| {\n-                char::to_digit(chr as char, radix).unwrap()\n+                (chr as char).to_digit(radix).unwrap()\n             };\n             let value2ascii = |val: uint| {\n                 char::from_digit(val, radix).unwrap() as u8"}, {"sha": "134819ad0275709535e6fb62484c6d4b0fa9a2d7", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5928f6c8b672b7569bc9349dda94cdde0a8a3117/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5928f6c8b672b7569bc9349dda94cdde0a8a3117/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=5928f6c8b672b7569bc9349dda94cdde0a8a3117", "patch": "@@ -411,7 +411,7 @@ impl<'a> Parser<'a> {\n         loop {\n             match self.cur.clone().next() {\n                 Some((_, c)) => {\n-                    match char::to_digit(c, 10) {\n+                    match c.to_digit(10) {\n                         Some(i) => {\n                             cur = cur * 10 + i;\n                             found = true;"}, {"sha": "649298d9c0818dc294412e92e8bc787cf40a9773", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5928f6c8b672b7569bc9349dda94cdde0a8a3117/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5928f6c8b672b7569bc9349dda94cdde0a8a3117/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=5928f6c8b672b7569bc9349dda94cdde0a8a3117", "patch": "@@ -17,6 +17,7 @@ pub use self::SignificantDigits::*;\n pub use self::SignFormat::*;\n \n use char;\n+use char::Char;\n use num;\n use num::{Int, Float, FPNaN, FPInfinite, ToPrimitive};\n use slice::{SlicePrelude, CloneSliceAllocPrelude};\n@@ -320,7 +321,7 @@ pub fn float_to_str_bytes_common<T: Float>(\n         // round the remaining ones.\n         if limit_digits && dig == digit_count {\n             let ascii2value = |chr: u8| {\n-                char::to_digit(chr as char, radix).unwrap()\n+                (chr as char).to_digit(radix).unwrap()\n             };\n             let value2ascii = |val: uint| {\n                 char::from_digit(val, radix).unwrap() as u8"}, {"sha": "e19e38e297701e7626799f39af1361b453d55252", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5928f6c8b672b7569bc9349dda94cdde0a8a3117/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5928f6c8b672b7569bc9349dda94cdde0a8a3117/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=5928f6c8b672b7569bc9349dda94cdde0a8a3117", "patch": "@@ -645,7 +645,7 @@ impl<'a> StringReader<'a> {\n         loop {\n             let c = self.curr;\n             if c == Some('_') { debug!(\"skipping a _\"); self.bump(); continue; }\n-            match c.and_then(|cc| char::to_digit(cc, radix)) {\n+            match c.and_then(|cc| cc.to_digit(radix)) {\n                 Some(_) => {\n                     debug!(\"{} in scan_digits\", c);\n                     len += 1;\n@@ -677,7 +677,7 @@ impl<'a> StringReader<'a> {\n                     return token::Integer(self.name_from(start_bpos));\n                 }\n             }\n-        } else if c.is_digit_radix(10) {\n+        } else if c.is_digit(10) {\n             num_digits = self.scan_digits(10) + 1;\n         } else {\n             num_digits = 0;\n@@ -696,7 +696,7 @@ impl<'a> StringReader<'a> {\n             // might have stuff after the ., and if it does, it needs to start\n             // with a number\n             self.bump();\n-            if self.curr.unwrap_or('\\0').is_digit_radix(10) {\n+            if self.curr.unwrap_or('\\0').is_digit(10) {\n                 self.scan_digits(10);\n                 self.scan_float_exponent();\n             }"}, {"sha": "cfab6494900765d30f78440dd0c22900ccc3659a", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5928f6c8b672b7569bc9349dda94cdde0a8a3117/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5928f6c8b672b7569bc9349dda94cdde0a8a3117/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=5928f6c8b672b7569bc9349dda94cdde0a8a3117", "patch": "@@ -14,8 +14,6 @@ pub use self::Param::*;\n use self::States::*;\n use self::FormatState::*;\n use self::FormatOp::*;\n-\n-use std::char;\n use std::mem::replace;\n \n #[deriving(PartialEq)]\n@@ -298,7 +296,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n             },\n             PushParam => {\n                 // params are 1-indexed\n-                stack.push(mparams[match char::to_digit(cur, 10) {\n+                stack.push(mparams[match cur.to_digit(10) {\n                     Some(d) => d - 1,\n                     None => return Err(\"bad param number\".to_string())\n                 }].clone());"}]}