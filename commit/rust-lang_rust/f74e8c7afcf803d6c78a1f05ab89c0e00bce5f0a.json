{"sha": "f74e8c7afcf803d6c78a1f05ab89c0e00bce5f0a", "node_id": "C_kwDOAAsO6NoAKGY3NGU4YzdhZmNmODAzZDZjNzhhMWYwNWFiODljMGUwMGJjZTVmMGE", "commit": {"author": {"name": "Gary Guo", "email": "gary@garyguo.net", "date": "2022-01-14T23:54:26Z"}, "committer": {"name": "Gary Guo", "email": "gary@garyguo.net", "date": "2022-02-13T03:10:09Z"}, "message": "Guard against unwinding in cleanup code", "tree": {"sha": "380d2e6d5df5a0d1fc181ce9f9041261b2748ba9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/380d2e6d5df5a0d1fc181ce9f9041261b2748ba9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f74e8c7afcf803d6c78a1f05ab89c0e00bce5f0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f74e8c7afcf803d6c78a1f05ab89c0e00bce5f0a", "html_url": "https://github.com/rust-lang/rust/commit/f74e8c7afcf803d6c78a1f05ab89c0e00bce5f0a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f74e8c7afcf803d6c78a1f05ab89c0e00bce5f0a/comments", "author": {"login": "nbdd0121", "id": 4065244, "node_id": "MDQ6VXNlcjQwNjUyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4065244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nbdd0121", "html_url": "https://github.com/nbdd0121", "followers_url": "https://api.github.com/users/nbdd0121/followers", "following_url": "https://api.github.com/users/nbdd0121/following{/other_user}", "gists_url": "https://api.github.com/users/nbdd0121/gists{/gist_id}", "starred_url": "https://api.github.com/users/nbdd0121/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nbdd0121/subscriptions", "organizations_url": "https://api.github.com/users/nbdd0121/orgs", "repos_url": "https://api.github.com/users/nbdd0121/repos", "events_url": "https://api.github.com/users/nbdd0121/events{/privacy}", "received_events_url": "https://api.github.com/users/nbdd0121/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nbdd0121", "id": 4065244, "node_id": "MDQ6VXNlcjQwNjUyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4065244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nbdd0121", "html_url": "https://github.com/nbdd0121", "followers_url": "https://api.github.com/users/nbdd0121/followers", "following_url": "https://api.github.com/users/nbdd0121/following{/other_user}", "gists_url": "https://api.github.com/users/nbdd0121/gists{/gist_id}", "starred_url": "https://api.github.com/users/nbdd0121/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nbdd0121/subscriptions", "organizations_url": "https://api.github.com/users/nbdd0121/orgs", "repos_url": "https://api.github.com/users/nbdd0121/repos", "events_url": "https://api.github.com/users/nbdd0121/events{/privacy}", "received_events_url": "https://api.github.com/users/nbdd0121/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3cfa4def7c87d571bd46d92fed608edf8fad236e", "url": "https://api.github.com/repos/rust-lang/rust/commits/3cfa4def7c87d571bd46d92fed608edf8fad236e", "html_url": "https://github.com/rust-lang/rust/commit/3cfa4def7c87d571bd46d92fed608edf8fad236e"}], "stats": {"total": 74, "additions": 59, "deletions": 15}, "files": [{"sha": "5cbbb34d2e62546b8814a89ae2c1ebad75134b53", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 54, "deletions": 13, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/f74e8c7afcf803d6c78a1f05ab89c0e00bce5f0a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74e8c7afcf803d6c78a1f05ab89c0e00bce5f0a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=f74e8c7afcf803d6c78a1f05ab89c0e00bce5f0a", "patch": "@@ -135,21 +135,38 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n         // If there is a cleanup block and the function we're calling can unwind, then\n         // do an invoke, otherwise do a call.\n         let fn_ty = bx.fn_decl_backend_type(&fn_abi);\n-        if let Some(cleanup) = cleanup.filter(|_| fn_abi.can_unwind) {\n+\n+        let unwind_block = if let Some(cleanup) = cleanup.filter(|_| fn_abi.can_unwind) {\n+            Some(self.llblock(fx, cleanup))\n+        } else if fx.mir[self.bb].is_cleanup\n+            && fn_abi.can_unwind\n+            && !base::wants_msvc_seh(fx.cx.tcx().sess)\n+        {\n+            // Exception must not propagate out of the execution of a cleanup (doing so\n+            // can cause undefined behaviour). We insert a double unwind guard for\n+            // functions that can potentially unwind to protect against this.\n+            //\n+            // This is not necessary for SEH which does not use successive unwinding\n+            // like Itanium EH. EH frames in SEH are different from normal function\n+            // frames and SEH will abort automatically if an exception tries to\n+            // propagate out from cleanup.\n+            Some(fx.double_unwind_guard())\n+        } else {\n+            None\n+        };\n+\n+        if let Some(unwind_block) = unwind_block {\n             let ret_llbb = if let Some((_, target)) = destination {\n                 fx.llbb(target)\n             } else {\n                 fx.unreachable_block()\n             };\n-            let invokeret = bx.invoke(\n-                fn_ty,\n-                fn_ptr,\n-                &llargs,\n-                ret_llbb,\n-                self.llblock(fx, cleanup),\n-                self.funclet(fx),\n-            );\n+            let invokeret =\n+                bx.invoke(fn_ty, fn_ptr, &llargs, ret_llbb, unwind_block, self.funclet(fx));\n             bx.apply_attrs_callsite(&fn_abi, invokeret);\n+            if fx.mir[self.bb].is_cleanup {\n+                bx.apply_attrs_to_cleanup_callsite(invokeret);\n+            }\n \n             if let Some((ret_dest, target)) = destination {\n                 let mut ret_bx = fx.build_block(target);\n@@ -486,17 +503,14 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let span = terminator.source_info.span;\n         self.set_debug_loc(&mut bx, terminator.source_info);\n \n-        // Get the location information.\n-        let location = self.get_caller_location(&mut bx, terminator.source_info).immediate();\n-\n         // Obtain the panic entry point.\n         let def_id = common::langcall(bx.tcx(), Some(span), \"\", LangItem::PanicNoUnwind);\n         let instance = ty::Instance::mono(bx.tcx(), def_id);\n         let fn_abi = bx.fn_abi_of_instance(instance, ty::List::empty());\n         let llfn = bx.get_fn_addr(instance);\n \n         // Codegen the actual panic invoke/call.\n-        helper.do_call(self, &mut bx, fn_abi, llfn, &[location], None, None);\n+        helper.do_call(self, &mut bx, fn_abi, llfn, &[], None, None);\n     }\n \n     /// Returns `true` if this is indeed a panic intrinsic and codegen is done.\n@@ -1398,6 +1412,33 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         })\n     }\n \n+    fn double_unwind_guard(&mut self) -> Bx::BasicBlock {\n+        self.double_unwind_guard.unwrap_or_else(|| {\n+            assert!(!base::wants_msvc_seh(self.cx.sess()));\n+\n+            let mut bx = self.new_block(\"abort\");\n+            let llpersonality = self.cx.eh_personality();\n+            let llretty = self.landing_pad_type();\n+            bx.cleanup_landing_pad(llretty, llpersonality);\n+\n+            let def_id = common::langcall(bx.tcx(), None, \"\", LangItem::PanicNoUnwind);\n+            let instance = ty::Instance::mono(bx.tcx(), def_id);\n+            let fn_abi = bx.fn_abi_of_instance(instance, ty::List::empty());\n+            let fn_ptr = bx.get_fn_addr(instance);\n+            let fn_ty = bx.fn_decl_backend_type(&fn_abi);\n+\n+            let llret = bx.call(fn_ty, fn_ptr, &[], None);\n+            bx.apply_attrs_callsite(&fn_abi, llret);\n+            bx.apply_attrs_to_cleanup_callsite(llret);\n+\n+            bx.unreachable();\n+            let llbb = bx.llbb();\n+\n+            self.double_unwind_guard = Some(llbb);\n+            llbb\n+        })\n+    }\n+\n     // FIXME(eddyb) replace with `build_sibling_block`/`append_sibling_block`\n     // (which requires having a `Bx` already, and not all callers do).\n     fn new_block(&self, name: &str) -> Bx {"}, {"sha": "4f05d02526e550582b6eebdfed62719349f9b3b4", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f74e8c7afcf803d6c78a1f05ab89c0e00bce5f0a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74e8c7afcf803d6c78a1f05ab89c0e00bce5f0a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=f74e8c7afcf803d6c78a1f05ab89c0e00bce5f0a", "patch": "@@ -62,6 +62,9 @@ pub struct FunctionCx<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n     /// Cached unreachable block\n     unreachable_block: Option<Bx::BasicBlock>,\n \n+    /// Cached double unwind guarding block\n+    double_unwind_guard: Option<Bx::BasicBlock>,\n+\n     /// The location where each MIR arg/var/tmp/ret is stored. This is\n     /// usually an `PlaceRef` representing an alloca, but not always:\n     /// sometimes we can skip the alloca and just store the value\n@@ -169,6 +172,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         personality_slot: None,\n         cached_llbbs,\n         unreachable_block: None,\n+        double_unwind_guard: None,\n         cleanup_kinds,\n         landing_pads: IndexVec::from_elem(None, mir.basic_blocks()),\n         funclets: IndexVec::from_fn_n(|_| None, mir.basic_blocks().len()),"}, {"sha": "2b720fc4192a7e04ee212a1961635ebba41f79dd", "filename": "library/core/src/panicking.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f74e8c7afcf803d6c78a1f05ab89c0e00bce5f0a/library%2Fcore%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f74e8c7afcf803d6c78a1f05ab89c0e00bce5f0a/library%2Fcore%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpanicking.rs?ref=f74e8c7afcf803d6c78a1f05ab89c0e00bce5f0a", "patch": "@@ -87,8 +87,7 @@ fn panic_bounds_check(index: usize, len: usize) -> ! {\n \n #[cfg(not(bootstrap))]\n #[cold]\n-#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n-#[track_caller]\n+#[inline(never)]\n #[lang = \"panic_no_unwind\"] // needed by codegen for panic in nounwind function\n fn panic_no_unwind() -> ! {\n     if cfg!(feature = \"panic_immediate_abort\") {"}]}