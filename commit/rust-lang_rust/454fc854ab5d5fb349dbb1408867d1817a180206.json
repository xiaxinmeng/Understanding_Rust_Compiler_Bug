{"sha": "454fc854ab5d5fb349dbb1408867d1817a180206", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1NGZjODU0YWI1ZDVmYjM0OWRiYjE0MDg4NjdkMTgxN2ExODAyMDY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-07-13T00:52:57Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-07-13T00:52:57Z"}, "message": "Rename value accessors to \"into_*\" so the three of them are better aligned", "tree": {"sha": "0fa1cdf7332864448bf5c3296b73b50b97d58c94", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0fa1cdf7332864448bf5c3296b73b50b97d58c94"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/454fc854ab5d5fb349dbb1408867d1817a180206", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/454fc854ab5d5fb349dbb1408867d1817a180206", "html_url": "https://github.com/rust-lang/rust/commit/454fc854ab5d5fb349dbb1408867d1817a180206", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/454fc854ab5d5fb349dbb1408867d1817a180206/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c149c3fc6a32148ede8229c39bf23249d8174f4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c149c3fc6a32148ede8229c39bf23249d8174f4b", "html_url": "https://github.com/rust-lang/rust/commit/c149c3fc6a32148ede8229c39bf23249d8174f4b"}], "stats": {"total": 88, "additions": 45, "deletions": 43}, "files": [{"sha": "4d7caaf6ff3ccf1e92f04d5a5b3c356e6135ad42", "filename": "src/eval_context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/454fc854ab5d5fb349dbb1408867d1817a180206/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/454fc854ab5d5fb349dbb1408867d1817a180206/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=454fc854ab5d5fb349dbb1408867d1817a180206", "patch": "@@ -1460,7 +1460,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n         match (&src_pointee_ty.sty, &dest_pointee_ty.sty) {\n             (&ty::TyArray(_, length), &ty::TySlice(_)) => {\n-                let ptr = src.read_ptr(&self.memory)?;\n+                let ptr = src.into_ptr(&self.memory)?;\n                 // u64 cast is from usize to u64, which is always good\n                 self.write_value(ptr.to_value_with_len(length as u64), dest, dest_ty)\n             }\n@@ -1474,7 +1474,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let trait_ref = data.principal().unwrap().with_self_ty(self.tcx, src_pointee_ty);\n                 let trait_ref = self.tcx.erase_regions(&trait_ref);\n                 let vtable = self.get_vtable(src_pointee_ty, trait_ref)?;\n-                let ptr = src.read_ptr(&self.memory)?;\n+                let ptr = src.into_ptr(&self.memory)?;\n                 self.write_value(ptr.to_value_with_vtable(vtable), dest, dest_ty)\n             },\n "}, {"sha": "bff6f9f955ade0cffc40f49a328a2c01de162c1b", "filename": "src/lvalue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/454fc854ab5d5fb349dbb1408867d1817a180206/src%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/454fc854ab5d5fb349dbb1408867d1817a180206/src%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flvalue.rs?ref=454fc854ab5d5fb349dbb1408867d1817a180206", "patch": "@@ -391,14 +391,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                 match self.tcx.struct_tail(pointee_type).sty {\n                     ty::TyDynamic(..) => {\n-                        let (ptr, vtable) = val.expect_ptr_vtable_pair(&self.memory)?;\n+                        let (ptr, vtable) = val.into_ptr_vtable_pair(&self.memory)?;\n                         (ptr, LvalueExtra::Vtable(vtable), true)\n                     },\n                     ty::TyStr | ty::TySlice(_) => {\n-                        let (ptr, len) = val.expect_slice(&self.memory)?;\n+                        let (ptr, len) = val.into_slice(&self.memory)?;\n                         (ptr, LvalueExtra::Length(len), true)\n                     },\n-                    _ => (val.read_ptr(&self.memory)?, LvalueExtra::None, true),\n+                    _ => (val.into_ptr(&self.memory)?, LvalueExtra::None, true),\n                 }\n             }\n "}, {"sha": "7af678645550a8336ef111a4f814e7deb8b975b2", "filename": "src/terminator/intrinsic.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/454fc854ab5d5fb349dbb1408867d1817a180206/src%2Fterminator%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/454fc854ab5d5fb349dbb1408867d1817a180206/src%2Fterminator%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fintrinsic.rs?ref=454fc854ab5d5fb349dbb1408867d1817a180206", "patch": "@@ -44,7 +44,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"arith_offset\" => {\n                 let offset = self.value_to_primval(arg_vals[1], isize)?.to_i128()? as i64;\n-                let ptr = arg_vals[0].read_ptr(&self.memory)?;\n+                let ptr = arg_vals[0].into_ptr(&self.memory)?;\n                 let result_ptr = self.wrapping_pointer_offset(ptr, substs.type_at(0), offset)?;\n                 self.write_ptr(dest, result_ptr, dest_ty)?;\n             }\n@@ -60,7 +60,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"atomic_load_acq\" |\n             \"volatile_load\" => {\n                 let ty = substs.type_at(0);\n-                let ptr = arg_vals[0].read_ptr(&self.memory)?;\n+                let ptr = arg_vals[0].into_ptr(&self.memory)?;\n                 self.write_value(Value::ByRef(ptr), dest, ty)?;\n             }\n \n@@ -69,7 +69,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"atomic_store_rel\" |\n             \"volatile_store\" => {\n                 let ty = substs.type_at(0);\n-                let dest = arg_vals[0].read_ptr(&self.memory)?;\n+                let dest = arg_vals[0].into_ptr(&self.memory)?;\n                 self.write_value_to_ptr(arg_vals[1], dest, ty)?;\n             }\n \n@@ -79,7 +79,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             _ if intrinsic_name.starts_with(\"atomic_xchg\") => {\n                 let ty = substs.type_at(0);\n-                let ptr = arg_vals[0].read_ptr(&self.memory)?;\n+                let ptr = arg_vals[0].into_ptr(&self.memory)?;\n                 let change = self.value_to_primval(arg_vals[1], ty)?;\n                 let old = self.read_value(ptr, ty)?;\n                 let old = match old {\n@@ -93,7 +93,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             _ if intrinsic_name.starts_with(\"atomic_cxchg\") => {\n                 let ty = substs.type_at(0);\n-                let ptr = arg_vals[0].read_ptr(&self.memory)?;\n+                let ptr = arg_vals[0].into_ptr(&self.memory)?;\n                 let expect_old = self.value_to_primval(arg_vals[1], ty)?;\n                 let change = self.value_to_primval(arg_vals[2], ty)?;\n                 let old = self.read_value(ptr, ty)?;\n@@ -114,7 +114,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"atomic_xadd\" | \"atomic_xadd_acq\" | \"atomic_xadd_rel\" | \"atomic_xadd_acqrel\" | \"atomic_xadd_relaxed\" |\n             \"atomic_xsub\" | \"atomic_xsub_acq\" | \"atomic_xsub_rel\" | \"atomic_xsub_acqrel\" | \"atomic_xsub_relaxed\" => {\n                 let ty = substs.type_at(0);\n-                let ptr = arg_vals[0].read_ptr(&self.memory)?;\n+                let ptr = arg_vals[0].into_ptr(&self.memory)?;\n                 let change = self.value_to_primval(arg_vals[1], ty)?;\n                 let old = self.read_value(ptr, ty)?;\n                 let old = match old {\n@@ -144,8 +144,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let elem_size = self.type_size(elem_ty)?.expect(\"cannot copy unsized value\");\n                 if elem_size != 0 {\n                     let elem_align = self.type_align(elem_ty)?;\n-                    let src = arg_vals[0].read_ptr(&self.memory)?;\n-                    let dest = arg_vals[1].read_ptr(&self.memory)?;\n+                    let src = arg_vals[0].into_ptr(&self.memory)?;\n+                    let dest = arg_vals[1].into_ptr(&self.memory)?;\n                     let count = self.value_to_primval(arg_vals[2], usize)?.to_u64()?;\n                     self.memory.copy(src, dest, count * elem_size, elem_align, intrinsic_name.ends_with(\"_nonoverlapping\"))?;\n                 }\n@@ -173,7 +173,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"discriminant_value\" => {\n                 let ty = substs.type_at(0);\n-                let adt_ptr = arg_vals[0].read_ptr(&self.memory)?.to_ptr()?;\n+                let adt_ptr = arg_vals[0].into_ptr(&self.memory)?.to_ptr()?;\n                 let discr_val = self.read_discriminant_value(adt_ptr, ty)?;\n                 self.write_primval(dest, PrimVal::Bytes(discr_val), dest_ty)?;\n             }\n@@ -293,7 +293,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"move_val_init\" => {\n                 let ty = substs.type_at(0);\n-                let ptr = arg_vals[0].read_ptr(&self.memory)?;\n+                let ptr = arg_vals[0].into_ptr(&self.memory)?;\n                 self.write_value_to_ptr(arg_vals[1], ptr, ty)?;\n             }\n \n@@ -306,7 +306,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"offset\" => {\n                 let offset = self.value_to_primval(arg_vals[1], isize)?.to_i128()? as i64;\n-                let ptr = arg_vals[0].read_ptr(&self.memory)?;\n+                let ptr = arg_vals[0].into_ptr(&self.memory)?;\n                 let result_ptr = self.pointer_offset(ptr, substs.type_at(0), offset)?;\n                 self.write_ptr(dest, result_ptr, dest_ty)?;\n             }\n@@ -460,7 +460,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let ty_align = self.type_align(ty)?;\n                 let val_byte = self.value_to_primval(arg_vals[1], u8)?.to_u128()? as u8;\n                 let size = self.type_size(ty)?.expect(\"write_bytes() type must be sized\");\n-                let ptr = arg_vals[0].read_ptr(&self.memory)?;\n+                let ptr = arg_vals[0].into_ptr(&self.memory)?;\n                 let count = self.value_to_primval(arg_vals[2], usize)?.to_u64()?;\n                 if count > 0 {\n                     // TODO: Should we, at least, validate the alignment? (Also see memory::copy)\n@@ -545,15 +545,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Ok((size, align.abi()))\n                 }\n                 ty::TyDynamic(..) => {\n-                    let (_, vtable) = value.expect_ptr_vtable_pair(&self.memory)?;\n+                    let (_, vtable) = value.into_ptr_vtable_pair(&self.memory)?;\n                     // the second entry in the vtable is the dynamic size of the object.\n                     self.read_size_and_align_from_vtable(vtable)\n                 }\n \n                 ty::TySlice(_) | ty::TyStr => {\n                     let elem_ty = ty.sequence_element_type(self.tcx);\n                     let elem_size = self.type_size(elem_ty)?.expect(\"slice element must be sized\") as u64;\n-                    let (_, len) = value.expect_slice(&self.memory)?;\n+                    let (_, len) = value.into_slice(&self.memory)?;\n                     let align = self.type_align(elem_ty)?;\n                     Ok((len * elem_size, align as u64))\n                 }"}, {"sha": "9a7619576c407361a8bd0424603b708f7ceedbdb", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/454fc854ab5d5fb349dbb1408867d1817a180206/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/454fc854ab5d5fb349dbb1408867d1817a180206/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=454fc854ab5d5fb349dbb1408867d1817a180206", "patch": "@@ -393,7 +393,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             },\n             ty::InstanceDef::Virtual(_, idx) => {\n                 let ptr_size = self.memory.pointer_size();\n-                let (_, vtable) = self.eval_operand(&arg_operands[0])?.expect_ptr_vtable_pair(&self.memory)?;\n+                let (_, vtable) = self.eval_operand(&arg_operands[0])?.into_ptr_vtable_pair(&self.memory)?;\n                 let fn_ptr = self.memory.read_ptr(vtable.offset(ptr_size * (idx as u64 + 3), self.memory.layout)?)?;\n                 let instance = self.memory.get_fn(fn_ptr.to_ptr()?)?;\n                 let mut arg_operands = arg_operands.to_vec();\n@@ -572,7 +572,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n             }\n             \"alloc::heap::::__rust_dealloc\" => {\n-                let ptr = args[0].read_ptr(&self.memory)?.to_ptr()?;\n+                let ptr = args[0].into_ptr(&self.memory)?.to_ptr()?;\n                 let old_size = self.value_to_primval(args[1], usize)?.to_u64()?;\n                 let align = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 if old_size == 0 {\n@@ -584,7 +584,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.memory.deallocate(ptr, Some((old_size, align)))?;\n             }\n             \"alloc::heap::::__rust_realloc\" => {\n-                let ptr = args[0].read_ptr(&self.memory)?.to_ptr()?;\n+                let ptr = args[0].into_ptr(&self.memory)?.to_ptr()?;\n                 let old_size = self.value_to_primval(args[1], usize)?.to_u64()?;\n                 let old_align = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 let new_size = self.value_to_primval(args[3], usize)?.to_u64()?;\n@@ -660,7 +660,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"free\" => {\n-                let ptr = args[0].read_ptr(&self.memory)?;\n+                let ptr = args[0].into_ptr(&self.memory)?;\n                 if !ptr.is_null()? {\n                     self.memory.deallocate(ptr.to_ptr()?, None)?;\n                 }\n@@ -674,8 +674,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"dlsym\" => {\n-                let _handle = args[0].read_ptr(&self.memory)?;\n-                let symbol = args[1].read_ptr(&self.memory)?.to_ptr()?;\n+                let _handle = args[0].into_ptr(&self.memory)?;\n+                let symbol = args[1].into_ptr(&self.memory)?.to_ptr()?;\n                 let symbol_name = self.memory.read_c_str(symbol)?;\n                 let err = format!(\"bad c unicode symbol: {:?}\", symbol_name);\n                 let symbol_name = ::std::str::from_utf8(symbol_name).unwrap_or(&err);\n@@ -686,8 +686,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 // fn __rust_maybe_catch_panic(f: fn(*mut u8), data: *mut u8, data_ptr: *mut usize, vtable_ptr: *mut usize) -> u32\n                 // We abort on panic, so not much is going on here, but we still have to call the closure\n                 let u8_ptr_ty = self.tcx.mk_mut_ptr(self.tcx.types.u8);\n-                let f = args[0].read_ptr(&self.memory)?.to_ptr()?;\n-                let data = args[1].read_ptr(&self.memory)?;\n+                let f = args[0].into_ptr(&self.memory)?.to_ptr()?;\n+                let data = args[1].into_ptr(&self.memory)?;\n                 let f_instance = self.memory.get_fn(f)?;\n                 self.write_null(dest, dest_ty)?;\n \n@@ -718,8 +718,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"memcmp\" => {\n-                let left = args[0].read_ptr(&self.memory)?;\n-                let right = args[1].read_ptr(&self.memory)?;\n+                let left = args[0].into_ptr(&self.memory)?;\n+                let right = args[1].into_ptr(&self.memory)?;\n                 let n = self.value_to_primval(args[2], usize)?.to_u64()?;\n \n                 let result = {\n@@ -738,7 +738,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"memrchr\" => {\n-                let ptr = args[0].read_ptr(&self.memory)?;\n+                let ptr = args[0].into_ptr(&self.memory)?;\n                 let val = self.value_to_primval(args[1], usize)?.to_u64()? as u8;\n                 let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().rev().position(|&c| c == val) {\n@@ -750,7 +750,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"memchr\" => {\n-                let ptr = args[0].read_ptr(&self.memory)?;\n+                let ptr = args[0].into_ptr(&self.memory)?;\n                 let val = self.value_to_primval(args[1], usize)?.to_u64()? as u8;\n                 let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().position(|&c| c == val) {\n@@ -763,7 +763,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"getenv\" => {\n                 let result = {\n-                    let name_ptr = args[0].read_ptr(&self.memory)?.to_ptr()?;\n+                    let name_ptr = args[0].into_ptr(&self.memory)?.to_ptr()?;\n                     let name = self.memory.read_c_str(name_ptr)?;\n                     match self.env_vars.get(name) {\n                         Some(&var) => PrimVal::Ptr(var),\n@@ -776,7 +776,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"unsetenv\" => {\n                 let mut success = None;\n                 {\n-                    let name_ptr = args[0].read_ptr(&self.memory)?;\n+                    let name_ptr = args[0].into_ptr(&self.memory)?;\n                     if !name_ptr.is_null()? {\n                         let name = self.memory.read_c_str(name_ptr.to_ptr()?)?;\n                         if !name.is_empty() && !name.contains(&b'=') {\n@@ -797,8 +797,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"setenv\" => {\n                 let mut new = None;\n                 {\n-                    let name_ptr = args[0].read_ptr(&self.memory)?;\n-                    let value_ptr = args[1].read_ptr(&self.memory)?.to_ptr()?;\n+                    let name_ptr = args[0].into_ptr(&self.memory)?;\n+                    let value_ptr = args[1].into_ptr(&self.memory)?.to_ptr()?;\n                     let value = self.memory.read_c_str(value_ptr)?;\n                     if !name_ptr.is_null()? {\n                         let name = self.memory.read_c_str(name_ptr.to_ptr()?)?;\n@@ -823,7 +823,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"write\" => {\n                 let fd = self.value_to_primval(args[0], usize)?.to_u64()?;\n-                let buf = args[1].read_ptr(&self.memory)?;\n+                let buf = args[1].into_ptr(&self.memory)?;\n                 let n = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 trace!(\"Called write({:?}, {:?}, {:?})\", fd, buf, n);\n                 let result = if fd == 1 || fd == 2 { // stdout/stderr\n@@ -840,7 +840,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"strlen\" => {\n-                let ptr = args[0].read_ptr(&self.memory)?.to_ptr()?;\n+                let ptr = args[0].into_ptr(&self.memory)?.to_ptr()?;\n                 let n = self.memory.read_c_str(ptr)?.len();\n                 self.write_primval(dest, PrimVal::Bytes(n as u128), dest_ty)?;\n             }\n@@ -863,10 +863,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             // Hook pthread calls that go to the thread-local storage memory subsystem\n             \"pthread_key_create\" => {\n-                let key_ptr = args[0].read_ptr(&self.memory)?;\n+                let key_ptr = args[0].into_ptr(&self.memory)?;\n \n                 // Extract the function type out of the signature (that seems easier than constructing it ourselves...)\n-                let dtor = match args[1].read_ptr(&self.memory)?.into_inner_primval() {\n+                let dtor = match args[1].into_ptr(&self.memory)?.into_inner_primval() {\n                     PrimVal::Ptr(dtor_ptr) => Some(self.memory.get_fn(dtor_ptr)?),\n                     PrimVal::Bytes(0) => None,\n                     PrimVal::Bytes(_) => return Err(EvalError::ReadBytesAsPointer),\n@@ -908,7 +908,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"pthread_setspecific\" => {\n                 // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n                 let key = self.value_to_primval(args[0], usize)?.to_u64()? as TlsKey;\n-                let new_ptr = args[1].read_ptr(&self.memory)?;\n+                let new_ptr = args[1].into_ptr(&self.memory)?;\n                 self.memory.store_tls(key, new_ptr)?;\n                 \n                 // Return success (0)"}, {"sha": "0e544456524f74673fdfa63b79bbd5454c0abf66", "filename": "src/value.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/454fc854ab5d5fb349dbb1408867d1817a180206/src%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/454fc854ab5d5fb349dbb1408867d1817a180206/src%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue.rs?ref=454fc854ab5d5fb349dbb1408867d1817a180206", "patch": "@@ -158,15 +158,17 @@ pub enum PrimValKind {\n }\n \n impl<'a, 'tcx: 'a> Value {\n-    pub(super) fn read_ptr(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, Pointer> {\n+    /// Convert the value into a pointer (or a pointer-sized integer).  If the value is a ByRef,\n+    /// this may have to perform a load.\n+    pub(super) fn into_ptr(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, Pointer> {\n         use self::Value::*;\n         match *self {\n             ByRef(ptr) => mem.read_ptr(ptr.to_ptr()?),\n             ByVal(ptr) | ByValPair(ptr, _) => Ok(ptr.into()),\n         }\n     }\n \n-    pub(super) fn expect_ptr_vtable_pair(\n+    pub(super) fn into_ptr_vtable_pair(\n         &self,\n         mem: &Memory<'a, 'tcx>\n     ) -> EvalResult<'tcx, (Pointer, MemoryPointer)> {\n@@ -184,7 +186,7 @@ impl<'a, 'tcx: 'a> Value {\n         }\n     }\n \n-    pub(super) fn expect_slice(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, (Pointer, u64)> {\n+    pub(super) fn into_slice(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, (Pointer, u64)> {\n         use self::Value::*;\n         match *self {\n             ByRef(ref_ptr) => {"}]}