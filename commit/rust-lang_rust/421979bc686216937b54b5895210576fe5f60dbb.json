{"sha": "421979bc686216937b54b5895210576fe5f60dbb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyMTk3OWJjNjg2MjE2OTM3YjU0YjU4OTUyMTA1NzZmZTVmNjBkYmI=", "commit": {"author": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-06-15T08:53:20Z"}, "committer": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-08-04T15:05:46Z"}, "message": "HirDisplay prints `?Sized` bounds now; `impl Trait: Sized` by default.", "tree": {"sha": "227d490460f8005a518c4a9b1b91c9e446d55d81", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/227d490460f8005a518c4a9b1b91c9e446d55d81"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/421979bc686216937b54b5895210576fe5f60dbb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/421979bc686216937b54b5895210576fe5f60dbb", "html_url": "https://github.com/rust-lang/rust/commit/421979bc686216937b54b5895210576fe5f60dbb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/421979bc686216937b54b5895210576fe5f60dbb/comments", "author": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9e6377b910261f65b83a6353935459acb73462e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9e6377b910261f65b83a6353935459acb73462e", "html_url": "https://github.com/rust-lang/rust/commit/d9e6377b910261f65b83a6353935459acb73462e"}], "stats": {"total": 181, "additions": 167, "deletions": 14}, "files": [{"sha": "df9094ac82de713df0e9320d576031763d6e1690", "filename": "crates/hir/src/display.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/421979bc686216937b54b5895210576fe5f60dbb/crates%2Fhir%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/421979bc686216937b54b5895210576fe5f60dbb/crates%2Fhir%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdisplay.rs?ref=421979bc686216937b54b5895210576fe5f60dbb", "patch": "@@ -7,7 +7,7 @@ use hir_def::{\n };\n use hir_ty::display::{\n     write_bounds_like_dyn_trait_with_prefix, write_visibility, HirDisplay, HirDisplayError,\n-    HirFormatter,\n+    HirFormatter, SizedByDefault,\n };\n use hir_ty::Interner;\n use syntax::ast::{self, NameOwner};\n@@ -239,7 +239,7 @@ impl HirDisplay for TypeParam {\n         let predicates =\n             bounds.iter().cloned().map(|b| b.substitute(&Interner, &substs)).collect::<Vec<_>>();\n         if !(predicates.is_empty() || f.omit_verbose_types()) {\n-            write_bounds_like_dyn_trait_with_prefix(\":\", &predicates, f)?;\n+            write_bounds_like_dyn_trait_with_prefix(\":\", &predicates, SizedByDefault::Sized, f)?;\n         }\n         Ok(())\n     }"}, {"sha": "df7cf1c39c41a60961571bdb0767318d6cd42321", "filename": "crates/hir_ty/src/display.rs", "status": "modified", "additions": 54, "deletions": 4, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/421979bc686216937b54b5895210576fe5f60dbb/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/421979bc686216937b54b5895210576fe5f60dbb/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs?ref=421979bc686216937b54b5895210576fe5f60dbb", "patch": "@@ -582,7 +582,12 @@ impl HirDisplay for Ty {\n                             .as_ref()\n                             .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n                         let bounds = data.substitute(&Interner, &parameters);\n-                        write_bounds_like_dyn_trait_with_prefix(\"impl\", bounds.skip_binders(), f)?;\n+                        write_bounds_like_dyn_trait_with_prefix(\n+                            \"impl\",\n+                            bounds.skip_binders(),\n+                            SizedByDefault::Sized,\n+                            f,\n+                        )?;\n                         // FIXME: it would maybe be good to distinguish this from the alias type (when debug printing), and to show the substitution\n                     }\n                     ImplTraitId::AsyncBlockTypeImplTrait(..) => {\n@@ -641,7 +646,12 @@ impl HirDisplay for Ty {\n                                     _ => false,\n                                 })\n                                 .collect::<Vec<_>>();\n-                        write_bounds_like_dyn_trait_with_prefix(\"impl\", &bounds, f)?;\n+                        write_bounds_like_dyn_trait_with_prefix(\n+                            \"impl\",\n+                            &bounds,\n+                            SizedByDefault::Sized,\n+                            f,\n+                        )?;\n                     }\n                 }\n             }\n@@ -650,6 +660,7 @@ impl HirDisplay for Ty {\n                 write_bounds_like_dyn_trait_with_prefix(\n                     \"dyn\",\n                     dyn_ty.bounds.skip_binders().interned(),\n+                    SizedByDefault::NotSized,\n                     f,\n                 )?;\n             }\n@@ -664,7 +675,12 @@ impl HirDisplay for Ty {\n                             .as_ref()\n                             .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n                         let bounds = data.substitute(&Interner, &opaque_ty.substitution);\n-                        write_bounds_like_dyn_trait_with_prefix(\"impl\", bounds.skip_binders(), f)?;\n+                        write_bounds_like_dyn_trait_with_prefix(\n+                            \"impl\",\n+                            bounds.skip_binders(),\n+                            SizedByDefault::Sized,\n+                            f,\n+                        )?;\n                     }\n                     ImplTraitId::AsyncBlockTypeImplTrait(..) => {\n                         write!(f, \"{{async block}}\")?;\n@@ -713,22 +729,37 @@ fn fn_traits(db: &dyn DefDatabase, trait_: TraitId) -> impl Iterator<Item = Trai\n     utils::fn_traits(db, krate)\n }\n \n+fn is_sized_trait(db: &dyn DefDatabase, trait_: TraitId) -> Option<bool> {\n+    let krate = trait_.lookup(db).container.krate();\n+    let sized_trait =\n+        db.lang_item(krate, \"sized\".into()).and_then(|lang_item| lang_item.as_trait())?;\n+    Some(trait_ == sized_trait)\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq)]\n+pub enum SizedByDefault {\n+    NotSized,\n+    Sized,\n+}\n+\n pub fn write_bounds_like_dyn_trait_with_prefix(\n     prefix: &str,\n     predicates: &[QuantifiedWhereClause],\n+    default_sized: SizedByDefault,\n     f: &mut HirFormatter,\n ) -> Result<(), HirDisplayError> {\n     write!(f, \"{}\", prefix)?;\n     if !predicates.is_empty() {\n         write!(f, \" \")?;\n-        write_bounds_like_dyn_trait(predicates, f)\n+        write_bounds_like_dyn_trait(predicates, default_sized, f)\n     } else {\n         Ok(())\n     }\n }\n \n fn write_bounds_like_dyn_trait(\n     predicates: &[QuantifiedWhereClause],\n+    default_sized: SizedByDefault,\n     f: &mut HirFormatter,\n ) -> Result<(), HirDisplayError> {\n     // Note: This code is written to produce nice results (i.e.\n@@ -740,10 +771,22 @@ fn write_bounds_like_dyn_trait(\n     let mut first = true;\n     let mut angle_open = false;\n     let mut is_fn_trait = false;\n+    let mut is_sized = None;\n     for p in predicates.iter() {\n         match p.skip_binders() {\n             WhereClause::Implemented(trait_ref) => {\n                 let trait_ = trait_ref.hir_trait_id();\n+                match is_sized_trait(f.db.upcast(), trait_) {\n+                    Some(true) => {\n+                        is_sized = Some(true);\n+                        if default_sized == SizedByDefault::Sized {\n+                            // Don't print +Sized, but rather +?Sized if absent.\n+                            continue;\n+                        }\n+                    }\n+                    Some(false) => is_sized = is_sized.or(Some(false)),\n+                    None => (),\n+                }\n                 if !is_fn_trait {\n                     is_fn_trait = fn_traits(f.db.upcast(), trait_).any(|it| it == trait_);\n                 }\n@@ -808,6 +851,13 @@ fn write_bounds_like_dyn_trait(\n     if angle_open {\n         write!(f, \">\")?;\n     }\n+    if default_sized == SizedByDefault::Sized && is_sized.is_some() {\n+        if is_sized == Some(false) {\n+            write!(f, \"{}?Sized\", if first { \"\" } else { \" + \" })?;\n+        } else if first {\n+            write!(f, \"Sized\")?;\n+        }\n+    }\n     Ok(())\n }\n "}, {"sha": "2bcd0fcb5db79aa6d1f38df7a48cb943699b99e5", "filename": "crates/hir_ty/src/lower.rs", "status": "modified", "additions": 36, "deletions": 7, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/421979bc686216937b54b5895210576fe5f60dbb/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/421979bc686216937b54b5895210576fe5f60dbb/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=421979bc686216937b54b5895210576fe5f60dbb", "patch": "@@ -226,6 +226,10 @@ impl<'a> TyLoweringContext<'a> {\n                     ImplTraitLoweringMode::Opaque => {\n                         let idx = self.impl_trait_counter.get();\n                         self.impl_trait_counter.set(idx + 1);\n+                        let func = match self.resolver.generic_def() {\n+                            Some(GenericDefId::FunctionId(f)) => f,\n+                            _ => panic!(\"opaque impl trait lowering in non-function\"),\n+                        };\n \n                         assert!(idx as usize == self.opaque_type_data.borrow().len());\n                         // this dance is to make sure the data is in the right\n@@ -245,14 +249,10 @@ impl<'a> TyLoweringContext<'a> {\n                         // away instead of two.\n                         let actual_opaque_type_data = self\n                             .with_debruijn(DebruijnIndex::INNERMOST, |ctx| {\n-                                ctx.lower_impl_trait(bounds)\n+                                ctx.lower_impl_trait(bounds, func)\n                             });\n                         self.opaque_type_data.borrow_mut()[idx as usize] = actual_opaque_type_data;\n \n-                        let func = match self.resolver.generic_def() {\n-                            Some(GenericDefId::FunctionId(f)) => f,\n-                            _ => panic!(\"opaque impl trait lowering in non-function\"),\n-                        };\n                         let impl_trait_id = ImplTraitId::ReturnTypeImplTrait(func, idx);\n                         let opaque_ty_id = self.db.intern_impl_trait_id(impl_trait_id).into();\n                         let generics = generics(self.db.upcast(), func.into());\n@@ -871,13 +871,42 @@ impl<'a> TyLoweringContext<'a> {\n             })\n     }\n \n-    fn lower_impl_trait(&self, bounds: &[Interned<TypeBound>]) -> ReturnTypeImplTrait {\n+    fn lower_impl_trait(\n+        &self,\n+        bounds: &[Interned<TypeBound>],\n+        func: FunctionId,\n+    ) -> ReturnTypeImplTrait {\n         cov_mark::hit!(lower_rpit);\n         let self_ty =\n             TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0)).intern(&Interner);\n+        // XXX(iDawer): Can shifting mess with unsized_types? For now I better reinsure.\n+        let outer_unsized_types = self.unsized_types.replace(Default::default());\n         let predicates = self.with_shifted_in(DebruijnIndex::ONE, |ctx| {\n-            bounds.iter().flat_map(|b| ctx.lower_type_bound(b, self_ty.clone(), false)).collect()\n+            let mut predicates: Vec<_> = bounds\n+                .iter()\n+                .flat_map(|b| ctx.lower_type_bound(b, self_ty.clone(), false))\n+                .collect();\n+\n+            if !ctx.unsized_types.borrow().contains(&self_ty) {\n+                let krate = func.lookup(ctx.db.upcast()).module(ctx.db.upcast()).krate();\n+                let sized_trait = ctx\n+                    .db\n+                    .lang_item(krate, \"sized\".into())\n+                    .and_then(|lang_item| lang_item.as_trait().map(to_chalk_trait_id));\n+                let sized_clause = sized_trait.map(|trait_id| {\n+                    let clause = WhereClause::Implemented(TraitRef {\n+                        trait_id,\n+                        substitution: Substitution::from1(&Interner, self_ty.clone()),\n+                    });\n+                    crate::wrap_empty_binders(clause)\n+                });\n+                predicates.extend(sized_clause.into_iter());\n+                predicates.shrink_to_fit();\n+            }\n+            predicates\n         });\n+        self.unsized_types.replace(outer_unsized_types);\n+\n         ReturnTypeImplTrait { bounds: crate::make_only_type_binders(1, predicates) }\n     }\n }"}, {"sha": "cef1ffe9c9e44ba4581181e4e801a97d235627db", "filename": "crates/hir_ty/src/tests/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/421979bc686216937b54b5895210576fe5f60dbb/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/421979bc686216937b54b5895210576fe5f60dbb/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=421979bc686216937b54b5895210576fe5f60dbb", "patch": "@@ -406,7 +406,7 @@ trait Foo {}\n fn test(f: impl Foo, g: &(impl Foo + ?Sized)) {\n     let _: &dyn Foo = &f;\n     let _: &dyn Foo = g;\n-                    //^ expected &dyn Foo, got &impl Foo\n+                    //^ expected &dyn Foo, got &impl Foo + ?Sized\n }\n         \"#,\n     );"}, {"sha": "cc2b779072ada9b40910a34547a7bef43e52bff2", "filename": "crates/hir_ty/src/tests/display_source_code.rs", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/421979bc686216937b54b5895210576fe5f60dbb/crates%2Fhir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/421979bc686216937b54b5895210576fe5f60dbb/crates%2Fhir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs?ref=421979bc686216937b54b5895210576fe5f60dbb", "patch": "@@ -67,3 +67,77 @@ fn foo(foo: &dyn for<'a> Foo<'a>) {}\n \"#,\n     );\n }\n+\n+#[test]\n+fn sized_bounds_apit() {\n+    check_types_source_code(\n+        r#\"\n+#[lang = \"sized\"]\n+pub trait Sized {}\n+\n+trait Foo {}\n+trait Bar<T> {}\n+struct S<T>;\n+fn test(\n+    a: impl Foo,\n+    b: impl Foo + Sized,\n+    c: &(impl Foo + ?Sized),\n+    d: S<impl Foo>,\n+    e: impl Bar<impl Foo>,\n+    empty: impl,\n+) {\n+    a;\n+  //^ impl Foo\n+    b;\n+  //^ impl Foo\n+    c;\n+  //^ &impl Foo + ?Sized\n+    d;\n+  //^ S<impl Foo>\n+    e;\n+  //^ impl Bar<impl Foo>\n+    empty;\n+} //^ impl Sized\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn sized_bounds_rpit() {\n+    check_types_source_code(\n+        r#\"\n+#[lang = \"sized\"]\n+pub trait Sized {}\n+\n+trait Foo {}\n+fn foo() -> impl Foo { loop {} }\n+fn test<T: Foo>() {\n+    let foo = foo();\n+    foo;\n+}   //^ impl Foo\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn sized_bounds_impl_traits_in_fn_signature() {\n+    check_types_source_code(\n+        r#\"\n+#[lang = \"sized\"]\n+pub trait Sized {}\n+\n+trait Foo {}\n+fn test(\n+    a: fn(impl Foo) -> impl Foo,\n+    b: fn(impl Foo + Sized) -> impl Foo + Sized,\n+    c: fn(&(impl Foo + ?Sized)) -> &(impl Foo + ?Sized),\n+) {\n+    a;\n+  //^ fn(impl Foo) -> impl Foo\n+    b;\n+  //^ fn(impl Foo) -> impl Foo\n+    c;\n+} //^ fn(&impl Foo + ?Sized) -> &impl Foo + ?Sized\n+\"#,\n+    );\n+}"}]}