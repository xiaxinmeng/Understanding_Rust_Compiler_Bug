{"sha": "740e8a3f37f224927269bf7b205b16142d91bf0f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0MGU4YTNmMzdmMjI0OTI3MjY5YmY3YjIwNWIxNjE0MmQ5MWJmMGY=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2018-10-22T20:50:10Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2018-10-26T21:47:52Z"}, "message": "Add the actual chain of projections to `UserTypeProjection`.\n\nUpdate the existing NLL `patterns.rs` test accordingly.\n\nincludes changes addressing review feedback:\n\n * Added example to docs for `UserTypeProjections` illustrating how we\n   build up multiple projections when descending into a pattern with\n   type ascriptions.\n\n * Adapted niko's suggested docs for `UserTypeProjection`.\n\n * Factored out `projection_ty` from more general `projection_ty_core`\n   (as a drive-by, made its callback an `FnMut`, as I discovered later\n   that I need that).\n\n * Add note to docs that `PlaceTy.field_ty(..)` does not normalize its result.\n\n * Normalize as we project out `field_ty`.", "tree": {"sha": "94b10bf3171886d3c26522085a0af10967231177", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94b10bf3171886d3c26522085a0af10967231177"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/740e8a3f37f224927269bf7b205b16142d91bf0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/740e8a3f37f224927269bf7b205b16142d91bf0f", "html_url": "https://github.com/rust-lang/rust/commit/740e8a3f37f224927269bf7b205b16142d91bf0f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/740e8a3f37f224927269bf7b205b16142d91bf0f/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b569caf267c595d2c2988941fb39f4718cadfdcc", "url": "https://api.github.com/repos/rust-lang/rust/commits/b569caf267c595d2c2988941fb39f4718cadfdcc", "html_url": "https://github.com/rust-lang/rust/commit/b569caf267c595d2c2988941fb39f4718cadfdcc"}], "stats": {"total": 336, "additions": 272, "deletions": 64}, "files": [{"sha": "274a2df283cbd05aa0eac6e978b84ffb044ba21f", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/740e8a3f37f224927269bf7b205b16142d91bf0f/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740e8a3f37f224927269bf7b205b16142d91bf0f/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=740e8a3f37f224927269bf7b205b16142d91bf0f", "patch": "@@ -607,5 +607,5 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::UserTypeAnnotation<\n     }\n }\n \n-impl_stable_hash_for!(struct mir::UserTypeProjection<'tcx> { base });\n+impl_stable_hash_for!(struct mir::UserTypeProjection<'tcx> { base, projs });\n impl_stable_hash_for!(struct mir::UserTypeProjections<'tcx> { contents });"}, {"sha": "142dc40e5b125cd67bc92cd7de8904e215a71a58", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 64, "deletions": 4, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/740e8a3f37f224927269bf7b205b16142d91bf0f/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740e8a3f37f224927269bf7b205b16142d91bf0f/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=740e8a3f37f224927269bf7b205b16142d91bf0f", "patch": "@@ -2456,6 +2456,31 @@ EnumLiftImpl! {\n ///\n /// Its a collection because there can be multiple type ascriptions on\n /// the path from the root of the pattern down to the binding itself.\n+///\n+/// An example:\n+///\n+/// ```rust\n+/// struct S<'a>((i32, &'a str), String);\n+/// let S((_, w): (i32, &'static str), _): S = ...;\n+/// //    ------  ^^^^^^^^^^^^^^^^^^^ (1)\n+/// //  ---------------------------------  ^ (2)\n+/// ```\n+///\n+/// The highlights labelled `(1)` show the subpattern `(_, w)` being\n+/// ascribed the type `(i32, &'static str)`.\n+///\n+/// The highlights labelled `(2)` show the whole pattern being\n+/// ascribed the type `S`.\n+///\n+/// In this example, when we descend to `w`, we will have built up the\n+/// following two projected types:\n+///\n+///   * base: `S`,                   projection: `(base.0).1`\n+///   * base: `(i32, &'static str)`, projection: `base.1`\n+///\n+/// The first will lead to the constraint `w: &'1 str` (for some\n+/// inferred region `'1`). The second will lead to the constraint `w:\n+/// &'static str`.\n #[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct UserTypeProjections<'tcx> {\n     pub(crate) contents: Vec<(UserTypeProjection<'tcx>, Span)>,\n@@ -2485,14 +2510,49 @@ impl<'tcx> UserTypeProjections<'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+/// Encodes the effect of a user-supplied type annotation on the\n+/// subcomponents of a pattern. The effect is determined by applying the\n+/// given list of proejctions to some underlying base type. Often,\n+/// the projection element list `projs` is empty, in which case this\n+/// directly encodes a type in `base`. But in the case of complex patterns with\n+/// subpatterns and bindings, we want to apply only a *part* of the type to a variable,\n+/// in which case the `projs` vector is used.\n+///\n+/// Examples:\n+///\n+/// * `let x: T = ...` -- here, the `projs` vector is empty.\n+///\n+/// * `let (x, _): T = ...` -- here, the `projs` vector would contain\n+///   `field[0]` (aka `.0`), indicating that the type of `s` is\n+///   determined by finding the type of the `.0` field from `T`.\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct UserTypeProjection<'tcx> {\n     pub base: UserTypeAnnotation<'tcx>,\n+    pub projs: Vec<ProjectionElem<'tcx, (), ()>>,\n }\n \n-BraceStructTypeFoldableImpl! {\n-    impl<'tcx> TypeFoldable<'tcx> for UserTypeProjection<'tcx> {\n-        base\n+impl<'tcx> TypeFoldable<'tcx> for UserTypeProjection<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        use mir::ProjectionElem::*;\n+\n+        let base = self.base.fold_with(folder);\n+        let projs: Vec<_> = self.projs\n+            .iter()\n+            .map(|elem| {\n+                match elem {\n+                    Deref => Deref,\n+                    Field(f, ()) => Field(f.clone(), ()),\n+                    Index(()) => Index(()),\n+                    elem => elem.clone(),\n+                }})\n+            .collect();\n+\n+        UserTypeProjection { base, projs }\n+    }\n+\n+    fn super_visit_with<Vs: TypeVisitor<'tcx>>(&self, visitor: &mut Vs) -> bool {\n+        self.base.visit_with(visitor)\n+        // Note: there's nothing in `self.proj` to visit.\n     }\n }\n "}, {"sha": "473730c548990c8005986a903aa8d546bcf951c1", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 53, "deletions": 3, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/740e8a3f37f224927269bf7b205b16142d91bf0f/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740e8a3f37f224927269bf7b205b16142d91bf0f/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=740e8a3f37f224927269bf7b205b16142d91bf0f", "patch": "@@ -44,11 +44,59 @@ impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n         }\n     }\n \n+    /// `place_ty.field_ty(tcx, f)` computes the type at a given field\n+    /// of a record or enum-variant. (Most clients of `PlaceTy` can\n+    /// instead just extract the relevant type directly from their\n+    /// `PlaceElem`, but some instances of `ProjectionElem<V, T>` do\n+    /// not carry a `Ty` for `T`.)\n+    ///\n+    /// Note that the resulting type has not been normalized.\n+    pub fn field_ty(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, f: &Field) -> Ty<'tcx>\n+    {\n+        // Pass `0` here so it can be used as a \"default\" variant_index in first arm below\n+        let answer = match (self, 0) {\n+            (PlaceTy::Ty {\n+                ty: &ty::TyS { sty: ty::TyKind::Adt(adt_def, substs), .. } }, variant_index) |\n+            (PlaceTy::Downcast { adt_def, substs, variant_index }, _) => {\n+                let variant_def = &adt_def.variants[variant_index];\n+                let field_def = &variant_def.fields[f.index()];\n+                field_def.ty(tcx, substs)\n+            }\n+            (PlaceTy::Ty { ty }, _) => {\n+                match ty.sty {\n+                    ty::Tuple(ref tys) => tys[f.index()],\n+                    _ => bug!(\"extracting field of non-tuple non-adt: {:?}\", self),\n+                }\n+            }\n+        };\n+        debug!(\"field_ty self: {:?} f: {:?} yields: {:?}\", self, f, answer);\n+        answer\n+    }\n+\n+    /// Convenience wrapper around `projection_ty_core` for\n+    /// `PlaceElem`, where we can just use the `Ty` that is already\n+    /// stored inline on field projection elems.\n     pub fn projection_ty(self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                          elem: &PlaceElem<'tcx>)\n                          -> PlaceTy<'tcx>\n     {\n-        match *elem {\n+        self.projection_ty_core(tcx, elem, |_, _, ty| ty)\n+    }\n+\n+    /// `place_ty.projection_ty_core(tcx, elem, |...| { ... })`\n+    /// projects `place_ty` onto `elem`, returning the appropriate\n+    /// `Ty` or downcast variant corresponding to that projection.\n+    /// The `handle_field` callback must map a `Field` to its `Ty`,\n+    /// (which should be trivial when `T` = `Ty`).\n+    pub fn projection_ty_core<V, T>(self,\n+                                    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                    elem: &ProjectionElem<'tcx, V, T>,\n+                                    mut handle_field: impl FnMut(&Self, &Field, &T) -> Ty<'tcx>)\n+                                    -> PlaceTy<'tcx>\n+    where\n+        V: ::std::fmt::Debug, T: ::std::fmt::Debug\n+    {\n+        let answer = match *elem {\n             ProjectionElem::Deref => {\n                 let ty = self.to_ty(tcx)\n                              .builtin_deref(true)\n@@ -94,8 +142,10 @@ impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n                         bug!(\"cannot downcast non-ADT type: `{:?}`\", self)\n                     }\n                 },\n-            ProjectionElem::Field(_, fty) => PlaceTy::Ty { ty: fty }\n-        }\n+            ProjectionElem::Field(ref f, ref fty) => PlaceTy::Ty { ty: handle_field(&self, f, fty) }\n+        };\n+        debug!(\"projection_ty self: {:?} elem: {:?} yields: {:?}\", self, elem, answer);\n+        answer\n     }\n }\n "}, {"sha": "bfc03923f6011d1138ad2ba7a1a64c785e921315", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/740e8a3f37f224927269bf7b205b16142d91bf0f/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740e8a3f37f224927269bf7b205b16142d91bf0f/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=740e8a3f37f224927269bf7b205b16142d91bf0f", "patch": "@@ -797,8 +797,9 @@ macro_rules! make_mir_visitor {\n             ) {\n                 let UserTypeProjection {\n                     ref $($mutability)* base,\n+                    projs: _, // Note: Does not visit projection elems!\n                 } = *ty;\n-                self.visit_user_type_annotation(base)\n+                self.visit_user_type_annotation(base);\n             }\n \n             fn super_user_type_annotation("}, {"sha": "1602ef3c5b795d5e726e5dbfa6560917712921b0", "filename": "src/librustc_codegen_llvm/mir/analyze.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/740e8a3f37f224927269bf7b205b16142d91bf0f/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740e8a3f37f224927269bf7b205b16142d91bf0f/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs?ref=740e8a3f37f224927269bf7b205b16142d91bf0f", "patch": "@@ -168,7 +168,9 @@ impl Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'll, 'tcx> {\n                 let base_ty = self.fx.monomorphize(&base_ty);\n \n                 // ZSTs don't require any actual memory access.\n-                let elem_ty = base_ty.projection_ty(cx.tcx, &proj.elem).to_ty(cx.tcx);\n+                let elem_ty = base_ty\n+                    .projection_ty(cx.tcx, &proj.elem)\n+                    .to_ty(cx.tcx);\n                 let elem_ty = self.fx.monomorphize(&elem_ty);\n                 if cx.layout_of(elem_ty).is_zst() {\n                     return;"}, {"sha": "062f7174680db92a470542e7a6e02877075e54ce", "filename": "src/librustc_codegen_llvm/mir/place.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/740e8a3f37f224927269bf7b205b16142d91bf0f/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740e8a3f37f224927269bf7b205b16142d91bf0f/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs?ref=740e8a3f37f224927269bf7b205b16142d91bf0f", "patch": "@@ -517,7 +517,8 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                         let mut subslice = cg_base.project_index(bx,\n                             C_usize(bx.cx, from as u64));\n                         let projected_ty = PlaceTy::Ty { ty: cg_base.layout.ty }\n-                            .projection_ty(tcx, &projection.elem).to_ty(bx.tcx());\n+                            .projection_ty(tcx, &projection.elem)\n+                            .to_ty(bx.tcx());\n                         subslice.layout = bx.cx.layout_of(self.monomorphize(&projected_ty));\n \n                         if subslice.layout.is_unsized() {"}, {"sha": "4d1eea4724beafb8a012680088e152699f47ec14", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/740e8a3f37f224927269bf7b205b16142d91bf0f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740e8a3f37f224927269bf7b205b16142d91bf0f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=740e8a3f37f224927269bf7b205b16142d91bf0f", "patch": "@@ -284,7 +284,7 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             if let Err(terr) = self.cx.relate_type_and_user_type(\n                 constant.ty,\n                 ty::Variance::Invariant,\n-                &UserTypeProjection { base: user_ty },\n+                &UserTypeProjection { base: user_ty, projs: vec![], },\n                 location.to_locations(),\n                 ConstraintCategory::Boring,\n             ) {\n@@ -980,7 +980,6 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             a, v, user_ty, locations,\n         );\n \n-        // FIXME\n         match user_ty.base {\n             UserTypeAnnotation::Ty(canonical_ty) => {\n                 let (ty, _) = self.infcx\n@@ -991,6 +990,20 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 // ambient variance to get the right relationship.\n                 let v1 = ty::Contravariant.xform(v);\n \n+                let tcx = self.infcx.tcx;\n+                let mut projected_ty = PlaceTy::from_ty(ty);\n+                for proj in &user_ty.projs {\n+                    projected_ty = projected_ty.projection_ty_core(\n+                        tcx, proj, |this, field, &()| {\n+                            let ty = this.field_ty(tcx, field);\n+                            self.normalize(ty, locations)\n+                        });\n+                }\n+                debug!(\"user_ty base: {:?} freshened: {:?} projs: {:?} yields: {:?}\",\n+                       user_ty.base, ty, user_ty.projs, projected_ty);\n+\n+                let ty = projected_ty.to_ty(tcx);\n+\n                 self.relate_types(ty, v1, a, locations, category)?;\n             }\n             UserTypeAnnotation::TypeOf(def_id, canonical_substs) => {\n@@ -1000,6 +1013,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 ) = self.infcx\n                     .instantiate_canonical_with_fresh_inference_vars(DUMMY_SP, &canonical_substs);\n \n+                // FIXME: add user_ty.projs support to `AscribeUserType`.\n                 self.fully_perform_op(\n                     locations,\n                     category,\n@@ -1173,7 +1187,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     if let Err(terr) = self.relate_type_and_user_type(\n                         rv_ty,\n                         ty::Variance::Invariant,\n-                        &UserTypeProjection { base: user_ty },\n+                        &UserTypeProjection { base: user_ty, projs: vec![], },\n                         location.to_locations(),\n                         ConstraintCategory::Boring,\n                     ) {"}, {"sha": "77746e5538d65db608fb5ff59118f01e7b1a033f", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/740e8a3f37f224927269bf7b205b16142d91bf0f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740e8a3f37f224927269bf7b205b16142d91bf0f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=740e8a3f37f224927269bf7b205b16142d91bf0f", "patch": "@@ -147,7 +147,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                             kind: StatementKind::AscribeUserType(\n                                 place.clone(),\n                                 Variance::Invariant,\n-                                box UserTypeProjection { base: user_ty },\n+                                box UserTypeProjection { base: user_ty, projs: vec![], },\n                             ),\n                         },\n                     );\n@@ -167,7 +167,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                             kind: StatementKind::AscribeUserType(\n                                 Place::Local(temp.clone()),\n                                 Variance::Invariant,\n-                                box UserTypeProjection { base: user_ty },\n+                                box UserTypeProjection { base: user_ty, projs: vec![], },\n                             ),\n                         },\n                     );"}, {"sha": "b92f270255af4fa23bbe4a00bb1476cc3cb8b208", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/740e8a3f37f224927269bf7b205b16142d91bf0f/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740e8a3f37f224927269bf7b205b16142d91bf0f/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=740e8a3f37f224927269bf7b205b16142d91bf0f", "patch": "@@ -32,6 +32,8 @@ mod simplify;\n mod test;\n mod util;\n \n+use std::convert::TryFrom;\n+\n /// ArmHasGuard is isomorphic to a boolean flag. It indicates whether\n /// a match arm has a guard expression attached to it.\n #[derive(Copy, Clone, Debug)]\n@@ -541,11 +543,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 ref slice,\n                 ref suffix,\n             } => {\n+                let from = u32::try_from(prefix.len()).unwrap();\n+                let to = u32::try_from(suffix.len()).unwrap();\n                 for subpattern in prefix {\n                     self.visit_bindings(subpattern, &pattern_user_ty.index(), f);\n                 }\n                 for subpattern in slice {\n-                    self.visit_bindings(subpattern, &pattern_user_ty.subslice(), f);\n+                    self.visit_bindings(subpattern, &pattern_user_ty.subslice(from, to), f);\n                 }\n                 for subpattern in suffix {\n                     self.visit_bindings(subpattern, &pattern_user_ty.index(), f);\n@@ -555,25 +559,28 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             PatternKind::Deref { ref subpattern } => {\n                 self.visit_bindings(subpattern, &pattern_user_ty.deref(), f);\n             }\n-            PatternKind::AscribeUserType { ref subpattern, user_ty, user_ty_span } => {\n+            PatternKind::AscribeUserType { ref subpattern, ref user_ty, user_ty_span } => {\n                 // This corresponds to something like\n                 //\n                 // ```\n                 // let A::<'a>(_): A<'static> = ...;\n                 // ```\n-                let pattern_user_ty = pattern_user_ty.add_user_type(user_ty, user_ty_span);\n-                self.visit_bindings(subpattern, &pattern_user_ty, f)\n+                let subpattern_user_ty = pattern_user_ty.add_user_type(user_ty, user_ty_span);\n+                self.visit_bindings(subpattern, &subpattern_user_ty, f)\n             }\n \n             PatternKind::Leaf { ref subpatterns } => {\n-                for (j, subpattern) in subpatterns.iter().enumerate() {\n-                    self.visit_bindings(&subpattern.pattern, &pattern_user_ty.leaf(j), f);\n+                for subpattern in subpatterns {\n+                    let subpattern_user_ty = pattern_user_ty.leaf(subpattern.field);\n+                    self.visit_bindings(&subpattern.pattern, &subpattern_user_ty, f);\n                 }\n             }\n \n-            PatternKind::Variant { ref subpatterns, .. } => {\n-                for (j, subpattern) in subpatterns.iter().enumerate() {\n-                    self.visit_bindings(&subpattern.pattern, &pattern_user_ty.variant(j), f);\n+            PatternKind::Variant { adt_def, substs: _, variant_index, ref subpatterns } => {\n+                for subpattern in subpatterns {\n+                    let subpattern_user_ty = pattern_user_ty.variant(\n+                        adt_def, variant_index, subpattern.field);\n+                    self.visit_bindings(&subpattern.pattern, &subpattern_user_ty, f);\n                 }\n             }\n         }\n@@ -1329,7 +1336,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     kind: StatementKind::AscribeUserType(\n                         ascription.source.clone(),\n                         ty::Variance::Covariant,\n-                        box ascription.user_ty.user_ty(),\n+                        box ascription.user_ty.clone().user_ty(),\n                     ),\n                 },\n             );"}, {"sha": "349d877d52474eec8ae1ec1dc37c781c68d4e260", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/740e8a3f37f224927269bf7b205b16142d91bf0f/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740e8a3f37f224927269bf7b205b16142d91bf0f/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=740e8a3f37f224927269bf7b205b16142d91bf0f", "patch": "@@ -63,10 +63,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                  candidate: &mut Candidate<'pat, 'tcx>)\n                                  -> Result<(), MatchPair<'pat, 'tcx>> {\n         match *match_pair.pattern.kind {\n-            PatternKind::AscribeUserType { ref subpattern, user_ty, user_ty_span } => {\n+            PatternKind::AscribeUserType { ref subpattern, ref user_ty, user_ty_span } => {\n                 candidate.ascriptions.push(Ascription {\n                     span: user_ty_span,\n-                    user_ty,\n+                    user_ty: user_ty.clone(),\n                     source: match_pair.place.clone(),\n                 });\n "}, {"sha": "bff87da9c771d5070906a2e082d512dee935d7de", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 63, "deletions": 19, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/740e8a3f37f224927269bf7b205b16142d91bf0f/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740e8a3f37f224927269bf7b205b16142d91bf0f/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=740e8a3f37f224927269bf7b205b16142d91bf0f", "patch": "@@ -21,7 +21,7 @@ use const_eval::{const_field, const_variant_index};\n use hair::util::UserAnnotatedTyHelpers;\n \n use rustc::mir::{fmt_const_val, Field, BorrowKind, Mutability};\n-use rustc::mir::{UserTypeAnnotation, UserTypeProjection, UserTypeProjections};\n+use rustc::mir::{ProjectionElem, UserTypeAnnotation, UserTypeProjection, UserTypeProjections};\n use rustc::mir::interpret::{Scalar, GlobalId, ConstValue, sign_extend};\n use rustc::ty::{self, Region, TyCtxt, AdtDef, Ty};\n use rustc::ty::subst::{Substs, Kind};\n@@ -86,43 +86,87 @@ impl<'tcx> PatternTypeProjections<'tcx> {\n         PatternTypeProjections { contents: vec![] }\n     }\n \n-    pub(crate) fn index(&self) -> Self {\n-        unimplemented!()\n+    fn map_projs(&self,\n+                 mut f: impl FnMut(&PatternTypeProjection<'tcx>) -> PatternTypeProjection<'tcx>)\n+                 -> Self\n+    {\n+        PatternTypeProjections {\n+            contents: self.contents\n+                .iter()\n+                .map(|(proj, span)| (f(proj), *span))\n+                .collect(), }\n     }\n \n-    pub(crate) fn subslice(&self) -> Self {\n-        unimplemented!()\n-    }\n+    pub(crate) fn index(&self) -> Self { self.map_projs(|pat_ty_proj| pat_ty_proj.index()) }\n \n-    pub(crate) fn deref(&self) -> Self {\n-        unimplemented!()\n+    pub(crate) fn subslice(&self, from: u32, to: u32) -> Self {\n+        self.map_projs(|pat_ty_proj| pat_ty_proj.subslice(from, to))\n     }\n \n-    pub(crate) fn add_user_type(&self, user_ty: PatternTypeProjection<'tcx>, sp: Span) -> Self {\n-        let mut new = self.clone();\n-        new.contents.push((user_ty, sp));\n-        new\n+    pub(crate) fn deref(&self) -> Self { self.map_projs(|pat_ty_proj| pat_ty_proj.deref()) }\n+\n+    pub(crate) fn leaf(&self, field: Field) -> Self {\n+        self.map_projs(|pat_ty_proj| pat_ty_proj.leaf(field))\n     }\n \n-    pub(crate) fn leaf(&self, _index: usize) -> Self {\n-        unimplemented!()\n+    pub(crate) fn variant(&self,\n+                          adt_def: &'tcx AdtDef,\n+                          variant_index: usize,\n+                          field: Field) -> Self {\n+        self.map_projs(|pat_ty_proj| pat_ty_proj.variant(adt_def, variant_index, field))\n     }\n \n-    pub(crate) fn variant(&self, _index: usize) -> Self {\n-        unimplemented!()\n+    pub(crate) fn add_user_type(&self, user_ty: &PatternTypeProjection<'tcx>, sp: Span) -> Self {\n+        let mut new = self.clone();\n+        new.contents.push((user_ty.clone(), sp));\n+        new\n     }\n }\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Clone, Debug)]\n pub struct PatternTypeProjection<'tcx>(UserTypeProjection<'tcx>);\n \n impl<'tcx> PatternTypeProjection<'tcx> {\n+    pub(crate) fn index(&self) -> Self {\n+        let mut new = self.clone();\n+        new.0.projs.push(ProjectionElem::Index(()));\n+        new\n+    }\n+\n+    pub(crate) fn subslice(&self, from: u32, to: u32) -> Self {\n+        let mut new = self.clone();\n+        new.0.projs.push(ProjectionElem::Subslice { from, to });\n+        new\n+    }\n+\n+    pub(crate) fn deref(&self) -> Self {\n+        let mut new = self.clone();\n+        new.0.projs.push(ProjectionElem::Deref);\n+        new\n+    }\n+\n+    pub(crate) fn leaf(&self, field: Field) -> Self {\n+        let mut new = self.clone();\n+        new.0.projs.push(ProjectionElem::Field(field, ()));\n+        new\n+    }\n+\n+    pub(crate) fn variant(&self,\n+                          adt_def: &'tcx AdtDef,\n+                          variant_index: usize,\n+                          field: Field) -> Self {\n+        let mut new = self.clone();\n+        new.0.projs.push(ProjectionElem::Downcast(adt_def, variant_index));\n+        new.0.projs.push(ProjectionElem::Field(field, ()));\n+        new\n+    }\n+\n     pub(crate) fn from_canonical_ty(c_ty: ty::CanonicalTy<'tcx>) -> Self {\n         Self::from_user_type(UserTypeAnnotation::Ty(c_ty))\n     }\n \n     pub(crate) fn from_user_type(u_ty: UserTypeAnnotation<'tcx>) -> Self {\n-        Self::from_user_type_proj(UserTypeProjection { base: u_ty })\n+        Self::from_user_type_proj(UserTypeProjection { base: u_ty, projs: vec![], })\n     }\n \n     pub(crate) fn from_user_type_proj(u_ty: UserTypeProjection<'tcx>) -> Self {\n@@ -1086,7 +1130,7 @@ impl<'tcx> PatternFoldable<'tcx> for PatternKind<'tcx> {\n             PatternKind::Wild => PatternKind::Wild,\n             PatternKind::AscribeUserType {\n                 ref subpattern,\n-                user_ty,\n+                ref user_ty,\n                 user_ty_span,\n             } => PatternKind::AscribeUserType {\n                 subpattern: subpattern.fold_with(folder),"}, {"sha": "643231b39b42e096611f7e0b22eb21fa6d464826", "filename": "src/test/ui/nll/user-annotations/patterns.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/740e8a3f37f224927269bf7b205b16142d91bf0f/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740e8a3f37f224927269bf7b205b16142d91bf0f/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fpatterns.rs?ref=740e8a3f37f224927269bf7b205b16142d91bf0f", "patch": "@@ -9,11 +9,11 @@ fn variable_no_initializer() {\n }\n \n fn tuple_no_initializer() {\n-    // FIXME(#47187): We are not propagating ascribed type through tuples.\n+\n \n     let x = 22;\n     let (y, z): (&'static u32, &'static u32);\n-    y = &x;\n+    y = &x; //~ ERROR\n }\n \n fn ref_with_ascribed_static_type() -> u32 {\n@@ -34,11 +34,11 @@ fn ref_with_ascribed_any_type() -> u32 {\n struct Single<T> { value: T }\n \n fn struct_no_initializer() {\n-    // FIXME(#47187): We are not propagating ascribed type through patterns.\n+\n \n     let x = 22;\n     let Single { value: y }: Single<&'static u32>;\n-    y = &x;\n+    y = &x; //~ ERROR\n }\n \n fn variable_with_initializer() {\n@@ -91,26 +91,26 @@ fn struct_double_field_underscore_with_initializer() {\n }\n \n fn static_to_a_to_static_through_variable<'a>(x: &'a u32) -> &'static u32 {\n-    // The error in this test is inconsistency with\n-    // `static_to_a_to_static_through_tuple`, but \"feels right\" to\n-    // me. It occurs because we special case the single binding case\n-    // and force the type of `y` to be `&'a u32`, even though the\n-    // right-hand side has type `&'static u32`.\n+\n+\n+\n+\n+\n \n     let y: &'a u32 = &22;\n     y //~ ERROR\n }\n \n fn static_to_a_to_static_through_tuple<'a>(x: &'a u32) -> &'static u32 {\n-    // FIXME(#47187): The fact that this type-checks is perhaps surprising.\n-    // What happens is that the right-hand side is constrained to have\n-    // type `&'a u32`, which is possible, because it has type\n-    // `&'static u32`. The variable `y` is then forced to have type\n-    // `&'static u32`, but it is constrained only by the right-hand\n-    // side, not the ascribed type, and hence it passes.\n+\n+\n+\n+\n+\n+\n \n     let (y, _z): (&'a u32, u32) = (&22, 44);\n-    y\n+    y //~ ERROR\n }\n \n fn a_to_static_then_static<'a>(x: &'a u32) -> &'static u32 {"}, {"sha": "58b708fcb1b53ef5eadbcf07bc75b1d9fdb7b2e7", "filename": "src/test/ui/nll/user-annotations/patterns.stderr", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/740e8a3f37f224927269bf7b205b16142d91bf0f/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fpatterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/740e8a3f37f224927269bf7b205b16142d91bf0f/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fpatterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fpatterns.stderr?ref=740e8a3f37f224927269bf7b205b16142d91bf0f", "patch": "@@ -8,6 +8,16 @@ LL |     y = &x; //~ ERROR\n LL | }\n    | - `x` dropped here while still borrowed\n \n+error[E0597]: `x` does not live long enough\n+  --> $DIR/patterns.rs:16:9\n+   |\n+LL |     let (y, z): (&'static u32, &'static u32);\n+   |                 ---------------------------- type annotation requires that `x` is borrowed for `'static`\n+LL |     y = &x; //~ ERROR\n+   |         ^^ borrowed value does not live long enough\n+LL | }\n+   | - `x` dropped here while still borrowed\n+\n error[E0597]: `x` does not live long enough\n   --> $DIR/patterns.rs:22:13\n    |\n@@ -19,6 +29,16 @@ LL |     **z\n LL | }\n    | - `x` dropped here while still borrowed\n \n+error[E0597]: `x` does not live long enough\n+  --> $DIR/patterns.rs:41:9\n+   |\n+LL |     let Single { value: y }: Single<&'static u32>;\n+   |                              -------------------- type annotation requires that `x` is borrowed for `'static`\n+LL |     y = &x; //~ ERROR\n+   |         ^^ borrowed value does not live long enough\n+LL | }\n+   | - `x` dropped here while still borrowed\n+\n error[E0597]: `x` does not live long enough\n   --> $DIR/patterns.rs:46:27\n    |\n@@ -127,6 +147,15 @@ LL | fn static_to_a_to_static_through_variable<'a>(x: &'a u32) -> &'static u32 {\n LL |     y //~ ERROR\n    |     ^ returning this value requires that `'a` must outlive `'static`\n \n+error: unsatisfied lifetime constraints\n+  --> $DIR/patterns.rs:113:5\n+   |\n+LL | fn static_to_a_to_static_through_tuple<'a>(x: &'a u32) -> &'static u32 {\n+   |                                        -- lifetime `'a` defined here\n+...\n+LL |     y //~ ERROR\n+   |     ^ returning this value requires that `'a` must outlive `'static`\n+\n error: unsatisfied lifetime constraints\n   --> $DIR/patterns.rs:117:18\n    |\n@@ -135,7 +164,7 @@ LL | fn a_to_static_then_static<'a>(x: &'a u32) -> &'static u32 {\n LL |     let (y, _z): (&'static u32, u32) = (x, 44); //~ ERROR\n    |                  ^^^^^^^^^^^^^^^^^^^ type annotation requires that `'a` must outlive `'static`\n \n-error: aborting due to 14 previous errors\n+error: aborting due to 17 previous errors\n \n Some errors occurred: E0597, E0716.\n For more information about an error, try `rustc --explain E0597`."}]}