{"sha": "ea94a90488e6b4701581079339de3595389e5b15", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhOTRhOTA0ODhlNmI0NzAxNTgxMDc5MzM5ZGUzNTk1Mzg5ZTViMTU=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-30T22:14:50Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-01-01T00:14:44Z"}, "message": "unicode: unbox closures used in function arguments", "tree": {"sha": "9ba332dd7b927207ccdee8538113c65bc691dee5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ba332dd7b927207ccdee8538113c65bc691dee5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea94a90488e6b4701581079339de3595389e5b15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea94a90488e6b4701581079339de3595389e5b15", "html_url": "https://github.com/rust-lang/rust/commit/ea94a90488e6b4701581079339de3595389e5b15", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea94a90488e6b4701581079339de3595389e5b15/comments", "author": null, "committer": null, "parents": [{"sha": "10d99a973498c5a1be6ba318210751efc1c2cf61", "url": "https://api.github.com/repos/rust-lang/rust/commits/10d99a973498c5a1be6ba318210751efc1c2cf61", "html_url": "https://github.com/rust-lang/rust/commit/10d99a973498c5a1be6ba318210751efc1c2cf61"}], "stats": {"total": 27, "additions": 15, "deletions": 12}, "files": [{"sha": "c6f86ccd9d412c81c87a9a2b4bbdef308d60a7cc", "filename": "src/libunicode/normalize.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ea94a90488e6b4701581079339de3595389e5b15/src%2Flibunicode%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea94a90488e6b4701581079339de3595389e5b15/src%2Flibunicode%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fnormalize.rs?ref=ea94a90488e6b4701581079339de3595389e5b15", "patch": "@@ -11,6 +11,7 @@\n //! Functions for computing canonical and compatible decompositions for Unicode characters.\n \n use core::cmp::Ordering::{Equal, Less, Greater};\n+use core::ops::FnMut;\n use core::option::Option;\n use core::option::Option::{Some, None};\n use core::slice::SliceExt;\n@@ -32,14 +33,15 @@ fn bsearch_table<T>(c: char, r: &'static [(char, &'static [T])]) -> Option<&'sta\n }\n \n /// Compute canonical Unicode decomposition for character\n-pub fn decompose_canonical(c: char, i: |char|) { d(c, i, false); }\n+pub fn decompose_canonical<F>(c: char, mut i: F) where F: FnMut(char) { d(c, &mut i, false); }\n \n /// Compute canonical or compatible Unicode decomposition for character\n-pub fn decompose_compatible(c: char, i: |char|) { d(c, i, true); }\n+pub fn decompose_compatible<F>(c: char, mut i: F) where F: FnMut(char) { d(c, &mut i, true); }\n \n-fn d(c: char, i: |char|, k: bool) {\n+// FIXME(#19596) This is a workaround, we should use `F` instead of `&mut F`\n+fn d<F>(c: char, i: &mut F, k: bool) where F: FnMut(char) {\n     // 7-bit ASCII never decomposes\n-    if c <= '\\x7f' { i(c); return; }\n+    if c <= '\\x7f' { (*i)(c); return; }\n \n     // Perform decomposition for Hangul\n     if (c as u32) >= S_BASE && (c as u32) < (S_BASE + S_COUNT) {\n@@ -51,29 +53,29 @@ fn d(c: char, i: |char|, k: bool) {\n     match bsearch_table(c, canonical_table) {\n         Some(canon) => {\n             for x in canon.iter() {\n-                d(*x, |b| i(b), k);\n+                d(*x, i, k);\n             }\n             return;\n         }\n         None => ()\n     }\n \n     // Bottom out if we're not doing compat.\n-    if !k { i(c); return; }\n+    if !k { (*i)(c); return; }\n \n     // Then check the compatibility decompositions\n     match bsearch_table(c, compatibility_table) {\n         Some(compat) => {\n             for x in compat.iter() {\n-                d(*x, |b| i(b), k);\n+                d(*x, i, k);\n             }\n             return;\n         }\n         None => ()\n     }\n \n     // Finally bottom out.\n-    i(c);\n+    (*i)(c);\n }\n \n pub fn compose(a: char, b: char) -> Option<char> {\n@@ -108,23 +110,24 @@ const T_COUNT: u32 = 28;\n const N_COUNT: u32 = (V_COUNT * T_COUNT);\n const S_COUNT: u32 = (L_COUNT * N_COUNT);\n \n+// FIXME(#19596) This is a workaround, we should use `F` instead of `&mut F`\n // Decompose a precomposed Hangul syllable\n #[inline(always)]\n-fn decompose_hangul(s: char, f: |char|) {\n+fn decompose_hangul<F>(s: char, f: &mut F) where F: FnMut(char) {\n     use core::mem::transmute;\n \n     let si = s as u32 - S_BASE;\n \n     let li = si / N_COUNT;\n     unsafe {\n-        f(transmute(L_BASE + li));\n+        (*f)(transmute(L_BASE + li));\n \n         let vi = (si % N_COUNT) / T_COUNT;\n-        f(transmute(V_BASE + vi));\n+        (*f)(transmute(V_BASE + vi));\n \n         let ti = si % T_COUNT;\n         if ti > 0 {\n-            f(transmute(T_BASE + ti));\n+            (*f)(transmute(T_BASE + ti));\n         }\n     }\n }"}]}