{"sha": "fc5c31c48cf19757ebf4b750efa34e7cb5f995e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjNWMzMWM0OGNmMTk3NTdlYmY0Yjc1MGVmYTM0ZTdjYjVmOTk1ZTM=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-06-09T07:55:16Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-06-10T12:29:53Z"}, "message": "rustc: make the comon case of tcx.infer_ctxt(()) nicer.", "tree": {"sha": "8760dec05da62290b437a65b0956554529957841", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8760dec05da62290b437a65b0956554529957841"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3", "html_url": "https://github.com/rust-lang/rust/commit/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63481a57dcb4a12501621f5bc915999d4af0e8a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/63481a57dcb4a12501621f5bc915999d4af0e8a0", "html_url": "https://github.com/rust-lang/rust/commit/63481a57dcb4a12501621f5bc915999d4af0e8a0"}], "stats": {"total": 214, "additions": 102, "deletions": 112}, "files": [{"sha": "4bc0005d568a44151e3c8625d7c62fec1f1eaedf", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 30, "deletions": 70, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=fc5c31c48cf19757ebf4b750efa34e7cb5f995e3", "patch": "@@ -31,7 +31,7 @@ use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use ty::relate::RelateResult;\n use traits::{self, ObligationCause, PredicateObligations, Reveal};\n use rustc_data_structures::unify::{self, UnificationTable};\n-use std::cell::{Cell, RefCell, Ref, RefMut};\n+use std::cell::{Cell, RefCell, Ref};\n use std::fmt;\n use syntax::ast;\n use errors::DiagnosticBuilder;\n@@ -72,39 +72,14 @@ pub type Bound<T> = Option<T>;\n pub type UnitResult<'tcx> = RelateResult<'tcx, ()>; // \"unify result\"\n pub type FixupResult<T> = Result<T, FixupError>; // \"fixup result\"\n \n-/// A version of &ty::TypeckTables which can be `Missing` (not needed),\n-/// `InProgress` (during typeck) or `Interned` (result of typeck).\n-/// Only the `InProgress` version supports `borrow_mut`.\n-#[derive(Copy, Clone)]\n-pub enum InferTables<'a, 'tcx: 'a> {\n-    InProgress(&'a RefCell<ty::TypeckTables<'tcx>>),\n-    Missing\n-}\n-\n-impl<'a, 'tcx> InferTables<'a, 'tcx> {\n-    pub fn borrow(self) -> Ref<'a, ty::TypeckTables<'tcx>> {\n-        match self {\n-            InferTables::InProgress(tables) => tables.borrow(),\n-            InferTables::Missing => {\n-                bug!(\"InferTables: infcx.tables.borrow() with no tables\")\n-            }\n-        }\n-    }\n-\n-    pub fn borrow_mut(self) -> RefMut<'a, ty::TypeckTables<'tcx>> {\n-        match self {\n-            InferTables::InProgress(tables) => tables.borrow_mut(),\n-            InferTables::Missing => {\n-                bug!(\"InferTables: infcx.tables.borrow_mut() with no tables\")\n-            }\n-        }\n-    }\n-}\n-\n pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n \n-    pub tables: InferTables<'a, 'tcx>,\n+    /// During type-checking/inference of a body, `in_progress_tables`\n+    /// contains a reference to the tables being built up, which are\n+    /// used for reading closure kinds/signatures as they are inferred,\n+    /// and for error reporting logic to read arbitrary node types.\n+    pub in_progress_tables: Option<&'a RefCell<ty::TypeckTables<'tcx>>>,\n \n     // Cache for projections. This cache is snapshotted along with the\n     // infcx.\n@@ -360,23 +335,7 @@ impl fmt::Display for FixupError {\n     }\n }\n \n-pub trait InferEnv<'a, 'tcx> {\n-    fn fresh_tables(self) -> Option<ty::TypeckTables<'tcx>>;\n-}\n-\n-impl<'a, 'tcx> InferEnv<'a, 'tcx> for () {\n-    fn fresh_tables(self) -> Option<ty::TypeckTables<'tcx>> {\n-        None\n-    }\n-}\n-\n-impl<'a, 'tcx> InferEnv<'a, 'tcx> for ty::TypeckTables<'tcx> {\n-    fn fresh_tables(self) -> Option<ty::TypeckTables<'tcx>> {\n-        Some(self)\n-    }\n-}\n-\n-/// Helper type of a temporary returned by tcx.infer_ctxt(...).\n+/// Helper type of a temporary returned by tcx.infer_ctxt().\n /// Necessary because we can't write the following bound:\n /// F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(InferCtxt<'b, 'gcx, 'tcx>).\n pub struct InferCtxtBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n@@ -386,16 +345,23 @@ pub struct InferCtxtBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n-    pub fn infer_ctxt<E: InferEnv<'a, 'gcx>>(self, env: E) -> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n+    pub fn infer_ctxt(self) -> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n         InferCtxtBuilder {\n             global_tcx: self,\n             arena: DroplessArena::new(),\n-            fresh_tables: env.fresh_tables().map(RefCell::new),\n+            fresh_tables: None,\n         }\n     }\n }\n \n impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n+    /// Used only by `rustc_typeck` during body type-checking/inference,\n+    /// will initialize `in_progress_tables` with fresh `TypeckTables`.\n+    pub fn with_fresh_in_progress_tables(mut self) -> Self {\n+        self.fresh_tables = Some(RefCell::new(ty::TypeckTables::empty()));\n+        self\n+    }\n+\n     pub fn enter<F, R>(&'tcx mut self, f: F) -> R\n         where F: for<'b> FnOnce(InferCtxt<'b, 'gcx, 'tcx>) -> R\n     {\n@@ -404,11 +370,10 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n             ref arena,\n             ref fresh_tables,\n         } = *self;\n-        let tables = fresh_tables.as_ref()\n-            .map_or(InferTables::Missing, InferTables::InProgress);\n+        let in_progress_tables = fresh_tables.as_ref();\n         global_tcx.enter_local(arena, |tcx| f(InferCtxt {\n-            tcx: tcx,\n-            tables: tables,\n+            tcx,\n+            in_progress_tables,\n             projection_cache: RefCell::new(traits::ProjectionCache::new()),\n             type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n             int_unification_table: RefCell::new(UnificationTable::new()),\n@@ -531,7 +496,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n             return value;\n         }\n \n-        self.infer_ctxt(()).enter(|infcx| {\n+        self.infer_ctxt().enter(|infcx| {\n             value.trans_normalize(&infcx, param_env)\n         })\n     }\n@@ -553,7 +518,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n             return value;\n         }\n \n-        self.infer_ctxt(()).enter(|infcx| {\n+        self.infer_ctxt().enter(|infcx| {\n             value.trans_normalize(&infcx, env.reveal_all())\n        })\n     }\n@@ -757,10 +722,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             was_in_snapshot: in_snapshot,\n             // Borrow tables \"in progress\" (i.e. during typeck)\n             // to ban writes from within a snapshot to them.\n-            _in_progress_tables: match self.tables {\n-                InferTables::InProgress(ref tables) => tables.try_borrow().ok(),\n-                _ => None\n-            }\n+            _in_progress_tables: self.in_progress_tables.map(|tables| {\n+                tables.borrow()\n+            })\n         }\n     }\n \n@@ -1366,14 +1330,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                  span: Span)\n                                  -> bool {\n         let ty = self.resolve_type_vars_if_possible(&ty);\n-        if let Some((param_env, ty)) = self.tcx.lift_to_global(&(param_env, ty)) {\n-            // Even if the type may have no inference variables, during\n-            // type-checking closure types are in local tables only.\n-            let local_closures = match self.tables {\n-                InferTables::InProgress(_) => ty.has_closure_types(),\n-                _ => false\n-            };\n-            if !local_closures {\n+        // Even if the type may have no inference variables, during\n+        // type-checking closure types are in local tables only.\n+        if !self.in_progress_tables.is_some() || !ty.has_closure_types() {\n+            if let Some((param_env, ty)) = self.tcx.lift_to_global(&(param_env, ty)) {\n                 return ty.moves_by_default(self.tcx.global_tcx(), param_env, span);\n             }\n         }\n@@ -1391,7 +1351,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         def_id: DefId)\n                         -> Option<ty::ClosureKind>\n     {\n-        if let InferTables::InProgress(tables) = self.tables {\n+        if let Some(tables) = self.in_progress_tables {\n             if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n                 return tables.borrow()\n                              .closure_kinds\n@@ -1409,7 +1369,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn closure_type(&self, def_id: DefId) -> ty::PolyFnSig<'tcx> {\n-        if let InferTables::InProgress(tables) = self.tables {\n+        if let Some(tables) = self.in_progress_tables {\n             if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n                 if let Some(&ty) = tables.borrow().closure_tys.get(&id) {\n                     return ty;"}, {"sha": "64438f586d7f515fe8de9b83c1f6b96152b60df3", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=fc5c31c48cf19757ebf4b750efa34e7cb5f995e3", "patch": "@@ -29,7 +29,7 @@ use hir::{self, intravisit, Local, Pat, Body};\n use hir::intravisit::{Visitor, NestedVisitorMap};\n use hir::map::NodeExpr;\n use hir::def_id::DefId;\n-use infer::{self, InferCtxt, InferTables};\n+use infer::{self, InferCtxt};\n use infer::type_variable::TypeVariableOrigin;\n use rustc::lint::builtin::EXTRA_REQUIREMENT_IN_IMPL;\n use std::fmt;\n@@ -72,9 +72,12 @@ struct FindLocalByTypeVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n }\n \n impl<'a, 'gcx, 'tcx> FindLocalByTypeVisitor<'a, 'gcx, 'tcx> {\n-    fn node_matches_type(&mut self, node_id: &'gcx NodeId) -> bool {\n-        match self.infcx.tables.borrow().node_types.get(node_id) {\n-            Some(&ty) => {\n+    fn node_matches_type(&mut self, node_id: NodeId) -> bool {\n+        let ty_opt = self.infcx.in_progress_tables.and_then(|tables| {\n+            tables.borrow().node_id_to_type_opt(node_id)\n+        });\n+        match ty_opt {\n+            Some(ty) => {\n                 let ty = self.infcx.resolve_type_vars_if_possible(&ty);\n                 ty.walk().any(|inner_ty| {\n                     inner_ty == *self.target_ty || match (&inner_ty.sty, &self.target_ty.sty) {\n@@ -88,7 +91,7 @@ impl<'a, 'gcx, 'tcx> FindLocalByTypeVisitor<'a, 'gcx, 'tcx> {\n                     }\n                 })\n             }\n-            _ => false,\n+            None => false,\n         }\n     }\n }\n@@ -99,15 +102,15 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindLocalByTypeVisitor<'a, 'gcx, 'tcx> {\n     }\n \n     fn visit_local(&mut self, local: &'gcx Local) {\n-        if self.found_local_pattern.is_none() && self.node_matches_type(&local.id) {\n+        if self.found_local_pattern.is_none() && self.node_matches_type(local.id) {\n             self.found_local_pattern = Some(&*local.pat);\n         }\n         intravisit::walk_local(self, local);\n     }\n \n     fn visit_body(&mut self, body: &'gcx Body) {\n         for argument in &body.arguments {\n-            if self.found_arg_pattern.is_none() && self.node_matches_type(&argument.id) {\n+            if self.found_arg_pattern.is_none() && self.node_matches_type(argument.id) {\n                 self.found_arg_pattern = Some(&*argument.pat);\n             }\n         }\n@@ -654,7 +657,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n                         // Additional context information explaining why the closure only implements\n                         // a particular trait.\n-                        if let InferTables::InProgress(tables) = self.tables {\n+                        if let Some(tables) = self.in_progress_tables {\n                             match tables.borrow().closure_kinds.get(&node_id) {\n                                 Some(&(ty::ClosureKind::FnOnce, Some((span, name)))) => {\n                                     err.span_note(span, &format!("}, {"sha": "3ce7ee847cca6547e6b3b506b73bede769c8afcc", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=fc5c31c48cf19757ebf4b750efa34e7cb5f995e3", "patch": "@@ -484,7 +484,7 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let elaborated_env = ty::ParamEnv::new(tcx.intern_predicates(&predicates),\n                                            unnormalized_env.reveal);\n \n-    tcx.infer_ctxt(()).enter(|infcx| {\n+    tcx.infer_ctxt().enter(|infcx| {\n         let predicates = match fully_normalize(\n             &infcx,\n             cause,\n@@ -598,7 +598,7 @@ pub fn normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     debug!(\"normalize_and_test_predicates(predicates={:?})\",\n            predicates);\n \n-    tcx.infer_ctxt(()).enter(|infcx| {\n+    tcx.infer_ctxt().enter(|infcx| {\n         let param_env = ty::ParamEnv::empty(Reveal::All);\n         let mut selcx = SelectionContext::new(&infcx);\n         let mut fulfill_cx = FulfillmentContext::new();"}, {"sha": "18734e2dbc3f19f4d75cd9485f8dfb224e684360", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=fc5c31c48cf19757ebf4b750efa34e7cb5f995e3", "patch": "@@ -125,7 +125,7 @@ pub fn find_associated_item<'a, 'tcx>(\n     let ancestors = trait_def.ancestors(tcx, impl_data.impl_def_id);\n     match ancestors.defs(tcx, item.name, item.kind).next() {\n         Some(node_item) => {\n-            let substs = tcx.infer_ctxt(()).enter(|infcx| {\n+            let substs = tcx.infer_ctxt().enter(|infcx| {\n                 let param_env = ty::ParamEnv::empty(Reveal::All);\n                 let substs = substs.rebase_onto(tcx, trait_def_id, impl_data.substs);\n                 let substs = translate_substs(&infcx, param_env, impl_data.impl_def_id,\n@@ -188,7 +188,7 @@ pub fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let impl1_trait_ref = tcx.impl_trait_ref(impl1_def_id).unwrap();\n \n     // Create a infcx, taking the predicates of impl1 as assumptions:\n-    let result = tcx.infer_ctxt(()).enter(|infcx| {\n+    let result = tcx.infer_ctxt().enter(|infcx| {\n         // Normalize the trait reference. The WF rules ought to ensure\n         // that this always succeeds.\n         let impl1_trait_ref ="}, {"sha": "f80caeec460facf955f6ea261bb2b72109feda3c", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=fc5c31c48cf19757ebf4b750efa34e7cb5f995e3", "patch": "@@ -109,7 +109,7 @@ impl<'a, 'gcx, 'tcx> Children {\n             let possible_sibling = *slot;\n \n             let tcx = tcx.global_tcx();\n-            let (le, ge) = tcx.infer_ctxt(()).enter(|infcx| {\n+            let (le, ge) = tcx.infer_ctxt().enter(|infcx| {\n                 let overlap = traits::overlapping_impls(&infcx,\n                                                         possible_sibling,\n                                                         impl_def_id);"}, {"sha": "734ba2a2d39096ade9dff9b37dc1ca926b724a36", "filename": "src/librustc/traits/trans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs?ref=fc5c31c48cf19757ebf4b750efa34e7cb5f995e3", "patch": "@@ -46,7 +46,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n \n             // Do the initial selection for the obligation. This yields the\n             // shallow result we are looking for -- that is, what specific impl.\n-            self.infer_ctxt(()).enter(|infcx| {\n+            self.infer_ctxt().enter(|infcx| {\n                 let mut selcx = SelectionContext::new(&infcx);\n \n                 let param_env = ty::ParamEnv::empty(Reveal::All);"}, {"sha": "a7029ac5fa9f11600d77c0b994532dbea48646b1", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=fc5c31c48cf19757ebf4b750efa34e7cb5f995e3", "patch": "@@ -175,7 +175,7 @@ impl<'tcx> ty::ParamEnv<'tcx> {\n                                        self_type: Ty<'tcx>, span: Span)\n                                        -> Result<(), CopyImplementationError<'tcx>> {\n         // FIXME: (@jroesch) float this code up\n-        tcx.infer_ctxt(()).enter(|infcx| {\n+        tcx.infer_ctxt().enter(|infcx| {\n             let (adt, substs) = match self_type.sty {\n                 ty::TyAdt(adt, substs) => (adt, substs),\n                 _ => return Err(CopyImplementationError::NotAnAdt),\n@@ -977,7 +977,7 @@ fn is_copy_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n {\n     let (param_env, ty) = query.into_parts();\n     let trait_def_id = tcx.require_lang_item(lang_items::CopyTraitLangItem);\n-    tcx.infer_ctxt(())\n+    tcx.infer_ctxt()\n        .enter(|infcx| traits::type_known_to_meet_bound(&infcx,\n                                                        param_env,\n                                                        ty,\n@@ -991,7 +991,7 @@ fn is_sized_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n {\n     let (param_env, ty) = query.into_parts();\n     let trait_def_id = tcx.require_lang_item(lang_items::SizedTraitLangItem);\n-    tcx.infer_ctxt(())\n+    tcx.infer_ctxt()\n        .enter(|infcx| traits::type_known_to_meet_bound(&infcx,\n                                                        param_env,\n                                                        ty,\n@@ -1005,7 +1005,7 @@ fn is_freeze_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n {\n     let (param_env, ty) = query.into_parts();\n     let trait_def_id = tcx.require_lang_item(lang_items::FreezeTraitLangItem);\n-    tcx.infer_ctxt(())\n+    tcx.infer_ctxt()\n        .enter(|infcx| traits::type_known_to_meet_bound(&infcx,\n                                                        param_env,\n                                                        ty,"}, {"sha": "ec7510546a044e01ff4c9641647837e922813f69", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=fc5c31c48cf19757ebf4b750efa34e7cb5f995e3", "patch": "@@ -483,7 +483,7 @@ fn resolve_trait_associated_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     debug!(\"resolve_trait_associated_const: trait_ref={:?}\",\n            trait_ref);\n \n-    tcx.infer_ctxt(()).enter(|infcx| {\n+    tcx.infer_ctxt().enter(|infcx| {\n         let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n         let mut selcx = traits::SelectionContext::new(&infcx);\n         let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),"}, {"sha": "62e20a90f8a0860e3b37543472a4e1390d062085", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=fc5c31c48cf19757ebf4b750efa34e7cb5f995e3", "patch": "@@ -154,7 +154,7 @@ fn test_env<F>(source_string: &str,\n                              index,\n                              \"test_crate\",\n                              |tcx| {\n-        tcx.infer_ctxt(()).enter(|infcx| {\n+        tcx.infer_ctxt().enter(|infcx| {\n             let mut region_maps = RegionMaps::new();\n             body(Env {\n                 infcx: &infcx,"}, {"sha": "9800012917c504475cc494efa845d302c6b47f1f", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=fc5c31c48cf19757ebf4b750efa34e7cb5f995e3", "patch": "@@ -956,7 +956,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n                                                 cx.param_env,\n                                                 trait_ref.to_poly_trait_predicate());\n \n-                    tcx.infer_ctxt(()).enter(|infcx| {\n+                    tcx.infer_ctxt().enter(|infcx| {\n                         let mut selcx = traits::SelectionContext::new(&infcx);\n                         match selcx.select(&obligation) {\n                             // The method comes from a `T: Trait` bound."}, {"sha": "56c0e18d6f91a39b3897f869cd1ef9cc2f4b4783", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=fc5c31c48cf19757ebf4b750efa34e7cb5f995e3", "patch": "@@ -83,7 +83,7 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n     };\n \n     let src = MirSource::from_node(tcx, id);\n-    tcx.infer_ctxt(()).enter(|infcx| {\n+    tcx.infer_ctxt().enter(|infcx| {\n         let cx = Cx::new(&infcx, src);\n         let mut mir = if cx.tables().tainted_by_errors {\n             build::construct_error(cx, body_id)\n@@ -171,7 +171,7 @@ fn create_constructor_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n {\n     let span = tcx.hir.span(ctor_id);\n     if let hir::VariantData::Tuple(ref fields, ctor_id) = *v {\n-        tcx.infer_ctxt(()).enter(|infcx| {\n+        tcx.infer_ctxt().enter(|infcx| {\n             let (mut mir, src) =\n                 shim::build_adt_ctor(&infcx, ctor_id, fields, span);\n "}, {"sha": "d60e761bc0b948e4c50462a5e9584d522e683922", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=fc5c31c48cf19757ebf4b750efa34e7cb5f995e3", "patch": "@@ -998,7 +998,7 @@ impl MirPass for QualifyAndPromoteConstants {\n         // Statics must be Sync.\n         if mode == Mode::Static {\n             let ty = mir.return_ty;\n-            tcx.infer_ctxt(()).enter(|infcx| {\n+            tcx.infer_ctxt().enter(|infcx| {\n                 let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n                 let cause = traits::ObligationCause::new(mir.span, id, traits::SharedStatic);\n                 let mut fulfillment_cx = traits::FulfillmentContext::new();"}, {"sha": "e23f0705b6a028dc83b2d00d91c608877d868b27", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=fc5c31c48cf19757ebf4b750efa34e7cb5f995e3", "patch": "@@ -759,7 +759,7 @@ impl MirPass for TypeckMir {\n             return;\n         }\n         let param_env = tcx.param_env(def_id);\n-        tcx.infer_ctxt(()).enter(|infcx| {\n+        tcx.infer_ctxt().enter(|infcx| {\n             let mut checker = TypeChecker::new(&infcx, item_id, param_env);\n             {\n                 let mut verifier = TypeVerifier::new(&mut checker, mir);"}, {"sha": "29742469f84d95d8077c113b0f02df22214bff89", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=fc5c31c48cf19757ebf4b750efa34e7cb5f995e3", "patch": "@@ -219,7 +219,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                          param_env,\n                                                          normalize_cause.clone());\n \n-    tcx.infer_ctxt(()).enter(|infcx| {\n+    tcx.infer_ctxt().enter(|infcx| {\n         let inh = Inherited::new(infcx, impl_m.def_id);\n         let infcx = &inh.infcx;\n \n@@ -726,7 +726,7 @@ pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                     impl_trait_ref: ty::TraitRef<'tcx>) {\n     debug!(\"compare_const_impl(impl_trait_ref={:?})\", impl_trait_ref);\n \n-    tcx.infer_ctxt(()).enter(|infcx| {\n+    tcx.infer_ctxt().enter(|infcx| {\n         let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n         let inh = Inherited::new(infcx, impl_c.def_id);\n         let infcx = &inh.infcx;"}, {"sha": "93057f91997daf2af2b6c2aa952a40fbbf45395d", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=fc5c31c48cf19757ebf4b750efa34e7cb5f995e3", "patch": "@@ -79,7 +79,7 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n \n     // check that the impl type can be made to match the trait type.\n \n-    tcx.infer_ctxt(()).enter(|ref infcx| {\n+    tcx.infer_ctxt().enter(|ref infcx| {\n         let impl_param_env = tcx.param_env(self_type_did);\n         let tcx = infcx.tcx;\n         let mut fulfillment_cx = traits::FulfillmentContext::new();"}, {"sha": "844065cb3348e5d57ce20f313c3b7541485dd0d5", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 38, "deletions": 11, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=fc5c31c48cf19757ebf4b750efa34e7cb5f995e3", "patch": "@@ -108,7 +108,7 @@ use lint;\n use util::common::{ErrorReported, indenter};\n use util::nodemap::{DefIdMap, FxHashMap, NodeMap};\n \n-use std::cell::{Cell, RefCell};\n+use std::cell::{Cell, RefCell, Ref, RefMut};\n use std::collections::hash_map::Entry;\n use std::cmp;\n use std::mem::replace;\n@@ -147,6 +147,33 @@ mod compare_method;\n mod intrinsic;\n mod op;\n \n+/// A wrapper for InferCtxt's `in_progress_tables` field.\n+#[derive(Copy, Clone)]\n+struct MaybeInProgressTables<'a, 'tcx: 'a> {\n+    maybe_tables: Option<&'a RefCell<ty::TypeckTables<'tcx>>>,\n+}\n+\n+impl<'a, 'tcx> MaybeInProgressTables<'a, 'tcx> {\n+    fn borrow(self) -> Ref<'a, ty::TypeckTables<'tcx>> {\n+        match self.maybe_tables {\n+            Some(tables) => tables.borrow(),\n+            None => {\n+                bug!(\"MaybeInProgressTables: inh/fcx.tables.borrow() with no tables\")\n+            }\n+        }\n+    }\n+\n+    fn borrow_mut(self) -> RefMut<'a, ty::TypeckTables<'tcx>> {\n+        match self.maybe_tables {\n+            Some(tables) => tables.borrow_mut(),\n+            None => {\n+                bug!(\"MaybeInProgressTables: inh/fcx.tables.borrow_mut() with no tables\")\n+            }\n+        }\n+    }\n+}\n+\n+\n /// closures defined within the function.  For example:\n ///\n ///     fn foo() {\n@@ -159,6 +186,8 @@ mod op;\n pub struct Inherited<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     infcx: InferCtxt<'a, 'gcx, 'tcx>,\n \n+    tables: MaybeInProgressTables<'a, 'tcx>,\n+\n     locals: RefCell<NodeMap<Ty<'tcx>>>,\n \n     fulfillment_cx: RefCell<traits::FulfillmentContext<'tcx>>,\n@@ -535,9 +564,8 @@ pub struct InheritedBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n     pub fn build(tcx: TyCtxt<'a, 'gcx, 'gcx>, def_id: DefId)\n                  -> InheritedBuilder<'a, 'gcx, 'tcx> {\n-        let tables = ty::TypeckTables::empty();\n         InheritedBuilder {\n-            infcx: tcx.infer_ctxt(tables),\n+            infcx: tcx.infer_ctxt().with_fresh_in_progress_tables(),\n             def_id,\n         }\n     }\n@@ -562,6 +590,9 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n         });\n \n         Inherited {\n+            tables: MaybeInProgressTables {\n+                maybe_tables: infcx.in_progress_tables,\n+            },\n             infcx: infcx,\n             fulfillment_cx: RefCell::new(traits::FulfillmentContext::new()),\n             locals: RefCell::new(NodeMap()),\n@@ -3302,14 +3333,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             self.check_expr_has_type(base_expr, struct_ty);\n             match struct_ty.sty {\n                 ty::TyAdt(adt, substs) if adt.is_struct() => {\n-                    self.tables.borrow_mut().fru_field_types.insert(\n-                        expr.id,\n-                        adt.struct_variant().fields.iter().map(|f| {\n-                            self.normalize_associated_types_in(\n-                                expr.span, &f.ty(self.tcx, substs)\n-                            )\n-                        }).collect()\n-                    );\n+                    let fru_field_types = adt.struct_variant().fields.iter().map(|f| {\n+                        self.normalize_associated_types_in(expr.span, &f.ty(self.tcx, substs))\n+                    }).collect();\n+                    self.tables.borrow_mut().fru_field_types.insert(expr.id, fru_field_types);\n                 }\n                 _ => {\n                     span_err!(self.tcx.sess, base_expr.span, E0436,"}, {"sha": "ccbc02990418f2b89088f5b1d20c7ae891de25e5", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=fc5c31c48cf19757ebf4b750efa34e7cb5f995e3", "patch": "@@ -208,7 +208,7 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n            source,\n            target);\n \n-    tcx.infer_ctxt(()).enter(|infcx| {\n+    tcx.infer_ctxt().enter(|infcx| {\n         let cause = ObligationCause::misc(span, impl_node_id);\n         let check_mutbl = |mt_a: ty::TypeAndMut<'tcx>,\n                            mt_b: ty::TypeAndMut<'tcx>,"}, {"sha": "078ae34bc524c41cc9830964b1a35955d52d6aff", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=fc5c31c48cf19757ebf4b750efa34e7cb5f995e3", "patch": "@@ -70,7 +70,7 @@ impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n \n         for (i, &impl1_def_id) in impls.iter().enumerate() {\n             for &impl2_def_id in &impls[(i + 1)..] {\n-                self.tcx.infer_ctxt(()).enter(|infcx| {\n+                self.tcx.infer_ctxt().enter(|infcx| {\n                     if traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id).is_some() {\n                         self.check_for_common_items_in_impls(impl1_def_id, impl2_def_id)\n                     }"}, {"sha": "26ea3ab3a3358aa3d5f30c083b83205155ffbdc2", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=fc5c31c48cf19757ebf4b750efa34e7cb5f995e3", "patch": "@@ -155,7 +155,7 @@ fn require_same_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 expected: Ty<'tcx>,\n                                 actual: Ty<'tcx>)\n                                 -> bool {\n-    tcx.infer_ctxt(()).enter(|ref infcx| {\n+    tcx.infer_ctxt().enter(|ref infcx| {\n         let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n         let mut fulfill_cx = FulfillmentContext::new();\n         match infcx.at(&cause, param_env).eq(expected, actual) {"}]}