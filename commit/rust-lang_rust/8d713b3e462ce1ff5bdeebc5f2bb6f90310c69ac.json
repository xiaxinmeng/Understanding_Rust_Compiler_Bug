{"sha": "8d713b3e462ce1ff5bdeebc5f2bb6f90310c69ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkNzEzYjNlNDYyY2UxZmY1YmRlZWJjNWYyYmI2ZjkwMzEwYzY5YWM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-05-20T18:41:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-20T18:41:26Z"}, "message": "Merge #8900\n\n8900: internal: support `#[register_attr]` and `#[register_tool]` r=jonas-schievink a=jonas-schievink\n\nRelatively straightforward since these are crate-local.\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "024719fdb69de56eadad477026a2df230cf66a1f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/024719fdb69de56eadad477026a2df230cf66a1f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d713b3e462ce1ff5bdeebc5f2bb6f90310c69ac", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgpq1WCRBK7hj4Ov3rIwAASsUIAHJHsR+ZnUM8MBsySVi66GoN\nXTnlOBwmTRfFS+WF/jOzVWUOvZVa0R/MklnDalSpjftRVtm5chlDg4JFtpXLypD1\n0C6CZvXisMHTZ3K61K9mVwBuvP6BBHOb0Xz+fMvebbHllUg+2aYefWcSbXiflIjw\nrca0Cf++VY9BVPTIWEV7eET/2z5Fv3/o3Xv3XEaTmh9/Ebsfu5ZgnJq3IBU2Z0im\nz0mq/qk6fsni+dy69tJD1TT/xBB4LobMWcM5o43OTRSh9BwfQg/Enn9vMtGG/AWs\n0u+0+a18TVC/3BTzvNvuHjz64jFAbSHlxmj7cJVuYpbRN9EOmTqoMsoSnDOpuKg=\n=kfyn\n-----END PGP SIGNATURE-----\n", "payload": "tree 024719fdb69de56eadad477026a2df230cf66a1f\nparent 9b94a2781357e1965e33e7ca48bdbcd35e9b8dff\nparent 6f19484c93b1d3bcbef8a271443742a3db3e8fae\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1621536086 +0000\ncommitter GitHub <noreply@github.com> 1621536086 +0000\n\nMerge #8900\n\n8900: internal: support `#[register_attr]` and `#[register_tool]` r=jonas-schievink a=jonas-schievink\n\nRelatively straightforward since these are crate-local.\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d713b3e462ce1ff5bdeebc5f2bb6f90310c69ac", "html_url": "https://github.com/rust-lang/rust/commit/8d713b3e462ce1ff5bdeebc5f2bb6f90310c69ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d713b3e462ce1ff5bdeebc5f2bb6f90310c69ac/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b94a2781357e1965e33e7ca48bdbcd35e9b8dff", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b94a2781357e1965e33e7ca48bdbcd35e9b8dff", "html_url": "https://github.com/rust-lang/rust/commit/9b94a2781357e1965e33e7ca48bdbcd35e9b8dff"}, {"sha": "6f19484c93b1d3bcbef8a271443742a3db3e8fae", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f19484c93b1d3bcbef8a271443742a3db3e8fae", "html_url": "https://github.com/rust-lang/rust/commit/6f19484c93b1d3bcbef8a271443742a3db3e8fae"}], "stats": {"total": 138, "additions": 100, "deletions": 38}, "files": [{"sha": "e76d039b8a51bfe5a7742541580eee53a2c0e92a", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 81, "deletions": 38, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/8d713b3e462ce1ff5bdeebc5f2bb6f90310c69ac/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d713b3e462ce1ff5bdeebc5f2bb6f90310c69ac/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=8d713b3e462ce1ff5bdeebc5f2bb6f90310c69ac", "patch": "@@ -20,7 +20,7 @@ use rustc_hash::{FxHashMap, FxHashSet};\n use syntax::ast;\n \n use crate::{\n-    attr::{Attr, AttrId, Attrs},\n+    attr::{Attr, AttrId, AttrInput, Attrs},\n     builtin_attr,\n     db::DefDatabase,\n     derive_macro_as_call_id,\n@@ -100,8 +100,10 @@ pub(super) fn collect_defs(\n         proc_macros,\n         exports_proc_macros: false,\n         from_glob_import: Default::default(),\n-        ignore_attrs_on: Default::default(),\n+        skip_attrs: Default::default(),\n         derive_helpers_in_scope: Default::default(),\n+        registered_attrs: Default::default(),\n+        registered_tools: Default::default(),\n     };\n     match block {\n         Some(block) => {\n@@ -253,10 +255,14 @@ struct DefCollector<'a> {\n     ///\n     /// This also stores the attributes to skip when we resolve derive helpers and non-macro\n     /// non-builtin attributes in general.\n-    ignore_attrs_on: FxHashMap<InFile<ModItem>, AttrId>,\n+    skip_attrs: FxHashMap<InFile<ModItem>, AttrId>,\n     /// Tracks which custom derives are in scope for an item, to allow resolution of derive helper\n     /// attributes.\n     derive_helpers_in_scope: FxHashMap<AstId<ast::Item>, Vec<Name>>,\n+    /// Custom attributes registered with `#![register_attr]`.\n+    registered_attrs: Vec<String>,\n+    /// Custom tool modules registered with `#![register_tool]`.\n+    registered_tools: Vec<String>,\n }\n \n impl DefCollector<'_> {\n@@ -265,11 +271,39 @@ impl DefCollector<'_> {\n         let item_tree = self.db.file_item_tree(file_id.into());\n         let module_id = self.def_map.root;\n         self.def_map.modules[module_id].origin = ModuleOrigin::CrateRoot { definition: file_id };\n-        if item_tree\n-            .top_level_attrs(self.db, self.def_map.krate)\n-            .cfg()\n-            .map_or(true, |cfg| self.cfg_options.check(&cfg) != Some(false))\n-        {\n+\n+        let attrs = item_tree.top_level_attrs(self.db, self.def_map.krate);\n+        if attrs.cfg().map_or(true, |cfg| self.cfg_options.check(&cfg) != Some(false)) {\n+            // Process other crate-level attributes.\n+            for attr in &*attrs {\n+                let attr_name = match attr.path.as_ident() {\n+                    Some(name) => name,\n+                    None => continue,\n+                };\n+\n+                let registered_name = if *attr_name == hir_expand::name![register_attr]\n+                    || *attr_name == hir_expand::name![register_tool]\n+                {\n+                    match &attr.input {\n+                        Some(AttrInput::TokenTree(subtree)) => match &*subtree.token_trees {\n+                            [tt::TokenTree::Leaf(tt::Leaf::Ident(name))] => name.as_name(),\n+                            _ => continue,\n+                        },\n+                        _ => continue,\n+                    }\n+                } else {\n+                    continue;\n+                };\n+\n+                if *attr_name == hir_expand::name![register_attr] {\n+                    self.registered_attrs.push(registered_name.to_string());\n+                    cov_mark::hit!(register_attr);\n+                } else {\n+                    self.registered_tools.push(registered_name.to_string());\n+                    cov_mark::hit!(register_tool);\n+                }\n+            }\n+\n             ModCollector {\n                 def_collector: &mut *self,\n                 macro_depth: 0,\n@@ -382,7 +416,7 @@ impl DefCollector<'_> {\n         let mut unresolved_macros = std::mem::replace(&mut self.unresolved_macros, Vec::new());\n         let pos = unresolved_macros.iter().position(|directive| {\n             if let MacroDirectiveKind::Attr { ast_id, mod_item, attr } = &directive.kind {\n-                self.ignore_attrs_on.insert(ast_id.ast_id.with_value(*mod_item), *attr);\n+                self.skip_attrs.insert(ast_id.ast_id.with_value(*mod_item), *attr);\n \n                 let file_id = ast_id.ast_id.file_id;\n                 let item_tree = self.db.file_item_tree(file_id);\n@@ -941,7 +975,7 @@ impl DefCollector<'_> {\n                                 let file_id = ast_id.ast_id.file_id;\n                                 let item_tree = self.db.file_item_tree(file_id);\n                                 let mod_dir = self.mod_dirs[&directive.module_id].clone();\n-                                self.ignore_attrs_on.insert(InFile::new(file_id, *mod_item), *attr);\n+                                self.skip_attrs.insert(InFile::new(file_id, *mod_item), *attr);\n                                 ModCollector {\n                                     def_collector: &mut *self,\n                                     macro_depth: directive.depth,\n@@ -1479,32 +1513,8 @@ impl ModCollector<'_, '_> {\n     /// If `ignore_up_to` is `Some`, attributes precending and including that attribute will be\n     /// assumed to be resolved already.\n     fn resolve_attributes(&mut self, attrs: &Attrs, mod_item: ModItem) -> Result<(), ()> {\n-        fn is_builtin_attr(path: &ModPath) -> bool {\n-            if path.kind == PathKind::Plain {\n-                if let Some(tool_module) = path.segments().first() {\n-                    let tool_module = tool_module.to_string();\n-                    if builtin_attr::TOOL_MODULES.iter().any(|m| tool_module == *m) {\n-                        return true;\n-                    }\n-                }\n-\n-                if let Some(name) = path.as_ident() {\n-                    let name = name.to_string();\n-                    if builtin_attr::INERT_ATTRIBUTES\n-                        .iter()\n-                        .chain(builtin_attr::EXTRA_ATTRIBUTES)\n-                        .any(|attr| name == *attr)\n-                    {\n-                        return true;\n-                    }\n-                }\n-            }\n-\n-            false\n-        }\n-\n         let mut ignore_up_to =\n-            self.def_collector.ignore_attrs_on.get(&InFile::new(self.file_id, mod_item)).copied();\n+            self.def_collector.skip_attrs.get(&InFile::new(self.file_id, mod_item)).copied();\n         for attr in attrs.iter().skip_while(|attr| match ignore_up_to {\n             Some(id) if attr.id == id => {\n                 ignore_up_to = None;\n@@ -1515,7 +1525,7 @@ impl ModCollector<'_, '_> {\n         }) {\n             if attr.path.as_ident() == Some(&hir_expand::name![derive]) {\n                 self.collect_derive(attr, mod_item);\n-            } else if is_builtin_attr(&attr.path) {\n+            } else if self.is_builtin_or_registered_attr(&attr.path) {\n                 continue;\n             } else {\n                 log::debug!(\"non-builtin attribute {}\", attr.path);\n@@ -1538,6 +1548,37 @@ impl ModCollector<'_, '_> {\n         Ok(())\n     }\n \n+    fn is_builtin_or_registered_attr(&self, path: &ModPath) -> bool {\n+        if path.kind == PathKind::Plain {\n+            if let Some(tool_module) = path.segments().first() {\n+                let tool_module = tool_module.to_string();\n+                if builtin_attr::TOOL_MODULES\n+                    .iter()\n+                    .copied()\n+                    .chain(self.def_collector.registered_tools.iter().map(|s| &**s))\n+                    .any(|m| tool_module == *m)\n+                {\n+                    return true;\n+                }\n+            }\n+\n+            if let Some(name) = path.as_ident() {\n+                let name = name.to_string();\n+                if builtin_attr::INERT_ATTRIBUTES\n+                    .iter()\n+                    .chain(builtin_attr::EXTRA_ATTRIBUTES)\n+                    .copied()\n+                    .chain(self.def_collector.registered_attrs.iter().map(|s| &**s))\n+                    .any(|attr| name == *attr)\n+                {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        false\n+    }\n+\n     fn collect_derive(&mut self, attr: &Attr, mod_item: ModItem) {\n         let ast_id: FileAstId<ast::Item> = match mod_item {\n             ModItem::Struct(it) => self.item_tree[it].ast_id.upcast(),\n@@ -1779,8 +1820,10 @@ mod tests {\n             proc_macros: Default::default(),\n             exports_proc_macros: false,\n             from_glob_import: Default::default(),\n-            ignore_attrs_on: Default::default(),\n-            derive_helpers_in_scope: FxHashMap::default(),\n+            skip_attrs: Default::default(),\n+            derive_helpers_in_scope: Default::default(),\n+            registered_attrs: Default::default(),\n+            registered_tools: Default::default(),\n         };\n         collector.seed_with_top_level();\n         collector.collect();"}, {"sha": "75147d973a2dc77db5171917ada8a97dc7ad248e", "filename": "crates/hir_def/src/nameres/tests/diagnostics.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8d713b3e462ce1ff5bdeebc5f2bb6f90310c69ac/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d713b3e462ce1ff5bdeebc5f2bb6f90310c69ac/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fdiagnostics.rs?ref=8d713b3e462ce1ff5bdeebc5f2bb6f90310c69ac", "patch": "@@ -237,3 +237,20 @@ fn good_out_dir_diagnostic() {\n         \"#,\n     );\n }\n+\n+#[test]\n+fn register_attr_and_tool() {\n+    cov_mark::check!(register_attr);\n+    cov_mark::check!(register_tool);\n+    check_no_diagnostics(\n+        r#\"\n+#![register_tool(tool)]\n+#![register_attr(attr)]\n+\n+#[tool::path]\n+#[attr]\n+struct S;\n+        \"#,\n+    );\n+    // NB: we don't currently emit diagnostics here\n+}"}, {"sha": "ef67ea2e99b5d8dd835ea25a355459e2c929bdf2", "filename": "crates/hir_expand/src/name.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d713b3e462ce1ff5bdeebc5f2bb6f90310c69ac/crates%2Fhir_expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d713b3e462ce1ff5bdeebc5f2bb6f90310c69ac/crates%2Fhir_expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fname.rs?ref=8d713b3e462ce1ff5bdeebc5f2bb6f90310c69ac", "patch": "@@ -164,6 +164,8 @@ pub mod known {\n         doc,\n         cfg,\n         cfg_attr,\n+        register_attr,\n+        register_tool,\n         // Components of known path (value or mod name)\n         std,\n         core,"}]}