{"sha": "e4970fe6ffa3052d6b1a880c934d4465bf656df9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0OTcwZmU2ZmZhMzA1MmQ2YjFhODgwYzkzNGQ0NDY1YmY2NTZkZjk=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-04-21T12:34:30Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-04-21T14:48:02Z"}, "message": "Windows: implement heap functions", "tree": {"sha": "102924206dd5b15f48ab03cc3843ed790eff258d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/102924206dd5b15f48ab03cc3843ed790eff258d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4970fe6ffa3052d6b1a880c934d4465bf656df9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4970fe6ffa3052d6b1a880c934d4465bf656df9", "html_url": "https://github.com/rust-lang/rust/commit/e4970fe6ffa3052d6b1a880c934d4465bf656df9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4970fe6ffa3052d6b1a880c934d4465bf656df9/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a87a7338e64001f60704a7bdd7d2ed6bfc64c397", "url": "https://api.github.com/repos/rust-lang/rust/commits/a87a7338e64001f60704a7bdd7d2ed6bfc64c397", "html_url": "https://github.com/rust-lang/rust/commit/a87a7338e64001f60704a7bdd7d2ed6bfc64c397"}], "stats": {"total": 178, "additions": 117, "deletions": 61}, "files": [{"sha": "9789a76c6393eabbd4959f748abe4d8d3bb09718", "filename": "src/fn_call.rs", "status": "modified", "additions": 117, "deletions": 61, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/e4970fe6ffa3052d6b1a880c934d4465bf656df9/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4970fe6ffa3052d6b1a880c934d4465bf656df9/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=e4970fe6ffa3052d6b1a880c934d4465bf656df9", "patch": "@@ -50,6 +50,86 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n         Ok(Some(this.load_mir(instance.def)?))\n     }\n \n+    fn malloc(\n+        &mut self,\n+        size: u64,\n+        zero_init: bool,\n+    ) -> Scalar<Tag> {\n+        let this = self.eval_context_mut();\n+        let tcx = &{this.tcx.tcx};\n+        if size == 0 {\n+            Scalar::from_int(0, this.pointer_size())\n+        } else {\n+            let align = this.tcx.data_layout.pointer_align.abi;\n+            let ptr = this.memory_mut().allocate(Size::from_bytes(size), align, MiriMemoryKind::C.into());\n+            if zero_init {\n+                // We just allocated this, the access cannot fail\n+                this.memory_mut()\n+                    .get_mut(ptr.alloc_id).unwrap()\n+                    .write_repeat(tcx, ptr, 0, Size::from_bytes(size)).unwrap();\n+            }\n+            Scalar::Ptr(ptr)\n+        }\n+    }\n+\n+    fn free(\n+        &mut self,\n+        ptr: Scalar<Tag>,\n+    ) -> EvalResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        if !ptr.is_null_ptr(this) {\n+            this.memory_mut().deallocate(\n+                ptr.to_ptr()?,\n+                None,\n+                MiriMemoryKind::C.into(),\n+            )?;\n+        }\n+        Ok(())\n+    }\n+\n+    fn realloc(\n+        &mut self,\n+        old_ptr: Scalar<Tag>,\n+        new_size: u64,\n+    ) -> EvalResult<'tcx, Scalar<Tag>> {\n+        let this = self.eval_context_mut();\n+        let align = this.tcx.data_layout.pointer_align.abi;\n+        if old_ptr.is_null_ptr(this) {\n+            if new_size == 0 {\n+                Ok(Scalar::from_int(0, this.pointer_size()))\n+            } else {\n+                let new_ptr = this.memory_mut().allocate(\n+                    Size::from_bytes(new_size),\n+                    align,\n+                    MiriMemoryKind::C.into()\n+                );\n+                Ok(Scalar::Ptr(new_ptr))\n+            }\n+        } else {\n+            let old_ptr = old_ptr.to_ptr()?;\n+            let memory = this.memory_mut();\n+            let old_size = Size::from_bytes(memory.get(old_ptr.alloc_id)?.bytes.len() as u64);\n+            if new_size == 0 {\n+                memory.deallocate(\n+                    old_ptr,\n+                    Some((old_size, align)),\n+                    MiriMemoryKind::C.into(),\n+                )?;\n+                Ok(Scalar::from_int(0, this.pointer_size()))\n+            } else {\n+                let new_ptr = memory.reallocate(\n+                    old_ptr,\n+                    old_size,\n+                    align,\n+                    Size::from_bytes(new_size),\n+                    align,\n+                    MiriMemoryKind::C.into(),\n+                )?;\n+                Ok(Scalar::Ptr(new_ptr))\n+            }\n+        }\n+    }\n+\n     /// Emulates calling a foreign item, failing if the item is not supported.\n     /// This function will handle `goto_block` if needed.\n     fn emulate_foreign_item(\n@@ -87,28 +167,15 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n         match link_name {\n             \"malloc\" => {\n                 let size = this.read_scalar(args[0])?.to_usize(this)?;\n-                if size == 0 {\n-                    this.write_null(dest)?;\n-                } else {\n-                    let align = this.tcx.data_layout.pointer_align.abi;\n-                    let ptr = this.memory_mut().allocate(Size::from_bytes(size), align, MiriMemoryKind::C.into());\n-                    this.write_scalar(Scalar::Ptr(ptr), dest)?;\n-                }\n+                let res = this.malloc(size, /*zero_init:*/ false);\n+                this.write_scalar(res, dest)?;\n             }\n             \"calloc\" => {\n                 let items = this.read_scalar(args[0])?.to_usize(this)?;\n                 let len = this.read_scalar(args[1])?.to_usize(this)?;\n-                let bytes = items.checked_mul(len).ok_or_else(|| InterpError::Overflow(mir::BinOp::Mul))?;\n-\n-                if bytes == 0 {\n-                    this.write_null(dest)?;\n-                } else {\n-                    let size = Size::from_bytes(bytes);\n-                    let align = this.tcx.data_layout.pointer_align.abi;\n-                    let ptr = this.memory_mut().allocate(size, align, MiriMemoryKind::C.into());\n-                    this.memory_mut().get_mut(ptr.alloc_id)?.write_repeat(tcx, ptr, 0, size)?;\n-                    this.write_scalar(Scalar::Ptr(ptr), dest)?;\n-                }\n+                let size = items.checked_mul(len).ok_or_else(|| InterpError::Overflow(mir::BinOp::Mul))?;\n+                let res = this.malloc(size, /*zero_init:*/ true);\n+                this.write_scalar(res, dest)?;\n             }\n             \"posix_memalign\" => {\n                 let ret = this.deref_operand(args[0])?;\n@@ -136,55 +203,15 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n                 }\n                 this.write_null(dest)?;\n             }\n-\n             \"free\" => {\n                 let ptr = this.read_scalar(args[0])?.not_undef()?;\n-                if !ptr.is_null_ptr(this) {\n-                    this.memory_mut().deallocate(\n-                        ptr.to_ptr()?,\n-                        None,\n-                        MiriMemoryKind::C.into(),\n-                    )?;\n-                }\n+                this.free(ptr)?;\n             }\n             \"realloc\" => {\n                 let old_ptr = this.read_scalar(args[0])?.not_undef()?;\n                 let new_size = this.read_scalar(args[1])?.to_usize(this)?;\n-                let align = this.tcx.data_layout.pointer_align.abi;\n-                if old_ptr.is_null_ptr(this) {\n-                    if new_size == 0 {\n-                        this.write_null(dest)?;\n-                    } else {\n-                        let new_ptr = this.memory_mut().allocate(\n-                            Size::from_bytes(new_size),\n-                            align,\n-                            MiriMemoryKind::C.into()\n-                        );\n-                        this.write_scalar(Scalar::Ptr(new_ptr), dest)?;\n-                    }\n-                } else {\n-                    let old_ptr = old_ptr.to_ptr()?;\n-                    let memory = this.memory_mut();\n-                    let old_size = Size::from_bytes(memory.get(old_ptr.alloc_id)?.bytes.len() as u64);\n-                    if new_size == 0 {\n-                        memory.deallocate(\n-                            old_ptr,\n-                            Some((old_size, align)),\n-                            MiriMemoryKind::C.into(),\n-                        )?;\n-                        this.write_null(dest)?;\n-                    } else {\n-                        let new_ptr = memory.reallocate(\n-                            old_ptr,\n-                            old_size,\n-                            align,\n-                            Size::from_bytes(new_size),\n-                            align,\n-                            MiriMemoryKind::C.into(),\n-                        )?;\n-                        this.write_scalar(Scalar::Ptr(new_ptr), dest)?;\n-                    }\n-                }\n+                let res = this.realloc(old_ptr, new_size)?;\n+                this.write_scalar(res, dest)?;\n             }\n \n             \"__rust_alloc\" => {\n@@ -687,6 +714,35 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n             },\n \n             // Windows API stubs.\n+            // HANDLE = isize\n+            // DWORD = ULONG = u32\n+            \"GetProcessHeap\" => {\n+                // Just fake a HANDLE\n+                this.write_scalar(Scalar::from_int(1, this.pointer_size()), dest)?;\n+            }\n+            \"HeapAlloc\" => {\n+                let _handle = this.read_scalar(args[0])?.to_isize(this)?;\n+                let flags = this.read_scalar(args[1])?.to_u32()?;\n+                let size = this.read_scalar(args[2])?.to_usize(this)?;\n+                let zero_init = (flags & 0x00000008) != 0; // HEAP_ZERO_MEMORY\n+                let res = this.malloc(size, zero_init);\n+                this.write_scalar(res, dest)?;\n+            }\n+            \"HeapFree\" => {\n+                let _handle = this.read_scalar(args[0])?.to_isize(this)?;\n+                let _flags = this.read_scalar(args[1])?.to_u32()?;\n+                let ptr = this.read_scalar(args[2])?.not_undef()?;\n+                this.free(ptr)?;\n+            }\n+            \"HeapReAlloc\" => {\n+                let _handle = this.read_scalar(args[0])?.to_isize(this)?;\n+                let _flags = this.read_scalar(args[1])?.to_u32()?;\n+                let ptr = this.read_scalar(args[2])?.not_undef()?;\n+                let size = this.read_scalar(args[3])?.to_usize(this)?;\n+                let res = this.realloc(ptr, size)?;\n+                this.write_scalar(res, dest)?;\n+            }\n+\n             \"SetLastError\" => {\n                 let err = this.read_scalar(args[0])?.to_u32()?;\n                 this.machine.last_error = err;"}]}