{"sha": "df4d717d0b150375057bd067356a4c7fe3c27551", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmNGQ3MTdkMGIxNTAzNzUwNTdiZDA2NzM1NmE0YzdmZTNjMjc1NTE=", "commit": {"author": {"name": "oli", "email": "github35764891676564198441@oli-obk.de", "date": "2020-11-01T16:57:03Z"}, "committer": {"name": "oli", "email": "github35764891676564198441@oli-obk.de", "date": "2020-11-04T10:11:31Z"}, "message": "s/Scalar::Raw/Scalar::Int", "tree": {"sha": "6bf4b702f8d3d69a244c908c52f293ed3994a7ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6bf4b702f8d3d69a244c908c52f293ed3994a7ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df4d717d0b150375057bd067356a4c7fe3c27551", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df4d717d0b150375057bd067356a4c7fe3c27551", "html_url": "https://github.com/rust-lang/rust/commit/df4d717d0b150375057bd067356a4c7fe3c27551", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df4d717d0b150375057bd067356a4c7fe3c27551/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a7970848cf3b525e94357fc9b01053b1ad15bcd", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a7970848cf3b525e94357fc9b01053b1ad15bcd", "html_url": "https://github.com/rust-lang/rust/commit/3a7970848cf3b525e94357fc9b01053b1ad15bcd"}], "stats": {"total": 96, "additions": 48, "deletions": 48}, "files": [{"sha": "41cfae4ca6e26e677319b6ee41d0af6893e91398", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df4d717d0b150375057bd067356a4c7fe3c27551/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df4d717d0b150375057bd067356a4c7fe3c27551/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=df4d717d0b150375057bd067356a4c7fe3c27551", "patch": "@@ -186,7 +186,7 @@ pub(crate) fn codegen_const_value<'tcx>(\n             }\n \n             match x {\n-                Scalar::Raw(int) => {\n+                Scalar::Int(int) => {\n                     CValue::const_val(fx, layout, int)\n                 }\n                 Scalar::Ptr(ptr) => {"}, {"sha": "34e1b7a60451eb225a0d9dae01408182a57c1e39", "filename": "compiler/rustc_codegen_llvm/src/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df4d717d0b150375057bd067356a4c7fe3c27551/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df4d717d0b150375057bd067356a4c7fe3c27551/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs?ref=df4d717d0b150375057bd067356a4c7fe3c27551", "patch": "@@ -230,11 +230,11 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn scalar_to_backend(&self, cv: Scalar, layout: &abi::Scalar, llty: &'ll Type) -> &'ll Value {\n         let bitsize = if layout.is_bool() { 1 } else { layout.value.size(self).bits() };\n         match cv {\n-            Scalar::Raw(ScalarInt::ZST) => {\n+            Scalar::Int(ScalarInt::ZST) => {\n                 assert_eq!(0, layout.value.size(self).bytes());\n                 self.const_undef(self.type_ix(0))\n             }\n-            Scalar::Raw(int) => {\n+            Scalar::Int(int) => {\n                 let data = int.assert_bits(layout.value.size(self));\n                 let llval = self.const_uint_big(self.type_ix(bitsize), data);\n                 if layout.value == Pointer {"}, {"sha": "c0fff98dc55b2647f6abfcf2708efffa67a3ec31", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/df4d717d0b150375057bd067356a4c7fe3c27551/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df4d717d0b150375057bd067356a4c7fe3c27551/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=df4d717d0b150375057bd067356a4c7fe3c27551", "patch": "@@ -103,7 +103,7 @@ impl<'tcx> ConstValue<'tcx> {\n #[derive(HashStable)]\n pub enum Scalar<Tag = ()> {\n     /// The raw bytes of a simple value.\n-    Raw(ScalarInt),\n+    Int(ScalarInt),\n \n     /// A pointer into an `Allocation`. An `Allocation` in the `memory` module has a list of\n     /// relocations, but a `Scalar` is only large enough to contain one, so we just represent the\n@@ -120,7 +120,7 @@ impl<Tag: fmt::Debug> fmt::Debug for Scalar<Tag> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             Scalar::Ptr(ptr) => write!(f, \"{:?}\", ptr),\n-            Scalar::Raw(int) => write!(f, \"{:?}\", int),\n+            Scalar::Int(int) => write!(f, \"{:?}\", int),\n         }\n     }\n }\n@@ -129,7 +129,7 @@ impl<Tag: fmt::Debug> fmt::Display for Scalar<Tag> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             Scalar::Ptr(ptr) => write!(f, \"pointer to {}\", ptr),\n-            Scalar::Raw { .. } => fmt::Debug::fmt(self, f),\n+            Scalar::Int { .. } => fmt::Debug::fmt(self, f),\n         }\n     }\n }\n@@ -156,7 +156,7 @@ impl Scalar<()> {\n     pub fn with_tag<Tag>(self, new_tag: Tag) -> Scalar<Tag> {\n         match self {\n             Scalar::Ptr(ptr) => Scalar::Ptr(ptr.with_tag(new_tag)),\n-            Scalar::Raw(int) => Scalar::Raw(int),\n+            Scalar::Int(int) => Scalar::Int(int),\n         }\n     }\n }\n@@ -169,18 +169,18 @@ impl<'tcx, Tag> Scalar<Tag> {\n     pub fn erase_tag(self) -> Scalar {\n         match self {\n             Scalar::Ptr(ptr) => Scalar::Ptr(ptr.erase_tag()),\n-            Scalar::Raw(int) => Scalar::Raw(int),\n+            Scalar::Int(int) => Scalar::Int(int),\n         }\n     }\n \n     #[inline]\n     pub fn null_ptr(cx: &impl HasDataLayout) -> Self {\n-        Scalar::Raw(ScalarInt::null(cx.data_layout().pointer_size))\n+        Scalar::Int(ScalarInt::null(cx.data_layout().pointer_size))\n     }\n \n     #[inline]\n     pub fn zst() -> Self {\n-        Scalar::Raw(ScalarInt::zst())\n+        Scalar::Int(ScalarInt::zst())\n     }\n \n     #[inline(always)]\n@@ -191,7 +191,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n         f_ptr: impl FnOnce(Pointer<Tag>) -> InterpResult<'tcx, Pointer<Tag>>,\n     ) -> InterpResult<'tcx, Self> {\n         match self {\n-            Scalar::Raw(int) => Ok(Scalar::Raw(int.ptr_sized_op(dl, f_int)?)),\n+            Scalar::Int(int) => Ok(Scalar::Int(int.ptr_sized_op(dl, f_int)?)),\n             Scalar::Ptr(ptr) => Ok(Scalar::Ptr(f_ptr(ptr)?)),\n         }\n     }\n@@ -232,17 +232,17 @@ impl<'tcx, Tag> Scalar<Tag> {\n \n     #[inline]\n     pub fn from_bool(b: bool) -> Self {\n-        Scalar::Raw(b.into())\n+        Scalar::Int(b.into())\n     }\n \n     #[inline]\n     pub fn from_char(c: char) -> Self {\n-        Scalar::Raw(c.into())\n+        Scalar::Int(c.into())\n     }\n \n     #[inline]\n     pub fn try_from_uint(i: impl Into<u128>, size: Size) -> Option<Self> {\n-        ScalarInt::try_from_uint(i, size).map(Scalar::Raw)\n+        ScalarInt::try_from_uint(i, size).map(Scalar::Int)\n     }\n \n     #[inline]\n@@ -254,22 +254,22 @@ impl<'tcx, Tag> Scalar<Tag> {\n \n     #[inline]\n     pub fn from_u8(i: u8) -> Self {\n-        Scalar::Raw(i.into())\n+        Scalar::Int(i.into())\n     }\n \n     #[inline]\n     pub fn from_u16(i: u16) -> Self {\n-        Scalar::Raw(i.into())\n+        Scalar::Int(i.into())\n     }\n \n     #[inline]\n     pub fn from_u32(i: u32) -> Self {\n-        Scalar::Raw(i.into())\n+        Scalar::Int(i.into())\n     }\n \n     #[inline]\n     pub fn from_u64(i: u64) -> Self {\n-        Scalar::Raw(i.into())\n+        Scalar::Int(i.into())\n     }\n \n     #[inline]\n@@ -279,7 +279,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n \n     #[inline]\n     pub fn try_from_int(i: impl Into<i128>, size: Size) -> Option<Self> {\n-        ScalarInt::try_from_int(i, size).map(Scalar::Raw)\n+        ScalarInt::try_from_int(i, size).map(Scalar::Int)\n     }\n \n     #[inline]\n@@ -316,12 +316,12 @@ impl<'tcx, Tag> Scalar<Tag> {\n \n     #[inline]\n     pub fn from_f32(f: Single) -> Self {\n-        Scalar::Raw(f.into())\n+        Scalar::Int(f.into())\n     }\n \n     #[inline]\n     pub fn from_f64(f: Double) -> Self {\n-        Scalar::Raw(f.into())\n+        Scalar::Int(f.into())\n     }\n \n     /// This is very rarely the method you want!  You should dispatch on the type\n@@ -336,7 +336,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n     ) -> Result<u128, Pointer<Tag>> {\n         assert_ne!(target_size.bytes(), 0, \"you should never look at the bits of a ZST\");\n         match self {\n-            Scalar::Raw(int) => Ok(int.assert_bits(target_size)),\n+            Scalar::Int(int) => Ok(int.assert_bits(target_size)),\n             Scalar::Ptr(ptr) => {\n                 assert_eq!(target_size, cx.data_layout().pointer_size);\n                 Err(ptr)\n@@ -350,7 +350,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n     fn to_bits(self, target_size: Size) -> InterpResult<'tcx, u128> {\n         assert_ne!(target_size.bytes(), 0, \"you should never look at the bits of a ZST\");\n         match self {\n-            Scalar::Raw(int) => int.to_bits(target_size),\n+            Scalar::Int(int) => int.to_bits(target_size),\n             Scalar::Ptr(_) => throw_unsup!(ReadPointerAsBytes),\n         }\n     }\n@@ -364,14 +364,14 @@ impl<'tcx, Tag> Scalar<Tag> {\n     pub fn assert_ptr(self) -> Pointer<Tag> {\n         match self {\n             Scalar::Ptr(p) => p,\n-            Scalar::Raw { .. } => bug!(\"expected a Pointer but got Raw bits\"),\n+            Scalar::Int { .. } => bug!(\"expected a Pointer but got Raw bits\"),\n         }\n     }\n \n     /// Do not call this method!  Dispatch based on the type instead.\n     #[inline]\n     pub fn is_bits(self) -> bool {\n-        matches!(self, Scalar::Raw { .. })\n+        matches!(self, Scalar::Int { .. })\n     }\n \n     /// Do not call this method!  Dispatch based on the type instead."}, {"sha": "bf091201e1004e3c41348eccccfee1196ae50ed0", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df4d717d0b150375057bd067356a4c7fe3c27551/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df4d717d0b150375057bd067356a4c7fe3c27551/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=df4d717d0b150375057bd067356a4c7fe3c27551", "patch": "@@ -1952,7 +1952,7 @@ impl<'tcx> Operand<'tcx> {\n                 .unwrap_or_else(|e| panic!(\"could not compute layout for {:?}: {:?}\", ty, e))\n                 .size;\n             let scalar_size = match val {\n-                Scalar::Raw(int) => int.size(),\n+                Scalar::Int(int) => int.size(),\n                 _ => panic!(\"Invalid scalar type {:?}\", val),\n             };\n             scalar_size == type_size"}, {"sha": "8ff4adda606e204b2e050827a933252a6242bd6e", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/df4d717d0b150375057bd067356a4c7fe3c27551/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df4d717d0b150375057bd067356a4c7fe3c27551/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=df4d717d0b150375057bd067356a4c7fe3c27551", "patch": "@@ -982,27 +982,27 @@ pub trait PrettyPrinter<'tcx>:\n                 None => p!(\"<dangling pointer>\"),\n             },\n             // Bool\n-            (Scalar::Raw(int), ty::Bool) if int == ScalarInt::FALSE => p!(\"false\"),\n-            (Scalar::Raw(int), ty::Bool) if int == ScalarInt::TRUE => p!(\"true\"),\n+            (Scalar::Int(int), ty::Bool) if int == ScalarInt::FALSE => p!(\"false\"),\n+            (Scalar::Int(int), ty::Bool) if int == ScalarInt::TRUE => p!(\"true\"),\n             // Float\n-            (Scalar::Raw(int), ty::Float(ast::FloatTy::F32)) => {\n+            (Scalar::Int(int), ty::Float(ast::FloatTy::F32)) => {\n                 p!(write(\"{}f32\", Single::try_from(int).unwrap()))\n             }\n-            (Scalar::Raw(int), ty::Float(ast::FloatTy::F64)) => {\n+            (Scalar::Int(int), ty::Float(ast::FloatTy::F64)) => {\n                 p!(write(\"{}f64\", Double::try_from(int).unwrap()))\n             }\n             // Int\n-            (Scalar::Raw(int), ty::Uint(_) | ty::Int(_)) => {\n+            (Scalar::Int(int), ty::Uint(_) | ty::Int(_)) => {\n                 let int =\n                     ConstInt::new(int, matches!(ty.kind(), ty::Int(_)), ty.is_ptr_sized_integral());\n                 if print_ty { p!(write(\"{:#?}\", int)) } else { p!(write(\"{:?}\", int)) }\n             }\n             // Char\n-            (Scalar::Raw(int), ty::Char) if char::try_from(int).is_ok() => {\n+            (Scalar::Int(int), ty::Char) if char::try_from(int).is_ok() => {\n                 p!(write(\"{:?}\", char::try_from(int).unwrap()))\n             }\n             // Raw pointers\n-            (Scalar::Raw(int), ty::RawPtr(_)) => {\n+            (Scalar::Int(int), ty::RawPtr(_)) => {\n                 let data = int.assert_bits(self.tcx().data_layout.pointer_size);\n                 self = self.typed_value(\n                     |mut this| {\n@@ -1025,11 +1025,11 @@ pub trait PrettyPrinter<'tcx>:\n                 )?;\n             }\n             // For function type zsts just printing the path is enough\n-            (Scalar::Raw(int), ty::FnDef(d, s)) if int == ScalarInt::ZST => {\n+            (Scalar::Int(int), ty::FnDef(d, s)) if int == ScalarInt::ZST => {\n                 p!(print_value_path(*d, s))\n             }\n             // Nontrivial types with scalar bit representation\n-            (Scalar::Raw(int), _) => {\n+            (Scalar::Int(int), _) => {\n                 let print = |mut this: Self| {\n                     if int.size() == Size::ZERO {\n                         write!(this, \"transmute(())\")?;"}, {"sha": "a5edfbd9367aae05f7b70f0378f02ce85813edf0", "filename": "compiler/rustc_mir/src/const_eval/eval_queries.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df4d717d0b150375057bd067356a4c7fe3c27551/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df4d717d0b150375057bd067356a4c7fe3c27551/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=df4d717d0b150375057bd067356a4c7fe3c27551", "patch": "@@ -137,7 +137,7 @@ pub(super) fn op_to_const<'tcx>(\n             let alloc = ecx.tcx.global_alloc(ptr.alloc_id).unwrap_memory();\n             ConstValue::ByRef { alloc, offset: ptr.offset }\n         }\n-        Scalar::Raw(int) => {\n+        Scalar::Int(int) => {\n             assert!(mplace.layout.is_zst());\n             assert_eq!(\n                 int.assert_bits(ecx.tcx.data_layout.pointer_size)\n@@ -162,7 +162,7 @@ pub(super) fn op_to_const<'tcx>(\n                     Scalar::Ptr(ptr) => {\n                         (ecx.tcx.global_alloc(ptr.alloc_id).unwrap_memory(), ptr.offset.bytes())\n                     }\n-                    Scalar::Raw { .. } => (\n+                    Scalar::Int { .. } => (\n                         ecx.tcx\n                             .intern_const_alloc(Allocation::from_byte_aligned_bytes(b\"\" as &[u8])),\n                         0,"}, {"sha": "5fe393bf4323536fc3739502adccf9d8e4bc9179", "filename": "compiler/rustc_mir/src/const_eval/machine.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/df4d717d0b150375057bd067356a4c7fe3c27551/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df4d717d0b150375057bd067356a4c7fe3c27551/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=df4d717d0b150375057bd067356a4c7fe3c27551", "patch": "@@ -181,9 +181,9 @@ impl<'mir, 'tcx: 'mir> CompileTimeEvalContext<'mir, 'tcx> {\n     fn guaranteed_eq(&mut self, a: Scalar, b: Scalar) -> bool {\n         match (a, b) {\n             // Comparisons between integers are always known.\n-            (Scalar::Raw { .. }, Scalar::Raw { .. }) => a == b,\n+            (Scalar::Int { .. }, Scalar::Int { .. }) => a == b,\n             // Equality with integers can never be known for sure.\n-            (Scalar::Raw { .. }, Scalar::Ptr(_)) | (Scalar::Ptr(_), Scalar::Raw { .. }) => false,\n+            (Scalar::Int { .. }, Scalar::Ptr(_)) | (Scalar::Ptr(_), Scalar::Int { .. }) => false,\n             // FIXME: return `true` for when both sides are the same pointer, *except* that\n             // some things (like functions and vtables) do not have stable addresses\n             // so we need to be careful around them (see e.g. #73722).\n@@ -194,11 +194,11 @@ impl<'mir, 'tcx: 'mir> CompileTimeEvalContext<'mir, 'tcx> {\n     fn guaranteed_ne(&mut self, a: Scalar, b: Scalar) -> bool {\n         match (a, b) {\n             // Comparisons between integers are always known.\n-            (Scalar::Raw(_), Scalar::Raw(_)) => a != b,\n+            (Scalar::Int(_), Scalar::Int(_)) => a != b,\n             // Comparisons of abstract pointers with null pointers are known if the pointer\n             // is in bounds, because if they are in bounds, the pointer can't be null.\n             // Inequality with integers other than null can never be known for sure.\n-            (Scalar::Raw(int), Scalar::Ptr(ptr)) | (Scalar::Ptr(ptr), Scalar::Raw(int)) => {\n+            (Scalar::Int(int), Scalar::Ptr(ptr)) | (Scalar::Ptr(ptr), Scalar::Int(int)) => {\n                 int == ScalarInt::null(int.size()) && !self.memory.ptr_may_be_null(ptr)\n             }\n             // FIXME: return `true` for at least some comparisons where we can reliably"}, {"sha": "2fa73df2d60fd8d93db524f4da8eed674c49e1e2", "filename": "compiler/rustc_mir/src/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df4d717d0b150375057bd067356a4c7fe3c27551/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df4d717d0b150375057bd067356a4c7fe3c27551/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs?ref=df4d717d0b150375057bd067356a4c7fe3c27551", "patch": "@@ -212,7 +212,7 @@ impl<'tcx, Tag: Copy> ImmTy<'tcx, Tag> {\n     pub fn to_const_int(self) -> ConstInt {\n         assert!(self.layout.ty.is_integral());\n         let int = match self.to_scalar().expect(\"to_const_int doesn't work on scalar pairs\") {\n-            Scalar::Raw(int) => int,\n+            Scalar::Int(int) => int,\n             Scalar::Ptr(_) => bug!(\"to_const_int doesn't work on pointers\"),\n         };\n         ConstInt::new(int, self.layout.ty.is_signed(), self.layout.ty.is_ptr_sized_integral())\n@@ -541,7 +541,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let tag_scalar = |scalar| -> InterpResult<'tcx, _> {\n             Ok(match scalar {\n                 Scalar::Ptr(ptr) => Scalar::Ptr(self.global_base_pointer(ptr)?),\n-                Scalar::Raw(int) => Scalar::Raw(int),\n+                Scalar::Int(int) => Scalar::Int(int),\n             })\n         };\n         // Early-return cases."}, {"sha": "3e10d0960a88aeaf72f1d25b3df36eef09f91cff", "filename": "compiler/rustc_mir/src/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df4d717d0b150375057bd067356a4c7fe3c27551/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df4d717d0b150375057bd067356a4c7fe3c27551/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs?ref=df4d717d0b150375057bd067356a4c7fe3c27551", "patch": "@@ -721,7 +721,7 @@ where\n                     dest.layout.size,\n                     \"Size mismatch when writing pointer\"\n                 ),\n-                Immediate::Scalar(ScalarMaybeUninit::Scalar(Scalar::Raw(int))) => {\n+                Immediate::Scalar(ScalarMaybeUninit::Scalar(Scalar::Int(int))) => {\n                     assert_eq!(int.size(), dest.layout.size, \"Size mismatch when writing bits\")\n                 }\n                 Immediate::Scalar(ScalarMaybeUninit::Uninit) => {} // uninit can have any size"}, {"sha": "ea56080c75216c96971ff01385e26fa4285c89a4", "filename": "compiler/rustc_mir/src/transform/simplify_comparison_integral.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df4d717d0b150375057bd067356a4c7fe3c27551/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_comparison_integral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df4d717d0b150375057bd067356a4c7fe3c27551/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_comparison_integral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_comparison_integral.rs?ref=df4d717d0b150375057bd067356a4c7fe3c27551", "patch": "@@ -40,7 +40,7 @@ impl<'tcx> MirPass<'tcx> for SimplifyComparisonIntegral {\n             let bbs = &mut body.basic_blocks_mut();\n             let bb = &mut bbs[opt.bb_idx];\n             let new_value = match opt.branch_value_scalar {\n-                Scalar::Raw(int) => {\n+                Scalar::Int(int) => {\n                     let layout = tcx\n                         .layout_of(param_env.and(opt.branch_value_ty))\n                         .expect(\"if we have an evaluated constant we must know the layout\");"}, {"sha": "8bee8417c51fa6dddc0102cfa022beac01694226", "filename": "compiler/rustc_mir/src/util/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df4d717d0b150375057bd067356a4c7fe3c27551/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df4d717d0b150375057bd067356a4c7fe3c27551/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs?ref=df4d717d0b150375057bd067356a4c7fe3c27551", "patch": "@@ -630,7 +630,7 @@ pub fn write_allocations<'tcx>(\n             ConstValue::Scalar(interpret::Scalar::Ptr(ptr)) => {\n                 Either::Left(Either::Left(std::iter::once(ptr.alloc_id)))\n             }\n-            ConstValue::Scalar(interpret::Scalar::Raw { .. }) => {\n+            ConstValue::Scalar(interpret::Scalar::Int { .. }) => {\n                 Either::Left(Either::Right(std::iter::empty()))\n             }\n             ConstValue::ByRef { alloc, .. } | ConstValue::Slice { data: alloc, .. } => {"}, {"sha": "ac91fcf62937a5306ea78f7290a43860eaa0f1f3", "filename": "compiler/rustc_symbol_mangling/src/legacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df4d717d0b150375057bd067356a4c7fe3c27551/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df4d717d0b150375057bd067356a4c7fe3c27551/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs?ref=df4d717d0b150375057bd067356a4c7fe3c27551", "patch": "@@ -237,7 +237,7 @@ impl Printer<'tcx> for SymbolPrinter<'tcx> {\n \n     fn print_const(mut self, ct: &'tcx ty::Const<'tcx>) -> Result<Self::Const, Self::Error> {\n         // only print integers\n-        if let ty::ConstKind::Value(ConstValue::Scalar(Scalar::Raw { .. })) = ct.val {\n+        if let ty::ConstKind::Value(ConstValue::Scalar(Scalar::Int { .. })) = ct.val {\n             if ct.ty.is_integral() {\n                 return self.pretty_print_const(ct, true);\n             }"}, {"sha": "c8bbc9ce2b0287e9355350d53c8eea42fbcfd8cc", "filename": "src/tools/clippy/clippy_lints/src/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df4d717d0b150375057bd067356a4c7fe3c27551/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df4d717d0b150375057bd067356a4c7fe3c27551/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fconsts.rs?ref=df4d717d0b150375057bd067356a4c7fe3c27551", "patch": "@@ -503,7 +503,7 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n pub fn miri_to_const(result: &ty::Const<'_>) -> Option<Constant> {\n     use rustc_middle::mir::interpret::{ConstValue};\n     match result.val {\n-        ty::ConstKind::Value(ConstValue::Scalar(Scalar::Raw(int))) => {\n+        ty::ConstKind::Value(ConstValue::Scalar(Scalar::Int(int))) => {\n             match result.ty.kind() {\n                 ty::Bool => Some(Constant::Bool(int == ScalarInt::TRUE)),\n                 ty::Uint(_) | ty::Int(_) => Some(Constant::Int(int.assert_bits(int.size()))),"}]}