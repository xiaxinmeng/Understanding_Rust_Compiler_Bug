{"sha": "0ae203a779b8a75b3b79b409d92558d4bda92133", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhZTIwM2E3NzliOGE3NWIzYjc5YjQwOWQ5MjU1OGQ0YmRhOTIxMzM=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-06-25T23:38:32Z"}, "committer": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2013-06-26T22:07:17Z"}, "message": "Refactor extra::term a bit\n\nMove all the colors into a nested mod named color instead of prefixing\nwith \"color_\".\n\nDefine a new type color::Color, and make this a u16 instead of a u8 (to\nallow for easy comparisons against num_colors, which is a u16).\n\nRemove color_supported and replace it with num_colors.\n\nTeach fg() and bg() to \"dim\" bright colors down to the normal intensity\nif num_colors isn't high enough.\n\nRemove unnecessary copies, and fix a bug where a terminfo parse failure\nwould try to use the wrong error and end up failing.", "tree": {"sha": "f496a99e24c3058116ef53f2f632360850785ac2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f496a99e24c3058116ef53f2f632360850785ac2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ae203a779b8a75b3b79b409d92558d4bda92133", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ae203a779b8a75b3b79b409d92558d4bda92133", "html_url": "https://github.com/rust-lang/rust/commit/0ae203a779b8a75b3b79b409d92558d4bda92133", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ae203a779b8a75b3b79b409d92558d4bda92133/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00b4138857055ba3495a70a01eea0bc8d9fed690", "url": "https://api.github.com/repos/rust-lang/rust/commits/00b4138857055ba3495a70a01eea0bc8d9fed690", "html_url": "https://github.com/rust-lang/rust/commit/00b4138857055ba3495a70a01eea0bc8d9fed690"}], "stats": {"total": 146, "additions": 82, "deletions": 64}, "files": [{"sha": "9a4469cb5265a85298ddf0cd655f330fcf3fb1be", "filename": "src/libextra/term.rs", "status": "modified", "additions": 65, "deletions": 47, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/0ae203a779b8a75b3b79b409d92558d4bda92133/src%2Flibextra%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ae203a779b8a75b3b79b409d92558d4bda92133/src%2Flibextra%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterm.rs?ref=0ae203a779b8a75b3b79b409d92558d4bda92133", "patch": "@@ -24,35 +24,38 @@ use core::io;\n \n // FIXME (#2807): Windows support.\n \n-pub static color_black: u8 = 0u8;\n-pub static color_red: u8 = 1u8;\n-pub static color_green: u8 = 2u8;\n-pub static color_yellow: u8 = 3u8;\n-pub static color_blue: u8 = 4u8;\n-pub static color_magenta: u8 = 5u8;\n-pub static color_cyan: u8 = 6u8;\n-pub static color_light_gray: u8 = 7u8;\n-pub static color_light_grey: u8 = 7u8;\n-pub static color_dark_gray: u8 = 8u8;\n-pub static color_dark_grey: u8 = 8u8;\n-pub static color_bright_red: u8 = 9u8;\n-pub static color_bright_green: u8 = 10u8;\n-pub static color_bright_yellow: u8 = 11u8;\n-pub static color_bright_blue: u8 = 12u8;\n-pub static color_bright_magenta: u8 = 13u8;\n-pub static color_bright_cyan: u8 = 14u8;\n-pub static color_bright_white: u8 = 15u8;\n+pub mod color {\n+    pub type Color = u16;\n+\n+    pub static black:   Color = 0u16;\n+    pub static red:     Color = 1u16;\n+    pub static green:   Color = 2u16;\n+    pub static yellow:  Color = 3u16;\n+    pub static blue:    Color = 4u16;\n+    pub static magenta: Color = 5u16;\n+    pub static cyan:    Color = 6u16;\n+    pub static white:   Color = 7u16;\n+\n+    pub static bright_black:   Color = 8u16;\n+    pub static bright_red:     Color = 9u16;\n+    pub static bright_green:   Color = 10u16;\n+    pub static bright_yellow:  Color = 11u16;\n+    pub static bright_blue:    Color = 12u16;\n+    pub static bright_magenta: Color = 13u16;\n+    pub static bright_cyan:    Color = 14u16;\n+    pub static bright_white:   Color = 15u16;\n+}\n \n #[cfg(not(target_os = \"win32\"))]\n pub struct Terminal {\n-    color_supported: bool,\n+    num_colors: u16,\n     priv out: @io::Writer,\n     priv ti: ~TermInfo\n }\n \n #[cfg(target_os = \"win32\")]\n pub struct Terminal {\n-    color_supported: bool,\n+    num_colors: u16,\n     priv out: @io::Writer,\n }\n \n@@ -66,66 +69,81 @@ impl Terminal {\n \n         let entry = open(term.unwrap());\n         if entry.is_err() {\n-            return Err(entry.get_err());\n+            return Err(entry.unwrap_err());\n         }\n \n-        let ti = parse(entry.get(), false);\n+        let ti = parse(entry.unwrap(), false);\n         if ti.is_err() {\n-            return Err(entry.get_err());\n+            return Err(ti.unwrap_err());\n         }\n \n-        let mut inf = ti.get();\n-        let cs = *inf.numbers.find_or_insert(~\"colors\", 0) >= 16\n-            && inf.strings.find(&~\"setaf\").is_some()\n-            && inf.strings.find_equiv(&(\"setab\")).is_some();\n+        let inf = ti.unwrap();\n+        let nc = if inf.strings.find_equiv(&(\"setaf\")).is_some()\n+                 && inf.strings.find_equiv(&(\"setab\")).is_some() {\n+                     inf.numbers.find_equiv(&(\"colors\")).map_consume_default(0, |&n| n)\n+                 } else { 0 };\n \n-        return Ok(Terminal {out: out, ti: inf, color_supported: cs});\n+        return Ok(Terminal {out: out, ti: inf, num_colors: nc});\n     }\n-    pub fn fg(&self, color: u8) {\n-        if self.color_supported {\n+    /// Sets the foreground color to the given color.\n+    ///\n+    /// If the color is a bright color, but the terminal only supports 8 colors,\n+    /// the corresponding normal color will be used instead.\n+    pub fn fg(&self, color: color::Color) {\n+        let color = self.dim_if_necessary(color);\n+        if self.num_colors > color {\n             let s = expand(*self.ti.strings.find_equiv(&(\"setaf\")).unwrap(),\n                            [Number(color as int)], &mut Variables::new());\n             if s.is_ok() {\n-                self.out.write(s.get());\n+                self.out.write(s.unwrap());\n             } else {\n-                warn!(s.get_err());\n+                warn!(s.unwrap_err());\n             }\n         }\n     }\n-    pub fn bg(&self, color: u8) {\n-        if self.color_supported {\n+    /// Sets the background color to the given color.\n+    ///\n+    /// If the color is a bright color, but the terminal only supports 8 colors,\n+    /// the corresponding normal color will be used instead.\n+    pub fn bg(&self, color: color::Color) {\n+        let color = self.dim_if_necessary(color);\n+        if self.num_colors > color {\n             let s = expand(*self.ti.strings.find_equiv(&(\"setab\")).unwrap(),\n                            [Number(color as int)], &mut Variables::new());\n             if s.is_ok() {\n-                self.out.write(s.get());\n+                self.out.write(s.unwrap());\n             } else {\n-                warn!(s.get_err());\n+                warn!(s.unwrap_err());\n             }\n         }\n     }\n     pub fn reset(&self) {\n-        if self.color_supported {\n-            let mut vars = Variables::new();\n-            let s = expand(*self.ti.strings.find_equiv(&(\"op\")).unwrap(), [], &mut vars);\n-            if s.is_ok() {\n-                self.out.write(s.get());\n-            } else {\n-                warn!(s.get_err());\n-            }\n+        let mut vars = Variables::new();\n+        let s = expand(*self.ti.strings.find_equiv(&(\"op\")).unwrap(), [], &mut vars);\n+        if s.is_ok() {\n+            self.out.write(s.unwrap());\n+        } else {\n+            warn!(s.unwrap_err());\n         }\n     }\n+\n+    priv fn dim_if_necessary(&self, color: color::Color) -> color::Color {\n+        if color >= self.num_colors && color >= 8 && color < 16 {\n+            color-8\n+        } else { color }\n+    }\n }\n \n #[cfg(target_os = \"win32\")]\n impl Terminal {\n     pub fn new(out: @io::Writer) -> Result<Terminal, ~str> {\n-        return Ok(Terminal {out: out, color_supported: false});\n+        return Ok(Terminal {out: out, num_colors: 0});\n     }\n \n-    pub fn fg(&self, _color: u8) {\n+    pub fn fg(&self, _color: color::Color) {\n     }\n \n-    pub fn bg(&self, _color: u8) {\n+    pub fn bg(&self, _color: color::Color) {\n     }\n \n     pub fn reset(&self) {"}, {"sha": "03d9a06079802b51482cc4dbdbf129aae92aa7eb", "filename": "src/libextra/test.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0ae203a779b8a75b3b79b409d92558d4bda92133/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ae203a779b8a75b3b79b409d92558d4bda92133/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=0ae203a779b8a75b3b79b409d92558d4bda92133", "patch": "@@ -326,33 +326,33 @@ pub fn run_tests_console(opts: &TestOpts,\n     }\n \n     fn write_ok(out: @io::Writer, use_color: bool) {\n-        write_pretty(out, \"ok\", term::color_green, use_color);\n+        write_pretty(out, \"ok\", term::color::green, use_color);\n     }\n \n     fn write_failed(out: @io::Writer, use_color: bool) {\n-        write_pretty(out, \"FAILED\", term::color_red, use_color);\n+        write_pretty(out, \"FAILED\", term::color::red, use_color);\n     }\n \n     fn write_ignored(out: @io::Writer, use_color: bool) {\n-        write_pretty(out, \"ignored\", term::color_yellow, use_color);\n+        write_pretty(out, \"ignored\", term::color::yellow, use_color);\n     }\n \n     fn write_bench(out: @io::Writer, use_color: bool) {\n-        write_pretty(out, \"bench\", term::color_cyan, use_color);\n+        write_pretty(out, \"bench\", term::color::cyan, use_color);\n     }\n \n     fn write_pretty(out: @io::Writer,\n                     word: &str,\n-                    color: u8,\n+                    color: term::color::Color,\n                     use_color: bool) {\n         let t = term::Terminal::new(out);\n         match t {\n             Ok(term)  => {\n-                if use_color && term.color_supported {\n+                if use_color {\n                     term.fg(color);\n                 }\n                 out.write_str(word);\n-                if use_color && term.color_supported {\n+                if use_color {\n                     term.reset();\n                 }\n             },"}, {"sha": "bde7aaeab8e4a8139106990e7bef7cc7e4bbc351", "filename": "src/librustpkg/messages.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0ae203a779b8a75b3b79b409d92558d4bda92133/src%2Flibrustpkg%2Fmessages.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ae203a779b8a75b3b79b409d92558d4bda92133/src%2Flibrustpkg%2Fmessages.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fmessages.rs?ref=0ae203a779b8a75b3b79b409d92558d4bda92133", "patch": "@@ -13,18 +13,18 @@ use core::io;\n use core::result::*;\n \n pub fn note(msg: &str) {\n-    pretty_message(msg, \"note: \", term::color_green, io::stdout())\n+    pretty_message(msg, \"note: \", term::color::green, io::stdout())\n }\n \n pub fn warn(msg: &str) {\n-    pretty_message(msg, \"warning: \", term::color_yellow, io::stdout())\n+    pretty_message(msg, \"warning: \", term::color::yellow, io::stdout())\n }\n \n pub fn error(msg: &str) {\n-    pretty_message(msg, \"error: \", term::color_red, io::stdout())\n+    pretty_message(msg, \"error: \", term::color::red, io::stdout())\n }\n \n-fn pretty_message<'a>(msg: &'a str, prefix: &'a str, color: u8, out: @io::Writer) {\n+fn pretty_message<'a>(msg: &'a str, prefix: &'a str, color: term::color::Color, out: @io::Writer) {\n     let term = term::Terminal::new(out);\n     match term {\n         Ok(ref t) => {"}, {"sha": "89867922b25bd4d250c77ae6fb769ea0471b81c4", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0ae203a779b8a75b3b79b409d92558d4bda92133/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ae203a779b8a75b3b79b409d92558d4bda92133/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=0ae203a779b8a75b3b79b409d92558d4bda92133", "patch": "@@ -178,16 +178,16 @@ fn diagnosticstr(lvl: level) -> ~str {\n     }\n }\n \n-fn diagnosticcolor(lvl: level) -> u8 {\n+fn diagnosticcolor(lvl: level) -> term::color::Color {\n     match lvl {\n-        fatal => term::color_bright_red,\n-        error => term::color_bright_red,\n-        warning => term::color_bright_yellow,\n-        note => term::color_bright_green\n+        fatal => term::color::bright_red,\n+        error => term::color::bright_red,\n+        warning => term::color::bright_yellow,\n+        note => term::color::bright_green\n     }\n }\n \n-fn print_maybe_colored(msg: &str, color: u8) {\n+fn print_maybe_colored(msg: &str, color: term::color::Color) {\n     let stderr = io::stderr();\n \n     let t = term::Terminal::new(stderr);"}]}