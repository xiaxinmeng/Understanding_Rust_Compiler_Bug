{"sha": "108b953254e46851130e427b41cd143eee07fd02", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwOGI5NTMyNTRlNDY4NTExMzBlNDI3YjQxY2QxNDNlZWUwN2ZkMDI=", "commit": {"author": {"name": "Zac Pullar-Strecker", "email": "zacmps@gmail.com", "date": "2020-06-13T04:13:32Z"}, "committer": {"name": "Zac Pullar-Strecker", "email": "zacmps@gmail.com", "date": "2020-06-30T08:05:21Z"}, "message": "Remove local documentation link rewriting", "tree": {"sha": "4f14d14f0d85d5f8b5988a520de86f2c082b90f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f14d14f0d85d5f8b5988a520de86f2c082b90f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/108b953254e46851130e427b41cd143eee07fd02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/108b953254e46851130e427b41cd143eee07fd02", "html_url": "https://github.com/rust-lang/rust/commit/108b953254e46851130e427b41cd143eee07fd02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/108b953254e46851130e427b41cd143eee07fd02/comments", "author": {"login": "zacps", "id": 9827696, "node_id": "MDQ6VXNlcjk4Mjc2OTY=", "avatar_url": "https://avatars.githubusercontent.com/u/9827696?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zacps", "html_url": "https://github.com/zacps", "followers_url": "https://api.github.com/users/zacps/followers", "following_url": "https://api.github.com/users/zacps/following{/other_user}", "gists_url": "https://api.github.com/users/zacps/gists{/gist_id}", "starred_url": "https://api.github.com/users/zacps/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zacps/subscriptions", "organizations_url": "https://api.github.com/users/zacps/orgs", "repos_url": "https://api.github.com/users/zacps/repos", "events_url": "https://api.github.com/users/zacps/events{/privacy}", "received_events_url": "https://api.github.com/users/zacps/received_events", "type": "User", "site_admin": false}, "committer": {"login": "zacps", "id": 9827696, "node_id": "MDQ6VXNlcjk4Mjc2OTY=", "avatar_url": "https://avatars.githubusercontent.com/u/9827696?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zacps", "html_url": "https://github.com/zacps", "followers_url": "https://api.github.com/users/zacps/followers", "following_url": "https://api.github.com/users/zacps/following{/other_user}", "gists_url": "https://api.github.com/users/zacps/gists{/gist_id}", "starred_url": "https://api.github.com/users/zacps/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zacps/subscriptions", "organizations_url": "https://api.github.com/users/zacps/orgs", "repos_url": "https://api.github.com/users/zacps/repos", "events_url": "https://api.github.com/users/zacps/events{/privacy}", "received_events_url": "https://api.github.com/users/zacps/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f52a516dedeab16ede8c26807c4ff79b3d308d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f52a516dedeab16ede8c26807c4ff79b3d308d3", "html_url": "https://github.com/rust-lang/rust/commit/5f52a516dedeab16ede8c26807c4ff79b3d308d3"}], "stats": {"total": 127, "additions": 22, "deletions": 105}, "files": [{"sha": "0da10a08ecdfda7db89c17cff5fe17fd6a95852a", "filename": "crates/ra_ide/src/hover.rs", "status": "modified", "additions": 19, "deletions": 50, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/108b953254e46851130e427b41cd143eee07fd02/crates%2Fra_ide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b953254e46851130e427b41cd143eee07fd02/crates%2Fra_ide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fhover.rs?ref=108b953254e46851130e427b41cd143eee07fd02", "patch": "@@ -1,10 +1,8 @@\n use std::iter::once;\n-use std::path::PathBuf;\n-use std::sync::Arc;\n \n use hir::{\n     Adt, AsAssocItem, AssocItemContainer, FieldSource, HasSource, HirDisplay, ModuleDef,\n-    ModuleSource, Semantics, Documentation, AttrDef, Crate, GenericDef, ModPath, Hygiene\n+    ModuleSource, Semantics, Documentation, AttrDef, Crate, ModPath, Hygiene\n };\n use itertools::Itertools;\n use ra_db::SourceDatabase;\n@@ -13,11 +11,9 @@ use ra_ide_db::{\n     RootDatabase,\n };\n use ra_syntax::{ast, match_ast, AstNode, SyntaxKind::*, SyntaxToken, SyntaxNode, TokenAtOffset, ast::Path};\n-use ra_project_model::ProjectWorkspace;\n-use ra_hir_def::{item_scope::ItemInNs, db::DefDatabase, GenericDefId, ModuleId, resolver::HasResolver};\n+use ra_hir_def::{item_scope::ItemInNs, db::DefDatabase, resolver::HasResolver};\n use ra_tt::{Literal, Ident, Punct, TokenTree, Leaf};\n use ra_hir_expand::name::AsName;\n-use ra_parser::FragmentKind;\n use maplit::{hashset, hashmap};\n \n use comrak::{parse_document,format_commonmark, ComrakOptions, Arena};\n@@ -130,7 +126,7 @@ impl HoverResult {\n //\n // Shows additional information, like type of an expression or documentation for definition when \"focusing\" code.\n // Focusing is usually hovering with a mouse, but can also be triggered with a shortcut.\n-pub(crate) fn hover(db: &RootDatabase, position: FilePosition, workspaces: Arc<Vec<ProjectWorkspace>>) -> Option<RangeInfo<HoverResult>> {\n+pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeInfo<HoverResult>> {\n     let sema = Semantics::new(db);\n     let file = sema.parse(position.file_id).syntax().clone();\n     let token = pick_best(file.token_at_offset(position.offset))?;\n@@ -150,7 +146,7 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition, workspaces: Arc<V\n         }\n     } {\n         let range = sema.original_range(&node).range;\n-        let text = hover_text_from_name_kind(db, name_kind.clone()).map(|text| rewrite_links(db, &text, &name_kind, workspaces).unwrap_or(text));\n+        let text = hover_text_from_name_kind(db, name_kind.clone()).map(|text| rewrite_links(db, &text, &name_kind).unwrap_or(text));\n         res.extend(text);\n \n         if !res.is_empty() {\n@@ -393,15 +389,9 @@ fn hover_text_from_name_kind(db: &RootDatabase, def: Definition) -> Option<Strin\n }\n \n /// Rewrite documentation links in markdown to point to local documentation/docs.rs\n-fn rewrite_links(db: &RootDatabase, markdown: &str, definition: &Definition, workspaces: Arc<Vec<ProjectWorkspace>>) -> Option<String> {\n+fn rewrite_links(db: &RootDatabase, markdown: &str, definition: &Definition) -> Option<String> {\n     let arena = Arena::new();\n     let doc = parse_document(&arena, markdown, &ComrakOptions::default());\n-    let doc_target_dirs = workspaces\n-        .iter()\n-        .filter_map(|workspace| if let ProjectWorkspace::Cargo{cargo: cargo_workspace, ..} = workspace {Some(cargo_workspace)} else {None})\n-        .map(|workspace| workspace.workspace_root())\n-        // TODO: `target` is configurable in cargo config, we should respect it\n-        .map(|root| root.join(\"target/doc\"));\n \n     iter_nodes(doc, &|node| {\n         match &mut node.data.borrow_mut().value {\n@@ -415,8 +405,8 @@ fn rewrite_links(db: &RootDatabase, markdown: &str, definition: &Definition, wor\n                     Err(_) => {\n                         let link_str = String::from_utf8(link.url.clone()).unwrap();\n                         let link_text = String::from_utf8(link.title.clone()).unwrap();\n-                        let resolved = try_resolve_path(db, &mut doc_target_dirs.clone(), definition, &link_str, UrlMode::Url)\n-                            .or_else(|| try_resolve_intra(db, &mut doc_target_dirs.clone(), definition, &link_text, &link_str));\n+                        let resolved = try_resolve_path(db, definition, &link_str)\n+                            .or_else(|| try_resolve_intra(db, definition, &link_text, &link_str));\n \n                         if let Some(resolved) = resolved {\n                             link.url = resolved.as_bytes().to_vec();\n@@ -451,7 +441,7 @@ impl Namespace {\n \n         ns_map\n             .iter()\n-            .filter(|(ns, (prefixes, suffixes))| {\n+            .filter(|(_ns, (prefixes, suffixes))| {\n                 prefixes.iter().map(|prefix| s.starts_with(prefix) && s.chars().nth(prefix.len()+1).map(|c| c == '@' || c == ' ').unwrap_or(false)).any(|cond| cond) ||\n                 suffixes.iter().map(|suffix| s.starts_with(suffix) && s.chars().nth(suffix.len()+1).map(|c| c == '@' || c == ' ').unwrap_or(false)).any(|cond| cond)\n             })\n@@ -463,7 +453,7 @@ impl Namespace {\n /// Try to resolve path to local documentation via intra-doc-links (i.e. `super::gateway::Shard`).\n ///\n /// See [RFC1946](https://github.com/rust-lang/rfcs/blob/master/text/1946-intra-rustdoc-links.md).\n-fn try_resolve_intra(db: &RootDatabase, doc_target_dirs: impl Iterator<Item = PathBuf>, definition: &Definition, link_text: &str, link_target: &str) -> Option<String> {\n+fn try_resolve_intra(db: &RootDatabase, definition: &Definition, link_text: &str, link_target: &str) -> Option<String> {\n     eprintln!(\"try_resolve_intra\");\n \n     // Set link_target for implied shortlinks\n@@ -496,13 +486,13 @@ fn try_resolve_intra(db: &RootDatabase, doc_target_dirs: impl Iterator<Item = Pa\n                 ModuleDef::Trait(t) => Into::<TraitId>::into(t.clone()).resolver(db),\n                 ModuleDef::TypeAlias(t) => Into::<ModuleId>::into(t.module(db)).resolver(db),\n                 // TODO: This should be a resolver relative to `std`\n-                ModuleDef::BuiltinType(t) => Into::<ModuleId>::into(definition.module(db)?).resolver(db)\n+                ModuleDef::BuiltinType(_t) => Into::<ModuleId>::into(definition.module(db)?).resolver(db)\n             },\n             Definition::Field(field) => Into::<VariantId>::into(Into::<VariantDef>::into(field.parent_def(db))).resolver(db),\n             Definition::Macro(m) => Into::<ModuleId>::into(m.module(db)?).resolver(db),\n             Definition::SelfType(imp) => Into::<ImplId>::into(imp.clone()).resolver(db),\n             // it's possible, read probable, that other arms of this are also unreachable\n-            Definition::Local(local) => unreachable!(),\n+            Definition::Local(_local) => unreachable!(),\n             Definition::TypeParam(tp) => Into::<ModuleId>::into(tp.module(db)).resolver(db)\n         }\n     };\n@@ -542,13 +532,8 @@ fn try_resolve_intra(db: &RootDatabase, doc_target_dirs: impl Iterator<Item = Pa\n     )\n }\n \n-enum UrlMode {\n-    Url,\n-    File\n-}\n-\n /// Try to resolve path to local documentation via path-based links (i.e. `../gateway/struct.Shard.html`).\n-fn try_resolve_path(db: &RootDatabase, doc_target_dirs: impl Iterator<Item = PathBuf>, definition: &Definition, link: &str, mode: UrlMode) -> Option<String> {\n+fn try_resolve_path(db: &RootDatabase, definition: &Definition, link: &str) -> Option<String> {\n     eprintln!(\"try_resolve_path\");\n     let ns = if let Definition::ModuleDef(moddef) = definition {\n         ItemInNs::Types(moddef.clone().into())\n@@ -561,29 +546,13 @@ fn try_resolve_path(db: &RootDatabase, doc_target_dirs: impl Iterator<Item = Pat\n     // TODO: It should be possible to fall back to not-necessarilly-public paths if we can't find a public one,\n     // then hope rustdoc was run locally with `--document-private-items`\n     let base = import_map.path_of(ns)?;\n-    let mut base = once(format!(\"{}\", krate.display_name(db)?)).chain(base.segments.iter().map(|name| format!(\"{}\", name)));\n-\n-    match mode {\n-        UrlMode::Url => {\n-            let mut base = base.join(\"/\");\n-            get_doc_url(db, &krate)\n-                .and_then(|url| url.join(&base).ok())\n-                .and_then(|url| get_symbol_filename(db, definition).as_deref().map(|f| url.join(f).ok()).flatten())\n-                .and_then(|url| url.join(link).ok())\n-                .map(|url| url.into_string())\n-        },\n-        UrlMode::File => {\n-            let base = base.collect::<PathBuf>();\n-            doc_target_dirs\n-                .map(|dir| dir.join(format!(\"{}\", krate.display_name(db).unwrap())).join(base.join(\"..\").join(link)))\n-                .inspect(|path| eprintln!(\"candidate {}\", path.display()))\n-                .filter(|path| path.exists())\n-                .map(|path| format!(\"file:///{}\", path.display()))\n-                // \\. is treated as an escape in vscode's markdown hover rendering\n-                .map(|path_str| path_str.replace(\"\\\\\", \"/\"))\n-                .next()\n-        }\n-    }\n+    let base = once(format!(\"{}\", krate.display_name(db)?)).chain(base.segments.iter().map(|name| format!(\"{}\", name))).join(\"/\");\n+\n+    get_doc_url(db, &krate)\n+        .and_then(|url| url.join(&base).ok())\n+        .and_then(|url| get_symbol_filename(db, definition).as_deref().map(|f| url.join(f).ok()).flatten())\n+        .and_then(|url| url.join(link).ok())\n+        .map(|url| url.into_string())\n }\n \n /// Try to get the root URL of the documentation of a crate."}, {"sha": "ecac5134e6970e599a410210b8eb7a46a42ec903", "filename": "crates/ra_ide/src/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/108b953254e46851130e427b41cd143eee07fd02/crates%2Fra_ide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b953254e46851130e427b41cd143eee07fd02/crates%2Fra_ide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Flib.rs?ref=108b953254e46851130e427b41cd143eee07fd02", "patch": "@@ -54,7 +54,6 @@ use ra_ide_db::{\n     LineIndexDatabase,\n };\n use ra_syntax::{SourceFile, TextRange, TextSize};\n-use ra_project_model::ProjectWorkspace;\n \n use crate::display::ToNav;\n \n@@ -390,8 +389,8 @@ impl Analysis {\n     }\n \n     /// Returns a short text describing element at position.\n-    pub fn hover(&self, position: FilePosition, workspaces: Arc<Vec<ProjectWorkspace>>) -> Cancelable<Option<RangeInfo<HoverResult>>> {\n-        self.with_db(|db| hover::hover(db, position, workspaces))\n+    pub fn hover(&self, position: FilePosition) -> Cancelable<Option<RangeInfo<HoverResult>>> {\n+        self.with_db(|db| hover::hover(db, position))\n     }\n \n     /// Computes parameter information for the given call expression."}, {"sha": "f746bf1e725f3ab67afa0fd1cad3cdc56178fad6", "filename": "crates/ra_syntax/src/ast/test.txt", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5f52a516dedeab16ede8c26807c4ff79b3d308d3/crates%2Fra_syntax%2Fsrc%2Fast%2Ftest.txt", "raw_url": "https://github.com/rust-lang/rust/raw/5f52a516dedeab16ede8c26807c4ff79b3d308d3/crates%2Fra_syntax%2Fsrc%2Fast%2Ftest.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Ftest.txt?ref=5f52a516dedeab16ede8c26807c4ff79b3d308d3", "patch": "@@ -1,15 +0,0 @@\n-The context is a general utility struct provided on event dispatches, which\n-helps with dealing with the current \"context\" of the event dispatch.\n-The context also acts as a general high-level interface over the associated\n-[`Shard`] which received the event, or the low-level [`http`] module.\n-\n-The context contains \"shortcuts\", like for interacting with the shard.\n-Methods like [`set_activity`] will unlock the shard and perform an update for\n-you to save a bit of work.\n-\n-A context will only live for the event it was dispatched for. After the\n-event handler finished, it is destroyed and will not be re-used.\n-\n-[`Shard`]: ../gateway/struct.Shard.html\n-[`http`]: ../http/index.html\n-[`set_activity`]: #method.set_activity"}, {"sha": "a8f2454fd96e861209a9345911cef983ce41ace4", "filename": "crates/ra_syntax/src/ast/traits.rs", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/108b953254e46851130e427b41cd143eee07fd02/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b953254e46851130e427b41cd143eee07fd02/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs?ref=108b953254e46851130e427b41cd143eee07fd02", "patch": "@@ -146,39 +146,3 @@ impl Iterator for CommentIter {\n         self.iter.by_ref().find_map(|el| el.into_token().and_then(ast::Comment::cast))\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use comrak::{parse_document,format_commonmark, ComrakOptions, Arena};\n-    use comrak::nodes::{AstNode, NodeValue};\n-\n-    fn iter_nodes<'a, F>(node: &'a AstNode<'a>, f: &F)\n-        where F : Fn(&'a AstNode<'a>) {\n-        f(node);\n-        for c in node.children() {\n-            iter_nodes(c, f);\n-        }\n-    }\n-\n-    #[allow(non_snake_case)]\n-    #[test]\n-    fn test_link_rewrite() {\n-        let src = include_str!(\"./test.txt\");\n-\n-        let arena = Arena::new();\n-        let doc = parse_document(&arena, src, &ComrakOptions::default());\n-\n-        iter_nodes(doc, &|node| {\n-            match &mut node.data.borrow_mut().value {\n-                &mut NodeValue::Link(ref mut link) => {\n-                    link.url = \"https://www.google.com\".as_bytes().to_vec();\n-                },\n-                _ => ()\n-            }\n-        });\n-\n-        let mut out = Vec::new();\n-        format_commonmark(doc, &ComrakOptions::default(), &mut out);\n-        panic!(\"{}\", String::from_utf8(out).unwrap());\n-    }\n-}"}, {"sha": "951006771ec666440f7acf3d26204dc1fab428c3", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/108b953254e46851130e427b41cd143eee07fd02/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b953254e46851130e427b41cd143eee07fd02/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=108b953254e46851130e427b41cd143eee07fd02", "patch": "@@ -548,7 +548,7 @@ pub(crate) fn handle_hover(\n ) -> Result<Option<lsp_ext::Hover>> {\n     let _p = profile(\"handle_hover\");\n     let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n-    let info = match snap.analysis.hover(position)? {\n+    let info = match snap.analysis().hover(position)? {\n         None => return Ok(None),\n         Some(info) => info,\n     };"}]}