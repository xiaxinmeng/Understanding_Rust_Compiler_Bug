{"sha": "b2d476eb387b739e37f28435613596e027241fc5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyZDQ3NmViMzg3YjczOWUzN2YyODQzNTYxMzU5NmUwMjcyNDFmYzU=", "commit": {"author": {"name": "Oliver 'ker' Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-11-11T12:07:41Z"}, "committer": {"name": "Oliver 'ker' Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-11-11T12:07:41Z"}, "message": "`type_size` now returns `None` for unsized types", "tree": {"sha": "1902d9bd6d4788527dfd4bed7a5a0936ae88e1b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1902d9bd6d4788527dfd4bed7a5a0936ae88e1b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2d476eb387b739e37f28435613596e027241fc5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2d476eb387b739e37f28435613596e027241fc5", "html_url": "https://github.com/rust-lang/rust/commit/b2d476eb387b739e37f28435613596e027241fc5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2d476eb387b739e37f28435613596e027241fc5/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "921f5af1fe14dad904df3b5f6da47860b234a813", "url": "https://api.github.com/repos/rust-lang/rust/commits/921f5af1fe14dad904df3b5f6da47860b234a813", "html_url": "https://github.com/rust-lang/rust/commit/921f5af1fe14dad904df3b5f6da47860b234a813"}], "stats": {"total": 53, "additions": 31, "deletions": 22}, "files": [{"sha": "9c5dd30e378a02b58c9bb7444a1298dd35a621fa", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b2d476eb387b739e37f28435613596e027241fc5/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d476eb387b739e37f28435613596e027241fc5/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=b2d476eb387b739e37f28435613596e027241fc5", "patch": "@@ -182,7 +182,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         ty: Ty<'tcx>,\n         substs: &'tcx Substs<'tcx>\n     ) -> EvalResult<'tcx, Pointer> {\n-        let size = self.type_size_with_substs(ty, substs);\n+        let size = self.type_size_with_substs(ty, substs).expect(\"cannot alloc memory for unsized type\");\n         let align = self.type_align_with_substs(ty, substs);\n         self.memory.allocate(size, align)\n     }\n@@ -290,16 +290,21 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.tcx.normalize_associated_type(&substituted)\n     }\n \n-    fn type_size(&self, ty: Ty<'tcx>) -> usize {\n+    fn type_size(&self, ty: Ty<'tcx>) -> Option<usize> {\n         self.type_size_with_substs(ty, self.substs())\n     }\n \n     fn type_align(&self, ty: Ty<'tcx>) -> usize {\n         self.type_align_with_substs(ty, self.substs())\n     }\n \n-    fn type_size_with_substs(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> usize {\n-        self.type_layout_with_substs(ty, substs).size(&self.tcx.data_layout).bytes() as usize\n+    fn type_size_with_substs(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> Option<usize> {\n+        let layout = self.type_layout_with_substs(ty, substs);\n+        if layout.is_unsized() {\n+            None\n+        } else {\n+            Some(layout.size(&self.tcx.data_layout).bytes() as usize)\n+        }\n     }\n \n     fn type_align_with_substs(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> usize {\n@@ -480,7 +485,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                     Array { .. } => {\n                         let elem_size = match dest_ty.sty {\n-                            ty::TyArray(elem_ty, _) => self.type_size(elem_ty) as u64,\n+                            ty::TyArray(elem_ty, _) => self.type_size(elem_ty).expect(\"array elements are sized\") as u64,\n                             _ => bug!(\"tried to assign {:?} to non-array type {:?}\", kind, dest_ty),\n                         };\n                         let offsets = (0..).map(|i| i * elem_size);\n@@ -534,7 +539,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             } else {\n                                 for operand in operands {\n                                     let operand_ty = self.operand_ty(operand);\n-                                    assert_eq!(self.type_size(operand_ty), 0);\n+                                    assert_eq!(self.type_size(operand_ty), Some(0));\n                                 }\n                                 let offset = self.nonnull_offset(dest_ty, nndiscr, discrfield)?;\n \n@@ -576,7 +581,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     ty::TyArray(elem_ty, n) => (elem_ty, n),\n                     _ => bug!(\"tried to assign array-repeat to non-array type {:?}\", dest_ty),\n                 };\n-                let elem_size = self.type_size(elem_ty);\n+                let elem_size = self.type_size(elem_ty).expect(\"repeat element type must be sized\");\n                 let value = self.eval_operand(operand)?;\n \n                 // FIXME(solson)\n@@ -991,7 +996,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let (base_ptr, _) = base.to_ptr_and_extra();\n \n                 let (elem_ty, len) = base.elem_ty_and_len(base_ty);\n-                let elem_size = self.type_size(elem_ty);\n+                let elem_size = self.type_size(elem_ty).expect(\"slice element must be sized\");\n                 let n_ptr = self.eval_operand(operand)?;\n                 let usize = self.tcx.types.usize;\n                 let n = self.value_to_primval(n_ptr, usize)?\n@@ -1007,7 +1012,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let (base_ptr, _) = base.to_ptr_and_extra();\n \n                 let (elem_ty, n) = base.elem_ty_and_len(base_ty);\n-                let elem_size = self.type_size(elem_ty);\n+                let elem_size = self.type_size(elem_ty).expect(\"sequence element must be sized\");\n                 assert!(n >= min_length as u64);\n \n                 let index = if from_end {\n@@ -1026,7 +1031,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let (base_ptr, _) = base.to_ptr_and_extra();\n \n                 let (elem_ty, n) = base.elem_ty_and_len(base_ty);\n-                let elem_size = self.type_size(elem_ty);\n+                let elem_size = self.type_size(elem_ty).expect(\"slice element must be sized\");\n                 assert!((from as u64) <= n - (to as u64));\n                 let ptr = base_ptr.offset(from as isize * elem_size as isize);\n                 let extra = LvalueExtra::Length(n - to as u64 - from as u64);\n@@ -1046,7 +1051,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     fn copy(&mut self, src: Pointer, dest: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, ()> {\n-        let size = self.type_size(ty);\n+        let size = self.type_size(ty).expect(\"cannot copy from an unsized type\");\n         let align = self.type_align(ty);\n         self.memory.copy(src, dest, size, align)?;\n         Ok(())\n@@ -1512,7 +1517,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 for (i, (src_f, dst_f)) in iter {\n                     let src_fty = monomorphize_field_ty(self.tcx, src_f, substs_a);\n                     let dst_fty = monomorphize_field_ty(self.tcx, dst_f, substs_b);\n-                    if self.type_size(dst_fty) == 0 {\n+                    if self.type_size(dst_fty) == Some(0) {\n                         continue;\n                     }\n                     let src_field_offset = self.get_field_offset(src_ty, i)?.bytes() as isize;"}, {"sha": "280cabc07859365e07cf17da0722b0d2dc8266f0", "filename": "src/interpreter/terminator/intrinsics.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b2d476eb387b739e37f28435613596e027241fc5/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d476eb387b739e37f28435613596e027241fc5/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fintrinsics.rs?ref=b2d476eb387b739e37f28435613596e027241fc5", "patch": "@@ -96,7 +96,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"copy_nonoverlapping\" => {\n                 // FIXME: check whether overlapping occurs\n                 let elem_ty = substs.type_at(0);\n-                let elem_size = self.type_size(elem_ty);\n+                let elem_size = self.type_size(elem_ty).expect(\"cannot copy unsized value\");\n                 let elem_align = self.type_align(elem_ty);\n                 let src = arg_vals[0].read_ptr(&self.memory)?;\n                 let dest = arg_vals[1].read_ptr(&self.memory)?;\n@@ -230,7 +230,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"offset\" => {\n                 let pointee_ty = substs.type_at(0);\n-                let pointee_size = self.type_size(pointee_ty) as isize;\n+                let pointee_size = self.type_size(pointee_ty).expect(\"cannot offset a pointer to an unsized type\") as isize;\n                 let offset = self.value_to_primval(arg_vals[1], isize)?\n                     .expect_int(\"offset second arg not isize\");\n \n@@ -281,7 +281,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"size_of\" => {\n                 let ty = substs.type_at(0);\n-                let size = self.type_size(ty) as u64;\n+                // FIXME: change the `box_free` lang item to take `T: ?Sized` and have it use the\n+                // `size_of_val` intrinsic, then change this back to\n+                // .expect(\"size_of intrinsic called on unsized value\")\n+                // see https://github.com/rust-lang/rust/pull/37708\n+                let size = self.type_size(ty).unwrap_or(!0) as u64;\n                 let size_val = self.usize_primval(size);\n                 self.write_primval(dest, size_val)?;\n             }\n@@ -360,8 +364,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         value: Value,\n     ) -> EvalResult<'tcx, (u64, u64)> {\n         let pointer_size = self.memory.pointer_size();\n-        if self.type_is_sized(ty) {\n-            Ok((self.type_size(ty) as u64, self.type_align(ty) as u64))\n+        if let Some(size) = self.type_size(ty) {\n+            Ok((size as u64, self.type_align(ty) as u64))\n         } else {\n             match ty.sty {\n                 ty::TyAdt(def, substs) => {\n@@ -435,7 +439,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                 ty::TySlice(_) | ty::TyStr => {\n                     let elem_ty = ty.sequence_element_type(self.tcx);\n-                    let elem_size = self.type_size(elem_ty) as u64;\n+                    let elem_size = self.type_size(elem_ty).expect(\"slice element must be sized\") as u64;\n                     let len = value.expect_slice_len(&self.memory)?;\n                     let align = self.type_align(elem_ty);\n                     Ok((len * elem_size, align as u64))"}, {"sha": "0097e4d2c23581401354716aff39fc64fc32904c", "filename": "src/interpreter/terminator/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2d476eb387b739e37f28435613596e027241fc5/src%2Finterpreter%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d476eb387b739e37f28435613596e027241fc5/src%2Finterpreter%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fmod.rs?ref=b2d476eb387b739e37f28435613596e027241fc5", "patch": "@@ -193,7 +193,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             Abi::C => {\n                 let ty = fn_ty.sig.0.output;\n-                let size = self.type_size(ty);\n+                let size = self.type_size(ty).expect(\"function return type cannot be unsized\");\n                 let (ret, target) = destination.unwrap();\n                 self.call_c_abi(def_id, arg_operands, ret, size)?;\n                 self.goto_block(target);\n@@ -655,7 +655,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Lvalue::Ptr { ptr, extra: LvalueExtra::Length(len) } => (ptr, len as isize),\n                     _ => bug!(\"expected an lvalue with a length\"),\n                 };\n-                let size = self.type_size(elem_ty) as isize;\n+                let size = self.type_size(elem_ty).expect(\"slice element must be sized\") as isize;\n                 // FIXME: this creates a lot of stack frames if the element type has\n                 // a drop impl\n                 for i in 0..len {\n@@ -668,7 +668,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Lvalue::Ptr { ptr, extra } => (ptr, extra),\n                     _ => bug!(\"expected an lvalue with optional extra data\"),\n                 };\n-                let size = self.type_size(elem_ty) as isize;\n+                let size = self.type_size(elem_ty).expect(\"array element cannot be unsized\") as isize;\n                 // FIXME: this creates a lot of stack frames if the element type has\n                 // a drop impl\n                 for i in 0..len {"}, {"sha": "7320872724015f74933e5bb5a9b085f710634ce4", "filename": "src/interpreter/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2d476eb387b739e37f28435613596e027241fc5/src%2Finterpreter%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d476eb387b739e37f28435613596e027241fc5/src%2Finterpreter%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fvtable.rs?ref=b2d476eb387b739e37f28435613596e027241fc5", "patch": "@@ -78,7 +78,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n         }).collect();\n \n-        let size = self.type_size(trait_ref.self_ty());\n+        let size = self.type_size(trait_ref.self_ty()).expect(\"can't create a vtable for an unsized type\");\n         let align = self.type_align(trait_ref.self_ty());\n \n         let ptr_size = self.memory.pointer_size();"}]}