{"sha": "b507cd1745663c53cc4b3714de54206fce894ffd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1MDdjZDE3NDU2NjNjNTNjYzRiMzcxNGRlNTQyMDZmY2U4OTRmZmQ=", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2021-07-12T23:54:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-07-12T23:54:27Z"}, "message": "Rollup merge of #86344 - est31:maybe-uninit-extra, r=RalfJung\n\nSplit MaybeUninit::write into new feature gate and stabilize it\n\nThis splits off the `MaybeUninit::write` function from the `maybe_uninit_extra` feature gate into a new `maybe_uninit_write` feature gate and stabilizes it.\n\nEarlier work to improve the documentation of the write function: #86220\n\nTracking issue: #63567", "tree": {"sha": "30f1168e6e3fc2b26586b3fb162895b74b3e9217", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30f1168e6e3fc2b26586b3fb162895b74b3e9217"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b507cd1745663c53cc4b3714de54206fce894ffd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg7NY0CRBK7hj4Ov3rIwAAXAwIALIUoil4rm9vjwXFoUfW0kFp\nuATCSswZ9TaD9TDkPTsqilIxsDkbjM1KYojWBa73RM+KSFQzfnYA7zzKWMnpQxRf\nnFckV/4oXlrTY0HM9Wh4uOQ6yIX8SspH/2W7vNSNDl1dLulGZSr0HfFimqConQz+\n5C08SJRJgnYmtpT6HORFg6KQ8u5Ak7vlW5TmJnQ73hSRFM06V+sAYQXXMFNwZoSL\nWXzYmwBYtZt34qocme+iweStyOEfs5XqzCPDEVAnfCVJzrYDR7lb/wCwo2YbgyF6\n91xKgFeJj1hCbZjui3nd8VD7GBW5p9+hxS5v4RpwVE8VTpFc2046YgrfK1zib1A=\n=CALR\n-----END PGP SIGNATURE-----\n", "payload": "tree 30f1168e6e3fc2b26586b3fb162895b74b3e9217\nparent 955b9c0d4cd9176b53f518e01cbe175545c69947\nparent 848a6215914e7396172e7a3895bbdbbd6a6e3247\nauthor Yuki Okushi <jtitor@2k36.org> 1626134067 +0900\ncommitter GitHub <noreply@github.com> 1626134067 +0900\n\nRollup merge of #86344 - est31:maybe-uninit-extra, r=RalfJung\n\nSplit MaybeUninit::write into new feature gate and stabilize it\n\nThis splits off the `MaybeUninit::write` function from the `maybe_uninit_extra` feature gate into a new `maybe_uninit_write` feature gate and stabilizes it.\n\nEarlier work to improve the documentation of the write function: #86220\n\nTracking issue: #63567\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b507cd1745663c53cc4b3714de54206fce894ffd", "html_url": "https://github.com/rust-lang/rust/commit/b507cd1745663c53cc4b3714de54206fce894ffd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b507cd1745663c53cc4b3714de54206fce894ffd/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "955b9c0d4cd9176b53f518e01cbe175545c69947", "url": "https://api.github.com/repos/rust-lang/rust/commits/955b9c0d4cd9176b53f518e01cbe175545c69947", "html_url": "https://github.com/rust-lang/rust/commit/955b9c0d4cd9176b53f518e01cbe175545c69947"}, {"sha": "848a6215914e7396172e7a3895bbdbbd6a6e3247", "url": "https://api.github.com/repos/rust-lang/rust/commits/848a6215914e7396172e7a3895bbdbbd6a6e3247", "html_url": "https://github.com/rust-lang/rust/commit/848a6215914e7396172e7a3895bbdbbd6a6e3247"}], "stats": {"total": 58, "additions": 43, "deletions": 15}, "files": [{"sha": "5122421ea8c852fdef7afbbba7c3f58075f49a0f", "filename": "library/core/src/mem/maybe_uninit.rs", "status": "modified", "additions": 43, "deletions": 15, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/b507cd1745663c53cc4b3714de54206fce894ffd/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b507cd1745663c53cc4b3714de54206fce894ffd/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs?ref=b507cd1745663c53cc4b3714de54206fce894ffd", "patch": "@@ -79,7 +79,7 @@ use crate::ptr;\n /// // a `MaybeUninit<T>` may be invalid, and hence this is not UB:\n /// let mut x = MaybeUninit::<&i32>::uninit();\n /// // Set it to a valid value.\n-/// unsafe { x.as_mut_ptr().write(&0); }\n+/// x.write(&0);\n /// // Extract the initialized data -- this is only allowed *after* properly\n /// // initializing `x`!\n /// let x = unsafe { x.assume_init() };\n@@ -135,7 +135,7 @@ use crate::ptr;\n ///     // this loop, we have a memory leak, but there is no memory safety\n ///     // issue.\n ///     for elem in &mut data[..] {\n-///         *elem = MaybeUninit::new(vec![42]);\n+///         elem.write(vec![42]);\n ///     }\n ///\n ///     // Everything is initialized. Transmute the array to the\n@@ -161,7 +161,7 @@ use crate::ptr;\n /// let mut data_len: usize = 0;\n ///\n /// for elem in &mut data[0..500] {\n-///     *elem = MaybeUninit::new(String::from(\"hello\"));\n+///     elem.write(String::from(\"hello\"));\n ///     data_len += 1;\n /// }\n ///\n@@ -410,7 +410,7 @@ impl<T> MaybeUninit<T> {\n     /// (now safely initialized) contents of `self`.\n     ///\n     /// As the content is stored inside a `MaybeUninit`, the destructor is not\n-    /// ran for the inner data if the MaybeUninit leaves scope without a call to\n+    /// run for the inner data if the MaybeUninit leaves scope without a call to\n     /// [`assume_init`], [`assume_init_drop`], or similar. Code that receives\n     /// the mutable reference returned by this function needs to keep this in\n     /// mind. The safety model of Rust regards leaks as safe, but they are\n@@ -426,7 +426,6 @@ impl<T> MaybeUninit<T> {\n     /// Correct usage of this method:\n     ///\n     /// ```rust\n-    /// #![feature(maybe_uninit_extra)]\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let mut x = MaybeUninit::<Vec<u8>>::uninit();\n@@ -445,7 +444,6 @@ impl<T> MaybeUninit<T> {\n     /// This usage of the method causes a leak:\n     ///\n     /// ```rust\n-    /// #![feature(maybe_uninit_extra)]\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let mut x = MaybeUninit::<String>::uninit();\n@@ -456,8 +454,38 @@ impl<T> MaybeUninit<T> {\n     /// // x is initialized now:\n     /// let s = unsafe { x.assume_init() };\n     /// ```\n-    #[unstable(feature = \"maybe_uninit_extra\", issue = \"63567\")]\n-    #[rustc_const_unstable(feature = \"maybe_uninit_extra\", issue = \"63567\")]\n+    ///\n+    /// This method can be used to avoid unsafe in some cases. The example below\n+    /// shows a part of an implementation of a fixed sized arena that lends out\n+    /// pinned references.\n+    /// With `write`, we can avoid the need to write through a raw pointer:\n+    ///\n+    /// ```rust\n+    /// #![feature(maybe_uninit_extra)]\n+    /// use core::pin::Pin;\n+    /// use core::mem::MaybeUninit;\n+    ///\n+    /// struct PinArena<T> {\n+    ///     memory: Box<[MaybeUninit<T>]>,\n+    ///     len: usize,\n+    /// }\n+    ///\n+    /// impl <T> PinArena<T> {\n+    ///     pub fn capacity(&self) -> usize {\n+    ///         self.memory.len()\n+    ///     }\n+    ///     pub fn push(&mut self, val: T) -> Pin<&mut T> {\n+    ///         if self.len >= self.capacity() {\n+    ///             panic!(\"Attempted to push to a full pin arena!\");\n+    ///         }\n+    ///         let ref_ = self.memory[self.len].write(val);\n+    ///         self.len += 1;\n+    ///         unsafe { Pin::new_unchecked(ref_) }\n+    ///     }\n+    /// }\n+    /// ```\n+    #[stable(feature = \"maybe_uninit_write\", since = \"1.55.0\")]\n+    #[rustc_const_unstable(feature = \"const_maybe_uninit_write\", issue = \"63567\")]\n     #[inline(always)]\n     pub const fn write(&mut self, val: T) -> &mut T {\n         *self = MaybeUninit::new(val);\n@@ -478,7 +506,7 @@ impl<T> MaybeUninit<T> {\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n-    /// unsafe { x.as_mut_ptr().write(vec![0, 1, 2]); }\n+    /// x.write(vec![0, 1, 2]);\n     /// // Create a reference into the `MaybeUninit<T>`. This is okay because we initialized it.\n     /// let x_vec = unsafe { &*x.as_ptr() };\n     /// assert_eq!(x_vec.len(), 3);\n@@ -515,7 +543,7 @@ impl<T> MaybeUninit<T> {\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n-    /// unsafe { x.as_mut_ptr().write(vec![0, 1, 2]); }\n+    /// x.write(vec![0, 1, 2]);\n     /// // Create a reference into the `MaybeUninit<Vec<u32>>`.\n     /// // This is okay because we initialized it.\n     /// let x_vec = unsafe { &mut *x.as_mut_ptr() };\n@@ -574,7 +602,7 @@ impl<T> MaybeUninit<T> {\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let mut x = MaybeUninit::<bool>::uninit();\n-    /// unsafe { x.as_mut_ptr().write(true); }\n+    /// x.write(true);\n     /// let x_init = unsafe { x.assume_init() };\n     /// assert_eq!(x_init, true);\n     /// ```\n@@ -723,7 +751,7 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n     /// // Initialize `x`:\n-    /// unsafe { x.as_mut_ptr().write(vec![1, 2, 3]); }\n+    /// x.write(vec![1, 2, 3]);\n     /// // Now that our `MaybeUninit<_>` is known to be initialized, it is okay to\n     /// // create a shared reference to it:\n     /// let x: &Vec<u32> = unsafe {\n@@ -897,9 +925,9 @@ impl<T> MaybeUninit<T> {\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let mut array: [MaybeUninit<i32>; 3] = MaybeUninit::uninit_array();\n-    /// array[0] = MaybeUninit::new(0);\n-    /// array[1] = MaybeUninit::new(1);\n-    /// array[2] = MaybeUninit::new(2);\n+    /// array[0].write(0);\n+    /// array[1].write(1);\n+    /// array[2].write(2);\n     ///\n     /// // SAFETY: Now safe as we initialised all elements\n     /// let array = unsafe {"}]}