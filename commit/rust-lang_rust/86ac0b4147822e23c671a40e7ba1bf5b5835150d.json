{"sha": "86ac0b4147822e23c671a40e7ba1bf5b5835150d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2YWMwYjQxNDc4MjJlMjNjNjcxYTQwZTdiYTFiZjViNTgzNTE1MGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-26T23:13:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-26T23:13:15Z"}, "message": "Auto merge of #85652 - ehuss:linkchecker-perf, r=Mark-Simulacrum\n\nOptimize linkchecker and add report.\n\nThis makes three changes to the linkchecker:\n\n* Adds a report displayed after it finishes.\n* Improves the performance by caching all filesystem access. The linkchecker can take over a minute to run on some systems, and this should make it about 2-3 times faster.\n* Added a few tests.", "tree": {"sha": "bbb9ceaa0b716caf31ada4872cd3e555cd415bb9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bbb9ceaa0b716caf31ada4872cd3e555cd415bb9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86ac0b4147822e23c671a40e7ba1bf5b5835150d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86ac0b4147822e23c671a40e7ba1bf5b5835150d", "html_url": "https://github.com/rust-lang/rust/commit/86ac0b4147822e23c671a40e7ba1bf5b5835150d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86ac0b4147822e23c671a40e7ba1bf5b5835150d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9111b8ae9793f18179a1336417618fc07a9cac85", "url": "https://api.github.com/repos/rust-lang/rust/commits/9111b8ae9793f18179a1336417618fc07a9cac85", "html_url": "https://github.com/rust-lang/rust/commit/9111b8ae9793f18179a1336417618fc07a9cac85"}, {"sha": "b6532ebeeb31f3e1236e23bffbd36327979458dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6532ebeeb31f3e1236e23bffbd36327979458dc", "html_url": "https://github.com/rust-lang/rust/commit/b6532ebeeb31f3e1236e23bffbd36327979458dc"}], "stats": {"total": 732, "additions": 505, "deletions": 227}, "files": [{"sha": "076b3653583b79c8bab6919219f09ade2099d090", "filename": "src/tools/linkchecker/main.rs", "status": "modified", "additions": 318, "deletions": 227, "changes": 545, "blob_url": "https://github.com/rust-lang/rust/blob/86ac0b4147822e23c671a40e7ba1bf5b5835150d/src%2Ftools%2Flinkchecker%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86ac0b4147822e23c671a40e7ba1bf5b5835150d/src%2Ftools%2Flinkchecker%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Fmain.rs?ref=86ac0b4147822e23c671a40e7ba1bf5b5835150d", "patch": "@@ -14,18 +14,18 @@\n //! A few exceptions are allowed as there's known bugs in rustdoc, but this\n //! should catch the majority of \"broken link\" cases.\n \n-use std::collections::hash_map::Entry;\n+use std::cell::RefCell;\n use std::collections::{HashMap, HashSet};\n use std::env;\n use std::fs;\n+use std::io::ErrorKind;\n use std::path::{Component, Path, PathBuf};\n use std::rc::Rc;\n+use std::time::Instant;\n \n use once_cell::sync::Lazy;\n use regex::Regex;\n \n-use crate::Redirect::*;\n-\n // Add linkcheck exceptions here\n // If at all possible you should use intra-doc links to avoid linkcheck issues. These\n // are cases where that does not work\n@@ -87,33 +87,64 @@ macro_rules! t {\n }\n \n fn main() {\n-    let docs = env::args_os().nth(1).unwrap();\n+    let docs = env::args_os().nth(1).expect(\"doc path should be first argument\");\n     let docs = env::current_dir().unwrap().join(docs);\n-    let mut errors = false;\n-    walk(&mut HashMap::new(), &docs, &docs, &mut errors);\n-    if errors {\n-        panic!(\"found some broken links\");\n+    let mut checker = Checker { root: docs.clone(), cache: HashMap::new() };\n+    let mut report = Report {\n+        errors: 0,\n+        start: Instant::now(),\n+        html_files: 0,\n+        html_redirects: 0,\n+        links_checked: 0,\n+        links_ignored_external: 0,\n+        links_ignored_exception: 0,\n+        intra_doc_exceptions: 0,\n+    };\n+    checker.walk(&docs, &mut report);\n+    report.report();\n+    if report.errors != 0 {\n+        println!(\"found some broken links\");\n+        std::process::exit(1);\n     }\n }\n \n-#[derive(Debug)]\n-pub enum LoadError {\n-    IOError(std::io::Error),\n-    BrokenRedirect(PathBuf, std::io::Error),\n-    IsRedirect,\n+struct Checker {\n+    root: PathBuf,\n+    cache: Cache,\n }\n \n-enum Redirect {\n-    SkipRedirect,\n-    FromRedirect(bool),\n+struct Report {\n+    errors: u32,\n+    start: Instant,\n+    html_files: u32,\n+    html_redirects: u32,\n+    links_checked: u32,\n+    links_ignored_external: u32,\n+    links_ignored_exception: u32,\n+    intra_doc_exceptions: u32,\n }\n \n-struct FileEntry {\n-    source: Rc<String>,\n-    ids: HashSet<String>,\n+/// A cache entry.\n+enum FileEntry {\n+    /// An HTML file.\n+    ///\n+    /// This includes the contents of the HTML file, and an optional set of\n+    /// HTML IDs. The IDs are used for checking fragments. The are computed\n+    /// as-needed. The source is discarded (replaced with an empty string)\n+    /// after the file has been checked, to conserve on memory.\n+    HtmlFile { source: Rc<String>, ids: RefCell<HashSet<String>> },\n+    /// This file is an HTML redirect to the given local path.\n+    Redirect { target: PathBuf },\n+    /// This is not an HTML file.\n+    OtherFile,\n+    /// This is a directory.\n+    Dir,\n+    /// The file doesn't exist.\n+    Missing,\n }\n \n-type Cache = HashMap<PathBuf, FileEntry>;\n+/// A cache to speed up file access.\n+type Cache = HashMap<String, FileEntry>;\n \n fn small_url_encode(s: &str) -> String {\n     s.replace(\"<\", \"%3C\")\n@@ -130,173 +161,169 @@ fn small_url_encode(s: &str) -> String {\n         .replace(\"\\\"\", \"%22\")\n }\n \n-impl FileEntry {\n-    fn parse_ids(&mut self, file: &Path, contents: &str, errors: &mut bool) {\n-        if self.ids.is_empty() {\n-            with_attrs_in_source(contents, \" id\", |fragment, i, _| {\n-                let frag = fragment.trim_start_matches(\"#\").to_owned();\n-                let encoded = small_url_encode(&frag);\n-                if !self.ids.insert(frag) {\n-                    *errors = true;\n-                    println!(\"{}:{}: id is not unique: `{}`\", file.display(), i, fragment);\n-                }\n-                // Just in case, we also add the encoded id.\n-                self.ids.insert(encoded);\n-            });\n-        }\n-    }\n-}\n-\n-fn walk(cache: &mut Cache, root: &Path, dir: &Path, errors: &mut bool) {\n-    for entry in t!(dir.read_dir()).map(|e| t!(e)) {\n-        let path = entry.path();\n-        let kind = t!(entry.file_type());\n-        if kind.is_dir() {\n-            walk(cache, root, &path, errors);\n-        } else {\n-            let pretty_path = check(cache, root, &path, errors);\n-            if let Some(pretty_path) = pretty_path {\n-                let entry = cache.get_mut(&pretty_path).unwrap();\n-                // we don't need the source anymore,\n-                // so drop to reduce memory-usage\n-                entry.source = Rc::new(String::new());\n+impl Checker {\n+    /// Primary entry point for walking the filesystem to find HTML files to check.\n+    fn walk(&mut self, dir: &Path, report: &mut Report) {\n+        for entry in t!(dir.read_dir()).map(|e| t!(e)) {\n+            let path = entry.path();\n+            let kind = t!(entry.file_type());\n+            if kind.is_dir() {\n+                self.walk(&path, report);\n+            } else {\n+                self.check(&path, report);\n             }\n         }\n     }\n-}\n-\n-fn is_intra_doc_exception(file: &Path, link: &str) -> bool {\n-    if let Some(entry) = INTRA_DOC_LINK_EXCEPTIONS.iter().find(|&(f, _)| file.ends_with(f)) {\n-        entry.1.is_empty() || entry.1.contains(&link)\n-    } else {\n-        false\n-    }\n-}\n \n-fn is_exception(file: &Path, link: &str) -> bool {\n-    if let Some(entry) = LINKCHECK_EXCEPTIONS.iter().find(|&(f, _)| file.ends_with(f)) {\n-        entry.1.contains(&link)\n-    } else {\n-        // FIXME(#63351): Concat trait in alloc/slice reexported in primitive page\n-        //\n-        // NOTE: This cannot be added to `LINKCHECK_EXCEPTIONS` because the resolved path\n-        // calculated in `check` function is outside `build/<triple>/doc` dir.\n-        // So the `strip_prefix` method just returns the old absolute broken path.\n-        if file.ends_with(\"std/primitive.slice.html\") {\n-            if link.ends_with(\"primitive.slice.html\") {\n-                return true;\n+    /// Checks a single file.\n+    fn check(&mut self, file: &Path, report: &mut Report) {\n+        let (pretty_path, entry) = self.load_file(file, report);\n+        let source = match entry {\n+            FileEntry::Missing => panic!(\"missing file {:?} while walking\", file),\n+            FileEntry::Dir => unreachable!(\"never with `check` path\"),\n+            FileEntry::OtherFile => return,\n+            FileEntry::Redirect { .. } => return,\n+            FileEntry::HtmlFile { source, ids } => {\n+                parse_ids(&mut ids.borrow_mut(), &pretty_path, source, report);\n+                source.clone()\n             }\n-        }\n-        false\n-    }\n-}\n-\n-fn check(cache: &mut Cache, root: &Path, file: &Path, errors: &mut bool) -> Option<PathBuf> {\n-    // Ignore non-HTML files.\n-    if file.extension().and_then(|s| s.to_str()) != Some(\"html\") {\n-        return None;\n-    }\n+        };\n \n-    let res = load_file(cache, root, file, SkipRedirect);\n-    let (pretty_file, contents) = match res {\n-        Ok(res) => res,\n-        Err(_) => return None,\n-    };\n-    {\n-        cache.get_mut(&pretty_file).unwrap().parse_ids(&pretty_file, &contents, errors);\n-    }\n+        // Search for anything that's the regex 'href[ ]*=[ ]*\".*?\"'\n+        with_attrs_in_source(&source, \" href\", |url, i, base| {\n+            // Ignore external URLs\n+            if url.starts_with(\"http:\")\n+                || url.starts_with(\"https:\")\n+                || url.starts_with(\"javascript:\")\n+                || url.starts_with(\"ftp:\")\n+                || url.starts_with(\"irc:\")\n+                || url.starts_with(\"data:\")\n+            {\n+                report.links_ignored_external += 1;\n+                return;\n+            }\n+            report.links_checked += 1;\n+            let (url, fragment) = match url.split_once('#') {\n+                None => (url, None),\n+                Some((url, fragment)) => (url, Some(fragment)),\n+            };\n+            // NB: the `splitn` always succeeds, even if the delimiter is not present.\n+            let url = url.splitn(2, '?').next().unwrap();\n+\n+            // Once we've plucked out the URL, parse it using our base url and\n+            // then try to extract a file path.\n+            let mut path = file.to_path_buf();\n+            if !base.is_empty() || !url.is_empty() {\n+                path.pop();\n+                for part in Path::new(base).join(url).components() {\n+                    match part {\n+                        Component::Prefix(_) | Component::RootDir => {\n+                            // Avoid absolute paths as they make the docs not\n+                            // relocatable by making assumptions on where the docs\n+                            // are hosted relative to the site root.\n+                            report.errors += 1;\n+                            println!(\n+                                \"{}:{}: absolute path - {}\",\n+                                pretty_path,\n+                                i + 1,\n+                                Path::new(base).join(url).display()\n+                            );\n+                            return;\n+                        }\n+                        Component::CurDir => {}\n+                        Component::ParentDir => {\n+                            path.pop();\n+                        }\n+                        Component::Normal(s) => {\n+                            path.push(s);\n+                        }\n+                    }\n+                }\n+            }\n \n-    // Search for anything that's the regex 'href[ ]*=[ ]*\".*?\"'\n-    with_attrs_in_source(&contents, \" href\", |url, i, base| {\n-        // Ignore external URLs\n-        if url.starts_with(\"http:\")\n-            || url.starts_with(\"https:\")\n-            || url.starts_with(\"javascript:\")\n-            || url.starts_with(\"ftp:\")\n-            || url.starts_with(\"irc:\")\n-            || url.starts_with(\"data:\")\n-        {\n-            return;\n-        }\n-        let (url, fragment) = match url.split_once('#') {\n-            None => (url, None),\n-            Some((url, fragment)) => (url, Some(fragment)),\n-        };\n-        // NB: the `splitn` always succeeds, even if the delimiter is not present.\n-        let url = url.splitn(2, '?').next().unwrap();\n-\n-        // Once we've plucked out the URL, parse it using our base url and\n-        // then try to extract a file path.\n-        let mut path = file.to_path_buf();\n-        if !base.is_empty() || !url.is_empty() {\n-            path.pop();\n-            for part in Path::new(base).join(url).components() {\n-                match part {\n-                    Component::Prefix(_) | Component::RootDir => {\n-                        // Avoid absolute paths as they make the docs not\n-                        // relocatable by making assumptions on where the docs\n-                        // are hosted relative to the site root.\n-                        *errors = true;\n+            let (target_pretty_path, target_entry) = self.load_file(&path, report);\n+            let (target_source, target_ids) = match target_entry {\n+                FileEntry::Missing => {\n+                    if is_exception(file, &target_pretty_path) {\n+                        report.links_ignored_exception += 1;\n+                    } else {\n+                        report.errors += 1;\n                         println!(\n-                            \"{}:{}: absolute path - {}\",\n-                            pretty_file.display(),\n+                            \"{}:{}: broken link - `{}`\",\n+                            pretty_path,\n                             i + 1,\n-                            Path::new(base).join(url).display()\n+                            target_pretty_path\n                         );\n-                        return;\n-                    }\n-                    Component::CurDir => {}\n-                    Component::ParentDir => {\n-                        path.pop();\n                     }\n-                    Component::Normal(s) => {\n-                        path.push(s);\n-                    }\n-                }\n-            }\n-        }\n-\n-        // Alright, if we've found a file name then this file had better\n-        // exist! If it doesn't then we register and print an error.\n-        if path.exists() {\n-            if path.is_dir() {\n-                // Links to directories show as directory listings when viewing\n-                // the docs offline so it's best to avoid them.\n-                *errors = true;\n-                let pretty_path = path.strip_prefix(root).unwrap_or(&path);\n-                println!(\n-                    \"{}:{}: directory link - {}\",\n-                    pretty_file.display(),\n-                    i + 1,\n-                    pretty_path.display()\n-                );\n-                return;\n-            }\n-            if let Some(extension) = path.extension() {\n-                // Ignore none HTML files.\n-                if extension != \"html\" {\n                     return;\n                 }\n-            }\n-            let res = load_file(cache, root, &path, FromRedirect(false));\n-            let (pretty_path, contents) = match res {\n-                Ok(res) => res,\n-                Err(LoadError::IOError(err)) => {\n-                    panic!(\"error loading {}: {}\", path.display(), err);\n-                }\n-                Err(LoadError::BrokenRedirect(target, _)) => {\n-                    *errors = true;\n+                FileEntry::Dir => {\n+                    // Links to directories show as directory listings when viewing\n+                    // the docs offline so it's best to avoid them.\n+                    report.errors += 1;\n                     println!(\n-                        \"{}:{}: broken redirect to {}\",\n-                        pretty_file.display(),\n+                        \"{}:{}: directory link to `{}` \\\n+                         (directory links should use index.html instead)\",\n+                        pretty_path,\n                         i + 1,\n-                        target.display()\n+                        target_pretty_path\n                     );\n                     return;\n                 }\n-                Err(LoadError::IsRedirect) => unreachable!(),\n+                FileEntry::OtherFile => return,\n+                FileEntry::Redirect { target } => {\n+                    let t = target.clone();\n+                    drop(target);\n+                    let (target, redir_entry) = self.load_file(&t, report);\n+                    match redir_entry {\n+                        FileEntry::Missing => {\n+                            report.errors += 1;\n+                            println!(\n+                                \"{}:{}: broken redirect from `{}` to `{}`\",\n+                                pretty_path,\n+                                i + 1,\n+                                target_pretty_path,\n+                                target\n+                            );\n+                            return;\n+                        }\n+                        FileEntry::Redirect { target } => {\n+                            // Redirect to a redirect, this link checker\n+                            // currently doesn't support this, since it would\n+                            // require cycle checking, etc.\n+                            report.errors += 1;\n+                            println!(\n+                                \"{}:{}: redirect from `{}` to `{}` \\\n+                                 which is also a redirect (not supported)\",\n+                                pretty_path,\n+                                i + 1,\n+                                target_pretty_path,\n+                                target.display()\n+                            );\n+                            return;\n+                        }\n+                        FileEntry::Dir => {\n+                            report.errors += 1;\n+                            println!(\n+                                \"{}:{}: redirect from `{}` to `{}` \\\n+                                 which is a directory \\\n+                                 (directory links should use index.html instead)\",\n+                                pretty_path,\n+                                i + 1,\n+                                target_pretty_path,\n+                                target\n+                            );\n+                            return;\n+                        }\n+                        FileEntry::OtherFile => return,\n+                        FileEntry::HtmlFile { source, ids } => (source, ids),\n+                    }\n+                }\n+                FileEntry::HtmlFile { source, ids } => (source, ids),\n             };\n \n+            // Alright, if we've found an HTML file for the target link. If\n+            // this is a fragment link, also check that the `id` exists.\n             if let Some(ref fragment) = fragment {\n                 // Fragments like `#1-6` are most likely line numbers to be\n                 // interpreted by javascript, so we're ignoring these\n@@ -309,80 +336,129 @@ fn check(cache: &mut Cache, root: &Path, file: &Path, errors: &mut bool) -> Opti\n                     return;\n                 }\n \n-                let entry = &mut cache.get_mut(&pretty_path).unwrap();\n-                entry.parse_ids(&pretty_path, &contents, errors);\n+                parse_ids(&mut target_ids.borrow_mut(), &pretty_path, target_source, report);\n+\n+                if target_ids.borrow().contains(*fragment) {\n+                    return;\n+                }\n \n-                if !entry.ids.contains(*fragment) && !is_exception(file, &format!(\"#{}\", fragment))\n-                {\n-                    *errors = true;\n-                    print!(\"{}:{}: broken link fragment \", pretty_file.display(), i + 1);\n-                    println!(\"`#{}` pointing to `{}`\", fragment, pretty_path.display());\n+                if is_exception(file, &format!(\"#{}\", fragment)) {\n+                    report.links_ignored_exception += 1;\n+                } else {\n+                    report.errors += 1;\n+                    print!(\"{}:{}: broken link fragment \", pretty_path, i + 1);\n+                    println!(\"`#{}` pointing to `{}`\", fragment, pretty_path);\n                 };\n             }\n-        } else {\n-            let pretty_path = path.strip_prefix(root).unwrap_or(&path);\n-            if !is_exception(file, pretty_path.to_str().unwrap()) {\n-                *errors = true;\n-                print!(\"{}:{}: broken link - \", pretty_file.display(), i + 1);\n-                println!(\"{}\", pretty_path.display());\n+        });\n+\n+        // Search for intra-doc links that rustdoc didn't warn about\n+        // FIXME(#77199, 77200) Rustdoc should just warn about these directly.\n+        // NOTE: only looks at one line at a time; in practice this should find most links\n+        for (i, line) in source.lines().enumerate() {\n+            for broken_link in BROKEN_INTRA_DOC_LINK.captures_iter(line) {\n+                if is_intra_doc_exception(file, &broken_link[1]) {\n+                    report.intra_doc_exceptions += 1;\n+                } else {\n+                    report.errors += 1;\n+                    print!(\"{}:{}: broken intra-doc link - \", pretty_path, i + 1);\n+                    println!(\"{}\", &broken_link[0]);\n+                }\n             }\n         }\n-    });\n-\n-    // Search for intra-doc links that rustdoc didn't warn about\n-    // FIXME(#77199, 77200) Rustdoc should just warn about these directly.\n-    // NOTE: only looks at one line at a time; in practice this should find most links\n-    for (i, line) in contents.lines().enumerate() {\n-        for broken_link in BROKEN_INTRA_DOC_LINK.captures_iter(line) {\n-            if !is_intra_doc_exception(file, &broken_link[1]) {\n-                *errors = true;\n-                print!(\"{}:{}: broken intra-doc link - \", pretty_file.display(), i + 1);\n-                println!(\"{}\", &broken_link[0]);\n-            }\n+        // we don't need the source anymore,\n+        // so drop to reduce memory-usage\n+        match self.cache.get_mut(&pretty_path).unwrap() {\n+            FileEntry::HtmlFile { source, .. } => *source = Rc::new(String::new()),\n+            _ => unreachable!(\"must be html file\"),\n         }\n     }\n-    Some(pretty_file)\n-}\n \n-fn load_file(\n-    cache: &mut Cache,\n-    root: &Path,\n-    file: &Path,\n-    redirect: Redirect,\n-) -> Result<(PathBuf, Rc<String>), LoadError> {\n-    let pretty_file = PathBuf::from(file.strip_prefix(root).unwrap_or(&file));\n-\n-    let (maybe_redirect, contents) = match cache.entry(pretty_file.clone()) {\n-        Entry::Occupied(entry) => (None, entry.get().source.clone()),\n-        Entry::Vacant(entry) => {\n-            let contents = match fs::read_to_string(file) {\n-                Ok(s) => Rc::new(s),\n-                Err(err) => {\n-                    return Err(if let FromRedirect(true) = redirect {\n-                        LoadError::BrokenRedirect(file.to_path_buf(), err)\n+    /// Load a file from disk, or from the cache if available.\n+    fn load_file(&mut self, file: &Path, report: &mut Report) -> (String, &FileEntry) {\n+        let pretty_path =\n+            file.strip_prefix(&self.root).unwrap_or(&file).to_str().unwrap().to_string();\n+\n+        let entry =\n+            self.cache.entry(pretty_path.clone()).or_insert_with(|| match fs::metadata(file) {\n+                Ok(metadata) if metadata.is_dir() => FileEntry::Dir,\n+                Ok(_) => {\n+                    if file.extension().and_then(|s| s.to_str()) != Some(\"html\") {\n+                        FileEntry::OtherFile\n                     } else {\n-                        LoadError::IOError(err)\n-                    });\n+                        report.html_files += 1;\n+                        load_html_file(file, report)\n+                    }\n                 }\n-            };\n-\n-            let maybe = maybe_redirect(&contents);\n-            if maybe.is_some() {\n-                if let SkipRedirect = redirect {\n-                    return Err(LoadError::IsRedirect);\n+                Err(e) if e.kind() == ErrorKind::NotFound => FileEntry::Missing,\n+                Err(e) => {\n+                    panic!(\"unexpected read error for {}: {}\", file.display(), e);\n                 }\n-            } else {\n-                entry.insert(FileEntry { source: contents.clone(), ids: HashSet::new() });\n-            }\n-            (maybe, contents)\n+            });\n+        (pretty_path, entry)\n+    }\n+}\n+\n+impl Report {\n+    fn report(&self) {\n+        println!(\"checked links in: {:.1}s\", self.start.elapsed().as_secs_f64());\n+        println!(\"number of HTML files scanned: {}\", self.html_files);\n+        println!(\"number of HTML redirects found: {}\", self.html_redirects);\n+        println!(\"number of links checked: {}\", self.links_checked);\n+        println!(\"number of links ignored due to external: {}\", self.links_ignored_external);\n+        println!(\"number of links ignored due to exceptions: {}\", self.links_ignored_exception);\n+        println!(\"number of intra doc links ignored: {}\", self.intra_doc_exceptions);\n+        println!(\"errors found: {}\", self.errors);\n+    }\n+}\n+\n+fn load_html_file(file: &Path, report: &mut Report) -> FileEntry {\n+    let source = match fs::read_to_string(file) {\n+        Ok(s) => Rc::new(s),\n+        Err(err) => {\n+            // This usually should not fail since `metadata` was already\n+            // called successfully on this file.\n+            panic!(\"unexpected read error for {}: {}\", file.display(), err);\n         }\n     };\n-    match maybe_redirect.map(|url| file.parent().unwrap().join(url)) {\n-        Some(redirect_file) => load_file(cache, root, &redirect_file, FromRedirect(true)),\n-        None => Ok((pretty_file, contents)),\n+    match maybe_redirect(&source) {\n+        Some(target) => {\n+            report.html_redirects += 1;\n+            let target = file.parent().unwrap().join(target);\n+            FileEntry::Redirect { target }\n+        }\n+        None => FileEntry::HtmlFile { source: source.clone(), ids: RefCell::new(HashSet::new()) },\n+    }\n+}\n+\n+fn is_intra_doc_exception(file: &Path, link: &str) -> bool {\n+    if let Some(entry) = INTRA_DOC_LINK_EXCEPTIONS.iter().find(|&(f, _)| file.ends_with(f)) {\n+        entry.1.is_empty() || entry.1.contains(&link)\n+    } else {\n+        false\n     }\n }\n \n+fn is_exception(file: &Path, link: &str) -> bool {\n+    if let Some(entry) = LINKCHECK_EXCEPTIONS.iter().find(|&(f, _)| file.ends_with(f)) {\n+        entry.1.contains(&link)\n+    } else {\n+        // FIXME(#63351): Concat trait in alloc/slice reexported in primitive page\n+        //\n+        // NOTE: This cannot be added to `LINKCHECK_EXCEPTIONS` because the resolved path\n+        // calculated in `check` function is outside `build/<triple>/doc` dir.\n+        // So the `strip_prefix` method just returns the old absolute broken path.\n+        if file.ends_with(\"std/primitive.slice.html\") {\n+            if link.ends_with(\"primitive.slice.html\") {\n+                return true;\n+            }\n+        }\n+        false\n+    }\n+}\n+\n+/// If the given HTML file contents is an HTML redirect, this returns the\n+/// destination path given in the redirect.\n fn maybe_redirect(source: &str) -> Option<String> {\n     const REDIRECT: &str = \"<p>Redirecting to <a href=\";\n \n@@ -396,9 +472,9 @@ fn maybe_redirect(source: &str) -> Option<String> {\n     })\n }\n \n-fn with_attrs_in_source<F: FnMut(&str, usize, &str)>(contents: &str, attr: &str, mut f: F) {\n+fn with_attrs_in_source<F: FnMut(&str, usize, &str)>(source: &str, attr: &str, mut f: F) {\n     let mut base = \"\";\n-    for (i, mut line) in contents.lines().enumerate() {\n+    for (i, mut line) in source.lines().enumerate() {\n         while let Some(j) = line.find(attr) {\n             let rest = &line[j + attr.len()..];\n             // The base tag should always be the first link in the document so\n@@ -437,3 +513,18 @@ fn with_attrs_in_source<F: FnMut(&str, usize, &str)>(contents: &str, attr: &str,\n         }\n     }\n }\n+\n+fn parse_ids(ids: &mut HashSet<String>, file: &str, source: &str, report: &mut Report) {\n+    if ids.is_empty() {\n+        with_attrs_in_source(source, \" id\", |fragment, i, _| {\n+            let frag = fragment.trim_start_matches(\"#\").to_owned();\n+            let encoded = small_url_encode(&frag);\n+            if !ids.insert(frag) {\n+                report.errors += 1;\n+                println!(\"{}:{}: id is not unique: `{}`\", file, i, fragment);\n+            }\n+            // Just in case, we also add the encoded id.\n+            ids.insert(encoded);\n+        });\n+    }\n+}"}, {"sha": "cb27c55c9fe944519a72e065efaddaceed38fb1b", "filename": "src/tools/linkchecker/tests/basic_broken/foo.html", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/86ac0b4147822e23c671a40e7ba1bf5b5835150d/src%2Ftools%2Flinkchecker%2Ftests%2Fbasic_broken%2Ffoo.html", "raw_url": "https://github.com/rust-lang/rust/raw/86ac0b4147822e23c671a40e7ba1bf5b5835150d/src%2Ftools%2Flinkchecker%2Ftests%2Fbasic_broken%2Ffoo.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Ftests%2Fbasic_broken%2Ffoo.html?ref=86ac0b4147822e23c671a40e7ba1bf5b5835150d", "patch": "@@ -0,0 +1,5 @@\n+<html>\n+<body>\n+<a href=\"bar.html\">test</a>\n+</body>\n+</html>"}, {"sha": "66c457ad01f474b72146e0b68a07253e7028edce", "filename": "src/tools/linkchecker/tests/broken_fragment_local/foo.html", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/86ac0b4147822e23c671a40e7ba1bf5b5835150d/src%2Ftools%2Flinkchecker%2Ftests%2Fbroken_fragment_local%2Ffoo.html", "raw_url": "https://github.com/rust-lang/rust/raw/86ac0b4147822e23c671a40e7ba1bf5b5835150d/src%2Ftools%2Flinkchecker%2Ftests%2Fbroken_fragment_local%2Ffoo.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Ftests%2Fbroken_fragment_local%2Ffoo.html?ref=86ac0b4147822e23c671a40e7ba1bf5b5835150d", "patch": "@@ -0,0 +1,5 @@\n+<html>\n+<body>\n+<a href=\"#somefrag\">test</a>\n+</body>\n+</html>"}, {"sha": "7879e1ce9fd77d4d90054013725af5137e8ef31a", "filename": "src/tools/linkchecker/tests/broken_fragment_remote/bar.html", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/86ac0b4147822e23c671a40e7ba1bf5b5835150d/src%2Ftools%2Flinkchecker%2Ftests%2Fbroken_fragment_remote%2Fbar.html", "raw_url": "https://github.com/rust-lang/rust/raw/86ac0b4147822e23c671a40e7ba1bf5b5835150d/src%2Ftools%2Flinkchecker%2Ftests%2Fbroken_fragment_remote%2Fbar.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Ftests%2Fbroken_fragment_remote%2Fbar.html?ref=86ac0b4147822e23c671a40e7ba1bf5b5835150d", "patch": "@@ -0,0 +1,4 @@\n+<html>\n+<body>\n+</body>\n+</html>"}, {"sha": "7683060b3a6fac555b3f3c5c7eae37ff2eb73340", "filename": "src/tools/linkchecker/tests/broken_fragment_remote/inner/foo.html", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/86ac0b4147822e23c671a40e7ba1bf5b5835150d/src%2Ftools%2Flinkchecker%2Ftests%2Fbroken_fragment_remote%2Finner%2Ffoo.html", "raw_url": "https://github.com/rust-lang/rust/raw/86ac0b4147822e23c671a40e7ba1bf5b5835150d/src%2Ftools%2Flinkchecker%2Ftests%2Fbroken_fragment_remote%2Finner%2Ffoo.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Ftests%2Fbroken_fragment_remote%2Finner%2Ffoo.html?ref=86ac0b4147822e23c671a40e7ba1bf5b5835150d", "patch": "@@ -0,0 +1,5 @@\n+<html>\n+<body>\n+<a href=\"../bar.html#somefrag\">test</a>\n+</body>\n+</html>"}, {"sha": "bd3e3ad3343c6a72c6cde90a02bf220f0d4b55a7", "filename": "src/tools/linkchecker/tests/broken_redir/foo.html", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/86ac0b4147822e23c671a40e7ba1bf5b5835150d/src%2Ftools%2Flinkchecker%2Ftests%2Fbroken_redir%2Ffoo.html", "raw_url": "https://github.com/rust-lang/rust/raw/86ac0b4147822e23c671a40e7ba1bf5b5835150d/src%2Ftools%2Flinkchecker%2Ftests%2Fbroken_redir%2Ffoo.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Ftests%2Fbroken_redir%2Ffoo.html?ref=86ac0b4147822e23c671a40e7ba1bf5b5835150d", "patch": "@@ -0,0 +1,5 @@\n+<html>\n+<body>\n+  <a href=\"redir-bad.html\">bad redir</a>\n+</body>\n+</html>"}, {"sha": "3e376629f74fe6f6cd7657302074bc53ad2ae04f", "filename": "src/tools/linkchecker/tests/broken_redir/redir-bad.html", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/86ac0b4147822e23c671a40e7ba1bf5b5835150d/src%2Ftools%2Flinkchecker%2Ftests%2Fbroken_redir%2Fredir-bad.html", "raw_url": "https://github.com/rust-lang/rust/raw/86ac0b4147822e23c671a40e7ba1bf5b5835150d/src%2Ftools%2Flinkchecker%2Ftests%2Fbroken_redir%2Fredir-bad.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Ftests%2Fbroken_redir%2Fredir-bad.html?ref=86ac0b4147822e23c671a40e7ba1bf5b5835150d", "patch": "@@ -0,0 +1,10 @@\n+<!DOCTYPE html>\n+<html lang=\"en\">\n+<head>\n+    <meta http-equiv=\"refresh\" content=\"0;URL=sometarget\">\n+</head>\n+<body>\n+    <p>Redirecting to <a href=\"sometarget\">sometarget</a>...</p>\n+    <script>location.replace(\"sometarget\" + location.search + location.hash);</script>\n+</body>\n+</html>"}, {"sha": "c6ec999e5cfe229422420eb7b1fb5aa09ae8cbf2", "filename": "src/tools/linkchecker/tests/checks.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/86ac0b4147822e23c671a40e7ba1bf5b5835150d/src%2Ftools%2Flinkchecker%2Ftests%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86ac0b4147822e23c671a40e7ba1bf5b5835150d/src%2Ftools%2Flinkchecker%2Ftests%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Ftests%2Fchecks.rs?ref=86ac0b4147822e23c671a40e7ba1bf5b5835150d", "patch": "@@ -0,0 +1,77 @@\n+use std::path::Path;\n+use std::process::{Command, ExitStatus};\n+\n+fn run(dirname: &str) -> (ExitStatus, String, String) {\n+    let output = Command::new(env!(\"CARGO_BIN_EXE_linkchecker\"))\n+        .current_dir(Path::new(env!(\"CARGO_MANIFEST_DIR\")).join(\"tests\"))\n+        .arg(dirname)\n+        .output()\n+        .unwrap();\n+    let stdout = String::from_utf8(output.stdout).unwrap();\n+    let stderr = String::from_utf8(output.stderr).unwrap();\n+    (output.status, stdout, stderr)\n+}\n+\n+fn broken_test(dirname: &str, expected: &str) {\n+    let (status, stdout, stderr) = run(dirname);\n+    assert!(!status.success());\n+    if !stdout.contains(expected) {\n+        panic!(\n+            \"stdout did not contain expected text: {}\\n\\\n+            --- stdout:\\n\\\n+            {}\\n\\\n+            --- stderr:\\n\\\n+            {}\\n\",\n+            expected, stdout, stderr\n+        );\n+    }\n+}\n+\n+fn valid_test(dirname: &str) {\n+    let (status, stdout, stderr) = run(dirname);\n+    if !status.success() {\n+        panic!(\n+            \"test did not succeed as expected\\n\\\n+            --- stdout:\\n\\\n+            {}\\n\\\n+            --- stderr:\\n\\\n+            {}\\n\",\n+            stdout, stderr\n+        );\n+    }\n+}\n+\n+#[test]\n+fn valid() {\n+    valid_test(\"valid/inner\");\n+}\n+\n+#[test]\n+fn basic_broken() {\n+    broken_test(\"basic_broken\", \"bar.html\");\n+}\n+\n+#[test]\n+fn broken_fragment_local() {\n+    broken_test(\"broken_fragment_local\", \"#somefrag\");\n+}\n+\n+#[test]\n+fn broken_fragment_remote() {\n+    broken_test(\"broken_fragment_remote/inner\", \"#somefrag\");\n+}\n+\n+#[test]\n+fn broken_redir() {\n+    broken_test(\"broken_redir\", \"sometarget\");\n+}\n+\n+#[test]\n+fn directory_link() {\n+    broken_test(\"directory_link\", \"somedir\");\n+}\n+\n+#[test]\n+fn redirect_loop() {\n+    broken_test(\"redirect_loop\", \"redir-bad.html\");\n+}"}, {"sha": "40a8461b86cf5a2179f352063f84d714397adbf0", "filename": "src/tools/linkchecker/tests/directory_link/foo.html", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/86ac0b4147822e23c671a40e7ba1bf5b5835150d/src%2Ftools%2Flinkchecker%2Ftests%2Fdirectory_link%2Ffoo.html", "raw_url": "https://github.com/rust-lang/rust/raw/86ac0b4147822e23c671a40e7ba1bf5b5835150d/src%2Ftools%2Flinkchecker%2Ftests%2Fdirectory_link%2Ffoo.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Ftests%2Fdirectory_link%2Ffoo.html?ref=86ac0b4147822e23c671a40e7ba1bf5b5835150d", "patch": "@@ -0,0 +1,5 @@\n+<html>\n+<body>\n+  <a href=\"somedir\">dir link</a>\n+</body>\n+</html>"}, {"sha": "7879e1ce9fd77d4d90054013725af5137e8ef31a", "filename": "src/tools/linkchecker/tests/directory_link/somedir/index.html", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/86ac0b4147822e23c671a40e7ba1bf5b5835150d/src%2Ftools%2Flinkchecker%2Ftests%2Fdirectory_link%2Fsomedir%2Findex.html", "raw_url": "https://github.com/rust-lang/rust/raw/86ac0b4147822e23c671a40e7ba1bf5b5835150d/src%2Ftools%2Flinkchecker%2Ftests%2Fdirectory_link%2Fsomedir%2Findex.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Ftests%2Fdirectory_link%2Fsomedir%2Findex.html?ref=86ac0b4147822e23c671a40e7ba1bf5b5835150d", "patch": "@@ -0,0 +1,4 @@\n+<html>\n+<body>\n+</body>\n+</html>"}, {"sha": "bee58b212b5576aaa0794ac2939877c659398b7f", "filename": "src/tools/linkchecker/tests/redirect_loop/foo.html", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/86ac0b4147822e23c671a40e7ba1bf5b5835150d/src%2Ftools%2Flinkchecker%2Ftests%2Fredirect_loop%2Ffoo.html", "raw_url": "https://github.com/rust-lang/rust/raw/86ac0b4147822e23c671a40e7ba1bf5b5835150d/src%2Ftools%2Flinkchecker%2Ftests%2Fredirect_loop%2Ffoo.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Ftests%2Fredirect_loop%2Ffoo.html?ref=86ac0b4147822e23c671a40e7ba1bf5b5835150d", "patch": "@@ -0,0 +1,5 @@\n+<html>\n+<body>\n+  <a href=\"redir-bad.html\">loop link</a>\n+</body>\n+</html>"}, {"sha": "fe7780e6739bfe3106e66f7982833ccc6ebea34d", "filename": "src/tools/linkchecker/tests/redirect_loop/redir-bad.html", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/86ac0b4147822e23c671a40e7ba1bf5b5835150d/src%2Ftools%2Flinkchecker%2Ftests%2Fredirect_loop%2Fredir-bad.html", "raw_url": "https://github.com/rust-lang/rust/raw/86ac0b4147822e23c671a40e7ba1bf5b5835150d/src%2Ftools%2Flinkchecker%2Ftests%2Fredirect_loop%2Fredir-bad.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Ftests%2Fredirect_loop%2Fredir-bad.html?ref=86ac0b4147822e23c671a40e7ba1bf5b5835150d", "patch": "@@ -0,0 +1,10 @@\n+<!DOCTYPE html>\n+<html lang=\"en\">\n+<head>\n+    <meta http-equiv=\"refresh\" content=\"0;URL=redir-bad.html\">\n+</head>\n+<body>\n+    <p>Redirecting to <a href=\"redir-bad.html\">redir-bad.html</a>...</p>\n+    <script>location.replace(\"redir-bad.html\" + location.search + location.hash);</script>\n+</body>\n+</html>"}, {"sha": "4b500d78b76e4cc3db989effb3f8316d6aa64a9a", "filename": "src/tools/linkchecker/tests/valid/inner/bar.html", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/86ac0b4147822e23c671a40e7ba1bf5b5835150d/src%2Ftools%2Flinkchecker%2Ftests%2Fvalid%2Finner%2Fbar.html", "raw_url": "https://github.com/rust-lang/rust/raw/86ac0b4147822e23c671a40e7ba1bf5b5835150d/src%2Ftools%2Flinkchecker%2Ftests%2Fvalid%2Finner%2Fbar.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Ftests%2Fvalid%2Finner%2Fbar.html?ref=86ac0b4147822e23c671a40e7ba1bf5b5835150d", "patch": "@@ -0,0 +1,7 @@\n+<html>\n+<body>\n+\n+  <h2 id=\"barfrag\">Bar</h2>\n+\n+</body>\n+</html>"}, {"sha": "3c6a7483bcd46020a67b1819e7a3a621d1fb5b31", "filename": "src/tools/linkchecker/tests/valid/inner/foo.html", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/86ac0b4147822e23c671a40e7ba1bf5b5835150d/src%2Ftools%2Flinkchecker%2Ftests%2Fvalid%2Finner%2Ffoo.html", "raw_url": "https://github.com/rust-lang/rust/raw/86ac0b4147822e23c671a40e7ba1bf5b5835150d/src%2Ftools%2Flinkchecker%2Ftests%2Fvalid%2Finner%2Ffoo.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Ftests%2Fvalid%2Finner%2Ffoo.html?ref=86ac0b4147822e23c671a40e7ba1bf5b5835150d", "patch": "@@ -0,0 +1,14 @@\n+<html>\n+<body>\n+  <a href=\"#localfrag\">test local frag</a>\n+  <a href=\"../outer.html\">remote link</a>\n+  <a href=\"../outer.html#somefrag\">remote link with fragment</a>\n+  <a href=\"bar.html\">this book</a>\n+  <a href=\"bar.html#barfrag\">this book with fragment</a>\n+  <a href=\"https://example.com/doesnotexist\">external links not validated</a>\n+  <a href=\"redir.html#redirfrag\">Redirect</a>\n+\n+  <h2 id=\"localfrag\">Local</h2>\n+\n+</body>\n+</html>"}, {"sha": "d21336e7e738bb08d3497a27aa49ecd0fda99abe", "filename": "src/tools/linkchecker/tests/valid/inner/redir-bad.html", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/86ac0b4147822e23c671a40e7ba1bf5b5835150d/src%2Ftools%2Flinkchecker%2Ftests%2Fvalid%2Finner%2Fredir-bad.html", "raw_url": "https://github.com/rust-lang/rust/raw/86ac0b4147822e23c671a40e7ba1bf5b5835150d/src%2Ftools%2Flinkchecker%2Ftests%2Fvalid%2Finner%2Fredir-bad.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Ftests%2Fvalid%2Finner%2Fredir-bad.html?ref=86ac0b4147822e23c671a40e7ba1bf5b5835150d", "patch": "@@ -0,0 +1,11 @@\n+<!DOCTYPE html>\n+<html lang=\"en\">\n+<head>\n+    <meta http-equiv=\"refresh\" content=\"0;URL=xxx\">\n+</head>\n+<body>\n+    <p>Redirecting to <a href=\"xxx\">xxx</a>...</p>\n+    <script>location.replace(\"xxx\" + location.search + location.hash);</script>\n+    These files are skipped, but probably shouldn't be.\n+</body>\n+</html>"}, {"sha": "bd59884a01ecff0abab7f1eacaee8ba10e04ea67", "filename": "src/tools/linkchecker/tests/valid/inner/redir-target.html", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/86ac0b4147822e23c671a40e7ba1bf5b5835150d/src%2Ftools%2Flinkchecker%2Ftests%2Fvalid%2Finner%2Fredir-target.html", "raw_url": "https://github.com/rust-lang/rust/raw/86ac0b4147822e23c671a40e7ba1bf5b5835150d/src%2Ftools%2Flinkchecker%2Ftests%2Fvalid%2Finner%2Fredir-target.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Ftests%2Fvalid%2Finner%2Fredir-target.html?ref=86ac0b4147822e23c671a40e7ba1bf5b5835150d", "patch": "@@ -0,0 +1,5 @@\n+<html>\n+<body>\n+  <h2 id=\"redirfrag\">Redir</h2>\n+</body>\n+</html>"}, {"sha": "1808b23aed8564f539a3e902dee107bd4773727b", "filename": "src/tools/linkchecker/tests/valid/inner/redir.html", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/86ac0b4147822e23c671a40e7ba1bf5b5835150d/src%2Ftools%2Flinkchecker%2Ftests%2Fvalid%2Finner%2Fredir.html", "raw_url": "https://github.com/rust-lang/rust/raw/86ac0b4147822e23c671a40e7ba1bf5b5835150d/src%2Ftools%2Flinkchecker%2Ftests%2Fvalid%2Finner%2Fredir.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Ftests%2Fvalid%2Finner%2Fredir.html?ref=86ac0b4147822e23c671a40e7ba1bf5b5835150d", "patch": "@@ -0,0 +1,10 @@\n+<!DOCTYPE html>\n+<html lang=\"en\">\n+<head>\n+    <meta http-equiv=\"refresh\" content=\"0;URL=redir-target.html\">\n+</head>\n+<body>\n+    <p>Redirecting to <a href=\"redir-target.html\">redir-target.html</a>...</p>\n+    <script>location.replace(\"redir-target.html\" + location.search + location.hash);</script>\n+</body>\n+</html>"}, {"sha": "35f799f2023177c40bd72396f15f062559cff0a0", "filename": "src/tools/linkchecker/tests/valid/outer.html", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/86ac0b4147822e23c671a40e7ba1bf5b5835150d/src%2Ftools%2Flinkchecker%2Ftests%2Fvalid%2Fouter.html", "raw_url": "https://github.com/rust-lang/rust/raw/86ac0b4147822e23c671a40e7ba1bf5b5835150d/src%2Ftools%2Flinkchecker%2Ftests%2Fvalid%2Fouter.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Ftests%2Fvalid%2Fouter.html?ref=86ac0b4147822e23c671a40e7ba1bf5b5835150d", "patch": "@@ -0,0 +1,5 @@\n+<html>\n+<body>\n+<a id=\"somefrag\"></a>\n+</body>\n+</html>"}]}