{"sha": "fbc1d2a51436ed186c85f6f0d64217d9d1dd4523", "node_id": "C_kwDOAAsO6NoAKGZiYzFkMmE1MTQzNmVkMTg2Yzg1ZjZmMGQ2NDIxN2Q5ZDFkZDQ1MjM", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-03-14T19:36:35Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-03-14T19:36:35Z"}, "message": "Simplify", "tree": {"sha": "84b9311b43b74be683c92f84ee0bedc847c3cea5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84b9311b43b74be683c92f84ee0bedc847c3cea5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fbc1d2a51436ed186c85f6f0d64217d9d1dd4523", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fbc1d2a51436ed186c85f6f0d64217d9d1dd4523", "html_url": "https://github.com/rust-lang/rust/commit/fbc1d2a51436ed186c85f6f0d64217d9d1dd4523", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fbc1d2a51436ed186c85f6f0d64217d9d1dd4523/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "301711ee71568c939cb5595a3fe4313d8664757a", "url": "https://api.github.com/repos/rust-lang/rust/commits/301711ee71568c939cb5595a3fe4313d8664757a", "html_url": "https://github.com/rust-lang/rust/commit/301711ee71568c939cb5595a3fe4313d8664757a"}], "stats": {"total": 73, "additions": 38, "deletions": 35}, "files": [{"sha": "9bb395061f7f4352519f93a55c8b7a52baf8d276", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fbc1d2a51436ed186c85f6f0d64217d9d1dd4523/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc1d2a51436ed186c85f6f0d64217d9d1dd4523/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=fbc1d2a51436ed186c85f6f0d64217d9d1dd4523", "patch": "@@ -1327,14 +1327,14 @@ impl<'a> SemanticsScope<'a> {\n                     resolver::ScopeDef::ImplSelfType(it) => ScopeDef::ImplSelfType(it.into()),\n                     resolver::ScopeDef::AdtSelfType(it) => ScopeDef::AdtSelfType(it.into()),\n                     resolver::ScopeDef::GenericParam(id) => ScopeDef::GenericParam(id.into()),\n-                    resolver::ScopeDef::Local(pat_id) => {\n-                        let parent = self.resolver.body_owner().unwrap();\n-                        ScopeDef::Local(Local { parent, pat_id })\n-                    }\n-                    resolver::ScopeDef::Label(label_id) => {\n-                        let parent = self.resolver.body_owner().unwrap();\n-                        ScopeDef::Label(Label { parent, label_id })\n-                    }\n+                    resolver::ScopeDef::Local(pat_id) => match self.resolver.body_owner() {\n+                        Some(parent) => ScopeDef::Local(Local { parent, pat_id }),\n+                        None => continue,\n+                    },\n+                    resolver::ScopeDef::Label(label_id) => match self.resolver.body_owner() {\n+                        Some(parent) => ScopeDef::Label(Label { parent, label_id }),\n+                        None => continue,\n+                    },\n                 };\n                 f(name.clone(), def)\n             }"}, {"sha": "33627a1fed57112d274d39a4f28cb44b7e6db894", "filename": "crates/hir_def/src/resolver.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fbc1d2a51436ed186c85f6f0d64217d9d1dd4523/crates%2Fhir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc1d2a51436ed186c85f6f0d64217d9d1dd4523/crates%2Fhir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fresolver.rs?ref=fbc1d2a51436ed186c85f6f0d64217d9d1dd4523", "patch": "@@ -1,5 +1,5 @@\n //! Name resolution fa\u00e7ade.\n-use std::sync::Arc;\n+use std::{hash::BuildHasherDefault, sync::Arc};\n \n use base_db::CrateId;\n use hir_expand::name::{name, Name};\n@@ -352,7 +352,7 @@ impl Resolver {\n     /// Returns a set of names available in the current scope.\n     ///\n     /// Note that this is a somewhat fuzzy concept -- internally, the compiler\n-    /// doesn't necessary follow a strict scoping discipline. Rathe, it just\n+    /// doesn't necessary follow a strict scoping discipline. Rather, it just\n     /// tells for each ident what it resolves to.\n     ///\n     /// A good example is something like `str::from_utf8`. From scopes point of\n@@ -387,10 +387,13 @@ impl Resolver {\n     /// The result is ordered *roughly* from the innermost scope to the\n     /// outermost: when the name is introduced in two namespaces in two scopes,\n     /// we use the position of the first scope.\n-    pub fn names_in_scope(&self, db: &dyn DefDatabase) -> IndexMap<Name, SmallVec<[ScopeDef; 1]>> {\n+    pub fn names_in_scope(\n+        &self,\n+        db: &dyn DefDatabase,\n+    ) -> FxIndexMap<Name, SmallVec<[ScopeDef; 1]>> {\n         let mut res = ScopeNames::default();\n         for scope in self.scopes() {\n-            scope.process_names(db, &mut res);\n+            scope.process_names(&mut res, db);\n         }\n         res.map\n     }\n@@ -475,7 +478,7 @@ impl Resolver {\n     }\n }\n \n-#[derive(Debug, PartialEq, Eq)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum ScopeDef {\n     ModuleDef(ModuleDefId),\n     Unknown,\n@@ -487,7 +490,7 @@ pub enum ScopeDef {\n }\n \n impl Scope {\n-    fn process_names(&self, db: &dyn DefDatabase, acc: &mut ScopeNames) {\n+    fn process_names(&self, acc: &mut ScopeNames, db: &dyn DefDatabase) {\n         match self {\n             Scope::ModuleScope(m) => {\n                 // FIXME: should we provide `self` here?\n@@ -700,9 +703,10 @@ fn to_type_ns(per_ns: PerNs) -> Option<TypeNs> {\n     Some(res)\n }\n \n+type FxIndexMap<K, V> = IndexMap<K, V, BuildHasherDefault<rustc_hash::FxHasher>>;\n #[derive(Default)]\n struct ScopeNames {\n-    map: IndexMap<Name, SmallVec<[ScopeDef; 1]>>,\n+    map: FxIndexMap<Name, SmallVec<[ScopeDef; 1]>>,\n }\n \n impl ScopeNames {"}, {"sha": "4fffd1aa0c4d9f1b1c40fb9542b106cf290237e6", "filename": "crates/ide_completion/src/completions/lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fbc1d2a51436ed186c85f6f0d64217d9d1dd4523/crates%2Fide_completion%2Fsrc%2Fcompletions%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc1d2a51436ed186c85f6f0d64217d9d1dd4523/crates%2Fide_completion%2Fsrc%2Fcompletions%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Flifetime.rs?ref=fbc1d2a51436ed186c85f6f0d64217d9d1dd4523", "patch": "@@ -30,7 +30,7 @@ pub(crate) fn complete_lifetime(acc: &mut Completions, ctx: &CompletionContext)\n     let param_lifetime = param_lifetime.as_ref().map(ast::Lifetime::text);\n     let param_lifetime = param_lifetime.as_ref().map(TokenText::as_str);\n \n-    ctx.scope.process_all_names(&mut |name, res| {\n+    ctx.process_all_names_raw(&mut |name, res| {\n         if matches!(\n             res,\n             ScopeDef::GenericParam(hir::GenericParam::LifetimeParam(_))\n@@ -49,7 +49,7 @@ pub(crate) fn complete_label(acc: &mut Completions, ctx: &CompletionContext) {\n     if !matches!(ctx.lifetime_ctx, Some(LifetimeContext::LabelRef)) {\n         return;\n     }\n-    ctx.scope.process_all_names(&mut |name, res| {\n+    ctx.process_all_names_raw(&mut |name, res| {\n         if let ScopeDef::Label(_) = res {\n             acc.add_label(ctx, name);\n         }"}, {"sha": "ba664a29dae2e41dbf1e825e6950b194c90ba8f3", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fbc1d2a51436ed186c85f6f0d64217d9d1dd4523/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc1d2a51436ed186c85f6f0d64217d9d1dd4523/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=fbc1d2a51436ed186c85f6f0d64217d9d1dd4523", "patch": "@@ -12,7 +12,7 @@ use ide_db::{\n     famous_defs::FamousDefs,\n     RootDatabase,\n };\n-use rustc_hash::FxHashSet;\n+use rustc_hash::{FxHashMap, FxHashSet};\n use syntax::{\n     algo::{find_node_at_offset, non_trivia_sibling},\n     ast::{self, AttrKind, HasName, NameOrNameRef},\n@@ -146,7 +146,7 @@ pub(crate) struct CompletionContext<'a> {\n \n     pub(super) existing_derives: FxHashSet<hir::Macro>,\n \n-    pub(super) locals: Vec<(Name, Local)>,\n+    pub(super) locals: FxHashMap<Name, Local>,\n }\n \n impl<'a> CompletionContext<'a> {\n@@ -293,6 +293,10 @@ impl<'a> CompletionContext<'a> {\n         self.path_context.as_ref().and_then(|it| it.kind)\n     }\n \n+    pub(crate) fn is_immediately_after_macro_bang(&self) -> bool {\n+        self.token.kind() == BANG && self.token.parent().map_or(false, |it| it.kind() == MACRO_CALL)\n+    }\n+\n     /// Checks if an item is visible and not `doc(hidden)` at the completion site.\n     pub(crate) fn is_visible<I>(&self, item: &I) -> Visible\n     where\n@@ -318,11 +322,6 @@ impl<'a> CompletionContext<'a> {\n             _ => false,\n         }\n     }\n-\n-    pub(crate) fn is_immediately_after_macro_bang(&self) -> bool {\n-        self.token.kind() == BANG && self.token.parent().map_or(false, |it| it.kind() == MACRO_CALL)\n-    }\n-\n     /// Whether the given trait is an operator trait or not.\n     pub(crate) fn is_ops_trait(&self, trait_: hir::Trait) -> bool {\n         match trait_.attrs(self.db).lang() {\n@@ -340,7 +339,12 @@ impl<'a> CompletionContext<'a> {\n             }\n \n             f(name, def);\n-        })\n+        });\n+    }\n+\n+    pub(crate) fn process_all_names_raw(&self, f: &mut dyn FnMut(Name, ScopeDef)) {\n+        let _p = profile::span(\"CompletionContext::process_all_names_raw\");\n+        self.scope.process_all_names(&mut |name, def| f(name, def));\n     }\n \n     fn is_visible_impl(\n@@ -372,16 +376,11 @@ impl<'a> CompletionContext<'a> {\n     }\n \n     fn is_doc_hidden(&self, attrs: &hir::Attrs, defining_crate: hir::Crate) -> bool {\n-        let krate = match self.krate {\n-            Some(it) => it,\n-            None => return true,\n-        };\n-        if krate != defining_crate && attrs.has_doc_hidden() {\n+        match self.krate {\n             // `doc(hidden)` items are only completed within the defining crate.\n-            return true;\n+            Some(krate) => krate != defining_crate && attrs.has_doc_hidden(),\n+            None => true,\n         }\n-\n-        false\n     }\n }\n \n@@ -413,10 +412,10 @@ impl<'a> CompletionContext<'a> {\n         let scope = sema.scope_at_offset(&token.parent()?, offset);\n         let krate = scope.krate();\n         let module = scope.module();\n-        let mut locals = vec![];\n+        let mut locals = FxHashMap::default();\n         scope.process_all_names(&mut |name, scope| {\n             if let ScopeDef::Local(local) = scope {\n-                locals.push((name, local));\n+                locals.insert(name, local);\n             }\n         });\n "}]}