{"sha": "a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzYzc3ZjZhZDFjMWMxODVlNTYxZTljZDdmZGVjN2RiNTY5MTY5ZDE=", "commit": {"author": {"name": "Philipp Hansch", "email": "dev@phansch.net", "date": "2018-12-08T12:42:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-12-08T12:42:01Z"}, "message": "Merge pull request #3512 from matthiaskrgr/rustup\n\nrustup https://github.com/rust-lang/rust/pull/56502 ( .hir -> .hir() )", "tree": {"sha": "65bdc9cc83e142207c3b8f55030e8c47a7c1d29b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/65bdc9cc83e142207c3b8f55030e8c47a7c1d29b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcC7wZCRBK7hj4Ov3rIwAAdHIIAHcSBonPtgfUhV1xAlY2cnfW\nMa9+FbIWwsNS5l4dcN0PPEAL/8PgziAlCsgMWiA031FxfNlk/1Fe+qRHHOqDze7a\nAyJb9SY1E0kaij7E90+FFaHztOWmtc2qOFq0tGLRfPYgMbJC8pWG/FKI7nqDeKwf\nEqx3FWLIOuHugIPs0elnnHvMt9DMfY9orFo6aVkWID/9saLIyVM4kac21BZGQEgB\njEZfgFVUuot5+CuSP2jmilLcmUj5/gwcpfqzipblZR8oNIuO6R9T2L93gS0B0A2j\nZMFnCJ1nz2OVWFbBADVV2DVqF8aFc1NW0bMC/MBdyICqnlO2hGPvnVsoIta/fEQ=\n=BEdT\n-----END PGP SIGNATURE-----\n", "payload": "tree 65bdc9cc83e142207c3b8f55030e8c47a7c1d29b\nparent 26602ddff475ef75ed94803b05217a761a7f5523\nparent d93ea1ec99261cf1f0b0d68f8760077d7d332f34\nauthor Philipp Hansch <dev@phansch.net> 1544272921 +0100\ncommitter GitHub <noreply@github.com> 1544272921 +0100\n\nMerge pull request #3512 from matthiaskrgr/rustup\n\nrustup https://github.com/rust-lang/rust/pull/56502 ( .hir -> .hir() )"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "html_url": "https://github.com/rust-lang/rust/commit/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/comments", "author": {"login": "phansch", "id": 2042399, "node_id": "MDQ6VXNlcjIwNDIzOTk=", "avatar_url": "https://avatars.githubusercontent.com/u/2042399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/phansch", "html_url": "https://github.com/phansch", "followers_url": "https://api.github.com/users/phansch/followers", "following_url": "https://api.github.com/users/phansch/following{/other_user}", "gists_url": "https://api.github.com/users/phansch/gists{/gist_id}", "starred_url": "https://api.github.com/users/phansch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/phansch/subscriptions", "organizations_url": "https://api.github.com/users/phansch/orgs", "repos_url": "https://api.github.com/users/phansch/repos", "events_url": "https://api.github.com/users/phansch/events{/privacy}", "received_events_url": "https://api.github.com/users/phansch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "26602ddff475ef75ed94803b05217a761a7f5523", "url": "https://api.github.com/repos/rust-lang/rust/commits/26602ddff475ef75ed94803b05217a761a7f5523", "html_url": "https://github.com/rust-lang/rust/commit/26602ddff475ef75ed94803b05217a761a7f5523"}, {"sha": "d93ea1ec99261cf1f0b0d68f8760077d7d332f34", "url": "https://api.github.com/repos/rust-lang/rust/commits/d93ea1ec99261cf1f0b0d68f8760077d7d332f34", "html_url": "https://github.com/rust-lang/rust/commit/d93ea1ec99261cf1f0b0d68f8760077d7d332f34"}], "stats": {"total": 351, "additions": 182, "deletions": 169}, "files": [{"sha": "e3819448877f5fa16a33bd8726d866550e3eab90", "filename": ".travis.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -30,7 +30,7 @@ before_install:\n install:\n   - |\n     if [ -z ${INTEGRATION} ]; then\n-      rustup component add rustfmt-preview || cargo install --git https://github.com/rust-lang/rustfmt/ --force\n+      rustup component add rustfmt || cargo install --git https://github.com/rust-lang/rustfmt/ --force\n       if [ \"$TRAVIS_OS_NAME\" == \"linux\" ]; then\n         . $HOME/.nvm/nvm.sh\n         nvm install stable"}, {"sha": "0b2c00b9b58b8f3052ba9f4c5a9716f0fca1632d", "filename": "clippy_lints/src/arithmetic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Farithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Farithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farithmetic.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -121,11 +121,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Arithmetic {\n     }\n \n     fn check_body(&mut self, cx: &LateContext<'_, '_>, body: &hir::Body) {\n-        let body_owner = cx.tcx.hir.body_owner(body.id());\n+        let body_owner = cx.tcx.hir().body_owner(body.id());\n \n-        match cx.tcx.hir.body_owner_kind(body_owner) {\n+        match cx.tcx.hir().body_owner_kind(body_owner) {\n             hir::BodyOwnerKind::Static(_) | hir::BodyOwnerKind::Const => {\n-                let body_span = cx.tcx.hir.span(body_owner);\n+                let body_span = cx.tcx.hir().span(body_owner);\n \n                 if let Some(span) = self.const_span {\n                     if span.contains(body_span) {\n@@ -139,8 +139,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Arithmetic {\n     }\n \n     fn check_body_post(&mut self, cx: &LateContext<'_, '_>, body: &hir::Body) {\n-        let body_owner = cx.tcx.hir.body_owner(body.id());\n-        let body_span = cx.tcx.hir.span(body_owner);\n+        let body_owner = cx.tcx.hir().body_owner(body.id());\n+        let body_span = cx.tcx.hir().span(body_owner);\n \n         if let Some(span) = self.const_span {\n             if span.contains(body_span) {"}, {"sha": "f69c66a3d350e3b33e51a1bf0d46046f3719e2b4", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -144,12 +144,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                                             return; // useless if the trait doesn't exist\n                                         };\n                                         // check that we are not inside an `impl AssignOp` of this exact operation\n-                                        let parent_fn = cx.tcx.hir.get_parent(e.id);\n-                                        let parent_impl = cx.tcx.hir.get_parent(parent_fn);\n+                                        let parent_fn = cx.tcx.hir().get_parent(e.id);\n+                                        let parent_impl = cx.tcx.hir().get_parent(parent_fn);\n                                         // the crate node is the only one that is not in the map\n                                         if_chain! {\n                                             if parent_impl != ast::CRATE_NODE_ID;\n-                                            if let hir::Node::Item(item) = cx.tcx.hir.get(parent_impl);\n+                                            if let hir::Node::Item(item) = cx.tcx.hir().get(parent_impl);\n                                             if let hir::ItemKind::Impl(_, _, _, _, Some(ref trait_ref), _, _) =\n                                                 item.node;\n                                             if trait_ref.path.def.def_id() == trait_id;"}, {"sha": "9f8cc76c5aac229bdae4255e55d62777a16216e9", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -354,15 +354,15 @@ fn check_clippy_lint_names(cx: &LateContext<'_, '_>, items: &[NestedMetaItem]) {\n \n fn is_relevant_item(tcx: TyCtxt<'_, '_, '_>, item: &Item) -> bool {\n     if let ItemKind::Fn(_, _, _, eid) = item.node {\n-        is_relevant_expr(tcx, tcx.body_tables(eid), &tcx.hir.body(eid).value)\n+        is_relevant_expr(tcx, tcx.body_tables(eid), &tcx.hir().body(eid).value)\n     } else {\n         true\n     }\n }\n \n fn is_relevant_impl(tcx: TyCtxt<'_, '_, '_>, item: &ImplItem) -> bool {\n     match item.node {\n-        ImplItemKind::Method(_, eid) => is_relevant_expr(tcx, tcx.body_tables(eid), &tcx.hir.body(eid).value),\n+        ImplItemKind::Method(_, eid) => is_relevant_expr(tcx, tcx.body_tables(eid), &tcx.hir().body(eid).value),\n         _ => false,\n     }\n }\n@@ -371,7 +371,7 @@ fn is_relevant_trait(tcx: TyCtxt<'_, '_, '_>, item: &TraitItem) -> bool {\n     match item.node {\n         TraitItemKind::Method(_, TraitMethod::Required(_)) => true,\n         TraitItemKind::Method(_, TraitMethod::Provided(eid)) => {\n-            is_relevant_expr(tcx, tcx.body_tables(eid), &tcx.hir.body(eid).value)\n+            is_relevant_expr(tcx, tcx.body_tables(eid), &tcx.hir().body(eid).value)\n         },\n         _ => false,\n     }"}, {"sha": "825bf789a6937983f99836f632f165fbdfc83258", "filename": "clippy_lints/src/block_in_if_condition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -68,7 +68,7 @@ struct ExVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx: 'a> Visitor<'tcx> for ExVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n         if let ExprKind::Closure(_, _, eid, _, _) = expr.node {\n-            let body = self.cx.tcx.hir.body(eid);\n+            let body = self.cx.tcx.hir().body(eid);\n             let ex = &body.value;\n             if matches!(ex.node, ExprKind::Block(_, _)) && !in_macro(body.value.span) {\n                 self.found_block = Some(ex);"}, {"sha": "5d81e51422dbcfd65da6dbb23d1621439d2e98b4", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -60,7 +60,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ByteCount {\n             if filter_args.len() == 2;\n             if let ExprKind::Closure(_, _, body_id, _, _) = filter_args[1].node;\n             then {\n-                let body = cx.tcx.hir.body(body_id);\n+                let body = cx.tcx.hir().body(body_id);\n                 if_chain! {\n                     if body.arguments.len() == 1;\n                     if let Some(argname) = get_pat_name(&body.arguments[0].pat);"}, {"sha": "e5bbe9eb38a8722273e585802e32f762a8ddd621", "filename": "clippy_lints/src/copy_iterator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fcopy_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fcopy_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopy_iterator.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -49,7 +49,7 @@ impl LintPass for CopyIterator {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CopyIterator {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if let ItemKind::Impl(_, _, _, _, Some(ref trait_ref), _, _) = item.node {\n-            let ty = cx.tcx.type_of(cx.tcx.hir.local_def_id(item.id));\n+            let ty = cx.tcx.type_of(cx.tcx.hir().local_def_id(item.id));\n \n             if is_copy(cx, ty) && match_path(&trait_ref.path, &paths::ITERATOR) {\n                 span_note_and_lint("}, {"sha": "e2f98dce4716a08a5c42979a7048c194c08bdc99", "filename": "clippy_lints/src/cyclomatic_complexity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -130,7 +130,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CyclomaticComplexity {\n         span: Span,\n         node_id: NodeId,\n     ) {\n-        let def_id = cx.tcx.hir.local_def_id(node_id);\n+        let def_id = cx.tcx.hir().local_def_id(node_id);\n         if !cx.tcx.has_attr(def_id, \"test\") {\n             self.check(cx, body, span);\n         }"}, {"sha": "02eda701817e49ad585e35979368c071760523b3", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -82,7 +82,7 @@ impl LintPass for Derive {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Derive {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if let ItemKind::Impl(_, _, _, _, Some(ref trait_ref), _, _) = item.node {\n-            let ty = cx.tcx.type_of(cx.tcx.hir.local_def_id(item.id));\n+            let ty = cx.tcx.type_of(cx.tcx.hir().local_def_id(item.id));\n             let is_automatically_derived = is_automatically_derived(&*item.attrs);\n \n             check_hash_peq(cx, item.span, trait_ref, ty, is_automatically_derived);\n@@ -129,9 +129,9 @@ fn check_hash_peq<'a, 'tcx>(\n                         cx, DERIVE_HASH_XOR_EQ, span,\n                         mess,\n                         |db| {\n-                        if let Some(node_id) = cx.tcx.hir.as_local_node_id(impl_id) {\n+                        if let Some(node_id) = cx.tcx.hir().as_local_node_id(impl_id) {\n                             db.span_note(\n-                                cx.tcx.hir.span(node_id),\n+                                cx.tcx.hir().span(node_id),\n                                 \"`PartialEq` implemented here\"\n                             );\n                         }"}, {"sha": "045551d38dccfcab0bafb44e44c05a2d5d432877", "filename": "clippy_lints/src/empty_enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fempty_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fempty_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fempty_enum.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -43,7 +43,7 @@ impl LintPass for EmptyEnum {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EmptyEnum {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &Item) {\n-        let did = cx.tcx.hir.local_def_id(item.id);\n+        let did = cx.tcx.hir().local_def_id(item.id);\n         if let ItemKind::Enum(..) = item.node {\n             let ty = cx.tcx.type_of(did);\n             let adt = ty.ty_adt_def().expect(\"already checked whether this is an enum\");"}, {"sha": "bd3d3d13bb33bd21429aa20002fc0b17599f3cc5", "filename": "clippy_lints/src/enum_clike.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_clike.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -62,7 +62,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnportableVariant {\n                 let variant = &var.node;\n                 if let Some(ref anon_const) = variant.disr_expr {\n                     let param_env = ty::ParamEnv::empty();\n-                    let def_id = cx.tcx.hir.body_owner_def_id(anon_const.body);\n+                    let def_id = cx.tcx.hir().body_owner_def_id(anon_const.body);\n                     let substs = Substs::identity_for_item(cx.tcx.global_tcx(), def_id);\n                     let instance = ty::Instance::new(def_id, substs);\n                     let c_id = GlobalId {"}, {"sha": "3a98c784fe2521abca0e3cfb1fa3001576de3a40", "filename": "clippy_lints/src/enum_glob_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_glob_use.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -47,7 +47,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EnumGlobUse {\n     fn check_mod(&mut self, cx: &LateContext<'a, 'tcx>, m: &'tcx Mod, _: Span, _: NodeId) {\n         // only check top level `use` statements\n         for item in &m.item_ids {\n-            self.lint_item(cx, cx.tcx.hir.expect_item(item.id));\n+            self.lint_item(cx, cx.tcx.hir().expect_item(item.id));\n         }\n     }\n }"}, {"sha": "4b4a6bd9d5c1e9a91f48602996f93bca6e0399a8", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -74,8 +74,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         node_id: NodeId,\n     ) {\n         // If the method is an impl for a trait, don't warn\n-        let parent_id = cx.tcx.hir.get_parent(node_id);\n-        let parent_node = cx.tcx.hir.find(parent_id);\n+        let parent_id = cx.tcx.hir().get_parent(node_id);\n+        let parent_node = cx.tcx.hir().find(parent_id);\n \n         if let Some(Node::Item(item)) = parent_node {\n             if let ItemKind::Impl(_, _, _, _, Some(..), _, _) = item.node {\n@@ -89,15 +89,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             too_large_for_stack: self.too_large_for_stack,\n         };\n \n-        let fn_def_id = cx.tcx.hir.local_def_id(node_id);\n+        let fn_def_id = cx.tcx.hir().local_def_id(node_id);\n         let region_scope_tree = &cx.tcx.region_scope_tree(fn_def_id);\n         ExprUseVisitor::new(&mut v, cx.tcx, cx.param_env, region_scope_tree, cx.tables, None).consume_body(body);\n \n         for node in v.set {\n             span_lint(\n                 cx,\n                 BOXED_LOCAL,\n-                cx.tcx.hir.span(node),\n+                cx.tcx.hir().span(node),\n                 \"local variable doesn't need to be boxed here\",\n             );\n         }\n@@ -115,7 +115,7 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n     }\n     fn matched_pat(&mut self, _: &Pat, _: &cmt_<'tcx>, _: MatchMode) {}\n     fn consume_pat(&mut self, consume_pat: &Pat, cmt: &cmt_<'tcx>, _: ConsumeMode) {\n-        let map = &self.cx.tcx.hir;\n+        let map = &self.cx.tcx.hir();\n         if map.is_argument(consume_pat.id) {\n             // Skip closure arguments\n             if let Some(Node::Expr(..)) = map.find(map.get_parent_node(consume_pat.id)) {"}, {"sha": "e06f4d260d4110aba34699866a405d33d39b4d16", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -62,7 +62,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EtaPass {\n \n fn check_closure(cx: &LateContext<'_, '_>, expr: &Expr) {\n     if let ExprKind::Closure(_, ref decl, eid, _, _) = expr.node {\n-        let body = cx.tcx.hir.body(eid);\n+        let body = cx.tcx.hir().body(eid);\n         let ex = &body.value;\n         if let ExprKind::Call(ref caller, ref args) = ex.node {\n             if args.len() != decl.inputs.len() {"}, {"sha": "69d3b09a8ae547d2e0d63650378c17639c7de3e4", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -191,7 +191,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DivergenceVisitor<'a, 'tcx> {\n ///\n /// When such a read is found, the lint is triggered.\n fn check_for_unsequenced_reads(vis: &mut ReadVisitor<'_, '_>) {\n-    let map = &vis.cx.tcx.hir;\n+    let map = &vis.cx.tcx.hir();\n     let mut cur_id = vis.write_expr.id;\n     loop {\n         let parent_id = map.get_parent_node(cur_id);"}, {"sha": "0f1c1f7ef1d0c7775441c9f5bf6ffc54275da3d0", "filename": "clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -48,7 +48,7 @@ impl LintPass for FallibleImplFrom {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for FallibleImplFrom {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item) {\n         // check for `impl From<???> for ..`\n-        let impl_def_id = cx.tcx.hir.local_def_id(item.id);\n+        let impl_def_id = cx.tcx.hir().local_def_id(item.id);\n         if_chain! {\n             if let hir::ItemKind::Impl(.., ref impl_items) = item.node;\n             if let Some(impl_trait_ref) = cx.tcx.impl_trait_ref(impl_def_id);\n@@ -106,11 +106,11 @@ fn lint_impl_body<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, impl_span: Span, impl_it\n         if_chain! {\n             if impl_item.ident.name == \"from\";\n             if let ImplItemKind::Method(_, body_id) =\n-                cx.tcx.hir.impl_item(impl_item.id).node;\n+                cx.tcx.hir().impl_item(impl_item.id).node;\n             then {\n                 // check the body for `begin_panic` or `unwrap`\n-                let body = cx.tcx.hir.body(body_id);\n-                let impl_item_def_id = cx.tcx.hir.local_def_id(impl_item.id.node_id);\n+                let body = cx.tcx.hir().body(body_id);\n+                let impl_item_def_id = cx.tcx.hir().local_def_id(impl_item.id.node_id);\n                 let mut fpu = FindPanicUnwrap {\n                     tcx: cx.tcx,\n                     tables: cx.tcx.typeck_tables_of(impl_item_def_id),"}, {"sha": "e3c43c1c0902d0931fd6fb2d76ab4e9e12099fcd", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -95,7 +95,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Functions {\n         span: Span,\n         nodeid: ast::NodeId,\n     ) {\n-        let is_impl = if let Some(hir::Node::Item(item)) = cx.tcx.hir.find(cx.tcx.hir.get_parent_node(nodeid)) {\n+        let is_impl = if let Some(hir::Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_node(nodeid)) {\n             matches!(item.node, hir::ItemKind::Impl(_, _, _, _, Some(_), _, _))\n         } else {\n             false\n@@ -138,7 +138,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Functions {\n             }\n \n             if let hir::TraitMethod::Provided(eid) = *eid {\n-                let body = cx.tcx.hir.body(eid);\n+                let body = cx.tcx.hir().body(eid);\n                 self.check_raw_ptr(cx, sig.header.unsafety, &sig.decl, body, item.id);\n             }\n         }"}, {"sha": "75c66d22647a5ee2d7d6fd15515094786c1350f0", "filename": "clippy_lints/src/implicit_return.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fimplicit_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fimplicit_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_return.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -119,7 +119,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         _: Span,\n         _: NodeId,\n     ) {\n-        let def_id = cx.tcx.hir.body_owner_def_id(body.id());\n+        let def_id = cx.tcx.hir().body_owner_def_id(body.id());\n         let mir = cx.tcx.optimized_mir(def_id);\n \n         // checking return type through MIR, HIR is not able to determine inferred closure return types"}, {"sha": "625eca86d87a47130df91443f46806c02066dc75", "filename": "clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfinite_iter.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -165,7 +165,7 @@ fn is_infinite(cx: &LateContext<'_, '_>, expr: &Expr) -> Finiteness {\n             }\n             if method.ident.name == \"flat_map\" && args.len() == 2 {\n                 if let ExprKind::Closure(_, _, body_id, _, _) = args[1].node {\n-                    let body = cx.tcx.hir.body(body_id);\n+                    let body = cx.tcx.hir().body(body_id);\n                     return is_infinite(cx, &body.value);\n                 }\n             }"}, {"sha": "8c8fc5dbedae9085afaff53e996fd2e94f6f027c", "filename": "clippy_lints/src/large_enum_variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_enum_variant.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -59,7 +59,7 @@ impl LintPass for LargeEnumVariant {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LargeEnumVariant {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &Item) {\n-        let did = cx.tcx.hir.local_def_id(item.id);\n+        let did = cx.tcx.hir().local_def_id(item.id);\n         if let ItemKind::Enum(ref def, _) = item.node {\n             let ty = cx.tcx.type_of(did);\n             let adt = ty.ty_adt_def().expect(\"already checked whether this is an enum\");"}, {"sha": "47b0fb55934693911374b14458a343aeaf364dfe", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -137,7 +137,7 @@ fn check_trait_items(cx: &LateContext<'_, '_>, visited_trait: &Item, trait_items\n         item.ident.name == name\n             && if let AssociatedItemKind::Method { has_self } = item.kind {\n                 has_self && {\n-                    let did = cx.tcx.hir.local_def_id(item.id.node_id);\n+                    let did = cx.tcx.hir().local_def_id(item.id.node_id);\n                     cx.tcx.fn_sig(did).inputs().skip_binder().len() == 1\n                 }\n             } else {\n@@ -156,7 +156,7 @@ fn check_trait_items(cx: &LateContext<'_, '_>, visited_trait: &Item, trait_items\n \n     if cx.access_levels.is_exported(visited_trait.id) && trait_items.iter().any(|i| is_named_self(cx, i, \"len\")) {\n         let mut current_and_super_traits = FxHashSet::default();\n-        let visited_trait_def_id = cx.tcx.hir.local_def_id(visited_trait.id);\n+        let visited_trait_def_id = cx.tcx.hir().local_def_id(visited_trait.id);\n         fill_trait_set(visited_trait_def_id, &mut current_and_super_traits, cx);\n \n         let is_empty_method_found = current_and_super_traits\n@@ -188,7 +188,7 @@ fn check_impl_items(cx: &LateContext<'_, '_>, item: &Item, impl_items: &[ImplIte\n         item.ident.name == name\n             && if let AssociatedItemKind::Method { has_self } = item.kind {\n                 has_self && {\n-                    let did = cx.tcx.hir.local_def_id(item.id.node_id);\n+                    let did = cx.tcx.hir().local_def_id(item.id.node_id);\n                     cx.tcx.fn_sig(did).inputs().skip_binder().len() == 1\n                 }\n             } else {\n@@ -208,7 +208,7 @@ fn check_impl_items(cx: &LateContext<'_, '_>, item: &Item, impl_items: &[ImplIte\n \n     if let Some(i) = impl_items.iter().find(|i| is_named_self(cx, i, \"len\")) {\n         if cx.access_levels.is_exported(i.id.node_id) {\n-            let def_id = cx.tcx.hir.local_def_id(item.id);\n+            let def_id = cx.tcx.hir().local_def_id(item.id);\n             let ty = cx.tcx.type_of(def_id);\n \n             span_lint("}, {"sha": "9dcbf576375ba3ee941c3165111bf496bd3462f7", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -204,7 +204,7 @@ fn could_use_elision<'a, 'tcx: 'a>(\n         let mut checker = BodyLifetimeChecker {\n             lifetimes_used_in_body: false,\n         };\n-        checker.visit_expr(&cx.tcx.hir.body(body_id).value);\n+        checker.visit_expr(&cx.tcx.hir().body(body_id).value);\n         if checker.lifetimes_used_in_body {\n             return false;\n         }\n@@ -324,7 +324,7 @@ impl<'v, 't> RefVisitor<'v, 't> {\n                     GenericArg::Type(_) => false,\n                 })\n             {\n-                let hir_id = self.cx.tcx.hir.node_to_hir_id(ty.id);\n+                let hir_id = self.cx.tcx.hir().node_to_hir_id(ty.id);\n                 match self.cx.tables.qpath_def(qpath, hir_id) {\n                     Def::TyAlias(def_id) | Def::Struct(def_id) => {\n                         let generics = self.cx.tcx.generics_of(def_id);\n@@ -360,7 +360,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n                 self.collect_anonymous_lifetimes(path, ty);\n             },\n             TyKind::Def(item, _) => {\n-                if let ItemKind::Existential(ref exist_ty) = self.cx.tcx.hir.expect_item(item.id).node {\n+                if let ItemKind::Existential(ref exist_ty) = self.cx.tcx.hir().expect_item(item.id).node {\n                     for bound in &exist_ty.bounds {\n                         if let GenericBound::Outlives(_) = *bound {\n                             self.record(&None);"}, {"sha": "7ff43bd2da294ddefeb51462f52f9ac6d7b36aa1", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -1111,8 +1111,8 @@ fn check_for_loop_range<'a, 'tcx>(\n \n                 // ensure that the indexed variable was declared before the loop, see #601\n                 if let Some(indexed_extent) = indexed_extent {\n-                    let parent_id = cx.tcx.hir.get_parent(expr.id);\n-                    let parent_def_id = cx.tcx.hir.local_def_id(parent_id);\n+                    let parent_id = cx.tcx.hir().get_parent(expr.id);\n+                    let parent_def_id = cx.tcx.hir().local_def_id(parent_id);\n                     let region_scope_tree = cx.tcx.region_scope_tree(parent_def_id);\n                     let pat_extent = region_scope_tree.var_scope(pat.hir_id.local_id);\n                     if region_scope_tree.is_subscope_of(indexed_extent, pat_extent) {\n@@ -1464,7 +1464,7 @@ fn check_for_loop_explicit_counter<'a, 'tcx>(\n \n     // For each candidate, check the parent block to see if\n     // it's initialized to zero at the start of the loop.\n-    let map = &cx.tcx.hir;\n+    let map = &cx.tcx.hir();\n     let parent_scope = map\n         .get_enclosing_scope(expr.id)\n         .and_then(|id| map.get_enclosing_scope(id));\n@@ -1636,7 +1636,7 @@ fn check_for_mutability(cx: &LateContext<'_, '_>, bound: &Expr) -> Option<NodeId\n         then {\n             let def = cx.tables.qpath_def(qpath, bound.hir_id);\n             if let Def::Local(node_id) = def {\n-                let node_str = cx.tcx.hir.get(node_id);\n+                let node_str = cx.tcx.hir().get(node_id);\n                 if_chain! {\n                     if let Node::Binding(pat) = node_str;\n                     if let PatKind::Binding(bind_ann, _, _, _) = pat.node;\n@@ -1772,10 +1772,10 @@ impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n                     let def = self.cx.tables.qpath_def(seqpath, seqexpr.hir_id);\n                     match def {\n                         Def::Local(node_id) | Def::Upvar(node_id, ..) => {\n-                            let hir_id = self.cx.tcx.hir.node_to_hir_id(node_id);\n+                            let hir_id = self.cx.tcx.hir().node_to_hir_id(node_id);\n \n-                            let parent_id = self.cx.tcx.hir.get_parent(expr.id);\n-                            let parent_def_id = self.cx.tcx.hir.local_def_id(parent_id);\n+                            let parent_id = self.cx.tcx.hir().get_parent(expr.id);\n+                            let parent_def_id = self.cx.tcx.hir().local_def_id(parent_id);\n                             let extent = self.cx.tcx.region_scope_tree(parent_def_id).var_scope(hir_id.local_id);\n                             if indexed_indirectly {\n                                 self.indexed_indirectly.insert(seqvar.segments[0].ident.name, Some(extent));\n@@ -2186,7 +2186,7 @@ fn is_conditional(expr: &Expr) -> bool {\n fn is_nested(cx: &LateContext<'_, '_>, match_expr: &Expr, iter_expr: &Expr) -> bool {\n     if_chain! {\n         if let Some(loop_block) = get_enclosing_block(cx, match_expr.id);\n-        if let Some(Node::Expr(loop_expr)) = cx.tcx.hir.find(cx.tcx.hir.get_parent_node(loop_block.id));\n+        if let Some(Node::Expr(loop_expr)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_node(loop_block.id));\n         then {\n             return is_loop_nested(cx, loop_expr, iter_expr)\n         }\n@@ -2202,11 +2202,11 @@ fn is_loop_nested(cx: &LateContext<'_, '_>, loop_expr: &Expr, iter_expr: &Expr)\n         return true;\n     };\n     loop {\n-        let parent = cx.tcx.hir.get_parent_node(id);\n+        let parent = cx.tcx.hir().get_parent_node(id);\n         if parent == id {\n             return false;\n         }\n-        match cx.tcx.hir.find(parent) {\n+        match cx.tcx.hir().find(parent) {\n             Some(Node::Expr(expr)) => match expr.node {\n                 ExprKind::Loop(..) | ExprKind::While(..) => {\n                     return true;"}, {"sha": "8ca1fbb27592fd23b549e492f188e35652028019", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -69,7 +69,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             let ty = cx.tables.expr_ty(&args[0]);\n             if match_type(cx, ty, &paths::OPTION) || match_trait_method(cx, e, &paths::ITERATOR);\n             if let hir::ExprKind::Closure(_, _, body_id, _, _) = args[1].node;\n-            let closure_body = cx.tcx.hir.body(body_id);\n+            let closure_body = cx.tcx.hir().body(body_id);\n             let closure_expr = remove_blocks(&closure_body.value);\n             then {\n                 match closure_body.arguments[0].pat.node {"}, {"sha": "39450deb84cab030531553420ff87e7ecd2a8289", "filename": "clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -161,7 +161,7 @@ fn reduce_unit_expression<'a>(cx: &LateContext<'_, '_>, expr: &'a hir::Expr) ->\n \n fn unit_closure<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'a hir::Expr) -> Option<(&'tcx hir::Arg, &'a hir::Expr)> {\n     if let hir::ExprKind::Closure(_, ref decl, inner_expr_id, _, _) = expr.node {\n-        let body = cx.tcx.hir.body(inner_expr_id);\n+        let body = cx.tcx.hir().body(inner_expr_id);\n         let body_expr = &body.value;\n \n         if_chain! {"}, {"sha": "d311f76074cc0e37ed17846dc380ecc5b58f0057", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -911,14 +911,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             return;\n         }\n         let name = implitem.ident.name;\n-        let parent = cx.tcx.hir.get_parent(implitem.id);\n-        let item = cx.tcx.hir.expect_item(parent);\n-        let def_id = cx.tcx.hir.local_def_id(item.id);\n+        let parent = cx.tcx.hir().get_parent(implitem.id);\n+        let item = cx.tcx.hir().expect_item(parent);\n+        let def_id = cx.tcx.hir().local_def_id(item.id);\n         let ty = cx.tcx.type_of(def_id);\n         if_chain! {\n             if let hir::ImplItemKind::Method(ref sig, id) = implitem.node;\n             if let Some(first_arg_ty) = sig.decl.inputs.get(0);\n-            if let Some(first_arg) = iter_input_pats(&sig.decl, cx.tcx.hir.body(id)).next();\n+            if let Some(first_arg) = iter_input_pats(&sig.decl, cx.tcx.hir().body(id)).next();\n             if let hir::ItemKind::Impl(_, _, _, _, None, ref self_ty, _) = item.node;\n             then {\n                 if cx.access_levels.is_exported(implitem.id) {\n@@ -1086,7 +1086,7 @@ fn lint_or_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span: Spa\n         }\n \n         // don't lint for constant values\n-        let owner_def = cx.tcx.hir.get_parent_did(arg.id);\n+        let owner_def = cx.tcx.hir().get_parent_did(arg.id);\n         let promotable = cx.tcx.rvalue_promotable_map(owner_def).contains(&arg.hir_id.local_id);\n         if promotable {\n             return;\n@@ -1333,9 +1333,11 @@ fn lint_clone_on_copy(cx: &LateContext<'_, '_>, expr: &hir::Expr, arg: &hir::Exp\n         let snip;\n         if let Some(snippet) = sugg::Sugg::hir_opt(cx, arg) {\n             // x.clone() might have dereferenced x, possibly through Deref impls\n-            if cx.tables.expr_ty(arg) != ty {\n-                let parent = cx.tcx.hir.get_parent_node(expr.id);\n-                match cx.tcx.hir.get(parent) {\n+            if cx.tables.expr_ty(arg) == ty {\n+                snip = Some((\"try removing the `clone` call\", format!(\"{}\", snippet)));\n+            } else {\n+                let parent = cx.tcx.hir().get_parent_node(expr.id);\n+                match cx.tcx.hir().get(parent) {\n                     hir::Node::Expr(parent) => match parent.node {\n                         // &*x is a nop, &x.clone() is not\n                         hir::ExprKind::AddrOf(..) |\n@@ -1367,8 +1369,6 @@ fn lint_clone_on_copy(cx: &LateContext<'_, '_>, expr: &hir::Expr, arg: &hir::Exp\n                     .count();\n                 let derefs: String = iter::repeat('*').take(deref_count).collect();\n                 snip = Some((\"try dereferencing it\", format!(\"{}{}\", derefs, snippet)));\n-            } else {\n-                snip = Some((\"try removing the `clone` call\", format!(\"{}\", snippet)));\n             }\n         } else {\n             snip = None;\n@@ -1496,7 +1496,7 @@ fn lint_unnecessary_fold(cx: &LateContext<'_, '_>, expr: &hir::Expr, fold_args:\n         if_chain! {\n             // Extract the body of the closure passed to fold\n             if let hir::ExprKind::Closure(_, _, body_id, _, _) = fold_args[2].node;\n-            let closure_body = cx.tcx.hir.body(body_id);\n+            let closure_body = cx.tcx.hir().body(body_id);\n             let closure_expr = remove_blocks(&closure_body.value);\n \n             // Check if the closure body is of the form `acc <op> some_expr(x)`"}, {"sha": "3ffe802201fe01099995ffb9415c7ff48536a70e", "filename": "clippy_lints/src/methods/unnecessary_filter_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -26,7 +26,7 @@ pub(super) fn lint(cx: &LateContext<'_, '_>, expr: &hir::Expr, args: &[hir::Expr\n     }\n \n     if let hir::ExprKind::Closure(_, _, body_id, ..) = args[1].node {\n-        let body = cx.tcx.hir.body(body_id);\n+        let body = cx.tcx.hir().body(body_id);\n         let arg_id = body.arguments[0].pat.id;\n         let mutates_arg = match mutated_variables(&body.value, cx) {\n             Some(used_mutably) => used_mutably.contains(&arg_id),"}, {"sha": "bc3e19064dbd7563ca156bcc3fb66cfc82c98674", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -612,7 +612,7 @@ fn in_attributes_expansion(expr: &Expr) -> bool {\n /// Test whether `def` is a variable defined outside a macro.\n fn non_macro_local(cx: &LateContext<'_, '_>, def: &def::Def) -> bool {\n     match *def {\n-        def::Def::Local(id) | def::Def::Upvar(id, _, _) => !in_macro(cx.tcx.hir.span(id)),\n+        def::Def::Local(id) | def::Def::Upvar(id, _, _) => !in_macro(cx.tcx.hir().span(id)),\n         _ => false,\n     }\n }"}, {"sha": "6a2db0bb098b36e0e85e5c6b697091df015a513d", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -142,8 +142,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n             hir::ItemKind::Fn(..) => {\n                 // ignore main()\n                 if it.name == \"main\" {\n-                    let def_id = cx.tcx.hir.local_def_id(it.id);\n-                    let def_key = cx.tcx.hir.def_key(def_id);\n+                    let def_id = cx.tcx.hir().local_def_id(it.id);\n+                    let def_key = cx.tcx.hir().def_key(def_id);\n                     if def_key.parent == Some(hir::def_id::CRATE_DEF_INDEX) {\n                         return;\n                     }\n@@ -180,7 +180,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n \n     fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, impl_item: &'tcx hir::ImplItem) {\n         // If the method is an impl for a trait, don't doc.\n-        let def_id = cx.tcx.hir.local_def_id(impl_item.id);\n+        let def_id = cx.tcx.hir().local_def_id(impl_item.id);\n         match cx.tcx.associated_item(def_id).container {\n             ty::TraitContainer(_) => return,\n             ty::ImplContainer(cid) => {"}, {"sha": "b76d63166003b31579a160b0123407912510dbc1", "filename": "clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_inline.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -123,15 +123,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingInline {\n                 // note: we need to check if the trait is exported so we can't use\n                 // `LateLintPass::check_trait_item` here.\n                 for tit in trait_items {\n-                    let tit_ = cx.tcx.hir.trait_item(tit.id);\n+                    let tit_ = cx.tcx.hir().trait_item(tit.id);\n                     match tit_.node {\n                         hir::TraitItemKind::Const(..) | hir::TraitItemKind::Type(..) => {},\n                         hir::TraitItemKind::Method(..) => {\n                             if tit.defaultness.has_value() {\n                                 // trait method with default body needs inline in case\n                                 // an impl is not provided\n                                 let desc = \"a default trait method\";\n-                                let item = cx.tcx.hir.expect_trait_item(tit.id.node_id);\n+                                let item = cx.tcx.hir().expect_trait_item(tit.id.node_id);\n                                 check_missing_inline_attrs(cx, &item.attrs, item.span, desc);\n                             }\n                         },\n@@ -171,14 +171,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingInline {\n             hir::ImplItemKind::Const(..) | hir::ImplItemKind::Type(_) | hir::ImplItemKind::Existential(_) => return,\n         };\n \n-        let def_id = cx.tcx.hir.local_def_id(impl_item.id);\n+        let def_id = cx.tcx.hir().local_def_id(impl_item.id);\n         let trait_def_id = match cx.tcx.associated_item(def_id).container {\n             TraitContainer(cid) => Some(cid),\n             ImplContainer(cid) => cx.tcx.impl_trait_ref(cid).map(|t| t.def_id),\n         };\n \n         if let Some(trait_def_id) = trait_def_id {\n-            if let Some(n) = cx.tcx.hir.as_local_node_id(trait_def_id) {\n+            if let Some(n) = cx.tcx.hir().as_local_node_id(trait_def_id) {\n                 if !cx.access_levels.is_exported(n) {\n                     // If a trait is being implemented for an item, and the\n                     // trait is not exported, we don't need #[inline]"}, {"sha": "26bd56c2e7b0ac1fdfbcf455e343afadb803d5b2", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -107,7 +107,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n         }\n \n         // Exclude non-inherent impls\n-        if let Some(Node::Item(item)) = cx.tcx.hir.find(cx.tcx.hir.get_parent_node(node_id)) {\n+        if let Some(Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_node(node_id)) {\n             if matches!(item.node, ItemKind::Impl(_, _, _, _, Some(_), _, _) |\n                 ItemKind::Trait(..))\n             {\n@@ -126,7 +126,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n \n         let sized_trait = need!(cx.tcx.lang_items().sized_trait());\n \n-        let fn_def_id = cx.tcx.hir.local_def_id(node_id);\n+        let fn_def_id = cx.tcx.hir().local_def_id(node_id);\n \n         let preds = traits::elaborate_predicates(cx.tcx, cx.param_env.caller_bounds.to_vec())\n             .filter(|p| !p.is_global())\n@@ -220,7 +220,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                     // Dereference suggestion\n                     let sugg = |db: &mut DiagnosticBuilder<'_>| {\n                         if let ty::Adt(def, ..) = ty.sty {\n-                            if let Some(span) = cx.tcx.hir.span_if_local(def.did) {\n+                            if let Some(span) = cx.tcx.hir().span_if_local(def.did) {\n                                 if cx.param_env.can_type_implement_copy(cx.tcx, ty).is_ok() {\n                                     db.span_help(span, \"consider marking this type as Copy\");\n                                 }\n@@ -355,14 +355,14 @@ impl<'a, 'tcx> MovedVariablesCtxt<'a, 'tcx> {\n         if let mc::Categorization::Local(vid) = cmt.cat {\n             let mut id = matched_pat.id;\n             loop {\n-                let parent = self.cx.tcx.hir.get_parent_node(id);\n+                let parent = self.cx.tcx.hir().get_parent_node(id);\n                 if id == parent {\n                     // no parent\n                     return;\n                 }\n                 id = parent;\n \n-                if let Some(node) = self.cx.tcx.hir.find(id) {\n+                if let Some(node) = self.cx.tcx.hir().find(id) {\n                     match node {\n                         Node::Expr(e) => {\n                             // `match` and `if let`"}, {"sha": "7b838fdee9510da361469ceffbba3b38269051ba", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -107,7 +107,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n         if let hir::ItemKind::Impl(_, _, _, _, None, _, ref items) = item.node {\n             for assoc_item in items {\n                 if let hir::AssociatedItemKind::Method { has_self: false } = assoc_item.kind {\n-                    let impl_item = cx.tcx.hir.impl_item(assoc_item.id);\n+                    let impl_item = cx.tcx.hir().impl_item(assoc_item.id);\n                     if in_external_macro(cx.sess(), impl_item.span) {\n                         return;\n                     }\n@@ -132,7 +132,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n                             return;\n                         }\n                         if sig.decl.inputs.is_empty() && name == \"new\" && cx.access_levels.is_reachable(id) {\n-                            let self_did = cx.tcx.hir.local_def_id(cx.tcx.hir.get_parent(id));\n+                            let self_did = cx.tcx.hir().local_def_id(cx.tcx.hir().get_parent(id));\n                             let self_ty = cx.tcx.type_of(self_did);\n                             if_chain! {\n                                 if same_tys(cx, self_ty, return_ty(cx, id));\n@@ -142,7 +142,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n                                         let mut impls = NodeSet::default();\n                                         cx.tcx.for_each_impl(default_trait_id, |d| {\n                                             if let Some(ty_def) = cx.tcx.type_of(d).ty_adt_def() {\n-                                                if let Some(node_id) = cx.tcx.hir.as_local_node_id(ty_def.did) {\n+                                                if let Some(node_id) = cx.tcx.hir().as_local_node_id(ty_def.did) {\n                                                     impls.insert(node_id);\n                                                 }\n                                             }\n@@ -157,7 +157,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n                                         if let Some(self_def) = cx.tcx.type_of(self_did).ty_adt_def();\n                                         if self_def.did.is_local();\n                                         then {\n-                                            let self_id = cx.tcx.hir.local_def_id_to_node_id(self_def.did.to_local());\n+                                            let self_id = cx.tcx.hir().local_def_id_to_node_id(self_def.did.to_local());\n                                             if impling_types.contains(&self_id) {\n                                                 return;\n                                             }"}, {"sha": "b699a53176e99de02ffddc351f73919e2e225efd", "filename": "clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -182,8 +182,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCopyConst {\n \n     fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, impl_item: &'tcx ImplItem) {\n         if let ImplItemKind::Const(hir_ty, ..) = &impl_item.node {\n-            let item_node_id = cx.tcx.hir.get_parent_node(impl_item.id);\n-            let item = cx.tcx.hir.expect_item(item_node_id);\n+            let item_node_id = cx.tcx.hir().get_parent_node(impl_item.id);\n+            let item = cx.tcx.hir().expect_item(item_node_id);\n             // ensure the impl is an inherent impl.\n             if let ItemKind::Impl(_, _, _, _, None, _, _) = item.node {\n                 let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n@@ -217,11 +217,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCopyConst {\n             let mut dereferenced_expr = expr;\n             let mut needs_check_adjustment = true;\n             loop {\n-                let parent_id = cx.tcx.hir.get_parent_node(cur_expr.id);\n+                let parent_id = cx.tcx.hir().get_parent_node(cur_expr.id);\n                 if parent_id == cur_expr.id {\n                     break;\n                 }\n-                if let Some(Node::Expr(parent_expr)) = cx.tcx.hir.find(parent_id) {\n+                if let Some(Node::Expr(parent_expr)) = cx.tcx.hir().find(parent_id) {\n                     match &parent_expr.node {\n                         ExprKind::AddrOf(..) => {\n                             // `&e` => `e` must be referenced"}, {"sha": "b2039c2630006552bfa6d56ceba2400714f32d51", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -122,7 +122,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PointerPass {\n \n     fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx ImplItem) {\n         if let ImplItemKind::Method(ref sig, body_id) = item.node {\n-            if let Some(Node::Item(it)) = cx.tcx.hir.find(cx.tcx.hir.get_parent(item.id)) {\n+            if let Some(Node::Item(it)) = cx.tcx.hir().find(cx.tcx.hir().get_parent(item.id)) {\n                 if let ItemKind::Impl(_, _, _, _, Some(_), _, _) = it.node {\n                     return; // ignore trait impls\n                 }\n@@ -157,7 +157,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PointerPass {\n }\n \n fn check_fn(cx: &LateContext<'_, '_>, decl: &FnDecl, fn_id: NodeId, opt_body_id: Option<BodyId>) {\n-    let fn_def_id = cx.tcx.hir.local_def_id(fn_id);\n+    let fn_def_id = cx.tcx.hir().local_def_id(fn_id);\n     let sig = cx.tcx.fn_sig(fn_def_id);\n     let fn_ty = sig.skip_binder();\n "}, {"sha": "c61608e1c1b32741ab3c576f19d842f87ed1b707", "filename": "clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -93,7 +93,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for RedundantClone {\n         _: Span,\n         _: NodeId,\n     ) {\n-        let def_id = cx.tcx.hir.body_owner_def_id(body.id());\n+        let def_id = cx.tcx.hir().body_owner_def_id(body.id());\n         let mir = cx.tcx.optimized_mir(def_id);\n \n         for (bb, bbdata) in mir.basic_blocks().iter_enumerated() {"}, {"sha": "21c4e9d30de8f3e56ab2c8437c5fe7a175893c34", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -371,7 +371,7 @@ fn check_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: &'tcx Ty, bindings: &mut V\n         TyKind::Slice(ref sty) => check_ty(cx, sty, bindings),\n         TyKind::Array(ref fty, ref anon_const) => {\n             check_ty(cx, fty, bindings);\n-            check_expr(cx, &cx.tcx.hir.body(anon_const.body).value, bindings);\n+            check_expr(cx, &cx.tcx.hir().body(anon_const.body).value, bindings);\n         },\n         TyKind::Ptr(MutTy { ty: ref mty, .. }) | TyKind::Rptr(_, MutTy { ty: ref mty, .. }) => {\n             check_ty(cx, mty, bindings)\n@@ -381,7 +381,7 @@ fn check_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: &'tcx Ty, bindings: &mut V\n                 check_ty(cx, t, bindings)\n             }\n         },\n-        TyKind::Typeof(ref anon_const) => check_expr(cx, &cx.tcx.hir.body(anon_const.body).value, bindings),\n+        TyKind::Typeof(ref anon_const) => check_expr(cx, &cx.tcx.hir().body(anon_const.body).value, bindings),\n         _ => (),\n     }\n }"}, {"sha": "c54d89da7053623d4ced1cc0314e2b684b0cd16c", "filename": "clippy_lints/src/suspicious_trait_impl.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -82,17 +82,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SuspiciousImpl {\n             }\n             // Check if the binary expression is part of another bi/unary expression\n             // as a child node\n-            let mut parent_expr = cx.tcx.hir.get_parent_node(expr.id);\n+            let mut parent_expr = cx.tcx.hir().get_parent_node(expr.id);\n             while parent_expr != ast::CRATE_NODE_ID {\n-                if let hir::Node::Expr(e) = cx.tcx.hir.get(parent_expr) {\n+                if let hir::Node::Expr(e) = cx.tcx.hir().get(parent_expr) {\n                     match e.node {\n                         hir::ExprKind::Binary(..)\n                         | hir::ExprKind::Unary(hir::UnOp::UnNot, _)\n                         | hir::ExprKind::Unary(hir::UnOp::UnNeg, _) => return,\n                         _ => {},\n                     }\n                 }\n-                parent_expr = cx.tcx.hir.get_parent_node(parent_expr);\n+                parent_expr = cx.tcx.hir().get_parent_node(parent_expr);\n             }\n             // as a parent node\n             let mut visitor = BinaryExprVisitor { in_binary_expr: false };\n@@ -182,12 +182,12 @@ fn check_binop<'a>(\n     }\n \n     // Get the actually implemented trait\n-    let parent_fn = cx.tcx.hir.get_parent(expr.id);\n-    let parent_impl = cx.tcx.hir.get_parent(parent_fn);\n+    let parent_fn = cx.tcx.hir().get_parent(expr.id);\n+    let parent_impl = cx.tcx.hir().get_parent(parent_fn);\n \n     if_chain! {\n         if parent_impl != ast::CRATE_NODE_ID;\n-        if let hir::Node::Item(item) = cx.tcx.hir.get(parent_impl);\n+        if let hir::Node::Item(item) = cx.tcx.hir().get(parent_impl);\n         if let hir::ItemKind::Impl(_, _, _, _, Some(ref trait_ref), _, _) = item.node;\n         if let Some(idx) = trait_ids.iter().position(|&tid| tid == trait_ref.path.def.def_id());\n         if binop != expected_ops[idx];"}, {"sha": "9a7a5958b62752cb81bd4c299c9a3a80afa764cd", "filename": "clippy_lints/src/trivially_copy_pass_by_ref.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -82,11 +82,11 @@ impl<'a, 'tcx> TriviallyCopyPassByRef {\n     }\n \n     fn check_trait_method(&mut self, cx: &LateContext<'_, 'tcx>, item: &TraitItemRef) {\n-        let method_def_id = cx.tcx.hir.local_def_id(item.id.node_id);\n+        let method_def_id = cx.tcx.hir().local_def_id(item.id.node_id);\n         let method_sig = cx.tcx.fn_sig(method_def_id);\n         let method_sig = cx.tcx.erase_late_bound_regions(&method_sig);\n \n-        let decl = match cx.tcx.hir.fn_decl(item.id.node_id) {\n+        let decl = match cx.tcx.hir().fn_decl(item.id.node_id) {\n             Some(b) => b,\n             None => return,\n         };\n@@ -192,15 +192,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TriviallyCopyPassByRef {\n         }\n \n         // Exclude non-inherent impls\n-        if let Some(Node::Item(item)) = cx.tcx.hir.find(cx.tcx.hir.get_parent_node(node_id)) {\n+        if let Some(Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_node(node_id)) {\n             if matches!(item.node, ItemKind::Impl(_, _, _, _, Some(_), _, _) |\n                 ItemKind::Trait(..))\n             {\n                 return;\n             }\n         }\n \n-        let fn_def_id = cx.tcx.hir.local_def_id(node_id);\n+        let fn_def_id = cx.tcx.hir().local_def_id(node_id);\n \n         let fn_sig = cx.tcx.fn_sig(fn_def_id);\n         let fn_sig = cx.tcx.erase_late_bound_regions(&fn_sig);"}, {"sha": "f9a0d6114290f91943038f30b6e83b1353424746", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -28,8 +28,9 @@ use crate::syntax::source_map::Span;\n use crate::utils::paths;\n use crate::utils::{\n     clip, comparisons, differing_macro_contexts, higher, in_constant, in_macro, int_bits, last_path_segment,\n-    match_def_path, match_path, match_type, multispan_sugg, opt_def_id, same_tys, sext, snippet, snippet_opt,\n+    match_def_path, match_path, multispan_sugg, opt_def_id, same_tys, sext, snippet, snippet_opt,\n     snippet_with_applicability, span_help_and_lint, span_lint, span_lint_and_sugg, span_lint_and_then, unsext,\n+    AbsolutePathBuffer\n };\n use if_chain::if_chain;\n use std::borrow::Cow;\n@@ -154,7 +155,7 @@ impl LintPass for TypePass {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypePass {\n     fn check_fn(&mut self, cx: &LateContext<'_, '_>, _: FnKind<'_>, decl: &FnDecl, _: &Body, _: Span, id: NodeId) {\n         // skip trait implementations, see #605\n-        if let Some(hir::Node::Item(item)) = cx.tcx.hir.find(cx.tcx.hir.get_parent(id)) {\n+        if let Some(hir::Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent(id)) {\n             if let ItemKind::Impl(_, _, _, _, Some(..), _, _) = item.node {\n                 return;\n             }\n@@ -203,7 +204,7 @@ fn match_type_parameter(cx: &LateContext<'_, '_>, qpath: &QPath, path: &[&str])\n             GenericArg::Lifetime(_) => None,\n         });\n         if let TyKind::Path(ref qpath) = ty.node;\n-        if let Some(did) = opt_def_id(cx.tables.qpath_def(qpath, cx.tcx.hir.node_to_hir_id(ty.id)));\n+        if let Some(did) = opt_def_id(cx.tables.qpath_def(qpath, cx.tcx.hir().node_to_hir_id(ty.id)));\n         if match_def_path(cx.tcx, did, path);\n         then {\n             return true;\n@@ -223,7 +224,7 @@ fn check_ty(cx: &LateContext<'_, '_>, ast_ty: &hir::Ty, is_local: bool) {\n     }\n     match ast_ty.node {\n         TyKind::Path(ref qpath) if !is_local => {\n-            let hir_id = cx.tcx.hir.node_to_hir_id(ast_ty.id);\n+            let hir_id = cx.tcx.hir().node_to_hir_id(ast_ty.id);\n             let def = cx.tables.qpath_def(qpath, hir_id);\n             if let Some(def_id) = opt_def_id(def) {\n                 if Some(def_id) == cx.tcx.lang_items().owned_box() {\n@@ -317,7 +318,7 @@ fn check_ty(cx: &LateContext<'_, '_>, ast_ty: &hir::Ty, is_local: bool) {\n fn check_ty_rptr(cx: &LateContext<'_, '_>, ast_ty: &hir::Ty, is_local: bool, lt: &Lifetime, mut_ty: &MutTy) {\n     match mut_ty.ty.node {\n         TyKind::Path(ref qpath) => {\n-            let hir_id = cx.tcx.hir.node_to_hir_id(mut_ty.ty.id);\n+            let hir_id = cx.tcx.hir().node_to_hir_id(mut_ty.ty.id);\n             let def = cx.tables.qpath_def(qpath, hir_id);\n             if_chain! {\n                 if let Some(def_id) = opt_def_id(def);\n@@ -545,7 +546,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitArg {\n             ExprKind::Call(_, ref args) | ExprKind::MethodCall(_, _, ref args) => {\n                 for arg in args {\n                     if is_unit(cx.tables.expr_ty(arg)) && !is_unit_literal(arg) {\n-                        let map = &cx.tcx.hir;\n+                        let map = &cx.tcx.hir();\n                         // apparently stuff in the desugaring of `?` can trigger this\n                         // so check for that here\n                         // only the calls to `Try::from_error` is marked as desugared,\n@@ -1023,6 +1024,21 @@ impl LintPass for CastPass {\n     }\n }\n \n+// Check if the given type is either `core::ffi::c_void` or\n+// one of the platform specific `libc::<platform>::c_void` of libc.\n+fn is_c_void(tcx: TyCtxt<'_, '_, '_>, ty: Ty<'_>) -> bool {\n+    if let ty::Adt(adt, _) = ty.sty {\n+        let mut apb = AbsolutePathBuffer { names: vec![] };\n+        tcx.push_item_path(&mut apb, adt.did, false);\n+\n+        if apb.names.is_empty() { return false }\n+        if apb.names[0] == \"libc\" || apb.names[0] == \"core\" && *apb.names.last().unwrap() == \"c_void\" {\n+            return true\n+        }\n+    }\n+    false\n+}\n+\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CastPass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprKind::Cast(ref ex, _) = expr.node {\n@@ -1114,10 +1130,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CastPass {\n                 if let Some(to_align) = cx.layout_of(to_ptr_ty.ty).ok().map(|a| a.align.abi);\n                 if from_align < to_align;\n                 // with c_void, we inherently need to trust the user\n-                if ! (\n-                    match_type(cx, from_ptr_ty.ty, &paths::C_VOID)\n-                    || match_type(cx, from_ptr_ty.ty, &paths::C_VOID_LIBC)\n-                );\n+                if !is_c_void(cx.tcx, from_ptr_ty.ty);\n                 then {\n                     span_lint(\n                         cx,\n@@ -1930,7 +1943,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImplicitHasher {\n                     });\n \n                     let mut ctr_vis = ImplicitHasherConstructorVisitor::new(cx, target);\n-                    for item in items.iter().map(|item| cx.tcx.hir.impl_item(item.id)) {\n+                    for item in items.iter().map(|item| cx.tcx.hir().impl_item(item.id)) {\n                         ctr_vis.visit_impl_item(item);\n                     }\n \n@@ -1949,7 +1962,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImplicitHasher {\n                 }\n             },\n             ItemKind::Fn(ref decl, .., ref generics, body_id) => {\n-                let body = cx.tcx.hir.body(body_id);\n+                let body = cx.tcx.hir().body(body_id);\n \n                 for ty in &decl.inputs {\n                     let mut vis = ImplicitHasherTypeVisitor::new(cx);\n@@ -2157,6 +2170,6 @@ impl<'a, 'b, 'tcx: 'a + 'b> Visitor<'tcx> for ImplicitHasherConstructorVisitor<'\n     }\n \n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.cx.tcx.hir)\n+        NestedVisitorMap::OnlyBodies(&self.cx.tcx.hir())\n     }\n }"}, {"sha": "bebbce8e73ec242fad1eaf0cede0ff56b4d1f871", "filename": "clippy_lints/src/unused_label.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Funused_label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Funused_label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_label.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -93,6 +93,6 @@ impl<'a, 'tcx: 'a> Visitor<'tcx> for UnusedLabelVisitor<'a, 'tcx> {\n         walk_expr(self, expr);\n     }\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::All(&self.cx.tcx.hir)\n+        NestedVisitorMap::All(&self.cx.tcx.hir())\n     }\n }"}, {"sha": "c65406a1954cb8ce84ba6f61eccd50aa629cec30", "filename": "clippy_lints/src/unwrap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -185,7 +185,7 @@ impl<'a, 'tcx: 'a> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n     }\n \n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.cx.tcx.hir)\n+        NestedVisitorMap::OnlyBodies(&self.cx.tcx.hir())\n     }\n }\n "}, {"sha": "d4e03c097f7c2d7395b89e4237554c56ddea5efc", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -135,7 +135,7 @@ fn check_trait_method_impl_decl<'a, 'tcx: 'a>(\n     let trait_method_sig = cx.tcx.fn_sig(trait_method.def_id);\n     let trait_method_sig = cx.tcx.erase_late_bound_regions(&trait_method_sig);\n \n-    let impl_method_def_id = cx.tcx.hir.local_def_id(impl_item.id);\n+    let impl_method_def_id = cx.tcx.hir().local_def_id(impl_item.id);\n     let impl_method_sig = cx.tcx.fn_sig(impl_method_def_id);\n     let impl_method_sig = cx.tcx.erase_late_bound_regions(&impl_method_sig);\n \n@@ -190,26 +190,26 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UseSelf {\n                         item_path,\n                         cx,\n                     };\n-                    let impl_def_id = cx.tcx.hir.local_def_id(item.id);\n+                    let impl_def_id = cx.tcx.hir().local_def_id(item.id);\n                     let impl_trait_ref = cx.tcx.impl_trait_ref(impl_def_id);\n \n                     if let Some(impl_trait_ref) = impl_trait_ref {\n                         for impl_item_ref in refs {\n-                            let impl_item = cx.tcx.hir.impl_item(impl_item_ref.id);\n+                            let impl_item = cx.tcx.hir().impl_item(impl_item_ref.id);\n                             if let ImplItemKind::Method(MethodSig{ decl: impl_decl, .. }, impl_body_id)\n                                     = &impl_item.node {\n                                 let item_type = cx.tcx.type_of(impl_def_id);\n                                 check_trait_method_impl_decl(cx, item_type, impl_item, impl_decl, &impl_trait_ref);\n \n-                                let body = cx.tcx.hir.body(*impl_body_id);\n+                                let body = cx.tcx.hir().body(*impl_body_id);\n                                 visitor.visit_body(body);\n                             } else {\n                                 visitor.visit_impl_item(impl_item);\n                             }\n                         }\n                     } else {\n                         for impl_item_ref in refs {\n-                            let impl_item = cx.tcx.hir.impl_item(impl_item_ref.id);\n+                            let impl_item = cx.tcx.hir().impl_item(impl_item_ref.id);\n                             visitor.visit_impl_item(impl_item);\n                         }\n                     }\n@@ -238,6 +238,6 @@ impl<'a, 'tcx> Visitor<'tcx> for UseSelfVisitor<'a, 'tcx> {\n     }\n \n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::All(&self.cx.tcx.hir)\n+        NestedVisitorMap::All(&self.cx.tcx.hir())\n     }\n }"}, {"sha": "73169414a028b7ffea939a6e7896ab6dacd3bff1", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -145,9 +145,9 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n             },\n             (&ExprKind::Repeat(ref le, ref ll_id), &ExprKind::Repeat(ref re, ref rl_id)) => {\n                 let mut celcx = constant_context(self.cx, self.cx.tcx.body_tables(ll_id.body));\n-                let ll = celcx.expr(&self.cx.tcx.hir.body(ll_id.body).value);\n+                let ll = celcx.expr(&self.cx.tcx.hir().body(ll_id.body).value);\n                 let mut celcx = constant_context(self.cx, self.cx.tcx.body_tables(rl_id.body));\n-                let rl = celcx.expr(&self.cx.tcx.hir.body(rl_id.body).value);\n+                let rl = celcx.expr(&self.cx.tcx.hir().body(rl_id.body).value);\n \n                 self.eq_expr(le, re) && ll == rl\n             },\n@@ -287,11 +287,11 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n \n                 let mut celcx = constant_context(self.cx, self.cx.tcx.body_tables(ll_id.body));\n                 self.tables = self.cx.tcx.body_tables(ll_id.body);\n-                let ll = celcx.expr(&self.cx.tcx.hir.body(ll_id.body).value);\n+                let ll = celcx.expr(&self.cx.tcx.hir().body(ll_id.body).value);\n \n                 let mut celcx = constant_context(self.cx, self.cx.tcx.body_tables(rl_id.body));\n                 self.tables = self.cx.tcx.body_tables(rl_id.body);\n-                let rl = celcx.expr(&self.cx.tcx.hir.body(rl_id.body).value);\n+                let rl = celcx.expr(&self.cx.tcx.hir().body(rl_id.body).value);\n \n                 let eq_ty = self.eq_ty(lt, rt);\n                 self.tables = full_table;\n@@ -484,7 +484,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                     CaptureClause::CaptureByRef => 1,\n                 }\n                 .hash(&mut self.s);\n-                self.hash_expr(&self.cx.tcx.hir.body(eid).value);\n+                self.hash_expr(&self.cx.tcx.hir().body(eid).value);\n             },\n             ExprKind::Field(ref e, ref f) => {\n                 let c: fn(_, _) -> _ = ExprKind::Field;\n@@ -551,7 +551,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 self.hash_expr(e);\n                 let full_table = self.tables;\n                 self.tables = self.cx.tcx.body_tables(l_id.body);\n-                self.hash_expr(&self.cx.tcx.hir.body(l_id.body).value);\n+                self.hash_expr(&self.cx.tcx.hir().body(l_id.body).value);\n                 self.tables = full_table;\n             },\n             ExprKind::Ret(ref e) => {"}, {"sha": "93a5845ad458edef27a6daf9928524c6c1a2a362", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -74,7 +74,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         match item.node {\n             hir::ImplItemKind::Const(_, body_id) => {\n                 println!(\"associated constant\");\n-                print_expr(cx, &cx.tcx.hir.body(body_id).value, 1);\n+                print_expr(cx, &cx.tcx.hir().body(body_id).value, 1);\n             },\n             hir::ImplItemKind::Method(..) => println!(\"method\"),\n             hir::ImplItemKind::Type(_) => println!(\"associated type\"),\n@@ -345,13 +345,13 @@ fn print_expr(cx: &LateContext<'_, '_>, expr: &hir::Expr, indent: usize) {\n             println!(\"{}value:\", ind);\n             print_expr(cx, val, indent + 1);\n             println!(\"{}repeat count:\", ind);\n-            print_expr(cx, &cx.tcx.hir.body(anon_const.body).value, indent + 1);\n+            print_expr(cx, &cx.tcx.hir().body(anon_const.body).value, indent + 1);\n         },\n     }\n }\n \n fn print_item(cx: &LateContext<'_, '_>, item: &hir::Item) {\n-    let did = cx.tcx.hir.local_def_id(item.id);\n+    let did = cx.tcx.hir().local_def_id(item.id);\n     println!(\"item `{}`\", item.name);\n     match item.vis.node {\n         hir::VisibilityKind::Public => println!(\"public\"),\n@@ -364,7 +364,7 @@ fn print_item(cx: &LateContext<'_, '_>, item: &hir::Item) {\n     }\n     match item.node {\n         hir::ItemKind::ExternCrate(ref _renamed_from) => {\n-            let def_id = cx.tcx.hir.local_def_id(item.id);\n+            let def_id = cx.tcx.hir().local_def_id(item.id);\n             if let Some(crate_id) = cx.tcx.extern_mod_stmt_cnum(def_id) {\n                 let source = cx.tcx.used_crate_source(crate_id);\n                 if let Some(ref src) = source.dylib {"}, {"sha": "144e2693b47414aa563db3af01fb7f2bb9ceed8f", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -166,8 +166,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LintWithoutLintPass {\n                         output: &mut self.registered_lints,\n                         cx,\n                     };\n-                    let body_id = cx.tcx.hir.body_owned_by(impl_item_refs[0].id.node_id);\n-                    collector.visit_expr(&cx.tcx.hir.body(body_id).value);\n+                    let body_id = cx.tcx.hir().body_owned_by(impl_item_refs[0].id.node_id);\n+                    collector.visit_expr(&cx.tcx.hir().body(body_id).value);\n                 }\n             }\n         }\n@@ -236,7 +236,7 @@ impl<'a, 'tcx: 'a> Visitor<'tcx> for LintCollector<'a, 'tcx> {\n         }\n     }\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::All(&self.cx.tcx.hir)\n+        NestedVisitorMap::All(&self.cx.tcx.hir())\n     }\n }\n "}, {"sha": "68357b08d6ca26b3cb53c1c6ce3c4dccea9b39a2", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 29, "deletions": 27, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -29,6 +29,7 @@ use crate::syntax::attr;\n use crate::syntax::errors::DiagnosticBuilder;\n use crate::syntax::source_map::{Span, DUMMY_SP};\n use crate::syntax::symbol::{keywords, Symbol};\n+use crate::syntax::symbol;\n use if_chain::if_chain;\n use matches::matches;\n use std::borrow::Cow;\n@@ -62,8 +63,8 @@ pub fn differing_macro_contexts(lhs: Span, rhs: Span) -> bool {\n }\n \n pub fn in_constant(cx: &LateContext<'_, '_>, id: NodeId) -> bool {\n-    let parent_id = cx.tcx.hir.get_parent(id);\n-    match cx.tcx.hir.body_owner_kind(parent_id) {\n+    let parent_id = cx.tcx.hir().get_parent(id);\n+    match cx.tcx.hir().body_owner_kind(parent_id) {\n         hir::BodyOwnerKind::Fn => false,\n         hir::BodyOwnerKind::Const | hir::BodyOwnerKind::Static(..) => true,\n     }\n@@ -74,6 +75,25 @@ pub fn in_macro(span: Span) -> bool {\n     span.ctxt().outer().expn_info().is_some()\n }\n \n+/// Used to store the absolute path to a type.\n+///\n+/// See `match_def_path` for usage.\n+#[derive(Debug)]\n+pub struct AbsolutePathBuffer {\n+    pub names: Vec<symbol::LocalInternedString>,\n+}\n+\n+impl ty::item_path::ItemPathBuffer for AbsolutePathBuffer {\n+    fn root_mode(&self) -> &ty::item_path::RootMode {\n+        const ABSOLUTE: &ty::item_path::RootMode = &ty::item_path::RootMode::Absolute;\n+        ABSOLUTE\n+    }\n+\n+    fn push(&mut self, text: &str) {\n+        self.names.push(symbol::Symbol::intern(text).as_str());\n+    }\n+}\n+\n /// Check if a `DefId`'s path matches the given absolute type path usage.\n ///\n /// # Examples\n@@ -83,24 +103,6 @@ pub fn in_macro(span: Span) -> bool {\n ///\n /// See also the `paths` module.\n pub fn match_def_path(tcx: TyCtxt<'_, '_, '_>, def_id: DefId, path: &[&str]) -> bool {\n-    use crate::syntax::symbol;\n-\n-    #[derive(Debug)]\n-    struct AbsolutePathBuffer {\n-        names: Vec<symbol::LocalInternedString>,\n-    }\n-\n-    impl ty::item_path::ItemPathBuffer for AbsolutePathBuffer {\n-        fn root_mode(&self) -> &ty::item_path::RootMode {\n-            const ABSOLUTE: &ty::item_path::RootMode = &ty::item_path::RootMode::Absolute;\n-            ABSOLUTE\n-        }\n-\n-        fn push(&mut self, text: &str) {\n-            self.names.push(symbol::Symbol::intern(text).as_str());\n-        }\n-    }\n-\n     let mut apb = AbsolutePathBuffer { names: vec![] };\n \n     tcx.push_item_path(&mut apb, def_id, false);\n@@ -331,8 +333,8 @@ pub fn method_chain_args<'a>(expr: &'a Expr, methods: &[&str]) -> Option<Vec<&'a\n \n /// Get the name of the item the expression is in, if available.\n pub fn get_item_name(cx: &LateContext<'_, '_>, expr: &Expr) -> Option<Name> {\n-    let parent_id = cx.tcx.hir.get_parent(expr.id);\n-    match cx.tcx.hir.find(parent_id) {\n+    let parent_id = cx.tcx.hir().get_parent(expr.id);\n+    match cx.tcx.hir().find(parent_id) {\n         Some(Node::Item(&Item { ref name, .. })) => Some(*name),\n         Some(Node::TraitItem(&TraitItem { ident, .. })) | Some(Node::ImplItem(&ImplItem { ident, .. })) => {\n             Some(ident.name)\n@@ -520,7 +522,7 @@ fn trim_multiline_inner(s: Cow<'_, str>, ignore_first: bool, ch: char) -> Cow<'_\n \n /// Get a parent expressions if any \u2013 this is useful to constrain a lint.\n pub fn get_parent_expr<'c>(cx: &'c LateContext<'_, '_>, e: &Expr) -> Option<&'c Expr> {\n-    let map = &cx.tcx.hir;\n+    let map = &cx.tcx.hir();\n     let node_id: NodeId = e.id;\n     let parent_id: NodeId = map.get_parent_node(node_id);\n     if node_id == parent_id {\n@@ -536,7 +538,7 @@ pub fn get_parent_expr<'c>(cx: &'c LateContext<'_, '_>, e: &Expr) -> Option<&'c\n }\n \n pub fn get_enclosing_block<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, node: NodeId) -> Option<&'tcx Block> {\n-    let map = &cx.tcx.hir;\n+    let map = &cx.tcx.hir();\n     let enclosing_node = map\n         .get_enclosing_scope(node)\n         .and_then(|enclosing_id| map.find(enclosing_id));\n@@ -550,7 +552,7 @@ pub fn get_enclosing_block<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, node: NodeI\n             | Node::ImplItem(&ImplItem {\n                 node: ImplItemKind::Method(_, eid),\n                 ..\n-            }) => match cx.tcx.hir.body(eid).value.node {\n+            }) => match cx.tcx.hir().body(eid).value.node {\n                 ExprKind::Block(ref block, _) => Some(block),\n                 _ => None,\n             },\n@@ -836,7 +838,7 @@ pub fn is_direct_expn_of(span: Span, name: &str) -> Option<Span> {\n \n /// Convenience function to get the return type of a function\n pub fn return_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, fn_item: NodeId) -> Ty<'tcx> {\n-    let fn_def_id = cx.tcx.hir.local_def_id(fn_item);\n+    let fn_def_id = cx.tcx.hir().local_def_id(fn_item);\n     let ret_ty = cx.tcx.fn_sig(fn_def_id).output();\n     cx.tcx.erase_late_bound_regions(&ret_ty)\n }\n@@ -1117,7 +1119,7 @@ pub fn without_block_comments(lines: Vec<&str>) -> Vec<&str> {\n }\n \n pub fn any_parent_is_automatically_derived(tcx: TyCtxt<'_, '_, '_>, node: NodeId) -> bool {\n-    let map = &tcx.hir;\n+    let map = &tcx.hir();\n     let mut prev_enclosing_node = None;\n     let mut enclosing_node = node;\n     while Some(enclosing_node) != prev_enclosing_node {"}, {"sha": "0779d77936f52f4dbd7cf8c164d54244fc54e036", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -27,8 +27,6 @@ pub const CMP_MAX: [&str; 3] = [\"core\", \"cmp\", \"max\"];\n pub const CMP_MIN: [&str; 3] = [\"core\", \"cmp\", \"min\"];\n pub const COW: [&str; 3] = [\"alloc\", \"borrow\", \"Cow\"];\n pub const CSTRING_NEW: [&str; 5] = [\"std\", \"ffi\", \"c_str\", \"CString\", \"new\"];\n-pub const C_VOID: [&str; 3] = [\"core\", \"ffi\", \"c_void\"];\n-pub const C_VOID_LIBC: [&str; 2] = [\"libc\", \"c_void\"];\n pub const DEFAULT_TRAIT: [&str; 3] = [\"core\", \"default\", \"Default\"];\n pub const DEFAULT_TRAIT_METHOD: [&str; 4] = [\"core\", \"default\", \"Default\", \"default\"];\n pub const DEREF_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"Deref\", \"deref\"];"}, {"sha": "854da37f4d22a9fa08f694fd966e1bfb1b4ec03f", "filename": "clippy_lints/src/utils/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Futils%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c77f6ad1c1c185e561e9cd7fdec7db569169d1/clippy_lints%2Fsrc%2Futils%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fptr.rs?ref=a3c77f6ad1c1c185e561e9cd7fdec7db569169d1", "patch": "@@ -21,7 +21,7 @@ pub fn get_spans(\n     idx: usize,\n     replacements: &'static [(&'static str, &'static str)],\n ) -> Option<Vec<(Span, Cow<'static, str>)>> {\n-    if let Some(body) = opt_body_id.map(|id| cx.tcx.hir.body(id)) {\n+    if let Some(body) = opt_body_id.map(|id| cx.tcx.hir().body(id)) {\n         get_binding_name(&body.arguments[idx]).map_or_else(\n             || Some(vec![]),\n             |name| extract_clone_suggestions(cx, name, replacements, body),"}]}