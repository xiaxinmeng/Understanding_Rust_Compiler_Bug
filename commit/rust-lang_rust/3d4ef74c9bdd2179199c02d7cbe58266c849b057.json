{"sha": "3d4ef74c9bdd2179199c02d7cbe58266c849b057", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkNGVmNzRjOWJkZDIxNzkxOTljMDJkN2NiZTU4MjY2Yzg0OWIwNTc=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-04-26T19:15:46Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-05-02T20:38:56Z"}, "message": "Encode the ifaces a class implements in metadata\n\nThis lets you use class A as if it had type B if A implements B,\nand A and B are in different crates from your own.\n\nCloses #2285", "tree": {"sha": "fd383163df55f42913b91a701b9c93acb89cdbb0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd383163df55f42913b91a701b9c93acb89cdbb0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d4ef74c9bdd2179199c02d7cbe58266c849b057", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d4ef74c9bdd2179199c02d7cbe58266c849b057", "html_url": "https://github.com/rust-lang/rust/commit/3d4ef74c9bdd2179199c02d7cbe58266c849b057", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d4ef74c9bdd2179199c02d7cbe58266c849b057/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d9f67003a4def3894096e7971cde49e638ac449", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d9f67003a4def3894096e7971cde49e638ac449", "html_url": "https://github.com/rust-lang/rust/commit/8d9f67003a4def3894096e7971cde49e638ac449"}], "stats": {"total": 229, "additions": 187, "deletions": 42}, "files": [{"sha": "54a05cc206de5717f6921dee66374ff82a0e4c3d", "filename": "src/rustc/metadata/common.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3d4ef74c9bdd2179199c02d7cbe58266c849b057/src%2Frustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d4ef74c9bdd2179199c02d7cbe58266c849b057/src%2Frustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcommon.rs?ref=3d4ef74c9bdd2179199c02d7cbe58266c849b057", "patch": "@@ -70,7 +70,7 @@ const tag_crate_dep_vers: uint = 0x2cu;\n \n const tag_mod_impl: uint = 0x30u;\n \n-const tag_item_method: uint = 0x31u;\n+const tag_item_iface_method: uint = 0x31u;\n const tag_impl_iface: uint = 0x32u;\n \n // discriminator value for variants\n@@ -85,6 +85,17 @@ const tag_item_field: uint = 0x44u;\n const tag_class_mut: uint = 0x45u;\n \n const tag_region_param: uint = 0x46u;\n+const tag_mod_impl_use: uint = 0x47u;\n+const tag_mod_impl_iface: uint = 0x48u;\n+/*\n+  iface items contain tag_item_iface_method elements,\n+  impl items contain tag_item_impl_method elements, and classes\n+  have both. That's because some code treats classes like ifaces,\n+  and other code treats them like impls. Because classes can contain\n+  both, tag_item_iface_method and tag_item_impl_method have to be two\n+  different tags.\n+ */\n+const tag_item_impl_method: uint = 0x49u;\n \n // used to encode crate_ctxt side tables\n enum astencode_tag { // Reserves 0x50 -- 0x6f"}, {"sha": "ef0bd8694829447f87bb5f89e4e6ad6e6294ecbc", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 31, "deletions": 12, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/3d4ef74c9bdd2179199c02d7cbe58266c849b057/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d4ef74c9bdd2179199c02d7cbe58266c849b057/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=3d4ef74c9bdd2179199c02d7cbe58266c849b057", "patch": "@@ -156,8 +156,7 @@ fn item_impl_iface(item: ebml::doc, tcx: ty::ctxt, cdata: cmd)\n     -> option<ty::t> {\n     let mut result = none;\n     ebml::tagged_docs(item, tag_impl_iface) {|ity|\n-        result = some(parse_ty_data(ity.data, cdata.cnum, ity.start, tcx,\n-                             {|did| translate_def_id(cdata, did)}));\n+        result = some(doc_type(ity, tcx, cdata));\n     };\n     result\n }\n@@ -304,7 +303,7 @@ fn get_impl_iface(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n fn get_impl_method(cdata: cmd, id: ast::node_id, name: str) -> ast::def_id {\n     let items = ebml::get_doc(ebml::doc(cdata.data), tag_items);\n     let mut found = none;\n-    ebml::tagged_docs(find_item(id, items), tag_item_method) {|mid|\n+    ebml::tagged_docs(find_item(id, items), tag_item_impl_method) {|mid|\n         let m_did = parse_def_id(ebml::doc_data(mid));\n         if item_name(find_item(m_did.node, items)) == name {\n             found = some(translate_def_id(cdata, m_did));\n@@ -320,7 +319,7 @@ fn get_class_method(cdata: cmd, id: ast::node_id, name: str) -> ast::def_id {\n             some(it) { it }\n             none { fail (#fmt(\"get_class_method: class id not found \\\n              when looking up method %s\", name)) }};\n-    ebml::tagged_docs(cls_items, tag_item_method) {|mid|\n+    ebml::tagged_docs(cls_items, tag_item_iface_method) {|mid|\n         let m_did = class_member_id(mid, cdata);\n         if item_name(mid) == name {\n             found = some(m_did);\n@@ -398,10 +397,12 @@ fn get_enum_variants(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n fn item_impl_methods(cdata: cmd, item: ebml::doc, base_tps: uint)\n     -> [@middle::resolve::method_info] {\n     let mut rslt = [];\n-    ebml::tagged_docs(item, tag_item_method) {|doc|\n+    ebml::tagged_docs(item, tag_item_impl_method) {|doc|\n         let m_did = parse_def_id(ebml::doc_data(doc));\n         let mth_item = lookup_item(m_did.node, cdata.data);\n         rslt += [@{did: translate_def_id(cdata, m_did),\n+                    /* FIXME tjc: take a look at this, it may relate\n+                     to #2323 */\n                    n_tps: item_ty_param_count(mth_item) - base_tps,\n                    ident: item_name(mth_item)}];\n     }\n@@ -416,21 +417,39 @@ fn get_impls_for_mod(cdata: cmd, m_id: ast::node_id,\n     let mod_item = lookup_item(m_id, data);\n     let mut result = [];\n     ebml::tagged_docs(mod_item, tag_mod_impl) {|doc|\n-        let did = parse_def_id(ebml::doc_data(doc));\n+        /*\n+          Pair of an item did and an iface did.\n+          The second one is unneeded if the first id names\n+          an impl; disambiguates if it's a class\n+        */\n+        let did = parse_def_id(ebml::doc_data(ebml::get_doc(doc,\n+                                                      tag_mod_impl_use)));\n         let local_did = translate_def_id(cdata, did);\n-        // The impl may be defined in a different crate. Ask the caller\n-        // to give us the metadata\n+        /*\n+        // iface is optional\n+        let iface_did = option::map(ebml::maybe_get_doc(doc,\n+                                           tag_mod_impl_iface)) {|d|\n+                                     parse_def_id(ebml::doc_data(d))};\n+        option::iter(iface_did) {|x|\n+                let _local_iface_did = translate_def_id(cdata, x);\n+        };\n+        */\n+        // CONFUSED -- previous code is pointless\n+          // The impl may be defined in a different crate. Ask the caller\n+          // to give us the metadata\n         let impl_cdata = get_cdata(local_did.crate);\n         let impl_data = impl_cdata.data;\n         let item = lookup_item(local_did.node, impl_data);\n         let nm = item_name(item);\n         if alt name { some(n) { n == nm } none { true } } {\n-            let base_tps = item_ty_param_count(item);\n-            result += [@{\n+           let base_tps = item_ty_param_count(item);\n+           result += [@{\n+                   // here, we need to... reconstruct the iface_ref?\n+                   // probz broken\n                 did: local_did, ident: nm,\n                 methods: item_impl_methods(impl_cdata, item, base_tps)\n             }];\n-        }\n+        };\n     }\n     @result\n }\n@@ -441,7 +460,7 @@ fn get_iface_methods(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n     let data = cdata.data;\n     let item = lookup_item(id, data);\n     let mut result = [];\n-    ebml::tagged_docs(item, tag_item_method) {|mth|\n+    ebml::tagged_docs(item, tag_item_iface_method) {|mth|\n         let bounds = item_ty_param_bounds(mth, tcx, cdata);\n         let name = item_name(mth);\n         let ty = doc_type(mth, tcx, cdata);"}, {"sha": "9fd63ecf2fd73956437ba836bb67174878449728", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 71, "deletions": 20, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/3d4ef74c9bdd2179199c02d7cbe58266c849b057/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d4ef74c9bdd2179199c02d7cbe58266c849b057/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=3d4ef74c9bdd2179199c02d7cbe58266c849b057", "patch": "@@ -1,5 +1,7 @@\n // Metadata encoding\n \n+import util::ppaux::ty_to_str;\n+\n import std::{ebml, map, list};\n import std::map::hashmap;\n import io::writer_util;\n@@ -197,6 +199,12 @@ fn encode_module_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt,\n     }\n }\n \n+fn encode_iface_ref(ebml_w: ebml::writer, ecx: @encode_ctxt, t: @iface_ref) {\n+    ebml_w.start_tag(tag_impl_iface);\n+    encode_type(ecx, ebml_w, node_id_to_type(ecx.ccx.tcx, t.id));\n+    ebml_w.end_tag();\n+}\n+\n fn encode_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt, crate: @crate)\n     -> [entry<str>] {\n     let mut index: [entry<str>] = [];\n@@ -361,12 +369,52 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml::writer, md: _mod,\n       list::cons(impls, @list::nil) {\n         for vec::each(*impls) {|i|\n             if ast_util::is_exported(i.ident, md) {\n-                ebml_w.wr_tagged_str(tag_mod_impl, def_to_str(i.did));\n-            }\n-        }\n+                ebml_w.start_tag(tag_mod_impl);\n+            /* If did stands for an iface\n+               ref, we need to map it to its parent class */\n+                ebml_w.start_tag(tag_mod_impl_use);\n+                let iface_ty = alt ecx.ccx.tcx.items.get(i.did.node) {\n+                  ast_map::node_item(it@@{node: cl@item_class(*),_},_) {\n+                    ebml_w.wr_str(def_to_str(local_def(it.id)));\n+                    some(ty::lookup_item_type(ecx.ccx.tcx, i.did).ty)\n+                  }\n+                  ast_map::node_item(@{node: item_impl(_,_,\n+                                           some(ifce),_,_),_},_) {\n+                    ebml_w.wr_str(def_to_str(i.did));\n+                    some(ty::node_id_to_type(ecx.ccx.tcx, ifce.id))\n+                  }\n+                  _ {\n+                      ebml_w.wr_str(def_to_str(i.did)); none\n+                  }\n+                };\n+                ebml_w.end_tag();\n+\n+                /*\n+                /* Write the iface did if it exists */\n+                option::iter(iface_ty) {|i|\n+                alt ty::get(i).struct {\n+                  ty::ty_iface(did, tys) {\n+                    // FIXME: tys?\n+                      ebml_w.start_tag(tag_mod_impl_iface);\n+                     ebml_w.wr_str(def_to_str(did));\n+                     ebml_w.end_tag();\n+\n+                  }\n+                  t {\n+                      ecx.ccx.tcx.sess.bug(#fmt(\"Expected item to implement \\\n+                       an iface, but found %s\",\n+                       util::ppaux::ty_to_str(ecx.ccx.tcx, i)));\n+                  }\n+                }}\n+                */\n+                ebml_w.end_tag();\n+            } // if\n+            } // for\n+      } // list::cons alt\n+      _ {\n+          ecx.ccx.tcx.sess.bug(#fmt(\"encode_info_for_mod: empty impl_map \\\n+            entry for %?\", path));\n       }\n-      _ { ecx.ccx.tcx.sess.bug(#fmt(\"encode_info_for_mod: empty impl_map \\\n-            entry for %?\", path)); }\n     }\n     encode_path(ebml_w, path, ast_map::path_mod(name));\n     ebml_w.end_tag();\n@@ -571,7 +619,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_enum_variant_info(ecx, ebml_w, item.id, variants,\n                                  path, index, tps);\n       }\n-      item_class(tps, _ifaces, items, ctor, rp) {\n+      item_class(tps, ifaces, items, ctor, rp) {\n         /* First, encode the fields and methods\n            These come first because we need to write them to make\n            the index, and the index needs to be in the item for the\n@@ -589,7 +637,9 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_name(ebml_w, item.ident);\n         encode_path(ebml_w, path, ast_map::path_name(item.ident));\n         encode_region_param(ebml_w, rp);\n-        /* FIXME: encode ifaces */\n+        for ifaces.each {|t|\n+           encode_iface_ref(ebml_w, ecx, t);\n+        }\n         /* Encode def_ids for each field and method\n          for methods, write all the stuff get_iface_method\n         needs to know*/\n@@ -605,14 +655,21 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n            alt m.privacy {\n               priv { /* do nothing */ }\n               pub {\n-                ebml_w.start_tag(tag_item_method);\n-                #debug(\"Writing %s %d\", m.ident, m.id);\n+                /* Write the info that's needed when viewing this class\n+                   as an iface */\n+                ebml_w.start_tag(tag_item_iface_method);\n                 encode_family(ebml_w, purity_fn_family(m.decl.purity));\n                 encode_name(ebml_w, m.ident);\n                 encode_type_param_bounds(ebml_w, ecx, tps + m.tps);\n                 encode_type(ecx, ebml_w, node_id_to_type(tcx, m.id));\n                 encode_def_id(ebml_w, local_def(m.id));\n                 ebml_w.end_tag();\n+                /* Write the info that's needed when viewing this class\n+                   as an impl (just the method def_id) */\n+                ebml_w.start_tag(tag_item_impl_method);\n+                ebml_w.writer.write(str::bytes(def_to_str(local_def(m.id))));\n+                ebml_w.end_tag();\n+\n               }\n            }\n         }\n@@ -659,19 +716,13 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ebml_w, item.ident);\n         for methods.each {|m|\n-            ebml_w.start_tag(tag_item_method);\n+            ebml_w.start_tag(tag_item_impl_method);\n             ebml_w.writer.write(str::bytes(def_to_str(local_def(m.id))));\n             ebml_w.end_tag();\n         }\n-        alt ifce {\n-          some(t) {\n-            let i_ty = ty::node_id_to_type(tcx, t.id);\n-            ebml_w.start_tag(tag_impl_iface);\n-            write_type(ecx, ebml_w, i_ty);\n-            ebml_w.end_tag();\n-          }\n-          _ {}\n-        }\n+        option::iter(ifce) {|t|\n+           encode_iface_ref(ebml_w, ecx, t)\n+        };\n         encode_path(ebml_w, path, ast_map::path_name(item.ident));\n         ebml_w.end_tag();\n \n@@ -693,7 +744,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_name(ebml_w, item.ident);\n         let mut i = 0u;\n         for vec::each(*ty::iface_methods(tcx, local_def(item.id))) {|mty|\n-            ebml_w.start_tag(tag_item_method);\n+            ebml_w.start_tag(tag_item_iface_method);\n             encode_name(ebml_w, mty.ident);\n             encode_type_param_bounds(ebml_w, ecx, ms[i].tps);\n             encode_type(ecx, ebml_w, ty::mk_fn(tcx, mty.fty));"}, {"sha": "7f627e3903962bf99375aeb4b2ed5f9062ab8cb2", "filename": "src/rustc/metadata/tydecode.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3d4ef74c9bdd2179199c02d7cbe58266c849b057/src%2Frustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d4ef74c9bdd2179199c02d7cbe58266c849b057/src%2Frustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftydecode.rs?ref=3d4ef74c9bdd2179199c02d7cbe58266c849b057", "patch": "@@ -481,15 +481,13 @@ fn parse_def_id(buf: [u8]) -> ast::def_id {\n \n     let crate_num = alt uint::parse_buf(crate_part, 10u) {\n        some(cn) { cn as int }\n-       none { fail (#fmt(\"internal error: parse_def_id: error parsing %? \\\n-                         as crate\",\n-                         crate_part)); }\n+       none { fail (#fmt(\"internal error: parse_def_id: crate number \\\n+         expected, but found %?\", crate_part)); }\n     };\n     let def_num = alt uint::parse_buf(def_part, 10u) {\n        some(dn) { dn as int }\n-       none { fail (#fmt(\"internal error: parse_def_id: error parsing %? \\\n-                         as id\",\n-                         def_part)); }\n+       none { fail (#fmt(\"internal error: parse_def_id: id expected, but \\\n+         found %?\", def_part)); }\n     };\n     ret {crate: crate_num, node: def_num};\n }"}, {"sha": "cd0696c4104b1016c1505d550020f76b8efefce6", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3d4ef74c9bdd2179199c02d7cbe58266c849b057/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d4ef74c9bdd2179199c02d7cbe58266c849b057/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=3d4ef74c9bdd2179199c02d7cbe58266c849b057", "patch": "@@ -2115,8 +2115,14 @@ fn check_exports(e: @env) {\n // Impl resolution\n \n type method_info = {did: def_id, n_tps: uint, ident: ast::ident};\n-/* what are the did and ident here? */\n-/* ident = the name of the impl */\n+/* An _impl represents an implementation that's currently in scope.\n+   Its fields:\n+   * did: the def id of the class or impl item\n+   * ident: the name of the impl, unless it has no name (as in\n+   \"impl of X\") in which case the ident\n+   is the ident of the iface that's being implemented\n+   * methods: the item's methods\n+*/\n type _impl = {did: def_id, ident: ast::ident, methods: [@method_info]};\n type iscopes = list<@[@_impl]>;\n "}, {"sha": "944d04ee4028015157ff46cafaf0d7f8a5e051e2", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d4ef74c9bdd2179199c02d7cbe58266c849b057/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d4ef74c9bdd2179199c02d7cbe58266c849b057/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=3d4ef74c9bdd2179199c02d7cbe58266c849b057", "patch": "@@ -4686,8 +4686,10 @@ mod vtable {\n             let mut found = [];\n \n             for list::each(isc) {|impls|\n+            /* For each impl in scope... */\n                 for vec::each(*impls) {|im|\n-                    // find the iface that the impl is an impl of (if any)\n+                    // im = one specific impl\n+                    // find the iface that im implements (if any)\n                     let of_ty = alt ty::impl_iface(tcx, im.did) {\n                       some(of_ty) { of_ty }\n                       _ { cont; }"}, {"sha": "997cab281553fbcce3eaa4dd61957389d73a2a7b", "filename": "src/test/auxiliary/cci_class_cast.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3d4ef74c9bdd2179199c02d7cbe58266c849b057/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d4ef74c9bdd2179199c02d7cbe58266c849b057/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs?ref=3d4ef74c9bdd2179199c02d7cbe58266c849b057", "patch": "@@ -0,0 +1,40 @@\n+import to_str::*;\n+import to_str::to_str;\n+\n+mod kitty {\n+\n+class cat implements to_str {\n+  priv {\n+    let mut meows : uint;\n+    fn meow() {\n+      #error(\"Meow\");\n+      self.meows += 1u;\n+      if self.meows % 5u == 0u {\n+          self.how_hungry += 1;\n+      }\n+    }\n+  }\n+\n+  let mut how_hungry : int;\n+  let name : str;\n+\n+  new(in_x : uint, in_y : int, in_name: str)\n+    { self.meows = in_x; self.how_hungry = in_y; self.name = in_name; }\n+\n+  fn speak() { self.meow(); }\n+\n+  fn eat() -> bool {\n+    if self.how_hungry > 0 {\n+        #error(\"OM NOM NOM\");\n+        self.how_hungry -= 2;\n+        ret true;\n+    }\n+    else {\n+        #error(\"Not hungry!\");\n+        ret false;\n+    }\n+  }\n+\n+  fn to_str() -> str { self.name }\n+}\n+}"}, {"sha": "733af04f175c7ccacc58cbaa09c7d9c6e15189c6", "filename": "src/test/run-pass/class-cast-to-iface-cross-crate-2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3d4ef74c9bdd2179199c02d7cbe58266c849b057/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface-cross-crate-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d4ef74c9bdd2179199c02d7cbe58266c849b057/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface-cross-crate-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface-cross-crate-2.rs?ref=3d4ef74c9bdd2179199c02d7cbe58266c849b057", "patch": "@@ -0,0 +1,18 @@\n+// xfail-fast\n+// aux-build:cci_class_cast.rs\n+use cci_class_cast;\n+import cci_class_cast::kitty::*;\n+import to_str::*;\n+import to_str::to_str;\n+\n+fn print_out<T: to_str>(thing: T, expected: str) {\n+  let actual = thing.to_str();\n+  #debug(\"%s\", actual);\n+  assert(actual == expected);\n+}\n+\n+fn main() {\n+  let nyan : to_str  = cat(0u, 2, \"nyan\") as to_str;\n+  print_out(nyan, \"nyan\");\n+}\n+"}]}