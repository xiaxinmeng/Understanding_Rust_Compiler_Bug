{"sha": "0f5dcc665da4da6af0532bf1ca5e96ac4c9f6286", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmNWRjYzY2NWRhNGRhNmFmMDUzMmJmMWNhNWU5NmFjNGM5ZjYyODY=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-12-01T04:30:04Z"}, "committer": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2017-12-03T02:34:18Z"}, "message": "Handle special-case macros", "tree": {"sha": "385a1a5b521e2464d390cc2665c20475ff58f27c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/385a1a5b521e2464d390cc2665c20475ff58f27c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f5dcc665da4da6af0532bf1ca5e96ac4c9f6286", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f5dcc665da4da6af0532bf1ca5e96ac4c9f6286", "html_url": "https://github.com/rust-lang/rust/commit/0f5dcc665da4da6af0532bf1ca5e96ac4c9f6286", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f5dcc665da4da6af0532bf1ca5e96ac4c9f6286/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ffbe52eb7638f6647d09564d44314b9bf8d76836", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffbe52eb7638f6647d09564d44314b9bf8d76836", "html_url": "https://github.com/rust-lang/rust/commit/ffbe52eb7638f6647d09564d44314b9bf8d76836"}], "stats": {"total": 123, "additions": 108, "deletions": 15}, "files": [{"sha": "70363f7dd23115be4f6a1ed1a1f5d5b04fab6fa0", "filename": "src/expr.rs", "status": "modified", "additions": 81, "deletions": 14, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/0f5dcc665da4da6af0532bf1ca5e96ac4c9f6286/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f5dcc665da4da6af0532bf1ca5e96ac4c9f6286/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=0f5dcc665da4da6af0532bf1ca5e96ac4c9f6286", "patch": "@@ -1862,9 +1862,6 @@ where\n     };\n     let used_width = extra_offset(callee_str, shape);\n     let one_line_width = shape.width.checked_sub(used_width + 2 * paren_overhead)?;\n-    // 1 = \"(\"\n-    let combine_arg_with_callee =\n-        callee_str.len() + 1 <= context.config.tab_spaces() && args.len() == 1;\n \n     // 1 = \"(\" or \")\"\n     let one_line_shape = shape\n@@ -1889,7 +1886,7 @@ where\n         one_line_width,\n         args_max_width,\n         force_trailing_comma,\n-        combine_arg_with_callee,\n+        callee_str,\n     )?;\n \n     if !context.use_block_indent() && need_block_indent(&list_str, nested_shape) && !extendable {\n@@ -1930,7 +1927,7 @@ fn rewrite_call_args<'a, T>(\n     one_line_width: usize,\n     args_max_width: usize,\n     force_trailing_comma: bool,\n-    combine_arg_with_callee: bool,\n+    callee_str: &str,\n ) -> Option<(bool, String)>\n where\n     T: Rewrite + Spanned + ToExpr + 'a,\n@@ -1960,7 +1957,7 @@ where\n         nested_shape,\n         one_line_width,\n         args_max_width,\n-        combine_arg_with_callee,\n+        callee_str,\n     );\n \n     let fmt = ListFormatting {\n@@ -1980,7 +1977,8 @@ where\n         config: context.config,\n     };\n \n-    write_list(&item_vec, &fmt).map(|args_str| (tactic != DefinitiveListTactic::Vertical, args_str))\n+    write_list(&item_vec, &fmt)\n+        .map(|args_str| (tactic == DefinitiveListTactic::Horizontal, args_str))\n }\n \n fn try_overflow_last_arg<'a, T>(\n@@ -1991,11 +1989,14 @@ fn try_overflow_last_arg<'a, T>(\n     nested_shape: Shape,\n     one_line_width: usize,\n     args_max_width: usize,\n-    combine_arg_with_callee: bool,\n+    callee_str: &str,\n ) -> DefinitiveListTactic\n where\n     T: Rewrite + Spanned + ToExpr + 'a,\n {\n+    // 1 = \"(\"\n+    let combine_arg_with_callee =\n+        callee_str.len() + 1 <= context.config.tab_spaces() && args.len() == 1;\n     let overflow_last = combine_arg_with_callee || can_be_overflowed(context, args);\n \n     // Replace the last item with its first line to see if it fits with\n@@ -2032,6 +2033,16 @@ where\n         _ if args.len() >= 1 => {\n             item_vec[args.len() - 1].item = args.last()\n                 .and_then(|last_arg| last_arg.rewrite(context, nested_shape));\n+\n+            let default_tactic = || {\n+                definitive_tactic(\n+                    &*item_vec,\n+                    ListTactic::LimitedHorizontalVertical(args_max_width),\n+                    Separator::Comma,\n+                    one_line_width,\n+                )\n+            };\n+\n             // Use horizontal layout for a function with a single argument as long as\n             // everything fits in a single line.\n             if args.len() == 1\n@@ -2042,12 +2053,44 @@ where\n             {\n                 tactic = DefinitiveListTactic::Horizontal;\n             } else {\n-                tactic = definitive_tactic(\n-                    &*item_vec,\n-                    ListTactic::LimitedHorizontalVertical(args_max_width),\n-                    Separator::Comma,\n-                    one_line_width,\n-                );\n+                tactic = default_tactic();\n+                let is_simple_enough =\n+                    tactic == DefinitiveListTactic::Vertical && is_every_args_simple(args);\n+                if is_simple_enough\n+                    && FORMAT_LIKE_WHITELIST\n+                        .iter()\n+                        .find(|s| **s == callee_str)\n+                        .is_some()\n+                {\n+                    let args_tactic = definitive_tactic(\n+                        &item_vec[1..],\n+                        ListTactic::HorizontalVertical,\n+                        Separator::Comma,\n+                        nested_shape.width,\n+                    );\n+                    tactic = if args_tactic == DefinitiveListTactic::Horizontal {\n+                        DefinitiveListTactic::FormatCall\n+                    } else {\n+                        default_tactic()\n+                    };\n+                } else if is_simple_enough && item_vec.len() >= 2\n+                    && WRITE_LIKE_WHITELIST\n+                        .iter()\n+                        .find(|s| **s == callee_str)\n+                        .is_some()\n+                {\n+                    let args_tactic = definitive_tactic(\n+                        &item_vec[2..],\n+                        ListTactic::HorizontalVertical,\n+                        Separator::Comma,\n+                        nested_shape.width,\n+                    );\n+                    tactic = if args_tactic == DefinitiveListTactic::Horizontal {\n+                        DefinitiveListTactic::WriteCall\n+                    } else {\n+                        default_tactic()\n+                    };\n+                }\n             }\n         }\n         _ => (),\n@@ -2056,6 +2099,30 @@ where\n     tactic\n }\n \n+fn is_simple_arg(expr: &ast::Expr) -> bool {\n+    match expr.node {\n+        ast::ExprKind::Lit(..) => true,\n+        ast::ExprKind::Path(ref qself, ref path) => qself.is_none() && path.segments.len() <= 1,\n+        ast::ExprKind::AddrOf(_, ref expr)\n+        | ast::ExprKind::Box(ref expr)\n+        | ast::ExprKind::Cast(ref expr, _)\n+        | ast::ExprKind::Field(ref expr, _)\n+        | ast::ExprKind::Try(ref expr)\n+        | ast::ExprKind::TupField(ref expr, _)\n+        | ast::ExprKind::Unary(_, ref expr) => is_simple_arg(expr),\n+        ast::ExprKind::Index(ref lhs, ref rhs) | ast::ExprKind::Repeat(ref lhs, ref rhs) => {\n+            is_simple_arg(lhs) && is_simple_arg(rhs)\n+        }\n+        _ => false,\n+    }\n+}\n+\n+fn is_every_args_simple<T: ToExpr>(lists: &[&T]) -> bool {\n+    lists\n+        .iter()\n+        .all(|arg| arg.to_expr().map_or(false, is_simple_arg))\n+}\n+\n /// Returns a shape for the last argument which is going to be overflowed.\n fn last_arg_shape<T>(\n     lists: &[&T],"}, {"sha": "a51653b3732ae37a7404d5c028d7863a0bc33e30", "filename": "src/lists.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0f5dcc665da4da6af0532bf1ca5e96ac4c9f6286/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f5dcc665da4da6af0532bf1ca5e96ac4c9f6286/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=0f5dcc665da4da6af0532bf1ca5e96ac4c9f6286", "patch": "@@ -160,6 +160,10 @@ pub enum DefinitiveListTactic {\n     Vertical,\n     Horizontal,\n     Mixed,\n+    // Special case tactic for `format!()` variants.\n+    FormatCall,\n+    // Special case tactic for `write!()` varianta.\n+    WriteCall,\n }\n \n impl DefinitiveListTactic {\n@@ -267,7 +271,7 @@ where\n     I: IntoIterator<Item = T> + Clone,\n     T: AsRef<ListItem>,\n {\n-    let tactic = formatting.tactic;\n+    let mut tactic = formatting.tactic;\n     let sep_len = formatting.separator.len();\n \n     // Now that we know how we will layout, we can decide for sure if there\n@@ -309,6 +313,28 @@ where\n             DefinitiveListTactic::Horizontal if !first => {\n                 result.push(' ');\n             }\n+            DefinitiveListTactic::FormatCall if !first => {\n+                result.push('\\n');\n+                result.push_str(indent_str);\n+                tactic = DefinitiveListTactic::Horizontal;\n+            }\n+            DefinitiveListTactic::WriteCall => {\n+                let second = i == 1;\n+                let third = i == 2;\n+\n+                if first {\n+                    // Nothing\n+                } else if second {\n+                    result.push('\\n');\n+                    result.push_str(indent_str);\n+                } else if third {\n+                    result.push('\\n');\n+                    result.push_str(indent_str);\n+                    tactic = DefinitiveListTactic::Horizontal;\n+                } else {\n+                    unreachable!();\n+                }\n+            }\n             DefinitiveListTactic::Vertical if !first => {\n                 result.push('\\n');\n                 result.push_str(indent_str);"}]}