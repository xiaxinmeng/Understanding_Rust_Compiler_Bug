{"sha": "d059b57c7878f2503b11727fb7e8bb919de542c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwNTliNTdjNzg3OGYyNTAzYjExNzI3ZmI3ZThiYjkxOWRlNTQyYzQ=", "commit": {"author": {"name": "Ramana Venkata", "email": "vramana@users.noreply.github.com", "date": "2017-11-18T22:32:05Z"}, "committer": {"name": "Ramana Venkata", "email": "vramana@users.noreply.github.com", "date": "2017-11-23T13:57:13Z"}, "message": "Fix borrowck compiler errors for upvars contain \"spurious\" dereferences\n\nFixes #46003", "tree": {"sha": "149a052eee924912698892014398e51f4a27872d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/149a052eee924912698892014398e51f4a27872d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d059b57c7878f2503b11727fb7e8bb919de542c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d059b57c7878f2503b11727fb7e8bb919de542c4", "html_url": "https://github.com/rust-lang/rust/commit/d059b57c7878f2503b11727fb7e8bb919de542c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d059b57c7878f2503b11727fb7e8bb919de542c4/comments", "author": {"login": "vramana", "id": 3112509, "node_id": "MDQ6VXNlcjMxMTI1MDk=", "avatar_url": "https://avatars.githubusercontent.com/u/3112509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vramana", "html_url": "https://github.com/vramana", "followers_url": "https://api.github.com/users/vramana/followers", "following_url": "https://api.github.com/users/vramana/following{/other_user}", "gists_url": "https://api.github.com/users/vramana/gists{/gist_id}", "starred_url": "https://api.github.com/users/vramana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vramana/subscriptions", "organizations_url": "https://api.github.com/users/vramana/orgs", "repos_url": "https://api.github.com/users/vramana/repos", "events_url": "https://api.github.com/users/vramana/events{/privacy}", "received_events_url": "https://api.github.com/users/vramana/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vramana", "id": 3112509, "node_id": "MDQ6VXNlcjMxMTI1MDk=", "avatar_url": "https://avatars.githubusercontent.com/u/3112509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vramana", "html_url": "https://github.com/vramana", "followers_url": "https://api.github.com/users/vramana/followers", "following_url": "https://api.github.com/users/vramana/following{/other_user}", "gists_url": "https://api.github.com/users/vramana/gists{/gist_id}", "starred_url": "https://api.github.com/users/vramana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vramana/subscriptions", "organizations_url": "https://api.github.com/users/vramana/orgs", "repos_url": "https://api.github.com/users/vramana/repos", "events_url": "https://api.github.com/users/vramana/events{/privacy}", "received_events_url": "https://api.github.com/users/vramana/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "247d98ec371210446934c57b419b3b5d23772d02", "url": "https://api.github.com/repos/rust-lang/rust/commits/247d98ec371210446934c57b419b3b5d23772d02", "html_url": "https://github.com/rust-lang/rust/commit/247d98ec371210446934c57b419b3b5d23772d02"}], "stats": {"total": 72, "additions": 59, "deletions": 13}, "files": [{"sha": "ddaade98be108d9157aec9338c38893fee89ab80", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 46, "deletions": 11, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/d059b57c7878f2503b11727fb7e8bb919de542c4/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d059b57c7878f2503b11727fb7e8bb919de542c4/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=d059b57c7878f2503b11727fb7e8bb919de542c4", "patch": "@@ -15,9 +15,9 @@ use rustc::hir::def_id::{DefId};\n use rustc::infer::{InferCtxt};\n use rustc::ty::{self, TyCtxt, ParamEnv};\n use rustc::ty::maps::Providers;\n-use rustc::mir::{AssertMessage, BasicBlock, BorrowKind, Field, Location, Lvalue, Local};\n+use rustc::mir::{AssertMessage, BasicBlock, BorrowKind, Location, Lvalue, Local};\n use rustc::mir::{Mir, Mutability, Operand, Projection, ProjectionElem, Rvalue};\n-use rustc::mir::{Statement, StatementKind, Terminator, TerminatorKind};\n+use rustc::mir::{Field, Statement, StatementKind, Terminator, TerminatorKind};\n use transform::nll;\n \n use rustc_data_structures::fx::FxHashSet;\n@@ -1581,6 +1581,31 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         buf\n     }\n \n+    /// If this is a field projection, and the field is being projected from a closure type,\n+    /// then returns the index of the field being projected. Note that this closure will always\n+    /// be `self` in the current MIR, because that is the only time we directly access the fields\n+    /// of a closure type.\n+    fn is_upvar_field_projection(&self, lvalue: &Lvalue<'tcx>) -> Option<Field> {\n+        match *lvalue {\n+            Lvalue::Projection(ref proj) => {\n+                match proj.elem {\n+                    ProjectionElem::Field(field, _ty) => {\n+                        let is_projection_from_ty_closure = proj.base.ty(self.mir, self.tcx)\n+                                .to_ty(self.tcx).is_closure();\n+\n+                        if is_projection_from_ty_closure {\n+                            Some(field)\n+                        } else {\n+                            None\n+                        }\n+                    },\n+                    _ => None\n+                }\n+            },\n+            _ => None\n+        }\n+    }\n+\n     // Appends end-user visible description of `lvalue` to `buf`.\n     fn append_lvalue_to_string(&self,\n                                lvalue: &Lvalue<'tcx>,\n@@ -1596,25 +1621,35 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Lvalue::Projection(ref proj) => {\n                 match proj.elem {\n                     ProjectionElem::Deref => {\n-                        if autoderef {\n-                            self.append_lvalue_to_string(&proj.base, buf, autoderef);\n+                        if let Some(field) = self.is_upvar_field_projection(&proj.base) {\n+                            let var_index = field.index();\n+                            let name = self.mir.upvar_decls[var_index].debug_name.to_string();\n+                            if self.mir.upvar_decls[var_index].by_ref {\n+                                buf.push_str(&name);\n+                            } else {\n+                                buf.push_str(&format!(\"*{}\", &name));\n+                            }\n                         } else {\n-                            buf.push_str(&\"*\");\n-                            self.append_lvalue_to_string(&proj.base, buf, autoderef);\n+                            if autoderef {\n+                                self.append_lvalue_to_string(&proj.base, buf, autoderef);\n+                            } else {\n+                                buf.push_str(&\"*\");\n+                                self.append_lvalue_to_string(&proj.base, buf, autoderef);\n+                            }\n                         }\n                     },\n                     ProjectionElem::Downcast(..) => {\n                         self.append_lvalue_to_string(&proj.base, buf, autoderef);\n                     },\n                     ProjectionElem::Field(field, _ty) => {\n                         autoderef = true;\n-                        let is_projection_from_ty_closure = proj.base.ty(self.mir, self.tcx)\n-                                .to_ty(self.tcx).is_closure();\n \n-                        let field_name = self.describe_field(&proj.base, field);\n-                        if is_projection_from_ty_closure {\n-                            buf.push_str(&format!(\"{}\", field_name));\n+                        if let Some(field) = self.is_upvar_field_projection(lvalue) {\n+                            let var_index = field.index();\n+                            let name = self.mir.upvar_decls[var_index].debug_name.to_string();\n+                            buf.push_str(&name);\n                         } else {\n+                            let field_name = self.describe_field(&proj.base, field);\n                             self.append_lvalue_to_string(&proj.base, buf, autoderef);\n                             buf.push_str(&format!(\".{}\", field_name));\n                         }"}, {"sha": "32052fff90ddf72d0312b4a1df047f9466f36866", "filename": "src/test/compile-fail/borrowck/borrowck-describe-lvalue.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d059b57c7878f2503b11727fb7e8bb919de542c4/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-describe-lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d059b57c7878f2503b11727fb7e8bb919de542c4/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-describe-lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-describe-lvalue.rs?ref=d059b57c7878f2503b11727fb7e8bb919de542c4", "patch": "@@ -300,7 +300,7 @@ fn main() {\n             let y = &mut x;\n             &mut x; //[ast]~ ERROR cannot borrow `**x` as mutable more than once at a time\n                     //[mir]~^ ERROR cannot borrow `**x` as mutable more than once at a time (Ast)\n-                    //[mir]~| ERROR cannot borrow `*x` as mutable more than once at a time (Mir)\n+                    //[mir]~| ERROR cannot borrow `x` as mutable more than once at a time (Mir)\n             *y = 1;\n         };\n     }\n@@ -312,9 +312,20 @@ fn main() {\n                 let y = &mut x;\n                 &mut x; //[ast]~ ERROR cannot borrow `**x` as mutable more than once at a time\n                         //[mir]~^ ERROR cannot borrow `**x` as mutable more than once at a time (Ast)\n-                        //[mir]~| ERROR cannot borrow `*x` as mutable more than once at a time (Mir)\n+                        //[mir]~| ERROR cannot borrow `x` as mutable more than once at a time (Mir)\n                 *y = 1;\n                 }\n            };\n     }\n+    {\n+        fn foo(x: Vec<i32>) {\n+            let c = || {\n+                drop(x);\n+                drop(x); //[ast]~ ERROR use of moved value: `x`\n+                         //[mir]~^ ERROR use of moved value: `x` (Ast)\n+                         //[mir]~| ERROR use of moved value: `x` (Mir)\n+            };\n+            c();\n+        }\n+    }\n }"}]}