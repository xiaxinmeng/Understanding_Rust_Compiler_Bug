{"sha": "30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwZGJiZTE3YzkxODlmZWQzMmQwZjVmMzMyYjRmNmZmOGY3Y2M0YWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-09T01:36:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-09T01:36:57Z"}, "message": "auto merge of #5787 : alexcrichton/rust/less-mut-fields, r=catamorphism\n\nThis removes some of the easier instances of mutable fields where the explicit self can just become `&mut self` along with removing some unsafe blocks which aren't necessary any more now that purity is gone.\r\n\r\nMost of #4568 is done, except for [one case](https://github.com/alexcrichton/rust/blob/less-mut-fields/src/libcore/vec.rs#L1754) where it looks like it has to do with it being a `const` vector. Removing the unsafe block yields:\r\n\r\n```\r\n/Users/alex/code/rust2/src/libcore/vec.rs:1755:12: 1755:16 error: illegal borrow unless pure: creating immutable alias to const vec content\r\n/Users/alex/code/rust2/src/libcore/vec.rs:1755         for self.each |e| {\r\n                                                           ^~~~\r\n/Users/alex/code/rust2/src/libcore/vec.rs:1757:8: 1757:9 note: impure due to access to impure function\r\n/Users/alex/code/rust2/src/libcore/vec.rs:1757         }\r\n                                                       ^\r\nerror: aborting due to previous error\r\n```\r\n\r\nI also didn't delve too much into removing mutable fields with `Cell` or `transmute` and friends.", "tree": {"sha": "3a13a4df0a798bdb55dc87e23188f8a975bd4691", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a13a4df0a798bdb55dc87e23188f8a975bd4691"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa", "html_url": "https://github.com/rust-lang/rust/commit/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22f65e9852e71645ab6552106225857bced327a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/22f65e9852e71645ab6552106225857bced327a2", "html_url": "https://github.com/rust-lang/rust/commit/22f65e9852e71645ab6552106225857bced327a2"}, {"sha": "255193cc1af5e07753906ad18bae077b45b5c3f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/255193cc1af5e07753906ad18bae077b45b5c3f0", "html_url": "https://github.com/rust-lang/rust/commit/255193cc1af5e07753906ad18bae077b45b5c3f0"}], "stats": {"total": 1045, "additions": 470, "deletions": 575}, "files": [{"sha": "6ca33540ceef61417c01b17f39e5fb3409a4e6a4", "filename": "src/libcore/char.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa", "patch": "@@ -202,12 +202,10 @@ pub fn escape_unicode(c: char) -> ~str {\n                     else { ('U', 8u) });\n     assert!(str::len(s) <= pad);\n     let mut out = ~\"\\\\\";\n-    unsafe {\n-        str::push_str(&mut out, str::from_char(c));\n-        for uint::range(str::len(s), pad) |_i|\n-            { str::push_str(&mut out, ~\"0\"); }\n-        str::push_str(&mut out, s);\n-    }\n+    str::push_str(&mut out, str::from_char(c));\n+    for uint::range(str::len(s), pad) |_i|\n+        { str::push_str(&mut out, ~\"0\"); }\n+    str::push_str(&mut out, s);\n     out\n }\n "}, {"sha": "c229bc17311c9005984ba8b85e1ecb3eb848fbb6", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 26, "deletions": 36, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa", "patch": "@@ -76,51 +76,43 @@ pub trait Streaming {\n impl<A:IterBytes> Hash for A {\n     #[inline(always)]\n     fn hash_keyed(&self, k0: u64, k1: u64) -> u64 {\n-        unsafe {\n-            let s = &State(k0, k1);\n-            for self.iter_bytes(true) |bytes| {\n-                s.input(bytes);\n-            }\n-            s.result_u64()\n+        let s = &State(k0, k1);\n+        for self.iter_bytes(true) |bytes| {\n+            s.input(bytes);\n         }\n+        s.result_u64()\n     }\n }\n \n fn hash_keyed_2<A: IterBytes,\n                 B: IterBytes>(a: &A, b: &B, k0: u64, k1: u64) -> u64 {\n-    unsafe {\n-        let s = &State(k0, k1);\n-        for a.iter_bytes(true) |bytes| { s.input(bytes); }\n-        for b.iter_bytes(true) |bytes| { s.input(bytes); }\n-        s.result_u64()\n-    }\n+    let s = &State(k0, k1);\n+    for a.iter_bytes(true) |bytes| { s.input(bytes); }\n+    for b.iter_bytes(true) |bytes| { s.input(bytes); }\n+    s.result_u64()\n }\n \n fn hash_keyed_3<A: IterBytes,\n                 B: IterBytes,\n                 C: IterBytes>(a: &A, b: &B, c: &C, k0: u64, k1: u64) -> u64 {\n-    unsafe {\n-        let s = &State(k0, k1);\n-        for a.iter_bytes(true) |bytes| { s.input(bytes); }\n-        for b.iter_bytes(true) |bytes| { s.input(bytes); }\n-        for c.iter_bytes(true) |bytes| { s.input(bytes); }\n-        s.result_u64()\n-    }\n+    let s = &State(k0, k1);\n+    for a.iter_bytes(true) |bytes| { s.input(bytes); }\n+    for b.iter_bytes(true) |bytes| { s.input(bytes); }\n+    for c.iter_bytes(true) |bytes| { s.input(bytes); }\n+    s.result_u64()\n }\n \n fn hash_keyed_4<A: IterBytes,\n                 B: IterBytes,\n                 C: IterBytes,\n                 D: IterBytes>(a: &A, b: &B, c: &C, d: &D, k0: u64, k1: u64)\n                            -> u64 {\n-    unsafe {\n-        let s = &State(k0, k1);\n-        for a.iter_bytes(true) |bytes| { s.input(bytes); }\n-        for b.iter_bytes(true) |bytes| { s.input(bytes); }\n-        for c.iter_bytes(true) |bytes| { s.input(bytes); }\n-        for d.iter_bytes(true) |bytes| { s.input(bytes); }\n-        s.result_u64()\n-    }\n+    let s = &State(k0, k1);\n+    for a.iter_bytes(true) |bytes| { s.input(bytes); }\n+    for b.iter_bytes(true) |bytes| { s.input(bytes); }\n+    for c.iter_bytes(true) |bytes| { s.input(bytes); }\n+    for d.iter_bytes(true) |bytes| { s.input(bytes); }\n+    s.result_u64()\n }\n \n fn hash_keyed_5<A: IterBytes,\n@@ -129,15 +121,13 @@ fn hash_keyed_5<A: IterBytes,\n                 D: IterBytes,\n                 E: IterBytes>(a: &A, b: &B, c: &C, d: &D, e: &E,\n                               k0: u64, k1: u64) -> u64 {\n-    unsafe {\n-        let s = &State(k0, k1);\n-        for a.iter_bytes(true) |bytes| { s.input(bytes); }\n-        for b.iter_bytes(true) |bytes| { s.input(bytes); }\n-        for c.iter_bytes(true) |bytes| { s.input(bytes); }\n-        for d.iter_bytes(true) |bytes| { s.input(bytes); }\n-        for e.iter_bytes(true) |bytes| { s.input(bytes); }\n-        s.result_u64()\n-    }\n+    let s = &State(k0, k1);\n+    for a.iter_bytes(true) |bytes| { s.input(bytes); }\n+    for b.iter_bytes(true) |bytes| { s.input(bytes); }\n+    for c.iter_bytes(true) |bytes| { s.input(bytes); }\n+    for d.iter_bytes(true) |bytes| { s.input(bytes); }\n+    for e.iter_bytes(true) |bytes| { s.input(bytes); }\n+    s.result_u64()\n }\n \n // Implement State as SipState"}, {"sha": "de699a3756b6ebc25df27cf4ddf8d282cc8e904b", "filename": "src/libcore/num/strconv.rs", "status": "modified", "additions": 33, "deletions": 47, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibcore%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibcore%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fstrconv.rs?ref=30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa", "patch": "@@ -228,10 +228,8 @@ pub fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n         deccum /= radix_gen;\n         deccum = deccum.round_to_zero();\n \n-        unsafe { // FIXME: Pureness workaround (#4568)\n-            buf.push(char::from_digit(current_digit.to_int() as uint, radix)\n-                 .unwrap() as u8);\n-        }\n+        buf.push(char::from_digit(current_digit.to_int() as uint, radix)\n+             .unwrap() as u8);\n \n         // No more digits to calculate for the non-fractional part -> break\n         if deccum == _0 { break; }\n@@ -247,21 +245,15 @@ pub fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n     // Decide what sign to put in front\n     match sign {\n         SignNeg | SignAll if neg => {\n-            unsafe { // FIXME: Pureness workaround (#4568)\n-                buf.push('-' as u8);\n-            }\n+            buf.push('-' as u8);\n         }\n         SignAll => {\n-            unsafe { // FIXME: Pureness workaround (#4568)\n-                buf.push('+' as u8);\n-            }\n+            buf.push('+' as u8);\n         }\n         _ => ()\n     }\n \n-    unsafe { // FIXME: Pureness workaround (#4568)\n-        vec::reverse(buf);\n-    }\n+    vec::reverse(buf);\n \n     // Remember start of the fractional digits.\n     // Points one beyond end of buf if none get generated,\n@@ -271,9 +263,7 @@ pub fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n     // Now emit the fractional part, if any\n     deccum = num.fractional_part();\n     if deccum != _0 || (limit_digits && exact && digit_count > 0) {\n-        unsafe { // FIXME: Pureness workaround (#4568)\n-            buf.push('.' as u8);\n-        }\n+        buf.push('.' as u8);\n         let mut dig = 0u;\n \n         // calculate new digits while\n@@ -299,10 +289,8 @@ pub fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n                 current_digit_signed\n             };\n \n-            unsafe { // FIXME: Pureness workaround (#4568)\n-                buf.push(char::from_digit(\n-                    current_digit.to_int() as uint, radix).unwrap() as u8);\n-            }\n+            buf.push(char::from_digit(\n+                current_digit.to_int() as uint, radix).unwrap() as u8);\n \n             // Decrease the deccumulator one fractional digit at a time\n             deccum = deccum.fractional_part();\n@@ -320,33 +308,31 @@ pub fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n                 char::from_digit(val, radix).unwrap() as u8\n             };\n \n-            unsafe { // FIXME: Pureness workaround (#4568)\n-                let extra_digit = ascii2value(buf.pop());\n-                if extra_digit >= radix / 2 { // -> need to round\n-                    let mut i: int = buf.len() as int - 1;\n-                    loop {\n-                        // If reached left end of number, have to\n-                        // insert additional digit:\n-                        if i < 0\n-                        || buf[i] == '-' as u8\n-                        || buf[i] == '+' as u8 {\n-                            buf.insert((i + 1) as uint, value2ascii(1));\n-                            break;\n-                        }\n-\n-                        // Skip the '.'\n-                        if buf[i] == '.' as u8 { i -= 1; loop; }\n-\n-                        // Either increment the digit,\n-                        // or set to 0 if max and carry the 1.\n-                        let current_digit = ascii2value(buf[i]);\n-                        if current_digit < (radix - 1) {\n-                            buf[i] = value2ascii(current_digit+1);\n-                            break;\n-                        } else {\n-                            buf[i] = value2ascii(0);\n-                            i -= 1;\n-                        }\n+            let extra_digit = ascii2value(buf.pop());\n+            if extra_digit >= radix / 2 { // -> need to round\n+                let mut i: int = buf.len() as int - 1;\n+                loop {\n+                    // If reached left end of number, have to\n+                    // insert additional digit:\n+                    if i < 0\n+                    || buf[i] == '-' as u8\n+                    || buf[i] == '+' as u8 {\n+                        buf.insert((i + 1) as uint, value2ascii(1));\n+                        break;\n+                    }\n+\n+                    // Skip the '.'\n+                    if buf[i] == '.' as u8 { i -= 1; loop; }\n+\n+                    // Either increment the digit,\n+                    // or set to 0 if max and carry the 1.\n+                    let current_digit = ascii2value(buf[i]);\n+                    if current_digit < (radix - 1) {\n+                        buf[i] = value2ascii(current_digit+1);\n+                        break;\n+                    } else {\n+                        buf[i] = value2ascii(0);\n+                        i -= 1;\n                     }\n                 }\n             }"}, {"sha": "8fd81a2060342ef12286b7aef483d5992dd2ba20", "filename": "src/libcore/result.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa", "patch": "@@ -39,9 +39,8 @@ pub enum Result<T, U> {\n pub fn get<T:Copy,U>(res: &Result<T, U>) -> T {\n     match *res {\n       Ok(copy t) => t,\n-      Err(ref the_err) => unsafe {\n+      Err(ref the_err) =>\n         fail!(fmt!(\"get called on error result: %?\", *the_err))\n-      }\n     }\n }\n \n@@ -56,9 +55,8 @@ pub fn get<T:Copy,U>(res: &Result<T, U>) -> T {\n pub fn get_ref<'a, T, U>(res: &'a Result<T, U>) -> &'a T {\n     match *res {\n         Ok(ref t) => t,\n-        Err(ref the_err) => unsafe {\n+        Err(ref the_err) =>\n             fail!(fmt!(\"get_ref called on error result: %?\", *the_err))\n-        }\n     }\n }\n "}, {"sha": "f1605309fb4886cc59e2ac89e1571eca6ec11f52", "filename": "src/libcore/str.rs", "status": "modified", "additions": 24, "deletions": 34, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa", "patch": "@@ -1020,11 +1020,9 @@ pub fn any(ss: &str, pred: &fn(char) -> bool) -> bool {\n /// Apply a function to each character\n pub fn map(ss: &str, ff: &fn(char) -> char) -> ~str {\n     let mut result = ~\"\";\n-    unsafe {\n-        reserve(&mut result, len(ss));\n-        for ss.each_char |cc| {\n-            str::push_char(&mut result, ff(cc));\n-        }\n+    reserve(&mut result, len(ss));\n+    for ss.each_char |cc| {\n+        str::push_char(&mut result, ff(cc));\n     }\n     result\n }\n@@ -1660,20 +1658,18 @@ pub fn to_utf16(s: &str) -> ~[u16] {\n         // Arithmetic with u32 literals is easier on the eyes than chars.\n         let mut ch = ch as u32;\n \n-        unsafe {\n-            if (ch & 0xFFFF_u32) == ch {\n-                // The BMP falls through (assuming non-surrogate, as it\n-                // should)\n-                assert!(ch <= 0xD7FF_u32 || ch >= 0xE000_u32);\n-                u.push(ch as u16)\n-            } else {\n-                // Supplementary planes break into surrogates.\n-                assert!(ch >= 0x1_0000_u32 && ch <= 0x10_FFFF_u32);\n-                ch -= 0x1_0000_u32;\n-                let w1 = 0xD800_u16 | ((ch >> 10) as u16);\n-                let w2 = 0xDC00_u16 | ((ch as u16) & 0x3FF_u16);\n-                u.push_all(~[w1, w2])\n-            }\n+        if (ch & 0xFFFF_u32) == ch {\n+            // The BMP falls through (assuming non-surrogate, as it\n+            // should)\n+            assert!(ch <= 0xD7FF_u32 || ch >= 0xE000_u32);\n+            u.push(ch as u16)\n+        } else {\n+            // Supplementary planes break into surrogates.\n+            assert!(ch >= 0x1_0000_u32 && ch <= 0x10_FFFF_u32);\n+            ch -= 0x1_0000_u32;\n+            let w1 = 0xD800_u16 | ((ch >> 10) as u16);\n+            let w2 = 0xDC00_u16 | ((ch as u16) & 0x3FF_u16);\n+            u.push_all(~[w1, w2])\n         }\n     }\n     u\n@@ -1705,16 +1701,14 @@ pub fn utf16_chars(v: &[u16], f: &fn(char)) {\n \n pub fn from_utf16(v: &[u16]) -> ~str {\n     let mut buf = ~\"\";\n-    unsafe {\n-        reserve(&mut buf, vec::len(v));\n-        utf16_chars(v, |ch| push_char(&mut buf, ch));\n-    }\n+    reserve(&mut buf, vec::len(v));\n+    utf16_chars(v, |ch| push_char(&mut buf, ch));\n     buf\n }\n \n pub fn with_capacity(capacity: uint) -> ~str {\n     let mut buf = ~\"\";\n-    unsafe { reserve(&mut buf, capacity); }\n+    reserve(&mut buf, capacity);\n     buf\n }\n \n@@ -2105,23 +2099,19 @@ pub fn capacity(s: &const ~str) -> uint {\n /// Escape each char in `s` with char::escape_default.\n pub fn escape_default(s: &str) -> ~str {\n     let mut out: ~str = ~\"\";\n-    unsafe {\n-        reserve_at_least(&mut out, str::len(s));\n-        for s.each_char |c| {\n-            push_str(&mut out, char::escape_default(c));\n-        }\n+    reserve_at_least(&mut out, str::len(s));\n+    for s.each_char |c| {\n+        push_str(&mut out, char::escape_default(c));\n     }\n     out\n }\n \n /// Escape each char in `s` with char::escape_unicode.\n pub fn escape_unicode(s: &str) -> ~str {\n     let mut out: ~str = ~\"\";\n-    unsafe {\n-        reserve_at_least(&mut out, str::len(s));\n-        for s.each_char |c| {\n-            push_str(&mut out, char::escape_unicode(c));\n-        }\n+    reserve_at_least(&mut out, str::len(s));\n+    for s.each_char |c| {\n+        push_str(&mut out, char::escape_unicode(c));\n     }\n     out\n }"}, {"sha": "980d4b445d04da8e7be66902b9025db92532d018", "filename": "src/libcore/to_str.rs", "status": "modified", "additions": 21, "deletions": 42, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibcore%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibcore%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_str.rs?ref=30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa", "patch": "@@ -72,63 +72,42 @@ impl<A:ToStr,B:ToStr,C:ToStr> ToStr for (A, B, C) {\n impl<'self,A:ToStr> ToStr for &'self [A] {\n     #[inline(always)]\n     fn to_str(&self) -> ~str {\n-        unsafe {\n-            // FIXME #4568\n-            // Bleh -- not really unsafe\n-            // push_str and push_char\n-            let mut acc = ~\"[\", first = true;\n-            for self.each |elt| {\n-                unsafe {\n-                    if first { first = false; }\n-                    else { str::push_str(&mut acc, ~\", \"); }\n-                    str::push_str(&mut acc, elt.to_str());\n-                }\n-            }\n-            str::push_char(&mut acc, ']');\n-            acc\n+        let mut acc = ~\"[\", first = true;\n+        for self.each |elt| {\n+            if first { first = false; }\n+            else { str::push_str(&mut acc, ~\", \"); }\n+            str::push_str(&mut acc, elt.to_str());\n         }\n+        str::push_char(&mut acc, ']');\n+        acc\n     }\n }\n \n impl<A:ToStr> ToStr for ~[A] {\n     #[inline(always)]\n     fn to_str(&self) -> ~str {\n-        unsafe {\n-            // FIXME #4568\n-            // Bleh -- not really unsafe\n-            // push_str and push_char\n-            let mut acc = ~\"[\", first = true;\n-            for self.each |elt| {\n-                unsafe {\n-                    if first { first = false; }\n-                    else { str::push_str(&mut acc, ~\", \"); }\n-                    str::push_str(&mut acc, elt.to_str());\n-                }\n-            }\n-            str::push_char(&mut acc, ']');\n-            acc\n+        let mut acc = ~\"[\", first = true;\n+        for self.each |elt| {\n+            if first { first = false; }\n+            else { str::push_str(&mut acc, ~\", \"); }\n+            str::push_str(&mut acc, elt.to_str());\n         }\n+        str::push_char(&mut acc, ']');\n+        acc\n     }\n }\n \n impl<A:ToStr> ToStr for @[A] {\n     #[inline(always)]\n     fn to_str(&self) -> ~str {\n-        unsafe {\n-            // FIXME #4568\n-            // Bleh -- not really unsafe\n-            // push_str and push_char\n-            let mut acc = ~\"[\", first = true;\n-            for self.each |elt| {\n-                unsafe {\n-                    if first { first = false; }\n-                    else { str::push_str(&mut acc, ~\", \"); }\n-                    str::push_str(&mut acc, elt.to_str());\n-                }\n-            }\n-            str::push_char(&mut acc, ']');\n-            acc\n+        let mut acc = ~\"[\", first = true;\n+        for self.each |elt| {\n+            if first { first = false; }\n+            else { str::push_str(&mut acc, ~\", \"); }\n+            str::push_str(&mut acc, elt.to_str());\n         }\n+        str::push_char(&mut acc, ']');\n+        acc\n     }\n }\n "}, {"sha": "5b06591f9ecc8c4f47628f7aeb9e2a7dc5e30f85", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 33, "deletions": 48, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa", "patch": "@@ -167,7 +167,7 @@ pub fn from_slice<T:Copy>(t: &[T]) -> ~[T] {\n \n pub fn with_capacity<T>(capacity: uint) -> ~[T] {\n     let mut vec = ~[];\n-    unsafe { reserve(&mut vec, capacity); }\n+    reserve(&mut vec, capacity);\n     vec\n }\n \n@@ -186,7 +186,7 @@ pub fn with_capacity<T>(capacity: uint) -> ~[T] {\n #[inline(always)]\n pub fn build_sized<A>(size: uint, builder: &fn(push: &fn(v: A))) -> ~[A] {\n     let mut vec = with_capacity(size);\n-    builder(|x| unsafe { vec.push(x) });\n+    builder(|x| vec.push(x));\n     vec\n }\n \n@@ -437,12 +437,10 @@ pub fn partitioned<T:Copy>(v: &[T], f: &fn(&T) -> bool) -> (~[T], ~[T]) {\n     let mut rights = ~[];\n \n     for each(v) |elt| {\n-        unsafe {\n-            if f(elt) {\n-                lefts.push(*elt);\n-            } else {\n-                rights.push(*elt);\n-            }\n+        if f(elt) {\n+            lefts.push(*elt);\n+        } else {\n+            rights.push(*elt);\n         }\n     }\n \n@@ -735,16 +733,14 @@ pub fn dedup<T:Eq>(v: &mut ~[T]) {\n #[inline(always)]\n pub fn append<T:Copy>(lhs: ~[T], rhs: &const [T]) -> ~[T] {\n     let mut v = lhs;\n-    unsafe {\n-        v.push_all(rhs);\n-    }\n+    v.push_all(rhs);\n     v\n }\n \n #[inline(always)]\n pub fn append_one<T>(lhs: ~[T], x: T) -> ~[T] {\n     let mut v = lhs;\n-    unsafe { v.push(x); }\n+    v.push(x);\n     v\n }\n \n@@ -811,9 +807,7 @@ pub fn grow_set<T:Copy>(v: &mut ~[T], index: uint, initval: &T, val: T) {\n pub fn map<T, U>(v: &[T], f: &fn(t: &T) -> U) -> ~[U] {\n     let mut result = with_capacity(len(v));\n     for each(v) |elem| {\n-        unsafe {\n-            result.push(f(elem));\n-        }\n+        result.push(f(elem));\n     }\n     result\n }\n@@ -841,7 +835,7 @@ pub fn mapi<T, U>(v: &[T], f: &fn(uint, t: &T) -> U) -> ~[U] {\n  */\n pub fn flat_map<T, U>(v: &[T], f: &fn(t: &T) -> ~[U]) -> ~[U] {\n     let mut result = ~[];\n-    for each(v) |elem| { unsafe{ result.push_all_move(f(elem)); } }\n+    for each(v) |elem| { result.push_all_move(f(elem)); }\n     result\n }\n \n@@ -853,7 +847,7 @@ pub fn map2<T:Copy,U:Copy,V>(v0: &[T], v1: &[U],\n     let mut u: ~[V] = ~[];\n     let mut i = 0u;\n     while i < v0_len {\n-        unsafe { u.push(f(&v0[i], &v1[i])) };\n+        u.push(f(&v0[i], &v1[i]));\n         i += 1u;\n     }\n     u\n@@ -894,7 +888,7 @@ pub fn filter_mapped<T, U: Copy>(\n     for each(v) |elem| {\n         match f(elem) {\n           None => {/* no-op */ }\n-          Some(result_elem) => unsafe { result.push(result_elem); }\n+          Some(result_elem) => { result.push(result_elem); }\n         }\n     }\n     result\n@@ -927,7 +921,7 @@ pub fn filter<T>(v: ~[T], f: &fn(t: &T) -> bool) -> ~[T] {\n pub fn filtered<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[T] {\n     let mut result = ~[];\n     for each(v) |elem| {\n-        if f(elem) { unsafe { result.push(*elem); } }\n+        if f(elem) { result.push(*elem); }\n     }\n     result\n }\n@@ -959,7 +953,7 @@ pub fn retain<T>(v: &mut ~[T], f: &fn(t: &T) -> bool) {\n  */\n pub fn concat<T:Copy>(v: &[~[T]]) -> ~[T] {\n     let mut r = ~[];\n-    for each(v) |inner| { unsafe { r.push_all(*inner); } }\n+    for each(v) |inner| { r.push_all(*inner); }\n     r\n }\n \n@@ -968,8 +962,8 @@ pub fn connect<T:Copy>(v: &[~[T]], sep: &T) -> ~[T] {\n     let mut r: ~[T] = ~[];\n     let mut first = true;\n     for each(v) |inner| {\n-        if first { first = false; } else { unsafe { r.push(*sep); } }\n-        unsafe { r.push_all(*inner) };\n+        if first { first = false; } else { r.push(*sep); }\n+        r.push_all(*inner);\n     }\n     r\n }\n@@ -1236,10 +1230,8 @@ pub fn unzip_slice<T:Copy,U:Copy>(v: &[(T, U)]) -> (~[T], ~[U]) {\n     let mut ts = ~[], us = ~[];\n     for each(v) |p| {\n         let (t, u) = *p;\n-        unsafe {\n-            ts.push(t);\n-            us.push(u);\n-        }\n+        ts.push(t);\n+        us.push(u);\n     }\n     (ts, us)\n }\n@@ -1254,12 +1246,10 @@ pub fn unzip_slice<T:Copy,U:Copy>(v: &[(T, U)]) -> (~[T], ~[U]) {\n  */\n pub fn unzip<T,U>(v: ~[(T, U)]) -> (~[T], ~[U]) {\n     let mut ts = ~[], us = ~[];\n-    unsafe {\n-        do consume(v) |_i, p| {\n-            let (t, u) = p;\n-            ts.push(t);\n-            us.push(u);\n-        }\n+    do consume(v) |_i, p| {\n+        let (t, u) = p;\n+        ts.push(t);\n+        us.push(u);\n     }\n     (ts, us)\n }\n@@ -1274,7 +1264,8 @@ pub fn zip_slice<T:Copy,U:Copy>(v: &const [T], u: &const [U])\n     let mut i = 0u;\n     assert!(sz == len(u));\n     while i < sz {\n-        unsafe { zipped.push((v[i], u[i])); i += 1u; }\n+        zipped.push((v[i], u[i]));\n+        i += 1u;\n     }\n     zipped\n }\n@@ -1290,10 +1281,10 @@ pub fn zip<T, U>(mut v: ~[T], mut u: ~[U]) -> ~[(T, U)] {\n     assert!(i == len(u));\n     let mut w = with_capacity(i);\n     while i > 0 {\n-        unsafe { w.push((v.pop(),u.pop())); }\n+        w.push((v.pop(),u.pop()));\n         i -= 1;\n     }\n-    unsafe { reverse(w); }\n+    reverse(w);\n     w\n }\n \n@@ -1322,10 +1313,8 @@ pub fn reversed<T:Copy>(v: &const [T]) -> ~[T] {\n     let mut rs: ~[T] = ~[];\n     let mut i = len::<T>(v);\n     if i == 0 { return (rs); } else { i -= 1; }\n-    unsafe {\n-        while i != 0 { rs.push(v[i]); i -= 1; }\n-        rs.push(v[0]);\n-    }\n+    while i != 0 { rs.push(v[i]); i -= 1; }\n+    rs.push(v[0]);\n     rs\n }\n \n@@ -1495,12 +1484,10 @@ pub fn each_permutation<T:Copy>(v: &[T], put: &fn(ts: &[T]) -> bool) {\n         while i < ln {\n             let elt = v[i];\n             let mut rest = slice(v, 0u, i).to_vec();\n-            unsafe {\n-                rest.push_all(const_slice(v, i+1u, ln));\n-                for each_permutation(rest) |permutation| {\n-                    if !put(append(~[elt], permutation)) {\n-                        return;\n-                    }\n+            rest.push_all(const_slice(v, i+1u, ln));\n+            for each_permutation(rest) |permutation| {\n+                if !put(append(~[elt], permutation)) {\n+                    return;\n                 }\n             }\n             i += 1u;\n@@ -1514,9 +1501,7 @@ pub fn windowed<TT:Copy>(nn: uint, xx: &[TT]) -> ~[~[TT]] {\n     for vec::eachi (xx) |ii, _x| {\n         let len = xx.len();\n         if ii+nn <= len {\n-            unsafe {\n-                ww.push(slice(xx, ii, ii+nn).to_vec());\n-            }\n+            ww.push(slice(xx, ii, ii+nn).to_vec());\n         }\n     }\n     ww"}, {"sha": "585ce2dc8150047a487b5b904ed5ef777e050471", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa", "patch": "@@ -259,7 +259,7 @@ struct RWARCInner<T> { lock: RWlock, failed: bool, data: T }\n  */\n struct RWARC<T> {\n     x: SharedMutableState<RWARCInner<T>>,\n-    mut cant_nest: ()\n+    cant_nest: ()\n }\n \n /// Create a reader/writer ARC with the supplied data."}, {"sha": "781a720b1a4db6dbb075a4200cb2cb440dadf70e", "filename": "src/libstd/base64.rs", "status": "modified", "additions": 77, "deletions": 81, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibstd%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibstd%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbase64.rs?ref=30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa", "patch": "@@ -29,47 +29,45 @@ static CHARS: [char, ..64] = [\n impl<'self> ToBase64 for &'self [u8] {\n     fn to_base64(&self) -> ~str {\n         let mut s = ~\"\";\n-        unsafe {\n-            let len = self.len();\n-            str::reserve(&mut s, ((len + 3u) / 4u) * 3u);\n-\n-            let mut i = 0u;\n-\n-            while i < len - (len % 3u) {\n-                let n = (self[i] as uint) << 16u |\n-                        (self[i + 1u] as uint) << 8u |\n-                        (self[i + 2u] as uint);\n-\n-                // This 24-bit number gets separated into four 6-bit numbers.\n-                str::push_char(&mut s, CHARS[(n >> 18u) & 63u]);\n-                str::push_char(&mut s, CHARS[(n >> 12u) & 63u]);\n-                str::push_char(&mut s, CHARS[(n >> 6u) & 63u]);\n-                str::push_char(&mut s, CHARS[n & 63u]);\n-\n-                i += 3u;\n-            }\n-\n-            // Heh, would be cool if we knew this was exhaustive\n-            // (the dream of bounded integer types)\n-            match len % 3 {\n-              0 => (),\n-              1 => {\n-                let n = (self[i] as uint) << 16u;\n-                str::push_char(&mut s, CHARS[(n >> 18u) & 63u]);\n-                str::push_char(&mut s, CHARS[(n >> 12u) & 63u]);\n-                str::push_char(&mut s, '=');\n-                str::push_char(&mut s, '=');\n-              }\n-              2 => {\n-                let n = (self[i] as uint) << 16u |\n-                    (self[i + 1u] as uint) << 8u;\n-                str::push_char(&mut s, CHARS[(n >> 18u) & 63u]);\n-                str::push_char(&mut s, CHARS[(n >> 12u) & 63u]);\n-                str::push_char(&mut s, CHARS[(n >> 6u) & 63u]);\n-                str::push_char(&mut s, '=');\n-              }\n-              _ => fail!(~\"Algebra is broken, please alert the math police\")\n-            }\n+        let len = self.len();\n+        str::reserve(&mut s, ((len + 3u) / 4u) * 3u);\n+\n+        let mut i = 0u;\n+\n+        while i < len - (len % 3u) {\n+            let n = (self[i] as uint) << 16u |\n+                    (self[i + 1u] as uint) << 8u |\n+                    (self[i + 2u] as uint);\n+\n+            // This 24-bit number gets separated into four 6-bit numbers.\n+            str::push_char(&mut s, CHARS[(n >> 18u) & 63u]);\n+            str::push_char(&mut s, CHARS[(n >> 12u) & 63u]);\n+            str::push_char(&mut s, CHARS[(n >> 6u) & 63u]);\n+            str::push_char(&mut s, CHARS[n & 63u]);\n+\n+            i += 3u;\n+        }\n+\n+        // Heh, would be cool if we knew this was exhaustive\n+        // (the dream of bounded integer types)\n+        match len % 3 {\n+          0 => (),\n+          1 => {\n+            let n = (self[i] as uint) << 16u;\n+            str::push_char(&mut s, CHARS[(n >> 18u) & 63u]);\n+            str::push_char(&mut s, CHARS[(n >> 12u) & 63u]);\n+            str::push_char(&mut s, '=');\n+            str::push_char(&mut s, '=');\n+          }\n+          2 => {\n+            let n = (self[i] as uint) << 16u |\n+                (self[i + 1u] as uint) << 8u;\n+            str::push_char(&mut s, CHARS[(n >> 18u) & 63u]);\n+            str::push_char(&mut s, CHARS[(n >> 12u) & 63u]);\n+            str::push_char(&mut s, CHARS[(n >> 6u) & 63u]);\n+            str::push_char(&mut s, '=');\n+          }\n+          _ => fail!(~\"Algebra is broken, please alert the math police\")\n         }\n         s\n     }\n@@ -99,49 +97,47 @@ impl FromBase64 for ~[u8] {\n \n         let mut r = vec::with_capacity((len / 4u) * 3u - padding);\n \n-        unsafe {\n-            let mut i = 0u;\n-            while i < len {\n-                let mut n = 0u;\n-\n-                for iter::repeat(4u) {\n-                    let ch = self[i] as char;\n-                    n <<= 6u;\n-\n-                    if ch >= 'A' && ch <= 'Z' {\n-                        n |= (ch as uint) - 0x41u;\n-                    } else if ch >= 'a' && ch <= 'z' {\n-                        n |= (ch as uint) - 0x47u;\n-                    } else if ch >= '0' && ch <= '9' {\n-                        n |= (ch as uint) + 0x04u;\n-                    } else if ch == '+' {\n-                        n |= 0x3Eu;\n-                    } else if ch == '/' {\n-                        n |= 0x3Fu;\n-                    } else if ch == '=' {\n-                        match len - i {\n-                          1u => {\n-                            r.push(((n >> 16u) & 0xFFu) as u8);\n-                            r.push(((n >> 8u ) & 0xFFu) as u8);\n-                            return copy r;\n-                          }\n-                          2u => {\n-                            r.push(((n >> 10u) & 0xFFu) as u8);\n-                            return copy r;\n-                          }\n-                          _ => fail!(~\"invalid base64 padding\")\n-                        }\n-                    } else {\n-                        fail!(~\"invalid base64 character\");\n+        let mut i = 0u;\n+        while i < len {\n+            let mut n = 0u;\n+\n+            for iter::repeat(4u) {\n+                let ch = self[i] as char;\n+                n <<= 6u;\n+\n+                if ch >= 'A' && ch <= 'Z' {\n+                    n |= (ch as uint) - 0x41u;\n+                } else if ch >= 'a' && ch <= 'z' {\n+                    n |= (ch as uint) - 0x47u;\n+                } else if ch >= '0' && ch <= '9' {\n+                    n |= (ch as uint) + 0x04u;\n+                } else if ch == '+' {\n+                    n |= 0x3Eu;\n+                } else if ch == '/' {\n+                    n |= 0x3Fu;\n+                } else if ch == '=' {\n+                    match len - i {\n+                      1u => {\n+                        r.push(((n >> 16u) & 0xFFu) as u8);\n+                        r.push(((n >> 8u ) & 0xFFu) as u8);\n+                        return copy r;\n+                      }\n+                      2u => {\n+                        r.push(((n >> 10u) & 0xFFu) as u8);\n+                        return copy r;\n+                      }\n+                      _ => fail!(~\"invalid base64 padding\")\n                     }\n+                } else {\n+                    fail!(~\"invalid base64 character\");\n+                }\n \n-                    i += 1u;\n-                };\n+                i += 1u;\n+            };\n \n-                r.push(((n >> 16u) & 0xFFu) as u8);\n-                r.push(((n >> 8u ) & 0xFFu) as u8);\n-                r.push(((n       ) & 0xFFu) as u8);\n-            }\n+            r.push(((n >> 16u) & 0xFFu) as u8);\n+            r.push(((n >> 8u ) & 0xFFu) as u8);\n+            r.push(((n       ) & 0xFFu) as u8);\n         }\n         r\n     }"}, {"sha": "a490065b835c1f616c830f5cfdcaa059b448627a", "filename": "src/libstd/dlist.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibstd%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibstd%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdlist.rs?ref=30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa", "patch": "@@ -99,7 +99,7 @@ pub fn DList<T>() -> @mut DList<T> {\n /// Creates a new dlist with a single element\n pub fn from_elem<T>(data: T) -> @mut DList<T> {\n     let list = DList();\n-    unsafe { list.push(data); }\n+    list.push(data);\n     list\n }\n \n@@ -484,11 +484,8 @@ pub impl<T:Copy> DList<T> {\n     /// Get the elements of the list as a vector. O(n).\n     fn to_vec(@mut self) -> ~[T] {\n         let mut v = vec::with_capacity(self.size);\n-        unsafe {\n-            // Take this out of the unchecked when iter's functions are pure\n-            for iter::eachi(&self) |index,data| {\n-                v[index] = *data;\n-            }\n+        for iter::eachi(&self) |index,data| {\n+            v[index] = *data;\n         }\n         v\n     }"}, {"sha": "d733a60f34fffd4076d378acc5a6701f72fe9ef5", "filename": "src/libstd/json.rs", "status": "modified", "additions": 33, "deletions": 38, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa", "patch": "@@ -342,10 +342,7 @@ pub fn to_writer(wr: @io::Writer, json: &Json) {\n \n /// Encodes a json value into a string\n pub fn to_str(json: &Json) -> ~str {\n-    unsafe {\n-        // ugh, should be safe\n-        io::with_str_writer(|wr| to_writer(wr, json))\n-    }\n+    io::with_str_writer(|wr| to_writer(wr, json))\n }\n \n /// Encodes a json value into a io::writer\n@@ -360,9 +357,9 @@ pub fn to_pretty_str(json: &Json) -> ~str {\n \n pub struct Parser {\n     priv rdr: @io::Reader,\n-    priv mut ch: char,\n-    priv mut line: uint,\n-    priv mut col: uint,\n+    priv ch: char,\n+    priv line: uint,\n+    priv col: uint,\n }\n \n /// Decode a json value from an io::reader\n@@ -376,7 +373,7 @@ pub fn Parser(rdr: @io::Reader) -> Parser {\n }\n \n pub impl Parser {\n-    fn parse(&self) -> Result<Json, Error> {\n+    fn parse(&mut self) -> Result<Json, Error> {\n         match self.parse_value() {\n           Ok(value) => {\n             // Skip trailing whitespaces.\n@@ -396,7 +393,7 @@ pub impl Parser {\n priv impl Parser {\n     fn eof(&self) -> bool { self.ch == -1 as char }\n \n-    fn bump(&self) {\n+    fn bump(&mut self) {\n         self.ch = self.rdr.read_char();\n \n         if self.ch == '\\n' {\n@@ -407,7 +404,7 @@ priv impl Parser {\n         }\n     }\n \n-    fn next_char(&self) -> char {\n+    fn next_char(&mut self) -> char {\n         self.bump();\n         self.ch\n     }\n@@ -416,7 +413,7 @@ priv impl Parser {\n         Err(Error { line: self.line, col: self.col, msg: @msg })\n     }\n \n-    fn parse_value(&self) -> Result<Json, Error> {\n+    fn parse_value(&mut self) -> Result<Json, Error> {\n         self.parse_whitespace();\n \n         if self.eof() { return self.error(~\"EOF while parsing value\"); }\n@@ -437,11 +434,11 @@ priv impl Parser {\n         }\n     }\n \n-    fn parse_whitespace(&self) {\n+    fn parse_whitespace(&mut self) {\n         while char::is_whitespace(self.ch) { self.bump(); }\n     }\n \n-    fn parse_ident(&self, ident: &str, value: Json) -> Result<Json, Error> {\n+    fn parse_ident(&mut self, ident: &str, value: Json) -> Result<Json, Error> {\n         if str::all(ident, |c| c == self.next_char()) {\n             self.bump();\n             Ok(value)\n@@ -450,7 +447,7 @@ priv impl Parser {\n         }\n     }\n \n-    fn parse_number(&self) -> Result<Json, Error> {\n+    fn parse_number(&mut self) -> Result<Json, Error> {\n         let mut neg = 1f;\n \n         if self.ch == '-' {\n@@ -480,7 +477,7 @@ priv impl Parser {\n         Ok(Number(neg * res))\n     }\n \n-    fn parse_integer(&self) -> Result<float, Error> {\n+    fn parse_integer(&mut self) -> Result<float, Error> {\n         let mut res = 0f;\n \n         match self.ch {\n@@ -512,7 +509,7 @@ priv impl Parser {\n         Ok(res)\n     }\n \n-    fn parse_decimal(&self, res: float) -> Result<float, Error> {\n+    fn parse_decimal(&mut self, res: float) -> Result<float, Error> {\n         self.bump();\n \n         // Make sure a digit follows the decimal place.\n@@ -538,10 +535,9 @@ priv impl Parser {\n         Ok(res)\n     }\n \n-    fn parse_exponent(&self, res: float) -> Result<float, Error> {\n+    fn parse_exponent(&mut self, mut res: float) -> Result<float, Error> {\n         self.bump();\n \n-        let mut res = res;\n         let mut exp = 0u;\n         let mut neg_exp = false;\n \n@@ -579,7 +575,7 @@ priv impl Parser {\n         Ok(res)\n     }\n \n-    fn parse_str(&self) -> Result<~str, Error> {\n+    fn parse_str(&mut self) -> Result<~str, Error> {\n         let mut escape = false;\n         let mut res = ~\"\";\n \n@@ -643,7 +639,7 @@ priv impl Parser {\n         self.error(~\"EOF while parsing string\")\n     }\n \n-    fn parse_list(&self) -> Result<Json, Error> {\n+    fn parse_list(&mut self) -> Result<Json, Error> {\n         self.bump();\n         self.parse_whitespace();\n \n@@ -673,7 +669,7 @@ priv impl Parser {\n         };\n     }\n \n-    fn parse_object(&self) -> Result<Json, Error> {\n+    fn parse_object(&mut self) -> Result<Json, Error> {\n         self.bump();\n         self.parse_whitespace();\n \n@@ -726,7 +722,8 @@ priv impl Parser {\n \n /// Decodes a json value from an @io::Reader\n pub fn from_reader(rdr: @io::Reader) -> Result<Json, Error> {\n-    Parser(rdr).parse()\n+    let mut parser = Parser(rdr);\n+    parser.parse()\n }\n \n /// Decodes a json value from a string\n@@ -988,23 +985,21 @@ impl Ord for Json {\n                 match *other {\n                     Number(_) | String(_) | Boolean(_) | List(_) => false,\n                     Object(ref d1) => {\n-                        unsafe {\n-                            let mut d0_flat = ~[];\n-                            let mut d1_flat = ~[];\n-\n-                            // FIXME #4430: this is horribly inefficient...\n-                            for d0.each |&(k, v)| {\n-                                 d0_flat.push((@copy *k, @copy *v));\n-                            }\n-                            d0_flat.qsort();\n-\n-                            for d1.each |&(k, v)| {\n-                                d1_flat.push((@copy *k, @copy *v));\n-                            }\n-                            d1_flat.qsort();\n-\n-                            d0_flat < d1_flat\n+                        let mut d0_flat = ~[];\n+                        let mut d1_flat = ~[];\n+\n+                        // FIXME #4430: this is horribly inefficient...\n+                        for d0.each |&(k, v)| {\n+                             d0_flat.push((@copy *k, @copy *v));\n                         }\n+                        d0_flat.qsort();\n+\n+                        for d1.each |&(k, v)| {\n+                            d1_flat.push((@copy *k, @copy *v));\n+                        }\n+                        d1_flat.qsort();\n+\n+                        d0_flat < d1_flat\n                     }\n                     Null => true\n                 }"}, {"sha": "24dd08c362e991a88d3092186ddf07af2c6dd959", "filename": "src/libstd/md4.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibstd%2Fmd4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibstd%2Fmd4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmd4.rs?ref=30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa", "patch": "@@ -29,14 +29,14 @@ pub fn md4(msg: &[u8]) -> Quad {\n     let mut msg = vec::append(vec::from_slice(msg), ~[0x80u8]);\n     let mut bitlen = orig_len + 8u64;\n     while (bitlen + 64u64) % 512u64 > 0u64 {\n-        unsafe {msg.push(0u8);}\n+        msg.push(0u8);\n         bitlen += 8u64;\n     }\n \n     // append length\n     let mut i = 0u64;\n     while i < 8u64 {\n-        unsafe {msg.push((orig_len >> (i * 8u64)) as u8);}\n+        msg.push((orig_len >> (i * 8u64)) as u8);\n         i += 1u64;\n     }\n "}, {"sha": "ec5d2cded8d56d468f3d2db44dba201d5dd8aa58", "filename": "src/libstd/num/bigint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibstd%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibstd%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fbigint.rs?ref=30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa", "patch": "@@ -341,7 +341,7 @@ pub impl BigUint {\n \n         if new_len == v.len() { return BigUint { data: v }; }\n         let mut v = v;\n-        unsafe { v.truncate(new_len); }\n+        v.truncate(new_len);\n         return BigUint { data: v };\n     }\n "}, {"sha": "949850f3ca6771d8c96c8545dbe56fe139932a2d", "filename": "src/libstd/num/complex.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibstd%2Fnum%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibstd%2Fnum%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fcomplex.rs?ref=30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa", "patch": "@@ -239,7 +239,6 @@ mod test {\n \n     mod arith {\n         use super::*;\n-        use super::super::*;\n         use core::num::Zero;\n \n         #[test]"}, {"sha": "232f46b6676df6fc4a8af620445bb106a416247a", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 36, "deletions": 37, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa", "patch": "@@ -455,7 +455,7 @@ pub mod iterator {\n               node::Content(x) => return node::leaf_iterator::start(x)\n             }\n         }\n-        pub fn next(it: &node::leaf_iterator::T) -> Option<node::Leaf> {\n+        pub fn next(it: &mut node::leaf_iterator::T) -> Option<node::Leaf> {\n             return node::leaf_iterator::next(it);\n         }\n     }\n@@ -470,7 +470,7 @@ pub mod iterator {\n               node::Content(x) => return node::char_iterator::start(x)\n             }\n         }\n-        pub fn next(it: &node::char_iterator::T) -> Option<char> {\n+        pub fn next(it: &mut node::char_iterator::T) -> Option<char> {\n             return node::char_iterator::next(it)\n         }\n     }\n@@ -832,9 +832,9 @@ pub mod node {\n         unsafe {\n             let mut buf = vec::from_elem(byte_len(node), 0);\n             let mut offset = 0u;//Current position in the buffer\n-            let it = leaf_iterator::start(node);\n+            let mut it = leaf_iterator::start(node);\n             loop {\n-                match (leaf_iterator::next(&it)) {\n+                match leaf_iterator::next(&mut it) {\n                   option::None => break,\n                   option::Some(x) => {\n                     //FIXME (#2744): Replace with memcpy or something similar\n@@ -896,9 +896,9 @@ pub mod node {\n         if height(node) < hint_max_node_height { return option::None; }\n         //1. Gather all leaves as a forest\n         let mut forest = ~[];\n-        let it = leaf_iterator::start(node);\n+        let mut it = leaf_iterator::start(node);\n         loop {\n-            match (leaf_iterator::next(&it)) {\n+            match leaf_iterator::next(&mut it) {\n               option::None    => break,\n               option::Some(x) => forest.push(@Leaf(x))\n             }\n@@ -1058,11 +1058,12 @@ pub mod node {\n     }\n \n     pub fn cmp(a: @Node, b: @Node) -> int {\n-        let ita = char_iterator::start(a);\n-        let itb = char_iterator::start(b);\n+        let mut ita = char_iterator::start(a);\n+        let mut itb = char_iterator::start(b);\n         let mut result = 0;\n         while result == 0 {\n-            match ((char_iterator::next(&ita), char_iterator::next(&itb))) {\n+            match (char_iterator::next(&mut ita), char_iterator::next(&mut itb))\n+            {\n               (option::None, option::None) => break,\n               (option::Some(chara), option::Some(charb)) => {\n                 result = char::cmp(chara, charb);\n@@ -1131,9 +1132,7 @@ pub mod node {\n      * proportional to the height of the rope + the (bounded)\n      * length of the largest leaf.\n      */\n-    pub fn char_at(node: @Node, pos: uint) -> char {\n-        let mut node    = node;\n-        let mut pos     = pos;\n+    pub fn char_at(mut node: @Node, mut pos: uint) -> char {\n         loop {\n             match *node {\n               Leaf(x) => return str::char_at(*x.content, pos),\n@@ -1154,8 +1153,8 @@ pub mod node {\n         use core::vec;\n \n         pub struct T {\n-            mut stack: ~[@Node],\n-            mut stackpos: int,\n+            stack: ~[@Node],\n+            stackpos: int,\n         }\n \n         pub fn empty() -> T {\n@@ -1171,7 +1170,7 @@ pub mod node {\n             }\n         }\n \n-        pub fn next(it: &T) -> Option<Leaf> {\n+        pub fn next(it: &mut T) -> Option<Leaf> {\n             if it.stackpos < 0 { return option::None; }\n             loop {\n                 let current = it.stack[it.stackpos];\n@@ -1199,8 +1198,8 @@ pub mod node {\n \n         pub struct T {\n             leaf_iterator: leaf_iterator::T,\n-            mut leaf:  Option<Leaf>,\n-            mut leaf_byte_pos: uint,\n+            leaf:  Option<Leaf>,\n+            leaf_byte_pos: uint,\n         }\n \n         pub fn start(node: @Node) -> T {\n@@ -1219,13 +1218,13 @@ pub mod node {\n             }\n         }\n \n-        pub fn next(it: &T) -> Option<char> {\n+        pub fn next(it: &mut T) -> Option<char> {\n             loop {\n-                match (get_current_or_next_leaf(it)) {\n+                match get_current_or_next_leaf(it) {\n                   option::None => return option::None,\n                   option::Some(_) => {\n                     let next_char = get_next_char_in_leaf(it);\n-                    match (next_char) {\n+                    match next_char {\n                       option::None => loop,\n                       option::Some(_) => return next_char\n                     }\n@@ -1234,30 +1233,30 @@ pub mod node {\n             };\n         }\n \n-        pub fn get_current_or_next_leaf(it: &T) -> Option<Leaf> {\n-            match ((*it).leaf) {\n-              option::Some(_) => return (*it).leaf,\n+        pub fn get_current_or_next_leaf(it: &mut T) -> Option<Leaf> {\n+            match it.leaf {\n+              option::Some(_) => return it.leaf,\n               option::None => {\n-                let next = leaf_iterator::next(&((*it).leaf_iterator));\n-                match (next) {\n+                let next = leaf_iterator::next(&mut it.leaf_iterator);\n+                match next {\n                   option::None => return option::None,\n                   option::Some(_) => {\n-                    (*it).leaf          = next;\n-                    (*it).leaf_byte_pos = 0u;\n+                    it.leaf          = next;\n+                    it.leaf_byte_pos = 0u;\n                     return next;\n                   }\n                 }\n               }\n             }\n         }\n \n-        pub fn get_next_char_in_leaf(it: &T) -> Option<char> {\n-            match copy (*it).leaf {\n+        pub fn get_next_char_in_leaf(it: &mut T) -> Option<char> {\n+            match copy it.leaf {\n               option::None => return option::None,\n               option::Some(aleaf) => {\n-                if (*it).leaf_byte_pos >= aleaf.byte_len {\n+                if it.leaf_byte_pos >= aleaf.byte_len {\n                     //We are actually past the end of the leaf\n-                    (*it).leaf = option::None;\n+                    it.leaf = option::None;\n                     return option::None\n                 } else {\n                     let range =\n@@ -1342,11 +1341,11 @@ mod tests {\n         assert!(rope_to_string(r) == *sample);\n \n         let mut string_iter = 0u;\n-        let string_len  = str::len(*sample);\n-        let rope_iter   = iterator::char::start(r);\n-        let mut equal   = true;\n+        let string_len = str::len(*sample);\n+        let mut rope_iter = iterator::char::start(r);\n+        let mut equal = true;\n         while equal {\n-            match (node::char_iterator::next(&rope_iter)) {\n+            match (node::char_iterator::next(&mut rope_iter)) {\n               option::None => {\n                 if string_iter < string_len {\n                     equal = false;\n@@ -1376,9 +1375,9 @@ mod tests {\n         let r      = of_str(sample);\n \n         let mut len = 0u;\n-        let it  = iterator::char::start(r);\n+        let mut it  = iterator::char::start(r);\n         loop {\n-            match (node::char_iterator::next(&it)) {\n+            match (node::char_iterator::next(&mut it)) {\n               option::None => break,\n               option::Some(_) => len += 1u\n             }"}, {"sha": "f5f7f5e326a792157cefceaea295a5c36d2b25f5", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 114, "deletions": 116, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa", "patch": "@@ -283,134 +283,132 @@ mod tests {\n \n     #[test]\n     pub fn test() {\n-        unsafe {\n-            struct Test {\n-                input: ~str,\n-                output: ~[u8],\n-                output_str: ~str,\n-            }\n+        struct Test {\n+            input: ~str,\n+            output: ~[u8],\n+            output_str: ~str,\n+        }\n \n-            fn a_million_letter_a() -> ~str {\n-                let mut i = 0;\n-                let mut rs = ~\"\";\n-                while i < 100000 {\n-                    str::push_str(&mut rs, ~\"aaaaaaaaaa\");\n-                    i += 1;\n-                }\n-                return rs;\n+        fn a_million_letter_a() -> ~str {\n+            let mut i = 0;\n+            let mut rs = ~\"\";\n+            while i < 100000 {\n+                str::push_str(&mut rs, ~\"aaaaaaaaaa\");\n+                i += 1;\n             }\n-            // Test messages from FIPS 180-1\n+            return rs;\n+        }\n+        // Test messages from FIPS 180-1\n \n-            let fips_180_1_tests = ~[\n-                Test {\n-                    input: ~\"abc\",\n-                    output: ~[\n-                        0xA9u8, 0x99u8, 0x3Eu8, 0x36u8,\n-                        0x47u8, 0x06u8, 0x81u8, 0x6Au8,\n-                        0xBAu8, 0x3Eu8, 0x25u8, 0x71u8,\n-                        0x78u8, 0x50u8, 0xC2u8, 0x6Cu8,\n-                        0x9Cu8, 0xD0u8, 0xD8u8, 0x9Du8,\n-                    ],\n-                    output_str: ~\"a9993e364706816aba3e25717850c26c9cd0d89d\"\n-                },\n-                Test {\n-                    input:\n-                         ~\"abcdbcdecdefdefgefghfghighij\" +\n-                         ~\"hijkijkljklmklmnlmnomnopnopq\",\n-                    output: ~[\n-                        0x84u8, 0x98u8, 0x3Eu8, 0x44u8,\n-                        0x1Cu8, 0x3Bu8, 0xD2u8, 0x6Eu8,\n-                        0xBAu8, 0xAEu8, 0x4Au8, 0xA1u8,\n-                        0xF9u8, 0x51u8, 0x29u8, 0xE5u8,\n-                        0xE5u8, 0x46u8, 0x70u8, 0xF1u8,\n-                    ],\n-                    output_str: ~\"84983e441c3bd26ebaae4aa1f95129e5e54670f1\"\n-                },\n-                Test {\n-                    input: a_million_letter_a(),\n-                    output: ~[\n-                        0x34u8, 0xAAu8, 0x97u8, 0x3Cu8,\n-                        0xD4u8, 0xC4u8, 0xDAu8, 0xA4u8,\n-                        0xF6u8, 0x1Eu8, 0xEBu8, 0x2Bu8,\n-                        0xDBu8, 0xADu8, 0x27u8, 0x31u8,\n-                        0x65u8, 0x34u8, 0x01u8, 0x6Fu8,\n-                    ],\n-                    output_str: ~\"34aa973cd4c4daa4f61eeb2bdbad27316534016f\"\n-                },\n-            ];\n-            // Examples from wikipedia\n+        let fips_180_1_tests = ~[\n+            Test {\n+                input: ~\"abc\",\n+                output: ~[\n+                    0xA9u8, 0x99u8, 0x3Eu8, 0x36u8,\n+                    0x47u8, 0x06u8, 0x81u8, 0x6Au8,\n+                    0xBAu8, 0x3Eu8, 0x25u8, 0x71u8,\n+                    0x78u8, 0x50u8, 0xC2u8, 0x6Cu8,\n+                    0x9Cu8, 0xD0u8, 0xD8u8, 0x9Du8,\n+                ],\n+                output_str: ~\"a9993e364706816aba3e25717850c26c9cd0d89d\"\n+            },\n+            Test {\n+                input:\n+                     ~\"abcdbcdecdefdefgefghfghighij\" +\n+                     ~\"hijkijkljklmklmnlmnomnopnopq\",\n+                output: ~[\n+                    0x84u8, 0x98u8, 0x3Eu8, 0x44u8,\n+                    0x1Cu8, 0x3Bu8, 0xD2u8, 0x6Eu8,\n+                    0xBAu8, 0xAEu8, 0x4Au8, 0xA1u8,\n+                    0xF9u8, 0x51u8, 0x29u8, 0xE5u8,\n+                    0xE5u8, 0x46u8, 0x70u8, 0xF1u8,\n+                ],\n+                output_str: ~\"84983e441c3bd26ebaae4aa1f95129e5e54670f1\"\n+            },\n+            Test {\n+                input: a_million_letter_a(),\n+                output: ~[\n+                    0x34u8, 0xAAu8, 0x97u8, 0x3Cu8,\n+                    0xD4u8, 0xC4u8, 0xDAu8, 0xA4u8,\n+                    0xF6u8, 0x1Eu8, 0xEBu8, 0x2Bu8,\n+                    0xDBu8, 0xADu8, 0x27u8, 0x31u8,\n+                    0x65u8, 0x34u8, 0x01u8, 0x6Fu8,\n+                ],\n+                output_str: ~\"34aa973cd4c4daa4f61eeb2bdbad27316534016f\"\n+            },\n+        ];\n+        // Examples from wikipedia\n \n-            let wikipedia_tests = ~[\n-                Test {\n-                    input: ~\"The quick brown fox jumps over the lazy dog\",\n-                    output: ~[\n-                        0x2fu8, 0xd4u8, 0xe1u8, 0xc6u8,\n-                        0x7au8, 0x2du8, 0x28u8, 0xfcu8,\n-                        0xedu8, 0x84u8, 0x9eu8, 0xe1u8,\n-                        0xbbu8, 0x76u8, 0xe7u8, 0x39u8,\n-                        0x1bu8, 0x93u8, 0xebu8, 0x12u8,\n-                    ],\n-                    output_str: ~\"2fd4e1c67a2d28fced849ee1bb76e7391b93eb12\",\n-                },\n-                Test {\n-                    input: ~\"The quick brown fox jumps over the lazy cog\",\n-                    output: ~[\n-                        0xdeu8, 0x9fu8, 0x2cu8, 0x7fu8,\n-                        0xd2u8, 0x5eu8, 0x1bu8, 0x3au8,\n-                        0xfau8, 0xd3u8, 0xe8u8, 0x5au8,\n-                        0x0bu8, 0xd1u8, 0x7du8, 0x9bu8,\n-                        0x10u8, 0x0du8, 0xb4u8, 0xb3u8,\n-                    ],\n-                    output_str: ~\"de9f2c7fd25e1b3afad3e85a0bd17d9b100db4b3\",\n-                },\n-            ];\n-            let tests = fips_180_1_tests + wikipedia_tests;\n-            fn check_vec_eq(v0: ~[u8], v1: ~[u8]) {\n-                assert!((vec::len::<u8>(v0) == vec::len::<u8>(v1)));\n-                let len = vec::len::<u8>(v0);\n-                let mut i = 0u;\n-                while i < len {\n-                    let a = v0[i];\n-                    let b = v1[i];\n-                    assert!((a == b));\n-                    i += 1u;\n-                }\n+        let wikipedia_tests = ~[\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog\",\n+                output: ~[\n+                    0x2fu8, 0xd4u8, 0xe1u8, 0xc6u8,\n+                    0x7au8, 0x2du8, 0x28u8, 0xfcu8,\n+                    0xedu8, 0x84u8, 0x9eu8, 0xe1u8,\n+                    0xbbu8, 0x76u8, 0xe7u8, 0x39u8,\n+                    0x1bu8, 0x93u8, 0xebu8, 0x12u8,\n+                ],\n+                output_str: ~\"2fd4e1c67a2d28fced849ee1bb76e7391b93eb12\",\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy cog\",\n+                output: ~[\n+                    0xdeu8, 0x9fu8, 0x2cu8, 0x7fu8,\n+                    0xd2u8, 0x5eu8, 0x1bu8, 0x3au8,\n+                    0xfau8, 0xd3u8, 0xe8u8, 0x5au8,\n+                    0x0bu8, 0xd1u8, 0x7du8, 0x9bu8,\n+                    0x10u8, 0x0du8, 0xb4u8, 0xb3u8,\n+                ],\n+                output_str: ~\"de9f2c7fd25e1b3afad3e85a0bd17d9b100db4b3\",\n+            },\n+        ];\n+        let tests = fips_180_1_tests + wikipedia_tests;\n+        fn check_vec_eq(v0: ~[u8], v1: ~[u8]) {\n+            assert!((vec::len::<u8>(v0) == vec::len::<u8>(v1)));\n+            let len = vec::len::<u8>(v0);\n+            let mut i = 0u;\n+            while i < len {\n+                let a = v0[i];\n+                let b = v1[i];\n+                assert!((a == b));\n+                i += 1u;\n             }\n-            // Test that it works when accepting the message all at once\n+        }\n+        // Test that it works when accepting the message all at once\n \n-            let mut sh = sha1::sha1();\n-            for vec::each(tests) |t| {\n-                sh.input_str(t.input);\n-                let out = sh.result();\n-                check_vec_eq(t.output, out);\n+        let mut sh = sha1::sha1();\n+        for vec::each(tests) |t| {\n+            sh.input_str(t.input);\n+            let out = sh.result();\n+            check_vec_eq(t.output, out);\n \n-                let out_str = sh.result_str();\n-                assert!((out_str.len() == 40));\n-                assert!((out_str == t.output_str));\n+            let out_str = sh.result_str();\n+            assert!((out_str.len() == 40));\n+            assert!((out_str == t.output_str));\n \n-                sh.reset();\n-            }\n+            sh.reset();\n+        }\n \n \n-            // Test that it works when accepting the message in pieces\n-            for vec::each(tests) |t| {\n-                let len = str::len(t.input);\n-                let mut left = len;\n-                while left > 0u {\n-                    let take = (left + 1u) / 2u;\n-                    sh.input_str(str::slice(t.input, len - left,\n-                                 take + len - left).to_owned());\n-                    left = left - take;\n-                }\n-                let out = sh.result();\n-                check_vec_eq(t.output, out);\n+        // Test that it works when accepting the message in pieces\n+        for vec::each(tests) |t| {\n+            let len = str::len(t.input);\n+            let mut left = len;\n+            while left > 0u {\n+                let take = (left + 1u) / 2u;\n+                sh.input_str(str::slice(t.input, len - left,\n+                             take + len - left).to_owned());\n+                left = left - take;\n+            }\n+            let out = sh.result();\n+            check_vec_eq(t.output, out);\n \n-                let out_str = sh.result_str();\n-                assert!((out_str.len() == 40));\n-                assert!((out_str == t.output_str));\n+            let out_str = sh.result_str();\n+            assert!((out_str.len() == 40));\n+            assert!((out_str == t.output_str));\n \n-                sh.reset();\n-            }\n+            sh.reset();\n         }\n     }\n }"}, {"sha": "39ca9bb5ba66fee2e17ddc4765fc54f99115b703", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa", "patch": "@@ -27,7 +27,7 @@ type Le<'self, T> = &'self fn(v1: &T, v2: &T) -> bool;\n pub fn merge_sort<T:Copy>(v: &const [T], le: Le<T>) -> ~[T] {\n     type Slice = (uint, uint);\n \n-    unsafe {return merge_sort_(v, (0u, len(v)), le);}\n+    return merge_sort_(v, (0u, len(v)), le);\n \n     fn merge_sort_<T:Copy>(v: &const [T], slice: Slice, le: Le<T>)\n         -> ~[T] {\n@@ -68,14 +68,11 @@ fn part<T>(arr: &mut [T], left: uint,\n     let mut storage_index: uint = left;\n     let mut i: uint = left;\n     while i < right {\n-        // XXX: Unsafe because borrow check doesn't handle this right\n-        unsafe {\n-            let a: &T = cast::transmute(&mut arr[i]);\n-            let b: &T = cast::transmute(&mut arr[right]);\n-            if compare_func(a, b) {\n-                arr[i] <-> arr[storage_index];\n-                storage_index += 1;\n-            }\n+        let a: &mut T = &mut arr[i];\n+        let b: &mut T = &mut arr[right];\n+        if compare_func(a, b) {\n+            arr[i] <-> arr[storage_index];\n+            storage_index += 1;\n         }\n         i += 1;\n     }\n@@ -888,12 +885,9 @@ mod tests {\n         // tjc: funny that we have to use parens\n         fn ile(x: &(&'static str), y: &(&'static str)) -> bool\n         {\n-            unsafe // to_lower is not pure...\n-            {\n-                let x = x.to_lower();\n-                let y = y.to_lower();\n-                x <= y\n-            }\n+            let x = x.to_lower();\n+            let y = y.to_lower();\n+            x <= y\n         }\n \n         let names1 = ~[\"joe bob\", \"Joe Bob\", \"Jack Brown\", \"JOE Bob\",\n@@ -921,10 +915,8 @@ mod test_tim_sort {\n \n     impl Ord for CVal {\n         fn lt(&self, other: &CVal) -> bool {\n-            unsafe {\n-                let rng = rand::Rng();\n-                if rng.gen_float() > 0.995 { fail!(~\"It's happening!!!\"); }\n-            }\n+            let rng = rand::Rng();\n+            if rng.gen_float() > 0.995 { fail!(~\"It's happening!!!\"); }\n             (*self).val < other.val\n         }\n         fn le(&self, other: &CVal) -> bool { (*self).val <= other.val }"}, {"sha": "1bfdd7f99d501c0ceafaf9a8f2fdc0e24d02455b", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa", "patch": "@@ -72,7 +72,7 @@ fn broadcast_waitqueue(q: &Waitqueue) -> uint {\n // The building-block used to make semaphores, mutexes, and rwlocks.\n #[doc(hidden)]\n struct SemInner<Q> {\n-    mut count: int,\n+    count: int,\n     waiters:   Waitqueue,\n     // Can be either unit or another waitqueue. Some sems shouldn't come with\n     // a condition variable attached, others should.\n@@ -729,7 +729,6 @@ mod tests {\n \n     use core::cast;\n     use core::cell::Cell;\n-    use core::option;\n     use core::ptr;\n     use core::result;\n     use core::task;"}, {"sha": "3f2772942a5cb60187f18fbda6f91949ab5b5a6a", "filename": "src/libstd/task_pool.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibstd%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibstd%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask_pool.rs?ref=30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa", "patch": "@@ -26,8 +26,7 @@ enum Msg<T> {\n \n pub struct TaskPool<T> {\n     channels: ~[Chan<Msg<T>>],\n-    mut next_index: uint,\n-\n+    next_index: uint,\n }\n \n #[unsafe_destructor]\n@@ -84,7 +83,7 @@ pub impl<T> TaskPool<T> {\n \n     /// Executes the function `f` on a task in the pool. The function\n     /// receives a reference to the local data returned by the `init_fn`.\n-    fn execute(&self, f: ~fn(&T)) {\n+    fn execute(&mut self, f: ~fn(&T)) {\n         self.channels[self.next_index].send(Execute(f));\n         self.next_index += 1;\n         if self.next_index == self.channels.len() { self.next_index = 0; }\n@@ -97,7 +96,7 @@ fn test_task_pool() {\n         let g: ~fn(uint) -> uint = |i| i;\n         g\n     };\n-    let pool = TaskPool::new(4, Some(SingleThreaded), f);\n+    let mut pool = TaskPool::new(4, Some(SingleThreaded), f);\n     for 8.times {\n         pool.execute(|i| io::println(fmt!(\"Hello from thread %u!\", *i)));\n     }"}, {"sha": "04fa319b25530f2dc4ba5be6394c24ab9397d7ba", "filename": "src/libstd/test.rs", "status": "modified", "additions": 32, "deletions": 29, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa", "patch": "@@ -201,19 +201,19 @@ struct ConsoleTestState {\n     out: @io::Writer,\n     log_out: Option<@io::Writer>,\n     use_color: bool,\n-    mut total: uint,\n-    mut passed: uint,\n-    mut failed: uint,\n-    mut ignored: uint,\n-    mut benchmarked: uint,\n-    mut failures: ~[TestDesc]\n+    total: uint,\n+    passed: uint,\n+    failed: uint,\n+    ignored: uint,\n+    benchmarked: uint,\n+    failures: ~[TestDesc]\n }\n \n // A simple console test runner\n pub fn run_tests_console(opts: &TestOpts,\n                          tests: ~[TestDescAndFn]) -> bool {\n \n-    fn callback(event: &TestEvent, st: @ConsoleTestState) {\n+    fn callback(event: &TestEvent, st: &mut ConsoleTestState) {\n         debug!(\"callback(event=%?)\", event);\n         match *event {\n           TeFiltered(ref filtered_tests) => {\n@@ -268,16 +268,16 @@ pub fn run_tests_console(opts: &TestOpts,\n         None => None\n     };\n \n-    let st = @ConsoleTestState {\n+    let st = @mut ConsoleTestState {\n         out: io::stdout(),\n         log_out: log_out,\n         use_color: use_color(),\n-        mut total: 0u,\n-        mut passed: 0u,\n-        mut failed: 0u,\n-        mut ignored: 0u,\n-        mut benchmarked: 0u,\n-        mut failures: ~[]\n+        total: 0u,\n+        passed: 0u,\n+        failed: 0u,\n+        ignored: 0u,\n+        benchmarked: 0u,\n+        failures: ~[]\n     };\n \n     run_tests(opts, tests, |x| callback(&x, st));\n@@ -290,15 +290,18 @@ pub fn run_tests_console(opts: &TestOpts,\n         print_failures(st);\n     }\n \n-    st.out.write_str(fmt!(\"\\nresult: \"));\n-    if success {\n-        // There's no parallelism at this point so it's safe to use color\n-        write_ok(st.out, true);\n-    } else {\n-        write_failed(st.out, true);\n+    {\n+      let st: &mut ConsoleTestState = st;\n+      st.out.write_str(fmt!(\"\\nresult: \"));\n+      if success {\n+          // There's no parallelism at this point so it's safe to use color\n+          write_ok(st.out, true);\n+      } else {\n+          write_failed(st.out, true);\n+      }\n+      st.out.write_str(fmt!(\". %u passed; %u failed; %u ignored\\n\\n\",\n+                            st.passed, st.failed, st.ignored));\n     }\n-    st.out.write_str(fmt!(\". %u passed; %u failed; %u ignored\\n\\n\",\n-                          st.passed, st.failed, st.ignored));\n \n     return success;\n \n@@ -356,7 +359,7 @@ pub fn run_tests_console(opts: &TestOpts,\n     }\n }\n \n-fn print_failures(st: @ConsoleTestState) {\n+fn print_failures(st: &ConsoleTestState) {\n     st.out.write_line(~\"\\nfailures:\");\n     let mut failures = ~[];\n     for uint::range(0, vec::uniq_len(&const st.failures)) |i| {\n@@ -390,12 +393,12 @@ fn should_sort_failures_before_printing_them() {\n             out: wr,\n             log_out: option::None,\n             use_color: false,\n-            mut total: 0u,\n-            mut passed: 0u,\n-            mut failed: 0u,\n-            mut ignored: 0u,\n-            mut benchmarked: 0u,\n-            mut failures: ~[test_b, test_a]\n+            total: 0u,\n+            passed: 0u,\n+            failed: 0u,\n+            ignored: 0u,\n+            benchmarked: 0u,\n+            failures: ~[test_b, test_a]\n         };\n \n         print_failures(st);"}, {"sha": "adfa12594aac152525ee1d757ca52f192dddeb4a", "filename": "src/libstd/time.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa", "patch": "@@ -176,16 +176,12 @@ pub fn now() -> Tm {\n \n /// Parses the time from the string according to the format string.\n pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n-    // unsafe only because do_strptime is annoying to make pure\n-    // (it does IO with a str_reader)\n-    unsafe {do_strptime(s, format)}\n+    do_strptime(s, format)\n }\n \n /// Formats the time according to the format string.\n pub fn strftime(format: &str, tm: &Tm) -> ~str {\n-    // unsafe only because do_strftime is annoying to make pure\n-    // (it does IO with a str_reader)\n-    unsafe { do_strftime(format, tm) }\n+    do_strftime(format, tm)\n }\n \n pub impl Tm {"}, {"sha": "fc08073686d0d0fa0eb3356fdf8f4d9808b60a75", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa", "patch": "@@ -252,15 +252,13 @@ pub impl FileMap {\n \n     // get a line from the list of pre-computed line-beginnings\n     pub fn get_line(&self, line: int) -> ~str {\n-        unsafe {\n-            let begin: BytePos = self.lines[line] - self.start_pos;\n-            let begin = begin.to_uint();\n-            let end = match str::find_char_from(*self.src, '\\n', begin) {\n-                Some(e) => e,\n-                None => str::len(*self.src)\n-            };\n-            str::slice(*self.src, begin, end).to_owned()\n-        }\n+        let begin: BytePos = self.lines[line] - self.start_pos;\n+        let begin = begin.to_uint();\n+        let end = match str::find_char_from(*self.src, '\\n', begin) {\n+            Some(e) => e,\n+            None => str::len(*self.src)\n+        };\n+        str::slice(*self.src, begin, end).to_owned()\n     }\n \n     pub fn record_multibyte_char(&self, pos: BytePos, bytes: uint) {"}, {"sha": "59e4dddc73be9640892944ab2df09f428b4b545e", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=30dbbe17c9189fed32d0f5f332b4f6ff8f7cc4aa", "patch": "@@ -175,12 +175,10 @@ fn byte_offset(rdr: @mut StringReader) -> BytePos {\n }\n \n pub fn get_str_from(rdr: @mut StringReader, start: BytePos) -> ~str {\n-    unsafe {\n-        // I'm pretty skeptical about this subtraction. What if there's a\n-        // multi-byte character before the mark?\n-        return str::slice(*rdr.src, start.to_uint() - 1u,\n-                          byte_offset(rdr).to_uint() - 1u).to_owned();\n-    }\n+    // I'm pretty skeptical about this subtraction. What if there's a\n+    // multi-byte character before the mark?\n+    return str::slice(*rdr.src, start.to_uint() - 1u,\n+                      byte_offset(rdr).to_uint() - 1u).to_owned();\n }\n \n // EFFECT: advance the StringReader by one character. If a newline is"}]}