{"sha": "b490a4077cbb2d3c4038fecfd913a0049027d8e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0OTBhNDA3N2NiYjJkM2M0MDM4ZmVjZmQ5MTNhMDA0OTAyN2Q4ZTU=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2017-01-29T11:27:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-01-29T11:27:29Z"}, "message": "Merge pull request #103 from oli-obk/tuples\n\nallow using tuple variant names as function handles", "tree": {"sha": "818f01dbc8b3ed16f5b6361f1418a0c24b1f04a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/818f01dbc8b3ed16f5b6361f1418a0c24b1f04a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b490a4077cbb2d3c4038fecfd913a0049027d8e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b490a4077cbb2d3c4038fecfd913a0049027d8e5", "html_url": "https://github.com/rust-lang/rust/commit/b490a4077cbb2d3c4038fecfd913a0049027d8e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b490a4077cbb2d3c4038fecfd913a0049027d8e5/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc336eecacfcba7a38fac97127313add69a369d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc336eecacfcba7a38fac97127313add69a369d8", "html_url": "https://github.com/rust-lang/rust/commit/dc336eecacfcba7a38fac97127313add69a369d8"}, {"sha": "ce95ae592742517df40498b288938570c877e706", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce95ae592742517df40498b288938570c877e706", "html_url": "https://github.com/rust-lang/rust/commit/ce95ae592742517df40498b288938570c877e706"}], "stats": {"total": 188, "additions": 155, "deletions": 33}, "files": [{"sha": "eb7db8b354edb5bb07bfeaf4ee3d9cb3c25567e3", "filename": "src/bin/miri.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b490a4077cbb2d3c4038fecfd913a0049027d8e5/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b490a4077cbb2d3c4038fecfd913a0049027d8e5/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=b490a4077cbb2d3c4038fecfd913a0049027d8e5", "patch": "@@ -8,7 +8,7 @@ extern crate rustc_errors;\n extern crate env_logger;\n extern crate log_settings;\n extern crate syntax;\n-#[macro_use] extern crate log;\n+extern crate log;\n \n use rustc::session::Session;\n use rustc_driver::{Compilation, CompilerCalls, RustcDefaultCalls};"}, {"sha": "ce44e34f9ed9e0c102509b1ed1da6098d1b61e8d", "filename": "src/eval_context.rs", "status": "modified", "additions": 72, "deletions": 22, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/b490a4077cbb2d3c4038fecfd913a0049027d8e5/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b490a4077cbb2d3c4038fecfd913a0049027d8e5/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=b490a4077cbb2d3c4038fecfd913a0049027d8e5", "patch": "@@ -223,7 +223,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     pub fn monomorphize(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n-        let substituted = ty.subst(self.tcx, substs);\n+        // miri doesn't care about lifetimes, and will choke on some crazy ones\n+        // let's simply get rid of them\n+        let without_lifetimes = self.tcx.erase_regions(&ty);\n+        let substituted = without_lifetimes.subst(self.tcx, substs);\n         self.tcx.normalize_associated_type(&substituted)\n     }\n \n@@ -355,18 +358,44 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(())\n     }\n \n-    fn assign_fields<I: IntoIterator<Item = u64>>(\n+    pub fn assign_discr_and_fields<\n+        I: IntoIterator<Item = u64>,\n+        V: IntoValTyPair<'tcx>,\n+        J: IntoIterator<Item = V>,\n+    >(\n         &mut self,\n         dest: Lvalue<'tcx>,\n         offsets: I,\n-        operands: &[mir::Operand<'tcx>],\n+        operands: J,\n+        discr_val: u128,\n+        discr_size: u64,\n+    ) -> EvalResult<'tcx, ()> {\n+        // FIXME(solson)\n+        let dest_ptr = self.force_allocation(dest)?.to_ptr();\n+\n+        let mut offsets = offsets.into_iter();\n+        let discr_offset = offsets.next().unwrap();\n+        let discr_dest = dest_ptr.offset(discr_offset);\n+        self.memory.write_uint(discr_dest, discr_val, discr_size)?;\n+\n+        self.assign_fields(dest, offsets, operands)\n+    }\n+\n+    pub fn assign_fields<\n+        I: IntoIterator<Item = u64>,\n+        V: IntoValTyPair<'tcx>,\n+        J: IntoIterator<Item = V>,\n+    >(\n+        &mut self,\n+        dest: Lvalue<'tcx>,\n+        offsets: I,\n+        operands: J,\n     ) -> EvalResult<'tcx, ()> {\n         // FIXME(solson)\n         let dest = self.force_allocation(dest)?.to_ptr();\n \n         for (offset, operand) in offsets.into_iter().zip(operands) {\n-            let value = self.eval_operand(operand)?;\n-            let value_ty = self.operand_ty(operand);\n+            let (value, value_ty) = operand.into_val_ty_pair(self)?;\n             let field_dest = dest.offset(offset);\n             self.write_value_to_ptr(value, field_dest, value_ty)?;\n         }\n@@ -431,18 +460,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         if let mir::AggregateKind::Adt(adt_def, variant, _, _) = *kind {\n                             let discr_val = adt_def.variants[variant].disr_val.to_u128_unchecked();\n                             let discr_size = discr.size().bytes();\n-                            let discr_offset = variants[variant].offsets[0].bytes();\n \n-                            // FIXME(solson)\n-                            let dest = self.force_allocation(dest)?;\n-                            let discr_dest = (dest.to_ptr()).offset(discr_offset);\n-\n-                            self.memory.write_uint(discr_dest, discr_val, discr_size)?;\n-\n-                            // Don't include the first offset; it's for the discriminant.\n-                            let field_offsets = variants[variant].offsets.iter().skip(1)\n-                                .map(|s| s.bytes());\n-                            self.assign_fields(dest, field_offsets, operands)?;\n+                            self.assign_discr_and_fields(\n+                                dest,\n+                                variants[variant].offsets.iter().cloned().map(Size::bytes),\n+                                operands,\n+                                discr_val,\n+                                discr_size,\n+                            )?;\n                         } else {\n                             bug!(\"tried to assign {:?} to Layout::General\", kind);\n                         }\n@@ -660,22 +685,25 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let path = discrfield.iter().skip(2).map(|&i| i as usize);\n \n         // Handle the field index for the outer non-null variant.\n-        let inner_ty = match ty.sty {\n+        let (inner_offset, inner_ty) = match ty.sty {\n             ty::TyAdt(adt_def, substs) => {\n                 let variant = &adt_def.variants[nndiscr as usize];\n                 let index = discrfield[1];\n                 let field = &variant.fields[index as usize];\n-                field.ty(self.tcx, substs)\n+                (self.get_field_offset(ty, index as usize)?, field.ty(self.tcx, substs))\n             }\n             _ => bug!(\"non-enum for StructWrappedNullablePointer: {}\", ty),\n         };\n \n-        self.field_path_offset_and_ty(inner_ty, path)\n+        self.field_path_offset_and_ty(inner_offset, inner_ty, path)\n     }\n \n-    fn field_path_offset_and_ty<I: Iterator<Item = usize>>(&self, mut ty: Ty<'tcx>, path: I) -> EvalResult<'tcx, (Size, Ty<'tcx>)> {\n-        let mut offset = Size::from_bytes(0);\n-\n+    fn field_path_offset_and_ty<I: Iterator<Item = usize>>(\n+        &self,\n+        mut offset: Size,\n+        mut ty: Ty<'tcx>,\n+        path: I,\n+    ) -> EvalResult<'tcx, (Size, Ty<'tcx>)> {\n         // Skip the initial 0 intended for LLVM GEP.\n         for field_index in path {\n             let field_offset = self.get_field_offset(ty, field_index)?;\n@@ -722,6 +750,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let bytes = field_index as u64 * self.memory.pointer_size();\n                 Ok(Size::from_bytes(bytes))\n             }\n+            StructWrappedNullablePointer { ref nonnull, .. } => {\n+                Ok(nonnull.offsets[field_index])\n+            }\n             _ => {\n                 let msg = format!(\"can't handle type: {:?}, with layout: {:?}\", ty, layout);\n                 Err(EvalError::Unimplemented(msg))\n@@ -736,6 +767,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         match *layout {\n             Univariant { ref variant, .. } => Ok(variant.offsets.len()),\n             FatPointer { .. } => Ok(2),\n+            StructWrappedNullablePointer { ref nonnull, .. } => Ok(nonnull.offsets.len()),\n             _ => {\n                 let msg = format!(\"can't handle type: {:?}, with layout: {:?}\", ty, layout);\n                 Err(EvalError::Unimplemented(msg))\n@@ -1464,3 +1496,21 @@ pub fn monomorphize_field_ty<'a, 'tcx:'a >(tcx: TyCtxt<'a, 'tcx, 'tcx>, f: &ty::\n pub fn is_inhabited<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n     ty.uninhabited_from(&mut FxHashSet::default(), tcx).is_empty()\n }\n+\n+pub trait IntoValTyPair<'tcx> {\n+    fn into_val_ty_pair<'a>(self, ecx: &mut EvalContext<'a, 'tcx>) -> EvalResult<'tcx, (Value, Ty<'tcx>)> where 'tcx: 'a;\n+}\n+\n+impl<'tcx> IntoValTyPair<'tcx> for (Value, Ty<'tcx>) {\n+    fn into_val_ty_pair<'a>(self, _: &mut EvalContext<'a, 'tcx>) -> EvalResult<'tcx, (Value, Ty<'tcx>)> where 'tcx: 'a {\n+        Ok(self)\n+    }\n+}\n+\n+impl<'b, 'tcx: 'b> IntoValTyPair<'tcx> for &'b mir::Operand<'tcx> {\n+    fn into_val_ty_pair<'a>(self, ecx: &mut EvalContext<'a, 'tcx>) -> EvalResult<'tcx, (Value, Ty<'tcx>)> where 'tcx: 'a {\n+        let value = ecx.eval_operand(self)?;\n+        let value_ty = ecx.operand_ty(self);\n+        Ok((value, value_ty))\n+    }\n+}"}, {"sha": "b2124486f4918a0c9d53d11d056f0d7a49450bea", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 42, "deletions": 10, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/b490a4077cbb2d3c4038fecfd913a0049027d8e5/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b490a4077cbb2d3c4038fecfd913a0049027d8e5/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=b490a4077cbb2d3c4038fecfd913a0049027d8e5", "patch": "@@ -2,7 +2,7 @@ use rustc::hir::def_id::DefId;\n use rustc::mir;\n use rustc::traits::{self, Reveal};\n use rustc::ty::fold::TypeFoldable;\n-use rustc::ty::layout::Layout;\n+use rustc::ty::layout::{Layout, Size};\n use rustc::ty::subst::{Substs, Kind};\n use rustc::ty::{self, Ty, TyCtxt, BareFnTy};\n use syntax::codemap::{DUMMY_SP, Span};\n@@ -238,20 +238,51 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         let (lvalue, target) = destination.expect(\"tuple struct constructors can't diverge\");\n                         let dest_ty = self.tcx.item_type(adt_def.did);\n                         let dest_layout = self.type_layout(dest_ty)?;\n+                        trace!(\"layout({:?}) = {:#?}\", dest_ty, dest_layout);\n                         match *dest_layout {\n                             Layout::Univariant { ref variant, .. } => {\n-                                assert_eq!(v.disr_val.to_u128_unchecked(), 0);\n+                                let disr_val = v.disr_val.to_u128_unchecked();\n+                                assert_eq!(disr_val, 0);\n                                 let offsets = variant.offsets.iter().map(|s| s.bytes());\n \n-                                // FIXME: don't allocate for single or dual field structs\n-                                let dest = self.force_allocation(lvalue)?.to_ptr();\n-\n-                                for (offset, (value, value_ty)) in offsets.into_iter().zip(args) {\n-                                    let field_dest = dest.offset(offset);\n-                                    self.write_value_to_ptr(value, field_dest, value_ty)?;\n+                                self.assign_fields(lvalue, offsets, args)?;\n+                            },\n+                            Layout::General { discr, ref variants, .. } => {\n+                                let disr_val = v.disr_val.to_u128_unchecked();\n+                                let discr_size = discr.size().bytes();\n+                                self.assign_discr_and_fields(\n+                                    lvalue,\n+                                    variants[disr_val as usize].offsets.iter().cloned().map(Size::bytes),\n+                                    args,\n+                                    disr_val,\n+                                    discr_size,\n+                                )?;\n+                            },\n+                            Layout::StructWrappedNullablePointer { nndiscr, ref nonnull, ref discrfield, .. } => {\n+                                let disr_val = v.disr_val.to_u128_unchecked();\n+                                if nndiscr as u128 == disr_val {\n+                                    let offsets = nonnull.offsets.iter().map(|s| s.bytes());\n+                                    self.assign_fields(lvalue, offsets, args)?;\n+                                } else {\n+                                    for (_, ty) in args {\n+                                        assert_eq!(self.type_size(ty)?, Some(0));\n+                                    }\n+                                    let (offset, ty) = self.nonnull_offset_and_ty(dest_ty, nndiscr, discrfield)?;\n+\n+                                    // FIXME(solson)\n+                                    let dest = self.force_allocation(lvalue)?.to_ptr();\n+\n+                                    let dest = dest.offset(offset.bytes());\n+                                    let dest_size = self.type_size(ty)?\n+                                        .expect(\"bad StructWrappedNullablePointer discrfield\");\n+                                    self.memory.write_int(dest, 0, dest_size)?;\n                                 }\n                             },\n-                            // FIXME: enum variant constructors\n+                            Layout::RawNullablePointer { .. } => {\n+                                assert_eq!(args.len(), 1);\n+                                let (val, ty) = args.pop().unwrap();\n+                                self.write_value(val, lvalue, ty)?;\n+                            },\n                             _ => bug!(\"bad layout for tuple struct constructor: {:?}\", dest_layout),\n                         }\n                         self.goto_block(target);\n@@ -295,7 +326,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     fn read_discriminant_value(&self, adt_ptr: Pointer, adt_ty: Ty<'tcx>) -> EvalResult<'tcx, u128> {\n         use rustc::ty::layout::Layout::*;\n         let adt_layout = self.type_layout(adt_ty)?;\n-        trace!(\"read_discriminant_value {:?}\", adt_layout);\n+        trace!(\"read_discriminant_value {:#?}\", adt_layout);\n \n         let discr_val = match *adt_layout {\n             General { discr, .. } | CEnum { discr, signed: false, .. } => {\n@@ -332,6 +363,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     fn read_nonnull_discriminant_value(&self, ptr: Pointer, nndiscr: u128, discr_size: u64) -> EvalResult<'tcx, u128> {\n+        trace!(\"read_nonnull_discriminant_value: {:?}, {}, {}\", ptr, nndiscr, discr_size);\n         let not_null = match self.memory.read_uint(ptr, discr_size) {\n             Ok(0) => false,\n             Ok(_) | Err(EvalError::ReadPointerAsBytes) => true,"}, {"sha": "5cf91b3f4d194eb188c8942cbb902709e7674c4c", "filename": "tests/run-pass/tuple_like_enum_variant_constructor.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b490a4077cbb2d3c4038fecfd913a0049027d8e5/tests%2Frun-pass%2Ftuple_like_enum_variant_constructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b490a4077cbb2d3c4038fecfd913a0049027d8e5/tests%2Frun-pass%2Ftuple_like_enum_variant_constructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ftuple_like_enum_variant_constructor.rs?ref=b490a4077cbb2d3c4038fecfd913a0049027d8e5", "patch": "@@ -0,0 +1,3 @@\n+fn main() {\n+    assert_eq!(Some(42).map(Some), Some(Some(42)));\n+}"}, {"sha": "fb57d4f4c1652aa9782c0a713626f098cc11d23b", "filename": "tests/run-pass/tuple_like_enum_variant_constructor_pointer_opt.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b490a4077cbb2d3c4038fecfd913a0049027d8e5/tests%2Frun-pass%2Ftuple_like_enum_variant_constructor_pointer_opt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b490a4077cbb2d3c4038fecfd913a0049027d8e5/tests%2Frun-pass%2Ftuple_like_enum_variant_constructor_pointer_opt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ftuple_like_enum_variant_constructor_pointer_opt.rs?ref=b490a4077cbb2d3c4038fecfd913a0049027d8e5", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    let x = 5;\n+    assert_eq!(Some(&x).map(Some), Some(Some(&x)));\n+}"}, {"sha": "44441ed1d36c88a548ce577949f72e5a75032815", "filename": "tests/run-pass/tuple_like_enum_variant_constructor_struct_pointer_opt.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b490a4077cbb2d3c4038fecfd913a0049027d8e5/tests%2Frun-pass%2Ftuple_like_enum_variant_constructor_struct_pointer_opt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b490a4077cbb2d3c4038fecfd913a0049027d8e5/tests%2Frun-pass%2Ftuple_like_enum_variant_constructor_struct_pointer_opt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ftuple_like_enum_variant_constructor_struct_pointer_opt.rs?ref=b490a4077cbb2d3c4038fecfd913a0049027d8e5", "patch": "@@ -0,0 +1,33 @@\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+struct A<'a> {\n+    x: i32,\n+    y: &'a i32,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+struct B<'a>(i32, &'a i32);\n+\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+enum C<'a> {\n+    Value(i32, &'a i32),\n+    #[allow(dead_code)]\n+    NoValue,\n+}\n+\n+fn main() {\n+    let x = 5;\n+    let a = A { x: 99, y: &x };\n+    assert_eq!(Some(a).map(Some), Some(Some(a)));\n+    let f = B;\n+    assert_eq!(Some(B(42, &x)), Some(f(42, &x)));\n+    // the following doesn't compile :(\n+    //let f: for<'a> fn(i32, &'a i32) -> B<'a> = B;\n+    //assert_eq!(Some(B(42, &x)), Some(f(42, &x)));\n+    assert_eq!(B(42, &x), foo(&x, B));\n+    let f = C::Value;\n+    assert_eq!(C::Value(42, &x), f(42, &x));\n+}\n+\n+fn foo<'a, F: Fn(i32, &'a i32) -> B<'a>>(i: &'a i32, f: F) -> B<'a> {\n+    f(42, i)\n+}"}]}