{"sha": "82b89645fb6ec31138d5788b588ddd7e44c434fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyYjg5NjQ1ZmI2ZWMzMTEzOGQ1Nzg4YjU4OGRkZDdlNDRjNDM0ZmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-13T23:32:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-13T23:32:30Z"}, "message": "Auto merge of #27684 - alexcrichton:remove-deprecated, r=aturon\n\nThis commit removes all unstable and deprecated functions in the standard\r\nlibrary. A release was recently cut (1.3) which makes this a good time for some\r\nspring cleaning of the deprecated functions.", "tree": {"sha": "46903a10262b98e3c864f47c76835336f811675c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46903a10262b98e3c864f47c76835336f811675c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82b89645fb6ec31138d5788b588ddd7e44c434fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82b89645fb6ec31138d5788b588ddd7e44c434fa", "html_url": "https://github.com/rust-lang/rust/commit/82b89645fb6ec31138d5788b588ddd7e44c434fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82b89645fb6ec31138d5788b588ddd7e44c434fa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4066271b77810aec0a4a309f66a45e4f8b940de", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4066271b77810aec0a4a309f66a45e4f8b940de", "html_url": "https://github.com/rust-lang/rust/commit/a4066271b77810aec0a4a309f66a45e4f8b940de"}, {"sha": "8d90d3f36871a00023cc1f313f91e351c287ca15", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d90d3f36871a00023cc1f313f91e351c287ca15", "html_url": "https://github.com/rust-lang/rust/commit/8d90d3f36871a00023cc1f313f91e351c287ca15"}], "stats": {"total": 17213, "additions": 1684, "deletions": 15529}, "files": [{"sha": "2c14741947032ce56ebd4d95737e217e20656cb9", "filename": "src/etc/unicode.py", "status": "modified", "additions": 0, "deletions": 163, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Fetc%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Fetc%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Funicode.py?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -395,46 +395,6 @@ def emit_conversions_module(f, to_upper, to_lower, to_title):\n         is_pub=False, t_type = t_type, pfun=pfun)\n     f.write(\"}\\n\\n\")\n \n-def emit_grapheme_module(f, grapheme_table, grapheme_cats):\n-    f.write(\"\"\"pub mod grapheme {\n-    use core::slice::SliceExt;\n-    pub use self::GraphemeCat::*;\n-    use core::result::Result::{Ok, Err};\n-\n-    #[allow(non_camel_case_types)]\n-    #[derive(Clone, Copy)]\n-    pub enum GraphemeCat {\n-\"\"\")\n-    for cat in grapheme_cats + [\"Any\"]:\n-        f.write(\"        GC_\" + cat + \",\\n\")\n-    f.write(\"\"\"    }\n-\n-    fn bsearch_range_value_table(c: char, r: &'static [(char, char, GraphemeCat)]) -> GraphemeCat {\n-        use core::cmp::Ordering::{Equal, Less, Greater};\n-        match r.binary_search_by(|&(lo, hi, _)| {\n-            if lo <= c && c <= hi { Equal }\n-            else if hi < c { Less }\n-            else { Greater }\n-        }) {\n-            Ok(idx) => {\n-                let (_, _, cat) = r[idx];\n-                cat\n-            }\n-            Err(_) => GC_Any\n-        }\n-    }\n-\n-    pub fn grapheme_category(c: char) -> GraphemeCat {\n-        bsearch_range_value_table(c, grapheme_cat_table)\n-    }\n-\n-\"\"\")\n-\n-    emit_table(f, \"grapheme_cat_table\", grapheme_table, \"&'static [(char, char, GraphemeCat)]\",\n-        pfun=lambda x: \"(%s,%s,GC_%s)\" % (escape_char(x[0]), escape_char(x[1]), x[2]),\n-        is_pub=False)\n-    f.write(\"}\\n\")\n-\n def emit_charwidth_module(f, width_table):\n     f.write(\"pub mod charwidth {\\n\")\n     f.write(\"    use core::option::Option;\\n\")\n@@ -497,79 +457,6 @@ def emit_norm_module(f, canon, compat, combine, norm_props):\n     canon_comp_keys = canon_comp.keys()\n     canon_comp_keys.sort()\n \n-    f.write(\"pub mod normalization {\\n\")\n-\n-    def mkdata_fun(table):\n-        def f(char):\n-            data = \"(%s,&[\" % escape_char(char)\n-            first = True\n-            for d in table[char]:\n-                if not first:\n-                    data += \",\"\n-                first = False\n-                data += escape_char(d)\n-            data += \"])\"\n-            return data\n-        return f\n-\n-    f.write(\"    // Canonical decompositions\\n\")\n-    emit_table(f, \"canonical_table\", canon_keys, \"&'static [(char, &'static [char])]\",\n-        pfun=mkdata_fun(canon))\n-\n-    f.write(\"    // Compatibility decompositions\\n\")\n-    emit_table(f, \"compatibility_table\", compat_keys, \"&'static [(char, &'static [char])]\",\n-        pfun=mkdata_fun(compat))\n-\n-    def comp_pfun(char):\n-        data = \"(%s,&[\" % escape_char(char)\n-        canon_comp[char].sort(lambda x, y: x[0] - y[0])\n-        first = True\n-        for pair in canon_comp[char]:\n-            if not first:\n-                data += \",\"\n-            first = False\n-            data += \"(%s,%s)\" % (escape_char(pair[0]), escape_char(pair[1]))\n-        data += \"])\"\n-        return data\n-\n-    f.write(\"    // Canonical compositions\\n\")\n-    emit_table(f, \"composition_table\", canon_comp_keys,\n-        \"&'static [(char, &'static [(char, char)])]\", pfun=comp_pfun)\n-\n-    f.write(\"\"\"\n-    fn bsearch_range_value_table(c: char, r: &'static [(char, char, u8)]) -> u8 {\n-        use core::cmp::Ordering::{Equal, Less, Greater};\n-        use core::slice::SliceExt;\n-        use core::result::Result::{Ok, Err};\n-        match r.binary_search_by(|&(lo, hi, _)| {\n-            if lo <= c && c <= hi { Equal }\n-            else if hi < c { Less }\n-            else { Greater }\n-        }) {\n-            Ok(idx) => {\n-                let (_, _, result) = r[idx];\n-                result\n-            }\n-            Err(_) => 0\n-        }\n-    }\\n\n-\"\"\")\n-\n-    emit_table(f, \"combining_class_table\", combine, \"&'static [(char, char, u8)]\", is_pub=False,\n-            pfun=lambda x: \"(%s,%s,%s)\" % (escape_char(x[0]), escape_char(x[1]), x[2]))\n-\n-    f.write(\"\"\"    #[deprecated(reason = \"use the crates.io `unicode-normalization` lib instead\",\n-                 since = \"1.0.0\")]\n-    #[unstable(feature = \"unicode\",\n-               reason = \"this functionality will be moved to crates.io\")]\n-    pub fn canonical_combining_class(c: char) -> u8 {\n-        bsearch_range_value_table(c, combining_class_table)\n-    }\n-\n-}\n-\n-\"\"\")\n-\n def remove_from_wtable(wtable, val):\n     wtable_out = []\n     while wtable:\n@@ -649,53 +536,3 @@ def optimize_width_table(wtable):\n         # normalizations and conversions module\n         emit_norm_module(rf, canon_decomp, compat_decomp, combines, norm_props)\n         emit_conversions_module(rf, to_upper, to_lower, to_title)\n-\n-        ### character width module\n-        width_table = []\n-        for zwcat in [\"Me\", \"Mn\", \"Cf\"]:\n-            width_table.extend(map(lambda (lo, hi): (lo, hi, 0, 0), gencats[zwcat]))\n-        width_table.append((4448, 4607, 0, 0))\n-\n-        # get widths, except those that are explicitly marked zero-width above\n-        ea_widths = load_east_asian_width([\"W\", \"F\", \"A\"], [\"Me\", \"Mn\", \"Cf\"])\n-        # these are doublewidth\n-        for dwcat in [\"W\", \"F\"]:\n-            width_table.extend(map(lambda (lo, hi): (lo, hi, 2, 2), ea_widths[dwcat]))\n-        width_table.extend(map(lambda (lo, hi): (lo, hi, 1, 2), ea_widths[\"A\"]))\n-\n-        width_table.sort(key=lambda w: w[0])\n-\n-        # soft hyphen is not zero width in preformatted text; it's used to indicate\n-        # a hyphen inserted to facilitate a linebreak.\n-        width_table = remove_from_wtable(width_table, 173)\n-\n-        # optimize the width table by collapsing adjacent entities when possible\n-        width_table = optimize_width_table(width_table)\n-        emit_charwidth_module(rf, width_table)\n-\n-        ### grapheme cluster module\n-        # from http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Break_Property_Values\n-        grapheme_cats = load_properties(\"auxiliary/GraphemeBreakProperty.txt\", [])\n-\n-        # Control\n-        #  Note 1:\n-        # This category also includes Cs (surrogate codepoints), but Rust's `char`s are\n-        # Unicode Scalar Values only, and surrogates are thus invalid `char`s.\n-        # Thus, we have to remove Cs from the Control category\n-        #  Note 2:\n-        # 0x0a and 0x0d (CR and LF) are not in the Control category for Graphemes.\n-        # However, the Graphemes iterator treats these as a special case, so they\n-        # should be included in grapheme_cats[\"Control\"] for our implementation.\n-        grapheme_cats[\"Control\"] = group_cat(list(\n-            (set(ungroup_cat(grapheme_cats[\"Control\"]))\n-             | set(ungroup_cat(grapheme_cats[\"CR\"]))\n-             | set(ungroup_cat(grapheme_cats[\"LF\"])))\n-            - set(ungroup_cat([surrogate_codepoints]))))\n-        del(grapheme_cats[\"CR\"])\n-        del(grapheme_cats[\"LF\"])\n-\n-        grapheme_table = []\n-        for cat in grapheme_cats:\n-            grapheme_table.extend([(x, y, cat) for (x, y) in grapheme_cats[cat]])\n-        grapheme_table.sort(key=lambda w: w[0])\n-        emit_grapheme_module(rf, grapheme_table, grapheme_cats.keys())"}, {"sha": "09a4f9e0a62b8b30bfded1c38c8b2019cd5316f1", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 50, "deletions": 77, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -272,18 +272,6 @@ impl<T: ?Sized> Arc<T> {\n     }\n }\n \n-/// Get the number of weak references to this value.\n-#[inline]\n-#[unstable(feature = \"arc_counts\")]\n-#[deprecated(since = \"1.2.0\", reason = \"renamed to Arc::weak_count\")]\n-pub fn weak_count<T: ?Sized>(this: &Arc<T>) -> usize { Arc::weak_count(this) }\n-\n-/// Get the number of strong references to this value.\n-#[inline]\n-#[unstable(feature = \"arc_counts\")]\n-#[deprecated(since = \"1.2.0\", reason = \"renamed to Arc::strong_count\")]\n-pub fn strong_count<T: ?Sized>(this: &Arc<T>) -> usize { Arc::strong_count(this) }\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Clone for Arc<T> {\n     /// Makes a clone of the `Arc<T>`.\n@@ -484,13 +472,6 @@ impl<T: ?Sized> Arc<T> {\n     }\n }\n \n-#[inline]\n-#[unstable(feature = \"arc_unique\")]\n-#[deprecated(since = \"1.2\", reason = \"use Arc::get_mut instead\")]\n-pub fn get_mut<T: ?Sized>(this: &mut Arc<T>) -> Option<&mut T> {\n-    Arc::get_mut(this)\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Drop for Arc<T> {\n     /// Drops the `Arc<T>`.\n@@ -860,7 +841,7 @@ mod tests {\n     use std::sync::atomic::Ordering::{Acquire, SeqCst};\n     use std::thread;\n     use std::vec::Vec;\n-    use super::{Arc, Weak, get_mut, weak_count, strong_count};\n+    use super::{Arc, Weak};\n     use std::sync::Mutex;\n \n     struct Canary(*mut atomic::AtomicUsize);\n@@ -898,43 +879,39 @@ mod tests {\n \n     #[test]\n     fn test_arc_get_mut() {\n-        unsafe {\n-            let mut x = Arc::new(3);\n-            *get_mut(&mut x).unwrap() = 4;\n-            assert_eq!(*x, 4);\n-            let y = x.clone();\n-            assert!(get_mut(&mut x).is_none());\n-            drop(y);\n-            assert!(get_mut(&mut x).is_some());\n-            let _w = x.downgrade();\n-            assert!(get_mut(&mut x).is_none());\n-        }\n+        let mut x = Arc::new(3);\n+        *Arc::get_mut(&mut x).unwrap() = 4;\n+        assert_eq!(*x, 4);\n+        let y = x.clone();\n+        assert!(Arc::get_mut(&mut x).is_none());\n+        drop(y);\n+        assert!(Arc::get_mut(&mut x).is_some());\n+        let _w = x.downgrade();\n+        assert!(Arc::get_mut(&mut x).is_none());\n     }\n \n     #[test]\n     fn test_cowarc_clone_make_unique() {\n-        unsafe {\n-            let mut cow0 = Arc::new(75);\n-            let mut cow1 = cow0.clone();\n-            let mut cow2 = cow1.clone();\n-\n-            assert!(75 == *Arc::make_unique(&mut cow0));\n-            assert!(75 == *Arc::make_unique(&mut cow1));\n-            assert!(75 == *Arc::make_unique(&mut cow2));\n-\n-            *Arc::make_unique(&mut cow0) += 1;\n-            *Arc::make_unique(&mut cow1) += 2;\n-            *Arc::make_unique(&mut cow2) += 3;\n-\n-            assert!(76 == *cow0);\n-            assert!(77 == *cow1);\n-            assert!(78 == *cow2);\n-\n-            // none should point to the same backing memory\n-            assert!(*cow0 != *cow1);\n-            assert!(*cow0 != *cow2);\n-            assert!(*cow1 != *cow2);\n-        }\n+        let mut cow0 = Arc::new(75);\n+        let mut cow1 = cow0.clone();\n+        let mut cow2 = cow1.clone();\n+\n+        assert!(75 == *Arc::make_unique(&mut cow0));\n+        assert!(75 == *Arc::make_unique(&mut cow1));\n+        assert!(75 == *Arc::make_unique(&mut cow2));\n+\n+        *Arc::make_unique(&mut cow0) += 1;\n+        *Arc::make_unique(&mut cow1) += 2;\n+        *Arc::make_unique(&mut cow2) += 3;\n+\n+        assert!(76 == *cow0);\n+        assert!(77 == *cow1);\n+        assert!(78 == *cow2);\n+\n+        // none should point to the same backing memory\n+        assert!(*cow0 != *cow1);\n+        assert!(*cow0 != *cow2);\n+        assert!(*cow1 != *cow2);\n     }\n \n     #[test]\n@@ -947,9 +924,7 @@ mod tests {\n         assert!(75 == *cow1);\n         assert!(75 == *cow2);\n \n-        unsafe {\n-            *Arc::make_unique(&mut cow0) += 1;\n-        }\n+        *Arc::make_unique(&mut cow0) += 1;\n \n         assert!(76 == *cow0);\n         assert!(75 == *cow1);\n@@ -970,9 +945,7 @@ mod tests {\n         assert!(75 == *cow0);\n         assert!(75 == *cow1_weak.upgrade().unwrap());\n \n-        unsafe {\n-            *Arc::make_unique(&mut cow0) += 1;\n-        }\n+        *Arc::make_unique(&mut cow0) += 1;\n \n         assert!(76 == *cow0);\n         assert!(cow1_weak.upgrade().is_none());\n@@ -1028,40 +1001,40 @@ mod tests {\n     #[test]\n     fn test_strong_count() {\n         let a = Arc::new(0u32);\n-        assert!(strong_count(&a) == 1);\n+        assert!(Arc::strong_count(&a) == 1);\n         let w = a.downgrade();\n-        assert!(strong_count(&a) == 1);\n+        assert!(Arc::strong_count(&a) == 1);\n         let b = w.upgrade().expect(\"\");\n-        assert!(strong_count(&b) == 2);\n-        assert!(strong_count(&a) == 2);\n+        assert!(Arc::strong_count(&b) == 2);\n+        assert!(Arc::strong_count(&a) == 2);\n         drop(w);\n         drop(a);\n-        assert!(strong_count(&b) == 1);\n+        assert!(Arc::strong_count(&b) == 1);\n         let c = b.clone();\n-        assert!(strong_count(&b) == 2);\n-        assert!(strong_count(&c) == 2);\n+        assert!(Arc::strong_count(&b) == 2);\n+        assert!(Arc::strong_count(&c) == 2);\n     }\n \n     #[test]\n     fn test_weak_count() {\n         let a = Arc::new(0u32);\n-        assert!(strong_count(&a) == 1);\n-        assert!(weak_count(&a) == 0);\n+        assert!(Arc::strong_count(&a) == 1);\n+        assert!(Arc::weak_count(&a) == 0);\n         let w = a.downgrade();\n-        assert!(strong_count(&a) == 1);\n-        assert!(weak_count(&a) == 1);\n+        assert!(Arc::strong_count(&a) == 1);\n+        assert!(Arc::weak_count(&a) == 1);\n         let x = w.clone();\n-        assert!(weak_count(&a) == 2);\n+        assert!(Arc::weak_count(&a) == 2);\n         drop(w);\n         drop(x);\n-        assert!(strong_count(&a) == 1);\n-        assert!(weak_count(&a) == 0);\n+        assert!(Arc::strong_count(&a) == 1);\n+        assert!(Arc::weak_count(&a) == 0);\n         let c = a.clone();\n-        assert!(strong_count(&a) == 2);\n-        assert!(weak_count(&a) == 0);\n+        assert!(Arc::strong_count(&a) == 2);\n+        assert!(Arc::weak_count(&a) == 0);\n         let d = c.downgrade();\n-        assert!(weak_count(&c) == 1);\n-        assert!(strong_count(&c) == 2);\n+        assert!(Arc::weak_count(&c) == 1);\n+        assert!(Arc::strong_count(&c) == 2);\n \n         drop(a);\n         drop(c);"}, {"sha": "8d357eb49a9f389049529270ad0a78acc5c6720e", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -86,7 +86,6 @@ use core::raw::{TraitObject};\n #[lang = \"exchange_heap\"]\n #[unstable(feature = \"box_heap\",\n            reason = \"may be renamed; uncertain about custom allocator design\")]\n-#[allow(deprecated)]\n pub const HEAP: ExchangeHeapSingleton =\n     ExchangeHeapSingleton { _force_singleton: () };\n \n@@ -254,31 +253,6 @@ impl<T : ?Sized> Box<T> {\n     }\n }\n \n-/// Consumes the `Box`, returning the wrapped raw pointer.\n-///\n-/// After call to this function, caller is responsible for the memory\n-/// previously managed by `Box`, in particular caller should properly\n-/// destroy `T` and release memory. The proper way to do it is to\n-/// convert pointer back to `Box` with `Box::from_raw` function, because\n-/// `Box` does not specify, how memory is allocated.\n-///\n-/// # Examples\n-/// ```\n-/// #![feature(box_raw)]\n-///\n-/// use std::boxed;\n-///\n-/// let seventeen = Box::new(17u32);\n-/// let raw = boxed::into_raw(seventeen);\n-/// let boxed_again = unsafe { Box::from_raw(raw) };\n-/// ```\n-#[unstable(feature = \"box_raw\", reason = \"may be renamed\")]\n-#[deprecated(since = \"1.2.0\", reason = \"renamed to Box::into_raw\")]\n-#[inline]\n-pub fn into_raw<T : ?Sized>(b: Box<T>) -> *mut T {\n-    Box::into_raw(b)\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Default> Default for Box<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "05863c2ee5c9bf251ad5c848cbc1ba28741a21fd", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -93,7 +93,7 @@\n #![feature(core_slice_ext)]\n #![feature(core_str_ext)]\n \n-#![cfg_attr(test, feature(test, alloc, rustc_private, box_raw))]\n+#![cfg_attr(test, feature(test, rustc_private, box_raw))]\n #![cfg_attr(all(not(feature = \"external_funcs\"), not(feature = \"external_crate\")),\n             feature(libc))]\n "}, {"sha": "b750e051f28d523e94ab41db7c51e0256fafb69e", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 28, "deletions": 106, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -338,84 +338,6 @@ impl<T: ?Sized> Rc<T> {\n     }\n }\n \n-/// Get the number of weak references to this value.\n-#[inline]\n-#[unstable(feature = \"rc_counts\")]\n-#[deprecated(since = \"1.2.0\", reason = \"renamed to Rc::weak_count\")]\n-pub fn weak_count<T: ?Sized>(this: &Rc<T>) -> usize { Rc::weak_count(this) }\n-\n-/// Get the number of strong references to this value.\n-#[inline]\n-#[unstable(feature = \"rc_counts\")]\n-#[deprecated(since = \"1.2.0\", reason = \"renamed to Rc::strong_count\")]\n-pub fn strong_count<T: ?Sized>(this: &Rc<T>) -> usize { Rc::strong_count(this) }\n-\n-/// Returns true if there are no other `Rc` or `Weak<T>` values that share the\n-/// same inner value.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// #![feature(rc_unique)]\n-///\n-/// use std::rc;\n-/// use std::rc::Rc;\n-///\n-/// let five = Rc::new(5);\n-///\n-/// rc::is_unique(&five);\n-/// ```\n-#[inline]\n-#[unstable(feature = \"rc_unique\")]\n-#[deprecated(since = \"1.2.0\", reason = \"renamed to Rc::is_unique\")]\n-pub fn is_unique<T>(rc: &Rc<T>) -> bool { Rc::is_unique(rc) }\n-\n-/// Unwraps the contained value if the `Rc<T>` is unique.\n-///\n-/// If the `Rc<T>` is not unique, an `Err` is returned with the same `Rc<T>`.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// #![feature(rc_unique)]\n-///\n-/// use std::rc::{self, Rc};\n-///\n-/// let x = Rc::new(3);\n-/// assert_eq!(rc::try_unwrap(x), Ok(3));\n-///\n-/// let x = Rc::new(4);\n-/// let _y = x.clone();\n-/// assert_eq!(rc::try_unwrap(x), Err(Rc::new(4)));\n-/// ```\n-#[inline]\n-#[unstable(feature = \"rc_unique\")]\n-#[deprecated(since = \"1.2.0\", reason = \"renamed to Rc::try_unwrap\")]\n-pub fn try_unwrap<T>(rc: Rc<T>) -> Result<T, Rc<T>> { Rc::try_unwrap(rc) }\n-\n-/// Returns a mutable reference to the contained value if the `Rc<T>` is unique.\n-///\n-/// Returns `None` if the `Rc<T>` is not unique.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// #![feature(rc_unique)]\n-///\n-/// use std::rc::{self, Rc};\n-///\n-/// let mut x = Rc::new(3);\n-/// *rc::get_mut(&mut x).unwrap() = 4;\n-/// assert_eq!(*x, 4);\n-///\n-/// let _y = x.clone();\n-/// assert!(rc::get_mut(&mut x).is_none());\n-/// ```\n-#[inline]\n-#[unstable(feature = \"rc_unique\")]\n-#[deprecated(since = \"1.2.0\", reason = \"renamed to Rc::get_mut\")]\n-pub fn get_mut<T>(rc: &mut Rc<T>) -> Option<&mut T> { Rc::get_mut(rc) }\n-\n impl<T: Clone> Rc<T> {\n     /// Make a mutable reference from the given `Rc<T>`.\n     ///\n@@ -922,7 +844,7 @@ impl<T: ?Sized> RcBoxPtr<T> for Weak<T> {\n \n #[cfg(test)]\n mod tests {\n-    use super::{Rc, Weak, weak_count, strong_count};\n+    use super::{Rc, Weak};\n     use std::boxed::Box;\n     use std::cell::RefCell;\n     use std::option::Option;\n@@ -990,74 +912,74 @@ mod tests {\n     #[test]\n     fn is_unique() {\n         let x = Rc::new(3);\n-        assert!(super::is_unique(&x));\n+        assert!(Rc::is_unique(&x));\n         let y = x.clone();\n-        assert!(!super::is_unique(&x));\n+        assert!(!Rc::is_unique(&x));\n         drop(y);\n-        assert!(super::is_unique(&x));\n+        assert!(Rc::is_unique(&x));\n         let w = x.downgrade();\n-        assert!(!super::is_unique(&x));\n+        assert!(!Rc::is_unique(&x));\n         drop(w);\n-        assert!(super::is_unique(&x));\n+        assert!(Rc::is_unique(&x));\n     }\n \n     #[test]\n     fn test_strong_count() {\n         let a = Rc::new(0u32);\n-        assert!(strong_count(&a) == 1);\n+        assert!(Rc::strong_count(&a) == 1);\n         let w = a.downgrade();\n-        assert!(strong_count(&a) == 1);\n+        assert!(Rc::strong_count(&a) == 1);\n         let b = w.upgrade().expect(\"upgrade of live rc failed\");\n-        assert!(strong_count(&b) == 2);\n-        assert!(strong_count(&a) == 2);\n+        assert!(Rc::strong_count(&b) == 2);\n+        assert!(Rc::strong_count(&a) == 2);\n         drop(w);\n         drop(a);\n-        assert!(strong_count(&b) == 1);\n+        assert!(Rc::strong_count(&b) == 1);\n         let c = b.clone();\n-        assert!(strong_count(&b) == 2);\n-        assert!(strong_count(&c) == 2);\n+        assert!(Rc::strong_count(&b) == 2);\n+        assert!(Rc::strong_count(&c) == 2);\n     }\n \n     #[test]\n     fn test_weak_count() {\n         let a = Rc::new(0u32);\n-        assert!(strong_count(&a) == 1);\n-        assert!(weak_count(&a) == 0);\n+        assert!(Rc::strong_count(&a) == 1);\n+        assert!(Rc::weak_count(&a) == 0);\n         let w = a.downgrade();\n-        assert!(strong_count(&a) == 1);\n-        assert!(weak_count(&a) == 1);\n+        assert!(Rc::strong_count(&a) == 1);\n+        assert!(Rc::weak_count(&a) == 1);\n         drop(w);\n-        assert!(strong_count(&a) == 1);\n-        assert!(weak_count(&a) == 0);\n+        assert!(Rc::strong_count(&a) == 1);\n+        assert!(Rc::weak_count(&a) == 0);\n         let c = a.clone();\n-        assert!(strong_count(&a) == 2);\n-        assert!(weak_count(&a) == 0);\n+        assert!(Rc::strong_count(&a) == 2);\n+        assert!(Rc::weak_count(&a) == 0);\n         drop(c);\n     }\n \n     #[test]\n     fn try_unwrap() {\n         let x = Rc::new(3);\n-        assert_eq!(super::try_unwrap(x), Ok(3));\n+        assert_eq!(Rc::try_unwrap(x), Ok(3));\n         let x = Rc::new(4);\n         let _y = x.clone();\n-        assert_eq!(super::try_unwrap(x), Err(Rc::new(4)));\n+        assert_eq!(Rc::try_unwrap(x), Err(Rc::new(4)));\n         let x = Rc::new(5);\n         let _w = x.downgrade();\n-        assert_eq!(super::try_unwrap(x), Err(Rc::new(5)));\n+        assert_eq!(Rc::try_unwrap(x), Err(Rc::new(5)));\n     }\n \n     #[test]\n     fn get_mut() {\n         let mut x = Rc::new(3);\n-        *super::get_mut(&mut x).unwrap() = 4;\n+        *Rc::get_mut(&mut x).unwrap() = 4;\n         assert_eq!(*x, 4);\n         let y = x.clone();\n-        assert!(super::get_mut(&mut x).is_none());\n+        assert!(Rc::get_mut(&mut x).is_none());\n         drop(y);\n-        assert!(super::get_mut(&mut x).is_some());\n+        assert!(Rc::get_mut(&mut x).is_some());\n         let _w = x.downgrade();\n-        assert!(super::get_mut(&mut x).is_none());\n+        assert!(Rc::get_mut(&mut x).is_none());\n     }\n \n     #[test]"}, {"sha": "e1ae4c51e3affb642e0bf782ae62fc8c7c6e95ce", "filename": "src/libcollections/bit.rs", "status": "removed", "additions": 0, "deletions": 2209, "changes": 2209, "blob_url": "https://github.com/rust-lang/rust/blob/a4066271b77810aec0a4a309f66a45e4f8b940de/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4066271b77810aec0a4a309f66a45e4f8b940de/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=a4066271b77810aec0a4a309f66a45e4f8b940de", "patch": "@@ -1,2209 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![deprecated(reason = \"BitVec and BitSet have been migrated to cargo as bit-vec and bit-set\",\n-              since = \"1.3.0\")]\n-#![unstable(feature = \"collections\", reason = \"deprecated\")]\n-#![allow(deprecated)]\n-\n-// FIXME(Gankro): BitVec and BitSet are very tightly coupled. Ideally (for\n-// maintenance), they should be in separate files/modules, with BitSet only\n-// using BitVec's public API. This will be hard for performance though, because\n-// `BitVec` will not want to leak its internal representation while its internal\n-// representation as `u32`s must be assumed for best performance.\n-\n-// FIXME(tbu-): `BitVec`'s methods shouldn't be `union`, `intersection`, but\n-// rather `or` and `and`.\n-\n-// (1) Be careful, most things can overflow here because the amount of bits in\n-//     memory can overflow `usize`.\n-// (2) Make sure that the underlying vector has no excess length:\n-//     E. g. `nbits == 16`, `storage.len() == 2` would be excess length,\n-//     because the last word isn't used at all. This is important because some\n-//     methods rely on it (for *CORRECTNESS*).\n-// (3) Make sure that the unused bits in the last word are zeroed out, again\n-//     other methods rely on it for *CORRECTNESS*.\n-// (4) `BitSet` is tightly coupled with `BitVec`, so any changes you make in\n-// `BitVec` will need to be reflected in `BitSet`.\n-\n-//! Collections implemented with bit vectors.\n-//!\n-//! # Examples\n-//!\n-//! This is a simple example of the [Sieve of Eratosthenes][sieve]\n-//! which calculates prime numbers up to a given limit.\n-//!\n-//! [sieve]: http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n-//!\n-//! ```\n-//! #![feature(bitset, bitvec, range_inclusive, step_by)]\n-//!\n-//! use std::collections::{BitSet, BitVec};\n-//! use std::iter;\n-//!\n-//! let max_prime = 10000;\n-//!\n-//! // Store the primes as a BitSet\n-//! let primes = {\n-//!     // Assume all numbers are prime to begin, and then we\n-//!     // cross off non-primes progressively\n-//!     let mut bv = BitVec::from_elem(max_prime, true);\n-//!\n-//!     // Neither 0 nor 1 are prime\n-//!     bv.set(0, false);\n-//!     bv.set(1, false);\n-//!\n-//!     for i in iter::range_inclusive(2, (max_prime as f64).sqrt() as usize) {\n-//!         // if i is a prime\n-//!         if bv[i] {\n-//!             // Mark all multiples of i as non-prime (any multiples below i * i\n-//!             // will have been marked as non-prime previously)\n-//!             for j in (i * i..max_prime).step_by(i) { bv.set(j, false) }\n-//!         }\n-//!     }\n-//!     BitSet::from_bit_vec(bv)\n-//! };\n-//!\n-//! // Simple primality tests below our max bound\n-//! let print_primes = 20;\n-//! print!(\"The primes below {} are: \", print_primes);\n-//! for x in 0..print_primes {\n-//!     if primes.contains(&x) {\n-//!         print!(\"{} \", x);\n-//!     }\n-//! }\n-//! println!(\"\");\n-//!\n-//! // We can manipulate the internal BitVec\n-//! let num_primes = primes.get_ref().iter().filter(|x| *x).count();\n-//! println!(\"There are {} primes below {}\", num_primes, max_prime);\n-//! ```\n-\n-use core::cmp::Ordering;\n-use core::cmp;\n-use core::fmt;\n-use core::hash;\n-#[allow(deprecated)]\n-use core::iter::RandomAccessIterator;\n-use core::iter::{Chain, Enumerate, Repeat, Skip, Take, repeat, Cloned};\n-use core::iter::{self, FromIterator};\n-use core::mem::swap;\n-use core::ops::Index;\n-use core::slice;\n-use core::{u8, u32, usize};\n-use bit_set; //so meta\n-\n-use Vec;\n-\n-type Blocks<'a> = Cloned<slice::Iter<'a, u32>>;\n-type MutBlocks<'a> = slice::IterMut<'a, u32>;\n-type MatchWords<'a> = Chain<Enumerate<Blocks<'a>>, Skip<Take<Enumerate<Repeat<u32>>>>>;\n-\n-fn reverse_bits(byte: u8) -> u8 {\n-    let mut result = 0;\n-    for i in 0..u8::BITS {\n-        result |= ((byte >> i) & 1) << (u8::BITS - 1 - i);\n-    }\n-    result\n-}\n-\n-// Take two BitVec's, and return iterators of their words, where the shorter one\n-// has been padded with 0's\n-fn match_words <'a,'b>(a: &'a BitVec, b: &'b BitVec) -> (MatchWords<'a>, MatchWords<'b>) {\n-    let a_len = a.storage.len();\n-    let b_len = b.storage.len();\n-\n-    // have to uselessly pretend to pad the longer one for type matching\n-    if a_len < b_len {\n-        (a.blocks().enumerate().chain(iter::repeat(0).enumerate().take(b_len).skip(a_len)),\n-         b.blocks().enumerate().chain(iter::repeat(0).enumerate().take(0).skip(0)))\n-    } else {\n-        (a.blocks().enumerate().chain(iter::repeat(0).enumerate().take(0).skip(0)),\n-         b.blocks().enumerate().chain(iter::repeat(0).enumerate().take(a_len).skip(b_len)))\n-    }\n-}\n-\n-const TRUE: &'static bool = &true;\n-const FALSE: &'static bool = &false;\n-\n-/// The bitvector type.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// #![feature(bitvec)]\n-///\n-/// use std::collections::BitVec;\n-///\n-/// let mut bv = BitVec::from_elem(10, false);\n-///\n-/// // insert all primes less than 10\n-/// bv.set(2, true);\n-/// bv.set(3, true);\n-/// bv.set(5, true);\n-/// bv.set(7, true);\n-/// println!(\"{:?}\", bv);\n-/// println!(\"total bits set to true: {}\", bv.iter().filter(|x| *x).count());\n-///\n-/// // flip all values in bitvector, producing non-primes less than 10\n-/// bv.negate();\n-/// println!(\"{:?}\", bv);\n-/// println!(\"total bits set to true: {}\", bv.iter().filter(|x| *x).count());\n-///\n-/// // reset bitvector to empty\n-/// bv.clear();\n-/// println!(\"{:?}\", bv);\n-/// println!(\"total bits set to true: {}\", bv.iter().filter(|x| *x).count());\n-/// ```\n-#[unstable(feature = \"bitvec\", reason = \"RFC 509\")]\n-pub struct BitVec {\n-    /// Internal representation of the bit vector\n-    storage: Vec<u32>,\n-    /// The number of valid bits in the internal representation\n-    nbits: usize\n-}\n-\n-// FIXME(Gankro): NopeNopeNopeNopeNope (wait for IndexGet to be a thing)\n-impl Index<usize> for BitVec {\n-    type Output = bool;\n-\n-    #[inline]\n-    fn index(&self, i: usize) -> &bool {\n-        if self.get(i).expect(\"index out of bounds\") {\n-            TRUE\n-        } else {\n-            FALSE\n-        }\n-    }\n-}\n-\n-/// Computes how many blocks are needed to store that many bits\n-fn blocks_for_bits(bits: usize) -> usize {\n-    // If we want 17 bits, dividing by 32 will produce 0. So we add 1 to make\n-    // sure we reserve enough. But if we want exactly a multiple of 32, this\n-    // will actually allocate one too many. So we need to check if that's the\n-    // case. We can do that by computing if bitwise AND by `32 - 1` is 0. But\n-    // LLVM should be able to optimize the semantically superior modulo operator\n-    // on a power of two to this.\n-    //\n-    // Note that we can technically avoid this branch with the expression\n-    // `(nbits + u32::BITS - 1) / 32::BITS`, but if nbits is almost usize::MAX\n-    // this will overflow.\n-    if bits % u32::BITS == 0 {\n-        bits / u32::BITS\n-    } else {\n-        bits / u32::BITS + 1\n-    }\n-}\n-\n-/// Computes the bitmask for the final word of the vector\n-fn mask_for_bits(bits: usize) -> u32 {\n-    // Note especially that a perfect multiple of u32::BITS should mask all 1s.\n-    !0 >> (u32::BITS - bits % u32::BITS) % u32::BITS\n-}\n-\n-#[unstable(feature = \"bitvec\", reason = \"RFC 509\")]\n-impl BitVec {\n-    /// Applies the given operation to the blocks of self and other, and sets\n-    /// self to be the result. This relies on the caller not to corrupt the\n-    /// last word.\n-    #[inline]\n-    fn process<F>(&mut self, other: &BitVec, mut op: F) -> bool where F: FnMut(u32, u32) -> u32 {\n-        assert_eq!(self.len(), other.len());\n-        // This could theoretically be a `debug_assert!`.\n-        assert_eq!(self.storage.len(), other.storage.len());\n-        let mut changed_bits = 0;\n-        for (a, b) in self.blocks_mut().zip(other.blocks()) {\n-            let w = op(*a, b);\n-            changed_bits |= *a ^ w;\n-            *a = w;\n-        }\n-        changed_bits != 0\n-    }\n-\n-    /// Iterator over mutable refs to  the underlying blocks of data.\n-    fn blocks_mut(&mut self) -> MutBlocks {\n-        // (2)\n-        self.storage.iter_mut()\n-    }\n-\n-    /// Iterator over the underlying blocks of data\n-    fn blocks(&self) -> Blocks {\n-        // (2)\n-        self.storage.iter().cloned()\n-    }\n-\n-    /// An operation might screw up the unused bits in the last block of the\n-    /// `BitVec`. As per (3), it's assumed to be all 0s. This method fixes it up.\n-    fn fix_last_block(&mut self) {\n-        let extra_bits = self.len() % u32::BITS;\n-        if extra_bits > 0 {\n-            let mask = (1 << extra_bits) - 1;\n-            let storage_len = self.storage.len();\n-            self.storage[storage_len - 1] &= mask;\n-        }\n-    }\n-\n-    /// Creates an empty `BitVec`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitvec)]\n-    ///\n-    /// use std::collections::BitVec;\n-    /// let mut bv = BitVec::new();\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new() -> BitVec {\n-        BitVec { storage: Vec::new(), nbits: 0 }\n-    }\n-\n-    /// Creates a `BitVec` that holds `nbits` elements, setting each element\n-    /// to `bit`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitvec)]\n-    ///\n-    /// use std::collections::BitVec;\n-    ///\n-    /// let bv = BitVec::from_elem(10, false);\n-    /// assert_eq!(bv.len(), 10);\n-    /// for x in &bv {\n-    ///     assert_eq!(x, false);\n-    /// }\n-    /// ```\n-    pub fn from_elem(nbits: usize, bit: bool) -> BitVec {\n-        let nblocks = blocks_for_bits(nbits);\n-        let mut bit_vec = BitVec {\n-            storage: vec![if bit { !0 } else { 0 }; nblocks],\n-            nbits: nbits\n-        };\n-        bit_vec.fix_last_block();\n-        bit_vec\n-    }\n-\n-    /// Constructs a new, empty `BitVec` with the specified capacity.\n-    ///\n-    /// The bitvector will be able to hold at least `capacity` bits without\n-    /// reallocating. If `capacity` is 0, it will not allocate.\n-    ///\n-    /// It is important to note that this function does not specify the\n-    /// *length* of the returned bitvector, but only the *capacity*.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_capacity(nbits: usize) -> BitVec {\n-        BitVec {\n-            storage: Vec::with_capacity(blocks_for_bits(nbits)),\n-            nbits: 0,\n-        }\n-    }\n-\n-    /// Transforms a byte-vector into a `BitVec`. Each byte becomes eight bits,\n-    /// with the most significant bits of each byte coming first. Each\n-    /// bit becomes `true` if equal to 1 or `false` if equal to 0.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitvec)]\n-    ///\n-    /// use std::collections::BitVec;\n-    ///\n-    /// let bv = BitVec::from_bytes(&[0b10100000, 0b00010010]);\n-    /// assert!(bv.eq_vec(&[true, false, true, false,\n-    ///                     false, false, false, false,\n-    ///                     false, false, false, true,\n-    ///                     false, false, true, false]));\n-    /// ```\n-    pub fn from_bytes(bytes: &[u8]) -> BitVec {\n-        let len = bytes.len().checked_mul(u8::BITS).expect(\"capacity overflow\");\n-        let mut bit_vec = BitVec::with_capacity(len);\n-        let complete_words = bytes.len() / 4;\n-        let extra_bytes = bytes.len() % 4;\n-\n-        bit_vec.nbits = len;\n-\n-        for i in 0..complete_words {\n-            bit_vec.storage.push(\n-                ((reverse_bits(bytes[i * 4 + 0]) as u32) << 0) |\n-                ((reverse_bits(bytes[i * 4 + 1]) as u32) << 8) |\n-                ((reverse_bits(bytes[i * 4 + 2]) as u32) << 16) |\n-                ((reverse_bits(bytes[i * 4 + 3]) as u32) << 24)\n-            );\n-        }\n-\n-        if extra_bytes > 0 {\n-            let mut last_word = 0;\n-            for (i, &byte) in bytes[complete_words*4..].iter().enumerate() {\n-                last_word |= (reverse_bits(byte) as u32) << (i * 8);\n-            }\n-            bit_vec.storage.push(last_word);\n-        }\n-\n-        bit_vec\n-    }\n-\n-    /// Creates a `BitVec` of the specified length where the value at each index\n-    /// is `f(index)`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitvec)]\n-    ///\n-    /// use std::collections::BitVec;\n-    ///\n-    /// let bv = BitVec::from_fn(5, |i| { i % 2 == 0 });\n-    /// assert!(bv.eq_vec(&[true, false, true, false, true]));\n-    /// ```\n-    pub fn from_fn<F>(len: usize, mut f: F) -> BitVec where F: FnMut(usize) -> bool {\n-        let mut bit_vec = BitVec::from_elem(len, false);\n-        for i in 0..len {\n-            bit_vec.set(i, f(i));\n-        }\n-        bit_vec\n-    }\n-\n-    /// Retrieves the value at index `i`, or `None` if the index is out of bounds.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitvec)]\n-    ///\n-    /// use std::collections::BitVec;\n-    ///\n-    /// let bv = BitVec::from_bytes(&[0b01100000]);\n-    /// assert_eq!(bv.get(0), Some(false));\n-    /// assert_eq!(bv.get(1), Some(true));\n-    /// assert_eq!(bv.get(100), None);\n-    ///\n-    /// // Can also use array indexing\n-    /// assert_eq!(bv[1], true);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get(&self, i: usize) -> Option<bool> {\n-        if i >= self.nbits {\n-            return None;\n-        }\n-        let w = i / u32::BITS;\n-        let b = i % u32::BITS;\n-        self.storage.get(w).map(|&block|\n-            (block & (1 << b)) != 0\n-        )\n-    }\n-\n-    /// Sets the value of a bit at an index `i`.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `i` is out of bounds.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitvec)]\n-    ///\n-    /// use std::collections::BitVec;\n-    ///\n-    /// let mut bv = BitVec::from_elem(5, false);\n-    /// bv.set(3, true);\n-    /// assert_eq!(bv[3], true);\n-    /// ```\n-    #[inline]\n-    pub fn set(&mut self, i: usize, x: bool) {\n-        assert!(i < self.nbits);\n-        let w = i / u32::BITS;\n-        let b = i % u32::BITS;\n-        let flag = 1 << b;\n-        let val = if x { self.storage[w] | flag }\n-                  else { self.storage[w] & !flag };\n-        self.storage[w] = val;\n-    }\n-\n-    /// Sets all bits to 1.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitvec)]\n-    ///\n-    /// use std::collections::BitVec;\n-    ///\n-    /// let before = 0b01100000;\n-    /// let after  = 0b11111111;\n-    ///\n-    /// let mut bv = BitVec::from_bytes(&[before]);\n-    /// bv.set_all();\n-    /// assert_eq!(bv, BitVec::from_bytes(&[after]));\n-    /// ```\n-    #[inline]\n-    pub fn set_all(&mut self) {\n-        for w in &mut self.storage { *w = !0; }\n-        self.fix_last_block();\n-    }\n-\n-    /// Flips all bits.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitvec)]\n-    ///\n-    /// use std::collections::BitVec;\n-    ///\n-    /// let before = 0b01100000;\n-    /// let after  = 0b10011111;\n-    ///\n-    /// let mut bv = BitVec::from_bytes(&[before]);\n-    /// bv.negate();\n-    /// assert_eq!(bv, BitVec::from_bytes(&[after]));\n-    /// ```\n-    #[inline]\n-    pub fn negate(&mut self) {\n-        for w in &mut self.storage { *w = !*w; }\n-        self.fix_last_block();\n-    }\n-\n-    /// Calculates the union of two bitvectors. This acts like the bitwise `or`\n-    /// function.\n-    ///\n-    /// Sets `self` to the union of `self` and `other`. Both bitvectors must be\n-    /// the same length. Returns `true` if `self` changed.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if the bitvectors are of different lengths.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitvec)]\n-    ///\n-    /// use std::collections::BitVec;\n-    ///\n-    /// let a   = 0b01100100;\n-    /// let b   = 0b01011010;\n-    /// let res = 0b01111110;\n-    ///\n-    /// let mut a = BitVec::from_bytes(&[a]);\n-    /// let b = BitVec::from_bytes(&[b]);\n-    ///\n-    /// assert!(a.union(&b));\n-    /// assert_eq!(a, BitVec::from_bytes(&[res]));\n-    /// ```\n-    #[inline]\n-    pub fn union(&mut self, other: &BitVec) -> bool {\n-        self.process(other, |w1, w2| w1 | w2)\n-    }\n-\n-    /// Calculates the intersection of two bitvectors. This acts like the\n-    /// bitwise `and` function.\n-    ///\n-    /// Sets `self` to the intersection of `self` and `other`. Both bitvectors\n-    /// must be the same length. Returns `true` if `self` changed.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if the bitvectors are of different lengths.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitvec)]\n-    ///\n-    /// use std::collections::BitVec;\n-    ///\n-    /// let a   = 0b01100100;\n-    /// let b   = 0b01011010;\n-    /// let res = 0b01000000;\n-    ///\n-    /// let mut a = BitVec::from_bytes(&[a]);\n-    /// let b = BitVec::from_bytes(&[b]);\n-    ///\n-    /// assert!(a.intersect(&b));\n-    /// assert_eq!(a, BitVec::from_bytes(&[res]));\n-    /// ```\n-    #[inline]\n-    pub fn intersect(&mut self, other: &BitVec) -> bool {\n-        self.process(other, |w1, w2| w1 & w2)\n-    }\n-\n-    /// Calculates the difference between two bitvectors.\n-    ///\n-    /// Sets each element of `self` to the value of that element minus the\n-    /// element of `other` at the same index. Both bitvectors must be the same\n-    /// length. Returns `true` if `self` changed.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if the bitvectors are of different length.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitvec)]\n-    ///\n-    /// use std::collections::BitVec;\n-    ///\n-    /// let a   = 0b01100100;\n-    /// let b   = 0b01011010;\n-    /// let a_b = 0b00100100; // a - b\n-    /// let b_a = 0b00011010; // b - a\n-    ///\n-    /// let mut bva = BitVec::from_bytes(&[a]);\n-    /// let bvb = BitVec::from_bytes(&[b]);\n-    ///\n-    /// assert!(bva.difference(&bvb));\n-    /// assert_eq!(bva, BitVec::from_bytes(&[a_b]));\n-    ///\n-    /// let bva = BitVec::from_bytes(&[a]);\n-    /// let mut bvb = BitVec::from_bytes(&[b]);\n-    ///\n-    /// assert!(bvb.difference(&bva));\n-    /// assert_eq!(bvb, BitVec::from_bytes(&[b_a]));\n-    /// ```\n-    #[inline]\n-    pub fn difference(&mut self, other: &BitVec) -> bool {\n-        self.process(other, |w1, w2| w1 & !w2)\n-    }\n-\n-    /// Returns `true` if all bits are 1.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitvec)]\n-    ///\n-    /// use std::collections::BitVec;\n-    ///\n-    /// let mut bv = BitVec::from_elem(5, true);\n-    /// assert_eq!(bv.all(), true);\n-    ///\n-    /// bv.set(1, false);\n-    /// assert_eq!(bv.all(), false);\n-    /// ```\n-    pub fn all(&self) -> bool {\n-        let mut last_word = !0;\n-        // Check that every block but the last is all-ones...\n-        self.blocks().all(|elem| {\n-            let tmp = last_word;\n-            last_word = elem;\n-            tmp == !0\n-        // and then check the last one has enough ones\n-        }) && (last_word == mask_for_bits(self.nbits))\n-    }\n-\n-    /// Returns an iterator over the elements of the vector in order.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitvec)]\n-    ///\n-    /// use std::collections::BitVec;\n-    ///\n-    /// let bv = BitVec::from_bytes(&[0b01110100, 0b10010010]);\n-    /// assert_eq!(bv.iter().filter(|x| *x).count(), 7);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn iter(&self) -> Iter {\n-        Iter { bit_vec: self, next_idx: 0, end_idx: self.nbits }\n-    }\n-\n-    /// Moves all bits from `other` into `Self`, leaving `other` empty.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitvec, append)]\n-    ///\n-    /// use std::collections::BitVec;\n-    ///\n-    /// let mut a = BitVec::from_bytes(&[0b10000000]);\n-    /// let mut b = BitVec::from_bytes(&[0b01100001]);\n-    ///\n-    /// a.append(&mut b);\n-    ///\n-    /// assert_eq!(a.len(), 16);\n-    /// assert_eq!(b.len(), 0);\n-    /// assert!(a.eq_vec(&[true, false, false, false, false, false, false, false,\n-    ///                    false, true, true, false, false, false, false, true]));\n-    /// ```\n-    #[unstable(feature = \"append\",\n-               reason = \"recently added as part of collections reform 2\")]\n-    pub fn append(&mut self, other: &mut Self) {\n-        let b = self.len() % u32::BITS;\n-\n-        self.nbits += other.len();\n-        other.nbits = 0;\n-\n-        if b == 0 {\n-            self.storage.append(&mut other.storage);\n-        } else {\n-            self.storage.reserve(other.storage.len());\n-\n-            for block in other.storage.drain(..) {\n-                *(self.storage.last_mut().unwrap()) |= block << b;\n-                self.storage.push(block >> (u32::BITS - b));\n-            }\n-        }\n-    }\n-\n-    /// Splits the `BitVec` into two at the given bit,\n-    /// retaining the first half in-place and returning the second one.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `at` is out of bounds.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitvec, split_off)]\n-    ///\n-    /// use std::collections::BitVec;\n-    /// let mut a = BitVec::new();\n-    /// a.push(true);\n-    /// a.push(false);\n-    /// a.push(false);\n-    /// a.push(true);\n-    ///\n-    /// let b = a.split_off(2);\n-    ///\n-    /// assert_eq!(a.len(), 2);\n-    /// assert_eq!(b.len(), 2);\n-    /// assert!(a.eq_vec(&[true, false]));\n-    /// assert!(b.eq_vec(&[false, true]));\n-    /// ```\n-    #[unstable(feature = \"split_off\",\n-               reason = \"recently added as part of collections reform 2\")]\n-    pub fn split_off(&mut self, at: usize) -> Self {\n-        assert!(at <= self.len(), \"`at` out of bounds\");\n-\n-        let mut other = BitVec::new();\n-\n-        if at == 0 {\n-            swap(self, &mut other);\n-            return other;\n-        } else if at == self.len() {\n-            return other;\n-        }\n-\n-        let w = at / u32::BITS;\n-        let b = at % u32::BITS;\n-        other.nbits = self.nbits - at;\n-        self.nbits = at;\n-        if b == 0 {\n-            // Split at block boundary\n-            other.storage = self.storage.split_off(w);\n-        } else {\n-            other.storage.reserve(self.storage.len() - w);\n-\n-            {\n-                let mut iter = self.storage[w..].iter();\n-                let mut last = *iter.next().unwrap();\n-                for &cur in iter {\n-                    other.storage.push((last >> b) | (cur << (u32::BITS - b)));\n-                    last = cur;\n-                }\n-                other.storage.push(last >> b);\n-            }\n-\n-            self.storage.truncate(w+1);\n-            self.fix_last_block();\n-        }\n-\n-        other\n-    }\n-\n-    /// Returns `true` if all bits are 0.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitvec)]\n-    ///\n-    /// use std::collections::BitVec;\n-    ///\n-    /// let mut bv = BitVec::from_elem(10, false);\n-    /// assert_eq!(bv.none(), true);\n-    ///\n-    /// bv.set(3, true);\n-    /// assert_eq!(bv.none(), false);\n-    /// ```\n-    pub fn none(&self) -> bool {\n-        self.blocks().all(|w| w == 0)\n-    }\n-\n-    /// Returns `true` if any bit is 1.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitvec)]\n-    ///\n-    /// use std::collections::BitVec;\n-    ///\n-    /// let mut bv = BitVec::from_elem(10, false);\n-    /// assert_eq!(bv.any(), false);\n-    ///\n-    /// bv.set(3, true);\n-    /// assert_eq!(bv.any(), true);\n-    /// ```\n-    #[inline]\n-    pub fn any(&self) -> bool {\n-        !self.none()\n-    }\n-\n-    /// Organises the bits into bytes, such that the first bit in the\n-    /// `BitVec` becomes the high-order bit of the first byte. If the\n-    /// size of the `BitVec` is not a multiple of eight then trailing bits\n-    /// will be filled-in with `false`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitvec)]\n-    ///\n-    /// use std::collections::BitVec;\n-    ///\n-    /// let mut bv = BitVec::from_elem(3, true);\n-    /// bv.set(1, false);\n-    ///\n-    /// assert_eq!(bv.to_bytes(), [0b10100000]);\n-    ///\n-    /// let mut bv = BitVec::from_elem(9, false);\n-    /// bv.set(2, true);\n-    /// bv.set(8, true);\n-    ///\n-    /// assert_eq!(bv.to_bytes(), [0b00100000, 0b10000000]);\n-    /// ```\n-    pub fn to_bytes(&self) -> Vec<u8> {\n-        fn bit(bit_vec: &BitVec, byte: usize, bit: usize) -> u8 {\n-            let offset = byte * 8 + bit;\n-            if offset >= bit_vec.nbits {\n-                0\n-            } else {\n-                (bit_vec[offset] as u8) << (7 - bit)\n-            }\n-        }\n-\n-        let len = self.nbits/8 +\n-                  if self.nbits % 8 == 0 { 0 } else { 1 };\n-        (0..len).map(|i|\n-            bit(self, i, 0) |\n-            bit(self, i, 1) |\n-            bit(self, i, 2) |\n-            bit(self, i, 3) |\n-            bit(self, i, 4) |\n-            bit(self, i, 5) |\n-            bit(self, i, 6) |\n-            bit(self, i, 7)\n-        ).collect()\n-    }\n-\n-    /// Compares a `BitVec` to a slice of `bool`s.\n-    /// Both the `BitVec` and slice must have the same length.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if the `BitVec` and slice are of different length.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitvec)]\n-    ///\n-    /// use std::collections::BitVec;\n-    ///\n-    /// let bv = BitVec::from_bytes(&[0b10100000]);\n-    ///\n-    /// assert!(bv.eq_vec(&[true, false, true, false,\n-    ///                     false, false, false, false]));\n-    /// ```\n-    pub fn eq_vec(&self, v: &[bool]) -> bool {\n-        assert_eq!(self.nbits, v.len());\n-        iter::order::eq(self.iter(), v.iter().cloned())\n-    }\n-\n-    /// Shortens a `BitVec`, dropping excess elements.\n-    ///\n-    /// If `len` is greater than the vector's current length, this has no\n-    /// effect.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitvec)]\n-    ///\n-    /// use std::collections::BitVec;\n-    ///\n-    /// let mut bv = BitVec::from_bytes(&[0b01001011]);\n-    /// bv.truncate(2);\n-    /// assert!(bv.eq_vec(&[false, true]));\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn truncate(&mut self, len: usize) {\n-        if len < self.len() {\n-            self.nbits = len;\n-            // This fixes (2).\n-            self.storage.truncate(blocks_for_bits(len));\n-            self.fix_last_block();\n-        }\n-    }\n-\n-    /// Reserves capacity for at least `additional` more bits to be inserted in the given\n-    /// `BitVec`. The collection may reserve more space to avoid frequent reallocations.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if the new capacity overflows `usize`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitvec)]\n-    ///\n-    /// use std::collections::BitVec;\n-    ///\n-    /// let mut bv = BitVec::from_elem(3, false);\n-    /// bv.reserve(10);\n-    /// assert_eq!(bv.len(), 3);\n-    /// assert!(bv.capacity() >= 13);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve(&mut self, additional: usize) {\n-        let desired_cap = self.len().checked_add(additional).expect(\"capacity overflow\");\n-        let storage_len = self.storage.len();\n-        if desired_cap > self.capacity() {\n-            self.storage.reserve(blocks_for_bits(desired_cap) - storage_len);\n-        }\n-    }\n-\n-    /// Reserves the minimum capacity for exactly `additional` more bits to be inserted in the\n-    /// given `BitVec`. Does nothing if the capacity is already sufficient.\n-    ///\n-    /// Note that the allocator may give the collection more space than it requests. Therefore\n-    /// capacity can not be relied upon to be precisely minimal. Prefer `reserve` if future\n-    /// insertions are expected.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if the new capacity overflows `usize`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitvec)]\n-    ///\n-    /// use std::collections::BitVec;\n-    ///\n-    /// let mut bv = BitVec::from_elem(3, false);\n-    /// bv.reserve(10);\n-    /// assert_eq!(bv.len(), 3);\n-    /// assert!(bv.capacity() >= 13);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve_exact(&mut self, additional: usize) {\n-        let desired_cap = self.len().checked_add(additional).expect(\"capacity overflow\");\n-        let storage_len = self.storage.len();\n-        if desired_cap > self.capacity() {\n-            self.storage.reserve_exact(blocks_for_bits(desired_cap) - storage_len);\n-        }\n-    }\n-\n-    /// Returns the capacity in bits for this bit vector. Inserting any\n-    /// element less than this amount will not trigger a resizing.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitvec)]\n-    ///\n-    /// use std::collections::BitVec;\n-    ///\n-    /// let mut bv = BitVec::new();\n-    /// bv.reserve(10);\n-    /// assert!(bv.capacity() >= 10);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn capacity(&self) -> usize {\n-        self.storage.capacity().checked_mul(u32::BITS).unwrap_or(usize::MAX)\n-    }\n-\n-    /// Grows the `BitVec` in-place, adding `n` copies of `value` to the `BitVec`.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if the new len overflows a `usize`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitvec)]\n-    ///\n-    /// use std::collections::BitVec;\n-    ///\n-    /// let mut bv = BitVec::from_bytes(&[0b01001011]);\n-    /// bv.grow(2, true);\n-    /// assert_eq!(bv.len(), 10);\n-    /// assert_eq!(bv.to_bytes(), [0b01001011, 0b11000000]);\n-    /// ```\n-    pub fn grow(&mut self, n: usize, value: bool) {\n-        // Note: we just bulk set all the bits in the last word in this fn in multiple places\n-        // which is technically wrong if not all of these bits are to be used. However, at the end\n-        // of this fn we call `fix_last_block` at the end of this fn, which should fix this.\n-\n-        let new_nbits = self.nbits.checked_add(n).expect(\"capacity overflow\");\n-        let new_nblocks = blocks_for_bits(new_nbits);\n-        let full_value = if value { !0 } else { 0 };\n-\n-        // Correct the old tail word, setting or clearing formerly unused bits\n-        let num_cur_blocks = blocks_for_bits(self.nbits);\n-        if self.nbits % u32::BITS > 0 {\n-            let mask = mask_for_bits(self.nbits);\n-            if value {\n-                self.storage[num_cur_blocks - 1] |= !mask;\n-            } else {\n-                // Extra bits are already zero by invariant.\n-            }\n-        }\n-\n-        // Fill in words after the old tail word\n-        let stop_idx = cmp::min(self.storage.len(), new_nblocks);\n-        for idx in num_cur_blocks..stop_idx {\n-            self.storage[idx] = full_value;\n-        }\n-\n-        // Allocate new words, if needed\n-        if new_nblocks > self.storage.len() {\n-            let to_add = new_nblocks - self.storage.len();\n-            self.storage.extend(repeat(full_value).take(to_add));\n-        }\n-\n-        // Adjust internal bit count\n-        self.nbits = new_nbits;\n-\n-        self.fix_last_block();\n-    }\n-\n-    /// Removes the last bit from the BitVec, and returns it. Returns None if the BitVec is empty.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitvec)]\n-    ///\n-    /// use std::collections::BitVec;\n-    ///\n-    /// let mut bv = BitVec::from_bytes(&[0b01001001]);\n-    /// assert_eq!(bv.pop(), Some(true));\n-    /// assert_eq!(bv.pop(), Some(false));\n-    /// assert_eq!(bv.len(), 6);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn pop(&mut self) -> Option<bool> {\n-        if self.is_empty() {\n-            None\n-        } else {\n-            let i = self.nbits - 1;\n-            let ret = self[i];\n-            // (3)\n-            self.set(i, false);\n-            self.nbits = i;\n-            if self.nbits % u32::BITS == 0 {\n-                // (2)\n-                self.storage.pop();\n-            }\n-            Some(ret)\n-        }\n-    }\n-\n-    /// Pushes a `bool` onto the end.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitvec)]\n-    ///\n-    /// use std::collections::BitVec;\n-    ///\n-    /// let mut bv = BitVec::new();\n-    /// bv.push(true);\n-    /// bv.push(false);\n-    /// assert!(bv.eq_vec(&[true, false]));\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn push(&mut self, elem: bool) {\n-        if self.nbits % u32::BITS == 0 {\n-            self.storage.push(0);\n-        }\n-        let insert_pos = self.nbits;\n-        self.nbits = self.nbits.checked_add(1).expect(\"Capacity overflow\");\n-        self.set(insert_pos, elem);\n-    }\n-\n-    /// Returns the total number of bits in this vector\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> usize { self.nbits }\n-\n-    /// Returns true if there are no bits in this vector\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_empty(&self) -> bool { self.len() == 0 }\n-\n-    /// Clears all bits in this vector.\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn clear(&mut self) {\n-        for w in &mut self.storage { *w = 0; }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Default for BitVec {\n-    #[inline]\n-    fn default() -> BitVec { BitVec::new() }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl FromIterator<bool> for BitVec {\n-    fn from_iter<I: IntoIterator<Item=bool>>(iter: I) -> BitVec {\n-        let mut ret = BitVec::new();\n-        ret.extend(iter);\n-        ret\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Extend<bool> for BitVec {\n-    #[inline]\n-    fn extend<I: IntoIterator<Item=bool>>(&mut self, iterable: I) {\n-        let iterator = iterable.into_iter();\n-        let (min, _) = iterator.size_hint();\n-        self.reserve(min);\n-        for element in iterator {\n-            self.push(element)\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n-impl<'a> Extend<&'a bool> for BitVec {\n-    fn extend<I: IntoIterator<Item=&'a bool>>(&mut self, iter: I) {\n-        self.extend(iter.into_iter().cloned());\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Clone for BitVec {\n-    #[inline]\n-    fn clone(&self) -> BitVec {\n-        BitVec { storage: self.storage.clone(), nbits: self.nbits }\n-    }\n-\n-    #[inline]\n-    fn clone_from(&mut self, source: &BitVec) {\n-        self.nbits = source.nbits;\n-        self.storage.clone_from(&source.storage);\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl PartialOrd for BitVec {\n-    #[inline]\n-    fn partial_cmp(&self, other: &BitVec) -> Option<Ordering> {\n-        iter::order::partial_cmp(self.iter(), other.iter())\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Ord for BitVec {\n-    #[inline]\n-    fn cmp(&self, other: &BitVec) -> Ordering {\n-        iter::order::cmp(self.iter(), other.iter())\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Debug for BitVec {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        for bit in self {\n-            try!(write!(fmt, \"{}\", if bit { 1 } else { 0 }));\n-        }\n-        Ok(())\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl hash::Hash for BitVec {\n-    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n-        self.nbits.hash(state);\n-        for elem in self.blocks() {\n-            elem.hash(state);\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl cmp::PartialEq for BitVec {\n-    #[inline]\n-    fn eq(&self, other: &BitVec) -> bool {\n-        if self.nbits != other.nbits {\n-            return false;\n-        }\n-        self.blocks().zip(other.blocks()).all(|(w1, w2)| w1 == w2)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl cmp::Eq for BitVec {}\n-\n-/// An iterator for `BitVec`.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone)]\n-pub struct Iter<'a> {\n-    bit_vec: &'a BitVec,\n-    next_idx: usize,\n-    end_idx: usize,\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> Iterator for Iter<'a> {\n-    type Item = bool;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<bool> {\n-        if self.next_idx != self.end_idx {\n-            let idx = self.next_idx;\n-            self.next_idx += 1;\n-            Some(self.bit_vec[idx])\n-        } else {\n-            None\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let rem = self.end_idx - self.next_idx;\n-        (rem, Some(rem))\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> DoubleEndedIterator for Iter<'a> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<bool> {\n-        if self.next_idx != self.end_idx {\n-            self.end_idx -= 1;\n-            Some(self.bit_vec[self.end_idx])\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> ExactSizeIterator for Iter<'a> {}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n-impl<'a> RandomAccessIterator for Iter<'a> {\n-    #[inline]\n-    fn indexable(&self) -> usize {\n-        self.end_idx - self.next_idx\n-    }\n-\n-    #[inline]\n-    fn idx(&mut self, index: usize) -> Option<bool> {\n-        if index >= self.indexable() {\n-            None\n-        } else {\n-            Some(self.bit_vec[index])\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> IntoIterator for &'a BitVec {\n-    type Item = bool;\n-    type IntoIter = Iter<'a>;\n-\n-    fn into_iter(self) -> Iter<'a> {\n-        self.iter()\n-    }\n-}\n-\n-/// An implementation of a set using a bit vector as an underlying\n-/// representation for holding unsigned numerical elements.\n-///\n-/// It should also be noted that the amount of storage necessary for holding a\n-/// set of objects is proportional to the maximum of the objects when viewed\n-/// as a `usize`.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// #![feature(bitvec, bitset)]\n-///\n-/// use std::collections::{BitSet, BitVec};\n-///\n-/// // It's a regular set\n-/// let mut s = BitSet::new();\n-/// s.insert(0);\n-/// s.insert(3);\n-/// s.insert(7);\n-///\n-/// s.remove(&7);\n-///\n-/// if !s.contains(&7) {\n-///     println!(\"There is no 7\");\n-/// }\n-///\n-/// // Can initialize from a `BitVec`\n-/// let other = BitSet::from_bit_vec(BitVec::from_bytes(&[0b11010000]));\n-///\n-/// s.union_with(&other);\n-///\n-/// // Print 0, 1, 3 in some order\n-/// for x in &s {\n-///     println!(\"{}\", x);\n-/// }\n-///\n-/// // Can convert back to a `BitVec`\n-/// let bv: BitVec = s.into_bit_vec();\n-/// assert!(bv[3]);\n-/// ```\n-#[derive(Clone)]\n-#[unstable(feature = \"bitset\", reason = \"RFC 509\")]\n-pub struct BitSet {\n-    bit_vec: BitVec,\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Default for BitSet {\n-    #[inline]\n-    fn default() -> BitSet { BitSet::new() }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl FromIterator<usize> for BitSet {\n-    fn from_iter<I: IntoIterator<Item=usize>>(iter: I) -> BitSet {\n-        let mut ret = BitSet::new();\n-        ret.extend(iter);\n-        ret\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Extend<usize> for BitSet {\n-    #[inline]\n-    fn extend<I: IntoIterator<Item=usize>>(&mut self, iter: I) {\n-        for i in iter {\n-            self.insert(i);\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n-impl<'a> Extend<&'a usize> for BitSet {\n-    fn extend<I: IntoIterator<Item=&'a usize>>(&mut self, iter: I) {\n-        self.extend(iter.into_iter().cloned());\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl PartialOrd for BitSet {\n-    #[inline]\n-    fn partial_cmp(&self, other: &BitSet) -> Option<Ordering> {\n-        let (a_iter, b_iter) = match_words(self.get_ref(), other.get_ref());\n-        iter::order::partial_cmp(a_iter, b_iter)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Ord for BitSet {\n-    #[inline]\n-    fn cmp(&self, other: &BitSet) -> Ordering {\n-        let (a_iter, b_iter) = match_words(self.get_ref(), other.get_ref());\n-        iter::order::cmp(a_iter, b_iter)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl cmp::PartialEq for BitSet {\n-    #[inline]\n-    fn eq(&self, other: &BitSet) -> bool {\n-        let (a_iter, b_iter) = match_words(self.get_ref(), other.get_ref());\n-        iter::order::eq(a_iter, b_iter)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl cmp::Eq for BitSet {}\n-\n-#[unstable(feature = \"bitset\", reason = \"RFC 509\")]\n-impl BitSet {\n-    /// Creates a new empty `BitSet`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitset)]\n-    ///\n-    /// use std::collections::BitSet;\n-    ///\n-    /// let mut s = BitSet::new();\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new() -> BitSet {\n-        BitSet { bit_vec: BitVec::new() }\n-    }\n-\n-    /// Creates a new `BitSet` with initially no contents, able to\n-    /// hold `nbits` elements without resizing.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitset)]\n-    ///\n-    /// use std::collections::BitSet;\n-    ///\n-    /// let mut s = BitSet::with_capacity(100);\n-    /// assert!(s.capacity() >= 100);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_capacity(nbits: usize) -> BitSet {\n-        let bit_vec = BitVec::from_elem(nbits, false);\n-        BitSet::from_bit_vec(bit_vec)\n-    }\n-\n-    /// Creates a new `BitSet` from the given bit vector.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitset, bitvec)]\n-    ///\n-    /// use std::collections::{BitVec, BitSet};\n-    ///\n-    /// let bv = BitVec::from_bytes(&[0b01100000]);\n-    /// let s = BitSet::from_bit_vec(bv);\n-    ///\n-    /// // Print 1, 2 in arbitrary order\n-    /// for x in &s {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    /// ```\n-    #[inline]\n-    pub fn from_bit_vec(bit_vec: BitVec) -> BitSet {\n-        BitSet { bit_vec: bit_vec }\n-    }\n-\n-    /// Returns the capacity in bits for this bit vector. Inserting any\n-    /// element less than this amount will not trigger a resizing.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitset)]\n-    ///\n-    /// use std::collections::BitSet;\n-    ///\n-    /// let mut s = BitSet::with_capacity(100);\n-    /// assert!(s.capacity() >= 100);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn capacity(&self) -> usize {\n-        self.bit_vec.capacity()\n-    }\n-\n-    /// Reserves capacity for the given `BitSet` to contain `len` distinct\n-    /// elements. In the case of `BitSet` this means reallocations will not\n-    /// occur as long as all inserted elements are less than `len`.\n-    ///\n-    /// The collection may reserve more space to avoid frequent reallocations.\n-    ///\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitset)]\n-    ///\n-    /// use std::collections::BitSet;\n-    ///\n-    /// let mut s = BitSet::new();\n-    /// s.reserve_len(10);\n-    /// assert!(s.capacity() >= 10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve_len(&mut self, len: usize) {\n-        let cur_len = self.bit_vec.len();\n-        if len >= cur_len {\n-            self.bit_vec.reserve(len - cur_len);\n-        }\n-    }\n-\n-    /// Reserves the minimum capacity for the given `BitSet` to contain `len`\n-    /// distinct elements.  In the case of `BitSet` this means reallocations\n-    /// will not occur as long as all inserted elements are less than `len`.\n-    ///\n-    /// Note that the allocator may give the collection more space than it\n-    /// requests. Therefore capacity can not be relied upon to be precisely\n-    /// minimal. Prefer `reserve_len` if future insertions are expected.\n-    ///\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitset)]\n-    ///\n-    /// use std::collections::BitSet;\n-    ///\n-    /// let mut s = BitSet::new();\n-    /// s.reserve_len_exact(10);\n-    /// assert!(s.capacity() >= 10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve_len_exact(&mut self, len: usize) {\n-        let cur_len = self.bit_vec.len();\n-        if len >= cur_len {\n-            self.bit_vec.reserve_exact(len - cur_len);\n-        }\n-    }\n-\n-\n-    /// Consumes this set to return the underlying bit vector.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitset)]\n-    ///\n-    /// use std::collections::BitSet;\n-    ///\n-    /// let mut s = BitSet::new();\n-    /// s.insert(0);\n-    /// s.insert(3);\n-    ///\n-    /// let bv = s.into_bit_vec();\n-    /// assert!(bv[0]);\n-    /// assert!(bv[3]);\n-    /// ```\n-    #[inline]\n-    pub fn into_bit_vec(self) -> BitVec {\n-        self.bit_vec\n-    }\n-\n-    /// Returns a reference to the underlying bit vector.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitset)]\n-    ///\n-    /// use std::collections::BitSet;\n-    ///\n-    /// let mut s = BitSet::new();\n-    /// s.insert(0);\n-    ///\n-    /// let bv = s.get_ref();\n-    /// assert_eq!(bv[0], true);\n-    /// ```\n-    #[inline]\n-    pub fn get_ref(&self) -> &BitVec {\n-        &self.bit_vec\n-    }\n-\n-    #[inline]\n-    fn other_op<F>(&mut self, other: &BitSet, mut f: F) where F: FnMut(u32, u32) -> u32 {\n-        // Unwrap BitVecs\n-        let self_bit_vec = &mut self.bit_vec;\n-        let other_bit_vec = &other.bit_vec;\n-\n-        let self_len = self_bit_vec.len();\n-        let other_len = other_bit_vec.len();\n-\n-        // Expand the vector if necessary\n-        if self_len < other_len {\n-            self_bit_vec.grow(other_len - self_len, false);\n-        }\n-\n-        // virtually pad other with 0's for equal lengths\n-        let other_words = {\n-            let (_, result) = match_words(self_bit_vec, other_bit_vec);\n-            result\n-        };\n-\n-        // Apply values found in other\n-        for (i, w) in other_words {\n-            let old = self_bit_vec.storage[i];\n-            let new = f(old, w);\n-            self_bit_vec.storage[i] = new;\n-        }\n-    }\n-\n-    /// Truncates the underlying vector to the least length required.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitset)]\n-    ///\n-    /// use std::collections::BitSet;\n-    ///\n-    /// let mut s = BitSet::new();\n-    /// s.insert(32183231);\n-    /// s.remove(&32183231);\n-    ///\n-    /// // Internal storage will probably be bigger than necessary\n-    /// println!(\"old capacity: {}\", s.capacity());\n-    ///\n-    /// // Now should be smaller\n-    /// s.shrink_to_fit();\n-    /// println!(\"new capacity: {}\", s.capacity());\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn shrink_to_fit(&mut self) {\n-        let bit_vec = &mut self.bit_vec;\n-        // Obtain original length\n-        let old_len = bit_vec.storage.len();\n-        // Obtain coarse trailing zero length\n-        let n = bit_vec.storage.iter().rev().take_while(|&&n| n == 0).count();\n-        // Truncate\n-        let trunc_len = cmp::max(old_len - n, 1);\n-        bit_vec.storage.truncate(trunc_len);\n-        bit_vec.nbits = trunc_len * u32::BITS;\n-    }\n-\n-    /// Iterator over each usize stored in the `BitSet`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitset, bitvec)]\n-    ///\n-    /// use std::collections::{BitVec, BitSet};\n-    ///\n-    /// let s = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01001010]));\n-    ///\n-    /// // Print 1, 4, 6 in arbitrary order\n-    /// for x in s.iter() {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn iter(&self) -> bit_set::Iter {\n-        SetIter(BlockIter::from_blocks(self.bit_vec.blocks()))\n-    }\n-\n-    /// Iterator over each usize stored in `self` union `other`.\n-    /// See [union_with](#method.union_with) for an efficient in-place version.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitset, bitvec)]\n-    ///\n-    /// use std::collections::{BitVec, BitSet};\n-    ///\n-    /// let a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01101000]));\n-    /// let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100000]));\n-    ///\n-    /// // Print 0, 1, 2, 4 in arbitrary order\n-    /// for x in a.union(&b) {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn union<'a>(&'a self, other: &'a BitSet) -> Union<'a> {\n-        fn or(w1: u32, w2: u32) -> u32 { w1 | w2 }\n-\n-        Union(BlockIter::from_blocks(TwoBitPositions {\n-            set: self.bit_vec.blocks(),\n-            other: other.bit_vec.blocks(),\n-            merge: or,\n-        }))\n-    }\n-\n-    /// Iterator over each usize stored in `self` intersect `other`.\n-    /// See [intersect_with](#method.intersect_with) for an efficient in-place\n-    /// version.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitset, bitvec)]\n-    ///\n-    /// use std::collections::{BitVec, BitSet};\n-    ///\n-    /// let a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01101000]));\n-    /// let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100000]));\n-    ///\n-    /// // Print 2\n-    /// for x in a.intersection(&b) {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn intersection<'a>(&'a self, other: &'a BitSet) -> Intersection<'a> {\n-        fn bitand(w1: u32, w2: u32) -> u32 { w1 & w2 }\n-        let min = cmp::min(self.bit_vec.len(), other.bit_vec.len());\n-\n-        Intersection(BlockIter::from_blocks(TwoBitPositions {\n-            set: self.bit_vec.blocks(),\n-            other: other.bit_vec.blocks(),\n-            merge: bitand,\n-        }).take(min))\n-    }\n-\n-    /// Iterator over each usize stored in the `self` setminus `other`.\n-    /// See [difference_with](#method.difference_with) for an efficient in-place\n-    /// version.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitset, bitvec)]\n-    ///\n-    /// use std::collections::{BitSet, BitVec};\n-    ///\n-    /// let a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01101000]));\n-    /// let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100000]));\n-    ///\n-    /// // Print 1, 4 in arbitrary order\n-    /// for x in a.difference(&b) {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    ///\n-    /// // Note that difference is not symmetric,\n-    /// // and `b - a` means something else.\n-    /// // This prints 0\n-    /// for x in b.difference(&a) {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn difference<'a>(&'a self, other: &'a BitSet) -> Difference<'a> {\n-        fn diff(w1: u32, w2: u32) -> u32 { w1 & !w2 }\n-\n-        Difference(BlockIter::from_blocks(TwoBitPositions {\n-            set: self.bit_vec.blocks(),\n-            other: other.bit_vec.blocks(),\n-            merge: diff,\n-        }))\n-    }\n-\n-    /// Iterator over each usize stored in the symmetric difference of `self`\n-    /// and `other`.  See\n-    /// [symmetric_difference_with](#method.symmetric_difference_with) for an\n-    /// efficient in-place version.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitset, bitvec)]\n-    ///\n-    /// use std::collections::{BitSet, BitVec};\n-    ///\n-    /// let a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01101000]));\n-    /// let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100000]));\n-    ///\n-    /// // Print 0, 1, 4 in arbitrary order\n-    /// for x in a.symmetric_difference(&b) {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn symmetric_difference<'a>(&'a self, other: &'a BitSet) -> SymmetricDifference<'a> {\n-        fn bitxor(w1: u32, w2: u32) -> u32 { w1 ^ w2 }\n-\n-        SymmetricDifference(BlockIter::from_blocks(TwoBitPositions {\n-            set: self.bit_vec.blocks(),\n-            other: other.bit_vec.blocks(),\n-            merge: bitxor,\n-        }))\n-    }\n-\n-    /// Unions in-place with the specified other bit vector.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitset, bitvec)]\n-    ///\n-    /// use std::collections::{BitSet, BitVec};\n-    ///\n-    /// let a   = 0b01101000;\n-    /// let b   = 0b10100000;\n-    /// let res = 0b11101000;\n-    ///\n-    /// let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[a]));\n-    /// let b = BitSet::from_bit_vec(BitVec::from_bytes(&[b]));\n-    /// let res = BitSet::from_bit_vec(BitVec::from_bytes(&[res]));\n-    ///\n-    /// a.union_with(&b);\n-    /// assert_eq!(a, res);\n-    /// ```\n-    #[inline]\n-    pub fn union_with(&mut self, other: &BitSet) {\n-        self.other_op(other, |w1, w2| w1 | w2);\n-    }\n-\n-    /// Intersects in-place with the specified other bit vector.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitset, bitvec)]\n-    ///\n-    /// use std::collections::{BitSet, BitVec};\n-    ///\n-    /// let a   = 0b01101000;\n-    /// let b   = 0b10100000;\n-    /// let res = 0b00100000;\n-    ///\n-    /// let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[a]));\n-    /// let b = BitSet::from_bit_vec(BitVec::from_bytes(&[b]));\n-    /// let res = BitSet::from_bit_vec(BitVec::from_bytes(&[res]));\n-    ///\n-    /// a.intersect_with(&b);\n-    /// assert_eq!(a, res);\n-    /// ```\n-    #[inline]\n-    pub fn intersect_with(&mut self, other: &BitSet) {\n-        self.other_op(other, |w1, w2| w1 & w2);\n-    }\n-\n-    /// Makes this bit vector the difference with the specified other bit vector\n-    /// in-place.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitset, bitvec)]\n-    ///\n-    /// use std::collections::{BitSet, BitVec};\n-    ///\n-    /// let a   = 0b01101000;\n-    /// let b   = 0b10100000;\n-    /// let a_b = 0b01001000; // a - b\n-    /// let b_a = 0b10000000; // b - a\n-    ///\n-    /// let mut bva = BitSet::from_bit_vec(BitVec::from_bytes(&[a]));\n-    /// let bvb = BitSet::from_bit_vec(BitVec::from_bytes(&[b]));\n-    /// let bva_b = BitSet::from_bit_vec(BitVec::from_bytes(&[a_b]));\n-    /// let bvb_a = BitSet::from_bit_vec(BitVec::from_bytes(&[b_a]));\n-    ///\n-    /// bva.difference_with(&bvb);\n-    /// assert_eq!(bva, bva_b);\n-    ///\n-    /// let bva = BitSet::from_bit_vec(BitVec::from_bytes(&[a]));\n-    /// let mut bvb = BitSet::from_bit_vec(BitVec::from_bytes(&[b]));\n-    ///\n-    /// bvb.difference_with(&bva);\n-    /// assert_eq!(bvb, bvb_a);\n-    /// ```\n-    #[inline]\n-    pub fn difference_with(&mut self, other: &BitSet) {\n-        self.other_op(other, |w1, w2| w1 & !w2);\n-    }\n-\n-    /// Makes this bit vector the symmetric difference with the specified other\n-    /// bit vector in-place.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitset, bitvec)]\n-    ///\n-    /// use std::collections::{BitSet, BitVec};\n-    ///\n-    /// let a   = 0b01101000;\n-    /// let b   = 0b10100000;\n-    /// let res = 0b11001000;\n-    ///\n-    /// let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[a]));\n-    /// let b = BitSet::from_bit_vec(BitVec::from_bytes(&[b]));\n-    /// let res = BitSet::from_bit_vec(BitVec::from_bytes(&[res]));\n-    ///\n-    /// a.symmetric_difference_with(&b);\n-    /// assert_eq!(a, res);\n-    /// ```\n-    #[inline]\n-    pub fn symmetric_difference_with(&mut self, other: &BitSet) {\n-        self.other_op(other, |w1, w2| w1 ^ w2);\n-    }\n-\n-    /// Moves all elements from `other` into `Self`, leaving `other` empty.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitset, bitvec, append)]\n-    ///\n-    /// use std::collections::{BitVec, BitSet};\n-    ///\n-    /// let mut a = BitSet::new();\n-    /// a.insert(2);\n-    /// a.insert(6);\n-    ///\n-    /// let mut b = BitSet::new();\n-    /// b.insert(1);\n-    /// b.insert(3);\n-    /// b.insert(6);\n-    ///\n-    /// a.append(&mut b);\n-    ///\n-    /// assert_eq!(a.len(), 4);\n-    /// assert_eq!(b.len(), 0);\n-    /// assert_eq!(a, BitSet::from_bit_vec(BitVec::from_bytes(&[0b01110010])));\n-    /// ```\n-    #[unstable(feature = \"append\",\n-               reason = \"recently added as part of collections reform 2\")]\n-    pub fn append(&mut self, other: &mut Self) {\n-        self.union_with(other);\n-        other.clear();\n-    }\n-\n-    /// Splits the `BitSet` into two at the given key including the key.\n-    /// Retains the first part in-place while returning the second part.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(bitset, bitvec, split_off)]\n-    ///\n-    /// use std::collections::{BitSet, BitVec};\n-    /// let mut a = BitSet::new();\n-    /// a.insert(2);\n-    /// a.insert(6);\n-    /// a.insert(1);\n-    /// a.insert(3);\n-    ///\n-    /// let b = a.split_off(3);\n-    ///\n-    /// assert_eq!(a.len(), 2);\n-    /// assert_eq!(b.len(), 2);\n-    /// assert_eq!(a, BitSet::from_bit_vec(BitVec::from_bytes(&[0b01100000])));\n-    /// assert_eq!(b, BitSet::from_bit_vec(BitVec::from_bytes(&[0b00010010])));\n-    /// ```\n-    #[unstable(feature = \"split_off\",\n-               reason = \"recently added as part of collections reform 2\")]\n-    pub fn split_off(&mut self, at: usize) -> Self {\n-        let mut other = BitSet::new();\n-\n-        if at == 0 {\n-            swap(self, &mut other);\n-            return other;\n-        } else if at >= self.bit_vec.len() {\n-            return other;\n-        }\n-\n-        // Calculate block and bit at which to split\n-        let w = at / u32::BITS;\n-        let b = at % u32::BITS;\n-\n-        // Pad `other` with `w` zero blocks,\n-        // append `self`'s blocks in the range from `w` to the end to `other`\n-        other.bit_vec.storage.extend(repeat(0u32).take(w)\n-                                     .chain(self.bit_vec.storage[w..].iter().cloned()));\n-        other.bit_vec.nbits = self.bit_vec.nbits;\n-\n-        if b > 0 {\n-            other.bit_vec.storage[w] &= !0 << b;\n-        }\n-\n-        // Sets `bit_vec.len()` and fixes the last block as well\n-        self.bit_vec.truncate(at);\n-\n-        other\n-    }\n-\n-    /// Returns the number of set bits in this set.\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> usize  {\n-        self.bit_vec.blocks().fold(0, |acc, n| acc + n.count_ones() as usize)\n-    }\n-\n-    /// Returns whether there are no bits set in this set\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_empty(&self) -> bool {\n-        self.bit_vec.none()\n-    }\n-\n-    /// Clears all bits in this set\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn clear(&mut self) {\n-        self.bit_vec.clear();\n-    }\n-\n-    /// Returns `true` if this set contains the specified integer.\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn contains(&self, value: &usize) -> bool {\n-        let bit_vec = &self.bit_vec;\n-        *value < bit_vec.nbits && bit_vec[*value]\n-    }\n-\n-    /// Returns `true` if the set has no elements in common with `other`.\n-    /// This is equivalent to checking for an empty intersection.\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_disjoint(&self, other: &BitSet) -> bool {\n-        self.intersection(other).next().is_none()\n-    }\n-\n-    /// Returns `true` if the set is a subset of another.\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_subset(&self, other: &BitSet) -> bool {\n-        let self_bit_vec = &self.bit_vec;\n-        let other_bit_vec = &other.bit_vec;\n-        let other_blocks = blocks_for_bits(other_bit_vec.len());\n-\n-        // Check that `self` intersect `other` is self\n-        self_bit_vec.blocks().zip(other_bit_vec.blocks()).all(|(w1, w2)| w1 & w2 == w1) &&\n-        // Make sure if `self` has any more blocks than `other`, they're all 0\n-        self_bit_vec.blocks().skip(other_blocks).all(|w| w == 0)\n-    }\n-\n-    /// Returns `true` if the set is a superset of another.\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_superset(&self, other: &BitSet) -> bool {\n-        other.is_subset(self)\n-    }\n-\n-    /// Adds a value to the set. Returns `true` if the value was not already\n-    /// present in the set.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn insert(&mut self, value: usize) -> bool {\n-        if self.contains(&value) {\n-            return false;\n-        }\n-\n-        // Ensure we have enough space to hold the new element\n-        let len = self.bit_vec.len();\n-        if value >= len {\n-            self.bit_vec.grow(value - len + 1, false)\n-        }\n-\n-        self.bit_vec.set(value, true);\n-        return true;\n-    }\n-\n-    /// Removes a value from the set. Returns `true` if the value was\n-    /// present in the set.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn remove(&mut self, value: &usize) -> bool {\n-        if !self.contains(value) {\n-            return false;\n-        }\n-\n-        self.bit_vec.set(*value, false);\n-\n-        return true;\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Debug for BitSet {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(fmt, \"{{\"));\n-        let mut first = true;\n-        for n in self {\n-            if !first {\n-                try!(write!(fmt, \", \"));\n-            }\n-            try!(write!(fmt, \"{:?}\", n));\n-            first = false;\n-        }\n-        write!(fmt, \"}}\")\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl hash::Hash for BitSet {\n-    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n-        for pos in self {\n-            pos.hash(state);\n-        }\n-    }\n-}\n-\n-#[derive(Clone)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-struct BlockIter<T> where T: Iterator<Item=u32> {\n-    head: u32,\n-    head_offset: usize,\n-    tail: T,\n-}\n-\n-impl<'a, T> BlockIter<T> where T: Iterator<Item=u32> {\n-    fn from_blocks(mut blocks: T) -> BlockIter<T> {\n-        let h = blocks.next().unwrap_or(0);\n-        BlockIter {tail: blocks, head: h, head_offset: 0}\n-    }\n-}\n-\n-/// An iterator combining two `BitSet` iterators.\n-#[derive(Clone)]\n-struct TwoBitPositions<'a> {\n-    set: Blocks<'a>,\n-    other: Blocks<'a>,\n-    merge: fn(u32, u32) -> u32,\n-}\n-\n-/// An iterator for `BitSet`.\n-#[derive(Clone)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct SetIter<'a>(BlockIter<Blocks<'a>>);\n-#[derive(Clone)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Union<'a>(BlockIter<TwoBitPositions<'a>>);\n-#[derive(Clone)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Intersection<'a>(Take<BlockIter<TwoBitPositions<'a>>>);\n-#[derive(Clone)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Difference<'a>(BlockIter<TwoBitPositions<'a>>);\n-#[derive(Clone)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct SymmetricDifference<'a>(BlockIter<TwoBitPositions<'a>>);\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> Iterator for BlockIter<T> where T: Iterator<Item=u32> {\n-    type Item = usize;\n-\n-    fn next(&mut self) -> Option<usize> {\n-        while self.head == 0 {\n-            match self.tail.next() {\n-                Some(w) => self.head = w,\n-                None => return None\n-            }\n-            self.head_offset += u32::BITS;\n-        }\n-\n-        // from the current block, isolate the\n-        // LSB and subtract 1, producing k:\n-        // a block with a number of set bits\n-        // equal to the index of the LSB\n-        let k = (self.head & (!self.head + 1)) - 1;\n-        // update block, removing the LSB\n-        self.head &= self.head - 1;\n-        // return offset + (index of LSB)\n-        Some(self.head_offset + (u32::count_ones(k) as usize))\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        match self.tail.size_hint() {\n-            (_, Some(h)) => (0, Some(1 + h * (u32::BITS as usize))),\n-            _ => (0, None)\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> Iterator for TwoBitPositions<'a> {\n-    type Item = u32;\n-\n-    fn next(&mut self) -> Option<u32> {\n-        match (self.set.next(), self.other.next()) {\n-            (Some(a), Some(b)) => Some((self.merge)(a, b)),\n-            (Some(a), None) => Some((self.merge)(a, 0)),\n-            (None, Some(b)) => Some((self.merge)(0, b)),\n-            _ => return None\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (a, au) = self.set.size_hint();\n-        let (b, bu) = self.other.size_hint();\n-\n-        let upper = match (au, bu) {\n-            (Some(au), Some(bu)) => Some(cmp::max(au, bu)),\n-            _ => None\n-        };\n-\n-        (cmp::max(a, b), upper)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> Iterator for SetIter<'a> {\n-    type Item = usize;\n-\n-    #[inline] fn next(&mut self) -> Option<usize> { self.0.next() }\n-    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.0.size_hint() }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> Iterator for Union<'a> {\n-    type Item = usize;\n-\n-    #[inline] fn next(&mut self) -> Option<usize> { self.0.next() }\n-    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.0.size_hint() }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> Iterator for Intersection<'a> {\n-    type Item = usize;\n-\n-    #[inline] fn next(&mut self) -> Option<usize> { self.0.next() }\n-    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.0.size_hint() }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> Iterator for Difference<'a> {\n-    type Item = usize;\n-\n-    #[inline] fn next(&mut self) -> Option<usize> { self.0.next() }\n-    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.0.size_hint() }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> Iterator for SymmetricDifference<'a> {\n-    type Item = usize;\n-\n-    #[inline] fn next(&mut self) -> Option<usize> { self.0.next() }\n-    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.0.size_hint() }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> IntoIterator for &'a BitSet {\n-    type Item = usize;\n-    type IntoIter = SetIter<'a>;\n-\n-    fn into_iter(self) -> SetIter<'a> {\n-        self.iter()\n-    }\n-}"}, {"sha": "e5d6909caa5214ee44418643e36ba2565ec740cf", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -1145,18 +1145,6 @@ impl<'a, K, V> DoubleEndedIterator for RangeMut<'a, K, V> {\n }\n \n impl<'a, K: Ord, V> Entry<'a, K, V> {\n-    #[unstable(feature = \"entry\",\n-               reason = \"will soon be replaced by or_insert\")]\n-    #[deprecated(since = \"1.0\",\n-                reason = \"replaced with more ergonomic `or_insert` and `or_insert_with`\")]\n-    /// Returns a mutable reference to the entry if occupied, or the VacantEntry if vacant\n-    pub fn get(self) -> Result<&'a mut V, VacantEntry<'a, K, V>> {\n-        match self {\n-            Occupied(entry) => Ok(entry.into_mut()),\n-            Vacant(entry) => Err(entry),\n-        }\n-    }\n-\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     /// Ensures a value is in the entry by inserting the default if empty, and returns\n     /// a mutable reference to the value in the entry."}, {"sha": "cbafd6fc6edadb349979d31778d31a50e244a340", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -37,8 +37,6 @@\n #![feature(core_slice_ext)]\n #![feature(core_str_ext)]\n #![feature(heap_api)]\n-#![feature(iter_cmp)]\n-#![feature(iter_idx)]\n #![feature(iter_order)]\n #![feature(iter_arith)]\n #![feature(iter_arith)]\n@@ -58,7 +56,6 @@\n #![feature(unsafe_no_drop_flag, filling_drop)]\n #![feature(utf8_error)]\n #![cfg_attr(test, feature(rand, test))]\n-#![cfg_attr(not(test), feature(str_words))]\n \n #![feature(no_std)]\n #![no_std]\n@@ -70,19 +67,13 @@ extern crate alloc;\n #[cfg(test)] extern crate test;\n \n pub use binary_heap::BinaryHeap;\n-#[allow(deprecated)]\n-pub use bit_vec::BitVec;\n-#[allow(deprecated)]\n-pub use bit_set::BitSet;\n pub use btree_map::BTreeMap;\n pub use btree_set::BTreeSet;\n pub use linked_list::LinkedList;\n pub use enum_set::EnumSet;\n pub use vec_deque::VecDeque;\n pub use string::String;\n pub use vec::Vec;\n-#[allow(deprecated)]\n-pub use vec_map::VecMap;\n \n // Needed for the vec! macro\n pub use alloc::boxed;\n@@ -91,7 +82,6 @@ pub use alloc::boxed;\n mod macros;\n \n pub mod binary_heap;\n-mod bit;\n mod btree;\n pub mod borrow;\n pub mod enum_set;\n@@ -103,21 +93,6 @@ pub mod str;\n pub mod string;\n pub mod vec;\n pub mod vec_deque;\n-#[allow(deprecated)]\n-pub mod vec_map;\n-\n-#[unstable(feature = \"bitvec\", reason = \"RFC 509\")]\n-pub mod bit_vec {\n-    #![allow(deprecated)]\n-    pub use bit::{BitVec, Iter};\n-}\n-\n-#[unstable(feature = \"bitset\", reason = \"RFC 509\")]\n-pub mod bit_set {\n-    #![allow(deprecated)]\n-    pub use bit::{BitSet, Union, Intersection, Difference, SymmetricDifference};\n-    pub use bit::SetIter as Iter;\n-}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub mod btree_map {"}, {"sha": "a15573f04f32661a7b7aabbc4a5c4bd7a71cab6b", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 1, "deletions": 393, "changes": 394, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -98,14 +98,13 @@ use core::option::Option::{self, Some, None};\n use core::ptr;\n use core::result::Result;\n use core::slice as core_slice;\n-use self::Direction::*;\n \n use borrow::{Borrow, BorrowMut, ToOwned};\n use vec::Vec;\n \n pub use core::slice::{Chunks, Windows};\n pub use core::slice::{Iter, IterMut};\n-pub use core::slice::{IntSliceExt, SplitMut, ChunksMut, Split};\n+pub use core::slice::{SplitMut, ChunksMut, Split};\n pub use core::slice::{SplitN, RSplitN, SplitNMut, RSplitNMut};\n pub use core::slice::{bytes, mut_ref_slice, ref_slice};\n pub use core::slice::{from_raw_parts, from_raw_parts_mut};\n@@ -141,8 +140,6 @@ mod hack {\n     use string::ToString;\n     use vec::Vec;\n \n-    use super::{ElementSwaps, Permutations};\n-\n     pub fn into_vec<T>(mut b: Box<[T]>) -> Vec<T> {\n         unsafe {\n             let xs = Vec::from_raw_parts(b.as_mut_ptr(), b.len(), b.len());\n@@ -151,76 +148,12 @@ mod hack {\n         }\n     }\n \n-    #[allow(deprecated)]\n-    pub fn permutations<T>(s: &[T]) -> Permutations<T> where T: Clone {\n-        Permutations{\n-            swaps: ElementSwaps::new(s.len()),\n-            v: to_vec(s),\n-        }\n-    }\n-\n     #[inline]\n     pub fn to_vec<T>(s: &[T]) -> Vec<T> where T: Clone {\n         let mut vector = Vec::with_capacity(s.len());\n         vector.push_all(s);\n         vector\n     }\n-\n-    // NB we can remove this hack if we move this test to libcollectionstest -\n-    // but that can't be done right now because the test needs access to the\n-    // private fields of Permutations\n-    #[test]\n-    fn test_permutations() {\n-        {\n-            let v: [i32; 0] = [];\n-            let mut it = permutations(&v);\n-            let (min_size, max_opt) = it.size_hint();\n-            assert_eq!(min_size, 1);\n-            assert_eq!(max_opt.unwrap(), 1);\n-            assert_eq!(it.next(), Some(to_vec(&v)));\n-            assert_eq!(it.next(), None);\n-        }\n-        {\n-            let v = [\"Hello\".to_string()];\n-            let mut it = permutations(&v);\n-            let (min_size, max_opt) = it.size_hint();\n-            assert_eq!(min_size, 1);\n-            assert_eq!(max_opt.unwrap(), 1);\n-            assert_eq!(it.next(), Some(to_vec(&v)));\n-            assert_eq!(it.next(), None);\n-        }\n-        {\n-            let v = [1, 2, 3];\n-            let mut it = permutations(&v);\n-            let (min_size, max_opt) = it.size_hint();\n-            assert_eq!(min_size, 3*2);\n-            assert_eq!(max_opt.unwrap(), 3*2);\n-            assert_eq!(it.next().unwrap(), [1,2,3]);\n-            assert_eq!(it.next().unwrap(), [1,3,2]);\n-            assert_eq!(it.next().unwrap(), [3,1,2]);\n-            let (min_size, max_opt) = it.size_hint();\n-            assert_eq!(min_size, 3);\n-            assert_eq!(max_opt.unwrap(), 3);\n-            assert_eq!(it.next().unwrap(), [3,2,1]);\n-            assert_eq!(it.next().unwrap(), [2,3,1]);\n-            assert_eq!(it.next().unwrap(), [2,1,3]);\n-            assert_eq!(it.next(), None);\n-        }\n-        {\n-            // check that we have N! permutations\n-            let v = ['A', 'B', 'C', 'D', 'E', 'F'];\n-            let mut amt = 0;\n-            let mut it = permutations(&v);\n-            let (min_size, max_opt) = it.size_hint();\n-            for _perm in it.by_ref() {\n-                amt += 1;\n-            }\n-            assert_eq!(amt, it.swaps.swaps_made);\n-            assert_eq!(amt, min_size);\n-            assert_eq!(amt, 2 * 3 * 4 * 5 * 6);\n-            assert_eq!(amt, max_opt.unwrap());\n-        }\n-    }\n }\n \n /// Allocating extension methods for slices.\n@@ -280,44 +213,20 @@ impl<T> [T] {\n         core_slice::SliceExt::first_mut(self)\n     }\n \n-    /// Returns all but the first element of a slice.\n-    #[unstable(feature = \"slice_extras\", reason = \"likely to be renamed\")]\n-    #[deprecated(since = \"1.3.0\", reason = \"superseded by split_first\")]\n-    #[inline]\n-    pub fn tail(&self) -> &[T] {\n-        core_slice::SliceExt::tail(self)\n-    }\n-\n     /// Returns the first and all the rest of the elements of a slice.\n     #[unstable(feature = \"slice_splits\", reason = \"new API\")]\n     #[inline]\n     pub fn split_first(&self) -> Option<(&T, &[T])> {\n         core_slice::SliceExt::split_first(self)\n     }\n \n-    /// Returns all but the first element of a mutable slice\n-    #[unstable(feature = \"slice_extras\", reason = \"likely to be renamed or removed\")]\n-    #[deprecated(since = \"1.3.0\", reason = \"superseded by split_first_mut\")]\n-    #[inline]\n-    pub fn tail_mut(&mut self) -> &mut [T] {\n-        core_slice::SliceExt::tail_mut(self)\n-    }\n-\n     /// Returns the first and all the rest of the elements of a slice.\n     #[unstable(feature = \"slice_splits\", reason = \"new API\")]\n     #[inline]\n     pub fn split_first_mut(&mut self) -> Option<(&mut T, &mut [T])> {\n         core_slice::SliceExt::split_first_mut(self)\n     }\n \n-    /// Returns all but the last element of a slice.\n-    #[unstable(feature = \"slice_extras\", reason = \"likely to be renamed\")]\n-    #[deprecated(since = \"1.3.0\", reason = \"superseded by split_last\")]\n-    #[inline]\n-    pub fn init(&self) -> &[T] {\n-        core_slice::SliceExt::init(self)\n-    }\n-\n     /// Returns the last and all the rest of the elements of a slice.\n     #[unstable(feature = \"slice_splits\", reason = \"new API\")]\n     #[inline]\n@@ -326,14 +235,6 @@ impl<T> [T] {\n \n     }\n \n-    /// Returns all but the last element of a mutable slice\n-    #[unstable(feature = \"slice_extras\", reason = \"likely to be renamed or removed\")]\n-    #[deprecated(since = \"1.3.0\", reason = \"superseded by split_last_mut\")]\n-    #[inline]\n-    pub fn init_mut(&mut self) -> &mut [T] {\n-        core_slice::SliceExt::init_mut(self)\n-    }\n-\n     /// Returns the last and all the rest of the elements of a slice.\n     #[unstable(feature = \"slice_splits\", since = \"1.3.0\")]\n     #[inline]\n@@ -760,22 +661,6 @@ impl<T> [T] {\n         core_slice::SliceExt::ends_with(self, needle)\n     }\n \n-    /// Find the first index containing a matching value.\n-    #[unstable(feature = \"slice_position_elem\")]\n-    #[deprecated(since = \"1.3.0\",\n-                 reason = \"less idiomatic than .iter().position()\")]\n-    pub fn position_elem(&self, t: &T) -> Option<usize> where T: PartialEq {\n-        core_slice::SliceExt::position_elem(self, t)\n-    }\n-\n-    /// Find the last index containing a matching value.\n-    #[unstable(feature = \"slice_position_elem\")]\n-    #[deprecated(since = \"1.3.0\",\n-                 reason = \"less idiomatic than .iter().rev().position()\")]\n-    pub fn rposition_elem(&self, t: &T) -> Option<usize> where T: PartialEq {\n-        core_slice::SliceExt::rposition_elem(self, t)\n-    }\n-\n     /// Binary search a sorted slice for a given element.\n     ///\n     /// If the value is found then `Ok` is returned, containing the\n@@ -881,95 +766,6 @@ impl<T> [T] {\n         merge_sort(self, compare)\n     }\n \n-    /// Creates an iterator that yields every possible permutation of the\n-    /// vector in succession.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// #![feature(permutations)]\n-    ///\n-    /// let v = [1, 2, 3];\n-    /// let mut perms = v.permutations();\n-    ///\n-    /// for p in perms {\n-    ///   println!(\"{:?}\", p);\n-    /// }\n-    /// ```\n-    ///\n-    /// Iterating through permutations one by one.\n-    ///\n-    /// ```rust\n-    /// #![feature(permutations)]\n-    ///\n-    /// let v = [1, 2, 3];\n-    /// let mut perms = v.permutations();\n-    ///\n-    /// assert_eq!(Some(vec![1, 2, 3]), perms.next());\n-    /// assert_eq!(Some(vec![1, 3, 2]), perms.next());\n-    /// assert_eq!(Some(vec![3, 1, 2]), perms.next());\n-    /// ```\n-    #[allow(deprecated)]\n-    #[unstable(feature = \"permutations\")]\n-    #[deprecated(since = \"1.2.0\", reason = \"not clear this should be in the stdlib\")]\n-    #[inline]\n-    pub fn permutations(&self) -> Permutations<T> where T: Clone {\n-        // NB see hack module in this file\n-        hack::permutations(self)\n-    }\n-\n-    /// Mutates the slice to the next lexicographic permutation.\n-    ///\n-    /// Returns `true` if successful and `false` if the slice is at the\n-    /// last-ordered permutation.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// #![feature(permutations)]\n-    ///\n-    /// let v: &mut [_] = &mut [0, 1, 2];\n-    /// v.next_permutation();\n-    /// let b: &mut [_] = &mut [0, 2, 1];\n-    /// assert!(v == b);\n-    /// v.next_permutation();\n-    /// let b: &mut [_] = &mut [1, 0, 2];\n-    /// assert!(v == b);\n-    /// ```\n-    #[allow(deprecated)]\n-    #[unstable(feature = \"permutations\",\n-               reason = \"uncertain if this merits inclusion in std\")]\n-    #[deprecated(since = \"1.2.0\", reason = \"not clear this should be in the stdlib\")]\n-    pub fn next_permutation(&mut self) -> bool where T: Ord {\n-        core_slice::SliceExt::next_permutation(self)\n-    }\n-\n-    /// Mutates the slice to the previous lexicographic permutation.\n-    ///\n-    /// Returns `true` if successful and `false` if the slice is at the\n-    /// first-ordered permutation.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// #![feature(permutations)]\n-    ///\n-    /// let v: &mut [_] = &mut [1, 0, 2];\n-    /// v.prev_permutation();\n-    /// let b: &mut [_] = &mut [0, 2, 1];\n-    /// assert!(v == b);\n-    /// v.prev_permutation();\n-    /// let b: &mut [_] = &mut [0, 1, 2];\n-    /// assert!(v == b);\n-    /// ```\n-    #[allow(deprecated)]\n-    #[unstable(feature = \"permutations\",\n-               reason = \"uncertain if this merits inclusion in std\")]\n-    #[deprecated(since = \"1.2.0\", reason = \"not clear this should be in the stdlib\")]\n-    pub fn prev_permutation(&mut self) -> bool where T: Ord {\n-        core_slice::SliceExt::prev_permutation(self)\n-    }\n-\n     /// Copies as many elements from `src` as it can into `self` (the\n     /// shorter of `self.len()` and `src.len()`). Returns the number\n     /// of elements copied.\n@@ -994,41 +790,6 @@ impl<T> [T] {\n         core_slice::SliceExt::clone_from_slice(self, src)\n     }\n \n-    /// Consumes `src` and moves as many elements as it can into `self`\n-    /// from the range [start,end).\n-    ///\n-    /// Returns the number of elements copied (the shorter of `self.len()`\n-    /// and `end - start`).\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * src - A mutable vector of `T`\n-    /// * start - The index into `src` to start copying from\n-    /// * end - The index into `src` to stop copying from\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// #![feature(move_from)]\n-    ///\n-    /// let mut a = [1, 2, 3, 4, 5];\n-    /// let b = vec![6, 7, 8];\n-    /// let num_moved = a.move_from(b, 0, 3);\n-    /// assert_eq!(num_moved, 3);\n-    /// assert!(a == [6, 7, 8, 4, 5]);\n-    /// ```\n-    #[unstable(feature = \"move_from\",\n-               reason = \"uncertain about this API approach\")]\n-    #[deprecated(since = \"1.3.0\",\n-                 reason = \"unclear that it must belong in the standard library\")]\n-    #[inline]\n-    pub fn move_from(&mut self, mut src: Vec<T>, start: usize, end: usize) -> usize {\n-        for (a, b) in self.iter_mut().zip(&mut src[start .. end]) {\n-            mem::swap(a, b);\n-        }\n-        cmp::min(self.len(), end-start)\n-    }\n-\n     /// Copies `self` into a new `Vec`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -1120,45 +881,6 @@ impl<T: Clone, V: Borrow<[T]>> SliceConcatExt<T> for [V] {\n     }\n }\n \n-/// An iterator that yields the element swaps needed to produce\n-/// a sequence of all possible permutations for an indexed sequence of\n-/// elements. Each permutation is only a single swap apart.\n-///\n-/// The Steinhaus-Johnson-Trotter algorithm is used.\n-///\n-/// Generates even and odd permutations alternately.\n-///\n-/// The last generated swap is always (0, 1), and it returns the\n-/// sequence to its initial order.\n-#[allow(deprecated)]\n-#[unstable(feature = \"permutations\")]\n-#[derive(Clone)]\n-#[deprecated(since = \"1.2.0\", reason = \"not clear this should be in the stdlib\")]\n-pub struct ElementSwaps {\n-    sdir: Vec<SizeDirection>,\n-    /// If `true`, emit the last swap that returns the sequence to initial\n-    /// state.\n-    emit_reset: bool,\n-    swaps_made : usize,\n-}\n-\n-#[allow(deprecated)]\n-impl ElementSwaps {\n-    /// Creates an `ElementSwaps` iterator for a sequence of `length` elements.\n-    #[unstable(feature = \"permutations\")]\n-    #[deprecated(since = \"1.2.0\", reason = \"not clear this should be in the stdlib\")]\n-    pub fn new(length: usize) -> ElementSwaps {\n-        // Initialize `sdir` with a direction that position should move in\n-        // (all negative at the beginning) and the `size` of the\n-        // element (equal to the original index).\n-        ElementSwaps{\n-            emit_reset: true,\n-            sdir: (0..length).map(|i| SizeDirection{ size: i, dir: Neg }).collect(),\n-            swaps_made: 0\n-        }\n-    }\n-}\n-\n ////////////////////////////////////////////////////////////////////////////////\n // Standard trait implementations for slices\n ////////////////////////////////////////////////////////////////////////////////\n@@ -1187,120 +909,6 @@ impl<T: Clone> ToOwned for [T] {\n     fn to_owned(&self) -> Vec<T> { panic!(\"not available with cfg(test)\") }\n }\n \n-////////////////////////////////////////////////////////////////////////////////\n-// Iterators\n-////////////////////////////////////////////////////////////////////////////////\n-\n-#[derive(Copy, Clone)]\n-enum Direction { Pos, Neg }\n-\n-/// An `Index` and `Direction` together.\n-#[derive(Copy, Clone)]\n-struct SizeDirection {\n-    size: usize,\n-    dir: Direction,\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n-impl Iterator for ElementSwaps {\n-    type Item = (usize, usize);\n-\n-    // #[inline]\n-    fn next(&mut self) -> Option<(usize, usize)> {\n-        fn new_pos_wrapping(i: usize, s: Direction) -> usize {\n-            i.wrapping_add(match s { Pos => 1, Neg => !0 /* aka -1 */ })\n-        }\n-\n-        fn new_pos(i: usize, s: Direction) -> usize {\n-            match s { Pos => i + 1, Neg => i - 1 }\n-        }\n-\n-        // Find the index of the largest mobile element:\n-        // The direction should point into the vector, and the\n-        // swap should be with a smaller `size` element.\n-        let max = self.sdir.iter().cloned().enumerate()\n-                           .filter(|&(i, sd)|\n-                                new_pos_wrapping(i, sd.dir) < self.sdir.len() &&\n-                                self.sdir[new_pos(i, sd.dir)].size < sd.size)\n-                           .max_by(|&(_, sd)| sd.size);\n-        match max {\n-            Some((i, sd)) => {\n-                let j = new_pos(i, sd.dir);\n-                self.sdir.swap(i, j);\n-\n-                // Swap the direction of each larger SizeDirection\n-                for x in &mut self.sdir {\n-                    if x.size > sd.size {\n-                        x.dir = match x.dir { Pos => Neg, Neg => Pos };\n-                    }\n-                }\n-                self.swaps_made += 1;\n-                Some((i, j))\n-            },\n-            None => if self.emit_reset {\n-                self.emit_reset = false;\n-                if self.sdir.len() > 1 {\n-                    // The last swap\n-                    self.swaps_made += 1;\n-                    Some((0, 1))\n-                } else {\n-                    // Vector is of the form [] or [x], and the only permutation is itself\n-                    self.swaps_made += 1;\n-                    Some((0,0))\n-                }\n-            } else { None }\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        // For a vector of size n, there are exactly n! permutations.\n-        let n: usize = (2..self.sdir.len() + 1).product();\n-        (n - self.swaps_made, Some(n - self.swaps_made))\n-    }\n-}\n-\n-/// An iterator that uses `ElementSwaps` to iterate through\n-/// all possible permutations of a vector.\n-///\n-/// The first iteration yields a clone of the vector as it is,\n-/// then each successive element is the vector with one\n-/// swap applied.\n-///\n-/// Generates even and odd permutations alternately.\n-#[unstable(feature = \"permutations\")]\n-#[deprecated(since = \"1.2.0\", reason = \"not clear this should be in the stdlib\")]\n-#[allow(deprecated)]\n-pub struct Permutations<T> {\n-    swaps: ElementSwaps,\n-    v: Vec<T>,\n-}\n-\n-#[unstable(feature = \"permutations\", reason = \"trait is unstable\")]\n-#[allow(deprecated)]\n-impl<T: Clone> Iterator for Permutations<T> {\n-    type Item = Vec<T>;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<Vec<T>> {\n-        match self.swaps.next() {\n-            None => None,\n-            Some((0,0)) => Some(self.v.clone()),\n-            Some((a, b)) => {\n-                let elt = self.v.clone();\n-                self.v.swap(a, b);\n-                Some(elt)\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.swaps.size_hint()\n-    }\n-}\n-\n ////////////////////////////////////////////////////////////////////////////////\n // Sorting\n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "56a04f0398a34b616b5d77c31af9fc3d17fc7c50", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 5, "deletions": 470, "changes": 475, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -19,9 +19,6 @@\n // It's cleaner to just turn off the unused_imports warning than to fix them.\n #![allow(unused_imports)]\n \n-use self::RecompositionState::*;\n-use self::DecompositionType::*;\n-\n use core::clone::Clone;\n use core::iter::{Iterator, Extend};\n use core::option::Option::{self, Some, None};\n@@ -49,7 +46,7 @@ pub use core::str::{Matches, RMatches};\n pub use core::str::{MatchIndices, RMatchIndices};\n pub use core::str::{from_utf8, Chars, CharIndices, Bytes};\n pub use core::str::{from_utf8_unchecked, ParseBoolError};\n-pub use rustc_unicode::str::{SplitWhitespace, Words, Graphemes, GraphemeIndices};\n+pub use rustc_unicode::str::{SplitWhitespace};\n pub use core::str::pattern;\n \n impl<S: Borrow<str>> SliceConcatExt<str> for [S] {\n@@ -104,230 +101,6 @@ impl<S: Borrow<str>> SliceConcatExt<str> for [S] {\n     }\n }\n \n-// Helper functions used for Unicode normalization\n-fn canonical_sort(comb: &mut [(char, u8)]) {\n-    let len = comb.len();\n-    for i in 0..len {\n-        let mut swapped = false;\n-        for j in 1..len-i {\n-            let class_a = comb[j-1].1;\n-            let class_b = comb[j].1;\n-            if class_a != 0 && class_b != 0 && class_a > class_b {\n-                comb.swap(j-1, j);\n-                swapped = true;\n-            }\n-        }\n-        if !swapped { break; }\n-    }\n-}\n-\n-#[derive(Clone)]\n-enum DecompositionType {\n-    Canonical,\n-    Compatible\n-}\n-\n-/// External iterator for a string decomposition's characters.\n-///\n-/// For use with the `std::iter` module.\n-#[allow(deprecated)]\n-#[deprecated(reason = \"use the crates.io `unicode-normalization` library instead\",\n-             since = \"1.0.0\")]\n-#[derive(Clone)]\n-#[unstable(feature = \"unicode\",\n-           reason = \"this functionality may be replaced with a more generic \\\n-                     unicode crate on crates.io\")]\n-pub struct Decompositions<'a> {\n-    kind: DecompositionType,\n-    iter: Chars<'a>,\n-    buffer: Vec<(char, u8)>,\n-    sorted: bool\n-}\n-\n-#[allow(deprecated)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> Iterator for Decompositions<'a> {\n-    type Item = char;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<char> {\n-        match self.buffer.first() {\n-            Some(&(c, 0)) => {\n-                self.sorted = false;\n-                self.buffer.remove(0);\n-                return Some(c);\n-            }\n-            Some(&(c, _)) if self.sorted => {\n-                self.buffer.remove(0);\n-                return Some(c);\n-            }\n-            _ => self.sorted = false\n-        }\n-\n-        if !self.sorted {\n-            for ch in self.iter.by_ref() {\n-                let buffer = &mut self.buffer;\n-                let sorted = &mut self.sorted;\n-                {\n-                    let callback = |d| {\n-                        let class =\n-                            rustc_unicode::char::canonical_combining_class(d);\n-                        if class == 0 && !*sorted {\n-                            canonical_sort(buffer);\n-                            *sorted = true;\n-                        }\n-                        buffer.push((d, class));\n-                    };\n-                    match self.kind {\n-                        Canonical => {\n-                            rustc_unicode::char::decompose_canonical(ch, callback)\n-                        }\n-                        Compatible => {\n-                            rustc_unicode::char::decompose_compatible(ch, callback)\n-                        }\n-                    }\n-                }\n-                if *sorted {\n-                    break\n-                }\n-            }\n-        }\n-\n-        if !self.sorted {\n-            canonical_sort(&mut self.buffer);\n-            self.sorted = true;\n-        }\n-\n-        if self.buffer.is_empty() {\n-            None\n-        } else {\n-            match self.buffer.remove(0) {\n-                (c, 0) => {\n-                    self.sorted = false;\n-                    Some(c)\n-                }\n-                (c, _) => Some(c),\n-            }\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (lower, _) = self.iter.size_hint();\n-        (lower, None)\n-    }\n-}\n-\n-#[derive(Clone)]\n-enum RecompositionState {\n-    Composing,\n-    Purging,\n-    Finished\n-}\n-\n-/// External iterator for a string recomposition's characters.\n-///\n-/// For use with the `std::iter` module.\n-#[allow(deprecated)]\n-#[deprecated(reason = \"use the crates.io `unicode-normalization` library instead\",\n-             since = \"1.0.0\")]\n-#[derive(Clone)]\n-#[unstable(feature = \"unicode\",\n-           reason = \"this functionality may be replaced with a more generic \\\n-                     unicode crate on crates.io\")]\n-pub struct Recompositions<'a> {\n-    iter: Decompositions<'a>,\n-    state: RecompositionState,\n-    buffer: VecDeque<char>,\n-    composee: Option<char>,\n-    last_ccc: Option<u8>\n-}\n-\n-#[allow(deprecated)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> Iterator for Recompositions<'a> {\n-    type Item = char;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<char> {\n-        loop {\n-            match self.state {\n-                Composing => {\n-                    for ch in self.iter.by_ref() {\n-                        let ch_class = rustc_unicode::char::canonical_combining_class(ch);\n-                        if self.composee.is_none() {\n-                            if ch_class != 0 {\n-                                return Some(ch);\n-                            }\n-                            self.composee = Some(ch);\n-                            continue;\n-                        }\n-                        let k = self.composee.clone().unwrap();\n-\n-                        match self.last_ccc {\n-                            None => {\n-                                match rustc_unicode::char::compose(k, ch) {\n-                                    Some(r) => {\n-                                        self.composee = Some(r);\n-                                        continue;\n-                                    }\n-                                    None => {\n-                                        if ch_class == 0 {\n-                                            self.composee = Some(ch);\n-                                            return Some(k);\n-                                        }\n-                                        self.buffer.push_back(ch);\n-                                        self.last_ccc = Some(ch_class);\n-                                    }\n-                                }\n-                            }\n-                            Some(l_class) => {\n-                                if l_class >= ch_class {\n-                                    // `ch` is blocked from `composee`\n-                                    if ch_class == 0 {\n-                                        self.composee = Some(ch);\n-                                        self.last_ccc = None;\n-                                        self.state = Purging;\n-                                        return Some(k);\n-                                    }\n-                                    self.buffer.push_back(ch);\n-                                    self.last_ccc = Some(ch_class);\n-                                    continue;\n-                                }\n-                                match rustc_unicode::char::compose(k, ch) {\n-                                    Some(r) => {\n-                                        self.composee = Some(r);\n-                                        continue;\n-                                    }\n-                                    None => {\n-                                        self.buffer.push_back(ch);\n-                                        self.last_ccc = Some(ch_class);\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                    self.state = Finished;\n-                    if self.composee.is_some() {\n-                        return self.composee.take();\n-                    }\n-                }\n-                Purging => {\n-                    match self.buffer.pop_front() {\n-                        None => self.state = Composing,\n-                        s => return s\n-                    }\n-                }\n-                Finished => {\n-                    match self.buffer.pop_front() {\n-                        None => return self.composee.take(),\n-                        s => return s\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n /// External iterator for a string's UTF16 codeunits.\n ///\n /// For use with the `std::iter` module.\n@@ -408,28 +181,6 @@ impl str {\n         core_str::StrExt::is_empty(self)\n     }\n \n-    /// Returns a string's displayed width in columns.\n-    ///\n-    /// Control characters have zero width.\n-    ///\n-    /// `is_cjk` determines behavior for characters in the Ambiguous category:\n-    /// if `is_cjk` is\n-    /// `true`, these are 2 columns wide; otherwise, they are 1.\n-    /// In CJK locales, `is_cjk` should be\n-    /// `true`, else it should be `false`.\n-    /// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)\n-    /// recommends that these\n-    /// characters be treated as 1 column (i.e., `is_cjk = false`) if the\n-    /// locale is unknown.\n-    #[deprecated(reason = \"use the crates.io `unicode-width` library instead\",\n-                 since = \"1.0.0\")]\n-    #[unstable(feature = \"unicode\",\n-               reason = \"this functionality may only be provided by libunicode\")]\n-    #[inline]\n-    pub fn width(&self, is_cjk: bool) -> usize {\n-        UnicodeStr::width(self, is_cjk)\n-    }\n-\n     /// Checks that `index`-th byte lies at the start and/or end of a\n     /// UTF-8 code point sequence.\n     ///\n@@ -530,42 +281,6 @@ impl str {\n         core_str::StrExt::slice_mut_unchecked(self, begin, end)\n     }\n \n-    /// Returns a slice of the string from the range [`begin`..`end`) where indices\n-    /// are counted in code points.\n-    ///\n-    /// That is, start at the `begin`-th code point of the string and continue\n-    /// to the `end`-th code point. This does not detect or handle edge cases\n-    /// such as leaving a combining character as the first `char` of the\n-    /// string.\n-    ///\n-    /// Due to the design of UTF-8, this operation is `O(end)`. Use slicing\n-    /// syntax if you want to use `O(1)` byte indices instead.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `begin` > `end` or the either `begin` or `end` are beyond the\n-    /// last character of the string.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(slice_chars)]\n-    ///\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    ///\n-    /// assert_eq!(s.slice_chars(0, 4), \"L\u00f6we\");\n-    /// assert_eq!(s.slice_chars(5, 7), \"\u8001\u864e\");\n-    /// ```\n-    #[unstable(feature = \"slice_chars\",\n-               reason = \"may have yet to prove its worth\")]\n-    #[deprecated(since = \"1.3.0\",\n-                 reason = \"can be implemented with char_indices and \\\n-                           hasn't seen enough use to justify inclusion\")]\n-    #[inline]\n-    pub fn slice_chars(&self, begin: usize, end: usize) -> &str {\n-        core_str::StrExt::slice_chars(self, begin, end)\n-    }\n-\n     /// Given a byte position, return the next code point and its index.\n     ///\n     /// This can be used to iterate over the Unicode code points of a string.\n@@ -603,8 +318,8 @@ impl str {\n     /// 6: V\n     /// 7: i\n     /// 8: e\n-    /// 9: \u0323\n-    /// 11: \u0302\n+    /// 9:\n+    /// 11:\n     /// 13: t\n     /// 14:\n     /// 15: N\n@@ -662,8 +377,8 @@ impl str {\n     /// 16: N\n     /// 15:\n     /// 14: t\n-    /// 13: \u0302\n-    /// 11: \u0323\n+    /// 13:\n+    /// 11:\n     /// 9: e\n     /// 8: i\n     /// 7: V\n@@ -880,30 +595,6 @@ impl str {\n         UnicodeStr::split_whitespace(self)\n     }\n \n-    /// An iterator over the non-empty substrings of `self` which contain no whitespace,\n-    /// and which are separated by any amount of whitespace.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(str_words)]\n-    /// #![allow(deprecated)]\n-    ///\n-    /// let some_words = \" Mary   had\\ta\\u{2009}little  \\n\\t lamb\";\n-    /// let v: Vec<&str> = some_words.words().collect();\n-    ///\n-    /// assert_eq!(v, [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n-    /// ```\n-    #[deprecated(reason = \"words() will be removed. Use split_whitespace() instead\",\n-                 since = \"1.1.0\")]\n-    #[unstable(feature = \"str_words\",\n-               reason = \"the precise algorithm to use is unclear\")]\n-    #[allow(deprecated)]\n-    #[inline]\n-    pub fn words(&self) -> Words {\n-        UnicodeStr::words(self)\n-    }\n-\n     /// An iterator over the lines of a string, separated by `\\n`.\n     ///\n     /// This does not include the empty string after a trailing `\\n`.\n@@ -959,135 +650,6 @@ impl str {\n         core_str::StrExt::lines_any(self)\n     }\n \n-    /// Returns an iterator over the string in Unicode Normalization Form D\n-    /// (canonical decomposition).\n-    #[allow(deprecated)]\n-    #[deprecated(reason = \"use the crates.io `unicode-normalization` library instead\",\n-             since = \"1.0.0\")]\n-    #[inline]\n-    #[unstable(feature = \"unicode\",\n-               reason = \"this functionality may be replaced with a more generic \\\n-                         unicode crate on crates.io\")]\n-    pub fn nfd_chars(&self) -> Decompositions {\n-        Decompositions {\n-            iter: self[..].chars(),\n-            buffer: Vec::new(),\n-            sorted: false,\n-            kind: Canonical\n-        }\n-    }\n-\n-    /// Returns an iterator over the string in Unicode Normalization Form KD\n-    /// (compatibility decomposition).\n-    #[allow(deprecated)]\n-    #[deprecated(reason = \"use the crates.io `unicode-normalization` library instead\",\n-             since = \"1.0.0\")]\n-    #[inline]\n-    #[unstable(feature = \"unicode\",\n-               reason = \"this functionality may be replaced with a more generic \\\n-                         unicode crate on crates.io\")]\n-    pub fn nfkd_chars(&self) -> Decompositions {\n-        Decompositions {\n-            iter: self[..].chars(),\n-            buffer: Vec::new(),\n-            sorted: false,\n-            kind: Compatible\n-        }\n-    }\n-\n-    /// An Iterator over the string in Unicode Normalization Form C\n-    /// (canonical decomposition followed by canonical composition).\n-    #[allow(deprecated)]\n-    #[deprecated(reason = \"use the crates.io `unicode-normalization` library instead\",\n-             since = \"1.0.0\")]\n-    #[inline]\n-    #[unstable(feature = \"unicode\",\n-               reason = \"this functionality may be replaced with a more generic \\\n-                         unicode crate on crates.io\")]\n-    pub fn nfc_chars(&self) -> Recompositions {\n-        Recompositions {\n-            iter: self.nfd_chars(),\n-            state: Composing,\n-            buffer: VecDeque::new(),\n-            composee: None,\n-            last_ccc: None\n-        }\n-    }\n-\n-    /// An Iterator over the string in Unicode Normalization Form KC\n-    /// (compatibility decomposition followed by canonical composition).\n-    #[allow(deprecated)]\n-    #[deprecated(reason = \"use the crates.io `unicode-normalization` library instead\",\n-             since = \"1.0.0\")]\n-    #[inline]\n-    #[unstable(feature = \"unicode\",\n-               reason = \"this functionality may be replaced with a more generic \\\n-                         unicode crate on crates.io\")]\n-    pub fn nfkc_chars(&self) -> Recompositions {\n-        Recompositions {\n-            iter: self.nfkd_chars(),\n-            state: Composing,\n-            buffer: VecDeque::new(),\n-            composee: None,\n-            last_ccc: None\n-        }\n-    }\n-\n-    /// Returns an iterator over the [grapheme clusters][graphemes] of `self`.\n-    ///\n-    /// [graphemes]: http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries\n-    ///\n-    /// If `is_extended` is true, the iterator is over the\n-    /// *extended grapheme clusters*;\n-    /// otherwise, the iterator is over the *legacy grapheme clusters*.\n-    /// [UAX#29](http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries)\n-    /// recommends extended grapheme cluster boundaries for general processing.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(unicode, core)]\n-    ///\n-    /// let gr1 = \"a\\u{310}e\\u{301}o\\u{308}\\u{332}\".graphemes(true).collect::<Vec<&str>>();\n-    /// let b: &[_] = &[\"a\\u{310}\", \"e\\u{301}\", \"o\\u{308}\\u{332}\"];\n-    ///\n-    /// assert_eq!(&gr1[..], b);\n-    ///\n-    /// let gr2 = \"a\\r\\nb\ud83c\uddf7\ud83c\uddfa\ud83c\uddf8\ud83c\uddf9\".graphemes(true).collect::<Vec<&str>>();\n-    /// let b: &[_] = &[\"a\", \"\\r\\n\", \"b\", \"\ud83c\uddf7\ud83c\uddfa\ud83c\uddf8\ud83c\uddf9\"];\n-    ///\n-    /// assert_eq!(&gr2[..], b);\n-    /// ```\n-    #[deprecated(reason = \"use the crates.io `unicode-segmentation` library instead\",\n-             since = \"1.0.0\")]\n-    #[unstable(feature = \"unicode\",\n-               reason = \"this functionality may only be provided by libunicode\")]\n-    pub fn graphemes(&self, is_extended: bool) -> Graphemes {\n-        UnicodeStr::graphemes(self, is_extended)\n-    }\n-\n-    /// Returns an iterator over the grapheme clusters of `self` and their\n-    /// byte offsets. See\n-    /// `graphemes()` for more information.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(unicode, core)]\n-    ///\n-    /// let gr_inds = \"a\u0310e\u0301o\u0308\u0332\\r\\n\".grapheme_indices(true).collect::<Vec<(usize, &str)>>();\n-    /// let b: &[_] = &[(0, \"a\u0310\"), (3, \"e\u0301\"), (6, \"o\u0308\u0332\"), (11, \"\\r\\n\")];\n-    ///\n-    /// assert_eq!(&gr_inds[..], b);\n-    /// ```\n-    #[deprecated(reason = \"use the crates.io `unicode-segmentation` library instead\",\n-             since = \"1.0.0\")]\n-    #[unstable(feature = \"unicode\",\n-               reason = \"this functionality may only be provided by libunicode\")]\n-    pub fn grapheme_indices(&self, is_extended: bool) -> GraphemeIndices {\n-        UnicodeStr::grapheme_indices(self, is_extended)\n-    }\n-\n     /// Returns an iterator of `u16` over the string encoded as UTF-16.\n     #[unstable(feature = \"str_utf16\",\n                reason = \"this functionality may only be provided by libunicode\")]\n@@ -1678,33 +1240,6 @@ impl str {\n         core_str::StrExt::rmatch_indices(self, pat)\n     }\n \n-    /// Returns the byte offset of an inner slice relative to an enclosing\n-    /// outer slice.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `inner` is not a direct slice contained within self.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(subslice_offset)]\n-    ///\n-    /// let string = \"a\\nb\\nc\";\n-    /// let lines: Vec<&str> = string.lines().collect();\n-    ///\n-    /// assert!(string.subslice_offset(lines[0]) == 0); // &\"a\"\n-    /// assert!(string.subslice_offset(lines[1]) == 2); // &\"b\"\n-    /// assert!(string.subslice_offset(lines[2]) == 4); // &\"c\"\n-    /// ```\n-    #[unstable(feature = \"subslice_offset\",\n-               reason = \"awaiting convention about comparability of arbitrary slices\")]\n-    #[deprecated(since = \"1.3.0\",\n-                 reason = \"replaced with other pattern-related methods\")]\n-    pub fn subslice_offset(&self, inner: &str) -> usize {\n-        core_str::StrExt::subslice_offset(self, inner)\n-    }\n-\n     /// Returns a `&str` with leading and trailing whitespace removed.\n     ///\n     /// # Examples"}, {"sha": "e588680074800a8d2231bcc5730940ab33e752b9", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -82,24 +82,6 @@ impl String {\n         }\n     }\n \n-    /// Creates a new string buffer from the given string.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(collections)]\n-    ///\n-    /// let s = String::from(\"hello\");\n-    /// assert_eq!(&s[..], \"hello\");\n-    /// ```\n-    #[inline]\n-    #[unstable(feature = \"collections\", reason = \"use `String::from` instead\")]\n-    #[deprecated(since = \"1.2.0\", reason = \"use `String::from` instead\")]\n-    #[cfg(not(test))]\n-    pub fn from_str(string: &str) -> String {\n-        String { vec: <[_]>::to_vec(string.as_bytes()) }\n-    }\n-\n     // HACK(japaric): with cfg(test) the inherent `[T]::to_vec` method, which is\n     // required for this method definition, is not available. Since we don't\n     // require this method for testing purposes, I'll just stub it"}, {"sha": "957c1a767a4cfa72af6bba98443337327c8f357f", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 15, "deletions": 326, "changes": 341, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -32,7 +32,8 @@\n //! let v = vec![0; 10]; // ten zeroes\n //! ```\n //!\n-//! You can `push` values onto the end of a vector (which will grow the vector as needed):\n+//! You can `push` values onto the end of a vector (which will grow the vector\n+//! as needed):\n //!\n //! ```\n //! let mut v = vec![1, 2];\n@@ -66,7 +67,6 @@ use core::fmt;\n use core::hash::{self, Hash};\n use core::intrinsics::{arith_offset, assume, drop_in_place};\n use core::iter::FromIterator;\n-use core::marker::PhantomData;\n use core::mem;\n use core::ops::{Index, IndexMut, Deref};\n use core::ops;\n@@ -177,12 +177,13 @@ impl<T> Vec<T> {\n \n     /// Constructs a new, empty `Vec<T>` with the specified capacity.\n     ///\n-    /// The vector will be able to hold exactly `capacity` elements without reallocating. If\n-    /// `capacity` is 0, the vector will not allocate.\n+    /// The vector will be able to hold exactly `capacity` elements without\n+    /// reallocating. If `capacity` is 0, the vector will not allocate.\n     ///\n-    /// It is important to note that this function does not specify the *length* of the returned\n-    /// vector, but only the *capacity*. (For an explanation of the difference between length and\n-    /// capacity, see the main `Vec<T>` docs above, 'Capacity and reallocation'.)\n+    /// It is important to note that this function does not specify the *length*\n+    /// of the returned vector, but only the *capacity*. (For an explanation of\n+    /// the difference between length and capacity, see the main `Vec<T>` docs\n+    /// above, 'Capacity and reallocation'.)\n     ///\n     /// # Examples\n     ///\n@@ -260,24 +261,6 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Creates a vector by copying the elements from a raw pointer.\n-    ///\n-    /// This function will copy `elts` contiguous elements starting at `ptr`\n-    /// into a new allocation owned by the returned `Vec<T>`. The elements of\n-    /// the buffer are copied into the vector without cloning, as if\n-    /// `ptr::read()` were called on them.\n-    #[inline]\n-    #[unstable(feature = \"vec_from_raw_buf\",\n-               reason = \"may be better expressed via composition\")]\n-    #[deprecated(since = \"1.2.0\",\n-                 reason = \"use slice::from_raw_parts + .to_vec() instead\")]\n-    pub unsafe fn from_raw_buf(ptr: *const T, elts: usize) -> Vec<T> {\n-        let mut dst = Vec::with_capacity(elts);\n-        dst.set_len(elts);\n-        ptr::copy_nonoverlapping(ptr, dst.as_mut_ptr(), elts);\n-        dst\n-    }\n-\n     /// Returns the number of elements the vector can hold without\n     /// reallocating.\n     ///\n@@ -597,7 +580,8 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Removes the last element from a vector and returns it, or `None` if it is empty.\n+    /// Removes the last element from a vector and returns it, or `None` if it\n+    /// is empty.\n     ///\n     /// # Examples\n     ///\n@@ -755,210 +739,6 @@ impl<T> Vec<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n-    /// Converts a `Vec<T>` to a `Vec<U>` where `T` and `U` have the same\n-    /// size and in case they are not zero-sized the same minimal alignment.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `T` and `U` have differing sizes or are not zero-sized and\n-    /// have differing minimal alignments.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(map_in_place)]\n-    ///\n-    /// let v = vec![0, 1, 2];\n-    /// let w = v.map_in_place(|i| i + 3);\n-    /// assert_eq!(&w[..], &[3, 4, 5]);\n-    ///\n-    /// #[derive(PartialEq, Debug)]\n-    /// struct Newtype(u8);\n-    /// let bytes = vec![0x11, 0x22];\n-    /// let newtyped_bytes = bytes.map_in_place(|x| Newtype(x));\n-    /// assert_eq!(&newtyped_bytes[..], &[Newtype(0x11), Newtype(0x22)]);\n-    /// ```\n-    #[unstable(feature = \"map_in_place\",\n-               reason = \"API may change to provide stronger guarantees\")]\n-    #[deprecated(since = \"1.3.0\",\n-                 reason = \"unclear that the API is strong enough and did \\\n-                           not proven itself\")]\n-    pub fn map_in_place<U, F>(self, mut f: F) -> Vec<U> where F: FnMut(T) -> U {\n-        // FIXME: Assert statically that the types `T` and `U` have the same\n-        // size.\n-        assert!(mem::size_of::<T>() == mem::size_of::<U>());\n-\n-        let mut vec = self;\n-\n-        if mem::size_of::<T>() != 0 {\n-            // FIXME: Assert statically that the types `T` and `U` have the\n-            // same minimal alignment in case they are not zero-sized.\n-\n-            // These asserts are necessary because the `align_of` of the\n-            // types are passed to the allocator by `Vec`.\n-            assert!(mem::align_of::<T>() == mem::align_of::<U>());\n-\n-            // This `as isize` cast is safe, because the size of the elements of the\n-            // vector is not 0, and:\n-            //\n-            // 1) If the size of the elements in the vector is 1, the `isize` may\n-            //    overflow, but it has the correct bit pattern so that the\n-            //    `.offset()` function will work.\n-            //\n-            //    Example:\n-            //        Address space 0x0-0xF.\n-            //        `u8` array at: 0x1.\n-            //        Size of `u8` array: 0x8.\n-            //        Calculated `offset`: -0x8.\n-            //        After `array.offset(offset)`: 0x9.\n-            //        (0x1 + 0x8 = 0x1 - 0x8)\n-            //\n-            // 2) If the size of the elements in the vector is >1, the `usize` ->\n-            //    `isize` conversion can't overflow.\n-            let offset = vec.len() as isize;\n-            let start = vec.as_mut_ptr();\n-\n-            let mut pv = PartialVecNonZeroSized {\n-                vec: vec,\n-\n-                start_t: start,\n-                // This points inside the vector, as the vector has length\n-                // `offset`.\n-                end_t: unsafe { start.offset(offset) },\n-                start_u: start as *mut U,\n-                end_u: start as *mut U,\n-\n-                _marker: PhantomData,\n-            };\n-            //  start_t\n-            //  start_u\n-            //  |\n-            // +-+-+-+-+-+-+\n-            // |T|T|T|...|T|\n-            // +-+-+-+-+-+-+\n-            //  |           |\n-            //  end_u       end_t\n-\n-            while pv.end_u as *mut T != pv.end_t {\n-                unsafe {\n-                    //  start_u start_t\n-                    //  |       |\n-                    // +-+-+-+-+-+-+-+-+-+\n-                    // |U|...|U|T|T|...|T|\n-                    // +-+-+-+-+-+-+-+-+-+\n-                    //          |         |\n-                    //          end_u     end_t\n-\n-                    let t = ptr::read(pv.start_t);\n-                    //  start_u start_t\n-                    //  |       |\n-                    // +-+-+-+-+-+-+-+-+-+\n-                    // |U|...|U|X|T|...|T|\n-                    // +-+-+-+-+-+-+-+-+-+\n-                    //          |         |\n-                    //          end_u     end_t\n-                    // We must not panic here, one cell is marked as `T`\n-                    // although it is not `T`.\n-\n-                    pv.start_t = pv.start_t.offset(1);\n-                    //  start_u   start_t\n-                    //  |         |\n-                    // +-+-+-+-+-+-+-+-+-+\n-                    // |U|...|U|X|T|...|T|\n-                    // +-+-+-+-+-+-+-+-+-+\n-                    //          |         |\n-                    //          end_u     end_t\n-                    // We may panic again.\n-\n-                    // The function given by the user might panic.\n-                    let u = f(t);\n-\n-                    ptr::write(pv.end_u, u);\n-                    //  start_u   start_t\n-                    //  |         |\n-                    // +-+-+-+-+-+-+-+-+-+\n-                    // |U|...|U|U|T|...|T|\n-                    // +-+-+-+-+-+-+-+-+-+\n-                    //          |         |\n-                    //          end_u     end_t\n-                    // We should not panic here, because that would leak the `U`\n-                    // pointed to by `end_u`.\n-\n-                    pv.end_u = pv.end_u.offset(1);\n-                    //  start_u   start_t\n-                    //  |         |\n-                    // +-+-+-+-+-+-+-+-+-+\n-                    // |U|...|U|U|T|...|T|\n-                    // +-+-+-+-+-+-+-+-+-+\n-                    //            |       |\n-                    //            end_u   end_t\n-                    // We may panic again.\n-                }\n-            }\n-\n-            //  start_u     start_t\n-            //  |           |\n-            // +-+-+-+-+-+-+\n-            // |U|...|U|U|U|\n-            // +-+-+-+-+-+-+\n-            //              |\n-            //              end_t\n-            //              end_u\n-            // Extract `vec` and prevent the destructor of\n-            // `PartialVecNonZeroSized` from running. Note that none of the\n-            // function calls can panic, thus no resources can be leaked (as the\n-            // `vec` member of `PartialVec` is the only one which holds\n-            // allocations -- and it is returned from this function. None of\n-            // this can panic.\n-            unsafe {\n-                let vec_len = pv.vec.len();\n-                let vec_cap = pv.vec.capacity();\n-                let vec_ptr = pv.vec.as_mut_ptr() as *mut U;\n-                mem::forget(pv);\n-                Vec::from_raw_parts(vec_ptr, vec_len, vec_cap)\n-            }\n-        } else {\n-            // Put the `Vec` into the `PartialVecZeroSized` structure and\n-            // prevent the destructor of the `Vec` from running. Since the\n-            // `Vec` contained zero-sized objects, it did not allocate, so we\n-            // are not leaking memory here.\n-            let mut pv = PartialVecZeroSized::<T,U> {\n-                num_t: vec.len(),\n-                num_u: 0,\n-                marker: PhantomData,\n-            };\n-            mem::forget(vec);\n-\n-            while pv.num_t != 0 {\n-                unsafe {\n-                    // Create a `T` out of thin air and decrement `num_t`. This\n-                    // must not panic between these steps, as otherwise a\n-                    // destructor of `T` which doesn't exist runs.\n-                    let t = mem::uninitialized();\n-                    pv.num_t -= 1;\n-\n-                    // The function given by the user might panic.\n-                    let u = f(t);\n-\n-                    // Forget the `U` and increment `num_u`. This increment\n-                    // cannot overflow the `usize` as we only do this for a\n-                    // number of times that fits into a `usize` (and start with\n-                    // `0`). Again, we should not panic between these steps.\n-                    mem::forget(u);\n-                    pv.num_u += 1;\n-                }\n-            }\n-            // Create a `Vec` from our `PartialVecZeroSized` and make sure the\n-            // destructor of the latter will not run. None of this can panic.\n-            let mut result = Vec::new();\n-            unsafe {\n-                result.set_len(pv.num_u);\n-                mem::forget(pv);\n-            }\n-            result\n-        }\n-    }\n-\n     /// Splits the collection into two at the given index.\n     ///\n     /// Returns a newly allocated `Self`. `self` contains elements `[0, at)`,\n@@ -1081,9 +861,9 @@ impl<T: Clone> Vec<T> {\n         for i in 0..other.len() {\n             let len = self.len();\n \n-            // Unsafe code so this can be optimised to a memcpy (or something similarly\n-            // fast) when T is Copy. LLVM is easily confused, so any extra operations\n-            // during the loop can prevent this optimisation.\n+            // Unsafe code so this can be optimised to a memcpy (or something\n+            // similarly fast) when T is Copy. LLVM is easily confused, so any\n+            // extra operations during the loop can prevent this optimisation.\n             unsafe {\n                 ptr::write(\n                     self.get_unchecked_mut(len),\n@@ -1424,7 +1204,7 @@ impl<T> IntoIterator for Vec<T> {\n             };\n             let buf = ptr::read(&self.buf);\n             mem::forget(self);\n-            IntoIter { buf: buf, ptr: begin, end: end }\n+            IntoIter { _buf: buf, ptr: begin, end: end }\n         }\n     }\n }\n@@ -1608,14 +1388,12 @@ impl<'a, T> FromIterator<T> for Cow<'a, [T]> where T: Clone {\n     }\n }\n \n-#[allow(deprecated)]\n impl<'a, T: 'a> IntoCow<'a, [T]> for Vec<T> where T: Clone {\n     fn into_cow(self) -> Cow<'a, [T]> {\n         Cow::Owned(self)\n     }\n }\n \n-#[allow(deprecated)]\n impl<'a, T> IntoCow<'a, [T]> for &'a [T] where T: Clone {\n     fn into_cow(self) -> Cow<'a, [T]> {\n         Cow::Borrowed(self)\n@@ -1629,29 +1407,14 @@ impl<'a, T> IntoCow<'a, [T]> for &'a [T] where T: Clone {\n /// An iterator that moves out of a vector.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n-    buf: RawVec<T>,\n+    _buf: RawVec<T>,\n     ptr: *const T,\n     end: *const T\n }\n \n unsafe impl<T: Send> Send for IntoIter<T> { }\n unsafe impl<T: Sync> Sync for IntoIter<T> { }\n \n-impl<T> IntoIter<T> {\n-    #[inline]\n-    /// Drops all items that have not yet been moved and returns the empty vector.\n-    #[unstable(feature = \"iter_to_vec\")]\n-    #[deprecated(since = \"1.3.0\", reason = \"replaced by drain()\")]\n-    pub fn into_inner(mut self) -> Vec<T> {\n-        unsafe {\n-            for _x in self.by_ref() { }\n-            let buf = ptr::read(&self.buf);\n-            mem::forget(self);\n-            Vec { buf: buf, len: 0 }\n-        }\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Iterator for IntoIter<T> {\n     type Item = T;\n@@ -1800,77 +1563,3 @@ impl<'a, T> Drop for Drain<'a, T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Drain<'a, T> {}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Partial vec, used for map_in_place\n-////////////////////////////////////////////////////////////////////////////////\n-\n-/// An owned, partially type-converted vector of elements with non-zero size.\n-///\n-/// `T` and `U` must have the same, non-zero size. They must also have the same\n-/// alignment.\n-///\n-/// When the destructor of this struct runs, all `U`s from `start_u` (incl.) to\n-/// `end_u` (excl.) and all `T`s from `start_t` (incl.) to `end_t` (excl.) are\n-/// destructed. Additionally the underlying storage of `vec` will be freed.\n-struct PartialVecNonZeroSized<T,U> {\n-    vec: Vec<T>,\n-\n-    start_u: *mut U,\n-    end_u: *mut U,\n-    start_t: *mut T,\n-    end_t: *mut T,\n-\n-    _marker: PhantomData<U>,\n-}\n-\n-/// An owned, partially type-converted vector of zero-sized elements.\n-///\n-/// When the destructor of this struct runs, all `num_t` `T`s and `num_u` `U`s\n-/// are destructed.\n-struct PartialVecZeroSized<T,U> {\n-    num_t: usize,\n-    num_u: usize,\n-    marker: PhantomData<::core::cell::Cell<(T,U)>>,\n-}\n-\n-impl<T,U> Drop for PartialVecNonZeroSized<T,U> {\n-    fn drop(&mut self) {\n-        unsafe {\n-            // `vec` hasn't been modified until now. As it has a length\n-            // currently, this would run destructors of `T`s which might not be\n-            // there. So at first, set `vec`s length to `0`. This must be done\n-            // at first to remain memory-safe as the destructors of `U` or `T`\n-            // might cause unwinding where `vec`s destructor would be executed.\n-            self.vec.set_len(0);\n-\n-            // We have instances of `U`s and `T`s in `vec`. Destruct them.\n-            while self.start_u != self.end_u {\n-                let _ = ptr::read(self.start_u); // Run a `U` destructor.\n-                self.start_u = self.start_u.offset(1);\n-            }\n-            while self.start_t != self.end_t {\n-                let _ = ptr::read(self.start_t); // Run a `T` destructor.\n-                self.start_t = self.start_t.offset(1);\n-            }\n-            // After this destructor ran, the destructor of `vec` will run,\n-            // deallocating the underlying memory.\n-        }\n-    }\n-}\n-\n-impl<T,U> Drop for PartialVecZeroSized<T,U> {\n-    fn drop(&mut self) {\n-        unsafe {\n-            // Destruct the instances of `T` and `U` this struct owns.\n-            while self.num_t != 0 {\n-                let _: T = mem::uninitialized(); // Run a `T` destructor.\n-                self.num_t -= 1;\n-            }\n-            while self.num_u != 0 {\n-                let _: U = mem::uninitialized(); // Run a `U` destructor.\n-                self.num_u -= 1;\n-            }\n-        }\n-    }\n-}"}, {"sha": "94cce8e1b1c5cfe8654ab6c4b274a9b9ce8051c9", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -20,7 +20,7 @@\n \n use core::cmp::Ordering;\n use core::fmt;\n-use core::iter::{self, repeat, FromIterator, RandomAccessIterator};\n+use core::iter::{self, repeat, FromIterator};\n use core::ops::{Index, IndexMut};\n use core::ptr;\n use core::slice;\n@@ -1522,26 +1522,6 @@ impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n-impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n-    #[inline]\n-    fn indexable(&self) -> usize {\n-        let (len, _) = self.size_hint();\n-        len\n-    }\n-\n-    #[inline]\n-    fn idx(&mut self, j: usize) -> Option<&'a T> {\n-        if j >= self.indexable() {\n-            None\n-        } else {\n-            let idx = wrap_index(self.tail.wrapping_add(j), self.ring.len());\n-            unsafe { Some(self.ring.get_unchecked(idx)) }\n-        }\n-    }\n-}\n-\n /// `VecDeque` mutable iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T:'a> {"}, {"sha": "93f8db23e565a3aef7f61acf1bc469f1d64aa32d", "filename": "src/libcollections/vec_map.rs", "status": "removed", "additions": 0, "deletions": 1083, "changes": 1083, "blob_url": "https://github.com/rust-lang/rust/blob/a4066271b77810aec0a4a309f66a45e4f8b940de/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4066271b77810aec0a4a309f66a45e4f8b940de/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=a4066271b77810aec0a4a309f66a45e4f8b940de", "patch": "@@ -1,1083 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! A simple map based on a vector for small integer keys. Space requirements\n-//! are O(highest integer key).\n-\n-#![deprecated(reason = \"VecMap moved to crates.io as vec_map\",\n-              since = \"1.3.0\")]\n-#![unstable(feature = \"vecmap\", reason = \"deprecated\")]\n-#![allow(deprecated)]\n-\n-#![allow(missing_docs)]\n-\n-use self::Entry::*;\n-\n-use core::cmp::{max, Ordering};\n-use core::fmt;\n-use core::hash::{Hash, Hasher};\n-use core::iter::{Enumerate, FilterMap, Map, FromIterator};\n-use core::iter;\n-use core::mem::{replace, swap};\n-use core::ops::{Index, IndexMut};\n-\n-use {vec, slice};\n-use vec::Vec;\n-\n-/// A map optimized for small integer keys.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// #![feature(vecmap)]\n-///\n-/// use std::collections::VecMap;\n-///\n-/// let mut months = VecMap::new();\n-/// months.insert(1, \"Jan\");\n-/// months.insert(2, \"Feb\");\n-/// months.insert(3, \"Mar\");\n-///\n-/// if !months.contains_key(&12) {\n-///     println!(\"The end is near!\");\n-/// }\n-///\n-/// assert_eq!(months.get(&1), Some(&\"Jan\"));\n-///\n-/// if let Some(value) = months.get_mut(&3) {\n-///     *value = \"Venus\";\n-/// }\n-///\n-/// assert_eq!(months.get(&3), Some(&\"Venus\"));\n-///\n-/// // Print out all months\n-/// for (key, value) in &months {\n-///     println!(\"month {} is {}\", key, value);\n-/// }\n-///\n-/// months.clear();\n-/// assert!(months.is_empty());\n-/// ```\n-pub struct VecMap<V> {\n-    v: Vec<Option<V>>,\n-}\n-\n-/// A view into a single entry in a map, which may either be vacant or occupied.\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub enum Entry<'a, V:'a> {\n-    /// A vacant Entry\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Vacant(VacantEntry<'a, V>),\n-\n-    /// An occupied Entry\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Occupied(OccupiedEntry<'a, V>),\n-}\n-\n-/// A vacant Entry.\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct VacantEntry<'a, V:'a> {\n-    map: &'a mut VecMap<V>,\n-    index: usize,\n-}\n-\n-/// An occupied Entry.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct OccupiedEntry<'a, V:'a> {\n-    map: &'a mut VecMap<V>,\n-    index: usize,\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<V> Default for VecMap<V> {\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    fn default() -> VecMap<V> { VecMap::new() }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<V:Clone> Clone for VecMap<V> {\n-    #[inline]\n-    fn clone(&self) -> VecMap<V> {\n-        VecMap { v: self.v.clone() }\n-    }\n-\n-    #[inline]\n-    fn clone_from(&mut self, source: &VecMap<V>) {\n-        self.v.clone_from(&source.v);\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<V: Hash> Hash for VecMap<V> {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        // In order to not traverse the `VecMap` twice, count the elements\n-        // during iteration.\n-        let mut count: usize = 0;\n-        for elt in self {\n-            elt.hash(state);\n-            count += 1;\n-        }\n-        count.hash(state);\n-    }\n-}\n-\n-impl<V> VecMap<V> {\n-    /// Creates an empty `VecMap`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(vecmap)]\n-    ///\n-    /// use std::collections::VecMap;\n-    /// let mut map: VecMap<&str> = VecMap::new();\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new() -> VecMap<V> { VecMap { v: vec![] } }\n-\n-    /// Creates an empty `VecMap` with space for at least `capacity`\n-    /// elements before resizing.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(vecmap)]\n-    ///\n-    /// use std::collections::VecMap;\n-    /// let mut map: VecMap<&str> = VecMap::with_capacity(10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_capacity(capacity: usize) -> VecMap<V> {\n-        VecMap { v: Vec::with_capacity(capacity) }\n-    }\n-\n-    /// Returns the number of elements the `VecMap` can hold without\n-    /// reallocating.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(vecmap)]\n-    ///\n-    /// use std::collections::VecMap;\n-    /// let map: VecMap<String> = VecMap::with_capacity(10);\n-    /// assert!(map.capacity() >= 10);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn capacity(&self) -> usize {\n-        self.v.capacity()\n-    }\n-\n-    /// Reserves capacity for the given `VecMap` to contain `len` distinct keys.\n-    /// In the case of `VecMap` this means reallocations will not occur as long\n-    /// as all inserted keys are less than `len`.\n-    ///\n-    /// The collection may reserve more space to avoid frequent reallocations.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(vecmap)]\n-    ///\n-    /// use std::collections::VecMap;\n-    /// let mut map: VecMap<&str> = VecMap::new();\n-    /// map.reserve_len(10);\n-    /// assert!(map.capacity() >= 10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve_len(&mut self, len: usize) {\n-        let cur_len = self.v.len();\n-        if len >= cur_len {\n-            self.v.reserve(len - cur_len);\n-        }\n-    }\n-\n-    /// Reserves the minimum capacity for the given `VecMap` to contain `len` distinct keys.\n-    /// In the case of `VecMap` this means reallocations will not occur as long as all inserted\n-    /// keys are less than `len`.\n-    ///\n-    /// Note that the allocator may give the collection more space than it requests.\n-    /// Therefore capacity cannot be relied upon to be precisely minimal.  Prefer\n-    /// `reserve_len` if future insertions are expected.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(vecmap)]\n-    ///\n-    /// use std::collections::VecMap;\n-    /// let mut map: VecMap<&str> = VecMap::new();\n-    /// map.reserve_len_exact(10);\n-    /// assert!(map.capacity() >= 10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve_len_exact(&mut self, len: usize) {\n-        let cur_len = self.v.len();\n-        if len >= cur_len {\n-            self.v.reserve_exact(len - cur_len);\n-        }\n-    }\n-\n-    /// Returns an iterator visiting all keys in ascending order of the keys.\n-    /// The iterator's element type is `usize`.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn keys<'r>(&'r self) -> Keys<'r, V> {\n-        fn first<A, B>((a, _): (A, B)) -> A { a }\n-        let first: fn((usize, &'r V)) -> usize = first; // coerce to fn pointer\n-\n-        Keys { iter: self.iter().map(first) }\n-    }\n-\n-    /// Returns an iterator visiting all values in ascending order of the keys.\n-    /// The iterator's element type is `&'r V`.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn values<'r>(&'r self) -> Values<'r, V> {\n-        fn second<A, B>((_, b): (A, B)) -> B { b }\n-        let second: fn((usize, &'r V)) -> &'r V = second; // coerce to fn pointer\n-\n-        Values { iter: self.iter().map(second) }\n-    }\n-\n-    /// Returns an iterator visiting all key-value pairs in ascending order of the keys.\n-    /// The iterator's element type is `(usize, &'r V)`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(vecmap)]\n-    ///\n-    /// use std::collections::VecMap;\n-    ///\n-    /// let mut map = VecMap::new();\n-    /// map.insert(1, \"a\");\n-    /// map.insert(3, \"c\");\n-    /// map.insert(2, \"b\");\n-    ///\n-    /// // Print `1: a` then `2: b` then `3: c`\n-    /// for (key, value) in map.iter() {\n-    ///     println!(\"{}: {}\", key, value);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn iter<'r>(&'r self) -> Iter<'r, V> {\n-        Iter {\n-            front: 0,\n-            back: self.v.len(),\n-            iter: self.v.iter()\n-        }\n-    }\n-\n-    /// Returns an iterator visiting all key-value pairs in ascending order of the keys,\n-    /// with mutable references to the values.\n-    /// The iterator's element type is `(usize, &'r mut V)`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(vecmap)]\n-    ///\n-    /// use std::collections::VecMap;\n-    ///\n-    /// let mut map = VecMap::new();\n-    /// map.insert(1, \"a\");\n-    /// map.insert(2, \"b\");\n-    /// map.insert(3, \"c\");\n-    ///\n-    /// for (key, value) in map.iter_mut() {\n-    ///     *value = \"x\";\n-    /// }\n-    ///\n-    /// for (key, value) in &map {\n-    ///     assert_eq!(value, &\"x\");\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn iter_mut<'r>(&'r mut self) -> IterMut<'r, V> {\n-        IterMut {\n-            front: 0,\n-            back: self.v.len(),\n-            iter: self.v.iter_mut()\n-        }\n-    }\n-\n-    /// Moves all elements from `other` into the map while overwriting existing keys.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(vecmap, append)]\n-    ///\n-    /// use std::collections::VecMap;\n-    ///\n-    /// let mut a = VecMap::new();\n-    /// a.insert(1, \"a\");\n-    /// a.insert(2, \"b\");\n-    ///\n-    /// let mut b = VecMap::new();\n-    /// b.insert(3, \"c\");\n-    /// b.insert(4, \"d\");\n-    ///\n-    /// a.append(&mut b);\n-    ///\n-    /// assert_eq!(a.len(), 4);\n-    /// assert_eq!(b.len(), 0);\n-    /// assert_eq!(a[1], \"a\");\n-    /// assert_eq!(a[2], \"b\");\n-    /// assert_eq!(a[3], \"c\");\n-    /// assert_eq!(a[4], \"d\");\n-    /// ```\n-    #[unstable(feature = \"append\",\n-               reason = \"recently added as part of collections reform 2\")]\n-    pub fn append(&mut self, other: &mut Self) {\n-        self.extend(other.drain());\n-    }\n-\n-    /// Splits the collection into two at the given key.\n-    ///\n-    /// Returns a newly allocated `Self`. `self` contains elements `[0, at)`,\n-    /// and the returned `Self` contains elements `[at, max_key)`.\n-    ///\n-    /// Note that the capacity of `self` does not change.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(vecmap, split_off)]\n-    ///\n-    /// use std::collections::VecMap;\n-    ///\n-    /// let mut a = VecMap::new();\n-    /// a.insert(1, \"a\");\n-    /// a.insert(2, \"b\");\n-    /// a.insert(3, \"c\");\n-    /// a.insert(4, \"d\");\n-    ///\n-    /// let b = a.split_off(3);\n-    ///\n-    /// assert_eq!(a[1], \"a\");\n-    /// assert_eq!(a[2], \"b\");\n-    ///\n-    /// assert_eq!(b[3], \"c\");\n-    /// assert_eq!(b[4], \"d\");\n-    /// ```\n-    #[unstable(feature = \"split_off\",\n-               reason = \"recently added as part of collections reform 2\")]\n-    pub fn split_off(&mut self, at: usize) -> Self {\n-        let mut other = VecMap::new();\n-\n-        if at == 0 {\n-            // Move all elements to other\n-            swap(self, &mut other);\n-            return other\n-        } else if at >= self.v.len() {\n-            // No elements to copy\n-            return other;\n-        }\n-\n-        // Look up the index of the first non-None item\n-        let first_index = self.v.iter().position(|el| el.is_some());\n-        let start_index = match first_index {\n-            Some(index) => max(at, index),\n-            None => {\n-                // self has no elements\n-                return other;\n-            }\n-        };\n-\n-        // Fill the new VecMap with `None`s until `start_index`\n-        other.v.extend((0..start_index).map(|_| None));\n-\n-        // Move elements beginning with `start_index` from `self` into `other`\n-        other.v.extend(self.v[start_index..].iter_mut().map(|el| el.take()));\n-\n-        other\n-    }\n-\n-    /// Returns an iterator visiting all key-value pairs in ascending order of\n-    /// the keys, emptying (but not consuming) the original `VecMap`.\n-    /// The iterator's element type is `(usize, &'r V)`. Keeps the allocated memory for reuse.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(vecmap, drain)]\n-    ///\n-    /// use std::collections::VecMap;\n-    ///\n-    /// let mut map = VecMap::new();\n-    /// map.insert(1, \"a\");\n-    /// map.insert(3, \"c\");\n-    /// map.insert(2, \"b\");\n-    ///\n-    /// let vec: Vec<(usize, &str)> = map.drain().collect();\n-    ///\n-    /// assert_eq!(vec, [(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n-    /// ```\n-    #[unstable(feature = \"drain\",\n-               reason = \"matches collection reform specification, waiting for dust to settle\")]\n-    pub fn drain<'a>(&'a mut self) -> Drain<'a, V> {\n-        fn filter<A>((i, v): (usize, Option<A>)) -> Option<(usize, A)> {\n-            v.map(|v| (i, v))\n-        }\n-        let filter: fn((usize, Option<V>)) -> Option<(usize, V)> = filter; // coerce to fn ptr\n-\n-        Drain { iter: self.v.drain(..).enumerate().filter_map(filter) }\n-    }\n-\n-    /// Returns the number of elements in the map.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(vecmap)]\n-    ///\n-    /// use std::collections::VecMap;\n-    ///\n-    /// let mut a = VecMap::new();\n-    /// assert_eq!(a.len(), 0);\n-    /// a.insert(1, \"a\");\n-    /// assert_eq!(a.len(), 1);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> usize {\n-        self.v.iter().filter(|elt| elt.is_some()).count()\n-    }\n-\n-    /// Returns true if the map contains no elements.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(vecmap)]\n-    ///\n-    /// use std::collections::VecMap;\n-    ///\n-    /// let mut a = VecMap::new();\n-    /// assert!(a.is_empty());\n-    /// a.insert(1, \"a\");\n-    /// assert!(!a.is_empty());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_empty(&self) -> bool {\n-        self.v.iter().all(|elt| elt.is_none())\n-    }\n-\n-    /// Clears the map, removing all key-value pairs.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(vecmap)]\n-    ///\n-    /// use std::collections::VecMap;\n-    ///\n-    /// let mut a = VecMap::new();\n-    /// a.insert(1, \"a\");\n-    /// a.clear();\n-    /// assert!(a.is_empty());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn clear(&mut self) { self.v.clear() }\n-\n-    /// Returns a reference to the value corresponding to the key.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(vecmap)]\n-    ///\n-    /// use std::collections::VecMap;\n-    ///\n-    /// let mut map = VecMap::new();\n-    /// map.insert(1, \"a\");\n-    /// assert_eq!(map.get(&1), Some(&\"a\"));\n-    /// assert_eq!(map.get(&2), None);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get(&self, key: &usize) -> Option<&V> {\n-        if *key < self.v.len() {\n-            match self.v[*key] {\n-              Some(ref value) => Some(value),\n-              None => None\n-            }\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Returns true if the map contains a value for the specified key.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(vecmap)]\n-    ///\n-    /// use std::collections::VecMap;\n-    ///\n-    /// let mut map = VecMap::new();\n-    /// map.insert(1, \"a\");\n-    /// assert_eq!(map.contains_key(&1), true);\n-    /// assert_eq!(map.contains_key(&2), false);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn contains_key(&self, key: &usize) -> bool {\n-        self.get(key).is_some()\n-    }\n-\n-    /// Returns a mutable reference to the value corresponding to the key.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(vecmap)]\n-    ///\n-    /// use std::collections::VecMap;\n-    ///\n-    /// let mut map = VecMap::new();\n-    /// map.insert(1, \"a\");\n-    /// if let Some(x) = map.get_mut(&1) {\n-    ///     *x = \"b\";\n-    /// }\n-    /// assert_eq!(map[1], \"b\");\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_mut(&mut self, key: &usize) -> Option<&mut V> {\n-        if *key < self.v.len() {\n-            match *(&mut self.v[*key]) {\n-              Some(ref mut value) => Some(value),\n-              None => None\n-            }\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Inserts a key-value pair into the map. If the key already had a value\n-    /// present in the map, that value is returned. Otherwise, `None` is returned.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(vecmap)]\n-    ///\n-    /// use std::collections::VecMap;\n-    ///\n-    /// let mut map = VecMap::new();\n-    /// assert_eq!(map.insert(37, \"a\"), None);\n-    /// assert_eq!(map.is_empty(), false);\n-    ///\n-    /// map.insert(37, \"b\");\n-    /// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n-    /// assert_eq!(map[37], \"c\");\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn insert(&mut self, key: usize, value: V) -> Option<V> {\n-        let len = self.v.len();\n-        if len <= key {\n-            self.v.extend((0..key - len + 1).map(|_| None));\n-        }\n-        replace(&mut self.v[key], Some(value))\n-    }\n-\n-    /// Removes a key from the map, returning the value at the key if the key\n-    /// was previously in the map.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(vecmap)]\n-    ///\n-    /// use std::collections::VecMap;\n-    ///\n-    /// let mut map = VecMap::new();\n-    /// map.insert(1, \"a\");\n-    /// assert_eq!(map.remove(&1), Some(\"a\"));\n-    /// assert_eq!(map.remove(&1), None);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn remove(&mut self, key: &usize) -> Option<V> {\n-        if *key >= self.v.len() {\n-            return None;\n-        }\n-        let result = &mut self.v[*key];\n-        result.take()\n-    }\n-\n-    /// Gets the given key's corresponding entry in the map for in-place manipulation.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(vecmap, entry)]\n-    ///\n-    /// use std::collections::VecMap;\n-    ///\n-    /// let mut count: VecMap<u32> = VecMap::new();\n-    ///\n-    /// // count the number of occurrences of numbers in the vec\n-    /// for x in vec![1, 2, 1, 2, 3, 4, 1, 2, 4] {\n-    ///     *count.entry(x).or_insert(0) += 1;\n-    /// }\n-    ///\n-    /// assert_eq!(count[1], 3);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn entry(&mut self, key: usize) -> Entry<V> {\n-        // FIXME(Gankro): this is basically the dumbest implementation of\n-        // entry possible, because weird non-lexical borrows issues make it\n-        // completely insane to do any other way. That said, Entry is a border-line\n-        // useless construct on VecMap, so it's hardly a big loss.\n-        if self.contains_key(&key) {\n-            Occupied(OccupiedEntry {\n-                map: self,\n-                index: key,\n-            })\n-        } else {\n-            Vacant(VacantEntry {\n-                map: self,\n-                index: key,\n-            })\n-        }\n-    }\n-}\n-\n-\n-impl<'a, V> Entry<'a, V> {\n-    #[unstable(feature = \"entry\",\n-               reason = \"will soon be replaced by or_insert\")]\n-    #[deprecated(since = \"1.0\",\n-                reason = \"replaced with more ergonomic `or_insert` and `or_insert_with`\")]\n-    /// Returns a mutable reference to the entry if occupied, or the VacantEntry if vacant\n-    pub fn get(self) -> Result<&'a mut V, VacantEntry<'a, V>> {\n-        match self {\n-            Occupied(entry) => Ok(entry.into_mut()),\n-            Vacant(entry) => Err(entry),\n-        }\n-    }\n-\n-    #[stable(feature = \"vecmap_entry\", since = \"1.2.0\")]\n-    /// Ensures a value is in the entry by inserting the default if empty, and\n-    /// returns a mutable reference to the value in the entry.\n-    pub fn or_insert(self, default: V) -> &'a mut V {\n-        match self {\n-            Occupied(entry) => entry.into_mut(),\n-            Vacant(entry) => entry.insert(default),\n-        }\n-    }\n-\n-    #[stable(feature = \"vecmap_entry\", since = \"1.2.0\")]\n-    /// Ensures a value is in the entry by inserting the result of the default\n-    /// function if empty, and returns a mutable reference to the value in the\n-    /// entry.\n-    pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V {\n-        match self {\n-            Occupied(entry) => entry.into_mut(),\n-            Vacant(entry) => entry.insert(default()),\n-        }\n-    }\n-}\n-\n-impl<'a, V> VacantEntry<'a, V> {\n-    /// Sets the value of the entry with the VacantEntry's key,\n-    /// and returns a mutable reference to it.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn insert(self, value: V) -> &'a mut V {\n-        let index = self.index;\n-        self.map.insert(index, value);\n-        &mut self.map[index]\n-    }\n-}\n-\n-impl<'a, V> OccupiedEntry<'a, V> {\n-    /// Gets a reference to the value in the entry.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get(&self) -> &V {\n-        let index = self.index;\n-        &self.map[index]\n-    }\n-\n-    /// Gets a mutable reference to the value in the entry.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_mut(&mut self) -> &mut V {\n-        let index = self.index;\n-        &mut self.map[index]\n-    }\n-\n-    /// Converts the entry into a mutable reference to its value.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_mut(self) -> &'a mut V {\n-        let index = self.index;\n-        &mut self.map[index]\n-    }\n-\n-    /// Sets the value of the entry with the OccupiedEntry's key,\n-    /// and returns the entry's old value.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn insert(&mut self, value: V) -> V {\n-        let index = self.index;\n-        self.map.insert(index, value).unwrap()\n-    }\n-\n-    /// Takes the value of the entry out of the map, and returns it.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn remove(self) -> V {\n-        let index = self.index;\n-        self.map.remove(&index).unwrap()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<V: PartialEq> PartialEq for VecMap<V> {\n-    fn eq(&self, other: &VecMap<V>) -> bool {\n-        iter::order::eq(self.iter(), other.iter())\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<V: Eq> Eq for VecMap<V> {}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<V: PartialOrd> PartialOrd for VecMap<V> {\n-    #[inline]\n-    fn partial_cmp(&self, other: &VecMap<V>) -> Option<Ordering> {\n-        iter::order::partial_cmp(self.iter(), other.iter())\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<V: Ord> Ord for VecMap<V> {\n-    #[inline]\n-    fn cmp(&self, other: &VecMap<V>) -> Ordering {\n-        iter::order::cmp(self.iter(), other.iter())\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<V: fmt::Debug> fmt::Debug for VecMap<V> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"{{\"));\n-\n-        for (i, (k, v)) in self.iter().enumerate() {\n-            if i != 0 { try!(write!(f, \", \")); }\n-            try!(write!(f, \"{}: {:?}\", k, *v));\n-        }\n-\n-        write!(f, \"}}\")\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<V> FromIterator<(usize, V)> for VecMap<V> {\n-    fn from_iter<I: IntoIterator<Item=(usize, V)>>(iter: I) -> VecMap<V> {\n-        let mut map = VecMap::new();\n-        map.extend(iter);\n-        map\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> IntoIterator for VecMap<T> {\n-    type Item = (usize, T);\n-    type IntoIter = IntoIter<T>;\n-\n-    /// Returns an iterator visiting all key-value pairs in ascending order of\n-    /// the keys, consuming the original `VecMap`.\n-    /// The iterator's element type is `(usize, &'r V)`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(vecmap)]\n-    ///\n-    /// use std::collections::VecMap;\n-    ///\n-    /// let mut map = VecMap::new();\n-    /// map.insert(1, \"a\");\n-    /// map.insert(3, \"c\");\n-    /// map.insert(2, \"b\");\n-    ///\n-    /// let vec: Vec<(usize, &str)> = map.into_iter().collect();\n-    ///\n-    /// assert_eq!(vec, [(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n-    /// ```\n-    fn into_iter(self) -> IntoIter<T> {\n-        fn filter<A>((i, v): (usize, Option<A>)) -> Option<(usize, A)> {\n-            v.map(|v| (i, v))\n-        }\n-        let filter: fn((usize, Option<T>)) -> Option<(usize, T)> = filter; // coerce to fn ptr\n-\n-        IntoIter { iter: self.v.into_iter().enumerate().filter_map(filter) }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> IntoIterator for &'a VecMap<T> {\n-    type Item = (usize, &'a T);\n-    type IntoIter = Iter<'a, T>;\n-\n-    fn into_iter(self) -> Iter<'a, T> {\n-        self.iter()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> IntoIterator for &'a mut VecMap<T> {\n-    type Item = (usize, &'a mut T);\n-    type IntoIter = IterMut<'a, T>;\n-\n-    fn into_iter(mut self) -> IterMut<'a, T> {\n-        self.iter_mut()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<V> Extend<(usize, V)> for VecMap<V> {\n-    fn extend<I: IntoIterator<Item=(usize, V)>>(&mut self, iter: I) {\n-        for (k, v) in iter {\n-            self.insert(k, v);\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n-impl<'a, V: Copy> Extend<(usize, &'a V)> for VecMap<V> {\n-    fn extend<I: IntoIterator<Item=(usize, &'a V)>>(&mut self, iter: I) {\n-        self.extend(iter.into_iter().map(|(key, &value)| (key, value)));\n-    }\n-}\n-\n-impl<V> Index<usize> for VecMap<V> {\n-    type Output = V;\n-\n-    #[inline]\n-    fn index<'a>(&'a self, i: usize) -> &'a V {\n-        self.get(&i).expect(\"key not present\")\n-    }\n-}\n-\n-impl<'a,V> Index<&'a usize> for VecMap<V> {\n-    type Output = V;\n-\n-    #[inline]\n-    fn index(&self, i: &usize) -> &V {\n-        self.get(i).expect(\"key not present\")\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<V> IndexMut<usize> for VecMap<V> {\n-    #[inline]\n-    fn index_mut(&mut self, i: usize) -> &mut V {\n-        self.get_mut(&i).expect(\"key not present\")\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, V> IndexMut<&'a usize> for VecMap<V> {\n-    #[inline]\n-    fn index_mut(&mut self, i: &usize) -> &mut V {\n-        self.get_mut(i).expect(\"key not present\")\n-    }\n-}\n-\n-macro_rules! iterator {\n-    (impl $name:ident -> $elem:ty, $($getter:ident),+) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<'a, V> Iterator for $name<'a, V> {\n-            type Item = $elem;\n-\n-            #[inline]\n-            fn next(&mut self) -> Option<$elem> {\n-                while self.front < self.back {\n-                    match self.iter.next() {\n-                        Some(elem) => {\n-                            match elem$(. $getter ())+ {\n-                                Some(x) => {\n-                                    let index = self.front;\n-                                    self.front += 1;\n-                                    return Some((index, x));\n-                                },\n-                                None => {},\n-                            }\n-                        }\n-                        _ => ()\n-                    }\n-                    self.front += 1;\n-                }\n-                None\n-            }\n-\n-            #[inline]\n-            fn size_hint(&self) -> (usize, Option<usize>) {\n-                (0, Some(self.back - self.front))\n-            }\n-        }\n-    }\n-}\n-\n-macro_rules! double_ended_iterator {\n-    (impl $name:ident -> $elem:ty, $($getter:ident),+) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<'a, V> DoubleEndedIterator for $name<'a, V> {\n-            #[inline]\n-            fn next_back(&mut self) -> Option<$elem> {\n-                while self.front < self.back {\n-                    match self.iter.next_back() {\n-                        Some(elem) => {\n-                            match elem$(. $getter ())+ {\n-                                Some(x) => {\n-                                    self.back -= 1;\n-                                    return Some((self.back, x));\n-                                },\n-                                None => {},\n-                            }\n-                        }\n-                        _ => ()\n-                    }\n-                    self.back -= 1;\n-                }\n-                None\n-            }\n-        }\n-    }\n-}\n-\n-/// An iterator over the key-value pairs of a map.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Iter<'a, V:'a> {\n-    front: usize,\n-    back: usize,\n-    iter: slice::Iter<'a, Option<V>>\n-}\n-\n-// FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-impl<'a, V> Clone for Iter<'a, V> {\n-    fn clone(&self) -> Iter<'a, V> {\n-        Iter {\n-            front: self.front,\n-            back: self.back,\n-            iter: self.iter.clone()\n-        }\n-    }\n-}\n-\n-iterator! { impl Iter -> (usize, &'a V), as_ref }\n-double_ended_iterator! { impl Iter -> (usize, &'a V), as_ref }\n-\n-/// An iterator over the key-value pairs of a map, with the\n-/// values being mutable.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct IterMut<'a, V:'a> {\n-    front: usize,\n-    back: usize,\n-    iter: slice::IterMut<'a, Option<V>>\n-}\n-\n-iterator! { impl IterMut -> (usize, &'a mut V), as_mut }\n-double_ended_iterator! { impl IterMut -> (usize, &'a mut V), as_mut }\n-\n-/// An iterator over the keys of a map.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Keys<'a, V: 'a> {\n-    iter: Map<Iter<'a, V>, fn((usize, &'a V)) -> usize>\n-}\n-\n-// FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-impl<'a, V> Clone for Keys<'a, V> {\n-    fn clone(&self) -> Keys<'a, V> {\n-        Keys {\n-            iter: self.iter.clone()\n-        }\n-    }\n-}\n-\n-/// An iterator over the values of a map.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Values<'a, V: 'a> {\n-    iter: Map<Iter<'a, V>, fn((usize, &'a V)) -> &'a V>\n-}\n-\n-// FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-impl<'a, V> Clone for Values<'a, V> {\n-    fn clone(&self) -> Values<'a, V> {\n-        Values {\n-            iter: self.iter.clone()\n-        }\n-    }\n-}\n-\n-/// A consuming iterator over the key-value pairs of a map.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct IntoIter<V> {\n-    iter: FilterMap<\n-    Enumerate<vec::IntoIter<Option<V>>>,\n-    fn((usize, Option<V>)) -> Option<(usize, V)>>\n-}\n-\n-#[unstable(feature = \"drain\")]\n-pub struct Drain<'a, V:'a> {\n-    iter: FilterMap<\n-    Enumerate<vec::Drain<'a, Option<V>>>,\n-    fn((usize, Option<V>)) -> Option<(usize, V)>>\n-}\n-\n-#[unstable(feature = \"drain\")]\n-impl<'a, V> Iterator for Drain<'a, V> {\n-    type Item = (usize, V);\n-\n-    fn next(&mut self) -> Option<(usize, V)> { self.iter.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n-}\n-\n-#[unstable(feature = \"drain\")]\n-impl<'a, V> DoubleEndedIterator for Drain<'a, V> {\n-    fn next_back(&mut self) -> Option<(usize, V)> { self.iter.next_back() }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, V> Iterator for Keys<'a, V> {\n-    type Item = usize;\n-\n-    fn next(&mut self) -> Option<usize> { self.iter.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, V> DoubleEndedIterator for Keys<'a, V> {\n-    fn next_back(&mut self) -> Option<usize> { self.iter.next_back() }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, V> Iterator for Values<'a, V> {\n-    type Item = &'a V;\n-\n-    fn next(&mut self) -> Option<(&'a V)> { self.iter.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, V> DoubleEndedIterator for Values<'a, V> {\n-    fn next_back(&mut self) -> Option<(&'a V)> { self.iter.next_back() }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<V> Iterator for IntoIter<V> {\n-    type Item = (usize, V);\n-\n-    fn next(&mut self) -> Option<(usize, V)> { self.iter.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<V> DoubleEndedIterator for IntoIter<V> {\n-    fn next_back(&mut self) -> Option<(usize, V)> { self.iter.next_back() }\n-}"}, {"sha": "8e06524f2e5ae539c315cb4205979715990037b1", "filename": "src/libcollectionstest/bit/mod.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a4066271b77810aec0a4a309f66a45e4f8b940de/src%2Flibcollectionstest%2Fbit%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4066271b77810aec0a4a309f66a45e4f8b940de/src%2Flibcollectionstest%2Fbit%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbit%2Fmod.rs?ref=a4066271b77810aec0a4a309f66a45e4f8b940de", "patch": "@@ -1,12 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-mod set;\n-mod vec;"}, {"sha": "8ab3eff0f4f6425e490adf4c09b6da257867e527", "filename": "src/libcollectionstest/bit/set.rs", "status": "removed", "additions": 0, "deletions": 520, "changes": 520, "blob_url": "https://github.com/rust-lang/rust/blob/a4066271b77810aec0a4a309f66a45e4f8b940de/src%2Flibcollectionstest%2Fbit%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4066271b77810aec0a4a309f66a45e4f8b940de/src%2Flibcollectionstest%2Fbit%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbit%2Fset.rs?ref=a4066271b77810aec0a4a309f66a45e4f8b940de", "patch": "@@ -1,520 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::cmp::Ordering::{Equal, Greater, Less};\n-use std::collections::{BitSet, BitVec};\n-\n-#[test]\n-fn test_bit_set_show() {\n-    let mut s = BitSet::new();\n-    s.insert(1);\n-    s.insert(10);\n-    s.insert(50);\n-    s.insert(2);\n-    assert_eq!(\"{1, 2, 10, 50}\", format!(\"{:?}\", s));\n-}\n-\n-#[test]\n-fn test_bit_set_from_usizes() {\n-    let usizes = vec![0, 2, 2, 3];\n-    let a: BitSet = usizes.into_iter().collect();\n-    let mut b = BitSet::new();\n-    b.insert(0);\n-    b.insert(2);\n-    b.insert(3);\n-    assert_eq!(a, b);\n-}\n-\n-#[test]\n-fn test_bit_set_iterator() {\n-    let usizes = vec![0, 2, 2, 3];\n-    let bit_vec: BitSet = usizes.into_iter().collect();\n-\n-    let idxs: Vec<_> = bit_vec.iter().collect();\n-    assert_eq!(idxs, [0, 2, 3]);\n-\n-    let long: BitSet = (0..10000).filter(|&n| n % 2 == 0).collect();\n-    let real: Vec<_> = (0..10000).step_by(2).collect();\n-\n-    let idxs: Vec<_> = long.iter().collect();\n-    assert_eq!(idxs, real);\n-}\n-\n-#[test]\n-fn test_bit_set_frombit_vec_init() {\n-    let bools = [true, false];\n-    let lengths = [10, 64, 100];\n-    for &b in &bools {\n-        for &l in &lengths {\n-            let bitset = BitSet::from_bit_vec(BitVec::from_elem(l, b));\n-            assert_eq!(bitset.contains(&1), b);\n-            assert_eq!(bitset.contains(&(l-1)), b);\n-            assert!(!bitset.contains(&l));\n-        }\n-    }\n-}\n-\n-#[test]\n-fn test_bit_vec_masking() {\n-    let b = BitVec::from_elem(140, true);\n-    let mut bs = BitSet::from_bit_vec(b);\n-    assert!(bs.contains(&139));\n-    assert!(!bs.contains(&140));\n-    assert!(bs.insert(150));\n-    assert!(!bs.contains(&140));\n-    assert!(!bs.contains(&149));\n-    assert!(bs.contains(&150));\n-    assert!(!bs.contains(&151));\n-}\n-\n-#[test]\n-fn test_bit_set_basic() {\n-    let mut b = BitSet::new();\n-    assert!(b.insert(3));\n-    assert!(!b.insert(3));\n-    assert!(b.contains(&3));\n-    assert!(b.insert(4));\n-    assert!(!b.insert(4));\n-    assert!(b.contains(&3));\n-    assert!(b.insert(400));\n-    assert!(!b.insert(400));\n-    assert!(b.contains(&400));\n-    assert_eq!(b.len(), 3);\n-}\n-\n-#[test]\n-fn test_bit_set_intersection() {\n-    let mut a = BitSet::new();\n-    let mut b = BitSet::new();\n-\n-    assert!(a.insert(11));\n-    assert!(a.insert(1));\n-    assert!(a.insert(3));\n-    assert!(a.insert(77));\n-    assert!(a.insert(103));\n-    assert!(a.insert(5));\n-\n-    assert!(b.insert(2));\n-    assert!(b.insert(11));\n-    assert!(b.insert(77));\n-    assert!(b.insert(5));\n-    assert!(b.insert(3));\n-\n-    let expected = [3, 5, 11, 77];\n-    let actual: Vec<_> = a.intersection(&b).collect();\n-    assert_eq!(actual, expected);\n-}\n-\n-#[test]\n-fn test_bit_set_difference() {\n-    let mut a = BitSet::new();\n-    let mut b = BitSet::new();\n-\n-    assert!(a.insert(1));\n-    assert!(a.insert(3));\n-    assert!(a.insert(5));\n-    assert!(a.insert(200));\n-    assert!(a.insert(500));\n-\n-    assert!(b.insert(3));\n-    assert!(b.insert(200));\n-\n-    let expected = [1, 5, 500];\n-    let actual: Vec<_> = a.difference(&b).collect();\n-    assert_eq!(actual, expected);\n-}\n-\n-#[test]\n-fn test_bit_set_symmetric_difference() {\n-    let mut a = BitSet::new();\n-    let mut b = BitSet::new();\n-\n-    assert!(a.insert(1));\n-    assert!(a.insert(3));\n-    assert!(a.insert(5));\n-    assert!(a.insert(9));\n-    assert!(a.insert(11));\n-\n-    assert!(b.insert(3));\n-    assert!(b.insert(9));\n-    assert!(b.insert(14));\n-    assert!(b.insert(220));\n-\n-    let expected = [1, 5, 11, 14, 220];\n-    let actual: Vec<_> = a.symmetric_difference(&b).collect();\n-    assert_eq!(actual, expected);\n-}\n-\n-#[test]\n-fn test_bit_set_union() {\n-    let mut a = BitSet::new();\n-    let mut b = BitSet::new();\n-    assert!(a.insert(1));\n-    assert!(a.insert(3));\n-    assert!(a.insert(5));\n-    assert!(a.insert(9));\n-    assert!(a.insert(11));\n-    assert!(a.insert(160));\n-    assert!(a.insert(19));\n-    assert!(a.insert(24));\n-    assert!(a.insert(200));\n-\n-    assert!(b.insert(1));\n-    assert!(b.insert(5));\n-    assert!(b.insert(9));\n-    assert!(b.insert(13));\n-    assert!(b.insert(19));\n-\n-    let expected = [1, 3, 5, 9, 11, 13, 19, 24, 160, 200];\n-    let actual: Vec<_> = a.union(&b).collect();\n-    assert_eq!(actual, expected);\n-}\n-\n-#[test]\n-fn test_bit_set_subset() {\n-    let mut set1 = BitSet::new();\n-    let mut set2 = BitSet::new();\n-\n-    assert!(set1.is_subset(&set2)); //  {}  {}\n-    set2.insert(100);\n-    assert!(set1.is_subset(&set2)); //  {}  { 1 }\n-    set2.insert(200);\n-    assert!(set1.is_subset(&set2)); //  {}  { 1, 2 }\n-    set1.insert(200);\n-    assert!(set1.is_subset(&set2)); //  { 2 }  { 1, 2 }\n-    set1.insert(300);\n-    assert!(!set1.is_subset(&set2)); // { 2, 3 }  { 1, 2 }\n-    set2.insert(300);\n-    assert!(set1.is_subset(&set2)); // { 2, 3 }  { 1, 2, 3 }\n-    set2.insert(400);\n-    assert!(set1.is_subset(&set2)); // { 2, 3 }  { 1, 2, 3, 4 }\n-    set2.remove(&100);\n-    assert!(set1.is_subset(&set2)); // { 2, 3 }  { 2, 3, 4 }\n-    set2.remove(&300);\n-    assert!(!set1.is_subset(&set2)); // { 2, 3 }  { 2, 4 }\n-    set1.remove(&300);\n-    assert!(set1.is_subset(&set2)); // { 2 }  { 2, 4 }\n-}\n-\n-#[test]\n-fn test_bit_set_is_disjoint() {\n-    let a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n-    let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01000000]));\n-    let c = BitSet::new();\n-    let d = BitSet::from_bit_vec(BitVec::from_bytes(&[0b00110000]));\n-\n-    assert!(!a.is_disjoint(&d));\n-    assert!(!d.is_disjoint(&a));\n-\n-    assert!(a.is_disjoint(&b));\n-    assert!(a.is_disjoint(&c));\n-    assert!(b.is_disjoint(&a));\n-    assert!(b.is_disjoint(&c));\n-    assert!(c.is_disjoint(&a));\n-    assert!(c.is_disjoint(&b));\n-}\n-\n-#[test]\n-fn test_bit_set_union_with() {\n-    //a should grow to include larger elements\n-    let mut a = BitSet::new();\n-    a.insert(0);\n-    let mut b = BitSet::new();\n-    b.insert(5);\n-    let expected = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10000100]));\n-    a.union_with(&b);\n-    assert_eq!(a, expected);\n-\n-    // Standard\n-    let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n-    let mut b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01100010]));\n-    let c = a.clone();\n-    a.union_with(&b);\n-    b.union_with(&c);\n-    assert_eq!(a.len(), 4);\n-    assert_eq!(b.len(), 4);\n-}\n-\n-#[test]\n-fn test_bit_set_intersect_with() {\n-    // Explicitly 0'ed bits\n-    let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n-    let mut b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b00000000]));\n-    let c = a.clone();\n-    a.intersect_with(&b);\n-    b.intersect_with(&c);\n-    assert!(a.is_empty());\n-    assert!(b.is_empty());\n-\n-    // Uninitialized bits should behave like 0's\n-    let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n-    let mut b = BitSet::new();\n-    let c = a.clone();\n-    a.intersect_with(&b);\n-    b.intersect_with(&c);\n-    assert!(a.is_empty());\n-    assert!(b.is_empty());\n-\n-    // Standard\n-    let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n-    let mut b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01100010]));\n-    let c = a.clone();\n-    a.intersect_with(&b);\n-    b.intersect_with(&c);\n-    assert_eq!(a.len(), 2);\n-    assert_eq!(b.len(), 2);\n-}\n-\n-#[test]\n-fn test_bit_set_difference_with() {\n-    // Explicitly 0'ed bits\n-    let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b00000000]));\n-    let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n-    a.difference_with(&b);\n-    assert!(a.is_empty());\n-\n-    // Uninitialized bits should behave like 0's\n-    let mut a = BitSet::new();\n-    let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b11111111]));\n-    a.difference_with(&b);\n-    assert!(a.is_empty());\n-\n-    // Standard\n-    let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n-    let mut b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01100010]));\n-    let c = a.clone();\n-    a.difference_with(&b);\n-    b.difference_with(&c);\n-    assert_eq!(a.len(), 1);\n-    assert_eq!(b.len(), 1);\n-}\n-\n-#[test]\n-fn test_bit_set_symmetric_difference_with() {\n-    //a should grow to include larger elements\n-    let mut a = BitSet::new();\n-    a.insert(0);\n-    a.insert(1);\n-    let mut b = BitSet::new();\n-    b.insert(1);\n-    b.insert(5);\n-    let expected = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10000100]));\n-    a.symmetric_difference_with(&b);\n-    assert_eq!(a, expected);\n-\n-    let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n-    let b = BitSet::new();\n-    let c = a.clone();\n-    a.symmetric_difference_with(&b);\n-    assert_eq!(a, c);\n-\n-    // Standard\n-    let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b11100010]));\n-    let mut b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01101010]));\n-    let c = a.clone();\n-    a.symmetric_difference_with(&b);\n-    b.symmetric_difference_with(&c);\n-    assert_eq!(a.len(), 2);\n-    assert_eq!(b.len(), 2);\n-}\n-\n-#[test]\n-fn test_bit_set_eq() {\n-    let a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n-    let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b00000000]));\n-    let c = BitSet::new();\n-\n-    assert!(a == a);\n-    assert!(a != b);\n-    assert!(a != c);\n-    assert!(b == b);\n-    assert!(b == c);\n-    assert!(c == c);\n-}\n-\n-#[test]\n-fn test_bit_set_cmp() {\n-    let a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n-    let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b00000000]));\n-    let c = BitSet::new();\n-\n-    assert_eq!(a.cmp(&b), Greater);\n-    assert_eq!(a.cmp(&c), Greater);\n-    assert_eq!(b.cmp(&a), Less);\n-    assert_eq!(b.cmp(&c), Equal);\n-    assert_eq!(c.cmp(&a), Less);\n-    assert_eq!(c.cmp(&b), Equal);\n-}\n-\n-#[test]\n-fn test_bit_vec_remove() {\n-    let mut a = BitSet::new();\n-\n-    assert!(a.insert(1));\n-    assert!(a.remove(&1));\n-\n-    assert!(a.insert(100));\n-    assert!(a.remove(&100));\n-\n-    assert!(a.insert(1000));\n-    assert!(a.remove(&1000));\n-    a.shrink_to_fit();\n-}\n-\n-#[test]\n-fn test_bit_vec_clone() {\n-    let mut a = BitSet::new();\n-\n-    assert!(a.insert(1));\n-    assert!(a.insert(100));\n-    assert!(a.insert(1000));\n-\n-    let mut b = a.clone();\n-\n-    assert!(a == b);\n-\n-    assert!(b.remove(&1));\n-    assert!(a.contains(&1));\n-\n-    assert!(a.remove(&1000));\n-    assert!(b.contains(&1000));\n-}\n-\n-#[test]\n-fn test_bit_set_append() {\n-    let mut a = BitSet::new();\n-    a.insert(2);\n-    a.insert(6);\n-\n-    let mut b = BitSet::new();\n-    b.insert(1);\n-    b.insert(3);\n-    b.insert(6);\n-\n-    a.append(&mut b);\n-\n-    assert_eq!(a.len(), 4);\n-    assert_eq!(b.len(), 0);\n-    assert!(b.capacity() >= 6);\n-\n-    assert_eq!(a, BitSet::from_bit_vec(BitVec::from_bytes(&[0b01110010])));\n-}\n-\n-#[test]\n-fn test_bit_set_split_off() {\n-    // Split at 0\n-    let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100000, 0b00010010, 0b10010010,\n-                                                          0b00110011, 0b01101011, 0b10101101]));\n-\n-    let b = a.split_off(0);\n-\n-    assert_eq!(a.len(), 0);\n-    assert_eq!(b.len(), 21);\n-\n-    assert_eq!(b, BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100000, 0b00010010, 0b10010010,\n-                                                            0b00110011, 0b01101011, 0b10101101])));\n-\n-    // Split behind last element\n-    let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100000, 0b00010010, 0b10010010,\n-                                                          0b00110011, 0b01101011, 0b10101101]));\n-\n-    let b = a.split_off(50);\n-\n-    assert_eq!(a.len(), 21);\n-    assert_eq!(b.len(), 0);\n-\n-    assert_eq!(a, BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100000, 0b00010010, 0b10010010,\n-                                                            0b00110011, 0b01101011, 0b10101101])));\n-\n-    // Split at arbitrary element\n-    let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100000, 0b00010010, 0b10010010,\n-                                                          0b00110011, 0b01101011, 0b10101101]));\n-\n-    let b = a.split_off(34);\n-\n-    assert_eq!(a.len(), 12);\n-    assert_eq!(b.len(), 9);\n-\n-    assert_eq!(a, BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100000, 0b00010010, 0b10010010,\n-                                                            0b00110011, 0b01000000])));\n-    assert_eq!(b, BitSet::from_bit_vec(BitVec::from_bytes(&[0, 0, 0, 0,\n-                                                            0b00101011, 0b10101101])));\n-}\n-\n-#[test]\n-fn test_bit_set_extend_ref() {\n-    let mut a = BitSet::new();\n-    a.insert(3);\n-\n-    a.extend(&[5, 7, 10]);\n-\n-    assert_eq!(a.len(), 4);\n-    assert_eq!(a, BitSet::from_bit_vec(BitVec::from_bytes(&[0b00010101,0b00100000])));\n-\n-    let mut b = BitSet::new();\n-    b.insert(11);\n-    b.insert(15);\n-\n-    a.extend(&b);\n-\n-    assert_eq!(a.len(), 6);\n-    assert_eq!(a, BitSet::from_bit_vec(BitVec::from_bytes(&[0b00010101,0b00110001])));\n-}\n-\n-mod bench {\n-    use std::collections::{BitSet, BitVec};\n-    use std::__rand::{Rng, thread_rng, ThreadRng};\n-    use std::u32;\n-\n-    use test::{Bencher, black_box};\n-\n-    const BENCH_BITS : usize = 1 << 14;\n-\n-    fn rng() -> ThreadRng {\n-        thread_rng()\n-    }\n-\n-    #[bench]\n-    fn bench_bit_vecset_small(b: &mut Bencher) {\n-        let mut r = rng();\n-        let mut bit_vec = BitSet::new();\n-        b.iter(|| {\n-            for _ in 0..100 {\n-                bit_vec.insert((r.next_u32() as usize) % u32::BITS);\n-            }\n-            black_box(&bit_vec);\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_bit_vecset_big(b: &mut Bencher) {\n-        let mut r = rng();\n-        let mut bit_vec = BitSet::new();\n-        b.iter(|| {\n-            for _ in 0..100 {\n-                bit_vec.insert((r.next_u32() as usize) % BENCH_BITS);\n-            }\n-            black_box(&bit_vec);\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_bit_vecset_iter(b: &mut Bencher) {\n-        let bit_vec = BitSet::from_bit_vec(BitVec::from_fn(BENCH_BITS,\n-                                              |idx| {idx % 3 == 0}));\n-        b.iter(|| {\n-            let mut sum = 0;\n-            for idx in &bit_vec {\n-                sum += idx as usize;\n-            }\n-            sum\n-        })\n-    }\n-}"}, {"sha": "486a651e679fdf4014f120981c828e3b3c2f0da5", "filename": "src/libcollectionstest/bit/vec.rs", "status": "removed", "additions": 0, "deletions": 881, "changes": 881, "blob_url": "https://github.com/rust-lang/rust/blob/a4066271b77810aec0a4a309f66a45e4f8b940de/src%2Flibcollectionstest%2Fbit%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4066271b77810aec0a4a309f66a45e4f8b940de/src%2Flibcollectionstest%2Fbit%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbit%2Fvec.rs?ref=a4066271b77810aec0a4a309f66a45e4f8b940de", "patch": "@@ -1,881 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::collections::BitVec;\n-use std::u32;\n-\n-#[test]\n-fn test_to_str() {\n-    let zerolen = BitVec::new();\n-    assert_eq!(format!(\"{:?}\", zerolen), \"\");\n-\n-    let eightbits = BitVec::from_elem(8, false);\n-    assert_eq!(format!(\"{:?}\", eightbits), \"00000000\")\n-}\n-\n-#[test]\n-fn test_0_elements() {\n-    let act = BitVec::new();\n-    let exp = Vec::new();\n-    assert!(act.eq_vec(&exp));\n-    assert!(act.none() && act.all());\n-}\n-\n-#[test]\n-fn test_1_element() {\n-    let mut act = BitVec::from_elem(1, false);\n-    assert!(act.eq_vec(&[false]));\n-    assert!(act.none() && !act.all());\n-    act = BitVec::from_elem(1, true);\n-    assert!(act.eq_vec(&[true]));\n-    assert!(!act.none() && act.all());\n-}\n-\n-#[test]\n-fn test_2_elements() {\n-    let mut b = BitVec::from_elem(2, false);\n-    b.set(0, true);\n-    b.set(1, false);\n-    assert_eq!(format!(\"{:?}\", b), \"10\");\n-    assert!(!b.none() && !b.all());\n-}\n-\n-#[test]\n-fn test_10_elements() {\n-    let mut act;\n-    // all 0\n-\n-    act = BitVec::from_elem(10, false);\n-    assert!((act.eq_vec(\n-                &[false, false, false, false, false, false, false, false, false, false])));\n-    assert!(act.none() && !act.all());\n-    // all 1\n-\n-    act = BitVec::from_elem(10, true);\n-    assert!((act.eq_vec(&[true, true, true, true, true, true, true, true, true, true])));\n-    assert!(!act.none() && act.all());\n-    // mixed\n-\n-    act = BitVec::from_elem(10, false);\n-    act.set(0, true);\n-    act.set(1, true);\n-    act.set(2, true);\n-    act.set(3, true);\n-    act.set(4, true);\n-    assert!((act.eq_vec(&[true, true, true, true, true, false, false, false, false, false])));\n-    assert!(!act.none() && !act.all());\n-    // mixed\n-\n-    act = BitVec::from_elem(10, false);\n-    act.set(5, true);\n-    act.set(6, true);\n-    act.set(7, true);\n-    act.set(8, true);\n-    act.set(9, true);\n-    assert!((act.eq_vec(&[false, false, false, false, false, true, true, true, true, true])));\n-    assert!(!act.none() && !act.all());\n-    // mixed\n-\n-    act = BitVec::from_elem(10, false);\n-    act.set(0, true);\n-    act.set(3, true);\n-    act.set(6, true);\n-    act.set(9, true);\n-    assert!((act.eq_vec(&[true, false, false, true, false, false, true, false, false, true])));\n-    assert!(!act.none() && !act.all());\n-}\n-\n-#[test]\n-fn test_31_elements() {\n-    let mut act;\n-    // all 0\n-\n-    act = BitVec::from_elem(31, false);\n-    assert!(act.eq_vec(\n-            &[false, false, false, false, false, false, false, false, false, false, false,\n-              false, false, false, false, false, false, false, false, false, false, false,\n-              false, false, false, false, false, false, false, false, false]));\n-    assert!(act.none() && !act.all());\n-    // all 1\n-\n-    act = BitVec::from_elem(31, true);\n-    assert!(act.eq_vec(\n-            &[true, true, true, true, true, true, true, true, true, true, true, true, true,\n-              true, true, true, true, true, true, true, true, true, true, true, true, true,\n-              true, true, true, true, true]));\n-    assert!(!act.none() && act.all());\n-    // mixed\n-\n-    act = BitVec::from_elem(31, false);\n-    act.set(0, true);\n-    act.set(1, true);\n-    act.set(2, true);\n-    act.set(3, true);\n-    act.set(4, true);\n-    act.set(5, true);\n-    act.set(6, true);\n-    act.set(7, true);\n-    assert!(act.eq_vec(\n-            &[true, true, true, true, true, true, true, true, false, false, false, false, false,\n-              false, false, false, false, false, false, false, false, false, false, false,\n-              false, false, false, false, false, false, false]));\n-    assert!(!act.none() && !act.all());\n-    // mixed\n-\n-    act = BitVec::from_elem(31, false);\n-    act.set(16, true);\n-    act.set(17, true);\n-    act.set(18, true);\n-    act.set(19, true);\n-    act.set(20, true);\n-    act.set(21, true);\n-    act.set(22, true);\n-    act.set(23, true);\n-    assert!(act.eq_vec(\n-            &[false, false, false, false, false, false, false, false, false, false, false,\n-              false, false, false, false, false, true, true, true, true, true, true, true, true,\n-              false, false, false, false, false, false, false]));\n-    assert!(!act.none() && !act.all());\n-    // mixed\n-\n-    act = BitVec::from_elem(31, false);\n-    act.set(24, true);\n-    act.set(25, true);\n-    act.set(26, true);\n-    act.set(27, true);\n-    act.set(28, true);\n-    act.set(29, true);\n-    act.set(30, true);\n-    assert!(act.eq_vec(\n-            &[false, false, false, false, false, false, false, false, false, false, false,\n-              false, false, false, false, false, false, false, false, false, false, false,\n-              false, false, true, true, true, true, true, true, true]));\n-    assert!(!act.none() && !act.all());\n-    // mixed\n-\n-    act = BitVec::from_elem(31, false);\n-    act.set(3, true);\n-    act.set(17, true);\n-    act.set(30, true);\n-    assert!(act.eq_vec(\n-            &[false, false, false, true, false, false, false, false, false, false, false, false,\n-              false, false, false, false, false, true, false, false, false, false, false, false,\n-              false, false, false, false, false, false, true]));\n-    assert!(!act.none() && !act.all());\n-}\n-\n-#[test]\n-fn test_32_elements() {\n-    let mut act;\n-    // all 0\n-\n-    act = BitVec::from_elem(32, false);\n-    assert!(act.eq_vec(\n-            &[false, false, false, false, false, false, false, false, false, false, false,\n-              false, false, false, false, false, false, false, false, false, false, false,\n-              false, false, false, false, false, false, false, false, false, false]));\n-    assert!(act.none() && !act.all());\n-    // all 1\n-\n-    act = BitVec::from_elem(32, true);\n-    assert!(act.eq_vec(\n-            &[true, true, true, true, true, true, true, true, true, true, true, true, true,\n-              true, true, true, true, true, true, true, true, true, true, true, true, true,\n-              true, true, true, true, true, true]));\n-    assert!(!act.none() && act.all());\n-    // mixed\n-\n-    act = BitVec::from_elem(32, false);\n-    act.set(0, true);\n-    act.set(1, true);\n-    act.set(2, true);\n-    act.set(3, true);\n-    act.set(4, true);\n-    act.set(5, true);\n-    act.set(6, true);\n-    act.set(7, true);\n-    assert!(act.eq_vec(\n-            &[true, true, true, true, true, true, true, true, false, false, false, false, false,\n-              false, false, false, false, false, false, false, false, false, false, false,\n-              false, false, false, false, false, false, false, false]));\n-    assert!(!act.none() && !act.all());\n-    // mixed\n-\n-    act = BitVec::from_elem(32, false);\n-    act.set(16, true);\n-    act.set(17, true);\n-    act.set(18, true);\n-    act.set(19, true);\n-    act.set(20, true);\n-    act.set(21, true);\n-    act.set(22, true);\n-    act.set(23, true);\n-    assert!(act.eq_vec(\n-            &[false, false, false, false, false, false, false, false, false, false, false,\n-              false, false, false, false, false, true, true, true, true, true, true, true, true,\n-              false, false, false, false, false, false, false, false]));\n-    assert!(!act.none() && !act.all());\n-    // mixed\n-\n-    act = BitVec::from_elem(32, false);\n-    act.set(24, true);\n-    act.set(25, true);\n-    act.set(26, true);\n-    act.set(27, true);\n-    act.set(28, true);\n-    act.set(29, true);\n-    act.set(30, true);\n-    act.set(31, true);\n-    assert!(act.eq_vec(\n-            &[false, false, false, false, false, false, false, false, false, false, false,\n-              false, false, false, false, false, false, false, false, false, false, false,\n-              false, false, true, true, true, true, true, true, true, true]));\n-    assert!(!act.none() && !act.all());\n-    // mixed\n-\n-    act = BitVec::from_elem(32, false);\n-    act.set(3, true);\n-    act.set(17, true);\n-    act.set(30, true);\n-    act.set(31, true);\n-    assert!(act.eq_vec(\n-            &[false, false, false, true, false, false, false, false, false, false, false, false,\n-              false, false, false, false, false, true, false, false, false, false, false, false,\n-              false, false, false, false, false, false, true, true]));\n-    assert!(!act.none() && !act.all());\n-}\n-\n-#[test]\n-fn test_33_elements() {\n-    let mut act;\n-    // all 0\n-\n-    act = BitVec::from_elem(33, false);\n-    assert!(act.eq_vec(\n-            &[false, false, false, false, false, false, false, false, false, false, false,\n-              false, false, false, false, false, false, false, false, false, false, false,\n-              false, false, false, false, false, false, false, false, false, false, false]));\n-    assert!(act.none() && !act.all());\n-    // all 1\n-\n-    act = BitVec::from_elem(33, true);\n-    assert!(act.eq_vec(\n-            &[true, true, true, true, true, true, true, true, true, true, true, true, true,\n-              true, true, true, true, true, true, true, true, true, true, true, true, true,\n-              true, true, true, true, true, true, true]));\n-    assert!(!act.none() && act.all());\n-    // mixed\n-\n-    act = BitVec::from_elem(33, false);\n-    act.set(0, true);\n-    act.set(1, true);\n-    act.set(2, true);\n-    act.set(3, true);\n-    act.set(4, true);\n-    act.set(5, true);\n-    act.set(6, true);\n-    act.set(7, true);\n-    assert!(act.eq_vec(\n-            &[true, true, true, true, true, true, true, true, false, false, false, false, false,\n-              false, false, false, false, false, false, false, false, false, false, false,\n-              false, false, false, false, false, false, false, false, false]));\n-    assert!(!act.none() && !act.all());\n-    // mixed\n-\n-    act = BitVec::from_elem(33, false);\n-    act.set(16, true);\n-    act.set(17, true);\n-    act.set(18, true);\n-    act.set(19, true);\n-    act.set(20, true);\n-    act.set(21, true);\n-    act.set(22, true);\n-    act.set(23, true);\n-    assert!(act.eq_vec(\n-            &[false, false, false, false, false, false, false, false, false, false, false,\n-              false, false, false, false, false, true, true, true, true, true, true, true, true,\n-              false, false, false, false, false, false, false, false, false]));\n-    assert!(!act.none() && !act.all());\n-    // mixed\n-\n-    act = BitVec::from_elem(33, false);\n-    act.set(24, true);\n-    act.set(25, true);\n-    act.set(26, true);\n-    act.set(27, true);\n-    act.set(28, true);\n-    act.set(29, true);\n-    act.set(30, true);\n-    act.set(31, true);\n-    assert!(act.eq_vec(\n-            &[false, false, false, false, false, false, false, false, false, false, false,\n-              false, false, false, false, false, false, false, false, false, false, false,\n-              false, false, true, true, true, true, true, true, true, true, false]));\n-    assert!(!act.none() && !act.all());\n-    // mixed\n-\n-    act = BitVec::from_elem(33, false);\n-    act.set(3, true);\n-    act.set(17, true);\n-    act.set(30, true);\n-    act.set(31, true);\n-    act.set(32, true);\n-    assert!(act.eq_vec(\n-            &[false, false, false, true, false, false, false, false, false, false, false, false,\n-              false, false, false, false, false, true, false, false, false, false, false, false,\n-              false, false, false, false, false, false, true, true, true]));\n-    assert!(!act.none() && !act.all());\n-}\n-\n-#[test]\n-fn test_equal_differing_sizes() {\n-    let v0 = BitVec::from_elem(10, false);\n-    let v1 = BitVec::from_elem(11, false);\n-    assert!(v0 != v1);\n-}\n-\n-#[test]\n-fn test_equal_greatly_differing_sizes() {\n-    let v0 = BitVec::from_elem(10, false);\n-    let v1 = BitVec::from_elem(110, false);\n-    assert!(v0 != v1);\n-}\n-\n-#[test]\n-fn test_equal_sneaky_small() {\n-    let mut a = BitVec::from_elem(1, false);\n-    a.set(0, true);\n-\n-    let mut b = BitVec::from_elem(1, true);\n-    b.set(0, true);\n-\n-    assert_eq!(a, b);\n-}\n-\n-#[test]\n-fn test_equal_sneaky_big() {\n-    let mut a = BitVec::from_elem(100, false);\n-    for i in 0..100 {\n-        a.set(i, true);\n-    }\n-\n-    let mut b = BitVec::from_elem(100, true);\n-    for i in 0..100 {\n-        b.set(i, true);\n-    }\n-\n-    assert_eq!(a, b);\n-}\n-\n-#[test]\n-fn test_from_bytes() {\n-    let bit_vec = BitVec::from_bytes(&[0b10110110, 0b00000000, 0b11111111]);\n-    let str = concat!(\"10110110\", \"00000000\", \"11111111\");\n-    assert_eq!(format!(\"{:?}\", bit_vec), str);\n-}\n-\n-#[test]\n-fn test_to_bytes() {\n-    let mut bv = BitVec::from_elem(3, true);\n-    bv.set(1, false);\n-    assert_eq!(bv.to_bytes(), [0b10100000]);\n-\n-    let mut bv = BitVec::from_elem(9, false);\n-    bv.set(2, true);\n-    bv.set(8, true);\n-    assert_eq!(bv.to_bytes(), [0b00100000, 0b10000000]);\n-}\n-\n-#[test]\n-fn test_from_bools() {\n-    let bools = vec![true, false, true, true];\n-    let bit_vec: BitVec = bools.iter().map(|n| *n).collect();\n-    assert_eq!(format!(\"{:?}\", bit_vec), \"1011\");\n-}\n-\n-#[test]\n-fn test_to_bools() {\n-    let bools = vec![false, false, true, false, false, true, true, false];\n-    assert_eq!(BitVec::from_bytes(&[0b00100110]).iter().collect::<Vec<bool>>(), bools);\n-}\n-\n-#[test]\n-fn test_bit_vec_iterator() {\n-    let bools = vec![true, false, true, true];\n-    let bit_vec: BitVec = bools.iter().map(|n| *n).collect();\n-\n-    assert_eq!(bit_vec.iter().collect::<Vec<bool>>(), bools);\n-\n-    let long: Vec<_> = (0..10000).map(|i| i % 2 == 0).collect();\n-    let bit_vec: BitVec = long.iter().map(|n| *n).collect();\n-    assert_eq!(bit_vec.iter().collect::<Vec<bool>>(), long)\n-}\n-\n-#[test]\n-fn test_small_difference() {\n-    let mut b1 = BitVec::from_elem(3, false);\n-    let mut b2 = BitVec::from_elem(3, false);\n-    b1.set(0, true);\n-    b1.set(1, true);\n-    b2.set(1, true);\n-    b2.set(2, true);\n-    assert!(b1.difference(&b2));\n-    assert!(b1[0]);\n-    assert!(!b1[1]);\n-    assert!(!b1[2]);\n-}\n-\n-#[test]\n-fn test_big_difference() {\n-    let mut b1 = BitVec::from_elem(100, false);\n-    let mut b2 = BitVec::from_elem(100, false);\n-    b1.set(0, true);\n-    b1.set(40, true);\n-    b2.set(40, true);\n-    b2.set(80, true);\n-    assert!(b1.difference(&b2));\n-    assert!(b1[0]);\n-    assert!(!b1[40]);\n-    assert!(!b1[80]);\n-}\n-\n-#[test]\n-fn test_small_clear() {\n-    let mut b = BitVec::from_elem(14, true);\n-    assert!(!b.none() && b.all());\n-    b.clear();\n-    assert!(b.none() && !b.all());\n-}\n-\n-#[test]\n-fn test_big_clear() {\n-    let mut b = BitVec::from_elem(140, true);\n-    assert!(!b.none() && b.all());\n-    b.clear();\n-    assert!(b.none() && !b.all());\n-}\n-\n-#[test]\n-fn test_bit_vec_lt() {\n-    let mut a = BitVec::from_elem(5, false);\n-    let mut b = BitVec::from_elem(5, false);\n-\n-    assert!(!(a < b) && !(b < a));\n-    b.set(2, true);\n-    assert!(a < b);\n-    a.set(3, true);\n-    assert!(a < b);\n-    a.set(2, true);\n-    assert!(!(a < b) && b < a);\n-    b.set(0, true);\n-    assert!(a < b);\n-}\n-\n-#[test]\n-fn test_ord() {\n-    let mut a = BitVec::from_elem(5, false);\n-    let mut b = BitVec::from_elem(5, false);\n-\n-    assert!(a <= b && a >= b);\n-    a.set(1, true);\n-    assert!(a > b && a >= b);\n-    assert!(b < a && b <= a);\n-    b.set(1, true);\n-    b.set(2, true);\n-    assert!(b > a && b >= a);\n-    assert!(a < b && a <= b);\n-}\n-\n-\n-#[test]\n-fn test_small_bit_vec_tests() {\n-    let v = BitVec::from_bytes(&[0]);\n-    assert!(!v.all());\n-    assert!(!v.any());\n-    assert!(v.none());\n-\n-    let v = BitVec::from_bytes(&[0b00010100]);\n-    assert!(!v.all());\n-    assert!(v.any());\n-    assert!(!v.none());\n-\n-    let v = BitVec::from_bytes(&[0xFF]);\n-    assert!(v.all());\n-    assert!(v.any());\n-    assert!(!v.none());\n-}\n-\n-#[test]\n-fn test_big_bit_vec_tests() {\n-    let v = BitVec::from_bytes(&[ // 88 bits\n-        0, 0, 0, 0,\n-        0, 0, 0, 0,\n-        0, 0, 0]);\n-    assert!(!v.all());\n-    assert!(!v.any());\n-    assert!(v.none());\n-\n-    let v = BitVec::from_bytes(&[ // 88 bits\n-        0, 0, 0b00010100, 0,\n-        0, 0, 0, 0b00110100,\n-        0, 0, 0]);\n-    assert!(!v.all());\n-    assert!(v.any());\n-    assert!(!v.none());\n-\n-    let v = BitVec::from_bytes(&[ // 88 bits\n-        0xFF, 0xFF, 0xFF, 0xFF,\n-        0xFF, 0xFF, 0xFF, 0xFF,\n-        0xFF, 0xFF, 0xFF]);\n-    assert!(v.all());\n-    assert!(v.any());\n-    assert!(!v.none());\n-}\n-\n-#[test]\n-fn test_bit_vec_push_pop() {\n-    let mut s = BitVec::from_elem(5 * u32::BITS - 2, false);\n-    assert_eq!(s.len(), 5 * u32::BITS - 2);\n-    assert_eq!(s[5 * u32::BITS - 3], false);\n-    s.push(true);\n-    s.push(true);\n-    assert_eq!(s[5 * u32::BITS - 2], true);\n-    assert_eq!(s[5 * u32::BITS - 1], true);\n-    // Here the internal vector will need to be extended\n-    s.push(false);\n-    assert_eq!(s[5 * u32::BITS], false);\n-    s.push(false);\n-    assert_eq!(s[5 * u32::BITS + 1], false);\n-    assert_eq!(s.len(), 5 * u32::BITS + 2);\n-    // Pop it all off\n-    assert_eq!(s.pop(), Some(false));\n-    assert_eq!(s.pop(), Some(false));\n-    assert_eq!(s.pop(), Some(true));\n-    assert_eq!(s.pop(), Some(true));\n-    assert_eq!(s.len(), 5 * u32::BITS - 2);\n-}\n-\n-#[test]\n-fn test_bit_vec_truncate() {\n-    let mut s = BitVec::from_elem(5 * u32::BITS, true);\n-\n-    assert_eq!(s, BitVec::from_elem(5 * u32::BITS, true));\n-    assert_eq!(s.len(), 5 * u32::BITS);\n-    s.truncate(4 * u32::BITS);\n-    assert_eq!(s, BitVec::from_elem(4 * u32::BITS, true));\n-    assert_eq!(s.len(), 4 * u32::BITS);\n-    // Truncating to a size > s.len() should be a noop\n-    s.truncate(5 * u32::BITS);\n-    assert_eq!(s, BitVec::from_elem(4 * u32::BITS, true));\n-    assert_eq!(s.len(), 4 * u32::BITS);\n-    s.truncate(3 * u32::BITS - 10);\n-    assert_eq!(s, BitVec::from_elem(3 * u32::BITS - 10, true));\n-    assert_eq!(s.len(), 3 * u32::BITS - 10);\n-    s.truncate(0);\n-    assert_eq!(s, BitVec::from_elem(0, true));\n-    assert_eq!(s.len(), 0);\n-}\n-\n-#[test]\n-fn test_bit_vec_reserve() {\n-    let mut s = BitVec::from_elem(5 * u32::BITS, true);\n-    // Check capacity\n-    assert!(s.capacity() >= 5 * u32::BITS);\n-    s.reserve(2 * u32::BITS);\n-    assert!(s.capacity() >= 7 * u32::BITS);\n-    s.reserve(7 * u32::BITS);\n-    assert!(s.capacity() >= 12 * u32::BITS);\n-    s.reserve_exact(7 * u32::BITS);\n-    assert!(s.capacity() >= 12 * u32::BITS);\n-    s.reserve(7 * u32::BITS + 1);\n-    assert!(s.capacity() >= 12 * u32::BITS + 1);\n-    // Check that length hasn't changed\n-    assert_eq!(s.len(), 5 * u32::BITS);\n-    s.push(true);\n-    s.push(false);\n-    s.push(true);\n-    assert_eq!(s[5 * u32::BITS - 1], true);\n-    assert_eq!(s[5 * u32::BITS - 0], true);\n-    assert_eq!(s[5 * u32::BITS + 1], false);\n-    assert_eq!(s[5 * u32::BITS + 2], true);\n-}\n-\n-#[test]\n-fn test_bit_vec_grow() {\n-    let mut bit_vec = BitVec::from_bytes(&[0b10110110, 0b00000000, 0b10101010]);\n-    bit_vec.grow(32, true);\n-    assert_eq!(bit_vec, BitVec::from_bytes(&[0b10110110, 0b00000000, 0b10101010,\n-                                 0xFF, 0xFF, 0xFF, 0xFF]));\n-    bit_vec.grow(64, false);\n-    assert_eq!(bit_vec, BitVec::from_bytes(&[0b10110110, 0b00000000, 0b10101010,\n-                                 0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0]));\n-    bit_vec.grow(16, true);\n-    assert_eq!(bit_vec, BitVec::from_bytes(&[0b10110110, 0b00000000, 0b10101010,\n-                                 0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF]));\n-}\n-\n-#[test]\n-fn test_bit_vec_extend() {\n-    let mut bit_vec = BitVec::from_bytes(&[0b10110110, 0b00000000, 0b11111111]);\n-    let ext = BitVec::from_bytes(&[0b01001001, 0b10010010, 0b10111101]);\n-    bit_vec.extend(&ext);\n-    assert_eq!(bit_vec, BitVec::from_bytes(&[0b10110110, 0b00000000, 0b11111111,\n-                                 0b01001001, 0b10010010, 0b10111101]));\n-}\n-\n-#[test]\n-fn test_bit_vecextend_ref() {\n-    let mut bv = BitVec::from_bytes(&[0b10100011]);\n-    bv.extend(&[true, false, true]);\n-\n-    assert_eq!(bv.len(), 11);\n-    assert!(bv.eq_vec(&[true, false, true, false, false, false, true, true,\n-                        true, false, true]));\n-\n-    let bw = BitVec::from_bytes(&[0b00010001]);\n-    bv.extend(&bw);\n-\n-    assert_eq!(bv.len(), 19);\n-    assert!(bv.eq_vec(&[true, false, true, false, false, false, true, true,\n-                        true, false, true, false, false, false, true, false,\n-                        false, false, true]));\n-}\n-\n-#[test]\n-fn test_bit_vec_append() {\n-    // Append to BitVec that holds a multiple of u32::BITS bits\n-    let mut a = BitVec::from_bytes(&[0b10100000, 0b00010010, 0b10010010, 0b00110011]);\n-    let mut b = BitVec::new();\n-    b.push(false);\n-    b.push(true);\n-    b.push(true);\n-\n-    a.append(&mut b);\n-\n-    assert_eq!(a.len(), 35);\n-    assert_eq!(b.len(), 0);\n-    assert!(b.capacity() >= 3);\n-\n-    assert!(a.eq_vec(&[true, false, true, false, false, false, false, false,\n-                       false, false, false, true, false, false, true, false,\n-                       true, false, false, true, false, false, true, false,\n-                       false, false, true, true, false, false, true, true,\n-                       false, true, true]));\n-\n-    // Append to arbitrary BitVec\n-    let mut a = BitVec::new();\n-    a.push(true);\n-    a.push(false);\n-\n-    let mut b = BitVec::from_bytes(&[0b10100000, 0b00010010, 0b10010010, 0b00110011, 0b10010101]);\n-\n-    a.append(&mut b);\n-\n-    assert_eq!(a.len(), 42);\n-    assert_eq!(b.len(), 0);\n-    assert!(b.capacity() >= 40);\n-\n-    assert!(a.eq_vec(&[true, false, true, false, true, false, false, false,\n-                       false, false, false, false, false, true, false, false,\n-                       true, false, true, false, false, true, false, false,\n-                       true, false, false, false, true, true, false, false,\n-                       true, true, true, false, false, true, false, true,\n-                       false, true]));\n-\n-    // Append to empty BitVec\n-    let mut a = BitVec::new();\n-    let mut b = BitVec::from_bytes(&[0b10100000, 0b00010010, 0b10010010, 0b00110011, 0b10010101]);\n-\n-    a.append(&mut b);\n-\n-    assert_eq!(a.len(), 40);\n-    assert_eq!(b.len(), 0);\n-    assert!(b.capacity() >= 40);\n-\n-    assert!(a.eq_vec(&[true, false, true, false, false, false, false, false,\n-                       false, false, false, true, false, false, true, false,\n-                       true, false, false, true, false, false, true, false,\n-                       false, false, true, true, false, false, true, true,\n-                       true, false, false, true, false, true, false, true]));\n-\n-    // Append empty BitVec\n-    let mut a = BitVec::from_bytes(&[0b10100000, 0b00010010, 0b10010010, 0b00110011, 0b10010101]);\n-    let mut b = BitVec::new();\n-\n-    a.append(&mut b);\n-\n-    assert_eq!(a.len(), 40);\n-    assert_eq!(b.len(), 0);\n-\n-    assert!(a.eq_vec(&[true, false, true, false, false, false, false, false,\n-                       false, false, false, true, false, false, true, false,\n-                       true, false, false, true, false, false, true, false,\n-                       false, false, true, true, false, false, true, true,\n-                       true, false, false, true, false, true, false, true]));\n-}\n-\n-#[test]\n-fn test_bit_vec_split_off() {\n-    // Split at 0\n-    let mut a = BitVec::new();\n-    a.push(true);\n-    a.push(false);\n-    a.push(false);\n-    a.push(true);\n-\n-    let b = a.split_off(0);\n-\n-    assert_eq!(a.len(), 0);\n-    assert_eq!(b.len(), 4);\n-\n-    assert!(b.eq_vec(&[true, false, false, true]));\n-\n-    // Split at last bit\n-    a.truncate(0);\n-    a.push(true);\n-    a.push(false);\n-    a.push(false);\n-    a.push(true);\n-\n-    let b = a.split_off(4);\n-\n-    assert_eq!(a.len(), 4);\n-    assert_eq!(b.len(), 0);\n-\n-    assert!(a.eq_vec(&[true, false, false, true]));\n-\n-    // Split at block boundary\n-    let mut a = BitVec::from_bytes(&[0b10100000, 0b00010010, 0b10010010, 0b00110011, 0b11110011]);\n-\n-    let b = a.split_off(32);\n-\n-    assert_eq!(a.len(), 32);\n-    assert_eq!(b.len(), 8);\n-\n-    assert!(a.eq_vec(&[true, false, true, false, false, false, false, false,\n-                       false, false, false, true, false, false, true, false,\n-                       true, false, false, true, false, false, true, false,\n-                       false, false, true, true, false, false, true, true]));\n-    assert!(b.eq_vec(&[true, true, true, true, false, false, true, true]));\n-\n-    // Don't split at block boundary\n-    let mut a = BitVec::from_bytes(&[0b10100000, 0b00010010, 0b10010010, 0b00110011,\n-                                     0b01101011, 0b10101101]);\n-\n-    let b = a.split_off(13);\n-\n-    assert_eq!(a.len(), 13);\n-    assert_eq!(b.len(), 35);\n-\n-    assert!(a.eq_vec(&[true, false, true, false, false, false, false, false,\n-                       false, false, false, true, false]));\n-    assert!(b.eq_vec(&[false, true, false, true, false, false, true, false,\n-                       false, true, false, false, false, true, true, false,\n-                       false, true, true, false, true, true, false, true,\n-                       false, true, true,  true, false, true, false, true,\n-                       true, false, true]));\n-}\n-\n-mod bench {\n-    use std::collections::BitVec;\n-    use std::u32;\n-    use std::__rand::{Rng, thread_rng, ThreadRng};\n-\n-    use test::{Bencher, black_box};\n-\n-    const BENCH_BITS : usize = 1 << 14;\n-\n-    fn rng() -> ThreadRng {\n-        thread_rng()\n-    }\n-\n-    #[bench]\n-    fn bench_usize_small(b: &mut Bencher) {\n-        let mut r = rng();\n-        let mut bit_vec = 0 as usize;\n-        b.iter(|| {\n-            for _ in 0..100 {\n-                bit_vec |= 1 << ((r.next_u32() as usize) % u32::BITS);\n-            }\n-            black_box(&bit_vec);\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_bit_set_big_fixed(b: &mut Bencher) {\n-        let mut r = rng();\n-        let mut bit_vec = BitVec::from_elem(BENCH_BITS, false);\n-        b.iter(|| {\n-            for _ in 0..100 {\n-                bit_vec.set((r.next_u32() as usize) % BENCH_BITS, true);\n-            }\n-            black_box(&bit_vec);\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_bit_set_big_variable(b: &mut Bencher) {\n-        let mut r = rng();\n-        let mut bit_vec = BitVec::from_elem(BENCH_BITS, false);\n-        b.iter(|| {\n-            for _ in 0..100 {\n-                bit_vec.set((r.next_u32() as usize) % BENCH_BITS, r.gen());\n-            }\n-            black_box(&bit_vec);\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_bit_set_small(b: &mut Bencher) {\n-        let mut r = rng();\n-        let mut bit_vec = BitVec::from_elem(u32::BITS, false);\n-        b.iter(|| {\n-            for _ in 0..100 {\n-                bit_vec.set((r.next_u32() as usize) % u32::BITS, true);\n-            }\n-            black_box(&bit_vec);\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_bit_vec_big_union(b: &mut Bencher) {\n-        let mut b1 = BitVec::from_elem(BENCH_BITS, false);\n-        let b2 = BitVec::from_elem(BENCH_BITS, false);\n-        b.iter(|| {\n-            b1.union(&b2)\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_bit_vec_small_iter(b: &mut Bencher) {\n-        let bit_vec = BitVec::from_elem(u32::BITS, false);\n-        b.iter(|| {\n-            let mut sum = 0;\n-            for _ in 0..10 {\n-                for pres in &bit_vec {\n-                    sum += pres as usize;\n-                }\n-            }\n-            sum\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_bit_vec_big_iter(b: &mut Bencher) {\n-        let bit_vec = BitVec::from_elem(BENCH_BITS, false);\n-        b.iter(|| {\n-            let mut sum = 0;\n-            for pres in &bit_vec {\n-                sum += pres as usize;\n-            }\n-            sum\n-        })\n-    }\n-}"}, {"sha": "b0d7390a49c5dce44255ca71ab28123d2d8c6813", "filename": "src/libcollectionstest/btree/set.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcollectionstest%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcollectionstest%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbtree%2Fset.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use std::collections::BTreeSet;\n-use std::hash::{SipHasher, self};\n \n #[test]\n fn test_clone_eq() {\n@@ -34,7 +33,7 @@ fn test_hash() {\n   y.insert(2);\n   y.insert(1);\n \n-  assert!(hash::hash::<_, SipHasher>(&x) == hash::hash::<_, SipHasher>(&y));\n+  assert!(::hash(&x) == ::hash(&y));\n }\n \n struct Counter<'a, 'b> {"}, {"sha": "ca96f27d80d937adea97c2c6eca2a25aee2e61c7", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -10,8 +10,6 @@\n \n #![feature(ascii)]\n #![feature(append)]\n-#![feature(bitset)]\n-#![feature(bitvec)]\n #![feature(box_syntax)]\n #![feature(btree_range)]\n #![feature(collections)]\n@@ -21,24 +19,14 @@\n #![feature(deque_extras)]\n #![feature(drain)]\n #![feature(enumset)]\n-#![feature(hash_default)]\n #![feature(into_cow)]\n-#![feature(iter_idx)]\n-#![feature(iter_order)]\n #![feature(iter_arith)]\n-#![feature(iter_to_vec)]\n-#![feature(map_in_place)]\n-#![feature(move_from)]\n-#![feature(num_bits_bytes)]\n #![feature(pattern)]\n-#![feature(permutations)]\n #![feature(rand)]\n #![feature(range_inclusive)]\n #![feature(rustc_private)]\n #![feature(slice_bytes)]\n-#![feature(slice_chars)]\n #![feature(slice_splits)]\n-#![feature(slice_position_elem)]\n #![feature(split_off)]\n #![feature(step_by)]\n #![feature(str_char)]\n@@ -47,27 +35,23 @@\n #![feature(str_split_at)]\n #![feature(str_utf16)]\n #![feature(box_str)]\n-#![feature(subslice_offset)]\n #![feature(test)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n #![feature(vec_deque_retain)]\n-#![feature(vec_from_raw_buf)]\n #![feature(vec_push_all)]\n-#![feature(vecmap)]\n-\n-#![allow(deprecated)]\n \n #[macro_use] extern crate log;\n \n extern crate collections;\n extern crate test;\n extern crate rustc_unicode;\n \n+use std::hash::{Hash, Hasher, SipHasher};\n+\n #[cfg(test)] #[macro_use] mod bench;\n \n mod binary_heap;\n-mod bit;\n mod btree;\n mod enum_set;\n mod fmt;\n@@ -76,5 +60,10 @@ mod slice;\n mod str;\n mod string;\n mod vec_deque;\n-mod vec_map;\n mod vec;\n+\n+fn hash<T: Hash>(t: &T) -> u64 {\n+    let mut s = SipHasher::new();\n+    t.hash(&mut s);\n+    s.finish()\n+}"}, {"sha": "7dac967d8030c71b50458ca372f4b3f2c5c47577", "filename": "src/libcollectionstest/linked_list.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcollectionstest%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcollectionstest%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flinked_list.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use std::collections::LinkedList;\n-use std::hash::{SipHasher, self};\n \n use test;\n \n@@ -257,7 +256,7 @@ fn test_hash() {\n   let mut x = LinkedList::new();\n   let mut y = LinkedList::new();\n \n-  assert!(hash::hash::<_, SipHasher>(&x) == hash::hash::<_, SipHasher>(&y));\n+  assert!(::hash(&x) == ::hash(&y));\n \n   x.push_back(1);\n   x.push_back(2);\n@@ -267,7 +266,7 @@ fn test_hash() {\n   y.push_front(2);\n   y.push_front(1);\n \n-  assert!(hash::hash::<_, SipHasher>(&x) == hash::hash::<_, SipHasher>(&y));\n+  assert!(::hash(&x) == ::hash(&y));\n }\n \n #[test]"}, {"sha": "80dcd48fbfaa9e953b84f104595d95f8c3ee271e", "filename": "src/libcollectionstest/slice.rs", "status": "modified", "additions": 0, "deletions": 186, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcollectionstest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcollectionstest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fslice.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -10,11 +10,9 @@\n \n use std::cmp::Ordering::{Equal, Greater, Less};\n use std::default::Default;\n-use std::iter::RandomAccessIterator;\n use std::mem;\n use std::__rand::{Rng, thread_rng};\n use std::rc::Rc;\n-use std::slice::ElementSwaps;\n \n fn square(n: usize) -> usize { n * n }\n \n@@ -366,97 +364,6 @@ fn test_retain() {\n     assert_eq!(v, [1, 3, 5]);\n }\n \n-#[test]\n-fn test_element_swaps() {\n-    let mut v = [1, 2, 3];\n-    for (i, (a, b)) in ElementSwaps::new(v.len()).enumerate() {\n-        v.swap(a, b);\n-        match i {\n-            0 => assert!(v == [1, 3, 2]),\n-            1 => assert!(v == [3, 1, 2]),\n-            2 => assert!(v == [3, 2, 1]),\n-            3 => assert!(v == [2, 3, 1]),\n-            4 => assert!(v == [2, 1, 3]),\n-            5 => assert!(v == [1, 2, 3]),\n-            _ => panic!(),\n-        }\n-    }\n-}\n-\n-#[test]\n-fn test_lexicographic_permutations() {\n-    let v : &mut[_] = &mut[1, 2, 3, 4, 5];\n-    assert!(v.prev_permutation() == false);\n-    assert!(v.next_permutation());\n-    let b: &mut[_] = &mut[1, 2, 3, 5, 4];\n-    assert!(v == b);\n-    assert!(v.prev_permutation());\n-    let b: &mut[_] = &mut[1, 2, 3, 4, 5];\n-    assert!(v == b);\n-    assert!(v.next_permutation());\n-    assert!(v.next_permutation());\n-    let b: &mut[_] = &mut[1, 2, 4, 3, 5];\n-    assert!(v == b);\n-    assert!(v.next_permutation());\n-    let b: &mut[_] = &mut[1, 2, 4, 5, 3];\n-    assert!(v == b);\n-\n-    let v : &mut[_] = &mut[1, 0, 0, 0];\n-    assert!(v.next_permutation() == false);\n-    assert!(v.prev_permutation());\n-    let b: &mut[_] = &mut[0, 1, 0, 0];\n-    assert!(v == b);\n-    assert!(v.prev_permutation());\n-    let b: &mut[_] = &mut[0, 0, 1, 0];\n-    assert!(v == b);\n-    assert!(v.prev_permutation());\n-    let b: &mut[_] = &mut[0, 0, 0, 1];\n-    assert!(v == b);\n-    assert!(v.prev_permutation() == false);\n-}\n-\n-#[test]\n-fn test_lexicographic_permutations_empty_and_short() {\n-    let empty : &mut[i32] = &mut[];\n-    assert!(empty.next_permutation() == false);\n-    let b: &mut[i32] = &mut[];\n-    assert!(empty == b);\n-    assert!(empty.prev_permutation() == false);\n-    assert!(empty == b);\n-\n-    let one_elem : &mut[_] = &mut[4];\n-    assert!(one_elem.prev_permutation() == false);\n-    let b: &mut[_] = &mut[4];\n-    assert!(one_elem == b);\n-    assert!(one_elem.next_permutation() == false);\n-    assert!(one_elem == b);\n-\n-    let two_elem : &mut[_] = &mut[1, 2];\n-    assert!(two_elem.prev_permutation() == false);\n-    let b : &mut[_] = &mut[1, 2];\n-    let c : &mut[_] = &mut[2, 1];\n-    assert!(two_elem == b);\n-    assert!(two_elem.next_permutation());\n-    assert!(two_elem == c);\n-    assert!(two_elem.next_permutation() == false);\n-    assert!(two_elem == c);\n-    assert!(two_elem.prev_permutation());\n-    assert!(two_elem == b);\n-    assert!(two_elem.prev_permutation() == false);\n-    assert!(two_elem == b);\n-}\n-\n-#[test]\n-fn test_position_elem() {\n-    assert!([].position_elem(&1).is_none());\n-\n-    let v1 = vec![1, 2, 3, 3, 2, 5];\n-    assert_eq!(v1.position_elem(&1), Some(0));\n-    assert_eq!(v1.position_elem(&2), Some(1));\n-    assert_eq!(v1.position_elem(&5), Some(5));\n-    assert!(v1.position_elem(&4).is_none());\n-}\n-\n #[test]\n fn test_binary_search() {\n     assert_eq!([1,2,3,4,5].binary_search(&5).ok(), Some(4));\n@@ -668,21 +575,6 @@ fn test_slice_2() {\n     assert_eq!(v[1], 3);\n }\n \n-#[test]\n-#[should_panic]\n-fn test_permute_fail() {\n-    let v: [(Box<_>, Rc<_>); 4] =\n-        [(box 0, Rc::new(0)), (box 0, Rc::new(0)),\n-         (box 0, Rc::new(0)), (box 0, Rc::new(0))];\n-    let mut i = 0;\n-    for _ in v.permutations() {\n-        if i == 2 {\n-            panic!()\n-        }\n-        i += 1;\n-    }\n-}\n-\n #[test]\n fn test_total_ord() {\n     let c = &[1, 2, 3];\n@@ -715,44 +607,6 @@ fn test_iterator() {\n     assert!(it.next().is_none());\n }\n \n-#[test]\n-fn test_random_access_iterator() {\n-    let xs = [1, 2, 5, 10, 11];\n-    let mut it = xs.iter();\n-\n-    assert_eq!(it.indexable(), 5);\n-    assert_eq!(it.idx(0).unwrap(), &1);\n-    assert_eq!(it.idx(2).unwrap(), &5);\n-    assert_eq!(it.idx(4).unwrap(), &11);\n-    assert!(it.idx(5).is_none());\n-\n-    assert_eq!(it.next().unwrap(), &1);\n-    assert_eq!(it.indexable(), 4);\n-    assert_eq!(it.idx(0).unwrap(), &2);\n-    assert_eq!(it.idx(3).unwrap(), &11);\n-    assert!(it.idx(4).is_none());\n-\n-    assert_eq!(it.next().unwrap(), &2);\n-    assert_eq!(it.indexable(), 3);\n-    assert_eq!(it.idx(1).unwrap(), &10);\n-    assert!(it.idx(3).is_none());\n-\n-    assert_eq!(it.next().unwrap(), &5);\n-    assert_eq!(it.indexable(), 2);\n-    assert_eq!(it.idx(1).unwrap(), &11);\n-\n-    assert_eq!(it.next().unwrap(), &10);\n-    assert_eq!(it.indexable(), 1);\n-    assert_eq!(it.idx(0).unwrap(), &11);\n-    assert!(it.idx(1).is_none());\n-\n-    assert_eq!(it.next().unwrap(), &11);\n-    assert_eq!(it.indexable(), 0);\n-    assert!(it.idx(0).is_none());\n-\n-    assert!(it.next().is_none());\n-}\n-\n #[test]\n fn test_iter_size_hints() {\n     let mut xs = [1, 2, 5, 10, 11];\n@@ -933,15 +787,6 @@ fn test_windowsator() {\n \n     let wins: &[&[_]] = &[&[3,4], &[2,3], &[1,2]];\n     assert_eq!(v.windows(2).rev().collect::<Vec<&[_]>>(), wins);\n-    let mut it = v.windows(2);\n-    assert_eq!(it.indexable(), 3);\n-    let win: &[_] = &[1,2];\n-    assert_eq!(it.idx(0).unwrap(), win);\n-    let win: &[_] = &[2,3];\n-    assert_eq!(it.idx(1).unwrap(), win);\n-    let win: &[_] = &[3,4];\n-    assert_eq!(it.idx(2).unwrap(), win);\n-    assert_eq!(it.idx(3), None);\n }\n \n #[test]\n@@ -966,16 +811,6 @@ fn test_chunksator() {\n \n     let chunks: &[&[_]] = &[&[5], &[3,4], &[1,2]];\n     assert_eq!(v.chunks(2).rev().collect::<Vec<_>>(), chunks);\n-    let mut it = v.chunks(2);\n-    assert_eq!(it.indexable(), 3);\n-\n-    let chunk: &[_] = &[1,2];\n-    assert_eq!(it.idx(0).unwrap(), chunk);\n-    let chunk: &[_] = &[3,4];\n-    assert_eq!(it.idx(1).unwrap(), chunk);\n-    let chunk: &[_] = &[5];\n-    assert_eq!(it.idx(2).unwrap(), chunk);\n-    assert_eq!(it.idx(3), None);\n }\n \n #[test]\n@@ -985,26 +820,6 @@ fn test_chunksator_0() {\n     let _it = v.chunks(0);\n }\n \n-#[test]\n-fn test_move_from() {\n-    let mut a = [1,2,3,4,5];\n-    let b = vec![6,7,8];\n-    assert_eq!(a.move_from(b, 0, 3), 3);\n-    assert!(a == [6,7,8,4,5]);\n-    let mut a = [7,2,8,1];\n-    let b = vec![3,1,4,1,5,9];\n-    assert_eq!(a.move_from(b, 0, 6), 4);\n-    assert!(a == [3,1,4,1]);\n-    let mut a = [1,2,3,4];\n-    let b = vec![5,6,7,8,9,0];\n-    assert_eq!(a.move_from(b, 2, 3), 1);\n-    assert!(a == [7,2,3,4]);\n-    let mut a = [1,2,3,4,5];\n-    let b = vec![5,6,7,8,9,0];\n-    assert_eq!(a[2..4].move_from(b,1,6), 2);\n-    assert!(a == [1,2,6,7,5]);\n-}\n-\n #[test]\n fn test_reverse_part() {\n     let mut values = [1,2,3,4,5];\n@@ -1324,7 +1139,6 @@ fn test_box_slice_clone_panics() {\n }\n \n mod bench {\n-    use std::iter::repeat;\n     use std::{mem, ptr};\n     use std::__rand::{Rng, thread_rng};\n "}, {"sha": "f890e3ca2e1a65ee6f71ee09ee46dd60c3c8783e", "filename": "src/libcollectionstest/str.rs", "status": "modified", "additions": 0, "deletions": 559, "changes": 559, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcollectionstest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcollectionstest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstr.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -19,36 +19,6 @@ fn test_le() {\n     assert!(\"foo\" != \"bar\");\n }\n \n-#[allow(deprecated)]\n-#[test]\n-fn test_len() {\n-    assert_eq!(\"\".len(), 0);\n-    assert_eq!(\"hello world\".len(), 11);\n-    assert_eq!(\"\\x63\".len(), 1);\n-    assert_eq!(\"\\u{a2}\".len(), 2);\n-    assert_eq!(\"\\u{3c0}\".len(), 2);\n-    assert_eq!(\"\\u{2620}\".len(), 3);\n-    assert_eq!(\"\\u{1d11e}\".len(), 4);\n-\n-    assert_eq!(\"\".chars().count(), 0);\n-    assert_eq!(\"hello world\".chars().count(), 11);\n-    assert_eq!(\"\\x63\".chars().count(), 1);\n-    assert_eq!(\"\\u{a2}\".chars().count(), 1);\n-    assert_eq!(\"\\u{3c0}\".chars().count(), 1);\n-    assert_eq!(\"\\u{2620}\".chars().count(), 1);\n-    assert_eq!(\"\\u{1d11e}\".chars().count(), 1);\n-    assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".chars().count(), 19);\n-\n-    assert_eq!(\"\uff48\uff45\uff4c\uff4c\uff4f\".width(false), 10);\n-    assert_eq!(\"\uff48\uff45\uff4c\uff4c\uff4f\".width(true), 10);\n-    assert_eq!(\"\\0\\0\\0\\0\\0\".width(false), 0);\n-    assert_eq!(\"\\0\\0\\0\\0\\0\".width(true), 0);\n-    assert_eq!(\"\".width(false), 0);\n-    assert_eq!(\"\".width(true), 0);\n-    assert_eq!(\"\\u{2081}\\u{2082}\\u{2083}\\u{2084}\".width(false), 4);\n-    assert_eq!(\"\\u{2081}\\u{2082}\\u{2083}\\u{2084}\".width(true), 8);\n-}\n-\n #[test]\n fn test_find() {\n     assert_eq!(\"hello\".find('l'), Some(2));\n@@ -117,19 +87,6 @@ fn test_find_str() {\n     assert_eq!(data[43..86].find(\"Nam\"), Some(83 - 43));\n }\n \n-#[test]\n-fn test_slice_chars() {\n-    fn t(a: &str, b: &str, start: usize) {\n-        assert_eq!(a.slice_chars(start, start + b.chars().count()), b);\n-    }\n-    t(\"\", \"\", 0);\n-    t(\"hello\", \"llo\", 2);\n-    t(\"hello\", \"el\", 1);\n-    t(\"\u03b1\u03b2\u03bb\", \"\u03b2\", 1);\n-    t(\"\u03b1\u03b2\u03bb\", \"\", 3);\n-    assert_eq!(\"\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\", \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".slice_chars(2, 8));\n-}\n-\n fn s(x: &str) -> String { x.to_string() }\n \n macro_rules! test_concat {\n@@ -598,29 +555,6 @@ fn test_as_ptr() {\n     }\n }\n \n-#[test]\n-fn test_subslice_offset() {\n-    let a = \"kernelsprite\";\n-    let b = &a[7..a.len()];\n-    let c = &a[0..a.len() - 6];\n-    assert_eq!(a.subslice_offset(b), 7);\n-    assert_eq!(a.subslice_offset(c), 0);\n-\n-    let string = \"a\\nb\\nc\";\n-    let lines: Vec<&str> = string.lines().collect();\n-    assert_eq!(string.subslice_offset(lines[0]), 0);\n-    assert_eq!(string.subslice_offset(lines[1]), 2);\n-    assert_eq!(string.subslice_offset(lines[2]), 4);\n-}\n-\n-#[test]\n-#[should_panic]\n-fn test_subslice_offset_2() {\n-    let a = \"alchemiter\";\n-    let b = \"cruxtruder\";\n-    a.subslice_offset(b);\n-}\n-\n #[test]\n fn vec_str_conversions() {\n     let s1: String = String::from(\"All mimsy were the borogoves\");\n@@ -977,88 +911,6 @@ fn test_split_whitespace() {\n     assert_eq!(words, [\"M\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\", \"Little\", \"l\u00e4mb\"])\n }\n \n-#[allow(deprecated)]\n-#[test]\n-fn test_nfd_chars() {\n-    macro_rules! t {\n-        ($input: expr, $expected: expr) => {\n-            assert_eq!($input.nfd_chars().collect::<String>(), $expected);\n-        }\n-    }\n-    t!(\"abc\", \"abc\");\n-    t!(\"\\u{1e0b}\\u{1c4}\", \"d\\u{307}\\u{1c4}\");\n-    t!(\"\\u{2026}\", \"\\u{2026}\");\n-    t!(\"\\u{2126}\", \"\\u{3a9}\");\n-    t!(\"\\u{1e0b}\\u{323}\", \"d\\u{323}\\u{307}\");\n-    t!(\"\\u{1e0d}\\u{307}\", \"d\\u{323}\\u{307}\");\n-    t!(\"a\\u{301}\", \"a\\u{301}\");\n-    t!(\"\\u{301}a\", \"\\u{301}a\");\n-    t!(\"\\u{d4db}\", \"\\u{1111}\\u{1171}\\u{11b6}\");\n-    t!(\"\\u{ac1c}\", \"\\u{1100}\\u{1162}\");\n-}\n-\n-#[allow(deprecated)]\n-#[test]\n-fn test_nfkd_chars() {\n-    macro_rules! t {\n-        ($input: expr, $expected: expr) => {\n-            assert_eq!($input.nfkd_chars().collect::<String>(), $expected);\n-        }\n-    }\n-    t!(\"abc\", \"abc\");\n-    t!(\"\\u{1e0b}\\u{1c4}\", \"d\\u{307}DZ\\u{30c}\");\n-    t!(\"\\u{2026}\", \"...\");\n-    t!(\"\\u{2126}\", \"\\u{3a9}\");\n-    t!(\"\\u{1e0b}\\u{323}\", \"d\\u{323}\\u{307}\");\n-    t!(\"\\u{1e0d}\\u{307}\", \"d\\u{323}\\u{307}\");\n-    t!(\"a\\u{301}\", \"a\\u{301}\");\n-    t!(\"\\u{301}a\", \"\\u{301}a\");\n-    t!(\"\\u{d4db}\", \"\\u{1111}\\u{1171}\\u{11b6}\");\n-    t!(\"\\u{ac1c}\", \"\\u{1100}\\u{1162}\");\n-}\n-\n-#[allow(deprecated)]\n-#[test]\n-fn test_nfc_chars() {\n-    macro_rules! t {\n-        ($input: expr, $expected: expr) => {\n-            assert_eq!($input.nfc_chars().collect::<String>(), $expected);\n-        }\n-    }\n-    t!(\"abc\", \"abc\");\n-    t!(\"\\u{1e0b}\\u{1c4}\", \"\\u{1e0b}\\u{1c4}\");\n-    t!(\"\\u{2026}\", \"\\u{2026}\");\n-    t!(\"\\u{2126}\", \"\\u{3a9}\");\n-    t!(\"\\u{1e0b}\\u{323}\", \"\\u{1e0d}\\u{307}\");\n-    t!(\"\\u{1e0d}\\u{307}\", \"\\u{1e0d}\\u{307}\");\n-    t!(\"a\\u{301}\", \"\\u{e1}\");\n-    t!(\"\\u{301}a\", \"\\u{301}a\");\n-    t!(\"\\u{d4db}\", \"\\u{d4db}\");\n-    t!(\"\\u{ac1c}\", \"\\u{ac1c}\");\n-    t!(\"a\\u{300}\\u{305}\\u{315}\\u{5ae}b\", \"\\u{e0}\\u{5ae}\\u{305}\\u{315}b\");\n-}\n-\n-#[allow(deprecated)]\n-#[test]\n-fn test_nfkc_chars() {\n-    macro_rules! t {\n-        ($input: expr, $expected: expr) => {\n-            assert_eq!($input.nfkc_chars().collect::<String>(), $expected);\n-        }\n-    }\n-    t!(\"abc\", \"abc\");\n-    t!(\"\\u{1e0b}\\u{1c4}\", \"\\u{1e0b}D\\u{17d}\");\n-    t!(\"\\u{2026}\", \"...\");\n-    t!(\"\\u{2126}\", \"\\u{3a9}\");\n-    t!(\"\\u{1e0b}\\u{323}\", \"\\u{1e0d}\\u{307}\");\n-    t!(\"\\u{1e0d}\\u{307}\", \"\\u{1e0d}\\u{307}\");\n-    t!(\"a\\u{301}\", \"\\u{e1}\");\n-    t!(\"\\u{301}a\", \"\\u{301}a\");\n-    t!(\"\\u{d4db}\", \"\\u{d4db}\");\n-    t!(\"\\u{ac1c}\", \"\\u{ac1c}\");\n-    t!(\"a\\u{300}\\u{305}\\u{315}\\u{5ae}b\", \"\\u{e0}\\u{5ae}\\u{305}\\u{315}b\");\n-}\n-\n #[test]\n fn test_lines() {\n     let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n@@ -1070,417 +922,6 @@ fn test_lines() {\n     assert_eq!(lines, [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"\", \"Little l\u00e4mb\"]);\n }\n \n-#[allow(deprecated)]\n-#[test]\n-fn test_graphemes() {\n-    use std::iter::order;\n-\n-    // official Unicode test data\n-    // from http://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.txt\n-    let test_same: [(_, &[_]); 325] = [\n-        (\"\\u{20}\\u{20}\", &[\"\\u{20}\", \"\\u{20}\"]),\n-        (\"\\u{20}\\u{308}\\u{20}\", &[\"\\u{20}\\u{308}\", \"\\u{20}\"]),\n-        (\"\\u{20}\\u{D}\", &[\"\\u{20}\", \"\\u{D}\"]),\n-        (\"\\u{20}\\u{308}\\u{D}\", &[\"\\u{20}\\u{308}\", \"\\u{D}\"]),\n-        (\"\\u{20}\\u{A}\", &[\"\\u{20}\", \"\\u{A}\"]),\n-        (\"\\u{20}\\u{308}\\u{A}\", &[\"\\u{20}\\u{308}\", \"\\u{A}\"]),\n-        (\"\\u{20}\\u{1}\", &[\"\\u{20}\", \"\\u{1}\"]),\n-        (\"\\u{20}\\u{308}\\u{1}\", &[\"\\u{20}\\u{308}\", \"\\u{1}\"]),\n-        (\"\\u{20}\\u{300}\", &[\"\\u{20}\\u{300}\"]),\n-        (\"\\u{20}\\u{308}\\u{300}\", &[\"\\u{20}\\u{308}\\u{300}\"]),\n-        (\"\\u{20}\\u{1100}\", &[\"\\u{20}\", \"\\u{1100}\"]),\n-        (\"\\u{20}\\u{308}\\u{1100}\", &[\"\\u{20}\\u{308}\", \"\\u{1100}\"]),\n-        (\"\\u{20}\\u{1160}\", &[\"\\u{20}\", \"\\u{1160}\"]),\n-        (\"\\u{20}\\u{308}\\u{1160}\", &[\"\\u{20}\\u{308}\", \"\\u{1160}\"]),\n-        (\"\\u{20}\\u{11A8}\", &[\"\\u{20}\", \"\\u{11A8}\"]),\n-        (\"\\u{20}\\u{308}\\u{11A8}\", &[\"\\u{20}\\u{308}\", \"\\u{11A8}\"]),\n-        (\"\\u{20}\\u{AC00}\", &[\"\\u{20}\", \"\\u{AC00}\"]),\n-        (\"\\u{20}\\u{308}\\u{AC00}\", &[\"\\u{20}\\u{308}\", \"\\u{AC00}\"]),\n-        (\"\\u{20}\\u{AC01}\", &[\"\\u{20}\", \"\\u{AC01}\"]),\n-        (\"\\u{20}\\u{308}\\u{AC01}\", &[\"\\u{20}\\u{308}\", \"\\u{AC01}\"]),\n-        (\"\\u{20}\\u{1F1E6}\", &[\"\\u{20}\", \"\\u{1F1E6}\"]),\n-        (\"\\u{20}\\u{308}\\u{1F1E6}\", &[\"\\u{20}\\u{308}\", \"\\u{1F1E6}\"]),\n-        (\"\\u{20}\\u{378}\", &[\"\\u{20}\", \"\\u{378}\"]),\n-        (\"\\u{20}\\u{308}\\u{378}\", &[\"\\u{20}\\u{308}\", \"\\u{378}\"]),\n-        (\"\\u{D}\\u{20}\", &[\"\\u{D}\", \"\\u{20}\"]),\n-        (\"\\u{D}\\u{308}\\u{20}\", &[\"\\u{D}\", \"\\u{308}\", \"\\u{20}\"]),\n-        (\"\\u{D}\\u{D}\", &[\"\\u{D}\", \"\\u{D}\"]),\n-        (\"\\u{D}\\u{308}\\u{D}\", &[\"\\u{D}\", \"\\u{308}\", \"\\u{D}\"]),\n-        (\"\\u{D}\\u{A}\", &[\"\\u{D}\\u{A}\"]),\n-        (\"\\u{D}\\u{308}\\u{A}\", &[\"\\u{D}\", \"\\u{308}\", \"\\u{A}\"]),\n-        (\"\\u{D}\\u{1}\", &[\"\\u{D}\", \"\\u{1}\"]),\n-        (\"\\u{D}\\u{308}\\u{1}\", &[\"\\u{D}\", \"\\u{308}\", \"\\u{1}\"]),\n-        (\"\\u{D}\\u{300}\", &[\"\\u{D}\", \"\\u{300}\"]),\n-        (\"\\u{D}\\u{308}\\u{300}\", &[\"\\u{D}\", \"\\u{308}\\u{300}\"]),\n-        (\"\\u{D}\\u{903}\", &[\"\\u{D}\", \"\\u{903}\"]),\n-        (\"\\u{D}\\u{1100}\", &[\"\\u{D}\", \"\\u{1100}\"]),\n-        (\"\\u{D}\\u{308}\\u{1100}\", &[\"\\u{D}\", \"\\u{308}\", \"\\u{1100}\"]),\n-        (\"\\u{D}\\u{1160}\", &[\"\\u{D}\", \"\\u{1160}\"]),\n-        (\"\\u{D}\\u{308}\\u{1160}\", &[\"\\u{D}\", \"\\u{308}\", \"\\u{1160}\"]),\n-        (\"\\u{D}\\u{11A8}\", &[\"\\u{D}\", \"\\u{11A8}\"]),\n-        (\"\\u{D}\\u{308}\\u{11A8}\", &[\"\\u{D}\", \"\\u{308}\", \"\\u{11A8}\"]),\n-        (\"\\u{D}\\u{AC00}\", &[\"\\u{D}\", \"\\u{AC00}\"]),\n-        (\"\\u{D}\\u{308}\\u{AC00}\", &[\"\\u{D}\", \"\\u{308}\", \"\\u{AC00}\"]),\n-        (\"\\u{D}\\u{AC01}\", &[\"\\u{D}\", \"\\u{AC01}\"]),\n-        (\"\\u{D}\\u{308}\\u{AC01}\", &[\"\\u{D}\", \"\\u{308}\", \"\\u{AC01}\"]),\n-        (\"\\u{D}\\u{1F1E6}\", &[\"\\u{D}\", \"\\u{1F1E6}\"]),\n-        (\"\\u{D}\\u{308}\\u{1F1E6}\", &[\"\\u{D}\", \"\\u{308}\", \"\\u{1F1E6}\"]),\n-        (\"\\u{D}\\u{378}\", &[\"\\u{D}\", \"\\u{378}\"]),\n-        (\"\\u{D}\\u{308}\\u{378}\", &[\"\\u{D}\", \"\\u{308}\", \"\\u{378}\"]),\n-        (\"\\u{A}\\u{20}\", &[\"\\u{A}\", \"\\u{20}\"]),\n-        (\"\\u{A}\\u{308}\\u{20}\", &[\"\\u{A}\", \"\\u{308}\", \"\\u{20}\"]),\n-        (\"\\u{A}\\u{D}\", &[\"\\u{A}\", \"\\u{D}\"]),\n-        (\"\\u{A}\\u{308}\\u{D}\", &[\"\\u{A}\", \"\\u{308}\", \"\\u{D}\"]),\n-        (\"\\u{A}\\u{A}\", &[\"\\u{A}\", \"\\u{A}\"]),\n-        (\"\\u{A}\\u{308}\\u{A}\", &[\"\\u{A}\", \"\\u{308}\", \"\\u{A}\"]),\n-        (\"\\u{A}\\u{1}\", &[\"\\u{A}\", \"\\u{1}\"]),\n-        (\"\\u{A}\\u{308}\\u{1}\", &[\"\\u{A}\", \"\\u{308}\", \"\\u{1}\"]),\n-        (\"\\u{A}\\u{300}\", &[\"\\u{A}\", \"\\u{300}\"]),\n-        (\"\\u{A}\\u{308}\\u{300}\", &[\"\\u{A}\", \"\\u{308}\\u{300}\"]),\n-        (\"\\u{A}\\u{903}\", &[\"\\u{A}\", \"\\u{903}\"]),\n-        (\"\\u{A}\\u{1100}\", &[\"\\u{A}\", \"\\u{1100}\"]),\n-        (\"\\u{A}\\u{308}\\u{1100}\", &[\"\\u{A}\", \"\\u{308}\", \"\\u{1100}\"]),\n-        (\"\\u{A}\\u{1160}\", &[\"\\u{A}\", \"\\u{1160}\"]),\n-        (\"\\u{A}\\u{308}\\u{1160}\", &[\"\\u{A}\", \"\\u{308}\", \"\\u{1160}\"]),\n-        (\"\\u{A}\\u{11A8}\", &[\"\\u{A}\", \"\\u{11A8}\"]),\n-        (\"\\u{A}\\u{308}\\u{11A8}\", &[\"\\u{A}\", \"\\u{308}\", \"\\u{11A8}\"]),\n-        (\"\\u{A}\\u{AC00}\", &[\"\\u{A}\", \"\\u{AC00}\"]),\n-        (\"\\u{A}\\u{308}\\u{AC00}\", &[\"\\u{A}\", \"\\u{308}\", \"\\u{AC00}\"]),\n-        (\"\\u{A}\\u{AC01}\", &[\"\\u{A}\", \"\\u{AC01}\"]),\n-        (\"\\u{A}\\u{308}\\u{AC01}\", &[\"\\u{A}\", \"\\u{308}\", \"\\u{AC01}\"]),\n-        (\"\\u{A}\\u{1F1E6}\", &[\"\\u{A}\", \"\\u{1F1E6}\"]),\n-        (\"\\u{A}\\u{308}\\u{1F1E6}\", &[\"\\u{A}\", \"\\u{308}\", \"\\u{1F1E6}\"]),\n-        (\"\\u{A}\\u{378}\", &[\"\\u{A}\", \"\\u{378}\"]),\n-        (\"\\u{A}\\u{308}\\u{378}\", &[\"\\u{A}\", \"\\u{308}\", \"\\u{378}\"]),\n-        (\"\\u{1}\\u{20}\", &[\"\\u{1}\", \"\\u{20}\"]),\n-        (\"\\u{1}\\u{308}\\u{20}\", &[\"\\u{1}\", \"\\u{308}\", \"\\u{20}\"]),\n-        (\"\\u{1}\\u{D}\", &[\"\\u{1}\", \"\\u{D}\"]),\n-        (\"\\u{1}\\u{308}\\u{D}\", &[\"\\u{1}\", \"\\u{308}\", \"\\u{D}\"]),\n-        (\"\\u{1}\\u{A}\", &[\"\\u{1}\", \"\\u{A}\"]),\n-        (\"\\u{1}\\u{308}\\u{A}\", &[\"\\u{1}\", \"\\u{308}\", \"\\u{A}\"]),\n-        (\"\\u{1}\\u{1}\", &[\"\\u{1}\", \"\\u{1}\"]),\n-        (\"\\u{1}\\u{308}\\u{1}\", &[\"\\u{1}\", \"\\u{308}\", \"\\u{1}\"]),\n-        (\"\\u{1}\\u{300}\", &[\"\\u{1}\", \"\\u{300}\"]),\n-        (\"\\u{1}\\u{308}\\u{300}\", &[\"\\u{1}\", \"\\u{308}\\u{300}\"]),\n-        (\"\\u{1}\\u{903}\", &[\"\\u{1}\", \"\\u{903}\"]),\n-        (\"\\u{1}\\u{1100}\", &[\"\\u{1}\", \"\\u{1100}\"]),\n-        (\"\\u{1}\\u{308}\\u{1100}\", &[\"\\u{1}\", \"\\u{308}\", \"\\u{1100}\"]),\n-        (\"\\u{1}\\u{1160}\", &[\"\\u{1}\", \"\\u{1160}\"]),\n-        (\"\\u{1}\\u{308}\\u{1160}\", &[\"\\u{1}\", \"\\u{308}\", \"\\u{1160}\"]),\n-        (\"\\u{1}\\u{11A8}\", &[\"\\u{1}\", \"\\u{11A8}\"]),\n-        (\"\\u{1}\\u{308}\\u{11A8}\", &[\"\\u{1}\", \"\\u{308}\", \"\\u{11A8}\"]),\n-        (\"\\u{1}\\u{AC00}\", &[\"\\u{1}\", \"\\u{AC00}\"]),\n-        (\"\\u{1}\\u{308}\\u{AC00}\", &[\"\\u{1}\", \"\\u{308}\", \"\\u{AC00}\"]),\n-        (\"\\u{1}\\u{AC01}\", &[\"\\u{1}\", \"\\u{AC01}\"]),\n-        (\"\\u{1}\\u{308}\\u{AC01}\", &[\"\\u{1}\", \"\\u{308}\", \"\\u{AC01}\"]),\n-        (\"\\u{1}\\u{1F1E6}\", &[\"\\u{1}\", \"\\u{1F1E6}\"]),\n-        (\"\\u{1}\\u{308}\\u{1F1E6}\", &[\"\\u{1}\", \"\\u{308}\", \"\\u{1F1E6}\"]),\n-        (\"\\u{1}\\u{378}\", &[\"\\u{1}\", \"\\u{378}\"]),\n-        (\"\\u{1}\\u{308}\\u{378}\", &[\"\\u{1}\", \"\\u{308}\", \"\\u{378}\"]),\n-        (\"\\u{300}\\u{20}\", &[\"\\u{300}\", \"\\u{20}\"]),\n-        (\"\\u{300}\\u{308}\\u{20}\", &[\"\\u{300}\\u{308}\", \"\\u{20}\"]),\n-        (\"\\u{300}\\u{D}\", &[\"\\u{300}\", \"\\u{D}\"]),\n-        (\"\\u{300}\\u{308}\\u{D}\", &[\"\\u{300}\\u{308}\", \"\\u{D}\"]),\n-        (\"\\u{300}\\u{A}\", &[\"\\u{300}\", \"\\u{A}\"]),\n-        (\"\\u{300}\\u{308}\\u{A}\", &[\"\\u{300}\\u{308}\", \"\\u{A}\"]),\n-        (\"\\u{300}\\u{1}\", &[\"\\u{300}\", \"\\u{1}\"]),\n-        (\"\\u{300}\\u{308}\\u{1}\", &[\"\\u{300}\\u{308}\", \"\\u{1}\"]),\n-        (\"\\u{300}\\u{300}\", &[\"\\u{300}\\u{300}\"]),\n-        (\"\\u{300}\\u{308}\\u{300}\", &[\"\\u{300}\\u{308}\\u{300}\"]),\n-        (\"\\u{300}\\u{1100}\", &[\"\\u{300}\", \"\\u{1100}\"]),\n-        (\"\\u{300}\\u{308}\\u{1100}\", &[\"\\u{300}\\u{308}\", \"\\u{1100}\"]),\n-        (\"\\u{300}\\u{1160}\", &[\"\\u{300}\", \"\\u{1160}\"]),\n-        (\"\\u{300}\\u{308}\\u{1160}\", &[\"\\u{300}\\u{308}\", \"\\u{1160}\"]),\n-        (\"\\u{300}\\u{11A8}\", &[\"\\u{300}\", \"\\u{11A8}\"]),\n-        (\"\\u{300}\\u{308}\\u{11A8}\", &[\"\\u{300}\\u{308}\", \"\\u{11A8}\"]),\n-        (\"\\u{300}\\u{AC00}\", &[\"\\u{300}\", \"\\u{AC00}\"]),\n-        (\"\\u{300}\\u{308}\\u{AC00}\", &[\"\\u{300}\\u{308}\", \"\\u{AC00}\"]),\n-        (\"\\u{300}\\u{AC01}\", &[\"\\u{300}\", \"\\u{AC01}\"]),\n-        (\"\\u{300}\\u{308}\\u{AC01}\", &[\"\\u{300}\\u{308}\", \"\\u{AC01}\"]),\n-        (\"\\u{300}\\u{1F1E6}\", &[\"\\u{300}\", \"\\u{1F1E6}\"]),\n-        (\"\\u{300}\\u{308}\\u{1F1E6}\", &[\"\\u{300}\\u{308}\", \"\\u{1F1E6}\"]),\n-        (\"\\u{300}\\u{378}\", &[\"\\u{300}\", \"\\u{378}\"]),\n-        (\"\\u{300}\\u{308}\\u{378}\", &[\"\\u{300}\\u{308}\", \"\\u{378}\"]),\n-        (\"\\u{903}\\u{20}\", &[\"\\u{903}\", \"\\u{20}\"]),\n-        (\"\\u{903}\\u{308}\\u{20}\", &[\"\\u{903}\\u{308}\", \"\\u{20}\"]),\n-        (\"\\u{903}\\u{D}\", &[\"\\u{903}\", \"\\u{D}\"]),\n-        (\"\\u{903}\\u{308}\\u{D}\", &[\"\\u{903}\\u{308}\", \"\\u{D}\"]),\n-        (\"\\u{903}\\u{A}\", &[\"\\u{903}\", \"\\u{A}\"]),\n-        (\"\\u{903}\\u{308}\\u{A}\", &[\"\\u{903}\\u{308}\", \"\\u{A}\"]),\n-        (\"\\u{903}\\u{1}\", &[\"\\u{903}\", \"\\u{1}\"]),\n-        (\"\\u{903}\\u{308}\\u{1}\", &[\"\\u{903}\\u{308}\", \"\\u{1}\"]),\n-        (\"\\u{903}\\u{300}\", &[\"\\u{903}\\u{300}\"]),\n-        (\"\\u{903}\\u{308}\\u{300}\", &[\"\\u{903}\\u{308}\\u{300}\"]),\n-        (\"\\u{903}\\u{1100}\", &[\"\\u{903}\", \"\\u{1100}\"]),\n-        (\"\\u{903}\\u{308}\\u{1100}\", &[\"\\u{903}\\u{308}\", \"\\u{1100}\"]),\n-        (\"\\u{903}\\u{1160}\", &[\"\\u{903}\", \"\\u{1160}\"]),\n-        (\"\\u{903}\\u{308}\\u{1160}\", &[\"\\u{903}\\u{308}\", \"\\u{1160}\"]),\n-        (\"\\u{903}\\u{11A8}\", &[\"\\u{903}\", \"\\u{11A8}\"]),\n-        (\"\\u{903}\\u{308}\\u{11A8}\", &[\"\\u{903}\\u{308}\", \"\\u{11A8}\"]),\n-        (\"\\u{903}\\u{AC00}\", &[\"\\u{903}\", \"\\u{AC00}\"]),\n-        (\"\\u{903}\\u{308}\\u{AC00}\", &[\"\\u{903}\\u{308}\", \"\\u{AC00}\"]),\n-        (\"\\u{903}\\u{AC01}\", &[\"\\u{903}\", \"\\u{AC01}\"]),\n-        (\"\\u{903}\\u{308}\\u{AC01}\", &[\"\\u{903}\\u{308}\", \"\\u{AC01}\"]),\n-        (\"\\u{903}\\u{1F1E6}\", &[\"\\u{903}\", \"\\u{1F1E6}\"]),\n-        (\"\\u{903}\\u{308}\\u{1F1E6}\", &[\"\\u{903}\\u{308}\", \"\\u{1F1E6}\"]),\n-        (\"\\u{903}\\u{378}\", &[\"\\u{903}\", \"\\u{378}\"]),\n-        (\"\\u{903}\\u{308}\\u{378}\", &[\"\\u{903}\\u{308}\", \"\\u{378}\"]),\n-        (\"\\u{1100}\\u{20}\", &[\"\\u{1100}\", \"\\u{20}\"]),\n-        (\"\\u{1100}\\u{308}\\u{20}\", &[\"\\u{1100}\\u{308}\", \"\\u{20}\"]),\n-        (\"\\u{1100}\\u{D}\", &[\"\\u{1100}\", \"\\u{D}\"]),\n-        (\"\\u{1100}\\u{308}\\u{D}\", &[\"\\u{1100}\\u{308}\", \"\\u{D}\"]),\n-        (\"\\u{1100}\\u{A}\", &[\"\\u{1100}\", \"\\u{A}\"]),\n-        (\"\\u{1100}\\u{308}\\u{A}\", &[\"\\u{1100}\\u{308}\", \"\\u{A}\"]),\n-        (\"\\u{1100}\\u{1}\", &[\"\\u{1100}\", \"\\u{1}\"]),\n-        (\"\\u{1100}\\u{308}\\u{1}\", &[\"\\u{1100}\\u{308}\", \"\\u{1}\"]),\n-        (\"\\u{1100}\\u{300}\", &[\"\\u{1100}\\u{300}\"]),\n-        (\"\\u{1100}\\u{308}\\u{300}\", &[\"\\u{1100}\\u{308}\\u{300}\"]),\n-        (\"\\u{1100}\\u{1100}\", &[\"\\u{1100}\\u{1100}\"]),\n-        (\"\\u{1100}\\u{308}\\u{1100}\", &[\"\\u{1100}\\u{308}\", \"\\u{1100}\"]),\n-        (\"\\u{1100}\\u{1160}\", &[\"\\u{1100}\\u{1160}\"]),\n-        (\"\\u{1100}\\u{308}\\u{1160}\", &[\"\\u{1100}\\u{308}\", \"\\u{1160}\"]),\n-        (\"\\u{1100}\\u{11A8}\", &[\"\\u{1100}\", \"\\u{11A8}\"]),\n-        (\"\\u{1100}\\u{308}\\u{11A8}\", &[\"\\u{1100}\\u{308}\", \"\\u{11A8}\"]),\n-        (\"\\u{1100}\\u{AC00}\", &[\"\\u{1100}\\u{AC00}\"]),\n-        (\"\\u{1100}\\u{308}\\u{AC00}\", &[\"\\u{1100}\\u{308}\", \"\\u{AC00}\"]),\n-        (\"\\u{1100}\\u{AC01}\", &[\"\\u{1100}\\u{AC01}\"]),\n-        (\"\\u{1100}\\u{308}\\u{AC01}\", &[\"\\u{1100}\\u{308}\", \"\\u{AC01}\"]),\n-        (\"\\u{1100}\\u{1F1E6}\", &[\"\\u{1100}\", \"\\u{1F1E6}\"]),\n-        (\"\\u{1100}\\u{308}\\u{1F1E6}\", &[\"\\u{1100}\\u{308}\", \"\\u{1F1E6}\"]),\n-        (\"\\u{1100}\\u{378}\", &[\"\\u{1100}\", \"\\u{378}\"]),\n-        (\"\\u{1100}\\u{308}\\u{378}\", &[\"\\u{1100}\\u{308}\", \"\\u{378}\"]),\n-        (\"\\u{1160}\\u{20}\", &[\"\\u{1160}\", \"\\u{20}\"]),\n-        (\"\\u{1160}\\u{308}\\u{20}\", &[\"\\u{1160}\\u{308}\", \"\\u{20}\"]),\n-        (\"\\u{1160}\\u{D}\", &[\"\\u{1160}\", \"\\u{D}\"]),\n-        (\"\\u{1160}\\u{308}\\u{D}\", &[\"\\u{1160}\\u{308}\", \"\\u{D}\"]),\n-        (\"\\u{1160}\\u{A}\", &[\"\\u{1160}\", \"\\u{A}\"]),\n-        (\"\\u{1160}\\u{308}\\u{A}\", &[\"\\u{1160}\\u{308}\", \"\\u{A}\"]),\n-        (\"\\u{1160}\\u{1}\", &[\"\\u{1160}\", \"\\u{1}\"]),\n-        (\"\\u{1160}\\u{308}\\u{1}\", &[\"\\u{1160}\\u{308}\", \"\\u{1}\"]),\n-        (\"\\u{1160}\\u{300}\", &[\"\\u{1160}\\u{300}\"]),\n-        (\"\\u{1160}\\u{308}\\u{300}\", &[\"\\u{1160}\\u{308}\\u{300}\"]),\n-        (\"\\u{1160}\\u{1100}\", &[\"\\u{1160}\", \"\\u{1100}\"]),\n-        (\"\\u{1160}\\u{308}\\u{1100}\", &[\"\\u{1160}\\u{308}\", \"\\u{1100}\"]),\n-        (\"\\u{1160}\\u{1160}\", &[\"\\u{1160}\\u{1160}\"]),\n-        (\"\\u{1160}\\u{308}\\u{1160}\", &[\"\\u{1160}\\u{308}\", \"\\u{1160}\"]),\n-        (\"\\u{1160}\\u{11A8}\", &[\"\\u{1160}\\u{11A8}\"]),\n-        (\"\\u{1160}\\u{308}\\u{11A8}\", &[\"\\u{1160}\\u{308}\", \"\\u{11A8}\"]),\n-        (\"\\u{1160}\\u{AC00}\", &[\"\\u{1160}\", \"\\u{AC00}\"]),\n-        (\"\\u{1160}\\u{308}\\u{AC00}\", &[\"\\u{1160}\\u{308}\", \"\\u{AC00}\"]),\n-        (\"\\u{1160}\\u{AC01}\", &[\"\\u{1160}\", \"\\u{AC01}\"]),\n-        (\"\\u{1160}\\u{308}\\u{AC01}\", &[\"\\u{1160}\\u{308}\", \"\\u{AC01}\"]),\n-        (\"\\u{1160}\\u{1F1E6}\", &[\"\\u{1160}\", \"\\u{1F1E6}\"]),\n-        (\"\\u{1160}\\u{308}\\u{1F1E6}\", &[\"\\u{1160}\\u{308}\", \"\\u{1F1E6}\"]),\n-        (\"\\u{1160}\\u{378}\", &[\"\\u{1160}\", \"\\u{378}\"]),\n-        (\"\\u{1160}\\u{308}\\u{378}\", &[\"\\u{1160}\\u{308}\", \"\\u{378}\"]),\n-        (\"\\u{11A8}\\u{20}\", &[\"\\u{11A8}\", \"\\u{20}\"]),\n-        (\"\\u{11A8}\\u{308}\\u{20}\", &[\"\\u{11A8}\\u{308}\", \"\\u{20}\"]),\n-        (\"\\u{11A8}\\u{D}\", &[\"\\u{11A8}\", \"\\u{D}\"]),\n-        (\"\\u{11A8}\\u{308}\\u{D}\", &[\"\\u{11A8}\\u{308}\", \"\\u{D}\"]),\n-        (\"\\u{11A8}\\u{A}\", &[\"\\u{11A8}\", \"\\u{A}\"]),\n-        (\"\\u{11A8}\\u{308}\\u{A}\", &[\"\\u{11A8}\\u{308}\", \"\\u{A}\"]),\n-        (\"\\u{11A8}\\u{1}\", &[\"\\u{11A8}\", \"\\u{1}\"]),\n-        (\"\\u{11A8}\\u{308}\\u{1}\", &[\"\\u{11A8}\\u{308}\", \"\\u{1}\"]),\n-        (\"\\u{11A8}\\u{300}\", &[\"\\u{11A8}\\u{300}\"]),\n-        (\"\\u{11A8}\\u{308}\\u{300}\", &[\"\\u{11A8}\\u{308}\\u{300}\"]),\n-        (\"\\u{11A8}\\u{1100}\", &[\"\\u{11A8}\", \"\\u{1100}\"]),\n-        (\"\\u{11A8}\\u{308}\\u{1100}\", &[\"\\u{11A8}\\u{308}\", \"\\u{1100}\"]),\n-        (\"\\u{11A8}\\u{1160}\", &[\"\\u{11A8}\", \"\\u{1160}\"]),\n-        (\"\\u{11A8}\\u{308}\\u{1160}\", &[\"\\u{11A8}\\u{308}\", \"\\u{1160}\"]),\n-        (\"\\u{11A8}\\u{11A8}\", &[\"\\u{11A8}\\u{11A8}\"]),\n-        (\"\\u{11A8}\\u{308}\\u{11A8}\", &[\"\\u{11A8}\\u{308}\", \"\\u{11A8}\"]),\n-        (\"\\u{11A8}\\u{AC00}\", &[\"\\u{11A8}\", \"\\u{AC00}\"]),\n-        (\"\\u{11A8}\\u{308}\\u{AC00}\", &[\"\\u{11A8}\\u{308}\", \"\\u{AC00}\"]),\n-        (\"\\u{11A8}\\u{AC01}\", &[\"\\u{11A8}\", \"\\u{AC01}\"]),\n-        (\"\\u{11A8}\\u{308}\\u{AC01}\", &[\"\\u{11A8}\\u{308}\", \"\\u{AC01}\"]),\n-        (\"\\u{11A8}\\u{1F1E6}\", &[\"\\u{11A8}\", \"\\u{1F1E6}\"]),\n-        (\"\\u{11A8}\\u{308}\\u{1F1E6}\", &[\"\\u{11A8}\\u{308}\", \"\\u{1F1E6}\"]),\n-        (\"\\u{11A8}\\u{378}\", &[\"\\u{11A8}\", \"\\u{378}\"]),\n-        (\"\\u{11A8}\\u{308}\\u{378}\", &[\"\\u{11A8}\\u{308}\", \"\\u{378}\"]),\n-        (\"\\u{AC00}\\u{20}\", &[\"\\u{AC00}\", \"\\u{20}\"]),\n-        (\"\\u{AC00}\\u{308}\\u{20}\", &[\"\\u{AC00}\\u{308}\", \"\\u{20}\"]),\n-        (\"\\u{AC00}\\u{D}\", &[\"\\u{AC00}\", \"\\u{D}\"]),\n-        (\"\\u{AC00}\\u{308}\\u{D}\", &[\"\\u{AC00}\\u{308}\", \"\\u{D}\"]),\n-        (\"\\u{AC00}\\u{A}\", &[\"\\u{AC00}\", \"\\u{A}\"]),\n-        (\"\\u{AC00}\\u{308}\\u{A}\", &[\"\\u{AC00}\\u{308}\", \"\\u{A}\"]),\n-        (\"\\u{AC00}\\u{1}\", &[\"\\u{AC00}\", \"\\u{1}\"]),\n-        (\"\\u{AC00}\\u{308}\\u{1}\", &[\"\\u{AC00}\\u{308}\", \"\\u{1}\"]),\n-        (\"\\u{AC00}\\u{300}\", &[\"\\u{AC00}\\u{300}\"]),\n-        (\"\\u{AC00}\\u{308}\\u{300}\", &[\"\\u{AC00}\\u{308}\\u{300}\"]),\n-        (\"\\u{AC00}\\u{1100}\", &[\"\\u{AC00}\", \"\\u{1100}\"]),\n-        (\"\\u{AC00}\\u{308}\\u{1100}\", &[\"\\u{AC00}\\u{308}\", \"\\u{1100}\"]),\n-        (\"\\u{AC00}\\u{1160}\", &[\"\\u{AC00}\\u{1160}\"]),\n-        (\"\\u{AC00}\\u{308}\\u{1160}\", &[\"\\u{AC00}\\u{308}\", \"\\u{1160}\"]),\n-        (\"\\u{AC00}\\u{11A8}\", &[\"\\u{AC00}\\u{11A8}\"]),\n-        (\"\\u{AC00}\\u{308}\\u{11A8}\", &[\"\\u{AC00}\\u{308}\", \"\\u{11A8}\"]),\n-        (\"\\u{AC00}\\u{AC00}\", &[\"\\u{AC00}\", \"\\u{AC00}\"]),\n-        (\"\\u{AC00}\\u{308}\\u{AC00}\", &[\"\\u{AC00}\\u{308}\", \"\\u{AC00}\"]),\n-        (\"\\u{AC00}\\u{AC01}\", &[\"\\u{AC00}\", \"\\u{AC01}\"]),\n-        (\"\\u{AC00}\\u{308}\\u{AC01}\", &[\"\\u{AC00}\\u{308}\", \"\\u{AC01}\"]),\n-        (\"\\u{AC00}\\u{1F1E6}\", &[\"\\u{AC00}\", \"\\u{1F1E6}\"]),\n-        (\"\\u{AC00}\\u{308}\\u{1F1E6}\", &[\"\\u{AC00}\\u{308}\", \"\\u{1F1E6}\"]),\n-        (\"\\u{AC00}\\u{378}\", &[\"\\u{AC00}\", \"\\u{378}\"]),\n-        (\"\\u{AC00}\\u{308}\\u{378}\", &[\"\\u{AC00}\\u{308}\", \"\\u{378}\"]),\n-        (\"\\u{AC01}\\u{20}\", &[\"\\u{AC01}\", \"\\u{20}\"]),\n-        (\"\\u{AC01}\\u{308}\\u{20}\", &[\"\\u{AC01}\\u{308}\", \"\\u{20}\"]),\n-        (\"\\u{AC01}\\u{D}\", &[\"\\u{AC01}\", \"\\u{D}\"]),\n-        (\"\\u{AC01}\\u{308}\\u{D}\", &[\"\\u{AC01}\\u{308}\", \"\\u{D}\"]),\n-        (\"\\u{AC01}\\u{A}\", &[\"\\u{AC01}\", \"\\u{A}\"]),\n-        (\"\\u{AC01}\\u{308}\\u{A}\", &[\"\\u{AC01}\\u{308}\", \"\\u{A}\"]),\n-        (\"\\u{AC01}\\u{1}\", &[\"\\u{AC01}\", \"\\u{1}\"]),\n-        (\"\\u{AC01}\\u{308}\\u{1}\", &[\"\\u{AC01}\\u{308}\", \"\\u{1}\"]),\n-        (\"\\u{AC01}\\u{300}\", &[\"\\u{AC01}\\u{300}\"]),\n-        (\"\\u{AC01}\\u{308}\\u{300}\", &[\"\\u{AC01}\\u{308}\\u{300}\"]),\n-        (\"\\u{AC01}\\u{1100}\", &[\"\\u{AC01}\", \"\\u{1100}\"]),\n-        (\"\\u{AC01}\\u{308}\\u{1100}\", &[\"\\u{AC01}\\u{308}\", \"\\u{1100}\"]),\n-        (\"\\u{AC01}\\u{1160}\", &[\"\\u{AC01}\", \"\\u{1160}\"]),\n-        (\"\\u{AC01}\\u{308}\\u{1160}\", &[\"\\u{AC01}\\u{308}\", \"\\u{1160}\"]),\n-        (\"\\u{AC01}\\u{11A8}\", &[\"\\u{AC01}\\u{11A8}\"]),\n-        (\"\\u{AC01}\\u{308}\\u{11A8}\", &[\"\\u{AC01}\\u{308}\", \"\\u{11A8}\"]),\n-        (\"\\u{AC01}\\u{AC00}\", &[\"\\u{AC01}\", \"\\u{AC00}\"]),\n-        (\"\\u{AC01}\\u{308}\\u{AC00}\", &[\"\\u{AC01}\\u{308}\", \"\\u{AC00}\"]),\n-        (\"\\u{AC01}\\u{AC01}\", &[\"\\u{AC01}\", \"\\u{AC01}\"]),\n-        (\"\\u{AC01}\\u{308}\\u{AC01}\", &[\"\\u{AC01}\\u{308}\", \"\\u{AC01}\"]),\n-        (\"\\u{AC01}\\u{1F1E6}\", &[\"\\u{AC01}\", \"\\u{1F1E6}\"]),\n-        (\"\\u{AC01}\\u{308}\\u{1F1E6}\", &[\"\\u{AC01}\\u{308}\", \"\\u{1F1E6}\"]),\n-        (\"\\u{AC01}\\u{378}\", &[\"\\u{AC01}\", \"\\u{378}\"]),\n-        (\"\\u{AC01}\\u{308}\\u{378}\", &[\"\\u{AC01}\\u{308}\", \"\\u{378}\"]),\n-        (\"\\u{1F1E6}\\u{20}\", &[\"\\u{1F1E6}\", \"\\u{20}\"]),\n-        (\"\\u{1F1E6}\\u{308}\\u{20}\", &[\"\\u{1F1E6}\\u{308}\", \"\\u{20}\"]),\n-        (\"\\u{1F1E6}\\u{D}\", &[\"\\u{1F1E6}\", \"\\u{D}\"]),\n-        (\"\\u{1F1E6}\\u{308}\\u{D}\", &[\"\\u{1F1E6}\\u{308}\", \"\\u{D}\"]),\n-        (\"\\u{1F1E6}\\u{A}\", &[\"\\u{1F1E6}\", \"\\u{A}\"]),\n-        (\"\\u{1F1E6}\\u{308}\\u{A}\", &[\"\\u{1F1E6}\\u{308}\", \"\\u{A}\"]),\n-        (\"\\u{1F1E6}\\u{1}\", &[\"\\u{1F1E6}\", \"\\u{1}\"]),\n-        (\"\\u{1F1E6}\\u{308}\\u{1}\", &[\"\\u{1F1E6}\\u{308}\", \"\\u{1}\"]),\n-        (\"\\u{1F1E6}\\u{300}\", &[\"\\u{1F1E6}\\u{300}\"]),\n-        (\"\\u{1F1E6}\\u{308}\\u{300}\", &[\"\\u{1F1E6}\\u{308}\\u{300}\"]),\n-        (\"\\u{1F1E6}\\u{1100}\", &[\"\\u{1F1E6}\", \"\\u{1100}\"]),\n-        (\"\\u{1F1E6}\\u{308}\\u{1100}\", &[\"\\u{1F1E6}\\u{308}\", \"\\u{1100}\"]),\n-        (\"\\u{1F1E6}\\u{1160}\", &[\"\\u{1F1E6}\", \"\\u{1160}\"]),\n-        (\"\\u{1F1E6}\\u{308}\\u{1160}\", &[\"\\u{1F1E6}\\u{308}\", \"\\u{1160}\"]),\n-        (\"\\u{1F1E6}\\u{11A8}\", &[\"\\u{1F1E6}\", \"\\u{11A8}\"]),\n-        (\"\\u{1F1E6}\\u{308}\\u{11A8}\", &[\"\\u{1F1E6}\\u{308}\", \"\\u{11A8}\"]),\n-        (\"\\u{1F1E6}\\u{AC00}\", &[\"\\u{1F1E6}\", \"\\u{AC00}\"]),\n-        (\"\\u{1F1E6}\\u{308}\\u{AC00}\", &[\"\\u{1F1E6}\\u{308}\", \"\\u{AC00}\"]),\n-        (\"\\u{1F1E6}\\u{AC01}\", &[\"\\u{1F1E6}\", \"\\u{AC01}\"]),\n-        (\"\\u{1F1E6}\\u{308}\\u{AC01}\", &[\"\\u{1F1E6}\\u{308}\", \"\\u{AC01}\"]),\n-        (\"\\u{1F1E6}\\u{1F1E6}\", &[\"\\u{1F1E6}\\u{1F1E6}\"]),\n-        (\"\\u{1F1E6}\\u{308}\\u{1F1E6}\", &[\"\\u{1F1E6}\\u{308}\", \"\\u{1F1E6}\"]),\n-        (\"\\u{1F1E6}\\u{378}\", &[\"\\u{1F1E6}\", \"\\u{378}\"]),\n-        (\"\\u{1F1E6}\\u{308}\\u{378}\", &[\"\\u{1F1E6}\\u{308}\", \"\\u{378}\"]),\n-        (\"\\u{378}\\u{20}\", &[\"\\u{378}\", \"\\u{20}\"]),\n-        (\"\\u{378}\\u{308}\\u{20}\", &[\"\\u{378}\\u{308}\", \"\\u{20}\"]),\n-        (\"\\u{378}\\u{D}\", &[\"\\u{378}\", \"\\u{D}\"]),\n-        (\"\\u{378}\\u{308}\\u{D}\", &[\"\\u{378}\\u{308}\", \"\\u{D}\"]),\n-        (\"\\u{378}\\u{A}\", &[\"\\u{378}\", \"\\u{A}\"]),\n-        (\"\\u{378}\\u{308}\\u{A}\", &[\"\\u{378}\\u{308}\", \"\\u{A}\"]),\n-        (\"\\u{378}\\u{1}\", &[\"\\u{378}\", \"\\u{1}\"]),\n-        (\"\\u{378}\\u{308}\\u{1}\", &[\"\\u{378}\\u{308}\", \"\\u{1}\"]),\n-        (\"\\u{378}\\u{300}\", &[\"\\u{378}\\u{300}\"]),\n-        (\"\\u{378}\\u{308}\\u{300}\", &[\"\\u{378}\\u{308}\\u{300}\"]),\n-        (\"\\u{378}\\u{1100}\", &[\"\\u{378}\", \"\\u{1100}\"]),\n-        (\"\\u{378}\\u{308}\\u{1100}\", &[\"\\u{378}\\u{308}\", \"\\u{1100}\"]),\n-        (\"\\u{378}\\u{1160}\", &[\"\\u{378}\", \"\\u{1160}\"]),\n-        (\"\\u{378}\\u{308}\\u{1160}\", &[\"\\u{378}\\u{308}\", \"\\u{1160}\"]),\n-        (\"\\u{378}\\u{11A8}\", &[\"\\u{378}\", \"\\u{11A8}\"]),\n-        (\"\\u{378}\\u{308}\\u{11A8}\", &[\"\\u{378}\\u{308}\", \"\\u{11A8}\"]),\n-        (\"\\u{378}\\u{AC00}\", &[\"\\u{378}\", \"\\u{AC00}\"]),\n-        (\"\\u{378}\\u{308}\\u{AC00}\", &[\"\\u{378}\\u{308}\", \"\\u{AC00}\"]),\n-        (\"\\u{378}\\u{AC01}\", &[\"\\u{378}\", \"\\u{AC01}\"]),\n-        (\"\\u{378}\\u{308}\\u{AC01}\", &[\"\\u{378}\\u{308}\", \"\\u{AC01}\"]),\n-        (\"\\u{378}\\u{1F1E6}\", &[\"\\u{378}\", \"\\u{1F1E6}\"]),\n-        (\"\\u{378}\\u{308}\\u{1F1E6}\", &[\"\\u{378}\\u{308}\", \"\\u{1F1E6}\"]),\n-        (\"\\u{378}\\u{378}\", &[\"\\u{378}\", \"\\u{378}\"]),\n-        (\"\\u{378}\\u{308}\\u{378}\", &[\"\\u{378}\\u{308}\", \"\\u{378}\"]),\n-        (\"\\u{61}\\u{1F1E6}\\u{62}\", &[\"\\u{61}\", \"\\u{1F1E6}\", \"\\u{62}\"]),\n-        (\"\\u{1F1F7}\\u{1F1FA}\", &[\"\\u{1F1F7}\\u{1F1FA}\"]),\n-        (\"\\u{1F1F7}\\u{1F1FA}\\u{1F1F8}\", &[\"\\u{1F1F7}\\u{1F1FA}\\u{1F1F8}\"]),\n-        (\"\\u{1F1F7}\\u{1F1FA}\\u{1F1F8}\\u{1F1EA}\",\n-        &[\"\\u{1F1F7}\\u{1F1FA}\\u{1F1F8}\\u{1F1EA}\"]),\n-        (\"\\u{1F1F7}\\u{1F1FA}\\u{200B}\\u{1F1F8}\\u{1F1EA}\",\n-         &[\"\\u{1F1F7}\\u{1F1FA}\", \"\\u{200B}\", \"\\u{1F1F8}\\u{1F1EA}\"]),\n-        (\"\\u{1F1E6}\\u{1F1E7}\\u{1F1E8}\", &[\"\\u{1F1E6}\\u{1F1E7}\\u{1F1E8}\"]),\n-        (\"\\u{1F1E6}\\u{200D}\\u{1F1E7}\\u{1F1E8}\", &[\"\\u{1F1E6}\\u{200D}\",\n-         \"\\u{1F1E7}\\u{1F1E8}\"]),\n-        (\"\\u{1F1E6}\\u{1F1E7}\\u{200D}\\u{1F1E8}\",\n-         &[\"\\u{1F1E6}\\u{1F1E7}\\u{200D}\", \"\\u{1F1E8}\"]),\n-        (\"\\u{20}\\u{200D}\\u{646}\", &[\"\\u{20}\\u{200D}\", \"\\u{646}\"]),\n-        (\"\\u{646}\\u{200D}\\u{20}\", &[\"\\u{646}\\u{200D}\", \"\\u{20}\"]),\n-    ];\n-\n-    let test_diff: [(_, &[_], &[_]); 23] = [\n-        (\"\\u{20}\\u{903}\", &[\"\\u{20}\\u{903}\"], &[\"\\u{20}\", \"\\u{903}\"]), (\"\\u{20}\\u{308}\\u{903}\",\n-        &[\"\\u{20}\\u{308}\\u{903}\"], &[\"\\u{20}\\u{308}\", \"\\u{903}\"]), (\"\\u{D}\\u{308}\\u{903}\",\n-        &[\"\\u{D}\", \"\\u{308}\\u{903}\"], &[\"\\u{D}\", \"\\u{308}\", \"\\u{903}\"]), (\"\\u{A}\\u{308}\\u{903}\",\n-        &[\"\\u{A}\", \"\\u{308}\\u{903}\"], &[\"\\u{A}\", \"\\u{308}\", \"\\u{903}\"]), (\"\\u{1}\\u{308}\\u{903}\",\n-        &[\"\\u{1}\", \"\\u{308}\\u{903}\"], &[\"\\u{1}\", \"\\u{308}\", \"\\u{903}\"]), (\"\\u{300}\\u{903}\",\n-        &[\"\\u{300}\\u{903}\"], &[\"\\u{300}\", \"\\u{903}\"]), (\"\\u{300}\\u{308}\\u{903}\",\n-        &[\"\\u{300}\\u{308}\\u{903}\"], &[\"\\u{300}\\u{308}\", \"\\u{903}\"]), (\"\\u{903}\\u{903}\",\n-        &[\"\\u{903}\\u{903}\"], &[\"\\u{903}\", \"\\u{903}\"]), (\"\\u{903}\\u{308}\\u{903}\",\n-        &[\"\\u{903}\\u{308}\\u{903}\"], &[\"\\u{903}\\u{308}\", \"\\u{903}\"]), (\"\\u{1100}\\u{903}\",\n-        &[\"\\u{1100}\\u{903}\"], &[\"\\u{1100}\", \"\\u{903}\"]), (\"\\u{1100}\\u{308}\\u{903}\",\n-        &[\"\\u{1100}\\u{308}\\u{903}\"], &[\"\\u{1100}\\u{308}\", \"\\u{903}\"]), (\"\\u{1160}\\u{903}\",\n-        &[\"\\u{1160}\\u{903}\"], &[\"\\u{1160}\", \"\\u{903}\"]), (\"\\u{1160}\\u{308}\\u{903}\",\n-        &[\"\\u{1160}\\u{308}\\u{903}\"], &[\"\\u{1160}\\u{308}\", \"\\u{903}\"]), (\"\\u{11A8}\\u{903}\",\n-        &[\"\\u{11A8}\\u{903}\"], &[\"\\u{11A8}\", \"\\u{903}\"]), (\"\\u{11A8}\\u{308}\\u{903}\",\n-        &[\"\\u{11A8}\\u{308}\\u{903}\"], &[\"\\u{11A8}\\u{308}\", \"\\u{903}\"]), (\"\\u{AC00}\\u{903}\",\n-        &[\"\\u{AC00}\\u{903}\"], &[\"\\u{AC00}\", \"\\u{903}\"]), (\"\\u{AC00}\\u{308}\\u{903}\",\n-        &[\"\\u{AC00}\\u{308}\\u{903}\"], &[\"\\u{AC00}\\u{308}\", \"\\u{903}\"]), (\"\\u{AC01}\\u{903}\",\n-        &[\"\\u{AC01}\\u{903}\"], &[\"\\u{AC01}\", \"\\u{903}\"]), (\"\\u{AC01}\\u{308}\\u{903}\",\n-        &[\"\\u{AC01}\\u{308}\\u{903}\"], &[\"\\u{AC01}\\u{308}\", \"\\u{903}\"]), (\"\\u{1F1E6}\\u{903}\",\n-        &[\"\\u{1F1E6}\\u{903}\"], &[\"\\u{1F1E6}\", \"\\u{903}\"]), (\"\\u{1F1E6}\\u{308}\\u{903}\",\n-        &[\"\\u{1F1E6}\\u{308}\\u{903}\"], &[\"\\u{1F1E6}\\u{308}\", \"\\u{903}\"]), (\"\\u{378}\\u{903}\",\n-        &[\"\\u{378}\\u{903}\"], &[\"\\u{378}\", \"\\u{903}\"]), (\"\\u{378}\\u{308}\\u{903}\",\n-        &[\"\\u{378}\\u{308}\\u{903}\"], &[\"\\u{378}\\u{308}\", \"\\u{903}\"]),\n-    ];\n-\n-    for &(s, g) in &test_same[..] {\n-        // test forward iterator\n-        assert!(order::equals(s.graphemes(true), g.iter().cloned()));\n-        assert!(order::equals(s.graphemes(false), g.iter().cloned()));\n-\n-        // test reverse iterator\n-        assert!(order::equals(s.graphemes(true).rev(), g.iter().rev().cloned()));\n-        assert!(order::equals(s.graphemes(false).rev(), g.iter().rev().cloned()));\n-    }\n-\n-    for &(s, gt, gf) in &test_diff {\n-        // test forward iterator\n-        assert!(order::equals(s.graphemes(true), gt.iter().cloned()));\n-        assert!(order::equals(s.graphemes(false), gf.iter().cloned()));\n-\n-        // test reverse iterator\n-        assert!(order::equals(s.graphemes(true).rev(), gt.iter().rev().cloned()));\n-        assert!(order::equals(s.graphemes(false).rev(), gf.iter().rev().cloned()));\n-    }\n-\n-    // test the indices iterators\n-    let s = \"a\u0310e\u0301o\u0308\u0332\\r\\n\";\n-    let gr_inds = s.grapheme_indices(true).collect::<Vec<(usize, &str)>>();\n-    let b: &[_] = &[(0, \"a\u0310\"), (3, \"e\u0301\"), (6, \"o\u0308\u0332\"), (11, \"\\r\\n\")];\n-    assert_eq!(gr_inds, b);\n-    let gr_inds = s.grapheme_indices(true).rev().collect::<Vec<(usize, &str)>>();\n-    let b: &[_] = &[(11, \"\\r\\n\"), (6, \"o\u0308\u0332\"), (3, \"e\u0301\"), (0, \"a\u0310\")];\n-    assert_eq!(gr_inds, b);\n-    let mut gr_inds_iter = s.grapheme_indices(true);\n-    {\n-        let gr_inds = gr_inds_iter.by_ref();\n-        let e1 = gr_inds.size_hint();\n-        assert_eq!(e1, (1, Some(13)));\n-        let c = gr_inds.count();\n-        assert_eq!(c, 4);\n-    }\n-    let e2 = gr_inds_iter.size_hint();\n-    assert_eq!(e2, (0, Some(0)));\n-\n-    // make sure the reverse iterator does the right thing with \"\\n\" at beginning of string\n-    let s = \"\\n\\r\\n\\r\";\n-    let gr = s.graphemes(true).rev().collect::<Vec<&str>>();\n-    let b: &[_] = &[\"\\r\", \"\\r\\n\", \"\\n\"];\n-    assert_eq!(gr, b);\n-}\n-\n #[test]\n fn test_splitator() {\n     fn t(s: &str, sep: &str, u: &[&str]) {"}, {"sha": "554be72e4268170ea057ab10309910ef937f9b37", "filename": "src/libcollectionstest/vec.rs", "status": "modified", "additions": 2, "deletions": 80, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcollectionstest%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcollectionstest%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fvec.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -254,23 +254,6 @@ fn test_zip_unzip() {\n     assert_eq!((3, 6), (left[2], right[2]));\n }\n \n-#[test]\n-fn test_unsafe_ptrs() {\n-    unsafe {\n-        // Test on-stack copy-from-buf.\n-        let a = [1, 2, 3];\n-        let ptr = a.as_ptr();\n-        let b = Vec::from_raw_buf(ptr, 3);\n-        assert_eq!(b, [1, 2, 3]);\n-\n-        // Test on-heap copy-from-buf.\n-        let c = vec![1, 2, 3, 4, 5];\n-        let ptr = c.as_ptr();\n-        let d = Vec::from_raw_buf(ptr, 5);\n-        assert_eq!(d, [1, 2, 3, 4, 5]);\n-    }\n-}\n-\n #[test]\n fn test_vec_truncate_drop() {\n     static mut drops: u32 = 0;\n@@ -323,7 +306,7 @@ fn test_index_out_of_bounds() {\n #[should_panic]\n fn test_slice_out_of_bounds_1() {\n     let x = vec![1, 2, 3, 4, 5];\n-    &x[-1..];\n+    &x[!0..];\n }\n \n #[test]\n@@ -337,7 +320,7 @@ fn test_slice_out_of_bounds_2() {\n #[should_panic]\n fn test_slice_out_of_bounds_3() {\n     let x = vec![1, 2, 3, 4, 5];\n-    &x[-1..4];\n+    &x[!0..4];\n }\n \n #[test]\n@@ -361,67 +344,6 @@ fn test_swap_remove_empty() {\n     vec.swap_remove(0);\n }\n \n-#[test]\n-fn test_move_iter_unwrap() {\n-    let mut vec = Vec::with_capacity(7);\n-    vec.push(1);\n-    vec.push(2);\n-    let ptr = vec.as_ptr();\n-    vec = vec.into_iter().into_inner();\n-    assert_eq!(vec.as_ptr(), ptr);\n-    assert_eq!(vec.capacity(), 7);\n-    assert_eq!(vec.len(), 0);\n-}\n-\n-#[test]\n-#[should_panic]\n-fn test_map_in_place_incompatible_types_fail() {\n-    let v = vec![0, 1, 2];\n-    v.map_in_place(|_| ());\n-}\n-\n-#[test]\n-fn test_map_in_place() {\n-    let v = vec![0, 1, 2];\n-    assert_eq!(v.map_in_place(|i: u32| i as i32 - 1), [-1, 0, 1]);\n-}\n-\n-#[test]\n-fn test_map_in_place_zero_sized() {\n-    let v = vec![(), ()];\n-    #[derive(PartialEq, Debug)]\n-    struct ZeroSized;\n-    assert_eq!(v.map_in_place(|_| ZeroSized), [ZeroSized, ZeroSized]);\n-}\n-\n-#[test]\n-fn test_map_in_place_zero_drop_count() {\n-    use std::sync::atomic::{AtomicUsize, Ordering};\n-\n-    #[derive(Clone, PartialEq, Debug)]\n-    struct Nothing;\n-    impl Drop for Nothing { fn drop(&mut self) { } }\n-\n-    #[derive(Clone, PartialEq, Debug)]\n-    struct ZeroSized;\n-    impl Drop for ZeroSized {\n-        fn drop(&mut self) {\n-            DROP_COUNTER.fetch_add(1, Ordering::Relaxed);\n-        }\n-    }\n-    const NUM_ELEMENTS: usize = 2;\n-    static DROP_COUNTER: AtomicUsize = AtomicUsize::new(0);\n-\n-    let v = repeat(Nothing).take(NUM_ELEMENTS).collect::<Vec<_>>();\n-\n-    DROP_COUNTER.store(0, Ordering::Relaxed);\n-\n-    let v = v.map_in_place(|_| ZeroSized);\n-    assert_eq!(DROP_COUNTER.load(Ordering::Relaxed), 0);\n-    drop(v);\n-    assert_eq!(DROP_COUNTER.load(Ordering::Relaxed), NUM_ELEMENTS);\n-}\n-\n #[test]\n fn test_move_items() {\n     let vec = vec![1, 2, 3];"}, {"sha": "1931e372aeb91c29c6bb6443094fb3ea407cec6f", "filename": "src/libcollectionstest/vec_deque.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcollectionstest%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcollectionstest%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fvec_deque.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -10,7 +10,6 @@\n \n use std::collections::VecDeque;\n use std::fmt::Debug;\n-use std::hash::{SipHasher, self};\n \n use test;\n \n@@ -603,7 +602,7 @@ fn test_hash() {\n   y.push_back(2);\n   y.push_back(3);\n \n-  assert!(hash::hash::<_, SipHasher>(&x) == hash::hash::<_, SipHasher>(&y));\n+  assert!(::hash(&x) == ::hash(&y));\n }\n \n #[test]"}, {"sha": "3ab32323603ca1bd096d9e2e9fdc4115b6187457", "filename": "src/libcollectionstest/vec_map.rs", "status": "removed", "additions": 0, "deletions": 526, "changes": 526, "blob_url": "https://github.com/rust-lang/rust/blob/a4066271b77810aec0a4a309f66a45e4f8b940de/src%2Flibcollectionstest%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4066271b77810aec0a4a309f66a45e4f8b940de/src%2Flibcollectionstest%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fvec_map.rs?ref=a4066271b77810aec0a4a309f66a45e4f8b940de", "patch": "@@ -1,526 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::collections::VecMap;\n-use std::collections::vec_map::Entry::{Occupied, Vacant};\n-use std::hash::{SipHasher, hash};\n-\n-#[test]\n-fn test_get_mut() {\n-    let mut m = VecMap::new();\n-    assert!(m.insert(1, 12).is_none());\n-    assert!(m.insert(2, 8).is_none());\n-    assert!(m.insert(5, 14).is_none());\n-    let new = 100;\n-    match m.get_mut(&5) {\n-        None => panic!(), Some(x) => *x = new\n-    }\n-    assert_eq!(m.get(&5), Some(&new));\n-}\n-\n-#[test]\n-fn test_len() {\n-    let mut map = VecMap::new();\n-    assert_eq!(map.len(), 0);\n-    assert!(map.is_empty());\n-    assert!(map.insert(5, 20).is_none());\n-    assert_eq!(map.len(), 1);\n-    assert!(!map.is_empty());\n-    assert!(map.insert(11, 12).is_none());\n-    assert_eq!(map.len(), 2);\n-    assert!(!map.is_empty());\n-    assert!(map.insert(14, 22).is_none());\n-    assert_eq!(map.len(), 3);\n-    assert!(!map.is_empty());\n-}\n-\n-#[test]\n-fn test_clear() {\n-    let mut map = VecMap::new();\n-    assert!(map.insert(5, 20).is_none());\n-    assert!(map.insert(11, 12).is_none());\n-    assert!(map.insert(14, 22).is_none());\n-    map.clear();\n-    assert!(map.is_empty());\n-    assert!(map.get(&5).is_none());\n-    assert!(map.get(&11).is_none());\n-    assert!(map.get(&14).is_none());\n-}\n-\n-#[test]\n-fn test_insert() {\n-    let mut m = VecMap::new();\n-    assert_eq!(m.insert(1, 2), None);\n-    assert_eq!(m.insert(1, 3), Some(2));\n-    assert_eq!(m.insert(1, 4), Some(3));\n-}\n-\n-#[test]\n-fn test_remove() {\n-    let mut m = VecMap::new();\n-    m.insert(1, 2);\n-    assert_eq!(m.remove(&1), Some(2));\n-    assert_eq!(m.remove(&1), None);\n-}\n-\n-#[test]\n-fn test_keys() {\n-    let mut map = VecMap::new();\n-    map.insert(1, 'a');\n-    map.insert(2, 'b');\n-    map.insert(3, 'c');\n-    let keys: Vec<_> = map.keys().collect();\n-    assert_eq!(keys.len(), 3);\n-    assert!(keys.contains(&1));\n-    assert!(keys.contains(&2));\n-    assert!(keys.contains(&3));\n-}\n-\n-#[test]\n-fn test_values() {\n-    let mut map = VecMap::new();\n-    map.insert(1, 'a');\n-    map.insert(2, 'b');\n-    map.insert(3, 'c');\n-    let values: Vec<_> = map.values().cloned().collect();\n-    assert_eq!(values.len(), 3);\n-    assert!(values.contains(&'a'));\n-    assert!(values.contains(&'b'));\n-    assert!(values.contains(&'c'));\n-}\n-\n-#[test]\n-fn test_iterator() {\n-    let mut m = VecMap::new();\n-\n-    assert!(m.insert(0, 1).is_none());\n-    assert!(m.insert(1, 2).is_none());\n-    assert!(m.insert(3, 5).is_none());\n-    assert!(m.insert(6, 10).is_none());\n-    assert!(m.insert(10, 11).is_none());\n-\n-    let mut it = m.iter();\n-    assert_eq!(it.size_hint(), (0, Some(11)));\n-    assert_eq!(it.next().unwrap(), (0, &1));\n-    assert_eq!(it.size_hint(), (0, Some(10)));\n-    assert_eq!(it.next().unwrap(), (1, &2));\n-    assert_eq!(it.size_hint(), (0, Some(9)));\n-    assert_eq!(it.next().unwrap(), (3, &5));\n-    assert_eq!(it.size_hint(), (0, Some(7)));\n-    assert_eq!(it.next().unwrap(), (6, &10));\n-    assert_eq!(it.size_hint(), (0, Some(4)));\n-    assert_eq!(it.next().unwrap(), (10, &11));\n-    assert_eq!(it.size_hint(), (0, Some(0)));\n-    assert!(it.next().is_none());\n-}\n-\n-#[test]\n-fn test_iterator_size_hints() {\n-    let mut m = VecMap::new();\n-\n-    assert!(m.insert(0, 1).is_none());\n-    assert!(m.insert(1, 2).is_none());\n-    assert!(m.insert(3, 5).is_none());\n-    assert!(m.insert(6, 10).is_none());\n-    assert!(m.insert(10, 11).is_none());\n-\n-    assert_eq!(m.iter().size_hint(), (0, Some(11)));\n-    assert_eq!(m.iter().rev().size_hint(), (0, Some(11)));\n-    assert_eq!(m.iter_mut().size_hint(), (0, Some(11)));\n-    assert_eq!(m.iter_mut().rev().size_hint(), (0, Some(11)));\n-}\n-\n-#[test]\n-fn test_mut_iterator() {\n-    let mut m = VecMap::new();\n-\n-    assert!(m.insert(0, 1).is_none());\n-    assert!(m.insert(1, 2).is_none());\n-    assert!(m.insert(3, 5).is_none());\n-    assert!(m.insert(6, 10).is_none());\n-    assert!(m.insert(10, 11).is_none());\n-\n-    for (k, v) in &mut m {\n-        *v += k as isize;\n-    }\n-\n-    let mut it = m.iter();\n-    assert_eq!(it.next().unwrap(), (0, &1));\n-    assert_eq!(it.next().unwrap(), (1, &3));\n-    assert_eq!(it.next().unwrap(), (3, &8));\n-    assert_eq!(it.next().unwrap(), (6, &16));\n-    assert_eq!(it.next().unwrap(), (10, &21));\n-    assert!(it.next().is_none());\n-}\n-\n-#[test]\n-fn test_rev_iterator() {\n-    let mut m = VecMap::new();\n-\n-    assert!(m.insert(0, 1).is_none());\n-    assert!(m.insert(1, 2).is_none());\n-    assert!(m.insert(3, 5).is_none());\n-    assert!(m.insert(6, 10).is_none());\n-    assert!(m.insert(10, 11).is_none());\n-\n-    let mut it = m.iter().rev();\n-    assert_eq!(it.next().unwrap(), (10, &11));\n-    assert_eq!(it.next().unwrap(), (6, &10));\n-    assert_eq!(it.next().unwrap(), (3, &5));\n-    assert_eq!(it.next().unwrap(), (1, &2));\n-    assert_eq!(it.next().unwrap(), (0, &1));\n-    assert!(it.next().is_none());\n-}\n-\n-#[test]\n-fn test_mut_rev_iterator() {\n-    let mut m = VecMap::new();\n-\n-    assert!(m.insert(0, 1).is_none());\n-    assert!(m.insert(1, 2).is_none());\n-    assert!(m.insert(3, 5).is_none());\n-    assert!(m.insert(6, 10).is_none());\n-    assert!(m.insert(10, 11).is_none());\n-\n-    for (k, v) in m.iter_mut().rev() {\n-        *v += k as isize;\n-    }\n-\n-    let mut it = m.iter();\n-    assert_eq!(it.next().unwrap(), (0, &1));\n-    assert_eq!(it.next().unwrap(), (1, &3));\n-    assert_eq!(it.next().unwrap(), (3, &8));\n-    assert_eq!(it.next().unwrap(), (6, &16));\n-    assert_eq!(it.next().unwrap(), (10, &21));\n-    assert!(it.next().is_none());\n-}\n-\n-#[test]\n-fn test_move_iter() {\n-    let mut m: VecMap<Box<_>> = VecMap::new();\n-    m.insert(1, box 2);\n-    let mut called = false;\n-    for (k, v) in m {\n-        assert!(!called);\n-        called = true;\n-        assert_eq!(k, 1);\n-        assert_eq!(v, box 2);\n-    }\n-    assert!(called);\n-}\n-\n-#[test]\n-fn test_drain_iterator() {\n-    let mut map = VecMap::new();\n-    map.insert(1, \"a\");\n-    map.insert(3, \"c\");\n-    map.insert(2, \"b\");\n-\n-    let vec: Vec<_> = map.drain().collect();\n-\n-    assert_eq!(vec, [(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n-    assert_eq!(map.len(), 0);\n-}\n-\n-#[test]\n-fn test_append() {\n-    let mut a = VecMap::new();\n-    a.insert(1, \"a\");\n-    a.insert(2, \"b\");\n-    a.insert(3, \"c\");\n-\n-    let mut b = VecMap::new();\n-    b.insert(3, \"d\");  // Overwrite element from a\n-    b.insert(4, \"e\");\n-    b.insert(5, \"f\");\n-\n-    a.append(&mut b);\n-\n-    assert_eq!(a.len(), 5);\n-    assert_eq!(b.len(), 0);\n-    // Capacity shouldn't change for possible reuse\n-    assert!(b.capacity() >= 4);\n-\n-    assert_eq!(a[1], \"a\");\n-    assert_eq!(a[2], \"b\");\n-    assert_eq!(a[3], \"d\");\n-    assert_eq!(a[4], \"e\");\n-    assert_eq!(a[5], \"f\");\n-}\n-\n-#[test]\n-fn test_split_off() {\n-    // Split within the key range\n-    let mut a = VecMap::new();\n-    a.insert(1, \"a\");\n-    a.insert(2, \"b\");\n-    a.insert(3, \"c\");\n-    a.insert(4, \"d\");\n-\n-    let b = a.split_off(3);\n-\n-    assert_eq!(a.len(), 2);\n-    assert_eq!(b.len(), 2);\n-\n-    assert_eq!(a[1], \"a\");\n-    assert_eq!(a[2], \"b\");\n-\n-    assert_eq!(b[3], \"c\");\n-    assert_eq!(b[4], \"d\");\n-\n-    // Split at 0\n-    a.clear();\n-    a.insert(1, \"a\");\n-    a.insert(2, \"b\");\n-    a.insert(3, \"c\");\n-    a.insert(4, \"d\");\n-\n-    let b = a.split_off(0);\n-\n-    assert_eq!(a.len(), 0);\n-    assert_eq!(b.len(), 4);\n-    assert_eq!(b[1], \"a\");\n-    assert_eq!(b[2], \"b\");\n-    assert_eq!(b[3], \"c\");\n-    assert_eq!(b[4], \"d\");\n-\n-    // Split behind max_key\n-    a.clear();\n-    a.insert(1, \"a\");\n-    a.insert(2, \"b\");\n-    a.insert(3, \"c\");\n-    a.insert(4, \"d\");\n-\n-    let b = a.split_off(5);\n-\n-    assert_eq!(a.len(), 4);\n-    assert_eq!(b.len(), 0);\n-    assert_eq!(a[1], \"a\");\n-    assert_eq!(a[2], \"b\");\n-    assert_eq!(a[3], \"c\");\n-    assert_eq!(a[4], \"d\");\n-}\n-\n-#[test]\n-fn test_show() {\n-    let mut map = VecMap::new();\n-    let empty = VecMap::<i32>::new();\n-\n-    map.insert(1, 2);\n-    map.insert(3, 4);\n-\n-    let map_str = format!(\"{:?}\", map);\n-    assert!(map_str == \"{1: 2, 3: 4}\" || map_str == \"{3: 4, 1: 2}\");\n-    assert_eq!(format!(\"{:?}\", empty), \"{}\");\n-}\n-\n-#[test]\n-fn test_clone() {\n-    let mut a = VecMap::new();\n-\n-    a.insert(1, 'x');\n-    a.insert(4, 'y');\n-    a.insert(6, 'z');\n-\n-    assert!(a.clone() == a);\n-}\n-\n-#[test]\n-fn test_eq() {\n-    let mut a = VecMap::new();\n-    let mut b = VecMap::new();\n-\n-    assert!(a == b);\n-    assert!(a.insert(0, 5).is_none());\n-    assert!(a != b);\n-    assert!(b.insert(0, 4).is_none());\n-    assert!(a != b);\n-    assert!(a.insert(5, 19).is_none());\n-    assert!(a != b);\n-    assert!(!b.insert(0, 5).is_none());\n-    assert!(a != b);\n-    assert!(b.insert(5, 19).is_none());\n-    assert!(a == b);\n-\n-    a = VecMap::new();\n-    b = VecMap::with_capacity(1);\n-    assert!(a == b);\n-}\n-\n-#[test]\n-fn test_lt() {\n-    let mut a = VecMap::new();\n-    let mut b = VecMap::new();\n-\n-    assert!(!(a < b) && !(b < a));\n-    assert!(b.insert(2, 5).is_none());\n-    assert!(a < b);\n-    assert!(a.insert(2, 7).is_none());\n-    assert!(!(a < b) && b < a);\n-    assert!(b.insert(1, 0).is_none());\n-    assert!(b < a);\n-    assert!(a.insert(0, 6).is_none());\n-    assert!(a < b);\n-    assert!(a.insert(6, 2).is_none());\n-    assert!(a < b && !(b < a));\n-}\n-\n-#[test]\n-fn test_ord() {\n-    let mut a = VecMap::new();\n-    let mut b = VecMap::new();\n-\n-    assert!(a <= b && a >= b);\n-    assert!(a.insert(1, 1).is_none());\n-    assert!(a > b && a >= b);\n-    assert!(b < a && b <= a);\n-    assert!(b.insert(2, 2).is_none());\n-    assert!(b > a && b >= a);\n-    assert!(a < b && a <= b);\n-}\n-\n-#[test]\n-fn test_hash() {\n-    let mut x = VecMap::new();\n-    let mut y = VecMap::new();\n-\n-    assert!(hash::<_, SipHasher>(&x) == hash::<_, SipHasher>(&y));\n-    x.insert(1, 'a');\n-    x.insert(2, 'b');\n-    x.insert(3, 'c');\n-\n-    y.insert(3, 'c');\n-    y.insert(2, 'b');\n-    y.insert(1, 'a');\n-\n-    assert!(hash::<_, SipHasher>(&x) == hash::<_, SipHasher>(&y));\n-\n-    x.insert(1000, 'd');\n-    x.remove(&1000);\n-\n-    assert!(hash::<_, SipHasher>(&x) == hash::<_, SipHasher>(&y));\n-}\n-\n-#[test]\n-fn test_from_iter() {\n-    let xs = vec![(1, 'a'), (2, 'b'), (3, 'c'), (4, 'd'), (5, 'e')];\n-\n-    let map: VecMap<_> = xs.iter().cloned().collect();\n-\n-    for &(k, v) in &xs {\n-        assert_eq!(map.get(&k), Some(&v));\n-    }\n-}\n-\n-#[test]\n-fn test_index() {\n-    let mut map = VecMap::new();\n-\n-    map.insert(1, 2);\n-    map.insert(2, 1);\n-    map.insert(3, 4);\n-\n-    assert_eq!(map[3], 4);\n-}\n-\n-#[test]\n-#[should_panic]\n-fn test_index_nonexistent() {\n-    let mut map = VecMap::new();\n-\n-    map.insert(1, 2);\n-    map.insert(2, 1);\n-    map.insert(3, 4);\n-\n-    map[4];\n-}\n-\n-#[test]\n-fn test_entry(){\n-    let xs = [(1, 10), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)];\n-\n-    let mut map: VecMap<_> = xs.iter().cloned().collect();\n-\n-    // Existing key (insert)\n-    match map.entry(1) {\n-        Vacant(_) => unreachable!(),\n-        Occupied(mut view) => {\n-            assert_eq!(view.get(), &10);\n-            assert_eq!(view.insert(100), 10);\n-        }\n-    }\n-    assert_eq!(map.get(&1).unwrap(), &100);\n-    assert_eq!(map.len(), 6);\n-\n-\n-    // Existing key (update)\n-    match map.entry(2) {\n-        Vacant(_) => unreachable!(),\n-        Occupied(mut view) => {\n-            let v = view.get_mut();\n-            *v *= 10;\n-        }\n-    }\n-    assert_eq!(map.get(&2).unwrap(), &200);\n-    assert_eq!(map.len(), 6);\n-\n-    // Existing key (take)\n-    match map.entry(3) {\n-        Vacant(_) => unreachable!(),\n-        Occupied(view) => {\n-            assert_eq!(view.remove(), 30);\n-        }\n-    }\n-    assert_eq!(map.get(&3), None);\n-    assert_eq!(map.len(), 5);\n-\n-\n-    // Inexistent key (insert)\n-    match map.entry(10) {\n-        Occupied(_) => unreachable!(),\n-        Vacant(view) => {\n-            assert_eq!(*view.insert(1000), 1000);\n-        }\n-    }\n-    assert_eq!(map.get(&10).unwrap(), &1000);\n-    assert_eq!(map.len(), 6);\n-}\n-\n-#[test]\n-fn test_extend_ref() {\n-    let mut a = VecMap::new();\n-    a.insert(1, \"one\");\n-    let mut b = VecMap::new();\n-    b.insert(2, \"two\");\n-    b.insert(3, \"three\");\n-\n-    a.extend(&b);\n-\n-    assert_eq!(a.len(), 3);\n-    assert_eq!(a[&1], \"one\");\n-    assert_eq!(a[&2], \"two\");\n-    assert_eq!(a[&3], \"three\");\n-}\n-\n-mod bench {\n-    use std::collections::VecMap;\n-\n-    map_insert_rand_bench!{insert_rand_100,    100,    VecMap}\n-    map_insert_rand_bench!{insert_rand_10_000, 10_000, VecMap}\n-\n-    map_insert_seq_bench!{insert_seq_100,    100,    VecMap}\n-    map_insert_seq_bench!{insert_seq_10_000, 10_000, VecMap}\n-\n-    map_find_rand_bench!{find_rand_100,    100,    VecMap}\n-    map_find_rand_bench!{find_rand_10_000, 10_000, VecMap}\n-\n-    map_find_seq_bench!{find_seq_100,    100,    VecMap}\n-    map_find_seq_bench!{find_seq_10_000, 10_000, VecMap}\n-}"}, {"sha": "8062e77d39747ac87a5fb59f5b262c746e5e49f1", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 1, "deletions": 27, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -546,20 +546,6 @@ impl<'b, T: ?Sized> Deref for Ref<'b, T> {\n     }\n }\n \n-/// Copies a `Ref`.\n-///\n-/// The `RefCell` is already immutably borrowed, so this cannot fail.\n-///\n-/// A `Clone` implementation would interfere with the widespread\n-/// use of `r.borrow().clone()` to clone the contents of a `RefCell`.\n-#[deprecated(since = \"1.2.0\", reason = \"moved to a `Ref::clone` associated function\")]\n-#[unstable(feature = \"core\",\n-           reason = \"likely to be moved to a method, pending language changes\")]\n-#[inline]\n-pub fn clone_ref<'b, T:Clone>(orig: &Ref<'b, T>) -> Ref<'b, T> {\n-    Ref::clone(orig)\n-}\n-\n impl<'b, T: ?Sized> Ref<'b, T> {\n     /// Copies a `Ref`.\n     ///\n@@ -799,14 +785,7 @@ impl<'b, T: ?Sized> DerefMut for RefMut<'b, T> {\n #[lang = \"unsafe_cell\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct UnsafeCell<T: ?Sized> {\n-    /// Wrapped value\n-    ///\n-    /// This field should not be accessed directly, it is made public for static\n-    /// initializers.\n-    #[deprecated(since = \"1.2.0\", reason = \"use `get` to access the wrapped \\\n-        value or `new` to initialize `UnsafeCell` in statics\")]\n-    #[unstable(feature = \"core\")]\n-    pub value: T,\n+    value: T,\n }\n \n impl<T: ?Sized> !Sync for UnsafeCell<T> {}\n@@ -828,7 +807,6 @@ impl<T> UnsafeCell<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub const fn new(value: T) -> UnsafeCell<T> {\n-        #![allow(deprecated)]\n         UnsafeCell { value: value }\n     }\n \n@@ -851,7 +829,6 @@ impl<T> UnsafeCell<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub unsafe fn into_inner(self) -> T {\n-        #![allow(deprecated)]\n         self.value\n     }\n }\n@@ -871,9 +848,6 @@ impl<T: ?Sized> UnsafeCell<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self) -> *mut T {\n-        // FIXME(#23542) Replace with type ascription.\n-        #![allow(trivial_casts)]\n-        #![allow(deprecated)]\n         &self.value as *const T as *mut T\n     }\n }"}, {"sha": "aea5feb4be1ff4e942892bd4a7b5e0334d5700e0", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 1, "deletions": 73, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -21,7 +21,7 @@ use self::Ordering::*;\n \n use mem;\n use marker::Sized;\n-use option::Option::{self, Some, None};\n+use option::Option::{self, Some};\n \n /// Trait for equality comparisons which are [partial equivalence\n /// relations](http://en.wikipedia.org/wiki/Partial_equivalence_relation).\n@@ -381,78 +381,6 @@ pub fn max<T: Ord>(v1: T, v2: T) -> T {\n     if v2 >= v1 { v2 } else { v1 }\n }\n \n-/// Compare and return the minimum of two values if there is one.\n-///\n-/// Returns the first argument if the comparison determines them to be equal.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// #![feature(cmp_partial)]\n-///\n-/// use std::cmp;\n-///\n-/// assert_eq!(Some(1), cmp::partial_min(1, 2));\n-/// assert_eq!(Some(2), cmp::partial_min(2, 2));\n-/// ```\n-///\n-/// When comparison is impossible:\n-///\n-/// ```\n-/// #![feature(cmp_partial)]\n-///\n-/// use std::cmp;\n-///\n-/// let result = cmp::partial_min(std::f64::NAN, 1.0);\n-/// assert_eq!(result, None);\n-/// ```\n-#[inline]\n-#[unstable(feature = \"cmp_partial\")]\n-#[deprecated(since = \"1.3.0\", reason = \"has not proven itself worthwhile\")]\n-pub fn partial_min<T: PartialOrd>(v1: T, v2: T) -> Option<T> {\n-    match v1.partial_cmp(&v2) {\n-        Some(Less) | Some(Equal) => Some(v1),\n-        Some(Greater) => Some(v2),\n-        None => None\n-    }\n-}\n-\n-/// Compare and return the maximum of two values if there is one.\n-///\n-/// Returns the second argument if the comparison determines them to be equal.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// #![feature(cmp_partial)]\n-///\n-/// use std::cmp;\n-///\n-/// assert_eq!(Some(2), cmp::partial_max(1, 2));\n-/// assert_eq!(Some(2), cmp::partial_max(2, 2));\n-/// ```\n-///\n-/// When comparison is impossible:\n-///\n-/// ```\n-/// #![feature(cmp_partial)]\n-///\n-/// use std::cmp;\n-///\n-/// let result = cmp::partial_max(std::f64::NAN, 1.0);\n-/// assert_eq!(result, None);\n-/// ```\n-#[inline]\n-#[unstable(feature = \"cmp_partial\")]\n-#[deprecated(since = \"1.3.0\", reason = \"has not proven itself worthwhile\")]\n-pub fn partial_max<T: PartialOrd>(v1: T, v2: T) -> Option<T> {\n-    match v1.partial_cmp(&v2) {\n-        Some(Equal) | Some(Less) => Some(v2),\n-        Some(Greater) => Some(v1),\n-        None => None\n-    }\n-}\n-\n // Implementation of PartialEq, Eq, PartialOrd and Ord for primitive types\n mod impls {\n     use cmp::{PartialOrd, Ord, PartialEq, Eq, Ordering};"}, {"sha": "361c6d700dec1d42f2fb423044853f6338420707", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 16, "deletions": 23, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -16,9 +16,7 @@\n //! # Examples\n //!\n //! ```rust\n-//! #![feature(hash_default)]\n-//!\n-//! use std::hash::{hash, Hash, SipHasher};\n+//! use std::hash::{Hash, SipHasher, Hasher};\n //!\n //! #[derive(Hash)]\n //! struct Person {\n@@ -30,16 +28,20 @@\n //! let person1 = Person { id: 5, name: \"Janet\".to_string(), phone: 555_666_7777 };\n //! let person2 = Person { id: 5, name: \"Bob\".to_string(), phone: 555_666_7777 };\n //!\n-//! assert!(hash::<_, SipHasher>(&person1) != hash::<_, SipHasher>(&person2));\n+//! assert!(hash(&person1) != hash(&person2));\n+//!\n+//! fn hash<T: Hash>(t: &T) -> u64 {\n+//!     let mut s = SipHasher::new();\n+//!     t.hash(&mut s);\n+//!     s.finish()\n+//! }\n //! ```\n //!\n //! If you need more control over how a value is hashed, you need to implement\n //! the trait `Hash`:\n //!\n //! ```rust\n-//! #![feature(hash_default)]\n-//!\n-//! use std::hash::{hash, Hash, Hasher, SipHasher};\n+//! use std::hash::{Hash, Hasher, SipHasher};\n //!\n //! struct Person {\n //!     id: u32,\n@@ -57,7 +59,13 @@\n //! let person1 = Person { id: 5, name: \"Janet\".to_string(), phone: 555_666_7777 };\n //! let person2 = Person { id: 5, name: \"Bob\".to_string(), phone: 555_666_7777 };\n //!\n-//! assert_eq!(hash::<_, SipHasher>(&person1), hash::<_, SipHasher>(&person2));\n+//! assert_eq!(hash(&person1), hash(&person2));\n+//!\n+//! fn hash<T: Hash>(t: &T) -> u64 {\n+//!     let mut s = SipHasher::new();\n+//!     t.hash(&mut s);\n+//!     s.finish()\n+//! }\n //! ```\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -165,21 +173,6 @@ pub trait Hasher {\n     fn write_isize(&mut self, i: isize) { self.write_usize(i as usize) }\n }\n \n-/// Hash a value with the default SipHasher algorithm (two initial keys of 0).\n-///\n-/// The specified value will be hashed with this hasher and then the resulting\n-/// hash will be returned.\n-#[unstable(feature = \"hash_default\",\n-           reason = \"not the most ergonomic interface unless `H` is defaulted \\\n-                     to SipHasher, but perhaps not ready to commit to that\")]\n-#[deprecated(since = \"1.3.0\",\n-             reason = \"has yet to prove itself useful\")]\n-pub fn hash<T: Hash, H: Hasher + Default>(value: &T) -> u64 {\n-    let mut h: H = Default::default();\n-    value.hash(&mut h);\n-    h.finish()\n-}\n-\n //////////////////////////////////////////////////////////////////////////////\n \n mod impls {"}, {"sha": "79e4a5b428607d41e14fbee2b5a97e6135789c78", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 1, "deletions": 544, "changes": 545, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -56,9 +56,6 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-#[allow(deprecated)]\n-use self::MinMaxResult::*;\n-\n use clone::Clone;\n use cmp;\n use cmp::{Ord, PartialOrd, PartialEq};\n@@ -445,7 +442,6 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[allow(deprecated)]\n     fn scan<St, B, F>(self, initial_state: St, f: F) -> Scan<Self, St, F>\n         where Self: Sized, F: FnMut(&mut St, Self::Item) -> Option<B>,\n     {\n@@ -806,89 +802,6 @@ pub trait Iterator {\n             .map(|(_, x)| x)\n     }\n \n-    /// `min_max` finds the minimum and maximum elements in the iterator.\n-    ///\n-    /// The return type `MinMaxResult` is an enum of three variants:\n-    ///\n-    /// - `NoElements` if the iterator is empty.\n-    /// - `OneElement(x)` if the iterator has exactly one element.\n-    /// - `MinMax(x, y)` is returned otherwise, where `x <= y`. Two\n-    ///    values are equal if and only if there is more than one\n-    ///    element in the iterator and all elements are equal.\n-    ///\n-    /// On an iterator of length `n`, `min_max` does `1.5 * n` comparisons,\n-    /// and so is faster than calling `min` and `max` separately which does `2 *\n-    /// n` comparisons.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(iter_min_max)]\n-    ///\n-    /// use std::iter::MinMaxResult::{NoElements, OneElement, MinMax};\n-    ///\n-    /// let a: [i32; 0] = [];\n-    /// assert_eq!(a.iter().min_max(), NoElements);\n-    ///\n-    /// let a = [1];\n-    /// assert_eq!(a.iter().min_max(), OneElement(&1));\n-    ///\n-    /// let a = [1, 2, 3, 4, 5];\n-    /// assert_eq!(a.iter().min_max(), MinMax(&1, &5));\n-    ///\n-    /// let a = [1, 1, 1, 1];\n-    /// assert_eq!(a.iter().min_max(), MinMax(&1, &1));\n-    /// ```\n-    #[unstable(feature = \"iter_min_max\",\n-               reason = \"return type may change or may wish to have a closure \\\n-                         based version as well\")]\n-    #[deprecated(since = \"1.3.0\", reason = \"has not proven itself\")]\n-    #[allow(deprecated)]\n-    fn min_max(mut self) -> MinMaxResult<Self::Item> where Self: Sized, Self::Item: Ord\n-    {\n-        let (mut min, mut max) = match self.next() {\n-            None => return NoElements,\n-            Some(x) => {\n-                match self.next() {\n-                    None => return OneElement(x),\n-                    Some(y) => if x <= y {(x, y)} else {(y, x)}\n-                }\n-            }\n-        };\n-\n-        loop {\n-            // `first` and `second` are the two next elements we want to look\n-            // at.  We first compare `first` and `second` (#1). The smaller one\n-            // is then compared to current minimum (#2). The larger one is\n-            // compared to current maximum (#3). This way we do 3 comparisons\n-            // for 2 elements.\n-            let first = match self.next() {\n-                None => break,\n-                Some(x) => x\n-            };\n-            let second = match self.next() {\n-                None => {\n-                    if first < min {\n-                        min = first;\n-                    } else if first >= max {\n-                        max = first;\n-                    }\n-                    break;\n-                }\n-                Some(x) => x\n-            };\n-            if first <= second {\n-                if first < min { min = first }\n-                if second >= max { max = second }\n-            } else {\n-                if second < min { min = second }\n-                if first >= max { max = first }\n-            }\n-        }\n-\n-        MinMax(min, max)\n-    }\n-\n     /// Returns the element that gives the maximum value from the\n     /// specified function.\n     ///\n@@ -1046,22 +959,6 @@ pub trait Iterator {\n         Cycle{orig: self.clone(), iter: self}\n     }\n \n-    /// Use an iterator to reverse a container in place.\n-    #[unstable(feature = \"core\",\n-               reason = \"uncertain about placement or widespread use\")]\n-    #[deprecated(since = \"1.2.0\",\n-                 reason = \"not performant enough to justify inclusion\")]\n-    fn reverse_in_place<'a, T: 'a>(&mut self) where\n-        Self: Sized + Iterator<Item=&'a mut T> + DoubleEndedIterator\n-    {\n-        loop {\n-            match (self.next(), self.next_back()) {\n-                (Some(x), Some(y)) => mem::swap(x, y),\n-                _ => break\n-            }\n-        }\n-    }\n-\n     /// Iterates over the entire iterator, summing up all the elements\n     ///\n     /// # Examples\n@@ -1229,29 +1126,6 @@ impl<'a, I: DoubleEndedIterator + ?Sized> DoubleEndedIterator for &'a mut I {\n     fn next_back(&mut self) -> Option<I::Item> { (**self).next_back() }\n }\n \n-/// An object implementing random access indexing by `usize`\n-///\n-/// A `RandomAccessIterator` should be either infinite or a\n-/// `DoubleEndedIterator`.  Calling `next()` or `next_back()` on a\n-/// `RandomAccessIterator` reduces the indexable range accordingly. That is,\n-/// `it.idx(1)` will become `it.idx(0)` after `it.next()` is called.\n-#[unstable(feature = \"iter_idx\",\n-           reason = \"not widely used, may be better decomposed into Index \\\n-                     and ExactSizeIterator\")]\n-#[deprecated(since = \"1.2.0\",\n-             reason = \"trait has not proven itself as a widely useful \\\n-                       abstraction for iterators, and more time may be needed \\\n-                       for iteration on the design\")]\n-#[allow(deprecated)]\n-pub trait RandomAccessIterator: Iterator {\n-    /// Returns the number of indexable elements. At most `std::usize::MAX`\n-    /// elements are indexable, even if the iterator represents a longer range.\n-    fn indexable(&self) -> usize;\n-\n-    /// Returns an element at an index, or `None` if the index is out of bounds\n-    fn idx(&mut self, index: usize) -> Option<Self::Item>;\n-}\n-\n /// An iterator that knows its exact length\n ///\n /// This trait is a helper for iterators like the vector iterator, so that\n@@ -1321,78 +1195,6 @@ impl<I> DoubleEndedIterator for Rev<I> where I: DoubleEndedIterator {\n     fn next_back(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next() }\n }\n \n-#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n-#[allow(deprecated)]\n-impl<I> RandomAccessIterator for Rev<I>\n-    where I: DoubleEndedIterator + RandomAccessIterator\n-{\n-    #[inline]\n-    fn indexable(&self) -> usize { self.iter.indexable() }\n-    #[inline]\n-    fn idx(&mut self, index: usize) -> Option<<I as Iterator>::Item> {\n-        let amt = self.indexable();\n-        if amt > index {\n-            self.iter.idx(amt - index - 1)\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-/// `MinMaxResult` is an enum returned by `min_max`. See `Iterator::min_max` for\n-/// more detail.\n-#[derive(Clone, PartialEq, Debug)]\n-#[unstable(feature = \"iter_min_max\",\n-           reason = \"unclear whether such a fine-grained result is widely useful\")]\n-#[deprecated(since = \"1.3.0\", reason = \"has not proven itself\")]\n-#[allow(deprecated)]\n-pub enum MinMaxResult<T> {\n-    /// Empty iterator\n-    NoElements,\n-\n-    /// Iterator with one element, so the minimum and maximum are the same\n-    OneElement(T),\n-\n-    /// More than one element in the iterator, the first element is not larger\n-    /// than the second\n-    MinMax(T, T)\n-}\n-\n-#[unstable(feature = \"iter_min_max\", reason = \"type is unstable\")]\n-#[deprecated(since = \"1.3.0\", reason = \"has not proven itself\")]\n-#[allow(deprecated)]\n-impl<T: Clone> MinMaxResult<T> {\n-    /// `into_option` creates an `Option` of type `(T,T)`. The returned `Option`\n-    /// has variant `None` if and only if the `MinMaxResult` has variant\n-    /// `NoElements`. Otherwise variant `Some(x,y)` is returned where `x <= y`.\n-    /// If `MinMaxResult` has variant `OneElement(x)`, performing this operation\n-    /// will make one clone of `x`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(iter_min_max)]\n-    ///\n-    /// use std::iter::MinMaxResult::{self, NoElements, OneElement, MinMax};\n-    ///\n-    /// let r: MinMaxResult<i32> = NoElements;\n-    /// assert_eq!(r.into_option(), None);\n-    ///\n-    /// let r = OneElement(1);\n-    /// assert_eq!(r.into_option(), Some((1, 1)));\n-    ///\n-    /// let r = MinMax(1, 2);\n-    /// assert_eq!(r.into_option(), Some((1, 2)));\n-    /// ```\n-    pub fn into_option(self) -> Option<(T,T)> {\n-        match self {\n-            NoElements => None,\n-            OneElement(x) => Some((x.clone(), x)),\n-            MinMax(x, y) => Some((x, y))\n-        }\n-    }\n-}\n-\n /// An iterator that clones the elements of an underlying iterator\n #[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n@@ -1430,22 +1232,6 @@ impl<'a, I, T: 'a> ExactSizeIterator for Cloned<I>\n     where I: ExactSizeIterator<Item=&'a T>, T: Clone\n {}\n \n-#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n-#[allow(deprecated)]\n-impl<'a, I, T: 'a> RandomAccessIterator for Cloned<I>\n-    where I: RandomAccessIterator<Item=&'a T>, T: Clone\n-{\n-    #[inline]\n-    fn indexable(&self) -> usize {\n-        self.it.indexable()\n-    }\n-\n-    #[inline]\n-    fn idx(&mut self, index: usize) -> Option<T> {\n-        self.it.idx(index).cloned()\n-    }\n-}\n-\n /// An iterator that repeats endlessly\n #[derive(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n@@ -1478,34 +1264,6 @@ impl<I> Iterator for Cycle<I> where I: Clone + Iterator {\n     }\n }\n \n-#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n-#[allow(deprecated)]\n-impl<I> RandomAccessIterator for Cycle<I> where\n-    I: Clone + RandomAccessIterator,\n-{\n-    #[inline]\n-    fn indexable(&self) -> usize {\n-        if self.orig.indexable() > 0 {\n-            usize::MAX\n-        } else {\n-            0\n-        }\n-    }\n-\n-    #[inline]\n-    fn idx(&mut self, index: usize) -> Option<<I as Iterator>::Item> {\n-        let liter = self.iter.indexable();\n-        let lorig = self.orig.indexable();\n-        if lorig == 0 {\n-            None\n-        } else if index < liter {\n-            self.iter.idx(index)\n-        } else {\n-            self.orig.idx((index - liter) % lorig)\n-        }\n-    }\n-}\n-\n /// An iterator that strings two iterators together\n #[derive(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n@@ -1593,29 +1351,6 @@ impl<A, B> DoubleEndedIterator for Chain<A, B> where\n     }\n }\n \n-#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n-#[allow(deprecated)]\n-impl<A, B> RandomAccessIterator for Chain<A, B> where\n-    A: RandomAccessIterator,\n-    B: RandomAccessIterator<Item = A::Item>,\n-{\n-    #[inline]\n-    fn indexable(&self) -> usize {\n-        let (a, b) = (self.a.indexable(), self.b.indexable());\n-        a.saturating_add(b)\n-    }\n-\n-    #[inline]\n-    fn idx(&mut self, index: usize) -> Option<A::Item> {\n-        let len = self.a.indexable();\n-        if index < len {\n-            self.a.idx(index)\n-        } else {\n-            self.b.idx(index - len)\n-        }\n-    }\n-}\n-\n /// An iterator that iterates two other iterators simultaneously\n #[derive(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n@@ -1682,27 +1417,6 @@ impl<A, B> DoubleEndedIterator for Zip<A, B> where\n     }\n }\n \n-#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n-#[allow(deprecated)]\n-impl<A, B> RandomAccessIterator for Zip<A, B> where\n-    A: RandomAccessIterator,\n-    B: RandomAccessIterator\n-{\n-    #[inline]\n-    fn indexable(&self) -> usize {\n-        cmp::min(self.a.indexable(), self.b.indexable())\n-    }\n-\n-    #[inline]\n-    fn idx(&mut self, index: usize) -> Option<(A::Item, B::Item)> {\n-        self.a.idx(index).and_then(|x| {\n-            self.b.idx(index).and_then(|y| {\n-                Some((x, y))\n-            })\n-        })\n-    }\n-}\n-\n /// An iterator that maps the values of `iter` with `f`\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1737,22 +1451,6 @@ impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for Map<I, F> where\n     }\n }\n \n-#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n-#[allow(deprecated)]\n-impl<B, I: RandomAccessIterator, F> RandomAccessIterator for Map<I, F> where\n-    F: FnMut(I::Item) -> B,\n-{\n-    #[inline]\n-    fn indexable(&self) -> usize {\n-        self.iter.indexable()\n-    }\n-\n-    #[inline]\n-    fn idx(&mut self, index: usize) -> Option<B> {\n-        self.iter.idx(index).map(|a| (self.f)(a))\n-    }\n-}\n-\n /// An iterator that filters the elements of `iter` with `predicate`\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1912,23 +1610,6 @@ impl<I> DoubleEndedIterator for Enumerate<I> where\n     }\n }\n \n-#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n-#[allow(deprecated)]\n-impl<I> RandomAccessIterator for Enumerate<I> where I: RandomAccessIterator {\n-    #[inline]\n-    fn indexable(&self) -> usize {\n-        self.iter.indexable()\n-    }\n-\n-    #[inline]\n-    fn idx(&mut self, index: usize) -> Option<(usize, <I as Iterator>::Item)> {\n-        // Can safely add, `ExactSizeIterator` (ancestor of\n-        // `RandomAccessIterator`) promises that the number of elements fits\n-        // into a `usize`.\n-        self.iter.idx(index).map(|a| (self.count + index, a))\n-    }\n-}\n-\n /// An iterator with a `peek()` that returns an optional reference to the next element.\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2163,24 +1844,6 @@ impl<I> Iterator for Skip<I> where I: Iterator {\n     }\n }\n \n-#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n-#[allow(deprecated)]\n-impl<I> RandomAccessIterator for Skip<I> where I: RandomAccessIterator{\n-    #[inline]\n-    fn indexable(&self) -> usize {\n-        self.iter.indexable().saturating_sub(self.n)\n-    }\n-\n-    #[inline]\n-    fn idx(&mut self, index: usize) -> Option<<I as Iterator>::Item> {\n-        if index >= self.indexable() {\n-            None\n-        } else {\n-            self.iter.idx(index + self.n)\n-        }\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> ExactSizeIterator for Skip<I> where I: ExactSizeIterator {}\n \n@@ -2236,24 +1899,6 @@ impl<I> Iterator for Take<I> where I: Iterator{\n     }\n }\n \n-#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n-#[allow(deprecated)]\n-impl<I> RandomAccessIterator for Take<I> where I: RandomAccessIterator{\n-    #[inline]\n-    fn indexable(&self) -> usize {\n-        cmp::min(self.iter.indexable(), self.n)\n-    }\n-\n-    #[inline]\n-    fn idx(&mut self, index: usize) -> Option<<I as Iterator>::Item> {\n-        if index >= self.n {\n-            None\n-        } else {\n-            self.iter.idx(index)\n-        }\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> ExactSizeIterator for Take<I> where I: ExactSizeIterator {}\n \n@@ -2262,16 +1907,10 @@ impl<I> ExactSizeIterator for Take<I> where I: ExactSizeIterator {}\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Clone)]\n-#[allow(deprecated)]\n pub struct Scan<I, St, F> {\n     iter: I,\n     f: F,\n-\n-    /// The current internal state to be passed to the closure next.\n-    #[unstable(feature = \"scan_state\",\n-               reason = \"public fields are otherwise rare in the stdlib\")]\n-    #[deprecated(since = \"1.3.0\", reason = \"unclear whether this is necessary\")]\n-    pub state: St,\n+    state: St,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2282,7 +1921,6 @@ impl<B, I, St, F> Iterator for Scan<I, St, F> where\n     type Item = B;\n \n     #[inline]\n-    #[allow(deprecated)]\n     fn next(&mut self) -> Option<B> {\n         self.iter.next().and_then(|a| (self.f)(&mut self.state, a))\n     }\n@@ -2440,37 +2078,9 @@ impl<I> DoubleEndedIterator for Fuse<I> where I: DoubleEndedIterator {\n     }\n }\n \n-// Allow RandomAccessIterators to be fused without affecting random-access behavior\n-#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n-#[allow(deprecated)]\n-impl<I> RandomAccessIterator for Fuse<I> where I: RandomAccessIterator {\n-    #[inline]\n-    fn indexable(&self) -> usize {\n-        self.iter.indexable()\n-    }\n-\n-    #[inline]\n-    fn idx(&mut self, index: usize) -> Option<<I as Iterator>::Item> {\n-        self.iter.idx(index)\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> ExactSizeIterator for Fuse<I> where I: ExactSizeIterator {}\n \n-impl<I> Fuse<I> {\n-    /// Resets the `Fuse` such that the next call to `.next()` or\n-    /// `.next_back()` will call the underlying iterator again even if it\n-    /// previously returned `None`.\n-    #[inline]\n-    #[unstable(feature = \"iter_reset_fuse\", reason = \"seems marginal\")]\n-    #[deprecated(since = \"1.3.0\",\n-                 reason = \"unusual for adaptors to have one-off methods\")]\n-    pub fn reset_fuse(&mut self) {\n-        self.done = false\n-    }\n-}\n-\n /// An iterator that calls a function with a reference to each\n /// element before yielding it.\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n@@ -2519,104 +2129,6 @@ impl<I: DoubleEndedIterator, F> DoubleEndedIterator for Inspect<I, F>\n     }\n }\n \n-#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n-#[allow(deprecated)]\n-impl<I: RandomAccessIterator, F> RandomAccessIterator for Inspect<I, F>\n-    where F: FnMut(&I::Item),\n-{\n-    #[inline]\n-    fn indexable(&self) -> usize {\n-        self.iter.indexable()\n-    }\n-\n-    #[inline]\n-    fn idx(&mut self, index: usize) -> Option<I::Item> {\n-        let element = self.iter.idx(index);\n-        self.do_inspect(element)\n-    }\n-}\n-\n-/// An iterator that passes mutable state to a closure and yields the result.\n-///\n-/// # Examples\n-///\n-/// An iterator that yields sequential Fibonacci numbers, and stops on overflow.\n-///\n-/// ```\n-/// #![feature(iter_unfold)]\n-/// use std::iter::Unfold;\n-///\n-/// // This iterator will yield up to the last Fibonacci number before the max\n-/// // value of `u32`. You can simply change `u32` to `u64` in this line if\n-/// // you want higher values than that.\n-/// let mut fibonacci = Unfold::new((Some(0u32), Some(1u32)),\n-///                                 |&mut (ref mut x2, ref mut x1)| {\n-///     // Attempt to get the next Fibonacci number\n-///     // `x1` will be `None` if previously overflowed.\n-///     let next = match (*x2, *x1) {\n-///         (Some(x2), Some(x1)) => x2.checked_add(x1),\n-///         _ => None,\n-///     };\n-///\n-///     // Shift left: ret <- x2 <- x1 <- next\n-///     let ret = *x2;\n-///     *x2 = *x1;\n-///     *x1 = next;\n-///\n-///     ret\n-/// });\n-///\n-/// for i in fibonacci {\n-///     println!(\"{}\", i);\n-/// }\n-/// ```\n-#[unstable(feature = \"iter_unfold\")]\n-#[derive(Clone)]\n-#[deprecated(since = \"1.2.0\",\n-             reason = \"has not gained enough traction to retain its position \\\n-                       in the standard library\")]\n-#[allow(deprecated)]\n-pub struct Unfold<St, F> {\n-    f: F,\n-    /// Internal state that will be passed to the closure on the next iteration\n-    #[unstable(feature = \"iter_unfold\")]\n-    pub state: St,\n-}\n-\n-#[unstable(feature = \"iter_unfold\")]\n-#[deprecated(since = \"1.2.0\",\n-             reason = \"has not gained enough traction to retain its position \\\n-                       in the standard library\")]\n-#[allow(deprecated)]\n-impl<A, St, F> Unfold<St, F> where F: FnMut(&mut St) -> Option<A> {\n-    /// Creates a new iterator with the specified closure as the \"iterator\n-    /// function\" and an initial state to eventually pass to the closure\n-    #[inline]\n-    pub fn new(initial_state: St, f: F) -> Unfold<St, F> {\n-        Unfold {\n-            f: f,\n-            state: initial_state\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n-impl<A, St, F> Iterator for Unfold<St, F> where F: FnMut(&mut St) -> Option<A> {\n-    type Item = A;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<A> {\n-        (self.f)(&mut self.state)\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        // no possible known bounds at this point\n-        (0, None)\n-    }\n-}\n-\n /// Objects that can be stepped over in both directions.\n ///\n /// The `steps_between` function provides a way to efficiently compare\n@@ -2759,7 +2271,6 @@ impl<A: Step> RangeFrom<A> {\n     }\n }\n \n-#[allow(deprecated)]\n impl<A: Step> ops::Range<A> {\n     /// Creates an iterator with the same range, but stepping by the\n     /// given amount at each iteration.\n@@ -2892,7 +2403,6 @@ impl<A> DoubleEndedIterator for RangeInclusive<A> where\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n impl<A: Step + Zero + Clone> Iterator for StepBy<A, ops::Range<A>> {\n     type Item = A;\n \n@@ -2937,7 +2447,6 @@ macro_rules! range_exact_iter_impl {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n impl<A: Step + One> Iterator for ops::Range<A> where\n     for<'a> &'a A: Add<&'a A, Output = A>\n {\n@@ -2968,7 +2477,6 @@ impl<A: Step + One> Iterator for ops::Range<A> where\n range_exact_iter_impl!(usize u8 u16 u32 isize i8 i16 i32);\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n impl<A: Step + One + Clone> DoubleEndedIterator for ops::Range<A> where\n     for<'a> &'a A: Add<&'a A, Output = A>,\n     for<'a> &'a A: Sub<&'a A, Output = A>\n@@ -2985,7 +2493,6 @@ impl<A: Step + One + Clone> DoubleEndedIterator for ops::Range<A> where\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n impl<A: Step + One> Iterator for ops::RangeFrom<A> where\n     for<'a> &'a A: Add<&'a A, Output = A>\n {\n@@ -3022,56 +2529,6 @@ impl<A: Clone> DoubleEndedIterator for Repeat<A> {\n     fn next_back(&mut self) -> Option<A> { Some(self.element.clone()) }\n }\n \n-#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n-#[allow(deprecated)]\n-impl<A: Clone> RandomAccessIterator for Repeat<A> {\n-    #[inline]\n-    fn indexable(&self) -> usize { usize::MAX }\n-    #[inline]\n-    fn idx(&mut self, _: usize) -> Option<A> { Some(self.element.clone()) }\n-}\n-\n-type IterateState<T, F> = (F, Option<T>, bool);\n-\n-/// An iterator that repeatedly applies a given function, starting\n-/// from a given seed value.\n-#[unstable(feature = \"iter_iterate\")]\n-#[deprecated(since = \"1.2.0\",\n-             reason = \"has not gained enough traction to retain its position \\\n-                       in the standard library\")]\n-#[allow(deprecated)]\n-pub type Iterate<T, F> = Unfold<IterateState<T, F>, fn(&mut IterateState<T, F>) -> Option<T>>;\n-\n-/// Creates a new iterator that produces an infinite sequence of\n-/// repeated applications of the given function `f`.\n-#[unstable(feature = \"iter_iterate\")]\n-#[deprecated(since = \"1.2.0\",\n-             reason = \"has not gained enough traction to retain its position \\\n-                       in the standard library\")]\n-#[allow(deprecated)]\n-pub fn iterate<T, F>(seed: T, f: F) -> Iterate<T, F> where\n-    T: Clone,\n-    F: FnMut(T) -> T,\n-{\n-    fn next<T, F>(st: &mut IterateState<T, F>) -> Option<T> where\n-        T: Clone,\n-        F: FnMut(T) -> T,\n-    {\n-        let &mut (ref mut f, ref mut val, ref mut first) = st;\n-        if *first {\n-            *first = false;\n-        } else if let Some(x) = val.take() {\n-            *val = Some((*f)(x))\n-        }\n-        val.clone()\n-    }\n-\n-    // coerce to a fn pointer\n-    let next: fn(&mut IterateState<T,F>) -> Option<T> = next;\n-\n-    Unfold::new((f, Some(seed), true), next)\n-}\n-\n /// Creates a new iterator that endlessly repeats the element `elt`.\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "e0c6bb527816e95e26e840a4bfabbb95b33d984c", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -218,18 +218,6 @@ unsafe impl Sync for .. { }\n impl<T> !Sync for *const T { }\n impl<T> !Sync for *mut T { }\n \n-/// A type which is considered \"not POD\", meaning that it is not\n-/// implicitly copyable. This is typically embedded in other types to\n-/// ensure that they are never copied, even if they lack a destructor.\n-#[unstable(feature = \"core\",\n-           reason = \"likely to change with new variance strategy\")]\n-#[deprecated(since = \"1.2.0\",\n-             reason = \"structs are by default not copyable\")]\n-#[lang = \"no_copy_bound\"]\n-#[allow(deprecated)]\n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]\n-pub struct NoCopy;\n-\n macro_rules! impls{\n     ($t: ident) => (\n         impl<T:?Sized> Hash for $t<T> {\n@@ -419,7 +407,6 @@ mod impls {\n #[rustc_reflect_like]\n #[unstable(feature = \"reflect_marker\",\n            reason = \"requires RFC and more experience\")]\n-#[allow(deprecated)]\n #[rustc_on_unimplemented = \"`{Self}` does not implement `Any`; \\\n                             ensure all type parameters are bounded by `Any`\"]\n pub trait Reflect {}"}, {"sha": "c7652390d9ea07c70d61b829c707be6f75d0ab67", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -558,33 +558,3 @@ pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n     #![allow(trivial_casts)]\n     ptr::read(src as *const T as *const U)\n }\n-\n-/// Transforms lifetime of the second pointer to match the first.\n-#[inline]\n-#[unstable(feature = \"copy_lifetime\",\n-           reason = \"this function may be removed in the future due to its \\\n-                     questionable utility\")]\n-#[deprecated(since = \"1.2.0\",\n-             reason = \"unclear that this function buys more safety and \\\n-                       lifetimes are generally not handled as such in unsafe \\\n-                       code today\")]\n-pub unsafe fn copy_lifetime<'a, S: ?Sized, T: ?Sized + 'a>(_ptr: &'a S,\n-                                                        ptr: &T) -> &'a T {\n-    transmute(ptr)\n-}\n-\n-/// Transforms lifetime of the second mutable pointer to match the first.\n-#[inline]\n-#[unstable(feature = \"copy_lifetime\",\n-           reason = \"this function may be removed in the future due to its \\\n-                     questionable utility\")]\n-#[deprecated(since = \"1.2.0\",\n-             reason = \"unclear that this function buys more safety and \\\n-                       lifetimes are generally not handled as such in unsafe \\\n-                       code today\")]\n-pub unsafe fn copy_mut_lifetime<'a, S: ?Sized, T: ?Sized + 'a>(_ptr: &'a S,\n-                                                               ptr: &mut T)\n-                                                              -> &'a mut T\n-{\n-    transmute(ptr)\n-}"}, {"sha": "6ce037f17aed0e227a574afedc6f7868369289b5", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -80,12 +80,6 @@ pub mod consts {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const PI: f32 = 3.14159265358979323846264338327950288_f32;\n \n-    /// pi * 2.0\n-    #[unstable(feature = \"float_consts\",\n-               reason = \"unclear naming convention/usefulness\")]\n-    #[deprecated(since = \"1.2.0\", reason = \"unclear on usefulness\")]\n-    pub const PI_2: f32 = 6.28318530717958647692528676655900576_f32;\n-\n     /// pi/2.0\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const FRAC_PI_2: f32 = 1.57079632679489661923132169163975144_f32;"}, {"sha": "b9dbc04679983e3f5275cab6bf5bde9c696af9a9", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -80,12 +80,6 @@ pub mod consts {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const PI: f64 = 3.14159265358979323846264338327950288_f64;\n \n-    /// pi * 2.0\n-    #[unstable(feature = \"float_consts\",\n-               reason = \"unclear naming convention/usefulness\")]\n-    #[deprecated(since = \"1.2.0\", reason = \"unclear on usefulness\")]\n-    pub const PI_2: f64 = 6.28318530717958647692528676655900576_f64;\n-\n     /// pi/2.0\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const FRAC_PI_2: f64 = 1.57079632679489661923132169163975144_f64;"}, {"sha": "ffa5c56a28226edefce1891e052066842bbb13db", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -137,7 +137,6 @@ macro_rules! int_impl {\n         /// assert_eq!(u32::from_str_radix(\"A\", 16), Ok(10));\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[allow(deprecated)]\n         pub fn from_str_radix(src: &str, radix: u32) -> Result<Self, ParseIntError> {\n             from_str_radix(src, radix)\n         }\n@@ -692,7 +691,6 @@ macro_rules! uint_impl {\n         /// `Err(ParseIntError)` if the string did not represent a valid number.\n         /// Otherwise, `Ok(n)` where `n` is the integer represented by `src`.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[allow(deprecated)]\n         pub fn from_str_radix(src: &str, radix: u32) -> Result<Self, ParseIntError> {\n             from_str_radix(src, radix)\n         }\n@@ -1396,7 +1394,6 @@ macro_rules! from_str_float_impl {\n             /// number.  Otherwise, `Ok(n)` where `n` is the floating-point\n             /// number represented by `src`.\n             #[inline]\n-            #[allow(deprecated)]\n             fn from_str(src: &str) -> Result<Self, ParseFloatError> {\n                 dec2flt::$func(src)\n             }\n@@ -1409,7 +1406,6 @@ from_str_float_impl!(f64, to_f64);\n macro_rules! from_str_radix_int_impl {\n     ($($t:ty)*) => {$(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[allow(deprecated)]\n         impl FromStr for $t {\n             type Err = ParseIntError;\n             fn from_str(src: &str) -> Result<Self, ParseIntError> {"}, {"sha": "8e6ecf3c71e11e96dd4a1eb0cbc4d5454f60578b", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n #![allow(missing_docs)]\n-#![allow(deprecated)]\n #![unstable(feature = \"wrapping\", reason = \"may be removed or relocated\")]\n \n use super::Wrapping;"}, {"sha": "ba1fe6f48cdb5f5de590d8a344699b6c3af33f0f", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -123,27 +123,6 @@ pub unsafe fn read<T>(src: *const T) -> T {\n     tmp\n }\n \n-/// Reads the value from `src` and nulls it out without dropping it.\n-///\n-/// # Safety\n-///\n-/// This is unsafe for the same reasons that `read` is unsafe.\n-#[inline(always)]\n-#[unstable(feature = \"read_and_zero\",\n-           reason = \"may play a larger role in std::ptr future extensions\")]\n-#[deprecated(since = \"1.3.0\",\n-             reason = \"a \\\"zero value\\\" will soon not actually exist for all \\\n-                       types once dynamic drop has been implemented\")]\n-pub unsafe fn read_and_zero<T>(dest: *mut T) -> T {\n-    // Copy the data out from `dest`:\n-    let tmp = read(&*dest);\n-\n-    // Now zero out `dest`:\n-    write_bytes(dest, 0, 1);\n-\n-    tmp\n-}\n-\n /// Variant of read_and_zero that writes the specific drop-flag byte\n /// (which may be more appropriate than zero).\n #[inline(always)]"}, {"sha": "7ddb0883bf296b80667567ce7c608a2446fd1f9f", "filename": "src/libcore/result.rs", "status": "modified", "additions": 1, "deletions": 33, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -234,7 +234,7 @@ use self::Result::{Ok, Err};\n use clone::Clone;\n use fmt;\n use iter::{Iterator, DoubleEndedIterator, FromIterator, ExactSizeIterator, IntoIterator};\n-use ops::{FnMut, FnOnce};\n+use ops::FnOnce;\n use option::Option::{self, None, Some};\n use slice;\n \n@@ -957,35 +957,3 @@ impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n         }\n     }\n }\n-\n-/////////////////////////////////////////////////////////////////////////////\n-// FromIterator\n-/////////////////////////////////////////////////////////////////////////////\n-\n-/// Performs a fold operation over the result values from an iterator.\n-///\n-/// If an `Err` is encountered, it is immediately returned.\n-/// Otherwise, the folded value is returned.\n-#[inline]\n-#[unstable(feature = \"result_fold\",\n-           reason = \"unclear if this function should exist\")]\n-#[deprecated(since = \"1.2.0\",\n-             reason = \"has not seen enough usage to justify its position in \\\n-                       the standard library\")]\n-pub fn fold<T,\n-            V,\n-            E,\n-            F: FnMut(V, T) -> V,\n-            Iter: Iterator<Item=Result<T, E>>>(\n-            iterator: Iter,\n-            mut init: V,\n-            mut f: F)\n-            -> Result<V, E> {\n-    for t in iterator {\n-        match t {\n-            Ok(v) => init = f(init, v),\n-            Err(u) => return Err(u)\n-        }\n-    }\n-    Ok(init)\n-}"}, {"sha": "4019e63a9f19d83f6646a50fdabde8d40885ce87", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 0, "deletions": 140, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -827,27 +827,6 @@ impl<'a, T> Clone for Iter<'a, T> {\n     fn clone(&self) -> Iter<'a, T> { Iter { ptr: self.ptr, end: self.end, _marker: self._marker } }\n }\n \n-#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n-#[allow(deprecated)]\n-impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n-    #[inline]\n-    fn indexable(&self) -> usize {\n-        let (exact, _) = self.size_hint();\n-        exact\n-    }\n-\n-    #[inline]\n-    fn idx(&mut self, index: usize) -> Option<&'a T> {\n-        unsafe {\n-            if index < self.indexable() {\n-                Some(slice_ref!(self.ptr.offset(index as isize)))\n-            } else {\n-                None\n-            }\n-        }\n-    }\n-}\n-\n /// Mutable slice iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T: 'a> {\n@@ -1228,24 +1207,6 @@ impl<'a, T> DoubleEndedIterator for Windows<'a, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Windows<'a, T> {}\n \n-#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n-#[allow(deprecated)]\n-impl<'a, T> RandomAccessIterator for Windows<'a, T> {\n-    #[inline]\n-    fn indexable(&self) -> usize {\n-        self.size_hint().0\n-    }\n-\n-    #[inline]\n-    fn idx(&mut self, index: usize) -> Option<&'a [T]> {\n-        if index + self.size > self.v.len() {\n-            None\n-        } else {\n-            Some(&self.v[index .. index+self.size])\n-        }\n-    }\n-}\n-\n /// An iterator over a slice in (non-overlapping) chunks (`size` elements at a\n /// time).\n ///\n@@ -1348,28 +1309,6 @@ impl<'a, T> DoubleEndedIterator for Chunks<'a, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Chunks<'a, T> {}\n \n-#[unstable(feature = \"iter_idx\", reason = \"trait is experimental\")]\n-#[allow(deprecated)]\n-impl<'a, T> RandomAccessIterator for Chunks<'a, T> {\n-    #[inline]\n-    fn indexable(&self) -> usize {\n-        self.v.len()/self.size + if self.v.len() % self.size != 0 { 1 } else { 0 }\n-    }\n-\n-    #[inline]\n-    fn idx(&mut self, index: usize) -> Option<&'a [T]> {\n-        if index < self.indexable() {\n-            let lo = index * self.size;\n-            let mut hi = lo + self.size;\n-            if hi < lo || hi > self.v.len() { hi = self.v.len(); }\n-\n-            Some(&self.v[lo..hi])\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n /// An iterator over a slice in (non-overlapping) mutable chunks (`size`\n /// elements at a time). When the slice len is not evenly divided by the chunk\n /// size, the last slice of the iteration will be the remainder.\n@@ -1534,37 +1473,6 @@ pub unsafe fn from_raw_parts_mut<'a, T>(p: *mut T, len: usize) -> &'a mut [T] {\n     mem::transmute(RawSlice { data: p, len: len })\n }\n \n-#[inline]\n-fn check_types<T,U>() {\n-    assert!(mem::size_of::<T>() == mem::size_of::<U>());\n-    assert!(mem::align_of::<T>() % mem::align_of::<U>() == 0)\n-}\n-\n-/// Reinterprets a slice of one type as a slice of another type.\n-///\n-/// Both types have to have the same size and the type that is converted to\n-/// must have equal or less restrictive alignment.\n-///\n-/// # Panics\n-///\n-/// This functions panics if the above preconditions about the types are not\n-/// met.\n-#[inline]\n-unsafe fn transmute<T,U>(slice: &[T]) -> &[U] {\n-    check_types::<T,U>();\n-    from_raw_parts(slice.as_ptr() as *const U, slice.len())\n-}\n-\n-/// Reinterprets a mutable slice of one type as a mutable slice of another\n-/// type.\n-///\n-/// Equivalent of `slice::transmute` for mutable slices.\n-#[inline]\n-unsafe fn transmute_mut<T,U>(slice: &mut [T]) -> &mut [U] {\n-    check_types::<T,U>();\n-    from_raw_parts_mut(slice.as_mut_ptr() as *mut U, slice.len())\n-}\n-\n //\n // Submodules\n //\n@@ -1674,51 +1582,3 @@ impl<T: PartialOrd> PartialOrd for [T] {\n         order::gt(self.iter(), other.iter())\n     }\n }\n-\n-/// Extension methods for slices containing integers.\n-#[unstable(feature = \"int_slice\")]\n-#[deprecated(since = \"1.2.0\",\n-             reason = \"has not seen much usage and may want to live in the \\\n-                       standard library now that most slice methods are \\\n-                       on an inherent implementation block\")]\n-pub trait IntSliceExt<U, S> {\n-    /// Converts the slice to an immutable slice of unsigned integers with the same width.\n-    fn as_unsigned<'a>(&'a self) -> &'a [U];\n-    /// Converts the slice to an immutable slice of signed integers with the same width.\n-    fn as_signed<'a>(&'a self) -> &'a [S];\n-\n-    /// Converts the slice to a mutable slice of unsigned integers with the same width.\n-    fn as_unsigned_mut<'a>(&'a mut self) -> &'a mut [U];\n-    /// Converts the slice to a mutable slice of signed integers with the same width.\n-    fn as_signed_mut<'a>(&'a mut self) -> &'a mut [S];\n-}\n-\n-macro_rules! impl_int_slice {\n-    ($u:ty, $s:ty, $t:ty) => {\n-        #[unstable(feature = \"int_slice\")]\n-        #[allow(deprecated)]\n-        impl IntSliceExt<$u, $s> for [$t] {\n-            #[inline]\n-            fn as_unsigned(&self) -> &[$u] { unsafe { transmute(self) } }\n-            #[inline]\n-            fn as_signed(&self) -> &[$s] { unsafe { transmute(self) } }\n-            #[inline]\n-            fn as_unsigned_mut(&mut self) -> &mut [$u] { unsafe { transmute_mut(self) } }\n-            #[inline]\n-            fn as_signed_mut(&mut self) -> &mut [$s] { unsafe { transmute_mut(self) } }\n-        }\n-    }\n-}\n-\n-macro_rules! impl_int_slices {\n-    ($u:ty, $s:ty) => {\n-        impl_int_slice! { $u, $s, $u }\n-        impl_int_slice! { $u, $s, $s }\n-    }\n-}\n-\n-impl_int_slices! { u8,   i8  }\n-impl_int_slices! { u16,  i16 }\n-impl_int_slices! { u32,  i32 }\n-impl_int_slices! { u64,  i64 }\n-impl_int_slices! { usize, isize }"}, {"sha": "e077a0d8fe7fc9a49798eb2ff021d3466346d4fb", "filename": "src/libcoretest/char.rs", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -211,31 +211,3 @@ fn test_len_utf16() {\n     assert!('\\u{a66e}'.len_utf16() == 1);\n     assert!('\\u{1f4a9}'.len_utf16() == 2);\n }\n-\n-#[allow(deprecated)]\n-#[test]\n-fn test_width() {\n-    assert_eq!('\\x00'.width(false),Some(0));\n-    assert_eq!('\\x00'.width(true),Some(0));\n-\n-    assert_eq!('\\x0A'.width(false),None);\n-    assert_eq!('\\x0A'.width(true),None);\n-\n-    assert_eq!('w'.width(false),Some(1));\n-    assert_eq!('w'.width(true),Some(1));\n-\n-    assert_eq!('\uff48'.width(false),Some(2));\n-    assert_eq!('\uff48'.width(true),Some(2));\n-\n-    assert_eq!('\\u{AD}'.width(false),Some(1));\n-    assert_eq!('\\u{AD}'.width(true),Some(1));\n-\n-    assert_eq!('\\u{1160}'.width(false),Some(0));\n-    assert_eq!('\\u{1160}'.width(true),Some(0));\n-\n-    assert_eq!('\\u{a1}'.width(false),Some(1));\n-    assert_eq!('\\u{a1}'.width(true),Some(2));\n-\n-    assert_eq!('\\u{300}'.width(false),Some(0));\n-    assert_eq!('\\u{300}'.width(true),Some(0));\n-}"}, {"sha": "051356cad1640ed001b05cbcf4bc372cb7327ad7", "filename": "src/libcoretest/cmp.rs", "status": "modified", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcoretest%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcoretest%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fcmp.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::cmp::{partial_min, partial_max};\n use core::cmp::Ordering::{Less, Greater, Equal};\n \n #[test]\n@@ -42,72 +41,6 @@ fn test_ordering_order() {\n     assert_eq!(Greater.cmp(&Less), Greater);\n }\n \n-#[test]\n-fn test_partial_min() {\n-    use core::f64::NAN;\n-    let data_integer = [\n-        // a, b, result\n-        (0, 0, Some(0)),\n-        (1, 0, Some(0)),\n-        (0, 1, Some(0)),\n-        (-1, 0, Some(-1)),\n-        (0, -1, Some(-1))\n-    ];\n-\n-    let data_float = [\n-        // a, b, result\n-        (0.0f64, 0.0f64, Some(0.0f64)),\n-        (1.0f64, 0.0f64, Some(0.0f64)),\n-        (0.0f64, 1.0f64, Some(0.0f64)),\n-        (-1.0f64, 0.0f64, Some(-1.0f64)),\n-        (0.0f64, -1.0f64, Some(-1.0f64)),\n-        (NAN, NAN, None),\n-        (NAN, 1.0f64, None),\n-        (1.0f64, NAN, None)\n-    ];\n-\n-    for &(a, b, result) in &data_integer {\n-        assert!(partial_min(a, b) == result);\n-    }\n-\n-    for &(a, b, result) in &data_float {\n-        assert!(partial_min(a, b) == result);\n-    }\n-}\n-\n-#[test]\n-fn test_partial_max() {\n-    use core::f64::NAN;\n-    let data_integer = [\n-        // a, b, result\n-        (0, 0, Some(0)),\n-        (1, 0, Some(1)),\n-        (0, 1, Some(1)),\n-        (-1, 0, Some(0)),\n-        (0, -1, Some(0))\n-    ];\n-\n-    let data_float = [\n-        // a, b, result\n-        (0.0f64, 0.0f64, Some(0.0f64)),\n-        (1.0f64, 0.0f64, Some(1.0f64)),\n-        (0.0f64, 1.0f64, Some(1.0f64)),\n-        (-1.0f64, 0.0f64, Some(0.0f64)),\n-        (0.0f64, -1.0f64, Some(0.0f64)),\n-        (NAN, NAN, None),\n-        (NAN, 1.0f64, None),\n-        (1.0f64, NAN, None)\n-    ];\n-\n-    for &(a, b, result) in &data_integer {\n-        assert!(partial_max(a, b) == result);\n-    }\n-\n-    for &(a, b, result) in &data_float {\n-        assert!(partial_max(a, b) == result);\n-    }\n-}\n-\n #[test]\n fn test_user_defined_eq() {\n     // Our type."}, {"sha": "4ea42644ecdfdd1f605f2aa1834167a5ad377a9f", "filename": "src/libcoretest/hash/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcoretest%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcoretest%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fhash%2Fmod.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -36,7 +36,9 @@ impl Hasher for MyHasher {\n #[test]\n fn test_writer_hasher() {\n     fn hash<T: Hash>(t: &T) -> u64 {\n-        ::std::hash::hash::<_, MyHasher>(t)\n+        let mut s = MyHasher { hash: 0 };\n+        t.hash(&mut s);\n+        s.finish()\n     }\n \n     assert_eq!(hash(&()), 0);\n@@ -102,7 +104,9 @@ impl Hash for Custom {\n #[test]\n fn test_custom_state() {\n     fn hash<T: Hash>(t: &T) -> u64 {\n-        ::std::hash::hash::<_, CustomHasher>(t)\n+        let mut c = CustomHasher { output: 0 };\n+        t.hash(&mut c);\n+        c.finish()\n     }\n \n     assert_eq!(hash(&Custom { hash: 5 }), 5);"}, {"sha": "ea65c118e5e98a8a5a327150a3f989a0c0d9bead", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 0, "deletions": 186, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -10,10 +10,8 @@\n \n use core::iter::*;\n use core::iter::order::*;\n-use core::iter::MinMaxResult::*;\n use core::{i8, i16, isize};\n use core::usize;\n-use core::cmp;\n \n use test::Bencher;\n \n@@ -451,27 +449,6 @@ fn test_inspect() {\n     assert_eq!(&xs[..], &ys[..]);\n }\n \n-#[test]\n-fn test_unfoldr() {\n-    fn count(st: &mut usize) -> Option<usize> {\n-        if *st < 10 {\n-            let ret = Some(*st);\n-            *st += 1;\n-            ret\n-        } else {\n-            None\n-        }\n-    }\n-\n-    let it = Unfold::new(0, count);\n-    let mut i = 0;\n-    for counted in it {\n-        assert_eq!(counted, i);\n-        i += 1;\n-    }\n-    assert_eq!(i, 10);\n-}\n-\n #[test]\n fn test_cycle() {\n     let cycle_len = 3;\n@@ -781,28 +758,6 @@ fn test_rposition_panic() {\n }\n \n \n-#[cfg(test)]\n-fn check_randacc_iter<A, T>(a: T, len: usize) where\n-    A: PartialEq,\n-    T: Clone + RandomAccessIterator + Iterator<Item=A>,\n-{\n-    let mut b = a.clone();\n-    assert_eq!(len, b.indexable());\n-    let mut n = 0;\n-    for (i, elt) in a.enumerate() {\n-        assert!(Some(elt) == b.idx(i));\n-        n += 1;\n-    }\n-    assert_eq!(n, len);\n-    assert!(None == b.idx(n));\n-    // call recursively to check after picking off an element\n-    if len > 0 {\n-        b.next();\n-        check_randacc_iter(b, len-1);\n-    }\n-}\n-\n-\n #[test]\n fn test_double_ended_flat_map() {\n     let u = [0,1];\n@@ -820,101 +775,6 @@ fn test_double_ended_flat_map() {\n     assert_eq!(it.next_back(), None);\n }\n \n-#[test]\n-fn test_random_access_chain() {\n-    let xs = [1, 2, 3, 4, 5];\n-    let ys = [7, 9, 11];\n-    let mut it = xs.iter().chain(&ys);\n-    assert_eq!(it.idx(0).unwrap(), &1);\n-    assert_eq!(it.idx(5).unwrap(), &7);\n-    assert_eq!(it.idx(7).unwrap(), &11);\n-    assert!(it.idx(8).is_none());\n-\n-    it.next();\n-    it.next();\n-    it.next_back();\n-\n-    assert_eq!(it.idx(0).unwrap(), &3);\n-    assert_eq!(it.idx(4).unwrap(), &9);\n-    assert!(it.idx(6).is_none());\n-\n-    check_randacc_iter(it, xs.len() + ys.len() - 3);\n-}\n-\n-#[test]\n-fn test_random_access_enumerate() {\n-    let xs = [1, 2, 3, 4, 5];\n-    check_randacc_iter(xs.iter().enumerate(), xs.len());\n-}\n-\n-#[test]\n-fn test_random_access_rev() {\n-    let xs = [1, 2, 3, 4, 5];\n-    check_randacc_iter(xs.iter().rev(), xs.len());\n-    let mut it = xs.iter().rev();\n-    it.next();\n-    it.next_back();\n-    it.next();\n-    check_randacc_iter(it, xs.len() - 3);\n-}\n-\n-#[test]\n-fn test_random_access_zip() {\n-    let xs = [1, 2, 3, 4, 5];\n-    let ys = [7, 9, 11];\n-    check_randacc_iter(xs.iter().zip(&ys), cmp::min(xs.len(), ys.len()));\n-}\n-\n-#[test]\n-fn test_random_access_take() {\n-    let xs = [1, 2, 3, 4, 5];\n-    let empty: &[isize] = &[];\n-    check_randacc_iter(xs.iter().take(3), 3);\n-    check_randacc_iter(xs.iter().take(20), xs.len());\n-    check_randacc_iter(xs.iter().take(0), 0);\n-    check_randacc_iter(empty.iter().take(2), 0);\n-}\n-\n-#[test]\n-fn test_random_access_skip() {\n-    let xs = [1, 2, 3, 4, 5];\n-    let empty: &[isize] = &[];\n-    check_randacc_iter(xs.iter().skip(2), xs.len() - 2);\n-    check_randacc_iter(empty.iter().skip(2), 0);\n-}\n-\n-#[test]\n-fn test_random_access_inspect() {\n-    let xs = [1, 2, 3, 4, 5];\n-\n-    // test .map and .inspect that don't implement Clone\n-    let mut it = xs.iter().inspect(|_| {});\n-    assert_eq!(xs.len(), it.indexable());\n-    for (i, elt) in xs.iter().enumerate() {\n-        assert_eq!(Some(elt), it.idx(i));\n-    }\n-\n-}\n-\n-#[test]\n-fn test_random_access_map() {\n-    let xs = [1, 2, 3, 4, 5];\n-\n-    let mut it = xs.iter().cloned();\n-    assert_eq!(xs.len(), it.indexable());\n-    for (i, elt) in xs.iter().enumerate() {\n-        assert_eq!(Some(*elt), it.idx(i));\n-    }\n-}\n-\n-#[test]\n-fn test_random_access_cycle() {\n-    let xs = [1, 2, 3, 4, 5];\n-    let empty: &[isize] = &[];\n-    check_randacc_iter(xs.iter().cycle().take(27), 27);\n-    check_randacc_iter(empty.iter().cycle(), 0);\n-}\n-\n #[test]\n fn test_double_ended_range() {\n     assert_eq!((11..14).rev().collect::<Vec<_>>(), [13, 12, 11]);\n@@ -984,13 +844,6 @@ fn test_range_step() {\n     assert_eq!((isize::MIN..isize::MAX).step_by(1).size_hint(), (usize::MAX, Some(usize::MAX)));\n }\n \n-#[test]\n-fn test_reverse() {\n-    let mut ys = [1, 2, 3, 4, 5];\n-    ys.iter_mut().reverse_in_place();\n-    assert!(ys == [5, 4, 3, 2, 1]);\n-}\n-\n #[test]\n fn test_peekable_is_empty() {\n     let a = [1];\n@@ -1000,45 +853,6 @@ fn test_peekable_is_empty() {\n     assert!( it.is_empty() );\n }\n \n-#[test]\n-fn test_min_max() {\n-    let v: [isize; 0] = [];\n-    assert_eq!(v.iter().min_max(), NoElements);\n-\n-    let v = [1];\n-    assert!(v.iter().min_max() == OneElement(&1));\n-\n-    let v = [1, 2, 3, 4, 5];\n-    assert!(v.iter().min_max() == MinMax(&1, &5));\n-\n-    let v = [1, 2, 3, 4, 5, 6];\n-    assert!(v.iter().min_max() == MinMax(&1, &6));\n-\n-    let v = [1, 1, 1, 1];\n-    assert!(v.iter().min_max() == MinMax(&1, &1));\n-}\n-\n-#[test]\n-fn test_min_max_result() {\n-    let r: MinMaxResult<isize> = NoElements;\n-    assert_eq!(r.into_option(), None);\n-\n-    let r = OneElement(1);\n-    assert_eq!(r.into_option(), Some((1,1)));\n-\n-    let r = MinMax(1,2);\n-    assert_eq!(r.into_option(), Some((1,2)));\n-}\n-\n-#[test]\n-fn test_iterate() {\n-    let mut it = iterate(1, |x| x * 2);\n-    assert_eq!(it.next(), Some(1));\n-    assert_eq!(it.next(), Some(2));\n-    assert_eq!(it.next(), Some(4));\n-    assert_eq!(it.next(), Some(8));\n-}\n-\n #[test]\n fn test_repeat() {\n     let mut it = repeat(42);"}, {"sha": "6313e42e0edc5c7806d218b38ec2a5de9470a2a7", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -12,7 +12,6 @@\n #![feature(borrow_state)]\n #![feature(box_syntax)]\n #![feature(cell_extras)]\n-#![feature(cmp_partial)]\n #![feature(const_fn)]\n #![feature(core)]\n #![feature(core_float)]\n@@ -21,18 +20,10 @@\n #![feature(flt2dec)]\n #![feature(dec2flt)]\n #![feature(fmt_radix)]\n-#![feature(hash_default)]\n-#![feature(hasher_write)]\n #![feature(iter_arith)]\n #![feature(iter_arith)]\n #![feature(iter_cmp)]\n-#![feature(iter_empty)]\n-#![feature(iter_idx)]\n-#![feature(iter_iterate)]\n-#![feature(iter_min_max)]\n-#![feature(iter_once)]\n #![feature(iter_order)]\n-#![feature(iter_unfold)]\n #![feature(libc)]\n #![feature(nonzero)]\n #![feature(num_bits_bytes)]"}, {"sha": "d0f6c3be8cad40abe078a60d18b5537263017bf2", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -539,16 +539,6 @@ pub fn opt(short_name: &str,\n     }\n }\n \n-impl Fail {\n-    /// Convert a `Fail` enum into an error string.\n-    #[unstable(feature = \"rustc_private\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `fmt::Display` (`{}` format specifier)\")]\n-    pub fn to_err_msg(self) -> String {\n-        self.to_string()\n-    }\n-}\n-\n impl fmt::Display for Fail {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {"}, {"sha": "1916a4949900456ee0de3eca99d61cf023ce1d7b", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -60,7 +60,6 @@\n #![feature(vec_push_all)]\n #![feature(wrapping)]\n #![feature(cell_extras)]\n-#![feature(page_size)]\n #![cfg_attr(test, feature(test))]\n \n #![allow(trivial_casts)]"}, {"sha": "e0cb47d6c952378b8a63847d272b48ee482aaf16", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -99,7 +99,6 @@ impl<'a> PluginLoader<'a> {\n     }\n \n     // Dynamically link a registrar function into the compiler process.\n-    #[allow(deprecated)] // until #23197\n     fn dylink_registrar(&mut self,\n                         span: Span,\n                         path: PathBuf,"}, {"sha": "beb95697201d6bbc9a31379f96215052a423693c", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 15, "deletions": 27, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -75,24 +75,28 @@ pub fn time<T, U, F>(do_it: bool, what: &str, u: U, f: F) -> T where\n     rv\n }\n \n+// Like std::macros::try!, but for Option<>.\n+macro_rules! option_try(\n+    ($e:expr) => (match $e { Some(e) => e, None => return None })\n+);\n+\n // Memory reporting\n #[cfg(unix)]\n fn get_resident() -> Option<usize> {\n-    get_proc_self_statm_field(1)\n-}\n+    use std::fs::File;\n+    use std::io::Read;\n \n-#[cfg(windows)]\n-fn get_resident() -> Option<usize> {\n-    get_working_set_size()\n+    let field = 1;\n+    let mut f = option_try!(File::open(\"/proc/self/statm\").ok());\n+    let mut contents = String::new();\n+    option_try!(f.read_to_string(&mut contents).ok());\n+    let s = option_try!(contents.split_whitespace().nth(field));\n+    let npages = option_try!(s.parse::<usize>().ok());\n+    Some(npages * 4096)\n }\n \n-// Like std::macros::try!, but for Option<>.\n-macro_rules! option_try(\n-    ($e:expr) => (match $e { Some(e) => e, None => return None })\n-);\n-\n #[cfg(windows)]\n-fn get_working_set_size() -> Option<usize> {\n+fn get_resident() -> Option<usize> {\n     use libc::{BOOL, DWORD, HANDLE, SIZE_T, GetCurrentProcess};\n     use std::mem;\n     #[repr(C)] #[allow(non_snake_case)]\n@@ -123,22 +127,6 @@ fn get_working_set_size() -> Option<usize> {\n     }\n }\n \n-#[cfg_attr(windows, allow(dead_code))]\n-#[allow(deprecated)]\n-fn get_proc_self_statm_field(field: usize) -> Option<usize> {\n-    use std::fs::File;\n-    use std::io::Read;\n-\n-    assert!(cfg!(unix));\n-\n-    let mut f = option_try!(File::open(\"/proc/self/statm\").ok());\n-    let mut contents = String::new();\n-    option_try!(f.read_to_string(&mut contents).ok());\n-    let s = option_try!(contents.split_whitespace().nth(field));\n-    let npages = option_try!(s.parse::<usize>().ok());\n-    Some(npages * ::std::env::page_size())\n-}\n-\n pub fn indent<R, F>(op: F) -> R where\n     R: Debug,\n     F: FnOnce() -> R,"}, {"sha": "077a0feebd497eb5acb441d78bb5118b7f8a4eb9", "filename": "src/librustc_back/tempdir.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibrustc_back%2Ftempdir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibrustc_back%2Ftempdir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftempdir.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -75,7 +75,6 @@ impl TempDir {\n     /// deleted once the returned wrapper is destroyed.\n     ///\n     /// If no directory can be created, `Err` is returned.\n-    #[allow(deprecated)]\n     pub fn new(prefix: &str) -> io::Result<TempDir> {\n         TempDir::new_in(&env::temp_dir(), prefix)\n     }"}, {"sha": "dd73969a4d7c5860b6035631bf35befba0e716f0", "filename": "src/librustc_bitflags/lib.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibrustc_bitflags%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibrustc_bitflags%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_bitflags%2Flib.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -19,7 +19,6 @@\n #![feature(no_std)]\n #![no_std]\n #![unstable(feature = \"rustc_private\")]\n-#![cfg_attr(test, feature(hash_default))]\n \n //! A typesafe bitmask flag generator.\n \n@@ -293,7 +292,7 @@ macro_rules! bitflags {\n #[cfg(test)]\n #[allow(non_upper_case_globals)]\n mod tests {\n-    use std::hash::{self, SipHasher};\n+    use std::hash::{Hasher, Hash, SipHasher};\n     use std::option::Option::{Some, None};\n \n     bitflags! {\n@@ -487,9 +486,15 @@ mod tests {\n     fn test_hash() {\n       let mut x = Flags::empty();\n       let mut y = Flags::empty();\n-      assert!(hash::hash::<Flags, SipHasher>(&x) == hash::hash::<Flags, SipHasher>(&y));\n+      assert!(hash(&x) == hash(&y));\n       x = Flags::all();\n       y = Flags::FlagABC;\n-      assert!(hash::hash::<Flags, SipHasher>(&x) == hash::hash::<Flags, SipHasher>(&y));\n+      assert!(hash(&x) == hash(&y));\n+    }\n+\n+    fn hash<T: Hash>(t: &T) -> u64 {\n+        let mut s = SipHasher::new();\n+        t.hash(&mut s);\n+        s.finish()\n     }\n }"}, {"sha": "f581931647765d9a7f416bacbf19aa7b318be095", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -28,9 +28,6 @@\n //! Use the former for unit-like structs and the latter for structs with\n //! a `pub fn new()`.\n \n-// BitSet\n-#![allow(deprecated)]\n-\n use metadata::{csearch, decoder};\n use middle::{cfg, def, infer, pat_util, stability, traits};\n use middle::subst::Substs;\n@@ -41,7 +38,7 @@ use rustc::ast_map;\n use util::nodemap::{FnvHashMap, FnvHashSet, NodeSet};\n use lint::{Level, Context, LintPass, LintArray, Lint};\n \n-use std::collections::{HashSet, BitSet};\n+use std::collections::HashSet;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::{cmp, slice};\n use std::{i8, i16, i32, i64, u8, u16, u32, u64, f32, f64};\n@@ -2170,7 +2167,7 @@ impl LintPass for UnconditionalRecursion {\n         let mut work_queue = vec![cfg.entry];\n         let mut reached_exit_without_self_call = false;\n         let mut self_call_spans = vec![];\n-        let mut visited = BitSet::new();\n+        let mut visited = HashSet::new();\n \n         while let Some(idx) = work_queue.pop() {\n             if idx == cfg.exit {"}, {"sha": "c5ed6561a27692539452ccf9d527beef53039dc6", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -703,7 +703,6 @@ impl<'v> Visitor<'v> for PathCollector {\n     }\n }\n \n-#[allow(deprecated)]\n pub fn process_crate(tcx: &ty::ctxt,\n                      analysis: &ty::CrateAnalysis,\n                      odir: Option<&Path>) {"}, {"sha": "eceb7fdfc7be56b0f034e174bd8bfc869cf51208", "filename": "src/librustc_unicode/char.rs", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibrustc_unicode%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibrustc_unicode%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Fchar.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -32,16 +32,12 @@\n use core::char::CharExt as C;\n use core::option::Option::{self, Some, None};\n use core::iter::Iterator;\n-use tables::{derived_property, property, general_category, conversions, charwidth};\n+use tables::{derived_property, property, general_category, conversions};\n \n // stable reexports\n pub use core::char::{MAX, from_u32, from_u32_unchecked, from_digit, EscapeUnicode, EscapeDefault};\n \n // unstable reexports\n-#[allow(deprecated)]\n-pub use normalize::{decompose_canonical, decompose_compatible, compose};\n-#[allow(deprecated)]\n-pub use tables::normalization::canonical_combining_class;\n pub use tables::UNICODE_VERSION;\n \n /// An iterator over the lowercase mapping of a given character, returned from\n@@ -502,22 +498,4 @@ impl char {\n     pub fn to_uppercase(self) -> ToUppercase {\n         ToUppercase(CaseMappingIter::new(conversions::to_upper(self)))\n     }\n-\n-    /// Returns this character's displayed width in columns, or `None` if it is a\n-    /// control character other than `'\\x00'`.\n-    ///\n-    /// `is_cjk` determines behavior for characters in the Ambiguous category:\n-    /// if `is_cjk` is `true`, these are 2 columns wide; otherwise, they are 1.\n-    /// In CJK contexts, `is_cjk` should be `true`, else it should be `false`.\n-    /// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)\n-    /// recommends that these characters be treated as 1 column (i.e.,\n-    /// `is_cjk` = `false`) if the context cannot be reliably determined.\n-    #[deprecated(reason = \"use the crates.io `unicode-width` library instead\",\n-                 since = \"1.0.0\")]\n-    #[unstable(feature = \"unicode\",\n-               reason = \"needs expert opinion. is_cjk flag stands out as ugly\")]\n-    #[inline]\n-    pub fn width(self, is_cjk: bool) -> Option<usize> {\n-        charwidth::width(self, is_cjk)\n-    }\n }"}, {"sha": "5fd77c27b641dcb0331b556d0110cccb8ef1cd3a", "filename": "src/librustc_unicode/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibrustc_unicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibrustc_unicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Flib.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -37,18 +37,16 @@\n #![feature(core_char_ext)]\n #![feature(core_slice_ext)]\n #![feature(core_str_ext)]\n-#![feature(iter_arith)]\n #![feature(lang_items)]\n #![feature(no_std)]\n #![feature(staged_api)]\n \n-mod normalize;\n mod tables;\n mod u_str;\n pub mod char;\n \n pub mod str {\n-    pub use u_str::{UnicodeStr, SplitWhitespace, Words, Graphemes, GraphemeIndices};\n+    pub use u_str::{UnicodeStr, SplitWhitespace};\n     pub use u_str::{utf8_char_width, is_utf16, Utf16Items, Utf16Item};\n     pub use u_str::{utf16_items, Utf16Encoder};\n }"}, {"sha": "d5219ab28fed61ee6bf7e396af914db63b43bf3c", "filename": "src/librustc_unicode/normalize.rs", "status": "removed", "additions": 0, "deletions": 162, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/a4066271b77810aec0a4a309f66a45e4f8b940de/src%2Flibrustc_unicode%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4066271b77810aec0a4a309f66a45e4f8b940de/src%2Flibrustc_unicode%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Fnormalize.rs?ref=a4066271b77810aec0a4a309f66a45e4f8b940de", "patch": "@@ -1,162 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Functions for computing canonical and compatible decompositions for Unicode characters.\n-\n-use core::cmp::Ordering::{Equal, Less, Greater};\n-use core::ops::FnMut;\n-use core::option::Option;\n-use core::option::Option::{Some, None};\n-use core::slice::SliceExt;\n-use core::result::Result::{Ok, Err};\n-use tables::normalization::{canonical_table, compatibility_table, composition_table};\n-\n-fn bsearch_table<T>(c: char, r: &'static [(char, &'static [T])]) -> Option<&'static [T]> {\n-    match r.binary_search_by(|&(val, _)| {\n-        if c == val { Equal }\n-        else if val < c { Less }\n-        else { Greater }\n-    }) {\n-        Ok(idx) => {\n-            let (_, result) = r[idx];\n-            Some(result)\n-        }\n-        Err(_) => None\n-    }\n-}\n-\n-/// Compute canonical Unicode decomposition for character\n-#[deprecated(reason = \"use the crates.io `unicode-normalization` library instead\",\n-             since = \"1.0.0\")]\n-#[unstable(feature = \"unicode\",\n-           reason = \"this functionality will be moved to crates.io\")]\n-pub fn decompose_canonical<F>(c: char, mut i: F) where F: FnMut(char) { d(c, &mut i, false); }\n-\n-/// Compute canonical or compatible Unicode decomposition for character\n-#[deprecated(reason = \"use the crates.io `unicode-normalization` library instead\",\n-             since = \"1.0.0\")]\n-#[unstable(feature = \"unicode\",\n-           reason = \"this functionality will be moved to crates.io\")]\n-pub fn decompose_compatible<F>(c: char, mut i: F) where F: FnMut(char) { d(c, &mut i, true); }\n-\n-// FIXME(#19596) This is a workaround, we should use `F` instead of `&mut F`\n-fn d<F>(c: char, i: &mut F, k: bool) where F: FnMut(char) {\n-    // 7-bit ASCII never decomposes\n-    if c <= '\\x7f' { (*i)(c); return; }\n-\n-    // Perform decomposition for Hangul\n-    if (c as u32) >= S_BASE && (c as u32) < (S_BASE + S_COUNT) {\n-        decompose_hangul(c, i);\n-        return;\n-    }\n-\n-    // First check the canonical decompositions\n-    match bsearch_table(c, canonical_table) {\n-        Some(canon) => {\n-            for x in canon {\n-                d(*x, i, k);\n-            }\n-            return;\n-        }\n-        None => ()\n-    }\n-\n-    // Bottom out if we're not doing compat.\n-    if !k { (*i)(c); return; }\n-\n-    // Then check the compatibility decompositions\n-    match bsearch_table(c, compatibility_table) {\n-        Some(compat) => {\n-            for x in compat {\n-                d(*x, i, k);\n-            }\n-            return;\n-        }\n-        None => ()\n-    }\n-\n-    // Finally bottom out.\n-    (*i)(c);\n-}\n-\n-#[deprecated(reason = \"use the crates.io `unicode-normalization` library instead\",\n-             since = \"1.0.0\")]\n-#[unstable(feature = \"unicode\",\n-           reason = \"this functionality will be moved to crates.io\")]\n-pub fn compose(a: char, b: char) -> Option<char> {\n-    compose_hangul(a, b).or_else(|| {\n-        match bsearch_table(a, composition_table) {\n-            None => None,\n-            Some(candidates) => {\n-                match candidates.binary_search_by(|&(val, _)| {\n-                    if b == val { Equal }\n-                    else if val < b { Less }\n-                    else { Greater }\n-                }) {\n-                    Ok(idx) => {\n-                        let (_, result) = candidates[idx];\n-                        Some(result)\n-                    }\n-                    Err(_) => None\n-                }\n-            }\n-        }\n-    })\n-}\n-\n-// Constants from Unicode 6.3.0 Section 3.12 Conjoining Jamo Behavior\n-const S_BASE: u32 = 0xAC00;\n-const L_BASE: u32 = 0x1100;\n-const V_BASE: u32 = 0x1161;\n-const T_BASE: u32 = 0x11A7;\n-const L_COUNT: u32 = 19;\n-const V_COUNT: u32 = 21;\n-const T_COUNT: u32 = 28;\n-const N_COUNT: u32 = (V_COUNT * T_COUNT);\n-const S_COUNT: u32 = (L_COUNT * N_COUNT);\n-\n-// FIXME(#19596) This is a workaround, we should use `F` instead of `&mut F`\n-// Decompose a precomposed Hangul syllable\n-#[inline(always)]\n-fn decompose_hangul<F>(s: char, f: &mut F) where F: FnMut(char) {\n-    use core::char::from_u32_unchecked;\n-    let si = s as u32 - S_BASE;\n-    let li = si / N_COUNT;\n-    unsafe {\n-        (*f)(from_u32_unchecked(L_BASE + li));\n-\n-        let vi = (si % N_COUNT) / T_COUNT;\n-        (*f)(from_u32_unchecked(V_BASE + vi));\n-\n-        let ti = si % T_COUNT;\n-        if ti > 0 {\n-            (*f)(from_u32_unchecked(T_BASE + ti));\n-        }\n-    }\n-}\n-\n-// Compose a pair of Hangul Jamo\n-#[inline(always)]\n-fn compose_hangul(a: char, b: char) -> Option<char> {\n-    use core::char::from_u32_unchecked;\n-    let l = a as u32;\n-    let v = b as u32;\n-    // Compose an LPart and a VPart\n-    if L_BASE <= l && l < (L_BASE + L_COUNT) && V_BASE <= v && v < (V_BASE + V_COUNT) {\n-        let r = S_BASE + (l - L_BASE) * N_COUNT + (v - V_BASE) * T_COUNT;\n-        return unsafe { Some(from_u32_unchecked(r)) };\n-    }\n-    // Compose an LVPart and a TPart\n-    if S_BASE <= l && l <= (S_BASE+S_COUNT-T_COUNT) && T_BASE <= v && v < (T_BASE+T_COUNT) {\n-        let r = l + (v - T_BASE);\n-        return unsafe { Some(from_u32_unchecked(r)) };\n-    }\n-    None\n-}"}, {"sha": "a314ffb2642421413ee55de767dfaa573eac4a7e", "filename": "src/librustc_unicode/tables.rs", "status": "modified", "additions": 1336, "deletions": 4627, "changes": 5963, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibrustc_unicode%2Ftables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibrustc_unicode%2Ftables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Ftables.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa"}, {"sha": "f6e6ac508a75c2f624e91a9afb50a12c469f32b6", "filename": "src/librustc_unicode/u_str.rs", "status": "modified", "additions": 0, "deletions": 296, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibrustc_unicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibrustc_unicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Fu_str.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -13,22 +13,11 @@\n //! This module provides functionality to `str` that requires the Unicode methods provided by the\n //! unicode parts of the CharExt trait.\n \n-use self::GraphemeState::*;\n-\n use core::char;\n-use core::cmp;\n use core::iter::Filter;\n use core::slice;\n use core::str::Split;\n \n-use tables::grapheme::GraphemeCat;\n-\n-#[deprecated(reason = \"struct Words is being replaced by struct SplitWhitespace\",\n-             since = \"1.1.0\")]\n-#[unstable(feature = \"str_words\",\n-           reason = \"words() will be replaced by split_whitespace() in 1.1.0\")]\n-pub type Words<'a> = SplitWhitespace<'a>;\n-\n /// An iterator over the non-whitespace substrings of a string,\n /// separated by any amount of whitespace.\n #[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n@@ -39,36 +28,15 @@ pub struct SplitWhitespace<'a> {\n /// Methods for Unicode string slices\n #[allow(missing_docs)] // docs in libcollections\n pub trait UnicodeStr {\n-    fn graphemes<'a>(&'a self, is_extended: bool) -> Graphemes<'a>;\n-    fn grapheme_indices<'a>(&'a self, is_extended: bool) -> GraphemeIndices<'a>;\n-    #[allow(deprecated)]\n-    fn words<'a>(&'a self) -> Words<'a>;\n     fn split_whitespace<'a>(&'a self) -> SplitWhitespace<'a>;\n     fn is_whitespace(&self) -> bool;\n     fn is_alphanumeric(&self) -> bool;\n-    fn width(&self, is_cjk: bool) -> usize;\n     fn trim<'a>(&'a self) -> &'a str;\n     fn trim_left<'a>(&'a self) -> &'a str;\n     fn trim_right<'a>(&'a self) -> &'a str;\n }\n \n impl UnicodeStr for str {\n-    #[inline]\n-    fn graphemes(&self, is_extended: bool) -> Graphemes {\n-        Graphemes { string: self, extended: is_extended, cat: None, catb: None }\n-    }\n-\n-    #[inline]\n-    fn grapheme_indices(&self, is_extended: bool) -> GraphemeIndices {\n-        GraphemeIndices { start_offset: self.as_ptr() as usize, iter: self.graphemes(is_extended) }\n-    }\n-\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn words(&self) -> Words {\n-        self.split_whitespace()\n-    }\n-\n     #[inline]\n     fn split_whitespace(&self) -> SplitWhitespace {\n         fn is_not_empty(s: &&str) -> bool { !s.is_empty() }\n@@ -86,12 +54,6 @@ impl UnicodeStr for str {\n     #[inline]\n     fn is_alphanumeric(&self) -> bool { self.chars().all(|c| c.is_alphanumeric()) }\n \n-    #[allow(deprecated)]\n-    #[inline]\n-    fn width(&self, is_cjk: bool) -> usize {\n-        self.chars().map(|c| c.width(is_cjk).unwrap_or(0)).sum()\n-    }\n-\n     #[inline]\n     fn trim(&self) -> &str {\n         self.trim_matches(|c: char| c.is_whitespace())\n@@ -108,264 +70,6 @@ impl UnicodeStr for str {\n     }\n }\n \n-/// External iterator for grapheme clusters and byte offsets.\n-#[derive(Clone)]\n-pub struct GraphemeIndices<'a> {\n-    start_offset: usize,\n-    iter: Graphemes<'a>,\n-}\n-\n-impl<'a> Iterator for GraphemeIndices<'a> {\n-    type Item = (usize, &'a str);\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<(usize, &'a str)> {\n-        self.iter.next().map(|s| (s.as_ptr() as usize - self.start_offset, s))\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-}\n-\n-impl<'a> DoubleEndedIterator for GraphemeIndices<'a> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<(usize, &'a str)> {\n-        self.iter.next_back().map(|s| (s.as_ptr() as usize - self.start_offset, s))\n-    }\n-}\n-\n-/// External iterator for a string's\n-/// [grapheme clusters](http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries).\n-#[derive(Clone)]\n-pub struct Graphemes<'a> {\n-    string: &'a str,\n-    extended: bool,\n-    cat: Option<GraphemeCat>,\n-    catb: Option<GraphemeCat>,\n-}\n-\n-// state machine for cluster boundary rules\n-#[derive(PartialEq,Eq)]\n-enum GraphemeState {\n-    Start,\n-    FindExtend,\n-    HangulL,\n-    HangulLV,\n-    HangulLVT,\n-    Regional,\n-}\n-\n-impl<'a> Iterator for Graphemes<'a> {\n-    type Item = &'a str;\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let slen = self.string.len();\n-        (cmp::min(slen, 1), Some(slen))\n-    }\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a str> {\n-        use tables::grapheme as gr;\n-        if self.string.is_empty() {\n-            return None;\n-        }\n-\n-        let mut take_curr = true;\n-        let mut idx = 0;\n-        let mut state = Start;\n-        let mut cat = gr::GC_Any;\n-        for (curr, ch) in self.string.char_indices() {\n-            idx = curr;\n-\n-            // retrieve cached category, if any\n-            // We do this because most of the time we would end up\n-            // looking up each character twice.\n-            cat = match self.cat {\n-                None => gr::grapheme_category(ch),\n-                _ => self.cat.take().unwrap()\n-            };\n-\n-            if match cat {\n-                gr::GC_Extend => true,\n-                gr::GC_SpacingMark if self.extended => true,\n-                _ => false\n-            } {\n-                    state = FindExtend;     // rule GB9/GB9a\n-                    continue;\n-            }\n-\n-            state = match state {\n-                Start if '\\r' == ch => {\n-                    let slen = self.string.len();\n-                    let nidx = idx + 1;\n-                    if nidx != slen && self.string.char_at(nidx) == '\\n' {\n-                        idx = nidx;             // rule GB3\n-                    }\n-                    break;                      // rule GB4\n-                }\n-                Start => match cat {\n-                    gr::GC_Control => break,\n-                    gr::GC_L => HangulL,\n-                    gr::GC_LV | gr::GC_V => HangulLV,\n-                    gr::GC_LVT | gr::GC_T => HangulLVT,\n-                    gr::GC_Regional_Indicator => Regional,\n-                    _ => FindExtend\n-                },\n-                FindExtend => {         // found non-extending when looking for extending\n-                    take_curr = false;\n-                    break;\n-                },\n-                HangulL => match cat {      // rule GB6: L x (L|V|LV|LVT)\n-                    gr::GC_L => continue,\n-                    gr::GC_LV | gr::GC_V => HangulLV,\n-                    gr::GC_LVT => HangulLVT,\n-                    _ => {\n-                        take_curr = false;\n-                        break;\n-                    }\n-                },\n-                HangulLV => match cat {     // rule GB7: (LV|V) x (V|T)\n-                    gr::GC_V => continue,\n-                    gr::GC_T => HangulLVT,\n-                    _ => {\n-                        take_curr = false;\n-                        break;\n-                    }\n-                },\n-                HangulLVT => match cat {    // rule GB8: (LVT|T) x T\n-                    gr::GC_T => continue,\n-                    _ => {\n-                        take_curr = false;\n-                        break;\n-                    }\n-                },\n-                Regional => match cat {     // rule GB8a\n-                    gr::GC_Regional_Indicator => continue,\n-                    _ => {\n-                        take_curr = false;\n-                        break;\n-                    }\n-                }\n-            }\n-        }\n-\n-        self.cat = if take_curr {\n-            idx = idx + self.string.char_at(idx).len_utf8();\n-            None\n-        } else {\n-            Some(cat)\n-        };\n-\n-        let retstr = &self.string[..idx];\n-        self.string = &self.string[idx..];\n-        Some(retstr)\n-    }\n-}\n-\n-impl<'a> DoubleEndedIterator for Graphemes<'a> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<&'a str> {\n-        use tables::grapheme as gr;\n-        if self.string.is_empty() {\n-            return None;\n-        }\n-\n-        let mut take_curr = true;\n-        let mut idx = self.string.len();\n-        let mut previdx = idx;\n-        let mut state = Start;\n-        let mut cat = gr::GC_Any;\n-        for (curr, ch) in self.string.char_indices().rev() {\n-            previdx = idx;\n-            idx = curr;\n-\n-            // cached category, if any\n-            cat = match self.catb {\n-                None => gr::grapheme_category(ch),\n-                _ => self.catb.take().unwrap()\n-            };\n-\n-            // a matching state machine that runs *backwards* across an input string\n-            // note that this has some implications for the Hangul matching, since\n-            // we now need to know what the rightward letter is:\n-            //\n-            // Right to left, we have:\n-            //      L x L\n-            //      V x (L|V|LV)\n-            //      T x (V|T|LV|LVT)\n-            // HangulL means the letter to the right is L\n-            // HangulLV means the letter to the right is V\n-            // HangulLVT means the letter to the right is T\n-            state = match state {\n-                Start if '\\n' == ch => {\n-                    if idx > 0 && '\\r' == self.string.char_at_reverse(idx) {\n-                        idx -= 1;       // rule GB3\n-                    }\n-                    break;              // rule GB4\n-                },\n-                Start | FindExtend => match cat {\n-                    gr::GC_Extend => FindExtend,\n-                    gr::GC_SpacingMark if self.extended => FindExtend,\n-                    gr::GC_L | gr::GC_LV | gr::GC_LVT => HangulL,\n-                    gr::GC_V => HangulLV,\n-                    gr::GC_T => HangulLVT,\n-                    gr::GC_Regional_Indicator => Regional,\n-                    gr::GC_Control => {\n-                        take_curr = Start == state;\n-                        break;\n-                    },\n-                    _ => break\n-                },\n-                HangulL => match cat {      // char to right is an L\n-                    gr::GC_L => continue,               // L x L is the only legal match\n-                    _ => {\n-                        take_curr = false;\n-                        break;\n-                    }\n-                },\n-                HangulLV => match cat {     // char to right is a V\n-                    gr::GC_V => continue,               // V x V, right char is still V\n-                    gr::GC_L | gr::GC_LV => HangulL,    // (L|V) x V, right char is now L\n-                    _ => {\n-                        take_curr = false;\n-                        break;\n-                    }\n-                },\n-                HangulLVT => match cat {    // char to right is a T\n-                    gr::GC_T => continue,               // T x T, right char is still T\n-                    gr::GC_V => HangulLV,               // V x T, right char is now V\n-                    gr::GC_LV | gr::GC_LVT => HangulL,  // (LV|LVT) x T, right char is now L\n-                    _ => {\n-                        take_curr = false;\n-                        break;\n-                    }\n-                },\n-                Regional => match cat {     // rule GB8a\n-                    gr::GC_Regional_Indicator => continue,\n-                    _ => {\n-                        take_curr = false;\n-                        break;\n-                    }\n-                }\n-            }\n-        }\n-\n-        self.catb = if take_curr {\n-            None\n-        } else  {\n-            idx = previdx;\n-            Some(cat)\n-        };\n-\n-        let retstr = &self.string[idx..];\n-        self.string = &self.string[..idx];\n-        Some(retstr)\n-    }\n-}\n-\n // https://tools.ietf.org/html/rfc3629\n static UTF8_CHAR_WIDTH: [u8; 256] = [\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,"}, {"sha": "2f2c63ef19ed2d455de12267c90d2da4bbd59e36", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -354,7 +354,6 @@ fn parse_externs(matches: &getopts::Matches) -> Result<core::Externs, String> {\n /// generated from the cleaned AST of the crate.\n ///\n /// This form of input will run all of the plug/cleaning passes\n-#[allow(deprecated)] // for old Path in plugin manager\n fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matches) -> Output {\n     let mut default_passes = !matches.opt_present(\"no-defaults\");\n     let mut passes = matches.opt_strs(\"passes\");"}, {"sha": "a81787dad77744889e6d5691621d387c756d9dc1", "filename": "src/librustdoc/plugins.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibrustdoc%2Fplugins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibrustdoc%2Fplugins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fplugins.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(deprecated)] // old path, used for compatibility with dynamic lib\n-\n use clean;\n \n use std::dynamic_lib as dl;"}, {"sha": "cb949940b6d2bddfb687c4b10eb687173a54a9b5", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 1, "deletions": 30, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// VecMap\n-#![allow(deprecated)]\n-\n //! Implementations of serialization for structures found in libcollections\n \n use std::usize;\n@@ -19,7 +16,7 @@ use std::hash::Hash;\n use std::collections::hash_state::HashState;\n \n use {Decodable, Encodable, Decoder, Encoder};\n-use std::collections::{LinkedList, VecDeque, BTreeMap, BTreeSet, HashMap, HashSet, VecMap};\n+use std::collections::{LinkedList, VecDeque, BTreeMap, BTreeSet, HashMap, HashSet};\n use collections::enum_set::{EnumSet, CLike};\n \n impl<\n@@ -228,29 +225,3 @@ impl<T, S> Decodable for HashSet<T, S>\n         })\n     }\n }\n-\n-impl<V: Encodable> Encodable for VecMap<V> {\n-    fn encode<S: Encoder>(&self, e: &mut S) -> Result<(), S::Error> {\n-        e.emit_map(self.len(), |e| {\n-                for (i, (key, val)) in self.iter().enumerate() {\n-                    try!(e.emit_map_elt_key(i, |e| key.encode(e)));\n-                    try!(e.emit_map_elt_val(i, |e| val.encode(e)));\n-                }\n-                Ok(())\n-            })\n-    }\n-}\n-\n-impl<V: Decodable> Decodable for VecMap<V> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<VecMap<V>, D::Error> {\n-        d.read_map(|d, len| {\n-            let mut map = VecMap::new();\n-            for i in 0..len {\n-                let key = try!(d.read_map_elt_key(i, |d| Decodable::decode(d)));\n-                let val = try!(d.read_map_elt_val(i, |d| Decodable::decode(d)));\n-                map.insert(key, val);\n-            }\n-            Ok(map)\n-        })\n-    }\n-}"}, {"sha": "e474f47a1b5aac87006a2d009bf02aa19784e198", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -1552,7 +1552,6 @@ impl<T: Iterator<Item=char>> Parser<T> {\n         }\n     }\n \n-    #[allow(deprecated)] // possible resolve bug is mapping these to traits\n     fn parse_u64(&mut self) -> Result<u64, ParserError> {\n         let mut accum = 0u64;\n         let last_accum = 0; // necessary to detect overflow."}, {"sha": "7472839a59c91801eaab3c80514f40e273eadb39", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -36,7 +36,6 @@ Core encoding and decoding interfaces.\n #![feature(staged_api)]\n #![feature(str_char)]\n #![feature(unicode)]\n-#![feature(vecmap)]\n #![cfg_attr(test, feature(test))]\n \n // test harness access"}, {"sha": "82b5f60d65cd7b0ac62e00ecdfc5a22b50448471", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 14, "deletions": 85, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -17,24 +17,6 @@ use prelude::v1::*;\n use mem;\n use ops::Range;\n \n-/// Extension methods for ASCII-subset only operations on owned strings\n-#[unstable(feature = \"owned_ascii_ext\",\n-           reason = \"would prefer to do this in a more general way\")]\n-#[deprecated(since = \"1.3.0\",\n-             reason = \"hasn't yet proved essential to be in the standard library\")]\n-#[allow(deprecated)]\n-pub trait OwnedAsciiExt {\n-    /// Converts the string to ASCII upper case:\n-    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n-    /// but non-ASCII letters are unchanged.\n-    fn into_ascii_uppercase(self) -> Self;\n-\n-    /// Converts the string to ASCII lower case:\n-    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n-    /// but non-ASCII letters are unchanged.\n-    fn into_ascii_lowercase(self) -> Self;\n-}\n-\n /// Extension methods for ASCII-subset only operations on string slices.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait AsciiExt {\n@@ -169,15 +151,19 @@ impl AsciiExt for str {\n     }\n \n     #[inline]\n-    #[allow(deprecated)]\n     fn to_ascii_uppercase(&self) -> String {\n-        self.to_string().into_ascii_uppercase()\n+        let mut bytes = self.as_bytes().to_vec();\n+        bytes.make_ascii_uppercase();\n+        // make_ascii_uppercase() preserves the UTF-8 invariant.\n+        unsafe { String::from_utf8_unchecked(bytes) }\n     }\n \n     #[inline]\n-    #[allow(deprecated)]\n     fn to_ascii_lowercase(&self) -> String {\n-        self.to_string().into_ascii_lowercase()\n+        let mut bytes = self.as_bytes().to_vec();\n+        bytes.make_ascii_lowercase();\n+        // make_ascii_uppercase() preserves the UTF-8 invariant.\n+        unsafe { String::from_utf8_unchecked(bytes) }\n     }\n \n     #[inline]\n@@ -196,21 +182,6 @@ impl AsciiExt for str {\n     }\n }\n \n-#[allow(deprecated)]\n-impl OwnedAsciiExt for String {\n-    #[inline]\n-    fn into_ascii_uppercase(self) -> String {\n-        // Vec<u8>::into_ascii_uppercase() preserves the UTF-8 invariant.\n-        unsafe { String::from_utf8_unchecked(self.into_bytes().into_ascii_uppercase()) }\n-    }\n-\n-    #[inline]\n-    fn into_ascii_lowercase(self) -> String {\n-        // Vec<u8>::into_ascii_lowercase() preserves the UTF-8 invariant.\n-        unsafe { String::from_utf8_unchecked(self.into_bytes().into_ascii_lowercase()) }\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsciiExt for [u8] {\n     type Owned = Vec<u8>;\n@@ -220,15 +191,17 @@ impl AsciiExt for [u8] {\n     }\n \n     #[inline]\n-    #[allow(deprecated)]\n     fn to_ascii_uppercase(&self) -> Vec<u8> {\n-        self.to_vec().into_ascii_uppercase()\n+        let mut me = self.to_vec();\n+        me.make_ascii_uppercase();\n+        return me\n     }\n \n     #[inline]\n-    #[allow(deprecated)]\n     fn to_ascii_lowercase(&self) -> Vec<u8> {\n-        self.to_vec().into_ascii_lowercase()\n+        let mut me = self.to_vec();\n+        me.make_ascii_lowercase();\n+        return me\n     }\n \n     #[inline]\n@@ -252,21 +225,6 @@ impl AsciiExt for [u8] {\n     }\n }\n \n-#[allow(deprecated)]\n-impl OwnedAsciiExt for Vec<u8> {\n-    #[inline]\n-    fn into_ascii_uppercase(mut self) -> Vec<u8> {\n-        self.make_ascii_uppercase();\n-        self\n-    }\n-\n-    #[inline]\n-    fn into_ascii_lowercase(mut self) -> Vec<u8> {\n-        self.make_ascii_lowercase();\n-        self\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsciiExt for u8 {\n     type Owned = u8;\n@@ -522,35 +480,6 @@ mod tests {\n         }\n     }\n \n-    #[test]\n-    fn test_into_ascii_uppercase() {\n-        assert_eq!((\"url()URL()uRl()\u00fcrl\".to_string()).into_ascii_uppercase(),\n-                   \"URL()URL()URL()\u00fcRL\".to_string());\n-        assert_eq!((\"h\u0131\u212a\u00df\".to_string()).into_ascii_uppercase(), \"H\u0131\u212a\u00df\");\n-\n-        for i in 0..501 {\n-            let upper = if 'a' as u32 <= i && i <= 'z' as u32 { i + 'A' as u32 - 'a' as u32 }\n-                        else { i };\n-            assert_eq!((from_u32(i).unwrap()).to_string().into_ascii_uppercase(),\n-                       (from_u32(upper).unwrap()).to_string());\n-        }\n-    }\n-\n-    #[test]\n-    fn test_into_ascii_lowercase() {\n-        assert_eq!((\"url()URL()uRl()\u00dcrl\".to_string()).into_ascii_lowercase(),\n-                   \"url()url()url()\u00dcrl\");\n-        // Dotted capital I, Kelvin sign, Sharp S.\n-        assert_eq!((\"H\u0130\u212a\u00df\".to_string()).into_ascii_lowercase(), \"h\u0130\u212a\u00df\");\n-\n-        for i in 0..501 {\n-            let lower = if 'A' as u32 <= i && i <= 'Z' as u32 { i + 'a' as u32 - 'A' as u32 }\n-                        else { i };\n-            assert_eq!((from_u32(i).unwrap()).to_string().into_ascii_lowercase(),\n-                       (from_u32(lower).unwrap()).to_string());\n-        }\n-    }\n-\n     #[test]\n     fn test_make_ascii_lower_case() {\n         macro_rules! test {"}, {"sha": "654b2eac4bab564f563b73d8080c963ef18e0c13", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -24,7 +24,7 @@ use mem::{self, replace};\n use ops::{Deref, FnMut, FnOnce, Index};\n use option::Option::{self, Some, None};\n use rand::{self, Rng};\n-use result::Result::{self, Ok, Err};\n+use result::Result;\n \n use super::table::{\n     self,\n@@ -1482,18 +1482,6 @@ impl<'a, K, V> ExactSizeIterator for Drain<'a, K, V> {\n }\n \n impl<'a, K, V> Entry<'a, K, V> {\n-    #[unstable(feature = \"entry\",\n-               reason = \"will soon be replaced by or_insert\")]\n-    #[deprecated(since = \"1.0\",\n-                reason = \"replaced with more ergonomic `or_insert` and `or_insert_with`\")]\n-    /// Returns a mutable reference to the entry if occupied, or the VacantEntry if vacant\n-    pub fn get(self) -> Result<&'a mut V, VacantEntry<'a, K, V>> {\n-        match self {\n-            Occupied(entry) => Ok(entry.into_mut()),\n-            Vacant(entry) => Err(entry),\n-        }\n-    }\n-\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     /// Ensures a value is in the entry by inserting the default if empty, and returns\n     /// a mutable reference to the value in the entry.\n@@ -1610,7 +1598,7 @@ pub struct RandomState {\n impl RandomState {\n     /// Constructs a new `RandomState` that is initialized with random keys.\n     #[inline]\n-    #[allow(deprecated)]\n+    #[allow(deprecated)] // rand\n     pub fn new() -> RandomState {\n         let mut r = rand::thread_rng();\n         RandomState { k0: r.gen(), k1: r.gen() }"}, {"sha": "d59d08497d29b3453e54f88f4137a0180aa5faf5", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -385,11 +385,11 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n pub use core_collections::Bound;\n-pub use core_collections::{BinaryHeap, BitVec, BitSet, BTreeMap, BTreeSet};\n-pub use core_collections::{LinkedList, VecDeque, VecMap};\n+pub use core_collections::{BinaryHeap, BTreeMap, BTreeSet};\n+pub use core_collections::{LinkedList, VecDeque};\n \n-pub use core_collections::{binary_heap, bit_vec, bit_set, btree_map, btree_set};\n-pub use core_collections::{linked_list, vec_deque, vec_map};\n+pub use core_collections::{binary_heap, btree_map, btree_set};\n+pub use core_collections::{linked_list, vec_deque};\n \n pub use self::hash_map::HashMap;\n pub use self::hash_set::HashSet;"}, {"sha": "d80a222d8d28967dff421eefd1986e651615e40f", "filename": "src/libstd/env.rs", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -23,7 +23,6 @@ use ffi::{OsStr, OsString};\n use fmt;\n use io;\n use path::{Path, PathBuf};\n-use sync::atomic::{AtomicIsize, Ordering};\n use sync::StaticMutex;\n use sys::os as os_imp;\n \n@@ -474,30 +473,6 @@ pub fn current_exe() -> io::Result<PathBuf> {\n     os_imp::current_exe()\n }\n \n-static EXIT_STATUS: AtomicIsize = AtomicIsize::new(0);\n-\n-/// Sets the process exit code\n-///\n-/// Sets the exit code returned by the process if all supervised threads\n-/// terminate successfully (without panicking). If the current root thread panics\n-/// and is supervised by the scheduler then any user-specified exit status is\n-/// ignored and the process exits with the default panic status.\n-///\n-/// Note that this is not synchronized against modifications of other threads.\n-#[unstable(feature = \"exit_status\", reason = \"managing the exit status may change\")]\n-#[deprecated(since = \"1.2.0\", reason = \"use process::exit instead\")]\n-pub fn set_exit_status(code: i32) {\n-    EXIT_STATUS.store(code as isize, Ordering::SeqCst)\n-}\n-\n-/// Fetches the process's current exit code. This defaults to 0 and can change\n-/// by calling `set_exit_status`.\n-#[unstable(feature = \"exit_status\", reason = \"managing the exit status may change\")]\n-#[deprecated(since = \"1.2.0\", reason = \"use process::exit instead\")]\n-pub fn get_exit_status() -> i32 {\n-    EXIT_STATUS.load(Ordering::SeqCst) as i32\n-}\n-\n /// An iterator over the arguments of a process, yielding a `String` value\n /// for each argument.\n ///\n@@ -588,14 +563,6 @@ impl ExactSizeIterator for ArgsOs {\n     fn len(&self) -> usize { self.inner.len() }\n }\n \n-/// Returns the page size of the current architecture in bytes.\n-#[unstable(feature = \"page_size\", reason = \"naming and/or location may change\")]\n-#[deprecated(since = \"1.3.0\",\n-             reason = \"hasn't seen enough usage to justify inclusion\")]\n-pub fn page_size() -> usize {\n-    os_imp::page_size()\n-}\n-\n /// Constants associated with the current target\n #[stable(feature = \"env\", since = \"1.0.0\")]\n pub mod consts {"}, {"sha": "f99d3c14ed8ce3596d2acc1445005bea3eb779bb", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -468,6 +468,7 @@ mod tests {\n     use super::*;\n     use libc;\n     use borrow::Cow::{Borrowed, Owned};\n+    use hash::{SipHasher, Hash, Hasher};\n \n     #[test]\n     fn c_to_rust() {\n@@ -545,15 +546,16 @@ mod tests {\n \n     #[test]\n     fn equal_hash() {\n-        use hash;\n-\n         let data = b\"123\\xE2\\xFA\\xA6\\0\";\n         let ptr = data.as_ptr() as *const libc::c_char;\n         let cstr: &'static CStr = unsafe { CStr::from_ptr(ptr) };\n \n-        let cstr_hash = hash::hash::<_, hash::SipHasher>(&cstr);\n-        let cstring_hash =\n-            hash::hash::<_, hash::SipHasher>(&CString::new(&data[..data.len() - 1]).unwrap());\n+        let mut s = SipHasher::new_with_keys(0, 0);\n+        cstr.hash(&mut s);\n+        let cstr_hash = s.finish();\n+        let mut s = SipHasher::new_with_keys(0, 0);\n+        CString::new(&data[..data.len() - 1]).unwrap().hash(&mut s);\n+        let cstring_hash = s.finish();\n \n         assert_eq!(cstr_hash, cstring_hash);\n     }"}, {"sha": "53caa0e78e28d547276667a23d17a936163dfb27", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -1216,23 +1216,6 @@ impl PathExt for Path {\n     }\n }\n \n-/// Changes the timestamps for a file's last modification and access time.\n-///\n-/// The file at the path specified will have its last access time set to\n-/// `accessed` and its modification time set to `modified`. The times specified\n-/// should be in milliseconds.\n-#[unstable(feature = \"fs_time\",\n-           reason = \"the argument type of u64 is not quite appropriate for \\\n-                     this function and may change if the standard library \\\n-                     gains a type to represent a moment in time\")]\n-#[deprecated(since = \"1.3.0\",\n-             reason = \"will never be stabilized as-is and its replacement will \\\n-                       likely have a totally new API\")]\n-pub fn set_file_times<P: AsRef<Path>>(path: P, accessed: u64,\n-                                 modified: u64) -> io::Result<()> {\n-    fs_imp::utimes(path.as_ref(), accessed, modified)\n-}\n-\n /// Changes the permissions found on a file or a directory.\n ///\n /// # Examples\n@@ -2049,44 +2032,6 @@ mod tests {\n         assert_eq!(check!(fs::metadata(&tmpdir.join(\"h\"))).len(), 3);\n     }\n \n-    #[test]\n-    fn utime() {\n-        let tmpdir = tmpdir();\n-        let path = tmpdir.join(\"a\");\n-        check!(File::create(&path));\n-        // These numbers have to be bigger than the time in the day to account\n-        // for timezones Windows in particular will fail in certain timezones\n-        // with small enough values\n-        check!(fs::set_file_times(&path, 100_000, 200_000));\n-\n-        check(&check!(path.metadata()));\n-\n-        #[cfg(unix)]\n-        fn check(metadata: &fs::Metadata) {\n-            use os::unix::prelude::*;\n-            assert_eq!(metadata.atime(), 100);\n-            assert_eq!(metadata.atime_nsec(), 0);\n-            assert_eq!(metadata.mtime(), 200);\n-            assert_eq!(metadata.mtime_nsec(), 0);\n-        }\n-        #[cfg(windows)]\n-        fn check(metadata: &fs::Metadata) {\n-            use os::windows::prelude::*;\n-            assert_eq!(metadata.last_access_time(), 100_000 * 10_000);\n-            assert_eq!(metadata.last_write_time(), 200_000 * 10_000);\n-        }\n-    }\n-\n-    #[test]\n-    fn utime_noexist() {\n-        let tmpdir = tmpdir();\n-\n-        match fs::set_file_times(&tmpdir.join(\"a\"), 100, 200) {\n-            Ok(..) => panic!(),\n-            Err(..) => {}\n-        }\n-    }\n-\n     #[test]\n     fn binary_file() {\n         let mut bytes = [0; 1024];"}, {"sha": "90bcbe7fe86587767e86c628dcaa3812b830fcbe", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 1, "deletions": 148, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -785,129 +785,11 @@ impl<W: Read + Write> Read for InternalBufWriter<W> {\n     }\n }\n \n-/// Wraps a Stream and buffers input and output to and from it.\n-///\n-/// It can be excessively inefficient to work directly with a `Read+Write`. For\n-/// example, every call to `read` or `write` on `TcpStream` results in a system\n-/// call. A `BufStream` keeps in memory buffers of data, making large,\n-/// infrequent calls to `read` and `write` on the underlying `Read+Write`.\n-///\n-/// The output buffer will be written out when this stream is dropped.\n-#[unstable(feature = \"buf_stream\",\n-           reason = \"unsure about semantics of buffering two directions, \\\n-                     leading to issues like #17136\")]\n-#[deprecated(since = \"1.2.0\",\n-             reason = \"use the crates.io `bufstream` crate instead\")]\n-pub struct BufStream<S: Write> {\n-    inner: BufReader<InternalBufWriter<S>>\n-}\n-\n-#[unstable(feature = \"buf_stream\",\n-           reason = \"unsure about semantics of buffering two directions, \\\n-                     leading to issues like #17136\")]\n-#[deprecated(since = \"1.2.0\",\n-             reason = \"use the crates.io `bufstream` crate instead\")]\n-#[allow(deprecated)]\n-impl<S: Read + Write> BufStream<S> {\n-    /// Creates a new buffered stream with explicitly listed capacities for the\n-    /// reader/writer buffer.\n-    pub fn with_capacities(reader_cap: usize, writer_cap: usize, inner: S)\n-                           -> BufStream<S> {\n-        let writer = BufWriter::with_capacity(writer_cap, inner);\n-        let internal_writer = InternalBufWriter(writer);\n-        let reader = BufReader::with_capacity(reader_cap, internal_writer);\n-        BufStream { inner: reader }\n-    }\n-\n-    /// Creates a new buffered stream with the default reader/writer buffer\n-    /// capacities.\n-    pub fn new(inner: S) -> BufStream<S> {\n-        BufStream::with_capacities(DEFAULT_BUF_SIZE, DEFAULT_BUF_SIZE, inner)\n-    }\n-\n-    /// Gets a reference to the underlying stream.\n-    pub fn get_ref(&self) -> &S {\n-        let InternalBufWriter(ref w) = self.inner.inner;\n-        w.get_ref()\n-    }\n-\n-    /// Gets a mutable reference to the underlying stream.\n-    ///\n-    /// It is inadvisable to read directly from or write directly to the\n-    /// underlying stream.\n-    pub fn get_mut(&mut self) -> &mut S {\n-        let InternalBufWriter(ref mut w) = self.inner.inner;\n-        w.get_mut()\n-    }\n-\n-    /// Unwraps this `BufStream`, returning the underlying stream.\n-    ///\n-    /// The internal write buffer is written out before returning the stream.\n-    /// Any leftover data in the read buffer is lost.\n-    pub fn into_inner(self) -> Result<S, IntoInnerError<BufStream<S>>> {\n-        let BufReader { inner: InternalBufWriter(w), buf, pos, cap } = self.inner;\n-        w.into_inner().map_err(|IntoInnerError(w, e)| {\n-            IntoInnerError(BufStream {\n-                inner: BufReader { inner: InternalBufWriter(w), buf: buf, pos: pos, cap: cap },\n-            }, e)\n-        })\n-    }\n-}\n-\n-#[unstable(feature = \"buf_stream\",\n-           reason = \"unsure about semantics of buffering two directions, \\\n-                     leading to issues like #17136\")]\n-#[allow(deprecated)]\n-impl<S: Read + Write> BufRead for BufStream<S> {\n-    fn fill_buf(&mut self) -> io::Result<&[u8]> { self.inner.fill_buf() }\n-    fn consume(&mut self, amt: usize) { self.inner.consume(amt) }\n-}\n-\n-#[unstable(feature = \"buf_stream\",\n-           reason = \"unsure about semantics of buffering two directions, \\\n-                     leading to issues like #17136\")]\n-#[allow(deprecated)]\n-impl<S: Read + Write> Read for BufStream<S> {\n-    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n-        self.inner.read(buf)\n-    }\n-}\n-\n-#[unstable(feature = \"buf_stream\",\n-           reason = \"unsure about semantics of buffering two directions, \\\n-                     leading to issues like #17136\")]\n-#[allow(deprecated)]\n-impl<S: Read + Write> Write for BufStream<S> {\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        self.inner.inner.get_mut().write(buf)\n-    }\n-    fn flush(&mut self) -> io::Result<()> {\n-        self.inner.inner.get_mut().flush()\n-    }\n-}\n-\n-#[unstable(feature = \"buf_stream\",\n-           reason = \"unsure about semantics of buffering two directions, \\\n-                     leading to issues like #17136\")]\n-#[allow(deprecated)]\n-impl<S: Write> fmt::Debug for BufStream<S> where S: fmt::Debug {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let reader = &self.inner;\n-        let writer = &self.inner.inner.0;\n-        fmt.debug_struct(\"BufStream\")\n-            .field(\"stream\", &writer.inner)\n-            .field(\"write_buffer\", &format_args!(\"{}/{}\", writer.buf.len(), writer.buf.capacity()))\n-            .field(\"read_buffer\",\n-                   &format_args!(\"{}/{}\", reader.cap - reader.pos, reader.buf.len()))\n-            .finish()\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use prelude::v1::*;\n     use io::prelude::*;\n-    use io::{self, BufReader, BufWriter, BufStream, Cursor, LineWriter, SeekFrom};\n+    use io::{self, BufReader, BufWriter, Cursor, LineWriter, SeekFrom};\n     use test;\n \n     /// A dummy reader intended at testing short-reads propagation.\n@@ -1078,27 +960,6 @@ mod tests {\n         assert_eq!(&w.into_inner().unwrap().into_inner()[..], &[0, 1, 8, 9, 4, 5, 6, 7]);\n     }\n \n-    // This is just here to make sure that we don't infinite loop in the\n-    // newtype struct autoderef weirdness\n-    #[test]\n-    fn test_buffered_stream() {\n-        struct S;\n-\n-        impl Write for S {\n-            fn write(&mut self, b: &[u8]) -> io::Result<usize> { Ok(b.len()) }\n-            fn flush(&mut self) -> io::Result<()> { Ok(()) }\n-        }\n-\n-        impl Read for S {\n-            fn read(&mut self, _: &mut [u8]) -> io::Result<usize> { Ok(0) }\n-        }\n-\n-        let mut stream = BufStream::new(S);\n-        assert_eq!(stream.read(&mut [0; 10]).unwrap(), 0);\n-        stream.write(&[0; 10]).unwrap();\n-        stream.flush().unwrap();\n-    }\n-\n     #[test]\n     fn test_read_until() {\n         let inner: &[u8] = &[0, 1, 2, 1, 0];\n@@ -1230,12 +1091,4 @@ mod tests {\n             BufWriter::new(io::sink())\n         });\n     }\n-\n-    #[bench]\n-    fn bench_buffered_stream(b: &mut test::Bencher) {\n-        let mut buf = Cursor::new(Vec::new());\n-        b.iter(|| {\n-            BufStream::new(&mut buf);\n-        });\n-    }\n }"}, {"sha": "eda6e85ff7f49b0a16110388fea12e11c9e465ea", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -255,7 +255,7 @@ use string::String;\n use str;\n use vec::Vec;\n \n-pub use self::buffered::{BufReader, BufWriter, BufStream, LineWriter};\n+pub use self::buffered::{BufReader, BufWriter, LineWriter};\n pub use self::buffered::IntoInnerError;\n pub use self::cursor::Cursor;\n pub use self::error::{Result, Error, ErrorKind};"}, {"sha": "77c634e8090d3f3b5296d2ce998a2a16ee9f941d", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -360,8 +360,6 @@ mod uint_macros;\n \n pub mod ascii;\n \n-pub mod thunk;\n-\n /* Common traits */\n \n pub mod num;"}, {"sha": "be224c15ff0864f22d9ac155661cb823ff079087", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -128,26 +128,6 @@ impl TcpStream {\n         self.0.duplicate().map(TcpStream)\n     }\n \n-    /// Sets the nodelay flag on this connection to the boolean specified.\n-    #[deprecated(since = \"1.3.0\",\n-                 reason = \"available through the `net2` crate on crates.io\")]\n-    #[unstable(feature = \"tcp_extras\", reason = \"available externally\")]\n-    pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {\n-        self.0.set_nodelay(nodelay)\n-    }\n-\n-    /// Sets the keepalive timeout to the timeout specified.\n-    ///\n-    /// If the value specified is `None`, then the keepalive flag is cleared on\n-    /// this connection. Otherwise, the keepalive timeout will be set to the\n-    /// specified time, in seconds.\n-    #[unstable(feature = \"tcp_extras\", reason = \"available externally\")]\n-    #[deprecated(since = \"1.3.0\",\n-                 reason = \"available through the `net2` crate on crates.io\")]\n-    pub fn set_keepalive(&self, seconds: Option<u32>) -> io::Result<()> {\n-        self.0.set_keepalive(seconds)\n-    }\n-\n     /// Sets the read timeout to the timeout specified.\n     ///\n     /// If the value specified is `None`, then `read` calls will block"}, {"sha": "20ce344be4fdd5dd011b7621c749a32b7635046f", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 1, "deletions": 51, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -13,7 +13,7 @@\n \n use fmt;\n use io::{self, Error, ErrorKind};\n-use net::{ToSocketAddrs, SocketAddr, IpAddr};\n+use net::{ToSocketAddrs, SocketAddr};\n use sys_common::net as net_imp;\n use sys_common::{AsInner, FromInner, IntoInner};\n use time::Duration;\n@@ -95,56 +95,6 @@ impl UdpSocket {\n         self.0.duplicate().map(UdpSocket)\n     }\n \n-    /// Sets the broadcast flag on or off.\n-    #[deprecated(since = \"1.3.0\",\n-                 reason = \"available through the `net2` crate on crates.io\")]\n-    #[unstable(feature = \"udp_extras\", reason = \"available externally\")]\n-    pub fn set_broadcast(&self, on: bool) -> io::Result<()> {\n-        self.0.set_broadcast(on)\n-    }\n-\n-    /// Sets the multicast loop flag to the specified value.\n-    ///\n-    /// This lets multicast packets loop back to local sockets (if enabled)\n-    #[deprecated(since = \"1.3.0\",\n-                 reason = \"available through the `net2` crate on crates.io\")]\n-    #[unstable(feature = \"udp_extras\", reason = \"available externally\")]\n-    pub fn set_multicast_loop(&self, on: bool) -> io::Result<()> {\n-        self.0.set_multicast_loop(on)\n-    }\n-\n-    /// Joins a multicast IP address (becomes a member of it).\n-    #[deprecated(since = \"1.3.0\",\n-                 reason = \"available through the `net2` crate on crates.io\")]\n-    #[unstable(feature = \"udp_extras\", reason = \"available externally\")]\n-    pub fn join_multicast(&self, multi: &IpAddr) -> io::Result<()> {\n-        self.0.join_multicast(multi)\n-    }\n-\n-    /// Leaves a multicast IP address (drops membership from it).\n-    #[deprecated(since = \"1.3.0\",\n-                 reason = \"available through the `net2` crate on crates.io\")]\n-    #[unstable(feature = \"udp_extras\", reason = \"available externally\")]\n-    pub fn leave_multicast(&self, multi: &IpAddr) -> io::Result<()> {\n-        self.0.leave_multicast(multi)\n-    }\n-\n-    /// Sets the multicast TTL.\n-    #[deprecated(since = \"1.3.0\",\n-                 reason = \"available through the `net2` crate on crates.io\")]\n-    #[unstable(feature = \"udp_extras\", reason = \"available externally\")]\n-    pub fn set_multicast_time_to_live(&self, ttl: i32) -> io::Result<()> {\n-        self.0.multicast_time_to_live(ttl)\n-    }\n-\n-    /// Sets this socket's TTL.\n-    #[deprecated(since = \"1.3.0\",\n-                 reason = \"available through the `net2` crate on crates.io\")]\n-    #[unstable(feature = \"udp_extras\", reason = \"available externally\")]\n-    pub fn set_time_to_live(&self, ttl: i32) -> io::Result<()> {\n-        self.0.time_to_live(ttl)\n-    }\n-\n     /// Sets the read timeout to the timeout specified.\n     ///\n     /// If the value specified is `None`, then `read` calls will block"}, {"sha": "2bc837a231ce68f4da950aa824789dd6d5a2cf2e", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -1751,7 +1751,6 @@ mod tests {\n         use super::consts;\n \n         let pi: f32 = consts::PI;\n-        let two_pi: f32 = consts::PI_2;\n         let frac_pi_2: f32 = consts::FRAC_PI_2;\n         let frac_pi_3: f32 = consts::FRAC_PI_3;\n         let frac_pi_4: f32 = consts::FRAC_PI_4;\n@@ -1768,7 +1767,6 @@ mod tests {\n         let ln_2: f32 = consts::LN_2;\n         let ln_10: f32 = consts::LN_10;\n \n-        assert_approx_eq!(two_pi, 2f32 * pi);\n         assert_approx_eq!(frac_pi_2, pi / 2f32);\n         assert_approx_eq!(frac_pi_3, pi / 3f32);\n         assert_approx_eq!(frac_pi_4, pi / 4f32);"}, {"sha": "c6e2d7380dfeafe990f9ff7c466a4108093f5aad", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -1651,7 +1651,6 @@ mod tests {\n     fn test_real_consts() {\n         use super::consts;\n         let pi: f64 = consts::PI;\n-        let two_pi: f64 = consts::PI_2;\n         let frac_pi_2: f64 = consts::FRAC_PI_2;\n         let frac_pi_3: f64 = consts::FRAC_PI_3;\n         let frac_pi_4: f64 = consts::FRAC_PI_4;\n@@ -1668,7 +1667,6 @@ mod tests {\n         let ln_2: f64 = consts::LN_2;\n         let ln_10: f64 = consts::LN_10;\n \n-        assert_approx_eq!(two_pi, 2.0 * pi);\n         assert_approx_eq!(frac_pi_2, pi / 2f64);\n         assert_approx_eq!(frac_pi_3, pi / 3f64);\n         assert_approx_eq!(frac_pi_4, pi / 4f64);"}, {"sha": "2ace6e4cf8d592463e48a19f0bc5d9f3eafacb6f", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -59,7 +59,6 @@ fn lang_start(main: *const u8, argc: isize, argv: *const *const u8) -> isize {\n     use prelude::v1::*;\n \n     use mem;\n-    use env;\n     use rt;\n     use sys_common::thread_info::{self, NewThread};\n     use thread::Thread;\n@@ -105,9 +104,7 @@ fn lang_start(main: *const u8, argc: isize, argv: *const *const u8) -> isize {\n     if failed {\n         rt::DEFAULT_ERROR_CODE\n     } else {\n-        #[allow(deprecated)]\n-        fn exit_status() -> isize { env::get_exit_status() as isize }\n-        exit_status()\n+        0\n     }\n }\n "}, {"sha": "506b8260278a87416af983f3ddc92dec0a25ced7", "filename": "src/libstd/sync/future.rs", "status": "removed", "additions": 0, "deletions": 231, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/a4066271b77810aec0a4a309f66a45e4f8b940de/src%2Flibstd%2Fsync%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4066271b77810aec0a4a309f66a45e4f8b940de/src%2Flibstd%2Fsync%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ffuture.rs?ref=a4066271b77810aec0a4a309f66a45e4f8b940de", "patch": "@@ -1,231 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! A type representing values that may be computed concurrently and operations\n-//! for working with them.\n-//!\n-//! # Examples\n-//!\n-//! ```\n-//! #![feature(future)]\n-//!\n-//! use std::sync::Future;\n-//!\n-//! // a fake, for now\n-//! fn fib(n: u32) -> u32 { 42 };\n-//!\n-//! let mut delayed_fib = Future::spawn(move || fib(5000));\n-//!\n-//! // do stuff...\n-//!\n-//! println!(\"fib(5000) = {}\", delayed_fib.get())\n-//! ```\n-\n-#![allow(missing_docs)]\n-#![unstable(feature = \"future\",\n-            reason = \"futures as-is have yet to be deeply reevaluated with recent \\\n-                      core changes to Rust's synchronization story, and will likely \\\n-                      become stable in the future but are unstable until that time\")]\n-#![deprecated(since = \"1.2.0\",\n-              reason = \"implementation does not match the quality of the \\\n-                        standard library and this will likely be prototyped \\\n-                        outside in crates.io first\")]\n-#![allow(deprecated)]\n-\n-use core::mem::replace;\n-\n-use boxed::Box;\n-use self::FutureState::*;\n-use sync::mpsc::{Receiver, channel};\n-use thunk::Thunk;\n-use thread;\n-\n-/// A type encapsulating the result of a computation which may not be complete\n-pub struct Future<A> {\n-    state: FutureState<A>,\n-}\n-\n-enum FutureState<A> {\n-    Pending(Thunk<'static,(),A>),\n-    Evaluating,\n-    Forced(A)\n-}\n-\n-/// Methods on the `future` type\n-impl<A:Clone> Future<A> {\n-    pub fn get(&mut self) -> A {\n-        //! Get the value of the future.\n-        (*(self.get_ref())).clone()\n-    }\n-}\n-\n-impl<A> Future<A> {\n-    /// Gets the value from this future, forcing evaluation.\n-    pub fn into_inner(mut self) -> A {\n-        self.get_ref();\n-        let state = replace(&mut self.state, Evaluating);\n-        match state {\n-            Forced(v) => v,\n-            _ => panic!( \"Logic error.\" ),\n-        }\n-    }\n-\n-    pub fn get_ref<'a>(&'a mut self) -> &'a A {\n-        /*!\n-        * Executes the future's closure and then returns a reference\n-        * to the result.  The reference lasts as long as\n-        * the future.\n-        */\n-        match self.state {\n-            Forced(ref v) => return v,\n-            Evaluating => panic!(\"Recursive forcing of future!\"),\n-            Pending(_) => {\n-                match replace(&mut self.state, Evaluating) {\n-                    Forced(_) | Evaluating => panic!(\"Logic error.\"),\n-                    Pending(f) => {\n-                        self.state = Forced(f());\n-                        self.get_ref()\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    pub fn from_value(val: A) -> Future<A> {\n-        /*!\n-         * Create a future from a value.\n-         *\n-         * The value is immediately available and calling `get` later will\n-         * not block.\n-         */\n-\n-        Future {state: Forced(val)}\n-    }\n-\n-    pub fn from_fn<F>(f: F) -> Future<A>\n-        where F : FnOnce() -> A, F : Send + 'static\n-    {\n-        /*!\n-         * Create a future from a function.\n-         *\n-         * The first time that the value is requested it will be retrieved by\n-         * calling the function.  Note that this function is a local\n-         * function. It is not spawned into another task.\n-         */\n-\n-        Future {state: Pending(Box::new(f))}\n-    }\n-}\n-\n-impl<A:Send+'static> Future<A> {\n-    pub fn from_receiver(rx: Receiver<A>) -> Future<A> {\n-        /*!\n-         * Create a future from a port\n-         *\n-         * The first time that the value is requested the task will block\n-         * waiting for the result to be received on the port.\n-         */\n-\n-        Future::from_fn(move || {\n-            rx.recv().unwrap()\n-        })\n-    }\n-\n-    pub fn spawn<F>(blk: F) -> Future<A>\n-        where F : FnOnce() -> A, F : Send + 'static\n-    {\n-        /*!\n-         * Create a future from a unique closure.\n-         *\n-         * The closure will be run in a new task and its result used as the\n-         * value of the future.\n-         */\n-\n-        let (tx, rx) = channel();\n-\n-        thread::spawn(move || {\n-            // Don't panic if the other end has hung up\n-            let _ = tx.send(blk());\n-        });\n-\n-        Future::from_receiver(rx)\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::v1::*;\n-    use sync::mpsc::channel;\n-    use sync::Future;\n-    use thread;\n-\n-    #[test]\n-    fn test_from_value() {\n-        let mut f = Future::from_value(\"snail\".to_string());\n-        assert_eq!(f.get(), \"snail\");\n-    }\n-\n-    #[test]\n-    fn test_from_receiver() {\n-        let (tx, rx) = channel();\n-        tx.send(\"whale\".to_string()).unwrap();\n-        let mut f = Future::from_receiver(rx);\n-        assert_eq!(f.get(), \"whale\");\n-    }\n-\n-    #[test]\n-    fn test_from_fn() {\n-        let mut f = Future::from_fn(move|| \"brail\".to_string());\n-        assert_eq!(f.get(), \"brail\");\n-    }\n-\n-    #[test]\n-    fn test_interface_get() {\n-        let mut f = Future::from_value(\"fail\".to_string());\n-        assert_eq!(f.get(), \"fail\");\n-    }\n-\n-    #[test]\n-    fn test_interface_unwrap() {\n-        let f = Future::from_value(\"fail\".to_string());\n-        assert_eq!(f.into_inner(), \"fail\");\n-    }\n-\n-    #[test]\n-    fn test_get_ref_method() {\n-        let mut f = Future::from_value(22);\n-        assert_eq!(*f.get_ref(), 22);\n-    }\n-\n-    #[test]\n-    fn test_spawn() {\n-        let mut f = Future::spawn(move|| \"bale\".to_string());\n-        assert_eq!(f.get(), \"bale\");\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_future_panic() {\n-        let mut f = Future::spawn(move|| panic!());\n-        let _x: String = f.get();\n-    }\n-\n-    #[test]\n-    fn test_sendable_future() {\n-        let expected = \"schlorf\";\n-        let (tx, rx) = channel();\n-        let f = Future::spawn(move|| { expected });\n-        let _t = thread::spawn(move|| {\n-            let mut f = f;\n-            tx.send(f.get()).unwrap();\n-        });\n-        assert_eq!(rx.recv().unwrap(), expected);\n-    }\n-}"}, {"sha": "28fab5a2c9dd9b5d6324da068897bd627156c828", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -30,14 +30,10 @@ pub use self::rwlock::{RwLockReadGuard, RwLockWriteGuard};\n pub use self::rwlock::{RwLock, StaticRwLock, RW_LOCK_INIT};\n pub use self::semaphore::{Semaphore, SemaphoreGuard};\n \n-#[allow(deprecated)]\n-pub use self::future::Future;\n-\n pub mod mpsc;\n \n mod barrier;\n mod condvar;\n-mod future;\n mod mutex;\n mod once;\n mod rwlock;"}, {"sha": "68d5f49dffac41a4185348de6c3b923c678a348f", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 0, "deletions": 95, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -186,42 +186,6 @@ impl TcpStream {\n \n     pub fn into_socket(self) -> Socket { self.inner }\n \n-    pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {\n-        setsockopt(&self.inner, libc::IPPROTO_TCP, libc::TCP_NODELAY,\n-                   nodelay as c_int)\n-    }\n-\n-    pub fn set_keepalive(&self, seconds: Option<u32>) -> io::Result<()> {\n-        let ret = setsockopt(&self.inner, libc::SOL_SOCKET, libc::SO_KEEPALIVE,\n-                             seconds.is_some() as c_int);\n-        match seconds {\n-            Some(n) => ret.and_then(|()| self.set_tcp_keepalive(n)),\n-            None => ret,\n-        }\n-    }\n-\n-    #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-    fn set_tcp_keepalive(&self, seconds: u32) -> io::Result<()> {\n-        setsockopt(&self.inner, libc::IPPROTO_TCP, libc::TCP_KEEPALIVE,\n-                   seconds as c_int)\n-    }\n-    #[cfg(any(target_os = \"freebsd\",\n-              target_os = \"dragonfly\",\n-              target_os = \"linux\"))]\n-    fn set_tcp_keepalive(&self, seconds: u32) -> io::Result<()> {\n-        setsockopt(&self.inner, libc::IPPROTO_TCP, libc::TCP_KEEPIDLE,\n-                   seconds as c_int)\n-    }\n-\n-    #[cfg(not(any(target_os = \"macos\",\n-                  target_os = \"ios\",\n-                  target_os = \"freebsd\",\n-                  target_os = \"dragonfly\",\n-                  target_os = \"linux\")))]\n-    fn set_tcp_keepalive(&self, _seconds: u32) -> io::Result<()> {\n-        Ok(())\n-    }\n-\n     pub fn set_read_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n         self.inner.set_timeout(dur, libc::SO_RCVTIMEO)\n     }\n@@ -431,65 +395,6 @@ impl UdpSocket {\n         Ok(ret as usize)\n     }\n \n-    pub fn set_broadcast(&self, on: bool) -> io::Result<()> {\n-        setsockopt(&self.inner, libc::SOL_SOCKET, libc::SO_BROADCAST,\n-                   on as c_int)\n-    }\n-\n-    pub fn set_multicast_loop(&self, on: bool) -> io::Result<()> {\n-        setsockopt(&self.inner, libc::IPPROTO_IP,\n-                   libc::IP_MULTICAST_LOOP, on as c_int)\n-    }\n-\n-    pub fn join_multicast(&self, multi: &IpAddr) -> io::Result<()> {\n-        match *multi {\n-            IpAddr::V4(..) => {\n-                self.set_membership(multi, libc::IP_ADD_MEMBERSHIP)\n-            }\n-            IpAddr::V6(..) => {\n-                self.set_membership(multi, libc::IPV6_ADD_MEMBERSHIP)\n-            }\n-        }\n-    }\n-    pub fn leave_multicast(&self, multi: &IpAddr) -> io::Result<()> {\n-        match *multi {\n-            IpAddr::V4(..) => {\n-                self.set_membership(multi, libc::IP_DROP_MEMBERSHIP)\n-            }\n-            IpAddr::V6(..) => {\n-                self.set_membership(multi, libc::IPV6_DROP_MEMBERSHIP)\n-            }\n-        }\n-    }\n-    fn set_membership(&self, addr: &IpAddr, opt: c_int) -> io::Result<()> {\n-        match *addr {\n-            IpAddr::V4(ref addr) => {\n-                let mreq = libc::ip_mreq {\n-                    imr_multiaddr: *addr.as_inner(),\n-                    // interface == INADDR_ANY\n-                    imr_interface: libc::in_addr { s_addr: 0x0 },\n-                };\n-                setsockopt(&self.inner, libc::IPPROTO_IP, opt, mreq)\n-            }\n-            IpAddr::V6(ref addr) => {\n-                let mreq = libc::ip6_mreq {\n-                    ipv6mr_multiaddr: *addr.as_inner(),\n-                    ipv6mr_interface: 0,\n-                };\n-                setsockopt(&self.inner, libc::IPPROTO_IPV6, opt, mreq)\n-            }\n-        }\n-    }\n-\n-    pub fn multicast_time_to_live(&self, ttl: i32) -> io::Result<()> {\n-        setsockopt(&self.inner, libc::IPPROTO_IP, libc::IP_MULTICAST_TTL,\n-                   ttl as c_int)\n-    }\n-\n-    pub fn time_to_live(&self, ttl: i32) -> io::Result<()> {\n-        setsockopt(&self.inner, libc::IPPROTO_IP, libc::IP_TTL, ttl as c_int)\n-    }\n-\n     pub fn duplicate(&self) -> io::Result<UdpSocket> {\n         self.inner.duplicate().map(|s| UdpSocket { inner: s })\n     }"}, {"sha": "1676fe8220ab324a465841089a282a8fbfaf273b", "filename": "src/libstd/sys/common/remutex.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Fsys%2Fcommon%2Fremutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Fsys%2Fcommon%2Fremutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fremutex.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -187,31 +187,31 @@ mod tests {\n \n     #[test]\n     fn is_mutex() {\n-        let m = ReentrantMutex::new(RefCell::new(0));\n+        let m = Arc::new(ReentrantMutex::new(RefCell::new(0)));\n+        let m2 = m.clone();\n         let lock = m.lock().unwrap();\n-        let handle = thread::scoped(|| {\n-            let lock = m.lock().unwrap();\n+        let child = thread::spawn(move || {\n+            let lock = m2.lock().unwrap();\n             assert_eq!(*lock.borrow(), 4950);\n         });\n         for i in 0..100 {\n             let lock = m.lock().unwrap();\n             *lock.borrow_mut() += i;\n         }\n         drop(lock);\n-        drop(handle);\n+        child.join().unwrap();\n     }\n \n     #[test]\n     fn trylock_works() {\n-        let m = ReentrantMutex::new(());\n+        let m = Arc::new(ReentrantMutex::new(()));\n+        let m2 = m.clone();\n         let lock = m.try_lock().unwrap();\n         let lock2 = m.try_lock().unwrap();\n-        {\n-            thread::scoped(|| {\n-                let lock = m.try_lock();\n-                assert!(lock.is_err());\n-            });\n-        }\n+        thread::spawn(move || {\n+            let lock = m2.try_lock();\n+            assert!(lock.is_err());\n+        }).join().unwrap();\n         let lock3 = m.try_lock().unwrap();\n     }\n "}, {"sha": "751b8e482631b438e0fced53f000bfd896639039", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -509,13 +509,6 @@ pub fn lstat(p: &Path) -> io::Result<FileAttr> {\n     Ok(FileAttr { stat: stat })\n }\n \n-pub fn utimes(p: &Path, atime: u64, mtime: u64) -> io::Result<()> {\n-    let p = try!(cstr(p));\n-    let buf = [super::ms_to_timeval(atime), super::ms_to_timeval(mtime)];\n-    try!(cvt(unsafe { c::utimes(p.as_ptr(), buf.as_ptr()) }));\n-    Ok(())\n-}\n-\n pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {\n     let path = try!(CString::new(p.as_os_str().as_bytes()));\n     let mut buf = vec![0u8; 16 * 1024];"}, {"sha": "bbed42cc31d75339a114b76720293e1d16b0f003", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -82,7 +82,6 @@ pub fn cvt<T: One + PartialEq + Neg<Output=T>>(t: T) -> io::Result<T> {\n     }\n }\n \n-#[allow(deprecated)]\n pub fn cvt_r<T, F>(mut f: F) -> io::Result<T>\n     where T: One + PartialEq + Neg<Output=T>, F: FnMut() -> T\n {\n@@ -93,10 +92,3 @@ pub fn cvt_r<T, F>(mut f: F) -> io::Result<T>\n         }\n     }\n }\n-\n-pub fn ms_to_timeval(ms: u64) -> libc::timeval {\n-    libc::timeval {\n-        tv_sec: (ms / 1000) as libc::time_t,\n-        tv_usec: ((ms % 1000) * 1000) as libc::suseconds_t,\n-    }\n-}"}, {"sha": "d413d536cc85be5708a829a34ca42a76dce8fade", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -571,19 +571,6 @@ pub fn set_perm(p: &Path, perm: FilePermissions) -> io::Result<()> {\n     }\n }\n \n-pub fn utimes(p: &Path, atime: u64, mtime: u64) -> io::Result<()> {\n-    let atime = super::ms_to_filetime(atime);\n-    let mtime = super::ms_to_filetime(mtime);\n-\n-    let mut o = OpenOptions::new();\n-    o.write(true);\n-    let f = try!(File::open(p, &o));\n-    try!(cvt(unsafe {\n-        c::SetFileTime(f.handle.raw(), 0 as *const _, &atime, &mtime)\n-    }));\n-    Ok(())\n-}\n-\n fn get_path(f: &File) -> io::Result<PathBuf> {\n     super::fill_utf16_buf(|buf, sz| unsafe {\n         c::GetFinalPathNameByHandleW(f.handle.raw(), buf, sz,"}, {"sha": "732e2e65864fd2a73fe521e626ea3c576a4e3851", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -174,13 +174,3 @@ fn dur2timeout(dur: Duration) -> libc::DWORD {\n         }\n     }).unwrap_or(libc::INFINITE)\n }\n-\n-fn ms_to_filetime(ms: u64) -> libc::FILETIME {\n-    // A FILETIME is a count of 100 nanosecond intervals, so we multiply by\n-    // 10000 b/c there are 10000 intervals in 1 ms\n-    let ms = ms * 10000;\n-    libc::FILETIME {\n-        dwLowDateTime: ms as u32,\n-        dwHighDateTime: (ms >> 32) as u32,\n-    }\n-}"}, {"sha": "57e84b0c46c58d0be9d32686b1280749dc79bbb5", "filename": "src/libstd/sys/windows/net.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -67,7 +67,6 @@ pub fn cvt_gai(err: c_int) -> io::Result<()> {\n }\n \n /// Provides the functionality of `cvt` for a closure.\n-#[allow(deprecated)]\n pub fn cvt_r<T, F>(mut f: F) -> io::Result<T>\n     where F: FnMut() -> T, T: One + Neg<Output=T> + PartialEq\n {"}, {"sha": "3e640ceaddddd58b29f6ed663f7957993a051ac9", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -21,7 +21,6 @@ use fmt;\n use io;\n use libc::types::os::arch::extra::LPWCH;\n use libc::{self, c_int, c_void};\n-use mem;\n use ops::Range;\n use os::windows::ffi::EncodeWide;\n use path::{self, PathBuf};\n@@ -334,14 +333,6 @@ pub fn args() -> Args {\n     }\n }\n \n-pub fn page_size() -> usize {\n-    unsafe {\n-        let mut info = mem::zeroed();\n-        libc::GetSystemInfo(&mut info);\n-        return info.dwPageSize as usize;\n-    }\n-}\n-\n pub fn temp_dir() -> PathBuf {\n     super::fill_utf16_buf(|buf, sz| unsafe {\n         c::GetTempPathW(sz, buf)"}, {"sha": "3435a1fccdfaaf4be4df45cbd58fd94e179a4fc8", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 4, "deletions": 106, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -253,36 +253,6 @@ impl Builder {\n         }\n     }\n \n-    /// Spawns a new child thread that must be joined within a given\n-    /// scope, and returns a `JoinGuard`.\n-    ///\n-    /// The join guard can be used to explicitly join the child thread (via\n-    /// `join`), returning `Result<T>`, or it will implicitly join the child\n-    /// upon being dropped. Because the child thread may refer to data on the\n-    /// current thread's stack (hence the \"scoped\" name), it cannot be detached;\n-    /// it *must* be joined before the relevant stack frame is popped. See the\n-    /// documentation on `thread::scoped` for additional details.\n-    ///\n-    /// # Errors\n-    ///\n-    /// Unlike the `scoped` free function, this method yields an\n-    /// `io::Result` to capture any failure to create the thread at\n-    /// the OS level.\n-    #[unstable(feature = \"scoped\",\n-               reason = \"memory unsafe if destructor is avoided, see #24292\")]\n-    #[deprecated(since = \"1.2.0\",\n-                 reason = \"this unsafe API is unlikely to ever be stabilized \\\n-                           in this form\")]\n-    pub fn scoped<'a, T, F>(self, f: F) -> io::Result<JoinGuard<'a, T>> where\n-        T: Send + 'a, F: FnOnce() -> T, F: Send + 'a\n-    {\n-        unsafe {\n-            self.spawn_inner(Box::new(f)).map(|inner| {\n-                JoinGuard { inner: inner, _marker: PhantomData }\n-            })\n-        }\n-    }\n-\n     // NB: this function is unsafe as the lifetime parameter of the code to run\n     //     in the new thread is not tied into the return value, and the return\n     //     value must not outlast that lifetime.\n@@ -346,50 +316,6 @@ pub fn spawn<F, T>(f: F) -> JoinHandle<T> where\n     Builder::new().spawn(f).unwrap()\n }\n \n-/// Spawns a new *scoped* thread, returning a `JoinGuard` for it.\n-///\n-/// The `spawn` method does not allow the child and parent threads to\n-/// share any stack data, since that is not safe in general. However,\n-/// `scoped` makes it possible to share the parent's stack by forcing\n-/// a join before any relevant stack frames are popped:\n-///\n-/// ```rust\n-/// #![feature(scoped)]\n-///\n-/// use std::thread;\n-///\n-/// let guard = thread::scoped(move || {\n-///     // some work here\n-/// });\n-///\n-/// // do some other work in the meantime\n-/// let output = guard.join();\n-/// ```\n-///\n-/// The `scoped` function doesn't return a `Thread` directly; instead, it\n-/// returns a *join guard*. The join guard can be used to explicitly join\n-/// the child thread (via `join`), returning `Result<T>`, or it will\n-/// implicitly join the child upon being dropped. Because the child thread\n-/// may refer to data on the current thread's stack (hence the \"scoped\"\n-/// name), it cannot be detached; it *must* be joined before the relevant\n-/// stack frame is popped.\n-///\n-/// # Panics\n-///\n-/// Panics if the OS fails to create a thread; use `Builder::scoped`\n-/// to recover from such errors.\n-#[unstable(feature = \"scoped\",\n-           reason = \"memory unsafe if destructor is avoided, see #24292\")]\n-#[deprecated(since = \"1.2.0\",\n-             reason = \"this unsafe API is unlikely to ever be stabilized \\\n-                       in this form\")]\n-#[allow(deprecated)]\n-pub fn scoped<'a, T, F>(f: F) -> JoinGuard<'a, T> where\n-    T: Send + 'a, F: FnOnce() -> T, F: Send + 'a\n-{\n-    Builder::new().scoped(f).unwrap()\n-}\n-\n /// Gets a handle to the thread that invokes it.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn current() -> Thread {\n@@ -769,7 +695,6 @@ mod tests {\n     use result;\n     use super::{Builder};\n     use thread;\n-    use thunk::Thunk;\n     use time::Duration;\n     use u32;\n \n@@ -785,9 +710,9 @@ mod tests {\n \n     #[test]\n     fn test_named_thread() {\n-        Builder::new().name(\"ada lovelace\".to_string()).scoped(move|| {\n+        Builder::new().name(\"ada lovelace\".to_string()).spawn(move|| {\n             assert!(thread::current().name().unwrap() == \"ada lovelace\".to_string());\n-        }).unwrap().join();\n+        }).unwrap().join().unwrap();\n     }\n \n     #[test]\n@@ -799,13 +724,6 @@ mod tests {\n         rx.recv().unwrap();\n     }\n \n-    #[test]\n-    fn test_join_success() {\n-        assert!(thread::scoped(move|| -> String {\n-            \"Success!\".to_string()\n-        }).join() == \"Success!\");\n-    }\n-\n     #[test]\n     fn test_join_panic() {\n         match thread::spawn(move|| {\n@@ -816,26 +734,6 @@ mod tests {\n         }\n     }\n \n-    #[test]\n-    fn test_scoped_success() {\n-        let res = thread::scoped(move|| -> String {\n-            \"Success!\".to_string()\n-        }).join();\n-        assert!(res == \"Success!\");\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_scoped_panic() {\n-        thread::scoped(|| panic!()).join();\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_scoped_implicit_panic() {\n-        let _ = thread::scoped(|| panic!());\n-    }\n-\n     #[test]\n     fn test_spawn_sched() {\n         use clone::Clone;\n@@ -870,7 +768,7 @@ mod tests {\n         rx.recv().unwrap();\n     }\n \n-    fn avoid_copying_the_body<F>(spawnfn: F) where F: FnOnce(Thunk<'static>) {\n+    fn avoid_copying_the_body<F>(spawnfn: F) where F: FnOnce(Box<Fn() + Send>) {\n         let (tx, rx) = channel();\n \n         let x: Box<_> = box 1;\n@@ -917,7 +815,7 @@ mod tests {\n         // (well, it would if the constant were 8000+ - I lowered it to be more\n         // valgrind-friendly. try this at home, instead..!)\n         const GENERATIONS: u32 = 16;\n-        fn child_no(x: u32) -> Thunk<'static> {\n+        fn child_no(x: u32) -> Box<Fn() + Send> {\n             return Box::new(move|| {\n                 if x < GENERATIONS {\n                     thread::spawn(move|| child_no(x+1)());"}, {"sha": "f1dc91f135fe5a60060faeaa116504c2100ec58a", "filename": "src/libstd/thunk.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a4066271b77810aec0a4a309f66a45e4f8b940de/src%2Flibstd%2Fthunk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4066271b77810aec0a4a309f66a45e4f8b940de/src%2Flibstd%2Fthunk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthunk.rs?ref=a4066271b77810aec0a4a309f66a45e4f8b940de", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Because this module is temporary...\n-#![allow(missing_docs)]\n-#![unstable(feature = \"thunk\")]\n-#![deprecated(since = \"1.2.0\", reason = \"use FnBox instead\")]\n-\n-use alloc::boxed::{Box, FnBox};\n-use core::marker::Send;\n-\n-pub type Thunk<'a, A=(), R=()> =\n-    Box<FnBox<A,Output=R> + Send + 'a>;\n-"}, {"sha": "d16fa83c2afe4c0ed36e427141845ca3f880602c", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -92,30 +92,13 @@ impl Duration {\n     #[stable(feature = \"duration\", since = \"1.3.0\")]\n     pub fn as_secs(&self) -> u64 { self.secs }\n \n-    #[deprecated(reason = \"renamed to `as_secs`\", since = \"1.3.0\")]\n-    #[unstable(feature = \"duration_deprecated\")]\n-    /// Returns the number of whole seconds represented by this duration.\n-    ///\n-    /// The extra precision represented by this duration is ignored (e.g. extra\n-    /// nanoseconds are not represented in the returned value).\n-    pub fn secs(&self) -> u64 { self.as_secs() }\n-\n     /// Returns the nanosecond precision represented by this duration.\n     ///\n     /// This method does **not** return the length of the duration when\n     /// represented by nanoseconds. The returned number always represents a\n     /// fractional portion of a second (e.g. it is less than one billion).\n     #[stable(feature = \"duration\", since = \"1.3.0\")]\n     pub fn subsec_nanos(&self) -> u32 { self.nanos }\n-\n-    #[deprecated(reason = \"renamed to `subsec_nanos`\", since = \"1.3.0\")]\n-    #[unstable(feature = \"duration_deprecated\")]\n-    /// Returns the nanosecond precision represented by this duration.\n-    ///\n-    /// This method does **not** return the length of the duration when\n-    /// represented by nanoseconds. The returned number always represents a\n-    /// fractional portion of a second (e.g. it is less than one billion).\n-    pub fn extra_nanos(&self) -> u32 { self.subsec_nanos() }\n }\n \n impl Add for Duration {"}, {"sha": "399a529af155bba5269aba5bf3889d7cd87b50b3", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -10,9 +10,6 @@\n \n // Functions dealing with attributes and meta items\n \n-// BitSet\n-#![allow(deprecated)]\n-\n pub use self::StabilityLevel::*;\n pub use self::ReprAttr::*;\n pub use self::IntType::*;\n@@ -28,20 +25,33 @@ use parse::token;\n use ptr::P;\n \n use std::cell::{RefCell, Cell};\n-use std::collections::BitSet;\n use std::collections::HashSet;\n use std::fmt;\n \n-thread_local! { static USED_ATTRS: RefCell<BitSet> = RefCell::new(BitSet::new()) }\n+thread_local! {\n+    static USED_ATTRS: RefCell<Vec<u64>> = RefCell::new(Vec::new())\n+}\n \n pub fn mark_used(attr: &Attribute) {\n     let AttrId(id) = attr.node.id;\n-    USED_ATTRS.with(|slot| slot.borrow_mut().insert(id));\n+    USED_ATTRS.with(|slot| {\n+        let idx = (id / 64) as usize;\n+        let shift = id % 64;\n+        if slot.borrow().len() <= idx {\n+            slot.borrow_mut().resize(idx + 1, 0);\n+        }\n+        slot.borrow_mut()[idx] |= 1 << shift;\n+    });\n }\n \n pub fn is_used(attr: &Attribute) -> bool {\n     let AttrId(id) = attr.node.id;\n-    USED_ATTRS.with(|slot| slot.borrow().contains(&id))\n+    USED_ATTRS.with(|slot| {\n+        let idx = (id / 64) as usize;\n+        let shift = id % 64;\n+        slot.borrow().get(idx).map(|bits| bits & (1 << shift) != 0)\n+            .unwrap_or(false)\n+    })\n }\n \n pub trait AttrMetaMethods {"}, {"sha": "290efb151957e7564302980f1a7c790f7f70c021", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -26,7 +26,6 @@\n        html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n #![feature(associated_consts)]\n-#![feature(bitset)]\n #![feature(drain)]\n #![feature(filling_drop)]\n #![feature(libc)]\n@@ -38,6 +37,7 @@\n #![feature(str_escape)]\n #![feature(unicode)]\n #![feature(vec_push_all)]\n+#![feature(vec_resize)]\n \n extern crate fmt_macros;\n extern crate serialize;"}, {"sha": "28ae990e05a2de508f5a2847d3b7fed986e8d273", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -17,7 +17,6 @@ extern crate collections;\n extern crate rand;\n \n use std::collections::BTreeSet;\n-use std::collections::BitSet;\n use std::collections::HashSet;\n use std::hash::Hash;\n use std::env;\n@@ -53,11 +52,6 @@ impl<T: Ord> MutableSet<T> for BTreeSet<T> {\n     fn remove(&mut self, k: &T) -> bool { self.remove(k) }\n     fn contains(&self, k: &T) -> bool { self.contains(k) }\n }\n-impl MutableSet<usize> for BitSet {\n-    fn insert(&mut self, k: usize) { self.insert(k); }\n-    fn remove(&mut self, k: &usize) -> bool { self.remove(k) }\n-    fn contains(&self, k: &usize) -> bool { self.contains(k) }\n-}\n \n impl Results {\n     pub fn bench_int<T:MutableSet<usize>,\n@@ -218,11 +212,4 @@ fn main() {\n         });\n         write_results(\"collections::BTreeSet\", &results);\n     }\n-\n-    {\n-        let mut rng: rand::IsaacRng = rand::SeedableRng::from_seed(seed);\n-        let mut results = empty_results();\n-        results.bench_int(&mut rng, num_keys, max, || BitSet::new());\n-        write_results(\"collections::bit_vec::BitSet\", &results);\n-    }\n }"}, {"sha": "843f49d8f0534a900559c7d94dfab1a17f4db347", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -17,11 +17,12 @@\n \n // no-pretty-expanded FIXME #15189\n \n-#![feature(duration, duration_span, future)]\n+#![feature(duration_span)]\n \n use std::env;\n-use std::sync::{Arc, Future, Mutex, Condvar};\n+use std::sync::{Arc, Mutex, Condvar};\n use std::time::Duration;\n+use std::thread;\n \n // A poor man's pipe.\n type pipe = Arc<(Mutex<Vec<usize>>, Condvar)>;\n@@ -89,7 +90,7 @@ fn main() {\n             //println!(\"spawning %?\", i);\n             let (new_chan, num_port) = init();\n             let num_chan_2 = num_chan.clone();\n-            let new_future = Future::spawn(move|| {\n+            let new_future = thread::spawn(move|| {\n                 thread_ring(i, msg_per_task, num_chan_2, num_port)\n             });\n             futures.push(new_future);\n@@ -100,8 +101,8 @@ fn main() {\n         thread_ring(0, msg_per_task, num_chan, num_port);\n \n         // synchronize\n-        for f in &mut futures {\n-            f.get()\n+        for f in futures {\n+            f.join().unwrap()\n         }\n     });\n "}, {"sha": "175ab5badb639099986b3ddab861ea1c05db94be", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -40,9 +40,7 @@\n \n // ignore-android: FIXME(#10393) hangs without output\n \n-#![feature(box_syntax, owned_ascii_ext, vec_push_all)]\n-\n-use std::ascii::OwnedAsciiExt;\n+use std::ascii::AsciiExt;\n use std::env;\n use std::fs::File;\n use std::io::prelude::*;\n@@ -146,11 +144,11 @@ impl Table {\n     fn search_remainder<C:TableCallback>(item: &mut Entry, key: Code, c: C) {\n         match item.next {\n             None => {\n-                let mut entry: Box<_> = box Entry {\n+                let mut entry = Box::new(Entry {\n                     code: key,\n                     count: 0,\n                     next: None,\n-                };\n+                });\n                 c.f(&mut *entry);\n                 item.next = Some(entry);\n             }\n@@ -170,11 +168,11 @@ impl Table {\n \n         {\n             if self.items[index as usize].is_none() {\n-                let mut entry: Box<_> = box Entry {\n+                let mut entry = Box::new(Entry {\n                     code: key,\n                     count: 0,\n                     next: None,\n-                };\n+                });\n                 c.f(&mut *entry);\n                 self.items[index as usize] = Some(entry);\n                 return;\n@@ -285,13 +283,16 @@ fn print_occurrences(frequencies: &mut Table, occurrence: &'static str) {\n }\n \n fn get_sequence<R: BufRead>(r: &mut R, key: &str) -> Vec<u8> {\n-    let mut res = Vec::new();\n+    let mut res = Vec::<u8>::new();\n     for l in r.lines().map(|l| l.unwrap())\n         .skip_while(|l| key != &l[..key.len()]).skip(1)\n     {\n-        res.push_all(l.trim().as_bytes());\n+        res.extend(l.trim().as_bytes());\n+    }\n+    for s in &mut res {\n+        *s = s.to_ascii_uppercase();\n     }\n-    res.into_ascii_uppercase()\n+    return res\n }\n \n fn main() {"}, {"sha": "3a0d182ab122164cc24d0ae599f3a8727810fadd", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -40,7 +40,7 @@\n \n // ignore-android: FIXME(#10393) hangs without output\n \n-#![feature(libc, scoped)]\n+#![feature(libc)]\n \n extern crate libc;\n \n@@ -195,11 +195,12 @@ fn reverse_complement(seq: &mut [u8], tables: &Tables) {\n \n /// Executes a closure in parallel over the given iterator over mutable slice.\n /// The closure `f` is run in parallel with an element of `iter`.\n+// FIXME: replace with thread::scoped when it exists again\n fn parallel<I: Iterator, F>(iter: I, ref f: F)\n         where I::Item: Send,\n               F: Fn(I::Item) + Sync, {\n     iter.map(|x| {\n-        thread::scoped(move || f(x))\n+        f(x)\n     }).collect::<Vec<_>>();\n }\n "}, {"sha": "b3591477022821c57e6741cdda1d551cf17d2d10", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -114,11 +114,10 @@ fn parallel<'a,T, F>(v: &mut [T], ref f: F)\n                   where T: Send + Sync + 'a,\n                         F: Fn(usize, &mut [T]) + Sync + 'a {\n     // FIXME: pick a more appropriate parallel factor\n+    // FIXME: replace with thread::scoped when it exists again\n     let parallelism = 4;\n     let size = v.len() / parallelism + 1;\n     v.chunks_mut(size).enumerate().map(|(i, chunk)| {\n-        thread::scoped(move|| {\n-            f(i * size, chunk)\n-        })\n+        f(i * size, chunk)\n     }).collect::<Vec<_>>();\n }"}, {"sha": "64f2381d1c35d2a4ff9fcdde0b87be63ff94e536", "filename": "src/test/bench/std-smallintmap.rs", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/a4066271b77810aec0a4a309f66a45e4f8b940de/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4066271b77810aec0a4a309f66a45e4f8b940de/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fstd-smallintmap.rs?ref=a4066271b77810aec0a4a309f66a45e4f8b940de", "patch": "@@ -1,61 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Microbenchmark for the smallintmap library\n-\n-#![feature(vecmap, duration, duration_span)]\n-\n-use std::collections::VecMap;\n-use std::env;\n-use std::time::Duration;\n-\n-fn append_sequential(min: usize, max: usize, map: &mut VecMap<usize>) {\n-    for i in min..max {\n-        map.insert(i, i + 22);\n-    }\n-}\n-\n-fn check_sequential(min: usize, max: usize, map: &VecMap<usize>) {\n-    for i in min..max {\n-        assert_eq!(map[i], i + 22);\n-    }\n-}\n-\n-fn main() {\n-    let args = env::args();\n-    let args = if env::var_os(\"RUST_BENCH\").is_some() {\n-        vec!(\"\".to_string(), \"100000\".to_string(), \"100\".to_string())\n-    } else if args.len() <= 1 {\n-        vec!(\"\".to_string(), \"10000\".to_string(), \"50\".to_string())\n-    } else {\n-        args.collect()\n-    };\n-    let max = args[1].parse::<usize>().unwrap();\n-    let rep = args[2].parse::<usize>().unwrap();\n-\n-    let mut checkf = Duration::new(0, 0);\n-    let mut appendf = Duration::new(0, 0);\n-\n-    for _ in 0..rep {\n-        let mut map = VecMap::new();\n-        let d1 = Duration::span(|| append_sequential(0, max, &mut map));\n-        let d2 = Duration::span(|| check_sequential(0, max, &map));\n-\n-        checkf = checkf + d2;\n-        appendf = appendf + d1;\n-    }\n-\n-    let maxf = max as f64;\n-\n-    println!(\"insert(): {:?} seconds\\n\", checkf);\n-    println!(\"        : {} op/s\\n\", maxf / checkf.as_secs() as f64);\n-    println!(\"get()   : {:?} seconds\\n\", appendf);\n-    println!(\"        : {} op/s\\n\", maxf / appendf.as_secs() as f64);\n-}"}, {"sha": "8b83b945fd148430a3d86f64c23fc3372d4d6a3c", "filename": "src/test/compile-fail/borrowck-move-out-of-static-item.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-static-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-static-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-static-item.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -10,14 +10,11 @@\n \n // Ensure that moves out of static items is forbidden\n \n-use std::marker;\n-\n struct Foo {\n     foo: isize,\n-    nocopy: marker::NoCopy\n }\n \n-static BAR: Foo = Foo{foo: 5, nocopy: marker::NoCopy};\n+static BAR: Foo = Foo { foo: 5 };\n \n \n fn test(f: Foo) {"}, {"sha": "bf1497420e2a7028d866c51d79fb1fb77440ea70", "filename": "src/test/compile-fail/borrowck-struct-update-with-dtor.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Fcompile-fail%2Fborrowck-struct-update-with-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Fcompile-fail%2Fborrowck-struct-update-with-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-struct-update-with-dtor.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -11,11 +11,8 @@\n // Issue 4691: Ensure that functional-struct-update can only copy, not\n // move, when the struct implements Drop.\n \n-// NoCopy\n-use std::marker::NoCopy as NP;\n-\n-\n-struct S { a: isize, np: NP }\n+struct B;\n+struct S { a: isize, b: B }\n impl Drop for S { fn drop(&mut self) { } }\n \n struct T { a: isize, mv: Box<isize> }"}, {"sha": "6a5bde365b42978b5fb1cd1669451298a985f71d", "filename": "src/test/compile-fail/future_not_copyable.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a4066271b77810aec0a4a309f66a45e4f8b940de/src%2Ftest%2Fcompile-fail%2Ffuture_not_copyable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4066271b77810aec0a4a309f66a45e4f8b940de/src%2Ftest%2Fcompile-fail%2Ffuture_not_copyable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffuture_not_copyable.rs?ref=a4066271b77810aec0a4a309f66a45e4f8b940de", "patch": "@@ -1,17 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::sync::Future;\n-\n-fn main() {\n-    let f = Future::from_value(());\n-    let g = f;\n-    f.into_inner(); //~ ERROR use of moved value\n-}"}, {"sha": "14128a0e6f7ec94591e42b3a247167bf318512f3", "filename": "src/test/compile-fail/issue-13352.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Fcompile-fail%2Fissue-13352.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Fcompile-fail%2Fissue-13352.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13352.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -10,17 +10,11 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(std_misc, libc)]\n-\n-extern crate libc;\n-\n-use std::thunk::Thunk;\n-\n-fn foo(_: Thunk) {}\n+fn foo(_: Box<FnMut()>) {}\n \n fn main() {\n     foo(loop {\n-        unsafe { libc::exit(0 as libc::c_int); }\n+        std::process::exit(0);\n     });\n     2_usize + (loop {});\n     //~^ ERROR E0277"}, {"sha": "a5a7117956f4a5d6c9a4f797dc5a9b828061e0ff", "filename": "src/test/compile-fail/issue-17718-static-move.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Fcompile-fail%2Fissue-17718-static-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Fcompile-fail%2Fissue-17718-static-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17718-static-move.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -8,10 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::marker;\n-\n-struct Foo { nc: marker::NoCopy }\n-const INIT: Foo = Foo { nc: marker::NoCopy };\n+struct Foo;\n+const INIT: Foo = Foo;\n static FOO: Foo = INIT;\n \n fn main() {"}, {"sha": "d9e139cc9db71d86b6715fb61f67034dfc9679f0", "filename": "src/test/compile-fail/marker-no-copy.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a4066271b77810aec0a4a309f66a45e4f8b940de/src%2Ftest%2Fcompile-fail%2Fmarker-no-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4066271b77810aec0a4a309f66a45e4f8b940de/src%2Ftest%2Fcompile-fail%2Fmarker-no-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmarker-no-copy.rs?ref=a4066271b77810aec0a4a309f66a45e4f8b940de", "patch": "@@ -1,18 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::marker;\n-\n-fn foo<P:Copy>(p: P) { }\n-\n-fn main()\n-{\n-    foo(marker::NoCopy); //~ ERROR the trait `core::marker::Copy` is not implemented\n-}"}, {"sha": "2e401ba6e9085929d1621640eee1214b74798667", "filename": "src/test/compile-fail/send-is-not-static-ensures-scoping.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Fcompile-fail%2Fsend-is-not-static-ensures-scoping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Fcompile-fail%2Fsend-is-not-static-ensures-scoping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsend-is-not-static-ensures-scoping.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -8,14 +8,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::thread;\n+struct Guard<'a> {\n+    f: Box<Fn() + Send + 'a>,\n+}\n+\n+fn scoped<'a, F: Fn() + Send + 'a>(f: F) -> Guard<'a> {\n+    Guard { f: Box::new(f) }\n+}\n+\n+impl<'a> Guard<'a> {\n+    fn join(self) {}\n+}\n \n fn main() {\n     let bad = {\n         let x = 1;\n         let y = &x; //~ ERROR `x` does not live long enough\n \n-        thread::scoped(|| {\n+        scoped(|| {\n             //~^ ERROR `y` does not live long enough\n             let _z = y;\n         })"}, {"sha": "c8fddeb12141dffe2d6223a5383f49efbcfa0a08", "filename": "src/test/compile-fail/static-items-cant-move.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Fcompile-fail%2Fstatic-items-cant-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Fcompile-fail%2Fstatic-items-cant-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-items-cant-move.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -10,14 +10,14 @@\n \n // Verifies that static items can't be moved\n \n-use std::marker;\n+struct B;\n \n struct Foo {\n     foo: isize,\n-    nocopy: marker::NoCopy\n+    b: B,\n }\n \n-static BAR: Foo = Foo{foo: 5, nocopy: marker::NoCopy};\n+static BAR: Foo = Foo { foo: 5, b: B };\n \n \n fn test(f: Foo) {"}, {"sha": "249e2e1ac2d64938594f638ccbc8186a405e1bfd", "filename": "src/test/run-fail/rt-set-exit-status-panic.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a4066271b77810aec0a4a309f66a45e4f8b940de/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4066271b77810aec0a4a309f66a45e4f8b940de/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic.rs?ref=a4066271b77810aec0a4a309f66a45e4f8b940de", "patch": "@@ -1,25 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:whatever\n-\n-#![feature(exit_status, rustc_private)]\n-\n-#[macro_use] extern crate log;\n-use std::env;\n-\n-fn main() {\n-    error!(\"whatever\");\n-    // Setting the exit status only works when the scheduler terminates\n-    // normally. In this case we're going to panic, so instead of\n-    // returning 50 the process will return the typical rt failure code.\n-    env::set_exit_status(50);\n-    panic!();\n-}"}, {"sha": "b4f0d7ceb99eb911ef8990dcd7ee8d3c52129191", "filename": "src/test/run-fail/rt-set-exit-status-panic2.rs", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a4066271b77810aec0a4a309f66a45e4f8b940de/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4066271b77810aec0a4a309f66a45e4f8b940de/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic2.rs?ref=a4066271b77810aec0a4a309f66a45e4f8b940de", "patch": "@@ -1,44 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:whatever\n-\n-#![feature(exit_status, rustc_private)]\n-\n-#[macro_use] extern crate log;\n-use std::env;\n-use std::thread;\n-\n-struct r {\n-  x:isize,\n-}\n-\n-// Setting the exit status after the runtime has already\n-// panicked has no effect and the process exits with the\n-// runtime's exit code\n-impl Drop for r {\n-    fn drop(&mut self) {\n-        env::set_exit_status(50);\n-    }\n-}\n-\n-fn r(x:isize) -> r {\n-    r {\n-        x: x\n-    }\n-}\n-\n-fn main() {\n-    error!(\"whatever\");\n-    let _t = thread::spawn(move|| {\n-      let _i = r(5);\n-    });\n-    panic!();\n-}"}, {"sha": "f5da02018154649106bf661aae0f2be723b06607", "filename": "src/test/run-fail/rt-set-exit-status.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a4066271b77810aec0a4a309f66a45e4f8b940de/src%2Ftest%2Frun-fail%2Frt-set-exit-status.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4066271b77810aec0a4a309f66a45e4f8b940de/src%2Ftest%2Frun-fail%2Frt-set-exit-status.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Frt-set-exit-status.rs?ref=a4066271b77810aec0a4a309f66a45e4f8b940de", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:whatever\n-\n-#![feature(rustc_private, exit_status)]\n-\n-#[macro_use] extern crate log;\n-use std::env;\n-\n-fn main() {\n-    error!(\"whatever\");\n-    // 101 is the code the runtime uses on thread panic and the value\n-    // compiletest expects run-fail tests to return.\n-    env::set_exit_status(101);\n-}"}, {"sha": "450460cf192142474408ab2a4d0c8edec4ebec45", "filename": "src/test/run-make/link-path-order/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Frun-make%2Flink-path-order%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Frun-make%2Flink-path-order%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flink-path-order%2Fmain.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -23,6 +23,6 @@ fn main() {\n     };\n \n     if result != 1 {\n-        std::env::set_exit_status(255);\n+        std::process::exit(255);\n     }\n }"}, {"sha": "3ab154356c4b6c23e5c6b52f3ca2a4b2120cb8e4", "filename": "src/test/run-pass/bitv-perf-test.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a4066271b77810aec0a4a309f66a45e4f8b940de/src%2Ftest%2Frun-pass%2Fbitv-perf-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4066271b77810aec0a4a309f66a45e4f8b940de/src%2Ftest%2Frun-pass%2Fbitv-perf-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbitv-perf-test.rs?ref=a4066271b77810aec0a4a309f66a45e4f8b940de", "patch": "@@ -1,25 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// pretty-expanded FIXME #23616\n-\n-#![feature(bitvec)]\n-\n-use std::collections::BitVec;\n-\n-fn bitv_test() {\n-    let mut v1 = BitVec::from_elem(31, false);\n-    let v2 = BitVec::from_elem(31, true);\n-    v1.union(&v2);\n-}\n-\n-pub fn main() {\n-    for _ in 0..10000 { bitv_test(); }\n-}"}, {"sha": "69e9816ab948616a28b9afec7a8107722231a33b", "filename": "src/test/run-pass/deriving-hash.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Frun-pass%2Fderiving-hash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Frun-pass%2Fderiving-hash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-hash.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -11,7 +11,7 @@\n \n #![feature(hash_default)]\n \n-use std::hash::{Hash, SipHasher};\n+use std::hash::{Hash, SipHasher, Hasher};\n \n #[derive(Hash)]\n struct Person {\n@@ -21,7 +21,9 @@ struct Person {\n }\n \n fn hash<T: Hash>(t: &T) -> u64 {\n-    std::hash::hash::<T, SipHasher>(t)\n+    let mut s = SipHasher::new_with_keys(0, 0);\n+    t.hash(&mut s);\n+    s.finish()\n }\n \n fn main() {"}, {"sha": "2770260a10e1c44ebb18e661edf122c6bc34afc5", "filename": "src/test/run-pass/dropck_legal_cycles.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Frun-pass%2Fdropck_legal_cycles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Frun-pass%2Fdropck_legal_cycles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdropck_legal_cycles.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -32,7 +32,6 @@ use std::collections::BinaryHeap;\n use std::collections::HashMap;\n use std::collections::LinkedList;\n use std::collections::VecDeque;\n-use std::collections::VecMap;\n use std::collections::btree_map::BTreeMap;\n use std::collections::btree_set::BTreeSet;\n use std::hash::{Hash, Hasher};\n@@ -155,16 +154,16 @@ pub fn main() {\n     if PRINT { println!(\"\"); }\n \n     // Cycle 7: { vm -> (vm0, vm1), {vm0, vm1} -> vm }\n-    let mut vm: VecMap<VM> = VecMap::new();\n+    let mut vm: HashMap<usize, VM> = HashMap::new();\n     vm.insert(0, Named::new(\"vm0\"));\n     vm.insert(1, Named::new(\"vm1\"));\n-    vm[0].contents.set(Some(&vm));\n-    vm[1].contents.set(Some(&vm));\n+    vm[&0].contents.set(Some(&vm));\n+    vm[&1].contents.set(Some(&vm));\n \n     let mut c = c_orig.clone();\n     c.curr_mark = 70;\n     assert!(!c.saw_prev_marked);\n-    vm[0].for_each_child(&mut c);\n+    vm[&0].for_each_child(&mut c);\n     assert!(c.saw_prev_marked);\n \n     if PRINT { println!(\"\"); }\n@@ -388,7 +387,7 @@ impl<'a> Marked<u32> for VD<'a> {\n struct VM<'a> {\n     name: &'static str,\n     mark: Cell<u32>,\n-    contents: Cell<Option<&'a VecMap<VM<'a>>>>,\n+    contents: Cell<Option<&'a HashMap<usize, VM<'a>>>>,\n }\n \n impl<'a> Named for VM<'a> {"}, {"sha": "e6ac8b52c51855c6f3e43826b402ab33f444cce1", "filename": "src/test/run-pass/fsu-moves-and-copies.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Frun-pass%2Ffsu-moves-and-copies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Frun-pass%2Ffsu-moves-and-copies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffsu-moves-and-copies.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -15,10 +15,8 @@\n #![allow(unknown_features)]\n #![feature(box_syntax, core)]\n \n-use std::marker::NoCopy as NP;\n-\n-struct ncint { np: NP, v: isize }\n-fn ncint(v: isize) -> ncint { ncint { np: NP, v: v } }\n+struct ncint { v: isize }\n+fn ncint(v: isize) -> ncint { ncint { v: v } }\n \n struct NoFoo { copied: isize, nocopy: ncint, }\n impl NoFoo {"}, {"sha": "cfff7eb339522e692b56688a2161bb5a6add7506", "filename": "src/test/run-pass/issue-11709.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Frun-pass%2Fissue-11709.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Frun-pass%2Fissue-11709.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11709.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -15,17 +15,13 @@\n // when this bug was opened. The cases where the compiler\n // panics before the fix have a comment.\n \n-#![feature(thunk)]\n-\n-use std::thunk::Thunk;\n-\n struct S {x:()}\n \n-fn test(slot: &mut Option<Thunk<(),Thunk>>) -> () {\n+fn test(slot: &mut Option<Box<FnMut() -> Box<FnMut()>>>) -> () {\n   let a = slot.take();\n   let _a = match a {\n     // `{let .. a(); }` would break\n-    Some(a) => { let _a = a(); },\n+    Some(mut a) => { let _a = a(); },\n     None => (),\n   };\n }"}, {"sha": "9b30305a1969de924c287b97475e94bdbb32f616", "filename": "src/test/run-pass/issue-11736.rs", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a4066271b77810aec0a4a309f66a45e4f8b940de/src%2Ftest%2Frun-pass%2Fissue-11736.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4066271b77810aec0a4a309f66a45e4f8b940de/src%2Ftest%2Frun-pass%2Fissue-11736.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11736.rs?ref=a4066271b77810aec0a4a309f66a45e4f8b940de", "patch": "@@ -1,35 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// pretty-expanded FIXME #23616\n-\n-#![feature(bitvec)]\n-\n-use std::collections::BitVec;\n-\n-fn main() {\n-    // Generate sieve of Eratosthenes for n up to 1e6\n-    let n = 1000000;\n-    let mut sieve = BitVec::from_elem(n+1, true);\n-    let limit: usize = (n as f32).sqrt() as usize;\n-    for i in 2..limit+1 {\n-        if sieve[i] {\n-            let mut j = 0;\n-            while i*i + j*i <= n {\n-                sieve.set(i*i+j*i, false);\n-                j += 1;\n-            }\n-        }\n-    }\n-    for i in 2..n+1 {\n-        if sieve[i] {\n-        }\n-    }\n-}"}, {"sha": "bd7e7c85189272232f7d6eca7dbe5c075ace080f", "filename": "src/test/run-pass/issue-16530.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Frun-pass%2Fissue-16530.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Frun-pass%2Fissue-16530.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16530.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -8,13 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(hash_default)]\n-\n-use std::hash::{SipHasher, hash};\n+use std::hash::{SipHasher, Hasher, Hash};\n \n #[derive(Hash)]\n struct Empty;\n \n pub fn main() {\n-    assert_eq!(hash::<_, SipHasher>(&Empty), hash::<_, SipHasher>(&Empty));\n+    let mut s1 = SipHasher::new_with_keys(0, 0);\n+    Empty.hash(&mut s1);\n+    let mut s2 = SipHasher::new_with_keys(0, 0);\n+    Empty.hash(&mut s2);\n+    assert_eq!(s1.finish(), s2.finish());\n }"}, {"sha": "82ecd636130363a8f3c20406f0985c3ad6beab2f", "filename": "src/test/run-pass/issue-17897.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Frun-pass%2Fissue-17897.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Frun-pass%2Fissue-17897.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17897.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -8,11 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(thunk)]\n-\n-use std::thunk::Thunk;\n-\n-fn action(cb: Thunk<(usize,), usize>) -> usize {\n+fn action(mut cb: Box<FnMut(usize) -> usize>) -> usize {\n     cb(1)\n }\n "}, {"sha": "18088a5f3ec31503dfd18ebd47d76789055f0ac9", "filename": "src/test/run-pass/issue-18188.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Frun-pass%2Fissue-18188.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Frun-pass%2Fissue-18188.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18188.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -10,18 +10,16 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(thunk)]\n-\n-use std::thunk::Thunk;\n-\n pub trait Promisable: Send + Sync {}\n impl<T: Send + Sync> Promisable for T {}\n-pub fn propagate<'a, T, E, F, G>(action: F) -> Thunk<'a, (Result<T, E>,), Result<T, E>>\n+\n+pub fn propagate<'a, T, E, F, G>(mut action: F)\n+    -> Box<FnMut(Result<T, E>) -> Result<T, E> + 'a>\n     where\n         T: Promisable + Clone + 'a,\n         E: Promisable + Clone + 'a,\n-        F: FnOnce(&T) -> Result<T, E> + Send + 'a,\n-        G: FnOnce(Result<T, E>) -> Result<T, E> + 'a {\n+        F: FnMut(&T) -> Result<T, E> + Send + 'a,\n+        G: FnMut(Result<T, E>) -> Result<T, E> + 'a {\n     Box::new(move |result: Result<T, E>| {\n         match result {\n             Ok(ref t) => action(t),"}, {"sha": "844826c45db92b41a816618684f9343923559ae9", "filename": "src/test/run-pass/issue-2190-1.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Frun-pass%2Fissue-2190-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Frun-pass%2Fissue-2190-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2190-1.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -10,18 +10,15 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(thunk)]\n-\n use std::thread::Builder;\n-use std::thunk::Thunk;\n \n static generations: usize = 1024+256+128+49;\n \n-fn spawn(f: Thunk<'static>) {\n+fn spawn(mut f: Box<FnMut() + 'static + Send>) {\n     Builder::new().stack_size(32 * 1024).spawn(move|| f());\n }\n \n-fn child_no(x: usize) -> Thunk<'static> {\n+fn child_no(x: usize) -> Box<FnMut() + 'static + Send> {\n     Box::new(move|| {\n         if x < generations {\n             spawn(child_no(x+1));"}, {"sha": "37decb9e7482b0defb7c1f63396f58d0dbacb720", "filename": "src/test/run-pass/minmax-stability-issue-23687.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Frun-pass%2Fminmax-stability-issue-23687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Frun-pass%2Fminmax-stability-issue-23687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fminmax-stability-issue-23687.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -12,7 +12,6 @@\n \n use std::fmt::Debug;\n use std::cmp::{self, PartialOrd, Ordering};\n-use std::iter::MinMaxResult::MinMax;\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n struct Foo {\n@@ -47,21 +46,12 @@ fn main() {\n     assert_eq!(data.iter().min_by(|a| a.n), Some(&a));\n     assert_eq!(cmp::min(a, b), a);\n     assert_eq!(cmp::min(b, a), b);\n-    assert_eq!(cmp::partial_min(a, b), Some(a));\n-    assert_eq!(cmp::partial_min(b, a), Some(b));\n \n     // `max` should return the right when the values are equal\n     assert_eq!(data.iter().max(), Some(&f));\n     assert_eq!(data.iter().max_by(|a| a.n), Some(&f));\n     assert_eq!(cmp::max(e, f), f);\n     assert_eq!(cmp::max(f, e), e);\n-    assert_eq!(cmp::partial_max(e, f), Some(f));\n-    assert_eq!(cmp::partial_max(f, e), Some(e));\n-\n-    // Similar for `min_max`\n-    assert_eq!(data.iter().min_max(), MinMax(&a, &f));\n-    assert_eq!(data[1..5].iter().min_max(), MinMax(&b, &e));\n-    assert_eq!(data[2..4].iter().min_max(), MinMax(&c, &d));\n \n     let mut presorted = data.to_vec();\n     presorted.sort();"}, {"sha": "356a3be3927e49bb9464a5f3e446b6c98c5d324d", "filename": "src/test/run-pass/send-is-not-static-par-for.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Frun-pass%2Fsend-is-not-static-par-for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Frun-pass%2Fsend-is-not-static-par-for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-is-not-static-par-for.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -8,21 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(core, std_misc, scoped)]\n use std::thread;\n use std::sync::Mutex;\n \n fn par_for<I, F>(iter: I, f: F)\n     where I: Iterator,\n-          <I as Iterator>::Item: Send,\n-          F: Fn(<I as Iterator>::Item) + Sync\n+          I::Item: Send,\n+          F: Fn(I::Item) + Sync\n {\n-    let f = &f;\n-    let _guards: Vec<_> = iter.map(|elem| {\n-        thread::scoped(move || {\n-            f(elem)\n-        })\n-    }).collect();\n+    for item in iter {\n+        f(item)\n+    }\n }\n \n fn sum(x: &[i32]) {"}, {"sha": "8160fe56fd0b27adfcdda9407b2996c15d095705", "filename": "src/test/run-pass/sync-send-iterators-in-libcollections.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcollections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcollections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcollections.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -17,14 +17,12 @@\n extern crate collections;\n \n use collections::BinaryHeap;\n-use collections::{BitSet, BitVec};\n use collections::{BTreeMap, BTreeSet};\n use collections::EnumSet;\n use collections::LinkedList;\n use collections::String;\n use collections::Vec;\n use collections::VecDeque;\n-use collections::VecMap;\n use std::collections::HashMap;\n use std::collections::HashSet;\n \n@@ -60,14 +58,6 @@ fn main() {\n     // implementations have where `Sync` and `Send` semantics apply.\n     all_sync_send!(BinaryHeap::<usize>::new(), iter, drain, into_iter);\n \n-    all_sync_send!(BitVec::new(), iter);\n-\n-    all_sync_send!(BitSet::new(), iter);\n-    is_sync_send!(BitSet::new(), union(&BitSet::new()));\n-    is_sync_send!(BitSet::new(), intersection(&BitSet::new()));\n-    is_sync_send!(BitSet::new(), difference(&BitSet::new()));\n-    is_sync_send!(BitSet::new(), symmetric_difference(&BitSet::new()));\n-\n     all_sync_send!(BTreeMap::<usize, usize>::new(), iter, iter_mut, into_iter, keys, values);\n     is_sync_send!(BTreeMap::<usize, usize>::new(), range(Included(&0), Included(&9)));\n     is_sync_send!(BTreeMap::<usize, usize>::new(), range_mut(Included(&0), Included(&9)));\n@@ -105,8 +95,6 @@ fn main() {\n \n     all_sync_send!(VecDeque::<usize>::new(), iter, iter_mut, drain, into_iter);\n \n-    all_sync_send!(VecMap::<usize>::new(), iter, iter_mut, drain, into_iter, keys, values);\n-\n     all_sync_send!(Vec::<usize>::new(), into_iter);\n     is_sync_send!(Vec::<usize>::new(), drain(..));\n     is_sync_send!(String::new(), drain(..));"}, {"sha": "c4d070f8bfed2c49b3ae8816eb8961862c39f064", "filename": "src/test/run-pass/sync-send-iterators-in-libcore.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcore.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -18,7 +18,7 @@\n #![feature(step_by)]\n #![feature(str_escape)]\n \n-use std::iter::{empty, once, range_inclusive, repeat, Unfold};\n+use std::iter::{empty, once, range_inclusive, repeat};\n \n fn is_sync<T>(_: T) where T: Sync {}\n fn is_send<T>(_: T) where T: Send {}\n@@ -97,7 +97,6 @@ fn main() {\n                    fuse,\n                    inspect(|_| ()));\n \n-    is_sync_send!(Unfold::new(Some(1), |&mut v| v));\n     is_sync_send!((1..).step_by(2));\n     is_sync_send!(range_inclusive(1, 1));\n     is_sync_send!((1..2).step_by(2));"}, {"sha": "db53fa855f11d401167fcf3ee53b156f5f71947e", "filename": "src/test/run-pass/typeid-intrinsic.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Frun-pass%2Ftypeid-intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Frun-pass%2Ftypeid-intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftypeid-intrinsic.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -11,13 +11,12 @@\n // aux-build:typeid-intrinsic.rs\n // aux-build:typeid-intrinsic2.rs\n \n-\n-#![feature(hash_default, core_intrinsics)]\n+#![feature(core_intrinsics)]\n \n extern crate typeid_intrinsic as other1;\n extern crate typeid_intrinsic2 as other2;\n \n-use std::hash::{self, SipHasher};\n+use std::hash::{SipHasher, Hasher, Hash};\n use std::any::TypeId;\n \n struct A;\n@@ -72,6 +71,10 @@ pub fn main() {\n     // check it has a hash\n     let (a, b) = (TypeId::of::<usize>(), TypeId::of::<usize>());\n \n-    assert_eq!(hash::hash::<TypeId, SipHasher>(&a),\n-               hash::hash::<TypeId, SipHasher>(&b));\n+    let mut s1 = SipHasher::new();\n+    a.hash(&mut s1);\n+    let mut s2 = SipHasher::new();\n+    b.hash(&mut s2);\n+\n+    assert_eq!(s1.finish(), s2.finish());\n }"}, {"sha": "685ce589bfa0349b1065c7dbd40fd01e72986f9f", "filename": "src/test/run-pass/ufcs-polymorphic-paths.rs", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Frun-pass%2Fufcs-polymorphic-paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b89645fb6ec31138d5788b588ddd7e44c434fa/src%2Ftest%2Frun-pass%2Fufcs-polymorphic-paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fufcs-polymorphic-paths.rs?ref=82b89645fb6ec31138d5788b588ddd7e44c434fa", "patch": "@@ -8,12 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-#![feature(collections, rand, into_cow, map_in_place, bitvec)]\n-#![allow(warnings)]\n+#![feature(into_cow)]\n \n use std::borrow::{Cow, IntoCow};\n-use std::collections::BitVec;\n use std::default::Default;\n use std::iter::FromIterator;\n use std::ops::Add;\n@@ -24,7 +21,7 @@ use XorShiftRng as DummyRng;\n impl Rng for XorShiftRng {}\n pub trait Rng {}\n pub trait Rand: Default + Sized {\n-    fn rand<R: Rng>(rng: &mut R) -> Self { Default::default() }\n+    fn rand<R: Rng>(_rng: &mut R) -> Self { Default::default() }\n }\n impl Rand for i32 { }\n \n@@ -42,6 +39,25 @@ trait Size: Sized {\n }\n impl<T> Size for T {}\n \n+#[derive(PartialEq, Eq)]\n+struct BitVec;\n+\n+impl BitVec {\n+    fn from_fn<F>(_: usize, _: F) -> BitVec where F: FnMut(usize) -> bool {\n+        BitVec\n+    }\n+}\n+\n+#[derive(PartialEq, Eq)]\n+struct Foo<T>(T);\n+\n+impl<T> Foo<T> {\n+    fn map_in_place<U, F>(self, mut f: F) -> Foo<U> where F: FnMut(T) -> U {\n+        Foo(f(self.0))\n+    }\n+\n+}\n+\n macro_rules! tests {\n     ($($expr:expr, $ty:ty, ($($test:expr),*);)+) => (pub fn main() {$({\n         const C: $ty = $expr;\n@@ -76,13 +92,13 @@ tests! {\n     BitVec::from_fn::<fn(usize) -> bool>, fn(usize, fn(usize) -> bool) -> BitVec, (5, odd);\n \n     // Inherent non-static method.\n-    Vec::map_in_place, fn(Vec<u8>, fn(u8) -> i8) -> Vec<i8>, (vec![b'f', b'o', b'o'], u8_as_i8);\n-    Vec::map_in_place::<i8, fn(u8) -> i8>, fn(Vec<u8>, fn(u8) -> i8) -> Vec<i8>,\n-        (vec![b'f', b'o', b'o'], u8_as_i8);\n-    Vec::<u8>::map_in_place, fn(Vec<u8>, fn(u8) -> i8) -> Vec<i8>\n-        , (vec![b'f', b'o', b'o'], u8_as_i8);\n-    Vec::<u8>::map_in_place::<i8, fn(u8) -> i8>, fn(Vec<u8>, fn(u8) -> i8) -> Vec<i8>\n-        , (vec![b'f', b'o', b'o'], u8_as_i8);\n+    Foo::map_in_place, fn(Foo<u8>, fn(u8) -> i8) -> Foo<i8>, (Foo(b'f'), u8_as_i8);\n+    Foo::map_in_place::<i8, fn(u8) -> i8>, fn(Foo<u8>, fn(u8) -> i8) -> Foo<i8>,\n+        (Foo(b'f'), u8_as_i8);\n+    Foo::<u8>::map_in_place, fn(Foo<u8>, fn(u8) -> i8) -> Foo<i8>\n+        , (Foo(b'f'), u8_as_i8);\n+    Foo::<u8>::map_in_place::<i8, fn(u8) -> i8>, fn(Foo<u8>, fn(u8) -> i8) -> Foo<i8>\n+        , (Foo(b'f'), u8_as_i8);\n \n     // Trait static methods.\n     bool::size, fn() -> usize, ();"}, {"sha": "9d5383fe0603fd70d59ee842f4f2640ac7a3233d", "filename": "src/test/run-pass/unfold-cross-crate.rs", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a4066271b77810aec0a4a309f66a45e4f8b940de/src%2Ftest%2Frun-pass%2Funfold-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4066271b77810aec0a4a309f66a45e4f8b940de/src%2Ftest%2Frun-pass%2Funfold-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funfold-cross-crate.rs?ref=a4066271b77810aec0a4a309f66a45e4f8b940de", "patch": "@@ -1,36 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(iter_unfold)]\n-\n-use std::iter::Unfold;\n-\n-// Unfold had a bug with 'a that mean it didn't work\n-// cross-crate\n-\n-pub fn main() {\n-    fn count(st: &mut usize) -> Option<usize> {\n-        if *st < 10 {\n-            let ret = Some(*st);\n-            *st += 1;\n-            ret\n-        } else {\n-            None\n-        }\n-    }\n-\n-    let mut it = Unfold::new(0, count);\n-    let mut i = 0;\n-    for counted in it {\n-        assert_eq!(counted, i);\n-        i += 1;\n-    }\n-    assert_eq!(i, 10);\n-}"}]}