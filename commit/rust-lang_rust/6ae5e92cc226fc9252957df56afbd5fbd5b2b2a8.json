{"sha": "6ae5e92cc226fc9252957df56afbd5fbd5b2b2a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhZTVlOTJjYzIyNmZjOTI1Mjk1N2RmNTZhZmJkNWZiZDViMmIyYTg=", "commit": {"author": {"name": "Adolfo Ochagav\u00eda", "email": "aochagavia92@gmail.com", "date": "2014-06-28T13:33:37Z"}, "committer": {"name": "Adolfo Ochagav\u00eda", "email": "aochagavia92@gmail.com", "date": "2014-06-30T19:35:46Z"}, "message": "Add `encode` and `decode` shortcut functions\n\nNow you can just use `json::encode` and `json::decode`, which is very\npractical\n\n**Deprecated `Encoder::str_encode` in favor of `json::encode`**\n\n[breaking-change]", "tree": {"sha": "48f0444f3e8fd01cdb5070a415c9e39df4da7d3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48f0444f3e8fd01cdb5070a415c9e39df4da7d3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ae5e92cc226fc9252957df56afbd5fbd5b2b2a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ae5e92cc226fc9252957df56afbd5fbd5b2b2a8", "html_url": "https://github.com/rust-lang/rust/commit/6ae5e92cc226fc9252957df56afbd5fbd5b2b2a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ae5e92cc226fc9252957df56afbd5fbd5b2b2a8/comments", "author": {"login": "aochagavia", "id": 5196584, "node_id": "MDQ6VXNlcjUxOTY1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5196584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aochagavia", "html_url": "https://github.com/aochagavia", "followers_url": "https://api.github.com/users/aochagavia/followers", "following_url": "https://api.github.com/users/aochagavia/following{/other_user}", "gists_url": "https://api.github.com/users/aochagavia/gists{/gist_id}", "starred_url": "https://api.github.com/users/aochagavia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aochagavia/subscriptions", "organizations_url": "https://api.github.com/users/aochagavia/orgs", "repos_url": "https://api.github.com/users/aochagavia/repos", "events_url": "https://api.github.com/users/aochagavia/events{/privacy}", "received_events_url": "https://api.github.com/users/aochagavia/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aochagavia", "id": 5196584, "node_id": "MDQ6VXNlcjUxOTY1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5196584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aochagavia", "html_url": "https://github.com/aochagavia", "followers_url": "https://api.github.com/users/aochagavia/followers", "following_url": "https://api.github.com/users/aochagavia/following{/other_user}", "gists_url": "https://api.github.com/users/aochagavia/gists{/gist_id}", "starred_url": "https://api.github.com/users/aochagavia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aochagavia/subscriptions", "organizations_url": "https://api.github.com/users/aochagavia/orgs", "repos_url": "https://api.github.com/users/aochagavia/repos", "events_url": "https://api.github.com/users/aochagavia/events{/privacy}", "received_events_url": "https://api.github.com/users/aochagavia/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e55dce0e40578ef0875044f5ce6371510b2e40c", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e55dce0e40578ef0875044f5ce6371510b2e40c", "html_url": "https://github.com/rust-lang/rust/commit/1e55dce0e40578ef0875044f5ce6371510b2e40c"}], "stats": {"total": 110, "additions": 49, "deletions": 61}, "files": [{"sha": "77dc73b4f66eda73fd7dfb096597382689479615", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 49, "deletions": 61, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/6ae5e92cc226fc9252957df56afbd5fbd5b2b2a8/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ae5e92cc226fc9252957df56afbd5fbd5b2b2a8/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=6ae5e92cc226fc9252957df56afbd5fbd5b2b2a8", "patch": "@@ -314,6 +314,23 @@ pub fn error_str(error: ErrorCode) -> &'static str {\n     }\n }\n \n+/// Shortcut function to decode a JSON `&str` into an object\n+pub fn decode<T: ::Decodable<Decoder, DecoderError>>(s: &str) -> DecodeResult<T> {\n+    let json = match from_str(s) {\n+        Ok(x) => x,\n+        Err(e) => return Err(ParseError(e))\n+    };\n+\n+    let mut decoder = Decoder::new(json);\n+    ::Decodable::decode(&mut decoder)\n+}\n+\n+/// Shortcut function to encode a `T` into a JSON `String`\n+pub fn encode<'a, T: Encodable<Encoder<'a>, io::IoError>>(object: &T) -> String {\n+    let buff = Encoder::buffer_encode(object);\n+    str::from_utf8_owned(buff).unwrap()\n+}\n+\n impl fmt::Show for ErrorCode {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         error_str(*self).fmt(f)\n@@ -382,9 +399,11 @@ impl<'a> Encoder<'a> {\n     }\n \n     /// Encode the specified struct into a json str\n+    ///\n+    /// Note: this function is deprecated. Consider using `json::encode` instead.\n+    #[deprecated = \"Replaced by `json::encode`\"]\n     pub fn str_encode<T: Encodable<Encoder<'a>, io::IoError>>(object: &T) -> String {\n-        let buff = Encoder::buffer_encode(object);\n-        str::from_utf8_owned(buff).unwrap()\n+        encode(object)\n     }\n }\n \n@@ -2456,16 +2475,13 @@ mod tests {\n \n     #[test]\n     fn test_decode_identifiers() {\n-        let mut decoder = Decoder::new(from_str(\"null\").unwrap());\n-        let v: () = Decodable::decode(&mut decoder).unwrap();\n+        let v: () = super::decode(\"null\").unwrap();\n         assert_eq!(v, ());\n \n-        let mut decoder = Decoder::new(from_str(\"true\").unwrap());\n-        let v: bool = Decodable::decode(&mut decoder).unwrap();\n+        let v: bool = super::decode(\"true\").unwrap();\n         assert_eq!(v, true);\n \n-        let mut decoder = Decoder::new(from_str(\"false\").unwrap());\n-        let v: bool = Decodable::decode(&mut decoder).unwrap();\n+        let v: bool = super::decode(\"false\").unwrap();\n         assert_eq!(v, false);\n     }\n \n@@ -2492,32 +2508,25 @@ mod tests {\n \n     #[test]\n     fn test_decode_numbers() {\n-        let mut decoder = Decoder::new(from_str(\"3\").unwrap());\n-        let v: f64 = Decodable::decode(&mut decoder).unwrap();\n+        let v: f64 = super::decode(\"3\").unwrap();\n         assert_eq!(v, 3.0);\n \n-        let mut decoder = Decoder::new(from_str(\"3.1\").unwrap());\n-        let v: f64 = Decodable::decode(&mut decoder).unwrap();\n+        let v: f64 = super::decode(\"3.1\").unwrap();\n         assert_eq!(v, 3.1);\n \n-        let mut decoder = Decoder::new(from_str(\"-1.2\").unwrap());\n-        let v: f64 = Decodable::decode(&mut decoder).unwrap();\n+        let v: f64 = super::decode(\"-1.2\").unwrap();\n         assert_eq!(v, -1.2);\n \n-        let mut decoder = Decoder::new(from_str(\"0.4\").unwrap());\n-        let v: f64 = Decodable::decode(&mut decoder).unwrap();\n+        let v: f64 = super::decode(\"0.4\").unwrap();\n         assert_eq!(v, 0.4);\n \n-        let mut decoder = Decoder::new(from_str(\"0.4e5\").unwrap());\n-        let v: f64 = Decodable::decode(&mut decoder).unwrap();\n+        let v: f64 = super::decode(\"0.4e5\").unwrap();\n         assert_eq!(v, 0.4e5);\n \n-        let mut decoder = Decoder::new(from_str(\"0.4e15\").unwrap());\n-        let v: f64 = Decodable::decode(&mut decoder).unwrap();\n+        let v: f64 = super::decode(\"0.4e15\").unwrap();\n         assert_eq!(v, 0.4e15);\n \n-        let mut decoder = Decoder::new(from_str(\"0.4e-01\").unwrap());\n-        let v: f64 = Decodable::decode(&mut decoder).unwrap();\n+        let v: f64 = super::decode(\"0.4e-01\").unwrap();\n         assert_eq!(v, 0.4e-01);\n     }\n \n@@ -2551,13 +2560,8 @@ mod tests {\n                  (\"\\\"\\\\uAB12\\\"\", \"\\uAB12\")];\n \n         for &(i, o) in s.iter() {\n-            let mut decoder = Decoder::new(from_str(i).unwrap());\n-            let v: String = Decodable::decode(&mut decoder).unwrap();\n+            let v: String = super::decode(i).unwrap();\n             assert_eq!(v.as_slice(), o);\n-\n-            let mut decoder = Decoder::new(from_str(i).unwrap());\n-            let v: String = Decodable::decode(&mut decoder).unwrap();\n-            assert_eq!(v, o.to_string());\n         }\n     }\n \n@@ -2584,28 +2588,19 @@ mod tests {\n \n     #[test]\n     fn test_decode_list() {\n-        let mut decoder = Decoder::new(from_str(\"[]\").unwrap());\n-        let v: Vec<()> = Decodable::decode(&mut decoder).unwrap();\n+        let v: Vec<()> = super::decode(\"[]\").unwrap();\n         assert_eq!(v, vec![]);\n \n-        let mut decoder = Decoder::new(from_str(\"[null]\").unwrap());\n-        let v: Vec<()> = Decodable::decode(&mut decoder).unwrap();\n+        let v: Vec<()> = super::decode(\"[null]\").unwrap();\n         assert_eq!(v, vec![()]);\n \n-        let mut decoder = Decoder::new(from_str(\"[true]\").unwrap());\n-        let v: Vec<bool> = Decodable::decode(&mut decoder).unwrap();\n+        let v: Vec<bool> = super::decode(\"[true]\").unwrap();\n         assert_eq!(v, vec![true]);\n \n-        let mut decoder = Decoder::new(from_str(\"[true]\").unwrap());\n-        let v: Vec<bool> = Decodable::decode(&mut decoder).unwrap();\n-        assert_eq!(v, vec![true]);\n-\n-        let mut decoder = Decoder::new(from_str(\"[3, 1]\").unwrap());\n-        let v: Vec<int> = Decodable::decode(&mut decoder).unwrap();\n+        let v: Vec<int> = super::decode(\"[3, 1]\").unwrap();\n         assert_eq!(v, vec![3, 1]);\n \n-        let mut decoder = Decoder::new(from_str(\"[[3], [1, 2]]\").unwrap());\n-        let v: Vec<Vec<uint>> = Decodable::decode(&mut decoder).unwrap();\n+        let v: Vec<Vec<uint>> = super::decode(\"[[3], [1, 2]]\").unwrap();\n         assert_eq!(v, vec![vec![3], vec![1, 2]]);\n     }\n \n@@ -2671,8 +2666,8 @@ mod tests {\n                 { \\\"a\\\": null, \\\"b\\\": 2, \\\"c\\\": [\\\"abc\\\", \\\"xyz\\\"] }\n             ]\n         }\";\n-        let mut decoder = Decoder::new(from_str(s).unwrap());\n-        let v: Outer = Decodable::decode(&mut decoder).unwrap();\n+\n+        let v: Outer = super::decode(s).unwrap();\n         assert_eq!(\n             v,\n             Outer {\n@@ -2690,44 +2685,37 @@ mod tests {\n     }\n     #[test]\n     fn test_decode_struct_with_nan() {\n-        let encoded_str = \"{\\\"f\\\":null,\\\"a\\\":[null,123]}\";\n-        let json_object = from_str(encoded_str.as_slice());\n-        let mut decoder = Decoder::new(json_object.unwrap());\n-        let after: FloatStruct = Decodable::decode(&mut decoder).unwrap();\n-        assert!(after.f.is_nan());\n-        assert!(after.a.get(0).is_nan());\n-        assert_eq!(after.a.get(1), &123f64);\n+        let s = \"{\\\"f\\\":null,\\\"a\\\":[null,123]}\";\n+        let obj: FloatStruct = super::decode(s).unwrap();\n+        assert!(obj.f.is_nan());\n+        assert!(obj.a.get(0).is_nan());\n+        assert_eq!(obj.a.get(1), &123f64);\n     }\n \n     #[test]\n     fn test_decode_option() {\n-        let mut decoder = Decoder::new(from_str(\"null\").unwrap());\n-        let value: Option<String> = Decodable::decode(&mut decoder).unwrap();\n+        let value: Option<String> = super::decode(\"null\").unwrap();\n         assert_eq!(value, None);\n \n-        let mut decoder = Decoder::new(from_str(\"\\\"jodhpurs\\\"\").unwrap());\n-        let value: Option<String> = Decodable::decode(&mut decoder).unwrap();\n+        let value: Option<String> = super::decode(\"\\\"jodhpurs\\\"\").unwrap();\n         assert_eq!(value, Some(\"jodhpurs\".to_string()));\n     }\n \n     #[test]\n     fn test_decode_enum() {\n-        let mut decoder = Decoder::new(from_str(\"\\\"Dog\\\"\").unwrap());\n-        let value: Animal = Decodable::decode(&mut decoder).unwrap();\n+        let value: Animal = super::decode(\"\\\"Dog\\\"\").unwrap();\n         assert_eq!(value, Dog);\n \n         let s = \"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\";\n-        let mut decoder = Decoder::new(from_str(s).unwrap());\n-        let value: Animal = Decodable::decode(&mut decoder).unwrap();\n+        let value: Animal = super::decode(s).unwrap();\n         assert_eq!(value, Frog(\"Henry\".to_string(), 349));\n     }\n \n     #[test]\n     fn test_decode_map() {\n         let s = \"{\\\"a\\\": \\\"Dog\\\", \\\"b\\\": {\\\"variant\\\":\\\"Frog\\\",\\\n                   \\\"fields\\\":[\\\"Henry\\\", 349]}}\";\n-        let mut decoder = Decoder::new(from_str(s).unwrap());\n-        let mut map: TreeMap<String, Animal> = Decodable::decode(&mut decoder).unwrap();\n+        let mut map: TreeMap<String, Animal> = super::decode(s).unwrap();\n \n         assert_eq!(map.pop(&\"a\".to_string()), Some(Dog));\n         assert_eq!(map.pop(&\"b\".to_string()), Some(Frog(\"Henry\".to_string(), 349)));"}]}