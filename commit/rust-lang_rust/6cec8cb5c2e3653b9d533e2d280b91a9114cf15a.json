{"sha": "6cec8cb5c2e3653b9d533e2d280b91a9114cf15a", "node_id": "C_kwDOAAsO6NoAKDZjZWM4Y2I1YzJlMzY1M2I5ZDUzM2UyZDI4MGI5MWE5MTE0Y2YxNWE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-03-13T20:55:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-03-13T20:55:36Z"}, "message": "Rollup merge of #108830 - compiler-errors:new-solver-fast-reject-faster, r=lcnr\n\nTreat projections with infer as placeholder during fast reject in new solver\n\nr? ``@lcnr``\n\nKind of a shame that we need to change all of the call sites for `for_each_relevant_impl`, etc. to pass an extra parameter. I guess I could have the \"default\" fn which calls a configurable fn?", "tree": {"sha": "91e4057a6ef6f1f8d436a84aa6eab6571d8df7b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91e4057a6ef6f1f8d436a84aa6eab6571d8df7b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkD43ICRBK7hj4Ov3rIwAAIxgIAAMHNkzIJpgYOqhBC69dvimo\nCugij5i3UTv3AZSFaWJ/Epja2NKPuNWPiQjHSyrPVd3fpcJu/0QVMasm3j95d1DZ\nTPMce38Yfe1bMJgy2dCvS42GDm/mFCMz6Wy081+1gkosenJh9Vw+3LqVWBTbB03N\nAonpS4NHx+iDWwKgv62v4GqrvaGutlX8+QGipIxW1EXZLejZdWTFogATNOSuJapA\nh+omX+Yoa1GidbvJcEBKuCyY7ysmevUYftgwXInjVJtvx5Nj8gvD/jdAtvoy2DlG\nNTzi8BFGsRRXWKlZ2w8N97dFxWWJDvFBLm+KnMTXTEwSIYLIhiXtA9wyatQqAio=\n=N6Nd\n-----END PGP SIGNATURE-----\n", "payload": "tree 91e4057a6ef6f1f8d436a84aa6eab6571d8df7b9\nparent b4c7fc4ea16cd0fd0589f064530cb3213ebcb048\nparent 84d254ead0527c8b098cc35b156d73f9f9c3ec8b\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1678740936 +0100\ncommitter GitHub <noreply@github.com> 1678740936 +0100\n\nRollup merge of #108830 - compiler-errors:new-solver-fast-reject-faster, r=lcnr\n\nTreat projections with infer as placeholder during fast reject in new solver\n\nr? ``@lcnr``\n\nKind of a shame that we need to change all of the call sites for `for_each_relevant_impl`, etc. to pass an extra parameter. I guess I could have the \"default\" fn which calls a configurable fn?\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a", "html_url": "https://github.com/rust-lang/rust/commit/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4c7fc4ea16cd0fd0589f064530cb3213ebcb048", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4c7fc4ea16cd0fd0589f064530cb3213ebcb048", "html_url": "https://github.com/rust-lang/rust/commit/b4c7fc4ea16cd0fd0589f064530cb3213ebcb048"}, {"sha": "84d254ead0527c8b098cc35b156d73f9f9c3ec8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/84d254ead0527c8b098cc35b156d73f9f9c3ec8b", "html_url": "https://github.com/rust-lang/rust/commit/84d254ead0527c8b098cc35b156d73f9f9c3ec8b"}], "stats": {"total": 333, "additions": 250, "deletions": 83}, "files": [{"sha": "07a33bcbb509bf847ed6789911ff55581ad59985", "filename": "compiler/rustc_hir_analysis/src/coherence/inherent_impls.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs?ref=6cec8cb5c2e3653b9d533e2d280b91a9114cf15a", "patch": "@@ -11,7 +11,7 @@ use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId};\n-use rustc_middle::ty::fast_reject::{simplify_type, SimplifiedType, TreatParams};\n+use rustc_middle::ty::fast_reject::{simplify_type, SimplifiedType, TreatParams, TreatProjections};\n use rustc_middle::ty::{self, CrateInherentImpls, Ty, TyCtxt};\n use rustc_span::symbol::sym;\n \n@@ -99,7 +99,12 @@ impl<'tcx> InherentCollect<'tcx> {\n                 }\n             }\n \n-            if let Some(simp) = simplify_type(self.tcx, self_ty, TreatParams::AsInfer) {\n+            if let Some(simp) = simplify_type(\n+                self.tcx,\n+                self_ty,\n+                TreatParams::AsCandidateKey,\n+                TreatProjections::AsCandidateKey,\n+            ) {\n                 self.impls_map.incoherent_impls.entry(simp).or_default().push(impl_def_id);\n             } else {\n                 bug!(\"unexpected self type: {:?}\", self_ty);\n@@ -159,7 +164,12 @@ impl<'tcx> InherentCollect<'tcx> {\n             }\n         }\n \n-        if let Some(simp) = simplify_type(self.tcx, ty, TreatParams::AsInfer) {\n+        if let Some(simp) = simplify_type(\n+            self.tcx,\n+            ty,\n+            TreatParams::AsCandidateKey,\n+            TreatProjections::AsCandidateKey,\n+        ) {\n             self.impls_map.incoherent_impls.entry(simp).or_default().push(impl_def_id);\n         } else {\n             bug!(\"unexpected primitive type: {:?}\", ty);"}, {"sha": "562dd2caae3410f900ffae36a6ed39fbf10c92c2", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=6cec8cb5c2e3653b9d533e2d280b91a9114cf15a", "patch": "@@ -15,6 +15,7 @@ use rustc_infer::infer::canonical::OriginalQueryValues;\n use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n use rustc_infer::infer::{self, InferOk, TyCtxtInferExt};\n use rustc_middle::middle::stability;\n+use rustc_middle::ty::fast_reject::TreatProjections;\n use rustc_middle::ty::fast_reject::{simplify_type, TreatParams};\n use rustc_middle::ty::AssocItem;\n use rustc_middle::ty::GenericParamDefKind;\n@@ -699,7 +700,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     }\n \n     fn assemble_inherent_candidates_for_incoherent_ty(&mut self, self_ty: Ty<'tcx>) {\n-        let Some(simp) = simplify_type(self.tcx, self_ty, TreatParams::AsInfer) else {\n+        let Some(simp) = simplify_type(self.tcx, self_ty, TreatParams::AsCandidateKey, TreatProjections::AsCandidateKey) else {\n             bug!(\"unexpected incoherent type: {:?}\", self_ty)\n         };\n         for &impl_def_id in self.tcx.incoherent_impls(simp) {"}, {"sha": "7055d9257ec90902c55124077e48874d5dfa4c7a", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=6cec8cb5c2e3653b9d533e2d280b91a9114cf15a", "patch": "@@ -25,6 +25,7 @@ use rustc_infer::infer::{\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_middle::traits::util::supertraits;\n use rustc_middle::ty::fast_reject::DeepRejectCtxt;\n+use rustc_middle::ty::fast_reject::TreatProjections;\n use rustc_middle::ty::fast_reject::{simplify_type, TreatParams};\n use rustc_middle::ty::print::{with_crate_prefix, with_forced_trimmed_paths};\n use rustc_middle::ty::{self, GenericArgKind, Ty, TyCtxt, TypeVisitableExt};\n@@ -1257,7 +1258,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let target_ty = self\n                 .autoderef(sugg_span, rcvr_ty)\n                 .find(|(rcvr_ty, _)| {\n-                    DeepRejectCtxt { treat_obligation_params: TreatParams::AsInfer }\n+                    DeepRejectCtxt { treat_obligation_params: TreatParams::AsCandidateKey }\n                         .types_may_unify(*rcvr_ty, impl_ty)\n                 })\n                 .map_or(impl_ty, |(ty, _)| ty)\n@@ -1516,7 +1517,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .into_iter()\n             .any(|info| self.associated_value(info.def_id, item_name).is_some());\n         let found_assoc = |ty: Ty<'tcx>| {\n-            simplify_type(tcx, ty, TreatParams::AsInfer)\n+            simplify_type(tcx, ty, TreatParams::AsCandidateKey, TreatProjections::AsCandidateKey)\n                 .and_then(|simp| {\n                     tcx.incoherent_impls(simp)\n                         .iter()\n@@ -2645,9 +2646,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // FIXME: Even though negative bounds are not implemented, we could maybe handle\n                 // cases where a positive bound implies a negative impl.\n                 (candidates, Vec::new())\n-            } else if let Some(simp_rcvr_ty) =\n-                simplify_type(self.tcx, rcvr_ty, TreatParams::AsPlaceholder)\n-            {\n+            } else if let Some(simp_rcvr_ty) = simplify_type(\n+                self.tcx,\n+                rcvr_ty,\n+                TreatParams::ForLookup,\n+                TreatProjections::ForLookup,\n+            ) {\n                 let mut potential_candidates = Vec::new();\n                 let mut explicitly_negative = Vec::new();\n                 for candidate in candidates {\n@@ -2660,8 +2664,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         })\n                         .any(|imp_did| {\n                             let imp = self.tcx.impl_trait_ref(imp_did).unwrap().subst_identity();\n-                            let imp_simp =\n-                                simplify_type(self.tcx, imp.self_ty(), TreatParams::AsPlaceholder);\n+                            let imp_simp = simplify_type(\n+                                self.tcx,\n+                                imp.self_ty(),\n+                                TreatParams::ForLookup,\n+                                TreatProjections::ForLookup,\n+                            );\n                             imp_simp.map_or(false, |s| s == simp_rcvr_ty)\n                         })\n                     {"}, {"sha": "bbab8a62a2bce98fa4a9cc083c49a64e4e935daa", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=6cec8cb5c2e3653b9d533e2d280b91a9114cf15a", "patch": "@@ -26,7 +26,7 @@ use rustc_middle::middle::exported_symbols::{\n use rustc_middle::mir::interpret;\n use rustc_middle::traits::specialization_graph;\n use rustc_middle::ty::codec::TyEncoder;\n-use rustc_middle::ty::fast_reject::{self, SimplifiedType, TreatParams};\n+use rustc_middle::ty::fast_reject::{self, SimplifiedType, TreatParams, TreatProjections};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, SymbolName, Ty, TyCtxt};\n use rustc_middle::util::common::to_readable_str;\n@@ -1858,7 +1858,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     let simplified_self_ty = fast_reject::simplify_type(\n                         self.tcx,\n                         trait_ref.self_ty(),\n-                        TreatParams::AsInfer,\n+                        TreatParams::AsCandidateKey,\n+                        TreatProjections::AsCandidateKey,\n                     );\n \n                     fx_hash_map"}, {"sha": "ee505742be9a039e4a7c125cc30542337e66120e", "filename": "compiler/rustc_middle/src/ty/fast_reject.rs", "status": "modified", "additions": 39, "deletions": 24, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs?ref=6cec8cb5c2e3653b9d533e2d280b91a9114cf15a", "patch": "@@ -51,15 +51,35 @@ pub enum SimplifiedType {\n /// generic parameters as if they were inference variables in that case.\n #[derive(PartialEq, Eq, Debug, Clone, Copy)]\n pub enum TreatParams {\n-    /// Treat parameters as placeholders in the given environment.\n+    /// Treat parameters as infer vars. This is the correct mode for caching\n+    /// an impl's type for lookup.\n+    AsCandidateKey,\n+    /// Treat parameters as placeholders in the given environment. This is the\n+    /// correct mode for *lookup*, as during candidate selection.\n+    ForLookup,\n+}\n+\n+/// During fast-rejection, we have the choice of treating projection types\n+/// as either simplifyable or not, depending on whether we expect the projection\n+/// to be normalized/rigid.\n+#[derive(PartialEq, Eq, Debug, Clone, Copy)]\n+pub enum TreatProjections {\n+    /// In candidates, we may be able to normalize the projection\n+    /// after instantiating the candidate and equating it with a goal.\n     ///\n-    /// Note that this also causes us to treat projections as if they were\n-    /// placeholders. This is only correct if the given projection cannot\n-    /// be normalized in the current context. Even if normalization fails,\n-    /// it may still succeed later if the projection contains any inference\n-    /// variables.\n-    AsPlaceholder,\n-    AsInfer,\n+    /// We must assume that the `impl<T> Trait<T> for <T as Id>::This`\n+    /// can apply to all self types so we don't return a simplified type\n+    /// for `<T as Id>::This`.\n+    AsCandidateKey,\n+    /// In the old solver we don't try to normalize projections\n+    /// when looking up impls and only access them by using the\n+    /// current self type. This means that if the self type is\n+    /// a projection which could later be normalized, we must not\n+    /// treat it as rigid.\n+    ForLookup,\n+    /// We can treat projections in the self type as opaque as\n+    /// we separately look up impls for the normalized self type.\n+    NextSolverLookup,\n }\n \n /// Tries to simplify a type by only returning the outermost injective\u00b9 layer, if one exists.\n@@ -87,6 +107,7 @@ pub fn simplify_type<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     ty: Ty<'tcx>,\n     treat_params: TreatParams,\n+    treat_projections: TreatProjections,\n ) -> Option<SimplifiedType> {\n     match *ty.kind() {\n         ty::Bool => Some(BoolSimplifiedType),\n@@ -115,19 +136,13 @@ pub fn simplify_type<'tcx>(\n         ty::FnPtr(f) => Some(FunctionSimplifiedType(f.skip_binder().inputs().len())),\n         ty::Placeholder(..) => Some(PlaceholderSimplifiedType),\n         ty::Param(_) => match treat_params {\n-            TreatParams::AsPlaceholder => Some(PlaceholderSimplifiedType),\n-            TreatParams::AsInfer => None,\n+            TreatParams::ForLookup => Some(PlaceholderSimplifiedType),\n+            TreatParams::AsCandidateKey => None,\n         },\n-        ty::Alias(..) => match treat_params {\n-            // When treating `ty::Param` as a placeholder, projections also\n-            // don't unify with anything else as long as they are fully normalized.\n-            //\n-            // We will have to be careful with lazy normalization here.\n-            TreatParams::AsPlaceholder if !ty.has_non_region_infer() => {\n-                debug!(\"treating `{}` as a placeholder\", ty);\n-                Some(PlaceholderSimplifiedType)\n-            }\n-            TreatParams::AsPlaceholder | TreatParams::AsInfer => None,\n+        ty::Alias(..) => match treat_projections {\n+            TreatProjections::ForLookup if !ty.needs_infer() => Some(PlaceholderSimplifiedType),\n+            TreatProjections::NextSolverLookup => Some(PlaceholderSimplifiedType),\n+            TreatProjections::AsCandidateKey | TreatProjections::ForLookup => None,\n         },\n         ty::Foreign(def_id) => Some(ForeignSimplifiedType(def_id)),\n         ty::Bound(..) | ty::Infer(_) | ty::Error(_) => None,\n@@ -295,8 +310,8 @@ impl DeepRejectCtxt {\n             // Depending on the value of `treat_obligation_params`, we either\n             // treat generic parameters like placeholders or like inference variables.\n             ty::Param(_) => match self.treat_obligation_params {\n-                TreatParams::AsPlaceholder => false,\n-                TreatParams::AsInfer => true,\n+                TreatParams::ForLookup => false,\n+                TreatParams::AsCandidateKey => true,\n             },\n \n             ty::Infer(_) => true,\n@@ -333,8 +348,8 @@ impl DeepRejectCtxt {\n         let k = impl_ct.kind();\n         match obligation_ct.kind() {\n             ty::ConstKind::Param(_) => match self.treat_obligation_params {\n-                TreatParams::AsPlaceholder => false,\n-                TreatParams::AsInfer => true,\n+                TreatParams::ForLookup => false,\n+                TreatParams::AsCandidateKey => true,\n             },\n \n             // As we don't necessarily eagerly evaluate constants,"}, {"sha": "bf2b121f704afcbcb55dd44ca800ab424ea9f84d", "filename": "compiler/rustc_middle/src/ty/trait_def.rs", "status": "modified", "additions": 41, "deletions": 17, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs?ref=6cec8cb5c2e3653b9d533e2d280b91a9114cf15a", "patch": "@@ -1,5 +1,5 @@\n use crate::traits::specialization_graph;\n-use crate::ty::fast_reject::{self, SimplifiedType, TreatParams};\n+use crate::ty::fast_reject::{self, SimplifiedType, TreatParams, TreatProjections};\n use crate::ty::visit::TypeVisitableExt;\n use crate::ty::{Ident, Ty, TyCtxt};\n use hir::def_id::LOCAL_CRATE;\n@@ -118,16 +118,32 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Iterate over every impl that could possibly match the self type `self_ty`.\n     ///\n     /// `trait_def_id` MUST BE the `DefId` of a trait.\n-    pub fn for_each_relevant_impl<F: FnMut(DefId)>(\n+    pub fn for_each_relevant_impl(\n         self,\n         trait_def_id: DefId,\n         self_ty: Ty<'tcx>,\n-        mut f: F,\n+        f: impl FnMut(DefId),\n     ) {\n-        let _: Option<()> = self.find_map_relevant_impl(trait_def_id, self_ty, |did| {\n-            f(did);\n-            None\n-        });\n+        self.for_each_relevant_impl_treating_projections(\n+            trait_def_id,\n+            self_ty,\n+            TreatProjections::ForLookup,\n+            f,\n+        )\n+    }\n+\n+    pub fn for_each_relevant_impl_treating_projections(\n+        self,\n+        trait_def_id: DefId,\n+        self_ty: Ty<'tcx>,\n+        treat_projections: TreatProjections,\n+        mut f: impl FnMut(DefId),\n+    ) {\n+        let _: Option<()> =\n+            self.find_map_relevant_impl(trait_def_id, self_ty, treat_projections, |did| {\n+                f(did);\n+                None\n+            });\n     }\n \n     /// `trait_def_id` MUST BE the `DefId` of a trait.\n@@ -137,7 +153,12 @@ impl<'tcx> TyCtxt<'tcx> {\n         self_ty: Ty<'tcx>,\n     ) -> impl Iterator<Item = DefId> + 'tcx {\n         let impls = self.trait_impls_of(trait_def_id);\n-        if let Some(simp) = fast_reject::simplify_type(self, self_ty, TreatParams::AsInfer) {\n+        if let Some(simp) = fast_reject::simplify_type(\n+            self,\n+            self_ty,\n+            TreatParams::AsCandidateKey,\n+            TreatProjections::AsCandidateKey,\n+        ) {\n             if let Some(impls) = impls.non_blanket_impls.get(&simp) {\n                 return impls.iter().copied();\n             }\n@@ -150,11 +171,12 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// the first non-none value.\n     ///\n     /// `trait_def_id` MUST BE the `DefId` of a trait.\n-    pub fn find_map_relevant_impl<T, F: FnMut(DefId) -> Option<T>>(\n+    pub fn find_map_relevant_impl<T>(\n         self,\n         trait_def_id: DefId,\n         self_ty: Ty<'tcx>,\n-        mut f: F,\n+        treat_projections: TreatProjections,\n+        mut f: impl FnMut(DefId) -> Option<T>,\n     ) -> Option<T> {\n         // FIXME: This depends on the set of all impls for the trait. That is\n         // unfortunate wrt. incremental compilation.\n@@ -169,14 +191,13 @@ impl<'tcx> TyCtxt<'tcx> {\n             }\n         }\n \n-        // Note that we're using `TreatParams::AsPlaceholder` to query `non_blanket_impls` while using\n-        // `TreatParams::AsInfer` while actually adding them.\n-        //\n         // This way, when searching for some impl for `T: Trait`, we do not look at any impls\n         // whose outer level is not a parameter or projection. Especially for things like\n         // `T: Clone` this is incredibly useful as we would otherwise look at all the impls\n         // of `Clone` for `Option<T>`, `Vec<T>`, `ConcreteType` and so on.\n-        if let Some(simp) = fast_reject::simplify_type(self, self_ty, TreatParams::AsPlaceholder) {\n+        if let Some(simp) =\n+            fast_reject::simplify_type(self, self_ty, TreatParams::ForLookup, treat_projections)\n+        {\n             if let Some(impls) = impls.non_blanket_impls.get(&simp) {\n                 for &impl_def_id in impls {\n                     if let result @ Some(_) = f(impl_def_id) {\n@@ -237,9 +258,12 @@ pub(super) fn trait_impls_of_provider(tcx: TyCtxt<'_>, trait_id: DefId) -> Trait\n             continue;\n         }\n \n-        if let Some(simplified_self_ty) =\n-            fast_reject::simplify_type(tcx, impl_self_ty, TreatParams::AsInfer)\n-        {\n+        if let Some(simplified_self_ty) = fast_reject::simplify_type(\n+            tcx,\n+            impl_self_ty,\n+            TreatParams::AsCandidateKey,\n+            TreatProjections::AsCandidateKey,\n+        ) {\n             impls.non_blanket_impls.entry(simplified_self_ty).or_default().push(impl_def_id);\n         } else {\n             impls.blanket_impls.push(impl_def_id);"}, {"sha": "b0f6127baa5d42073b3d6b6ed49243bc23eabaed", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=6cec8cb5c2e3653b9d533e2d280b91a9114cf15a", "patch": "@@ -2,6 +2,7 @@\n \n use crate::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use crate::mir;\n+use crate::ty::fast_reject::TreatProjections;\n use crate::ty::layout::IntegerExt;\n use crate::ty::{\n     self, FallibleTypeFolder, ToPredicate, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeSuperFoldable,\n@@ -363,14 +364,20 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.ensure().coherent_trait(drop_trait);\n \n         let ty = self.type_of(adt_did).subst_identity();\n-        let (did, constness) = self.find_map_relevant_impl(drop_trait, ty, |impl_did| {\n-            if let Some(item_id) = self.associated_item_def_ids(impl_did).first() {\n-                if validate(self, impl_did).is_ok() {\n-                    return Some((*item_id, self.constness(impl_did)));\n+        let (did, constness) = self.find_map_relevant_impl(\n+            drop_trait,\n+            ty,\n+            // FIXME: This could also be some other mode, like \"unexpected\"\n+            TreatProjections::ForLookup,\n+            |impl_did| {\n+                if let Some(item_id) = self.associated_item_def_ids(impl_did).first() {\n+                    if validate(self, impl_did).is_ok() {\n+                        return Some((*item_id, self.constness(impl_did)));\n+                    }\n                 }\n-            }\n-            None\n-        })?;\n+                None\n+            },\n+        )?;\n \n         Some(ty::Destructor { did, constness })\n     }"}, {"sha": "c8d371dd0846b8c2c0dcc27146a5e22ec8d14165", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=6cec8cb5c2e3653b9d533e2d280b91a9114cf15a", "patch": "@@ -2215,7 +2215,7 @@ impl CheckAttrVisitor<'_> {\n             // `fn(TokenStream) -> TokenStream` after some substitution of generic arguments.\n             //\n             // Properly checking this means pulling in additional `rustc` crates, so we don't.\n-            let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsInfer };\n+            let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsCandidateKey };\n \n             if sig.abi != Abi::Rust {\n                 tcx.sess.emit_err(errors::ProcMacroInvalidAbi {"}, {"sha": "891ea0cdebe5031be8908d1a92551530a3267713", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=6cec8cb5c2e3653b9d533e2d280b91a9114cf15a", "patch": "@@ -8,6 +8,7 @@ use rustc_hir::def_id::DefId;\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::util::elaborate_predicates;\n use rustc_middle::traits::solve::{CanonicalResponse, Certainty, Goal, MaybeCause, QueryResult};\n+use rustc_middle::ty::fast_reject::TreatProjections;\n use rustc_middle::ty::TypeFoldable;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use std::fmt::Debug;\n@@ -299,9 +300,10 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         candidates: &mut Vec<Candidate<'tcx>>,\n     ) {\n         let tcx = self.tcx();\n-        tcx.for_each_relevant_impl(\n+        tcx.for_each_relevant_impl_treating_projections(\n             goal.predicate.trait_def_id(tcx),\n             goal.predicate.self_ty(),\n+            TreatProjections::NextSolverLookup,\n             |impl_def_id| match G::consider_impl_candidate(self, goal, impl_def_id) {\n                 Ok(result) => candidates\n                     .push(Candidate { source: CandidateSource::Impl(impl_def_id), result }),"}, {"sha": "dbb8e722c8f6ff29aa7c5a5d6d8658e5e75237ba", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=6cec8cb5c2e3653b9d533e2d280b91a9114cf15a", "patch": "@@ -184,7 +184,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n \n         let goal_trait_ref = goal.predicate.projection_ty.trait_ref(tcx);\n         let impl_trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n-        let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsPlaceholder };\n+        let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::ForLookup };\n         if iter::zip(goal_trait_ref.substs, impl_trait_ref.skip_binder().substs)\n             .any(|(goal, imp)| !drcx.generic_args_may_unify(goal, imp))\n         {"}, {"sha": "7878539817cfb928fc8a6a0d4237cb7fa3b8113f", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=6cec8cb5c2e3653b9d533e2d280b91a9114cf15a", "patch": "@@ -8,7 +8,7 @@ use rustc_hir::LangItem;\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::util::supertraits;\n use rustc_middle::traits::solve::{CanonicalResponse, Certainty, Goal, QueryResult};\n-use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n+use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams, TreatProjections};\n use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt};\n use rustc_middle::ty::{TraitPredicate, TypeVisitableExt};\n use rustc_span::DUMMY_SP;\n@@ -36,7 +36,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         let tcx = ecx.tcx();\n \n         let impl_trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n-        let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsPlaceholder };\n+        let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::ForLookup };\n         if iter::zip(goal.predicate.trait_ref.substs, impl_trait_ref.skip_binder().substs)\n             .any(|(goal, imp)| !drcx.generic_args_may_unify(goal, imp))\n         {\n@@ -135,9 +135,15 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         // currently instead lint patterns which can be used to\n         // exploit this unsoundness on stable, see #93367 for\n         // more details.\n+        //\n+        // Using `TreatProjections::NextSolverLookup` is fine here because\n+        // `instantiate_constituent_tys_for_auto_trait` returns nothing for\n+        // projection types anyways. So it doesn't really matter what we do\n+        // here, and this is faster.\n         if let Some(def_id) = ecx.tcx().find_map_relevant_impl(\n             goal.predicate.def_id(),\n             goal.predicate.self_ty(),\n+            TreatProjections::NextSolverLookup,\n             Some,\n         ) {\n             debug!(?def_id, ?goal, \"disqualified auto-trait implementation\");"}, {"sha": "96a4b76af550fd5c9eb26d0782114f4514dee93c", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=6cec8cb5c2e3653b9d533e2d280b91a9114cf15a", "patch": "@@ -75,7 +75,7 @@ pub fn overlapping_impls(\n     // Before doing expensive operations like entering an inference context, do\n     // a quick check via fast_reject to tell if the impl headers could possibly\n     // unify.\n-    let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsInfer };\n+    let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsCandidateKey };\n     let impl1_ref = tcx.impl_trait_ref(impl1_def_id);\n     let impl2_ref = tcx.impl_trait_ref(impl2_def_id);\n     let may_overlap = match (impl1_ref, impl2_ref) {"}, {"sha": "41ffaeeac1c11ffa67b4f7c97c1d3d594191abb9", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=6cec8cb5c2e3653b9d533e2d280b91a9114cf15a", "patch": "@@ -32,6 +32,7 @@ use rustc_infer::infer::{InferOk, TypeTrace};\n use rustc_middle::traits::select::OverflowError;\n use rustc_middle::ty::abstract_const::NotConstEvaluatable;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n+use rustc_middle::ty::fast_reject::TreatProjections;\n use rustc_middle::ty::fold::{TypeFolder, TypeSuperFoldable};\n use rustc_middle::ty::print::{with_forced_trimmed_paths, FmtPrinter, Print};\n use rustc_middle::ty::{\n@@ -1799,12 +1800,17 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     })\n                     .and_then(|(trait_assoc_item, id)| {\n                         let trait_assoc_ident = trait_assoc_item.ident(self.tcx);\n-                        self.tcx.find_map_relevant_impl(id, proj.projection_ty.self_ty(), |did| {\n-                            self.tcx\n-                                .associated_items(did)\n-                                .in_definition_order()\n-                                .find(|assoc| assoc.ident(self.tcx) == trait_assoc_ident)\n-                        })\n+                        self.tcx.find_map_relevant_impl(\n+                            id,\n+                            proj.projection_ty.self_ty(),\n+                            TreatProjections::ForLookup,\n+                            |did| {\n+                                self.tcx\n+                                    .associated_items(did)\n+                                    .in_definition_order()\n+                                    .find(|assoc| assoc.ident(self.tcx) == trait_assoc_ident)\n+                            },\n+                        )\n                     })\n                     .and_then(|item| match self.tcx.hir().get_if_local(item.def_id) {\n                         Some(\n@@ -2176,7 +2182,12 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         trait_ref: &ty::PolyTraitRef<'tcx>,\n     ) -> bool {\n         let get_trait_impl = |trait_def_id| {\n-            self.tcx.find_map_relevant_impl(trait_def_id, trait_ref.skip_binder().self_ty(), Some)\n+            self.tcx.find_map_relevant_impl(\n+                trait_def_id,\n+                trait_ref.skip_binder().self_ty(),\n+                TreatProjections::ForLookup,\n+                Some,\n+            )\n         };\n         let required_trait_path = self.tcx.def_path_str(trait_ref.def_id());\n         let traits_with_same_path: std::collections::BTreeSet<_> = self"}, {"sha": "3182af989f05a565592755863faa044c939e11db", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=6cec8cb5c2e3653b9d533e2d280b91a9114cf15a", "patch": "@@ -9,6 +9,7 @@ use hir::LangItem;\n use rustc_hir as hir;\n use rustc_infer::traits::ObligationCause;\n use rustc_infer::traits::{Obligation, SelectionError, TraitObligation};\n+use rustc_middle::ty::fast_reject::TreatProjections;\n use rustc_middle::ty::{self, Ty, TypeVisitableExt};\n use rustc_target::spec::abi::Abi;\n \n@@ -783,6 +784,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 let relevant_impl = self.tcx().find_map_relevant_impl(\n                     self.tcx().require_lang_item(LangItem::Drop, None),\n                     obligation.predicate.skip_binder().trait_ref.self_ty(),\n+                    TreatProjections::ForLookup,\n                     Some,\n                 );\n "}, {"sha": "38cdaddc1e707c286693e3cd5c6e6d947fde9114", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=6cec8cb5c2e3653b9d533e2d280b91a9114cf15a", "patch": "@@ -2558,7 +2558,7 @@ impl<'tcx> SelectionContext<'_, 'tcx> {\n         // We can avoid creating type variables and doing the full\n         // substitution if we find that any of the input types, when\n         // simplified, do not match.\n-        let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsPlaceholder };\n+        let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::ForLookup };\n         iter::zip(obligation.predicate.skip_binder().trait_ref.substs, impl_trait_ref.substs)\n             .any(|(obl, imp)| !drcx.generic_args_may_unify(obl, imp))\n     }"}, {"sha": "cd665d9471db23a393370c81e5b9193758f85f86", "filename": "compiler/rustc_trait_selection/src/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=6cec8cb5c2e3653b9d533e2d280b91a9114cf15a", "patch": "@@ -3,7 +3,7 @@ use super::OverlapError;\n use crate::traits;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def_id::DefId;\n-use rustc_middle::ty::fast_reject::{self, SimplifiedType, TreatParams};\n+use rustc_middle::ty::fast_reject::{self, SimplifiedType, TreatParams, TreatProjections};\n use rustc_middle::ty::{self, TyCtxt, TypeVisitableExt};\n \n pub use rustc_middle::traits::specialization_graph::*;\n@@ -49,8 +49,12 @@ impl<'tcx> ChildrenExt<'tcx> for Children {\n     /// Insert an impl into this set of children without comparing to any existing impls.\n     fn insert_blindly(&mut self, tcx: TyCtxt<'tcx>, impl_def_id: DefId) {\n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap().skip_binder();\n-        if let Some(st) = fast_reject::simplify_type(tcx, trait_ref.self_ty(), TreatParams::AsInfer)\n-        {\n+        if let Some(st) = fast_reject::simplify_type(\n+            tcx,\n+            trait_ref.self_ty(),\n+            TreatParams::AsCandidateKey,\n+            TreatProjections::AsCandidateKey,\n+        ) {\n             debug!(\"insert_blindly: impl_def_id={:?} st={:?}\", impl_def_id, st);\n             self.non_blanket_impls.entry(st).or_default().push(impl_def_id)\n         } else {\n@@ -65,8 +69,12 @@ impl<'tcx> ChildrenExt<'tcx> for Children {\n     fn remove_existing(&mut self, tcx: TyCtxt<'tcx>, impl_def_id: DefId) {\n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap().skip_binder();\n         let vec: &mut Vec<DefId>;\n-        if let Some(st) = fast_reject::simplify_type(tcx, trait_ref.self_ty(), TreatParams::AsInfer)\n-        {\n+        if let Some(st) = fast_reject::simplify_type(\n+            tcx,\n+            trait_ref.self_ty(),\n+            TreatParams::AsCandidateKey,\n+            TreatProjections::AsCandidateKey,\n+        ) {\n             debug!(\"remove_existing: impl_def_id={:?} st={:?}\", impl_def_id, st);\n             vec = self.non_blanket_impls.get_mut(&st).unwrap();\n         } else {\n@@ -302,7 +310,12 @@ impl<'tcx> GraphExt<'tcx> for Graph {\n \n         let mut parent = trait_def_id;\n         let mut last_lint = None;\n-        let simplified = fast_reject::simplify_type(tcx, trait_ref.self_ty(), TreatParams::AsInfer);\n+        let simplified = fast_reject::simplify_type(\n+            tcx,\n+            trait_ref.self_ty(),\n+            TreatParams::AsCandidateKey,\n+            TreatProjections::AsCandidateKey,\n+        );\n \n         // Descend the specialization tree, where `parent` is the current parent node.\n         loop {"}, {"sha": "358f6ad566c25e669f29a85043de493ed389eeee", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=6cec8cb5c2e3653b9d533e2d280b91a9114cf15a", "patch": "@@ -13,7 +13,7 @@ use rustc_hir::def::Namespace::*;\n use rustc_hir::def::{DefKind, Namespace, PerNS};\n use rustc_hir::def_id::{DefId, CRATE_DEF_ID};\n use rustc_hir::Mutability;\n-use rustc_middle::ty::{Ty, TyCtxt};\n+use rustc_middle::ty::{fast_reject::TreatProjections, Ty, TyCtxt};\n use rustc_middle::{bug, ty};\n use rustc_resolve::rustdoc::MalformedGenerics;\n use rustc_resolve::rustdoc::{prepare_to_doc_link_resolution, strip_generics_from_path};\n@@ -735,7 +735,7 @@ fn trait_impls_for<'a>(\n         trace!(\"considering explicit impl for trait {:?}\", trait_);\n \n         // Look at each trait implementation to see if it's an impl for `did`\n-        tcx.find_map_relevant_impl(trait_, ty, |impl_| {\n+        tcx.find_map_relevant_impl(trait_, ty, TreatProjections::ForLookup, |impl_| {\n             let trait_ref = tcx.impl_trait_ref(impl_).expect(\"this is not an inherent impl\");\n             // Check if these are the same type.\n             let impl_type = trait_ref.skip_binder().self_ty();"}, {"sha": "92bad959095d260b28aed3e01018ce3c244251a1", "filename": "tests/ui/traits/new-solver/nested-obligations-with-bound-vars-gat.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a/tests%2Fui%2Ftraits%2Fnew-solver%2Fnested-obligations-with-bound-vars-gat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a/tests%2Fui%2Ftraits%2Fnew-solver%2Fnested-obligations-with-bound-vars-gat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fnested-obligations-with-bound-vars-gat.rs?ref=6cec8cb5c2e3653b9d533e2d280b91a9114cf15a", "patch": "@@ -0,0 +1,43 @@\n+// check-pass\n+// compile-flags: -Ztrait-solver=next\n+// Issue 96230\n+\n+use std::fmt::Debug;\n+\n+trait Classic {\n+    type Assoc;\n+}\n+\n+trait Gat {\n+    type Assoc<'a>;\n+}\n+\n+struct Foo;\n+\n+impl Classic for Foo {\n+    type Assoc = ();\n+}\n+\n+impl Gat for Foo {\n+    type Assoc<'i> = ();\n+}\n+\n+fn classic_debug<T: Classic>(_: T)\n+where\n+    T::Assoc: Debug,\n+{\n+}\n+\n+fn gat_debug<T: Gat>(_: T)\n+where\n+    for<'a> T::Assoc<'a>: Debug,\n+{\n+}\n+\n+fn main() {\n+    classic_debug::<Foo>(Foo); // fine\n+    classic_debug(Foo); // fine\n+\n+    gat_debug::<Foo>(Foo); // fine\n+    gat_debug(Foo); // boom\n+}"}, {"sha": "1dca86d3630b1a82e99700380b0b301e9183e771", "filename": "tests/ui/traits/new-solver/runaway-impl-candidate-selection.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a/tests%2Fui%2Ftraits%2Fnew-solver%2Frunaway-impl-candidate-selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a/tests%2Fui%2Ftraits%2Fnew-solver%2Frunaway-impl-candidate-selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Frunaway-impl-candidate-selection.rs?ref=6cec8cb5c2e3653b9d533e2d280b91a9114cf15a", "patch": "@@ -0,0 +1,15 @@\n+// compile-flags: -Ztrait-solver=next\n+\n+// In the new solver, we are trying to select `<?0 as Iterator>::Item: Debug`,\n+// which, naively can be unified with every impl of `Debug` if we're not careful.\n+// This test makes sure that we treat projections with inference var substs as\n+// placeholders during fast reject.\n+\n+fn iter<T: Iterator>() -> <T as Iterator>::Item {\n+    todo!()\n+}\n+\n+fn main() {\n+    println!(\"{:?}\", iter::<_>());\n+    //~^ ERROR type annotations needed\n+}"}, {"sha": "47004821ad7c6c1ce0058b2c17ede639331b365d", "filename": "tests/ui/traits/new-solver/runaway-impl-candidate-selection.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a/tests%2Fui%2Ftraits%2Fnew-solver%2Frunaway-impl-candidate-selection.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6cec8cb5c2e3653b9d533e2d280b91a9114cf15a/tests%2Fui%2Ftraits%2Fnew-solver%2Frunaway-impl-candidate-selection.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Frunaway-impl-candidate-selection.stderr?ref=6cec8cb5c2e3653b9d533e2d280b91a9114cf15a", "patch": "@@ -0,0 +1,9 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/runaway-impl-candidate-selection.rs:13:22\n+   |\n+LL |     println!(\"{:?}\", iter::<_>());\n+   |                      ^^^^^^^^^ cannot infer type of the type parameter `T` declared on the function `iter`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}]}