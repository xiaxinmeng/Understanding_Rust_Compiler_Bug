{"sha": "05e3d200801a6236ddbb5b467b3b12a1b4ff15b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1ZTNkMjAwODAxYTYyMzZkZGJiNWI0NjdiM2IxMmExYjRmZjE1YjI=", "commit": {"author": {"name": "Mark Mansi", "email": "markm@cs.wisc.edu", "date": "2019-12-11T22:40:49Z"}, "committer": {"name": "mark", "email": "markm@cs.wisc.edu", "date": "2019-12-23T06:32:00Z"}, "message": "Refactor region error handling to be done by mirborrowckctx", "tree": {"sha": "316b59f21fd15baf009196f63fc06ace5a1d7c5c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/316b59f21fd15baf009196f63fc06ace5a1d7c5c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05e3d200801a6236ddbb5b467b3b12a1b4ff15b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05e3d200801a6236ddbb5b467b3b12a1b4ff15b2", "html_url": "https://github.com/rust-lang/rust/commit/05e3d200801a6236ddbb5b467b3b12a1b4ff15b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05e3d200801a6236ddbb5b467b3b12a1b4ff15b2/comments", "author": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a916ac22b9f7f1f0f7aba0a41a789b3ecd765018", "url": "https://api.github.com/repos/rust-lang/rust/commits/a916ac22b9f7f1f0f7aba0a41a789b3ecd765018", "html_url": "https://github.com/rust-lang/rust/commit/a916ac22b9f7f1f0f7aba0a41a789b3ecd765018"}], "stats": {"total": 635, "additions": 345, "deletions": 290}, "files": [{"sha": "cd2138fdf94d34b61d34a26168bd9148ea7bdc49", "filename": "src/librustc_mir/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05e3d200801a6236ddbb5b467b3b12a1b4ff15b2/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e3d200801a6236ddbb5b467b3b12a1b4ff15b2/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=05e3d200801a6236ddbb5b467b3b12a1b4ff15b2", "patch": "@@ -32,7 +32,7 @@ mod region_errors;\n \n crate use mutability_errors::AccessKind;\n crate use outlives_suggestion::OutlivesSuggestionBuilder;\n-crate use region_errors::{ErrorConstraintInfo, ErrorReportingCtx};\n+crate use region_errors::{ErrorConstraintInfo, ErrorReportingCtx, RegionErrorKind, RegionErrors};\n crate use region_name::{RegionErrorNamingCtx, RegionName, RegionNameSource};\n \n pub(super) struct IncludingDowncast(pub(super) bool);"}, {"sha": "8acb2feeb70a91e7f33b93adc013bad0dd315992", "filename": "src/librustc_mir/borrow_check/diagnostics/outlives_suggestion.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05e3d200801a6236ddbb5b467b3b12a1b4ff15b2/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Foutlives_suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e3d200801a6236ddbb5b467b3b12a1b4ff15b2/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Foutlives_suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Foutlives_suggestion.rs?ref=05e3d200801a6236ddbb5b467b3b12a1b4ff15b2", "patch": "@@ -243,7 +243,9 @@ impl OutlivesSuggestionBuilder<'a> {\n \n         // If there is only one constraint to suggest, then we already suggested it in the\n         // intermediate suggestion above.\n-        if self.constraints_to_add.len() == 1 {\n+        if self.constraints_to_add.len() == 1\n+            && self.constraints_to_add.values().next().unwrap().len() == 1\n+        {\n             debug!(\"Only 1 suggestion. Skipping.\");\n             return;\n         }"}, {"sha": "e61581336283cb6ea8d40aacc4bb355d661b20e5", "filename": "src/librustc_mir/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 65, "deletions": 3, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/05e3d200801a6236ddbb5b467b3b12a1b4ff15b2/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e3d200801a6236ddbb5b467b3b12a1b4ff15b2/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=05e3d200801a6236ddbb5b467b3b12a1b4ff15b2", "patch": "@@ -2,10 +2,11 @@\n \n use rustc::hir::def_id::DefId;\n use rustc::infer::{\n-    error_reporting::nice_region_error::NiceRegionError, InferCtxt, NLLRegionVariableOrigin,\n+    error_reporting::nice_region_error::NiceRegionError, region_constraints::GenericKind,\n+    InferCtxt, NLLRegionVariableOrigin,\n };\n use rustc::mir::{Body, ConstraintCategory, Local, Location};\n-use rustc::ty::{self, RegionVid};\n+use rustc::ty::{self, RegionVid, Ty};\n use rustc_errors::DiagnosticBuilder;\n use rustc_index::vec::IndexVec;\n use std::collections::VecDeque;\n@@ -47,13 +48,74 @@ impl ConstraintDescription for ConstraintCategory {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum Trace {\n     StartRegion,\n     FromOutlivesConstraint(OutlivesConstraint),\n     NotVisited,\n }\n \n+/// A collection of errors encountered during region inference. This is needed to efficiently\n+/// report errors after borrow checking.\n+///\n+/// Usually we expect this to either be empty or contain a small number of items, so we can avoid\n+/// allocation most of the time.\n+crate type RegionErrors<'tcx> = Vec<RegionErrorKind<'tcx>>;\n+\n+#[derive(Clone, Debug)]\n+crate enum RegionErrorKind<'tcx> {\n+    /// An error for a type test: `T: 'a` does not live long enough.\n+    TypeTestDoesNotLiveLongEnough {\n+        /// The span of the type test.\n+        span: Span,\n+        /// The generic type of the type test.\n+        generic: GenericKind<'tcx>,\n+    },\n+\n+    /// A generic bound failure for a type test.\n+    TypeTestGenericBoundError {\n+        /// The span of the type test.\n+        span: Span,\n+        /// The generic type of the type test.\n+        generic: GenericKind<'tcx>,\n+        /// The lower bound region.\n+        lower_bound_region: ty::Region<'tcx>,\n+    },\n+\n+    /// An unexpected hidden region for an opaque type.\n+    UnexpectedHiddenRegion {\n+        /// The def id of the opaque type.\n+        opaque_type_def_id: DefId,\n+        /// The hidden type.\n+        hidden_ty: Ty<'tcx>,\n+        /// The unexpected region.\n+        member_region: ty::Region<'tcx>,\n+    },\n+\n+    /// Higher-ranked subtyping error.\n+    BoundUniversalRegionError {\n+        /// The placeholder free region.\n+        longer_fr: RegionVid,\n+        /// The region that erroneously must be outlived by `longer_fr`.\n+        error_region: RegionVid,\n+        /// The origin of the placeholder region.\n+        fr_origin: NLLRegionVariableOrigin,\n+    },\n+\n+    /// Any other lifetime error.\n+    RegionError {\n+        /// The origin of the region.\n+        fr_origin: NLLRegionVariableOrigin,\n+        /// The region that should outlive `shorter_fr`.\n+        longer_fr: RegionVid,\n+        /// The region that should be shorter, but we can't prove it.\n+        shorter_fr: RegionVid,\n+        /// Indicates whether this is a reported error. We currently only report the first error\n+        /// encountered and leave the rest unreported so as not to overwhelm the user.\n+        is_reported: bool,\n+    },\n+}\n+\n /// Various pieces of state used when reporting borrow checker errors.\n pub struct ErrorReportingCtx<'a, 'b, 'tcx> {\n     /// The region inference context used for borrow chekcing this MIR body."}, {"sha": "b12ed6d58b12652c88097c31920f651f280e822a", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 156, "deletions": 21, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/05e3d200801a6236ddbb5b467b3b12a1b4ff15b2/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e3d200801a6236ddbb5b467b3b12a1b4ff15b2/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=05e3d200801a6236ddbb5b467b3b12a1b4ff15b2", "patch": "@@ -1,9 +1,7 @@\n //! This query borrow-checks the MIR to (further) ensure it is not broken.\n \n-use rustc::hir::def_id::DefId;\n-use rustc::hir::Node;\n-use rustc::hir::{self, HirId};\n-use rustc::infer::InferCtxt;\n+use rustc::hir::{self, def_id::DefId, HirId, Node};\n+use rustc::infer::{opaque_types, InferCtxt};\n use rustc::lint::builtin::MUTABLE_BORROW_RESERVATION_CONFLICT;\n use rustc::lint::builtin::UNUSED_MUT;\n use rustc::mir::{\n@@ -39,8 +37,11 @@ use crate::dataflow::FlowAtLocation;\n use crate::dataflow::MoveDataParamEnv;\n use crate::dataflow::{do_dataflow, DebugFormatted};\n use crate::dataflow::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n+use crate::transform::MirSource;\n \n-use self::diagnostics::AccessKind;\n+use self::diagnostics::{\n+    AccessKind, OutlivesSuggestionBuilder, RegionErrorKind, RegionErrorNamingCtx, RegionErrors,\n+};\n use self::flows::Flows;\n use self::location::LocationTable;\n use self::prefixes::PrefixSet;\n@@ -202,22 +203,28 @@ fn do_mir_borrowck<'a, 'tcx>(\n     let borrow_set =\n         Rc::new(BorrowSet::build(tcx, body, locals_are_invalidated_at_exit, &mdpe.move_data));\n \n-    // If we are in non-lexical mode, compute the non-lexical lifetimes.\n-    let (regioncx, polonius_output, opt_closure_req) = nll::compute_regions(\n-        infcx,\n-        def_id,\n-        free_regions,\n-        body,\n-        &promoted,\n-        &local_names,\n-        &upvars,\n-        location_table,\n-        param_env,\n-        &mut flow_inits,\n-        &mdpe.move_data,\n-        &borrow_set,\n-        &mut errors_buffer,\n-    );\n+    // Compute non-lexical lifetimes.\n+    let nll::NllOutput { regioncx, polonius_output, opt_closure_req, nll_errors } =\n+        nll::compute_regions(\n+            infcx,\n+            def_id,\n+            free_regions,\n+            body,\n+            &promoted,\n+            location_table,\n+            param_env,\n+            &mut flow_inits,\n+            &mdpe.move_data,\n+            &borrow_set,\n+        );\n+\n+    // Dump MIR results into a file, if that is enabled. This let us\n+    // write unit-tests, as well as helping with debugging.\n+    nll::dump_mir_results(infcx, MirSource::item(def_id), &body, &regioncx, &opt_closure_req);\n+\n+    // We also have a `#[rustc_nll]` annotation that causes us to dump\n+    // information.\n+    nll::dump_annotation(infcx, &body, def_id, &regioncx, &opt_closure_req, &mut errors_buffer);\n \n     // The various `flow_*` structures can be large. We drop `flow_inits` here\n     // so it doesn't overlap with the others below. This reduces peak memory\n@@ -288,6 +295,9 @@ fn do_mir_borrowck<'a, 'tcx>(\n         local_names,\n     };\n \n+    // Compute and report region errors, if any.\n+    mbcx.report_region_errors(nll_errors);\n+\n     let mut state = Flows::new(flow_borrows, flow_uninits, flow_ever_inits, polonius_output);\n \n     if let Some(errors) = move_errors {\n@@ -1464,6 +1474,131 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             // initial reservation.\n         }\n     }\n+\n+    /// Produces nice borrowck error diagnostics for all the errors collected in `nll_errors`.\n+    fn report_region_errors(&mut self, nll_errors: RegionErrors<'tcx>) {\n+        // Iterate through all the errors, producing a diagnostic for each one. The diagnostics are\n+        // buffered in the `MirBorrowckCtxt`.\n+\n+        // FIXME(mark-i-m): Would be great to get rid of the naming context.\n+        let mut region_naming = RegionErrorNamingCtx::new();\n+        let mut outlives_suggestion =\n+            OutlivesSuggestionBuilder::new(self.mir_def_id, &self.local_names);\n+\n+        for nll_error in nll_errors.into_iter() {\n+            match nll_error {\n+                RegionErrorKind::TypeTestDoesNotLiveLongEnough { span, generic } => {\n+                    // FIXME. We should handle this case better. It\n+                    // indicates that we have e.g., some region variable\n+                    // whose value is like `'a+'b` where `'a` and `'b` are\n+                    // distinct unrelated univesal regions that are not\n+                    // known to outlive one another. It'd be nice to have\n+                    // some examples where this arises to decide how best\n+                    // to report it; we could probably handle it by\n+                    // iterating over the universal regions and reporting\n+                    // an error that multiple bounds are required.\n+                    self.infcx\n+                        .tcx\n+                        .sess\n+                        .struct_span_err(span, &format!(\"`{}` does not live long enough\", generic))\n+                        .buffer(&mut self.errors_buffer);\n+                }\n+\n+                RegionErrorKind::TypeTestGenericBoundError {\n+                    span,\n+                    generic,\n+                    lower_bound_region,\n+                } => {\n+                    let region_scope_tree = &self.infcx.tcx.region_scope_tree(self.mir_def_id);\n+                    self.infcx\n+                        .construct_generic_bound_failure(\n+                            region_scope_tree,\n+                            span,\n+                            None,\n+                            generic,\n+                            lower_bound_region,\n+                        )\n+                        .buffer(&mut self.errors_buffer);\n+                }\n+\n+                RegionErrorKind::UnexpectedHiddenRegion {\n+                    opaque_type_def_id,\n+                    hidden_ty,\n+                    member_region,\n+                } => {\n+                    let region_scope_tree = &self.infcx.tcx.region_scope_tree(self.mir_def_id);\n+                    opaque_types::unexpected_hidden_region_diagnostic(\n+                        self.infcx.tcx,\n+                        Some(region_scope_tree),\n+                        opaque_type_def_id,\n+                        hidden_ty,\n+                        member_region,\n+                    )\n+                    .buffer(&mut self.errors_buffer);\n+                }\n+\n+                RegionErrorKind::BoundUniversalRegionError {\n+                    longer_fr,\n+                    fr_origin,\n+                    error_region,\n+                } => {\n+                    // Find the code to blame for the fact that `longer_fr` outlives `error_fr`.\n+                    let (_, span) = self.nonlexical_regioncx.find_outlives_blame_span(\n+                        &self.body,\n+                        longer_fr,\n+                        fr_origin,\n+                        error_region,\n+                    );\n+\n+                    // FIXME: improve this error message\n+                    self.infcx\n+                        .tcx\n+                        .sess\n+                        .struct_span_err(span, \"higher-ranked subtype error\")\n+                        .buffer(&mut self.errors_buffer);\n+                }\n+\n+                RegionErrorKind::RegionError { fr_origin, longer_fr, shorter_fr, is_reported } => {\n+                    if is_reported {\n+                        let db = self.nonlexical_regioncx.report_error(\n+                            &self.body,\n+                            &self.local_names,\n+                            &self.upvars,\n+                            self.infcx,\n+                            self.mir_def_id,\n+                            longer_fr,\n+                            fr_origin,\n+                            shorter_fr,\n+                            &mut outlives_suggestion,\n+                            &mut region_naming,\n+                        );\n+\n+                        db.buffer(&mut self.errors_buffer);\n+                    } else {\n+                        // We only report the first error, so as not to overwhelm the user. See\n+                        // `RegRegionErrorKind` docs.\n+                        //\n+                        // FIXME: currently we do nothing with these, but perhaps we can do better?\n+                        // FIXME: try collecting these constraints on the outlives suggestion\n+                        // builder. Does it make the suggestions any better?\n+                        debug!(\n+                            \"Unreported region error: can't prove that {:?}: {:?}\",\n+                            longer_fr, shorter_fr\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Emit one outlives suggestions for each MIR def we borrowck\n+        outlives_suggestion.add_suggestion(\n+            &self.body,\n+            &self.nonlexical_regioncx,\n+            self.infcx,\n+            &mut self.errors_buffer,\n+            &mut region_naming,\n+        );\n+    }\n }\n \n impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {"}, {"sha": "04a53bafe052b821488fb7be6d7ae8ff31c79cc8", "filename": "src/librustc_mir/borrow_check/nll.rs", "status": "modified", "additions": 26, "deletions": 42, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/05e3d200801a6236ddbb5b467b3b12a1b4ff15b2/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e3d200801a6236ddbb5b467b3b12a1b4ff15b2/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs?ref=05e3d200801a6236ddbb5b467b3b12a1b4ff15b2", "patch": "@@ -3,8 +3,8 @@\n use rustc::hir::def_id::DefId;\n use rustc::infer::InferCtxt;\n use rustc::mir::{\n-    BasicBlock, Body, BodyAndCache, ClosureOutlivesSubject, ClosureRegionRequirements, Local,\n-    LocalKind, Location, Promoted, ReadOnlyBodyAndCache,\n+    BasicBlock, Body, BodyAndCache, ClosureOutlivesSubject, ClosureRegionRequirements, LocalKind,\n+    Location, Promoted, ReadOnlyBodyAndCache,\n };\n use rustc::ty::{self, RegionKind, RegionVid};\n use rustc_errors::Diagnostic;\n@@ -16,7 +16,6 @@ use std::path::PathBuf;\n use std::rc::Rc;\n use std::str::FromStr;\n use syntax::symbol::sym;\n-use syntax_pos::symbol::Symbol;\n \n use self::mir_util::PassWhere;\n use polonius_engine::{Algorithm, Output};\n@@ -31,21 +30,29 @@ use crate::util::pretty;\n use crate::borrow_check::{\n     borrow_set::BorrowSet,\n     constraint_generation,\n+    diagnostics::RegionErrors,\n     facts::{AllFacts, AllFactsExt, RustcFacts},\n     invalidation,\n     location::LocationTable,\n     region_infer::{values::RegionValueElements, RegionInferenceContext},\n     renumber,\n     type_check::{self, MirTypeckRegionConstraints, MirTypeckResults},\n     universal_regions::UniversalRegions,\n-    Upvar,\n };\n \n crate type PoloniusOutput = Output<RustcFacts>;\n \n-/// Rewrites the regions in the MIR to use NLL variables, also\n-/// scraping out the set of universal regions (e.g., region parameters)\n-/// declared on the function. That set will need to be given to\n+/// The output of `nll::compute_regions`. This includes the computed `RegionInferenceContext`, any\n+/// closure requirements to propagate, and any generated errors.\n+crate struct NllOutput<'tcx> {\n+    pub regioncx: RegionInferenceContext<'tcx>,\n+    pub polonius_output: Option<Rc<PoloniusOutput>>,\n+    pub opt_closure_req: Option<ClosureRegionRequirements<'tcx>>,\n+    pub nll_errors: RegionErrors<'tcx>,\n+}\n+\n+/// Rewrites the regions in the MIR to use NLL variables, also scraping out the set of universal\n+/// regions (e.g., region parameters) declared on the function. That set will need to be given to\n /// `compute_regions`.\n pub(in crate::borrow_check) fn replace_regions_in_mir<'cx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'tcx>,\n@@ -140,19 +147,12 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n     universal_regions: UniversalRegions<'tcx>,\n     body: ReadOnlyBodyAndCache<'_, 'tcx>,\n     promoted: &IndexVec<Promoted, ReadOnlyBodyAndCache<'_, 'tcx>>,\n-    local_names: &IndexVec<Local, Option<Symbol>>,\n-    upvars: &[Upvar],\n     location_table: &LocationTable,\n     param_env: ty::ParamEnv<'tcx>,\n     flow_inits: &mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'cx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n     borrow_set: &BorrowSet<'tcx>,\n-    errors_buffer: &mut Vec<Diagnostic>,\n-) -> (\n-    RegionInferenceContext<'tcx>,\n-    Option<Rc<PoloniusOutput>>,\n-    Option<ClosureRegionRequirements<'tcx>>,\n-) {\n+) -> NllOutput<'tcx> {\n     let mut all_facts = AllFacts::enabled(infcx.tcx).then_some(AllFacts::default());\n \n     let universal_regions = Rc::new(universal_regions);\n@@ -284,34 +284,18 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n     });\n \n     // Solve the region constraints.\n-    let closure_region_requirements = regioncx.solve(\n-        infcx,\n-        &body,\n-        local_names,\n-        upvars,\n-        def_id,\n-        errors_buffer,\n-        polonius_output.clone(),\n-    );\n-\n-    // Dump MIR results into a file, if that is enabled. This let us\n-    // write unit-tests, as well as helping with debugging.\n-    dump_mir_results(\n-        infcx,\n-        MirSource::item(def_id),\n-        &body,\n-        &regioncx,\n-        &closure_region_requirements,\n-    );\n-\n-    // We also have a `#[rustc_nll]` annotation that causes us to dump\n-    // information\n-    dump_annotation(infcx, &body, def_id, &regioncx, &closure_region_requirements, errors_buffer);\n-\n-    (regioncx, polonius_output, closure_region_requirements)\n+    let (closure_region_requirements, nll_errors) =\n+        regioncx.solve(infcx, &body, def_id, polonius_output.clone());\n+\n+    NllOutput {\n+        regioncx,\n+        polonius_output,\n+        opt_closure_req: closure_region_requirements,\n+        nll_errors,\n+    }\n }\n \n-fn dump_mir_results<'a, 'tcx>(\n+pub(super) fn dump_mir_results<'a, 'tcx>(\n     infcx: &InferCtxt<'a, 'tcx>,\n     source: MirSource<'tcx>,\n     body: &Body<'tcx>,\n@@ -362,7 +346,7 @@ fn dump_mir_results<'a, 'tcx>(\n     };\n }\n \n-fn dump_annotation<'a, 'tcx>(\n+pub(super) fn dump_annotation<'a, 'tcx>(\n     infcx: &InferCtxt<'a, 'tcx>,\n     body: &Body<'tcx>,\n     mir_def_id: DefId,"}, {"sha": "746b11733b36fd6304af14006903fbfc829738e6", "filename": "src/librustc_mir/borrow_check/region_infer/mod.rs", "status": "modified", "additions": 88, "deletions": 216, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/05e3d200801a6236ddbb5b467b3b12a1b4ff15b2/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05e3d200801a6236ddbb5b467b3b12a1b4ff15b2/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs?ref=05e3d200801a6236ddbb5b467b3b12a1b4ff15b2", "patch": "@@ -2,31 +2,27 @@ use std::rc::Rc;\n \n use rustc::hir::def_id::DefId;\n use rustc::infer::canonical::QueryOutlivesConstraint;\n-use rustc::infer::opaque_types;\n use rustc::infer::region_constraints::{GenericKind, VarInfos, VerifyBound};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin, RegionVariableOrigin};\n use rustc::mir::{\n     Body, ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements,\n     ConstraintCategory, Local, Location,\n };\n use rustc::ty::{self, subst::SubstsRef, RegionVid, Ty, TyCtxt, TypeFoldable};\n-use rustc::util::common::ErrorReported;\n use rustc_data_structures::binary_search_util;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::scc::Sccs;\n use rustc_data_structures::graph::vec_graph::VecGraph;\n use rustc_data_structures::graph::WithSuccessors;\n-use rustc_errors::{Diagnostic, DiagnosticBuilder};\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n-use syntax_pos::symbol::Symbol;\n use syntax_pos::Span;\n \n use crate::borrow_check::{\n     constraints::{\n         graph::NormalConstraintGraph, ConstraintSccIndex, OutlivesConstraint, OutlivesConstraintSet,\n     },\n-    diagnostics::{OutlivesSuggestionBuilder, RegionErrorNamingCtx},\n+    diagnostics::{RegionErrorKind, RegionErrors},\n     member_constraints::{MemberConstraintSet, NllMemberConstraintIndex},\n     nll::{PoloniusOutput, ToRegionVid},\n     region_infer::values::{\n@@ -35,7 +31,6 @@ use crate::borrow_check::{\n     },\n     type_check::{free_region_relations::UniversalRegionRelations, Locations},\n     universal_regions::UniversalRegions,\n-    Upvar,\n };\n \n mod dump_mir;\n@@ -221,6 +216,15 @@ pub struct TypeTest<'tcx> {\n     pub verify_bound: VerifyBound<'tcx>,\n }\n \n+/// When we have an unmet lifetime constraint, we try to propagate it outward (e.g. to a closure\n+/// environment). If we can't, it is an error.\n+#[derive(Clone, Copy, Debug, Eq, PartialEq)]\n+enum RegionRelationCheckResult {\n+    Ok,\n+    Propagated,\n+    Error,\n+}\n+\n impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Creates a new region inference context with a total of\n     /// `num_region_variables` valid inference variables; the first N\n@@ -423,7 +427,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     }\n \n     /// Adds annotations for `#[rustc_regions]`; see `UniversalRegions::annotate`.\n-    crate fn annotate(&self, tcx: TyCtxt<'tcx>, err: &mut DiagnosticBuilder<'_>) {\n+    crate fn annotate(&self, tcx: TyCtxt<'tcx>, err: &mut rustc_errors::DiagnosticBuilder<'_>) {\n         self.universal_regions.annotate(tcx, err)\n     }\n \n@@ -469,72 +473,48 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &mut self,\n         infcx: &InferCtxt<'_, 'tcx>,\n         body: &Body<'tcx>,\n-        local_names: &IndexVec<Local, Option<Symbol>>,\n-        upvars: &[Upvar],\n         mir_def_id: DefId,\n-        errors_buffer: &mut Vec<Diagnostic>,\n         polonius_output: Option<Rc<PoloniusOutput>>,\n-    ) -> Option<ClosureRegionRequirements<'tcx>> {\n+    ) -> (Option<ClosureRegionRequirements<'tcx>>, RegionErrors<'tcx>) {\n         self.propagate_constraints(body);\n \n+        let mut errors_buffer = RegionErrors::new();\n+\n         // If this is a closure, we can propagate unsatisfied\n         // `outlives_requirements` to our creator, so create a vector\n         // to store those. Otherwise, we'll pass in `None` to the\n         // functions below, which will trigger them to report errors\n         // eagerly.\n         let mut outlives_requirements = infcx.tcx.is_closure(mir_def_id).then(|| vec![]);\n \n-        self.check_type_tests(\n-            infcx,\n-            body,\n-            mir_def_id,\n-            outlives_requirements.as_mut(),\n-            errors_buffer,\n-        );\n-\n-        // If we produce any errors, we keep track of the names of all regions, so that we can use\n-        // the same error names in any suggestions we produce. Note that we need names to be unique\n-        // across different errors for the same MIR def so that we can make suggestions that fix\n-        // multiple problems.\n-        let mut region_naming = RegionErrorNamingCtx::new();\n+        self.check_type_tests(infcx, body, outlives_requirements.as_mut(), &mut errors_buffer);\n \n         // In Polonius mode, the errors about missing universal region relations are in the output\n         // and need to be emitted or propagated. Otherwise, we need to check whether the\n         // constraints were too strong, and if so, emit or propagate those errors.\n         if infcx.tcx.sess.opts.debugging_opts.polonius {\n             self.check_polonius_subset_errors(\n-                infcx,\n                 body,\n-                local_names,\n-                upvars,\n-                mir_def_id,\n                 outlives_requirements.as_mut(),\n-                errors_buffer,\n-                &mut region_naming,\n+                &mut errors_buffer,\n                 polonius_output.expect(\"Polonius output is unavailable despite `-Z polonius`\"),\n             );\n         } else {\n-            self.check_universal_regions(\n-                infcx,\n-                body,\n-                local_names,\n-                upvars,\n-                mir_def_id,\n-                outlives_requirements.as_mut(),\n-                errors_buffer,\n-                &mut region_naming,\n-            );\n+            self.check_universal_regions(body, outlives_requirements.as_mut(), &mut errors_buffer);\n         }\n \n-        self.check_member_constraints(infcx, mir_def_id, errors_buffer);\n+        self.check_member_constraints(infcx, &mut errors_buffer);\n \n         let outlives_requirements = outlives_requirements.unwrap_or(vec![]);\n \n         if outlives_requirements.is_empty() {\n-            None\n+            (None, errors_buffer)\n         } else {\n             let num_external_vids = self.universal_regions.num_global_and_external_regions();\n-            Some(ClosureRegionRequirements { num_external_vids, outlives_requirements })\n+            (\n+                Some(ClosureRegionRequirements { num_external_vids, outlives_requirements }),\n+                errors_buffer,\n+            )\n         }\n     }\n \n@@ -822,9 +802,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         infcx: &InferCtxt<'_, 'tcx>,\n         body: &Body<'tcx>,\n-        mir_def_id: DefId,\n         mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n-        errors_buffer: &mut Vec<Diagnostic>,\n+        errors_buffer: &mut RegionErrors<'tcx>,\n     ) {\n         let tcx = infcx.tcx;\n \n@@ -882,32 +861,16 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n \n             if let Some(lower_bound_region) = lower_bound_region {\n-                let region_scope_tree = &tcx.region_scope_tree(mir_def_id);\n-                infcx\n-                    .construct_generic_bound_failure(\n-                        region_scope_tree,\n-                        type_test_span,\n-                        None,\n-                        type_test.generic_kind,\n-                        lower_bound_region,\n-                    )\n-                    .buffer(errors_buffer);\n+                errors_buffer.push(RegionErrorKind::TypeTestGenericBoundError {\n+                    span: type_test_span,\n+                    generic: type_test.generic_kind,\n+                    lower_bound_region,\n+                });\n             } else {\n-                // FIXME. We should handle this case better. It\n-                // indicates that we have e.g., some region variable\n-                // whose value is like `'a+'b` where `'a` and `'b` are\n-                // distinct unrelated univesal regions that are not\n-                // known to outlive one another. It'd be nice to have\n-                // some examples where this arises to decide how best\n-                // to report it; we could probably handle it by\n-                // iterating over the universal regions and reporting\n-                // an error that multiple bounds are required.\n-                tcx.sess\n-                    .struct_span_err(\n-                        type_test_span,\n-                        &format!(\"`{}` does not live long enough\", type_test.generic_kind,),\n-                    )\n-                    .buffer(errors_buffer);\n+                errors_buffer.push(RegionErrorKind::TypeTestDoesNotLiveLongEnough {\n+                    span: type_test_span,\n+                    generic: type_test.generic_kind,\n+                });\n             }\n         }\n     }\n@@ -1300,49 +1263,33 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// report them as errors.\n     fn check_universal_regions(\n         &self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n         body: &Body<'tcx>,\n-        local_names: &IndexVec<Local, Option<Symbol>>,\n-        upvars: &[Upvar],\n-        mir_def_id: DefId,\n         mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n-        errors_buffer: &mut Vec<Diagnostic>,\n-        region_naming: &mut RegionErrorNamingCtx,\n+        errors_buffer: &mut RegionErrors<'tcx>,\n     ) {\n-        let mut outlives_suggestion = OutlivesSuggestionBuilder::new(mir_def_id, local_names);\n-\n         for (fr, fr_definition) in self.definitions.iter_enumerated() {\n             match fr_definition.origin {\n                 NLLRegionVariableOrigin::FreeRegion => {\n                     // Go through each of the universal regions `fr` and check that\n                     // they did not grow too large, accumulating any requirements\n                     // for our caller into the `outlives_requirements` vector.\n                     self.check_universal_region(\n-                        infcx,\n                         body,\n-                        local_names,\n-                        upvars,\n-                        mir_def_id,\n                         fr,\n                         &mut propagated_outlives_requirements,\n-                        &mut outlives_suggestion,\n                         errors_buffer,\n-                        region_naming,\n                     );\n                 }\n \n                 NLLRegionVariableOrigin::Placeholder(placeholder) => {\n-                    self.check_bound_universal_region(infcx, body, mir_def_id, fr, placeholder);\n+                    self.check_bound_universal_region(fr, placeholder, errors_buffer);\n                 }\n \n                 NLLRegionVariableOrigin::Existential { .. } => {\n                     // nothing to check here\n                 }\n             }\n         }\n-\n-        // Emit outlives suggestions\n-        outlives_suggestion.add_suggestion(body, self, infcx, errors_buffer, region_naming);\n     }\n \n     /// Checks if Polonius has found any unexpected free region relations.\n@@ -1368,23 +1315,16 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// report them as errors.\n     fn check_polonius_subset_errors(\n         &self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n         body: &Body<'tcx>,\n-        local_names: &IndexVec<Local, Option<Symbol>>,\n-        upvars: &[Upvar],\n-        mir_def_id: DefId,\n         mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n-        errors_buffer: &mut Vec<Diagnostic>,\n-        region_naming: &mut RegionErrorNamingCtx,\n+        errors_buffer: &mut RegionErrors<'tcx>,\n         polonius_output: Rc<PoloniusOutput>,\n     ) {\n         debug!(\n             \"check_polonius_subset_errors: {} subset_errors\",\n             polonius_output.subset_errors.len()\n         );\n \n-        let mut outlives_suggestion = OutlivesSuggestionBuilder::new(mir_def_id, local_names);\n-\n         // Similarly to `check_universal_regions`: a free region relation, which was not explicitly\n         // declared (\"known\") was found by Polonius, so emit an error, or propagate the\n         // requirements for our caller into the `propagated_outlives_requirements` vector.\n@@ -1425,27 +1365,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 body,\n                 &mut propagated_outlives_requirements,\n             );\n-            if !propagated {\n-                // If we are not in a context where we can't propagate errors, or we\n-                // could not shrink `fr` to something smaller, then just report an\n-                // error.\n-                //\n-                // Note: in this case, we use the unapproximated regions to report the\n-                // error. This gives better error messages in some cases.\n-                let db = self.report_error(\n-                    body,\n-                    local_names,\n-                    upvars,\n-                    infcx,\n-                    mir_def_id,\n-                    *longer_fr,\n-                    NLLRegionVariableOrigin::FreeRegion,\n-                    *shorter_fr,\n-                    &mut outlives_suggestion,\n-                    region_naming,\n-                );\n-\n-                db.buffer(errors_buffer);\n+            if propagated == RegionRelationCheckResult::Error {\n+                errors_buffer.push(RegionErrorKind::RegionError {\n+                    longer_fr: *longer_fr,\n+                    shorter_fr: *shorter_fr,\n+                    fr_origin: NLLRegionVariableOrigin::FreeRegion,\n+                    is_reported: true,\n+                });\n             }\n         }\n \n@@ -1458,17 +1384,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 }\n \n                 NLLRegionVariableOrigin::Placeholder(placeholder) => {\n-                    self.check_bound_universal_region(infcx, body, mir_def_id, fr, placeholder);\n+                    self.check_bound_universal_region(fr, placeholder, errors_buffer);\n                 }\n \n                 NLLRegionVariableOrigin::Existential { .. } => {\n                     // nothing to check here\n                 }\n             }\n         }\n-\n-        // Emit outlives suggestions\n-        outlives_suggestion.add_suggestion(body, self, infcx, errors_buffer, region_naming);\n     }\n \n     /// Checks the final value for the free region `fr` to see if it\n@@ -1481,16 +1404,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// `outlives_requirements` vector.\n     fn check_universal_region(\n         &self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n         body: &Body<'tcx>,\n-        local_names: &IndexVec<Local, Option<Symbol>>,\n-        upvars: &[Upvar],\n-        mir_def_id: DefId,\n         longer_fr: RegionVid,\n         propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n-        outlives_suggestion: &mut OutlivesSuggestionBuilder<'_>,\n-        errors_buffer: &mut Vec<Diagnostic>,\n-        region_naming: &mut RegionErrorNamingCtx,\n+        errors_buffer: &mut RegionErrors<'tcx>,\n     ) {\n         debug!(\"check_universal_region(fr={:?})\", longer_fr);\n \n@@ -1509,113 +1426,85 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // one in this SCC, so we will always check the representative here.\n         let representative = self.scc_representatives[longer_fr_scc];\n         if representative != longer_fr {\n-            self.check_universal_region_relation(\n+            if let RegionRelationCheckResult::Error = self.check_universal_region_relation(\n                 longer_fr,\n                 representative,\n-                infcx,\n                 body,\n-                local_names,\n-                upvars,\n-                mir_def_id,\n                 propagated_outlives_requirements,\n-                outlives_suggestion,\n-                errors_buffer,\n-                region_naming,\n-            );\n+            ) {\n+                errors_buffer.push(RegionErrorKind::RegionError {\n+                    longer_fr,\n+                    shorter_fr: representative,\n+                    fr_origin: NLLRegionVariableOrigin::FreeRegion,\n+                    is_reported: true,\n+                });\n+            }\n             return;\n         }\n \n         // Find every region `o` such that `fr: o`\n         // (because `fr` includes `end(o)`).\n+        let mut error_reported = false;\n         for shorter_fr in self.scc_values.universal_regions_outlived_by(longer_fr_scc) {\n-            if let Some(ErrorReported) = self.check_universal_region_relation(\n+            if let RegionRelationCheckResult::Error = self.check_universal_region_relation(\n                 longer_fr,\n                 shorter_fr,\n-                infcx,\n                 body,\n-                local_names,\n-                upvars,\n-                mir_def_id,\n                 propagated_outlives_requirements,\n-                outlives_suggestion,\n-                errors_buffer,\n-                region_naming,\n             ) {\n-                // continuing to iterate just reports more errors than necessary\n-                //\n-                // FIXME It would also allow us to report more Outlives Suggestions, though, so\n-                // it's not clear that that's a bad thing. Somebody should try commenting out this\n-                // line and see it is actually a regression.\n-                return;\n+                // We only report the first region error. Subsequent errors are hidden so as\n+                // not to overwhelm the user, but we do record them so as to potentially print\n+                // better diagnostics elsewhere...\n+                errors_buffer.push(RegionErrorKind::RegionError {\n+                    longer_fr,\n+                    shorter_fr,\n+                    fr_origin: NLLRegionVariableOrigin::FreeRegion,\n+                    is_reported: !error_reported,\n+                });\n+\n+                error_reported = true;\n             }\n         }\n     }\n \n+    /// Checks that we can prove that `longer_fr: shorter_fr`. If we can't we attempt to propagate\n+    /// the constraint outward (e.g. to a closure environment), but if that fails, there is an\n+    /// error.\n     fn check_universal_region_relation(\n         &self,\n         longer_fr: RegionVid,\n         shorter_fr: RegionVid,\n-        infcx: &InferCtxt<'_, 'tcx>,\n         body: &Body<'tcx>,\n-        local_names: &IndexVec<Local, Option<Symbol>>,\n-        upvars: &[Upvar],\n-        mir_def_id: DefId,\n         propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n-        outlives_suggestion: &mut OutlivesSuggestionBuilder<'_>,\n-        errors_buffer: &mut Vec<Diagnostic>,\n-        region_naming: &mut RegionErrorNamingCtx,\n-    ) -> Option<ErrorReported> {\n+    ) -> RegionRelationCheckResult {\n         // If it is known that `fr: o`, carry on.\n         if self.universal_region_relations.outlives(longer_fr, shorter_fr) {\n-            return None;\n-        }\n-\n-        let propagated = self.try_propagate_universal_region_error(\n-            longer_fr,\n-            shorter_fr,\n-            body,\n-            propagated_outlives_requirements,\n-        );\n-\n-        if propagated {\n-            None\n+            RegionRelationCheckResult::Ok\n         } else {\n             // If we are not in a context where we can't propagate errors, or we\n             // could not shrink `fr` to something smaller, then just report an\n             // error.\n             //\n             // Note: in this case, we use the unapproximated regions to report the\n             // error. This gives better error messages in some cases.\n-            let db = self.report_error(\n-                body,\n-                local_names,\n-                upvars,\n-                infcx,\n-                mir_def_id,\n+            self.try_propagate_universal_region_error(\n                 longer_fr,\n-                NLLRegionVariableOrigin::FreeRegion,\n                 shorter_fr,\n-                outlives_suggestion,\n-                region_naming,\n-            );\n-\n-            db.buffer(errors_buffer);\n-\n-            Some(ErrorReported)\n+                body,\n+                propagated_outlives_requirements,\n+            )\n         }\n     }\n \n     /// Attempt to propagate a region error (e.g. `'a: 'b`) that is not met to a closure's\n     /// creator. If we cannot, then the caller should report an error to the user.\n-    ///\n-    /// Returns `true` if the error was propagated, and `false` otherwise.\n     fn try_propagate_universal_region_error(\n         &self,\n         longer_fr: RegionVid,\n         shorter_fr: RegionVid,\n         body: &Body<'tcx>,\n         propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n-    ) -> bool {\n+    ) -> RegionRelationCheckResult {\n         if let Some(propagated_outlives_requirements) = propagated_outlives_requirements {\n             // Shrink `longer_fr` until we find a non-local region (if we do).\n             // We'll call it `fr-` -- it's ever so slightly smaller than\n@@ -1649,20 +1538,18 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         category: blame_span_category.0,\n                     });\n                 }\n-                return true;\n+                return RegionRelationCheckResult::Propagated;\n             }\n         }\n \n-        false\n+        RegionRelationCheckResult::Error\n     }\n \n     fn check_bound_universal_region(\n         &self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n-        body: &Body<'tcx>,\n-        _mir_def_id: DefId,\n         longer_fr: RegionVid,\n         placeholder: ty::PlaceholderRegion,\n+        errors_buffer: &mut RegionErrors<'tcx>,\n     ) {\n         debug!(\"check_bound_universal_region(fr={:?}, placeholder={:?})\", longer_fr, placeholder,);\n \n@@ -1699,28 +1586,17 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 .unwrap(),\n         };\n \n-        // Find the code to blame for the fact that `longer_fr` outlives `error_fr`.\n-        let (_, span) = self.find_outlives_blame_span(\n-            body,\n+        errors_buffer.push(RegionErrorKind::BoundUniversalRegionError {\n             longer_fr,\n-            NLLRegionVariableOrigin::Placeholder(placeholder),\n             error_region,\n-        );\n-\n-        // Obviously, this error message is far from satisfactory.\n-        // At present, though, it only appears in unit tests --\n-        // the AST-based checker uses a more conservative check,\n-        // so to even see this error, one must pass in a special\n-        // flag.\n-        let mut diag = infcx.tcx.sess.struct_span_err(span, \"higher-ranked subtype error\");\n-        diag.emit();\n+            fr_origin: NLLRegionVariableOrigin::Placeholder(placeholder),\n+        });\n     }\n \n     fn check_member_constraints(\n         &self,\n         infcx: &InferCtxt<'_, 'tcx>,\n-        mir_def_id: DefId,\n-        errors_buffer: &mut Vec<Diagnostic>,\n+        errors_buffer: &mut RegionErrors<'tcx>,\n     ) {\n         let member_constraints = self.member_constraints.clone();\n         for m_c_i in member_constraints.all_indices() {\n@@ -1744,16 +1620,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n \n             // If not, report an error.\n-            let region_scope_tree = &infcx.tcx.region_scope_tree(mir_def_id);\n             let member_region = infcx.tcx.mk_region(ty::ReVar(member_region_vid));\n-            opaque_types::unexpected_hidden_region_diagnostic(\n-                infcx.tcx,\n-                Some(region_scope_tree),\n-                m_c.opaque_type_def_id,\n-                m_c.hidden_ty,\n+            errors_buffer.push(RegionErrorKind::UnexpectedHiddenRegion {\n+                opaque_type_def_id: m_c.opaque_type_def_id,\n+                hidden_ty: m_c.hidden_ty,\n                 member_region,\n-            )\n-            .buffer(errors_buffer);\n+            });\n         }\n     }\n }"}, {"sha": "afa07cc60eb84839bd92e6891c0b03104684f51e", "filename": "src/test/ui/hrtb/hrtb-perfect-forwarding.nll.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/05e3d200801a6236ddbb5b467b3b12a1b4ff15b2/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-perfect-forwarding.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/05e3d200801a6236ddbb5b467b3b12a1b4ff15b2/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-perfect-forwarding.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-perfect-forwarding.nll.stderr?ref=05e3d200801a6236ddbb5b467b3b12a1b4ff15b2", "patch": "@@ -44,12 +44,6 @@ LL | | }\n    |\n    = help: a `loop` may express intention better if this is on purpose\n \n-error: higher-ranked subtype error\n-  --> $DIR/hrtb-perfect-forwarding.rs:46:5\n-   |\n-LL |     foo_hrtb_bar_not(&mut t);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n-\n error: lifetime may not live long enough\n   --> $DIR/hrtb-perfect-forwarding.rs:46:5\n    |\n@@ -61,6 +55,12 @@ LL |     foo_hrtb_bar_not(&mut t);\n    |\n    = help: consider replacing `'b` with `'static`\n \n+error: higher-ranked subtype error\n+  --> $DIR/hrtb-perfect-forwarding.rs:46:5\n+   |\n+LL |     foo_hrtb_bar_not(&mut t);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n warning: function cannot return without recursing\n   --> $DIR/hrtb-perfect-forwarding.rs:49:1\n    |"}]}