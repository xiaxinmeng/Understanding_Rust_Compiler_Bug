{"sha": "b3d035d252d9e916e35450609919c3dc218119c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzZDAzNWQyNTJkOWU5MTZlMzU0NTA2MDk5MTljM2RjMjE4MTE5YzY=", "commit": {"author": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2015-10-14T09:44:09Z"}, "committer": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2015-10-14T09:44:09Z"}, "message": "Merge PR #374", "tree": {"sha": "bcbd7c6e032afd04d40e9c7bc05c47d63aa79e14", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bcbd7c6e032afd04d40e9c7bc05c47d63aa79e14"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b3d035d252d9e916e35450609919c3dc218119c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b3d035d252d9e916e35450609919c3dc218119c6", "html_url": "https://github.com/rust-lang/rust/commit/b3d035d252d9e916e35450609919c3dc218119c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b3d035d252d9e916e35450609919c3dc218119c6/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa8833a58bdc8c16f754ef6481e07ad33897d590", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa8833a58bdc8c16f754ef6481e07ad33897d590", "html_url": "https://github.com/rust-lang/rust/commit/fa8833a58bdc8c16f754ef6481e07ad33897d590"}, {"sha": "fb5fdb61fab3b08a39aeb6713aeadd14f309f376", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb5fdb61fab3b08a39aeb6713aeadd14f309f376", "html_url": "https://github.com/rust-lang/rust/commit/fb5fdb61fab3b08a39aeb6713aeadd14f309f376"}], "stats": {"total": 58, "additions": 32, "deletions": 26}, "files": [{"sha": "7d7c97f1bb1d2743f4d25721b536f27c59b3ba54", "filename": "src/loops.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b3d035d252d9e916e35450609919c3dc218119c6/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3d035d252d9e916e35450609919c3dc218119c6/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=b3d035d252d9e916e35450609919c3dc218119c6", "patch": "@@ -173,26 +173,32 @@ impl LateLintPass for LoopsPass {\n                            use `panic!()` or add `std::thread::sleep(..);` to \\\n                            the loop body.\");\n             }\n-            \n-            // extract the first statement (if any) in a block\n-            let inner_stmt = extract_expr_from_first_stmt(block);\n-            // extract a single expression\n+\n+            // extract the expression from the first statement (if any) in a block\n+            let inner_stmt_expr = extract_expr_from_first_stmt(block);\n+            // extract the first expression (if any) from the block\n             let inner_expr = extract_first_expr(block);\n-            let extracted = match inner_stmt {\n-                Some(_) => inner_stmt,\n-                None => inner_expr,\n+            let (extracted, collect_expr) = match inner_stmt_expr {\n+                Some(_) => (inner_stmt_expr, true),     // check if an expression exists in the first statement\n+                None => (inner_expr, false),    // if not, let's go for the first expression in the block\n             };\n \n             if let Some(inner) = extracted {\n-                // collect remaining expressions below the match\n-                let other_stuff = block.stmts\n+                if let ExprMatch(ref matchexpr, ref arms, ref source) = inner.node {\n+                    // collect the remaining statements below the match\n+                    let mut other_stuff = block.stmts\n                                   .iter()\n                                   .skip(1)\n                                   .map(|stmt| {\n                                       format!(\"{}\", snippet(cx, stmt.span, \"..\"))\n                                   }).collect::<Vec<String>>();\n+                    if collect_expr {           // if we have a statement which has a match,\n+                        match block.expr {      // then collect the expression (without semicolon) below it\n+                            Some(ref expr) => other_stuff.push(format!(\"{}\", snippet(cx, expr.span, \"..\"))),\n+                            None => (),\n+                        }\n+                    }\n \n-                if let ExprMatch(ref matchexpr, ref arms, ref source) = inner.node {\n                     // ensure \"if let\" compatible match structure\n                     match *source {\n                         MatchSource::Normal | MatchSource::IfLetDesugar{..} => if\n@@ -203,7 +209,7 @@ impl LateLintPass for LoopsPass {\n                             is_break_expr(&arms[1].body)\n                         {\n                             if in_external_macro(cx, expr.span) { return; }\n-                            let loop_body = match inner_stmt {\n+                            let loop_body = match inner_stmt_expr {\n                                 // FIXME: should probably be an ellipsis\n                                 // tabbing and newline is probably a bad idea, especially for large blocks\n                                 Some(_) => Cow::Owned(format!(\"{{\\n    {}\\n}}\", other_stuff.join(\"\\n    \"))),\n@@ -321,20 +327,12 @@ fn is_iterable_array(ty: ty::Ty) -> bool {\n \n /// If a block begins with a statement (possibly a `let` binding) and has an expression, return it.\n fn extract_expr_from_first_stmt(block: &Block) -> Option<&Expr> {\n-    match block.expr {\n-        Some(_) => None,\n-        None if !block.stmts.is_empty() => match block.stmts[0].node {\n-            StmtDecl(ref decl, _) => match decl.node {\n-                DeclLocal(ref local) => match local.init {\n-                    Some(ref expr) => Some(expr),\n-                    None => None,\n-                },\n-                _ => None,\n-            },\n-            _ => None,\n-        },\n-        _ => None,\n-    }\n+    if block.stmts.is_empty() { return None; }\n+    if let StmtDecl(ref decl, _) = block.stmts[0].node {\n+        if let DeclLocal(ref local) = decl.node {\n+            if let Some(ref expr) = local.init { Some(expr) } else { None }\n+        } else { None }\n+    } else { None }\n }\n \n /// If a block begins with an expression (with or without semicolon), return it."}, {"sha": "a056fe249b50c15bfe4014f69bf230b14bdd1945", "filename": "tests/compile-fail/while_loop.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b3d035d252d9e916e35450609919c3dc218119c6/tests%2Fcompile-fail%2Fwhile_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3d035d252d9e916e35450609919c3dc218119c6/tests%2Fcompile-fail%2Fwhile_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fwhile_loop.rs?ref=b3d035d252d9e916e35450609919c3dc218119c6", "patch": "@@ -33,6 +33,14 @@ fn main() {\n         let _x = x;\n         let _str = \"foo\";\n     }\n+    loop { //~ERROR\n+        let x = match y {\n+            Some(x) => x,\n+            None => break,\n+        };\n+        { let _a = \"bar\"; };\n+        { let _b = \"foobar\"; }\n+    }\n     loop { // no error, else branch does something other than break\n         match y {\n             Some(_x) => true,\n@@ -53,7 +61,7 @@ fn main() {\n // cause this function to trigger it\n fn no_panic<T>(slice: &[T]) {\n     let mut iter = slice.iter();\n-    loop {\n+    loop { //~ERROR\n         let _ = match iter.next() {\n             Some(ele) => ele,\n             None => break"}]}