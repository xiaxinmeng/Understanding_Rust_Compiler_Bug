{"sha": "d4fd30c6ace41638f10e415f6cad175997ec21c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0ZmQzMGM2YWNlNDE2MzhmMTBlNDE1ZjZjYWQxNzU5OTdlYzIxYzQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-01-25T00:24:45Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-01-28T18:00:23Z"}, "message": "Link the lifetimes of regions resulting from borrows of the\ncontents of other borrowed pointers to the lifetimes of the\nborrowed value.  Fixes #3148.\n\nr=catamorphism", "tree": {"sha": "f306370ee07fa03b8f42234559be9bbcf8b28c09", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f306370ee07fa03b8f42234559be9bbcf8b28c09"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4fd30c6ace41638f10e415f6cad175997ec21c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4fd30c6ace41638f10e415f6cad175997ec21c4", "html_url": "https://github.com/rust-lang/rust/commit/d4fd30c6ace41638f10e415f6cad175997ec21c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4fd30c6ace41638f10e415f6cad175997ec21c4/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83ca034d2ed3acf3e9ae3075964763129ab51c23", "url": "https://api.github.com/repos/rust-lang/rust/commits/83ca034d2ed3acf3e9ae3075964763129ab51c23", "html_url": "https://github.com/rust-lang/rust/commit/83ca034d2ed3acf3e9ae3075964763129ab51c23"}], "stats": {"total": 734, "additions": 640, "deletions": 94}, "files": [{"sha": "6cd14d332bf55b874cddb1dbf26971b53e4db590", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4fd30c6ace41638f10e415f6cad175997ec21c4/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4fd30c6ace41638f10e415f6cad175997ec21c4/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=d4fd30c6ace41638f10e415f6cad175997ec21c4", "patch": "@@ -111,6 +111,8 @@ enum special_kind {\n // a complete categorization of a value indicating where it originated\n // and how it is located, as well as the mutability of the memory in\n // which the value is stored.\n+//\n+// note: cmt stands for \"categorized mutable type\".\n type cmt_ = {id: ast::node_id,        // id of expr/pat producing this value\n              span: span,              // span of same expr/pat\n              cat: categorization,     // categorization of expr"}, {"sha": "60ed64b1c1d5ed737879e3bf423be2d8a3827c7e", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d4fd30c6ace41638f10e415f6cad175997ec21c4/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4fd30c6ace41638f10e415f6cad175997ec21c4/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=d4fd30c6ace41638f10e415f6cad175997ec21c4", "patch": "@@ -25,6 +25,7 @@ use core::str;\n use core::vec;\n use syntax::ast::{RegionTyParamBound, TraitTyParamBound, _mod, add, arm};\n use syntax::ast::{binding_mode, bitand, bitor, bitxor, blk, capture_clause};\n+use syntax::ast::{bind_by_value, bind_infer, bind_by_ref, bind_by_move};\n use syntax::ast::{crate, crate_num, decl_item, def, def_arg, def_binding};\n use syntax::ast::{def_const, def_foreign_mod, def_fn, def_id, def_label};\n use syntax::ast::{def_local, def_mod, def_prim_ty, def_region, def_self};\n@@ -4521,6 +4522,10 @@ impl Resolver {\n                                     struct or enum variant\",\n                                     self.session.str_of(ident));\n \n+                            self.enforce_default_binding_mode(\n+                                pattern,\n+                                binding_mode,\n+                                \"an enum variant\");\n                             self.record_def(pattern.id, def);\n                         }\n                         FoundStructOrEnumVariant(_) => {\n@@ -4537,6 +4542,10 @@ impl Resolver {\n                                     constant\",\n                                     self.session.str_of(ident));\n \n+                            self.enforce_default_binding_mode(\n+                                pattern,\n+                                binding_mode,\n+                                \"a constant\");\n                             self.record_def(pattern.id, def);\n                         }\n                         FoundConst(_) => {\n@@ -5371,6 +5380,32 @@ impl Resolver {\n         self.def_map.insert(node_id, def);\n     }\n \n+    fn enforce_default_binding_mode(pat: @pat,\n+                                    pat_binding_mode: binding_mode,\n+                                    descr: &str) {\n+        match pat_binding_mode {\n+            bind_infer => {}\n+            bind_by_value => {\n+                self.session.span_err(\n+                    pat.span,\n+                    fmt!(\"cannot use `copy` binding mode with %s\",\n+                         descr));\n+            }\n+            bind_by_move => {\n+                self.session.span_err(\n+                    pat.span,\n+                    fmt!(\"cannot use `move` binding mode with %s\",\n+                         descr));\n+            }\n+            bind_by_ref(*) => {\n+                self.session.span_err(\n+                    pat.span,\n+                    fmt!(\"cannot use `ref` binding mode with %s\",\n+                         descr));\n+            }\n+        }\n+    }\n+\n     //\n     // main function checking\n     //"}, {"sha": "2e0d7026769ef82561a138f32455384977c56db9", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d4fd30c6ace41638f10e415f6cad175997ec21c4/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4fd30c6ace41638f10e415f6cad175997ec21c4/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=d4fd30c6ace41638f10e415f6cad175997ec21c4", "patch": "@@ -119,6 +119,7 @@ export ty_opaque_box, mk_opaque_box;\n export ty_float, mk_float, mk_mach_float, type_is_fp;\n export ty_fn, FnTy, FnTyBase, FnMeta, FnSig, mk_fn;\n export ty_fn_proto, ty_fn_purity, ty_fn_ret, tys_in_fn_sig;\n+export ty_vstore;\n export replace_fn_return_type;\n export ty_int, mk_int, mk_mach_int, mk_char;\n export mk_i8, mk_u8, mk_i16, mk_u16, mk_i32, mk_u32, mk_i64, mk_u64;\n@@ -3005,6 +3006,14 @@ fn is_fn_ty(fty: t) -> bool {\n     }\n }\n \n+pure fn ty_vstore(ty: t) -> vstore {\n+    match get(ty).sty {\n+        ty_evec(_, vstore) => vstore,\n+        ty_estr(vstore) => vstore,\n+        ref s => fail fmt!(\"ty_vstore() called on invalid sty: %?\", s)\n+    }\n+}\n+\n fn ty_region(ty: t) -> Region {\n     match get(ty).sty {\n       ty_rptr(r, _) => r,"}, {"sha": "be6559640d7243d9e8d9feb200ebc9371985da6d", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d4fd30c6ace41638f10e415f6cad175997ec21c4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4fd30c6ace41638f10e415f6cad175997ec21c4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=d4fd30c6ace41638f10e415f6cad175997ec21c4", "patch": "@@ -105,7 +105,7 @@ use middle::typeck::{isr_alist, lookup_def_ccx, method_map_entry};\n use middle::typeck::{method_origin, method_self, method_trait, no_params};\n use middle::typeck::{require_same_types};\n use util::common::{block_query, indenter, loop_query};\n-use util::ppaux::{bound_region_to_str, expr_repr};\n+use util::ppaux::{bound_region_to_str, expr_repr, pat_repr};\n use util::ppaux;\n \n use core::either;\n@@ -127,7 +127,6 @@ use syntax::ast_util;\n use syntax::codemap::span;\n use syntax::codemap;\n use syntax::parse::token::special_idents;\n-use syntax::print::pprust::{expr_to_str, pat_to_str};\n use syntax::print::pprust;\n use syntax::visit;\n use syntax;\n@@ -469,7 +468,7 @@ fn check_fn(ccx: @crate_ctxt,\n             };\n             assign(local.span, local.node.id, o_ty);\n             debug!(\"Local variable %s is assigned to %s\",\n-                   pat_to_str(local.node.pat, tcx.sess.intr()),\n+                   fcx.pat_to_str(local.node.pat),\n                    fcx.inh.locals.get(local.node.id).to_str());\n             visit::visit_local(local, e, v);\n         };\n@@ -756,6 +755,10 @@ impl @fn_ctxt {\n         expr_repr(self.tcx(), expr)\n     }\n \n+    fn pat_to_str(pat: @ast::pat) -> ~str {\n+        pat_repr(self.tcx(), pat)\n+    }\n+\n     fn expr_ty(ex: @ast::expr) -> ty::t {\n         match self.inh.node_types.find(ex.id) {\n             Some(t) => t,\n@@ -1600,7 +1603,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         let fty = ty::mk_fn(tcx, copy fn_ty);\n \n         debug!(\"check_expr_fn_with_unifier %s fty=%s\",\n-               expr_to_str(expr, tcx.sess.intr()),\n+               fcx.expr_to_str(expr),\n                fcx.infcx().ty_to_str(fty));\n \n         fcx.write_ty(expr.id, fty);\n@@ -2713,7 +2716,7 @@ fn check_enum_variants(ccx: @crate_ctxt,\n             do v.node.disr_expr.iter |e_ref| {\n                 let e = *e_ref;\n                 debug!(\"disr expr, checking %s\",\n-                       expr_to_str(e, ccx.tcx.sess.intr()));\n+                       pprust::expr_to_str(e, ccx.tcx.sess.intr()));\n                 let declty = ty::mk_int(ccx.tcx);\n                 let fcx = blank_fn_ctxt(ccx, rty, e.id);\n                 check_const_with_ty(fcx, e.span, e, declty);"}, {"sha": "419e6269957cfdd70a49936644523c9ec2fe38b5", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 458, "deletions": 56, "changes": 514, "blob_url": "https://github.com/rust-lang/rust/blob/d4fd30c6ace41638f10e415f6cad175997ec21c4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4fd30c6ace41638f10e415f6cad175997ec21c4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=d4fd30c6ace41638f10e415f6cad175997ec21c4", "patch": "@@ -30,7 +30,7 @@ this point a bit better.\n use core::prelude::*;\n \n use middle::freevars::get_freevars;\n-use middle::pat_util::pat_bindings;\n+use middle::pat_util::{pat_bindings, pat_is_binding};\n use middle::ty::{encl_region, re_scope};\n use middle::ty::{ty_fn_proto, vstore_box, vstore_fixed, vstore_slice};\n use middle::ty::{vstore_uniq};\n@@ -73,35 +73,44 @@ fn encl_region_of_def(fcx: @fn_ctxt, def: ast::def) -> ty::Region {\n }\n \n impl @rcx {\n-    /// Try to resolve the type for the given node.\n-    ///\n-    /// Note one important point: we do not attempt to resolve *region\n-    /// variables* here.  This is because regionck is essentially adding\n-    /// constraints to those region variables and so may yet influence\n-    /// how they are resolved.\n-    ///\n-    /// Consider this silly example:\n-    ///\n-    ///     fn borrow(x: &int) -> &int {x}\n-    ///     fn foo(x: @int) -> int {  /* block: B */\n-    ///         let b = borrow(x);    /* region: <R0> */\n-    ///         *b\n-    ///     }\n-    ///\n-    /// Here, the region of `b` will be `<R0>`.  `<R0>` is constrainted\n-    /// to be some subregion of the block B and some superregion of\n-    /// the call.  If we forced it now, we'd choose the smaller region\n-    /// (the call).  But that would make the *b illegal.  Since we don't\n-    /// resolve, the type of b will be `&<R0>.int` and then `*b` will require\n-    /// that `<R0>` be bigger than the let and the `*b` expression, so we\n-    /// will effectively resolve `<R0>` to be the block B.\n-    fn resolve_type(unresolved_ty: ty::t) -> fres<ty::t> {\n-        resolve_type(self.fcx.infcx(), unresolved_ty,\n-                     resolve_and_force_all_but_regions)\n+    fn resolve_type(unresolved_ty: ty::t) -> Option<ty::t> {\n+        /*!\n+         * Try to resolve the type for the given node, returning\n+         * None if an error results.  Note that we never care\n+         * about the details of the error, the same error will be\n+         * detected and reported in the writeback phase.\n+         *\n+         * Note one important point: we do not attempt to resolve\n+         * *region variables* here.  This is because regionck is\n+         * essentially adding constraints to those region variables\n+         * and so may yet influence how they are resolved.\n+         *\n+         * Consider this silly example:\n+         *\n+         *     fn borrow(x: &int) -> &int {x}\n+         *     fn foo(x: @int) -> int {  // block: B\n+         *         let b = borrow(x);    // region: <R0>\n+         *         *b\n+         *     }\n+         *\n+         * Here, the region of `b` will be `<R0>`.  `<R0>` is\n+         * constrainted to be some subregion of the block B and some\n+         * superregion of the call.  If we forced it now, we'd choose\n+         * the smaller region (the call).  But that would make the *b\n+         * illegal.  Since we don't resolve, the type of b will be\n+         * `&<R0>.int` and then `*b` will require that `<R0>` be\n+         * bigger than the let and the `*b` expression, so we will\n+         * effectively resolve `<R0>` to be the block B.\n+         */\n+        match resolve_type(self.fcx.infcx(), unresolved_ty,\n+                           resolve_and_force_all_but_regions) {\n+            Ok(t) => Some(t),\n+            Err(_) => None\n+        }\n     }\n \n     /// Try to resolve the type for the given node.\n-    fn resolve_node_type(id: ast::node_id) -> fres<ty::t> {\n+    fn resolve_node_type(id: ast::node_id) -> Option<ty::t> {\n         self.resolve_type(self.fcx.node_ty(id))\n     }\n }\n@@ -170,8 +179,7 @@ fn visit_block(b: ast::blk, &&rcx: @rcx, v: rvt) {\n }\n \n fn visit_expr(expr: @ast::expr, &&rcx: @rcx, v: rvt) {\n-    debug!(\"visit_expr(e=%s)\",\n-           pprust::expr_to_str(expr, rcx.fcx.tcx().sess.intr()));\n+    debug!(\"visit_expr(e=%s)\", rcx.fcx.expr_to_str(expr));\n \n     match /*bad*/copy expr.node {\n         ast::expr_path(*) => {\n@@ -242,40 +250,36 @@ fn visit_expr(expr: @ast::expr, &&rcx: @rcx, v: rvt) {\n             // particular case.  There is an extensive comment on the\n             // function check_cast_for_escaping_regions() in kind.rs\n             // explaining how it goes about doing that.\n-            match rcx.resolve_node_type(expr.id) {\n-                result::Err(_) => { return; /*typeck will fail anyhow*/ }\n-                result::Ok(target_ty) => {\n-                    match ty::get(target_ty).sty {\n-                        ty::ty_trait(_, _, vstore_slice(trait_region)) => {\n-                            let source_ty = rcx.fcx.expr_ty(source);\n-                            constrain_regions_in_type(rcx, trait_region,\n-                                                      expr.span, source_ty);\n-                        }\n-                        _ => ()\n+            for rcx.resolve_node_type(expr.id).each |target_ty| {\n+                match ty::get(*target_ty).sty {\n+                    ty::ty_trait(_, _, vstore_slice(trait_region)) => {\n+                        let source_ty = rcx.fcx.expr_ty(source);\n+                        constrain_regions_in_type(rcx, trait_region,\n+                                                  expr.span, source_ty);\n                     }\n+                    _ => ()\n                 }\n-            };\n+            }\n+        }\n+\n+        ast::expr_addr_of(_, base) => {\n+            guarantor::for_addr_of(rcx, expr, base);\n         }\n \n-        ast::expr_addr_of(*) => {\n-            // FIXME(#3148) -- in some cases, we need to capture a\n-            // dependency between the regions found in operand the\n-            // resulting region type.  See #3148 for more details.\n+        ast::expr_match(discr, ref arms) => {\n+            guarantor::for_match(rcx, discr, *arms);\n         }\n \n         ast::expr_fn(*) | ast::expr_fn_block(*) => {\n-            match rcx.resolve_node_type(expr.id) {\n-                result::Err(_) => return, // Typechecking will fail anyhow.\n-                result::Ok(function_type) => {\n-                    match ty::get(function_type).sty {\n-                        ty::ty_fn(ref fn_ty) => {\n-                            if fn_ty.meta.proto == ast::ProtoBorrowed {\n-                                constrain_free_variables(\n-                                    rcx, fn_ty.meta.region, expr);\n-                            }\n+            for rcx.resolve_node_type(expr.id).each |function_type| {\n+                match ty::get(*function_type).sty {\n+                    ty::ty_fn(ref fn_ty) => {\n+                        if fn_ty.meta.proto == ast::ProtoBorrowed {\n+                            constrain_free_variables(\n+                                rcx, fn_ty.meta.region, expr);\n                         }\n-                        _ => ()\n                     }\n+                    _ => ()\n                 }\n             }\n         }\n@@ -406,8 +410,8 @@ fn constrain_regions_in_type_of_node(\n     // is going to fail anyway, so just stop here and let typeck\n     // report errors later on in the writeback phase.\n     let ty = match rcx.resolve_node_type(id) {\n-      result::Err(_) => return true,\n-      result::Ok(ty) => ty\n+        None => { return true; }\n+        Some(ty) => { ty }\n     };\n \n     debug!(\"constrain_regions_in_type_of_node(\\\n@@ -477,3 +481,401 @@ fn constrain_regions_in_type(\n         }\n     }\n }\n+\n+mod guarantor {\n+    /*!\n+     *\n+     * The routines in this module are aiming to deal with the case\n+     * where the lifetime resulting from a borrow is linked to the\n+     * lifetime of the thing being borrowed.  Imagine you have a\n+     * borrowed pointer `b` with lifetime L1 and you have an\n+     * expression `&*b`.  The result of this borrow will be another\n+     * borrowed pointer with lifetime L2 (which is an inference\n+     * variable).  The borrow checker is going to enforce the\n+     * constraint that L2 < L1, because otherwise you are re-borrowing\n+     * data for a lifetime larger than the original loan.  However,\n+     * without the routines in this module, the region inferencer would\n+     * not know of this dependency and thus it might infer the\n+     * lifetime of L2 to be greater than L1 (issue #3148).\n+     *\n+     * There are a number of troublesome scenarios in the test\n+     * `region-dependent-addr-of.rs`, but here is one example:\n+     *\n+     *     struct Foo { i: int }\n+     *     struct Bar { foo: Foo  }\n+     *     fn get_i(x: &a/Bar) -> &a/int {\n+     *        let foo = &x.foo; // Lifetime L1\n+     *        &foo.i            // Lifetime L2\n+     *     }\n+     *\n+     * Note that this comes up either with `&` expressions, `ref`\n+     * bindings, and `autorefs`, which are the three ways to introduce\n+     * a borrow.\n+     *\n+     * The key point here is that when you are borrowing a value that\n+     * is \"guaranteed\" by a borrowed pointer, you must link the\n+     * lifetime of that borrowed pointer (L1, here) to the lifetime of\n+     * the borrow itself (L2).  What do I mean by \"guaranteed\" by a\n+     * borrowed pointer? Well, I would say the data \"owned\" by the\n+     * borrowed pointer, except that a borrowed pointer never owns its\n+     * contents, but the relation is the same.  That is, I mean any\n+     * data that is reached by first derefencing a borrowed pointer\n+     * and then either traversing interior offsets or owned pointers.\n+     * We say that the guarantor of such data it the region of the borrowed\n+     * pointer that was traversed.\n+     *\n+     * NB: I really wanted to use the `mem_categorization` code here\n+     * but I cannot because final type resolution hasn't happened yet.\n+     * So this is very similar logic to what you would find there,\n+     * but more special purpose.\n+     */\n+\n+    pub fn for_addr_of(rcx: @rcx, expr: @ast::expr, base: @ast::expr) {\n+        /*!\n+         *\n+         * Computes the guarantor for an expression `&base` and then\n+         * ensures that the lifetime of the resulting pointer is linked.\n+         */\n+\n+        debug!(\"guarantor::for_addr_of(base=%s)\", rcx.fcx.expr_to_str(base));\n+        let _i = ::util::common::indenter();\n+\n+        let guarantor = guarantor(rcx, base);\n+        link(rcx, expr.span, expr.id, guarantor);\n+    }\n+\n+    pub fn for_match(rcx: @rcx, discr: @ast::expr, arms: &[ast::arm]) {\n+        /*!\n+         *\n+         * Computes the guarantors for any ref bindings in a match and\n+         * then ensures that the lifetime of the resulting pointer is\n+         * linked.\n+         */\n+\n+        let discr_guarantor = guarantor(rcx, discr);\n+        for arms.each |arm| {\n+            for arm.pats.each |pat| {\n+                link_ref_bindings_in_pat(rcx, *pat, discr_guarantor);\n+            }\n+        }\n+    }\n+\n+    fn link(\n+        rcx: @rcx,\n+        span: span,\n+        id: ast::node_id,\n+        guarantor: Option<ty::Region>)\n+    {\n+        /*!\n+         *\n+         * Links the lifetime of the borrowed pointer resulting from a borrow\n+         * to the lifetime of its guarantor.\n+         */\n+\n+        debug!(\"opt_constrain_region(id=%?, guarantor=%?)\", id, guarantor);\n+\n+        let bound = match guarantor {\n+            None => { return; }\n+            Some(r) => { r }\n+        };\n+\n+        // this routine is used for the result of ref bindings and &\n+        // expressions, both of which always yield a region variable, so\n+        // mk_subr should never fail.\n+        for rcx.resolve_node_type(id).each |rptr_ty| {\n+            debug!(\"rptr_ty=%s\", ty_to_str(rcx.fcx.ccx.tcx, *rptr_ty));\n+            let r = ty::ty_region(*rptr_ty);\n+            infallibly_mk_subr(rcx, true, span, r, bound);\n+        }\n+    }\n+\n+    enum PointerCat {\n+        NotPointer,\n+        OwnedPointer,\n+        BorrowedPointer(ty::Region),\n+        OtherPointer\n+    }\n+\n+    struct ExprCategorization {\n+        guarantor: Option<ty::Region>,\n+        pointer: PointerCat\n+    }\n+\n+    fn guarantor(rcx: @rcx, expr: @ast::expr) -> Option<ty::Region> {\n+        debug!(\"guarantor(expr=%s)\", rcx.fcx.expr_to_str(expr));\n+        match expr.node {\n+            ast::expr_unary(ast::deref, b) => {\n+                let cat = categorize(rcx, b);\n+                guarantor_of_deref(&cat)\n+            }\n+            ast::expr_field(b, _, _) => {\n+                categorize(rcx, b).guarantor\n+            }\n+            ast::expr_index(b, _) => {\n+                let cat = categorize(rcx, b);\n+                guarantor_of_deref(&cat)\n+            }\n+\n+            ast::expr_paren(e) => {\n+                guarantor(rcx, e)\n+            }\n+\n+            ast::expr_path(*) => {\n+                // Either a variable or constant and hence resides\n+                // in constant memory or on the stack frame.  Either way,\n+                // not guaranteed by a region pointer.\n+                None\n+            }\n+\n+            // All of these expressions are rvalues and hence their\n+            // value is not guaranteed by a region pointer.\n+            ast::expr_mac(*) |\n+            ast::expr_lit(_) |\n+            ast::expr_unary(*) |\n+            ast::expr_addr_of(*) |\n+            ast::expr_binary(*) |\n+            ast::expr_vstore(*) |\n+            ast::expr_break(*) |\n+            ast::expr_again(*) |\n+            ast::expr_ret(*) |\n+            ast::expr_log(*) |\n+            ast::expr_fail(*) |\n+            ast::expr_assert(*) |\n+            ast::expr_while(*) |\n+            ast::expr_loop(*) |\n+            ast::expr_assign(*) |\n+            ast::expr_swap(*) |\n+            ast::expr_assign_op(*) |\n+            ast::expr_cast(*) |\n+            ast::expr_call(*) |\n+            ast::expr_method_call(*) |\n+            ast::expr_rec(*) |\n+            ast::expr_struct(*) |\n+            ast::expr_tup(*) |\n+            ast::expr_if(*) |\n+            ast::expr_match(*) |\n+            ast::expr_fn(*) |\n+            ast::expr_fn_block(*) |\n+            ast::expr_loop_body(*) |\n+            ast::expr_do_body(*) |\n+            ast::expr_block(*) |\n+            ast::expr_copy(*) |\n+            ast::expr_unary_move(*) |\n+            ast::expr_repeat(*) |\n+            ast::expr_vec(*) => {\n+                assert !ty::expr_is_lval(\n+                    rcx.fcx.tcx(), rcx.fcx.ccx.method_map, expr);\n+                None\n+            }\n+        }\n+    }\n+\n+    fn categorize(rcx: @rcx,\n+                  expr: @ast::expr) -> ExprCategorization\n+    {\n+        debug!(\"categorize(expr=%s)\", rcx.fcx.expr_to_str(expr));\n+        let _i = ::util::common::indenter();\n+\n+        let tcx = rcx.fcx.ccx.tcx;\n+        if rcx.fcx.ccx.method_map.contains_key(expr.id) {\n+            debug!(\"method call\");\n+            return id_categorization(rcx, None, expr.id);\n+        }\n+\n+        let expr_ty = match rcx.resolve_node_type(expr.id) {\n+            None => { return id_categorization(rcx, None, expr.id); }\n+            Some(t) => { t }\n+        };\n+        let mut cat = ExprCategorization {\n+            guarantor: guarantor(rcx, expr),\n+            pointer: pointer_categorize(expr_ty)\n+        };\n+\n+        debug!(\"before adjustments, cat=%?\", cat);\n+\n+        for rcx.fcx.inh.adjustments.find(expr.id).each |adjustment| {\n+            debug!(\"adjustment=%?\", adjustment);\n+            for uint::range(0, adjustment.autoderefs) |_| {\n+                cat.guarantor = guarantor_of_deref(&cat);\n+\n+                match ty::deref(tcx, expr_ty, true) {\n+                    Some(t) => {\n+                        cat.pointer = pointer_categorize(t.ty);\n+                    }\n+                    None => {\n+                        tcx.sess.span_bug(\n+                            expr.span,\n+                            fmt!(\"Autoderef but type not derefable: %s\",\n+                                 ty_to_str(tcx, expr_ty)));\n+                    }\n+                }\n+\n+                debug!(\"autoderef, cat=%?\", cat);\n+            }\n+\n+            for adjustment.autoref.each |autoref| {\n+                cat.guarantor = None;\n+                cat.pointer = BorrowedPointer(autoref.region);\n+                debug!(\"autoref, cat=%?\", cat);\n+            }\n+        }\n+\n+        debug!(\"result=%?\", cat);\n+        return cat;\n+    }\n+\n+    fn pointer_categorize(ty: ty::t) -> PointerCat {\n+        match ty::get(ty).sty {\n+            ty::ty_rptr(r, _) | ty::ty_evec(_, vstore_slice(r)) |\n+            ty::ty_estr(vstore_slice(r)) => {\n+                BorrowedPointer(r)\n+            }\n+            ty::ty_uniq(*) | ty::ty_estr(vstore_uniq) |\n+            ty::ty_evec(_, vstore_uniq) => {\n+                OwnedPointer\n+            }\n+            ty::ty_box(*) | ty::ty_ptr(*) |\n+            ty::ty_evec(_, vstore_box) |\n+            ty::ty_estr(vstore_box) => {\n+                OtherPointer\n+            }\n+            _ => {\n+                NotPointer\n+            }\n+        }\n+    }\n+\n+    fn id_categorization(rcx: @rcx,\n+                         guarantor: Option<ty::Region>,\n+                         id: ast::node_id) -> ExprCategorization\n+    {\n+        let pointer = match rcx.resolve_node_type(id) {\n+            None => NotPointer,\n+            Some(t) => pointer_categorize(t)\n+        };\n+\n+        ExprCategorization {guarantor: guarantor,\n+                            pointer: pointer}\n+    }\n+\n+    fn guarantor_of_deref(cat: &ExprCategorization) -> Option<ty::Region> {\n+        match cat.pointer {\n+            NotPointer => cat.guarantor,\n+            BorrowedPointer(r) => Some(r),\n+            OwnedPointer => cat.guarantor,\n+            OtherPointer => None\n+        }\n+    }\n+\n+    fn link_ref_bindings_in_pat(\n+        rcx: @rcx,\n+        pat: @ast::pat,\n+        guarantor: Option<ty::Region>)\n+    {\n+        /*!\n+         *\n+         * Descends through the pattern, tracking the guarantor\n+         * of the value being matched.  When a ref binding is encountered,\n+         * links the lifetime of that ref binding to the lifetime of\n+         * the guarantor.  We begin with the guarantor of the\n+         * discriminant but of course as we go we may pass through\n+         * other pointers.\n+         */\n+\n+        debug!(\"link_ref_bindings_in_pat(pat=%s, guarantor=%?)\",\n+               rcx.fcx.pat_to_str(pat), guarantor);\n+        let _i = ::util::common::indenter();\n+\n+        match pat.node {\n+            ast::pat_wild => {}\n+            ast::pat_ident(ast::bind_by_ref(_), _, opt_p) => {\n+                link(rcx, pat.span, pat.id, guarantor);\n+\n+                for opt_p.each |p| {\n+                    link_ref_bindings_in_pat(rcx, *p, guarantor);\n+                }\n+            }\n+            ast::pat_ident(_, _, opt_p) => {\n+                for opt_p.each |p| {\n+                    link_ref_bindings_in_pat(rcx, *p, guarantor);\n+                }\n+            }\n+            ast::pat_enum(*) => {}\n+            ast::pat_rec(ref fpats, _) |\n+            ast::pat_struct(_, ref fpats, _) => {\n+                for fpats.each |fpat| {\n+                    link_ref_bindings_in_pat(rcx, fpat.pat, guarantor);\n+                }\n+            }\n+            ast::pat_tup(ref ps) => {\n+                link_ref_bindings_in_pats(rcx, ps, guarantor)\n+            }\n+            ast::pat_box(p) => {\n+                link_ref_bindings_in_pat(rcx, p, None)\n+            }\n+            ast::pat_uniq(p) => {\n+                link_ref_bindings_in_pat(rcx, p, guarantor)\n+            }\n+            ast::pat_region(p) => {\n+                for rcx.resolve_node_type(pat.id).each |rptr_ty| {\n+                    let r = ty::ty_region(*rptr_ty);\n+                    link_ref_bindings_in_pat(rcx, p, Some(r));\n+                }\n+            }\n+            ast::pat_lit(*) => {}\n+            ast::pat_range(*) => {}\n+            ast::pat_vec(ref ps, ref opt_tail_pat) => {\n+                for rcx.resolve_node_type(pat.id).each |vec_ty| {\n+                    let vstore = ty::ty_vstore(*vec_ty);\n+                    let guarantor1 = match vstore {\n+                        vstore_fixed(_) | vstore_uniq => guarantor,\n+                        vstore_slice(r) => Some(r),\n+                        vstore_box => None\n+                    };\n+\n+                    link_ref_bindings_in_pats(rcx, ps, guarantor1);\n+\n+                    for opt_tail_pat.each |p| {\n+                        link_ref_bindings_in_pat(rcx, *p, guarantor);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn link_ref_bindings_in_pats(rcx: @rcx,\n+                      pats: &~[@ast::pat],\n+                      guarantor: Option<ty::Region>)\n+    {\n+        for pats.each |pat| {\n+            link_ref_bindings_in_pat(rcx, *pat, guarantor);\n+        }\n+    }\n+\n+}\n+\n+fn infallibly_mk_subr(rcx: @rcx,\n+                      a_is_expected: bool,\n+                      span: span,\n+                      a: ty::Region,\n+                      b: ty::Region)\n+{\n+    /*!\n+     *\n+     * Constraints `a` to be a subregion of `b`.  In many cases, we\n+     * know that this can never yield an error due to the way that\n+     * region inferencing works.  Therefore just report a bug if we\n+     * ever see `Err(_)`.\n+     */\n+\n+    match rcx.fcx.mk_subr(a_is_expected, span, a, b) {\n+        result::Ok(()) => {}\n+        result::Err(e) => {\n+            rcx.fcx.ccx.tcx.sess.span_bug(\n+                span,\n+                fmt!(\"Supposedly infallible attempt to \\\n+                      make %? < %? failed: %?\",\n+                     a, b, e));\n+        }\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "ac079f8f04450cf88cc558aee59c4bfad496f578", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4fd30c6ace41638f10e415f6cad175997ec21c4/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4fd30c6ace41638f10e415f6cad175997ec21c4/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=d4fd30c6ace41638f10e415f6cad175997ec21c4", "patch": "@@ -270,6 +270,12 @@ fn expr_repr(cx: ctxt, expr: @ast::expr) -> ~str {\n          pprust::expr_to_str(expr, cx.sess.intr()))\n }\n \n+fn pat_repr(cx: ctxt, pat: @ast::pat) -> ~str {\n+    fmt!(\"pat(%d: %s)\",\n+         pat.id,\n+         pprust::pat_to_str(pat, cx.sess.intr()))\n+}\n+\n fn tys_to_str(cx: ctxt, ts: &[t]) -> ~str {\n     let tstrs = ts.map(|t| ty_to_str(cx, *t));\n     fmt!(\"(%s)\", str::connect(tstrs, \", \"))"}, {"sha": "1bb516e831fd53471edf01e9e01a51103cab91bc", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4fd30c6ace41638f10e415f6cad175997ec21c4/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4fd30c6ace41638f10e415f6cad175997ec21c4/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=d4fd30c6ace41638f10e415f6cad175997ec21c4", "patch": "@@ -879,7 +879,7 @@ fn ser_variant(\n \n     let pat_node = if pats.is_empty() {\n         ast::pat_ident(\n-            ast::bind_by_ref(ast::m_imm),\n+            ast::bind_infer,\n             cx.path(span, ~[v_name]),\n             None\n         )"}, {"sha": "5ff69539606193afa27308340ee24582ee35fec2", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4fd30c6ace41638f10e415f6cad175997ec21c4/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4fd30c6ace41638f10e415f6cad175997ec21c4/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=d4fd30c6ace41638f10e415f6cad175997ec21c4", "patch": "@@ -267,8 +267,14 @@ fn mk_pat(cx: ext_ctxt, span: span, +pat: ast::pat_) -> @ast::pat {\n     @ast::pat { id: cx.next_id(), node: pat, span: span }\n }\n fn mk_pat_ident(cx: ext_ctxt, span: span, ident: ast::ident) -> @ast::pat {\n+    mk_pat_ident_with_binding_mode(cx, span, ident, ast::bind_by_value)\n+}\n+fn mk_pat_ident_with_binding_mode(cx: ext_ctxt,\n+                                  span: span,\n+                                  ident: ast::ident,\n+                                  bm: ast::binding_mode) -> @ast::pat {\n     let path = mk_raw_path(span, ~[ ident ]);\n-    let pat = ast::pat_ident(ast::bind_by_value, path, None);\n+    let pat = ast::pat_ident(bm, path, None);\n     mk_pat(cx, span, move pat)\n }\n fn mk_pat_enum(cx: ext_ctxt,"}, {"sha": "d542b104e541e34269b7f5f6d955481820a76cba", "filename": "src/libsyntax/ext/deriving.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4fd30c6ace41638f10e415f6cad175997ec21c4/src%2Flibsyntax%2Fext%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4fd30c6ace41638f10e415f6cad175997ec21c4/src%2Flibsyntax%2Fext%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving.rs?ref=d4fd30c6ace41638f10e415f6cad175997ec21c4", "patch": "@@ -363,7 +363,8 @@ fn create_enum_variant_pattern(cx: ext_ctxt,\n     match variant.node.kind {\n         tuple_variant_kind(ref variant_args) => {\n             if variant_args.len() == 0 {\n-                return build::mk_pat_ident(cx, span, variant_ident);\n+                return build::mk_pat_ident_with_binding_mode(\n+                    cx, span, variant_ident, ast::bind_infer);\n             }\n \n             let matching_path = build::mk_raw_path(span, ~[ variant_ident ]);"}, {"sha": "594556fffed953e0541344b6c7e2c50479974fdb", "filename": "src/test/run-pass/region-dependent-addr-of.rs", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/d4fd30c6ace41638f10e415f6cad175997ec21c4/src%2Ftest%2Frun-pass%2Fregion-dependent-addr-of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4fd30c6ace41638f10e415f6cad175997ec21c4/src%2Ftest%2Frun-pass%2Fregion-dependent-addr-of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregion-dependent-addr-of.rs?ref=d4fd30c6ace41638f10e415f6cad175997ec21c4", "patch": "@@ -0,0 +1,112 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct A {\n+    value: B\n+}\n+\n+struct B {\n+    v1: int,\n+    v2: [int * 3],\n+    v3: ~[int],\n+    v4: C,\n+    v5: ~C,\n+    v6: Option<C>\n+}\n+\n+struct C {\n+    f: int\n+}\n+\n+fn get_v1(a: &v/A) -> &v/int {\n+    // Region inferencer must deduce that &v < L2 < L1\n+    let foo = &a.value; // L1\n+    &foo.v1             // L2\n+}\n+\n+fn get_v2(a: &v/A, i: uint) -> &v/int {\n+    let foo = &a.value;\n+    &foo.v2[i]\n+}\n+\n+fn get_v3(a: &v/A, i: uint) -> &v/int {\n+    let foo = &a.value;\n+    &foo.v3[i]\n+}\n+\n+fn get_v4(a: &v/A, i: uint) -> &v/int {\n+    let foo = &a.value;\n+    &foo.v4.f\n+}\n+\n+fn get_v5(a: &v/A, i: uint) -> &v/int {\n+    let foo = &a.value;\n+    &foo.v5.f\n+}\n+\n+fn get_v6_a(a: &v/A, i: uint) -> &v/int {\n+    match a.value.v6 {\n+        Some(ref v) => &v.f,\n+        None => fail\n+    }\n+}\n+\n+fn get_v6_b(a: &v/A, i: uint) -> &v/int {\n+    match *a {\n+        A { value: B { v6: Some(ref v), _ } } => &v.f,\n+        _ => fail\n+    }\n+}\n+\n+fn get_v6_c(a: &v/A, i: uint) -> &v/int {\n+    match a {\n+        &A { value: B { v6: Some(ref v), _ } } => &v.f,\n+        _ => fail\n+    }\n+}\n+\n+fn get_v5_ref(a: &v/A, i: uint) -> &v/int {\n+    match &a.value {\n+        &B {v5: ~C {f: ref v}, _} => v\n+    }\n+}\n+\n+fn main() {\n+    let a = A {value: B {v1: 22,\n+                         v2: [23, 24, 25],\n+                         v3: ~[26, 27, 28],\n+                         v4: C { f: 29 },\n+                         v5: ~C { f: 30 },\n+                         v6: Some(C { f: 31 })}};\n+\n+    let p = get_v1(&a);\n+    assert *p == a.value.v1;\n+\n+    let p = get_v2(&a, 1);\n+    assert *p == a.value.v2[1];\n+\n+    let p = get_v3(&a, 1);\n+    assert *p == a.value.v3[1];\n+\n+    let p = get_v4(&a, 1);\n+    assert *p == a.value.v4.f;\n+\n+    let p = get_v5(&a, 1);\n+    assert *p == a.value.v5.f;\n+\n+    let p = get_v6_a(&a, 1);\n+    assert *p == a.value.v6.get().f;\n+\n+    let p = get_v6_b(&a, 1);\n+    assert *p == a.value.v6.get().f;\n+\n+    let p = get_v6_c(&a, 1);\n+    assert *p == a.value.v6.get().f;\n+}"}, {"sha": "8ed85b957ee73f791626c095f2e56ebb4aba7b97", "filename": "src/test/run-pass/region-return-interior-of-option-in-self.rs", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/83ca034d2ed3acf3e9ae3075964763129ab51c23/src%2Ftest%2Frun-pass%2Fregion-return-interior-of-option-in-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ca034d2ed3acf3e9ae3075964763129ab51c23/src%2Ftest%2Frun-pass%2Fregion-return-interior-of-option-in-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregion-return-interior-of-option-in-self.rs?ref=83ca034d2ed3acf3e9ae3075964763129ab51c23", "patch": "@@ -1,30 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// xfail-test (#3148)\n-\n-struct cell<T> {\n-    value: T;\n-}\n-\n-struct cells<T> {\n-    vals: ~[Option<cell<T>>];\n-}\n-\n-impl<T> &cells<T> {\n-    fn get(idx: uint) -> &self/T {\n-        match self.vals[idx] {\n-          Some(ref v) => &v.value,\n-          None => fail\n-        }\n-    }\n-}\n-\n-fn main() {}"}]}