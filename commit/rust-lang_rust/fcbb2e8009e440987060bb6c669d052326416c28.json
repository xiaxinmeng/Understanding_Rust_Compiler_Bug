{"sha": "fcbb2e8009e440987060bb6c669d052326416c28", "node_id": "C_kwDOAAsO6NoAKGZjYmIyZTgwMDllNDQwOTg3MDYwYmI2YzY2OWQwNTIzMjY0MTZjMjg", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-06-29T12:29:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-06-29T12:29:36Z"}, "message": "Rollup merge of #98607 - compiler-errors:tuple-wrap-suggestion, r=oli-obk\n\nClean up arg mismatch diagnostic, generalize tuple wrap suggestion\n\nThis is based on top of #97542, so just look at the last commit which contains the relevant changes.\n\n1. Remove `final_arg_types` which was one of the last places we were using raw (`usize`) indices instead of typed indices in the arg mismatch suggestion code.\n2. Improve the tuple wrap suggestion, now we suggest things like `call(a, b, c, d)` -> `call(a, (b, c), d)` :smiley_cat:\n3. Folded in fix #98645", "tree": {"sha": "e1fcd98790743b4104638c35c026cf204b91a5cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1fcd98790743b4104638c35c026cf204b91a5cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fcbb2e8009e440987060bb6c669d052326416c28", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJivEWwCRBK7hj4Ov3rIwAAlfgIAFq49rEc0NStDsDPtBQM52Nt\n9n1kqRIfZKQijdJZCk3mxsOyP1e5NokVczbsj2wp0Uhl2PjdpvtIeLfzcl+K3i7b\nM+GJA6j2CbvSfvZsz9inRWb79R8aVFDMcIPWXsALvjGeAcYW9eTV5rP/g3NJknrx\nYLFb8zpY5PwDUGuWEXLkB8pNR4JhcQ4in+ciX+Aa0XsxywWqF26UC/rphbnh1Cvv\noxYPngz6TKBu2bpcKhRvZvfJFwLc8IZTpqIAGVe5dJtUZURmu79rq3wDxaq22bxM\ngEWnPcZ54AZuZbpTGd5+tNsPyRL+g0s28SqdjCm8ymEpr2d9rJ5iaXe25dDLjJM=\n=Ar9w\n-----END PGP SIGNATURE-----\n", "payload": "tree e1fcd98790743b4104638c35c026cf204b91a5cd\nparent b2836bd34c34b60de93e6bc1c548bb9349b4dfea\nparent 23f3b0dfd04812b03da0df4d5dfad0fef39c6862\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1656505776 +0530\ncommitter GitHub <noreply@github.com> 1656505776 +0530\n\nRollup merge of #98607 - compiler-errors:tuple-wrap-suggestion, r=oli-obk\n\nClean up arg mismatch diagnostic, generalize tuple wrap suggestion\n\nThis is based on top of #97542, so just look at the last commit which contains the relevant changes.\n\n1. Remove `final_arg_types` which was one of the last places we were using raw (`usize`) indices instead of typed indices in the arg mismatch suggestion code.\n2. Improve the tuple wrap suggestion, now we suggest things like `call(a, b, c, d)` -> `call(a, (b, c), d)` :smiley_cat:\n3. Folded in fix #98645\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fcbb2e8009e440987060bb6c669d052326416c28", "html_url": "https://github.com/rust-lang/rust/commit/fcbb2e8009e440987060bb6c669d052326416c28", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fcbb2e8009e440987060bb6c669d052326416c28/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2836bd34c34b60de93e6bc1c548bb9349b4dfea", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2836bd34c34b60de93e6bc1c548bb9349b4dfea", "html_url": "https://github.com/rust-lang/rust/commit/b2836bd34c34b60de93e6bc1c548bb9349b4dfea"}, {"sha": "23f3b0dfd04812b03da0df4d5dfad0fef39c6862", "url": "https://api.github.com/repos/rust-lang/rust/commits/23f3b0dfd04812b03da0df4d5dfad0fef39c6862", "html_url": "https://github.com/rust-lang/rust/commit/23f3b0dfd04812b03da0df4d5dfad0fef39c6862"}], "stats": {"total": 471, "additions": 275, "deletions": 196}, "files": [{"sha": "e319f17b0e60d5fccc69536a0b085b279e2f4c91", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fcbb2e8009e440987060bb6c669d052326416c28/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcbb2e8009e440987060bb6c669d052326416c28/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=fcbb2e8009e440987060bb6c669d052326416c28", "patch": "@@ -342,8 +342,8 @@ pub fn same_type_modulo_infer<'tcx>(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n         )\n         | (&ty::Infer(ty::InferTy::TyVar(_)), _)\n         | (_, &ty::Infer(ty::InferTy::TyVar(_))) => true,\n-        (&ty::Ref(reg_a, ty_a, mut_a), &ty::Ref(reg_b, ty_b, mut_b)) => {\n-            reg_a == reg_b && mut_a == mut_b && same_type_modulo_infer(*ty_a, *ty_b)\n+        (&ty::Ref(_, ty_a, mut_a), &ty::Ref(_, ty_b, mut_b)) => {\n+            mut_a == mut_b && same_type_modulo_infer(*ty_a, *ty_b)\n         }\n         _ => a == b,\n     }"}, {"sha": "dc49ff90f34b0035dd77a4a5ead4c66c8641aa99", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 169, "deletions": 177, "changes": 346, "blob_url": "https://github.com/rust-lang/rust/blob/fcbb2e8009e440987060bb6c669d052326416c28/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcbb2e8009e440987060bb6c669d052326416c28/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=fcbb2e8009e440987060bb6c669d052326416c28", "patch": "@@ -24,7 +24,6 @@ use rustc_infer::infer::error_reporting::{FailureCode, ObligationCauseExt};\n use rustc_infer::infer::InferOk;\n use rustc_infer::infer::TypeTrace;\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n-use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::{self, IsSuggestable, Ty, TyCtxt};\n use rustc_session::Session;\n@@ -35,12 +34,6 @@ use rustc_trait_selection::traits::{self, ObligationCauseCode, StatementAsExpres\n use std::iter;\n use std::slice;\n \n-enum TupleMatchFound {\n-    None,\n-    Single,\n-    /// Beginning and end Span\n-    Multiple(Span, Span),\n-}\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub(in super::super) fn check_casts(&self) {\n         let mut deferred_cast_checks = self.deferred_cast_checks.borrow_mut();\n@@ -216,14 +209,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let minimum_input_count = expected_input_tys.len();\n         let provided_arg_count = provided_args.len();\n \n-        // We'll also want to keep track of the fully coerced argument types, for an awkward hack near the end\n-        // FIXME(compiler-errors): Get rid of this, actually.\n-        let mut final_arg_types: Vec<Option<(Ty<'_>, Ty<'_>)>> = vec![None; provided_arg_count];\n-\n         // We introduce a helper function to demand that a given argument satisfy a given input\n         // This is more complicated than just checking type equality, as arguments could be coerced\n         // This version writes those types back so further type checking uses the narrowed types\n-        let demand_compatible = |idx, final_arg_types: &mut Vec<Option<(Ty<'tcx>, Ty<'tcx>)>>| {\n+        let demand_compatible = |idx| {\n             let formal_input_ty: Ty<'tcx> = formal_input_tys[idx];\n             let expected_input_ty: Ty<'tcx> = expected_input_tys[idx];\n             let provided_arg = &provided_args[idx];\n@@ -242,9 +231,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             //    `ExpectHasType(expected_ty)`, or the `formal_ty` otherwise.\n             let coerced_ty = expectation.only_has_type(self).unwrap_or(formal_input_ty);\n \n-            // Keep track of these for below\n-            final_arg_types[idx] = Some((checked_ty, coerced_ty));\n-\n             // Cause selection errors caused by resolving a single argument to point at the\n             // argument and not the call. This lets us customize the span pointed to in the\n             // fulfillment error to be more accurate.\n@@ -253,16 +239,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     self.point_at_type_arg_instead_of_call_if_possible(errors, call_expr);\n                     self.point_at_arg_instead_of_call_if_possible(\n                         errors,\n-                        &final_arg_types,\n                         call_expr,\n                         call_span,\n                         provided_args,\n+                        &expected_input_tys,\n                     );\n                 });\n \n-            // Make sure we store the resolved type\n-            final_arg_types[idx] = Some((checked_ty, coerced_ty));\n-\n             let coerce_error = self\n                 .try_coerce(provided_arg, checked_ty, coerced_ty, AllowTwoPhase::Yes, None)\n                 .err();\n@@ -320,10 +303,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     self.point_at_type_arg_instead_of_call_if_possible(errors, call_expr);\n                     self.point_at_arg_instead_of_call_if_possible(\n                         errors,\n-                        &final_arg_types,\n                         call_expr,\n                         call_span,\n                         &provided_args,\n+                        &expected_input_tys,\n                     );\n                 })\n             }\n@@ -352,7 +335,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     continue;\n                 }\n \n-                let compatible = demand_compatible(idx, &mut final_arg_types);\n+                let compatible = demand_compatible(idx);\n                 let is_compatible = matches!(compatible, Compatibility::Compatible);\n                 compatibility_diagonal[idx] = compatible;\n \n@@ -445,72 +428,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 None => \"function\",\n             };\n \n-            let try_tuple_wrap_args = || {\n-                // The case where we expect a single tuple and wrapping all the args\n-                // in parentheses (or adding a comma to already existing parentheses)\n-                // will result in a tuple that satisfies the call.\n-                // This isn't super ideal code, because we copy code from elsewhere\n-                // and somewhat duplicate this. We also delegate to the general type\n-                // mismatch suggestions for the single arg case.\n-                match self.suggested_tuple_wrap(&expected_input_tys, provided_args) {\n-                    TupleMatchFound::Single => {\n-                        let expected_ty = expected_input_tys[0];\n-                        let provided_ty = final_arg_types[0].map(|ty| ty.0).unwrap();\n-                        let expected_ty = self.resolve_vars_if_possible(expected_ty);\n-                        let provided_ty = self.resolve_vars_if_possible(provided_ty);\n-                        let cause = &self.misc(provided_args[0].span);\n-                        let compatibility = demand_compatible(0, &mut final_arg_types);\n-                        let type_error = match compatibility {\n-                            Compatibility::Incompatible(Some(error)) => error,\n-                            _ => TypeError::Mismatch,\n-                        };\n-                        let trace = TypeTrace::types(cause, true, expected_ty, provided_ty);\n-                        let mut err = self.report_and_explain_type_error(trace, &type_error);\n-                        self.emit_coerce_suggestions(\n-                            &mut err,\n-                            &provided_args[0],\n-                            final_arg_types[0].map(|ty| ty.0).unwrap(),\n-                            final_arg_types[0].map(|ty| ty.1).unwrap(),\n-                            None,\n-                            None,\n-                        );\n-                        err.span_label(\n-                            full_call_span,\n-                            format!(\"arguments to this {} are incorrect\", call_name),\n-                        );\n-                        // Call out where the function is defined\n-                        label_fn_like(tcx, &mut err, fn_def_id);\n-                        err.emit();\n-                        return true;\n-                    }\n-                    TupleMatchFound::Multiple(start, end) => {\n-                        let mut err = tcx.sess.struct_span_err_with_code(\n-                            full_call_span,\n-                            &format!(\n-                                \"this {} takes {}{} but {} {} supplied\",\n-                                call_name,\n-                                if c_variadic { \"at least \" } else { \"\" },\n-                                potentially_plural_count(minimum_input_count, \"argument\"),\n-                                potentially_plural_count(provided_arg_count, \"argument\"),\n-                                if provided_arg_count == 1 { \"was\" } else { \"were\" }\n-                            ),\n-                            DiagnosticId::Error(err_code.to_owned()),\n-                        );\n-                        // Call out where the function is defined\n-                        label_fn_like(tcx, &mut err, fn_def_id);\n-                        err.multipart_suggestion(\n-                            \"use parentheses to construct a tuple\",\n-                            vec![(start, '('.to_string()), (end, ')'.to_string())],\n-                            Applicability::MachineApplicable,\n-                        );\n-                        err.emit();\n-                        return true;\n-                    }\n-                    TupleMatchFound::None => {}\n-                }\n-                false\n-            };\n-\n             let compatibility_diagonal = IndexVec::from_raw(compatibility_diagonal);\n             let provided_args = IndexVec::from_iter(provided_args.iter().take(if c_variadic {\n                 minimum_input_count\n@@ -541,7 +458,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 c_variadic,\n                 err_code,\n                 fn_def_id,\n-                try_tuple_wrap_args,\n             );\n         }\n     }\n@@ -558,7 +474,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         c_variadic: bool,\n         err_code: &str,\n         fn_def_id: Option<DefId>,\n-        try_tuple_wrap_args: impl FnOnce() -> bool,\n     ) {\n         // Don't print if it has error types or is just plain `_`\n         fn has_error_or_infer<'tcx>(tys: impl IntoIterator<Item = Ty<'tcx>>) -> bool {\n@@ -578,7 +493,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             let (formal_input_ty, expected_input_ty) = formal_and_expected_inputs[expected_idx];\n             // If either is an error type, we defy the usual convention and consider them to *not* be\n-            // coercible.  This prevents our error message heuristic from trying to pass errors into\n+            // coercible. This prevents our error message heuristic from trying to pass errors into\n             // every argument.\n             if (formal_input_ty, expected_input_ty).references_error() {\n                 return Compatibility::Incompatible(None);\n@@ -599,16 +514,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 return Compatibility::Incompatible(None);\n             }\n \n-            let subtyping_result = self\n-                .at(&self.misc(provided_arg.span), self.param_env)\n-                .sup(formal_input_ty, coerced_ty);\n+            // Using probe here, since we don't want this subtyping to affect inference.\n+            let subtyping_error = self.probe(|_| {\n+                self.at(&self.misc(provided_arg.span), self.param_env)\n+                    .sup(formal_input_ty, coerced_ty)\n+                    .err()\n+            });\n \n             // Same as above: if either the coerce type or the checked type is an error type,\n             // consider them *not* compatible.\n             let references_error = (coerced_ty, checked_ty).references_error();\n-            match (references_error, &subtyping_result) {\n-                (false, Ok(_)) => Compatibility::Compatible,\n-                _ => Compatibility::Incompatible(subtyping_result.err()),\n+            match (references_error, subtyping_error) {\n+                (false, None) => Compatibility::Compatible,\n+                (_, subtyping_error) => Compatibility::Incompatible(subtyping_error),\n             }\n         };\n \n@@ -629,16 +547,105 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .iter()\n             .map(|expr| {\n                 let ty = self\n-                    .in_progress_typeck_results\n-                    .as_ref()\n-                    .unwrap()\n+                    .typeck_results\n                     .borrow()\n                     .expr_ty_adjusted_opt(*expr)\n                     .unwrap_or_else(|| tcx.ty_error());\n                 (self.resolve_vars_if_possible(ty), expr.span)\n             })\n             .collect();\n \n+        // First, check if we just need to wrap some arguments in a tuple.\n+        if let Some((mismatch_idx, terr)) =\n+            compatibility_diagonal.iter().enumerate().find_map(|(i, c)| {\n+                if let Compatibility::Incompatible(Some(terr)) = c { Some((i, terr)) } else { None }\n+            })\n+        {\n+            // Is the first bad expected argument a tuple?\n+            // Do we have as many extra provided arguments as the tuple's length?\n+            // If so, we might have just forgotten to wrap some args in a tuple.\n+            if let Some(ty::Tuple(tys)) =\n+                formal_and_expected_inputs.get(mismatch_idx.into()).map(|tys| tys.1.kind())\n+                && provided_arg_tys.len() == formal_and_expected_inputs.len() - 1 + tys.len()\n+            {\n+                // Wrap up the N provided arguments starting at this position in a tuple.\n+                let provided_as_tuple = tcx.mk_tup(\n+                    provided_arg_tys.iter().map(|(ty, _)| *ty).skip(mismatch_idx).take(tys.len()),\n+                );\n+\n+                let mut satisfied = true;\n+                // Check if the newly wrapped tuple + rest of the arguments are compatible.\n+                for ((_, expected_ty), provided_ty) in std::iter::zip(\n+                    formal_and_expected_inputs.iter().skip(mismatch_idx),\n+                    [provided_as_tuple].into_iter().chain(\n+                        provided_arg_tys.iter().map(|(ty, _)| *ty).skip(mismatch_idx + tys.len()),\n+                    ),\n+                ) {\n+                    if !self.can_coerce(provided_ty, *expected_ty) {\n+                        satisfied = false;\n+                        break;\n+                    }\n+                }\n+\n+                // If they're compatible, suggest wrapping in an arg, and we're done!\n+                // Take some care with spans, so we don't suggest wrapping a macro's\n+                // innards in parenthesis, for example.\n+                if satisfied\n+                    && let Some(lo) =\n+                        provided_args[mismatch_idx.into()].span.find_ancestor_inside(error_span)\n+                    && let Some(hi) = provided_args[(mismatch_idx + tys.len() - 1).into()]\n+                        .span\n+                        .find_ancestor_inside(error_span)\n+                {\n+                    let mut err;\n+                    if tys.len() == 1 {\n+                        // A tuple wrap suggestion actually occurs within,\n+                        // so don't do anything special here.\n+                        err = self.report_and_explain_type_error(\n+                            TypeTrace::types(\n+                                &self.misc(lo),\n+                                true,\n+                                formal_and_expected_inputs[mismatch_idx.into()].1,\n+                                provided_arg_tys[mismatch_idx.into()].0,\n+                            ),\n+                            terr,\n+                        );\n+                        err.span_label(\n+                            full_call_span,\n+                            format!(\"arguments to this {} are incorrect\", call_name),\n+                        );\n+                    } else {\n+                        err = tcx.sess.struct_span_err_with_code(\n+                            full_call_span,\n+                            &format!(\n+                                \"this {} takes {}{} but {} {} supplied\",\n+                                call_name,\n+                                if c_variadic { \"at least \" } else { \"\" },\n+                                potentially_plural_count(\n+                                    formal_and_expected_inputs.len(),\n+                                    \"argument\"\n+                                ),\n+                                potentially_plural_count(provided_args.len(), \"argument\"),\n+                                if provided_args.len() == 1 { \"was\" } else { \"were\" }\n+                            ),\n+                            DiagnosticId::Error(err_code.to_owned()),\n+                        );\n+                        err.multipart_suggestion_verbose(\n+                            \"wrap these arguments in parentheses to construct a tuple\",\n+                            vec![\n+                                (lo.shrink_to_lo(), \"(\".to_string()),\n+                                (hi.shrink_to_hi(), \")\".to_string()),\n+                            ],\n+                            Applicability::MachineApplicable,\n+                        );\n+                    };\n+                    label_fn_like(tcx, &mut err, fn_def_id);\n+                    err.emit();\n+                    return;\n+                }\n+            }\n+        }\n+\n         // Okay, so here's where it gets complicated in regards to what errors\n         // we emit and how.\n         // There are 3 different \"types\" of errors we might encounter.\n@@ -666,7 +673,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     )\n                     .note(\n                         \"we would appreciate a bug report: \\\n-                        https://github.com/rust-lang/rust-clippy/issues/new\",\n+                        https://github.com/rust-lang/rust/issues/new\",\n                     )\n                     .emit();\n             }\n@@ -727,13 +734,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return;\n         }\n \n-        // Second, let's try tuple wrapping the args.\n-        // FIXME(compiler-errors): This is currently in its own closure because\n-        // I didn't want to factor it out.\n-        if try_tuple_wrap_args() {\n-            return;\n-        }\n-\n         let mut err = if formal_and_expected_inputs.len() == provided_args.len() {\n             struct_span_err!(\n                 tcx.sess,\n@@ -989,13 +989,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         } else {\n                             String::new()\n                         };\n-                        // FIXME(compiler-errors): Why do we get permutations with the same type?\n-                        if expected_ty != provided_ty {\n-                            labels.push((\n-                                provided_span,\n-                                format!(\"expected `{}`{}\", expected_ty, provided_ty_name),\n-                            ));\n-                        }\n+                        labels.push((\n+                            provided_span,\n+                            format!(\"expected `{}`{}\", expected_ty, provided_ty_name),\n+                        ));\n                     }\n \n                     suggestion_text = match suggestion_text {\n@@ -1043,10 +1040,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 } else {\n                     needs_comma = true;\n                 }\n-                let suggestion_text =\n-                    if let Some(provided_idx) = provided_idx\n+                let suggestion_text = if let Some(provided_idx) = provided_idx\n                     && let (_, provided_span) = provided_arg_tys[*provided_idx]\n-                    && let Ok(arg_text) = source_map.span_to_snippet(provided_span.source_callsite()) {\n+                    && let Ok(arg_text) =\n+                        source_map.span_to_snippet(provided_span.source_callsite())\n+                {\n                     arg_text\n                 } else {\n                     // Propose a placeholder of the correct type\n@@ -1073,38 +1071,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err.emit();\n     }\n \n-    fn suggested_tuple_wrap(\n-        &self,\n-        expected_input_tys: &[Ty<'tcx>],\n-        provided_args: &'tcx [hir::Expr<'tcx>],\n-    ) -> TupleMatchFound {\n-        // Only handle the case where we expect only one tuple arg\n-        let [expected_arg_type] = expected_input_tys[..] else { return TupleMatchFound::None };\n-        let &ty::Tuple(expected_types) = self.resolve_vars_if_possible(expected_arg_type).kind()\n-            else { return TupleMatchFound::None };\n-\n-        // First check that there are the same number of types.\n-        if expected_types.len() != provided_args.len() {\n-            return TupleMatchFound::None;\n-        }\n-\n-        let supplied_types: Vec<_> = provided_args.iter().map(|arg| self.check_expr(arg)).collect();\n-\n-        let all_match = iter::zip(expected_types, supplied_types)\n-            .all(|(expected, supplied)| self.can_eq(self.param_env, expected, supplied).is_ok());\n-\n-        if !all_match {\n-            return TupleMatchFound::None;\n-        }\n-        match provided_args {\n-            [] => TupleMatchFound::None,\n-            [_] => TupleMatchFound::Single,\n-            [first, .., last] => {\n-                TupleMatchFound::Multiple(first.span.shrink_to_lo(), last.span.shrink_to_hi())\n-            }\n-        }\n-    }\n-\n     // AST fragment checking\n     pub(in super::super) fn check_lit(\n         &self,\n@@ -1652,18 +1618,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn point_at_arg_instead_of_call_if_possible(\n         &self,\n         errors: &mut Vec<traits::FulfillmentError<'tcx>>,\n-        final_arg_types: &[Option<(Ty<'tcx>, Ty<'tcx>)>],\n         expr: &'tcx hir::Expr<'tcx>,\n         call_sp: Span,\n         args: &'tcx [hir::Expr<'tcx>],\n+        expected_tys: &[Ty<'tcx>],\n     ) {\n         // We *do not* do this for desugared call spans to keep good diagnostics when involving\n         // the `?` operator.\n         if call_sp.desugaring_kind().is_some() {\n             return;\n         }\n \n-        for error in errors {\n+        'outer: for error in errors {\n             // Only if the cause is somewhere inside the expression we want try to point at arg.\n             // Otherwise, it means that the cause is somewhere else and we should not change\n             // anything because we can break the correct span.\n@@ -1688,39 +1654,65 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     (result_code, code) = (code, parent);\n                 }\n             }\n-            let self_: ty::subst::GenericArg<'_> = match unpeel_to_top(error.obligation.cause.code()) {\n-                ObligationCauseCode::BuiltinDerivedObligation(code) |\n-                ObligationCauseCode::DerivedObligation(code) => {\n-                    code.parent_trait_pred.self_ty().skip_binder().into()\n-                }\n-                ObligationCauseCode::ImplDerivedObligation(code) => {\n-                    code.derived.parent_trait_pred.self_ty().skip_binder().into()\n-                }\n-                _ if let ty::PredicateKind::Trait(predicate) =\n-                    error.obligation.predicate.kind().skip_binder() => {\n+            let self_: ty::subst::GenericArg<'_> =\n+                match unpeel_to_top(error.obligation.cause.code()) {\n+                    ObligationCauseCode::BuiltinDerivedObligation(code)\n+                    | ObligationCauseCode::DerivedObligation(code) => {\n+                        code.parent_trait_pred.self_ty().skip_binder().into()\n+                    }\n+                    ObligationCauseCode::ImplDerivedObligation(code) => {\n+                        code.derived.parent_trait_pred.self_ty().skip_binder().into()\n+                    }\n+                    _ if let ty::PredicateKind::Trait(predicate) =\n+                        error.obligation.predicate.kind().skip_binder() =>\n+                    {\n                         predicate.self_ty().into()\n                     }\n-                _ =>  continue,\n-            };\n+                    _ => continue,\n+                };\n             let self_ = self.resolve_vars_if_possible(self_);\n+            let ty_matches_self = |ty: Ty<'tcx>| ty.walk().any(|arg| arg == self_);\n+\n+            let typeck_results = self.typeck_results.borrow();\n+\n+            for (idx, arg) in args.iter().enumerate() {\n+                // Don't adjust the span if we already have a more precise span\n+                // within one of the args.\n+                if arg.span.contains(error.obligation.cause.span) {\n+                    let references_arg =\n+                        typeck_results.expr_ty_opt(arg).map_or(false, &ty_matches_self)\n+                            || expected_tys.get(idx).copied().map_or(false, &ty_matches_self);\n+                    if references_arg && !arg.span.from_expansion() {\n+                        error.obligation.cause.map_code(|parent_code| {\n+                            ObligationCauseCode::FunctionArgumentObligation {\n+                                arg_hir_id: args[idx].hir_id,\n+                                call_hir_id: expr.hir_id,\n+                                parent_code,\n+                            }\n+                        })\n+                    }\n+                    continue 'outer;\n+                }\n+            }\n \n             // Collect the argument position for all arguments that could have caused this\n             // `FulfillmentError`.\n-            let mut referenced_in = final_arg_types\n-                .iter()\n+            let mut referenced_in: Vec<_> = std::iter::zip(expected_tys, args)\n                 .enumerate()\n-                .filter_map(|(i, arg)| match arg {\n-                    Some((checked_ty, coerce_ty)) => Some([(i, *checked_ty), (i, *coerce_ty)]),\n-                    _ => None,\n+                .flat_map(|(idx, (expected_ty, arg))| {\n+                    if let Some(arg_ty) = typeck_results.expr_ty_opt(arg) {\n+                        vec![(idx, arg_ty), (idx, *expected_ty)]\n+                    } else {\n+                        vec![]\n+                    }\n                 })\n-                .flatten()\n-                .flat_map(|(i, ty)| {\n+                .filter_map(|(i, ty)| {\n                     let ty = self.resolve_vars_if_possible(ty);\n                     // We walk the argument type because the argument's type could have\n                     // been `Option<T>`, but the `FulfillmentError` references `T`.\n-                    if ty.walk().any(|arg| arg == self_) { Some(i) } else { None }\n+                    if ty_matches_self(ty) { Some(i) } else { None }\n                 })\n-                .collect::<Vec<usize>>();\n+                .collect();\n \n             // Both checked and coerced types could have matched, thus we need to remove\n             // duplicates.\n@@ -1729,18 +1721,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             referenced_in.sort_unstable();\n             referenced_in.dedup();\n \n-            if let (Some(ref_in), None) = (referenced_in.pop(), referenced_in.pop()) {\n+            if let &[idx] = &referenced_in[..] {\n                 // Do not point at the inside of a macro.\n                 // That would often result in poor error messages.\n-                if args[ref_in].span.from_expansion() {\n-                    return;\n+                if args[idx].span.from_expansion() {\n+                    continue;\n                 }\n                 // We make sure that only *one* argument matches the obligation failure\n                 // and we assign the obligation's span to its expression's.\n-                error.obligation.cause.span = args[ref_in].span;\n+                error.obligation.cause.span = args[idx].span;\n                 error.obligation.cause.map_code(|parent_code| {\n                     ObligationCauseCode::FunctionArgumentObligation {\n-                        arg_hir_id: args[ref_in].hir_id,\n+                        arg_hir_id: args[idx].hir_id,\n                         call_hir_id: expr.hir_id,\n                         parent_code,\n                     }"}, {"sha": "a6bd98ddb1977881ceb3a7d5d6ca5476e6a0258a", "filename": "src/test/ui/proc-macro/signature.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fcbb2e8009e440987060bb6c669d052326416c28/src%2Ftest%2Fui%2Fproc-macro%2Fsignature.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fcbb2e8009e440987060bb6c669d052326416c28/src%2Ftest%2Fui%2Fproc-macro%2Fsignature.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fsignature.stderr?ref=fcbb2e8009e440987060bb6c669d052326416c28", "patch": "@@ -5,10 +5,7 @@ LL | / pub unsafe extern \"C\" fn foo(a: i32, b: u32) -> u32 {\n LL | |\n LL | |     loop {}\n LL | | }\n-   | | ^\n-   | | |\n-   | |_call the function in a closure: `|| unsafe { /* code */ }`\n-   |   required by a bound introduced by this call\n+   | |_^ call the function in a closure: `|| unsafe { /* code */ }`\n    |\n    = help: the trait `Fn<(proc_macro::TokenStream,)>` is not implemented for `unsafe extern \"C\" fn(i32, u32) -> u32 {foo}`\n    = note: unsafe function cannot be called generically without an unsafe block"}, {"sha": "2448a5149654d318ef4067e2177a5e08815e4608", "filename": "src/test/ui/suggestions/args-instead-of-tuple.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fcbb2e8009e440987060bb6c669d052326416c28/src%2Ftest%2Fui%2Fsuggestions%2Fargs-instead-of-tuple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fcbb2e8009e440987060bb6c669d052326416c28/src%2Ftest%2Fui%2Fsuggestions%2Fargs-instead-of-tuple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fargs-instead-of-tuple.stderr?ref=fcbb2e8009e440987060bb6c669d052326416c28", "patch": "@@ -9,7 +9,7 @@ note: tuple variant defined here\n    |\n LL |     Ok(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n    |     ^^\n-help: use parentheses to construct a tuple\n+help: wrap these arguments in parentheses to construct a tuple\n    |\n LL |     let _: Result<(i32, i8), ()> = Ok((1, 2));\n    |                                       +    +\n@@ -25,7 +25,7 @@ note: tuple variant defined here\n    |\n LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n    |     ^^^^\n-help: use parentheses to construct a tuple\n+help: wrap these arguments in parentheses to construct a tuple\n    |\n LL |     let _: Option<(i32, i8, &'static str)> = Some((1, 2, \"hi\"));\n    |                                                   +          +\n@@ -97,7 +97,7 @@ note: function defined here\n    |\n LL | fn two_ints(_: (i32, i32)) {\n    |    ^^^^^^^^ -------------\n-help: use parentheses to construct a tuple\n+help: wrap these arguments in parentheses to construct a tuple\n    |\n LL |     two_ints((1, 2));\n    |              +    +\n@@ -113,7 +113,7 @@ note: function defined here\n    |\n LL | fn with_generic<T: Copy + Send>((a, b): (i32, T)) {\n    |    ^^^^^^^^^^^^                 ----------------\n-help: use parentheses to construct a tuple\n+help: wrap these arguments in parentheses to construct a tuple\n    |\n LL |     with_generic((3, 4));\n    |                  +    +\n@@ -129,7 +129,7 @@ note: function defined here\n    |\n LL | fn with_generic<T: Copy + Send>((a, b): (i32, T)) {\n    |    ^^^^^^^^^^^^                 ----------------\n-help: use parentheses to construct a tuple\n+help: wrap these arguments in parentheses to construct a tuple\n    |\n LL |         with_generic((a, b));\n    |                      +    +"}, {"sha": "089c703fda5c7a8101544a7b9148f78b447ba4fe", "filename": "src/test/ui/tuple/add-tuple-within-arguments.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fcbb2e8009e440987060bb6c669d052326416c28/src%2Ftest%2Fui%2Ftuple%2Fadd-tuple-within-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcbb2e8009e440987060bb6c669d052326416c28/src%2Ftest%2Fui%2Ftuple%2Fadd-tuple-within-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftuple%2Fadd-tuple-within-arguments.rs?ref=fcbb2e8009e440987060bb6c669d052326416c28", "patch": "@@ -0,0 +1,10 @@\n+fn foo(s: &str, a: (i32, i32), s2: &str) {}\n+\n+fn bar(s: &str, a: (&str,), s2: &str) {}\n+\n+fn main() {\n+    foo(\"hi\", 1, 2, \"hi\");\n+    //~^ ERROR this function takes 3 arguments but 4 arguments were supplied\n+    bar(\"hi\", \"hi\", \"hi\");\n+    //~^ ERROR mismatched types\n+}"}, {"sha": "95df96ca0dd4f2c09574f8b70cff237b97a06f5e", "filename": "src/test/ui/tuple/add-tuple-within-arguments.stderr", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/fcbb2e8009e440987060bb6c669d052326416c28/src%2Ftest%2Fui%2Ftuple%2Fadd-tuple-within-arguments.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fcbb2e8009e440987060bb6c669d052326416c28/src%2Ftest%2Fui%2Ftuple%2Fadd-tuple-within-arguments.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftuple%2Fadd-tuple-within-arguments.stderr?ref=fcbb2e8009e440987060bb6c669d052326416c28", "patch": "@@ -0,0 +1,40 @@\n+error[E0061]: this function takes 3 arguments but 4 arguments were supplied\n+  --> $DIR/add-tuple-within-arguments.rs:6:5\n+   |\n+LL |     foo(\"hi\", 1, 2, \"hi\");\n+   |     ^^^\n+   |\n+note: function defined here\n+  --> $DIR/add-tuple-within-arguments.rs:1:4\n+   |\n+LL | fn foo(s: &str, a: (i32, i32), s2: &str) {}\n+   |    ^^^ -------  -------------  --------\n+help: wrap these arguments in parentheses to construct a tuple\n+   |\n+LL |     foo(\"hi\", (1, 2), \"hi\");\n+   |               +    +\n+\n+error[E0308]: mismatched types\n+  --> $DIR/add-tuple-within-arguments.rs:8:15\n+   |\n+LL |     bar(\"hi\", \"hi\", \"hi\");\n+   |     ---       ^^^^ expected tuple, found `&str`\n+   |     |\n+   |     arguments to this function are incorrect\n+   |\n+   = note:  expected tuple `(&str,)`\n+           found reference `&'static str`\n+note: function defined here\n+  --> $DIR/add-tuple-within-arguments.rs:3:4\n+   |\n+LL | fn bar(s: &str, a: (&str,), s2: &str) {}\n+   |    ^^^ -------  ----------  --------\n+help: use a trailing comma to create a tuple with one element\n+   |\n+LL |     bar(\"hi\", (\"hi\",), \"hi\");\n+   |               +    ++\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0061, E0308.\n+For more information about an error, try `rustc --explain E0061`."}, {"sha": "0c2a4c41461fc4d108f5656c5bb8917e899df08a", "filename": "src/test/ui/tuple/wrong_argument_ice-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fcbb2e8009e440987060bb6c669d052326416c28/src%2Ftest%2Fui%2Ftuple%2Fwrong_argument_ice-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fcbb2e8009e440987060bb6c669d052326416c28/src%2Ftest%2Fui%2Ftuple%2Fwrong_argument_ice-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftuple%2Fwrong_argument_ice-2.stderr?ref=fcbb2e8009e440987060bb6c669d052326416c28", "patch": "@@ -9,7 +9,7 @@ note: function defined here\n    |\n LL | fn test(t: (i32, i32)) {}\n    |    ^^^^ -------------\n-help: use parentheses to construct a tuple\n+help: wrap these arguments in parentheses to construct a tuple\n    |\n LL |     test((x.qux(), x.qux()));\n    |          +                +"}, {"sha": "ec07f1e70cff6a135376c7f51c3529237dfdd66c", "filename": "src/test/ui/tuple/wrong_argument_ice.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fcbb2e8009e440987060bb6c669d052326416c28/src%2Ftest%2Fui%2Ftuple%2Fwrong_argument_ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fcbb2e8009e440987060bb6c669d052326416c28/src%2Ftest%2Fui%2Ftuple%2Fwrong_argument_ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftuple%2Fwrong_argument_ice.stderr?ref=fcbb2e8009e440987060bb6c669d052326416c28", "patch": "@@ -9,7 +9,7 @@ note: associated function defined here\n    |\n LL |     pub fn push_back(&mut self, value: T) {\n    |            ^^^^^^^^^\n-help: use parentheses to construct a tuple\n+help: wrap these arguments in parentheses to construct a tuple\n    |\n LL |         self.acc.push_back((self.current_provides, self.current_requires));\n    |                            +                                            +"}, {"sha": "0221ef16b4965f30eb121b81b0b3843c40e6f42e", "filename": "src/test/ui/unsized/unsized-fn-param.stderr", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fcbb2e8009e440987060bb6c669d052326416c28/src%2Ftest%2Fui%2Funsized%2Funsized-fn-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fcbb2e8009e440987060bb6c669d052326416c28/src%2Ftest%2Fui%2Funsized%2Funsized-fn-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Funsized-fn-param.stderr?ref=fcbb2e8009e440987060bb6c669d052326416c28", "patch": "@@ -2,7 +2,9 @@ error[E0277]: the size for values of type `str` cannot be known at compilation t\n   --> $DIR/unsized-fn-param.rs:11:11\n    |\n LL |     foo11(\"bar\", &\"baz\");\n-   |           ^^^^^ doesn't have a size known at compile-time\n+   |     ----- ^^^^^ doesn't have a size known at compile-time\n+   |     |\n+   |     required by a bound introduced by this call\n    |\n    = help: the trait `Sized` is not implemented for `str`\n    = note: required for the cast from `str` to the object type `dyn AsRef<Path>`\n@@ -15,7 +17,9 @@ error[E0277]: the size for values of type `str` cannot be known at compilation t\n   --> $DIR/unsized-fn-param.rs:13:19\n    |\n LL |     foo12(&\"bar\", \"baz\");\n-   |                   ^^^^^ doesn't have a size known at compile-time\n+   |     -----         ^^^^^ doesn't have a size known at compile-time\n+   |     |\n+   |     required by a bound introduced by this call\n    |\n    = help: the trait `Sized` is not implemented for `str`\n    = note: required for the cast from `str` to the object type `dyn AsRef<Path>`\n@@ -28,7 +32,9 @@ error[E0277]: the size for values of type `str` cannot be known at compilation t\n   --> $DIR/unsized-fn-param.rs:16:11\n    |\n LL |     foo21(\"bar\", &\"baz\");\n-   |           ^^^^^ doesn't have a size known at compile-time\n+   |     ----- ^^^^^ doesn't have a size known at compile-time\n+   |     |\n+   |     required by a bound introduced by this call\n    |\n    = help: the trait `Sized` is not implemented for `str`\n    = note: required for the cast from `str` to the object type `dyn AsRef<str>`\n@@ -41,7 +47,9 @@ error[E0277]: the size for values of type `str` cannot be known at compilation t\n   --> $DIR/unsized-fn-param.rs:18:19\n    |\n LL |     foo22(&\"bar\", \"baz\");\n-   |                   ^^^^^ doesn't have a size known at compile-time\n+   |     -----         ^^^^^ doesn't have a size known at compile-time\n+   |     |\n+   |     required by a bound introduced by this call\n    |\n    = help: the trait `Sized` is not implemented for `str`\n    = note: required for the cast from `str` to the object type `dyn AsRef<str>`"}, {"sha": "af76aca2c295803a25e0ab072dfd67f837a3ed62", "filename": "src/test/ui/unsized/unsized3.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fcbb2e8009e440987060bb6c669d052326416c28/src%2Ftest%2Fui%2Funsized%2Funsized3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcbb2e8009e440987060bb6c669d052326416c28/src%2Ftest%2Fui%2Funsized%2Funsized3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Funsized3.rs?ref=fcbb2e8009e440987060bb6c669d052326416c28", "patch": "@@ -44,6 +44,7 @@ fn f9<X: ?Sized>(x1: Box<S<X>>) {\n fn f10<X: ?Sized>(x1: Box<S<X>>) {\n     f5(&(32, *x1));\n     //~^ ERROR the size for values of type\n+    //~| ERROR the size for values of type\n }\n \n pub fn main() {}"}, {"sha": "d64091b15eb1fc2c747980353ca77551e9d41dea", "filename": "src/test/ui/unsized/unsized3.stderr", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fcbb2e8009e440987060bb6c669d052326416c28/src%2Ftest%2Fui%2Funsized%2Funsized3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fcbb2e8009e440987060bb6c669d052326416c28/src%2Ftest%2Fui%2Funsized%2Funsized3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Funsized3.stderr?ref=fcbb2e8009e440987060bb6c669d052326416c28", "patch": "@@ -100,6 +100,29 @@ LL - fn f9<X: ?Sized>(x1: Box<S<X>>) {\n LL + fn f9<X>(x1: Box<S<X>>) {\n    |\n \n+error[E0277]: the size for values of type `X` cannot be known at compilation time\n+  --> $DIR/unsized3.rs:45:9\n+   |\n+LL | fn f10<X: ?Sized>(x1: Box<S<X>>) {\n+   |        - this type parameter needs to be `std::marker::Sized`\n+LL |     f5(&(32, *x1));\n+   |     --  ^^^^^^^^^ doesn't have a size known at compile-time\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required because it appears within the type `S<X>`\n+  --> $DIR/unsized3.rs:28:8\n+   |\n+LL | struct S<X: ?Sized> {\n+   |        ^\n+   = note: required because it appears within the type `({integer}, S<X>)`\n+   = note: tuples must have a statically known size to be initialized\n+help: consider removing the `?Sized` bound to make the type parameter `Sized`\n+   |\n+LL - fn f10<X: ?Sized>(x1: Box<S<X>>) {\n+LL + fn f10<X>(x1: Box<S<X>>) {\n+   |\n+\n error[E0277]: the size for values of type `X` cannot be known at compilation time\n   --> $DIR/unsized3.rs:45:8\n    |\n@@ -116,13 +139,21 @@ note: required because it appears within the type `S<X>`\n LL | struct S<X: ?Sized> {\n    |        ^\n    = note: required because it appears within the type `({integer}, S<X>)`\n-   = note: tuples must have a statically known size to be initialized\n+note: required by a bound in `f5`\n+  --> $DIR/unsized3.rs:24:7\n+   |\n+LL | fn f5<Y>(x: &Y) {}\n+   |       ^ required by this bound in `f5`\n help: consider removing the `?Sized` bound to make the type parameter `Sized`\n    |\n LL - fn f10<X: ?Sized>(x1: Box<S<X>>) {\n LL + fn f10<X>(x1: Box<S<X>>) {\n    |\n+help: consider relaxing the implicit `Sized` restriction\n+   |\n+LL | fn f5<Y: ?Sized>(x: &Y) {}\n+   |        ++++++++\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 6 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}]}