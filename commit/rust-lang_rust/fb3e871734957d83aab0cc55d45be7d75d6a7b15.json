{"sha": "fb3e871734957d83aab0cc55d45be7d75d6a7b15", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiM2U4NzE3MzQ5NTdkODNhYWIwY2M1NWQ0NWJlN2Q3NWQ2YTdiMTU=", "commit": {"author": {"name": "James Miller", "email": "james@aatch.net", "date": "2014-12-15T23:35:59Z"}, "committer": {"name": "James Miller", "email": "james@aatch.net", "date": "2014-12-18T02:28:33Z"}, "message": "Add some documentation", "tree": {"sha": "c638e3aaa55f27b54acbdd4e2df8ef3e47652345", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c638e3aaa55f27b54acbdd4e2df8ef3e47652345"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb3e871734957d83aab0cc55d45be7d75d6a7b15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb3e871734957d83aab0cc55d45be7d75d6a7b15", "html_url": "https://github.com/rust-lang/rust/commit/fb3e871734957d83aab0cc55d45be7d75d6a7b15", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb3e871734957d83aab0cc55d45be7d75d6a7b15/comments", "author": {"login": "Aatch", "id": 342416, "node_id": "MDQ6VXNlcjM0MjQxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aatch", "html_url": "https://github.com/Aatch", "followers_url": "https://api.github.com/users/Aatch/followers", "following_url": "https://api.github.com/users/Aatch/following{/other_user}", "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions", "organizations_url": "https://api.github.com/users/Aatch/orgs", "repos_url": "https://api.github.com/users/Aatch/repos", "events_url": "https://api.github.com/users/Aatch/events{/privacy}", "received_events_url": "https://api.github.com/users/Aatch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aatch", "id": 342416, "node_id": "MDQ6VXNlcjM0MjQxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aatch", "html_url": "https://github.com/Aatch", "followers_url": "https://api.github.com/users/Aatch/followers", "following_url": "https://api.github.com/users/Aatch/following{/other_user}", "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions", "organizations_url": "https://api.github.com/users/Aatch/orgs", "repos_url": "https://api.github.com/users/Aatch/repos", "events_url": "https://api.github.com/users/Aatch/events{/privacy}", "received_events_url": "https://api.github.com/users/Aatch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eee209d9e2dde700a3958f3e539eff02b63f50bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/eee209d9e2dde700a3958f3e539eff02b63f50bd", "html_url": "https://github.com/rust-lang/rust/commit/eee209d9e2dde700a3958f3e539eff02b63f50bd"}], "stats": {"total": 39, "additions": 38, "deletions": 1}, "files": [{"sha": "87f9d4c447f9f45909a88896f0cda89f2e66c44a", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb3e871734957d83aab0cc55d45be7d75d6a7b15/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3e871734957d83aab0cc55d45be7d75d6a7b15/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=fb3e871734957d83aab0cc55d45be7d75d6a7b15", "patch": "@@ -1393,6 +1393,16 @@ fn build_cfg(tcx: &ty::ctxt, id: ast::NodeId) -> (ast::NodeId, Option<cfg::CFG>)\n     (blk.id, Some(cfg::CFG::new(tcx, &**blk)))\n }\n \n+// Checks for the presence of \"nested returns\" in a function.\n+// Nested returns are when the inner expression of a return expression\n+// (the 'expr' in 'return expr') contains a return expression. Only cases\n+// where the outer return is actually reachable are considered. Implicit\n+// returns from the end of blocks are considered as well.\n+//\n+// This check is needed to handle the case where the inner expression is\n+// part of a larger expression that may have already partially-filled the\n+// return slot alloca. This can cause errors related to clean-up due to\n+// the clobbering of the existing value in the return slot.\n fn has_nested_returns(tcx: &ty::ctxt, cfg: &cfg::CFG, blk_id: ast::NodeId) -> bool {\n     for n in cfg.graph.depth_traverse(cfg.entry) {\n         match tcx.map.find(n.id) {"}, {"sha": "e55da561c940987a7e357380822ca1ad2e1a8c59", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fb3e871734957d83aab0cc55d45be7d75d6a7b15/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3e871734957d83aab0cc55d45be7d75d6a7b15/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=fb3e871734957d83aab0cc55d45be7d75d6a7b15", "patch": "@@ -112,8 +112,17 @@ pub fn trans_block<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     if dest != expr::Ignore {\n         let block_ty = node_id_type(bcx, b.id);\n+        \n         if b.expr.is_none() || type_is_zero_size(bcx.ccx(), block_ty) {\n             dest = expr::Ignore;\n+        } else if b.expr.is_some() {\n+            // If the block has an expression, but that expression isn't reachable,\n+            // don't save into the destination given, ignore it.\n+            if let Some(ref cfg) = bcx.fcx.cfg {\n+                if !cfg.node_is_reachable(b.expr.as_ref().unwrap().id) {\n+                    dest = expr::Ignore;\n+                }\n+            }\n         }\n     }\n "}, {"sha": "0307412ce74ce677dcbd37814ef9134861bd63b2", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fb3e871734957d83aab0cc55d45be7d75d6a7b15/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3e871734957d83aab0cc55d45be7d75d6a7b15/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=fb3e871734957d83aab0cc55d45be7d75d6a7b15", "patch": "@@ -928,7 +928,25 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             controlflow::trans_cont(bcx, expr.id, label_opt)\n         }\n         ast::ExprRet(ref ex) => {\n-            controlflow::trans_ret(bcx, ex.as_ref().map(|e| &**e))\n+            // Check to see if the return expression itself is reachable.\n+            // This can occur when the inner expression contains a return\n+            let reachable = if let Some(ref cfg) = bcx.fcx.cfg {\n+                cfg.node_is_reachable(expr.id)\n+            } else {\n+                true\n+            };\n+\n+            if reachable {\n+                controlflow::trans_ret(bcx, ex.as_ref().map(|e| &**e))\n+            } else {\n+                // If it's not reachable, just translate the inner expression\n+                // directly. This avoids having to manage a return slot when\n+                // it won't actually be used anyway.\n+                if let &Some(ref x) = ex {\n+                    bcx = trans_into(bcx, &**x, Ignore);\n+                } \n+                bcx\n+            }\n         }\n         ast::ExprWhile(ref cond, ref body, _) => {\n             controlflow::trans_while(bcx, expr.id, &**cond, &**body)"}]}