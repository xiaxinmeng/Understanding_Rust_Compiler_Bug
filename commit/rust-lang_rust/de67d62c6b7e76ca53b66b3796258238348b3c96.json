{"sha": "de67d62c6b7e76ca53b66b3796258238348b3c96", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlNjdkNjJjNmI3ZTc2Y2E1M2I2NmIzNzk2MjU4MjM4MzQ4YjNjOTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-18T02:02:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-18T02:02:57Z"}, "message": "Auto merge of #27474 - bluss:twoway-reverse, r=brson\n\nStrSearcher: Implement the complete reverse case for the two way algorithm\r\n\r\nFix quadratic behavior in StrSearcher in reverse search with periodic\r\nneedles.\r\n\r\nThis commit adds the missing pieces for the \"short period\" case in\r\nreverse search. The short case will show up when the needle is literally\r\nperiodic, for example \"abababab\".\r\n\r\nTwo way uses a \"critical factorization\" of the needle: x = u v.\r\n\r\nSearching matches v first, if mismatch at character k, skip k forward.\r\nMatching u, if mismatch, skip period(x) forward.\r\n\r\nTo avoid O(mn) behavior after mismatch in u, memorize the already\r\nmatched prefix.\r\n\r\nThe short period case requires that |u| < period(x).\r\n\r\nFor the reverse search we need to compute a different critical\r\nfactorization x = u' v' where |v'| < period(x), because we are searching\r\nfor the reversed needle. A short v' also benefits the algorithm in\r\ngeneral.\r\n\r\nThe reverse critical factorization is computed quickly by using the same\r\nmaximal suffix algorithm, but terminating as soon as we have a location\r\nwith local period equal to period(x).\r\n\r\nThis adds extra fields crit_pos_back and memory_back for the reverse\r\ncase. The new overhead for TwoWaySearcher::new is low, and additionally\r\nI think the \"short period\" case is uncommon in many applications of\r\nstring search.\r\n\r\nThe maximal_suffix methods were updated in documentation and the\r\nalgorithms updated to not use !0 and wrapping add, variable left is now\r\n1 larger, offset 1 smaller.\r\n\r\nUse periodicity when computing byteset: in the periodic case, just\r\niterate over one period instead of the whole needle.\r\n\r\nExample before (rfind) after (twoway_rfind) benchmark shows the removal\r\nof quadratic behavior.\r\n\r\nneedle: \"ab\" * 100, haystack: (\"bb\" + \"ab\" * 100) * 100\r\n\r\n```\r\ntest periodic::rfind           ... bench:   1,926,595 ns/iter (+/- 11,390) = 10 MB/s\r\ntest periodic::twoway_rfind    ... bench:      51,740 ns/iter (+/- 66) = 386 MB/s\r\n```", "tree": {"sha": "184df15aa25e6f660686487289af2d102aee2560", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/184df15aa25e6f660686487289af2d102aee2560"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de67d62c6b7e76ca53b66b3796258238348b3c96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de67d62c6b7e76ca53b66b3796258238348b3c96", "html_url": "https://github.com/rust-lang/rust/commit/de67d62c6b7e76ca53b66b3796258238348b3c96", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de67d62c6b7e76ca53b66b3796258238348b3c96/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e35fd748114c22df6d08991980c4f7e199414497", "url": "https://api.github.com/repos/rust-lang/rust/commits/e35fd748114c22df6d08991980c4f7e199414497", "html_url": "https://github.com/rust-lang/rust/commit/e35fd748114c22df6d08991980c4f7e199414497"}, {"sha": "01e88124612471f82b3c62efaad141e61842cfbb", "url": "https://api.github.com/repos/rust-lang/rust/commits/01e88124612471f82b3c62efaad141e61842cfbb", "html_url": "https://github.com/rust-lang/rust/commit/01e88124612471f82b3c62efaad141e61842cfbb"}], "stats": {"total": 277, "additions": 213, "deletions": 64}, "files": [{"sha": "a16809e100fa03face81ec360066e433b0dcce97", "filename": "src/libcollectionstest/str.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/de67d62c6b7e76ca53b66b3796258238348b3c96/src%2Flibcollectionstest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de67d62c6b7e76ca53b66b3796258238348b3c96/src%2Flibcollectionstest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstr.rs?ref=de67d62c6b7e76ca53b66b3796258238348b3c96", "patch": "@@ -85,6 +85,26 @@ fn test_find_str() {\n     assert_eq!(data[43..86].find(\"\u0e22\u4e2d\"), Some(67 - 43));\n     assert_eq!(data[43..86].find(\"i\u1ec7t\"), Some(77 - 43));\n     assert_eq!(data[43..86].find(\"Nam\"), Some(83 - 43));\n+\n+    // find every substring -- assert that it finds it, or an earlier occurence.\n+    let string = \"Vi\u1ec7t Namacbaabcaabaaba\";\n+    for (i, ci) in string.char_indices() {\n+        let ip = i + ci.len_utf8();\n+        for j in string[ip..].char_indices()\n+                             .map(|(i, _)| i)\n+                             .chain(Some(string.len() - ip))\n+        {\n+            let pat = &string[i..ip + j];\n+            assert!(match string.find(pat) {\n+                None => false,\n+                Some(x) => x <= i,\n+            });\n+            assert!(match string.rfind(pat) {\n+                None => false,\n+                Some(x) => x >= i,\n+            });\n+        }\n+    }\n }\n \n fn s(x: &str) -> String { x.to_string() }"}, {"sha": "29130100e996fe5268c28c173de8aff97e74ae7f", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 193, "deletions": 64, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/de67d62c6b7e76ca53b66b3796258238348b3c96/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de67d62c6b7e76ca53b66b3796258238348b3c96/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=de67d62c6b7e76ca53b66b3796258238348b3c96", "patch": "@@ -643,6 +643,8 @@ unsafe impl<'a, 'b> Searcher<'a> for StrSearcher<'a, 'b> {\n             }\n             StrSearcherImpl::TwoWay(ref mut searcher) => {\n                 let is_long = searcher.memory == usize::MAX;\n+                // write out `true` and `false` cases to encourage the compiler\n+                // to specialize the two cases separately.\n                 if is_long {\n                     searcher.next::<MatchOnly>(self.haystack.as_bytes(),\n                                                self.needle.as_bytes(),\n@@ -655,8 +657,8 @@ unsafe impl<'a, 'b> Searcher<'a> for StrSearcher<'a, 'b> {\n             }\n         }\n     }\n-\n }\n+\n unsafe impl<'a, 'b> ReverseSearcher<'a> for StrSearcher<'a, 'b> {\n     #[inline]\n     fn next_back(&mut self) -> SearchStep {\n@@ -678,8 +680,10 @@ unsafe impl<'a, 'b> ReverseSearcher<'a> for StrSearcher<'a, 'b> {\n                 if searcher.end == 0 {\n                     return SearchStep::Done;\n                 }\n+                let is_long = searcher.memory == usize::MAX;\n                 match searcher.next_back::<RejectAndMatch>(self.haystack.as_bytes(),\n-                                                           self.needle.as_bytes())\n+                                                           self.needle.as_bytes(),\n+                                                           is_long)\n                 {\n                     SearchStep::Reject(mut a, b) => {\n                         // skip to next char boundary\n@@ -708,26 +712,43 @@ unsafe impl<'a, 'b> ReverseSearcher<'a> for StrSearcher<'a, 'b> {\n                 }\n             }\n             StrSearcherImpl::TwoWay(ref mut searcher) => {\n-                searcher.next_back::<MatchOnly>(self.haystack.as_bytes(),\n-                                                self.needle.as_bytes())\n+                let is_long = searcher.memory == usize::MAX;\n+                // write out `true` and `false`, like `next_match`\n+                if is_long {\n+                    searcher.next_back::<MatchOnly>(self.haystack.as_bytes(),\n+                                                    self.needle.as_bytes(),\n+                                                    true)\n+                } else {\n+                    searcher.next_back::<MatchOnly>(self.haystack.as_bytes(),\n+                                                    self.needle.as_bytes(),\n+                                                    false)\n+                }\n             }\n         }\n     }\n }\n \n-/// The internal state of an iterator that searches for matches of a substring\n-/// within a larger string using two-way search\n+/// The internal state of the two-way substring search algorithm.\n #[derive(Clone, Debug)]\n struct TwoWaySearcher {\n     // constants\n+    /// critical factorization index\n     crit_pos: usize,\n+    /// critical factorization index for reversed needle\n+    crit_pos_back: usize,\n     period: usize,\n+    /// `byteset` is an extension (not part of the two way algorithm);\n+    /// it's a 64-bit \"fingerprint\" where each set bit `j` corresponds\n+    /// to a (byte & 63) == j present in the needle.\n     byteset: u64,\n \n     // variables\n     position: usize,\n     end: usize,\n-    memory: usize\n+    /// index into needle before which we have already matched\n+    memory: usize,\n+    /// index into needle after which we have already matched\n+    memory_back: usize,\n }\n \n /*\n@@ -799,6 +820,9 @@ struct TwoWaySearcher {\n \n     The purpose of maximal_suffix is to find such a critical factorization.\n \n+    If the period is short, compute another factorization x = u' v' to use\n+    for reverse search, chosen instead so that |v'| < period(x).\n+\n */\n impl TwoWaySearcher {\n     fn new(needle: &[u8], end: usize) -> TwoWaySearcher {\n@@ -812,10 +836,6 @@ impl TwoWaySearcher {\n                 (crit_pos_true, period_true)\n             };\n \n-        // This isn't in the original algorithm, as far as I'm aware.\n-        let byteset = needle.iter()\n-                            .fold(0, |a, &b| (1 << ((b & 0x3f) as usize)) | a);\n-\n         // A particularly readable explanation of what's going on here can be found\n         // in Crochemore and Rytter's book \"Text Algorithms\", ch 13. Specifically\n         // see the code for \"Algorithm CP\" on p. 323.\n@@ -826,31 +846,57 @@ impl TwoWaySearcher {\n         // \"Algorithm CP2\", which is optimized for when the period of the needle\n         // is large.\n         if &needle[..crit_pos] == &needle[period.. period + crit_pos] {\n-            // short period case\n+            // short period case -- the period is exact\n+            // compute a separate critical factorization for the reversed needle\n+            // x = u' v' where |v'| < period(x).\n+            //\n+            // This is sped up by the period being known already.\n+            // Note that a case like x = \"acba\" may be factored exactly forwards\n+            // (crit_pos = 1, period = 3) while being factored with approximate\n+            // period in reverse (crit_pos = 2, period = 2). We use the given\n+            // reverse factorization but keep the exact period.\n+            let crit_pos_back = needle.len() - cmp::max(\n+                TwoWaySearcher::reverse_maximal_suffix(needle, period, false),\n+                TwoWaySearcher::reverse_maximal_suffix(needle, period, true));\n+\n             TwoWaySearcher {\n                 crit_pos: crit_pos,\n+                crit_pos_back: crit_pos_back,\n                 period: period,\n-                byteset: byteset,\n+                byteset: Self::byteset_create(&needle[..period]),\n \n                 position: 0,\n                 end: end,\n-                memory: 0\n+                memory: 0,\n+                memory_back: needle.len(),\n             }\n         } else {\n-            // long period case\n-            // we have an approximation to the actual period, and don't use memory.\n+            // long period case -- we have an approximation to the actual period,\n+            // and don't use memorization.\n+            //\n+            // Approximate the period by lower bound max(|u|, |v|) + 1.\n+            // The critical factorization is efficient to use for both forward and\n+            // reverse search.\n+\n             TwoWaySearcher {\n                 crit_pos: crit_pos,\n+                crit_pos_back: crit_pos,\n                 period: cmp::max(crit_pos, needle.len() - crit_pos) + 1,\n-                byteset: byteset,\n+                byteset: Self::byteset_create(needle),\n \n                 position: 0,\n                 end: end,\n-                memory: usize::MAX // Dummy value to signify that the period is long\n+                memory: usize::MAX, // Dummy value to signify that the period is long\n+                memory_back: usize::MAX,\n             }\n         }\n     }\n \n+    #[inline]\n+    fn byteset_create(bytes: &[u8]) -> u64 {\n+        bytes.iter().fold(0, |a, &b| (1 << (b & 0x3f)) | a)\n+    }\n+\n     #[inline(always)]\n     fn byteset_contains(&self, byte: u8) -> bool {\n         (self.byteset >> ((byte & 0x3f) as usize)) & 1 != 0\n@@ -868,19 +914,25 @@ impl TwoWaySearcher {\n     {\n         // `next()` uses `self.position` as its cursor\n         let old_pos = self.position;\n+        let needle_last = needle.len() - 1;\n         'search: loop {\n             // Check that we have room to search in\n-            if needle.len() > haystack.len() - self.position {\n-                self.position = haystack.len();\n-                return S::rejecting(old_pos, self.position);\n-            }\n+            // position + needle_last can not overflow if we assume slices\n+            // are bounded by isize's range.\n+            let tail_byte = match haystack.get(self.position + needle_last) {\n+                Some(&b) => b,\n+                None => {\n+                    self.position = haystack.len();\n+                    return S::rejecting(old_pos, self.position);\n+                }\n+            };\n \n             if S::use_early_reject() && old_pos != self.position {\n                 return S::rejecting(old_pos, self.position);\n             }\n \n             // Quickly skip by large portions unrelated to our substring\n-            if !self.byteset_contains(haystack[self.position + needle.len() - 1]) {\n+            if !self.byteset_contains(tail_byte) {\n                 self.position += needle.len();\n                 if !long_period {\n                     self.memory = 0;\n@@ -928,19 +980,18 @@ impl TwoWaySearcher {\n \n     // Follows the ideas in `next()`.\n     //\n-    // All the definitions are completely symmetrical, with period(x) = period(reverse(x))\n+    // The definitions are symmetrical, with period(x) = period(reverse(x))\n     // and local_period(u, v) = local_period(reverse(v), reverse(u)), so if (u, v)\n-    // is a critical factorization, so is (reverse(v), reverse(u)). Similarly,\n-    // the \"period\" stored in self.period is the real period if long_period is\n-    // false, and so is still valid for a reversed needle, and if long_period is\n-    // true, all the algorithm requires is that self.period is less than or\n-    // equal to the real period, which must be true for the forward case anyway.\n+    // is a critical factorization, so is (reverse(v), reverse(u)).\n+    //\n+    // For the reverse case we have computed a critical factorization x = u' v'\n+    // (field `crit_pos_back`). We need |u| < period(x) for the forward case and\n+    // thus |v'| < period(x) for the reverse.\n     //\n     // To search in reverse through the haystack, we search forward through\n-    // a reversed haystack with a reversed needle, and the above paragraph shows\n-    // that the precomputed parameters can be left alone.\n+    // a reversed haystack with a reversed needle, matching first u' and then v'.\n     #[inline]\n-    fn next_back<S>(&mut self, haystack: &[u8], needle: &[u8])\n+    fn next_back<S>(&mut self, haystack: &[u8], needle: &[u8], long_period: bool)\n         -> S::Output\n         where S: TwoWayStrategy\n     {\n@@ -949,33 +1000,52 @@ impl TwoWaySearcher {\n         let old_end = self.end;\n         'search: loop {\n             // Check that we have room to search in\n-            if needle.len() > self.end {\n-                self.end = 0;\n-                return S::rejecting(0, old_end);\n-            }\n+            // end - needle.len() will wrap around when there is no more room,\n+            // but due to slice length limits it can never wrap all the way back\n+            // into the length of haystack.\n+            let front_byte = match haystack.get(self.end.wrapping_sub(needle.len())) {\n+                Some(&b) => b,\n+                None => {\n+                    self.end = 0;\n+                    return S::rejecting(0, old_end);\n+                }\n+            };\n \n             if S::use_early_reject() && old_end != self.end {\n                 return S::rejecting(self.end, old_end);\n             }\n \n             // Quickly skip by large portions unrelated to our substring\n-            if !self.byteset_contains(haystack[self.end - needle.len()]) {\n+            if !self.byteset_contains(front_byte) {\n                 self.end -= needle.len();\n+                if !long_period {\n+                    self.memory_back = needle.len();\n+                }\n                 continue 'search;\n             }\n \n             // See if the left part of the needle matches\n-            for i in (0..self.crit_pos).rev() {\n+            let crit = if long_period { self.crit_pos_back }\n+                       else { cmp::min(self.crit_pos_back, self.memory_back) };\n+            for i in (0..crit).rev() {\n                 if needle[i] != haystack[self.end - needle.len() + i] {\n-                    self.end -= self.crit_pos - i;\n+                    self.end -= self.crit_pos_back - i;\n+                    if !long_period {\n+                        self.memory_back = needle.len();\n+                    }\n                     continue 'search;\n                 }\n             }\n \n             // See if the right part of the needle matches\n-            for i in self.crit_pos..needle.len() {\n+            let needle_end = if long_period { needle.len() }\n+                             else { self.memory_back };\n+            for i in self.crit_pos_back..needle_end {\n                 if needle[i] != haystack[self.end - needle.len() + i] {\n                     self.end -= self.period;\n+                    if !long_period {\n+                        self.memory_back = self.period;\n+                    }\n                     continue 'search;\n                 }\n             }\n@@ -984,53 +1054,112 @@ impl TwoWaySearcher {\n             let match_pos = self.end - needle.len();\n             // Note: sub self.period instead of needle.len() to have overlapping matches\n             self.end -= needle.len();\n+            if !long_period {\n+                self.memory_back = needle.len();\n+            }\n \n             return S::matching(match_pos, match_pos + needle.len());\n         }\n     }\n \n-    // Computes a critical factorization (u, v) of `arr`.\n-    // Specifically, returns (i, p), where i is the starting index of v in some\n-    // critical factorization (u, v) and p = period(v)\n+    // Compute the maximal suffix of `arr`.\n+    //\n+    // The maximal suffix is a possible critical factorization (u, v) of `arr`.\n+    //\n+    // Returns (`i`, `p`) where `i` is the starting index of v and `p` is the\n+    // period of v.\n+    //\n+    // `order_greater` determines if lexical order is `<` or `>`. Both\n+    // orders must be computed -- the ordering with the largest `i` gives\n+    // a critical factorization.\n+    //\n+    // For long period cases, the resulting period is not exact (it is too short).\n     #[inline]\n-    fn maximal_suffix(arr: &[u8], reversed: bool) -> (usize, usize) {\n-        let mut left: usize = !0; // Corresponds to i in the paper\n-        let mut right = 0; // Corresponds to j in the paper\n-        let mut offset = 1; // Corresponds to k in the paper\n+    fn maximal_suffix(arr: &[u8], order_greater: bool) -> (usize, usize) {\n+        let mut left = 0; // Corresponds to i in the paper\n+        let mut right = 1; // Corresponds to j in the paper\n+        let mut offset = 0; // Corresponds to k in the paper, but starting at 0\n+                            // to match 0-based indexing.\n         let mut period = 1; // Corresponds to p in the paper\n \n-        while right + offset < arr.len() {\n-            let a;\n-            let b;\n-            if reversed {\n-                a = arr[left.wrapping_add(offset)];\n-                b = arr[right + offset];\n+        while let Some(&a) = arr.get(right + offset) {\n+            // `left` will be inbounds when `right` is.\n+            let b = arr[left + offset];\n+            if (a < b && !order_greater) || (a > b && order_greater) {\n+                // Suffix is smaller, period is entire prefix so far.\n+                right += offset + 1;\n+                offset = 0;\n+                period = right - left;\n+            } else if a == b {\n+                // Advance through repetition of the current period.\n+                if offset + 1 == period {\n+                    right += offset + 1;\n+                    offset = 0;\n+                } else {\n+                    offset += 1;\n+                }\n             } else {\n-                a = arr[right + offset];\n-                b = arr[left.wrapping_add(offset)];\n+                // Suffix is larger, start over from current location.\n+                left = right;\n+                right += 1;\n+                offset = 0;\n+                period = 1;\n             }\n-            if a < b {\n+        }\n+        (left, period)\n+    }\n+\n+    // Compute the maximal suffix of the reverse of `arr`.\n+    //\n+    // The maximal suffix is a possible critical factorization (u', v') of `arr`.\n+    //\n+    // Returns `i` where `i` is the starting index of v', from the back;\n+    // returns immedately when a period of `known_period` is reached.\n+    //\n+    // `order_greater` determines if lexical order is `<` or `>`. Both\n+    // orders must be computed -- the ordering with the largest `i` gives\n+    // a critical factorization.\n+    //\n+    // For long period cases, the resulting period is not exact (it is too short).\n+    fn reverse_maximal_suffix(arr: &[u8], known_period: usize,\n+                              order_greater: bool) -> usize\n+    {\n+        let mut left = 0; // Corresponds to i in the paper\n+        let mut right = 1; // Corresponds to j in the paper\n+        let mut offset = 0; // Corresponds to k in the paper, but starting at 0\n+                            // to match 0-based indexing.\n+        let mut period = 1; // Corresponds to p in the paper\n+        let n = arr.len();\n+\n+        while right + offset < n {\n+            let a = arr[n - (1 + right + offset)];\n+            let b = arr[n - (1 + left + offset)];\n+            if (a < b && !order_greater) || (a > b && order_greater) {\n                 // Suffix is smaller, period is entire prefix so far.\n-                right += offset;\n-                offset = 1;\n-                period = right.wrapping_sub(left);\n+                right += offset + 1;\n+                offset = 0;\n+                period = right - left;\n             } else if a == b {\n                 // Advance through repetition of the current period.\n-                if offset == period {\n-                    right += offset;\n-                    offset = 1;\n+                if offset + 1 == period {\n+                    right += offset + 1;\n+                    offset = 0;\n                 } else {\n                     offset += 1;\n                 }\n             } else {\n                 // Suffix is larger, start over from current location.\n                 left = right;\n                 right += 1;\n-                offset = 1;\n+                offset = 0;\n                 period = 1;\n             }\n+            if period == known_period {\n+                break;\n+            }\n         }\n-        (left.wrapping_add(1), period)\n+        debug_assert!(period <= known_period);\n+        left\n     }\n }\n "}]}