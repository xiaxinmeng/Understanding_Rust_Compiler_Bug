{"sha": "bb665a70627cbc2f4fb930fefb04899941b6afa6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiNjY1YTcwNjI3Y2JjMmY0ZmI5MzBmZWZiMDQ4OTk5NDFiNmFmYTY=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-02-21T20:47:50Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-02-21T20:47:50Z"}, "message": "Merge #864\n\n864: Fix handling of generics in tuple variants and refactor a bit r=matklad a=flodiebold\n\n(The problem was that we created separate substitutions for the return value, so we lost the connection between the type arguments in the constructor call and the type arguments of the result.)\r\n\r\nAlso make them display a tiny bit nicer.\r\n\r\nFixes #860.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\nCo-authored-by: Florian Diebold <florian.diebold@freiheit.com>", "tree": {"sha": "e63b8aa30ec149dbff97d5dbf45fed998fdaf744", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e63b8aa30ec149dbff97d5dbf45fed998fdaf744"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb665a70627cbc2f4fb930fefb04899941b6afa6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb665a70627cbc2f4fb930fefb04899941b6afa6", "html_url": "https://github.com/rust-lang/rust/commit/bb665a70627cbc2f4fb930fefb04899941b6afa6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb665a70627cbc2f4fb930fefb04899941b6afa6/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "5100aeac429919d1758908efb2f9cbe0d02c7510", "url": "https://api.github.com/repos/rust-lang/rust/commits/5100aeac429919d1758908efb2f9cbe0d02c7510", "html_url": "https://github.com/rust-lang/rust/commit/5100aeac429919d1758908efb2f9cbe0d02c7510"}, {"sha": "db9a5a9ac047ed13aebd136edaabd4309f442e99", "url": "https://api.github.com/repos/rust-lang/rust/commits/db9a5a9ac047ed13aebd136edaabd4309f442e99", "html_url": "https://github.com/rust-lang/rust/commit/db9a5a9ac047ed13aebd136edaabd4309f442e99"}], "stats": {"total": 166, "additions": 124, "deletions": 42}, "files": [{"sha": "c494beeb01250d009230e4fe15a1541550973326", "filename": "crates/ra_hir/src/generics.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bb665a70627cbc2f4fb930fefb04899941b6afa6/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb665a70627cbc2f4fb930fefb04899941b6afa6/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fgenerics.rs?ref=bb665a70627cbc2f4fb930fefb04899941b6afa6", "patch": "@@ -87,4 +87,17 @@ impl GenericParams {\n         let parent_count = self.count_parent_params();\n         parent_count + self.params.len()\n     }\n+\n+    fn for_each_param<'a>(&'a self, f: &mut impl FnMut(&'a GenericParam)) {\n+        if let Some(parent) = &self.parent_params {\n+            parent.for_each_param(f);\n+        }\n+        self.params.iter().for_each(f);\n+    }\n+\n+    pub fn params_including_parent(&self) -> Vec<&GenericParam> {\n+        let mut vec = Vec::with_capacity(self.count_params_including_parent());\n+        self.for_each_param(&mut |p| vec.push(p));\n+        vec\n+    }\n }"}, {"sha": "1a3e1994fe4acebe63c3ea653031db414119b9e0", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 47, "deletions": 39, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/bb665a70627cbc2f4fb930fefb04899941b6afa6/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb665a70627cbc2f4fb930fefb04899941b6afa6/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=bb665a70627cbc2f4fb930fefb04899941b6afa6", "patch": "@@ -40,7 +40,7 @@ use crate::{\n     name::KnownName,\n     expr::{Body, Expr, BindingAnnotation, Literal, ExprId, Pat, PatId, UnaryOp, BinaryOp, Statement, FieldPat, self},\n     generics::GenericParams,\n-    path::GenericArg,\n+    path::{ GenericArgs, GenericArg},\n     adt::VariantDef,\n     resolve::{Resolver, Resolution}, nameres::Namespace\n };\n@@ -165,17 +165,6 @@ impl Substs {\n     pub fn empty() -> Substs {\n         Substs(Arc::new([]))\n     }\n-\n-    /// Replaces the end of the substitutions by other ones.\n-    pub(crate) fn replace_tail(self, replace_by: Vec<Ty>) -> Substs {\n-        // again missing Arc::make_mut_slice...\n-        let len = replace_by.len().min(self.0.len());\n-        let parent_len = self.0.len() - len;\n-        let mut result = Vec::with_capacity(parent_len + len);\n-        result.extend(self.0.iter().take(parent_len).cloned());\n-        result.extend(replace_by);\n-        Substs(result.into())\n-    }\n }\n \n /// A type. This is based on the `TyKind` enum in rustc (librustc/ty/sty.rs).\n@@ -454,7 +443,7 @@ impl Ty {\n         for _ in supplied_params..def_generics.count_params_including_parent() {\n             substs.push(Ty::Unknown);\n         }\n-        assert_eq!(substs.len(), def_generics.params.len());\n+        assert_eq!(substs.len(), def_generics.count_params_including_parent());\n         Substs(substs.into())\n     }\n \n@@ -639,8 +628,11 @@ impl fmt::Display for Ty {\n                 join(sig.input.iter()).surround_with(\"fn(\", \")\").separator(\", \").to_fmt(f)?;\n                 write!(f, \" -> {}\", sig.output)\n             }\n-            Ty::FnDef { name, substs, sig, .. } => {\n-                write!(f, \"fn {}\", name)?;\n+            Ty::FnDef { def, name, substs, sig, .. } => {\n+                match def {\n+                    CallableDef::Function(_) => write!(f, \"fn {}\", name)?,\n+                    CallableDef::Struct(_) | CallableDef::EnumVariant(_) => write!(f, \"{}\", name)?,\n+                }\n                 if substs.0.len() > 0 {\n                     join(substs.0.iter()).surround_with(\"<\", \">\").separator(\", \").to_fmt(f)?;\n                 }\n@@ -712,16 +704,18 @@ fn type_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariant) ->\n         .iter()\n         .map(|(_, field)| Ty::from_hir(db, &resolver, &field.type_ref))\n         .collect::<Vec<_>>();\n-    let output = type_for_enum(db, def.parent_enum(db));\n-    let sig = Arc::new(FnSig { input, output });\n     let substs = make_substs(&generics);\n+    let output = type_for_enum(db, def.parent_enum(db)).apply_substs(substs.clone());\n+    let sig = Arc::new(FnSig { input, output });\n     Ty::FnDef { def: def.into(), sig, name, substs }\n }\n \n fn make_substs(generics: &GenericParams) -> Substs {\n     Substs(\n-        (0..generics.count_params_including_parent())\n-            .map(|_p| Ty::Unknown)\n+        generics\n+            .params_including_parent()\n+            .into_iter()\n+            .map(|p| Ty::Param { idx: p.idx, name: p.name.clone() })\n             .collect::<Vec<_>>()\n             .into(),\n     )\n@@ -736,7 +730,7 @@ fn type_for_struct(db: &impl HirDatabase, s: Struct) -> Ty {\n     }\n }\n \n-pub(crate) fn type_for_enum(db: &impl HirDatabase, s: Enum) -> Ty {\n+fn type_for_enum(db: &impl HirDatabase, s: Enum) -> Ty {\n     let generics = s.generic_params(db);\n     Ty::Adt {\n         def_id: s.into(),\n@@ -1353,6 +1347,37 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         ty\n     }\n \n+    fn substs_for_method_call(\n+        &mut self,\n+        def_generics: Option<Arc<GenericParams>>,\n+        generic_args: &Option<GenericArgs>,\n+    ) -> Substs {\n+        let (parent_param_count, param_count) =\n+            def_generics.map_or((0, 0), |g| (g.count_parent_params(), g.params.len()));\n+        let mut substs = Vec::with_capacity(parent_param_count + param_count);\n+        for _ in 0..parent_param_count {\n+            substs.push(Ty::Unknown);\n+        }\n+        // handle provided type arguments\n+        if let Some(generic_args) = generic_args {\n+            // if args are provided, it should be all of them, but we can't rely on that\n+            for arg in generic_args.args.iter().take(param_count) {\n+                match arg {\n+                    GenericArg::Type(type_ref) => {\n+                        let ty = self.make_ty(type_ref);\n+                        substs.push(ty);\n+                    }\n+                }\n+            }\n+        };\n+        let supplied_params = substs.len();\n+        for _ in supplied_params..parent_param_count + param_count {\n+            substs.push(Ty::Unknown);\n+        }\n+        assert_eq!(substs.len(), parent_param_count + param_count);\n+        Substs(substs.into())\n+    }\n+\n     fn infer_expr(&mut self, tgt_expr: ExprId, expected: &Expectation) -> Ty {\n         let body = Arc::clone(&self.body); // avoid borrow checker problem\n         let ty = match &body[tgt_expr] {\n@@ -1443,25 +1468,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     }\n                     None => (Ty::Unknown, receiver_ty, None),\n                 };\n-                // handle provided type arguments\n-                let method_ty = if let Some(generic_args) = generic_args {\n-                    // if args are provided, it should be all of them, but we can't rely on that\n-                    let param_count = def_generics.map(|g| g.params.len()).unwrap_or(0);\n-                    let mut new_substs = Vec::with_capacity(generic_args.args.len());\n-                    for arg in generic_args.args.iter().take(param_count) {\n-                        match arg {\n-                            GenericArg::Type(type_ref) => {\n-                                let ty = self.make_ty(type_ref);\n-                                new_substs.push(ty);\n-                            }\n-                        }\n-                    }\n-                    let substs = method_ty.substs().unwrap_or_else(Substs::empty);\n-                    let substs = substs.replace_tail(new_substs);\n-                    method_ty.apply_substs(substs)\n-                } else {\n-                    method_ty\n-                };\n+                let substs = self.substs_for_method_call(def_generics, generic_args);\n+                let method_ty = method_ty.apply_substs(substs);\n                 let method_ty = self.insert_type_vars(method_ty);\n                 let (expected_receiver_ty, param_tys, ret_ty) = match &method_ty {\n                     Ty::FnPtr(sig) => {"}, {"sha": "32f1fa10806debe65afccdfca9af8bf34ccaf75b", "filename": "crates/ra_hir/src/ty/snapshots/tests__infer_struct.snap", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bb665a70627cbc2f4fb930fefb04899941b6afa6/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_struct.snap", "raw_url": "https://github.com/rust-lang/rust/raw/bb665a70627cbc2f4fb930fefb04899941b6afa6/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_struct.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_struct.snap?ref=bb665a70627cbc2f4fb930fefb04899941b6afa6", "patch": "@@ -1,19 +1,19 @@\n ---\n-created: \"2019-02-17T16:16:58.863630956Z\"\n+created: \"2019-02-20T21:31:12.910924715Z\"\n creator: insta@0.6.2\n source: crates/ra_hir/src/ty/tests.rs\n expression: \"&result\"\n ---\n [72; 154) '{     ...a.c; }': ()\n [82; 83) 'c': C\n-[86; 87) 'C': fn C(usize) -> C\n+[86; 87) 'C': C(usize) -> C\n [86; 90) 'C(1)': C\n [88; 89) '1': usize\n [96; 97) 'B': B\n [107; 108) 'a': A\n [114; 133) 'A { b:...C(1) }': A\n [121; 122) 'B': B\n-[127; 128) 'C': fn C(usize) -> C\n+[127; 128) 'C': C(usize) -> C\n [127; 131) 'C(1)': C\n [129; 130) '1': usize\n [139; 140) 'a': A"}, {"sha": "783795cfdd7f916bb4f893c012d58485a9e77ae9", "filename": "crates/ra_hir/src/ty/snapshots/tests__infer_tuple_struct_generics.snap", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bb665a70627cbc2f4fb930fefb04899941b6afa6/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_tuple_struct_generics.snap", "raw_url": "https://github.com/rust-lang/rust/raw/bb665a70627cbc2f4fb930fefb04899941b6afa6/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_tuple_struct_generics.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_tuple_struct_generics.snap?ref=bb665a70627cbc2f4fb930fefb04899941b6afa6", "patch": "@@ -0,0 +1,23 @@\n+---\n+created: \"2019-02-20T21:31:12.911275141Z\"\n+creator: insta@0.6.2\n+source: crates/ra_hir/src/ty/tests.rs\n+expression: \"&result\"\n+---\n+[77; 185) '{     ...one; }': ()\n+[83; 84) 'A': A<i32>(T) -> A<T>\n+[83; 88) 'A(42)': A<i32>\n+[85; 87) '42': i32\n+[94; 95) 'A': A<u128>(T) -> A<T>\n+[94; 103) 'A(42u128)': A<u128>\n+[96; 102) '42u128': u128\n+[109; 113) 'Some': Some<&str>(T) -> Option<T>\n+[109; 118) 'Some(\"x\")': Option<&str>\n+[114; 117) '\"x\"': &str\n+[124; 136) 'Option::Some': Some<&str>(T) -> Option<T>\n+[124; 141) 'Option...e(\"x\")': Option<&str>\n+[137; 140) '\"x\"': &str\n+[147; 151) 'None': Option<[unknown]>\n+[161; 162) 'x': Option<i64>\n+[178; 182) 'None': Option<i64>\n+"}, {"sha": "3affcb4fe32a53d3f602d198d3e138c38a27dff6", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bb665a70627cbc2f4fb930fefb04899941b6afa6/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb665a70627cbc2f4fb930fefb04899941b6afa6/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=bb665a70627cbc2f4fb930fefb04899941b6afa6", "patch": "@@ -465,6 +465,27 @@ fn test(a1: A<u32>, i: i32) {\n     );\n }\n \n+#[test]\n+fn infer_tuple_struct_generics() {\n+    check_inference(\n+        \"infer_tuple_struct_generics\",\n+        r#\"\n+struct A<T>(T);\n+enum Option<T> { Some(T), None };\n+use Option::*;\n+\n+fn test() {\n+    A(42);\n+    A(42u128);\n+    Some(\"x\");\n+    Option::Some(\"x\");\n+    None;\n+    let x: Option<i64> = None;\n+}\n+\"#,\n+    );\n+}\n+\n #[test]\n fn infer_generics_in_patterns() {\n     check_inference("}, {"sha": "a41c4e546d805c7f80fc37945495ddbf911be13f", "filename": "crates/ra_ide_api/src/hover.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bb665a70627cbc2f4fb930fefb04899941b6afa6/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb665a70627cbc2f4fb930fefb04899941b6afa6/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fhover.rs?ref=bb665a70627cbc2f4fb930fefb04899941b6afa6", "patch": "@@ -163,6 +163,23 @@ mod tests {\n         assert_eq!(hover.info, \"u32\");\n     }\n \n+    #[test]\n+    fn hover_some() {\n+        let (analysis, position) = single_file_with_position(\n+            \"\n+            enum Option<T> { Some(T) }\n+            use Option::Some;\n+\n+            fn main() {\n+                So<|>me(12);\n+            }\n+            \",\n+        );\n+        let hover = analysis.hover(position).unwrap().unwrap();\n+        // not the nicest way to show it currently\n+        assert_eq!(hover.info, \"Some<i32>(T) -> Option<T>\");\n+    }\n+\n     #[test]\n     fn hover_for_local_variable() {\n         let (analysis, position) = single_file_with_position(\"fn func(foo: i32) { fo<|>o; }\");"}]}