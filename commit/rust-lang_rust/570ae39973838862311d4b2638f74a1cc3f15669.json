{"sha": "570ae39973838862311d4b2638f74a1cc3f15669", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3MGFlMzk5NzM4Mzg4NjIzMTFkNGIyNjM4Zjc0YTFjYzNmMTU2Njk=", "commit": {"author": {"name": "MarkMcCaskey", "email": "rabidwaffle@gmail.com", "date": "2017-09-02T21:01:34Z"}, "committer": {"name": "MarkMcCaskey", "email": "rabidwaffle@gmail.com", "date": "2017-09-02T21:01:34Z"}, "message": "Merge branch 'master' of git://github.com/rust-lang/rust", "tree": {"sha": "22d25e6c72e6e87ba33084ebd4921f415f552b9d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22d25e6c72e6e87ba33084ebd4921f415f552b9d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/570ae39973838862311d4b2638f74a1cc3f15669", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/570ae39973838862311d4b2638f74a1cc3f15669", "html_url": "https://github.com/rust-lang/rust/commit/570ae39973838862311d4b2638f74a1cc3f15669", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/570ae39973838862311d4b2638f74a1cc3f15669/comments", "author": {"login": "MarkMcCaskey", "id": 5770194, "node_id": "MDQ6VXNlcjU3NzAxOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5770194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/MarkMcCaskey", "html_url": "https://github.com/MarkMcCaskey", "followers_url": "https://api.github.com/users/MarkMcCaskey/followers", "following_url": "https://api.github.com/users/MarkMcCaskey/following{/other_user}", "gists_url": "https://api.github.com/users/MarkMcCaskey/gists{/gist_id}", "starred_url": "https://api.github.com/users/MarkMcCaskey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/MarkMcCaskey/subscriptions", "organizations_url": "https://api.github.com/users/MarkMcCaskey/orgs", "repos_url": "https://api.github.com/users/MarkMcCaskey/repos", "events_url": "https://api.github.com/users/MarkMcCaskey/events{/privacy}", "received_events_url": "https://api.github.com/users/MarkMcCaskey/received_events", "type": "User", "site_admin": false}, "committer": {"login": "MarkMcCaskey", "id": 5770194, "node_id": "MDQ6VXNlcjU3NzAxOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5770194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/MarkMcCaskey", "html_url": "https://github.com/MarkMcCaskey", "followers_url": "https://api.github.com/users/MarkMcCaskey/followers", "following_url": "https://api.github.com/users/MarkMcCaskey/following{/other_user}", "gists_url": "https://api.github.com/users/MarkMcCaskey/gists{/gist_id}", "starred_url": "https://api.github.com/users/MarkMcCaskey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/MarkMcCaskey/subscriptions", "organizations_url": "https://api.github.com/users/MarkMcCaskey/orgs", "repos_url": "https://api.github.com/users/MarkMcCaskey/repos", "events_url": "https://api.github.com/users/MarkMcCaskey/events{/privacy}", "received_events_url": "https://api.github.com/users/MarkMcCaskey/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e572d85e00befa25b5912c0076ef8831a4f9a9f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/e572d85e00befa25b5912c0076ef8831a4f9a9f0", "html_url": "https://github.com/rust-lang/rust/commit/e572d85e00befa25b5912c0076ef8831a4f9a9f0"}, {"sha": "204c0a47e7b7e371cf1cdc159404d405b86386ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/204c0a47e7b7e371cf1cdc159404d405b86386ba", "html_url": "https://github.com/rust-lang/rust/commit/204c0a47e7b7e371cf1cdc159404d405b86386ba"}], "stats": {"total": 2550, "additions": 1379, "deletions": 1171}, "files": [{"sha": "fbebccf408fb6634104d8a63a74c660cd0a42b96", "filename": ".gitmodules", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -33,3 +33,6 @@\n [submodule \"src/libcompiler_builtins\"]\n \tpath = src/libcompiler_builtins\n \turl = https://github.com/rust-lang-nursery/compiler-builtins\n+[submodule \"src/tools/clippy\"]\n+\tpath = src/tools/clippy\n+\turl = https://github.com/rust-lang-nursery/rust-clippy.git"}, {"sha": "cdac8e696c8e0b1c7238723de791de8e784c5cd2", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -298,6 +298,32 @@ Speaking of tests, Rust has a comprehensive test suite. More information about\n it can be found\n [here](https://github.com/rust-lang/rust-wiki-backup/blob/master/Note-testsuite.md).\n \n+### External Dependencies\n+\n+Currently building Rust will also build the following external projects:\n+\n+* [clippy](https://github.com/rust-lang-nursery/rust-clippy)\n+\n+If your changes break one of these projects, you need to fix them by opening\n+a pull request against the broken project. When you have opened a pull request,\n+you can point the submodule at your pull request by calling\n+\n+```\n+git fetch origin pull/$id_of_your_pr/head:my_pr\n+git checkout my_pr\n+```\n+\n+within the submodule's directory. Don't forget to also add your changes with\n+\n+```\n+git add path/to/submodule\n+```\n+\n+outside the submodule.\n+\n+It can also be more convenient during development to set `submodules = false`\n+in the `config.toml` to prevent `x.py` from resetting to the original branch.\n+\n ## Writing Documentation\n \n Documentation improvements are very welcome. The source of `doc.rust-lang.org`"}, {"sha": "5815cb0f9726007f7a372956268658087d0e76e0", "filename": "RELEASES.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -3,7 +3,7 @@ Version 1.20.0 (2017-08-31)\n \n Language\n --------\n-- [Associated constants in traits is now stabilised.][42809]\n+- [Associated constants are now stabilised.][42809]\n - [A lot of macro bugs are now fixed.][42913]\n \n Compiler\n@@ -77,7 +77,7 @@ Stabilized APIs\n - [`slice::sort_unstable_by_key`]\n - [`slice::sort_unstable_by`]\n - [`slice::sort_unstable`]\n-- [`ste::from_boxed_utf8_unchecked`]\n+- [`str::from_boxed_utf8_unchecked`]\n - [`str::as_bytes_mut`]\n - [`str::as_bytes_mut`]\n - [`str::from_utf8_mut`]"}, {"sha": "4842555bca6ae6af3319c970c2d5886706105db1", "filename": "src/Cargo.lock", "status": "modified", "additions": 60, "deletions": 67, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -80,7 +80,7 @@ version = \"0.2.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -93,7 +93,7 @@ dependencies = [\n  \"cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"dbghelp-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-demangle 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -104,7 +104,7 @@ version = \"0.1.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -140,7 +140,7 @@ dependencies = [\n  \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -175,20 +175,14 @@ dependencies = [\n \n [[package]]\n name = \"cargo\"\n-version = \"0.22.0\"\n-source = \"git+https://github.com/rust-lang/cargo#3d3f2c05d742e5f907e951aa8849b03f0bc1a895\"\n-replace = \"cargo 0.22.0\"\n-\n-[[package]]\n-name = \"cargo\"\n-version = \"0.22.0\"\n+version = \"0.23.0\"\n dependencies = [\n  \"advapi32-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"atty 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"bufstream 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cargotest 0.1.0\",\n  \"core-foundation 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"crates-io 0.11.0\",\n+ \"crates-io 0.12.0\",\n  \"crossbeam 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"curl 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"docopt 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -197,7 +191,7 @@ dependencies = [\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"flate2 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"fs2 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"git2 0.6.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"git2 0.6.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"git2-curl 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"glob 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"hamcrest 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -206,8 +200,8 @@ dependencies = [\n  \"ignore 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"jobserver 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libgit2-sys 0.6.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libgit2-sys 0.6.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"miow 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -223,7 +217,7 @@ dependencies = [\n  \"shell-escape 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tar 0.4.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tempdir 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"termcolor 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"termcolor 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"url 1.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -233,10 +227,10 @@ dependencies = [\n name = \"cargotest\"\n version = \"0.1.0\"\n dependencies = [\n- \"cargo 0.22.0\",\n+ \"cargo 0.23.0\",\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"flate2 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"git2 0.6.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"git2 0.6.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"hamcrest 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"hex 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -303,7 +297,7 @@ dependencies = [\n  \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -333,20 +327,20 @@ version = \"0.4.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"core-foundation-sys 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"core-foundation-sys\"\n version = \"0.4.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"crates-io\"\n-version = \"0.11.0\"\n+version = \"0.12.0\"\n dependencies = [\n  \"curl 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"error-chain 0.11.0-rc.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -391,7 +385,7 @@ version = \"0.4.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"curl-sys 0.3.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"openssl-probe 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"openssl-sys 0.9.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"socket2 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -404,7 +398,7 @@ version = \"0.3.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libz-sys 1.0.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"openssl-sys 0.9.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pkg-config 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -519,7 +513,7 @@ name = \"filetime\"\n version = \"0.1.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -539,7 +533,7 @@ name = \"flate2\"\n version = \"0.2.19\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"miniz-sys 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -563,7 +557,7 @@ version = \"0.4.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -593,12 +587,12 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"git2\"\n-version = \"0.6.6\"\n+version = \"0.6.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bitflags 0.9.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libgit2-sys 0.6.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libgit2-sys 0.6.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"openssl-probe 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"openssl-sys 0.9.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"url 1.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -610,7 +604,7 @@ version = \"0.7.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"curl 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"git2 0.6.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"git2 0.6.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"url 1.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -690,7 +684,7 @@ version = \"0.1.0\"\n \n [[package]]\n name = \"html-diff\"\n-version = \"0.0.3\"\n+version = \"0.0.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"kuchiki 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -762,15 +756,15 @@ dependencies = [\n \n [[package]]\n name = \"itoa\"\n-version = \"0.3.2\"\n+version = \"0.3.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"jobserver\"\n version = \"0.1.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rand 0.3.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -833,18 +827,18 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.29\"\n+version = \"0.2.30\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"libgit2-sys\"\n-version = \"0.6.12\"\n+version = \"0.6.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"cmake 0.1.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"curl-sys 0.3.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libssh2-sys 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libz-sys 1.0.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"openssl-sys 0.9.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -857,7 +851,7 @@ version = \"0.2.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"cmake 0.1.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libz-sys 1.0.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"openssl-sys 0.9.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pkg-config 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -869,7 +863,7 @@ version = \"1.0.16\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pkg-config 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"vcpkg 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -890,7 +884,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -955,15 +949,15 @@ name = \"memchr\"\n version = \"0.1.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"memchr\"\n version = \"1.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -972,7 +966,7 @@ version = \"0.1.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -997,7 +991,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ws2_32-sys 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -1073,7 +1067,7 @@ name = \"num_cpus\"\n version = \"1.6.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1093,7 +1087,7 @@ dependencies = [\n  \"bitflags 0.9.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"foreign-types 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"openssl-sys 0.9.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1108,7 +1102,7 @@ version = \"0.9.17\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pkg-config 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"vcpkg 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -1274,7 +1268,7 @@ name = \"rand\"\n version = \"0.3.16\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"magenta 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1336,7 +1330,7 @@ version = \"0.1.0\"\n name = \"rls\"\n version = \"0.1.0\"\n dependencies = [\n- \"cargo 0.22.0 (git+https://github.com/rust-lang/cargo)\",\n+ \"cargo 0.23.0\",\n  \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"jsonrpc-core 7.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"languageserver-types 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1800,7 +1794,7 @@ dependencies = [\n  \"build_helper 0.1.0\",\n  \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"html-diff 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"html-diff 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pulldown-cmark 0.0.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -1821,7 +1815,7 @@ dependencies = [\n  \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1920,7 +1914,7 @@ version = \"1.0.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"dtoa 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"itoa 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"itoa 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num-traits 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -1951,7 +1945,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ws2_32-sys 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -2099,7 +2093,7 @@ name = \"syntex_errors\"\n version = \"0.52.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntex_pos 0.52.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2121,7 +2115,7 @@ version = \"0.52.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bitflags 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntex_errors 0.52.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2136,7 +2130,7 @@ version = \"0.4.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"xattr 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -2177,13 +2171,13 @@ version = \"0.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"termcolor\"\n-version = \"0.3.2\"\n+version = \"0.3.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"wincolor 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2212,7 +2206,7 @@ version = \"2.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -2417,7 +2411,7 @@ name = \"xattr\"\n version = \"0.1.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -2446,7 +2440,6 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum bitflags 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1370e9fc2a6ae53aea8b7a5110edbd08836ed87c88736dfabccade1c2b44bff4\"\n \"checksum bitflags 0.9.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4efd02e230a02e18f92fc2735f44597385ed02ad8f831e7c1c1156ee5e1ab3a5\"\n \"checksum bufstream 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f2f382711e76b9de6c744cc00d0497baba02fb00a787f088c879f01d09468e32\"\n-\"checksum cargo 0.22.0 (git+https://github.com/rust-lang/cargo)\" = \"<none>\"\n \"checksum cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d4c819a1287eb618df47cc647173c5c4c66ba19d888a6e50d605672aed3140de\"\n \"checksum clap 2.26.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2267a8fdd4dce6956ba6649e130f62fb279026e5e84b92aa939ac8f85ce3f9f0\"\n \"checksum cmake 0.1.24 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b8ebbb35d3dc9cd09497168f33de1acb79b265d350ab0ac34133b98f8509af1f\"\n@@ -2479,27 +2472,27 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum futures 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a82bdc62350ca9d7974c760e9665102fc9d740992a528c2254aa930e53b783c4\"\n \"checksum gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\" = \"120d07f202dcc3f72859422563522b66fe6463a4c513df062874daad05f85f0a\"\n \"checksum getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d9047cfbd08a437050b363d35ef160452c5fe8ea5187ae0a624708c91581d685\"\n-\"checksum git2 0.6.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"aa01936ac96555c083c0e8553f672616274408d9d3fc5b8696603fbf63ff43ee\"\n+\"checksum git2 0.6.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0c1c0203d653f4140241da0c1375a404f0a397249ec818cd2076c6280c50f6fa\"\n \"checksum git2-curl 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"68676bc784bf0bef83278898929bf64a251e87c0340723d0b93fa096c9c5bf8e\"\n \"checksum glob 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8be18de09a56b60ed0edf84bc9df007e30040691af7acd1c41874faac5895bfb\"\n \"checksum globset 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"feeb1b6840809ef5efcf7a4a990bc4e1b7ee3df8cf9e2379a75aeb2ba42ac9c3\"\n \"checksum hamcrest 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bf088f042a467089e9baa4972f57f9247e42a0cc549ba264c7a04fbb8ecb89d4\"\n \"checksum handlebars 0.26.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fbba80e74e9591a5f6a4ffff6b7f9d645759a896e431cfbdc853e9184370294a\"\n \"checksum hex 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d6a22814455d41612f41161581c2883c0c6a1c41852729b17d5ed88f01e153aa\"\n \"checksum home 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9f25ae61099d8f3fee8b483df0bd4ecccf4b2731897aad40d50eca1b641fe6db\"\n-\"checksum html-diff 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"17dbc64943cae56925cf9ff22e8c76ccdb8010f6675a1a56660ec7e597ffa7c7\"\n+\"checksum html-diff 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5298d63081a642508fce965740ddb03a386c5d81bf1fef0579a815cf49cb8c68\"\n \"checksum html5ever 0.18.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a49d5001dd1bddf042ea41ed4e0a671d50b1bf187e66b349d7ec613bdce4ad90\"\n \"checksum idna 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"014b298351066f1512874135335d62a789ffe78a9974f94b43ed5621951eaf7d\"\n \"checksum ignore 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b3fcaf2365eb14b28ec7603c98c06cc531f19de9eb283d89a3dff8417c8c99f5\"\n-\"checksum itoa 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f74cf6ca1bdbc28496a2b9798ab7fccc2ca5a42cace95bb2b219577216a5fb90\"\n+\"checksum itoa 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ac17257442c2ed77dbc9fd555cf83c58b0c7f7d0e8f2ae08c0ac05c72842e1f6\"\n \"checksum jobserver 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"443ae8bc0af6c106e6e8b77e04684faecc1a5ce94e058f4c2b0a037b0ea1b133\"\n \"checksum jsonrpc-core 7.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"903e5eee845f3d83c1436d12848d97b1247cf850ff06a8e1db2f1ce3543af2cf\"\n \"checksum kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d\"\n \"checksum kuchiki 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ef2ea4f2f7883cd7c6772b06c14abca01a2cc1f75c426cebffcf6b3b925ef9fc\"\n \"checksum languageserver-types 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d52e477b23bf52cd3ca0f9fc6c5d14be954eec97e3b9cdfbd962d911bd533caf\"\n \"checksum lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3b37545ab726dd833ec6420aaba8231c5b320814b9029ad585555d2a03e94fbf\"\n-\"checksum libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8a014d9226c2cc402676fbe9ea2e15dd5222cd1dd57f576b5b283178c944a264\"\n-\"checksum libgit2-sys 0.6.12 (registry+https://github.com/rust-lang/crates.io-index)\" = \"df18a822100352d9863b302faf6f8f25c0e77f0e60feb40e5dbe1238b7f13b1d\"\n+\"checksum libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2370ca07ec338939e356443dac2296f581453c35fe1e3a3ed06023c49435f915\"\n+\"checksum libgit2-sys 0.6.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c00f6e5bc3fb2b5f87e75e8d0fd4ae6720d55f3ee23d389b7c6cae30f8db8db1\"\n \"checksum libssh2-sys 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0db4ec23611747ef772db1c4d650f8bd762f07b461727ec998f953c614024b75\"\n \"checksum libz-sys 1.0.16 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3fdd64ef8ee652185674455c1d450b83cbc8ad895625d543b5324d923f82e4d8\"\n \"checksum log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"880f77541efa6e5cc74e76910c9884d9859683118839d6a1dc3b11e63512565b\"\n@@ -2587,7 +2580,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum tendril 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8c1b72f8e2f5b73b65c315b1a70c730f24b9d7a25f39e98de8acbe2bb795caea\"\n \"checksum term 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fa63644f74ce96fbeb9b794f66aff2a52d601cbd5e80f4b97123e3899f4570f1\"\n \"checksum term_size 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e2b6b55df3198cc93372e85dd2ed817f0e38ce8cc0f22eb32391bfad9c4bf209\"\n-\"checksum termcolor 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9a5193a56b8d82014662c4b933dea6bec851daf018a2b01722e007daaf5f9dca\"\n+\"checksum termcolor 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9065bced9c3e43453aa3d56f1e98590b8455b341d2fa191a1090c0dd0b242c75\"\n \"checksum textwrap 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f728584ea33b0ad19318e20557cb0a39097751dbb07171419673502f848c7af6\"\n \"checksum thread-id 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a9539db560102d1cef46b8b78ce737ff0bb64e7e18d35b2a5688f7d097d0ff03\"\n \"checksum thread_local 0.2.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8576dbbfcaef9641452d5cf0df9b0e7eeab7694956dd33bb61515fb8f18cfdd5\""}, {"sha": "35ba022c4899a5e528f260b3181aa4360ae0c1f1", "filename": "src/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.toml?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -56,5 +56,5 @@ debug-assertions = false\n debug = false\n debug-assertions = false\n \n-[replace]\n-\"https://github.com/rust-lang/cargo#0.22.0\" = { path = \"tools/cargo\" }\n+[patch.'https://github.com/rust-lang/cargo']\n+cargo = { path = \"tools/cargo\" }"}, {"sha": "722b3d16e9d19c1bd2e0960ef065b6703bda0c67", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -248,7 +248,7 @@ impl<'a> Builder<'a> {\n                 compile::StartupObjects, tool::BuildManifest, tool::Rustbook, tool::ErrorIndex,\n                 tool::UnstableBookGen, tool::Tidy, tool::Linkchecker, tool::CargoTest,\n                 tool::Compiletest, tool::RemoteTestServer, tool::RemoteTestClient,\n-                tool::RustInstaller, tool::Cargo, tool::Rls, tool::Rustdoc,\n+                tool::RustInstaller, tool::Cargo, tool::Rls, tool::Rustdoc, tool::Clippy,\n                 native::Llvm),\n             Kind::Test => describe!(check::Tidy, check::Bootstrap, check::DefaultCompiletest,\n                 check::HostCompiletest, check::Crate, check::CrateLibrustc, check::Linkcheck,"}, {"sha": "6ed504dfe74a3178b6119b2e2ffa226f81a7b39d", "filename": "src/bootstrap/channel.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Fbootstrap%2Fchannel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Fbootstrap%2Fchannel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fchannel.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -24,7 +24,7 @@ use Build;\n use config::Config;\n \n // The version number\n-pub const CFG_RELEASE_NUM: &str = \"1.21.0\";\n+pub const CFG_RELEASE_NUM: &str = \"1.22.0\";\n \n // An optional number to put after the label, e.g. '.2' -> '-beta.2'\n // Be sure to make this starts with a dot to conform to semver pre-release"}, {"sha": "05d59e7d59565b359c2790d586e0fc2e6886cb40", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -757,7 +757,7 @@ impl Step for Src {\n             \"src/libprofiler_builtins\",\n         ];\n         let std_src_dirs_exclude = [\n-            \"src/compiler-rt/test\",\n+            \"src/libcompiler_builtins/compiler-rt/test\",\n             \"src/jemalloc/test/unit\",\n         ];\n "}, {"sha": "8173903c03440527bec8aff42a3d6f44fcc93a8a", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -407,6 +407,7 @@ impl Step for Openssl {\n             \"i686-unknown-freebsd\" => \"BSD-x86-elf\",\n             \"i686-unknown-linux-gnu\" => \"linux-elf\",\n             \"i686-unknown-linux-musl\" => \"linux-elf\",\n+            \"i686-unknown-netbsd\" => \"BSD-x86-elf\",\n             \"mips-unknown-linux-gnu\" => \"linux-mips32\",\n             \"mips64-unknown-linux-gnuabi64\" => \"linux64-mips64\",\n             \"mips64el-unknown-linux-gnuabi64\" => \"linux64-mips64\","}, {"sha": "0ad5bb8d2f673a769b7f16bb514f8ea4c338c2ee", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -340,6 +340,44 @@ impl Step for Cargo {\n     }\n }\n \n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct Clippy {\n+    pub compiler: Compiler,\n+    pub target: Interned<String>,\n+}\n+\n+impl Step for Clippy {\n+    type Output = PathBuf;\n+    const DEFAULT: bool = false;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/tools/clippy\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Clippy {\n+            compiler: run.builder.compiler(run.builder.top_stage, run.builder.build.build),\n+            target: run.target,\n+        });\n+    }\n+\n+    fn run(self, builder: &Builder) -> PathBuf {\n+        // Clippy depends on procedural macros (serde), which requires a full host\n+        // compiler to be available, so we need to depend on that.\n+        builder.ensure(compile::Rustc {\n+            compiler: self.compiler,\n+            target: builder.build.build,\n+        });\n+        builder.ensure(ToolBuild {\n+            compiler: self.compiler,\n+            target: self.target,\n+            tool: \"clippy\",\n+            mode: Mode::Librustc,\n+        })\n+    }\n+}\n+\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Rls {\n     pub compiler: Compiler,"}, {"sha": "234d937823fb5bfc6d3a1d2024ed6afd7d655653", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -279,7 +279,7 @@ pub fn symlink_dir(src: &Path, dest: &Path) -> io::Result<()> {\n                                 ptr::null_mut());\n \n             let mut data = [0u8; MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n-            let mut db = data.as_mut_ptr()\n+            let db = data.as_mut_ptr()\n                             as *mut REPARSE_MOUNTPOINT_DATA_BUFFER;\n             let buf = &mut (*db).ReparseTarget as *mut _;\n             let mut i = 0;"}, {"sha": "6a7926fecde38676261b62428dea65d93cbe7a1e", "filename": "src/libcore/array.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -123,14 +123,6 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[cfg(stage0)]\n-            impl<T:Copy> Clone for [T; $N] {\n-                fn clone(&self) -> [T; $N] {\n-                    *self\n-                }\n-            }\n-\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<T: Hash> Hash for [T; $N] {\n                 fn hash<H: hash::Hasher>(&self, state: &mut H) {"}, {"sha": "826420a0c001c3b862b10855c7926841e8983714", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 1, "deletions": 43, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -88,7 +88,7 @@\n /// }\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg_attr(not(stage0), lang = \"clone\")]\n+#[lang = \"clone\"]\n pub trait Clone : Sized {\n     /// Returns a copy of the value.\n     ///\n@@ -130,45 +130,3 @@ pub struct AssertParamIsClone<T: Clone + ?Sized> { _field: ::marker::PhantomData\n            reason = \"deriving hack, should not be public\",\n            issue = \"0\")]\n pub struct AssertParamIsCopy<T: Copy + ?Sized> { _field: ::marker::PhantomData<T> }\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(stage0)]\n-impl<'a, T: ?Sized> Clone for &'a T {\n-    /// Returns a shallow copy of the reference.\n-    #[inline]\n-    fn clone(&self) -> &'a T { *self }\n-}\n-\n-macro_rules! clone_impl {\n-    ($t:ty) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[cfg(stage0)]\n-        impl Clone for $t {\n-            /// Returns a deep copy of the value.\n-            #[inline]\n-            fn clone(&self) -> $t { *self }\n-        }\n-    }\n-}\n-\n-clone_impl! { isize }\n-clone_impl! { i8 }\n-clone_impl! { i16 }\n-clone_impl! { i32 }\n-clone_impl! { i64 }\n-clone_impl! { i128 }\n-\n-clone_impl! { usize }\n-clone_impl! { u8 }\n-clone_impl! { u16 }\n-clone_impl! { u32 }\n-clone_impl! { u64 }\n-clone_impl! { u128 }\n-\n-clone_impl! { f32 }\n-clone_impl! { f64 }\n-\n-clone_impl! { ! }\n-clone_impl! { () }\n-clone_impl! { bool }\n-clone_impl! { char }"}, {"sha": "83f8f9988f44890f358414ad731c6302b2735350", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -8,16 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[macro_export]\n-// This stability attribute is totally useless.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(stage0)]\n-macro_rules! __rust_unstable_column {\n-    () => {\n-        column!()\n-    }\n-}\n-\n /// Entry point of thread panic, for details, see std::macros\n #[macro_export]\n #[allow_internal_unstable]"}, {"sha": "272d75da28939368f76d5eb1a9550d8d87667a4c", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -188,26 +188,6 @@ pub fn forget<T>(t: T) {\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(stage0)]\n-pub fn size_of<T>() -> usize {\n-    unsafe { intrinsics::size_of::<T>() }\n-}\n-\n-/// Returns the size of a type in bytes.\n-///\n-/// More specifically, this is the offset in bytes between successive\n-/// items of the same type, including alignment padding.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::mem;\n-///\n-/// assert_eq!(4, mem::size_of::<i32>());\n-/// ```\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(not(stage0))]\n pub const fn size_of<T>() -> usize {\n     unsafe { intrinsics::size_of::<T>() }\n }\n@@ -299,29 +279,6 @@ pub fn min_align_of_val<T: ?Sized>(val: &T) -> usize {\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(stage0)]\n-pub fn align_of<T>() -> usize {\n-    unsafe { intrinsics::min_align_of::<T>() }\n-}\n-\n-/// Returns the [ABI]-required minimum alignment of a type.\n-///\n-/// Every reference to a value of the type `T` must be a multiple of this number.\n-///\n-/// This is the alignment used for struct fields. It may be smaller than the preferred alignment.\n-///\n-/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::mem;\n-///\n-/// assert_eq!(4, mem::align_of::<i32>());\n-/// ```\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(not(stage0))]\n pub const fn align_of<T>() -> usize {\n     unsafe { intrinsics::min_align_of::<T>() }\n }"}, {"sha": "43d38926c9718c37e6da208ed0a83c9702162932", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -10,8 +10,6 @@\n \n //! Operations and constants for 32-bits floats (`f32` type)\n \n-#![cfg_attr(stage0, allow(overflowing_literals))]\n-\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use intrinsics;"}, {"sha": "2e42e0dfd550d3b04d5a67907f2807054e100c02", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -875,36 +875,9 @@ pub fn eq<T: ?Sized>(a: *const T, b: *const T) -> bool {\n     a == b\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(stage0)]\n-impl<T: ?Sized> Clone for *const T {\n-    #[inline]\n-    fn clone(&self) -> *const T {\n-        *self\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(stage0)]\n-impl<T: ?Sized> Clone for *mut T {\n-    #[inline]\n-    fn clone(&self) -> *mut T {\n-        *self\n-    }\n-}\n-\n // Impls for function pointers\n macro_rules! fnptr_impls_safety_abi {\n     ($FnTy: ty, $($Arg: ident),*) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[cfg(stage0)]\n-        impl<Ret, $($Arg),*> Clone for $FnTy {\n-            #[inline]\n-            fn clone(&self) -> Self {\n-                *self\n-            }\n-        }\n-\n         #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n         impl<Ret, $($Arg),*> PartialEq for $FnTy {\n             #[inline]"}, {"sha": "4c5370194fecb240bdc9c3bea065db15381dce4f", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -21,14 +21,6 @@ macro_rules! tuple_impls {\n         }\n     )+) => {\n         $(\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[cfg(stage0)]\n-            impl<$($T:Clone),+> Clone for ($($T,)+) {\n-                fn clone(&self) -> ($($T,)+) {\n-                    ($(self.$idx.clone(),)+)\n-                }\n-            }\n-\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<$($T:PartialEq),+> PartialEq for ($($T,)+) where last_type!($($T,)+): ?Sized {\n                 #[inline]"}, {"sha": "8908bcb88655901d0b7926d13a933bff4ee05c8d", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 47, "deletions": 46, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -12,7 +12,6 @@ use rustc_data_structures::graph;\n use cfg::*;\n use middle::region::CodeExtent;\n use ty::{self, TyCtxt};\n-use syntax::ast;\n use syntax::ptr::P;\n \n use hir::{self, PatKind};\n@@ -30,13 +29,13 @@ struct CFGBuilder<'a, 'tcx: 'a> {\n \n #[derive(Copy, Clone)]\n struct BlockScope {\n-    block_expr_id: ast::NodeId, // id of breakable block expr node\n+    block_expr_id: hir::ItemLocalId, // id of breakable block expr node\n     break_index: CFGIndex, // where to go on `break`\n }\n \n #[derive(Copy, Clone)]\n struct LoopScope {\n-    loop_id: ast::NodeId,     // id of loop/while node\n+    loop_id: hir::ItemLocalId,     // id of loop/while node\n     continue_index: CFGIndex, // where to go on a `loop`\n     break_index: CFGIndex,    // where to go on a `break`\n }\n@@ -70,6 +69,7 @@ pub fn construct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     cfg_builder.add_contained_edge(body_exit, fn_exit);\n     let CFGBuilder { graph, .. } = cfg_builder;\n     CFG {\n+        owner_def_id,\n         graph,\n         entry,\n         exit: fn_exit,\n@@ -79,10 +79,10 @@ pub fn construct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     fn block(&mut self, blk: &hir::Block, pred: CFGIndex) -> CFGIndex {\n         if blk.targeted_by_break {\n-            let expr_exit = self.add_ast_node(blk.id, &[]);\n+            let expr_exit = self.add_ast_node(blk.hir_id.local_id, &[]);\n \n             self.breakable_block_scopes.push(BlockScope {\n-                block_expr_id: blk.id,\n+                block_expr_id: blk.hir_id.local_id,\n                 break_index: expr_exit,\n             });\n \n@@ -104,21 +104,22 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n             let expr_exit = self.opt_expr(&blk.expr, stmts_exit);\n \n-            self.add_ast_node(blk.id, &[expr_exit])\n+            self.add_ast_node(blk.hir_id.local_id, &[expr_exit])\n         }\n     }\n \n     fn stmt(&mut self, stmt: &hir::Stmt, pred: CFGIndex) -> CFGIndex {\n+        let hir_id = self.tcx.hir.node_to_hir_id(stmt.node.id());\n         match stmt.node {\n-            hir::StmtDecl(ref decl, id) => {\n+            hir::StmtDecl(ref decl, _) => {\n                 let exit = self.decl(&decl, pred);\n-                self.add_ast_node(id, &[exit])\n+                self.add_ast_node(hir_id.local_id, &[exit])\n             }\n \n-            hir::StmtExpr(ref expr, id) |\n-            hir::StmtSemi(ref expr, id) => {\n+            hir::StmtExpr(ref expr, _) |\n+            hir::StmtSemi(ref expr, _) => {\n                 let exit = self.expr(&expr, pred);\n-                self.add_ast_node(id, &[exit])\n+                self.add_ast_node(hir_id.local_id, &[exit])\n             }\n         }\n     }\n@@ -140,31 +141,31 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             PatKind::Path(_) |\n             PatKind::Lit(..) |\n             PatKind::Range(..) |\n-            PatKind::Wild => self.add_ast_node(pat.id, &[pred]),\n+            PatKind::Wild => self.add_ast_node(pat.hir_id.local_id, &[pred]),\n \n             PatKind::Box(ref subpat) |\n             PatKind::Ref(ref subpat, _) |\n             PatKind::Binding(.., Some(ref subpat)) => {\n                 let subpat_exit = self.pat(&subpat, pred);\n-                self.add_ast_node(pat.id, &[subpat_exit])\n+                self.add_ast_node(pat.hir_id.local_id, &[subpat_exit])\n             }\n \n             PatKind::TupleStruct(_, ref subpats, _) |\n             PatKind::Tuple(ref subpats, _) => {\n                 let pats_exit = self.pats_all(subpats.iter(), pred);\n-                self.add_ast_node(pat.id, &[pats_exit])\n+                self.add_ast_node(pat.hir_id.local_id, &[pats_exit])\n             }\n \n             PatKind::Struct(_, ref subpats, _) => {\n                 let pats_exit = self.pats_all(subpats.iter().map(|f| &f.node.pat), pred);\n-                self.add_ast_node(pat.id, &[pats_exit])\n+                self.add_ast_node(pat.hir_id.local_id, &[pats_exit])\n             }\n \n             PatKind::Slice(ref pre, ref vec, ref post) => {\n                 let pre_exit = self.pats_all(pre.iter(), pred);\n                 let vec_exit = self.pats_all(vec.iter(), pre_exit);\n                 let post_exit = self.pats_all(post.iter(), vec_exit);\n-                self.add_ast_node(pat.id, &[post_exit])\n+                self.add_ast_node(pat.hir_id.local_id, &[post_exit])\n             }\n         }\n     }\n@@ -180,7 +181,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         match expr.node {\n             hir::ExprBlock(ref blk) => {\n                 let blk_exit = self.block(&blk, pred);\n-                self.add_ast_node(expr.id, &[blk_exit])\n+                self.add_ast_node(expr.hir_id.local_id, &[blk_exit])\n             }\n \n             hir::ExprIf(ref cond, ref then, None) => {\n@@ -200,7 +201,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 //\n                 let cond_exit = self.expr(&cond, pred);                // 1\n                 let then_exit = self.expr(&then, cond_exit);          // 2\n-                self.add_ast_node(expr.id, &[cond_exit, then_exit])      // 3,4\n+                self.add_ast_node(expr.hir_id.local_id, &[cond_exit, then_exit])      // 3,4\n             }\n \n             hir::ExprIf(ref cond, ref then, Some(ref otherwise)) => {\n@@ -221,7 +222,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 let cond_exit = self.expr(&cond, pred);                // 1\n                 let then_exit = self.expr(&then, cond_exit);          // 2\n                 let else_exit = self.expr(&otherwise, cond_exit);      // 3\n-                self.add_ast_node(expr.id, &[then_exit, else_exit])      // 4, 5\n+                self.add_ast_node(expr.hir_id.local_id, &[then_exit, else_exit])      // 4, 5\n             }\n \n             hir::ExprWhile(ref cond, ref body, _) => {\n@@ -245,12 +246,12 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 let loopback = self.add_dummy_node(&[pred]);              // 1\n \n                 // Create expr_exit without pred (cond_exit)\n-                let expr_exit = self.add_ast_node(expr.id, &[]);         // 3\n+                let expr_exit = self.add_ast_node(expr.hir_id.local_id, &[]);         // 3\n \n                 // The LoopScope needs to be on the loop_scopes stack while evaluating the\n                 // condition and the body of the loop (both can break out of the loop)\n                 self.loop_scopes.push(LoopScope {\n-                    loop_id: expr.id,\n+                    loop_id: expr.hir_id.local_id,\n                     continue_index: loopback,\n                     break_index: expr_exit\n                 });\n@@ -282,9 +283,9 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 // may cause additional edges.\n \n                 let loopback = self.add_dummy_node(&[pred]);              // 1\n-                let expr_exit = self.add_ast_node(expr.id, &[]);          // 2\n+                let expr_exit = self.add_ast_node(expr.hir_id.local_id, &[]);          // 2\n                 self.loop_scopes.push(LoopScope {\n-                    loop_id: expr.id,\n+                    loop_id: expr.hir_id.local_id,\n                     continue_index: loopback,\n                     break_index: expr_exit,\n                 });\n@@ -295,7 +296,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             hir::ExprMatch(ref discr, ref arms, _) => {\n-                self.match_(expr.id, &discr, &arms, pred)\n+                self.match_(expr.hir_id.local_id, &discr, &arms, pred)\n             }\n \n             hir::ExprBinary(op, ref l, ref r) if op.node.is_lazy() => {\n@@ -315,30 +316,30 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 //\n                 let l_exit = self.expr(&l, pred);                      // 1\n                 let r_exit = self.expr(&r, l_exit);                    // 2\n-                self.add_ast_node(expr.id, &[l_exit, r_exit])            // 3,4\n+                self.add_ast_node(expr.hir_id.local_id, &[l_exit, r_exit])            // 3,4\n             }\n \n             hir::ExprRet(ref v) => {\n                 let v_exit = self.opt_expr(v, pred);\n-                let b = self.add_ast_node(expr.id, &[v_exit]);\n+                let b = self.add_ast_node(expr.hir_id.local_id, &[v_exit]);\n                 self.add_returning_edge(expr, b);\n                 self.add_unreachable_node()\n             }\n \n             hir::ExprBreak(destination, ref opt_expr) => {\n                 let v = self.opt_expr(opt_expr, pred);\n-                let (scope_id, break_dest) =\n+                let (target_scope, break_dest) =\n                     self.find_scope_edge(expr, destination, ScopeCfKind::Break);\n-                let b = self.add_ast_node(expr.id, &[v]);\n-                self.add_exiting_edge(expr, b, scope_id, break_dest);\n+                let b = self.add_ast_node(expr.hir_id.local_id, &[v]);\n+                self.add_exiting_edge(expr, b, target_scope, break_dest);\n                 self.add_unreachable_node()\n             }\n \n             hir::ExprAgain(destination) => {\n-                let (scope_id, cont_dest) =\n+                let (target_scope, cont_dest) =\n                     self.find_scope_edge(expr, destination, ScopeCfKind::Continue);\n-                let a = self.add_ast_node(expr.id, &[pred]);\n-                self.add_exiting_edge(expr, a, scope_id, cont_dest);\n+                let a = self.add_ast_node(expr.hir_id.local_id, &[pred]);\n+                self.add_exiting_edge(expr, a, target_scope, cont_dest);\n                 self.add_unreachable_node()\n             }\n \n@@ -397,7 +398,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             hir::ExprInlineAsm(_, ref outputs, ref inputs) => {\n                 let post_outputs = self.exprs(outputs.iter().map(|e| &*e), pred);\n                 let post_inputs = self.exprs(inputs.iter().map(|e| &*e), post_outputs);\n-                self.add_ast_node(expr.id, &[post_inputs])\n+                self.add_ast_node(expr.hir_id.local_id, &[post_inputs])\n             }\n \n             hir::ExprClosure(..) |\n@@ -444,10 +445,10 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         //! Handles case of an expression that evaluates `subexprs` in order\n \n         let subexprs_exit = self.exprs(subexprs, pred);\n-        self.add_ast_node(expr.id, &[subexprs_exit])\n+        self.add_ast_node(expr.hir_id.local_id, &[subexprs_exit])\n     }\n \n-    fn match_(&mut self, id: ast::NodeId, discr: &hir::Expr,\n+    fn match_(&mut self, id: hir::ItemLocalId, discr: &hir::Expr,\n               arms: &[hir::Arm], pred: CFGIndex) -> CFGIndex {\n         // The CFG for match expression is quite complex, so no ASCII\n         // art for it (yet).\n@@ -552,8 +553,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         self.add_node(CFGNodeData::Dummy, preds)\n     }\n \n-    fn add_ast_node(&mut self, id: ast::NodeId, preds: &[CFGIndex]) -> CFGIndex {\n-        assert!(id != ast::DUMMY_NODE_ID);\n+    fn add_ast_node(&mut self, id: hir::ItemLocalId, preds: &[CFGIndex]) -> CFGIndex {\n         self.add_node(CFGNodeData::AST(id), preds)\n     }\n \n@@ -579,14 +579,13 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     fn add_exiting_edge(&mut self,\n                         from_expr: &hir::Expr,\n                         from_index: CFGIndex,\n-                        scope_id: ast::NodeId,\n+                        target_scope: CodeExtent,\n                         to_index: CFGIndex) {\n         let mut data = CFGEdgeData { exiting_scopes: vec![] };\n-        let mut scope = CodeExtent::Misc(from_expr.id);\n-        let target_scope = CodeExtent::Misc(scope_id);\n+        let mut scope = CodeExtent::Misc(from_expr.hir_id.local_id);\n         let region_maps = self.tcx.region_maps(self.owner_def_id);\n         while scope != target_scope {\n-            data.exiting_scopes.push(scope.node_id());\n+            data.exiting_scopes.push(scope.item_local_id());\n             scope = region_maps.encl_scope(scope);\n         }\n         self.graph.add_edge(from_index, to_index, data);\n@@ -607,13 +606,14 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     fn find_scope_edge(&self,\n                   expr: &hir::Expr,\n                   destination: hir::Destination,\n-                  scope_cf_kind: ScopeCfKind) -> (ast::NodeId, CFGIndex) {\n+                  scope_cf_kind: ScopeCfKind) -> (CodeExtent, CFGIndex) {\n \n         match destination.target_id {\n             hir::ScopeTarget::Block(block_expr_id) => {\n                 for b in &self.breakable_block_scopes {\n-                    if b.block_expr_id == block_expr_id {\n-                        return (block_expr_id, match scope_cf_kind {\n+                    if b.block_expr_id == self.tcx.hir.node_to_hir_id(block_expr_id).local_id {\n+                        let scope_id = self.tcx.hir.node_to_hir_id(block_expr_id).local_id;\n+                        return (CodeExtent::Misc(scope_id), match scope_cf_kind {\n                             ScopeCfKind::Break => b.break_index,\n                             ScopeCfKind::Continue => bug!(\"can't continue to block\"),\n                         });\n@@ -623,8 +623,9 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n             hir::ScopeTarget::Loop(hir::LoopIdResult::Ok(loop_id)) => {\n                 for l in &self.loop_scopes {\n-                    if l.loop_id == loop_id {\n-                        return (loop_id, match scope_cf_kind {\n+                    if l.loop_id == self.tcx.hir.node_to_hir_id(loop_id).local_id {\n+                        let scope_id = self.tcx.hir.node_to_hir_id(loop_id).local_id;\n+                        return (CodeExtent::Misc(scope_id), match scope_cf_kind {\n                             ScopeCfKind::Break => l.break_index,\n                             ScopeCfKind::Continue => l.continue_index,\n                         });"}, {"sha": "9241240caf043b174a72fdd913d6c2bbf91b940d", "filename": "src/librustc/cfg/graphviz.rs", "status": "modified", "additions": 34, "deletions": 30, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fgraphviz.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -15,40 +15,48 @@\n use graphviz as dot;\n use graphviz::IntoCow;\n \n-use syntax::ast;\n-\n-use hir::map as hir_map;\n use cfg;\n+use hir;\n+use ty::TyCtxt;\n \n pub type Node<'a> = (cfg::CFGIndex, &'a cfg::CFGNode);\n pub type Edge<'a> = &'a cfg::CFGEdge;\n \n-pub struct LabelledCFG<'a, 'hir: 'a> {\n-    pub hir_map: &'a hir_map::Map<'hir>,\n+pub struct LabelledCFG<'a, 'tcx: 'a> {\n+    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pub cfg: &'a cfg::CFG,\n     pub name: String,\n     /// `labelled_edges` controls whether we emit labels on the edges\n     pub labelled_edges: bool,\n }\n \n-fn replace_newline_with_backslash_l(s: String) -> String {\n-    // Replacing newlines with \\\\l causes each line to be left-aligned,\n-    // improving presentation of (long) pretty-printed expressions.\n-    if s.contains(\"\\n\") {\n-        let mut s = s.replace(\"\\n\", \"\\\\l\");\n-        // Apparently left-alignment applies to the line that precedes\n-        // \\l, not the line that follows; so, add \\l at end of string\n-        // if not already present, ensuring last line gets left-aligned\n-        // as well.\n-        let mut last_two: Vec<_> =\n-            s.chars().rev().take(2).collect();\n-        last_two.reverse();\n-        if last_two != ['\\\\', 'l'] {\n-            s.push_str(\"\\\\l\");\n+impl<'a, 'tcx> LabelledCFG<'a, 'tcx> {\n+    fn local_id_to_string(&self, local_id: hir::ItemLocalId) -> String {\n+        assert!(self.cfg.owner_def_id.is_local());\n+        let node_id = self.tcx.hir.hir_to_node_id(hir::HirId {\n+            owner: self.tcx.hir.def_index_to_hir_id(self.cfg.owner_def_id.index).owner,\n+            local_id\n+        });\n+        let s = self.tcx.hir.node_to_string(node_id);\n+\n+        // Replacing newlines with \\\\l causes each line to be left-aligned,\n+        // improving presentation of (long) pretty-printed expressions.\n+        if s.contains(\"\\n\") {\n+            let mut s = s.replace(\"\\n\", \"\\\\l\");\n+            // Apparently left-alignment applies to the line that precedes\n+            // \\l, not the line that follows; so, add \\l at end of string\n+            // if not already present, ensuring last line gets left-aligned\n+            // as well.\n+            let mut last_two: Vec<_> =\n+                s.chars().rev().take(2).collect();\n+            last_two.reverse();\n+            if last_two != ['\\\\', 'l'] {\n+                s.push_str(\"\\\\l\");\n+            }\n+            s\n+        } else {\n+            s\n         }\n-        s\n-    } else {\n-        s\n     }\n }\n \n@@ -66,12 +74,10 @@ impl<'a, 'hir> dot::Labeller<'a> for LabelledCFG<'a, 'hir> {\n             dot::LabelText::LabelStr(\"entry\".into_cow())\n         } else if i == self.cfg.exit {\n             dot::LabelText::LabelStr(\"exit\".into_cow())\n-        } else if n.data.id() == ast::DUMMY_NODE_ID {\n+        } else if n.data.id() == hir::DUMMY_ITEM_LOCAL_ID {\n             dot::LabelText::LabelStr(\"(dummy_node)\".into_cow())\n         } else {\n-            let s = self.hir_map.node_to_string(n.data.id());\n-            // left-aligns the lines\n-            let s = replace_newline_with_backslash_l(s);\n+            let s = self.local_id_to_string(n.data.id());\n             dot::LabelText::EscStr(s.into_cow())\n         }\n     }\n@@ -82,15 +88,13 @@ impl<'a, 'hir> dot::Labeller<'a> for LabelledCFG<'a, 'hir> {\n             return dot::LabelText::EscStr(label.into_cow());\n         }\n         let mut put_one = false;\n-        for (i, &node_id) in e.data.exiting_scopes.iter().enumerate() {\n+        for (i, &id) in e.data.exiting_scopes.iter().enumerate() {\n             if put_one {\n                 label.push_str(\",\\\\l\");\n             } else {\n                 put_one = true;\n             }\n-            let s = self.hir_map.node_to_string(node_id);\n-            // left-aligns the lines\n-            let s = replace_newline_with_backslash_l(s);\n+            let s = self.local_id_to_string(id);\n             label.push_str(&format!(\"exiting scope_{} {}\",\n                                    i,\n                                    &s[..]));"}, {"sha": "b379d3956e944b01b399b508ae025241ac12450b", "filename": "src/librustc/cfg/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fmod.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -13,40 +13,41 @@\n \n use rustc_data_structures::graph;\n use ty::TyCtxt;\n-use syntax::ast;\n use hir;\n+use hir::def_id::DefId;\n \n mod construct;\n pub mod graphviz;\n \n pub struct CFG {\n+    pub owner_def_id: DefId,\n     pub graph: CFGGraph,\n     pub entry: CFGIndex,\n     pub exit: CFGIndex,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq)]\n pub enum CFGNodeData {\n-    AST(ast::NodeId),\n+    AST(hir::ItemLocalId),\n     Entry,\n     Exit,\n     Dummy,\n     Unreachable,\n }\n \n impl CFGNodeData {\n-    pub fn id(&self) -> ast::NodeId {\n+    pub fn id(&self) -> hir::ItemLocalId {\n         if let CFGNodeData::AST(id) = *self {\n             id\n         } else {\n-            ast::DUMMY_NODE_ID\n+            hir::DUMMY_ITEM_LOCAL_ID\n         }\n     }\n }\n \n #[derive(Debug)]\n pub struct CFGEdgeData {\n-    pub exiting_scopes: Vec<ast::NodeId>\n+    pub exiting_scopes: Vec<hir::ItemLocalId>\n }\n \n pub type CFGIndex = graph::NodeIndex;\n@@ -63,7 +64,7 @@ impl CFG {\n         construct::construct(tcx, body)\n     }\n \n-    pub fn node_is_reachable(&self, id: ast::NodeId) -> bool {\n+    pub fn node_is_reachable(&self, id: hir::ItemLocalId) -> bool {\n         self.graph.depth_traverse(self.entry, graph::OUTGOING)\n                   .any(|idx| self.graph.node_data(idx).id() == id)\n     }"}, {"sha": "e54df2d50d8ebde88366df3f70c8fbb2f6b50eab", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -26,7 +26,7 @@ use syntax_pos::Span;\n \n use hir::*;\n use hir::print::Nested;\n-use util::nodemap::DefIdMap;\n+use util::nodemap::{DefIdMap, FxHashMap};\n \n use arena::TypedArena;\n use std::cell::RefCell;\n@@ -251,6 +251,9 @@ pub struct Map<'hir> {\n \n     /// Bodies inlined from other crates are cached here.\n     inlined_bodies: RefCell<DefIdMap<&'hir Body>>,\n+\n+    /// The reverse mapping of `node_to_hir_id`.\n+    hir_to_node_id: FxHashMap<HirId, NodeId>,\n }\n \n impl<'hir> Map<'hir> {\n@@ -339,6 +342,11 @@ impl<'hir> Map<'hir> {\n         self.definitions.as_local_node_id(def_id)\n     }\n \n+    #[inline]\n+    pub fn hir_to_node_id(&self, hir_id: HirId) -> NodeId {\n+        self.hir_to_node_id[&hir_id]\n+    }\n+\n     #[inline]\n     pub fn node_to_hir_id(&self, node_id: NodeId) -> HirId {\n         self.definitions.node_to_hir_id(node_id)\n@@ -1021,10 +1029,15 @@ pub fn map_crate<'hir>(forest: &'hir mut Forest,\n               entries, vector_length, (entries as f64 / vector_length as f64) * 100.);\n     }\n \n+    // Build the reverse mapping of `node_to_hir_id`.\n+    let hir_to_node_id = definitions.node_to_hir_id.iter_enumerated()\n+        .map(|(node_id, &hir_id)| (hir_id, node_id)).collect();\n+\n     let map = Map {\n         forest,\n         dep_graph: forest.dep_graph.clone(),\n         map,\n+        hir_to_node_id,\n         definitions,\n         inlined_bodies: RefCell::new(DefIdMap()),\n     };"}, {"sha": "90d781c6e36649e15357bf3faf14a802da7b165a", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -64,7 +64,7 @@ use std::fmt;\n use hir;\n use hir::map as hir_map;\n use hir::def_id::DefId;\n-use middle::region;\n+use middle::region::{self, RegionMaps};\n use traits::{ObligationCause, ObligationCauseCode};\n use ty::{self, Region, TyCtxt, TypeFoldable};\n use ty::error::TypeError;\n@@ -83,6 +83,7 @@ mod anon_anon_conflict;\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn note_and_explain_region(self,\n+                                   region_maps: &RegionMaps,\n                                    err: &mut DiagnosticBuilder,\n                                    prefix: &str,\n                                    region: ty::Region<'tcx>,\n@@ -130,14 +131,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     format!(\"{}unknown scope: {:?}{}.  Please report a bug.\",\n                             prefix, scope, suffix)\n                 };\n-                let span = match scope.span(&self.hir) {\n-                    Some(s) => s,\n-                    None => {\n-                        err.note(&unknown_scope());\n-                        return;\n-                    }\n-                };\n-                let tag = match self.hir.find(scope.node_id()) {\n+                let span = scope.span(self, region_maps);\n+                let tag = match self.hir.find(scope.node_id(self, region_maps)) {\n                     Some(hir_map::NodeBlock(_)) => \"block\",\n                     Some(hir_map::NodeExpr(expr)) => match expr.node {\n                         hir::ExprCall(..) => \"call\",\n@@ -260,8 +255,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n-\n-    pub fn report_region_errors(&self, errors: &Vec<RegionResolutionError<'tcx>>) {\n+    pub fn report_region_errors(&self,\n+                                region_maps: &RegionMaps,\n+                                errors: &Vec<RegionResolutionError<'tcx>>) {\n         debug!(\"report_region_errors(): {} errors to start\", errors.len());\n \n         // try to pre-process the errors, which will group some of them\n@@ -285,16 +281,16 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                   // the error. If all of these fails, we fall back to a rather\n                   // general bit of code that displays the error information\n                   ConcreteFailure(origin, sub, sup) => {\n-\n-                      self.report_concrete_failure(origin, sub, sup).emit();\n+                      self.report_concrete_failure(region_maps, origin, sub, sup).emit();\n                   }\n \n                   GenericBoundFailure(kind, param_ty, sub) => {\n-                      self.report_generic_bound_failure(kind, param_ty, sub);\n+                      self.report_generic_bound_failure(region_maps, kind, param_ty, sub);\n                   }\n \n                   SubSupConflict(var_origin, sub_origin, sub_r, sup_origin, sup_r) => {\n-                        self.report_sub_sup_conflict(var_origin,\n+                        self.report_sub_sup_conflict(region_maps,\n+                                                     var_origin,\n                                                      sub_origin,\n                                                      sub_r,\n                                                      sup_origin,\n@@ -773,6 +769,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn report_generic_bound_failure(&self,\n+                                    region_maps: &RegionMaps,\n                                     origin: SubregionOrigin<'tcx>,\n                                     bound_kind: GenericKind<'tcx>,\n                                     sub: Region<'tcx>)\n@@ -840,6 +837,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 err.help(&format!(\"consider adding an explicit lifetime bound for `{}`\",\n                                   bound_kind));\n                 self.tcx.note_and_explain_region(\n+                    region_maps,\n                     &mut err,\n                     &format!(\"{} must be valid for \", labeled_user_string),\n                     sub,\n@@ -853,21 +851,22 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn report_sub_sup_conflict(&self,\n+                               region_maps: &RegionMaps,\n                                var_origin: RegionVariableOrigin,\n                                sub_origin: SubregionOrigin<'tcx>,\n                                sub_region: Region<'tcx>,\n                                sup_origin: SubregionOrigin<'tcx>,\n                                sup_region: Region<'tcx>) {\n         let mut err = self.report_inference_failure(var_origin);\n \n-        self.tcx.note_and_explain_region(&mut err,\n+        self.tcx.note_and_explain_region(region_maps, &mut err,\n             \"first, the lifetime cannot outlive \",\n             sup_region,\n             \"...\");\n \n         self.note_region_origin(&mut err, &sup_origin);\n \n-        self.tcx.note_and_explain_region(&mut err,\n+        self.tcx.note_and_explain_region(region_maps, &mut err,\n             \"but, the lifetime must be valid for \",\n             sub_region,\n             \"...\");"}, {"sha": "3e78cce80f594ad24657f502a58b773f17378fe8", "filename": "src/librustc/infer/error_reporting/note.rs", "status": "modified", "additions": 64, "deletions": 48, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use infer::{self, InferCtxt, SubregionOrigin};\n+use middle::region::RegionMaps;\n use ty::{self, Region};\n use ty::error::TypeError;\n use errors::DiagnosticBuilder;\n@@ -144,26 +145,31 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub(super) fn report_concrete_failure(&self,\n+                                          region_maps: &RegionMaps,\n                                           origin: SubregionOrigin<'tcx>,\n                                           sub: Region<'tcx>,\n                                           sup: Region<'tcx>)\n                                           -> DiagnosticBuilder<'tcx> {\n         match origin {\n             infer::Subtype(trace) => {\n                 let terr = TypeError::RegionsDoesNotOutlive(sup, sub);\n-                self.report_and_explain_type_error(trace, &terr)\n+                let mut err = self.report_and_explain_type_error(trace, &terr);\n+                self.tcx.note_and_explain_region(region_maps, &mut err, \"\", sup, \"...\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"...does not necessarily outlive \", sub, \"\");\n+                err\n             }\n             infer::Reborrow(span) => {\n                 let mut err = struct_span_err!(self.tcx.sess,\n                                                span,\n                                                E0312,\n                                                \"lifetime of reference outlives lifetime of \\\n                                                 borrowed content...\");\n-                self.tcx.note_and_explain_region(&mut err,\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n                                                  \"...the reference is valid for \",\n                                                  sub,\n                                                  \"...\");\n-                self.tcx.note_and_explain_region(&mut err,\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n                                                  \"...but the borrowed content is only valid for \",\n                                                  sup,\n                                                  \"\");\n@@ -177,27 +183,27 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                 of captured variable `{}`...\",\n                                                self.tcx\n                                                    .local_var_name_str_def_index(upvar_id.var_id));\n-                self.tcx.note_and_explain_region(&mut err,\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n                                                  \"...the borrowed pointer is valid for \",\n                                                  sub,\n                                                  \"...\");\n-                self.tcx\n-                    .note_and_explain_region(\n-                      &mut err,\n-                      &format!(\"...but `{}` is only valid for \",\n-                               self.tcx.local_var_name_str_def_index(upvar_id.var_id)),\n-                      sup,\n-                      \"\");\n+                self.tcx.note_and_explain_region(\n+                    region_maps,\n+                    &mut err,\n+                    &format!(\"...but `{}` is only valid for \",\n+                        self.tcx.local_var_name_str_def_index(upvar_id.var_id)),\n+                    sup,\n+                    \"\");\n                 err\n             }\n             infer::InfStackClosure(span) => {\n                 let mut err =\n                     struct_span_err!(self.tcx.sess, span, E0314, \"closure outlives stack frame\");\n-                self.tcx.note_and_explain_region(&mut err,\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n                                                  \"...the closure must be valid for \",\n                                                  sub,\n                                                  \"...\");\n-                self.tcx.note_and_explain_region(&mut err,\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n                                                  \"...but the closure's stack frame is only valid \\\n                                                   for \",\n                                                  sup,\n@@ -209,17 +215,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                span,\n                                                E0315,\n                                                \"cannot invoke closure outside of its lifetime\");\n-                self.tcx\n-                    .note_and_explain_region(&mut err, \"the closure is only valid for \", sup, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"the closure is only valid for \", sup, \"\");\n                 err\n             }\n             infer::DerefPointer(span) => {\n                 let mut err = struct_span_err!(self.tcx.sess,\n                                                span,\n                                                E0473,\n                                                \"dereference of reference outside its lifetime\");\n-                self.tcx\n-                    .note_and_explain_region(&mut err, \"the reference is only valid for \", sup, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"the reference is only valid for \", sup, \"\");\n                 err\n             }\n             infer::FreeVariable(span, id) => {\n@@ -229,17 +235,19 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                \"captured variable `{}` does not outlive the \\\n                                                 enclosing closure\",\n                                                self.tcx.local_var_name_str(id));\n-                self.tcx\n-                    .note_and_explain_region(&mut err, \"captured variable is valid for \", sup, \"\");\n-                self.tcx.note_and_explain_region(&mut err, \"closure is valid for \", sub, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"captured variable is valid for \", sup, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"closure is valid for \", sub, \"\");\n                 err\n             }\n             infer::IndexSlice(span) => {\n                 let mut err = struct_span_err!(self.tcx.sess,\n                                                span,\n                                                E0475,\n                                                \"index of slice outside its lifetime\");\n-                self.tcx.note_and_explain_region(&mut err, \"the slice is only valid for \", sup, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"the slice is only valid for \", sup, \"\");\n                 err\n             }\n             infer::RelateObjectBound(span) => {\n@@ -248,8 +256,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                E0476,\n                                                \"lifetime of the source pointer does not outlive \\\n                                                 lifetime bound of the object type\");\n-                self.tcx.note_and_explain_region(&mut err, \"object type is valid for \", sub, \"\");\n-                self.tcx.note_and_explain_region(&mut err,\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"object type is valid for \", sub, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n                                                  \"source pointer is only valid for \",\n                                                  sup,\n                                                  \"\");\n@@ -264,22 +273,24 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                self.ty_to_string(ty));\n                 match *sub {\n                     ty::ReStatic => {\n-                        self.tcx.note_and_explain_region(&mut err, \"type must satisfy \", sub, \"\")\n+                        self.tcx.note_and_explain_region(region_maps, &mut err,\n+                            \"type must satisfy \", sub, \"\")\n                     }\n                     _ => {\n-                        self.tcx.note_and_explain_region(&mut err, \"type must outlive \", sub, \"\")\n+                        self.tcx.note_and_explain_region(region_maps, &mut err,\n+                            \"type must outlive \", sub, \"\")\n                     }\n                 }\n                 err\n             }\n             infer::RelateRegionParamBound(span) => {\n                 let mut err =\n                     struct_span_err!(self.tcx.sess, span, E0478, \"lifetime bound not satisfied\");\n-                self.tcx.note_and_explain_region(&mut err,\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n                                                  \"lifetime parameter instantiated with \",\n                                                  sup,\n                                                  \"\");\n-                self.tcx.note_and_explain_region(&mut err,\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n                                                  \"but lifetime parameter must outlive \",\n                                                  sub,\n                                                  \"\");\n@@ -292,7 +303,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                \"the type `{}` (provided as the value of a type \\\n                                                 parameter) is not valid at this point\",\n                                                self.ty_to_string(ty));\n-                self.tcx.note_and_explain_region(&mut err, \"type must outlive \", sub, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"type must outlive \", sub, \"\");\n                 err\n             }\n             infer::CallRcvr(span) => {\n@@ -301,8 +313,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                E0480,\n                                                \"lifetime of method receiver does not outlive the \\\n                                                 method call\");\n-                self.tcx\n-                    .note_and_explain_region(&mut err, \"the receiver is only valid for \", sup, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                \"the receiver is only valid for \", sup, \"\");\n                 err\n             }\n             infer::CallArg(span) => {\n@@ -311,7 +323,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                E0481,\n                                                \"lifetime of function argument does not outlive \\\n                                                 the function call\");\n-                self.tcx.note_and_explain_region(&mut err,\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n                                                  \"the function argument is only valid for \",\n                                                  sup,\n                                                  \"\");\n@@ -323,7 +335,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                E0482,\n                                                \"lifetime of return value does not outlive the \\\n                                                 function call\");\n-                self.tcx.note_and_explain_region(&mut err,\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n                                                  \"the return value is only valid for \",\n                                                  sup,\n                                                  \"\");\n@@ -335,17 +347,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                E0483,\n                                                \"lifetime of operand does not outlive the \\\n                                                 operation\");\n-                self.tcx\n-                    .note_and_explain_region(&mut err, \"the operand is only valid for \", sup, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"the operand is only valid for \", sup, \"\");\n                 err\n             }\n             infer::AddrOf(span) => {\n                 let mut err = struct_span_err!(self.tcx.sess,\n                                                span,\n                                                E0484,\n                                                \"reference is not valid at the time of borrow\");\n-                self.tcx\n-                    .note_and_explain_region(&mut err, \"the borrow is only valid for \", sup, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"the borrow is only valid for \", sup, \"\");\n                 err\n             }\n             infer::AutoBorrow(span) => {\n@@ -354,7 +366,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                E0485,\n                                                \"automatically reference is not valid at the time \\\n                                                 of borrow\");\n-                self.tcx.note_and_explain_region(&mut err,\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n                                                  \"the automatic borrow is only valid for \",\n                                                  sup,\n                                                  \"\");\n@@ -367,7 +379,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                \"type of expression contains references that are \\\n                                                 not valid during the expression: `{}`\",\n                                                self.ty_to_string(t));\n-                self.tcx.note_and_explain_region(&mut err, \"type is only valid for \", sup, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"type is only valid for \", sup, \"\");\n                 err\n             }\n             infer::SafeDestructor(span) => {\n@@ -377,8 +390,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                \"unsafe use of destructor: destructor might be \\\n                                                 called while references are dead\");\n                 // FIXME (22171): terms \"super/subregion\" are suboptimal\n-                self.tcx.note_and_explain_region(&mut err, \"superregion: \", sup, \"\");\n-                self.tcx.note_and_explain_region(&mut err, \"subregion: \", sub, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err, \"superregion: \", sup, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err, \"subregion: \", sub, \"\");\n                 err\n             }\n             infer::BindingTypeIsNotValidAtDecl(span) => {\n@@ -387,17 +400,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                E0488,\n                                                \"lifetime of variable does not enclose its \\\n                                                 declaration\");\n-                self.tcx\n-                    .note_and_explain_region(&mut err, \"the variable is only valid for \", sup, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"the variable is only valid for \", sup, \"\");\n                 err\n             }\n             infer::ParameterInScope(_, span) => {\n                 let mut err = struct_span_err!(self.tcx.sess,\n                                                span,\n                                                E0489,\n                                                \"type/lifetime parameter not in scope here\");\n-                self.tcx\n-                    .note_and_explain_region(&mut err, \"the parameter is only valid for \", sub, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"the parameter is only valid for \", sub, \"\");\n                 err\n             }\n             infer::DataBorrowed(ty, span) => {\n@@ -406,8 +419,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                E0490,\n                                                \"a value of type `{}` is borrowed for too long\",\n                                                self.ty_to_string(ty));\n-                self.tcx.note_and_explain_region(&mut err, \"the type is valid for \", sub, \"\");\n-                self.tcx.note_and_explain_region(&mut err, \"but the borrow lasts for \", sup, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"the type is valid for \", sub, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"but the borrow lasts for \", sup, \"\");\n                 err\n             }\n             infer::ReferenceOutlivesReferent(ty, span) => {\n@@ -417,8 +432,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                \"in type `{}`, reference has a longer lifetime \\\n                                                 than the data it references\",\n                                                self.ty_to_string(ty));\n-                self.tcx.note_and_explain_region(&mut err, \"the pointer is valid for \", sub, \"\");\n-                self.tcx.note_and_explain_region(&mut err,\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"the pointer is valid for \", sub, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n                                                  \"but the referenced data is only valid for \",\n                                                  sup,\n                                                  \"\");"}, {"sha": "21af92a25e6845249be4e56f9f732dba18fc7063", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -1084,7 +1084,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             // this infcx was in use.  This is totally hokey but\n             // otherwise we have a hard time separating legit region\n             // errors from silly ones.\n-            self.report_region_errors(&errors); // see error_reporting module\n+            self.report_region_errors(region_map, &errors); // see error_reporting module\n         }\n     }\n "}, {"sha": "c5863b5618feb37fac16c118ed590ae5b7b986bd", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -247,13 +247,27 @@ impl<'a> LintLevelsBuilder<'a> {\n                                                                     self.cur,\n                                                                     Some(&specs));\n                         let msg = format!(\"unknown lint: `{}`\", name);\n-                        lint::struct_lint_level(self.sess,\n+                        let mut db = lint::struct_lint_level(self.sess,\n                                                 lint,\n                                                 level,\n                                                 src,\n                                                 Some(li.span.into()),\n-                                                &msg)\n-                            .emit();\n+                                                &msg);\n+                        if name.as_str().chars().any(|c| c.is_uppercase()) {\n+                            let name_lower = name.as_str().to_lowercase();\n+                            if let CheckLintNameResult::NoLint =\n+                                    store.check_lint_name(&name_lower) {\n+                                db.emit();\n+                            } else {\n+                                db.span_suggestion(\n+                                    li.span,\n+                                    \"lowercase the lint name\",\n+                                    name_lower\n+                                ).emit();\n+                            }\n+                        } else {\n+                            db.emit();\n+                        }\n                     }\n                 }\n             }"}, {"sha": "e88678dea1d747d485c0c72af523c2ee58be2f3e", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 49, "deletions": 47, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -20,12 +20,11 @@ use ty::TyCtxt;\n use std::io;\n use std::mem;\n use std::usize;\n-use syntax::ast;\n use syntax::print::pprust::PrintState;\n \n use rustc_data_structures::graph::OUTGOING;\n \n-use util::nodemap::NodeMap;\n+use util::nodemap::FxHashMap;\n use hir;\n use hir::intravisit::{self, IdRange};\n use hir::print as pprust;\n@@ -56,7 +55,7 @@ pub struct DataFlowContext<'a, 'tcx: 'a, O> {\n \n     // mapping from node to cfg node index\n     // FIXME (#6298): Shouldn't this go with CFG?\n-    nodeid_to_index: NodeMap<Vec<CFGIndex>>,\n+    local_id_to_index: FxHashMap<hir::ItemLocalId, Vec<CFGIndex>>,\n \n     // Bit sets per cfg node.  The following three fields (`gens`, `kills`,\n     // and `on_entry`) all have the same structure. For each id in\n@@ -97,15 +96,16 @@ struct PropagationContext<'a, 'b: 'a, 'tcx: 'b, O: 'a> {\n     changed: bool\n }\n \n-fn get_cfg_indices<'a>(id: ast::NodeId, index: &'a NodeMap<Vec<CFGIndex>>) -> &'a [CFGIndex] {\n-    let opt_indices = index.get(&id);\n-    opt_indices.map(|v| &v[..]).unwrap_or(&[])\n+fn get_cfg_indices<'a>(id: hir::ItemLocalId,\n+                       index: &'a FxHashMap<hir::ItemLocalId, Vec<CFGIndex>>)\n+                       -> &'a [CFGIndex] {\n+    index.get(&id).map_or(&[], |v| &v[..])\n }\n \n impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n-    fn has_bitset_for_nodeid(&self, n: ast::NodeId) -> bool {\n-        assert!(n != ast::DUMMY_NODE_ID);\n-        self.nodeid_to_index.contains_key(&n)\n+    fn has_bitset_for_local_id(&self, n: hir::ItemLocalId) -> bool {\n+        assert!(n != hir::DUMMY_ITEM_LOCAL_ID);\n+        self.local_id_to_index.contains_key(&n)\n     }\n }\n \n@@ -117,19 +117,20 @@ impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O\n            ps: &mut pprust::State,\n            node: pprust::AnnNode) -> io::Result<()> {\n         let id = match node {\n-            pprust::NodeName(_) => ast::CRATE_NODE_ID,\n-            pprust::NodeExpr(expr) => expr.id,\n-            pprust::NodeBlock(blk) => blk.id,\n-            pprust::NodeItem(_) | pprust::NodeSubItem(_) => ast::CRATE_NODE_ID,\n-            pprust::NodePat(pat) => pat.id\n+            pprust::NodeName(_) => return Ok(()),\n+            pprust::NodeExpr(expr) => expr.hir_id.local_id,\n+            pprust::NodeBlock(blk) => blk.hir_id.local_id,\n+            pprust::NodeItem(_) |\n+            pprust::NodeSubItem(_) => return Ok(()),\n+            pprust::NodePat(pat) => pat.hir_id.local_id\n         };\n \n-        if !self.has_bitset_for_nodeid(id) {\n+        if !self.has_bitset_for_local_id(id) {\n             return Ok(());\n         }\n \n         assert!(self.bits_per_id > 0);\n-        let indices = get_cfg_indices(id, &self.nodeid_to_index);\n+        let indices = get_cfg_indices(id, &self.local_id_to_index);\n         for &cfgidx in indices {\n             let (start, end) = self.compute_id_range(cfgidx);\n             let on_entry = &self.on_entry[start.. end];\n@@ -157,17 +158,18 @@ impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O\n             };\n \n             ps.synth_comment(\n-                format!(\"id {}: {}{}{}{}\", id, entry_str,\n+                format!(\"id {}: {}{}{}{}\", id.as_usize(), entry_str,\n                         gens_str, action_kills_str, scope_kills_str))?;\n             ps.s.space()?;\n         }\n         Ok(())\n     }\n }\n \n-fn build_nodeid_to_index(body: Option<&hir::Body>,\n-                         cfg: &cfg::CFG) -> NodeMap<Vec<CFGIndex>> {\n-    let mut index = NodeMap();\n+fn build_local_id_to_index(body: Option<&hir::Body>,\n+                           cfg: &cfg::CFG)\n+                           -> FxHashMap<hir::ItemLocalId, Vec<CFGIndex>> {\n+    let mut index = FxHashMap();\n \n     // FIXME (#6298): Would it be better to fold formals from decl\n     // into cfg itself?  i.e. introduce a fn-based flow-graph in\n@@ -188,14 +190,14 @@ fn build_nodeid_to_index(body: Option<&hir::Body>,\n \n     /// Add mappings from the ast nodes for the formal bindings to\n     /// the entry-node in the graph.\n-    fn add_entries_from_fn_body(index: &mut NodeMap<Vec<CFGIndex>>,\n+    fn add_entries_from_fn_body(index: &mut FxHashMap<hir::ItemLocalId, Vec<CFGIndex>>,\n                                 body: &hir::Body,\n                                 entry: CFGIndex) {\n         use hir::intravisit::Visitor;\n \n         struct Formals<'a> {\n             entry: CFGIndex,\n-            index: &'a mut NodeMap<Vec<CFGIndex>>,\n+            index: &'a mut FxHashMap<hir::ItemLocalId, Vec<CFGIndex>>,\n         }\n         let mut formals = Formals { entry: entry, index: index };\n         for arg in &body.arguments {\n@@ -207,7 +209,7 @@ fn build_nodeid_to_index(body: Option<&hir::Body>,\n             }\n \n             fn visit_pat(&mut self, p: &hir::Pat) {\n-                self.index.entry(p.id).or_insert(vec![]).push(self.entry);\n+                self.index.entry(p.hir_id.local_id).or_insert(vec![]).push(self.entry);\n                 intravisit::walk_pat(self, p)\n             }\n         }\n@@ -259,13 +261,13 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         let kills2 = zeroes;\n         let on_entry = vec![entry; num_nodes * words_per_id];\n \n-        let nodeid_to_index = build_nodeid_to_index(body, cfg);\n+        let local_id_to_index = build_local_id_to_index(body, cfg);\n \n         DataFlowContext {\n             tcx,\n             analysis_name,\n             words_per_id,\n-            nodeid_to_index,\n+            local_id_to_index,\n             bits_per_id,\n             oper,\n             gens,\n@@ -275,29 +277,29 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         }\n     }\n \n-    pub fn add_gen(&mut self, id: ast::NodeId, bit: usize) {\n+    pub fn add_gen(&mut self, id: hir::ItemLocalId, bit: usize) {\n         //! Indicates that `id` generates `bit`\n-        debug!(\"{} add_gen(id={}, bit={})\",\n+        debug!(\"{} add_gen(id={:?}, bit={})\",\n                self.analysis_name, id, bit);\n-        assert!(self.nodeid_to_index.contains_key(&id));\n+        assert!(self.local_id_to_index.contains_key(&id));\n         assert!(self.bits_per_id > 0);\n \n-        let indices = get_cfg_indices(id, &self.nodeid_to_index);\n+        let indices = get_cfg_indices(id, &self.local_id_to_index);\n         for &cfgidx in indices {\n             let (start, end) = self.compute_id_range(cfgidx);\n             let gens = &mut self.gens[start.. end];\n             set_bit(gens, bit);\n         }\n     }\n \n-    pub fn add_kill(&mut self, kind: KillFrom, id: ast::NodeId, bit: usize) {\n+    pub fn add_kill(&mut self, kind: KillFrom, id: hir::ItemLocalId, bit: usize) {\n         //! Indicates that `id` kills `bit`\n-        debug!(\"{} add_kill(id={}, bit={})\",\n+        debug!(\"{} add_kill(id={:?}, bit={})\",\n                self.analysis_name, id, bit);\n-        assert!(self.nodeid_to_index.contains_key(&id));\n+        assert!(self.local_id_to_index.contains_key(&id));\n         assert!(self.bits_per_id > 0);\n \n-        let indices = get_cfg_indices(id, &self.nodeid_to_index);\n+        let indices = get_cfg_indices(id, &self.local_id_to_index);\n         for &cfgidx in indices {\n             let (start, end) = self.compute_id_range(cfgidx);\n             let kills = match kind {\n@@ -341,15 +343,15 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n     }\n \n \n-    pub fn each_bit_on_entry<F>(&self, id: ast::NodeId, mut f: F) -> bool where\n+    pub fn each_bit_on_entry<F>(&self, id: hir::ItemLocalId, mut f: F) -> bool where\n         F: FnMut(usize) -> bool,\n     {\n         //! Iterates through each bit that is set on entry to `id`.\n         //! Only useful after `propagate()` has been called.\n-        if !self.has_bitset_for_nodeid(id) {\n+        if !self.has_bitset_for_local_id(id) {\n             return true;\n         }\n-        let indices = get_cfg_indices(id, &self.nodeid_to_index);\n+        let indices = get_cfg_indices(id, &self.local_id_to_index);\n         for &cfgidx in indices {\n             if !self.each_bit_for_node(EntryOrExit::Entry, cfgidx, |i| f(i)) {\n                 return false;\n@@ -387,11 +389,11 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         self.each_bit(slice, f)\n     }\n \n-    pub fn each_gen_bit<F>(&self, id: ast::NodeId, mut f: F) -> bool where\n+    pub fn each_gen_bit<F>(&self, id: hir::ItemLocalId, mut f: F) -> bool where\n         F: FnMut(usize) -> bool,\n     {\n         //! Iterates through each bit in the gen set for `id`.\n-        if !self.has_bitset_for_nodeid(id) {\n+        if !self.has_bitset_for_local_id(id) {\n             return true;\n         }\n \n@@ -401,11 +403,11 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n             return true;\n         }\n \n-        let indices = get_cfg_indices(id, &self.nodeid_to_index);\n+        let indices = get_cfg_indices(id, &self.local_id_to_index);\n         for &cfgidx in indices {\n             let (start, end) = self.compute_id_range(cfgidx);\n             let gens = &self.gens[start.. end];\n-            debug!(\"{} each_gen_bit(id={}, gens={})\",\n+            debug!(\"{} each_gen_bit(id={:?}, gens={})\",\n                    self.analysis_name, id, bits_to_string(gens));\n             if !self.each_bit(gens, |i| f(i)) {\n                 return false;\n@@ -472,26 +474,26 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n             let mut orig_kills = self.scope_kills[start.. end].to_vec();\n \n             let mut changed = false;\n-            for &node_id in &edge.data.exiting_scopes {\n-                let opt_cfg_idx = self.nodeid_to_index.get(&node_id);\n+            for &id in &edge.data.exiting_scopes {\n+                let opt_cfg_idx = self.local_id_to_index.get(&id);\n                 match opt_cfg_idx {\n                     Some(indices) => {\n                         for &cfg_idx in indices {\n                             let (start, end) = self.compute_id_range(cfg_idx);\n                             let kills = &self.scope_kills[start.. end];\n                             if bitwise(&mut orig_kills, kills, &Union) {\n-                                debug!(\"scope exits: scope id={} \\\n+                                debug!(\"scope exits: scope id={:?} \\\n                                         (node={:?} of {:?}) added killset: {}\",\n-                                       node_id, cfg_idx, indices,\n+                                       id, cfg_idx, indices,\n                                        bits_to_string(kills));\n                                 changed = true;\n                             }\n                         }\n                     }\n                     None => {\n                         debug!(\"{} add_kills_from_flow_exits flow_exit={:?} \\\n-                                no cfg_idx for exiting_scope={}\",\n-                               self.analysis_name, flow_exit, node_id);\n+                                no cfg_idx for exiting_scope={:?}\",\n+                               self.analysis_name, flow_exit, id);\n                     }\n                 }\n             }\n@@ -559,7 +561,7 @@ impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n         // Iterate over nodes in reverse postorder\n         for &node_index in nodes_po.iter().rev() {\n             let node = cfg.graph.node(node_index);\n-            debug!(\"DataFlowContext::walk_cfg idx={:?} id={} begin in_out={}\",\n+            debug!(\"DataFlowContext::walk_cfg idx={:?} id={:?} begin in_out={}\",\n                    node_index, node.data.id(), bits_to_string(in_out));\n \n             let (start, end) = self.dfcx.compute_id_range(node_index);"}, {"sha": "1589ba60275904dc5ea7d0e398cf0b43e4c4983a", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -23,7 +23,7 @@ use hir::def::Def;\n use hir::def_id::{DefId};\n use infer::InferCtxt;\n use middle::mem_categorization as mc;\n-use middle::region::RegionMaps;\n+use middle::region::{CodeExtent, RegionMaps};\n use ty::{self, TyCtxt, adjustment};\n \n use hir::{self, PatKind};\n@@ -298,7 +298,8 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         for arg in &body.arguments {\n             let arg_ty = return_if_err!(self.mc.node_ty(arg.pat.hir_id));\n \n-            let fn_body_scope_r = self.tcx().node_scope_region(body.value.id);\n+            let fn_body_scope_r =\n+                self.tcx().mk_region(ty::ReScope(CodeExtent::Misc(body.value.hir_id.local_id)));\n             let arg_cmt = self.mc.cat_rvalue(\n                 arg.id,\n                 arg.pat.span,\n@@ -542,16 +543,17 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n             ty::TyError => { }\n             _ => {\n                 let def_id = self.mc.tables.type_dependent_defs()[call.hir_id].def_id();\n+                let call_scope = CodeExtent::Misc(call.hir_id.local_id);\n                 match OverloadedCallType::from_method_id(self.tcx(), def_id) {\n                     FnMutOverloadedCall => {\n-                        let call_scope_r = self.tcx().node_scope_region(call.id);\n+                        let call_scope_r = self.tcx().mk_region(ty::ReScope(call_scope));\n                         self.borrow_expr(callee,\n                                          call_scope_r,\n                                          ty::MutBorrow,\n                                          ClosureInvocation);\n                     }\n                     FnOverloadedCall => {\n-                        let call_scope_r = self.tcx().node_scope_region(call.id);\n+                        let call_scope_r = self.tcx().mk_region(ty::ReScope(call_scope));\n                         self.borrow_expr(callee,\n                                          call_scope_r,\n                                          ty::ImmBorrow,\n@@ -749,7 +751,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 // Converting from a &T to *T (or &mut T to *mut T) is\n                 // treated as borrowing it for the enclosing temporary\n                 // scope.\n-                let r = self.tcx().node_scope_region(expr.id);\n+                let r = self.tcx().mk_region(ty::ReScope(CodeExtent::Misc(expr.hir_id.local_id)));\n \n                 self.delegate.borrow(expr.id,\n                                      expr.span,"}, {"sha": "fdab71ee004419b8836ef3d44e995a302a2f2cd1", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -861,8 +861,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n     /// Returns the lifetime of a temporary created by expr with id `id`.\n     /// This could be `'static` if `id` is part of a constant expression.\n-    pub fn temporary_scope(&self, id: ast::NodeId) -> ty::Region<'tcx>\n-    {\n+    pub fn temporary_scope(&self, id: hir::ItemLocalId) -> ty::Region<'tcx> {\n         let scope = self.region_maps.temporary_scope(id);\n         self.tcx.mk_region(match scope {\n             Some(scope) => ty::ReScope(scope),\n@@ -890,7 +889,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         let re = if promotable {\n             self.tcx.types.re_static\n         } else {\n-            self.temporary_scope(id)\n+            self.temporary_scope(self.tcx.hir.node_to_hir_id(id).local_id)\n         };\n         let ret = self.cat_rvalue(id, span, re, expr_ty);\n         debug!(\"cat_rvalue_node ret {:?}\", ret);"}, {"sha": "f58d1a0b41fec859e249e3f0257c0e218f3b61bf", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 159, "deletions": 215, "changes": 374, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -16,24 +16,22 @@\n //! Most of the documentation on regions can be found in\n //! `middle/infer/region_inference/README.md`\n \n-use hir::map as hir_map;\n-use util::nodemap::{FxHashMap, NodeMap, NodeSet};\n+use util::nodemap::{FxHashMap, FxHashSet};\n use ty;\n \n+use std::collections::hash_map::Entry;\n use std::mem;\n use std::rc::Rc;\n use syntax::codemap;\n use syntax::ast;\n-use syntax::ast::NodeId;\n-use syntax_pos::Span;\n+use syntax_pos::{Span, DUMMY_SP};\n use ty::TyCtxt;\n use ty::maps::Providers;\n \n use hir;\n use hir::def_id::DefId;\n use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use hir::{Block, Arm, Pat, PatKind, Stmt, Expr, Local};\n-use hir::map::Node;\n use mir::transform::MirSource;\n \n /// CodeExtent represents a statically-describable extent that can be\n@@ -99,18 +97,18 @@ use mir::transform::MirSource;\n /// generated via deriving here.\n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Debug, Copy, RustcEncodable, RustcDecodable)]\n pub enum CodeExtent {\n-    Misc(ast::NodeId),\n+    Misc(hir::ItemLocalId),\n \n     // extent of the call-site for a function or closure (outlives\n     // the parameters as well as the body).\n-    CallSiteScope(hir::BodyId),\n+    CallSiteScope(hir::ItemLocalId),\n \n     // extent of parameters passed to a function or closure (they\n     // outlive its body)\n-    ParameterScope(hir::BodyId),\n+    ParameterScope(hir::ItemLocalId),\n \n     // extent of destructors for temporaries of node-id\n-    DestructionScope(ast::NodeId),\n+    DestructionScope(hir::ItemLocalId),\n \n     // extent of code following a `let id = expr;` binding in a block\n     Remainder(BlockRemainder)\n@@ -136,66 +134,77 @@ pub enum CodeExtent {\n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, RustcEncodable,\n          RustcDecodable, Debug, Copy)]\n pub struct BlockRemainder {\n-    pub block: ast::NodeId,\n+    pub block: hir::ItemLocalId,\n     pub first_statement_index: u32,\n }\n \n impl CodeExtent {\n-    /// Returns a node id associated with this scope.\n+    /// Returns a item-local id associated with this scope.\n     ///\n     /// NB: likely to be replaced as API is refined; e.g. pnkfelix\n     /// anticipates `fn entry_node_id` and `fn each_exit_node_id`.\n-    pub fn node_id(&self) -> ast::NodeId {\n+    pub fn item_local_id(&self) -> hir::ItemLocalId {\n         match *self {\n-            CodeExtent::Misc(node_id) => node_id,\n+            CodeExtent::Misc(id) => id,\n \n             // These cases all return rough approximations to the\n             // precise extent denoted by `self`.\n             CodeExtent::Remainder(br) => br.block,\n-            CodeExtent::DestructionScope(node_id) => node_id,\n-            CodeExtent::CallSiteScope(body_id) |\n-            CodeExtent::ParameterScope(body_id) => body_id.node_id,\n+            CodeExtent::DestructionScope(id) |\n+            CodeExtent::CallSiteScope(id) |\n+            CodeExtent::ParameterScope(id) => id,\n+        }\n+    }\n+\n+    pub fn node_id(&self, tcx: TyCtxt, region_maps: &RegionMaps) -> ast::NodeId {\n+        match region_maps.root_body {\n+            Some(hir_id) => {\n+                tcx.hir.hir_to_node_id(hir::HirId {\n+                    owner: hir_id.owner,\n+                    local_id: self.item_local_id()\n+                })\n+            }\n+            None => ast::DUMMY_NODE_ID\n         }\n     }\n \n     /// Returns the span of this CodeExtent.  Note that in general the\n     /// returned span may not correspond to the span of any node id in\n     /// the AST.\n-    pub fn span(&self, hir_map: &hir_map::Map) -> Option<Span> {\n-        match hir_map.find(self.node_id()) {\n-            Some(hir_map::NodeBlock(ref blk)) => {\n-                match *self {\n-                    CodeExtent::CallSiteScope(_) |\n-                    CodeExtent::ParameterScope(_) |\n-                    CodeExtent::Misc(_) |\n-                    CodeExtent::DestructionScope(_) => Some(blk.span),\n-\n-                    CodeExtent::Remainder(r) => {\n-                        assert_eq!(r.block, blk.id);\n-                        // Want span for extent starting after the\n-                        // indexed statement and ending at end of\n-                        // `blk`; reuse span of `blk` and shift `lo`\n-                        // forward to end of indexed statement.\n-                        //\n-                        // (This is the special case aluded to in the\n-                        // doc-comment for this method)\n-                        let stmt_span = blk.stmts[r.first_statement_index as usize].span;\n-                        Some(Span::new(stmt_span.hi(), blk.span.hi(), stmt_span.ctxt()))\n-                    }\n+    pub fn span(&self, tcx: TyCtxt, region_maps: &RegionMaps) -> Span {\n+        let node_id = self.node_id(tcx, region_maps);\n+        if node_id == ast::DUMMY_NODE_ID {\n+            return DUMMY_SP;\n+        }\n+        let span = tcx.hir.span(node_id);\n+        if let CodeExtent::Remainder(r) = *self {\n+            if let hir::map::NodeBlock(ref blk) = tcx.hir.get(node_id) {\n+                // Want span for extent starting after the\n+                // indexed statement and ending at end of\n+                // `blk`; reuse span of `blk` and shift `lo`\n+                // forward to end of indexed statement.\n+                //\n+                // (This is the special case aluded to in the\n+                // doc-comment for this method)\n+\n+                let stmt_span = blk.stmts[r.first_statement_index as usize].span;\n+\n+                // To avoid issues with macro-generated spans, the span\n+                // of the statement must be nested in that of the block.\n+                if span.lo() <= stmt_span.lo() && stmt_span.lo() <= span.hi() {\n+                    return Span::new(stmt_span.lo(), span.hi(), span.ctxt());\n                 }\n             }\n-            Some(hir_map::NodeExpr(ref expr)) => Some(expr.span),\n-            Some(hir_map::NodeStmt(ref stmt)) => Some(stmt.span),\n-            Some(hir_map::NodeItem(ref item)) => Some(item.span),\n-            Some(_) | None => None,\n          }\n+         span\n     }\n }\n \n /// The region maps encode information about region relationships.\n+#[derive(Default)]\n pub struct RegionMaps {\n     /// If not empty, this body is the root of this region hierarchy.\n-    root_body: Option<hir::BodyId>,\n+    root_body: Option<hir::HirId>,\n \n     /// The parent of the root body owner, if the latter is an\n     /// an associated const or method, as impls/traits can also\n@@ -212,10 +221,10 @@ pub struct RegionMaps {\n \n     /// `var_map` maps from a variable or binding id to the block in\n     /// which that variable is declared.\n-    var_map: NodeMap<CodeExtent>,\n+    var_map: FxHashMap<hir::ItemLocalId, CodeExtent>,\n \n     /// maps from a node-id to the associated destruction scope (if any)\n-    destruction_scopes: NodeMap<CodeExtent>,\n+    destruction_scopes: FxHashMap<hir::ItemLocalId, CodeExtent>,\n \n     /// `rvalue_scopes` includes entries for those expressions whose cleanup scope is\n     /// larger than the default. The map goes from the expression id\n@@ -225,7 +234,7 @@ pub struct RegionMaps {\n     /// block (see `terminating_scopes`).\n     /// In constants, None is used to indicate that certain expressions\n     /// escape into 'static and should have no local cleanup scope.\n-    rvalue_scopes: NodeMap<Option<CodeExtent>>,\n+    rvalue_scopes: FxHashMap<hir::ItemLocalId, Option<CodeExtent>>,\n \n     /// Encodes the hierarchy of fn bodies. Every fn body (including\n     /// closures) forms its own distinct region hierarchy, rooted in\n@@ -237,7 +246,11 @@ pub struct RegionMaps {\n     /// closure defined by that fn. See the \"Modeling closures\"\n     /// section of the README in infer::region_inference for\n     /// more details.\n-    fn_tree: NodeMap<ast::NodeId>,\n+    closure_tree: FxHashMap<hir::ItemLocalId, hir::ItemLocalId>,\n+\n+    /// If there are any `yield` nested within a scope, this map\n+    /// stores the `Span` of the first one.\n+    yield_in_scope: FxHashMap<CodeExtent, Span>,\n }\n \n #[derive(Debug, Copy, Clone)]\n@@ -248,7 +261,7 @@ pub struct Context {\n     /// arranged into a tree. See the \"Modeling closures\" section of\n     /// the README in infer::region_inference for more\n     /// details.\n-    root_id: Option<ast::NodeId>,\n+    root_id: Option<hir::ItemLocalId>,\n \n     /// the scope that contains any new variables declared\n     var_parent: Option<CodeExtent>,\n@@ -285,23 +298,11 @@ struct RegionResolutionVisitor<'a, 'tcx: 'a> {\n     /// arbitrary amounts of stack space. Terminating scopes end\n     /// up being contained in a DestructionScope that contains the\n     /// destructor's execution.\n-    terminating_scopes: NodeSet,\n+    terminating_scopes: FxHashSet<hir::ItemLocalId>,\n }\n \n \n impl<'tcx> RegionMaps {\n-    pub fn new() -> Self {\n-        RegionMaps {\n-            root_body: None,\n-            root_parent: None,\n-            scope_map: FxHashMap(),\n-            destruction_scopes: FxHashMap(),\n-            var_map: NodeMap(),\n-            rvalue_scopes: NodeMap(),\n-            fn_tree: NodeMap(),\n-        }\n-    }\n-\n     pub fn record_code_extent(&mut self,\n                               child: CodeExtent,\n                               parent: Option<CodeExtent>) {\n@@ -324,46 +325,51 @@ impl<'tcx> RegionMaps {\n         }\n     }\n \n-    pub fn each_var_scope<E>(&self, mut e:E) where E: FnMut(&ast::NodeId, CodeExtent) {\n+    pub fn each_var_scope<E>(&self, mut e:E) where E: FnMut(&hir::ItemLocalId, CodeExtent) {\n         for (child, &parent) in self.var_map.iter() {\n             e(child, parent)\n         }\n     }\n \n-    pub fn opt_destruction_extent(&self, n: ast::NodeId) -> Option<CodeExtent> {\n+    pub fn opt_destruction_extent(&self, n: hir::ItemLocalId) -> Option<CodeExtent> {\n         self.destruction_scopes.get(&n).cloned()\n     }\n \n-    /// Records that `sub_fn` is defined within `sup_fn`. These ids\n+    /// Records that `sub_closure` is defined within `sup_closure`. These ids\n     /// should be the id of the block that is the fn body, which is\n     /// also the root of the region hierarchy for that fn.\n-    fn record_fn_parent(&mut self, sub_fn: ast::NodeId, sup_fn: ast::NodeId) {\n-        debug!(\"record_fn_parent(sub_fn={:?}, sup_fn={:?})\", sub_fn, sup_fn);\n-        assert!(sub_fn != sup_fn);\n-        let previous = self.fn_tree.insert(sub_fn, sup_fn);\n+    fn record_closure_parent(&mut self,\n+                             sub_closure: hir::ItemLocalId,\n+                             sup_closure: hir::ItemLocalId) {\n+        debug!(\"record_closure_parent(sub_closure={:?}, sup_closure={:?})\",\n+               sub_closure, sup_closure);\n+        assert!(sub_closure != sup_closure);\n+        let previous = self.closure_tree.insert(sub_closure, sup_closure);\n         assert!(previous.is_none());\n     }\n \n-    fn fn_is_enclosed_by(&self, mut sub_fn: ast::NodeId, sup_fn: ast::NodeId) -> bool {\n+    fn closure_is_enclosed_by(&self,\n+                              mut sub_closure: hir::ItemLocalId,\n+                              sup_closure: hir::ItemLocalId) -> bool {\n         loop {\n-            if sub_fn == sup_fn { return true; }\n-            match self.fn_tree.get(&sub_fn) {\n-                Some(&s) => { sub_fn = s; }\n+            if sub_closure == sup_closure { return true; }\n+            match self.closure_tree.get(&sub_closure) {\n+                Some(&s) => { sub_closure = s; }\n                 None => { return false; }\n             }\n         }\n     }\n \n-    fn record_var_scope(&mut self, var: ast::NodeId, lifetime: CodeExtent) {\n+    fn record_var_scope(&mut self, var: hir::ItemLocalId, lifetime: CodeExtent) {\n         debug!(\"record_var_scope(sub={:?}, sup={:?})\", var, lifetime);\n-        assert!(var != lifetime.node_id());\n+        assert!(var != lifetime.item_local_id());\n         self.var_map.insert(var, lifetime);\n     }\n \n-    fn record_rvalue_scope(&mut self, var: ast::NodeId, lifetime: Option<CodeExtent>) {\n+    fn record_rvalue_scope(&mut self, var: hir::ItemLocalId, lifetime: Option<CodeExtent>) {\n         debug!(\"record_rvalue_scope(sub={:?}, sup={:?})\", var, lifetime);\n         if let Some(lifetime) = lifetime {\n-            assert!(var != lifetime.node_id());\n+            assert!(var != lifetime.item_local_id());\n         }\n         self.rvalue_scopes.insert(var, lifetime);\n     }\n@@ -380,14 +386,14 @@ impl<'tcx> RegionMaps {\n     }\n \n     /// Returns the lifetime of the local variable `var_id`\n-    pub fn var_scope(&self, var_id: ast::NodeId) -> CodeExtent {\n+    pub fn var_scope(&self, var_id: hir::ItemLocalId) -> CodeExtent {\n         match self.var_map.get(&var_id) {\n             Some(&r) => r,\n             None => { bug!(\"no enclosing scope for id {:?}\", var_id); }\n         }\n     }\n \n-    pub fn temporary_scope(&self, expr_id: ast::NodeId) -> Option<CodeExtent> {\n+    pub fn temporary_scope(&self, expr_id: hir::ItemLocalId) -> Option<CodeExtent> {\n         //! Returns the scope when temp created by expr_id will be cleaned up\n \n         // check for a designated rvalue scope\n@@ -417,7 +423,7 @@ impl<'tcx> RegionMaps {\n         return None;\n     }\n \n-    pub fn var_region(&self, id: ast::NodeId) -> ty::RegionKind {\n+    pub fn var_region(&self, id: hir::ItemLocalId) -> ty::RegionKind {\n         //! Returns the lifetime of the variable `id`.\n \n         let scope = ty::ReScope(self.var_scope(id));\n@@ -497,10 +503,10 @@ impl<'tcx> RegionMaps {\n             return match (a_root_scope, b_root_scope) {\n                 (CodeExtent::DestructionScope(a_root_id),\n                  CodeExtent::DestructionScope(b_root_id)) => {\n-                    if self.fn_is_enclosed_by(a_root_id, b_root_id) {\n+                    if self.closure_is_enclosed_by(a_root_id, b_root_id) {\n                         // `a` is enclosed by `b`, hence `b` is the ancestor of everything in `a`\n                         scope_b\n-                    } else if self.fn_is_enclosed_by(b_root_id, a_root_id) {\n+                    } else if self.closure_is_enclosed_by(b_root_id, a_root_id) {\n                         // `b` is enclosed by `a`, hence `a` is the ancestor of everything in `b`\n                         scope_a\n                     } else {\n@@ -565,20 +571,23 @@ impl<'tcx> RegionMaps {\n         let param_owner = tcx.parent_def_id(br.def_id).unwrap();\n \n         let param_owner_id = tcx.hir.as_local_node_id(param_owner).unwrap();\n-        let body_id = tcx.hir.maybe_body_owned_by(param_owner_id).unwrap_or_else(|| {\n+        let scope = tcx.hir.maybe_body_owned_by(param_owner_id).map(|body_id| {\n+            tcx.hir.body(body_id).value.hir_id.local_id\n+        }).unwrap_or_else(|| {\n             // The lifetime was defined on node that doesn't own a body,\n             // which in practice can only mean a trait or an impl, that\n             // is the parent of a method, and that is enforced below.\n             assert_eq!(Some(param_owner_id), self.root_parent,\n-                       \"free_extent: {:?} not recognized by the region maps for {:?}\",\n+                       \"free_extent: {:?} not recognized by the region maps for {:?} / {:?}\",\n                        param_owner,\n-                       self.root_body.map(|body| tcx.hir.body_owner_def_id(body)));\n+                       self.root_parent.map(|id| tcx.hir.local_def_id(id)),\n+                       self.root_body.map(|hir_id| DefId::local(hir_id.owner)));\n \n             // The trait/impl lifetime is in scope for the method's body.\n-            self.root_body.unwrap()\n+            self.root_body.unwrap().local_id\n         });\n \n-        CodeExtent::CallSiteScope(body_id)\n+        CodeExtent::CallSiteScope(scope)\n     }\n \n     /// Assuming that the provided region was defined within this `RegionMaps`,\n@@ -597,13 +606,20 @@ impl<'tcx> RegionMaps {\n         assert_eq!(param_owner, fr.scope);\n \n         let param_owner_id = tcx.hir.as_local_node_id(param_owner).unwrap();\n-        CodeExtent::CallSiteScope(tcx.hir.body_owned_by(param_owner_id))\n+        let body_id = tcx.hir.body_owned_by(param_owner_id);\n+        CodeExtent::CallSiteScope(tcx.hir.body(body_id).value.hir_id.local_id)\n+    }\n+\n+    /// Checks whether the given code extent contains a `yield`. If so,\n+    /// returns `Some(span)` with the span of a yield we found.\n+    pub fn yield_in_scope(&self, scope: CodeExtent) -> Option<Span> {\n+        self.yield_in_scope.get(&scope).cloned()\n     }\n }\n \n /// Records the lifetime of a local variable as `cx.var_parent`\n fn record_var_lifetime(visitor: &mut RegionResolutionVisitor,\n-                       var_id: ast::NodeId,\n+                       var_id: hir::ItemLocalId,\n                        _sp: Span) {\n     match visitor.cx.var_parent {\n         None => {\n@@ -646,7 +662,7 @@ fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, blk:\n     // `other_argument()` has run and also the call to `quux(..)`\n     // itself has returned.\n \n-    visitor.enter_node_extent_with_dtor(blk.id);\n+    visitor.enter_node_extent_with_dtor(blk.hir_id.local_id);\n     visitor.cx.var_parent = visitor.cx.parent;\n \n     {\n@@ -665,7 +681,7 @@ fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, blk:\n                 // block itself as a parent.\n                 visitor.enter_code_extent(\n                     CodeExtent::Remainder(BlockRemainder {\n-                        block: blk.id,\n+                        block: blk.hir_id.local_id,\n                         first_statement_index: i as u32\n                     })\n                 );\n@@ -680,28 +696,28 @@ fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, blk:\n }\n \n fn resolve_arm<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, arm: &'tcx hir::Arm) {\n-    visitor.terminating_scopes.insert(arm.body.id);\n+    visitor.terminating_scopes.insert(arm.body.hir_id.local_id);\n \n     if let Some(ref expr) = arm.guard {\n-        visitor.terminating_scopes.insert(expr.id);\n+        visitor.terminating_scopes.insert(expr.hir_id.local_id);\n     }\n \n     intravisit::walk_arm(visitor, arm);\n }\n \n fn resolve_pat<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, pat: &'tcx hir::Pat) {\n-    visitor.record_code_extent(CodeExtent::Misc(pat.id));\n+    visitor.record_code_extent(CodeExtent::Misc(pat.hir_id.local_id));\n \n     // If this is a binding then record the lifetime of that binding.\n     if let PatKind::Binding(..) = pat.node {\n-        record_var_lifetime(visitor, pat.id, pat.span);\n+        record_var_lifetime(visitor, pat.hir_id.local_id, pat.span);\n     }\n \n     intravisit::walk_pat(visitor, pat);\n }\n \n fn resolve_stmt<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, stmt: &'tcx hir::Stmt) {\n-    let stmt_id = stmt.node.id();\n+    let stmt_id = visitor.tcx.hir.node_to_hir_id(stmt.node.id()).local_id;\n     debug!(\"resolve_stmt(stmt.id={:?})\", stmt_id);\n \n     // Every statement will clean up the temporaries created during\n@@ -723,11 +739,11 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n     debug!(\"resolve_expr(expr.id={:?})\", expr.id);\n \n     let prev_cx = visitor.cx;\n-    visitor.enter_node_extent_with_dtor(expr.id);\n+    visitor.enter_node_extent_with_dtor(expr.hir_id.local_id);\n \n     {\n         let terminating_scopes = &mut visitor.terminating_scopes;\n-        let mut terminating = |id: ast::NodeId| {\n+        let mut terminating = |id: hir::ItemLocalId| {\n             terminating_scopes.insert(id);\n         };\n         match expr.node {\n@@ -739,27 +755,27 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n             hir::ExprBinary(codemap::Spanned { node: hir::BiOr, .. }, _, ref r) => {\n                 // For shortcircuiting operators, mark the RHS as a terminating\n                 // scope since it only executes conditionally.\n-                terminating(r.id);\n+                terminating(r.hir_id.local_id);\n             }\n \n             hir::ExprIf(ref expr, ref then, Some(ref otherwise)) => {\n-                terminating(expr.id);\n-                terminating(then.id);\n-                terminating(otherwise.id);\n+                terminating(expr.hir_id.local_id);\n+                terminating(then.hir_id.local_id);\n+                terminating(otherwise.hir_id.local_id);\n             }\n \n             hir::ExprIf(ref expr, ref then, None) => {\n-                terminating(expr.id);\n-                terminating(then.id);\n+                terminating(expr.hir_id.local_id);\n+                terminating(then.hir_id.local_id);\n             }\n \n             hir::ExprLoop(ref body, _, _) => {\n-                terminating(body.id);\n+                terminating(body.hir_id.local_id);\n             }\n \n             hir::ExprWhile(ref expr, ref body, _) => {\n-                terminating(expr.id);\n-                terminating(body.id);\n+                terminating(expr.hir_id.local_id);\n+                terminating(body.hir_id.local_id);\n             }\n \n             hir::ExprMatch(..) => {\n@@ -788,6 +804,29 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n                 // record_superlifetime(new_cx, expr.callee_id);\n             }\n \n+            hir::ExprYield(..) => {\n+                // Mark this expr's scope and all parent scopes as containing `yield`.\n+                let mut scope = CodeExtent::Misc(expr.hir_id.local_id);\n+                loop {\n+                    match visitor.region_maps.yield_in_scope.entry(scope) {\n+                        // Another `yield` has already been found.\n+                        Entry::Occupied(_) => break,\n+\n+                        Entry::Vacant(entry) => {\n+                            entry.insert(expr.span);\n+                        }\n+                    }\n+\n+                    // Keep traversing up while we can.\n+                    match visitor.region_maps.scope_map.get(&scope) {\n+                        // Don't cross from closure bodies to their parent.\n+                        Some(&CodeExtent::CallSiteScope(_)) => break,\n+                        Some(&superscope) => scope = superscope,\n+                        None => break\n+                    }\n+                }\n+            }\n+\n             _ => {}\n         }\n     }\n@@ -1018,7 +1057,7 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n             // because in trans if we must compile e.g. `*rvalue()`\n             // into a temporary, we request the temporary scope of the\n             // outer expression.\n-            visitor.region_maps.record_rvalue_scope(expr.id, blk_scope);\n+            visitor.region_maps.record_rvalue_scope(expr.hir_id.local_id, blk_scope);\n \n             match expr.node {\n                 hir::ExprAddrOf(_, ref subexpr) |\n@@ -1050,7 +1089,7 @@ impl<'a, 'tcx> RegionResolutionVisitor<'a, 'tcx> {\n         self.cx.parent = Some(child_scope);\n     }\n \n-    fn enter_node_extent_with_dtor(&mut self, id: ast::NodeId) {\n+    fn enter_node_extent_with_dtor(&mut self, id: hir::ItemLocalId) {\n         // If node was previously marked as a terminating scope during the\n         // recursive visit of its parent node in the AST, then we need to\n         // account for the destruction scope representing the extent of\n@@ -1082,16 +1121,16 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'a, 'tcx> {\n                self.cx.parent);\n \n         let outer_cx = self.cx;\n-        let outer_ts = mem::replace(&mut self.terminating_scopes, NodeSet());\n-        self.terminating_scopes.insert(body_id.node_id);\n+        let outer_ts = mem::replace(&mut self.terminating_scopes, FxHashSet());\n+        self.terminating_scopes.insert(body.value.hir_id.local_id);\n \n         if let Some(root_id) = self.cx.root_id {\n-            self.region_maps.record_fn_parent(body_id.node_id, root_id);\n+            self.region_maps.record_closure_parent(body.value.hir_id.local_id, root_id);\n         }\n-        self.cx.root_id = Some(body_id.node_id);\n+        self.cx.root_id = Some(body.value.hir_id.local_id);\n \n-        self.enter_code_extent(CodeExtent::CallSiteScope(body_id));\n-        self.enter_code_extent(CodeExtent::ParameterScope(body_id));\n+        self.enter_code_extent(CodeExtent::CallSiteScope(body.value.hir_id.local_id));\n+        self.enter_code_extent(CodeExtent::ParameterScope(body.value.hir_id.local_id));\n \n         // The arguments and `self` are parented to the fn.\n         self.cx.var_parent = self.cx.parent.take();\n@@ -1157,19 +1196,20 @@ fn region_maps<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n     }\n \n     let id = tcx.hir.as_local_node_id(def_id).unwrap();\n-    let maps = if let Some(body) = tcx.hir.maybe_body_owned_by(id) {\n+    let maps = if let Some(body_id) = tcx.hir.maybe_body_owned_by(id) {\n         let mut visitor = RegionResolutionVisitor {\n             tcx,\n-            region_maps: RegionMaps::new(),\n+            region_maps: RegionMaps::default(),\n             cx: Context {\n                 root_id: None,\n                 parent: None,\n                 var_parent: None,\n             },\n-            terminating_scopes: NodeSet(),\n+            terminating_scopes: FxHashSet(),\n         };\n \n-        visitor.region_maps.root_body = Some(body);\n+        let body = tcx.hir.body(body_id);\n+        visitor.region_maps.root_body = Some(body.value.hir_id);\n \n         // If the item is an associated const or a method,\n         // record its impl/trait parent, as it can also have\n@@ -1182,112 +1222,16 @@ fn region_maps<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n             _ => {}\n         }\n \n-        visitor.visit_body(tcx.hir.body(body));\n+        visitor.visit_body(body);\n \n         visitor.region_maps\n     } else {\n-        RegionMaps::new()\n+        RegionMaps::default()\n     };\n \n     Rc::new(maps)\n }\n \n-struct YieldFinder<'a> {\n-    cache: &'a mut FxHashMap<NodeId, Option<Span>>,\n-    result: Option<Span>,\n-}\n-\n-impl<'a> YieldFinder<'a> {\n-    fn lookup<F: FnOnce(&mut Self)>(&mut self, id: NodeId, f: F) {\n-        // Don't traverse further if we found a yield expression\n-        if self.result.is_some() {\n-            return;\n-        }\n-\n-        // See if there's an entry in the cache\n-        if let Some(result) = self.cache.get(&id) {\n-            self.result = *result;\n-            return;\n-        }\n-\n-        // Otherwise calculate the result and insert it into the cache\n-        f(self);\n-        self.cache.insert(id, self.result);\n-    }\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for YieldFinder<'a> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::None\n-    }\n-\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n-        if let hir::ExprYield(..) = expr.node {\n-            self.result = Some(expr.span);\n-            return;\n-        }\n-\n-        self.lookup(expr.id, |this| {\n-            intravisit::walk_expr(this, expr);\n-        });\n-    }\n-\n-    fn visit_block(&mut self, block: &'tcx hir::Block) {\n-        self.lookup(block.id, |this| {\n-            intravisit::walk_block(this, block);\n-        });\n-    }\n-}\n-\n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    /// Checks whether the given code extent contains a `yield`. If so,\n-    /// returns `Some(span)` with the span of a yield we found.\n-    pub fn yield_in_extent(self,\n-                          extent: CodeExtent,\n-                          cache: &mut FxHashMap<NodeId, Option<Span>>) -> Option<Span> {\n-        let mut finder = YieldFinder {\n-            cache,\n-            result: None,\n-        };\n-\n-        match extent {\n-            CodeExtent::DestructionScope(node_id) |\n-            CodeExtent::Misc(node_id) => {\n-                match self.hir.get(node_id) {\n-                    Node::NodeItem(_) |\n-                    Node::NodeTraitItem(_) |\n-                    Node::NodeImplItem(_) => {\n-                        let body = self.hir.body(self.hir.body_owned_by(node_id));\n-                        finder.visit_body(body);\n-                    }\n-                    Node::NodeExpr(expr) => finder.visit_expr(expr),\n-                    Node::NodeStmt(stmt) => finder.visit_stmt(stmt),\n-                    Node::NodeBlock(block) => finder.visit_block(block),\n-                    _ => bug!(),\n-                }\n-            }\n-\n-            CodeExtent::CallSiteScope(body_id) |\n-            CodeExtent::ParameterScope(body_id) => {\n-                finder.visit_body(self.hir.body(body_id))\n-            }\n-\n-            CodeExtent::Remainder(r) => {\n-                if let Node::NodeBlock(block) = self.hir.get(r.block) {\n-                    for stmt in &block.stmts[(r.first_statement_index as usize + 1)..] {\n-                        finder.visit_stmt(stmt);\n-                    }\n-                    block.expr.as_ref().map(|e| finder.visit_expr(e));\n-                } else {\n-                    bug!()\n-                }\n-            }\n-        }\n-\n-        finder.result\n-    }\n-}\n-\n pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n         region_maps,"}, {"sha": "35ca8eb14228379563fed15283de2c720f9d6347", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -532,7 +532,7 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         debug!(\"normalize_param_env_or_error: normalized predicates={:?}\",\n             predicates);\n \n-        let region_maps = RegionMaps::new();\n+        let region_maps = RegionMaps::default();\n         let free_regions = FreeRegionMap::new();\n         infcx.resolve_regions_and_report_errors(region_context, &region_maps, &free_regions);\n         let predicates = match infcx.fully_resolve(&predicates) {"}, {"sha": "49d7f40000f079b7847c5846c3b49f3b9b5521bc", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 2, "deletions": 35, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -36,11 +36,11 @@ pub enum TypeError<'tcx> {\n     TupleSize(ExpectedFound<usize>),\n     FixedArraySize(ExpectedFound<usize>),\n     ArgCount,\n+\n     RegionsDoesNotOutlive(Region<'tcx>, Region<'tcx>),\n-    RegionsNotSame(Region<'tcx>, Region<'tcx>),\n-    RegionsNoOverlap(Region<'tcx>, Region<'tcx>),\n     RegionsInsufficientlyPolymorphic(BoundRegion, Region<'tcx>),\n     RegionsOverlyPolymorphic(BoundRegion, Region<'tcx>),\n+\n     Sorts(ExpectedFound<Ty<'tcx>>),\n     IntMismatch(ExpectedFound<ty::IntVarValue>),\n     FloatMismatch(ExpectedFound<ast::FloatTy>),\n@@ -110,12 +110,6 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n             RegionsDoesNotOutlive(..) => {\n                 write!(f, \"lifetime mismatch\")\n             }\n-            RegionsNotSame(..) => {\n-                write!(f, \"lifetimes are not the same\")\n-            }\n-            RegionsNoOverlap(..) => {\n-                write!(f, \"lifetimes do not intersect\")\n-            }\n             RegionsInsufficientlyPolymorphic(br, _) => {\n                 write!(f,\n                        \"expected bound lifetime parameter{}{}, found concrete lifetime\",\n@@ -243,33 +237,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         use self::TypeError::*;\n \n         match err.clone() {\n-            RegionsDoesNotOutlive(subregion, superregion) => {\n-                self.note_and_explain_region(db, \"\", subregion, \"...\");\n-                self.note_and_explain_region(db, \"...does not necessarily outlive \",\n-                                           superregion, \"\");\n-            }\n-            RegionsNotSame(region1, region2) => {\n-                self.note_and_explain_region(db, \"\", region1, \"...\");\n-                self.note_and_explain_region(db, \"...is not the same lifetime as \",\n-                                           region2, \"\");\n-            }\n-            RegionsNoOverlap(region1, region2) => {\n-                self.note_and_explain_region(db, \"\", region1, \"...\");\n-                self.note_and_explain_region(db, \"...does not overlap \",\n-                                           region2, \"\");\n-            }\n-            RegionsInsufficientlyPolymorphic(_, conc_region) => {\n-                self.note_and_explain_region(db, \"concrete lifetime that was found is \",\n-                                           conc_region, \"\");\n-            }\n-            RegionsOverlyPolymorphic(_, &ty::ReVar(_)) => {\n-                // don't bother to print out the message below for\n-                // inference variables, it's not very illuminating.\n-            }\n-            RegionsOverlyPolymorphic(_, conc_region) => {\n-                self.note_and_explain_region(db, \"expected concrete lifetime is \",\n-                                           conc_region, \"\");\n-            }\n             Sorts(values) => {\n                 let expected_str = values.expected.sort_string(self);\n                 let found_str = values.found.sort_string(self);"}, {"sha": "2eb77ef3ffc1849e8fd58cfeab9cc9b5f6bec4a6", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 81, "deletions": 80, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -593,7 +593,7 @@ macro_rules! profq_key {\n macro_rules! define_maps {\n     (<$tcx:tt>\n      $($(#[$attr:meta])*\n-       [$($modifiers:tt)*] $name:ident: $node:ident($K:ty) -> $V:ty,)*) => {\n+       [$($modifiers:tt)*] fn $name:ident: $node:ident($K:ty) -> $V:ty,)*) => {\n         define_map_struct! {\n             tcx: $tcx,\n             input: ($(([$($modifiers)*] [$($attr)*] [$name]))*)\n@@ -954,191 +954,192 @@ macro_rules! define_provider_struct {\n // the driver creates (using several `rustc_*` crates).\n define_maps! { <'tcx>\n     /// Records the type of every item.\n-    [] type_of: TypeOfItem(DefId) -> Ty<'tcx>,\n+    [] fn type_of: TypeOfItem(DefId) -> Ty<'tcx>,\n \n     /// Maps from the def-id of an item (trait/struct/enum/fn) to its\n     /// associated generics and predicates.\n-    [] generics_of: GenericsOfItem(DefId) -> &'tcx ty::Generics,\n-    [] predicates_of: PredicatesOfItem(DefId) -> ty::GenericPredicates<'tcx>,\n+    [] fn generics_of: GenericsOfItem(DefId) -> &'tcx ty::Generics,\n+    [] fn predicates_of: PredicatesOfItem(DefId) -> ty::GenericPredicates<'tcx>,\n \n     /// Maps from the def-id of a trait to the list of\n     /// super-predicates. This is a subset of the full list of\n     /// predicates. We store these in a separate map because we must\n     /// evaluate them even during type conversion, often before the\n     /// full predicates are available (note that supertraits have\n     /// additional acyclicity requirements).\n-    [] super_predicates_of: SuperPredicatesOfItem(DefId) -> ty::GenericPredicates<'tcx>,\n+    [] fn super_predicates_of: SuperPredicatesOfItem(DefId) -> ty::GenericPredicates<'tcx>,\n \n     /// To avoid cycles within the predicates of a single item we compute\n     /// per-type-parameter predicates for resolving `T::AssocTy`.\n-    [] type_param_predicates: type_param_predicates((DefId, DefId))\n+    [] fn type_param_predicates: type_param_predicates((DefId, DefId))\n         -> ty::GenericPredicates<'tcx>,\n \n-    [] trait_def: TraitDefOfItem(DefId) -> &'tcx ty::TraitDef,\n-    [] adt_def: AdtDefOfItem(DefId) -> &'tcx ty::AdtDef,\n-    [] adt_destructor: AdtDestructor(DefId) -> Option<ty::Destructor>,\n-    [] adt_sized_constraint: SizedConstraint(DefId) -> &'tcx [Ty<'tcx>],\n-    [] adt_dtorck_constraint: DtorckConstraint(DefId) -> ty::DtorckConstraint<'tcx>,\n+    [] fn trait_def: TraitDefOfItem(DefId) -> &'tcx ty::TraitDef,\n+    [] fn adt_def: AdtDefOfItem(DefId) -> &'tcx ty::AdtDef,\n+    [] fn adt_destructor: AdtDestructor(DefId) -> Option<ty::Destructor>,\n+    [] fn adt_sized_constraint: SizedConstraint(DefId) -> &'tcx [Ty<'tcx>],\n+    [] fn adt_dtorck_constraint: DtorckConstraint(DefId) -> ty::DtorckConstraint<'tcx>,\n \n     /// True if this is a const fn\n-    [] is_const_fn: IsConstFn(DefId) -> bool,\n+    [] fn is_const_fn: IsConstFn(DefId) -> bool,\n \n     /// True if this is a foreign item (i.e., linked via `extern { ... }`).\n-    [] is_foreign_item: IsForeignItem(DefId) -> bool,\n+    [] fn is_foreign_item: IsForeignItem(DefId) -> bool,\n \n     /// True if this is a default impl (aka impl Foo for ..)\n-    [] is_default_impl: IsDefaultImpl(DefId) -> bool,\n+    [] fn is_default_impl: IsDefaultImpl(DefId) -> bool,\n \n     /// Get a map with the variance of every item; use `item_variance`\n     /// instead.\n-    [] crate_variances: crate_variances(CrateNum) -> Rc<ty::CrateVariancesMap>,\n+    [] fn crate_variances: crate_variances(CrateNum) -> Rc<ty::CrateVariancesMap>,\n \n     /// Maps from def-id of a type or region parameter to its\n     /// (inferred) variance.\n-    [] variances_of: ItemVariances(DefId) -> Rc<Vec<ty::Variance>>,\n+    [] fn variances_of: ItemVariances(DefId) -> Rc<Vec<ty::Variance>>,\n \n     /// Maps from an impl/trait def-id to a list of the def-ids of its items\n-    [] associated_item_def_ids: AssociatedItemDefIds(DefId) -> Rc<Vec<DefId>>,\n+    [] fn associated_item_def_ids: AssociatedItemDefIds(DefId) -> Rc<Vec<DefId>>,\n \n     /// Maps from a trait item to the trait item \"descriptor\"\n-    [] associated_item: AssociatedItems(DefId) -> ty::AssociatedItem,\n+    [] fn associated_item: AssociatedItems(DefId) -> ty::AssociatedItem,\n \n-    [] impl_trait_ref: ImplTraitRef(DefId) -> Option<ty::TraitRef<'tcx>>,\n-    [] impl_polarity: ImplPolarity(DefId) -> hir::ImplPolarity,\n+    [] fn impl_trait_ref: ImplTraitRef(DefId) -> Option<ty::TraitRef<'tcx>>,\n+    [] fn impl_polarity: ImplPolarity(DefId) -> hir::ImplPolarity,\n \n     /// Maps a DefId of a type to a list of its inherent impls.\n     /// Contains implementations of methods that are inherent to a type.\n     /// Methods in these implementations don't need to be exported.\n-    [] inherent_impls: InherentImpls(DefId) -> Rc<Vec<DefId>>,\n+    [] fn inherent_impls: InherentImpls(DefId) -> Rc<Vec<DefId>>,\n \n     /// Set of all the def-ids in this crate that have MIR associated with\n     /// them. This includes all the body owners, but also things like struct\n     /// constructors.\n-    [] mir_keys: mir_keys(CrateNum) -> Rc<DefIdSet>,\n+    [] fn mir_keys: mir_keys(CrateNum) -> Rc<DefIdSet>,\n \n     /// Maps DefId's that have an associated Mir to the result\n     /// of the MIR qualify_consts pass. The actual meaning of\n     /// the value isn't known except to the pass itself.\n-    [] mir_const_qualif: MirConstQualif(DefId) -> u8,\n+    [] fn mir_const_qualif: MirConstQualif(DefId) -> u8,\n \n     /// Fetch the MIR for a given def-id up till the point where it is\n     /// ready for const evaluation.\n     ///\n     /// See the README for the `mir` module for details.\n-    [] mir_const: MirConst(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n+    [] fn mir_const: MirConst(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n \n-    [] mir_validated: MirValidated(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n+    [] fn mir_validated: MirValidated(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n \n     /// MIR after our optimization passes have run. This is MIR that is ready\n     /// for trans. This is also the only query that can fetch non-local MIR, at present.\n-    [] optimized_mir: MirOptimized(DefId) -> &'tcx mir::Mir<'tcx>,\n+    [] fn optimized_mir: MirOptimized(DefId) -> &'tcx mir::Mir<'tcx>,\n \n     /// Type of each closure. The def ID is the ID of the\n     /// expression defining the closure.\n-    [] closure_kind: ClosureKind(DefId) -> ty::ClosureKind,\n+    [] fn closure_kind: ClosureKind(DefId) -> ty::ClosureKind,\n \n     /// The signature of functions and closures.\n-    [] fn_sig: FnSignature(DefId) -> ty::PolyFnSig<'tcx>,\n+    [] fn fn_sig: FnSignature(DefId) -> ty::PolyFnSig<'tcx>,\n \n     /// Records the signature of each generator. The def ID is the ID of the\n     /// expression defining the closure.\n-    [] generator_sig: GenSignature(DefId) -> Option<ty::PolyGenSig<'tcx>>,\n+    [] fn generator_sig: GenSignature(DefId) -> Option<ty::PolyGenSig<'tcx>>,\n \n     /// Caches CoerceUnsized kinds for impls on custom types.\n-    [] coerce_unsized_info: CoerceUnsizedInfo(DefId)\n+    [] fn coerce_unsized_info: CoerceUnsizedInfo(DefId)\n         -> ty::adjustment::CoerceUnsizedInfo,\n \n-    [] typeck_item_bodies: typeck_item_bodies_dep_node(CrateNum) -> CompileResult,\n+    [] fn typeck_item_bodies: typeck_item_bodies_dep_node(CrateNum) -> CompileResult,\n \n-    [] typeck_tables_of: TypeckTables(DefId) -> &'tcx ty::TypeckTables<'tcx>,\n+    [] fn typeck_tables_of: TypeckTables(DefId) -> &'tcx ty::TypeckTables<'tcx>,\n \n-    [] has_typeck_tables: HasTypeckTables(DefId) -> bool,\n+    [] fn has_typeck_tables: HasTypeckTables(DefId) -> bool,\n \n-    [] coherent_trait: coherent_trait_dep_node((CrateNum, DefId)) -> (),\n+    [] fn coherent_trait: coherent_trait_dep_node((CrateNum, DefId)) -> (),\n \n-    [] borrowck: BorrowCheck(DefId) -> (),\n+    [] fn borrowck: BorrowCheck(DefId) -> (),\n     // FIXME: shouldn't this return a `Result<(), BorrowckErrors>` instead?\n-    [] mir_borrowck: MirBorrowCheck(DefId) -> (),\n+    [] fn mir_borrowck: MirBorrowCheck(DefId) -> (),\n \n     /// Gets a complete map from all types to their inherent impls.\n     /// Not meant to be used directly outside of coherence.\n     /// (Defined only for LOCAL_CRATE)\n-    [] crate_inherent_impls: crate_inherent_impls_dep_node(CrateNum) -> CrateInherentImpls,\n+    [] fn crate_inherent_impls: crate_inherent_impls_dep_node(CrateNum) -> CrateInherentImpls,\n \n     /// Checks all types in the krate for overlap in their inherent impls. Reports errors.\n     /// Not meant to be used directly outside of coherence.\n     /// (Defined only for LOCAL_CRATE)\n-    [] crate_inherent_impls_overlap_check: inherent_impls_overlap_check_dep_node(CrateNum) -> (),\n+    [] fn crate_inherent_impls_overlap_check: inherent_impls_overlap_check_dep_node(CrateNum) -> (),\n \n     /// Results of evaluating const items or constants embedded in\n     /// other items (such as enum variant explicit discriminants).\n-    [] const_eval: const_eval_dep_node(ty::ParamEnvAnd<'tcx, (DefId, &'tcx Substs<'tcx>)>)\n+    [] fn const_eval: const_eval_dep_node(ty::ParamEnvAnd<'tcx, (DefId, &'tcx Substs<'tcx>)>)\n         -> const_val::EvalResult<'tcx>,\n \n     /// Performs the privacy check and computes \"access levels\".\n-    [] privacy_access_levels: PrivacyAccessLevels(CrateNum) -> Rc<AccessLevels>,\n+    [] fn privacy_access_levels: PrivacyAccessLevels(CrateNum) -> Rc<AccessLevels>,\n \n-    [] reachable_set: reachability_dep_node(CrateNum) -> Rc<NodeSet>,\n+    [] fn reachable_set: reachability_dep_node(CrateNum) -> Rc<NodeSet>,\n \n     /// Per-function `RegionMaps`. The `DefId` should be the owner-def-id for the fn body;\n     /// in the case of closures or \"inline\" expressions, this will be redirected to the enclosing\n     /// fn item.\n-    [] region_maps: RegionMaps(DefId) -> Rc<RegionMaps>,\n-\n-    [] mir_shims: mir_shim_dep_node(ty::InstanceDef<'tcx>) -> &'tcx mir::Mir<'tcx>,\n-\n-    [] def_symbol_name: SymbolName(DefId) -> ty::SymbolName,\n-    [] symbol_name: symbol_name_dep_node(ty::Instance<'tcx>) -> ty::SymbolName,\n-\n-    [] describe_def: DescribeDef(DefId) -> Option<Def>,\n-    [] def_span: DefSpan(DefId) -> Span,\n-    [] stability: Stability(DefId) -> Option<attr::Stability>,\n-    [] deprecation: Deprecation(DefId) -> Option<attr::Deprecation>,\n-    [] item_attrs: ItemAttrs(DefId) -> Rc<[ast::Attribute]>,\n-    [] fn_arg_names: FnArgNames(DefId) -> Vec<ast::Name>,\n-    [] impl_parent: ImplParent(DefId) -> Option<DefId>,\n-    [] trait_of_item: TraitOfItem(DefId) -> Option<DefId>,\n-    [] is_exported_symbol: IsExportedSymbol(DefId) -> bool,\n-    [] item_body_nested_bodies: ItemBodyNestedBodies(DefId) -> Rc<BTreeMap<hir::BodyId, hir::Body>>,\n-    [] const_is_rvalue_promotable_to_static: ConstIsRvaluePromotableToStatic(DefId) -> bool,\n-    [] is_mir_available: IsMirAvailable(DefId) -> bool,\n-\n-    [] trait_impls_of: TraitImpls(DefId) -> Rc<ty::trait_def::TraitImpls>,\n-    [] specialization_graph_of: SpecializationGraph(DefId) -> Rc<specialization_graph::Graph>,\n-    [] is_object_safe: ObjectSafety(DefId) -> bool,\n+    [] fn region_maps: RegionMaps(DefId) -> Rc<RegionMaps>,\n+\n+    [] fn mir_shims: mir_shim_dep_node(ty::InstanceDef<'tcx>) -> &'tcx mir::Mir<'tcx>,\n+\n+    [] fn def_symbol_name: SymbolName(DefId) -> ty::SymbolName,\n+    [] fn symbol_name: symbol_name_dep_node(ty::Instance<'tcx>) -> ty::SymbolName,\n+\n+    [] fn describe_def: DescribeDef(DefId) -> Option<Def>,\n+    [] fn def_span: DefSpan(DefId) -> Span,\n+    [] fn stability: Stability(DefId) -> Option<attr::Stability>,\n+    [] fn deprecation: Deprecation(DefId) -> Option<attr::Deprecation>,\n+    [] fn item_attrs: ItemAttrs(DefId) -> Rc<[ast::Attribute]>,\n+    [] fn fn_arg_names: FnArgNames(DefId) -> Vec<ast::Name>,\n+    [] fn impl_parent: ImplParent(DefId) -> Option<DefId>,\n+    [] fn trait_of_item: TraitOfItem(DefId) -> Option<DefId>,\n+    [] fn is_exported_symbol: IsExportedSymbol(DefId) -> bool,\n+    [] fn item_body_nested_bodies: ItemBodyNestedBodies(DefId)\n+        -> Rc<BTreeMap<hir::BodyId, hir::Body>>,\n+    [] fn const_is_rvalue_promotable_to_static: ConstIsRvaluePromotableToStatic(DefId) -> bool,\n+    [] fn is_mir_available: IsMirAvailable(DefId) -> bool,\n+\n+    [] fn trait_impls_of: TraitImpls(DefId) -> Rc<ty::trait_def::TraitImpls>,\n+    [] fn specialization_graph_of: SpecializationGraph(DefId) -> Rc<specialization_graph::Graph>,\n+    [] fn is_object_safe: ObjectSafety(DefId) -> bool,\n \n     // Get the ParameterEnvironment for a given item; this environment\n     // will be in \"user-facing\" mode, meaning that it is suitabe for\n     // type-checking etc, and it does not normalize specializable\n     // associated types. This is almost always what you want,\n     // unless you are doing MIR optimizations, in which case you\n     // might want to use `reveal_all()` method to change modes.\n-    [] param_env: ParamEnv(DefId) -> ty::ParamEnv<'tcx>,\n+    [] fn param_env: ParamEnv(DefId) -> ty::ParamEnv<'tcx>,\n \n     // Trait selection queries. These are best used by invoking `ty.moves_by_default()`,\n     // `ty.is_copy()`, etc, since that will prune the environment where possible.\n-    [] is_copy_raw: is_copy_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n-    [] is_sized_raw: is_sized_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n-    [] is_freeze_raw: is_freeze_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n-    [] needs_drop_raw: needs_drop_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n-    [] layout_raw: layout_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n+    [] fn is_copy_raw: is_copy_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n+    [] fn is_sized_raw: is_sized_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n+    [] fn is_freeze_raw: is_freeze_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n+    [] fn needs_drop_raw: needs_drop_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n+    [] fn layout_raw: layout_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n                                   -> Result<&'tcx Layout, LayoutError<'tcx>>,\n \n-    [] dylib_dependency_formats: DylibDepFormats(DefId)\n+    [] fn dylib_dependency_formats: DylibDepFormats(DefId)\n                                     -> Rc<Vec<(CrateNum, LinkagePreference)>>,\n \n-    [] is_allocator: IsAllocator(DefId) -> bool,\n-    [] is_panic_runtime: IsPanicRuntime(DefId) -> bool,\n-    [] is_compiler_builtins: IsCompilerBuiltins(DefId) -> bool,\n-    [] has_global_allocator: HasGlobalAllocator(DefId) -> bool,\n+    [] fn is_allocator: IsAllocator(DefId) -> bool,\n+    [] fn is_panic_runtime: IsPanicRuntime(DefId) -> bool,\n+    [] fn is_compiler_builtins: IsCompilerBuiltins(DefId) -> bool,\n+    [] fn has_global_allocator: HasGlobalAllocator(DefId) -> bool,\n \n-    [] extern_crate: ExternCrate(DefId) -> Rc<Option<ExternCrate>>,\n+    [] fn extern_crate: ExternCrate(DefId) -> Rc<Option<ExternCrate>>,\n \n-    [] lint_levels: lint_levels(CrateNum) -> Rc<lint::LintLevelMap>,\n+    [] fn lint_levels: lint_levels(CrateNum) -> Rc<lint::LintLevelMap>,\n \n-    [] specializes: specializes_node((DefId, DefId)) -> bool,\n-    [] in_scope_traits: InScopeTraits(HirId) -> Option<Rc<Vec<TraitCandidate>>>,\n-    [] module_exports: ModuleExports(HirId) -> Option<Rc<Vec<Export>>>,\n+    [] fn specializes: specializes_node((DefId, DefId)) -> bool,\n+    [] fn in_scope_traits: InScopeTraits(HirId) -> Option<Rc<Vec<TraitCandidate>>>,\n+    [] fn module_exports: ModuleExports(HirId) -> Option<Rc<Vec<Export>>>,\n }\n \n fn type_param_predicates<'tcx>((item_id, param_id): (DefId, DefId)) -> DepConstructor<'tcx> {"}, {"sha": "1851e1b8d34bbe595469f394cfe04c43104ddd9b", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -23,7 +23,6 @@ use middle::const_val::ConstVal;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use middle::privacy::AccessLevels;\n use middle::resolve_lifetime::ObjectLifetimeDefault;\n-use middle::region::CodeExtent;\n use mir::Mir;\n use mir::GeneratorLayout;\n use traits;\n@@ -2309,10 +2308,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn node_scope_region(self, id: NodeId) -> Region<'tcx> {\n-        self.mk_region(ty::ReScope(CodeExtent::Misc(id)))\n-    }\n-\n     /// Looks up the span of `impl_did` if the impl is local; otherwise returns `Err`\n     /// with the name of the crate containing the impl.\n     pub fn span_of_impl(self, impl_did: DefId) -> Result<Span, Symbol> {"}, {"sha": "ae05568ab414854a6edbbbfb27ac3a9d45c57774", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -371,12 +371,6 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n             RegionsDoesNotOutlive(a, b) => {\n                 return tcx.lift(&(a, b)).map(|(a, b)| RegionsDoesNotOutlive(a, b))\n             }\n-            RegionsNotSame(a, b) => {\n-                return tcx.lift(&(a, b)).map(|(a, b)| RegionsNotSame(a, b))\n-            }\n-            RegionsNoOverlap(a, b) => {\n-                return tcx.lift(&(a, b)).map(|(a, b)| RegionsNoOverlap(a, b))\n-            }\n             RegionsInsufficientlyPolymorphic(a, b) => {\n                 return tcx.lift(&b).map(|b| RegionsInsufficientlyPolymorphic(a, b))\n             }\n@@ -1057,12 +1051,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::error::TypeError<'tcx> {\n             RegionsDoesNotOutlive(a, b) => {\n                 RegionsDoesNotOutlive(a.fold_with(folder), b.fold_with(folder))\n             },\n-            RegionsNotSame(a, b) => {\n-                RegionsNotSame(a.fold_with(folder), b.fold_with(folder))\n-            },\n-            RegionsNoOverlap(a, b) => {\n-                RegionsNoOverlap(a.fold_with(folder), b.fold_with(folder))\n-            },\n             RegionsInsufficientlyPolymorphic(a, b) => {\n                 RegionsInsufficientlyPolymorphic(a, b.fold_with(folder))\n             },\n@@ -1088,9 +1076,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::error::TypeError<'tcx> {\n         match *self {\n             UnsafetyMismatch(x) => x.visit_with(visitor),\n             AbiMismatch(x) => x.visit_with(visitor),\n-            RegionsDoesNotOutlive(a, b) |\n-            RegionsNotSame(a, b) |\n-            RegionsNoOverlap(a, b) => {\n+            RegionsDoesNotOutlive(a, b) => {\n                 a.visit_with(visitor) || b.visit_with(visitor)\n             },\n             RegionsInsufficientlyPolymorphic(_, b) |"}, {"sha": "2f5f31e0f63bc8c8646ba3427c4e459948263216", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use hir::BodyId;\n use hir::def_id::DefId;\n use hir::map::definitions::DefPathData;\n use middle::region::{CodeExtent, BlockRemainder};\n@@ -527,16 +526,16 @@ impl fmt::Display for ty::RegionKind {\n             }\n             ty::ReScope(code_extent) if identify_regions() => {\n                 match code_extent {\n-                    CodeExtent::Misc(node_id) =>\n-                        write!(f, \"'{}mce\", node_id.as_u32()),\n-                    CodeExtent::CallSiteScope(BodyId { node_id }) =>\n-                        write!(f, \"'{}cce\", node_id.as_u32()),\n-                    CodeExtent::ParameterScope(BodyId { node_id }) =>\n-                        write!(f, \"'{}pce\", node_id.as_u32()),\n-                    CodeExtent::DestructionScope(node_id) =>\n-                        write!(f, \"'{}dce\", node_id.as_u32()),\n+                    CodeExtent::Misc(id) =>\n+                        write!(f, \"'{}mce\", id.as_usize()),\n+                    CodeExtent::CallSiteScope(id) =>\n+                        write!(f, \"'{}cce\", id.as_usize()),\n+                    CodeExtent::ParameterScope(id) =>\n+                        write!(f, \"'{}pce\", id.as_usize()),\n+                    CodeExtent::DestructionScope(id) =>\n+                        write!(f, \"'{}dce\", id.as_usize()),\n                     CodeExtent::Remainder(BlockRemainder { block, first_statement_index }) =>\n-                        write!(f, \"'{}_{}rce\", block, first_statement_index),\n+                        write!(f, \"'{}_{}rce\", block.as_usize(), first_statement_index),\n                 }\n             }\n             ty::ReVar(region_vid) if identify_regions() => {"}, {"sha": "7f31c53e63caf70ccc772d7360e3731447415acc", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -103,7 +103,8 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n         debug!(\"consume(consume_id={}, cmt={:?}, mode={:?})\",\n                consume_id, cmt, mode);\n \n-        self.consume_common(consume_id, consume_span, cmt, mode);\n+        let hir_id = self.tcx().hir.node_to_hir_id(consume_id);\n+        self.consume_common(hir_id.local_id, consume_span, cmt, mode);\n     }\n \n     fn matched_pat(&mut self,\n@@ -120,7 +121,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n                cmt,\n                mode);\n \n-        self.consume_common(consume_pat.id, consume_pat.span, cmt, mode);\n+        self.consume_common(consume_pat.hir_id.local_id, consume_pat.span, cmt, mode);\n     }\n \n     fn borrow(&mut self,\n@@ -136,15 +137,16 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n                borrow_id, cmt, loan_region,\n                bk, loan_cause);\n \n+        let hir_id = self.tcx().hir.node_to_hir_id(borrow_id);\n         if let Some(lp) = opt_loan_path(&cmt) {\n             let moved_value_use_kind = match loan_cause {\n                 euv::ClosureCapture(_) => MovedInCapture,\n                 _ => MovedInUse,\n             };\n-            self.check_if_path_is_moved(borrow_id, borrow_span, moved_value_use_kind, &lp);\n+            self.check_if_path_is_moved(hir_id.local_id, borrow_span, moved_value_use_kind, &lp);\n         }\n \n-        self.check_for_conflicting_loans(borrow_id);\n+        self.check_for_conflicting_loans(hir_id.local_id);\n     }\n \n     fn mutate(&mut self,\n@@ -163,7 +165,8 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n                     // have to be *FULLY* initialized, but we still\n                     // must be careful lest it contains derefs of\n                     // pointers.\n-                    self.check_if_assigned_path_is_moved(assignee_cmt.id,\n+                    let hir_id = self.tcx().hir.node_to_hir_id(assignee_cmt.id);\n+                    self.check_if_assigned_path_is_moved(hir_id.local_id,\n                                                          assignment_span,\n                                                          MovedInUse,\n                                                          &lp);\n@@ -172,14 +175,16 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n                     // In a case like `path += 1`, then path must be\n                     // fully initialized, since we will read it before\n                     // we write it.\n-                    self.check_if_path_is_moved(assignee_cmt.id,\n+                    let hir_id = self.tcx().hir.node_to_hir_id(assignee_cmt.id);\n+                    self.check_if_path_is_moved(hir_id.local_id,\n                                                 assignment_span,\n                                                 MovedInUse,\n                                                 &lp);\n                 }\n             }\n         }\n-        self.check_assignment(assignment_id, assignment_span, assignee_cmt);\n+        self.check_assignment(self.tcx().hir.node_to_hir_id(assignment_id).local_id,\n+                              assignment_span, assignee_cmt);\n     }\n \n     fn decl_without_init(&mut self, _id: ast::NodeId, _span: Span) { }\n@@ -220,7 +225,7 @@ fn compatible_borrow_kinds(borrow_kind1: ty::BorrowKind,\n impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.bccx.tcx }\n \n-    pub fn each_issued_loan<F>(&self, node: ast::NodeId, mut op: F) -> bool where\n+    pub fn each_issued_loan<F>(&self, node: hir::ItemLocalId, mut op: F) -> bool where\n         F: FnMut(&Loan<'tcx>) -> bool,\n     {\n         //! Iterates over each loan that has been issued\n@@ -241,7 +246,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         //! Like `each_issued_loan()`, but only considers loans that are\n         //! currently in scope.\n \n-        self.each_issued_loan(scope.node_id(), |loan| {\n+        self.each_issued_loan(scope.item_local_id(), |loan| {\n             if self.bccx.region_maps.is_subscope_of(scope, loan.kill_scope) {\n                 op(loan)\n             } else {\n@@ -325,7 +330,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         return true;\n     }\n \n-    pub fn loans_generated_by(&self, node: ast::NodeId) -> Vec<usize> {\n+    pub fn loans_generated_by(&self, node: hir::ItemLocalId) -> Vec<usize> {\n         //! Returns a vector of the loans that are generated as\n         //! we enter `node`.\n \n@@ -337,7 +342,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         return result;\n     }\n \n-    pub fn check_for_conflicting_loans(&self, node: ast::NodeId) {\n+    pub fn check_for_conflicting_loans(&self, node: hir::ItemLocalId) {\n         //! Checks to see whether any of the loans that are issued\n         //! on entrance to `node` conflict with loans that have already been\n         //! issued when we enter `node` (for example, we do not\n@@ -462,7 +467,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             // 3. Where does old loan expire.\n \n             let previous_end_span =\n-                self.tcx().hir.span(old_loan.kill_scope.node_id()).end_point();\n+                old_loan.kill_scope.span(self.tcx(), &self.bccx.region_maps).end_point();\n \n             let mut err = match (new_loan.kind, old_loan.kind) {\n                 (ty::MutBorrow, ty::MutBorrow) => {\n@@ -590,7 +595,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     }\n \n     fn consume_common(&self,\n-                      id: ast::NodeId,\n+                      id: hir::ItemLocalId,\n                       span: Span,\n                       cmt: mc::cmt<'tcx>,\n                       mode: euv::ConsumeMode) {\n@@ -628,7 +633,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     }\n \n     fn check_for_copy_of_frozen_path(&self,\n-                                     id: ast::NodeId,\n+                                     id: hir::ItemLocalId,\n                                      span: Span,\n                                      copy_path: &LoanPath<'tcx>) {\n         match self.analyze_restrictions_on_use(id, copy_path, ty::ImmBorrow) {\n@@ -649,7 +654,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     }\n \n     fn check_for_move_of_borrowed_path(&self,\n-                                       id: ast::NodeId,\n+                                       id: hir::ItemLocalId,\n                                        span: Span,\n                                        move_path: &LoanPath<'tcx>,\n                                        move_kind: move_data::MoveKind) {\n@@ -699,13 +704,12 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     }\n \n     pub fn analyze_restrictions_on_use(&self,\n-                                       expr_id: ast::NodeId,\n+                                       expr_id: hir::ItemLocalId,\n                                        use_path: &LoanPath<'tcx>,\n                                        borrow_kind: ty::BorrowKind)\n                                        -> UseError<'tcx> {\n-        debug!(\"analyze_restrictions_on_use(expr_id={}, use_path={:?})\",\n-               self.tcx().hir.node_to_string(expr_id),\n-               use_path);\n+        debug!(\"analyze_restrictions_on_use(expr_id={:?}, use_path={:?})\",\n+               expr_id, use_path);\n \n         let mut ret = UseOk;\n \n@@ -725,11 +729,11 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     /// Reports an error if `expr` (which should be a path)\n     /// is using a moved/uninitialized value\n     fn check_if_path_is_moved(&self,\n-                              id: ast::NodeId,\n+                              id: hir::ItemLocalId,\n                               span: Span,\n                               use_kind: MovedValueUseKind,\n                               lp: &Rc<LoanPath<'tcx>>) {\n-        debug!(\"check_if_path_is_moved(id={}, use_kind={:?}, lp={:?})\",\n+        debug!(\"check_if_path_is_moved(id={:?}, use_kind={:?}, lp={:?})\",\n                id, use_kind, lp);\n \n         // FIXME (22079): if you find yourself tempted to cut and paste\n@@ -772,7 +776,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     /// (*p).x = 22; // not ok, p is uninitialized, can't deref\n     /// ```\n     fn check_if_assigned_path_is_moved(&self,\n-                                       id: ast::NodeId,\n+                                       id: hir::ItemLocalId,\n                                        span: Span,\n                                        use_kind: MovedValueUseKind,\n                                        lp: &Rc<LoanPath<'tcx>>)\n@@ -822,7 +826,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     }\n \n     fn check_assignment(&self,\n-                        assignment_id: ast::NodeId,\n+                        assignment_id: hir::ItemLocalId,\n                         assignment_span: Span,\n                         assignee_cmt: mc::cmt<'tcx>) {\n         debug!(\"check_assignment(assignee_cmt={:?})\", assignee_cmt);"}, {"sha": "465457f5ab39a56a01e54412945bf2969d32c73a", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -27,7 +27,7 @@ use rustc::hir::*;\n use rustc::hir::map::Node::*;\n \n struct GatherMoveInfo<'tcx> {\n-    id: ast::NodeId,\n+    id: hir::ItemLocalId,\n     kind: MoveKind,\n     cmt: mc::cmt<'tcx>,\n     span_path_opt: Option<MovePlace<'tcx>>\n@@ -79,13 +79,14 @@ pub fn gather_decl<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                              var_id: ast::NodeId,\n                              var_ty: Ty<'tcx>) {\n     let loan_path = Rc::new(LoanPath::new(LpVar(var_id), var_ty));\n-    move_data.add_move(bccx.tcx, loan_path, var_id, Declared);\n+    let hir_id = bccx.tcx.hir.node_to_hir_id(var_id);\n+    move_data.add_move(bccx.tcx, loan_path, hir_id.local_id, Declared);\n }\n \n pub fn gather_move_from_expr<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                        move_data: &MoveData<'tcx>,\n                                        move_error_collector: &mut MoveErrorCollector<'tcx>,\n-                                       move_expr_id: ast::NodeId,\n+                                       move_expr_id: hir::ItemLocalId,\n                                        cmt: mc::cmt<'tcx>,\n                                        move_reason: euv::MoveReason) {\n     let kind = match move_reason {\n@@ -118,7 +119,7 @@ pub fn gather_move_from_pat<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         _ => None,\n     };\n     let move_info = GatherMoveInfo {\n-        id: move_pat.id,\n+        id: move_pat.hir_id.local_id,\n         kind: MovePat,\n         cmt,\n         span_path_opt: pat_span_path_opt,\n@@ -135,7 +136,7 @@ fn gather_move<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                          move_data: &MoveData<'tcx>,\n                          move_error_collector: &mut MoveErrorCollector<'tcx>,\n                          move_info: GatherMoveInfo<'tcx>) {\n-    debug!(\"gather_move(move_id={}, cmt={:?})\",\n+    debug!(\"gather_move(move_id={:?}, cmt={:?})\",\n            move_info.id, move_info.cmt);\n \n     let potentially_illegal_move =\n@@ -161,10 +162,10 @@ fn gather_move<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n \n pub fn gather_assignment<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                    move_data: &MoveData<'tcx>,\n-                                   assignment_id: ast::NodeId,\n+                                   assignment_id: hir::ItemLocalId,\n                                    assignment_span: Span,\n                                    assignee_loan_path: Rc<LoanPath<'tcx>>,\n-                                   assignee_id: ast::NodeId,\n+                                   assignee_id: hir::ItemLocalId,\n                                    mode: euv::MutateMode) {\n     move_data.add_assignment(bccx.tcx,\n                              assignee_loan_path,"}, {"sha": "461f1d6a43283930a7addae2b77a0bb1e737de27", "filename": "src/librustc_borrowck/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -115,8 +115,9 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n                 self.bccx.tcx.mk_region(ty::ReScope(self.item_scope))\n             }\n             Categorization::Local(local_id) => {\n+                let hir_id = self.bccx.tcx.hir.node_to_hir_id(local_id);\n                 self.bccx.tcx.mk_region(ty::ReScope(\n-                    self.bccx.region_maps.var_scope(local_id)))\n+                    self.bccx.region_maps.var_scope(hir_id.local_id)))\n             }\n             Categorization::StaticItem |\n             Categorization::Deref(_, mc::UnsafePtr(..)) => {"}, {"sha": "5689a30fd38c0c26b82ea614b3d780ecd0bb4bab", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -43,8 +43,8 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     let mut glcx = GatherLoanCtxt {\n         bccx,\n         all_loans: Vec::new(),\n-        item_ub: region::CodeExtent::Misc(body.node_id),\n-        move_data: MoveData::new(),\n+        item_ub: region::CodeExtent::Misc(bccx.tcx.hir.body(body).value.hir_id.local_id),\n+        move_data: MoveData::default(),\n         move_error_collector: move_error::MoveErrorCollector::new(),\n     };\n \n@@ -79,7 +79,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n             euv::Move(move_reason) => {\n                 gather_moves::gather_move_from_expr(\n                     self.bccx, &self.move_data, &mut self.move_error_collector,\n-                    consume_id, cmt, move_reason);\n+                    self.bccx.tcx.hir.node_to_hir_id(consume_id).local_id, cmt, move_reason);\n             }\n             euv::Copy => { }\n         }\n@@ -126,7 +126,8 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n                bk={:?}, loan_cause={:?})\",\n                borrow_id, cmt, loan_region,\n                bk, loan_cause);\n-        self.guarantee_valid(borrow_id,\n+        let hir_id = self.bccx.tcx.hir.node_to_hir_id(borrow_id);\n+        self.guarantee_valid(hir_id.local_id,\n                              borrow_span,\n                              cmt,\n                              bk,\n@@ -272,8 +273,12 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                     self.mark_loan_path_as_mutated(&lp);\n                 }\n                 gather_moves::gather_assignment(self.bccx, &self.move_data,\n-                                                assignment_id, assignment_span,\n-                                                lp, cmt.id, mode);\n+                                                self.bccx.tcx.hir.node_to_hir_id(assignment_id)\n+                                                    .local_id,\n+                                                assignment_span,\n+                                                lp,\n+                                                self.bccx.tcx.hir.node_to_hir_id(cmt.id).local_id,\n+                                                mode);\n             }\n             None => {\n                 // This can occur with e.g. `*foo() = 5`.  In such\n@@ -287,13 +292,13 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n     /// reports an error.  This may entail taking out loans, which will be added to the\n     /// `req_loan_map`.\n     fn guarantee_valid(&mut self,\n-                       borrow_id: ast::NodeId,\n+                       borrow_id: hir::ItemLocalId,\n                        borrow_span: Span,\n                        cmt: mc::cmt<'tcx>,\n                        req_kind: ty::BorrowKind,\n                        loan_region: ty::Region<'tcx>,\n                        cause: euv::LoanCause) {\n-        debug!(\"guarantee_valid(borrow_id={}, cmt={:?}, \\\n+        debug!(\"guarantee_valid(borrow_id={:?}, cmt={:?}, \\\n                 req_mutbl={:?}, loan_region={:?})\",\n                borrow_id,\n                cmt,\n@@ -392,7 +397,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n             }\n         };\n \n-        debug!(\"guarantee_valid(borrow_id={}), loan={:?}\",\n+        debug!(\"guarantee_valid(borrow_id={:?}), loan={:?}\",\n                borrow_id, loan);\n \n         // let loan_path = loan.loan_path;"}, {"sha": "25aac92c13d8572773e07dd7455c7a923dc1e838", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 31, "deletions": 33, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -36,7 +36,6 @@ use rustc::middle::region::{self, RegionMaps};\n use rustc::middle::free_region::RegionRelations;\n use rustc::ty::{self, TyCtxt};\n use rustc::ty::maps::Providers;\n-use rustc::util::nodemap::FxHashMap;\n use rustc_mir::util::borrowck_errors::{BorrowckErrors, Origin};\n \n use std::fmt;\n@@ -167,9 +166,10 @@ fn build_borrowck_dataflow_data<'a, 'c, 'tcx, F>(this: &mut BorrowckCtxt<'a, 'tc\n                              id_range,\n                              all_loans.len());\n     for (loan_idx, loan) in all_loans.iter().enumerate() {\n-        loan_dfcx.add_gen(loan.gen_scope.node_id(), loan_idx);\n+        loan_dfcx.add_gen(loan.gen_scope.item_local_id(), loan_idx);\n         loan_dfcx.add_kill(KillFrom::ScopeEnd,\n-                           loan.kill_scope.node_id(), loan_idx);\n+                           loan.kill_scope.item_local_id(),\n+                           loan_idx);\n     }\n     loan_dfcx.add_kills_from_flow_exits(cfg);\n     loan_dfcx.propagate(cfg, this.body);\n@@ -364,10 +364,14 @@ fn closure_to_block(closure_id: DefIndex,\n impl<'a, 'tcx> LoanPath<'tcx> {\n     pub fn kill_scope(&self, bccx: &BorrowckCtxt<'a, 'tcx>) -> region::CodeExtent {\n         match self.kind {\n-            LpVar(local_id) => bccx.region_maps.var_scope(local_id),\n+            LpVar(local_id) => {\n+                let hir_id = bccx.tcx.hir.node_to_hir_id(local_id);\n+                bccx.region_maps.var_scope(hir_id.local_id)\n+            }\n             LpUpvar(upvar_id) => {\n                 let block_id = closure_to_block(upvar_id.closure_expr_id, bccx.tcx);\n-                region::CodeExtent::Misc(block_id)\n+                let hir_id = bccx.tcx.hir.node_to_hir_id(block_id);\n+                region::CodeExtent::Misc(hir_id.local_id)\n             }\n             LpDowncast(ref base, _) |\n             LpExtend(ref base, ..) => base.kill_scope(bccx),\n@@ -640,19 +644,22 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n \n         // Get type of value and span where it was previously\n         // moved.\n+        let node_id = self.tcx.hir.hir_to_node_id(hir::HirId {\n+            owner: self.body.value.hir_id.owner,\n+            local_id: the_move.id\n+        });\n         let (move_span, move_note) = match the_move.kind {\n             move_data::Declared => {\n                 unreachable!();\n             }\n \n             move_data::MoveExpr |\n-            move_data::MovePat =>\n-                (self.tcx.hir.span(the_move.id), \"\"),\n+            move_data::MovePat => (self.tcx.hir.span(node_id), \"\"),\n \n             move_data::Captured =>\n-                (match self.tcx.hir.expect_expr(the_move.id).node {\n+                (match self.tcx.hir.expect_expr(node_id).node {\n                     hir::ExprClosure(.., fn_decl_span, _) => fn_decl_span,\n-                    ref r => bug!(\"Captured({}) maps to non-closure: {:?}\",\n+                    ref r => bug!(\"Captured({:?}) maps to non-closure: {:?}\",\n                                   the_move.id, r),\n                 }, \" (into closure)\"),\n         };\n@@ -813,7 +820,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 debug!(\"err_out_of_scope: self.body.is_generator = {:?}\",\n                        self.body.is_generator);\n                 let maybe_borrow_across_yield = if self.body.is_generator {\n-                    let body_extent = region::CodeExtent::Misc(self.body.id().node_id);\n+                    let body_extent = region::CodeExtent::Misc(self.body.value.hir_id.local_id);\n                     debug!(\"err_out_of_scope: body_extent = {:?}\", body_extent);\n                     debug!(\"err_out_of_scope: super_scope = {:?}\", super_scope);\n                     debug!(\"err_out_of_scope: sub_scope = {:?}\", sub_scope);\n@@ -839,7 +846,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                 // block remainder that starts with\n                                 // `let a`) for a yield. We can cite\n                                 // that for the user.\n-                                self.tcx.yield_in_extent(value_extent, &mut FxHashMap())\n+                                self.region_maps.yield_in_scope(value_extent)\n                             } else {\n                                 None\n                             }\n@@ -938,6 +945,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                             }\n                             None => {\n                                 self.tcx.note_and_explain_region(\n+                                    &self.region_maps,\n                                     &mut db,\n                                     \"borrowed value must be valid for \",\n                                     sub_scope,\n@@ -950,6 +958,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                             }\n                             None => {\n                                 self.tcx.note_and_explain_region(\n+                                    &self.region_maps,\n                                     &mut db,\n                                     \"...but borrowed value is only valid for \",\n                                     super_scope,\n@@ -959,8 +968,14 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     }\n                 }\n \n-                if let Some(_) = statement_scope_span(self.tcx, super_scope) {\n-                    db.note(\"consider using a `let` binding to increase its lifetime\");\n+                if let ty::ReScope(scope) = *super_scope {\n+                    let node_id = scope.node_id(self.tcx, &self.region_maps);\n+                    match self.tcx.hir.find(node_id) {\n+                        Some(hir_map::NodeStmt(_)) => {\n+                            db.note(\"consider using a `let` binding to increase its lifetime\");\n+                        }\n+                        _ => {}\n+                    }\n                 }\n \n                 db.emit();\n@@ -979,12 +994,14 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     None => self.cmt_to_string(&err.cmt),\n                 };\n                 self.tcx.note_and_explain_region(\n+                    &self.region_maps,\n                     &mut db,\n                     &format!(\"{} would have to be valid for \",\n                             descr),\n                     loan_scope,\n                     \"...\");\n                 self.tcx.note_and_explain_region(\n+                    &self.region_maps,\n                     &mut db,\n                     &format!(\"...but {} is only valid for \", descr),\n                     ptr_scope,\n@@ -1240,14 +1257,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     fn region_end_span(&self, region: ty::Region<'tcx>) -> Option<Span> {\n         match *region {\n             ty::ReScope(scope) => {\n-                match scope.span(&self.tcx.hir) {\n-                    Some(s) => {\n-                        Some(s.end_point())\n-                    }\n-                    None => {\n-                        None\n-                    }\n-                }\n+                Some(scope.span(self.tcx, &self.region_maps).end_point())\n             }\n             _ => None\n         }\n@@ -1384,18 +1394,6 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     }\n }\n \n-fn statement_scope_span(tcx: TyCtxt, region: ty::Region) -> Option<Span> {\n-    match *region {\n-        ty::ReScope(scope) => {\n-            match tcx.hir.find(scope.node_id()) {\n-                Some(hir_map::NodeStmt(stmt)) => Some(stmt.span),\n-                _ => None\n-            }\n-        }\n-        _ => None\n-    }\n-}\n-\n impl BitwiseOperator for LoanDataFlowOperator {\n     #[inline]\n     fn join(&self, succ: usize, pred: usize) -> usize {"}, {"sha": "7915eccbf74451cc447b6d779d949979b03250f2", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 21, "deletions": 32, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -23,16 +23,16 @@ use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::expr_use_visitor::MutateMode;\n use rustc::middle::mem_categorization as mc;\n use rustc::ty::{self, TyCtxt};\n-use rustc::util::nodemap::{FxHashMap, NodeSet};\n+use rustc::util::nodemap::{FxHashMap, FxHashSet};\n \n use std::cell::RefCell;\n use std::rc::Rc;\n use std::usize;\n-use syntax::ast;\n use syntax_pos::Span;\n use rustc::hir;\n use rustc::hir::intravisit::IdRange;\n \n+#[derive(Default)]\n pub struct MoveData<'tcx> {\n     /// Move paths. See section \"Move paths\" in `README.md`.\n     pub paths: RefCell<Vec<MovePath<'tcx>>>,\n@@ -54,7 +54,7 @@ pub struct MoveData<'tcx> {\n     pub path_assignments: RefCell<Vec<Assignment>>,\n \n     /// Assignments to a variable or path, like `x = foo`, but not `x += foo`.\n-    pub assignee_ids: RefCell<NodeSet>,\n+    pub assignee_ids: RefCell<FxHashSet<hir::ItemLocalId>>,\n }\n \n pub struct FlowedMoveData<'a, 'tcx: 'a> {\n@@ -133,7 +133,7 @@ pub struct Move {\n     pub path: MovePathIndex,\n \n     /// id of node that is doing the move.\n-    pub id: ast::NodeId,\n+    pub id: hir::ItemLocalId,\n \n     /// Kind of move, for error messages.\n     pub kind: MoveKind,\n@@ -148,13 +148,13 @@ pub struct Assignment {\n     pub path: MovePathIndex,\n \n     /// id where assignment occurs\n-    pub id: ast::NodeId,\n+    pub id: hir::ItemLocalId,\n \n     /// span of node where assignment occurs\n     pub span: Span,\n \n     /// id for l-value expression on lhs of assignment\n-    pub assignee_id: ast::NodeId,\n+    pub assignee_id: hir::ItemLocalId,\n }\n \n #[derive(Clone, Copy)]\n@@ -189,17 +189,6 @@ fn loan_path_is_precise(loan_path: &LoanPath) -> bool {\n }\n \n impl<'a, 'tcx> MoveData<'tcx> {\n-    pub fn new() -> MoveData<'tcx> {\n-        MoveData {\n-            paths: RefCell::new(Vec::new()),\n-            path_map: RefCell::new(FxHashMap()),\n-            moves: RefCell::new(Vec::new()),\n-            path_assignments: RefCell::new(Vec::new()),\n-            var_assignments: RefCell::new(Vec::new()),\n-            assignee_ids: RefCell::new(NodeSet()),\n-        }\n-    }\n-\n     /// return true if there are no trackable assignments or moves\n     /// in this move data - that means that there is nothing that\n     /// could cause a borrow error.\n@@ -345,7 +334,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n     /// Adds a new move entry for a move of `lp` that occurs at location `id` with kind `kind`.\n     pub fn add_move(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     orig_lp: Rc<LoanPath<'tcx>>,\n-                    id: ast::NodeId,\n+                    id: hir::ItemLocalId,\n                     kind: MoveKind) {\n         // Moving one union field automatically moves all its fields. Also move siblings of\n         // all parent union fields, moves do not propagate upwards automatically.\n@@ -373,9 +362,9 @@ impl<'a, 'tcx> MoveData<'tcx> {\n \n     fn add_move_helper(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                        lp: Rc<LoanPath<'tcx>>,\n-                       id: ast::NodeId,\n+                       id: hir::ItemLocalId,\n                        kind: MoveKind) {\n-        debug!(\"add_move(lp={:?}, id={}, kind={:?})\",\n+        debug!(\"add_move(lp={:?}, id={:?}, kind={:?})\",\n                lp,\n                id,\n                kind);\n@@ -398,9 +387,9 @@ impl<'a, 'tcx> MoveData<'tcx> {\n     /// `span`.\n     pub fn add_assignment(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           lp: Rc<LoanPath<'tcx>>,\n-                          assign_id: ast::NodeId,\n+                          assign_id: hir::ItemLocalId,\n                           span: Span,\n-                          assignee_id: ast::NodeId,\n+                          assignee_id: hir::ItemLocalId,\n                           mode: euv::MutateMode) {\n         // Assigning to one union field automatically assigns to all its fields.\n         if let LpExtend(ref base_lp, mutbl, LpInterior(opt_variant_id, interior)) = lp.kind {\n@@ -429,11 +418,11 @@ impl<'a, 'tcx> MoveData<'tcx> {\n \n     fn add_assignment_helper(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              lp: Rc<LoanPath<'tcx>>,\n-                             assign_id: ast::NodeId,\n+                             assign_id: hir::ItemLocalId,\n                              span: Span,\n-                             assignee_id: ast::NodeId,\n+                             assignee_id: hir::ItemLocalId,\n                              mode: euv::MutateMode) {\n-        debug!(\"add_assignment(lp={:?}, assign_id={}, assignee_id={}\",\n+        debug!(\"add_assignment(lp={:?}, assign_id={:?}, assignee_id={:?}\",\n                lp, assign_id, assignee_id);\n \n         let path_index = self.move_path(tcx, lp.clone());\n@@ -496,7 +485,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n                 LpVar(..) | LpUpvar(..) | LpDowncast(..) => {\n                     let kill_scope = path.loan_path.kill_scope(bccx);\n                     let path = *self.path_map.borrow().get(&path.loan_path).unwrap();\n-                    self.kill_moves(path, kill_scope.node_id(),\n+                    self.kill_moves(path, kill_scope.item_local_id(),\n                                     KillFrom::ScopeEnd, dfcx_moves);\n                 }\n                 LpExtend(..) => {}\n@@ -511,7 +500,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n                 LpVar(..) | LpUpvar(..) | LpDowncast(..) => {\n                     let kill_scope = lp.kill_scope(bccx);\n                     dfcx_assign.add_kill(KillFrom::ScopeEnd,\n-                                         kill_scope.node_id(),\n+                                         kill_scope.item_local_id(),\n                                          assignment_index);\n                 }\n                 LpExtend(..) => {\n@@ -579,7 +568,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n \n     fn kill_moves(&self,\n                   path: MovePathIndex,\n-                  kill_id: ast::NodeId,\n+                  kill_id: hir::ItemLocalId,\n                   kill_kind: KillFrom,\n                   dfcx_moves: &mut MoveDataFlow) {\n         // We can only perform kills for paths that refer to a unique location,\n@@ -589,7 +578,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n         let loan_path = self.path_loan_path(path);\n         if loan_path_is_precise(&loan_path) {\n             self.each_applicable_move(path, |move_index| {\n-                debug!(\"kill_moves add_kill {:?} kill_id={} move_index={}\",\n+                debug!(\"kill_moves add_kill {:?} kill_id={:?} move_index={}\",\n                        kill_kind, kill_id, move_index.get());\n                 dfcx_moves.add_kill(kill_kind, kill_id, move_index.get());\n                 true\n@@ -642,7 +631,7 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n     }\n \n     pub fn kind_of_move_of_path(&self,\n-                                id: ast::NodeId,\n+                                id: hir::ItemLocalId,\n                                 loan_path: &Rc<LoanPath<'tcx>>)\n                                 -> Option<MoveKind> {\n         //! Returns the kind of a move of `loan_path` by `id`, if one exists.\n@@ -667,7 +656,7 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n     /// have occurred on entry to `id` without an intervening assignment. In other words, any moves\n     /// that would invalidate a reference to `loan_path` at location `id`.\n     pub fn each_move_of<F>(&self,\n-                           id: ast::NodeId,\n+                           id: hir::ItemLocalId,\n                            loan_path: &Rc<LoanPath<'tcx>>,\n                            mut f: F)\n                            -> bool where\n@@ -724,7 +713,7 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n     /// Iterates through every assignment to `loan_path` that may have occurred on entry to `id`.\n     /// `loan_path` must be a single variable.\n     pub fn each_assignment_of<F>(&self,\n-                                 id: ast::NodeId,\n+                                 id: hir::ItemLocalId,\n                                  loan_path: &Rc<LoanPath<'tcx>>,\n                                  mut f: F)\n                                  -> bool where"}, {"sha": "22867ba5b55a4ae779ebef38fa6469abc5e90ed0", "filename": "src/librustc_borrowck/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_borrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_borrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fgraphviz.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -52,7 +52,7 @@ pub struct DataflowLabeller<'a, 'tcx: 'a> {\n impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n     fn dataflow_for(&self, e: EntryOrExit, n: &Node<'a>) -> String {\n         let id = n.1.data.id();\n-        debug!(\"dataflow_for({:?}, id={}) {:?}\", e, id, self.variants);\n+        debug!(\"dataflow_for({:?}, id={:?}) {:?}\", e, id, self.variants);\n         let mut sets = \"\".to_string();\n         let mut seen_one = false;\n         for &variant in &self.variants {"}, {"sha": "6a58b7fb75360ba040058d142624c99bce0168e0", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -765,7 +765,7 @@ fn print_flowgraph<'a, 'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n     let cfg = cfg::CFG::new(tcx, &body);\n     let labelled_edges = mode != PpFlowGraphMode::UnlabelledEdges;\n     let lcfg = LabelledCFG {\n-        hir_map: &tcx.hir,\n+        tcx,\n         cfg: &cfg,\n         name: format!(\"node_{}\", code.id()),\n         labelled_edges,"}, {"sha": "247f51b1da4437ee4a8c785a307428f97a17a687", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -50,7 +50,7 @@ struct Env<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n }\n \n struct RH<'a> {\n-    id: ast::NodeId,\n+    id: hir::ItemLocalId,\n     sub: &'a [RH<'a>],\n }\n \n@@ -157,7 +157,7 @@ fn test_env<F>(source_string: &str,\n                              \"test_crate\",\n                              |tcx| {\n         tcx.infer_ctxt().enter(|infcx| {\n-            let mut region_maps = RegionMaps::new();\n+            let mut region_maps = RegionMaps::default();\n             body(Env {\n                 infcx: &infcx,\n                 region_maps: &mut region_maps,\n@@ -188,21 +188,19 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n         // creates a region hierarchy where 1 is root, 10 and 11 are\n         // children of 1, etc\n \n-        let node = ast::NodeId::from_u32;\n-        let dscope = CodeExtent::DestructionScope(node(1));\n+        let dscope = CodeExtent::DestructionScope(hir::ItemLocalId(1));\n         self.region_maps.record_code_extent(dscope, None);\n         self.create_region_hierarchy(&RH {\n-                                         id: node(1),\n-                                         sub: &[RH {\n-                                                    id: node(10),\n-                                                    sub: &[],\n-                                                },\n-                                                RH {\n-                                                    id: node(11),\n-                                                    sub: &[],\n-                                                }],\n-                                     },\n-                                     dscope);\n+            id: hir::ItemLocalId(1),\n+            sub: &[RH {\n+                id: hir::ItemLocalId(10),\n+                sub: &[],\n+            },\n+            RH {\n+                id: hir::ItemLocalId(11),\n+                sub: &[],\n+            }],\n+        }, dscope);\n     }\n \n     #[allow(dead_code)] // this seems like it could be useful, even if we don't use it now\n@@ -335,7 +333,7 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn t_rptr_scope(&self, id: u32) -> Ty<'tcx> {\n-        let r = ty::ReScope(CodeExtent::Misc(ast::NodeId::from_u32(id)));\n+        let r = ty::ReScope(CodeExtent::Misc(hir::ItemLocalId(id)));\n         self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r), self.tcx().types.isize)\n     }\n "}, {"sha": "52b645638b86f37377a2829c9e2c729af1036500", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -850,23 +850,25 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n             }\n             visited.insert(cfg_id);\n \n-            let node_id = cfg.graph.node_data(idx).id();\n-\n             // is this a recursive call?\n-            let self_recursive = if node_id != ast::DUMMY_NODE_ID {\n-                match method {\n+            let local_id = cfg.graph.node_data(idx).id();\n+            if local_id != hir::DUMMY_ITEM_LOCAL_ID {\n+                let node_id = cx.tcx.hir.hir_to_node_id(hir::HirId {\n+                    owner: body.value.hir_id.owner,\n+                    local_id\n+                });\n+                let self_recursive = match method {\n                     Some(ref method) => expr_refers_to_this_method(cx, method, node_id),\n                     None => expr_refers_to_this_fn(cx, id, node_id),\n+                };\n+                if self_recursive {\n+                    self_call_spans.push(cx.tcx.hir.span(node_id));\n+                    // this is a self call, so we shouldn't explore past\n+                    // this node in the CFG.\n+                    continue;\n                 }\n-            } else {\n-                false\n-            };\n-            if self_recursive {\n-                self_call_spans.push(cx.tcx.hir.span(node_id));\n-                // this is a self call, so we shouldn't explore past\n-                // this node in the CFG.\n-                continue;\n             }\n+\n             // add the successors of this node to explore the graph further.\n             for (_, edge) in cfg.graph.outgoing_edges(idx) {\n                 let target_idx = edge.target();"}, {"sha": "5c0388a020c76b63e3724cb42cc2751e6c254fd3", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -71,7 +71,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let outer_visibility_scope = this.visibility_scope;\n         let source_info = this.source_info(span);\n         for stmt in stmts {\n-            let Stmt { span, kind, opt_destruction_extent } = this.hir.mirror(stmt);\n+            let Stmt { kind, opt_destruction_extent } = this.hir.mirror(stmt);\n             match kind {\n                 StmtKind::Expr { scope, expr } => {\n                     unpack!(block = this.in_opt_scope(\n@@ -83,15 +83,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         }));\n                 }\n                 StmtKind::Let { remainder_scope, init_scope, pattern, initializer } => {\n-                    let tcx = this.hir.tcx();\n-\n                     // Enter the remainder scope, i.e. the bindings' destruction scope.\n                     this.push_scope((remainder_scope, source_info));\n                     let_extent_stack.push(remainder_scope);\n \n                     // Declare the bindings, which may create a visibility scope.\n-                    let remainder_span = remainder_scope.span(&tcx.hir);\n-                    let remainder_span = remainder_span.unwrap_or(span);\n+                    let remainder_span = remainder_scope.span(this.hir.tcx(),\n+                                                              &this.hir.region_maps);\n                     let scope = this.declare_bindings(None, remainder_span, &pattern);\n \n                     // Evaluate the initializer, if present."}, {"sha": "fc6eca466a811b43015bccc7886f15a062f42e3d", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -202,7 +202,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn schedule_drop_for_binding(&mut self, var: NodeId, span: Span) {\n         let local_id = self.var_indices[&var];\n         let var_ty = self.local_decls[local_id].ty;\n-        let extent = self.hir.region_maps.var_scope(var);\n+        let hir_id = self.hir.tcx().hir.node_to_hir_id(var);\n+        let extent = self.hir.region_maps.var_scope(hir_id.local_id);\n         self.schedule_drop(span, extent, &Lvalue::Local(local_id), var_ty);\n     }\n "}, {"sha": "5cced32f7e69bae9f2b94c33ababc0577cdba52b", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -355,8 +355,8 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n         arguments.len(),\n         return_ty);\n \n-    let call_site_extent = CodeExtent::CallSiteScope(body.id());\n-    let arg_extent = CodeExtent::ParameterScope(body.id());\n+    let call_site_extent = CodeExtent::CallSiteScope(body.value.hir_id.local_id);\n+    let arg_extent = CodeExtent::ParameterScope(body.value.hir_id.local_id);\n     let mut block = START_BLOCK;\n     let source_info = builder.source_info(span);\n     unpack!(block = builder.in_scope((call_site_extent, source_info), block, |builder| {"}, {"sha": "2471d8c2c56f7d66fe9710fe402ae3f482de36e2", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -633,8 +633,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 if let DropKind::Value { .. } = drop_kind {\n                     scope.needs_cleanup = true;\n                 }\n-                let tcx = self.hir.tcx();\n-                let extent_span = extent.span(&tcx.hir).unwrap();\n+                let extent_span = extent.span(self.hir.tcx(), &self.hir.region_maps);\n                 // Attribute scope exit drops to scope's closing brace\n                 let scope_end = extent_span.with_lo(extent_span.hi());\n                 scope.drops.push(DropData {"}, {"sha": "8a87751d846c8922446a65ff615f769a254e06d4", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -13,19 +13,18 @@ use hair::cx::Cx;\n use hair::cx::to_ref::ToRef;\n use rustc::middle::region::{BlockRemainder, CodeExtent};\n use rustc::hir;\n-use syntax::ast;\n \n impl<'tcx> Mirror<'tcx> for &'tcx hir::Block {\n     type Output = Block<'tcx>;\n \n     fn make_mirror<'a, 'gcx>(self, cx: &mut Cx<'a, 'gcx, 'tcx>) -> Block<'tcx> {\n         // We have to eagerly translate the \"spine\" of the statements\n         // in order to get the lexical scoping correctly.\n-        let stmts = mirror_stmts(cx, self.id, &*self.stmts);\n-        let opt_destruction_extent = cx.region_maps.opt_destruction_extent(self.id);\n+        let stmts = mirror_stmts(cx, self.hir_id.local_id, &*self.stmts);\n+        let opt_destruction_extent = cx.region_maps.opt_destruction_extent(self.hir_id.local_id);\n         Block {\n             targeted_by_break: self.targeted_by_break,\n-            extent: CodeExtent::Misc(self.id),\n+            extent: CodeExtent::Misc(self.hir_id.local_id),\n             opt_destruction_extent,\n             span: self.span,\n             stmts,\n@@ -35,25 +34,25 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Block {\n }\n \n fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n-                                block_id: ast::NodeId,\n+                                block_id: hir::ItemLocalId,\n                                 stmts: &'tcx [hir::Stmt])\n                                 -> Vec<StmtRef<'tcx>> {\n     let mut result = vec![];\n     for (index, stmt) in stmts.iter().enumerate() {\n-        let opt_dxn_ext = cx.region_maps.opt_destruction_extent(stmt.node.id());\n+        let hir_id = cx.tcx.hir.node_to_hir_id(stmt.node.id());\n+        let opt_dxn_ext = cx.region_maps.opt_destruction_extent(hir_id.local_id);\n         match stmt.node {\n-            hir::StmtExpr(ref expr, id) |\n-            hir::StmtSemi(ref expr, id) => {\n+            hir::StmtExpr(ref expr, _) |\n+            hir::StmtSemi(ref expr, _) => {\n                 result.push(StmtRef::Mirror(Box::new(Stmt {\n-                    span: stmt.span,\n                     kind: StmtKind::Expr {\n-                        scope: CodeExtent::Misc(id),\n+                        scope: CodeExtent::Misc(hir_id.local_id),\n                         expr: expr.to_ref(),\n                     },\n                     opt_destruction_extent: opt_dxn_ext,\n                 })))\n             }\n-            hir::StmtDecl(ref decl, id) => {\n+            hir::StmtDecl(ref decl, _) => {\n                 match decl.node {\n                     hir::DeclItem(..) => {\n                         // ignore for purposes of the MIR\n@@ -69,10 +68,9 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                                         cx.tables(),\n                                                         &local.pat);\n                         result.push(StmtRef::Mirror(Box::new(Stmt {\n-                            span: stmt.span,\n                             kind: StmtKind::Let {\n                                 remainder_scope: remainder_extent,\n-                                init_scope: CodeExtent::Misc(id),\n+                                init_scope: CodeExtent::Misc(hir_id.local_id),\n                                 pattern,\n                                 initializer: local.init.to_ref(),\n                             },\n@@ -90,7 +88,7 @@ pub fn to_expr_ref<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                    block: &'tcx hir::Block)\n                                    -> ExprRef<'tcx> {\n     let block_ty = cx.tables().node_id_to_type(block.hir_id);\n-    let temp_lifetime = cx.region_maps.temporary_scope(block.id);\n+    let temp_lifetime = cx.region_maps.temporary_scope(block.hir_id.local_id);\n     let expr = Expr {\n         ty: block_ty,\n         temp_lifetime,"}, {"sha": "a877c61a47a912b35531d310e24c8a054cee789a", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -25,8 +25,8 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n     type Output = Expr<'tcx>;\n \n     fn make_mirror<'a, 'gcx>(self, cx: &mut Cx<'a, 'gcx, 'tcx>) -> Expr<'tcx> {\n-        let temp_lifetime = cx.region_maps.temporary_scope(self.id);\n-        let expr_extent = CodeExtent::Misc(self.id);\n+        let temp_lifetime = cx.region_maps.temporary_scope(self.hir_id.local_id);\n+        let expr_extent = CodeExtent::Misc(self.hir_id.local_id);\n \n         debug!(\"Expr::make_mirror(): id={}, span={:?}\", self.id, self.span);\n \n@@ -52,7 +52,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n         };\n \n         // Finally, create a destruction scope, if any.\n-        if let Some(extent) = cx.region_maps.opt_destruction_extent(self.id) {\n+        if let Some(extent) = cx.region_maps.opt_destruction_extent(self.hir_id.local_id) {\n             expr = Expr {\n                 temp_lifetime,\n                 ty: expr.ty,\n@@ -125,7 +125,7 @@ fn apply_adjustment<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             // Convert this to a suitable `&foo` and\n             // then an unsafe coercion. Limit the region to be just this\n             // expression.\n-            let region = ty::ReScope(CodeExtent::Misc(hir_expr.id));\n+            let region = ty::ReScope(CodeExtent::Misc(hir_expr.hir_id.local_id));\n             let region = cx.tcx.mk_region(region);\n             expr = Expr {\n                 temp_lifetime,\n@@ -160,7 +160,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                           expr: &'tcx hir::Expr)\n                                           -> Expr<'tcx> {\n     let expr_ty = cx.tables().expr_ty(expr);\n-    let temp_lifetime = cx.region_maps.temporary_scope(expr.id);\n+    let temp_lifetime = cx.region_maps.temporary_scope(expr.hir_id.local_id);\n \n     let kind = match expr.node {\n         // Here comes the interesting stuff:\n@@ -487,7 +487,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             match dest.target_id {\n                 hir::ScopeTarget::Block(target_id) |\n                 hir::ScopeTarget::Loop(hir::LoopIdResult::Ok(target_id)) => ExprKind::Break {\n-                    label: CodeExtent::Misc(target_id),\n+                    label: CodeExtent::Misc(cx.tcx.hir.node_to_hir_id(target_id).local_id),\n                     value: value.to_ref(),\n                 },\n                 hir::ScopeTarget::Loop(hir::LoopIdResult::Err(err)) =>\n@@ -498,7 +498,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             match dest.target_id {\n                 hir::ScopeTarget::Block(_) => bug!(\"cannot continue to blocks\"),\n                 hir::ScopeTarget::Loop(hir::LoopIdResult::Ok(loop_id)) => ExprKind::Continue {\n-                    label: CodeExtent::Misc(loop_id),\n+                    label: CodeExtent::Misc(cx.tcx.hir.node_to_hir_id(loop_id).local_id),\n                 },\n                 hir::ScopeTarget::Loop(hir::LoopIdResult::Err(err)) =>\n                     bug!(\"invalid loop id for continue: {}\", err)\n@@ -585,7 +585,7 @@ fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                  expr: &hir::Expr,\n                                  custom_callee: Option<(DefId, &'tcx Substs<'tcx>)>)\n                                  -> Expr<'tcx> {\n-    let temp_lifetime = cx.region_maps.temporary_scope(expr.id);\n+    let temp_lifetime = cx.region_maps.temporary_scope(expr.hir_id.local_id);\n     let (def_id, substs) = custom_callee.unwrap_or_else(|| {\n         (cx.tables().type_dependent_defs()[expr.hir_id].def_id(),\n          cx.tables().node_substs(expr.hir_id))\n@@ -676,7 +676,7 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                expr: &'tcx hir::Expr,\n                                def: Def)\n                                -> ExprKind<'tcx> {\n-    let temp_lifetime = cx.region_maps.temporary_scope(expr.id);\n+    let temp_lifetime = cx.region_maps.temporary_scope(expr.hir_id.local_id);\n \n     match def {\n         Def::Local(def_id) => {\n@@ -867,7 +867,7 @@ fn overloaded_lvalue<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n     // construct the complete expression `foo()` for the overloaded call,\n     // which will yield the &T type\n-    let temp_lifetime = cx.region_maps.temporary_scope(expr.id);\n+    let temp_lifetime = cx.region_maps.temporary_scope(expr.hir_id.local_id);\n     let fun = method_callee(cx, expr, custom_callee);\n     let ref_expr = Expr {\n         temp_lifetime,\n@@ -896,7 +896,7 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         closure_expr_id: cx.tcx.hir.local_def_id(closure_expr.id).index,\n     };\n     let upvar_capture = cx.tables().upvar_capture(upvar_id);\n-    let temp_lifetime = cx.region_maps.temporary_scope(closure_expr.id);\n+    let temp_lifetime = cx.region_maps.temporary_scope(closure_expr.hir_id.local_id);\n     let var_ty = cx.tables()\n                    .node_id_to_type(cx.tcx.hir.node_to_hir_id(var_node_id));\n     let captured_var = Expr {"}, {"sha": "58051aaecdaab464ae057200a7454b367064a53c", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -46,7 +46,6 @@ pub enum StmtRef<'tcx> {\n \n #[derive(Clone, Debug)]\n pub struct Stmt<'tcx> {\n-    pub span: Span,\n     pub kind: StmtKind<'tcx>,\n     pub opt_destruction_extent: Option<CodeExtent>,\n }"}, {"sha": "872a29e7bc0c56f46ed8649207fbb3f0e0c355ef", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -447,6 +447,7 @@ impl<'b, 'a, 'tcx> TypeVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'b\n             ty::TyProjection(ref proj) => Some(proj.item_def_id),\n             ty::TyFnDef(def_id, ..) |\n             ty::TyClosure(def_id, ..) |\n+            ty::TyGenerator(def_id, ..) |\n             ty::TyAnon(def_id, _) => Some(def_id),\n             _ => None\n         };"}, {"sha": "a4bbedfb26b3874036b07693b7b3cf33ab6f57bc", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -340,7 +340,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             // region obligations that get overlooked.  The right\n             // thing to do is the code below. But we keep this old\n             // pass around temporarily.\n-            let region_maps = RegionMaps::new();\n+            let region_maps = RegionMaps::default();\n             let mut free_regions = FreeRegionMap::new();\n             free_regions.relate_free_regions_from_predicates(&param_env.caller_bounds);\n             infcx.resolve_regions_and_report_errors(impl_m.def_id, &region_maps, &free_regions);"}, {"sha": "fd7dd052cd16d524cf99daf90fdef0bbe29e3dbb", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -114,7 +114,7 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n             return Err(ErrorReported);\n         }\n \n-        let region_maps = RegionMaps::new();\n+        let region_maps = RegionMaps::default();\n         let free_regions = FreeRegionMap::new();\n         infcx.resolve_regions_and_report_errors(drop_impl_did, &region_maps, &free_regions);\n         Ok(())"}, {"sha": "60762134f0ffd884920c38c397bf9b2a57e6e46b", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -13,21 +13,17 @@\n //! is calculated in `rustc_mir::transform::generator` and may be a subset of the\n //! types computed here.\n \n-use log;\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::{self, Body, Pat, PatKind, Expr};\n use rustc::middle::region::{RegionMaps, CodeExtent};\n use rustc::ty::Ty;\n-use syntax::ast::NodeId;\n-use syntax::codemap::Span;\n use std::rc::Rc;\n use super::FnCtxt;\n use util::nodemap::FxHashMap;\n \n struct InteriorVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n-    cache: FxHashMap<NodeId, Option<Span>>,\n     types: FxHashMap<Ty<'tcx>, usize>,\n     region_maps: Rc<RegionMaps>,\n }\n@@ -36,18 +32,15 @@ impl<'a, 'gcx, 'tcx> InteriorVisitor<'a, 'gcx, 'tcx> {\n     fn record(&mut self, ty: Ty<'tcx>, scope: Option<CodeExtent>, expr: Option<&'tcx Expr>) {\n         use syntax_pos::DUMMY_SP;\n \n-        let live_across_yield = scope.map(|s| {\n-            self.fcx.tcx.yield_in_extent(s, &mut self.cache).is_some()\n-        }).unwrap_or(true);\n+        let live_across_yield = scope.map_or(Some(DUMMY_SP), |s| {\n+            self.region_maps.yield_in_scope(s)\n+        });\n \n-        if live_across_yield {\n+        if let Some(span) = live_across_yield {\n             let ty = self.fcx.resolve_type_vars_if_possible(&ty);\n \n-            if log_enabled!(log::LogLevel::Debug) {\n-                let span = scope.map(|s| s.span(&self.fcx.tcx.hir).unwrap_or(DUMMY_SP));\n-                debug!(\"type in expr = {:?}, scope = {:?}, type = {:?}, span = {:?}\",\n-                       expr, scope, ty, span);\n-            }\n+            debug!(\"type in expr = {:?}, scope = {:?}, type = {:?}, span = {:?}\",\n+                   expr, scope, ty, span);\n \n             // Map the type to the number of types added before it\n             let entries = self.types.len();\n@@ -66,7 +59,6 @@ pub fn resolve_interior<'a, 'gcx, 'tcx>(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n     let mut visitor = InteriorVisitor {\n         fcx,\n         types: FxHashMap(),\n-        cache: FxHashMap(),\n         region_maps: fcx.tcx.region_maps(def_id),\n     };\n     intravisit::walk_body(&mut visitor, body);\n@@ -101,7 +93,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'gcx, 'tcx> {\n \n     fn visit_pat(&mut self, pat: &'tcx Pat) {\n         if let PatKind::Binding(..) = pat.node {\n-            let scope = self.region_maps.var_scope(pat.id);\n+            let scope = self.region_maps.var_scope(pat.hir_id.local_id);\n             let ty = self.fcx.tables.borrow().pat_ty(pat);\n             self.record(ty, Some(scope), None);\n         }\n@@ -110,7 +102,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'gcx, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n-        let scope = self.region_maps.temporary_scope(expr.id);\n+        let scope = self.region_maps.temporary_scope(expr.hir_id.local_id);\n         let ty = self.fcx.tables.borrow().expr_ty_adjusted(expr);\n         self.record(ty, scope, Some(expr));\n "}, {"sha": "2fa80a10d12e48929b44a7007cee197c7d713816", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -606,8 +606,9 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n         let tcx = infcx.tcx;\n         let item_id = tcx.hir.as_local_node_id(def_id);\n         let body_id = item_id.and_then(|id| tcx.hir.maybe_body_owned_by(id));\n-        let implicit_region_bound = body_id.map(|body| {\n-            tcx.mk_region(ty::ReScope(CodeExtent::CallSiteScope(body)))\n+        let implicit_region_bound = body_id.map(|body_id| {\n+            let body = tcx.hir.body(body_id);\n+            tcx.mk_region(ty::ReScope(CodeExtent::CallSiteScope(body.value.hir_id.local_id)))\n         });\n \n         Inherited {"}, {"sha": "0cd38a49adef206772a6fc4851ad8772f4a30bc5", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -305,7 +305,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n         let body_id = body.id();\n \n-        let call_site = CodeExtent::CallSiteScope(body_id);\n+        let call_site = CodeExtent::CallSiteScope(body.value.hir_id.local_id);\n         let old_call_site_scope = self.set_call_site_scope(Some(call_site));\n \n         let fn_sig = {\n@@ -330,7 +330,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n         let old_body_id = self.set_body_id(body_id.node_id);\n         self.relate_free_regions(&fn_sig_tys[..], body_id.node_id, span);\n-        self.link_fn_args(CodeExtent::Misc(body_id.node_id), &body.arguments);\n+        self.link_fn_args(CodeExtent::Misc(body.value.hir_id.local_id), &body.arguments);\n         self.visit_body(body);\n         self.visit_region_obligations(body_id.node_id);\n \n@@ -610,11 +610,11 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             // that the lifetime of any regions that appear in a\n             // variable's type enclose at least the variable's scope.\n \n-            let var_scope = self.region_maps.var_scope(id);\n+            let hir_id = self.tcx.hir.node_to_hir_id(id);\n+            let var_scope = self.region_maps.var_scope(hir_id.local_id);\n             let var_region = self.tcx.mk_region(ty::ReScope(var_scope));\n \n             let origin = infer::BindingTypeIsNotValidAtDecl(span);\n-            let hir_id = self.tcx.hir.node_to_hir_id(id);\n             self.type_of_node_must_outlive(origin, hir_id, var_region);\n \n             let typ = self.resolve_node_type(hir_id);\n@@ -668,7 +668,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n         // scope of that expression. This also guarantees basic WF.\n         let expr_ty = self.resolve_node_type(expr.hir_id);\n         // the region corresponding to this expression\n-        let expr_region = self.tcx.node_scope_region(expr.id);\n+        let expr_region = self.tcx.mk_region(ty::ReScope(CodeExtent::Misc(expr.hir_id.local_id)));\n         self.type_must_outlive(infer::ExprTypeIsNotInScope(expr_ty, expr.span),\n                                expr_ty, expr_region);\n \n@@ -950,7 +950,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         // call occurs.\n         //\n         // FIXME(#6268) to support nested method calls, should be callee_id\n-        let callee_scope = CodeExtent::Misc(call_expr.id);\n+        let callee_scope = CodeExtent::Misc(call_expr.hir_id.local_id);\n         let callee_region = self.tcx.mk_region(ty::ReScope(callee_scope));\n \n         debug!(\"callee_region={:?}\", callee_region);\n@@ -1002,7 +1002,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         // expression.\n         self.check_safety_of_rvalue_destructor_if_necessary(cmt.clone(), expr.span);\n \n-        let expr_region = self.tcx.node_scope_region(expr.id);\n+        let expr_region = self.tcx.mk_region(ty::ReScope(CodeExtent::Misc(expr.hir_id.local_id)));\n         for adjustment in adjustments {\n             debug!(\"constrain_adjustments: adjustment={:?}, cmt={:?}\",\n                    adjustment, cmt);\n@@ -1095,7 +1095,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"constrain_index(index_expr=?, indexed_ty={}\",\n                self.ty_to_string(indexed_ty));\n \n-        let r_index_expr = ty::ReScope(CodeExtent::Misc(index_expr.id));\n+        let r_index_expr = ty::ReScope(CodeExtent::Misc(index_expr.hir_id.local_id));\n         if let ty::TyRef(r_ptr, mt) = indexed_ty.sty {\n             match mt.ty.sty {\n                 ty::TySlice(_) | ty::TyStr => {\n@@ -1232,7 +1232,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             adjustment::AutoBorrow::RawPtr(m) => {\n-                let r = self.tcx.node_scope_region(expr.id);\n+                let r = self.tcx.mk_region(ty::ReScope(CodeExtent::Misc(expr.hir_id.local_id)));\n                 self.link_region(expr.span, r, ty::BorrowKind::from_mutbl(m), expr_cmt);\n             }\n         }"}, {"sha": "9cf15e2145d36ff811b202b43b817b98cf17c0ab", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -390,7 +390,7 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n \n         // Finally, resolve all regions.\n-        let region_maps = RegionMaps::new();\n+        let region_maps = RegionMaps::default();\n         let mut free_regions = FreeRegionMap::new();\n         free_regions.relate_free_regions_from_predicates(&param_env.caller_bounds);\n         infcx.resolve_regions_and_report_errors(impl_did, &region_maps, &free_regions);"}, {"sha": "00050bc35782790995fae241a6807331beac4f29", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -12,7 +12,7 @@ path = \"lib.rs\"\n env_logger = { version = \"0.4\", default-features = false }\n log = \"0.3\"\n pulldown-cmark = { version = \"0.0.14\", default-features = false }\n-html-diff = \"0.0.3\"\n+html-diff = \"0.0.4\"\n \n [build-dependencies]\n build_helper = { path = \"../build_helper\" }"}, {"sha": "cc84e340c74f8bf1b6fdd937bb9f19dbdd534262", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 210, "deletions": 35, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -63,7 +63,7 @@ use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use rustc::session::config::nightly_options::is_nightly_build;\n use rustc_data_structures::flock;\n \n-use clean::{self, AttributesExt, GetDefId, SelfTy, Mutability};\n+use clean::{self, AttributesExt, GetDefId, SelfTy, Mutability, Span};\n use doctree;\n use fold::DocFolder;\n use html::escape::Escape;\n@@ -124,6 +124,9 @@ pub struct SharedContext {\n     /// The given user css file which allow to customize the generated\n     /// documentation theme.\n     pub css_file_extension: Option<PathBuf>,\n+    /// Warnings for the user if rendering would differ using different markdown\n+    /// parsers.\n+    pub markdown_warnings: RefCell<Vec<(Span, String, Vec<html_diff::Difference>)>>,\n }\n \n /// Indicates where an external crate can be found.\n@@ -457,6 +460,7 @@ pub fn run(mut krate: clean::Crate,\n             krate: krate.name.clone(),\n         },\n         css_file_extension: css_file_extension.clone(),\n+        markdown_warnings: RefCell::new(vec![]),\n     };\n \n     // If user passed in `--playground-url` arg, we fill in crate name here\n@@ -579,8 +583,102 @@ pub fn run(mut krate: clean::Crate,\n \n     write_shared(&cx, &krate, &*cache, index)?;\n \n+    let scx = cx.shared.clone();\n+\n     // And finally render the whole crate's documentation\n-    cx.krate(krate)\n+    let result = cx.krate(krate);\n+\n+    let markdown_warnings = scx.markdown_warnings.borrow();\n+    if !markdown_warnings.is_empty() {\n+        println!(\"WARNING: documentation for this crate may be rendered \\\n+                  differently using the new Pulldown renderer.\");\n+        println!(\"    See https://github.com/rust-lang/rust/issues/44229 for details.\");\n+        for &(ref span, ref text, ref diffs) in &*markdown_warnings {\n+            println!(\"WARNING: rendering difference in `{}`\", concise_str(text));\n+            println!(\"   --> {}:{}:{}\", span.filename, span.loline, span.locol);\n+            for d in diffs {\n+                render_difference(d);\n+            }\n+        }\n+    }\n+\n+    result\n+}\n+\n+// A short, single-line view of `s`.\n+fn concise_str(s: &str) -> String {\n+    if s.contains('\\n') {\n+        return format!(\"{}...\", s.lines().next().expect(\"Impossible! We just found a newline\"));\n+    }\n+    if s.len() > 70 {\n+        return format!(\"{} ... {}\", &s[..50], &s[s.len()-20..]);\n+    }\n+    s.to_owned()\n+}\n+\n+// Returns short versions of s1 and s2, starting from where the strings differ.\n+fn concise_compared_strs(s1: &str, s2: &str) -> (String, String) {\n+    let s1 = s1.trim();\n+    let s2 = s2.trim();\n+    if !s1.contains('\\n') && !s2.contains('\\n') && s1.len() <= 70 && s2.len() <= 70 {\n+        return (s1.to_owned(), s2.to_owned());\n+    }\n+\n+    let mut start_byte = 0;\n+    for (c1, c2) in s1.chars().zip(s2.chars()) {\n+        if c1 != c2 {\n+            break;\n+        }\n+\n+        start_byte += c1.len_utf8();\n+    }\n+\n+    if start_byte == 0 {\n+        return (concise_str(s1), concise_str(s2));\n+    }\n+\n+    let s1 = &s1[start_byte..];\n+    let s2 = &s2[start_byte..];\n+    (format!(\"...{}\", concise_str(s1)), format!(\"...{}\", concise_str(s2)))\n+}\n+\n+fn render_difference(diff: &html_diff::Difference) {\n+    match *diff {\n+        html_diff::Difference::NodeType { ref elem, ref opposite_elem } => {\n+            println!(\"    {} Types differ: expected: `{}`, found: `{}`\",\n+                     elem.path, elem.element_name, opposite_elem.element_name);\n+        }\n+        html_diff::Difference::NodeName { ref elem, ref opposite_elem } => {\n+            println!(\"    {} Tags differ: expected: `{}`, found: `{}`\",\n+                     elem.path, elem.element_name, opposite_elem.element_name);\n+        }\n+        html_diff::Difference::NodeAttributes { ref elem,\n+                                     ref elem_attributes,\n+                                     ref opposite_elem_attributes,\n+                                     .. } => {\n+            println!(\"    {} Attributes differ in `{}`: expected: `{:?}`, found: `{:?}`\",\n+                     elem.path, elem.element_name, elem_attributes, opposite_elem_attributes);\n+        }\n+        html_diff::Difference::NodeText { ref elem, ref elem_text, ref opposite_elem_text, .. } => {\n+            let (s1, s2) = concise_compared_strs(elem_text, opposite_elem_text);\n+            println!(\"    {} Text differs:\\n        expected: `{}`\\n        found:    `{}`\",\n+                     elem.path, s1, s2);\n+        }\n+        html_diff::Difference::NotPresent { ref elem, ref opposite_elem } => {\n+            if let Some(ref elem) = *elem {\n+                println!(\"    {} One element is missing: expected: `{}`\",\n+                         elem.path, elem.element_name);\n+            } else if let Some(ref elem) = *opposite_elem {\n+                if elem.element_name.is_empty() {\n+                    println!(\"    {} Unexpected element: `{}`\",\n+                             elem.path, concise_str(&elem.element_content));\n+                } else {\n+                    println!(\"    {} Unexpected element `{}`: found: `{}`\",\n+                             elem.path, elem.element_name, concise_str(&elem.element_content));\n+                }\n+            }\n+        }\n+    }\n }\n \n /// Build the search index from the collected metadata\n@@ -1641,47 +1739,92 @@ fn plain_summary_line(s: Option<&str>) -> String {\n fn document(w: &mut fmt::Formatter, cx: &Context, item: &clean::Item) -> fmt::Result {\n     document_stability(w, cx, item)?;\n     let prefix = render_assoc_const_value(item);\n-    document_full(w, item, cx.render_type, &prefix)?;\n+    document_full(w, item, cx, &prefix)?;\n     Ok(())\n }\n \n-fn get_html_diff(w: &mut fmt::Formatter, md_text: &str, render_type: RenderType,\n-                 prefix: &str) -> fmt::Result {\n-    let output = format!(\"{}\", Markdown(md_text, render_type));\n-    let old = format!(\"{}\", Markdown(md_text, match render_type {\n-                                                  RenderType::Hoedown => RenderType::Pulldown,\n-                                                  RenderType::Pulldown => RenderType::Hoedown,\n-                                              }));\n-    let differences = html_diff::get_differences(&output, &old);\n-    if !differences.is_empty() {\n-        println!(\"Differences spotted in {:?}:\\n{}\",\n-                 md_text,\n-                 differences.iter()\n-                            .filter_map(|s| {\n-                                match *s {\n-                                    html_diff::Difference::NodeText { ref elem_text,\n-                                                                      ref opposite_elem_text,\n-                                                                      .. }\n-                                        if elem_text.trim() == opposite_elem_text.trim() => None,\n-                                    _ => Some(format!(\"=> {}\", s.to_string())),\n-                                }\n-                            })\n-                            .collect::<Vec<String>>()\n-                            .join(\"\\n\"));\n-    }\n+/// Render md_text as markdown. Warns the user if there are difference in\n+/// rendering between Pulldown and Hoedown.\n+fn render_markdown(w: &mut fmt::Formatter,\n+                   md_text: &str,\n+                   span: Span,\n+                   render_type: RenderType,\n+                   prefix: &str,\n+                   scx: &SharedContext)\n+                   -> fmt::Result {\n+    let hoedown_output = format!(\"{}\", Markdown(md_text, RenderType::Hoedown));\n+    // We only emit warnings if the user has opted-in to Pulldown rendering.\n+    let output = if render_type == RenderType::Pulldown {\n+        let pulldown_output = format!(\"{}\", Markdown(md_text, RenderType::Pulldown));\n+        let differences = html_diff::get_differences(&pulldown_output, &hoedown_output);\n+        let differences = differences.into_iter()\n+            .filter(|s| {\n+                match *s {\n+                    html_diff::Difference::NodeText { ref elem_text,\n+                                                      ref opposite_elem_text,\n+                                                      .. }\n+                        if match_non_whitespace(elem_text, opposite_elem_text) => false,\n+                    _ => true,\n+                }\n+            })\n+            .collect::<Vec<_>>();\n+\n+        if !differences.is_empty() {\n+            scx.markdown_warnings.borrow_mut().push((span, md_text.to_owned(), differences));\n+        }\n+\n+        pulldown_output\n+    } else {\n+        hoedown_output\n+    };\n+\n     write!(w, \"<div class='docblock'>{}{}</div>\", prefix, output)\n }\n \n+// Returns true iff s1 and s2 match, ignoring whitespace.\n+fn match_non_whitespace(s1: &str, s2: &str) -> bool {\n+    let s1 = s1.trim();\n+    let s2 = s2.trim();\n+    let mut cs1 = s1.chars();\n+    let mut cs2 = s2.chars();\n+    while let Some(c1) = cs1.next() {\n+        if c1.is_whitespace() {\n+            continue;\n+        }\n+\n+        loop {\n+            if let Some(c2) = cs2.next() {\n+                if !c2.is_whitespace() {\n+                    if c1 != c2 {\n+                        return false;\n+                    }\n+                    break;\n+                }\n+            } else {\n+                return false;\n+            }\n+        }\n+    }\n+\n+    while let Some(c2) = cs2.next() {\n+        if !c2.is_whitespace() {\n+            return false;\n+        }\n+    }\n+\n+    true\n+}\n+\n fn document_short(w: &mut fmt::Formatter, item: &clean::Item, link: AssocItemLink,\n-                  render_type: RenderType, prefix: &str) -> fmt::Result {\n+                  cx: &Context, prefix: &str) -> fmt::Result {\n     if let Some(s) = item.doc_value() {\n         let markdown = if s.contains('\\n') {\n             format!(\"{} [Read more]({})\",\n                     &plain_summary_line(Some(s)), naive_assoc_href(item, link))\n         } else {\n             format!(\"{}\", &plain_summary_line(Some(s)))\n         };\n-        get_html_diff(w, &markdown, render_type, prefix)?;\n+        render_markdown(w, &markdown, item.source.clone(), cx.render_type, prefix, &cx.shared)?;\n     } else if !prefix.is_empty() {\n         write!(w, \"<div class='docblock'>{}</div>\", prefix)?;\n     }\n@@ -1703,9 +1846,9 @@ fn render_assoc_const_value(item: &clean::Item) -> String {\n }\n \n fn document_full(w: &mut fmt::Formatter, item: &clean::Item,\n-                 render_type: RenderType, prefix: &str) -> fmt::Result {\n+                 cx: &Context, prefix: &str) -> fmt::Result {\n     if let Some(s) = item.doc_value() {\n-        get_html_diff(w, s, render_type, prefix)?;\n+        render_markdown(w, s, item.source.clone(), cx.render_type, prefix, &cx.shared)?;\n     } else if !prefix.is_empty() {\n         write!(w, \"<div class='docblock'>{}</div>\", prefix)?;\n     }\n@@ -3104,20 +3247,20 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n                         // because impls can't have a stability.\n                         document_stability(w, cx, it)?;\n                         if item.doc_value().is_some() {\n-                            document_full(w, item, cx.render_type, &prefix)?;\n+                            document_full(w, item, cx, &prefix)?;\n                         } else {\n                             // In case the item isn't documented,\n                             // provide short documentation from the trait.\n-                            document_short(w, it, link, cx.render_type, &prefix)?;\n+                            document_short(w, it, link, cx, &prefix)?;\n                         }\n                     }\n                 } else {\n                     document_stability(w, cx, item)?;\n-                    document_full(w, item, cx.render_type, &prefix)?;\n+                    document_full(w, item, cx, &prefix)?;\n                 }\n             } else {\n                 document_stability(w, cx, item)?;\n-                document_short(w, item, link, cx.render_type, &prefix)?;\n+                document_short(w, item, link, cx, &prefix)?;\n             }\n         }\n         Ok(())\n@@ -3586,3 +3729,35 @@ fn test_name_sorting() {\n     sorted.sort_by_key(|&s| name_key(s));\n     assert_eq!(names, sorted);\n }\n+\n+#[cfg(test)]\n+#[test]\n+fn test_match_non_whitespace() {\n+    assert!(match_non_whitespace(\"\", \"\"));\n+    assert!(match_non_whitespace(\"  \", \"\"));\n+    assert!(match_non_whitespace(\"\", \"  \"));\n+\n+    assert!(match_non_whitespace(\"a\", \"a\"));\n+    assert!(match_non_whitespace(\" a \", \"a\"));\n+    assert!(match_non_whitespace(\"a\", \"  a\"));\n+    assert!(match_non_whitespace(\"abc\", \"abc\"));\n+    assert!(match_non_whitespace(\"abc\", \" abc \"));\n+    assert!(match_non_whitespace(\"abc  \", \"abc\"));\n+    assert!(match_non_whitespace(\"abc xyz\", \"abc xyz\"));\n+    assert!(match_non_whitespace(\"abc xyz\", \"abc\\nxyz\"));\n+    assert!(match_non_whitespace(\"abc xyz\", \"abcxyz\"));\n+    assert!(match_non_whitespace(\"abcxyz\", \"abc xyz\"));\n+    assert!(match_non_whitespace(\"abc    xyz \", \" abc xyz\\n\"));\n+\n+    assert!(!match_non_whitespace(\"a\", \"b\"));\n+    assert!(!match_non_whitespace(\" a \", \"c\"));\n+    assert!(!match_non_whitespace(\"a\", \"  aa\"));\n+    assert!(!match_non_whitespace(\"abc\", \"ac\"));\n+    assert!(!match_non_whitespace(\"abc\", \" adc \"));\n+    assert!(!match_non_whitespace(\"abc  \", \"abca\"));\n+    assert!(!match_non_whitespace(\"abc xyz\", \"abc xy\"));\n+    assert!(!match_non_whitespace(\"abc xyz\", \"bc\\nxyz\"));\n+    assert!(!match_non_whitespace(\"abc xyz\", \"abc.xyz\"));\n+    assert!(!match_non_whitespace(\"abcxyz\", \"abc.xyz\"));\n+    assert!(!match_non_whitespace(\"abc    xyz \", \" abc xyz w\"));\n+}"}, {"sha": "ca55d0e5d2a8ef4cfbc6b64be5c5bb8a424f21d9", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -658,11 +658,13 @@ h3 > .collapse-toggle, h4 > .collapse-toggle {\n \n .toggle-wrapper {\n \tposition: relative;\n+\tmargin-top: 5px;\n }\n \n .toggle-wrapper.collapsed {\n-\theight: 1em;\n+\theight: 25px;\n \ttransition: height .2s;\n+\tmargin-bottom: .6em;\n }\n \n .collapse-toggle > .inner {\n@@ -704,14 +706,16 @@ span.since {\n \tmargin-top: 5px;\n }\n \n-.variant + .toggle-wrapper > a {\n-\tmargin-top: 5px;\n-}\n-\n .sub-variant, .sub-variant > h3 {\n \tmargin-top: 0 !important;\n }\n \n+.toggle-label {\n+\tdisplay: inline-block;\n+\tmargin-left: 4px;\n+\tmargin-top: 3px;\n+}\n+\n .enum > .toggle-wrapper + .docblock, .struct > .toggle-wrapper + .docblock {\n \tmargin-left: 30px;\n \tmargin-bottom: 20px;"}, {"sha": "074ab3ebd8fdca9b045f86672f04f093abf2704b", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -212,7 +212,7 @@\n //! # }\n //! ```\n //!\n-//! [functions-list]: #functions-2\n+//! [functions-list]: #functions-1\n //!\n //! ## io::Result\n //!"}, {"sha": "33bf0d68126d4c43f2ba4b24cc5cabcb102ae54c", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -322,14 +322,12 @@\n // if the user has disabled jemalloc in `./configure`).\n // `force_alloc_system` is *only* intended as a workaround for local rebuilds\n // with a rustc without jemalloc.\n-// The not(stage0+msvc) gates will only last until the next stage0 bump\n-#![cfg_attr(all(\n-        not(all(stage0, target_env = \"msvc\")),\n-        any(stage0, feature = \"force_alloc_system\")),\n-    feature(global_allocator))]\n-#[cfg(all(\n-    not(all(stage0, target_env = \"msvc\")),\n-    any(stage0, feature = \"force_alloc_system\")))]\n+// FIXME(#44236) shouldn't need MSVC logic\n+#![cfg_attr(all(not(target_env = \"msvc\"),\n+                any(stage0, feature = \"force_alloc_system\")),\n+            feature(global_allocator))]\n+#[cfg(all(not(target_env = \"msvc\"),\n+          any(stage0, feature = \"force_alloc_system\")))]\n #[global_allocator]\n static ALLOC: alloc_system::System = alloc_system::System;\n "}, {"sha": "72d561fae3bd9c249cdc2c7e563436f3e831e97b", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -14,16 +14,6 @@\n //! library. Each macro is available for use when linking against the standard\n //! library.\n \n-#[macro_export]\n-// This stability attribute is totally useless.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(stage0)]\n-macro_rules! __rust_unstable_column {\n-    () => {\n-        column!()\n-    }\n-}\n-\n /// The entry point for panic of Rust threads.\n ///\n /// This allows a program to to terminate immediately and provide feedback"}, {"sha": "e1d7a2531b6c92b15884d0d3a0a544975498aed7", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -767,7 +767,7 @@ impl hash::Hash for SocketAddrV6 {\n ///\n /// let stream = TcpStream::connect((\"127.0.0.1\", 443));\n /// // or\n-/// let stream = TcpStream::connect(\"127.0.0.1.443\");\n+/// let stream = TcpStream::connect(\"127.0.0.1:443\");\n /// // or\n /// let stream = TcpStream::connect((Ipv4Addr::new(127, 0, 0, 1), 443));\n /// ```"}, {"sha": "5467eff202b02847cd45ca92966ffbd7ce6df08e", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 44, "deletions": 4, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -111,15 +111,18 @@ impl TcpStream {\n     /// `addr` is an address of the remote host. Anything which implements\n     /// [`ToSocketAddrs`] trait can be supplied for the address; see this trait\n     /// documentation for concrete examples.\n-    /// In case [`ToSocketAddrs::to_socket_addrs()`] returns more than one entry,\n-    /// then the first valid and reachable address is used.\n+    ///\n+    /// If `addr` yields multiple addresses, `connect` will be attempted with\n+    /// each of the addresses until a connection is successful. If none of\n+    /// the addresses result in a successful connection, the error returned from\n+    /// the last connection attempt (the last address) is returned.\n     ///\n     /// [`ToSocketAddrs`]: ../../std/net/trait.ToSocketAddrs.html\n-    /// [`ToSocketAddrs::to_socket_addrs()`]:\n-    /// ../../std/net/trait.ToSocketAddrs.html#tymethod.to_socket_addrs\n     ///\n     /// # Examples\n     ///\n+    /// Open a TCP connection to `127.0.0.1:8080`:\n+    ///\n     /// ```no_run\n     /// use std::net::TcpStream;\n     ///\n@@ -129,6 +132,23 @@ impl TcpStream {\n     ///     println!(\"Couldn't connect to server...\");\n     /// }\n     /// ```\n+    ///\n+    /// Open a TCP connection to `127.0.0.1:8080`. If the connection fails, open\n+    /// a TCP connection to `127.0.0.1:8081`:\n+    ///\n+    /// ```no_run\n+    /// use std::net::{SocketAddr, TcpStream};\n+    ///\n+    /// let addrs = [\n+    ///     SocketAddr::from(([127, 0, 0, 1], 8080)),\n+    ///     SocketAddr::from(([127, 0, 0, 1], 8081)),\n+    /// ];\n+    /// if let Ok(stream) = TcpStream::connect(&addrs[..]) {\n+    ///     println!(\"Connected to the server!\");\n+    /// } else {\n+    ///     println!(\"Couldn't connect to server...\");\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn connect<A: ToSocketAddrs>(addr: A) -> io::Result<TcpStream> {\n         super::each_addr(addr, net_imp::TcpStream::connect).map(TcpStream)\n@@ -557,16 +577,36 @@ impl TcpListener {\n     /// The address type can be any implementor of [`ToSocketAddrs`] trait. See\n     /// its documentation for concrete examples.\n     ///\n+    /// If `addr` yields multiple addresses, `bind` will be attempted with\n+    /// each of the addresses until one succeeds and returns the listener. If\n+    /// none of the addresses succeed in creating a listener, the error returned\n+    /// from the last attempt (the last address) is returned.\n+    ///\n     /// [`local_addr`]: #method.local_addr\n     /// [`ToSocketAddrs`]: ../../std/net/trait.ToSocketAddrs.html\n     ///\n     /// # Examples\n     ///\n+    /// Create a TCP listener bound to `127.0.0.1:80`:\n+    ///\n     /// ```no_run\n     /// use std::net::TcpListener;\n     ///\n     /// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n     /// ```\n+    ///\n+    /// Create a TCP listener bound to `127.0.0.1:80`. If that fails, create a\n+    /// TCP listener bound to `127.0.0.1:443`:\n+    ///\n+    /// ```no_run\n+    /// use std::net::{SocketAddr, TcpListener};\n+    ///\n+    /// let addrs = [\n+    ///     SocketAddr::from(([127, 0, 0, 1], 80)),\n+    ///     SocketAddr::from(([127, 0, 0, 1], 443)),\n+    /// ];\n+    /// let listener = TcpListener::bind(&addrs[..]).unwrap();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn bind<A: ToSocketAddrs>(addr: A) -> io::Result<TcpListener> {\n         super::each_addr(addr, net_imp::TcpListener::bind).map(TcpListener)"}, {"sha": "35001833383c0253da750d37385d77e52cb42a0c", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 48, "deletions": 2, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -69,14 +69,34 @@ impl UdpSocket {\n     /// The address type can be any implementor of [`ToSocketAddrs`] trait. See\n     /// its documentation for concrete examples.\n     ///\n+    /// If `addr` yields multiple addresses, `bind` will be attempted with\n+    /// each of the addresses until one succeeds and returns the socket. If none\n+    /// of the addresses succeed in creating a socket, the error returned from\n+    /// the last attempt (the last address) is returned.\n+    ///\n     /// [`ToSocketAddrs`]: ../../std/net/trait.ToSocketAddrs.html\n     ///\n     /// # Examples\n     ///\n+    /// Create a UDP socket bound to `127.0.0.1:3400`:\n+    ///\n     /// ```no_run\n     /// use std::net::UdpSocket;\n     ///\n-    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:3400\").expect(\"couldn't bind to address\");\n+    /// ```\n+    ///\n+    /// Create a UDP socket bound to `127.0.0.1:3400`. If the socket cannot be\n+    /// bound to that address, create a UDP socket bound to `127.0.0.1:3401`:\n+    ///\n+    /// ```no_run\n+    /// use std::net::{SocketAddr, UdpSocket};\n+    ///\n+    /// let addrs = [\n+    ///     SocketAddr::from(([127, 0, 0, 1], 3400)),\n+    ///     SocketAddr::from(([127, 0, 0, 1], 3401)),\n+    /// ];\n+    /// let socket = UdpSocket::bind(&addrs[..]).expect(\"couldn't bind to address\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn bind<A: ToSocketAddrs>(addr: A) -> io::Result<UdpSocket> {\n@@ -130,6 +150,9 @@ impl UdpSocket {\n     /// Address type can be any implementor of [`ToSocketAddrs`] trait. See its\n     /// documentation for concrete examples.\n     ///\n+    /// It is possible for `addr` to yield multiple addresses, but `send_to`\n+    /// will only send data to the first address yielded by `addr`.\n+    ///\n     /// This will return an error when the IP version of the local socket\n     /// does not match that returned from [`ToSocketAddrs`].\n     ///\n@@ -562,14 +585,37 @@ impl UdpSocket {\n     /// `recv` syscalls to be used to send data and also applies filters to only\n     /// receive data from the specified address.\n     ///\n+    /// If `addr` yields multiple addresses, `connect` will be attempted with\n+    /// each of the addresses until a connection is successful. If none of\n+    /// the addresses are able to be connected, the error returned from the\n+    /// last connection attempt (the last address) is returned.\n+    ///\n     /// # Examples\n     ///\n+    /// Create a UDP socket bound to `127.0.0.1:3400` and connect the socket to\n+    /// `127.0.0.1:8080`:\n+    ///\n     /// ```no_run\n     /// use std::net::UdpSocket;\n     ///\n-    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:3400\").expect(\"couldn't bind to address\");\n     /// socket.connect(\"127.0.0.1:8080\").expect(\"connect function failed\");\n     /// ```\n+    ///\n+    /// Create a UDP socket bound to `127.0.0.1:3400` and connect the socket to\n+    /// `127.0.0.1:8080`. If that connection fails, then the UDP socket will\n+    /// connect to `127.0.0.1:8081`:\n+    ///\n+    /// ```no_run\n+    /// use std::net::{SocketAddr, UdpSocket};\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:3400\").expect(\"couldn't bind to address\");\n+    /// let connect_addrs = [\n+    ///     SocketAddr::from(([127, 0, 0, 1], 8080)),\n+    ///     SocketAddr::from(([127, 0, 0, 1], 8081)),\n+    /// ];\n+    /// socket.connect(&connect_addrs[..]).expect(\"connect function failed\");\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn connect<A: ToSocketAddrs>(&self, addr: A) -> io::Result<()> {\n         super::each_addr(addr, |addr| self.0.connect(addr))"}, {"sha": "80ce15944a5c374cdcb99322bc998ee2880a4f0c", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -522,40 +522,6 @@ pub fn begin_panic_fmt(msg: &fmt::Arguments,\n     begin_panic(s, file_line_col)\n }\n \n-// FIXME: In PR #42938, we have added the column as info passed to the panic\n-// handling code. For this, we want to break the ABI of begin_panic.\n-// This is not possible to do directly, as the stage0 compiler is hardcoded\n-// to emit a call to begin_panic in src/libsyntax/ext/build.rs, only\n-// with the file and line number being passed, but not the colum number.\n-// By changing the compiler source, we can only affect behaviour of higher\n-// stages. We need to perform the switch over two stage0 replacements, using\n-// a temporary function begin_panic_new while performing the switch:\n-// 0. Before the current switch, we told stage1 onward to emit a call\n-//    to begin_panic_new.\n-// 1. Right now, stage0 calls begin_panic_new with the new ABI,\n-//    begin_panic stops being used. We have changed begin_panic to\n-//    the new ABI, and started to emit calls to begin_panic in higher\n-//    stages again, this time with the new ABI.\n-// 2. After the second SNAP, stage0 calls begin_panic with the new ABI,\n-//    and we can remove the temporary begin_panic_new function.\n-\n-/// This is the entry point of panicking for panic!() and assert!().\n-#[cfg(stage0)]\n-#[unstable(feature = \"libstd_sys_internals\",\n-           reason = \"used by the panic! macro\",\n-           issue = \"0\")]\n-#[inline(never)] #[cold] // avoid code bloat at the call sites as much as possible\n-pub fn begin_panic_new<M: Any + Send>(msg: M, file_line_col: &(&'static str, u32, u32)) -> ! {\n-    // Note that this should be the only allocation performed in this code path.\n-    // Currently this means that panic!() on OOM will invoke this code path,\n-    // but then again we're not really ready for panic on OOM anyway. If\n-    // we do start doing this, then we should propagate this allocation to\n-    // be performed in the parent of this thread instead of the thread that's\n-    // panicking.\n-\n-    rust_panic_with_hook(Box::new(msg), file_line_col)\n-}\n-\n /// This is the entry point of panicking for panic!() and assert!().\n #[unstable(feature = \"libstd_sys_internals\",\n            reason = \"used by the panic! macro\","}, {"sha": "06fd838ea06d966b047f8e1a257d1acd253433cd", "filename": "src/libstd/rt.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibstd%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibstd%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -25,8 +25,6 @@\n \n \n // Reexport some of our utilities which are expected by other crates.\n-#[cfg(stage0)]\n-pub use panicking::begin_panic_new;\n pub use panicking::{begin_panic, begin_panic_fmt, update_panic_count};\n \n #[cfg(not(test))]"}, {"sha": "02347bf4906a6c21f475ade14a88ed791b693911", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -157,7 +157,7 @@ macro_rules! thread_local {\n            issue = \"0\")]\n #[macro_export]\n #[allow_internal_unstable]\n-#[cfg_attr(not(stage0), allow_internal_unsafe)]\n+#[allow_internal_unsafe]\n macro_rules! __thread_local_inner {\n     ($(#[$attr:meta])* $vis:vis $name:ident, $t:ty, $init:expr) => {\n         $(#[$attr])* $vis static $name: $crate::thread::LocalKey<$t> = {\n@@ -394,9 +394,6 @@ pub mod fast {\n         }\n     }\n \n-    #[cfg(stage0)]\n-    unsafe impl<T> ::marker::Sync for Key<T> { }\n-\n     impl<T> Key<T> {\n         pub const fn new() -> Key<T> {\n             Key {"}, {"sha": "d08373334f1b9e4fcad05e5ea2c9e56339f81693", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -3025,7 +3025,10 @@ impl<'a> Parser<'a> {\n         let decl = self.parse_fn_block_decl()?;\n         let decl_hi = self.prev_span;\n         let body = match decl.output {\n-            FunctionRetTy::Default(_) => self.parse_expr()?,\n+            FunctionRetTy::Default(_) => {\n+                let restrictions = self.restrictions - RESTRICTION_STMT_EXPR;\n+                self.parse_expr_res(restrictions, None)?\n+            },\n             _ => {\n                 // If an explicit return type is given, require a\n                 // block to appear (RFC 968)."}, {"sha": "4d3db15ef29dbd8fead00742db3303c032284af2", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -115,6 +115,12 @@ impl Symbol {\n     }\n }\n \n+impl<'a> From<&'a str> for Symbol {\n+    fn from(string: &'a str) -> Symbol {\n+        Symbol::intern(string)\n+    }\n+}\n+\n impl fmt::Debug for Symbol {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{}({})\", self, self.0)"}, {"sha": "892679c1929162e9dc611d9e657dbaa77856370a", "filename": "src/stage0.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Fstage0.txt", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Fstage0.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstage0.txt?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -12,7 +12,7 @@\n # source tarball for a stable release you'll likely see `1.x.0` for rustc and\n # `0.x.0` for Cargo where they were released on `date`.\n \n-date: 2017-07-18\n+date: 2017-08-29\n rustc: beta\n cargo: beta\n "}, {"sha": "7be677c184b735a9478bbc7e9b6d86ed55afb18a", "filename": "src/test/mir-opt/end_region_1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Ftest%2Fmir-opt%2Fend_region_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Ftest%2Fmir-opt%2Fend_region_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_1.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -22,16 +22,16 @@ fn main() {\n // START rustc.node4.SimplifyCfg-qualify-consts.after.mir\n //     let mut _0: ();\n //     let _1: i32;\n-//     let _2: &'6_1rce i32;\n+//     let _2: &'10_1rce i32;\n //\n //     bb0: {\n //         StorageLive(_1);\n //         _1 = const 3i32;\n //         StorageLive(_2);\n-//         _2 = &'6_1rce _1;\n+//         _2 = &'10_1rce _1;\n //         _0 = ();\n //         StorageDead(_2);\n-//         EndRegion('6_1rce);\n+//         EndRegion('10_1rce);\n //         StorageDead(_1);\n //         return;\n //     }"}, {"sha": "2cb9b38e7bb94928390385e5b2d9c2abb88393e8", "filename": "src/test/mir-opt/end_region_2.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Ftest%2Fmir-opt%2Fend_region_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Ftest%2Fmir-opt%2Fend_region_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_2.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -27,8 +27,8 @@ fn main() {\n // START rustc.node4.SimplifyCfg-qualify-consts.after.mir\n //     let mut _0: ();\n //     let _2: bool;\n-//     let _3: &'7_1rce bool;\n-//     let _7: &'7_3rce bool;\n+//     let _3: &'23_1rce bool;\n+//     let _7: &'23_3rce bool;\n //     let mut _4: ();\n //     let mut _5: bool;\n //     bb0: {\n@@ -38,7 +38,7 @@ fn main() {\n //         StorageLive(_2);\n //         _2 = const true;\n //         StorageLive(_3);\n-//         _3 = &'7_1rce _2;\n+//         _3 = &'23_1rce _2;\n //         StorageLive(_5);\n //         _5 = _2;\n //         switchInt(_5) -> [0u8: bb3, otherwise: bb2];\n@@ -47,19 +47,19 @@ fn main() {\n //         _0 = ();\n //         StorageDead(_5);\n //         StorageDead(_3);\n-//         EndRegion('7_1rce);\n+//         EndRegion('23_1rce);\n //         StorageDead(_2);\n //         return;\n //     }\n //     bb3: {\n //         StorageDead(_5);\n //         StorageLive(_7);\n-//         _7 = &'7_3rce _2;\n+//         _7 = &'23_3rce _2;\n //         _1 = ();\n //         StorageDead(_7);\n-//         EndRegion('7_3rce);\n+//         EndRegion('23_3rce);\n //         StorageDead(_3);\n-//         EndRegion('7_1rce);\n+//         EndRegion('23_1rce);\n //         StorageDead(_2);\n //         goto -> bb1;\n //     }"}, {"sha": "001bb9c1a02849749695657b121e35df195e4557", "filename": "src/test/mir-opt/end_region_3.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Ftest%2Fmir-opt%2Fend_region_3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Ftest%2Fmir-opt%2Fend_region_3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_3.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -28,8 +28,8 @@ fn main() {\n // START rustc.node4.SimplifyCfg-qualify-consts.after.mir\n //     let mut _0: ();\n //     let mut _1: bool;\n-//     let _3: &'9_1rce bool;\n-//     let _7: &'9_3rce bool;\n+//     let _3: &'26_1rce bool;\n+//     let _7: &'26_3rce bool;\n //     let mut _2: ();\n //     let mut _4: ();\n //     let mut _5: bool;\n@@ -41,7 +41,7 @@ fn main() {\n //     bb1: {\n //         _1 = const true;\n //         StorageLive(_3);\n-//         _3 = &'9_1rce _1;\n+//         _3 = &'26_1rce _1;\n //         StorageLive(_5);\n //         _5 = _1;\n //         switchInt(_5) -> [0u8: bb3, otherwise: bb2];\n@@ -50,20 +50,20 @@ fn main() {\n //         _0 = ();\n //         StorageDead(_5);\n //         StorageDead(_3);\n-//         EndRegion('9_1rce);\n+//         EndRegion('26_1rce);\n //         StorageDead(_1);\n //         return;\n //     }\n //     bb3: {\n //         _4 = ();\n //         StorageDead(_5);\n //         StorageLive(_7);\n-//         _7 = &'9_3rce _1;\n+//         _7 = &'26_3rce _1;\n //         _2 = ();\n //         StorageDead(_7);\n-//         EndRegion('9_3rce);\n+//         EndRegion('26_3rce);\n //         StorageDead(_3);\n-//         EndRegion('9_1rce);\n+//         EndRegion('26_1rce);\n //         goto -> bb1;\n //     }\n // END rustc.node4.SimplifyCfg-qualify-consts.after.mir"}, {"sha": "8c854ce87a2c6b100b2e398f73190633b420aa72", "filename": "src/test/mir-opt/end_region_4.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Ftest%2Fmir-opt%2Fend_region_4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Ftest%2Fmir-opt%2Fend_region_4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_4.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -33,8 +33,8 @@ fn foo(i: i32) {\n //     let mut _0: ();\n //     let _1: D;\n //     let _2: i32;\n-//     let _3: &'6_2rce i32;\n-//     let _6: &'6_4rce i32;\n+//     let _3: &'26_2rce i32;\n+//     let _6: &'26_4rce i32;\n //     let mut _4: ();\n //     let mut _5: i32;\n //     bb0: {\n@@ -43,28 +43,28 @@ fn foo(i: i32) {\n //         StorageLive(_2);\n //         _2 = const 0i32;\n //         StorageLive(_3);\n-//         _3 = &'6_2rce _2;\n+//         _3 = &'26_2rce _2;\n //         StorageLive(_5);\n //         _5 = (*_3);\n //         _4 = const foo(_5) -> [return: bb1, unwind: bb3];\n //     }\n //     bb1: {\n //         StorageDead(_5);\n //         StorageLive(_6);\n-//         _6 = &'6_4rce _2;\n+//         _6 = &'26_4rce _2;\n //         _0 = ();\n //         StorageDead(_6);\n-//         EndRegion('6_4rce);\n+//         EndRegion('26_4rce);\n //         StorageDead(_3);\n-//         EndRegion('6_2rce);\n+//         EndRegion('26_2rce);\n //         StorageDead(_2);\n //         drop(_1) -> bb4;\n //     }\n //     bb2: {\n //         resume;\n //     }\n //     bb3: {\n-//         EndRegion('6_2rce);\n+//         EndRegion('26_2rce);\n //         drop(_1) -> bb2;\n //     }\n //     bb4: {"}, {"sha": "ae1b4e2e83abb9ed22d052a6f4b73e1f2edb9859", "filename": "src/test/mir-opt/end_region_5.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Ftest%2Fmir-opt%2Fend_region_5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Ftest%2Fmir-opt%2Fend_region_5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_5.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -31,29 +31,29 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n //     let mut _0: ();\n //     let _1: D;\n //     let mut _2: ();\n-//     let mut _3: [closure@NodeId(18) d:&'19mce D];\n-//     let mut _4: &'19mce D;\n+//     let mut _3: [closure@NodeId(18) d:&'14mce D];\n+//     let mut _4: &'14mce D;\n //     bb0: {\n //         StorageLive(_1);\n //         _1 = D::{{constructor}}(const 0i32,);\n //         StorageLive(_3);\n //         StorageLive(_4);\n-//         _4 = &'19mce _1;\n+//         _4 = &'14mce _1;\n //         _3 = [closure@NodeId(18)] { d: _4 };\n //         StorageDead(_4);\n //         _2 = const foo(_3) -> [return: bb1, unwind: bb3];\n //     }\n //     bb1: {\n //         StorageDead(_3);\n-//         EndRegion('19mce);\n+//         EndRegion('14mce);\n //         _0 = ();\n //         drop(_1) -> bb4;\n //     }\n //     bb2: {\n //         resume;\n //     }\n //     bb3: {\n-//         EndRegion('19mce);\n+//         EndRegion('14mce);\n //         drop(_1) -> bb2;\n //     }\n //     bb4: {\n@@ -64,13 +64,13 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n // END rustc.node4.SimplifyCfg-qualify-consts.after.mir\n \n // START rustc.node18.SimplifyCfg-qualify-consts.after.mir\n-// fn main::{{closure}}(_1: [closure@NodeId(18) d:&'19mce D]) -> i32 {\n+// fn main::{{closure}}(_1: [closure@NodeId(18) d:&'14mce D]) -> i32 {\n //    let mut _0: i32;\n //    let mut _2: i32;\n //\n //    bb0: {\n //        StorageLive(_2);\n-//        _2 = ((*(_1.0: &'19mce D)).0: i32);\n+//        _2 = ((*(_1.0: &'14mce D)).0: i32);\n //        _0 = _2;\n //        StorageDead(_2);\n //        return;"}, {"sha": "8054b64400669c05f5cebf9d4a920ec6a612b1b9", "filename": "src/test/mir-opt/end_region_6.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Ftest%2Fmir-opt%2Fend_region_6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Ftest%2Fmir-opt%2Fend_region_6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_6.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -31,29 +31,29 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n //     let mut _0: ();\n //     let _1: D;\n //     let mut _2: ();\n-//     let mut _3: [closure@NodeId(22) d:&'23mce D];\n-//     let mut _4: &'23mce D;\n+//     let mut _3: [closure@NodeId(22) d:&'19mce D];\n+//     let mut _4: &'19mce D;\n //     bb0: {\n //         StorageLive(_1);\n //         _1 = D::{{constructor}}(const 0i32,);\n //         StorageLive(_3);\n //         StorageLive(_4);\n-//         _4 = &'23mce _1;\n+//         _4 = &'19mce _1;\n //         _3 = [closure@NodeId(22)] { d: _4 };\n //         StorageDead(_4);\n //         _2 = const foo(_3) -> [return: bb1, unwind: bb3];\n //     }\n //     bb1: {\n //         StorageDead(_3);\n-//         EndRegion('23mce);\n+//         EndRegion('19mce);\n //         _0 = ();\n //         drop(_1) -> bb4;\n //     }\n //     bb2: {\n //         resume;\n //     }\n //     bb3: {\n-//         EndRegion('23mce);\n+//         EndRegion('19mce);\n //         drop(_1) -> bb2;\n //     }\n //     bb4: {\n@@ -63,20 +63,20 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n // END rustc.node4.SimplifyCfg-qualify-consts.after.mir\n \n // START rustc.node22.SimplifyCfg-qualify-consts.after.mir\n-// fn main::{{closure}}(_1: [closure@NodeId(22) d:&'23mce D]) -> i32 {\n+// fn main::{{closure}}(_1: [closure@NodeId(22) d:&'19mce D]) -> i32 {\n //     let mut _0: i32;\n-//     let _2: &'14_0rce D;\n+//     let _2: &'15_0rce D;\n //     let mut _3: i32;\n //\n //     bb0: {\n //         StorageLive(_2);\n-//         _2 = &'14_0rce (*(_1.0: &'23mce D));\n+//         _2 = &'15_0rce (*(_1.0: &'19mce D));\n //         StorageLive(_3);\n //         _3 = ((*_2).0: i32);\n //         _0 = _3;\n //         StorageDead(_3);\n //         StorageDead(_2);\n-//         EndRegion('14_0rce);\n+//         EndRegion('15_0rce);\n //         return;\n //     }\n // END rustc.node22.SimplifyCfg-qualify-consts.after.mir"}, {"sha": "d68439087615b93d80361aea7f3e32bce5d9b10b", "filename": "src/test/mir-opt/end_region_7.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Ftest%2Fmir-opt%2Fend_region_7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Ftest%2Fmir-opt%2Fend_region_7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_7.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -74,18 +74,18 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n // START rustc.node22.SimplifyCfg-qualify-consts.after.mir\n // fn main::{{closure}}(_1: [closure@NodeId(22) d:D]) -> i32 {\n //     let mut _0: i32;\n-//     let _2: &'14_0rce D;\n+//     let _2: &'15_0rce D;\n //     let mut _3: i32;\n //\n //     bb0: {\n //         StorageLive(_2);\n-//         _2 = &'14_0rce (_1.0: D);\n+//         _2 = &'15_0rce (_1.0: D);\n //         StorageLive(_3);\n //         _3 = ((*_2).0: i32);\n //         _0 = _3;\n //         StorageDead(_3);\n //         StorageDead(_2);\n-//         EndRegion('14_0rce);\n+//         EndRegion('15_0rce);\n //         drop(_1) -> bb1;\n //     }\n //     bb1: {"}, {"sha": "8d7050941e7ebfe060b9bc8ebce967d544aae4ac", "filename": "src/test/mir-opt/end_region_8.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Ftest%2Fmir-opt%2Fend_region_8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Ftest%2Fmir-opt%2Fend_region_8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_8.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -31,15 +31,15 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n // fn main() -> () {\n //    let mut _0: ();\n //    let _1: D;\n-//    let _2: &'6_1rce D;\n+//    let _2: &'21_1rce D;\n //    let mut _3: ();\n-//    let mut _4: [closure@NodeId(22) r:&'6_1rce D];\n-//    let mut _5: &'6_1rce D;\n+//    let mut _4: [closure@NodeId(22) r:&'21_1rce D];\n+//    let mut _5: &'21_1rce D;\n //    bb0: {\n //        StorageLive(_1);\n //        _1 = D::{{constructor}}(const 0i32,);\n //        StorageLive(_2);\n-//        _2 = &'6_1rce _1;\n+//        _2 = &'21_1rce _1;\n //        StorageLive(_4);\n //        StorageLive(_5);\n //        _5 = _2;\n@@ -51,14 +51,14 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n //        StorageDead(_4);\n //        _0 = ();\n //        StorageDead(_2);\n-//        EndRegion('6_1rce);\n+//        EndRegion('21_1rce);\n //        drop(_1) -> bb4;\n //    }\n //    bb2: {\n //        resume;\n //    }\n //    bb3: {\n-//        EndRegion('6_1rce);\n+//        EndRegion('21_1rce);\n //        drop(_1) -> bb2;\n //    }\n //    bb4: {\n@@ -69,13 +69,13 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n // END rustc.node4.SimplifyCfg-qualify-consts.after.mir\n \n // START rustc.node22.SimplifyCfg-qualify-consts.after.mir\n-// fn main::{{closure}}(_1: [closure@NodeId(22) r:&'6_1rce D]) -> i32 {\n+// fn main::{{closure}}(_1: [closure@NodeId(22) r:&'21_1rce D]) -> i32 {\n //     let mut _0: i32;\n //     let mut _2: i32;\n //\n //     bb0: {\n //         StorageLive(_2);\n-//         _2 = ((*(_1.0: &'6_1rce D)).0: i32);\n+//         _2 = ((*(_1.0: &'21_1rce D)).0: i32);\n //         _0 = _2;\n //         StorageDead(_2);\n //         return;"}, {"sha": "9c528da8b348dda7bc3481a2f9dbada0a6a1e120", "filename": "src/test/mir-opt/validate_1.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -37,19 +37,19 @@ fn main() {\n // START rustc.node23.EraseRegions.after.mir\n // fn main() -> () {\n //     bb0: {\n-//         Validate(Suspend(ReScope(Misc(NodeId(34)))), [_1: i32]);\n+//         Validate(Suspend(ReScope(Misc(ItemLocalId(10)))), [_1: i32]);\n //         _6 = &ReErased mut _1;\n-//         Validate(Acquire, [(*_6): i32/ReScope(Misc(NodeId(34)))]);\n-//         Validate(Suspend(ReScope(Misc(NodeId(34)))), [(*_6): i32/ReScope(Misc(NodeId(34)))]);\n+//         Validate(Acquire, [(*_6): i32/ReScope(Misc(ItemLocalId(10)))]);\n+//         Validate(Suspend(ReScope(Misc(ItemLocalId(10)))), [(*_6): i32/ReScope(Misc(ItemLocalId(10)))]);\n //         _5 = &ReErased mut (*_6);\n-//         Validate(Acquire, [(*_5): i32/ReScope(Misc(NodeId(34)))]);\n-//         Validate(Release, [_2: (), _3: &ReScope(Misc(NodeId(34))) Test, _5: &ReScope(Misc(NodeId(34))) mut i32]);\n+//         Validate(Acquire, [(*_5): i32/ReScope(Misc(ItemLocalId(10)))]);\n+//         Validate(Release, [_2: (), _3: &ReScope(Misc(ItemLocalId(10))) Test, _5: &ReScope(Misc(ItemLocalId(10))) mut i32]);\n //         _2 = const Test::foo(_3, _5) -> bb1;\n //     }\n //\n //     bb1: {\n //         Validate(Acquire, [_2: ()]);\n-//         EndRegion(ReScope(Misc(NodeId(34))));\n+//         EndRegion(ReScope(Misc(ItemLocalId(10))));\n //         return;\n //     }\n // }\n@@ -61,15 +61,15 @@ fn main() {\n //         StorageLive(_3);\n //         _3 = _2;\n //         StorageLive(_4);\n-//         Validate(Suspend(ReScope(Remainder(BlockRemainder { block: NodeId(41), first_statement_index: 0 }))), [(*_3): i32]);\n+//         Validate(Suspend(ReScope(Remainder(BlockRemainder { block: ItemLocalId(22), first_statement_index: 0 }))), [(*_3): i32]);\n //         _4 = &ReErased (*_3);\n-//         Validate(Acquire, [(*_4): i32/ReScope(Remainder(BlockRemainder { block: NodeId(41), first_statement_index: 0 })) (imm)]);\n+//         Validate(Acquire, [(*_4): i32/ReScope(Remainder(BlockRemainder { block: ItemLocalId(22), first_statement_index: 0 })) (imm)]);\n //         StorageLive(_5);\n //         _5 = (*_4);\n //         _0 = _5;\n //         StorageDead(_5);\n //         StorageDead(_4);\n-//         EndRegion(ReScope(Remainder(BlockRemainder { block: NodeId(41), first_statement_index: 0 })));\n+//         EndRegion(ReScope(Remainder(BlockRemainder { block: ItemLocalId(22), first_statement_index: 0 })));\n //         StorageDead(_3);\n //         return;\n //     }"}, {"sha": "cd556564b7913d39bfaf8fc6e073f46044b279e3", "filename": "src/test/mir-opt/validate_3.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Ftest%2Fmir-opt%2Fvalidate_3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Ftest%2Fmir-opt%2Fvalidate_3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_3.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -32,18 +32,18 @@ fn main() {\n // fn main() -> () {\n //     let mut _5: &ReErased i32;\n //     bb0: {\n-//         Validate(Suspend(ReScope(Misc(NodeId(46)))), [((*_2).0: i32): i32/ReScope(Remainder(BlockRemainder { block: NodeId(18), first_statement_index: 3 })) (imm)]);\n+//         Validate(Suspend(ReScope(Misc(ItemLocalId(17)))), [((*_2).0: i32): i32/ReScope(Remainder(BlockRemainder { block: ItemLocalId(19), first_statement_index: 3 })) (imm)]);\n //         _5 = &ReErased ((*_2).0: i32);\n-//         Validate(Acquire, [(*_5): i32/ReScope(Misc(NodeId(46))) (imm)]);\n-//         Validate(Suspend(ReScope(Misc(NodeId(46)))), [(*_5): i32/ReScope(Misc(NodeId(46))) (imm)]);\n+//         Validate(Acquire, [(*_5): i32/ReScope(Misc(ItemLocalId(17))) (imm)]);\n+//         Validate(Suspend(ReScope(Misc(ItemLocalId(17)))), [(*_5): i32/ReScope(Misc(ItemLocalId(17))) (imm)]);\n //         _4 = &ReErased (*_5);\n-//         Validate(Acquire, [(*_4): i32/ReScope(Misc(NodeId(46))) (imm)]);\n-//         Validate(Release, [_3: (), _4: &ReScope(Misc(NodeId(46))) i32]);\n+//         Validate(Acquire, [(*_4): i32/ReScope(Misc(ItemLocalId(17))) (imm)]);\n+//         Validate(Release, [_3: (), _4: &ReScope(Misc(ItemLocalId(17))) i32]);\n //         _3 = const foo(_4) -> bb1;\n //     }\n //     bb1: {\n-//         EndRegion(ReScope(Misc(NodeId(46))));\n-//         EndRegion(ReScope(Remainder(BlockRemainder { block: NodeId(18), first_statement_index: 3 })));\n+//         EndRegion(ReScope(Misc(ItemLocalId(17))));\n+//         EndRegion(ReScope(Remainder(BlockRemainder { block: ItemLocalId(19), first_statement_index: 3 })));\n //         return;\n //     }\n // }"}, {"sha": "224f4ce2effe3294cd47269c84c8a74c1311ed95", "filename": "src/test/mir-opt/validate_5.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -50,12 +50,12 @@ fn main() {\n //         _3 = _2;\n //         StorageLive(_4);\n //         StorageLive(_5);\n-//         Validate(Suspend(ReScope(Misc(NodeId(44)))), [(*_3): i32]);\n+//         Validate(Suspend(ReScope(Misc(ItemLocalId(9)))), [(*_3): i32]);\n //         _5 = &ReErased mut (*_3);\n-//         Validate(Acquire, [(*_5): i32/ReScope(Misc(NodeId(44)))]);\n+//         Validate(Acquire, [(*_5): i32/ReScope(Misc(ItemLocalId(9)))]);\n //         _4 = _5 as *mut i32 (Misc);\n //         StorageDead(_5);\n-//         EndRegion(ReScope(Misc(NodeId(44))));\n+//         EndRegion(ReScope(Misc(ItemLocalId(9))));\n //         Validate(Release, [_0: bool, _4: *mut i32]);\n //         _0 = const write_42(_4) -> bb1;\n //     }"}, {"sha": "6b7a26556f430af72f7c3565d88cd8869b085167", "filename": "src/test/parse-fail/struct-literal-restrictions-in-lamda.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Ftest%2Fparse-fail%2Fstruct-literal-restrictions-in-lamda.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Ftest%2Fparse-fail%2Fstruct-literal-restrictions-in-lamda.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fstruct-literal-restrictions-in-lamda.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only\n+\n+struct Foo {\n+    x: isize,\n+}\n+\n+impl Foo {\n+    fn hi(&self) -> bool {\n+        true\n+    }\n+}\n+\n+fn main() {\n+    while || Foo {\n+        x: 3    //~ ERROR expected type, found `3`\n+    }.hi() { //~ ERROR expected one of `.`, `;`, `?`, `}`, or an operator, found `{`\n+        println!(\"yo\");\n+    }\n+}"}, {"sha": "a6a2a2d081e1f68cb1f2d852b28e8ebd55f0b5be", "filename": "src/test/run-pass/generator/auxiliary/xcrate-reachable.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Ftest%2Frun-pass%2Fgenerator%2Fauxiliary%2Fxcrate-reachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Ftest%2Frun-pass%2Fgenerator%2Fauxiliary%2Fxcrate-reachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fauxiliary%2Fxcrate-reachable.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(conservative_impl_trait, generators, generator_trait)]\n+\n+use std::ops::Generator;\n+\n+fn msg() -> u32 {\n+    0\n+}\n+\n+pub fn foo() -> impl Generator<Yield=(), Return=u32> {\n+    || {\n+        yield;\n+        return msg();\n+    }\n+}"}, {"sha": "dff5e08b9c20e3a54f0dafef49eb9c2cf227d20e", "filename": "src/test/run-pass/generator/xcrate-reachable.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Ftest%2Frun-pass%2Fgenerator%2Fxcrate-reachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Ftest%2Frun-pass%2Fgenerator%2Fxcrate-reachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fxcrate-reachable.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:xcrate-reachable.rs\n+\n+#![feature(conservative_impl_trait, generator_trait)]\n+\n+extern crate xcrate_reachable as foo;\n+\n+use std::ops::Generator;\n+\n+fn main() {\n+    foo::foo().resume();\n+}"}, {"sha": "0fc5fe498a62d6012d580df01e90d6e0def615f8", "filename": "src/test/run-pass/semistatement-in-lambda.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Ftest%2Frun-pass%2Fsemistatement-in-lambda.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Ftest%2Frun-pass%2Fsemistatement-in-lambda.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsemistatement-in-lambda.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+pub fn main() {\n+    // Test that lambdas behave as unary expressions with block-like expressions\n+    -if true { 1 } else { 2 } * 3;\n+    || if true { 1 } else { 2 } * 3;\n+\n+    // The following is invalid and parses as `if true { 1 } else { 2 }; *3`\n+    // if true { 1 } else { 2 } * 3\n+}"}, {"sha": "f296048e30b54d16d564f506ca8ddad3c8eac84e", "filename": "src/test/rustdoc/issue-29449.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Ftest%2Frustdoc%2Fissue-29449.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Ftest%2Frustdoc%2Fissue-29449.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-29449.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -18,12 +18,12 @@ impl Foo {\n     /// # Panics\n     pub fn bar() {}\n \n-    // @has - '//*[@id=\"examples-2\"]//a' 'Examples'\n+    // @has - '//*[@id=\"examples-1\"]//a' 'Examples'\n     /// # Examples\n     pub fn bar_1() {}\n \n-    // @has - '//*[@id=\"examples-4\"]//a' 'Examples'\n-    // @has - '//*[@id=\"panics-2\"]//a' 'Panics'\n+    // @has - '//*[@id=\"examples-2\"]//a' 'Examples'\n+    // @has - '//*[@id=\"panics-1\"]//a' 'Panics'\n     /// # Examples\n     /// # Panics\n     pub fn bar_2() {}"}, {"sha": "5cdc19823cfff08ebe31d6b4765dae71c3ac1b2d", "filename": "src/test/ui/lint/not_found.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Ftest%2Fui%2Flint%2Fnot_found.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Ftest%2Fui%2Flint%2Fnot_found.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fnot_found.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014\u20132017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// this tests the `unknown_lint` lint, especially the suggestions\n+\n+// the suggestion only appears if a lint with the lowercase name exists\n+#[allow(FOO_BAR)]\n+// the suggestion appears on all-uppercase names\n+#[warn(DEAD_CODE)]\n+// the suggestion appears also on mixed-case names\n+#[deny(Warnings)]\n+fn main() {\n+    unimplemented!();\n+}"}, {"sha": "73265845494c23735136d583dd712cca46ca59ef", "filename": "src/test/ui/lint/not_found.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Ftest%2Fui%2Flint%2Fnot_found.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Ftest%2Fui%2Flint%2Fnot_found.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fnot_found.stderr?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -0,0 +1,20 @@\n+warning: unknown lint: `FOO_BAR`\n+  --> $DIR/not_found.rs:14:9\n+   |\n+14 | #[allow(FOO_BAR)]\n+   |         ^^^^^^^\n+   |\n+   = note: #[warn(unknown_lints)] on by default\n+\n+warning: unknown lint: `DEAD_CODE`\n+  --> $DIR/not_found.rs:16:8\n+   |\n+16 | #[warn(DEAD_CODE)]\n+   |        ^^^^^^^^^ help: lowercase the lint name: `dead_code`\n+\n+warning: unknown lint: `Warnings`\n+  --> $DIR/not_found.rs:18:8\n+   |\n+18 | #[deny(Warnings)]\n+   |        ^^^^^^^^ help: lowercase the lint name: `warnings`\n+"}, {"sha": "d928a6a0a8e64b0299ca3fc2bf807963dbce1fbd", "filename": "src/test/ui/mismatched_types/closure-mismatch.stderr", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-mismatch.stderr?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -4,7 +4,6 @@ error[E0271]: type mismatch resolving `for<'r> <[closure@$DIR/closure-mismatch.r\n 18 |     baz(|_| ());\n    |     ^^^ expected bound lifetime parameter, found concrete lifetime\n    |\n-   = note: concrete lifetime that was found is lifetime '_#0r\n    = note: required because of the requirements on the impl of `Foo` for `[closure@$DIR/closure-mismatch.rs:18:9: 18:15]`\n    = note: required by `baz`\n "}, {"sha": "34c0674a251287c94cdd1a112966bcb9010c62e8", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -1 +1 @@\n-Subproject commit 3d3f2c05d742e5f907e951aa8849b03f0bc1a895\n+Subproject commit 34c0674a251287c94cdd1a112966bcb9010c62e8"}, {"sha": "4402bc70a3b175c38994bbc802bee41ddc59165b", "filename": "src/tools/clippy", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -0,0 +1 @@\n+Subproject commit 4402bc70a3b175c38994bbc802bee41ddc59165b"}, {"sha": "731a3d96cff9d9521c848200e667744dcb2f2310", "filename": "src/tools/tidy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -62,6 +62,7 @@ fn filter_dirs(path: &Path) -> bool {\n         \"src/rt/hoedown\",\n         \"src/tools/cargo\",\n         \"src/tools/rls\",\n+        \"src/tools/clippy\",\n         \"src/tools/rust-installer\",\n     ];\n     skip.iter().any(|p| path.ends_with(p))"}, {"sha": "8092a9e156bebf2c9b4f2efd868b885a9b123cec", "filename": "src/tools/tidy/src/pal.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/570ae39973838862311d4b2638f74a1cc3f15669/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/570ae39973838862311d4b2638f74a1cc3f15669/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs?ref=570ae39973838862311d4b2638f74a1cc3f15669", "patch": "@@ -65,11 +65,10 @@ const EXCEPTION_PATHS: &'static [&'static str] = &[\n     \"src/rtstartup\", // Not sure what to do about this. magic stuff for mingw\n \n     // temporary exceptions\n-    \"src/libstd/rtdeps.rs\", // Until rustbuild replaces make\n+    \"src/libstd/lib.rs\", // FIXME(#44217)\n     \"src/libstd/path.rs\",\n     \"src/libstd/f32.rs\",\n     \"src/libstd/f64.rs\",\n-    \"src/libstd/lib.rs\", // Until next stage0 snapshot bump\n     \"src/libstd/sys_common/mod.rs\",\n     \"src/libstd/sys_common/net.rs\",\n     \"src/libterm\", // Not sure how to make this crate portable, but test needs it"}]}