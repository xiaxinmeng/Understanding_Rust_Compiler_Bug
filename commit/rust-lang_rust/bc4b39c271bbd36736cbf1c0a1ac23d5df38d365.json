{"sha": "bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "node_id": "C_kwDOAAsO6NoAKGJjNGIzOWMyNzFiYmQzNjczNmNiZjFjMGExYWMyM2Q1ZGYzOGQzNjU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-29T18:56:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-29T18:56:59Z"}, "message": "Auto merge of #101152 - Dylan-DPC:rollup-v4iw8ux, r=Dylan-DPC\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #98304 (Add MaybeUninit memset test)\n - #98801 (Add a `File::create_new` constructor)\n - #99821 (Remove separate indexing of early-bound regions)\n - #100239 (remove an ineffective check in const_prop)\n - #100337 (Stabilize `std::io::read_to_string`)\n - #100819 (Make use of `[wrapping_]byte_{add,sub}`)\n - #100934 (Remove a panicking branch from `fmt::builders::PadAdapter`)\n - #101000 (Separate CountIsStar from CountIsParam in rustc_parse_format.)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "8f778be3486f10079fcf7448bc7601752152a5e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f778be3486f10079fcf7448bc7601752152a5e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "html_url": "https://github.com/rust-lang/rust/commit/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fcc2bddd262b26c3a4aeff2328e39b8e2b6d3254", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcc2bddd262b26c3a4aeff2328e39b8e2b6d3254", "html_url": "https://github.com/rust-lang/rust/commit/fcc2bddd262b26c3a4aeff2328e39b8e2b6d3254"}, {"sha": "0b6faca67057ceb99ee3af342d4ba6f1ac407fde", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b6faca67057ceb99ee3af342d4ba6f1ac407fde", "html_url": "https://github.com/rust-lang/rust/commit/0b6faca67057ceb99ee3af342d4ba6f1ac407fde"}], "stats": {"total": 864, "additions": 330, "deletions": 534}, "files": [{"sha": "46dbbd83d19054e2c2aaf8e4751c68a9aaf974d0", "filename": "compiler/rustc_arena/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Flib.rs?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -16,6 +16,7 @@\n #![feature(maybe_uninit_slice)]\n #![feature(min_specialization)]\n #![feature(decl_macro)]\n+#![feature(pointer_byte_offsets)]\n #![feature(rustc_attrs)]\n #![cfg_attr(test, feature(test))]\n #![feature(strict_provenance)]\n@@ -211,7 +212,7 @@ impl<T> TypedArena<T> {\n \n         unsafe {\n             if mem::size_of::<T>() == 0 {\n-                self.ptr.set((self.ptr.get() as *mut u8).wrapping_offset(1) as *mut T);\n+                self.ptr.set(self.ptr.get().wrapping_byte_add(1));\n                 let ptr = ptr::NonNull::<T>::dangling().as_ptr();\n                 // Don't drop the object. This `write` is equivalent to `forget`.\n                 ptr::write(ptr, object);"}, {"sha": "210048710751702a4c278b844536e16a85c97968", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -541,7 +541,7 @@ impl<'a, 'b> Context<'a, 'b> {\n     ) {\n         match c {\n             parse::CountImplied | parse::CountIs(..) => {}\n-            parse::CountIsParam(i) => {\n+            parse::CountIsParam(i) | parse::CountIsStar(i) => {\n                 self.unused_names_lint.maybe_add_positional_named_arg(\n                     self.args.get(i),\n                     named_arg_type,\n@@ -589,7 +589,7 @@ impl<'a, 'b> Context<'a, 'b> {\n             + self\n                 .arg_with_formatting\n                 .iter()\n-                .filter(|fmt| matches!(fmt.precision, parse::CountIsParam(_)))\n+                .filter(|fmt| matches!(fmt.precision, parse::CountIsStar(_)))\n                 .count();\n         if self.names.is_empty() && !numbered_position_args && count != self.num_args() {\n             e = self.ecx.struct_span_err(\n@@ -639,7 +639,7 @@ impl<'a, 'b> Context<'a, 'b> {\n             if let Some(span) = fmt.precision_span {\n                 let span = self.fmtsp.from_inner(InnerSpan::new(span.start, span.end));\n                 match fmt.precision {\n-                    parse::CountIsParam(pos) if pos > self.num_args() => {\n+                    parse::CountIsParam(pos) if pos >= self.num_args() => {\n                         e.span_label(\n                             span,\n                             &format!(\n@@ -651,12 +651,12 @@ impl<'a, 'b> Context<'a, 'b> {\n                         );\n                         zero_based_note = true;\n                     }\n-                    parse::CountIsParam(pos) => {\n+                    parse::CountIsStar(pos) => {\n                         let count = self.pieces.len()\n                             + self\n                                 .arg_with_formatting\n                                 .iter()\n-                                .filter(|fmt| matches!(fmt.precision, parse::CountIsParam(_)))\n+                                .filter(|fmt| matches!(fmt.precision, parse::CountIsStar(_)))\n                                 .count();\n                         e.span_label(\n                             span,\n@@ -837,7 +837,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         };\n         match c {\n             parse::CountIs(i) => count(sym::Is, Some(self.ecx.expr_usize(sp, i))),\n-            parse::CountIsParam(i) => {\n+            parse::CountIsParam(i) | parse::CountIsStar(i) => {\n                 // This needs mapping too, as `i` is referring to a macro\n                 // argument. If `i` is not found in `count_positions` then\n                 // the error had already been emitted elsewhere."}, {"sha": "d37eaeed095a154fa7732fa24253ab4dfde84688", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -187,9 +187,6 @@ pub enum LocalValue<Prov: Provenance = AllocId> {\n \n impl<'tcx, Prov: Provenance + 'static> LocalState<'tcx, Prov> {\n     /// Read the local's value or error if the local is not yet live or not live anymore.\n-    ///\n-    /// Note: This may only be invoked from the `Machine::access_local` hook and not from\n-    /// anywhere else. You may be invalidating machine invariants if you do!\n     #[inline]\n     pub fn access(&self) -> InterpResult<'tcx, &Operand<Prov>> {\n         match &self.value {"}, {"sha": "b151d03681f43df4a89246f7bea8d052cd7d0238", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -215,23 +215,12 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         right: &ImmTy<'tcx, Self::Provenance>,\n     ) -> InterpResult<'tcx, (Scalar<Self::Provenance>, bool, Ty<'tcx>)>;\n \n-    /// Called to read the specified `local` from the `frame`.\n-    /// Since reading a ZST is not actually accessing memory or locals, this is never invoked\n-    /// for ZST reads.\n-    #[inline]\n-    fn access_local<'a>(\n-        frame: &'a Frame<'mir, 'tcx, Self::Provenance, Self::FrameExtra>,\n-        local: mir::Local,\n-    ) -> InterpResult<'tcx, &'a Operand<Self::Provenance>>\n-    where\n-        'tcx: 'mir,\n-    {\n-        frame.locals[local].access()\n-    }\n-\n     /// Called to write the specified `local` from the `frame`.\n     /// Since writing a ZST is not actually accessing memory or locals, this is never invoked\n     /// for ZST reads.\n+    ///\n+    /// Due to borrow checker trouble, we indicate the `frame` as an index rather than an `&mut\n+    /// Frame`.\n     #[inline]\n     fn access_local_mut<'a>(\n         ecx: &'a mut InterpCx<'mir, 'tcx, Self>,"}, {"sha": "91a97fe4d4dd84dec4b661abbe26f8be3e65fd20", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -444,7 +444,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n     }\n \n-    /// Read from a local. Will not actually access the local if reading from a ZST.\n+    /// Read from a local.\n     /// Will not access memory, instead an indirect `Operand` is returned.\n     ///\n     /// This is public because it is used by [priroda](https://github.com/oli-obk/priroda) to get an\n@@ -456,12 +456,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         layout: Option<TyAndLayout<'tcx>>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>> {\n         let layout = self.layout_of_local(frame, local, layout)?;\n-        let op = if layout.is_zst() {\n-            // Bypass `access_local` (helps in ConstProp)\n-            Operand::Immediate(Immediate::Uninit)\n-        } else {\n-            *M::access_local(frame, local)?\n-        };\n+        let op = *frame.locals[local].access()?;\n         Ok(OpTy { op, layout, align: Some(layout.align.abi) })\n     }\n "}, {"sha": "d56323448cea19326c2746da29b52385afed217d", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -642,7 +642,7 @@ where\n         // avoid force_allocation.\n         let src = match self.read_immediate_raw(src)? {\n             Ok(src_val) => {\n-                assert!(!src.layout.is_unsized(), \"cannot have unsized immediates\");\n+                assert!(!src.layout.is_unsized(), \"cannot copy unsized immediates\");\n                 assert!(\n                     !dest.layout.is_unsized(),\n                     \"the src is sized, so the dest must also be sized\""}, {"sha": "16ce5bc71750a868d845528f8ff068a0a3165495", "filename": "compiler/rustc_const_eval/src/interpret/projection.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -100,6 +100,8 @@ where\n         // This makes several assumptions about what layouts we will encounter; we match what\n         // codegen does as good as we can (see `extract_field` in `rustc_codegen_ssa/src/mir/operand.rs`).\n         let field_val: Immediate<_> = match (*base, base.layout.abi) {\n+            // if the entire value is uninit, then so is the field (can happen in ConstProp)\n+            (Immediate::Uninit, _) => Immediate::Uninit,\n             // the field contains no information, can be left uninit\n             _ if field_layout.is_zst() => Immediate::Uninit,\n             // the field covers the entire type\n@@ -124,6 +126,7 @@ where\n                     b_val\n                 })\n             }\n+            // everything else is a bug\n             _ => span_bug!(\n                 self.cur_span(),\n                 \"invalid field access on immediate {}, layout {:#?}\","}, {"sha": "ddad72fdab93d9dfabeba68820cef3edfac199a1", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -103,7 +103,7 @@ impl<'tcx> Visitor<'tcx> for FindNestedTypeVisitor<'tcx> {\n                     // Find the index of the named region that was part of the\n                     // error. We will then search the function parameters for a bound\n                     // region at the right depth with the same index\n-                    (Some(rl::Region::EarlyBound(_, id)), ty::BrNamed(def_id, _)) => {\n+                    (Some(rl::Region::EarlyBound(id)), ty::BrNamed(def_id, _)) => {\n                         debug!(\"EarlyBound id={:?} def_id={:?}\", id, def_id);\n                         if id == def_id {\n                             self.found_type = Some(arg);\n@@ -133,7 +133,7 @@ impl<'tcx> Visitor<'tcx> for FindNestedTypeVisitor<'tcx> {\n                         Some(\n                             rl::Region::Static\n                             | rl::Region::Free(_, _)\n-                            | rl::Region::EarlyBound(_, _)\n+                            | rl::Region::EarlyBound(_)\n                             | rl::Region::LateBound(_, _, _),\n                         )\n                         | None,\n@@ -188,7 +188,7 @@ impl<'tcx> Visitor<'tcx> for TyPathVisitor<'tcx> {\n     fn visit_lifetime(&mut self, lifetime: &hir::Lifetime) {\n         match (self.tcx.named_region(lifetime.hir_id), self.bound_region) {\n             // the lifetime of the TyPath!\n-            (Some(rl::Region::EarlyBound(_, id)), ty::BrNamed(def_id, _)) => {\n+            (Some(rl::Region::EarlyBound(id)), ty::BrNamed(def_id, _)) => {\n                 debug!(\"EarlyBound id={:?} def_id={:?}\", id, def_id);\n                 if id == def_id {\n                     self.found_it = true;\n@@ -209,7 +209,7 @@ impl<'tcx> Visitor<'tcx> for TyPathVisitor<'tcx> {\n             (\n                 Some(\n                     rl::Region::Static\n-                    | rl::Region::EarlyBound(_, _)\n+                    | rl::Region::EarlyBound(_)\n                     | rl::Region::LateBound(_, _, _)\n                     | rl::Region::Free(_, _),\n                 )"}, {"sha": "3d002380f09dd2c3fb38830d98c163174f4850e5", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -2026,13 +2026,13 @@ declare_lint_pass!(ExplicitOutlivesRequirements => [EXPLICIT_OUTLIVES_REQUIREMEN\n impl ExplicitOutlivesRequirements {\n     fn lifetimes_outliving_lifetime<'tcx>(\n         inferred_outlives: &'tcx [(ty::Predicate<'tcx>, Span)],\n-        index: u32,\n+        def_id: DefId,\n     ) -> Vec<ty::Region<'tcx>> {\n         inferred_outlives\n             .iter()\n             .filter_map(|(pred, _)| match pred.kind().skip_binder() {\n                 ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(a, b)) => match *a {\n-                    ty::ReEarlyBound(ebr) if ebr.index == index => Some(b),\n+                    ty::ReEarlyBound(ebr) if ebr.def_id == def_id => Some(b),\n                     _ => None,\n                 },\n                 _ => None,\n@@ -2069,8 +2069,12 @@ impl ExplicitOutlivesRequirements {\n             .filter_map(|(i, bound)| {\n                 if let hir::GenericBound::Outlives(lifetime) = bound {\n                     let is_inferred = match tcx.named_region(lifetime.hir_id) {\n-                        Some(Region::EarlyBound(index, ..)) => inferred_outlives.iter().any(|r| {\n-                            if let ty::ReEarlyBound(ebr) = **r { ebr.index == index } else { false }\n+                        Some(Region::EarlyBound(def_id)) => inferred_outlives.iter().any(|r| {\n+                            if let ty::ReEarlyBound(ebr) = **r {\n+                                ebr.def_id == def_id\n+                            } else {\n+                                false\n+                            }\n                         }),\n                         _ => false,\n                     };\n@@ -2164,11 +2168,14 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n             for (i, where_predicate) in hir_generics.predicates.iter().enumerate() {\n                 let (relevant_lifetimes, bounds, span, in_where_clause) = match where_predicate {\n                     hir::WherePredicate::RegionPredicate(predicate) => {\n-                        if let Some(Region::EarlyBound(index, ..)) =\n+                        if let Some(Region::EarlyBound(region_def_id)) =\n                             cx.tcx.named_region(predicate.lifetime.hir_id)\n                         {\n                             (\n-                                Self::lifetimes_outliving_lifetime(inferred_outlives, index),\n+                                Self::lifetimes_outliving_lifetime(\n+                                    inferred_outlives,\n+                                    region_def_id,\n+                                ),\n                                 &predicate.bounds,\n                                 predicate.span,\n                                 predicate.in_where_clause,"}, {"sha": "9d201a0c799928174f80efd1f93135013ed01733", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -199,6 +199,7 @@ provide! { tcx, def_id, other, cdata,\n     codegen_fn_attrs => { table }\n     impl_trait_ref => { table }\n     const_param_default => { table }\n+    object_lifetime_default => { table }\n     thir_abstract_const => { table }\n     optimized_mir => { table }\n     mir_for_ctfe => { table }"}, {"sha": "3482d9f04514e561b08c458639af28b7dde76292", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -1076,6 +1076,11 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     record_array!(self.tables.inferred_outlives_of[def_id] <- inferred_outlives);\n                 }\n             }\n+            if let DefKind::TyParam | DefKind::ConstParam = def_kind {\n+                if let Some(default) = self.tcx.object_lifetime_default(def_id) {\n+                    record!(self.tables.object_lifetime_default[def_id] <- default);\n+                }\n+            }\n             if let DefKind::Trait | DefKind::TraitAlias = def_kind {\n                 record!(self.tables.super_predicates_of[def_id] <- self.tcx.super_predicates_of(def_id));\n             }"}, {"sha": "aeffc85b507556648ed956d50937c91435949a48", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -16,6 +16,7 @@ use rustc_index::{bit_set::FiniteBitSet, vec::IndexVec};\n use rustc_middle::metadata::ModChild;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrs;\n use rustc_middle::middle::exported_symbols::{ExportedSymbol, SymbolExportInfo};\n+use rustc_middle::middle::resolve_lifetime::ObjectLifetimeDefault;\n use rustc_middle::mir;\n use rustc_middle::ty::fast_reject::SimplifiedType;\n use rustc_middle::ty::query::Providers;\n@@ -358,6 +359,7 @@ define_tables! {\n     codegen_fn_attrs: Table<DefIndex, LazyValue<CodegenFnAttrs>>,\n     impl_trait_ref: Table<DefIndex, LazyValue<ty::TraitRef<'static>>>,\n     const_param_default: Table<DefIndex, LazyValue<rustc_middle::ty::Const<'static>>>,\n+    object_lifetime_default: Table<DefIndex, LazyValue<ObjectLifetimeDefault>>,\n     optimized_mir: Table<DefIndex, LazyValue<mir::Body<'static>>>,\n     mir_for_ctfe: Table<DefIndex, LazyValue<mir::Body<'static>>>,\n     promoted_mir: Table<DefIndex, LazyValue<IndexVec<mir::Promoted, mir::Body<'static>>>>,"}, {"sha": "8f7877392483f27f0c6ad04321071c912a27ee13", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -486,7 +486,9 @@ impl<'hir> Map<'hir> {\n         let def_kind = self.tcx.def_kind(def_id);\n         match def_kind {\n             DefKind::Trait | DefKind::TraitAlias => def_id,\n-            DefKind::TyParam | DefKind::ConstParam => self.tcx.local_parent(def_id),\n+            DefKind::LifetimeParam | DefKind::TyParam | DefKind::ConstParam => {\n+                self.tcx.local_parent(def_id)\n+            }\n             _ => bug!(\"ty_param_owner: {:?} is a {:?} not a type parameter\", def_id, def_kind),\n         }\n     }\n@@ -495,7 +497,9 @@ impl<'hir> Map<'hir> {\n         let def_kind = self.tcx.def_kind(def_id);\n         match def_kind {\n             DefKind::Trait | DefKind::TraitAlias => kw::SelfUpper,\n-            DefKind::TyParam | DefKind::ConstParam => self.tcx.item_name(def_id.to_def_id()),\n+            DefKind::LifetimeParam | DefKind::TyParam | DefKind::ConstParam => {\n+                self.tcx.item_name(def_id.to_def_id())\n+            }\n             _ => bug!(\"ty_param_name: {:?} is a {:?} not a type parameter\", def_id, def_kind),\n         }\n     }"}, {"sha": "a171f5711dcffd3304c86dc958f8651aecbcebd6", "filename": "compiler/rustc_middle/src/middle/resolve_lifetime.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -10,7 +10,7 @@ use rustc_macros::HashStable;\n #[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable, Debug, HashStable)]\n pub enum Region {\n     Static,\n-    EarlyBound(/* index */ u32, /* lifetime decl */ DefId),\n+    EarlyBound(/* lifetime decl */ DefId),\n     LateBound(ty::DebruijnIndex, /* late-bound index */ u32, /* lifetime decl */ DefId),\n     Free(DefId, /* lifetime decl */ DefId),\n }\n@@ -35,7 +35,13 @@ impl<T: PartialEq> Set1<T> {\n     }\n }\n \n-pub type ObjectLifetimeDefault = Set1<Region>;\n+#[derive(Copy, Clone, Debug, HashStable, Encodable, Decodable)]\n+pub enum ObjectLifetimeDefault {\n+    Empty,\n+    Static,\n+    Ambiguous,\n+    Param(DefId),\n+}\n \n /// Maps the id of each lifetime reference to the lifetime decl\n /// that it corresponds to."}, {"sha": "ddca9820da1aec8cacbd60356284744fa2c7fc03", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -1597,8 +1597,9 @@ rustc_queries! {\n     /// for each parameter if a trait object were to be passed for that parameter.\n     /// For example, for `struct Foo<'a, T, U>`, this would be `['static, 'static]`.\n     /// For `struct Foo<'a, T: 'a, U>`, this would instead be `['a, 'static]`.\n-    query object_lifetime_defaults(_: LocalDefId) -> Option<&'tcx [ObjectLifetimeDefault]> {\n-        desc { \"looking up lifetime defaults for a region on an item\" }\n+    query object_lifetime_default(key: DefId) -> Option<ObjectLifetimeDefault> {\n+        desc { \"looking up lifetime defaults for generic parameter `{:?}`\", key }\n+        separate_provide_extern\n     }\n     query late_bound_vars_map(_: LocalDefId)\n         -> Option<&'tcx FxHashMap<ItemLocalId, Vec<ty::BoundVariableKind>>> {"}, {"sha": "42b5d5a6efd7ec5435b6d141aef29c5858bf2f20", "filename": "compiler/rustc_middle/src/ty/generics.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -1,4 +1,3 @@\n-use crate::middle::resolve_lifetime::ObjectLifetimeDefault;\n use crate::ty;\n use crate::ty::subst::{Subst, SubstsRef};\n use crate::ty::EarlyBinder;\n@@ -13,7 +12,7 @@ use super::{EarlyBoundRegion, InstantiatedPredicates, ParamConst, ParamTy, Predi\n #[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n pub enum GenericParamDefKind {\n     Lifetime,\n-    Type { has_default: bool, object_lifetime_default: ObjectLifetimeDefault, synthetic: bool },\n+    Type { has_default: bool, synthetic: bool },\n     Const { has_default: bool },\n }\n "}, {"sha": "19b8f27bc95caae910d164128766cbefb533a254", "filename": "compiler/rustc_middle/src/ty/parameterized.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -53,6 +53,7 @@ trivially_parameterized_over_tcx! {\n     crate::metadata::ModChild,\n     crate::middle::codegen_fn_attrs::CodegenFnAttrs,\n     crate::middle::exported_symbols::SymbolExportInfo,\n+    crate::middle::resolve_lifetime::ObjectLifetimeDefault,\n     crate::mir::ConstQualifs,\n     ty::Generics,\n     ty::ImplPolarity,"}, {"sha": "53f33a7a0bad2516cde21120e629806b0898fa09", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 29, "deletions": 27, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -243,24 +243,6 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         throw_machine_stop_str!(\"pointer arithmetic or comparisons aren't supported in ConstProp\")\n     }\n \n-    fn access_local<'a>(\n-        frame: &'a Frame<'mir, 'tcx, Self::Provenance, Self::FrameExtra>,\n-        local: Local,\n-    ) -> InterpResult<'tcx, &'a interpret::Operand<Self::Provenance>> {\n-        let l = &frame.locals[local];\n-\n-        if matches!(\n-            l.value,\n-            LocalValue::Live(interpret::Operand::Immediate(interpret::Immediate::Uninit))\n-        ) {\n-            // For us \"uninit\" means \"we don't know its value, might be initiailized or not\".\n-            // So stop here.\n-            throw_machine_stop_str!(\"tried to access alocal with unknown value \")\n-        }\n-\n-        l.access()\n-    }\n-\n     fn access_local_mut<'a>(\n         ecx: &'a mut InterpCx<'mir, 'tcx, Self>,\n         frame: usize,\n@@ -431,7 +413,13 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n \n     fn get_const(&self, place: Place<'tcx>) -> Option<OpTy<'tcx>> {\n         let op = match self.ecx.eval_place_to_op(place, None) {\n-            Ok(op) => op,\n+            Ok(op) => {\n+                if matches!(*op, interpret::Operand::Immediate(Immediate::Uninit)) {\n+                    // Make sure nobody accidentally uses this value.\n+                    return None;\n+                }\n+                op\n+            }\n             Err(e) => {\n                 trace!(\"get_const failed: {}\", e);\n                 return None;\n@@ -643,6 +631,14 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         if rvalue.needs_subst() {\n             return None;\n         }\n+        if !rvalue\n+            .ty(&self.ecx.frame().body.local_decls, *self.ecx.tcx)\n+            .is_sized(self.ecx.tcx, self.param_env)\n+        {\n+            // the interpreter doesn't support unsized locals (only unsized arguments),\n+            // but rustc does (in a kinda broken way), so we have to skip them here\n+            return None;\n+        }\n \n         if self.tcx.sess.mir_opt_level() >= 4 {\n             self.eval_rvalue_with_identities(rvalue, place)\n@@ -660,18 +656,20 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         self.use_ecx(|this| match rvalue {\n             Rvalue::BinaryOp(op, box (left, right))\n             | Rvalue::CheckedBinaryOp(op, box (left, right)) => {\n-                let l = this.ecx.eval_operand(left, None);\n-                let r = this.ecx.eval_operand(right, None);\n+                let l = this.ecx.eval_operand(left, None).and_then(|x| this.ecx.read_immediate(&x));\n+                let r =\n+                    this.ecx.eval_operand(right, None).and_then(|x| this.ecx.read_immediate(&x));\n \n                 let const_arg = match (l, r) {\n-                    (Ok(ref x), Err(_)) | (Err(_), Ok(ref x)) => this.ecx.read_immediate(x)?,\n-                    (Err(e), Err(_)) => return Err(e),\n-                    (Ok(_), Ok(_)) => return this.ecx.eval_rvalue_into_place(rvalue, place),\n+                    (Ok(x), Err(_)) | (Err(_), Ok(x)) => x, // exactly one side is known\n+                    (Err(e), Err(_)) => return Err(e),      // neither side is known\n+                    (Ok(_), Ok(_)) => return this.ecx.eval_rvalue_into_place(rvalue, place), // both sides are known\n                 };\n \n                 if !matches!(const_arg.layout.abi, abi::Abi::Scalar(..)) {\n                     // We cannot handle Scalar Pair stuff.\n-                    return this.ecx.eval_rvalue_into_place(rvalue, place);\n+                    // No point in calling `eval_rvalue_into_place`, since only one side is known\n+                    throw_machine_stop_str!(\"cannot optimize this\")\n                 }\n \n                 let arg_value = const_arg.to_scalar().to_bits(const_arg.layout.size)?;\n@@ -696,7 +694,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                             this.ecx.write_immediate(*const_arg, &dest)\n                         }\n                     }\n-                    _ => this.ecx.eval_rvalue_into_place(rvalue, place),\n+                    _ => throw_machine_stop_str!(\"cannot optimize this\"),\n                 }\n             }\n             _ => this.ecx.eval_rvalue_into_place(rvalue, place),\n@@ -1073,7 +1071,11 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n                 if let Some(ref value) = self.eval_operand(&cond) {\n                     trace!(\"assertion on {:?} should be {:?}\", value, expected);\n                     let expected = Scalar::from_bool(*expected);\n-                    let value_const = self.ecx.read_scalar(&value).unwrap();\n+                    let Ok(value_const) = self.ecx.read_scalar(&value) else {\n+                        // FIXME should be used use_ecx rather than a local match... but we have\n+                        // quite a few of these read_scalar/read_immediate that need fixing.\n+                        return\n+                    };\n                     if expected != value_const {\n                         // Poison all places this operand references so that further code\n                         // doesn't use the invalid value"}, {"sha": "082d6c9f07e535c38175a741687ee8b144b85ea7", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -6,6 +6,7 @@ use crate::const_prop::ConstPropMachine;\n use crate::const_prop::ConstPropMode;\n use crate::MirLint;\n use rustc_const_eval::const_eval::ConstEvalErr;\n+use rustc_const_eval::interpret::Immediate;\n use rustc_const_eval::interpret::{\n     self, InterpCx, InterpResult, LocalState, LocalValue, MemoryKind, OpTy, Scalar, StackPopCleanup,\n };\n@@ -229,7 +230,13 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n \n     fn get_const(&self, place: Place<'tcx>) -> Option<OpTy<'tcx>> {\n         let op = match self.ecx.eval_place_to_op(place, None) {\n-            Ok(op) => op,\n+            Ok(op) => {\n+                if matches!(*op, interpret::Operand::Immediate(Immediate::Uninit)) {\n+                    // Make sure nobody accidentally uses this value.\n+                    return None;\n+                }\n+                op\n+            }\n             Err(e) => {\n                 trace!(\"get_const failed: {}\", e);\n                 return None;\n@@ -515,6 +522,14 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         if rvalue.needs_subst() {\n             return None;\n         }\n+        if !rvalue\n+            .ty(&self.ecx.frame().body.local_decls, *self.ecx.tcx)\n+            .is_sized(self.ecx.tcx, self.param_env)\n+        {\n+            // the interpreter doesn't support unsized locals (only unsized arguments),\n+            // but rustc does (in a kinda broken way), so we have to skip them here\n+            return None;\n+        }\n \n         self.use_ecx(source_info, |this| this.ecx.eval_rvalue_into_place(rvalue, place))\n     }\n@@ -624,7 +639,11 @@ impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n                 if let Some(ref value) = self.eval_operand(&cond, source_info) {\n                     trace!(\"assertion on {:?} should be {:?}\", value, expected);\n                     let expected = Scalar::from_bool(*expected);\n-                    let value_const = self.ecx.read_scalar(&value).unwrap();\n+                    let Ok(value_const) = self.ecx.read_scalar(&value) else {\n+                        // FIXME should be used use_ecx rather than a local match... but we have\n+                        // quite a few of these read_scalar/read_immediate that need fixing.\n+                        return\n+                    };\n                     if expected != value_const {\n                         enum DbgVal<T> {\n                             Val(T),\n@@ -641,9 +660,9 @@ impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n                         let mut eval_to_int = |op| {\n                             // This can be `None` if the lhs wasn't const propagated and we just\n                             // triggered the assert on the value of the rhs.\n-                            self.eval_operand(op, source_info).map_or(DbgVal::Underscore, |op| {\n-                                DbgVal::Val(self.ecx.read_immediate(&op).unwrap().to_const_int())\n-                            })\n+                            self.eval_operand(op, source_info)\n+                                .and_then(|op| self.ecx.read_immediate(&op).ok())\n+                                .map_or(DbgVal::Underscore, |op| DbgVal::Val(op.to_const_int()))\n                         };\n                         let msg = match msg {\n                             AssertKind::DivisionByZero(op) => {"}, {"sha": "a9e502016aa8d4ac2392a8ce4fada05db3d14563", "filename": "compiler/rustc_parse_format/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -167,6 +167,8 @@ pub enum Count<'a> {\n     CountIsName(&'a str, InnerSpan),\n     /// The count is specified by the argument at the given index.\n     CountIsParam(usize),\n+    /// The count is specified by a star (like in `{:.*}`) that refers to the argument at the given index.\n+    CountIsStar(usize),\n     /// The count is implied and cannot be explicitly specified.\n     CountImplied,\n }\n@@ -618,7 +620,7 @@ impl<'a> Parser<'a> {\n                 // We can do this immediately as `position` is resolved later.\n                 let i = self.curarg;\n                 self.curarg += 1;\n-                spec.precision = CountIsParam(i);\n+                spec.precision = CountIsStar(i);\n             } else {\n                 spec.precision = self.count(start + 1);\n             }"}, {"sha": "2f8c229c68ffe1e7ab48eb5dd818b462782ca103", "filename": "compiler/rustc_parse_format/src/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_parse_format%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_parse_format%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse_format%2Fsrc%2Ftests.rs?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -244,7 +244,7 @@ fn format_counts() {\n                 fill: None,\n                 align: AlignUnknown,\n                 flags: 0,\n-                precision: CountIsParam(0),\n+                precision: CountIsStar(0),\n                 precision_span: Some(InnerSpan { start: 3, end: 5 }),\n                 width: CountImplied,\n                 width_span: None,"}, {"sha": "f376da29bd919e63b0250fcda94bfd9e58d53078", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -16,6 +16,7 @@ use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{self, FnSig, ForeignItem, HirId, Item, ItemKind, TraitItem, CRATE_HIR_ID};\n use rustc_hir::{MethodKind, Target};\n use rustc_middle::hir::nested_filter;\n+use rustc_middle::middle::resolve_lifetime::ObjectLifetimeDefault;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::lint::builtin::{\n@@ -172,6 +173,9 @@ impl CheckAttrVisitor<'_> {\n                 sym::no_implicit_prelude => {\n                     self.check_generic_attr(hir_id, attr, target, &[Target::Mod])\n                 }\n+                sym::rustc_object_lifetime_default => {\n+                    self.check_object_lifetime_default(hir_id, span)\n+                }\n                 _ => {}\n             }\n \n@@ -410,6 +414,30 @@ impl CheckAttrVisitor<'_> {\n         }\n     }\n \n+    /// Debugging aid for `object_lifetime_default` query.\n+    fn check_object_lifetime_default(&self, hir_id: HirId, span: Span) {\n+        let tcx = self.tcx;\n+        if let Some(generics) = tcx.hir().get_generics(tcx.hir().local_def_id(hir_id)) {\n+            let object_lifetime_default_reprs: String = generics\n+                .params\n+                .iter()\n+                .filter_map(|p| {\n+                    let param_id = tcx.hir().local_def_id(p.hir_id);\n+                    let default = tcx.object_lifetime_default(param_id)?;\n+                    Some(match default {\n+                        ObjectLifetimeDefault::Empty => \"BaseDefault\".to_owned(),\n+                        ObjectLifetimeDefault::Static => \"'static\".to_owned(),\n+                        ObjectLifetimeDefault::Param(def_id) => tcx.item_name(def_id).to_string(),\n+                        ObjectLifetimeDefault::Ambiguous => \"Ambiguous\".to_owned(),\n+                    })\n+                })\n+                .collect::<Vec<String>>()\n+                .join(\",\");\n+\n+            tcx.sess.span_err(span, &object_lifetime_default_reprs);\n+        }\n+    }\n+\n     /// Checks if a `#[track_caller]` is applied to a non-naked function. Returns `true` if valid.\n     fn check_track_caller(\n         &self,"}, {"sha": "6ea976a59006470517ddf93e68df4014d8605ffd", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 80, "deletions": 374, "changes": 454, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -11,23 +11,21 @@ use rustc_data_structures::fx::{FxHashSet, FxIndexMap, FxIndexSet};\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::{DefIdMap, LocalDefId};\n+use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{GenericArg, GenericParam, GenericParamKind, HirIdMap, LifetimeName, Node};\n use rustc_middle::bug;\n use rustc_middle::hir::map::Map;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::resolve_lifetime::*;\n-use rustc_middle::ty::{self, GenericParamDefKind, TyCtxt};\n+use rustc_middle::ty::{self, DefIdTree, TyCtxt};\n use rustc_span::def_id::DefId;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n-use std::borrow::Cow;\n use std::fmt;\n-use std::mem::take;\n \n trait RegionExt {\n-    fn early(hir_map: Map<'_>, index: &mut u32, param: &GenericParam<'_>) -> (LocalDefId, Region);\n+    fn early(hir_map: Map<'_>, param: &GenericParam<'_>) -> (LocalDefId, Region);\n \n     fn late(index: u32, hir_map: Map<'_>, param: &GenericParam<'_>) -> (LocalDefId, Region);\n \n@@ -36,19 +34,13 @@ trait RegionExt {\n     fn shifted(self, amount: u32) -> Region;\n \n     fn shifted_out_to_binder(self, binder: ty::DebruijnIndex) -> Region;\n-\n-    fn subst<'a, L>(self, params: L, map: &NamedRegionMap) -> Option<Region>\n-    where\n-        L: Iterator<Item = &'a hir::Lifetime>;\n }\n \n impl RegionExt for Region {\n-    fn early(hir_map: Map<'_>, index: &mut u32, param: &GenericParam<'_>) -> (LocalDefId, Region) {\n-        let i = *index;\n-        *index += 1;\n+    fn early(hir_map: Map<'_>, param: &GenericParam<'_>) -> (LocalDefId, Region) {\n         let def_id = hir_map.local_def_id(param.hir_id);\n-        debug!(\"Region::early: index={} def_id={:?}\", i, def_id);\n-        (def_id, Region::EarlyBound(i, def_id.to_def_id()))\n+        debug!(\"Region::early: def_id={:?}\", def_id);\n+        (def_id, Region::EarlyBound(def_id.to_def_id()))\n     }\n \n     fn late(idx: u32, hir_map: Map<'_>, param: &GenericParam<'_>) -> (LocalDefId, Region) {\n@@ -65,9 +57,7 @@ impl RegionExt for Region {\n         match *self {\n             Region::Static => None,\n \n-            Region::EarlyBound(_, id) | Region::LateBound(_, _, id) | Region::Free(_, id) => {\n-                Some(id)\n-            }\n+            Region::EarlyBound(id) | Region::LateBound(_, _, id) | Region::Free(_, id) => Some(id),\n         }\n     }\n \n@@ -88,17 +78,6 @@ impl RegionExt for Region {\n             _ => self,\n         }\n     }\n-\n-    fn subst<'a, L>(self, mut params: L, map: &NamedRegionMap) -> Option<Region>\n-    where\n-        L: Iterator<Item = &'a hir::Lifetime>,\n-    {\n-        if let Region::EarlyBound(index, _) = self {\n-            params.nth(index as usize).and_then(|lifetime| map.defs.get(&lifetime.hir_id).cloned())\n-        } else {\n-            Some(self)\n-        }\n-    }\n }\n \n /// Maps the id of each lifetime reference to the lifetime decl\n@@ -131,9 +110,6 @@ pub(crate) struct LifetimeContext<'a, 'tcx> {\n     /// be false if the `Item` we are resolving lifetimes for is not a trait or\n     /// we eventually need lifetimes resolve for trait items.\n     trait_definition_only: bool,\n-\n-    /// Cache for cross-crate per-definition object lifetime defaults.\n-    xcrate_object_lifetime_defaults: DefIdMap<Vec<ObjectLifetimeDefault>>,\n }\n \n #[derive(Debug)]\n@@ -147,25 +123,6 @@ enum Scope<'a> {\n         /// for diagnostics.\n         lifetimes: FxIndexMap<LocalDefId, Region>,\n \n-        /// if we extend this scope with another scope, what is the next index\n-        /// we should use for an early-bound region?\n-        next_early_index: u32,\n-\n-        /// Whether or not this binder would serve as the parent\n-        /// binder for opaque types introduced within. For example:\n-        ///\n-        /// ```text\n-        ///     fn foo<'a>() -> impl for<'b> Trait<Item = impl Trait2<'a>>\n-        /// ```\n-        ///\n-        /// Here, the opaque types we create for the `impl Trait`\n-        /// and `impl Trait2` references will both have the `foo` item\n-        /// as their parent. When we get to `impl Trait2`, we find\n-        /// that it is nested within the `for<>` binder -- this flag\n-        /// allows us to skip that when looking for the parent binder\n-        /// of the resulting opaque type.\n-        opaque_type_parent: bool,\n-\n         scope_type: BinderScopeType,\n \n         /// The late bound vars for a given item are stored by `HirId` to be\n@@ -245,19 +202,9 @@ struct TruncatedScopeDebug<'a>(&'a Scope<'a>);\n impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self.0 {\n-            Scope::Binder {\n-                lifetimes,\n-                next_early_index,\n-                opaque_type_parent,\n-                scope_type,\n-                hir_id,\n-                where_bound_origin,\n-                s: _,\n-            } => f\n+            Scope::Binder { lifetimes, scope_type, hir_id, where_bound_origin, s: _ } => f\n                 .debug_struct(\"Binder\")\n                 .field(\"lifetimes\", lifetimes)\n-                .field(\"next_early_index\", next_early_index)\n-                .field(\"opaque_type_parent\", opaque_type_parent)\n                 .field(\"scope_type\", scope_type)\n                 .field(\"hir_id\", hir_id)\n                 .field(\"where_bound_origin\", where_bound_origin)\n@@ -294,10 +241,7 @@ pub fn provide(providers: &mut ty::query::Providers) {\n \n         named_region_map: |tcx, id| resolve_lifetimes_for(tcx, id).defs.get(&id),\n         is_late_bound_map,\n-        object_lifetime_defaults: |tcx, id| match tcx.hir().find_by_def_id(id) {\n-            Some(Node::Item(item)) => compute_object_lifetime_defaults(tcx, item),\n-            _ => None,\n-        },\n+        object_lifetime_default,\n         late_bound_vars_map: |tcx, id| resolve_lifetimes_for(tcx, id).late_bound_vars.get(&id),\n \n         ..*providers\n@@ -363,7 +307,6 @@ fn do_resolve(\n         map: &mut named_region_map,\n         scope: ROOT_SCOPE,\n         trait_definition_only,\n-        xcrate_object_lifetime_defaults: Default::default(),\n     };\n     visitor.visit_item(item);\n \n@@ -432,13 +375,6 @@ fn item_for(tcx: TyCtxt<'_>, local_def_id: LocalDefId) -> LocalDefId {\n     item\n }\n \n-/// In traits, there is an implicit `Self` type parameter which comes before the generics.\n-/// We have to account for this when computing the index of the other generic parameters.\n-/// This function returns whether there is such an implicit parameter defined on the given item.\n-fn sub_items_have_self_param(node: &hir::ItemKind<'_>) -> bool {\n-    matches!(*node, hir::ItemKind::Trait(..) | hir::ItemKind::TraitAlias(..))\n-}\n-\n fn late_region_as_bound_region<'tcx>(tcx: TyCtxt<'tcx>, region: &Region) -> ty::BoundVariableKind {\n     match region {\n         Region::LateBound(_, _, def_id) => {\n@@ -558,7 +494,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 }\n             }\n \n-            let next_early_index = self.next_early_index();\n             let (lifetimes, binders): (FxIndexMap<LocalDefId, Region>, Vec<_>) =\n                 bound_generic_params\n                     .iter()\n@@ -576,8 +511,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 hir_id: e.hir_id,\n                 lifetimes,\n                 s: self.scope,\n-                next_early_index,\n-                opaque_type_parent: false,\n                 scope_type: BinderScopeType::Normal,\n                 where_bound_origin: None,\n             };\n@@ -603,7 +536,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         }\n         match item.kind {\n             hir::ItemKind::Fn(_, ref generics, _) => {\n-                self.visit_early_late(None, item.hir_id(), generics, |this| {\n+                self.visit_early_late(item.hir_id(), generics, |this| {\n                     intravisit::walk_item(this, item);\n                 });\n             }\n@@ -670,31 +603,20 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             | hir::ItemKind::TraitAlias(ref generics, ..)\n             | hir::ItemKind::Impl(hir::Impl { ref generics, .. }) => {\n                 // These kinds of items have only early-bound lifetime parameters.\n-                let mut index = if sub_items_have_self_param(&item.kind) {\n-                    1 // Self comes before lifetimes\n-                } else {\n-                    0\n-                };\n-                let mut non_lifetime_count = 0;\n                 let lifetimes = generics\n                     .params\n                     .iter()\n                     .filter_map(|param| match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n-                            Some(Region::early(self.tcx.hir(), &mut index, param))\n-                        }\n-                        GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n-                            non_lifetime_count += 1;\n-                            None\n+                            Some(Region::early(self.tcx.hir(), param))\n                         }\n+                        GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => None,\n                     })\n                     .collect();\n                 self.map.late_bound_vars.insert(item.hir_id(), vec![]);\n                 let scope = Scope::Binder {\n                     hir_id: item.hir_id(),\n                     lifetimes,\n-                    next_early_index: index + non_lifetime_count,\n-                    opaque_type_parent: true,\n                     scope_type: BinderScopeType::Normal,\n                     s: ROOT_SCOPE,\n                     where_bound_origin: None,\n@@ -712,7 +634,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem<'tcx>) {\n         match item.kind {\n             hir::ForeignItemKind::Fn(_, _, ref generics) => {\n-                self.visit_early_late(None, item.hir_id(), generics, |this| {\n+                self.visit_early_late(item.hir_id(), generics, |this| {\n                     intravisit::walk_foreign_item(this, item);\n                 })\n             }\n@@ -729,7 +651,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &'tcx hir::Ty<'tcx>) {\n         match ty.kind {\n             hir::TyKind::BareFn(ref c) => {\n-                let next_early_index = self.next_early_index();\n                 let (lifetimes, binders): (FxIndexMap<LocalDefId, Region>, Vec<_>) = c\n                     .generic_params\n                     .iter()\n@@ -746,8 +667,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     hir_id: ty.hir_id,\n                     lifetimes,\n                     s: self.scope,\n-                    next_early_index,\n-                    opaque_type_parent: false,\n                     scope_type: BinderScopeType::Normal,\n                     where_bound_origin: None,\n                 };\n@@ -886,32 +805,23 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n                 // We want to start our early-bound indices at the end of the parent scope,\n                 // not including any parent `impl Trait`s.\n-                let mut index = self.next_early_index_for_opaque_type();\n-                debug!(?index);\n-\n                 let mut lifetimes = FxIndexMap::default();\n-                let mut non_lifetime_count = 0;\n                 debug!(?generics.params);\n                 for param in generics.params {\n                     match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n-                            let (def_id, reg) = Region::early(self.tcx.hir(), &mut index, &param);\n+                            let (def_id, reg) = Region::early(self.tcx.hir(), &param);\n                             lifetimes.insert(def_id, reg);\n                         }\n-                        GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n-                            non_lifetime_count += 1;\n-                        }\n+                        GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {}\n                     }\n                 }\n-                let next_early_index = index + non_lifetime_count;\n                 self.map.late_bound_vars.insert(ty.hir_id, vec![]);\n \n                 let scope = Scope::Binder {\n                     hir_id: ty.hir_id,\n                     lifetimes,\n-                    next_early_index,\n                     s: self.scope,\n-                    opaque_type_parent: false,\n                     scope_type: BinderScopeType::Normal,\n                     where_bound_origin: None,\n                 };\n@@ -933,39 +843,27 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         use self::hir::TraitItemKind::*;\n         match trait_item.kind {\n             Fn(_, _) => {\n-                let tcx = self.tcx;\n-                self.visit_early_late(\n-                    Some(tcx.hir().get_parent_item(trait_item.hir_id())),\n-                    trait_item.hir_id(),\n-                    &trait_item.generics,\n-                    |this| intravisit::walk_trait_item(this, trait_item),\n-                );\n+                self.visit_early_late(trait_item.hir_id(), &trait_item.generics, |this| {\n+                    intravisit::walk_trait_item(this, trait_item)\n+                });\n             }\n             Type(bounds, ref ty) => {\n                 let generics = &trait_item.generics;\n-                let mut index = self.next_early_index();\n-                debug!(\"visit_ty: index = {}\", index);\n-                let mut non_lifetime_count = 0;\n                 let lifetimes = generics\n                     .params\n                     .iter()\n                     .filter_map(|param| match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n-                            Some(Region::early(self.tcx.hir(), &mut index, param))\n-                        }\n-                        GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n-                            non_lifetime_count += 1;\n-                            None\n+                            Some(Region::early(self.tcx.hir(), param))\n                         }\n+                        GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => None,\n                     })\n                     .collect();\n                 self.map.late_bound_vars.insert(trait_item.hir_id(), vec![]);\n                 let scope = Scope::Binder {\n                     hir_id: trait_item.hir_id(),\n                     lifetimes,\n-                    next_early_index: index + non_lifetime_count,\n                     s: self.scope,\n-                    opaque_type_parent: true,\n                     scope_type: BinderScopeType::Normal,\n                     where_bound_origin: None,\n                 };\n@@ -993,40 +891,26 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n         use self::hir::ImplItemKind::*;\n         match impl_item.kind {\n-            Fn(..) => {\n-                let tcx = self.tcx;\n-                self.visit_early_late(\n-                    Some(tcx.hir().get_parent_item(impl_item.hir_id())),\n-                    impl_item.hir_id(),\n-                    &impl_item.generics,\n-                    |this| intravisit::walk_impl_item(this, impl_item),\n-                );\n-            }\n+            Fn(..) => self.visit_early_late(impl_item.hir_id(), &impl_item.generics, |this| {\n+                intravisit::walk_impl_item(this, impl_item)\n+            }),\n             TyAlias(ref ty) => {\n                 let generics = &impl_item.generics;\n-                let mut index = self.next_early_index();\n-                let mut non_lifetime_count = 0;\n-                debug!(\"visit_ty: index = {}\", index);\n                 let lifetimes: FxIndexMap<LocalDefId, Region> = generics\n                     .params\n                     .iter()\n                     .filter_map(|param| match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n-                            Some(Region::early(self.tcx.hir(), &mut index, param))\n-                        }\n-                        GenericParamKind::Const { .. } | GenericParamKind::Type { .. } => {\n-                            non_lifetime_count += 1;\n-                            None\n+                            Some(Region::early(self.tcx.hir(), param))\n                         }\n+                        GenericParamKind::Const { .. } | GenericParamKind::Type { .. } => None,\n                     })\n                     .collect();\n                 self.map.late_bound_vars.insert(ty.hir_id, vec![]);\n                 let scope = Scope::Binder {\n                     hir_id: ty.hir_id,\n                     lifetimes,\n-                    next_early_index: index + non_lifetime_count,\n                     s: self.scope,\n-                    opaque_type_parent: true,\n                     scope_type: BinderScopeType::Normal,\n                     where_bound_origin: None,\n                 };\n@@ -1129,7 +1013,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                                 })\n                                 .unzip();\n                         this.map.late_bound_vars.insert(bounded_ty.hir_id, binders.clone());\n-                        let next_early_index = this.next_early_index();\n                         // Even if there are no lifetimes defined here, we still wrap it in a binder\n                         // scope. If there happens to be a nested poly trait ref (an error), that\n                         // will be `Concatenating` anyways, so we don't have to worry about the depth\n@@ -1138,8 +1021,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                             hir_id: bounded_ty.hir_id,\n                             lifetimes,\n                             s: this.scope,\n-                            next_early_index,\n-                            opaque_type_parent: false,\n                             scope_type: BinderScopeType::Normal,\n                             where_bound_origin: Some(origin),\n                         };\n@@ -1210,8 +1091,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     hir_id: *hir_id,\n                     lifetimes: FxIndexMap::default(),\n                     s: self.scope,\n-                    next_early_index: self.next_early_index(),\n-                    opaque_type_parent: false,\n                     scope_type,\n                     where_bound_origin: None,\n                 };\n@@ -1230,7 +1109,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     ) {\n         debug!(\"visit_poly_trait_ref(trait_ref={:?})\", trait_ref);\n \n-        let next_early_index = self.next_early_index();\n         let (mut binders, scope_type) = self.poly_trait_ref_binder_info();\n \n         let initial_bound_vars = binders.len() as u32;\n@@ -1260,8 +1138,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             hir_id: trait_ref.trait_ref.hir_ref_id,\n             lifetimes,\n             s: self.scope,\n-            next_early_index,\n-            opaque_type_parent: false,\n             scope_type,\n             where_bound_origin: None,\n         };\n@@ -1272,139 +1148,56 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     }\n }\n \n-fn compute_object_lifetime_defaults<'tcx>(\n+fn object_lifetime_default<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    item: &hir::Item<'_>,\n-) -> Option<&'tcx [ObjectLifetimeDefault]> {\n-    match item.kind {\n-        hir::ItemKind::Struct(_, ref generics)\n-        | hir::ItemKind::Union(_, ref generics)\n-        | hir::ItemKind::Enum(_, ref generics)\n-        | hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n-            ref generics,\n-            origin: hir::OpaqueTyOrigin::TyAlias,\n-            ..\n-        })\n-        | hir::ItemKind::TyAlias(_, ref generics)\n-        | hir::ItemKind::Trait(_, _, ref generics, ..) => {\n-            let result = object_lifetime_defaults_for_item(tcx, generics);\n-\n-            // Debugging aid.\n-            let attrs = tcx.hir().attrs(item.hir_id());\n-            if tcx.sess.contains_name(attrs, sym::rustc_object_lifetime_default) {\n-                let object_lifetime_default_reprs: String = result\n-                    .iter()\n-                    .map(|set| match *set {\n-                        Set1::Empty => \"BaseDefault\".into(),\n-                        Set1::One(Region::Static) => \"'static\".into(),\n-                        Set1::One(Region::EarlyBound(mut i, _)) => generics\n-                            .params\n-                            .iter()\n-                            .find_map(|param| match param.kind {\n-                                GenericParamKind::Lifetime { .. } => {\n-                                    if i == 0 {\n-                                        return Some(param.name.ident().to_string().into());\n-                                    }\n-                                    i -= 1;\n-                                    None\n-                                }\n-                                _ => None,\n-                            })\n-                            .unwrap(),\n-                        Set1::One(_) => bug!(),\n-                        Set1::Many => \"Ambiguous\".into(),\n-                    })\n-                    .collect::<Vec<Cow<'static, str>>>()\n-                    .join(\",\");\n-                tcx.sess.span_err(item.span, &object_lifetime_default_reprs);\n-            }\n-\n-            Some(result)\n-        }\n-        _ => None,\n-    }\n-}\n-\n-/// Scan the bounds and where-clauses on parameters to extract bounds\n-/// of the form `T:'a` so as to determine the `ObjectLifetimeDefault`\n-/// for each type parameter.\n-fn object_lifetime_defaults_for_item<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    generics: &hir::Generics<'_>,\n-) -> &'tcx [ObjectLifetimeDefault] {\n-    fn add_bounds(set: &mut Set1<hir::LifetimeName>, bounds: &[hir::GenericBound<'_>]) {\n-        for bound in bounds {\n-            if let hir::GenericBound::Outlives(ref lifetime) = *bound {\n-                set.insert(lifetime.name.normalize_to_macros_2_0());\n-            }\n-        }\n-    }\n-\n-    let process_param = |param: &hir::GenericParam<'_>| match param.kind {\n+    param_def_id: DefId,\n+) -> Option<ObjectLifetimeDefault> {\n+    let param_def_id = param_def_id.expect_local();\n+    let parent_def_id = tcx.local_parent(param_def_id);\n+    let generics = tcx.hir().get_generics(parent_def_id)?;\n+    let param_hir_id = tcx.local_def_id_to_hir_id(param_def_id);\n+    let param = generics.params.iter().find(|p| p.hir_id == param_hir_id)?;\n+\n+    // Scan the bounds and where-clauses on parameters to extract bounds\n+    // of the form `T:'a` so as to determine the `ObjectLifetimeDefault`\n+    // for each type parameter.\n+    match param.kind {\n         GenericParamKind::Lifetime { .. } => None,\n         GenericParamKind::Type { .. } => {\n             let mut set = Set1::Empty;\n \n-            let param_def_id = tcx.hir().local_def_id(param.hir_id);\n-            for predicate in generics.predicates {\n-                // Look for `type: ...` where clauses.\n-                let hir::WherePredicate::BoundPredicate(ref data) = *predicate else { continue };\n-\n+            // Look for `type: ...` where clauses.\n+            for bound in generics.bounds_for_param(param_def_id) {\n                 // Ignore `for<'a> type: ...` as they can change what\n                 // lifetimes mean (although we could \"just\" handle it).\n-                if !data.bound_generic_params.is_empty() {\n+                if !bound.bound_generic_params.is_empty() {\n                     continue;\n                 }\n \n-                let res = match data.bounded_ty.kind {\n-                    hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => path.res,\n-                    _ => continue,\n-                };\n-\n-                if res == Res::Def(DefKind::TyParam, param_def_id.to_def_id()) {\n-                    add_bounds(&mut set, &data.bounds);\n+                for bound in bound.bounds {\n+                    if let hir::GenericBound::Outlives(ref lifetime) = *bound {\n+                        set.insert(lifetime.name.normalize_to_macros_2_0());\n+                    }\n                 }\n             }\n \n             Some(match set {\n-                Set1::Empty => Set1::Empty,\n-                Set1::One(name) => {\n-                    if name == hir::LifetimeName::Static {\n-                        Set1::One(Region::Static)\n-                    } else {\n-                        generics\n-                            .params\n-                            .iter()\n-                            .filter_map(|param| match param.kind {\n-                                GenericParamKind::Lifetime { .. } => {\n-                                    let param_def_id = tcx.hir().local_def_id(param.hir_id);\n-                                    Some((\n-                                        param_def_id,\n-                                        hir::LifetimeName::Param(param_def_id, param.name),\n-                                    ))\n-                                }\n-                                _ => None,\n-                            })\n-                            .enumerate()\n-                            .find(|&(_, (_, lt_name))| lt_name == name)\n-                            .map_or(Set1::Many, |(i, (def_id, _))| {\n-                                Set1::One(Region::EarlyBound(i as u32, def_id.to_def_id()))\n-                            })\n-                    }\n+                Set1::Empty => ObjectLifetimeDefault::Empty,\n+                Set1::One(hir::LifetimeName::Static) => ObjectLifetimeDefault::Static,\n+                Set1::One(hir::LifetimeName::Param(param_def_id, _)) => {\n+                    ObjectLifetimeDefault::Param(param_def_id.to_def_id())\n                 }\n-                Set1::Many => Set1::Many,\n+                _ => ObjectLifetimeDefault::Ambiguous,\n             })\n         }\n         GenericParamKind::Const { .. } => {\n             // Generic consts don't impose any constraints.\n             //\n             // We still store a dummy value here to allow generic parameters\n             // in an arbitrary order.\n-            Some(Set1::Empty)\n+            Some(ObjectLifetimeDefault::Empty)\n         }\n-    };\n-\n-    tcx.arena.alloc_from_iter(generics.params.iter().filter_map(process_param))\n+    }\n }\n \n impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n@@ -1413,20 +1206,17 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         F: for<'b> FnOnce(&mut LifetimeContext<'b, 'tcx>),\n     {\n         let LifetimeContext { tcx, map, .. } = self;\n-        let xcrate_object_lifetime_defaults = take(&mut self.xcrate_object_lifetime_defaults);\n         let mut this = LifetimeContext {\n             tcx: *tcx,\n             map,\n             scope: &wrap_scope,\n             trait_definition_only: self.trait_definition_only,\n-            xcrate_object_lifetime_defaults,\n         };\n         let span = tracing::debug_span!(\"scope\", scope = ?TruncatedScopeDebug(&this.scope));\n         {\n             let _enter = span.enter();\n             f(&mut this);\n         }\n-        self.xcrate_object_lifetime_defaults = this.xcrate_object_lifetime_defaults;\n     }\n \n     /// Visits self by adding a scope and handling recursive walk over the contents with `walk`.\n@@ -1449,30 +1239,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     /// ordering is not important there.\n     fn visit_early_late<F>(\n         &mut self,\n-        parent_id: Option<LocalDefId>,\n         hir_id: hir::HirId,\n         generics: &'tcx hir::Generics<'tcx>,\n         walk: F,\n     ) where\n         F: for<'b, 'c> FnOnce(&'b mut LifetimeContext<'c, 'tcx>),\n     {\n-        // Find the start of nested early scopes, e.g., in methods.\n-        let mut next_early_index = 0;\n-        if let Some(parent_id) = parent_id {\n-            let parent = self.tcx.hir().expect_item(parent_id);\n-            if sub_items_have_self_param(&parent.kind) {\n-                next_early_index += 1; // Self comes before lifetimes\n-            }\n-            match parent.kind {\n-                hir::ItemKind::Trait(_, _, ref generics, ..)\n-                | hir::ItemKind::Impl(hir::Impl { ref generics, .. }) => {\n-                    next_early_index += generics.params.len() as u32;\n-                }\n-                _ => {}\n-            }\n-        }\n-\n-        let mut non_lifetime_count = 0;\n         let mut named_late_bound_vars = 0;\n         let lifetimes: FxIndexMap<LocalDefId, Region> = generics\n             .params\n@@ -1484,16 +1256,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         named_late_bound_vars += 1;\n                         Some(Region::late(late_bound_idx, self.tcx.hir(), param))\n                     } else {\n-                        Some(Region::early(self.tcx.hir(), &mut next_early_index, param))\n+                        Some(Region::early(self.tcx.hir(), param))\n                     }\n                 }\n-                GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n-                    non_lifetime_count += 1;\n-                    None\n-                }\n+                GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => None,\n             })\n             .collect();\n-        let next_early_index = next_early_index + non_lifetime_count;\n \n         let binders: Vec<_> = generics\n             .params\n@@ -1512,51 +1280,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let scope = Scope::Binder {\n             hir_id,\n             lifetimes,\n-            next_early_index,\n             s: self.scope,\n-            opaque_type_parent: true,\n             scope_type: BinderScopeType::Normal,\n             where_bound_origin: None,\n         };\n         self.with(scope, walk);\n     }\n \n-    fn next_early_index_helper(&self, only_opaque_type_parent: bool) -> u32 {\n-        let mut scope = self.scope;\n-        loop {\n-            match *scope {\n-                Scope::Root => return 0,\n-\n-                Scope::Binder { next_early_index, opaque_type_parent, .. }\n-                    if (!only_opaque_type_parent || opaque_type_parent) =>\n-                {\n-                    return next_early_index;\n-                }\n-\n-                Scope::Binder { s, .. }\n-                | Scope::Body { s, .. }\n-                | Scope::Elision { s, .. }\n-                | Scope::ObjectLifetimeDefault { s, .. }\n-                | Scope::Supertrait { s, .. }\n-                | Scope::TraitRefBoundary { s, .. } => scope = s,\n-            }\n-        }\n-    }\n-\n-    /// Returns the next index one would use for an early-bound-region\n-    /// if extending the current scope.\n-    fn next_early_index(&self) -> u32 {\n-        self.next_early_index_helper(true)\n-    }\n-\n-    /// Returns the next index one would use for an `impl Trait` that\n-    /// is being converted into an opaque type alias `impl Trait`. This will be the\n-    /// next early index from the enclosing item, for the most\n-    /// part. See the `opaque_type_parent` field for more info.\n-    fn next_early_index_for_opaque_type(&self) -> u32 {\n-        self.next_early_index_helper(false)\n-    }\n-\n     #[tracing::instrument(level = \"debug\", skip(self))]\n     fn resolve_lifetime_ref(\n         &mut self,\n@@ -1679,17 +1409,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         );\n     }\n \n+    #[tracing::instrument(level = \"debug\", skip(self))]\n     fn visit_segment_args(\n         &mut self,\n         res: Res,\n         depth: usize,\n         generic_args: &'tcx hir::GenericArgs<'tcx>,\n     ) {\n-        debug!(\n-            \"visit_segment_args(res={:?}, depth={:?}, generic_args={:?})\",\n-            res, depth, generic_args,\n-        );\n-\n         if generic_args.parenthesized {\n             self.visit_fn_like_elision(\n                 generic_args.inputs(),\n@@ -1707,13 +1433,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n         // Figure out if this is a type/trait segment,\n         // which requires object lifetime defaults.\n-        let parent_def_id = |this: &mut Self, def_id: DefId| {\n-            let def_key = this.tcx.def_key(def_id);\n-            DefId { krate: def_id.krate, index: def_key.parent.expect(\"missing parent\") }\n-        };\n         let type_def_id = match res {\n-            Res::Def(DefKind::AssocTy, def_id) if depth == 1 => Some(parent_def_id(self, def_id)),\n-            Res::Def(DefKind::Variant, def_id) if depth == 0 => Some(parent_def_id(self, def_id)),\n+            Res::Def(DefKind::AssocTy, def_id) if depth == 1 => Some(self.tcx.parent(def_id)),\n+            Res::Def(DefKind::Variant, def_id) if depth == 0 => Some(self.tcx.parent(def_id)),\n             Res::Def(\n                 DefKind::Struct\n                 | DefKind::Union\n@@ -1725,7 +1447,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             _ => None,\n         };\n \n-        debug!(\"visit_segment_args: type_def_id={:?}\", type_def_id);\n+        debug!(?type_def_id);\n \n         // Compute a vector of defaults, one for each type parameter,\n         // per the rules given in RFCs 599 and 1156. Example:\n@@ -1763,55 +1485,39 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             };\n \n             let map = &self.map;\n-            let set_to_region = |set: &ObjectLifetimeDefault| match *set {\n-                Set1::Empty => {\n+            let generics = self.tcx.generics_of(def_id);\n+\n+            // `type_def_id` points to an item, so there is nothing to inherit generics from.\n+            debug_assert_eq!(generics.parent_count, 0);\n+\n+            let set_to_region = |set: ObjectLifetimeDefault| match set {\n+                ObjectLifetimeDefault::Empty => {\n                     if in_body {\n                         None\n                     } else {\n                         Some(Region::Static)\n                     }\n                 }\n-                Set1::One(r) => {\n-                    let lifetimes = generic_args.args.iter().filter_map(|arg| match arg {\n-                        GenericArg::Lifetime(lt) => Some(lt),\n+                ObjectLifetimeDefault::Static => Some(Region::Static),\n+                ObjectLifetimeDefault::Param(param_def_id) => {\n+                    // This index can be used with `generic_args` since `parent_count == 0`.\n+                    let index = generics.param_def_id_to_index[&param_def_id] as usize;\n+                    generic_args.args.get(index).and_then(|arg| match arg {\n+                        GenericArg::Lifetime(lt) => map.defs.get(&lt.hir_id).copied(),\n                         _ => None,\n-                    });\n-                    r.subst(lifetimes, map)\n+                    })\n                 }\n-                Set1::Many => None,\n+                ObjectLifetimeDefault::Ambiguous => None,\n             };\n-            if let Some(def_id) = def_id.as_local() {\n-                let id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n-                self.tcx\n-                    .object_lifetime_defaults(id.owner)\n-                    .unwrap()\n-                    .iter()\n-                    .map(set_to_region)\n-                    .collect()\n-            } else {\n-                let tcx = self.tcx;\n-                self.xcrate_object_lifetime_defaults\n-                    .entry(def_id)\n-                    .or_insert_with(|| {\n-                        tcx.generics_of(def_id)\n-                            .params\n-                            .iter()\n-                            .filter_map(|param| match param.kind {\n-                                GenericParamDefKind::Type { object_lifetime_default, .. } => {\n-                                    Some(object_lifetime_default)\n-                                }\n-                                GenericParamDefKind::Const { .. } => Some(Set1::Empty),\n-                                GenericParamDefKind::Lifetime => None,\n-                            })\n-                            .collect()\n-                    })\n-                    .iter()\n-                    .map(set_to_region)\n-                    .collect()\n-            }\n+            generics\n+                .params\n+                .iter()\n+                .filter_map(|param| self.tcx.object_lifetime_default(param.def_id))\n+                .map(set_to_region)\n+                .collect()\n         });\n \n-        debug!(\"visit_segment_args: object_lifetime_defaults={:?}\", object_lifetime_defaults);\n+        debug!(?object_lifetime_defaults);\n \n         let mut i = 0;\n         for arg in generic_args.args {"}, {"sha": "5c96f1c4623a6c9010633d79951b1af3023c96c4", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -222,9 +222,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 tcx.mk_region(ty::ReLateBound(debruijn, br))\n             }\n \n-            Some(rl::Region::EarlyBound(index, id)) => {\n-                let name = lifetime_name(id.expect_local());\n-                tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion { def_id: id, index, name }))\n+            Some(rl::Region::EarlyBound(def_id)) => {\n+                let name = tcx.hir().ty_param_name(def_id.expect_local());\n+                let item_def_id = tcx.hir().ty_param_owner(def_id.expect_local());\n+                let generics = tcx.generics_of(item_def_id);\n+                let index = generics.param_def_id_to_index[&def_id];\n+                tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion { def_id, index, name }))\n             }\n \n             Some(rl::Region::Free(scope, id)) => {\n@@ -253,9 +256,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 })\n             }\n         };\n-\n         debug!(\"ast_region_to_region(lifetime={:?}) yields {:?}\", lifetime, r);\n-\n         r\n     }\n \n@@ -2853,10 +2854,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             );\n \n             if !infer_replacements.is_empty() {\n-                diag.multipart_suggestion(&format!(\n+                diag.multipart_suggestion(\n+                    &format!(\n                     \"try replacing `_` with the type{} in the corresponding trait method signature\",\n                     rustc_errors::pluralize!(infer_replacements.len()),\n-                ), infer_replacements, Applicability::MachineApplicable);\n+                ),\n+                    infer_replacements,\n+                    Applicability::MachineApplicable,\n+                );\n             }\n \n             diag.emit();"}, {"sha": "6236ad370df60e1bcd30a14c92b70a2fbd498dac", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 3, "deletions": 20, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -1617,7 +1617,6 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n                         pure_wrt_drop: false,\n                         kind: ty::GenericParamDefKind::Type {\n                             has_default: false,\n-                            object_lifetime_default: rl::Set1::Empty,\n                             synthetic: false,\n                         },\n                     });\n@@ -1661,8 +1660,6 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n         kind: ty::GenericParamDefKind::Lifetime,\n     }));\n \n-    let object_lifetime_defaults = tcx.object_lifetime_defaults(hir_id.owner);\n-\n     // Now create the real type and const parameters.\n     let type_start = own_start - has_self as u32 + params.len() as u32;\n     let mut i = 0;\n@@ -1687,13 +1684,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n                 }\n             }\n \n-            let kind = ty::GenericParamDefKind::Type {\n-                has_default: default.is_some(),\n-                object_lifetime_default: object_lifetime_defaults\n-                    .as_ref()\n-                    .map_or(rl::Set1::Empty, |o| o[i]),\n-                synthetic,\n-            };\n+            let kind = ty::GenericParamDefKind::Type { has_default: default.is_some(), synthetic };\n \n             let param_def = ty::GenericParamDef {\n                 index: type_start + i as u32,\n@@ -1745,11 +1736,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n             name: Symbol::intern(arg),\n             def_id,\n             pure_wrt_drop: false,\n-            kind: ty::GenericParamDefKind::Type {\n-                has_default: false,\n-                object_lifetime_default: rl::Set1::Empty,\n-                synthetic: false,\n-            },\n+            kind: ty::GenericParamDefKind::Type { has_default: false, synthetic: false },\n         }));\n     }\n \n@@ -1762,11 +1749,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n                 name: Symbol::intern(\"<const_ty>\"),\n                 def_id,\n                 pure_wrt_drop: false,\n-                kind: ty::GenericParamDefKind::Type {\n-                    has_default: false,\n-                    object_lifetime_default: rl::Set1::Empty,\n-                    synthetic: false,\n-                },\n+                kind: ty::GenericParamDefKind::Type { has_default: false, synthetic: false },\n             });\n         }\n     }"}, {"sha": "ed049194dd068d584c9f0604cfe09be892617508", "filename": "library/alloc/src/vec/into_iter.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -4,7 +4,6 @@ use crate::alloc::{Allocator, Global};\n use crate::raw_vec::RawVec;\n use core::array;\n use core::fmt;\n-use core::intrinsics::arith_offset;\n use core::iter::{\n     FusedIterator, InPlaceIterable, SourceIter, TrustedLen, TrustedRandomAccessNoCoerce,\n };\n@@ -154,7 +153,7 @@ impl<T, A: Allocator> Iterator for IntoIter<T, A> {\n             // purposefully don't use 'ptr.offset' because for\n             // vectors with 0-size elements this would return the\n             // same pointer.\n-            self.ptr = unsafe { arith_offset(self.ptr as *const i8, 1) as *mut T };\n+            self.ptr = self.ptr.wrapping_byte_add(1);\n \n             // Make up a value of this ZST.\n             Some(unsafe { mem::zeroed() })\n@@ -184,7 +183,7 @@ impl<T, A: Allocator> Iterator for IntoIter<T, A> {\n             // SAFETY: due to unchecked casts of unsigned amounts to signed offsets the wraparound\n             // effectively results in unsigned pointers representing positions 0..usize::MAX,\n             // which is valid for ZSTs.\n-            self.ptr = unsafe { arith_offset(self.ptr as *const i8, step_size as isize) as *mut T }\n+            self.ptr = self.ptr.wrapping_byte_add(step_size);\n         } else {\n             // SAFETY: the min() above ensures that step_size is in bounds\n             self.ptr = unsafe { self.ptr.add(step_size) };\n@@ -217,7 +216,7 @@ impl<T, A: Allocator> Iterator for IntoIter<T, A> {\n                 return Err(unsafe { array::IntoIter::new_unchecked(raw_ary, 0..len) });\n             }\n \n-            self.ptr = unsafe { arith_offset(self.ptr as *const i8, N as isize) as *mut T };\n+            self.ptr = self.ptr.wrapping_byte_add(N);\n             // Safety: ditto\n             return Ok(unsafe { MaybeUninit::array_assume_init(raw_ary) });\n         }\n@@ -267,7 +266,7 @@ impl<T, A: Allocator> DoubleEndedIterator for IntoIter<T, A> {\n             None\n         } else if mem::size_of::<T>() == 0 {\n             // See above for why 'ptr.offset' isn't used\n-            self.end = unsafe { arith_offset(self.end as *const i8, -1) as *mut T };\n+            self.end = self.ptr.wrapping_byte_sub(1);\n \n             // Make up a value of this ZST.\n             Some(unsafe { mem::zeroed() })\n@@ -283,9 +282,7 @@ impl<T, A: Allocator> DoubleEndedIterator for IntoIter<T, A> {\n         let step_size = self.len().min(n);\n         if mem::size_of::<T>() == 0 {\n             // SAFETY: same as for advance_by()\n-            self.end = unsafe {\n-                arith_offset(self.end as *const i8, step_size.wrapping_neg() as isize) as *mut T\n-            }\n+            self.end = self.end.wrapping_byte_sub(step_size);\n         } else {\n             // SAFETY: same as for advance_by()\n             self.end = unsafe { self.end.sub(step_size) };"}, {"sha": "1f19b9e594549d534ca82e9c314868ba45082b89", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -59,7 +59,7 @@ use core::cmp::Ordering;\n use core::convert::TryFrom;\n use core::fmt;\n use core::hash::{Hash, Hasher};\n-use core::intrinsics::{arith_offset, assume};\n+use core::intrinsics::assume;\n use core::iter;\n #[cfg(not(no_global_oom_handling))]\n use core::iter::FromIterator;\n@@ -2678,7 +2678,7 @@ impl<T, A: Allocator> IntoIterator for Vec<T, A> {\n             let alloc = ManuallyDrop::new(ptr::read(me.allocator()));\n             let begin = me.as_mut_ptr();\n             let end = if mem::size_of::<T>() == 0 {\n-                arith_offset(begin as *const i8, me.len() as isize) as *const T\n+                begin.wrapping_byte_add(me.len())\n             } else {\n                 begin.add(me.len()) as *const T\n             };"}, {"sha": "7da49b04aaae99cd51f8c48cc6a15296b7283061", "filename": "library/core/src/fmt/builders.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/library%2Fcore%2Fsrc%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/library%2Fcore%2Fsrc%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fbuilders.rs?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -28,24 +28,14 @@ impl<'buf, 'state> PadAdapter<'buf, 'state> {\n }\n \n impl fmt::Write for PadAdapter<'_, '_> {\n-    fn write_str(&mut self, mut s: &str) -> fmt::Result {\n-        while !s.is_empty() {\n+    fn write_str(&mut self, s: &str) -> fmt::Result {\n+        for s in s.split_inclusive('\\n') {\n             if self.state.on_newline {\n                 self.buf.write_str(\"    \")?;\n             }\n \n-            let split = match s.find('\\n') {\n-                Some(pos) => {\n-                    self.state.on_newline = true;\n-                    pos + 1\n-                }\n-                None => {\n-                    self.state.on_newline = false;\n-                    s.len()\n-                }\n-            };\n-            self.buf.write_str(&s[..split])?;\n-            s = &s[split..];\n+            self.state.on_newline = s.ends_with('\\n');\n+            self.buf.write_str(s)?;\n         }\n \n         Ok(())"}, {"sha": "ef7b3b1d1470a1778950922e5803339bc50dda4e", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -249,7 +249,7 @@ impl<T: ?Sized> *const T {\n         let offset = dest_addr.wrapping_sub(self_addr);\n \n         // This is the canonical desugarring of this operation\n-        self.cast::<u8>().wrapping_offset(offset).cast::<T>()\n+        self.wrapping_byte_offset(offset)\n     }\n \n     /// Creates a new pointer by mapping `self`'s address to a new one."}, {"sha": "6a3b9ee9a7daa618a19f9bf933a0067e5997e030", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -255,7 +255,7 @@ impl<T: ?Sized> *mut T {\n         let offset = dest_addr.wrapping_sub(self_addr);\n \n         // This is the canonical desugarring of this operation\n-        self.cast::<u8>().wrapping_offset(offset).cast::<T>()\n+        self.wrapping_byte_offset(offset)\n     }\n \n     /// Creates a new pointer by mapping `self`'s address to a new one."}, {"sha": "47455760a4bd7f9199185a32d3d15bc68ab7b11a", "filename": "library/core/src/slice/iter/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -64,7 +64,7 @@ macro_rules! iterator {\n         // backwards by `n`. `n` must not exceed `self.len()`.\n         macro_rules! zst_shrink {\n             ($self: ident, $n: ident) => {\n-                $self.end = ($self.end as * $raw_mut u8).wrapping_offset(-$n) as * $raw_mut T;\n+                $self.end = $self.end.wrapping_byte_offset(-$n);\n             }\n         }\n "}, {"sha": "94b0310603bf41ccd7d16675513a544098e7561e", "filename": "library/core/tests/atomic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/library%2Fcore%2Ftests%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/library%2Fcore%2Ftests%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fatomic.rs?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -155,7 +155,7 @@ fn ptr_add_data() {\n \n     assert_eq!(atom.fetch_ptr_sub(1, SeqCst), n.wrapping_add(1));\n     assert_eq!(atom.load(SeqCst), n);\n-    let bytes_from_n = |b| n.cast::<u8>().wrapping_add(b).cast::<i64>();\n+    let bytes_from_n = |b| n.wrapping_byte_add(b);\n \n     assert_eq!(atom.fetch_byte_add(1, SeqCst), n);\n     assert_eq!(atom.load(SeqCst), bytes_from_n(1));"}, {"sha": "97a369810056dceefcdef14ad542fe4a0e15fd93", "filename": "library/core/tests/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/library%2Fcore%2Ftests%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/library%2Fcore%2Ftests%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fptr.rs?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -650,7 +650,7 @@ fn thin_box() {\n                     .unwrap_or_else(|| handle_alloc_error(layout))\n                     .cast::<DynMetadata<T>>();\n                 ptr.as_ptr().write(meta);\n-                ptr.cast::<u8>().as_ptr().add(offset).cast::<Value>().write(value);\n+                ptr.as_ptr().byte_add(offset).cast::<Value>().write(value);\n                 Self { ptr, phantom: PhantomData }\n             }\n         }"}, {"sha": "28a2c99f7e5e3e8d2ef77993fc6eb7e09564e5d8", "filename": "library/std/src/fs.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/library%2Fstd%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/library%2Fstd%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs.rs?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -377,6 +377,35 @@ impl File {\n         OpenOptions::new().write(true).create(true).truncate(true).open(path.as_ref())\n     }\n \n+    /// Creates a new file in read-write mode; error if the file exists.\n+    ///\n+    /// This function will create a file if it does not exist, or return an error if it does. This\n+    /// way, if the call succeeds, the file returned is guaranteed to be new.\n+    ///\n+    /// This option is useful because it is atomic. Otherwise between checking whether a file\n+    /// exists and creating a new one, the file may have been created by another process (a TOCTOU\n+    /// race condition / attack).\n+    ///\n+    /// This can also be written using\n+    /// `File::options().read(true).write(true).create_new(true).open(...)`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(file_create_new)]\n+    ///\n+    /// use std::fs::File;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let mut f = File::create_new(\"foo.txt\")?;\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"file_create_new\", issue = \"none\")]\n+    pub fn create_new<P: AsRef<Path>>(path: P) -> io::Result<File> {\n+        OpenOptions::new().read(true).write(true).create_new(true).open(path.as_ref())\n+    }\n+\n     /// Returns a new OpenOptions object.\n     ///\n     /// This function returns a new OpenOptions object that you can use to"}, {"sha": "781ae03ad45dcb865c66d90b45a6109d28c7fad8", "filename": "library/std/src/io/error/repr_bitpacked.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/library%2Fstd%2Fsrc%2Fio%2Ferror%2Frepr_bitpacked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/library%2Fstd%2Fsrc%2Fio%2Ferror%2Frepr_bitpacked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ferror%2Frepr_bitpacked.rs?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -269,10 +269,10 @@ where\n         }\n         TAG_SIMPLE_MESSAGE => ErrorData::SimpleMessage(&*ptr.cast::<SimpleMessage>().as_ptr()),\n         TAG_CUSTOM => {\n-            // It would be correct for us to use `ptr::sub` here (see the\n+            // It would be correct for us to use `ptr::byte_sub` here (see the\n             // comment above the `wrapping_add` call in `new_custom` for why),\n             // but it isn't clear that it makes a difference, so we don't.\n-            let custom = ptr.as_ptr().cast::<u8>().wrapping_sub(TAG_CUSTOM).cast::<Custom>();\n+            let custom = ptr.as_ptr().wrapping_byte_sub(TAG_CUSTOM).cast::<Custom>();\n             ErrorData::Custom(make_custom(custom))\n         }\n         _ => {"}, {"sha": "01a3873c75cec6c5b81459a8de83740a8297e559", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -1037,8 +1037,6 @@ pub trait Read {\n /// # Examples\n ///\n /// ```no_run\n-/// #![feature(io_read_to_string)]\n-///\n /// # use std::io;\n /// fn main() -> io::Result<()> {\n ///     let stdin = io::read_to_string(io::stdin())?;\n@@ -1047,7 +1045,7 @@ pub trait Read {\n ///     Ok(())\n /// }\n /// ```\n-#[unstable(feature = \"io_read_to_string\", issue = \"80218\")]\n+#[stable(feature = \"io_read_to_string\", since = \"CURRENT_RUSTC_VERSION\")]\n pub fn read_to_string<R: Read>(mut reader: R) -> Result<String> {\n     let mut buf = String::new();\n     reader.read_to_string(&mut buf)?;"}, {"sha": "8936e11b8e02eb854d438a1a7ffdefb9e74fc098", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -300,6 +300,7 @@\n #![feature(panic_can_unwind)]\n #![feature(panic_info_message)]\n #![feature(panic_internals)]\n+#![feature(pointer_byte_offsets)]\n #![feature(pointer_is_aligned)]\n #![feature(portable_simd)]\n #![feature(prelude_2024)]"}, {"sha": "c425de081a6a6e4ac964362cbf7e2a1c9e3a177a", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -192,7 +192,7 @@ fn clean_poly_trait_ref_with_bindings<'tcx>(\n fn clean_lifetime<'tcx>(lifetime: hir::Lifetime, cx: &mut DocContext<'tcx>) -> Lifetime {\n     let def = cx.tcx.named_region(lifetime.hir_id);\n     if let Some(\n-        rl::Region::EarlyBound(_, node_id)\n+        rl::Region::EarlyBound(node_id)\n         | rl::Region::LateBound(_, _, node_id)\n         | rl::Region::Free(_, node_id),\n     ) = def"}, {"sha": "e3abf73096125afca17155a4378380540e816c22", "filename": "src/test/codegen/issue-96274.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/src%2Ftest%2Fcodegen%2Fissue-96274.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/src%2Ftest%2Fcodegen%2Fissue-96274.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fissue-96274.rs?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -0,0 +1,11 @@\n+// min-llvm-version: 15.0\n+// compile-flags: -O\n+\n+#![crate_type = \"lib\"]\n+\n+use std::mem::MaybeUninit;\n+\n+pub fn maybe_uninit() -> [MaybeUninit<u8>; 3000] {\n+    // CHECK-NOT: memset\n+    [MaybeUninit::uninit(); 3000]\n+}"}, {"sha": "0f8898c389b7f4b33a819f03ff42622696884748", "filename": "src/test/incremental/hashes/enum_defs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -504,9 +504,9 @@ enum EnumAddLifetimeBoundToParameter<'a, T> {\n }\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes,generics_of,predicates_of\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes,predicates_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n-#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner,hir_owner_nodes,generics_of,predicates_of\")]\n+#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner,hir_owner_nodes,predicates_of\")]\n #[rustc_clean(cfg=\"cfail6\")]\n enum EnumAddLifetimeBoundToParameter<'a, T: 'a> {\n     Variant1(T),\n@@ -559,9 +559,9 @@ enum EnumAddLifetimeBoundToParameterWhere<'a, T> {\n }\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes,generics_of,predicates_of\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes,predicates_of\")]\n #[rustc_clean(cfg=\"cfail3\")]\n-#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner,hir_owner_nodes,generics_of,predicates_of\")]\n+#[rustc_clean(cfg=\"cfail5\", except=\"hir_owner,hir_owner_nodes,predicates_of\")]\n #[rustc_clean(cfg=\"cfail6\")]\n enum EnumAddLifetimeBoundToParameterWhere<'a, T> where T: 'a {\n     Variant1(T),"}, {"sha": "c453eeceb77f53b1266e25a5eccef6a814f5a297", "filename": "src/test/incremental/hashes/trait_defs.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_defs.rs?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -1066,9 +1066,9 @@ trait TraitAddTraitBoundToTypeParameterOfTrait<T: ReferencedTrait0> { }\n trait TraitAddLifetimeBoundToTypeParameterOfTrait<'a, T> { }\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(except=\"hir_owner,hir_owner_nodes,generics_of,predicates_of\", cfg=\"cfail2\")]\n+#[rustc_clean(except=\"hir_owner,hir_owner_nodes,predicates_of\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n-#[rustc_clean(except=\"hir_owner,hir_owner_nodes,generics_of,predicates_of\", cfg=\"cfail5\")]\n+#[rustc_clean(except=\"hir_owner,hir_owner_nodes,predicates_of\", cfg=\"cfail5\")]\n #[rustc_clean(cfg=\"cfail6\")]\n trait TraitAddLifetimeBoundToTypeParameterOfTrait<'a, T: 'a> { }\n \n@@ -1144,9 +1144,9 @@ trait TraitAddSecondTraitBoundToTypeParameterOfTrait<T: ReferencedTrait0 + Refer\n trait TraitAddSecondLifetimeBoundToTypeParameterOfTrait<'a, 'b, T: 'a> { }\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(except=\"hir_owner,hir_owner_nodes,generics_of,predicates_of\", cfg=\"cfail2\")]\n+#[rustc_clean(except=\"hir_owner,hir_owner_nodes,predicates_of\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n-#[rustc_clean(except=\"hir_owner,hir_owner_nodes,generics_of,predicates_of\", cfg=\"cfail5\")]\n+#[rustc_clean(except=\"hir_owner,hir_owner_nodes,predicates_of\", cfg=\"cfail5\")]\n #[rustc_clean(cfg=\"cfail6\")]\n trait TraitAddSecondLifetimeBoundToTypeParameterOfTrait<'a, 'b, T: 'a + 'b> { }\n \n@@ -1201,9 +1201,9 @@ trait TraitAddTraitBoundToTypeParameterOfTraitWhere<T> where T: ReferencedTrait0\n trait TraitAddLifetimeBoundToTypeParameterOfTraitWhere<'a, T> { }\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(except=\"hir_owner,hir_owner_nodes,generics_of,predicates_of\", cfg=\"cfail2\")]\n+#[rustc_clean(except=\"hir_owner,hir_owner_nodes,predicates_of\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n-#[rustc_clean(except=\"hir_owner,hir_owner_nodes,generics_of,predicates_of\", cfg=\"cfail5\")]\n+#[rustc_clean(except=\"hir_owner,hir_owner_nodes,predicates_of\", cfg=\"cfail5\")]\n #[rustc_clean(cfg=\"cfail6\")]\n trait TraitAddLifetimeBoundToTypeParameterOfTraitWhere<'a, T> where T: 'a { }\n \n@@ -1254,9 +1254,9 @@ trait TraitAddSecondTraitBoundToTypeParameterOfTraitWhere<T>\n trait TraitAddSecondLifetimeBoundToTypeParameterOfTraitWhere<'a, 'b, T> where T: 'a { }\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(except=\"hir_owner,hir_owner_nodes,generics_of,predicates_of\", cfg=\"cfail2\")]\n+#[rustc_clean(except=\"hir_owner,hir_owner_nodes,predicates_of\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n-#[rustc_clean(except=\"hir_owner,hir_owner_nodes,generics_of,predicates_of\", cfg=\"cfail5\")]\n+#[rustc_clean(except=\"hir_owner,hir_owner_nodes,predicates_of\", cfg=\"cfail5\")]\n #[rustc_clean(cfg=\"cfail6\")]\n trait TraitAddSecondLifetimeBoundToTypeParameterOfTraitWhere<'a, 'b, T> where T: 'a + 'b { }\n "}, {"sha": "186a953735675ec67382585fca5dc3510245b973", "filename": "src/test/mir-opt/const_prop/mutable_variable_unprop_assign.main.ConstProp.diff", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_unprop_assign.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_unprop_assign.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_unprop_assign.main.ConstProp.diff?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -41,7 +41,8 @@\n           StorageLive(_4);                 // scope 2 at $DIR/mutable_variable_unprop_assign.rs:+4:9: +4:10\n           _4 = (_2.1: i32);                // scope 2 at $DIR/mutable_variable_unprop_assign.rs:+4:13: +4:16\n           StorageLive(_5);                 // scope 3 at $DIR/mutable_variable_unprop_assign.rs:+5:9: +5:10\n-          _5 = (_2.0: i32);                // scope 3 at $DIR/mutable_variable_unprop_assign.rs:+5:13: +5:16\n+-         _5 = (_2.0: i32);                // scope 3 at $DIR/mutable_variable_unprop_assign.rs:+5:13: +5:16\n++         _5 = const 1_i32;                // scope 3 at $DIR/mutable_variable_unprop_assign.rs:+5:13: +5:16\n           nop;                             // scope 0 at $DIR/mutable_variable_unprop_assign.rs:+0:11: +6:2\n           StorageDead(_5);                 // scope 3 at $DIR/mutable_variable_unprop_assign.rs:+6:1: +6:2\n           StorageDead(_4);                 // scope 2 at $DIR/mutable_variable_unprop_assign.rs:+6:1: +6:2"}, {"sha": "f00cb05c9ebc378b7c9135d5b15254926fc3e8b1", "filename": "src/test/ui/fmt/ifmt-bad-arg.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/src%2Ftest%2Fui%2Ffmt%2Fifmt-bad-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/src%2Ftest%2Fui%2Ffmt%2Fifmt-bad-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Fifmt-bad-arg.rs?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -94,4 +94,6 @@ tenth number: {}\",\n     // doesn't exist.\n     println!(\"{:.*}\");\n     //~^ ERROR 2 positional arguments in format string, but no arguments were given\n+    println!(\"{:.0$}\");\n+    //~^ ERROR 1 positional argument in format string, but no arguments were given\n }"}, {"sha": "dbb4bc6d9370e9f377cb1cc8e241e9f070ba6589", "filename": "src/test/ui/fmt/ifmt-bad-arg.stderr", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/src%2Ftest%2Fui%2Ffmt%2Fifmt-bad-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365/src%2Ftest%2Fui%2Ffmt%2Fifmt-bad-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Fifmt-bad-arg.stderr?ref=bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "patch": "@@ -273,6 +273,17 @@ LL |     println!(\"{:.*}\");\n    = note: positional arguments are zero-based\n    = note: for information about formatting flags, visit https://doc.rust-lang.org/std/fmt/index.html\n \n+error: 1 positional argument in format string, but no arguments were given\n+  --> $DIR/ifmt-bad-arg.rs:97:15\n+   |\n+LL |     println!(\"{:.0$}\");\n+   |               ^^---^\n+   |                 |\n+   |                 this precision flag expects an `usize` argument at position 0, but no arguments were given\n+   |\n+   = note: positional arguments are zero-based\n+   = note: for information about formatting flags, visit https://doc.rust-lang.org/std/fmt/index.html\n+\n error[E0425]: cannot find value `foo` in this scope\n   --> $DIR/ifmt-bad-arg.rs:27:18\n    |\n@@ -339,7 +350,7 @@ LL |     pub fn from_usize(x: &usize) -> ArgumentV1<'_> {\n    |            ^^^^^^^^^^\n    = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 37 previous errors\n+error: aborting due to 38 previous errors\n \n Some errors have detailed explanations: E0308, E0425.\n For more information about an error, try `rustc --explain E0308`."}]}