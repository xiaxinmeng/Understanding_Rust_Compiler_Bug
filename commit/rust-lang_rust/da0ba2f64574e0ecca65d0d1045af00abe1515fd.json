{"sha": "da0ba2f64574e0ecca65d0d1045af00abe1515fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhMGJhMmY2NDU3NGUwZWNjYTY1ZDBkMTA0NWFmMDBhYmUxNTE1ZmQ=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-10-18T12:48:54Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-10-18T13:21:20Z"}, "message": "The only remaining constant patterns are opaque", "tree": {"sha": "fc5052dd1872dc74171afcad8c4d270077acae53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc5052dd1872dc74171afcad8c4d270077acae53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da0ba2f64574e0ecca65d0d1045af00abe1515fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da0ba2f64574e0ecca65d0d1045af00abe1515fd", "html_url": "https://github.com/rust-lang/rust/commit/da0ba2f64574e0ecca65d0d1045af00abe1515fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da0ba2f64574e0ecca65d0d1045af00abe1515fd/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1a784e7b9c4cfe9ce216eb89c362726ff890ea0", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1a784e7b9c4cfe9ce216eb89c362726ff890ea0", "html_url": "https://github.com/rust-lang/rust/commit/d1a784e7b9c4cfe9ce216eb89c362726ff890ea0"}], "stats": {"total": 87, "additions": 50, "deletions": 37}, "files": [{"sha": "fb068f21d8a69cce4b9b5bd0092317d41e9011b8", "filename": "compiler/rustc_mir_build/src/thir/pattern/_match.rs", "status": "modified", "additions": 41, "deletions": 28, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/da0ba2f64574e0ecca65d0d1045af00abe1515fd/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da0ba2f64574e0ecca65d0d1045af00abe1515fd/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs?ref=da0ba2f64574e0ecca65d0d1045af00abe1515fd", "patch": "@@ -394,9 +394,15 @@ impl<'p, 'tcx> PatStack<'p, 'tcx> {\n         cx: &mut MatchCheckCtxt<'p, 'tcx>,\n         constructor: &Constructor<'tcx>,\n         ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n+        is_my_head_ctor: bool,\n     ) -> Option<PatStack<'p, 'tcx>> {\n-        let new_fields =\n-            specialize_one_pattern(cx, self.head(), constructor, ctor_wild_subpatterns)?;\n+        let new_fields = specialize_one_pattern(\n+            cx,\n+            self.head(),\n+            constructor,\n+            ctor_wild_subpatterns,\n+            is_my_head_ctor,\n+        )?;\n         Some(new_fields.push_on_patstack(&self.0[1..]))\n     }\n }\n@@ -574,6 +580,7 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n                                 cx,\n                                 constructor,\n                                 ctor_wild_subpatterns,\n+                                false,\n                             )\n                         })\n                         .collect()\n@@ -599,7 +606,9 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n             SpecializationCache::Incompatible => self\n                 .patterns\n                 .iter()\n-                .filter_map(|r| r.specialize_constructor(cx, constructor, ctor_wild_subpatterns))\n+                .filter_map(|r| {\n+                    r.specialize_constructor(cx, constructor, ctor_wild_subpatterns, false)\n+                })\n                 .collect(),\n         }\n     }\n@@ -821,8 +830,6 @@ enum Constructor<'tcx> {\n     Single,\n     /// Enum variants.\n     Variant(DefId),\n-    /// Literal values.\n-    ConstantValue(&'tcx ty::Const<'tcx>),\n     /// Ranges of integer literal values (`2`, `2..=5` or `2..5`).\n     IntRange(IntRange<'tcx>),\n     /// Ranges of floating-point literal values (`2.0..=5.2`).\n@@ -831,27 +838,22 @@ enum Constructor<'tcx> {\n     Str(&'tcx ty::Const<'tcx>),\n     /// Array and slice patterns.\n     Slice(Slice),\n+    /// Constants that must not be matched structurally. They are treated as black\n+    /// boxes for the purposes of exhaustiveness: we must not inspect them, and they\n+    /// don't count towards making a match exhaustive.\n+    Opaque,\n     /// Fake extra constructor for enums that aren't allowed to be matched exhaustively.\n     NonExhaustive,\n }\n \n impl<'tcx> Constructor<'tcx> {\n-    fn variant_index_for_adt<'a>(\n-        &self,\n-        cx: &MatchCheckCtxt<'a, 'tcx>,\n-        adt: &'tcx ty::AdtDef,\n-    ) -> VariantIdx {\n+    fn variant_index_for_adt(&self, adt: &'tcx ty::AdtDef) -> VariantIdx {\n         match *self {\n             Variant(id) => adt.variant_index_with_id(id),\n             Single => {\n                 assert!(!adt.is_enum());\n                 VariantIdx::new(0)\n             }\n-            ConstantValue(c) => cx\n-                .tcx\n-                .destructure_const(cx.param_env.and(c))\n-                .variant\n-                .expect(\"destructed const of adt without variant id\"),\n             _ => bug!(\"bad constructor {:?} for adt {:?}\", self, adt),\n         }\n     }\n@@ -865,7 +867,7 @@ impl<'tcx> Constructor<'tcx> {\n \n         match self {\n             // Those constructors can only match themselves.\n-            Single | Variant(_) | ConstantValue(..) | Str(..) | FloatRange(..) => {\n+            Single | Variant(_) | Str(..) | FloatRange(..) => {\n                 if other_ctors.iter().any(|c| c == self) { vec![] } else { vec![self.clone()] }\n             }\n             &Slice(slice) => {\n@@ -936,6 +938,7 @@ impl<'tcx> Constructor<'tcx> {\n             }\n             // This constructor is never covered by anything else\n             NonExhaustive => vec![NonExhaustive],\n+            Opaque => bug!(\"unexpected opaque ctor {:?} found in all_ctors\", self),\n         }\n     }\n \n@@ -975,7 +978,7 @@ impl<'tcx> Constructor<'tcx> {\n                             PatKind::Variant {\n                                 adt_def: adt,\n                                 substs,\n-                                variant_index: self.variant_index_for_adt(cx, adt),\n+                                variant_index: self.variant_index_for_adt(adt),\n                                 subpatterns,\n                             }\n                         } else {\n@@ -1014,11 +1017,11 @@ impl<'tcx> Constructor<'tcx> {\n                     PatKind::Slice { prefix, slice: Some(wild), suffix }\n                 }\n             },\n-            &ConstantValue(value) => PatKind::Constant { value },\n             &Str(value) => PatKind::Constant { value },\n             &FloatRange(lo, hi, end) => PatKind::Range(PatRange { lo, hi, end }),\n             IntRange(range) => return range.to_pat(cx.tcx),\n             NonExhaustive => PatKind::Wild,\n+            Opaque => bug!(\"we should not try to apply an opaque constructor {:?}\", self),\n         };\n \n         Pat { ty, span: DUMMY_SP, kind: Box::new(pat) }\n@@ -1122,7 +1125,7 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n                         // Use T as the sub pattern type of Box<T>.\n                         Fields::from_single_pattern(wildcard_from_ty(substs.type_at(0)))\n                     } else {\n-                        let variant = &adt.variants[constructor.variant_index_for_adt(cx, adt)];\n+                        let variant = &adt.variants[constructor.variant_index_for_adt(adt)];\n                         // Whether we must not match the fields of this variant exhaustively.\n                         let is_non_exhaustive =\n                             variant.is_field_list_non_exhaustive() && !adt.did.is_local();\n@@ -1170,9 +1173,7 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n                 }\n                 _ => bug!(\"bad slice pattern {:?} {:?}\", constructor, ty),\n             },\n-            ConstantValue(..) | Str(..) | FloatRange(..) | IntRange(..) | NonExhaustive => {\n-                Fields::empty()\n-            }\n+            Str(..) | FloatRange(..) | IntRange(..) | NonExhaustive | Opaque => Fields::empty(),\n         };\n         debug!(\"Fields::wildcards({:?}, {:?}) = {:#?}\", constructor, ty, ret);\n         ret\n@@ -2085,7 +2086,7 @@ fn is_useful_specialized<'p, 'tcx>(\n     // We cache the result of `Fields::wildcards` because it is used a lot.\n     let ctor_wild_subpatterns = Fields::wildcards(cx, &ctor, ty);\n     let matrix = matrix.specialize_constructor(cx, &ctor, &ctor_wild_subpatterns);\n-    v.specialize_constructor(cx, &ctor, &ctor_wild_subpatterns)\n+    v.specialize_constructor(cx, &ctor, &ctor_wild_subpatterns, true)\n         .map(|v| is_useful(cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false))\n         .map(|u| u.apply_constructor(cx, &ctor, ty, &ctor_wild_subpatterns))\n         .unwrap_or(NotUseful)\n@@ -2112,7 +2113,7 @@ fn pat_constructor<'tcx>(\n                 match value.ty.kind() {\n                     ty::Float(_) => Some(FloatRange(value, value, RangeEnd::Included)),\n                     ty::Ref(_, t, _) if t.is_str() => Some(Str(value)),\n-                    _ => Some(ConstantValue(value)),\n+                    _ => Some(Opaque),\n                 }\n             }\n         }\n@@ -2461,15 +2462,26 @@ fn specialize_one_pattern<'p, 'tcx>(\n     pat: &'p Pat<'tcx>,\n     constructor: &Constructor<'tcx>,\n     ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n+    is_its_own_ctor: bool, // Whether `ctor` is known to be derived from `pat`\n ) -> Option<Fields<'p, 'tcx>> {\n     if let NonExhaustive = constructor {\n-        // Only a wildcard pattern can match the special extra constructor\n+        // Only a wildcard pattern can match the special extra constructor.\n         if !pat.is_wildcard() {\n             return None;\n         }\n         return Some(Fields::empty());\n     }\n \n+    if let Opaque = constructor {\n+        // Only a wildcard pattern can match an opaque constant, unless we're specializing the\n+        // value against its own constructor.\n+        if is_its_own_ctor || pat.is_wildcard() {\n+            return Some(Fields::empty());\n+        } else {\n+            return None;\n+        }\n+    }\n+\n     let result = match *pat.kind {\n         PatKind::AscribeUserType { .. } => bug!(), // Handled by `expand_pattern`\n \n@@ -2491,7 +2503,6 @@ fn specialize_one_pattern<'p, 'tcx>(\n \n         PatKind::Constant { .. } | PatKind::Range { .. } => {\n             match constructor {\n-                Single => {}\n                 IntRange(ctor) => {\n                     let pat = IntRange::from_pat(cx.tcx, cx.param_env, pat)?;\n                     ctor.intersection(cx.tcx, &pat)?;\n@@ -2514,7 +2525,7 @@ fn specialize_one_pattern<'p, 'tcx>(\n                         return None;\n                     }\n                 }\n-                ConstantValue(ctor_value) | Str(ctor_value) => {\n+                Str(ctor_value) => {\n                     let pat_value = match *pat.kind {\n                         PatKind::Constant { value } => value,\n                         _ => span_bug!(\n@@ -2532,7 +2543,9 @@ fn specialize_one_pattern<'p, 'tcx>(\n                     }\n                 }\n                 _ => {\n-                    span_bug!(pat.span, \"unexpected pattern {:?} with ctor {:?}\", pat, constructor)\n+                    // If we reach here, we must be trying to inspect an opaque constant. Thus we skip\n+                    // the row.\n+                    return None;\n                 }\n             }\n             Some(Fields::empty())"}, {"sha": "485e4cab87f82d99526b0784c37e48d0923daa58", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/da0ba2f64574e0ecca65d0d1045af00abe1515fd/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da0ba2f64574e0ecca65d0d1045af00abe1515fd/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=da0ba2f64574e0ecca65d0d1045af00abe1515fd", "patch": "@@ -158,6 +158,13 @@ crate enum PatKind<'tcx> {\n         subpattern: Pat<'tcx>,\n     },\n \n+    /// One of the following:\n+    /// * `&str`, which will be handled as a string pattern and thus exhaustiveness\n+    ///   checking will detect if you use the same string twice in different patterns.\n+    /// * integer, bool, char or float, which will be handled by exhaustivenes to cover exactly\n+    ///   its own value, similar to `&str`, but these values are much simpler.\n+    /// * Opaque constants, that must not be matched structurally. So anything that does not derive\n+    ///   `PartialEq` and `Eq`.\n     Constant {\n         value: &'tcx ty::Const<'tcx>,\n     },"}, {"sha": "761b293e9989bcb928ed496ccd82472bd34ad31f", "filename": "src/test/ui/pattern/usefulness/consts-opaque.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/da0ba2f64574e0ecca65d0d1045af00abe1515fd/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fconsts-opaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da0ba2f64574e0ecca65d0d1045af00abe1515fd/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fconsts-opaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fconsts-opaque.rs?ref=da0ba2f64574e0ecca65d0d1045af00abe1515fd", "patch": "@@ -106,8 +106,7 @@ fn main() {\n \n     match QUUX {\n         QUUX => {}\n-        QUUX => {} // should not be emitting unreachable warning\n-        //~^ ERROR unreachable pattern\n+        QUUX => {}\n         _ => {}\n     }\n }"}, {"sha": "6d7e36e01f7f7aef3492991e99f3a27f10788785", "filename": "src/test/ui/pattern/usefulness/consts-opaque.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/da0ba2f64574e0ecca65d0d1045af00abe1515fd/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fconsts-opaque.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da0ba2f64574e0ecca65d0d1045af00abe1515fd/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fconsts-opaque.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fconsts-opaque.stderr?ref=da0ba2f64574e0ecca65d0d1045af00abe1515fd", "patch": "@@ -144,11 +144,5 @@ error: unreachable pattern\n LL |         _ => {} // should not be emitting unreachable warning\n    |         ^\n \n-error: unreachable pattern\n-  --> $DIR/consts-opaque.rs:109:9\n-   |\n-LL |         QUUX => {} // should not be emitting unreachable warning\n-   |         ^^^^\n-\n-error: aborting due to 23 previous errors\n+error: aborting due to 22 previous errors\n "}]}