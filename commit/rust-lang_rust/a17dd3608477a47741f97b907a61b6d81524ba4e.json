{"sha": "a17dd3608477a47741f97b907a61b6d81524ba4e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExN2RkMzYwODQ3N2E0Nzc0MWY5N2I5MDdhNjFiNmQ4MTUyNGJhNGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-26T02:22:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-26T02:22:26Z"}, "message": "Auto merge of #70415 - Centril:rollup-1zttfvl, r=Centril\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #69866 (Rename `def_span` to `guess_head_span`)\n - #69878 (Tweak chained operators diagnostic)\n - #70375 (avoid catching InterpError)\n - #70386 (typeck: minor pattern typing improvements)\n - #70389 (borrowck: prefer \"value\" over \"`_`\" in diagnostics)\n - #70395 (Update cargo.)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "367485267991beccfc9abe073364aa3a629b48a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/367485267991beccfc9abe073364aa3a629b48a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a17dd3608477a47741f97b907a61b6d81524ba4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a17dd3608477a47741f97b907a61b6d81524ba4e", "html_url": "https://github.com/rust-lang/rust/commit/a17dd3608477a47741f97b907a61b6d81524ba4e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a17dd3608477a47741f97b907a61b6d81524ba4e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4519e2b966aaf7e2eb0105d0a1593fdb6e0a3a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4519e2b966aaf7e2eb0105d0a1593fdb6e0a3a5", "html_url": "https://github.com/rust-lang/rust/commit/e4519e2b966aaf7e2eb0105d0a1593fdb6e0a3a5"}, {"sha": "16e9d3f0ca61e820bbcb5945ff257b3a0fc8f55a", "url": "https://api.github.com/repos/rust-lang/rust/commits/16e9d3f0ca61e820bbcb5945ff257b3a0fc8f55a", "html_url": "https://github.com/rust-lang/rust/commit/16e9d3f0ca61e820bbcb5945ff257b3a0fc8f55a"}], "stats": {"total": 864, "additions": 474, "deletions": 390}, "files": [{"sha": "ada02ceb5cbf3cc910d319039ef80e1ab628fa5c", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -367,7 +367,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         let bytes = self.get_bytes_with_undef_and_ptr(cx, ptr, size)?;\n         // Undef check happens *after* we established that the alignment is correct.\n         // We must not return `Ok()` for unaligned pointers!\n-        if self.check_defined(ptr, size).is_err() {\n+        if self.is_defined(ptr, size).is_err() {\n             // This inflates undefined bytes to the entire scalar, even if only a few\n             // bytes are undefined.\n             return Ok(ScalarMaybeUndef::Undef);\n@@ -552,13 +552,19 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n }\n \n /// Undefined bytes.\n-impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n+impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n+    /// Checks whether the given range  is entirely defined.\n+    ///\n+    /// Returns `Ok(())` if it's defined. Otherwise returns the index of the byte\n+    /// at which the first undefined access begins.\n+    fn is_defined(&self, ptr: Pointer<Tag>, size: Size) -> Result<(), Size> {\n+        self.undef_mask.is_range_defined(ptr.offset, ptr.offset + size) // `Size` addition\n+    }\n+\n     /// Checks that a range of bytes is defined. If not, returns the `ReadUndefBytes`\n     /// error which will report the first byte which is undefined.\n-    #[inline]\n     fn check_defined(&self, ptr: Pointer<Tag>, size: Size) -> InterpResult<'tcx> {\n-        self.undef_mask\n-            .is_range_defined(ptr.offset, ptr.offset + size) // `Size` addition\n+        self.is_defined(ptr, size)\n             .or_else(|idx| throw_ub!(InvalidUndefBytes(Some(Pointer::new(ptr.alloc_id, idx)))))\n     }\n "}, {"sha": "c129b574fd38a0f6def4cb3a9fa896fde54304f9", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -108,7 +108,9 @@ impl<'tcx> ObligationCause<'tcx> {\n         match self.code {\n             ObligationCauseCode::CompareImplMethodObligation { .. }\n             | ObligationCauseCode::MainFunctionType\n-            | ObligationCauseCode::StartFunctionType => tcx.sess.source_map().def_span(self.span),\n+            | ObligationCauseCode::StartFunctionType => {\n+                tcx.sess.source_map().guess_head_span(self.span)\n+            }\n             ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n                 arm_span,\n                 .."}, {"sha": "c0cc119c5a12513e38aedc4e34634e253ed9e14c", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -388,7 +388,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         assert!(!stack.is_empty());\n \n         let fix_span = |span: Span, query: &Query<'tcx>| {\n-            self.sess.source_map().def_span(query.default_span(self, span))\n+            self.sess.source_map().guess_head_span(query.default_span(self, span))\n         };\n \n         // Disable naming impls with types in this path, since that\n@@ -456,7 +456,8 @@ impl<'tcx> TyCtxt<'tcx> {\n                             query_info.info.query.describe(icx.tcx)\n                         ),\n                     );\n-                    diag.span = icx.tcx.sess.source_map().def_span(query_info.info.span).into();\n+                    diag.span =\n+                        icx.tcx.sess.source_map().guess_head_span(query_info.info.span).into();\n                     handler.force_print_diagnostic(diag);\n \n                     current_query = query_info.job.parent;"}, {"sha": "c03c44fc634cecd361b810f1593a6c4bb3dbaf20", "filename": "src/librustc_ast_passes/ast_validation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_ast_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_ast_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Fast_validation.rs?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -402,7 +402,7 @@ impl<'a> AstValidator<'a> {\n \n     fn check_defaultness(&self, span: Span, defaultness: Defaultness) {\n         if let Defaultness::Default(def_span) = defaultness {\n-            let span = self.session.source_map().def_span(span);\n+            let span = self.session.source_map().guess_head_span(span);\n             self.err_handler()\n                 .struct_span_err(span, \"`default` is only allowed on items in `impl` definitions\")\n                 .span_label(def_span, \"`default` because of this\")\n@@ -517,7 +517,7 @@ impl<'a> AstValidator<'a> {\n     }\n \n     fn current_extern_span(&self) -> Span {\n-        self.session.source_map().def_span(self.extern_mod.unwrap().span)\n+        self.session.source_map().guess_head_span(self.extern_mod.unwrap().span)\n     }\n \n     /// An `fn` in `extern { ... }` cannot have qualfiers, e.g. `async fn`."}, {"sha": "5cd7b58e14e3ac5fb3d9c625d7ca1968c2883ad0", "filename": "src/librustc_ast_passes/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Ffeature_gate.rs?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -257,7 +257,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             gate_feature_post!(\n                 &self,\n                 non_ascii_idents,\n-                self.parse_sess.source_map().def_span(sp),\n+                self.parse_sess.source_map().guess_head_span(sp),\n                 \"non-ascii idents are not fully supported\"\n             );\n         }"}, {"sha": "735de4f0a5b2437b8b8bcb8c22be0ded4f7101b3", "filename": "src/librustc_builtin_macros/proc_macro_harness.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_builtin_macros%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_builtin_macros%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fproc_macro_harness.rs?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -198,7 +198,7 @@ impl<'a> CollectProcMacros<'a> {\n             } else {\n                 \"functions tagged with `#[proc_macro_derive]` must be `pub`\"\n             };\n-            self.handler.span_err(self.source_map.def_span(item.span), msg);\n+            self.handler.span_err(self.source_map.guess_head_span(item.span), msg);\n         }\n     }\n \n@@ -217,7 +217,7 @@ impl<'a> CollectProcMacros<'a> {\n             } else {\n                 \"functions tagged with `#[proc_macro_attribute]` must be `pub`\"\n             };\n-            self.handler.span_err(self.source_map.def_span(item.span), msg);\n+            self.handler.span_err(self.source_map.guess_head_span(item.span), msg);\n         }\n     }\n \n@@ -236,7 +236,7 @@ impl<'a> CollectProcMacros<'a> {\n             } else {\n                 \"functions tagged with `#[proc_macro]` must be `pub`\"\n             };\n-            self.handler.span_err(self.source_map.def_span(item.span), msg);\n+            self.handler.span_err(self.source_map.guess_head_span(item.span), msg);\n         }\n     }\n }\n@@ -247,7 +247,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n             if self.is_proc_macro_crate && attr::contains_name(&item.attrs, sym::macro_export) {\n                 let msg =\n                     \"cannot export macro_rules! macros from a `proc-macro` crate type currently\";\n-                self.handler.span_err(self.source_map.def_span(item.span), msg);\n+                self.handler.span_err(self.source_map.guess_head_span(item.span), msg);\n             }\n         }\n \n@@ -298,7 +298,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n \n         let attr = match found_attr {\n             None => {\n-                self.check_not_pub_in_root(&item.vis, self.source_map.def_span(item.span));\n+                self.check_not_pub_in_root(&item.vis, self.source_map.guess_head_span(item.span));\n                 let prev_in_root = mem::replace(&mut self.in_root, false);\n                 visit::walk_item(self, item);\n                 self.in_root = prev_in_root;"}, {"sha": "b9477be57ddda80358745ce31b08c22acc242ec0", "filename": "src/librustc_expand/mbe/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -326,7 +326,7 @@ fn generic_extension<'cx>(\n     let mut err = cx.struct_span_err(span, &parse_failure_msg(&token));\n     err.span_label(span, label);\n     if !def_span.is_dummy() && !cx.source_map().is_imported(def_span) {\n-        err.span_label(cx.source_map().def_span(def_span), \"when calling this macro\");\n+        err.span_label(cx.source_map().guess_head_span(def_span), \"when calling this macro\");\n     }\n \n     // Check whether there's a missing comma in this macro call, like `println!(\"{}\" a);`"}, {"sha": "129bc9e22a667e04de004a24b50b264629f1a279", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -200,7 +200,7 @@ fn msg_span_from_early_bound_and_free_regions(\n     };\n     let (prefix, span) = match *region {\n         ty::ReEarlyBound(ref br) => {\n-            let mut sp = sm.def_span(tcx.hir().span(node));\n+            let mut sp = sm.guess_head_span(tcx.hir().span(node));\n             if let Some(param) =\n                 tcx.hir().get_generics(scope).and_then(|generics| generics.get_named(br.name))\n             {\n@@ -209,7 +209,7 @@ fn msg_span_from_early_bound_and_free_regions(\n             (format!(\"the lifetime `{}` as defined on\", br.name), sp)\n         }\n         ty::ReFree(ty::FreeRegion { bound_region: ty::BoundRegion::BrNamed(_, name), .. }) => {\n-            let mut sp = sm.def_span(tcx.hir().span(node));\n+            let mut sp = sm.guess_head_span(tcx.hir().span(node));\n             if let Some(param) =\n                 tcx.hir().get_generics(scope).and_then(|generics| generics.get_named(name))\n             {\n@@ -223,7 +223,7 @@ fn msg_span_from_early_bound_and_free_regions(\n             }\n             _ => (\n                 format!(\"the lifetime `{}` as defined on\", region),\n-                sm.def_span(tcx.hir().span(node)),\n+                sm.guess_head_span(tcx.hir().span(node)),\n             ),\n         },\n         _ => bug!(),"}, {"sha": "47d3cdb7a4e2b5158b24165bf290a545f39ba14e", "filename": "src/librustc_infer/traits/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_infer%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_infer%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -20,12 +20,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         requirement: &dyn fmt::Display,\n     ) -> DiagnosticBuilder<'tcx> {\n         let msg = \"impl has stricter requirements than trait\";\n-        let sp = self.tcx.sess.source_map().def_span(error_span);\n+        let sp = self.tcx.sess.source_map().guess_head_span(error_span);\n \n         let mut err = struct_span_err!(self.tcx.sess, sp, E0276, \"{}\", msg);\n \n         if let Some(trait_item_span) = self.tcx.hir().span_if_local(trait_item_def_id) {\n-            let span = self.tcx.sess.source_map().def_span(trait_item_span);\n+            let span = self.tcx.sess.source_map().guess_head_span(trait_item_span);\n             err.span_label(span, format!(\"definition of `{}` from trait\", item_name));\n         }\n \n@@ -46,7 +46,7 @@ pub fn report_object_safety_error(\n         hir::Node::Item(item) => Some(item.ident.span),\n         _ => None,\n     });\n-    let span = tcx.sess.source_map().def_span(span);\n+    let span = tcx.sess.source_map().guess_head_span(span);\n     let mut err = struct_span_err!(\n         tcx.sess,\n         span,"}, {"sha": "906e46edfe7ff330cf2a740b056d5be1ef74b04a", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -76,7 +76,7 @@ impl EarlyLintPass for WhileTrue {\n                 if let ast::LitKind::Bool(true) = lit.kind {\n                     if !lit.span.from_expansion() {\n                         let msg = \"denote infinite loops with `loop { ... }`\";\n-                        let condition_span = cx.sess.source_map().def_span(e.span);\n+                        let condition_span = cx.sess.source_map().guess_head_span(e.span);\n                         cx.struct_span_lint(WHILE_TRUE, condition_span, |lint| {\n                             lint.build(msg)\n                                 .span_suggestion_short(\n@@ -374,9 +374,13 @@ impl MissingDoc {\n \n         let has_doc = attrs.iter().any(|a| has_doc(a));\n         if !has_doc {\n-            cx.struct_span_lint(MISSING_DOCS, cx.tcx.sess.source_map().def_span(sp), |lint| {\n-                lint.build(&format!(\"missing documentation for {} {}\", article, desc)).emit()\n-            });\n+            cx.struct_span_lint(\n+                MISSING_DOCS,\n+                cx.tcx.sess.source_map().guess_head_span(sp),\n+                |lint| {\n+                    lint.build(&format!(\"missing documentation for {} {}\", article, desc)).emit()\n+                },\n+            );\n         }\n     }\n }\n@@ -406,7 +410,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n             if !has_doc {\n                 cx.struct_span_lint(\n                     MISSING_DOCS,\n-                    cx.tcx.sess.source_map().def_span(macro_def.span),\n+                    cx.tcx.sess.source_map().guess_head_span(macro_def.span),\n                     |lint| lint.build(\"missing documentation for macro\").emit(),\n                 );\n             }\n@@ -978,7 +982,7 @@ impl UnreachablePub {\n                 if span.from_expansion() {\n                     applicability = Applicability::MaybeIncorrect;\n                 }\n-                let def_span = cx.tcx.sess.source_map().def_span(span);\n+                let def_span = cx.tcx.sess.source_map().guess_head_span(span);\n                 cx.struct_span_lint(UNREACHABLE_PUB, def_span, |lint| {\n                     let mut err = lint.build(&format!(\"unreachable `pub` {}\", what));\n                     let replacement = if cx.tcx.features().crate_visibility_modifier {"}, {"sha": "8f18fb4a30ed3ae5a366b16378d5257e0d3aa4ff", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 31, "deletions": 58, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -256,25 +256,17 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             \"report_move_out_while_borrowed: location={:?} place={:?} span={:?} borrow={:?}\",\n             location, place, span, borrow\n         );\n-        let value_msg = match self.describe_place(place.as_ref()) {\n-            Some(name) => format!(\"`{}`\", name),\n-            None => \"value\".to_owned(),\n-        };\n-        let borrow_msg = match self.describe_place(borrow.borrowed_place.as_ref()) {\n-            Some(name) => format!(\"`{}`\", name),\n-            None => \"value\".to_owned(),\n-        };\n+        let value_msg = self.describe_any_place(place.as_ref());\n+        let borrow_msg = self.describe_any_place(borrow.borrowed_place.as_ref());\n \n         let borrow_spans = self.retrieve_borrow_spans(borrow);\n         let borrow_span = borrow_spans.args_or_use();\n \n         let move_spans = self.move_spans(place.as_ref(), location);\n         let span = move_spans.args_or_use();\n \n-        let mut err = self.cannot_move_when_borrowed(\n-            span,\n-            &self.describe_place(place.as_ref()).unwrap_or_else(|| \"_\".to_owned()),\n-        );\n+        let mut err =\n+            self.cannot_move_when_borrowed(span, &self.describe_any_place(place.as_ref()));\n         err.span_label(borrow_span, format!(\"borrow of {} occurs here\", borrow_msg));\n         err.span_label(span, format!(\"move out of {} occurs here\", value_msg));\n \n@@ -314,16 +306,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         let mut err = self.cannot_use_when_mutably_borrowed(\n             span,\n-            &self.describe_place(place.as_ref()).unwrap_or_else(|| \"_\".to_owned()),\n+            &self.describe_any_place(place.as_ref()),\n             borrow_span,\n-            &self.describe_place(borrow.borrowed_place.as_ref()).unwrap_or_else(|| \"_\".to_owned()),\n+            &self.describe_any_place(borrow.borrowed_place.as_ref()),\n         );\n \n         borrow_spans.var_span_label(&mut err, {\n             let place = &borrow.borrowed_place;\n-            let desc_place = self.describe_place(place.as_ref()).unwrap_or_else(|| \"_\".to_owned());\n-\n-            format!(\"borrow occurs due to use of `{}`{}\", desc_place, borrow_spans.describe())\n+            let desc_place = self.describe_any_place(place.as_ref());\n+            format!(\"borrow occurs due to use of {}{}\", desc_place, borrow_spans.describe())\n         });\n \n         self.explain_why_borrow_contains_point(location, borrow, None)\n@@ -433,7 +424,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     borrow_spans.var_span_label(\n                         &mut err,\n                         format!(\n-                            \"borrow occurs due to use of `{}`{}\",\n+                            \"borrow occurs due to use of {}{}\",\n                             desc_place,\n                             borrow_spans.describe(),\n                         ),\n@@ -511,16 +502,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         if issued_spans == borrow_spans {\n             borrow_spans.var_span_label(\n                 &mut err,\n-                format!(\"borrows occur due to use of `{}`{}\", desc_place, borrow_spans.describe()),\n+                format!(\"borrows occur due to use of {}{}\", desc_place, borrow_spans.describe()),\n             );\n         } else {\n             let borrow_place = &issued_borrow.borrowed_place;\n-            let borrow_place_desc =\n-                self.describe_place(borrow_place.as_ref()).unwrap_or_else(|| \"_\".to_owned());\n+            let borrow_place_desc = self.describe_any_place(borrow_place.as_ref());\n             issued_spans.var_span_label(\n                 &mut err,\n                 format!(\n-                    \"first borrow occurs due to use of `{}`{}\",\n+                    \"first borrow occurs due to use of {}{}\",\n                     borrow_place_desc,\n                     issued_spans.describe(),\n                 ),\n@@ -529,7 +519,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             borrow_spans.var_span_label(\n                 &mut err,\n                 format!(\n-                    \"second borrow occurs due to use of `{}`{}\",\n+                    \"second borrow occurs due to use of {}{}\",\n                     desc_place,\n                     borrow_spans.describe(),\n                 ),\n@@ -538,7 +528,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         if union_type_name != \"\" {\n             err.note(&format!(\n-                \"`{}` is a field of the union `{}`, so it overlaps the field `{}`\",\n+                \"{} is a field of the union `{}`, so it overlaps the field {}\",\n                 msg_place, union_type_name, msg_borrow,\n             ));\n         }\n@@ -606,7 +596,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             let ty = Place::ty_from(place_base, place_projection, *self.body, self.infcx.tcx).ty;\n             ty.ty_adt_def().filter(|adt| adt.is_union()).map(|_| ty)\n         };\n-        let describe_place = |place| self.describe_place(place).unwrap_or_else(|| \"_\".to_owned());\n \n         // Start with an empty tuple, so we can use the functions on `Option` to reduce some\n         // code duplication (particularly around returning an empty description in the failure\n@@ -645,30 +634,25 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             .and_then(|(target_base, target_field)| {\n                 // With the place of a union and a field access into it, we traverse the second\n                 // borrowed place and look for a access to a different field of the same union.\n-                let Place { local, projection } = second_borrowed_place;\n+                let Place { local, ref projection } = *second_borrowed_place;\n \n                 let mut cursor = &projection[..];\n                 while let [proj_base @ .., elem] = cursor {\n                     cursor = proj_base;\n \n                     if let ProjectionElem::Field(field, _) = elem {\n-                        if let Some(union_ty) = union_ty(*local, proj_base) {\n+                        if let Some(union_ty) = union_ty(local, proj_base) {\n                             if field != target_field\n-                                && *local == target_base.local\n+                                && local == target_base.local\n                                 && proj_base == target_base.projection\n                             {\n-                                // FIXME when we avoid clone reuse describe_place closure\n-                                let describe_base_place = self\n-                                    .describe_place(PlaceRef {\n-                                        local: *local,\n-                                        projection: proj_base,\n-                                    })\n-                                    .unwrap_or_else(|| \"_\".to_owned());\n-\n                                 return Some((\n-                                    describe_base_place,\n-                                    describe_place(first_borrowed_place.as_ref()),\n-                                    describe_place(second_borrowed_place.as_ref()),\n+                                    self.describe_any_place(PlaceRef {\n+                                        local,\n+                                        projection: proj_base,\n+                                    }),\n+                                    self.describe_any_place(first_borrowed_place.as_ref()),\n+                                    self.describe_any_place(second_borrowed_place.as_ref()),\n                                     union_ty.to_string(),\n                                 ));\n                             }\n@@ -681,7 +665,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // If we didn't find a field access into a union, or both places match, then\n                 // only return the description of the first place.\n                 (\n-                    describe_place(first_borrowed_place.as_ref()),\n+                    self.describe_any_place(first_borrowed_place.as_ref()),\n                     \"\".to_string(),\n                     \"\".to_string(),\n                     \"\".to_string(),\n@@ -1404,12 +1388,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let loan_spans = self.retrieve_borrow_spans(loan);\n         let loan_span = loan_spans.args_or_use();\n \n+        let descr_place = self.describe_any_place(place.as_ref());\n         if loan.kind == BorrowKind::Shallow {\n             if let Some(section) = self.classify_immutable_section(&loan.assigned_place) {\n                 let mut err = self.cannot_mutate_in_immutable_section(\n                     span,\n                     loan_span,\n-                    &self.describe_place(place.as_ref()).unwrap_or_else(|| \"_\".to_owned()),\n+                    &descr_place,\n                     section,\n                     \"assign\",\n                 );\n@@ -1424,11 +1409,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n         }\n \n-        let mut err = self.cannot_assign_to_borrowed(\n-            span,\n-            loan_span,\n-            &self.describe_place(place.as_ref()).unwrap_or_else(|| \"_\".to_owned()),\n-        );\n+        let mut err = self.cannot_assign_to_borrowed(span, loan_span, &descr_place);\n \n         loan_spans\n             .var_span_label(&mut err, format!(\"borrow occurs due to use{}\", loan_spans.describe()));\n@@ -1482,27 +1463,19 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             })\n             | Some(LocalDecl { local_info: LocalInfo::StaticRef { .. }, .. })\n             | Some(LocalDecl { local_info: LocalInfo::Other, .. })\n-            | None => (self.describe_place(place.as_ref()), assigned_span),\n-            Some(decl) => (self.describe_place(err_place.as_ref()), decl.source_info.span),\n+            | None => (self.describe_any_place(place.as_ref()), assigned_span),\n+            Some(decl) => (self.describe_any_place(err_place.as_ref()), decl.source_info.span),\n         };\n \n-        let mut err = self.cannot_reassign_immutable(\n-            span,\n-            place_description.as_ref().map(AsRef::as_ref).unwrap_or(\"_\"),\n-            from_arg,\n-        );\n+        let mut err = self.cannot_reassign_immutable(span, &place_description, from_arg);\n         let msg = if from_arg {\n             \"cannot assign to immutable argument\"\n         } else {\n             \"cannot assign twice to immutable variable\"\n         };\n         if span != assigned_span {\n             if !from_arg {\n-                let value_msg = match place_description {\n-                    Some(name) => format!(\"`{}`\", name),\n-                    None => \"value\".to_owned(),\n-                };\n-                err.span_label(assigned_span, format!(\"first assignment to {}\", value_msg));\n+                err.span_label(assigned_span, format!(\"first assignment to {}\", place_description));\n             }\n         }\n         if let Some(decl) = local_decl {"}, {"sha": "605093d8acad2fc184fe38b8c4315543af03e738", "filename": "src/librustc_mir/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -137,8 +137,23 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n     }\n \n-    /// End-user visible description of `place` if one can be found. If the\n-    /// place is a temporary for instance, None will be returned.\n+    /// End-user visible description of `place` if one can be found.\n+    /// If the place is a temporary for instance, `\"value\"` will be returned.\n+    pub(super) fn describe_any_place(&self, place_ref: PlaceRef<'tcx>) -> String {\n+        match self.describe_place(place_ref) {\n+            Some(mut descr) => {\n+                // Surround descr with `backticks`.\n+                descr.reserve(2);\n+                descr.insert_str(0, \"`\");\n+                descr.push_str(\"`\");\n+                descr\n+            }\n+            None => \"value\".to_string(),\n+        }\n+    }\n+\n+    /// End-user visible description of `place` if one can be found.\n+    /// If the place is a temporary for instance, None will be returned.\n     pub(super) fn describe_place(&self, place_ref: PlaceRef<'tcx>) -> Option<String> {\n         self.describe_place_with_options(place_ref, IncludingDowncast(false))\n     }"}, {"sha": "2cdc1ced0bbeaffb2dd4d093ad525f207ff6c9f3", "filename": "src/librustc_mir/borrow_check/diagnostics/move_errors.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -272,14 +272,14 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         span: Span,\n     ) -> DiagnosticBuilder<'a> {\n         let description = if place.projection.len() == 1 {\n-            format!(\"static item `{}`\", self.describe_place(place.as_ref()).unwrap())\n+            format!(\"static item {}\", self.describe_any_place(place.as_ref()))\n         } else {\n             let base_static = PlaceRef { local: place.local, projection: &[ProjectionElem::Deref] };\n \n             format!(\n-                \"`{:?}` as `{:?}` is a static item\",\n-                self.describe_place(place.as_ref()).unwrap(),\n-                self.describe_place(base_static).unwrap(),\n+                \"{} as {} is a static item\",\n+                self.describe_any_place(place.as_ref()),\n+                self.describe_any_place(base_static),\n             )\n         };\n \n@@ -349,16 +349,14 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 let upvar_name = upvar.name;\n                 let upvar_span = self.infcx.tcx.hir().span(upvar_hir_id);\n \n-                let place_name = self.describe_place(move_place.as_ref()).unwrap();\n+                let place_name = self.describe_any_place(move_place.as_ref());\n \n-                let place_description = if self\n-                    .is_upvar_field_projection(move_place.as_ref())\n-                    .is_some()\n-                {\n-                    format!(\"`{}`, a {}\", place_name, capture_description)\n-                } else {\n-                    format!(\"`{}`, as `{}` is a {}\", place_name, upvar_name, capture_description,)\n-                };\n+                let place_description =\n+                    if self.is_upvar_field_projection(move_place.as_ref()).is_some() {\n+                        format!(\"{}, a {}\", place_name, capture_description)\n+                    } else {\n+                        format!(\"{}, as `{}` is a {}\", place_name, upvar_name, capture_description)\n+                    };\n \n                 debug!(\n                     \"report: closure_kind_ty={:?} closure_kind={:?} place_description={:?}\","}, {"sha": "f224041270dcc04b0bfb289a23d58f923d46e8f0", "filename": "src/librustc_mir/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -169,9 +169,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 borrow_spans.var_span_label(\n                     &mut err,\n                     format!(\n-                        \"mutable borrow occurs due to use of `{}` in closure\",\n-                        // always Some() if the message is printed.\n-                        self.describe_place(access_place.as_ref()).unwrap_or_default(),\n+                        \"mutable borrow occurs due to use of {} in closure\",\n+                        self.describe_any_place(access_place.as_ref()),\n                     ),\n                 );\n                 borrow_span"}, {"sha": "3ba60e69041e73062edc41e11ae9c3b94ce9acf3", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -565,14 +565,14 @@ fn is_enclosed(\n }\n \n fn report_unused_unsafe(tcx: TyCtxt<'_>, used_unsafe: &FxHashSet<hir::HirId>, id: hir::HirId) {\n-    let span = tcx.sess.source_map().def_span(tcx.hir().span(id));\n+    let span = tcx.sess.source_map().guess_head_span(tcx.hir().span(id));\n     tcx.struct_span_lint_hir(UNUSED_UNSAFE, id, span, |lint| {\n         let msg = \"unnecessary `unsafe` block\";\n         let mut db = lint.build(msg);\n         db.span_label(span, msg);\n         if let Some((kind, id)) = is_enclosed(tcx, used_unsafe, id) {\n             db.span_label(\n-                tcx.sess.source_map().def_span(tcx.hir().span(id)),\n+                tcx.sess.source_map().guess_head_span(tcx.hir().span(id)),\n                 format!(\"because it's nested under this `unsafe` {}\", kind),\n             );\n         }"}, {"sha": "6e6bbabd35b3c4e3b0774ca876e7451be255debf", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -4,7 +4,7 @@ use rustc_span::{MultiSpan, Span};\n \n impl<'cx, 'tcx> crate::borrow_check::MirBorrowckCtxt<'cx, 'tcx> {\n     crate fn cannot_move_when_borrowed(&self, span: Span, desc: &str) -> DiagnosticBuilder<'cx> {\n-        struct_span_err!(self, span, E0505, \"cannot move out of `{}` because it is borrowed\", desc,)\n+        struct_span_err!(self, span, E0505, \"cannot move out of {} because it is borrowed\", desc,)\n     }\n \n     crate fn cannot_use_when_mutably_borrowed(\n@@ -18,12 +18,12 @@ impl<'cx, 'tcx> crate::borrow_check::MirBorrowckCtxt<'cx, 'tcx> {\n             self,\n             span,\n             E0503,\n-            \"cannot use `{}` because it was mutably borrowed\",\n+            \"cannot use {} because it was mutably borrowed\",\n             desc,\n         );\n \n-        err.span_label(borrow_span, format!(\"borrow of `{}` occurs here\", borrow_desc));\n-        err.span_label(span, format!(\"use of borrowed `{}`\", borrow_desc));\n+        err.span_label(borrow_span, format!(\"borrow of {} occurs here\", borrow_desc));\n+        err.span_label(span, format!(\"use of borrowed {}\", borrow_desc));\n         err\n     }\n \n@@ -53,12 +53,12 @@ impl<'cx, 'tcx> crate::borrow_check::MirBorrowckCtxt<'cx, 'tcx> {\n         old_load_end_span: Option<Span>,\n     ) -> DiagnosticBuilder<'cx> {\n         let via =\n-            |msg: &str| if msg.is_empty() { msg.to_string() } else { format!(\" (via `{}`)\", msg) };\n+            |msg: &str| if msg.is_empty() { \"\".to_string() } else { format!(\" (via {})\", msg) };\n         let mut err = struct_span_err!(\n             self,\n             new_loan_span,\n             E0499,\n-            \"cannot borrow `{}`{} as mutable more than once at a time\",\n+            \"cannot borrow {}{} as mutable more than once at a time\",\n             desc,\n             via(opt_via),\n         );\n@@ -103,7 +103,7 @@ impl<'cx, 'tcx> crate::borrow_check::MirBorrowckCtxt<'cx, 'tcx> {\n             self,\n             new_loan_span,\n             E0524,\n-            \"two closures require unique access to `{}` at the same time\",\n+            \"two closures require unique access to {} at the same time\",\n             desc,\n         );\n         if old_loan_span == new_loan_span {\n@@ -136,7 +136,7 @@ impl<'cx, 'tcx> crate::borrow_check::MirBorrowckCtxt<'cx, 'tcx> {\n             self,\n             new_loan_span,\n             E0500,\n-            \"closure requires unique access to `{}` but {} is already borrowed{}\",\n+            \"closure requires unique access to {} but {} is already borrowed{}\",\n             desc_new,\n             noun_old,\n             old_opt_via,\n@@ -168,7 +168,7 @@ impl<'cx, 'tcx> crate::borrow_check::MirBorrowckCtxt<'cx, 'tcx> {\n             self,\n             new_loan_span,\n             E0501,\n-            \"cannot borrow `{}`{} as {} because previous closure \\\n+            \"cannot borrow {}{} as {} because previous closure \\\n              requires unique access\",\n             desc_new,\n             opt_via,\n@@ -201,13 +201,12 @@ impl<'cx, 'tcx> crate::borrow_check::MirBorrowckCtxt<'cx, 'tcx> {\n         old_load_end_span: Option<Span>,\n     ) -> DiagnosticBuilder<'cx> {\n         let via =\n-            |msg: &str| if msg.is_empty() { msg.to_string() } else { format!(\" (via `{}`)\", msg) };\n+            |msg: &str| if msg.is_empty() { \"\".to_string() } else { format!(\" (via {})\", msg) };\n         let mut err = struct_span_err!(\n             self,\n             span,\n             E0502,\n-            \"cannot borrow `{}`{} as {} because {} is also borrowed \\\n-             as {}{}\",\n+            \"cannot borrow {}{} as {} because {} is also borrowed as {}{}\",\n             desc_new,\n             via(msg_new),\n             kind_new,\n@@ -225,7 +224,7 @@ impl<'cx, 'tcx> crate::borrow_check::MirBorrowckCtxt<'cx, 'tcx> {\n             err.span_label(\n                 span,\n                 format!(\n-                    \"{} borrow of `{}` -- which overlaps with `{}` -- occurs here\",\n+                    \"{} borrow of {} -- which overlaps with {} -- occurs here\",\n                     kind_new, msg_new, msg_old,\n                 ),\n             );\n@@ -248,12 +247,12 @@ impl<'cx, 'tcx> crate::borrow_check::MirBorrowckCtxt<'cx, 'tcx> {\n             self,\n             span,\n             E0506,\n-            \"cannot assign to `{}` because it is borrowed\",\n+            \"cannot assign to {} because it is borrowed\",\n             desc,\n         );\n \n-        err.span_label(borrow_span, format!(\"borrow of `{}` occurs here\", desc));\n-        err.span_label(span, format!(\"assignment to borrowed `{}` occurs here\", desc));\n+        err.span_label(borrow_span, format!(\"borrow of {} occurs here\", desc));\n+        err.span_label(span, format!(\"assignment to borrowed {} occurs here\", desc));\n         err\n     }\n \n@@ -264,7 +263,7 @@ impl<'cx, 'tcx> crate::borrow_check::MirBorrowckCtxt<'cx, 'tcx> {\n         is_arg: bool,\n     ) -> DiagnosticBuilder<'cx> {\n         let msg = if is_arg { \"to immutable argument\" } else { \"twice to immutable variable\" };\n-        struct_span_err!(self, span, E0384, \"cannot assign {} `{}`\", msg, desc,)\n+        struct_span_err!(self, span, E0384, \"cannot assign {} {}\", msg, desc)\n     }\n \n     crate fn cannot_assign(&self, span: Span, desc: &str) -> DiagnosticBuilder<'cx> {\n@@ -362,7 +361,7 @@ impl<'cx, 'tcx> crate::borrow_check::MirBorrowckCtxt<'cx, 'tcx> {\n             self,\n             mutate_span,\n             E0510,\n-            \"cannot {} `{}` in {}\",\n+            \"cannot {} {} in {}\",\n             action,\n             immutable_place,\n             immutable_section,"}, {"sha": "3f92742261636cc580a8dc87db242e3dcd71208b", "filename": "src/librustc_mir_build/lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_mir_build%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_mir_build%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Flints.rs?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -123,7 +123,7 @@ fn check_fn_for_unconditional_recursion<'tcx>(\n     // recurs.\n     if !reached_exit_without_self_call && !self_call_locations.is_empty() {\n         let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-        let sp = tcx.sess.source_map().def_span(tcx.hir().span(hir_id));\n+        let sp = tcx.sess.source_map().guess_head_span(tcx.hir().span(hir_id));\n         tcx.struct_span_lint_hir(UNCONDITIONAL_RECURSION, hir_id, sp, |lint| {\n             let mut db = lint.build(\"function cannot return without recursing\");\n             db.span_label(sp, \"cannot return without recursing\");"}, {"sha": "c4546dedfcdd48db5d90770ad7271bc9b8687e34", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 103, "deletions": 52, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -17,7 +17,6 @@ use rustc_span::symbol::kw;\n use rustc_span::{MultiSpan, Span, SpanSnippetError, DUMMY_SP};\n \n use log::{debug, trace};\n-use std::mem;\n \n const TURBOFISH: &str = \"use `::<...>` instead of `<...>` to specify type arguments\";\n \n@@ -459,9 +458,28 @@ impl<'a> Parser<'a> {\n         err: &mut DiagnosticBuilder<'_>,\n         inner_op: &Expr,\n         outer_op: &Spanned<AssocOp>,\n-    ) {\n+    ) -> bool /* advanced the cursor */ {\n         if let ExprKind::Binary(op, ref l1, ref r1) = inner_op.kind {\n-            match (op.node, &outer_op.node) {\n+            if let ExprKind::Field(_, ident) = l1.kind {\n+                if ident.as_str().parse::<i32>().is_err() && !matches!(r1.kind, ExprKind::Lit(_)) {\n+                    // The parser has encountered `foo.bar<baz`, the likelihood of the turbofish\n+                    // suggestion being the only one to apply is high.\n+                    return false;\n+                }\n+            }\n+            let mut enclose = |left: Span, right: Span| {\n+                err.multipart_suggestion(\n+                    \"parenthesize the comparison\",\n+                    vec![\n+                        (left.shrink_to_lo(), \"(\".to_string()),\n+                        (right.shrink_to_hi(), \")\".to_string()),\n+                    ],\n+                    Applicability::MaybeIncorrect,\n+                );\n+            };\n+            return match (op.node, &outer_op.node) {\n+                // `x == y == z`\n+                (BinOpKind::Eq, AssocOp::Equal) |\n                 // `x < y < z` and friends.\n                 (BinOpKind::Lt, AssocOp::Less) | (BinOpKind::Lt, AssocOp::LessEqual) |\n                 (BinOpKind::Le, AssocOp::LessEqual) | (BinOpKind::Le, AssocOp::Less) |\n@@ -472,35 +490,55 @@ impl<'a> Parser<'a> {\n                         self.span_to_snippet(e.span)\n                             .unwrap_or_else(|_| pprust::expr_to_string(&e))\n                     };\n-                    err.span_suggestion(\n-                        inner_op.span.to(outer_op.span),\n-                        \"split the comparison into two...\",\n-                        format!(\n-                            \"{} {} {} && {} {}\",\n-                            expr_to_str(&l1),\n-                            op.node.to_string(),\n-                            expr_to_str(&r1),\n-                            expr_to_str(&r1),\n-                            outer_op.node.to_ast_binop().unwrap().to_string(),\n-                        ),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                    err.span_suggestion(\n-                        inner_op.span.to(outer_op.span),\n-                        \"...or parenthesize one of the comparisons\",\n-                        format!(\n-                            \"({} {} {}) {}\",\n-                            expr_to_str(&l1),\n-                            op.node.to_string(),\n-                            expr_to_str(&r1),\n-                            outer_op.node.to_ast_binop().unwrap().to_string(),\n-                        ),\n+                    err.span_suggestion_verbose(\n+                            inner_op.span.shrink_to_hi(),\n+                        \"split the comparison into two\",\n+                        format!(\" && {}\", expr_to_str(&r1)),\n                         Applicability::MaybeIncorrect,\n                     );\n+                    false // Keep the current parse behavior, where the AST is `(x < y) < z`.\n                 }\n-                _ => {}\n-            }\n+                // `x == y < z`\n+                (BinOpKind::Eq, AssocOp::Less) | (BinOpKind::Eq, AssocOp::LessEqual) |\n+                (BinOpKind::Eq, AssocOp::Greater) | (BinOpKind::Eq, AssocOp::GreaterEqual) => {\n+                    // Consume `z`/outer-op-rhs.\n+                    let snapshot = self.clone();\n+                    match self.parse_expr() {\n+                        Ok(r2) => {\n+                            // We are sure that outer-op-rhs could be consumed, the suggestion is\n+                            // likely correct.\n+                            enclose(r1.span, r2.span);\n+                            true\n+                        }\n+                        Err(mut expr_err) => {\n+                            expr_err.cancel();\n+                            *self = snapshot;\n+                            false\n+                        }\n+                    }\n+                }\n+                // `x > y == z`\n+                (BinOpKind::Lt, AssocOp::Equal) | (BinOpKind::Le, AssocOp::Equal) |\n+                (BinOpKind::Gt, AssocOp::Equal) | (BinOpKind::Ge, AssocOp::Equal) => {\n+                    let snapshot = self.clone();\n+                    // At this point it is always valid to enclose the lhs in parentheses, no\n+                    // further checks are necessary.\n+                    match self.parse_expr() {\n+                        Ok(_) => {\n+                            enclose(l1.span, r1.span);\n+                            true\n+                        }\n+                        Err(mut expr_err) => {\n+                            expr_err.cancel();\n+                            *self = snapshot;\n+                            false\n+                        }\n+                    }\n+                }\n+                _ => false,\n+            };\n         }\n+        false\n     }\n \n     /// Produces an error if comparison operators are chained (RFC #558).\n@@ -534,31 +572,26 @@ impl<'a> Parser<'a> {\n             |this: &Self, span| Ok(Some(this.mk_expr(span, ExprKind::Err, AttrVec::new())));\n \n         match inner_op.kind {\n-            ExprKind::Binary(op, _, _) if op.node.is_comparison() => {\n-                // Respan to include both operators.\n-                let op_span = op.span.to(self.prev_token.span);\n-                let mut err =\n-                    self.struct_span_err(op_span, \"comparison operators cannot be chained\");\n-\n-                // If it looks like a genuine attempt to chain operators (as opposed to a\n-                // misformatted turbofish, for instance), suggest a correct form.\n-                self.attempt_chained_comparison_suggestion(&mut err, inner_op, outer_op);\n+            ExprKind::Binary(op, ref l1, ref r1) if op.node.is_comparison() => {\n+                let mut err = self.struct_span_err(\n+                    vec![op.span, self.prev_token.span],\n+                    \"comparison operators cannot be chained\",\n+                );\n \n                 let suggest = |err: &mut DiagnosticBuilder<'_>| {\n                     err.span_suggestion_verbose(\n-                        op_span.shrink_to_lo(),\n+                        op.span.shrink_to_lo(),\n                         TURBOFISH,\n                         \"::\".to_string(),\n                         Applicability::MaybeIncorrect,\n                     );\n                 };\n \n-                if op.node == BinOpKind::Lt &&\n-                    outer_op.node == AssocOp::Less ||  // Include `<` to provide this recommendation\n-                    outer_op.node == AssocOp::Greater\n-                // even in a case like the following:\n+                // Include `<` to provide this recommendation even in a case like\n+                // `Foo<Bar<Baz<Qux, ()>>>`\n+                if op.node == BinOpKind::Lt && outer_op.node == AssocOp::Less\n+                    || outer_op.node == AssocOp::Greater\n                 {\n-                    //     Foo<Bar<Baz<Qux, ()>>>\n                     if outer_op.node == AssocOp::Less {\n                         let snapshot = self.clone();\n                         self.bump();\n@@ -572,7 +605,7 @@ impl<'a> Parser<'a> {\n                         {\n                             // We don't have `foo< bar >(` or `foo< bar >::`, so we rewind the\n                             // parser and bail out.\n-                            mem::replace(self, snapshot.clone());\n+                            *self = snapshot.clone();\n                         }\n                     }\n                     return if token::ModSep == self.token.kind {\n@@ -597,7 +630,7 @@ impl<'a> Parser<'a> {\n                                 expr_err.cancel();\n                                 // Not entirely sure now, but we bubble the error up with the\n                                 // suggestion.\n-                                mem::replace(self, snapshot);\n+                                *self = snapshot;\n                                 Err(err)\n                             }\n                         }\n@@ -617,15 +650,33 @@ impl<'a> Parser<'a> {\n                             }\n                         }\n                     } else {\n-                        // All we know is that this is `foo < bar >` and *nothing* else. Try to\n-                        // be helpful, but don't attempt to recover.\n-                        err.help(TURBOFISH);\n-                        err.help(\"or use `(...)` if you meant to specify fn arguments\");\n-                        // These cases cause too many knock-down errors, bail out (#61329).\n-                        Err(err)\n+                        if !matches!(l1.kind, ExprKind::Lit(_))\n+                            && !matches!(r1.kind, ExprKind::Lit(_))\n+                        {\n+                            // All we know is that this is `foo < bar >` and *nothing* else. Try to\n+                            // be helpful, but don't attempt to recover.\n+                            err.help(TURBOFISH);\n+                            err.help(\"or use `(...)` if you meant to specify fn arguments\");\n+                        }\n+\n+                        // If it looks like a genuine attempt to chain operators (as opposed to a\n+                        // misformatted turbofish, for instance), suggest a correct form.\n+                        if self.attempt_chained_comparison_suggestion(&mut err, inner_op, outer_op)\n+                        {\n+                            err.emit();\n+                            mk_err_expr(self, inner_op.span.to(self.prev_token.span))\n+                        } else {\n+                            // These cases cause too many knock-down errors, bail out (#61329).\n+                            Err(err)\n+                        }\n                     };\n                 }\n+                let recover =\n+                    self.attempt_chained_comparison_suggestion(&mut err, inner_op, outer_op);\n                 err.emit();\n+                if recover {\n+                    return mk_err_expr(self, inner_op.span.to(self.prev_token.span));\n+                }\n             }\n             _ => {}\n         }\n@@ -643,7 +694,7 @@ impl<'a> Parser<'a> {\n \n         if self.token.kind == token::Eof {\n             // Not entirely sure that what we consumed were fn arguments, rollback.\n-            mem::replace(self, snapshot);\n+            *self = snapshot;\n             Err(())\n         } else {\n             // 99% certain that the suggestion is correct, continue parsing."}, {"sha": "cc88464d774e852aff90b474d6d45f4709966913", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -907,7 +907,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn error_bad_item_kind<T>(&self, span: Span, kind: &ItemKind, ctx: &str) -> Option<T> {\n-        let span = self.sess.source_map().def_span(span);\n+        let span = self.sess.source_map().guess_head_span(span);\n         let msg = format!(\"{} is not supported in {}\", kind.descr(), ctx);\n         self.struct_span_err(span, &msg).emit();\n         None"}, {"sha": "2781c5c125d9f2b9a79ee2f225e647ed86e40214", "filename": "src/librustc_passes/dead.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_passes%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_passes%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdead.rs?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -590,7 +590,7 @@ impl Visitor<'tcx> for DeadVisitor<'tcx> {\n                     // We should probably annotate ident.span with the macro\n                     // context, but that's a larger change.\n                     if item.span.source_callee().is_some() {\n-                        self.tcx.sess.source_map().def_span(item.span)\n+                        self.tcx.sess.source_map().guess_head_span(item.span)\n                     } else {\n                         item.ident.span\n                     }\n@@ -663,7 +663,7 @@ impl Visitor<'tcx> for DeadVisitor<'tcx> {\n             }\n             hir::ImplItemKind::Fn(_, body_id) => {\n                 if !self.symbol_is_live(impl_item.hir_id) {\n-                    let span = self.tcx.sess.source_map().def_span(impl_item.span);\n+                    let span = self.tcx.sess.source_map().guess_head_span(impl_item.span);\n                     self.warn_dead_code(\n                         impl_item.hir_id,\n                         span,"}, {"sha": "78b7e256de21779b2ecae2e0b443961c38c13163", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -791,12 +791,12 @@ impl<'a> Resolver<'a> {\n                 _ => Some(\n                     self.session\n                         .source_map()\n-                        .def_span(self.cstore().get_span_untracked(def_id, self.session)),\n+                        .guess_head_span(self.cstore().get_span_untracked(def_id, self.session)),\n                 ),\n             });\n             if let Some(span) = def_span {\n                 err.span_label(\n-                    self.session.source_map().def_span(span),\n+                    self.session.source_map().guess_head_span(span),\n                     &format!(\n                         \"similarly named {} `{}` defined here\",\n                         suggestion.res.descr(),\n@@ -986,7 +986,7 @@ impl<'a> Resolver<'a> {\n                 which = if first { \"\" } else { \" which\" },\n                 dots = if next_binding.is_some() { \"...\" } else { \"\" },\n             );\n-            let def_span = self.session.source_map().def_span(binding.span);\n+            let def_span = self.session.source_map().guess_head_span(binding.span);\n             let mut note_span = MultiSpan::from_span(def_span);\n             if !first && binding.vis == ty::Visibility::Public {\n                 note_span.push_span_label(def_span, \"consider importing it directly\".into());"}, {"sha": "8c7ab8f5b1a5aec2aca8a533f8d771d6524e87ea", "filename": "src/librustc_resolve/imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_resolve%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_resolve%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fimports.rs?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -1441,7 +1441,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                     let enum_resolution = resolutions.get(&key).expect(\"resolution should exist\");\n                     let enum_span =\n                         enum_resolution.borrow().binding.expect(\"binding should exist\").span;\n-                    let enum_def_span = this.session.source_map().def_span(enum_span);\n+                    let enum_def_span = this.session.source_map().guess_head_span(enum_span);\n                     let enum_def_snippet = this\n                         .session\n                         .source_map()"}, {"sha": "9d5121cbad56205cf6e72e6f179a690c39563f9e", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -2517,7 +2517,8 @@ impl<'a> Resolver<'a> {\n             false => \"defined\",\n         };\n \n-        let (name, span) = (ident.name, self.session.source_map().def_span(new_binding.span));\n+        let (name, span) =\n+            (ident.name, self.session.source_map().guess_head_span(new_binding.span));\n \n         if let Some(s) = self.name_already_seen.get(&name) {\n             if s == &span {\n@@ -2558,7 +2559,7 @@ impl<'a> Resolver<'a> {\n \n         err.span_label(span, format!(\"`{}` re{} here\", name, new_participle));\n         err.span_label(\n-            self.session.source_map().def_span(old_binding.span),\n+            self.session.source_map().guess_head_span(old_binding.span),\n             format!(\"previous {} of the {} `{}` here\", old_noun, old_kind, name),\n         );\n "}, {"sha": "57e68320f3fbb1fec631b824200faa09dd2c2909", "filename": "src/librustc_span/source_map.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_span%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_span%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsource_map.rs?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -733,7 +733,14 @@ impl SourceMap {\n         }\n     }\n \n-    pub fn def_span(&self, sp: Span) -> Span {\n+    /// Given a `Span`, return a span ending in the closest `{`. This is useful when you have a\n+    /// `Span` enclosing a whole item but we need to point at only the head (usually the first\n+    /// line) of that item.\n+    ///\n+    /// *Only suitable for diagnostics.*\n+    pub fn guess_head_span(&self, sp: Span) -> Span {\n+        // FIXME: extend the AST items to have a head span, or replace callers with pointing at\n+        // the item's ident when appropriate.\n         self.span_until_char(sp, '{')\n     }\n "}, {"sha": "12939519fc28fe8a0cadd6c1fd23563eb2e68304", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -482,11 +482,10 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n                     ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n                         let found_kind = self.closure_kind(closure_substs).unwrap();\n-                        let closure_span = self\n-                            .tcx\n-                            .sess\n-                            .source_map()\n-                            .def_span(self.tcx.hir().span_if_local(closure_def_id).unwrap());\n+                        let closure_span =\n+                            self.tcx.sess.source_map().guess_head_span(\n+                                self.tcx.hir().span_if_local(closure_def_id).unwrap(),\n+                            );\n                         let hir_id = self.tcx.hir().as_local_hir_id(closure_def_id).unwrap();\n                         let mut err = struct_span_err!(\n                             self.tcx.sess,\n@@ -580,7 +579,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n                 let found_span = found_did\n                     .and_then(|did| self.tcx.hir().span_if_local(did))\n-                    .map(|sp| self.tcx.sess.source_map().def_span(sp)); // the sp could be an fn def\n+                    .map(|sp| self.tcx.sess.source_map().guess_head_span(sp)); // the sp could be an fn def\n \n                 if self.reported_closure_mismatch.borrow().contains(&(span, found_span)) {\n                     // We check closures twice, with obligations flowing in different directions,\n@@ -680,7 +679,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 kind: hir::ExprKind::Closure(_, ref _decl, id, span, _),\n                 ..\n             }) => (\n-                self.tcx.sess.source_map().def_span(span),\n+                self.tcx.sess.source_map().guess_head_span(span),\n                 self.tcx\n                     .hir()\n                     .body(id)\n@@ -723,7 +722,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 kind: hir::TraitItemKind::Fn(ref sig, _),\n                 ..\n             }) => (\n-                self.tcx.sess.source_map().def_span(span),\n+                self.tcx.sess.source_map().guess_head_span(span),\n                 sig.decl\n                     .inputs\n                     .iter()\n@@ -741,7 +740,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     .ctor_hir_id()\n                     .map(|hir_id| self.tcx.hir().span(hir_id))\n                     .unwrap_or(DUMMY_SP);\n-                let span = self.tcx.sess.source_map().def_span(span);\n+                let span = self.tcx.sess.source_map().guess_head_span(span);\n \n                 (span, vec![ArgKind::empty(); variant_data.fields().len()])\n             }\n@@ -1624,7 +1623,7 @@ pub fn recursive_type_with_infinite_size_error(\n ) -> DiagnosticBuilder<'tcx> {\n     assert!(type_def_id.is_local());\n     let span = tcx.hir().span_if_local(type_def_id).unwrap();\n-    let span = tcx.sess.source_map().def_span(span);\n+    let span = tcx.sess.source_map().guess_head_span(span);\n     let mut err = struct_span_err!(\n         tcx.sess,\n         span,"}, {"sha": "a4be70df122d7af2adcbf8940ca77b9db74e10d7", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -1381,7 +1381,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 let msg = format!(\"required by `{}`\", item_name);\n \n                 if let Some(sp) = tcx.hir().span_if_local(item_def_id) {\n-                    let sp = tcx.sess.source_map().def_span(sp);\n+                    let sp = tcx.sess.source_map().guess_head_span(sp);\n                     err.span_label(sp, &msg);\n                 } else {\n                     err.note(&msg);"}, {"sha": "0cc5032d74e8ec9215ff3e4c4f8f2866af3ff0eb", "filename": "src/librustc_trait_selection/traits/specialize/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -325,7 +325,7 @@ pub(super) fn specialization_graph_provider(\n \n             if let Some(overlap) = overlap {\n                 let impl_span =\n-                    tcx.sess.source_map().def_span(tcx.span_of_impl(impl_def_id).unwrap());\n+                    tcx.sess.source_map().guess_head_span(tcx.span_of_impl(impl_def_id).unwrap());\n \n                 // Work to be done after we've built the DiagnosticBuilder. We have to define it\n                 // now because the struct_lint methods don't return back the DiagnosticBuilder\n@@ -347,7 +347,7 @@ pub(super) fn specialization_graph_provider(\n                     match tcx.span_of_impl(overlap.with_impl) {\n                         Ok(span) => {\n                             err.span_label(\n-                                tcx.sess.source_map().def_span(span),\n+                                tcx.sess.source_map().guess_head_span(span),\n                                 \"first implementation here\".to_string(),\n                             );\n "}, {"sha": "aa129d2b81c5317c598754aaa840be4a464dc360", "filename": "src/librustc_trait_selection/traits/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -186,7 +186,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                     _ => (None, None),\n                 };\n \n-                let item_span = item.map(|i| tcx.sess.source_map().def_span(i.span));\n+                let item_span = item.map(|i| tcx.sess.source_map().guess_head_span(i.span));\n                 match pred {\n                     ty::Predicate::Projection(proj) => {\n                         // The obligation comes not from the current `impl` nor the `trait` being"}, {"sha": "54c646b855777e4985dc77842b724e0071263751", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -2269,7 +2269,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     }\n \n                     if let Some(sp) = tcx.hir().span_if_local(adt_def.did) {\n-                        let sp = tcx.sess.source_map().def_span(sp);\n+                        let sp = tcx.sess.source_map().guess_head_span(sp);\n                         err.span_label(sp, format!(\"variant `{}` not found here\", assoc_ident));\n                     }\n "}, {"sha": "a34389b7d89682eb41d220ce39494b95a7102e52", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -332,7 +332,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 //   | |_____^ expected integer, found `()`\n                 // ```\n                 if outer_sp.is_some() {\n-                    outer_sp = Some(self.tcx.sess.source_map().def_span(span));\n+                    outer_sp = Some(self.tcx.sess.source_map().guess_head_span(span));\n                 }\n                 else_expr.span\n             }"}, {"sha": "412f687b43ec6e2b00e0a67bc42ce81ee9a8e125", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -35,7 +35,7 @@ crate fn compare_impl_method<'tcx>(\n ) {\n     debug!(\"compare_impl_method(impl_trait_ref={:?})\", impl_trait_ref);\n \n-    let impl_m_span = tcx.sess.source_map().def_span(impl_m_span);\n+    let impl_m_span = tcx.sess.source_map().guess_head_span(impl_m_span);\n \n     if let Err(ErrorReported) = compare_self_type(tcx, impl_m, impl_m_span, trait_m, impl_trait_ref)\n     {\n@@ -363,7 +363,7 @@ fn check_region_bounds_on_impl_item<'tcx>(\n     // the moment, give a kind of vague error message.\n     if trait_params != impl_params {\n         let item_kind = assoc_item_kind_str(impl_m);\n-        let def_span = tcx.sess.source_map().def_span(span);\n+        let def_span = tcx.sess.source_map().guess_head_span(span);\n         let span = tcx.hir().get_generics(impl_m.def_id).map(|g| g.span).unwrap_or(def_span);\n         let mut err = struct_span_err!(\n             tcx.sess,\n@@ -375,7 +375,7 @@ fn check_region_bounds_on_impl_item<'tcx>(\n         );\n         err.span_label(span, &format!(\"lifetimes do not match {} in trait\", item_kind));\n         if let Some(sp) = tcx.hir().span_if_local(trait_m.def_id) {\n-            let def_sp = tcx.sess.source_map().def_span(sp);\n+            let def_sp = tcx.sess.source_map().guess_head_span(sp);\n             let sp = tcx.hir().get_generics(trait_m.def_id).map(|g| g.span).unwrap_or(def_sp);\n             err.span_label(\n                 sp,"}, {"sha": "e940ecce0b9fb5cd60e456a7863a4e874e61d567", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -147,7 +147,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         if let Some(note_span) = note_span {\n                             // We have a span pointing to the method. Show note with snippet.\n                             err.span_note(\n-                                self.tcx.sess.source_map().def_span(note_span),\n+                                self.tcx.sess.source_map().guess_head_span(note_span),\n                                 &note_str,\n                             );\n                         } else {\n@@ -189,8 +189,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 Some(item) => item,\n                                 None => continue,\n                             };\n-                        let item_span =\n-                            self.tcx.sess.source_map().def_span(self.tcx.def_span(item.def_id));\n+                        let item_span = self\n+                            .tcx\n+                            .sess\n+                            .source_map()\n+                            .guess_head_span(self.tcx.def_span(item.def_id));\n                         let idx = if sources.len() > 1 {\n                             let msg = &format!(\n                                 \"candidate #{} is defined in the trait `{}`\",\n@@ -397,7 +400,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                 if let Some(def) = actual.ty_adt_def() {\n                     if let Some(full_sp) = tcx.hir().span_if_local(def.did) {\n-                        let def_sp = tcx.sess.source_map().def_span(full_sp);\n+                        let def_sp = tcx.sess.source_map().guess_head_span(full_sp);\n                         err.span_label(\n                             def_sp,\n                             format!(\n@@ -537,8 +540,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                 let mut restrict_type_params = false;\n                 if !unsatisfied_predicates.is_empty() {\n-                    let def_span =\n-                        |def_id| self.tcx.sess.source_map().def_span(self.tcx.def_span(def_id));\n+                    let def_span = |def_id| {\n+                        self.tcx.sess.source_map().guess_head_span(self.tcx.def_span(def_id))\n+                    };\n                     let mut type_params = FxHashMap::default();\n                     let mut bound_spans = vec![];\n                     let mut collect_type_param_suggestions =\n@@ -1117,7 +1121,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if let [trait_info] = &candidates[..] {\n                     if let Some(span) = self.tcx.hir().span_if_local(trait_info.def_id) {\n                         err.span_note(\n-                            self.tcx.sess.source_map().def_span(span),\n+                            self.tcx.sess.source_map().guess_head_span(span),\n                             &format!(\n                                 \"`{}` defines an item `{}`, perhaps you need to {} it\",\n                                 self.tcx.def_path_str(trait_info.def_id),"}, {"sha": "e7ba00ac245076f8245b58c75dfdb6ba0e9e93ea", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -1479,7 +1479,7 @@ fn check_fn<'a, 'tcx>(\n                         }\n                     }\n                 } else {\n-                    let span = sess.source_map().def_span(span);\n+                    let span = sess.source_map().guess_head_span(span);\n                     sess.span_err(span, \"function should have one argument\");\n                 }\n             } else {\n@@ -1520,7 +1520,7 @@ fn check_fn<'a, 'tcx>(\n                         }\n                     }\n                 } else {\n-                    let span = sess.source_map().def_span(span);\n+                    let span = sess.source_map().guess_head_span(span);\n                     sess.span_err(span, \"function should have one argument\");\n                 }\n             } else {\n@@ -1962,7 +1962,7 @@ fn check_impl_items_against_trait<'tcx>(\n     impl_trait_ref: ty::TraitRef<'tcx>,\n     impl_item_refs: &[hir::ImplItemRef<'_>],\n ) {\n-    let impl_span = tcx.sess.source_map().def_span(full_impl_span);\n+    let impl_span = tcx.sess.source_map().guess_head_span(full_impl_span);\n \n     // If the trait reference itself is erroneous (so the compilation is going\n     // to fail), skip checking the items here -- the `impl_item` table in `tcx`\n@@ -2508,7 +2508,7 @@ fn check_transparent(tcx: TyCtxt<'_>, sp: Span, def_id: DefId) {\n     if !adt.repr.transparent() {\n         return;\n     }\n-    let sp = tcx.sess.source_map().def_span(sp);\n+    let sp = tcx.sess.source_map().guess_head_span(sp);\n \n     if adt.is_union() && !tcx.features().transparent_unions {\n         feature_err(\n@@ -3875,7 +3875,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 );\n             }\n \n-            if let Some(def_s) = def_span.map(|sp| tcx.sess.source_map().def_span(sp)) {\n+            if let Some(def_s) = def_span.map(|sp| tcx.sess.source_map().guess_head_span(sp)) {\n                 err.span_label(def_s, \"defined here\");\n             }\n             if sugg_unit {\n@@ -4966,7 +4966,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             (&found.kind, self.suggest_fn_call(err, expr, expected, found))\n         {\n             if let Some(sp) = self.tcx.hir().span_if_local(*def_id) {\n-                let sp = self.sess().source_map().def_span(sp);\n+                let sp = self.sess().source_map().guess_head_span(sp);\n                 err.span_label(sp, &format!(\"{} defined here\", found));\n             }\n         } else if !self.check_for_cast(err, expr, found, expected) {"}, {"sha": "0c4a05e61814df19888398b49fe6edc8dfb7dcfa", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -835,7 +835,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 on_error();\n                 return tcx.types.err;\n             }\n-            Res::Def(DefKind::AssocConst, _) | Res::Def(DefKind::AssocFn, _) => {\n+            Res::Def(DefKind::AssocConst | DefKind::AssocFn, _) => {\n                 report_unexpected_res(res);\n                 return tcx.types.err;\n             }\n@@ -1020,7 +1020,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ty::Adt(adt, substs) => (substs, adt),\n             _ => span_bug!(pat.span, \"struct pattern is not an ADT\"),\n         };\n-        let kind_name = adt.variant_descr();\n \n         // Index the struct fields' types.\n         let field_map = variant\n@@ -1074,7 +1073,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         if !inexistent_fields.is_empty() && !variant.recovered {\n             self.error_inexistent_fields(\n-                kind_name,\n+                adt.variant_descr(),\n                 &inexistent_fields,\n                 &mut unmentioned_fields,\n                 variant,\n@@ -1083,18 +1082,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Require `..` if struct has non_exhaustive attribute.\n         if variant.is_field_list_non_exhaustive() && !adt.did.is_local() && !etc {\n-            struct_span_err!(\n-                tcx.sess,\n-                pat.span,\n-                E0638,\n-                \"`..` required with {} marked as non-exhaustive\",\n-                kind_name\n-            )\n-            .emit();\n+            self.error_foreign_non_exhaustive_spat(pat, adt.variant_descr(), fields.is_empty());\n         }\n \n         // Report an error if incorrect number of the fields were specified.\n-        if kind_name == \"union\" {\n+        if adt.is_union() {\n             if fields.len() != 1 {\n                 tcx.sess\n                     .struct_span_err(pat.span, \"union patterns should have exactly one field\")\n@@ -1109,6 +1101,29 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         no_field_errors\n     }\n \n+    fn error_foreign_non_exhaustive_spat(&self, pat: &Pat<'_>, descr: &str, no_fields: bool) {\n+        let sess = self.tcx.sess;\n+        let sm = sess.source_map();\n+        let sp_brace = sm.end_point(pat.span);\n+        let sp_comma = sm.end_point(pat.span.with_hi(sp_brace.hi()));\n+        let sugg = if no_fields || sp_brace != sp_comma { \".. }\" } else { \", .. }\" };\n+\n+        let mut err = struct_span_err!(\n+            sess,\n+            pat.span,\n+            E0638,\n+            \"`..` required with {} marked as non-exhaustive\",\n+            descr\n+        );\n+        err.span_suggestion_verbose(\n+            sp_comma,\n+            \"add `..` at the end of the field list to ignore all other fields\",\n+            sugg.to_string(),\n+            Applicability::MachineApplicable,\n+        );\n+        err.emit();\n+    }\n+\n     fn error_field_already_bound(&self, span: Span, ident: ast::Ident, other_field: Span) {\n         struct_span_err!(\n             self.tcx.sess,"}, {"sha": "6ed4f62c4bea293f0d052ad3b45b1588852a06d9", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -20,7 +20,7 @@ mod unsafety;\n \n /// Obtains the span of just the impl header of `impl_def_id`.\n fn impl_header_span(tcx: TyCtxt<'_>, impl_def_id: DefId) -> Span {\n-    tcx.sess.source_map().def_span(tcx.span_of_impl(impl_def_id).unwrap())\n+    tcx.sess.source_map().guess_head_span(tcx.span_of_impl(impl_def_id).unwrap())\n }\n \n fn check_impl(tcx: TyCtxt<'_>, impl_def_id: DefId, trait_ref: ty::TraitRef<'_>) {"}, {"sha": "cc0ad364177a0153de6316f4e19d6abd4153818e", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -34,7 +34,7 @@ impl ItemLikeVisitor<'v> for OrphanChecker<'tcx> {\n             let trait_ref = self.tcx.impl_trait_ref(def_id).unwrap();\n             let trait_def_id = trait_ref.def_id;\n             let sm = self.tcx.sess.source_map();\n-            let sp = sm.def_span(item.span);\n+            let sp = sm.guess_head_span(item.span);\n             match traits::orphan_check(self.tcx, def_id) {\n                 Ok(()) => {}\n                 Err(traits::OrphanCheckErr::NonLocalInputType(tys)) => {"}, {"sha": "10972697f9fcdc7af0373f94d1493e80b785329e", "filename": "src/test/ui/did_you_mean/issue-40396.stderr", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40396.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40396.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40396.stderr?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -2,16 +2,8 @@ error: comparison operators cannot be chained\n   --> $DIR/issue-40396.rs:2:20\n    |\n LL |     (0..13).collect<Vec<i32>>();\n-   |                    ^^^^^\n+   |                    ^   ^\n    |\n-help: split the comparison into two...\n-   |\n-LL |     (0..13).collect < Vec && Vec <i32>>();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-help: ...or parenthesize one of the comparisons\n-   |\n-LL |     ((0..13).collect < Vec) <i32>>();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n help: use `::<...>` instead of `<...>` to specify type arguments\n    |\n LL |     (0..13).collect::<Vec<i32>>();\n@@ -21,7 +13,7 @@ error: comparison operators cannot be chained\n   --> $DIR/issue-40396.rs:4:8\n    |\n LL |     Vec<i32>::new();\n-   |        ^^^^^\n+   |        ^   ^\n    |\n help: use `::<...>` instead of `<...>` to specify type arguments\n    |\n@@ -32,16 +24,8 @@ error: comparison operators cannot be chained\n   --> $DIR/issue-40396.rs:6:20\n    |\n LL |     (0..13).collect<Vec<i32>();\n-   |                    ^^^^^\n-   |\n-help: split the comparison into two...\n-   |\n-LL |     (0..13).collect < Vec && Vec <i32>();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-help: ...or parenthesize one of the comparisons\n+   |                    ^   ^\n    |\n-LL |     ((0..13).collect < Vec) <i32>();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n help: use `::<...>` instead of `<...>` to specify type arguments\n    |\n LL |     (0..13).collect::<Vec<i32>();"}, {"sha": "bbd46082c9f901bcc6c22f8de14f1759029bb188", "filename": "src/test/ui/parser/chained-comparison-suggestion.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Ftest%2Fui%2Fparser%2Fchained-comparison-suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Ftest%2Fui%2Fparser%2Fchained-comparison-suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fchained-comparison-suggestion.rs?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -37,4 +37,17 @@ fn comp8() {\n     //~^ ERROR mismatched types\n }\n \n+fn comp9() {\n+    1 == 2 < 3; //~ ERROR comparison operators cannot be chained\n+}\n+\n+fn comp10() {\n+    1 > 2 == false; //~ ERROR comparison operators cannot be chained\n+}\n+\n+fn comp11() {\n+    1 == 2 == 3; //~ ERROR comparison operators cannot be chained\n+    //~^ ERROR mismatched types\n+}\n+\n fn main() {}"}, {"sha": "067920d12f486c6595229d8eef6c896ba9a055b6", "filename": "src/test/ui/parser/chained-comparison-suggestion.stderr", "status": "modified", "additions": 63, "deletions": 62, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Ftest%2Fui%2Fparser%2Fchained-comparison-suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Ftest%2Fui%2Fparser%2Fchained-comparison-suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fchained-comparison-suggestion.stderr?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -2,127 +2,122 @@ error: comparison operators cannot be chained\n   --> $DIR/chained-comparison-suggestion.rs:4:7\n    |\n LL |     1 < 2 <= 3;\n-   |       ^^^^^^\n+   |       ^   ^^\n    |\n-help: split the comparison into two...\n+help: split the comparison into two\n    |\n LL |     1 < 2 && 2 <= 3;\n-   |     ^^^^^^^^^^^^^\n-help: ...or parenthesize one of the comparisons\n-   |\n-LL |     (1 < 2) <= 3;\n-   |     ^^^^^^^^^^\n+   |           ^^^^\n \n error: comparison operators cannot be chained\n   --> $DIR/chained-comparison-suggestion.rs:9:7\n    |\n LL |     1 < 2 < 3;\n-   |       ^^^^^\n+   |       ^   ^\n    |\n-   = help: use `::<...>` instead of `<...>` to specify type arguments\n-   = help: or use `(...)` if you meant to specify fn arguments\n-help: split the comparison into two...\n+help: split the comparison into two\n    |\n LL |     1 < 2 && 2 < 3;\n-   |     ^^^^^^^^^^^^\n-help: ...or parenthesize one of the comparisons\n-   |\n-LL |     (1 < 2) < 3;\n-   |     ^^^^^^^^^\n+   |           ^^^^\n \n error: comparison operators cannot be chained\n   --> $DIR/chained-comparison-suggestion.rs:13:7\n    |\n LL |     1 <= 2 < 3;\n-   |       ^^^^^^\n+   |       ^^   ^\n    |\n-help: split the comparison into two...\n+help: split the comparison into two\n    |\n LL |     1 <= 2 && 2 < 3;\n-   |     ^^^^^^^^^^^^^\n-help: ...or parenthesize one of the comparisons\n-   |\n-LL |     (1 <= 2) < 3;\n-   |     ^^^^^^^^^^\n+   |            ^^^^\n \n error: comparison operators cannot be chained\n   --> $DIR/chained-comparison-suggestion.rs:18:7\n    |\n LL |     1 <= 2 <= 3;\n-   |       ^^^^^^^\n+   |       ^^   ^^\n    |\n-help: split the comparison into two...\n+help: split the comparison into two\n    |\n LL |     1 <= 2 && 2 <= 3;\n-   |     ^^^^^^^^^^^^^^\n-help: ...or parenthesize one of the comparisons\n-   |\n-LL |     (1 <= 2) <= 3;\n-   |     ^^^^^^^^^^^\n+   |            ^^^^\n \n error: comparison operators cannot be chained\n   --> $DIR/chained-comparison-suggestion.rs:23:7\n    |\n LL |     1 > 2 >= 3;\n-   |       ^^^^^^\n+   |       ^   ^^\n    |\n-help: split the comparison into two...\n+help: split the comparison into two\n    |\n LL |     1 > 2 && 2 >= 3;\n-   |     ^^^^^^^^^^^^^\n-help: ...or parenthesize one of the comparisons\n-   |\n-LL |     (1 > 2) >= 3;\n-   |     ^^^^^^^^^^\n+   |           ^^^^\n \n error: comparison operators cannot be chained\n   --> $DIR/chained-comparison-suggestion.rs:28:7\n    |\n LL |     1 > 2 > 3;\n-   |       ^^^^^\n+   |       ^   ^\n    |\n-   = help: use `::<...>` instead of `<...>` to specify type arguments\n-   = help: or use `(...)` if you meant to specify fn arguments\n-help: split the comparison into two...\n+help: split the comparison into two\n    |\n LL |     1 > 2 && 2 > 3;\n-   |     ^^^^^^^^^^^^\n-help: ...or parenthesize one of the comparisons\n-   |\n-LL |     (1 > 2) > 3;\n-   |     ^^^^^^^^^\n+   |           ^^^^\n \n error: comparison operators cannot be chained\n   --> $DIR/chained-comparison-suggestion.rs:32:7\n    |\n LL |     1 >= 2 > 3;\n-   |       ^^^^^^\n+   |       ^^   ^\n    |\n-   = help: use `::<...>` instead of `<...>` to specify type arguments\n-   = help: or use `(...)` if you meant to specify fn arguments\n-help: split the comparison into two...\n+help: split the comparison into two\n    |\n LL |     1 >= 2 && 2 > 3;\n-   |     ^^^^^^^^^^^^^\n-help: ...or parenthesize one of the comparisons\n-   |\n-LL |     (1 >= 2) > 3;\n-   |     ^^^^^^^^^^\n+   |            ^^^^\n \n error: comparison operators cannot be chained\n   --> $DIR/chained-comparison-suggestion.rs:36:7\n    |\n LL |     1 >= 2 >= 3;\n-   |       ^^^^^^^\n+   |       ^^   ^^\n    |\n-help: split the comparison into two...\n+help: split the comparison into two\n    |\n LL |     1 >= 2 && 2 >= 3;\n-   |     ^^^^^^^^^^^^^^\n-help: ...or parenthesize one of the comparisons\n+   |            ^^^^\n+\n+error: comparison operators cannot be chained\n+  --> $DIR/chained-comparison-suggestion.rs:41:7\n+   |\n+LL |     1 == 2 < 3;\n+   |       ^^   ^\n    |\n-LL |     (1 >= 2) >= 3;\n-   |     ^^^^^^^^^^^\n+help: parenthesize the comparison\n+   |\n+LL |     1 == (2 < 3);\n+   |          ^     ^\n+\n+error: comparison operators cannot be chained\n+  --> $DIR/chained-comparison-suggestion.rs:45:7\n+   |\n+LL |     1 > 2 == false;\n+   |       ^   ^^\n+   |\n+help: parenthesize the comparison\n+   |\n+LL |     (1 > 2) == false;\n+   |     ^     ^\n+\n+error: comparison operators cannot be chained\n+  --> $DIR/chained-comparison-suggestion.rs:49:7\n+   |\n+LL |     1 == 2 == 3;\n+   |       ^^   ^^\n+   |\n+help: split the comparison into two\n+   |\n+LL |     1 == 2 && 2 == 3;\n+   |            ^^^^\n \n error[E0308]: mismatched types\n   --> $DIR/chained-comparison-suggestion.rs:4:14\n@@ -154,6 +149,12 @@ error[E0308]: mismatched types\n LL |     1 >= 2 >= 3;\n    |               ^ expected `bool`, found integer\n \n-error: aborting due to 13 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/chained-comparison-suggestion.rs:49:15\n+   |\n+LL |     1 == 2 == 3;\n+   |               ^ expected `bool`, found integer\n+\n+error: aborting due to 17 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}, {"sha": "4e97904ed6d5f9f178aa6954b3673368724c1239", "filename": "src/test/ui/parser/require-parens-for-chained-comparison.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.rs?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -4,20 +4,18 @@ struct X;\n fn main() {\n     false == false == false;\n     //~^ ERROR comparison operators cannot be chained\n+    //~| HELP split the comparison into two\n \n     false == 0 < 2;\n     //~^ ERROR comparison operators cannot be chained\n-    //~| ERROR mismatched types\n-    //~| ERROR mismatched types\n+    //~| HELP parenthesize the comparison\n \n     f<X>();\n     //~^ ERROR comparison operators cannot be chained\n     //~| HELP use `::<...>` instead of `<...>` to specify type arguments\n \n     f<Result<Option<X>, Option<Option<X>>>(1, 2);\n     //~^ ERROR comparison operators cannot be chained\n-    //~| HELP split the comparison into two...\n-    //~| ...or parenthesize one of the comparisons\n     //~| HELP use `::<...>` instead of `<...>` to specify type arguments\n \n     use std::convert::identity;"}, {"sha": "7001aa8e8a1d8c279707db8c396f5637ddb2fb71", "filename": "src/test/ui/parser/require-parens-for-chained-comparison.stderr", "status": "modified", "additions": 18, "deletions": 29, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.stderr?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -2,19 +2,29 @@ error: comparison operators cannot be chained\n   --> $DIR/require-parens-for-chained-comparison.rs:5:11\n    |\n LL |     false == false == false;\n-   |           ^^^^^^^^^^^\n+   |           ^^       ^^\n+   |\n+help: split the comparison into two\n+   |\n+LL |     false == false && false == false;\n+   |                    ^^^^^^^^\n \n error: comparison operators cannot be chained\n-  --> $DIR/require-parens-for-chained-comparison.rs:8:11\n+  --> $DIR/require-parens-for-chained-comparison.rs:9:11\n    |\n LL |     false == 0 < 2;\n-   |           ^^^^^^\n+   |           ^^   ^\n+   |\n+help: parenthesize the comparison\n+   |\n+LL |     false == (0 < 2);\n+   |              ^     ^\n \n error: comparison operators cannot be chained\n   --> $DIR/require-parens-for-chained-comparison.rs:13:6\n    |\n LL |     f<X>();\n-   |      ^^^\n+   |      ^ ^\n    |\n help: use `::<...>` instead of `<...>` to specify type arguments\n    |\n@@ -25,42 +35,21 @@ error: comparison operators cannot be chained\n   --> $DIR/require-parens-for-chained-comparison.rs:17:6\n    |\n LL |     f<Result<Option<X>, Option<Option<X>>>(1, 2);\n-   |      ^^^^^^^^\n-   |\n-help: split the comparison into two...\n-   |\n-LL |     f < Result && Result <Option<X>, Option<Option<X>>>(1, 2);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^\n-help: ...or parenthesize one of the comparisons\n+   |      ^      ^\n    |\n-LL |     (f < Result) <Option<X>, Option<Option<X>>>(1, 2);\n-   |     ^^^^^^^^^^^^^^\n help: use `::<...>` instead of `<...>` to specify type arguments\n    |\n LL |     f::<Result<Option<X>, Option<Option<X>>>(1, 2);\n    |      ^^\n \n error: comparison operators cannot be chained\n-  --> $DIR/require-parens-for-chained-comparison.rs:24:21\n+  --> $DIR/require-parens-for-chained-comparison.rs:22:21\n    |\n LL |     let _ = identity<u8>;\n-   |                     ^^^^\n+   |                     ^  ^\n    |\n    = help: use `::<...>` instead of `<...>` to specify type arguments\n    = help: or use `(...)` if you meant to specify fn arguments\n \n-error[E0308]: mismatched types\n-  --> $DIR/require-parens-for-chained-comparison.rs:8:14\n-   |\n-LL |     false == 0 < 2;\n-   |              ^ expected `bool`, found integer\n-\n-error[E0308]: mismatched types\n-  --> $DIR/require-parens-for-chained-comparison.rs:8:18\n-   |\n-LL |     false == 0 < 2;\n-   |                  ^ expected `bool`, found integer\n-\n-error: aborting due to 7 previous errors\n+error: aborting due to 5 previous errors\n \n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "f1680e9e8884e93806f361bfd3a9b593111f7c90", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-at-and-box.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box.rs?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -45,27 +45,27 @@ fn main() {\n     *b = NC;\n     let ref a @ box ref mut b = Box::new(NC);\n     //~^ ERROR cannot borrow value as mutable because it is also borrowed as immutable\n-    //~| ERROR cannot borrow `_` as mutable because it is also borrowed as immutable\n+    //~| ERROR cannot borrow value as mutable because it is also borrowed as immutable\n     *b = NC;\n     drop(a);\n \n     let ref mut a @ box ref b = Box::new(NC);\n     //~^ ERROR cannot borrow value as immutable because it is also borrowed as mutable\n-    //~| ERROR cannot borrow `_` as immutable because it is also borrowed as mutable\n+    //~| ERROR cannot borrow value as immutable because it is also borrowed as mutable\n     *a = Box::new(NC);\n     drop(b);\n \n     fn f5(ref mut a @ box ref b: Box<NC>) {\n         //~^ ERROR cannot borrow value as immutable because it is also borrowed as mutable\n-        //~| ERROR cannot borrow `_` as immutable because it is also borrowed as mutable\n+        //~| ERROR cannot borrow value as immutable because it is also borrowed as mutable\n         *a = Box::new(NC);\n         drop(b);\n     }\n \n     match Box::new(nc()) {\n         ref mut a @ box ref b => {\n             //~^ ERROR cannot borrow value as immutable because it is also borrowed as mutable\n-            //~| ERROR cannot borrow `_` as immutable because it is also borrowed as mutable\n+            //~| ERROR cannot borrow value as immutable because it is also borrowed as mutable\n             *a = Box::new(NC);\n             drop(b);\n         }"}, {"sha": "5ce546f08bf6f41e21ea5cb70a74c88205280f88", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-at-and-box.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box.stderr?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -99,7 +99,7 @@ LL |         a @ box b => {}\n    |         |       value used here after move\n    |         value moved here\n \n-error[E0502]: cannot borrow `_` as mutable because it is also borrowed as immutable\n+error[E0502]: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-at-and-box.rs:46:21\n    |\n LL |     let ref a @ box ref mut b = Box::new(NC);\n@@ -111,7 +111,7 @@ LL |     let ref a @ box ref mut b = Box::new(NC);\n LL |     drop(a);\n    |          - immutable borrow later used here\n \n-error[E0502]: cannot borrow `_` as immutable because it is also borrowed as mutable\n+error[E0502]: cannot borrow value as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-pat-at-and-box.rs:52:25\n    |\n LL |     let ref mut a @ box ref b = Box::new(NC);\n@@ -123,7 +123,7 @@ LL |     let ref mut a @ box ref b = Box::new(NC);\n LL |     *a = Box::new(NC);\n    |     -- mutable borrow later used here\n \n-error[E0502]: cannot borrow `_` as immutable because it is also borrowed as mutable\n+error[E0502]: cannot borrow value as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-pat-at-and-box.rs:66:25\n    |\n LL |         ref mut a @ box ref b => {\n@@ -155,7 +155,7 @@ LL |     fn f2(a @ box b: Box<C>) {}\n    |           value moved here\n    |           move occurs because value has type `std::boxed::Box<C>`, which does not implement the `Copy` trait\n \n-error[E0502]: cannot borrow `_` as immutable because it is also borrowed as mutable\n+error[E0502]: cannot borrow value as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-pat-at-and-box.rs:58:27\n    |\n LL |     fn f5(ref mut a @ box ref b: Box<NC>) {"}, {"sha": "2b5e339c6396e36074e3d4f361baa17b63ada02f", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-ref-mut-and-ref.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-and-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-and-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-and-ref.rs?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -10,7 +10,7 @@ fn main() {\n     match &mut Some(1) {\n         ref mut z @ &mut Some(ref a) => {\n         //~^ ERROR cannot borrow value as immutable because it is also borrowed as mutable\n-        //~| ERROR cannot borrow `_` as immutable because it is also borrowed as mutable\n+        //~| ERROR cannot borrow value as immutable because it is also borrowed as mutable\n             **z = None;\n             println!(\"{}\", *a);\n         }\n@@ -47,12 +47,12 @@ fn main() {\n \n     let ref mut a @ ref b = u();\n     //~^ ERROR cannot borrow value as immutable because it is also borrowed as mutable\n-    //~| ERROR cannot borrow `_` as immutable because it is also borrowed as mutable\n+    //~| ERROR cannot borrow value as immutable because it is also borrowed as mutable\n     *a = u();\n     drop(b);\n     let ref a @ ref mut b = u();\n     //~^ ERROR cannot borrow value as mutable because it is also borrowed as immutable\n-    //~| ERROR cannot borrow `_` as mutable because it is also borrowed as immutable\n+    //~| ERROR cannot borrow value as mutable because it is also borrowed as immutable\n     *b = u();\n     drop(a);\n \n@@ -78,8 +78,8 @@ fn main() {\n         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) => {\n             //~^ ERROR cannot borrow value as mutable because it is also borrowed as immutable\n             //~| ERROR cannot borrow value as mutable because it is also borrowed as immutable\n-            //~| ERROR cannot borrow `_` as mutable because it is also borrowed as immutable\n-            //~| ERROR cannot borrow `_` as mutable because it is also borrowed as immutable\n+            //~| ERROR cannot borrow value as mutable because it is also borrowed as immutable\n+            //~| ERROR cannot borrow value as mutable because it is also borrowed as immutable\n             *b = U;\n             drop(a);\n         }\n@@ -123,15 +123,15 @@ fn main() {\n \n     let ref a @ (ref mut b, ref mut c) = (U, U);\n     //~^ ERROR cannot borrow value as mutable because it is also borrowed as immutable\n-    //~| ERROR cannot borrow `_` as mutable because it is also borrowed as immutable\n-    //~| ERROR cannot borrow `_` as mutable because it is also borrowed as immutable\n+    //~| ERROR cannot borrow value as mutable because it is also borrowed as immutable\n+    //~| ERROR cannot borrow value as mutable because it is also borrowed as immutable\n     *b = U;\n     drop(a);\n \n     let ref a @ (ref mut b, ref mut c) = (U, U);\n     //~^ ERROR cannot borrow value as mutable because it is also borrowed as immutable\n-    *b = U; //~| ERROR cannot borrow `_` as mutable because it is also borrowed as immutable\n-    *c = U; //~| ERROR cannot borrow `_` as mutable because it is also borrowed as immutable\n+    *b = U; //~| ERROR cannot borrow value as mutable because it is also borrowed as immutable\n+    *c = U; //~| ERROR cannot borrow value as mutable because it is also borrowed as immutable\n     drop(a);\n     let ref mut a @ (ref b, ref c) = (U, U);\n     //~^ ERROR cannot borrow value as immutable because it is also borrowed as mutable"}, {"sha": "b161054414a303ca660036dc32dc12b1a50f92eb", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-ref-mut-and-ref.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-and-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-and-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-and-ref.stderr?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -294,7 +294,7 @@ LL |     fn f4_also_moved(ref a @ ref mut b @ c: U) {}\n    |                              |           value moved into `c` here\n    |                              value borrowed, by `b`, here\n \n-error[E0502]: cannot borrow `_` as immutable because it is also borrowed as mutable\n+error[E0502]: cannot borrow value as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:11:31\n    |\n LL |         ref mut z @ &mut Some(ref a) => {\n@@ -306,7 +306,7 @@ LL |         ref mut z @ &mut Some(ref a) => {\n LL |             **z = None;\n    |             ---------- mutable borrow later used here\n \n-error[E0502]: cannot borrow `_` as immutable because it is also borrowed as mutable\n+error[E0502]: cannot borrow value as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:48:21\n    |\n LL |     let ref mut a @ ref b = u();\n@@ -318,7 +318,7 @@ LL |     let ref mut a @ ref b = u();\n LL |     *a = u();\n    |     -------- mutable borrow later used here\n \n-error[E0502]: cannot borrow `_` as mutable because it is also borrowed as immutable\n+error[E0502]: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:53:17\n    |\n LL |     let ref a @ ref mut b = u();\n@@ -330,7 +330,7 @@ LL |     let ref a @ ref mut b = u();\n LL |     drop(a);\n    |          - immutable borrow later used here\n \n-error[E0502]: cannot borrow `_` as mutable because it is also borrowed as immutable\n+error[E0502]: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:78:20\n    |\n LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) => {\n@@ -342,7 +342,7 @@ LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) => {\n LL |             drop(a);\n    |                  - immutable borrow later used here\n \n-error[E0502]: cannot borrow `_` as mutable because it is also borrowed as immutable\n+error[E0502]: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:78:45\n    |\n LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) => {\n@@ -402,7 +402,7 @@ LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) if { drop(a); false\n    |\n    = note: variables bound in patterns cannot be moved from until after the end of the pattern guard\n \n-error[E0502]: cannot borrow `_` as mutable because it is also borrowed as immutable\n+error[E0502]: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:124:18\n    |\n LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n@@ -414,7 +414,7 @@ LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n LL |     drop(a);\n    |          - immutable borrow later used here\n \n-error[E0502]: cannot borrow `_` as mutable because it is also borrowed as immutable\n+error[E0502]: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:124:29\n    |\n LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n@@ -426,7 +426,7 @@ LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n LL |     drop(a);\n    |          - immutable borrow later used here\n \n-error[E0502]: cannot borrow `_` as mutable because it is also borrowed as immutable\n+error[E0502]: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:131:18\n    |\n LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n@@ -438,7 +438,7 @@ LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n LL |     drop(a);\n    |          - immutable borrow later used here\n \n-error[E0502]: cannot borrow `_` as mutable because it is also borrowed as immutable\n+error[E0502]: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:131:29\n    |\n LL |     let ref a @ (ref mut b, ref mut c) = (U, U);"}, {"sha": "a208d0087ff53d7ff9e458f7223083990dca4307", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-ref-mut-twice.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-twice.rs?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -27,7 +27,7 @@ fn main() {\n \n     let ref mut a @ ref mut b = U;\n     //~^ ERROR cannot borrow value as mutable more than once at a time\n-    //~| ERROR cannot borrow `_` as mutable more than once at a time\n+    //~| ERROR cannot borrow value as mutable more than once at a time\n     drop(a);\n     let ref mut a @ ref mut b = U;\n     //~^ ERROR cannot borrow value as mutable more than once at a time\n@@ -37,7 +37,7 @@ fn main() {\n \n     let ref mut a @ ref mut b = U;\n     //~^ ERROR cannot borrow value as mutable more than once at a time\n-    //~| ERROR cannot borrow `_` as mutable more than once at a time\n+    //~| ERROR cannot borrow value as mutable more than once at a time\n     *a = U;\n     let ref mut a @ ref mut b = U;\n     //~^ ERROR cannot borrow value as mutable more than once at a time\n@@ -95,20 +95,20 @@ fn main() {\n         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n             //~^ ERROR cannot borrow value as mutable more than once at a time\n             //~| ERROR cannot borrow value as mutable more than once at a time\n-            //~| ERROR cannot borrow `_` as mutable more than once at a time\n-            //~| ERROR cannot borrow `_` as mutable more than once at a time\n+            //~| ERROR cannot borrow value as mutable more than once at a time\n+            //~| ERROR cannot borrow value as mutable more than once at a time\n             *a = Err(U);\n \n-            // FIXME: The binding name `_` used above makes for problematic diagnostics.\n+            // FIXME: The binding name value used above makes for problematic diagnostics.\n             // Resolve that somehow...\n         }\n     }\n     match Ok(U) {\n         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n             //~^ ERROR cannot borrow value as mutable more than once at a time\n             //~| ERROR cannot borrow value as mutable more than once at a time\n-            //~| ERROR cannot borrow `_` as mutable more than once at a time\n-            //~| ERROR cannot borrow `_` as mutable more than once at a time\n+            //~| ERROR cannot borrow value as mutable more than once at a time\n+            //~| ERROR cannot borrow value as mutable more than once at a time\n             drop(a);\n         }\n     }"}, {"sha": "ae7c8f38e1eb4b78fc35ad3fac3aa345e223fe07", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-ref-mut-twice.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-twice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-twice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-twice.stderr?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -258,7 +258,7 @@ LL |     fn f4_also_moved(ref mut a @ ref mut b @ c: U) {}\n    |                                  |           value moved into `c` here\n    |                                  value borrowed, by `b`, here\n \n-error[E0499]: cannot borrow `_` as mutable more than once at a time\n+error[E0499]: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:28:21\n    |\n LL |     let ref mut a @ ref mut b = U;\n@@ -270,7 +270,7 @@ LL |     let ref mut a @ ref mut b = U;\n LL |     drop(a);\n    |          - first borrow later used here\n \n-error[E0499]: cannot borrow `_` as mutable more than once at a time\n+error[E0499]: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:38:21\n    |\n LL |     let ref mut a @ ref mut b = U;\n@@ -318,7 +318,7 @@ LL |     let a @ &mut (ref mut b, ref mut c) = &mut (U, U);\n    |         |                    value borrowed here after move\n    |         value moved here\n \n-error[E0499]: cannot borrow `_` as mutable more than once at a time\n+error[E0499]: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:95:24\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n@@ -330,7 +330,7 @@ LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n LL |             *a = Err(U);\n    |             ----------- first borrow later used here\n \n-error[E0499]: cannot borrow `_` as mutable more than once at a time\n+error[E0499]: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:95:53\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n@@ -342,7 +342,7 @@ LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n LL |             *a = Err(U);\n    |             ----------- first borrow later used here\n \n-error[E0499]: cannot borrow `_` as mutable more than once at a time\n+error[E0499]: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:107:24\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n@@ -354,7 +354,7 @@ LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n LL |             drop(a);\n    |                  - first borrow later used here\n \n-error[E0499]: cannot borrow `_` as mutable more than once at a time\n+error[E0499]: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:107:53\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {"}, {"sha": "a45497229ac9e49a7b2213e2d87babc60e38b381", "filename": "src/test/ui/pattern/bindings-after-at/default-binding-modes-both-sides-independent.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fdefault-binding-modes-both-sides-independent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fdefault-binding-modes-both-sides-independent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fdefault-binding-modes-both-sides-independent.rs?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -29,7 +29,7 @@ fn main() {\n     let _a: &NotCopy = a;\n     let _b: NotCopy = b;\n     let ref mut a @ b = NotCopy; //~ ERROR cannot move out of value because it is borrowed\n-    //~^ ERROR cannot move out of `_` because it is borrowed\n+    //~^ ERROR cannot move out of value because it is borrowed\n     let _a: &NotCopy = a;\n     let _b: NotCopy = b;\n     match Ok(NotCopy) {"}, {"sha": "141d667c7460cb7bf31ec26038c36d97217ec779", "filename": "src/test/ui/pattern/bindings-after-at/default-binding-modes-both-sides-independent.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fdefault-binding-modes-both-sides-independent.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fdefault-binding-modes-both-sides-independent.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fdefault-binding-modes-both-sides-independent.stderr?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -44,7 +44,7 @@ LL |         ref a @ b => {\n    |         |       value moved into `b` here\n    |         value borrowed, by `a`, here\n \n-error[E0505]: cannot move out of `_` because it is borrowed\n+error[E0505]: cannot move out of value because it is borrowed\n   --> $DIR/default-binding-modes-both-sides-independent.rs:31:21\n    |\n LL |     let ref mut a @ b = NotCopy;"}, {"sha": "3bc38830537cf2cab5850de81588d1b022192175", "filename": "src/test/ui/rfc-2008-non-exhaustive/struct.stderr", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstruct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstruct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstruct.stderr?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -62,18 +62,33 @@ error[E0638]: `..` required with struct marked as non-exhaustive\n    |\n LL |     let NormalStruct { first_field, second_field } = ns;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: add `..` at the end of the field list to ignore all other fields\n+   |\n+LL |     let NormalStruct { first_field, second_field , .. } = ns;\n+   |                                                  ^^^^^^\n \n error[E0638]: `..` required with struct marked as non-exhaustive\n   --> $DIR/struct.rs:26:9\n    |\n LL |     let TupleStruct { 0: first_field, 1: second_field } = ts;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: add `..` at the end of the field list to ignore all other fields\n+   |\n+LL |     let TupleStruct { 0: first_field, 1: second_field , .. } = ts;\n+   |                                                       ^^^^^^\n \n error[E0638]: `..` required with struct marked as non-exhaustive\n   --> $DIR/struct.rs:35:9\n    |\n LL |     let UnitStruct { } = us;\n    |         ^^^^^^^^^^^^^^\n+   |\n+help: add `..` at the end of the field list to ignore all other fields\n+   |\n+LL |     let UnitStruct { .. } = us;\n+   |                      ^^^^\n \n error: aborting due to 9 previous errors\n "}, {"sha": "fbdbb0c9930a6a6d1ed89f91b3883289c62afa85", "filename": "src/test/ui/rfc-2008-non-exhaustive/variant.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fvariant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a17dd3608477a47741f97b907a61b6d81524ba4e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fvariant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fvariant.stderr?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -69,12 +69,22 @@ error[E0638]: `..` required with variant marked as non-exhaustive\n    |\n LL |         NonExhaustiveVariants::Struct { field } => \"\"\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: add `..` at the end of the field list to ignore all other fields\n+   |\n+LL |         NonExhaustiveVariants::Struct { field , .. } => \"\"\n+   |                                               ^^^^^^\n \n error[E0638]: `..` required with variant marked as non-exhaustive\n   --> $DIR/variant.rs:30:12\n    |\n LL |     if let NonExhaustiveVariants::Struct { field } = variant_struct {\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: add `..` at the end of the field list to ignore all other fields\n+   |\n+LL |     if let NonExhaustiveVariants::Struct { field , .. } = variant_struct {\n+   |                                                  ^^^^^^\n \n error: aborting due to 8 previous errors\n "}, {"sha": "8a0d4d9c9abc74fd670353094387d62028b40ae9", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=a17dd3608477a47741f97b907a61b6d81524ba4e", "patch": "@@ -1 +1 @@\n-Subproject commit 7019b3ed3d539db7429d10a343b69be8c426b576\n+Subproject commit 8a0d4d9c9abc74fd670353094387d62028b40ae9"}]}