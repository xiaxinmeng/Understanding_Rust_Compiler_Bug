{"sha": "1e54fcc1adeb3932ea7844ec1f86389a680ab86d", "node_id": "C_kwDOAAsO6NoAKDFlNTRmY2MxYWRlYjM5MzJlYTc4NDRlYzFmODYzODlhNjgwYWI4NmQ", "commit": {"author": {"name": "Jack Huey", "email": "31162821+jackh726@users.noreply.github.com", "date": "2022-09-08T22:36:55Z"}, "committer": {"name": "Jack Huey", "email": "31162821+jackh726@users.noreply.github.com", "date": "2022-09-09T00:55:56Z"}, "message": "Combine logic from lubs into lub_empty function", "tree": {"sha": "f082e8bad8fc37213ec272d10fb3ec31c64f0e26", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f082e8bad8fc37213ec272d10fb3ec31c64f0e26"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e54fcc1adeb3932ea7844ec1f86389a680ab86d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e54fcc1adeb3932ea7844ec1f86389a680ab86d", "html_url": "https://github.com/rust-lang/rust/commit/1e54fcc1adeb3932ea7844ec1f86389a680ab86d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e54fcc1adeb3932ea7844ec1f86389a680ab86d/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6d2995fb8b0ec9e4a7ce4f0ec21e7ecc3fb5c49", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6d2995fb8b0ec9e4a7ce4f0ec21e7ecc3fb5c49", "html_url": "https://github.com/rust-lang/rust/commit/f6d2995fb8b0ec9e4a7ce4f0ec21e7ecc3fb5c49"}], "stats": {"total": 111, "additions": 46, "deletions": 65}, "files": [{"sha": "5f13b2b3deb1b6e0c7fce6f27bd78280a495238b", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 46, "deletions": 65, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/1e54fcc1adeb3932ea7844ec1f86389a680ab86d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e54fcc1adeb3932ea7844ec1f86389a680ab86d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=1e54fcc1adeb3932ea7844ec1f86389a680ab86d", "patch": "@@ -15,6 +15,7 @@ use rustc_data_structures::graph::implementation::{\n use rustc_data_structures::intern::Interned;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::ty::fold::TypeFoldable;\n+use rustc_middle::ty::PlaceholderRegion;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::ty::{ReEarlyBound, ReErased, ReFree, ReStatic};\n use rustc_middle::ty::{ReLateBound, RePlaceholder, ReVar};\n@@ -195,6 +196,36 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         }\n     }\n \n+    /// Gets the LUb of a given region and the empty region\n+    fn lub_empty(&self, a_region: Region<'tcx>) -> Result<Region<'tcx>, PlaceholderRegion> {\n+        match *a_region {\n+            ReLateBound(..) | ReErased => {\n+                bug!(\"cannot relate region: {:?}\", a_region);\n+            }\n+\n+            ReVar(v_id) => {\n+                span_bug!(\n+                    self.var_infos[v_id].origin.span(),\n+                    \"lub invoked with non-concrete regions: {:?}\",\n+                    a_region,\n+                );\n+            }\n+\n+            ReStatic => {\n+                // nothing lives longer than `'static`\n+                Ok(self.tcx().lifetimes.re_static)\n+            }\n+\n+            ReEarlyBound(_) | ReFree(_) => {\n+                // All empty regions are less than early-bound, free,\n+                // and scope regions.\n+                Ok(a_region)\n+            }\n+\n+            RePlaceholder(placeholder) => Err(placeholder),\n+        }\n+    }\n+\n     fn expansion(&self, var_values: &mut LexicalRegionResolutions<'tcx>) {\n         // In the first pass, we expand region vids according to constraints we\n         // have previously found. In the second pass, we loop through the region\n@@ -237,40 +268,15 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                                 true\n                             }\n                             VarValue::Value(cur_region) => {\n-                                let lub = match *cur_region {\n-                                    ReLateBound(..) | ReErased => {\n-                                        bug!(\"cannot relate region: {:?}\", cur_region);\n-                                    }\n-\n-                                    ReVar(v_id) => {\n-                                        span_bug!(\n-                                            self.var_infos[v_id].origin.span(),\n-                                            \"lub_concrete_regions invoked with non-concrete regions: {:?}\",\n-                                            cur_region,\n-                                        );\n-                                    }\n-\n-                                    ReStatic => {\n-                                        // nothing lives longer than `'static`\n-                                        self.tcx().lifetimes.re_static\n-                                    }\n-\n-                                    ReEarlyBound(_) | ReFree(_) => {\n-                                        // All empty regions are less than early-bound, free,\n-                                        // and scope regions.\n+                                let lub = match self.lub_empty(cur_region) {\n+                                    Ok(r) => r,\n+                                    // If the empty and placeholder regions are in the same universe,\n+                                    // then the LUB is the Placeholder region (which is the cur_region).\n+                                    // If they are not in the same universe, the LUB is the Static lifetime.\n+                                    Err(placeholder) if a_universe == placeholder.universe => {\n                                         cur_region\n                                     }\n-\n-                                    RePlaceholder(placeholder) => {\n-                                        // If the empty and placeholder regions are in the same universe,\n-                                        // then the LUB is the Placeholder region (which is the cur_region).\n-                                        // If they are not in the same universe, the LUB is the Static lifetime.\n-                                        if a_universe == placeholder.universe {\n-                                            cur_region\n-                                        } else {\n-                                            self.tcx().lifetimes.re_static\n-                                        }\n-                                    }\n+                                    Err(_) => self.tcx().lifetimes.re_static,\n                                 };\n \n                                 if lub == cur_region {\n@@ -368,40 +374,15 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n \n         match *b_data {\n             VarValue::Empty(empty_ui) => {\n-                let lub = match *a_region {\n-                    ReLateBound(..) | ReErased => {\n-                        bug!(\"cannot relate region: {:?}\", a_region);\n-                    }\n-\n-                    ReVar(v_id) => {\n-                        span_bug!(\n-                            self.var_infos[v_id].origin.span(),\n-                            \"expand_node invoked with non-concrete regions: {:?}\",\n-                            a_region,\n-                        );\n-                    }\n-\n-                    ReStatic => {\n-                        // nothing lives longer than `'static`\n-                        self.tcx().lifetimes.re_static\n-                    }\n-\n-                    ReEarlyBound(_) | ReFree(_) => {\n-                        // All empty regions are less than early-bound, free,\n-                        // and scope regions.\n-                        a_region\n-                    }\n-\n-                    RePlaceholder(placeholder) => {\n-                        // If this empty region is from a universe that can\n-                        // name the placeholder, then the placeholder is\n-                        // larger; otherwise, the only ancestor is `'static`.\n-                        if empty_ui.can_name(placeholder.universe) {\n-                            self.tcx().mk_region(RePlaceholder(placeholder))\n-                        } else {\n-                            self.tcx().lifetimes.re_static\n-                        }\n+                let lub = match self.lub_empty(a_region) {\n+                    Ok(r) => r,\n+                    // If this empty region is from a universe that can\n+                    // name the placeholder, then the placeholder is\n+                    // larger; otherwise, the only ancestor is `'static`.\n+                    Err(placeholder) if empty_ui.can_name(placeholder.universe) => {\n+                        self.tcx().mk_region(RePlaceholder(placeholder))\n                     }\n+                    Err(_) => self.tcx().lifetimes.re_static,\n                 };\n \n                 debug!(\"Expanding value of {:?} from empty lifetime to {:?}\", b_vid, lub);"}]}