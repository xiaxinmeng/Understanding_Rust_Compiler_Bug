{"sha": "ee822d19b7662a9055bc6693c4c40d8dcf752ea1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlODIyZDE5Yjc2NjJhOTA1NWJjNjY5M2M0YzQwZDhkY2Y3NTJlYTE=", "commit": {"author": {"name": "Josh Mcguigan", "email": "joshmcg88@gmail.com", "date": "2020-04-12T15:40:09Z"}, "committer": {"name": "Josh Mcguigan", "email": "joshmcg88@gmail.com", "date": "2020-04-13T15:19:19Z"}, "message": "handle tuple patterns with ellipsis", "tree": {"sha": "a895315e5ca25485fa0ac5a341dd35fc6a851f9b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a895315e5ca25485fa0ac5a341dd35fc6a851f9b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee822d19b7662a9055bc6693c4c40d8dcf752ea1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee822d19b7662a9055bc6693c4c40d8dcf752ea1", "html_url": "https://github.com/rust-lang/rust/commit/ee822d19b7662a9055bc6693c4c40d8dcf752ea1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee822d19b7662a9055bc6693c4c40d8dcf752ea1/comments", "author": {"login": "JoshMcguigan", "id": 22216761, "node_id": "MDQ6VXNlcjIyMjE2NzYx", "avatar_url": "https://avatars.githubusercontent.com/u/22216761?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JoshMcguigan", "html_url": "https://github.com/JoshMcguigan", "followers_url": "https://api.github.com/users/JoshMcguigan/followers", "following_url": "https://api.github.com/users/JoshMcguigan/following{/other_user}", "gists_url": "https://api.github.com/users/JoshMcguigan/gists{/gist_id}", "starred_url": "https://api.github.com/users/JoshMcguigan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JoshMcguigan/subscriptions", "organizations_url": "https://api.github.com/users/JoshMcguigan/orgs", "repos_url": "https://api.github.com/users/JoshMcguigan/repos", "events_url": "https://api.github.com/users/JoshMcguigan/events{/privacy}", "received_events_url": "https://api.github.com/users/JoshMcguigan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JoshMcguigan", "id": 22216761, "node_id": "MDQ6VXNlcjIyMjE2NzYx", "avatar_url": "https://avatars.githubusercontent.com/u/22216761?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JoshMcguigan", "html_url": "https://github.com/JoshMcguigan", "followers_url": "https://api.github.com/users/JoshMcguigan/followers", "following_url": "https://api.github.com/users/JoshMcguigan/following{/other_user}", "gists_url": "https://api.github.com/users/JoshMcguigan/gists{/gist_id}", "starred_url": "https://api.github.com/users/JoshMcguigan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JoshMcguigan/subscriptions", "organizations_url": "https://api.github.com/users/JoshMcguigan/orgs", "repos_url": "https://api.github.com/users/JoshMcguigan/repos", "events_url": "https://api.github.com/users/JoshMcguigan/events{/privacy}", "received_events_url": "https://api.github.com/users/JoshMcguigan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "268b7987290143550461090c2c0e23371813dbec", "url": "https://api.github.com/repos/rust-lang/rust/commits/268b7987290143550461090c2c0e23371813dbec", "html_url": "https://github.com/rust-lang/rust/commit/268b7987290143550461090c2c0e23371813dbec"}], "stats": {"total": 199, "additions": 141, "deletions": 58}, "files": [{"sha": "79abe55ce6065227463376240b8f5673941d8092", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ee822d19b7662a9055bc6693c4c40d8dcf752ea1/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee822d19b7662a9055bc6693c4c40d8dcf752ea1/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=ee822d19b7662a9055bc6693c4c40d8dcf752ea1", "patch": "@@ -33,6 +33,7 @@ use crate::{\n };\n \n use super::{ExprSource, PatSource};\n+use ast::AstChildren;\n \n pub(super) fn lower(\n     db: &dyn DefDatabase,\n@@ -598,8 +599,8 @@ impl ExprCollector<'_> {\n             }\n             ast::Pat::TupleStructPat(p) => {\n                 let path = p.path().and_then(|path| self.expander.parse_path(path));\n-                let args = p.args().map(|p| self.collect_pat(p)).collect();\n-                Pat::TupleStruct { path, args }\n+                let (args, ellipsis) = self.collect_tuple_pat(p.args());\n+                Pat::TupleStruct { path, args, ellipsis }\n             }\n             ast::Pat::RefPat(p) => {\n                 let pat = self.collect_pat_opt(p.pat());\n@@ -616,10 +617,10 @@ impl ExprCollector<'_> {\n             }\n             ast::Pat::ParenPat(p) => return self.collect_pat_opt(p.pat()),\n             ast::Pat::TuplePat(p) => {\n-                let args = p.args().map(|p| self.collect_pat(p)).collect();\n-                Pat::Tuple(args)\n+                let (args, ellipsis) = self.collect_tuple_pat(p.args());\n+                Pat::Tuple { args, ellipsis }\n             }\n-            ast::Pat::PlaceholderPat(_) | ast::Pat::DotDotPat(_) => Pat::Wild,\n+            ast::Pat::PlaceholderPat(_) => Pat::Wild,\n             ast::Pat::RecordPat(p) => {\n                 let path = p.path().and_then(|path| self.expander.parse_path(path));\n                 let record_field_pat_list =\n@@ -665,6 +666,9 @@ impl ExprCollector<'_> {\n                     Pat::Missing\n                 }\n             }\n+            ast::Pat::DotDotPat(_) => unreachable!(\n+                \"`DotDotPat` requires special handling and should not be mapped to a Pat.\"\n+            ),\n             // FIXME: implement\n             ast::Pat::BoxPat(_) | ast::Pat::RangePat(_) | ast::Pat::MacroPat(_) => Pat::Missing,\n         };\n@@ -679,6 +683,19 @@ impl ExprCollector<'_> {\n             self.missing_pat()\n         }\n     }\n+\n+    fn collect_tuple_pat(&mut self, args: AstChildren<ast::Pat>) -> (Vec<PatId>, Option<usize>) {\n+        // Find the location of the `..`, if there is one. Note that we do not\n+        // consider the possiblity of there being multiple `..` here.\n+        let ellipsis = args.clone().position(|p| matches!(p, ast::Pat::DotDotPat(_)));\n+        // We want to skip the `..` pattern here, since we account for it above.\n+        let args = args\n+            .filter(|p| !matches!(p, ast::Pat::DotDotPat(_)))\n+            .map(|p| self.collect_pat(p))\n+            .collect();\n+\n+        (args, ellipsis)\n+    }\n }\n \n impl From<ast::BinOp> for BinaryOp {"}, {"sha": "a0cdad529b3fb8404e4216df17ab6cb353a912cd", "filename": "crates/ra_hir_def/src/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee822d19b7662a9055bc6693c4c40d8dcf752ea1/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee822d19b7662a9055bc6693c4c40d8dcf752ea1/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs?ref=ee822d19b7662a9055bc6693c4c40d8dcf752ea1", "patch": "@@ -374,15 +374,15 @@ pub struct RecordFieldPat {\n pub enum Pat {\n     Missing,\n     Wild,\n-    Tuple(Vec<PatId>),\n+    Tuple { args: Vec<PatId>, ellipsis: Option<usize> },\n     Or(Vec<PatId>),\n     Record { path: Option<Path>, args: Vec<RecordFieldPat>, ellipsis: bool },\n     Range { start: ExprId, end: ExprId },\n     Slice { prefix: Vec<PatId>, slice: Option<PatId>, suffix: Vec<PatId> },\n     Path(Path),\n     Lit(ExprId),\n     Bind { mode: BindingAnnotation, name: Name, subpat: Option<PatId> },\n-    TupleStruct { path: Option<Path>, args: Vec<PatId> },\n+    TupleStruct { path: Option<Path>, args: Vec<PatId>, ellipsis: Option<usize> },\n     Ref { pat: PatId, mutability: Mutability },\n }\n \n@@ -393,7 +393,7 @@ impl Pat {\n             Pat::Bind { subpat, .. } => {\n                 subpat.iter().copied().for_each(f);\n             }\n-            Pat::Or(args) | Pat::Tuple(args) | Pat::TupleStruct { args, .. } => {\n+            Pat::Or(args) | Pat::Tuple { args, .. } | Pat::TupleStruct { args, .. } => {\n                 args.iter().copied().for_each(f);\n             }\n             Pat::Ref { pat, .. } => f(*pat),"}, {"sha": "a64be9848ef1cebebdf1cd695e888812d4467f7d", "filename": "crates/ra_hir_ty/src/_match.rs", "status": "modified", "additions": 113, "deletions": 47, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/ee822d19b7662a9055bc6693c4c40d8dcf752ea1/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee822d19b7662a9055bc6693c4c40d8dcf752ea1/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2F_match.rs?ref=ee822d19b7662a9055bc6693c4c40d8dcf752ea1", "patch": "@@ -289,7 +289,7 @@ impl PatStack {\n         Self::from_slice(&self.0[1..])\n     }\n \n-    fn replace_head_with(&self, pat_ids: &[PatId]) -> PatStack {\n+    fn replace_head_with<T: Into<PatIdOrWild> + Copy>(&self, pat_ids: &[T]) -> PatStack {\n         let mut patterns: PatStackInner = smallvec![];\n         for pat in pat_ids {\n             patterns.push((*pat).into());\n@@ -320,12 +320,14 @@ impl PatStack {\n         constructor: &Constructor,\n     ) -> MatchCheckResult<Option<PatStack>> {\n         let result = match (self.head().as_pat(cx), constructor) {\n-            (Pat::Tuple(ref pat_ids), Constructor::Tuple { arity }) => {\n-                debug_assert_eq!(\n-                    pat_ids.len(),\n-                    *arity,\n-                    \"we type check before calling this code, so we should never hit this case\",\n-                );\n+            (Pat::Tuple { args: ref pat_ids, ellipsis }, Constructor::Tuple { arity: _ }) => {\n+                if ellipsis.is_some() {\n+                    // If there are ellipsis here, we should add the correct number of\n+                    // Pat::Wild patterns to `pat_ids`. We should be able to use the\n+                    // constructors arity for this, but at the time of writing we aren't\n+                    // correctly calculating this arity when ellipsis are present.\n+                    return Err(MatchCheckErr::NotImplemented);\n+                }\n \n                 Some(self.replace_head_with(pat_ids))\n             }\n@@ -351,19 +353,47 @@ impl PatStack {\n                     Some(self.to_tail())\n                 }\n             }\n-            (Pat::TupleStruct { args: ref pat_ids, .. }, Constructor::Enum(enum_constructor)) => {\n+            (\n+                Pat::TupleStruct { args: ref pat_ids, ellipsis, .. },\n+                Constructor::Enum(enum_constructor),\n+            ) => {\n                 let pat_id = self.head().as_id().expect(\"we know this isn't a wild\");\n                 if !enum_variant_matches(cx, pat_id, *enum_constructor) {\n                     None\n                 } else {\n-                    // If the enum variant matches, then we need to confirm\n-                    // that the number of patterns aligns with the expected\n-                    // number of patterns for that enum variant.\n-                    if pat_ids.len() != constructor.arity(cx)? {\n-                        return Err(MatchCheckErr::MalformedMatchArm);\n+                    let constructor_arity = constructor.arity(cx)?;\n+                    if let Some(ellipsis_position) = ellipsis {\n+                        // If there are ellipsis in the pattern, the ellipsis must take the place\n+                        // of at least one sub-pattern, so `pat_ids` should be smaller than the\n+                        // constructor arity.\n+                        if pat_ids.len() < constructor_arity {\n+                            let mut new_patterns: Vec<PatIdOrWild> = vec![];\n+\n+                            for pat_id in &pat_ids[0..ellipsis_position] {\n+                                new_patterns.push((*pat_id).into());\n+                            }\n+\n+                            for _ in 0..(constructor_arity - pat_ids.len()) {\n+                                new_patterns.push(PatIdOrWild::Wild);\n+                            }\n+\n+                            for pat_id in &pat_ids[ellipsis_position..pat_ids.len()] {\n+                                new_patterns.push((*pat_id).into());\n+                            }\n+\n+                            Some(self.replace_head_with(&new_patterns))\n+                        } else {\n+                            return Err(MatchCheckErr::MalformedMatchArm);\n+                        }\n+                    } else {\n+                        // If there is no ellipsis in the tuple pattern, the number\n+                        // of patterns must equal the constructor arity.\n+                        if pat_ids.len() == constructor_arity {\n+                            Some(self.replace_head_with(pat_ids))\n+                        } else {\n+                            return Err(MatchCheckErr::MalformedMatchArm);\n+                        }\n                     }\n-\n-                    Some(self.replace_head_with(pat_ids))\n                 }\n             }\n             (Pat::Or(_), _) => return Err(MatchCheckErr::NotImplemented),\n@@ -644,7 +674,11 @@ impl Constructor {\n fn pat_constructor(cx: &MatchCheckCtx, pat: PatIdOrWild) -> MatchCheckResult<Option<Constructor>> {\n     let res = match pat.as_pat(cx) {\n         Pat::Wild => None,\n-        Pat::Tuple(pats) => Some(Constructor::Tuple { arity: pats.len() }),\n+        // FIXME somehow create the Tuple constructor with the proper arity. If there are\n+        // ellipsis, the arity is not equal to the number of patterns.\n+        Pat::Tuple { args: pats, ellipsis } if ellipsis.is_none() => {\n+            Some(Constructor::Tuple { arity: pats.len() })\n+        }\n         Pat::Lit(lit_expr) => match cx.body.exprs[lit_expr] {\n             Expr::Literal(Literal::Bool(val)) => Some(Constructor::Bool(val)),\n             _ => return Err(MatchCheckErr::NotImplemented),\n@@ -1506,6 +1540,67 @@ mod tests {\n         check_no_diagnostic(content);\n     }\n \n+    #[test]\n+    fn enum_tuple_partial_ellipsis_2_no_diagnostic() {\n+        let content = r\"\n+            enum Either {\n+                A(bool, bool, bool, bool),\n+                B,\n+            }\n+            fn test_fn() {\n+                match Either::B {\n+                    Either::A(true, .., true) => {},\n+                    Either::A(true, .., false) => {},\n+                    Either::A(.., true) => {},\n+                    Either::A(.., false) => {},\n+                    Either::B => {},\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_tuple_partial_ellipsis_missing_arm() {\n+        let content = r\"\n+            enum Either {\n+                A(bool, bool, bool, bool),\n+                B,\n+            }\n+            fn test_fn() {\n+                match Either::B {\n+                    Either::A(true, .., true) => {},\n+                    Either::A(true, .., false) => {},\n+                    Either::A(false, .., false) => {},\n+                    Either::B => {},\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_tuple_partial_ellipsis_2_missing_arm() {\n+        let content = r\"\n+            enum Either {\n+                A(bool, bool, bool, bool),\n+                B,\n+            }\n+            fn test_fn() {\n+                match Either::B {\n+                    Either::A(true, .., true) => {},\n+                    Either::A(true, .., false) => {},\n+                    Either::A(.., true) => {},\n+                    Either::B => {},\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic(content);\n+    }\n+\n     #[test]\n     fn enum_tuple_ellipsis_no_diagnostic() {\n         let content = r\"\n@@ -1645,11 +1740,7 @@ mod false_negatives {\n         \";\n \n         // This is a false negative.\n-        // The `..` pattern is currently lowered to a single `Pat::Wild`\n-        // no matter how many fields the `..` pattern is covering. This\n-        // causes the match arm in this test not to type check against\n-        // the match expression, which causes this diagnostic not to\n-        // fire.\n+        // We don't currently handle tuple patterns with ellipsis.\n         check_no_diagnostic(content);\n     }\n \n@@ -1664,32 +1755,7 @@ mod false_negatives {\n         \";\n \n         // This is a false negative.\n-        // See comments on `tuple_of_bools_with_ellipsis_at_end_missing_arm`.\n-        check_no_diagnostic(content);\n-    }\n-\n-    #[test]\n-    fn enum_tuple_partial_ellipsis_missing_arm() {\n-        let content = r\"\n-            enum Either {\n-                A(bool, bool, bool, bool),\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::B {\n-                    Either::A(true, .., true) => {},\n-                    Either::A(true, .., false) => {},\n-                    Either::A(false, .., false) => {},\n-                    Either::B => {},\n-                }\n-            }\n-        \";\n-\n-        // This is a false negative.\n-        // The `..` pattern is currently lowered to a single `Pat::Wild`\n-        // no matter how many fields the `..` pattern is covering. This\n-        // causes us to return a `MatchCheckErr::MalformedMatchArm` in\n-        // `Pat::specialize_constructor`.\n+        // We don't currently handle tuple patterns with ellipsis.\n         check_no_diagnostic(content);\n     }\n }"}, {"sha": "8ec4d4ace084e7c805061bc6ae21235b1b5f1c67", "filename": "crates/ra_hir_ty/src/infer/pat.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee822d19b7662a9055bc6693c4c40d8dcf752ea1/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee822d19b7662a9055bc6693c4c40d8dcf752ea1/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs?ref=ee822d19b7662a9055bc6693c4c40d8dcf752ea1", "patch": "@@ -85,7 +85,7 @@ impl<'a> InferenceContext<'a> {\n         let body = Arc::clone(&self.body); // avoid borrow checker problem\n \n         let is_non_ref_pat = match &body[pat] {\n-            Pat::Tuple(..)\n+            Pat::Tuple { .. }\n             | Pat::Or(..)\n             | Pat::TupleStruct { .. }\n             | Pat::Record { .. }\n@@ -116,7 +116,7 @@ impl<'a> InferenceContext<'a> {\n         let expected = expected;\n \n         let ty = match &body[pat] {\n-            Pat::Tuple(ref args) => {\n+            Pat::Tuple { ref args, .. } => {\n                 let expectations = match expected.as_tuple() {\n                     Some(parameters) => &*parameters.0,\n                     _ => &[],\n@@ -155,7 +155,7 @@ impl<'a> InferenceContext<'a> {\n                 let subty = self.infer_pat(*pat, expectation, default_bm);\n                 Ty::apply_one(TypeCtor::Ref(*mutability), subty)\n             }\n-            Pat::TupleStruct { path: p, args: subpats } => {\n+            Pat::TupleStruct { path: p, args: subpats, .. } => {\n                 self.infer_tuple_struct_pat(p.as_ref(), subpats, expected, default_bm, pat)\n             }\n             Pat::Record { path: p, args: fields, ellipsis: _ } => {"}]}