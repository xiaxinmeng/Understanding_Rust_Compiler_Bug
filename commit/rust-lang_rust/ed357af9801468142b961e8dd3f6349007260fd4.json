{"sha": "ed357af9801468142b961e8dd3f6349007260fd4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkMzU3YWY5ODAxNDY4MTQyYjk2MWU4ZGQzZjYzNDkwMDcyNjBmZDQ=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-05-23T01:44:28Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-05-23T02:12:18Z"}, "message": "Convert more resource tests to use classes with dtors\n\nAnd monomorphize dtors correctly.", "tree": {"sha": "c0b8f43d1aa9bca71a2ae28689a7c4d2be5e982f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0b8f43d1aa9bca71a2ae28689a7c4d2be5e982f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed357af9801468142b961e8dd3f6349007260fd4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed357af9801468142b961e8dd3f6349007260fd4", "html_url": "https://github.com/rust-lang/rust/commit/ed357af9801468142b961e8dd3f6349007260fd4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed357af9801468142b961e8dd3f6349007260fd4/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8caf1403be0d5968123aeba25dd7ed620a670d6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/8caf1403be0d5968123aeba25dd7ed620a670d6b", "html_url": "https://github.com/rust-lang/rust/commit/8caf1403be0d5968123aeba25dd7ed620a670d6b"}], "stats": {"total": 323, "additions": 221, "deletions": 102}, "files": [{"sha": "a4970268efd26b4a2d225f42192df1c34699efb1", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 184, "deletions": 75, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/ed357af9801468142b961e8dd3f6349007260fd4/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed357af9801468142b961e8dd3f6349007260fd4/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=ed357af9801468142b961e8dd3f6349007260fd4", "patch": "@@ -698,6 +698,38 @@ fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n     build_return(bcx);\n }\n \n+fn trans_class_drop(bcx: block, v0: ValueRef, dtor_did: ast::def_id,\n+                    class_did: ast::def_id,\n+                    substs: ty::substs) -> block {\n+  let drop_flag = GEPi(bcx, v0, [0u, 0u]);\n+  with_cond(bcx, IsNotNull(bcx, Load(bcx, drop_flag))) {|cx|\n+    let mut bcx = cx;\n+      // We have to cast v0\n+     let classptr = GEPi(bcx, v0, [0u, 1u]);\n+     // Find and call the actual destructor\n+     let dtor_addr = get_res_dtor(bcx.ccx(), dtor_did, substs.tps);\n+     // The second argument is the \"self\" argument for drop\n+     let params = lib::llvm::fn_ty_param_tys\n+         (llvm::LLVMGetElementType\n+          (llvm::LLVMTypeOf(dtor_addr)));\n+     // Class dtors have no explicit args, so the params should just consist\n+     // of the output pointer and the environment (self)\n+     assert(params.len() == 2u);\n+     let self_arg = PointerCast(bcx, v0, params[1u]);\n+     let args = [bcx.fcx.llretptr, self_arg];\n+     Call(bcx, dtor_addr, args);\n+     // Drop the fields\n+     for vec::eachi(ty::class_items_as_fields(bcx.tcx(), class_did, substs))\n+     {|i, fld|\n+        let llfld_a = GEPi(bcx, classptr, [0u, i]);\n+        bcx = drop_ty(bcx, llfld_a, fld.mt.ty);\n+     }\n+     Store(bcx, C_u8(0u), drop_flag);\n+     bcx\n+  }\n+}\n+\n+\n fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let _icx = bcx.insn_ctxt(\"make_drop_glue\");\n@@ -718,37 +750,7 @@ fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n         let tcx = bcx.tcx();\n         alt ty::ty_dtor(tcx, did) {\n           some(dtor) {\n-            let drop_flag = GEPi(bcx, v0, [0u, 0u]);\n-            with_cond(bcx, IsNotNull(bcx, Load(bcx, drop_flag))) {|cx|\n-               let mut bcx = cx;\n-                // we have to cast v0\n-               let classptr = GEPi(bcx, v0, [0u, 1u]);\n-                // Find and call the actual destructor\n-                let dtor_addr = get_res_dtor(bcx.ccx(), dtor, substs.tps);\n-                // The second argument is the \"self\" argument for drop\n-                let params = lib::llvm::fn_ty_param_tys\n-                   (llvm::LLVMGetElementType\n-                    (llvm::LLVMTypeOf(dtor_addr)));\n-                let self_arg = PointerCast(bcx, v0, params[1u]);\n-                let args = [bcx.fcx.llretptr, self_arg];\n-                let val_llty = lib::llvm::fn_ty_param_tys\n-                    (llvm::LLVMGetElementType\n-                     (llvm::LLVMTypeOf(dtor_addr)))[args.len()];\n-                let val_cast = BitCast(bcx, classptr, val_llty);\n-                #debug(\"fn_ty: %s\", ty_str(bcx.ccx().tn,\n-                                           (llvm::LLVMGetElementType\n-                                            (llvm::LLVMTypeOf(dtor_addr)))));\n-                #debug(\"self's ty: %s\", val_str(bcx.ccx().tn, v0));\n-                Call(bcx, dtor_addr, args + [val_cast]);\n-                // Drop the fields\n-                for vec::eachi(ty::class_items_as_fields(tcx, did, substs))\n-                     {|i, fld|\n-                         let llfld_a = GEPi(bcx, classptr, [0u, i]);\n-                         bcx = drop_ty(bcx, llfld_a, fld.mt.ty);\n-                     }\n-                Store(bcx, C_u8(0u), drop_flag);\n-                bcx\n-             }\n+            trans_class_drop(bcx, v0, dtor, did, substs)\n           }\n           none {\n             // No dtor? Just the default case\n@@ -2063,8 +2065,21 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, real_substs: [ty::t],\n         ret {val: get_item_val(ccx, fn_id.node),\n              must_cast: true};\n       }\n-      ast_map::node_ctor(nm, _, _, pt) { (pt, nm, ast_util::dummy_sp()) }\n-      _ { fail \"unexpected node type\"; }\n+      ast_map::node_ctor(nm, _, ct, pt) { (pt, nm, alt ct {\n+                  ast_map::res_ctor(_, _, sp) { sp }\n+                  ast_map::class_ctor(ct_, _) { ct_.span }}) }\n+      ast_map::node_dtor(_, dtor, _, pt) {(pt, \"drop\", dtor.span)}\n+      ast_map::node_expr(*) { ccx.tcx.sess.bug(\"Can't monomorphize an expr\") }\n+      ast_map::node_export(*) {\n+          ccx.tcx.sess.bug(\"Can't monomorphize an export\")\n+      }\n+      ast_map::node_arg(*) { ccx.tcx.sess.bug(\"Can't monomorphize an arg\") }\n+      ast_map::node_block(*) {\n+          ccx.tcx.sess.bug(\"Can't monomorphize a block\")\n+      }\n+      ast_map::node_local(*) {\n+          ccx.tcx.sess.bug(\"Can't monomorphize a local\")\n+      }\n     };\n     let mono_ty = ty::subst_tps(ccx.tcx, substs, item_ty);\n     let llfty = type_of_fn_from_ty(ccx, mono_ty);\n@@ -2081,55 +2096,97 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, real_substs: [ty::t],\n \n     let pt = *pt + [path_name(ccx.names(name))];\n     let s = mangle_exported_name(ccx, pt, mono_ty);\n-    let lldecl = decl_internal_cdecl_fn(ccx.llmod, s, llfty);\n-    ccx.monomorphized.insert(hash_id, lldecl);\n+\n+    let mk_lldecl = {||\n+        let lldecl = decl_internal_cdecl_fn(ccx.llmod, s, llfty);\n+        ccx.monomorphized.insert(hash_id, lldecl);\n+        lldecl\n+    };\n \n     let psubsts = some({tys: substs, vtables: vtables, bounds: tpt.bounds});\n-    alt check map_node {\n+    let lldecl = alt map_node {\n       ast_map::node_item(i@@{node: ast::item_fn(decl, _, body), _}, _) {\n-        set_inline_hint_if_appr(i.attrs, lldecl);\n-        trans_fn(ccx, pt, decl, body, lldecl, no_self, psubsts, fn_id.node);\n+        let d = mk_lldecl();\n+        set_inline_hint_if_appr(i.attrs, d);\n+        trans_fn(ccx, pt, decl, body, d, no_self, psubsts, fn_id.node);\n+        d\n       }\n       ast_map::node_item(\n-          @{node: ast::item_res(d, _, body, d_id, _, _), _}, _) {\n-        trans_fn(ccx, pt, d, body, lldecl, no_self, psubsts, d_id);\n+          @{node: ast::item_res(dt, _, body, d_id, _, _), _}, _) {\n+          let d = mk_lldecl();\n+          trans_fn(ccx, pt, dt, body, d, no_self, psubsts, d_id);\n+          d\n+      }\n+      ast_map::node_item(*) {\n+          ccx.tcx.sess.bug(\"Can't monomorphize this kind of item\")\n       }\n       ast_map::node_native_item(i, _, _) {\n-        native::trans_intrinsic(ccx, lldecl, i, pt, option::get(psubsts),\n+          let d = mk_lldecl();\n+          native::trans_intrinsic(ccx, d, i, pt, option::get(psubsts),\n                                 ref_id);\n+          d\n       }\n       ast_map::node_variant(v, enum_item, _) {\n         let tvs = ty::enum_variants(ccx.tcx, local_def(enum_item.id));\n         let this_tv = option::get(vec::find(*tvs, {|tv|\n             tv.id.node == fn_id.node}));\n-        set_inline_hint(lldecl);\n+        let d = mk_lldecl();\n+        set_inline_hint(d);\n         trans_enum_variant(ccx, enum_item.id, v, this_tv.disr_val,\n-                           (*tvs).len() == 1u, psubsts, lldecl);\n+                           (*tvs).len() == 1u, psubsts, d);\n+        d\n       }\n       ast_map::node_method(mth, impl_def_id, _) {\n-        set_inline_hint_if_appr(mth.attrs, lldecl);\n+        let d = mk_lldecl();\n+        set_inline_hint_if_appr(mth.attrs, d);\n         let selfty = ty::node_id_to_type(ccx.tcx, mth.self_id);\n         let selfty = ty::subst_tps(ccx.tcx, substs, selfty);\n-        trans_fn(ccx, pt, mth.decl, mth.body, lldecl,\n+        trans_fn(ccx, pt, mth.decl, mth.body, d,\n                  impl_self(selfty), psubsts, fn_id.node);\n+        d\n       }\n       ast_map::node_ctor(nm, tps, ct, _) {\n+        let d = mk_lldecl();\n         alt ct {\n           ast_map::res_ctor(decl,_, _) {\n-            set_inline_hint(lldecl);\n-            trans_res_ctor(ccx, pt, decl, fn_id.node, psubsts, lldecl);\n+            set_inline_hint(d);\n+            trans_res_ctor(ccx, pt, decl, fn_id.node, psubsts, d);\n+            d\n           }\n           ast_map::class_ctor(ctor, parent_id) {\n             // ctors don't have attrs, at least not right now\n             let tp_tys: [ty::t] = ty::ty_params_to_tys(ccx.tcx, tps);\n-            trans_class_ctor(ccx, pt, ctor.node.dec, ctor.node.body, lldecl,\n+            trans_class_ctor(ccx, pt, ctor.node.dec, ctor.node.body, d,\n                  option::get_default(psubsts,\n                    {tys:tp_tys, vtables: none, bounds: @[]}),\n               fn_id.node, parent_id, ctor.span);\n+            d\n           }\n         }\n       }\n-    }\n+      ast_map::node_dtor(_, dtor, _, pt) {\n+          let parent_id = alt ty::ty_to_def_id(ty::node_id_to_type(ccx.tcx,\n+                                     dtor.node.self_id)) {\n+                  some(did) { did }\n+                  none      { ccx.sess.span_bug(dtor.span, \"Bad self ty in \\\n+                               dtor\"); }\n+          };\n+          trans_class_dtor(ccx, *pt, dtor.node.body,\n+                           dtor.node.id, psubsts, some(hash_id), parent_id, s)\n+      }\n+      // Ugh -- but this ensures any new variants won't be forgotten\n+      ast_map::node_expr(*) { ccx.tcx.sess.bug(\"Can't monomorphize an expr\") }\n+      ast_map::node_export(*) {\n+          ccx.tcx.sess.bug(\"Can't monomorphize an export\")\n+      }\n+      ast_map::node_arg(*) { ccx.tcx.sess.bug(\"Can't monomorphize an arg\") }\n+      ast_map::node_block(*) {\n+          ccx.tcx.sess.bug(\"Can't monomorphize a block\")\n+      }\n+      ast_map::node_local(*) {\n+          ccx.tcx.sess.bug(\"Can't monomorphize a local\")\n+      }\n+    };\n     ccx.monomorphizing.insert(fn_id, depth);\n     {val: lldecl, must_cast: must_cast}\n }\n@@ -2283,8 +2340,7 @@ fn lookup_discriminant(ccx: @crate_ctxt, vid: ast::def_id) -> ValueRef {\n }\n \n fn cast_self(cx: block, slf: val_self_pair) -> ValueRef {\n-    let rslt = PointerCast(cx, slf.v, T_ptr(type_of(cx.ccx(), slf.t)));\n-    rslt\n+    PointerCast(cx, slf.v, T_ptr(type_of(cx.ccx(), slf.t)))\n }\n \n fn trans_local_var(cx: block, def: ast::def) -> local_var_result {\n@@ -2310,14 +2366,25 @@ fn trans_local_var(cx: block, def: ast::def) -> local_var_result {\n         assert (cx.fcx.lllocals.contains_key(nid));\n         ret take_local(cx.fcx.lllocals, nid);\n       }\n-      ast::def_self(_) {\n+      ast::def_self(sid) {\n         let slf = alt copy cx.fcx.llself {\n-             some(s) { s }\n-             none { cx.sess().bug(\"trans_local_var: reference to self \\\n+          some(s) {\n+            alt option::map(ty::ty_to_def_id(s.t)) {|did|\n+                     ty::ty_dtor(cx.tcx(), did)} {\n+              some(some(_)) {\n+                  /* self is a class with a dtor, which means we\n+                     have to select out the object itself\n+                     (If any other code does the same thing, that's\n+                     a bug */\n+                GEPi(cx, cast_self(cx, s), [0u, 1u])\n+            }\n+            _ { cast_self(cx, s) }\n+           }\n+          }\n+          none { cx.sess().bug(\"trans_local_var: reference to self \\\n                                  out of context\"); }\n         };\n-        let ptr = cast_self(cx, slf);\n-        ret {val: ptr, kind: owned};\n+        ret {val: slf, kind: owned};\n       }\n       _ {\n         cx.sess().unimpl(#fmt(\"unsupported def type in trans_local_def: %?\",\n@@ -2388,24 +2455,18 @@ fn trans_rec_field(bcx: block, base: @ast::expr,\n \n fn trans_rec_field_inner(bcx: block, val: ValueRef, ty: ty::t,\n                          field: ast::ident, sp: span) -> lval_result {\n-    let mut is_class_with_dtor = false;\n     let fields = alt ty::get(ty).struct {\n        ty::ty_rec(fs) { fs }\n        ty::ty_class(did, substs) {\n-         if option::is_some(ty::ty_dtor(bcx.tcx(), did)) {\n-            is_class_with_dtor = true;\n-         }\n          ty::class_items_as_fields(bcx.tcx(), did, substs)\n        }\n        // Constraint?\n        _ { bcx.tcx().sess.span_bug(sp, \"trans_rec_field:\\\n                  base expr has non-record type\"); }\n     };\n     let ix = field_idx_strict(bcx.tcx(), sp, field, fields);\n-    let val = GEPi(bcx, if is_class_with_dtor {\n-            GEPi(bcx, val, [0u, 1u])\n-        }\n-        else { val }, [0u, ix]);\n+    let val = GEPi(bcx, val, [0u, ix]);\n+\n     ret {bcx: bcx, val: val, kind: owned};\n }\n \n@@ -4726,12 +4787,39 @@ fn trans_class_ctor(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n }\n \n fn trans_class_dtor(ccx: @crate_ctxt, path: path,\n-                    body: ast::blk, lldtor_decl: ValueRef,\n-                    dtor_id: ast::node_id,\n-                    parent_id: ast::def_id) {\n-  let class_ty = ty::lookup_item_type(ccx.tcx, parent_id).ty;\n+    body: ast::blk,\n+    dtor_id: ast::node_id, substs: option<param_substs>,\n+                    hash_id: option<mono_id>, parent_id: ast::def_id,\n+                    // mangled exported name for dtor\n+                    s: str) -> ValueRef {\n+  let tcx = ccx.tcx;\n+  /* Look up the parent class's def_id */\n+  let mut class_ty = ty::lookup_item_type(tcx, parent_id).ty;\n+  /* Substitute in the class type if necessary */\n+  option::iter(substs) {|ss|\n+    class_ty = ty::subst_tps(tcx, ss.tys, class_ty);\n+  }\n+\n+  /* The dtor takes a (null) output pointer, and a self argument,\n+     and returns () */\n+  let lldty = T_fn([T_ptr(type_of(ccx, ty::mk_nil(tcx))),\n+                    T_ptr(type_of(ccx, class_ty))],\n+                   llvm::LLVMVoidType());\n+  /* Register the dtor as a function. It has external linkage */\n+  let lldecl = decl_internal_cdecl_fn(ccx.llmod, s, lldty);\n+  lib::llvm::SetLinkage(lldecl, lib::llvm::ExternalLinkage);\n+\n+  /* If we're monomorphizing, register the monomorphized decl\n+     for the dtor */\n+  option::iter(hash_id) {|h_id|\n+    ccx.monomorphized.insert(h_id, lldecl);\n+  }\n+  /* Register the symbol for the dtor, and generate the code for its\n+     body */\n+  ccx.item_symbols.insert(dtor_id, s);\n   trans_fn(ccx, path, ast_util::dtor_dec(),\n-           body, lldtor_decl, impl_self(class_ty), none, dtor_id);\n+           body, lldecl, impl_self(class_ty), substs, dtor_id);\n+  lldecl\n }\n \n fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n@@ -4811,9 +4899,11 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n                            get_item_val(ccx, ctor.node.id), psubsts,\n                            ctor.node.id, local_def(item.id), ctor.span);\n           option::iter(m_dtor) {|dtor|\n-            trans_class_dtor(ccx, *path, dtor.node.body,\n-                           get_item_val(ccx, dtor.node.id),\n-                           dtor.node.id, local_def(item.id));\n+             let s = mangle_exported_name(ccx, *path +\n+                                         [path_name(ccx.names(\"dtor\"))],\n+                                 ty::node_id_to_type(ccx.tcx, dtor.node.id));\n+             trans_class_dtor(ccx, *path, dtor.node.body,\n+               dtor.node.id, none, none, local_def(item.id), s);\n           };\n         }\n         // If there are ty params, the ctor will get monomorphized\n@@ -4976,6 +5066,7 @@ fn item_path(ccx: @crate_ctxt, i: @ast::item) -> path {\n \n fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n     #debug(\"get_item_val: %d\", id);\n+    let tcx = ccx.tcx;\n     alt ccx.item_vals.find(id) {\n       some(v) { v }\n       none {\n@@ -5041,9 +5132,27 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n             }\n           }\n           ast_map::node_dtor(tps, dt, parent_id, pt) {\n-            let my_path = *pt + [path_name(\"dtor\")];\n-            let t = ty::node_id_to_type(ccx.tcx, dt.node.id);\n-            register_fn_full(ccx, dt.span, my_path, dt.node.id, t)\n+            /*\n+                Don't just call register_fn, since we don't want to add\n+                the implicit self argument automatically (we want to make sure\n+                it has the right type)\n+            */\n+            // Want parent_id and not id, because id is the dtor's type\n+            let class_ty = ty::lookup_item_type(tcx, parent_id).ty;\n+            // This code shouldn't be reached if the class is generic\n+            assert !ty::type_has_params(class_ty);\n+            let lldty = T_fn([T_ptr(type_of(ccx, ty::mk_nil(tcx))),\n+                    T_ptr(type_of(ccx, class_ty))],\n+                                   llvm::LLVMVoidType());\n+            /* The symbol for the dtor should have already been registered */\n+            let s: str = alt ccx.item_symbols.find(id) {\n+                    some(s) { s }\n+                    none { ccx.sess.bug(\"in get_item_val, dtor is unbound\"); }\n+            };\n+            /* Make the declaration for the dtor */\n+            let llfn = decl_internal_cdecl_fn(ccx.llmod, s, lldty);\n+            lib::llvm::SetLinkage(llfn, lib::llvm::ExternalLinkage);\n+            llfn\n           }\n \n           ast_map::node_variant(v, enm, pth) {"}, {"sha": "6ffd80cdceb577b1269c632cd5cf4ed6726a3768", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed357af9801468142b961e8dd3f6349007260fd4/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed357af9801468142b961e8dd3f6349007260fd4/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=ed357af9801468142b961e8dd3f6349007260fd4", "patch": "@@ -423,6 +423,12 @@ impl bcx_cxs for block {\n     fn tcx() -> ty::ctxt { self.fcx.ccx.tcx }\n     fn sess() -> session { self.fcx.ccx.sess }\n \n+    fn val_str(val: ValueRef) -> str {\n+        val_str(self.ccx().tn, val)\n+    }\n+    fn ty_to_str(t: ty::t) -> str {\n+        ty_to_str(self.tcx(), t)\n+    }\n     fn to_str() -> str {\n         alt self.node_info {\n           some(node_info) {"}, {"sha": "25aee106a8bd746ce8a5a041c913f137a06827e7", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed357af9801468142b961e8dd3f6349007260fd4/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed357af9801468142b961e8dd3f6349007260fd4/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=ed357af9801468142b961e8dd3f6349007260fd4", "patch": "@@ -6,6 +6,7 @@ import build::*;\n import driver::session::session;\n import syntax::{ast, ast_map};\n import ast_map::{path, path_mod, path_name, node_id_to_str};\n+import driver::session::expect;\n import syntax::ast_util::{local_def, split_class_items};\n import metadata::csearch;\n import back::{link, abi};\n@@ -247,7 +248,10 @@ fn make_impl_vtable(ccx: @crate_ctxt, impl_id: ast::def_id, substs: [ty::t],\n                     vtables: typeck::vtable_res) -> ValueRef {\n     let _icx = ccx.insn_ctxt(\"impl::make_impl_vtable\");\n     let tcx = ccx.tcx;\n-    let ifce_id = ty::ty_to_def_id(option::get(ty::impl_iface(tcx, impl_id)));\n+    let ifce_id = expect(ccx.sess,\n+                         ty::ty_to_def_id(option::get(ty::impl_iface(tcx,\n+                                                             impl_id))),\n+                         {|| \"make_impl_vtable: non-iface-type implemented\"});\n     let has_tps = (*ty::lookup_item_type(ccx.tcx, impl_id).bounds).len() > 0u;\n     make_vtable(ccx, vec::map(*ty::iface_methods(tcx, ifce_id)) {|im|\n         let fty = ty::subst_tps(tcx, substs, ty::mk_fn(tcx, im.fty));"}, {"sha": "1ba04547604d5d54f974ef3c8ce38b5afda48665", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed357af9801468142b961e8dd3f6349007260fd4/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed357af9801468142b961e8dd3f6349007260fd4/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=ed357af9801468142b961e8dd3f6349007260fd4", "patch": "@@ -90,6 +90,10 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n       ast_map::node_ctor(_, _, ast_map::class_ctor(ctor, _), _){\n         handle_body(cx, ctor.node.body);\n       }\n+      ast_map::node_dtor(_, dtor, _, _){\n+        handle_body(cx, dtor.node.body);\n+      }\n+\n     }\n     let uses = vec::from_mut(cx.uses);\n     ccx.type_use_cache.insert(fn_id, uses);"}, {"sha": "7ad4bb0103b1eaad722340ef972cb972412ea3fe", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ed357af9801468142b961e8dd3f6349007260fd4/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed357af9801468142b961e8dd3f6349007260fd4/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=ed357af9801468142b961e8dd3f6349007260fd4", "patch": "@@ -2375,11 +2375,12 @@ fn impl_iface(cx: ctxt, id: ast::def_id) -> option<t> {\n     }\n }\n \n-fn ty_to_def_id(ty: t) -> ast::def_id {\n-    alt check get(ty).struct {\n+fn ty_to_def_id(ty: t) -> option<ast::def_id> {\n+    alt get(ty).struct {\n       ty_iface(id, _) | ty_class(id, _) | ty_res(id, _, _) | ty_enum(id, _) {\n-        id\n+        some(id)\n       }\n+      _ { none }\n     }\n }\n \n@@ -2413,7 +2414,7 @@ fn ty_dtor(cx: ctxt, class_id: def_id) -> option<def_id> {\n          some(ast_map::node_item(@{node: ast::item_class(_, _, _, _,\n                                      some(dtor), _), _}, _))\n              { some(local_def(dtor.node.id))  }\n-          _  { none }\n+         _  { none }\n        }\n     }\n     else {"}, {"sha": "0ae85a5af0b79a66f6a5b70067fb78cdc698202d", "filename": "src/test/run-pass/resource-destruct-with-class.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8caf1403be0d5968123aeba25dd7ed620a670d6b/src%2Ftest%2Frun-pass%2Fresource-destruct-with-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8caf1403be0d5968123aeba25dd7ed620a670d6b/src%2Ftest%2Frun-pass%2Fresource-destruct-with-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-destruct-with-class.rs?ref=8caf1403be0d5968123aeba25dd7ed620a670d6b", "patch": "@@ -1,13 +0,0 @@\n-class shrinky_pointer {\n-  let i: @@mut int;\n-  fn look_at() -> int { ret **(self.i); }\n-  new(i: @@mut int) { self.i = i; }\n-  drop { log(error, \"Hello!\"); **(self.i) -= 1; }\n-}\n-\n-fn main() {\n-    let my_total = @@mut 10;\n-    { let pt <- shrinky_pointer(my_total); assert (pt.look_at() == 10); }\n-    log(error, #fmt(\"my_total = %d\", **my_total));\n-    assert (**my_total == 9);\n-}"}, {"sha": "0ae85a5af0b79a66f6a5b70067fb78cdc698202d", "filename": "src/test/run-pass/resource-destruct.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ed357af9801468142b961e8dd3f6349007260fd4/src%2Ftest%2Frun-pass%2Fresource-destruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed357af9801468142b961e8dd3f6349007260fd4/src%2Ftest%2Frun-pass%2Fresource-destruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-destruct.rs?ref=ed357af9801468142b961e8dd3f6349007260fd4", "patch": "@@ -1,9 +1,13 @@\n-resource shrinky_pointer(i: @mut int) { *i -= 1; }\n-\n-fn look_at(pt: shrinky_pointer) -> int { ret **pt; }\n+class shrinky_pointer {\n+  let i: @@mut int;\n+  fn look_at() -> int { ret **(self.i); }\n+  new(i: @@mut int) { self.i = i; }\n+  drop { log(error, \"Hello!\"); **(self.i) -= 1; }\n+}\n \n fn main() {\n-    let my_total = @mut 10;\n-    { let pt <- shrinky_pointer(my_total); assert (look_at(pt) == 10); }\n-    assert (*my_total == 9);\n+    let my_total = @@mut 10;\n+    { let pt <- shrinky_pointer(my_total); assert (pt.look_at() == 10); }\n+    log(error, #fmt(\"my_total = %d\", **my_total));\n+    assert (**my_total == 9);\n }"}, {"sha": "2cc23c1daad4c9469d48388c2475398246e0e6d7", "filename": "src/test/run-pass/resource-generic.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ed357af9801468142b961e8dd3f6349007260fd4/src%2Ftest%2Frun-pass%2Fresource-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed357af9801468142b961e8dd3f6349007260fd4/src%2Ftest%2Frun-pass%2Fresource-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-generic.rs?ref=ed357af9801468142b961e8dd3f6349007260fd4", "patch": "@@ -1,11 +1,15 @@\n-resource finish<T>(arg: {val: T, fin: native fn(T)}) {\n-    arg.fin(arg.val);\n+class finish<T: copy> {\n+  let arg: {val: T, fin: native fn(T)};\n+  new(arg: {val: T, fin: native fn(T)}) {\n+    self.arg = arg;\n+  }\n+  drop { self.arg.fin(self.arg.val); }\n }\n \n fn main() {\n     let box = @mut 10;\n     fn dec_box(&&i: @mut int) { *i -= 1; }\n \n-    { let i <- finish({val: box, fin: dec_box}); }\n+    { let _i <- finish({val: box, fin: dec_box}); }\n     assert (*box == 9);\n }"}]}