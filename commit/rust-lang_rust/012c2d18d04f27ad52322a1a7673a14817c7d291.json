{"sha": "012c2d18d04f27ad52322a1a7673a14817c7d291", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxMmMyZDE4ZDA0ZjI3YWQ1MjMyMmExYTc2NzNhMTQ4MTdjN2QyOTE=", "commit": {"author": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-03-02T03:43:19Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-02T18:28:15Z"}, "message": "Finish #fmt string parsing. Completely untested.", "tree": {"sha": "97c78c9b22632148e59e70746572caefbec59d96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/97c78c9b22632148e59e70746572caefbec59d96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/012c2d18d04f27ad52322a1a7673a14817c7d291", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/012c2d18d04f27ad52322a1a7673a14817c7d291", "html_url": "https://github.com/rust-lang/rust/commit/012c2d18d04f27ad52322a1a7673a14817c7d291", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/012c2d18d04f27ad52322a1a7673a14817c7d291/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4bc9052e135c25c79d4fa8556c44876e620ba1f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bc9052e135c25c79d4fa8556c44876e620ba1f7", "html_url": "https://github.com/rust-lang/rust/commit/4bc9052e135c25c79d4fa8556c44876e620ba1f7"}], "stats": {"total": 96, "additions": 89, "deletions": 7}, "files": [{"sha": "3f1e5c30392288df570d50089ca0acff61362882", "filename": "src/comp/front/extfmt.rs", "status": "modified", "additions": 89, "deletions": 7, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/012c2d18d04f27ad52322a1a7673a14817c7d291/src%2Fcomp%2Ffront%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012c2d18d04f27ad52322a1a7673a14817c7d291/src%2Fcomp%2Ffront%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fextfmt.rs?ref=012c2d18d04f27ad52322a1a7673a14817c7d291", "patch": "@@ -81,6 +81,10 @@ fn expand_syntax_ext(vec[@ast.expr] args,\n     }\n \n     auto fmt = expr_to_str(args.(0));\n+\n+    log \"Format string:\";\n+    log fmt;\n+\n     auto pieces = parse_fmt_string(fmt);\n     auto args_len = _vec.len[@ast.expr](args);\n     auto fmt_args = _vec.slice[@ast.expr](args, 1u, args_len - 1u);\n@@ -170,7 +174,7 @@ fn peek_num(str s, uint i, uint lim) -> option.t[tup(uint, uint)] {\n fn parse_conversion(str s, uint i, uint lim) -> tup(piece, uint) {\n     auto parm = parse_parameter(s, i, lim);\n     auto flags = parse_flags(s, parm._1, lim);\n-    auto width = parse_width(s, flags._1, lim);\n+    auto width = parse_count(s, flags._1, lim);\n     auto prec = parse_precision(s, width._1, lim);\n     auto ty = parse_type(s, prec._1, lim);\n     ret tup(piece_conv(rec(param = parm._0,\n@@ -192,22 +196,100 @@ fn parse_parameter(str s, uint i, uint lim) -> tup(option.t[int], uint) {\n             ret tup(none[int], i);\n         }\n         case (some[tup(uint, uint)](?t)) {\n-            fail;\n+            auto n = t._0;\n+            auto j = t._1;\n+            if (j < lim && s.(j) == '$' as u8) {\n+                ret tup(some[int](n as int), j + 1u);\n+            }\n+            else {\n+                ret tup(none[int], i);\n+            }\n         }\n     }\n }\n \n fn parse_flags(str s, uint i, uint lim) -> tup(vec[flag], uint) {\n-    let vec[flag] flags = vec();\n-    ret tup(flags, i);\n+    let vec[flag] noflags = vec();\n+\n+    if (i >= lim) {\n+        ret tup(noflags, i);\n+    }\n+\n+    fn more_(flag f, str s, uint i, uint lim) -> tup(vec[flag], uint) {\n+        auto next = parse_flags(s, i + 1u, lim);\n+        auto rest = next._0;\n+        auto j = next._1;\n+        let vec[flag] curr = vec(f);\n+        ret tup(curr + rest, j);\n+    }\n+\n+    auto more = bind more_(_, s, i, lim);\n+\n+    auto f = s.(i);\n+    if (f == ('-' as u8)) {\n+        ret more(flag_left_justify);\n+    } else if (f == ('0' as u8)) {\n+        ret more(flag_left_zero_pad);\n+    } else if (f == (' ' as u8)) {\n+        ret more(flag_left_space_pad);\n+    } else if (f == ('+' as u8)) {\n+        ret more(flag_plus_if_positive);\n+    } else if (f == ('#' as u8)) {\n+        ret more(flag_alternate);\n+    } else {\n+        ret tup(noflags, i);\n+    }\n }\n \n-fn parse_width(str s, uint i, uint lim) -> tup(count, uint) {\n-    ret tup(count_implied, i);\n+fn parse_count(str s, uint i, uint lim) -> tup(count, uint) {\n+    if (i >= lim) {\n+        ret tup(count_implied, i);\n+    }\n+\n+    // FIXME: These inner functions are just to avoid a rustboot\n+    // \"Unsatisfied precondition constraint\" bug with alts nested in ifs\n+    fn parse_star_count(str s, uint i, uint lim) -> tup(count, uint) {\n+        auto param = parse_parameter(s, i + 1u, lim);\n+        auto j = param._1;\n+        alt (param._0) {\n+            case (none[int]) {\n+                ret tup(count_is_next_param, j);\n+            }\n+            case (some[int](?n)) {\n+                ret tup(count_is_param(n), j);\n+            }\n+        }\n+    }\n+\n+    fn parse_count_(str s, uint i, uint lim) -> tup(count, uint) {\n+        auto num = peek_num(s, i, lim);\n+        alt (num) {\n+            case (none[tup(uint, uint)]) {\n+                ret tup(count_implied, i);\n+            }\n+            case (some[tup(uint, uint)](?num)) {\n+                ret tup(count_is(num._0 as int), num._1);\n+            }\n+        }\n+    }\n+\n+    if (s.(i) == ('*' as u8)) {\n+        ret parse_star_count(s, i, lim);\n+    } else {\n+        ret parse_count_(s, i, lim);\n+    }\n }\n \n fn parse_precision(str s, uint i, uint lim) -> tup(count, uint) {\n-    ret tup(count_implied, i);\n+    if (i >= lim) {\n+        ret tup(count_implied, i);\n+    }\n+\n+    if (s.(i) == '.' as u8) {\n+        ret parse_count(s, i + 1u, lim);\n+    } else {\n+        ret tup(count_implied, i);\n+    }\n }\n \n fn parse_type(str s, uint i, uint lim) -> tup(ty, uint) {"}]}