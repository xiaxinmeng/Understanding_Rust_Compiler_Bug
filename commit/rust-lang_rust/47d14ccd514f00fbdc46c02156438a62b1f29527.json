{"sha": "47d14ccd514f00fbdc46c02156438a62b1f29527", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3ZDE0Y2NkNTE0ZjAwZmJkYzQ2YzAyMTU2NDM4YTYyYjFmMjk1Mjc=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-09-18T16:03:09Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-09-20T09:21:25Z"}, "message": "incr.comp.: Remove IncrementalHashesMap and calculate_svh module.", "tree": {"sha": "9c1dfd7af21bcbc64c4cf1d244faa87e0cc8eaa7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c1dfd7af21bcbc64c4cf1d244faa87e0cc8eaa7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47d14ccd514f00fbdc46c02156438a62b1f29527", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47d14ccd514f00fbdc46c02156438a62b1f29527", "html_url": "https://github.com/rust-lang/rust/commit/47d14ccd514f00fbdc46c02156438a62b1f29527", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47d14ccd514f00fbdc46c02156438a62b1f29527/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4d1651266fafe94b023393228178ebcd39f885f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4d1651266fafe94b023393228178ebcd39f885f", "html_url": "https://github.com/rust-lang/rust/commit/c4d1651266fafe94b023393228178ebcd39f885f"}], "stats": {"total": 446, "additions": 52, "deletions": 394}, "files": [{"sha": "ce4ab2c8a1de90ee5b7d53c1c88a83c47a7b4b29", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/47d14ccd514f00fbdc46c02156438a62b1f29527/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d14ccd514f00fbdc46c02156438a62b1f29527/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=47d14ccd514f00fbdc46c02156438a62b1f29527", "patch": "@@ -30,7 +30,7 @@ use rustc::traits;\n use rustc::util::common::{ErrorReported, time};\n use rustc_allocator as allocator;\n use rustc_borrowck as borrowck;\n-use rustc_incremental::{self, IncrementalHashesMap};\n+use rustc_incremental;\n use rustc_resolve::{MakeGlobMap, Resolver};\n use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::{self, CStore};\n@@ -218,7 +218,7 @@ pub fn compile_input(sess: &Session,\n                                     &arenas,\n                                     &crate_name,\n                                     &outputs,\n-                                    |tcx, analysis, incremental_hashes_map, rx, result| {\n+                                    |tcx, analysis, rx, result| {\n             {\n                 // Eventually, we will want to track plugins.\n                 let _ignore = tcx.dep_graph.in_ignore();\n@@ -246,9 +246,7 @@ pub fn compile_input(sess: &Session,\n                 tcx.print_debug_stats();\n             }\n \n-            let trans = phase_4_translate_to_llvm(tcx,\n-                                                  incremental_hashes_map,\n-                                                  rx);\n+            let trans = phase_4_translate_to_llvm(tcx, rx);\n \n             if log_enabled!(::log::LogLevel::Info) {\n                 println!(\"Post-trans\");\n@@ -921,7 +919,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                                                -> Result<R, CompileIncomplete>\n     where F: for<'a> FnOnce(TyCtxt<'a, 'tcx, 'tcx>,\n                             ty::CrateAnalysis,\n-                            IncrementalHashesMap,\n                             mpsc::Receiver<Box<Any + Send>>,\n                             CompileResult) -> R\n {\n@@ -1053,22 +1050,16 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                              tx,\n                              output_filenames,\n                              |tcx| {\n-        let incremental_hashes_map =\n-            time(time_passes,\n-                 \"compute_incremental_hashes_map\",\n-                 || rustc_incremental::compute_incremental_hashes_map(tcx));\n-\n         time(time_passes,\n              \"load_dep_graph\",\n-             || rustc_incremental::load_dep_graph(tcx, &incremental_hashes_map));\n+             || rustc_incremental::load_dep_graph(tcx));\n \n         time(time_passes,\n              \"stability checking\",\n              || stability::check_unstable_api_usage(tcx));\n \n         // passes are timed inside typeck\n-        try_with_f!(typeck::check_crate(tcx),\n-                    (tcx, analysis, incremental_hashes_map, rx));\n+        try_with_f!(typeck::check_crate(tcx), (tcx, analysis, rx));\n \n         time(time_passes,\n              \"const checking\",\n@@ -1112,7 +1103,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n         // lint warnings and so on -- kindck used to do this abort, but\n         // kindck is gone now). -nmatsakis\n         if sess.err_count() > 0 {\n-            return Ok(f(tcx, analysis, incremental_hashes_map, rx, sess.compile_status()));\n+            return Ok(f(tcx, analysis, rx, sess.compile_status()));\n         }\n \n         time(time_passes, \"death checking\", || middle::dead::check_crate(tcx));\n@@ -1123,14 +1114,13 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n         time(time_passes, \"lint checking\", || lint::check_crate(tcx));\n \n-        return Ok(f(tcx, analysis, incremental_hashes_map, rx, tcx.sess.compile_status()));\n+        return Ok(f(tcx, analysis, rx, tcx.sess.compile_status()));\n     })\n }\n \n /// Run the translation phase to LLVM, after which the AST and analysis can\n /// be discarded.\n pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                           incremental_hashes_map: IncrementalHashesMap,\n                                            rx: mpsc::Receiver<Box<Any + Send>>)\n                                            -> write::OngoingCrateTranslation {\n     let time_passes = tcx.sess.time_passes();\n@@ -1141,7 +1131,7 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let translation =\n         time(time_passes, \"translation\", move || {\n-            trans::trans_crate(tcx, incremental_hashes_map, rx)\n+            trans::trans_crate(tcx, rx)\n         });\n \n     if tcx.sess.profile_queries() {"}, {"sha": "b633a170422eb95f31fc7d0bcf6fdc961e968060", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47d14ccd514f00fbdc46c02156438a62b1f29527/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d14ccd514f00fbdc46c02156438a62b1f29527/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=47d14ccd514f00fbdc46c02156438a62b1f29527", "patch": "@@ -237,7 +237,7 @@ impl PpSourceMode {\n                                                                  arenas,\n                                                                  id,\n                                                                  output_filenames,\n-                                                                 |tcx, _, _, _, _| {\n+                                                                 |tcx, _, _, _| {\n                     let empty_tables = ty::TypeckTables::empty(None);\n                     let annotation = TypedAnnotation {\n                         tcx,\n@@ -1036,7 +1036,7 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n                                                      arenas,\n                                                      crate_name,\n                                                      output_filenames,\n-                                                     |tcx, _, _, _, _| {\n+                                                     |tcx, _, _, _| {\n         match ppm {\n             PpmMir | PpmMirCFG => {\n                 if let Some(nodeid) = nodeid {"}, {"sha": "0329aa8d6741b71e1476089419735d8d86eb3c14", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "removed", "additions": 0, "deletions": 331, "changes": 331, "blob_url": "https://github.com/rust-lang/rust/blob/c4d1651266fafe94b023393228178ebcd39f885f/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4d1651266fafe94b023393228178ebcd39f885f/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=c4d1651266fafe94b023393228178ebcd39f885f", "patch": "@@ -1,331 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Calculation of the (misnamed) \"strict version hash\" for crates and\n-//! items. This hash is used to tell when the HIR changed in such a\n-//! way that results from previous compilations may no longer be\n-//! applicable and hence must be recomputed. It should probably be\n-//! renamed to the ICH (incremental compilation hash).\n-//!\n-//! The hashes for all items are computed once at the beginning of\n-//! compilation and stored into a map. In addition, a hash is computed\n-//! of the **entire crate**.\n-//!\n-//! Storing the hashes in a map avoids the need to compute them twice\n-//! (once when loading prior incremental results and once when\n-//! saving), but it is also important for correctness: at least as of\n-//! the time of this writing, the typeck passes rewrites entries in\n-//! the dep-map in-place to accommodate UFCS resolutions. Since name\n-//! resolution is part of the hash, the result is that hashes computed\n-//! at the end of compilation would be different from those computed\n-//! at the beginning.\n-\n-use std::cell::RefCell;\n-use std::hash::Hash;\n-use rustc::dep_graph::{DepNode, DepKind};\n-use rustc::hir;\n-use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n-use rustc::hir::map::DefPathHash;\n-use rustc::hir::itemlikevisit::ItemLikeVisitor;\n-use rustc::ich::{Fingerprint, StableHashingContext};\n-use rustc::ty::TyCtxt;\n-use rustc::util::common::record_time;\n-use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::accumulate_vec::AccumulateVec;\n-\n-pub type IchHasher = StableHasher<Fingerprint>;\n-\n-pub struct IncrementalHashesMap {\n-    hashes: FxHashMap<DepNode, Fingerprint>,\n-\n-    // These are the metadata hashes for the current crate as they were stored\n-    // during the last compilation session. They are only loaded if\n-    // -Z query-dep-graph was specified and are needed for auto-tests using\n-    // the #[rustc_metadata_dirty] and #[rustc_metadata_clean] attributes to\n-    // check whether some metadata hash has changed in between two revisions.\n-    pub prev_metadata_hashes: RefCell<FxHashMap<DefId, Fingerprint>>,\n-}\n-\n-impl IncrementalHashesMap {\n-    pub fn new() -> IncrementalHashesMap {\n-        IncrementalHashesMap {\n-            hashes: FxHashMap(),\n-            prev_metadata_hashes: RefCell::new(FxHashMap()),\n-        }\n-    }\n-\n-    pub fn insert(&mut self, k: DepNode, v: Fingerprint) {\n-        assert!(self.hashes.insert(k, v).is_none());\n-    }\n-\n-    pub fn iter<'a>(&'a self)\n-                    -> ::std::collections::hash_map::Iter<'a, DepNode, Fingerprint> {\n-        self.hashes.iter()\n-    }\n-\n-    pub fn len(&self) -> usize {\n-        self.hashes.len()\n-    }\n-}\n-\n-impl<'a> ::std::ops::Index<&'a DepNode> for IncrementalHashesMap {\n-    type Output = Fingerprint;\n-\n-    fn index(&self, index: &'a DepNode) -> &Fingerprint {\n-        match self.hashes.get(index) {\n-            Some(fingerprint) => fingerprint,\n-            None => {\n-                bug!(\"Could not find ICH for {:?}\", index);\n-            }\n-        }\n-    }\n-}\n-\n-struct ComputeItemHashesVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    hcx: StableHashingContext<'tcx>,\n-    hashes: IncrementalHashesMap,\n-}\n-\n-impl<'a, 'tcx: 'a> ComputeItemHashesVisitor<'a, 'tcx> {\n-    fn compute_and_store_ich_for_item_like<T>(&mut self,\n-                                              def_index: DefIndex,\n-                                              hash_bodies: bool,\n-                                              item_like: T)\n-        where T: HashStable<StableHashingContext<'tcx>>\n-    {\n-        if !hash_bodies && !self.tcx.sess.opts.build_dep_graph() {\n-            // If we just need the hashes in order to compute the SVH, we don't\n-            // need have two hashes per item. Just the one containing also the\n-            // item's body is sufficient.\n-            return\n-        }\n-\n-        let def_path_hash = self.hcx.local_def_path_hash(def_index);\n-\n-        let mut hasher = IchHasher::new();\n-        self.hcx.while_hashing_hir_bodies(hash_bodies, |hcx| {\n-            item_like.hash_stable(hcx, &mut hasher);\n-        });\n-\n-        let bytes_hashed = hasher.bytes_hashed();\n-        let item_hash = hasher.finish();\n-        let dep_node = if hash_bodies {\n-            def_path_hash.to_dep_node(DepKind::HirBody)\n-        } else {\n-            def_path_hash.to_dep_node(DepKind::Hir)\n-        };\n-        debug!(\"calculate_def_hash: dep_node={:?} hash={:?}\", dep_node, item_hash);\n-        self.hashes.insert(dep_node, item_hash);\n-\n-        let bytes_hashed =\n-            self.tcx.sess.perf_stats.incr_comp_bytes_hashed.get() + bytes_hashed;\n-        self.tcx.sess.perf_stats.incr_comp_bytes_hashed.set(bytes_hashed);\n-\n-        if hash_bodies {\n-            let in_scope_traits_map = self.tcx.in_scope_traits_map(def_index);\n-            let mut hasher = IchHasher::new();\n-            in_scope_traits_map.hash_stable(&mut self.hcx, &mut hasher);\n-            let dep_node = def_path_hash.to_dep_node(DepKind::InScopeTraits);\n-            self.hashes.insert(dep_node, hasher.finish());\n-        }\n-    }\n-\n-    fn compute_crate_hash(&mut self) {\n-        let krate = self.tcx.hir.krate();\n-\n-        let mut crate_state = IchHasher::new();\n-\n-        let crate_disambiguator = self.tcx.sess.local_crate_disambiguator();\n-        \"crate_disambiguator\".hash(&mut crate_state);\n-        crate_disambiguator.as_str().len().hash(&mut crate_state);\n-        crate_disambiguator.as_str().hash(&mut crate_state);\n-\n-        // add each item (in some deterministic order) to the overall\n-        // crate hash.\n-        {\n-            let mut item_hashes: Vec<_> =\n-                self.hashes.iter()\n-                           .filter_map(|(&item_dep_node, &item_hash)| {\n-                                // This `match` determines what kinds of nodes\n-                                // go into the SVH:\n-                                match item_dep_node.kind {\n-                                    DepKind::InScopeTraits |\n-                                    DepKind::Hir |\n-                                    DepKind::HirBody => {\n-                                        // We want to incoporate these into the\n-                                        // SVH.\n-                                    }\n-                                    DepKind::AllLocalTraitImpls => {\n-                                        // These are already covered by hashing\n-                                        // the HIR.\n-                                        return None\n-                                    }\n-                                    ref other => {\n-                                        bug!(\"Found unexpected DepKind during \\\n-                                              SVH computation: {:?}\",\n-                                             other)\n-                                    }\n-                                }\n-\n-                                Some((item_dep_node, item_hash))\n-                           })\n-                           .collect();\n-            item_hashes.sort_unstable(); // avoid artificial dependencies on item ordering\n-            item_hashes.hash(&mut crate_state);\n-        }\n-\n-        krate.attrs.hash_stable(&mut self.hcx, &mut crate_state);\n-\n-        let crate_hash = crate_state.finish();\n-        self.hashes.insert(DepNode::new_no_params(DepKind::Krate), crate_hash);\n-        debug!(\"calculate_crate_hash: crate_hash={:?}\", crate_hash);\n-    }\n-\n-    fn hash_crate_root_module(&mut self, krate: &'tcx hir::Crate) {\n-        let hir::Crate {\n-            ref module,\n-            // Crate attributes are not copied over to the root `Mod`, so hash\n-            // them explicitly here.\n-            ref attrs,\n-            span,\n-\n-            // These fields are handled separately:\n-            exported_macros: _,\n-            items: _,\n-            trait_items: _,\n-            impl_items: _,\n-            bodies: _,\n-            trait_impls: _,\n-            trait_default_impl: _,\n-            body_ids: _,\n-        } = *krate;\n-\n-        self.compute_and_store_ich_for_item_like(CRATE_DEF_INDEX,\n-                                                 false,\n-                                                 (module, (span, attrs)));\n-        self.compute_and_store_ich_for_item_like(CRATE_DEF_INDEX,\n-                                                 true,\n-                                                 (module, (span, attrs)));\n-    }\n-\n-    fn compute_and_store_ich_for_trait_impls(&mut self, krate: &'tcx hir::Crate)\n-    {\n-        let tcx = self.tcx;\n-\n-        let mut impls: Vec<(DefPathHash, Fingerprint)> = krate\n-            .trait_impls\n-            .iter()\n-            .map(|(&trait_id, impls)| {\n-                let trait_id = tcx.def_path_hash(trait_id);\n-                let mut impls: AccumulateVec<[_; 32]> = impls\n-                    .iter()\n-                    .map(|&node_id| {\n-                        let def_id = tcx.hir.local_def_id(node_id);\n-                        tcx.def_path_hash(def_id)\n-                    })\n-                    .collect();\n-\n-                impls.sort_unstable();\n-                let mut hasher = StableHasher::new();\n-                impls.hash_stable(&mut self.hcx, &mut hasher);\n-                (trait_id, hasher.finish())\n-            })\n-            .collect();\n-\n-        impls.sort_unstable();\n-\n-        let mut default_impls: AccumulateVec<[_; 32]> = krate\n-            .trait_default_impl\n-            .iter()\n-            .map(|(&trait_def_id, &impl_node_id)| {\n-                let impl_def_id = tcx.hir.local_def_id(impl_node_id);\n-                (tcx.def_path_hash(trait_def_id), tcx.def_path_hash(impl_def_id))\n-            })\n-            .collect();\n-\n-        default_impls.sort_unstable();\n-\n-        let mut hasher = StableHasher::new();\n-        impls.hash_stable(&mut self.hcx, &mut hasher);\n-\n-        self.hashes.insert(DepNode::new_no_params(DepKind::AllLocalTraitImpls),\n-                           hasher.finish());\n-    }\n-}\n-\n-impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for ComputeItemHashesVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        let def_index = self.tcx.hir.local_def_id(item.id).index;\n-        self.compute_and_store_ich_for_item_like(def_index,\n-                                                 false,\n-                                                 item);\n-        self.compute_and_store_ich_for_item_like(def_index,\n-                                                 true,\n-                                                 item);\n-    }\n-\n-    fn visit_trait_item(&mut self, item: &'tcx hir::TraitItem) {\n-        let def_index = self.tcx.hir.local_def_id(item.id).index;\n-        self.compute_and_store_ich_for_item_like(def_index,\n-                                                 false,\n-                                                 item);\n-        self.compute_and_store_ich_for_item_like(def_index,\n-                                                 true,\n-                                                 item);\n-    }\n-\n-    fn visit_impl_item(&mut self, item: &'tcx hir::ImplItem) {\n-        let def_index = self.tcx.hir.local_def_id(item.id).index;\n-        self.compute_and_store_ich_for_item_like(def_index,\n-                                                 false,\n-                                                 item);\n-        self.compute_and_store_ich_for_item_like(def_index,\n-                                                 true,\n-                                                 item);\n-    }\n-}\n-\n-\n-\n-pub fn compute_incremental_hashes_map<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                                    -> IncrementalHashesMap {\n-    let _ignore = tcx.dep_graph.in_ignore();\n-    let krate = tcx.hir.krate();\n-\n-    let mut visitor = ComputeItemHashesVisitor {\n-        tcx,\n-        hcx: tcx.create_stable_hashing_context(),\n-        hashes: IncrementalHashesMap::new(),\n-    };\n-\n-    record_time(&tcx.sess.perf_stats.incr_comp_hashes_time, || {\n-        visitor.hash_crate_root_module(krate);\n-        krate.visit_all_item_likes(&mut visitor);\n-\n-        for macro_def in krate.exported_macros.iter() {\n-            let def_index = tcx.hir.local_def_id(macro_def.id).index;\n-            visitor.compute_and_store_ich_for_item_like(def_index,\n-                                                        false,\n-                                                        macro_def);\n-            visitor.compute_and_store_ich_for_item_like(def_index,\n-                                                        true,\n-                                                        macro_def);\n-        }\n-\n-        visitor.compute_and_store_ich_for_trait_impls(krate);\n-    });\n-\n-    tcx.sess.perf_stats.incr_comp_hashes_count.set(visitor.hashes.len() as u64);\n-\n-    record_time(&tcx.sess.perf_stats.svh_time, || visitor.compute_crate_hash());\n-    visitor.hashes\n-}"}, {"sha": "6817856fdb1db44dbea35e61fa72e8606213c2f8", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47d14ccd514f00fbdc46c02156438a62b1f29527/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d14ccd514f00fbdc46c02156438a62b1f29527/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=47d14ccd514f00fbdc46c02156438a62b1f29527", "patch": "@@ -28,13 +28,9 @@ extern crate syntax;\n extern crate syntax_pos;\n \n mod assert_dep_graph;\n-mod calculate_svh;\n mod persist;\n \n pub use assert_dep_graph::assert_dep_graph;\n-pub use calculate_svh::compute_incremental_hashes_map;\n-pub use calculate_svh::IncrementalHashesMap;\n-pub use calculate_svh::IchHasher;\n pub use persist::load_dep_graph;\n pub use persist::save_dep_graph;\n pub use persist::save_trans_partition;"}, {"sha": "0d6257e4245777c16a7ac8964c76f9c78c0a858d", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/47d14ccd514f00fbdc46c02156438a62b1f29527/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d14ccd514f00fbdc46c02156438a62b1f29527/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=47d14ccd514f00fbdc46c02156438a62b1f29527", "patch": "@@ -11,18 +11,17 @@\n //! Code to save/load the dep-graph from files.\n \n use rustc::dep_graph::{DepNode, WorkProductId, DepKind};\n-use rustc::hir::def_id::DefId;\n use rustc::hir::svh::Svh;\n use rustc::ich::Fingerprint;\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n+use rustc::util::nodemap::DefIdMap;\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_serialize::Decodable as RustcDecodable;\n use rustc_serialize::opaque::Decoder;\n use std::path::{Path};\n \n-use IncrementalHashesMap;\n use super::data::*;\n use super::dirty_clean;\n use super::hash::*;\n@@ -40,17 +39,15 @@ pub type DirtyNodes = FxHashMap<DepNodeIndex, DepNodeIndex>;\n /// early in compilation, before we've really done any work, but\n /// actually it doesn't matter all that much.) See `README.md` for\n /// more general overview.\n-pub fn load_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                incremental_hashes_map: &IncrementalHashesMap) {\n+pub fn load_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     tcx.precompute_in_scope_traits_hashes();\n     if tcx.sess.incr_session_load_dep_graph() {\n         let _ignore = tcx.dep_graph.in_ignore();\n-        load_dep_graph_if_exists(tcx, incremental_hashes_map);\n+        load_dep_graph_if_exists(tcx);\n     }\n }\n \n-fn load_dep_graph_if_exists<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                      incremental_hashes_map: &IncrementalHashesMap) {\n+fn load_dep_graph_if_exists<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let dep_graph_path = dep_graph_path(tcx.sess);\n     let dep_graph_data = match load_data(tcx.sess, &dep_graph_path) {\n         Some(p) => p,\n@@ -63,7 +60,7 @@ fn load_dep_graph_if_exists<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         None => return // no file\n     };\n \n-    match decode_dep_graph(tcx, incremental_hashes_map, &dep_graph_data, &work_products_data) {\n+    match decode_dep_graph(tcx, &dep_graph_data, &work_products_data) {\n         Ok(dirty_nodes) => dirty_nodes,\n         Err(err) => {\n             tcx.sess.warn(\n@@ -118,7 +115,6 @@ fn does_still_exist(tcx: TyCtxt, dep_node: &DepNode) -> bool {\n /// Decode the dep graph and load the edges/nodes that are still clean\n /// into `tcx.dep_graph`.\n pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                  incremental_hashes_map: &IncrementalHashesMap,\n                                   dep_graph_data: &[u8],\n                                   work_products_data: &[u8])\n                                   -> Result<(), String>\n@@ -193,9 +189,6 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     dirty_clean::check_dirty_clean_annotations(tcx,\n                                                &serialized_dep_graph.nodes,\n                                                &dirty_raw_nodes);\n-\n-    load_prev_metadata_hashes(tcx,\n-                              &mut *incremental_hashes_map.prev_metadata_hashes.borrow_mut());\n     Ok(())\n }\n \n@@ -309,11 +302,12 @@ fn delete_dirty_work_product(tcx: TyCtxt,\n     work_product::delete_workproduct_files(tcx.sess, &swp.work_product);\n }\n \n-fn load_prev_metadata_hashes(tcx: TyCtxt,\n-                             output: &mut FxHashMap<DefId, Fingerprint>) {\n+pub fn load_prev_metadata_hashes(tcx: TyCtxt) -> DefIdMap<Fingerprint> {\n+    let mut output = DefIdMap();\n+\n     if !tcx.sess.opts.debugging_opts.query_dep_graph {\n         // Previous metadata hashes are only needed for testing.\n-        return\n+        return output\n     }\n \n     debug!(\"load_prev_metadata_hashes() - Loading previous metadata hashes\");\n@@ -323,7 +317,7 @@ fn load_prev_metadata_hashes(tcx: TyCtxt,\n     if !file_path.exists() {\n         debug!(\"load_prev_metadata_hashes() - Couldn't find file containing \\\n                 hashes at `{}`\", file_path.display());\n-        return\n+        return output\n     }\n \n     debug!(\"load_prev_metadata_hashes() - File: {}\", file_path.display());\n@@ -333,12 +327,12 @@ fn load_prev_metadata_hashes(tcx: TyCtxt,\n         Ok(None) => {\n             debug!(\"load_prev_metadata_hashes() - File produced by incompatible \\\n                     compiler version: {}\", file_path.display());\n-            return\n+            return output\n         }\n         Err(err) => {\n             debug!(\"load_prev_metadata_hashes() - Error reading file `{}`: {}\",\n                    file_path.display(), err);\n-            return\n+            return output\n         }\n     };\n \n@@ -362,6 +356,8 @@ fn load_prev_metadata_hashes(tcx: TyCtxt,\n \n     debug!(\"load_prev_metadata_hashes() - successfully loaded {} hashes\",\n            serialized_hashes.index_map.len());\n+\n+    output\n }\n \n fn process_edge<'a, 'tcx, 'edges>("}, {"sha": "e2d03fcb0e1c819ed53ca644c8bf8a34ff5a010b", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/47d14ccd514f00fbdc46c02156438a62b1f29527/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d14ccd514f00fbdc46c02156438a62b1f29527/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=47d14ccd514f00fbdc46c02156438a62b1f29527", "patch": "@@ -15,6 +15,7 @@ use rustc::ich::Fingerprint;\n use rustc::middle::cstore::EncodedMetadataHashes;\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n+use rustc::util::nodemap::DefIdMap;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::graph;\n use rustc_data_structures::indexed_vec::IndexVec;\n@@ -24,7 +25,6 @@ use std::io::{self, Cursor, Write};\n use std::fs::{self, File};\n use std::path::PathBuf;\n \n-use IncrementalHashesMap;\n use super::data::*;\n use super::hash::*;\n use super::preds::*;\n@@ -33,8 +33,9 @@ use super::dirty_clean;\n use super::file_format;\n use super::work_product;\n \n+use super::load::load_prev_metadata_hashes;\n+\n pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                incremental_hashes_map: IncrementalHashesMap,\n                                 metadata_hashes: &EncodedMetadataHashes,\n                                 svh: Svh) {\n     debug!(\"save_dep_graph()\");\n@@ -51,6 +52,14 @@ pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         eprintln!(\"incremental: {} edges in dep-graph\", query.graph.len_edges());\n     }\n \n+    // We load the previous metadata hashes now before overwriting the file\n+    // (if we need them for testing).\n+    let prev_metadata_hashes = if tcx.sess.opts.debugging_opts.query_dep_graph {\n+        load_prev_metadata_hashes(tcx)\n+    } else {\n+        DefIdMap()\n+    };\n+\n     let mut hcx = HashContext::new(tcx);\n     let preds = Predecessors::new(&query, &mut hcx);\n     let mut current_metadata_hashes = FxHashMap();\n@@ -73,9 +82,8 @@ pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             dep_graph_path(sess),\n             |e| encode_dep_graph(tcx, &preds, e));\n \n-    let prev_metadata_hashes = incremental_hashes_map.prev_metadata_hashes.borrow();\n     dirty_clean::check_dirty_clean_metadata(tcx,\n-                                            &*prev_metadata_hashes,\n+                                            &prev_metadata_hashes,\n                                             &current_metadata_hashes);\n }\n "}, {"sha": "9d13d4ce15b79e9bb544dc51a21d94a2225c9749", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/47d14ccd514f00fbdc46c02156438a62b1f29527/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d14ccd514f00fbdc46c02156438a62b1f29527/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=47d14ccd514f00fbdc46c02156438a62b1f29527", "patch": "@@ -20,17 +20,16 @@ use rustc::session::config::{self, NoDebugInfo, OutputFilenames, OutputType, Pri\n use rustc::session::filesearch;\n use rustc::session::search_paths::PathKind;\n use rustc::session::Session;\n+use rustc::ich::Fingerprint;\n use rustc::middle::cstore::{LinkMeta, NativeLibrary, LibSource, NativeLibraryKind};\n use rustc::middle::dependency_format::Linkage;\n use {CrateTranslation, CrateInfo};\n use rustc::util::common::time;\n use rustc::util::fs::fix_windows_verbatim_for_gcc;\n-use rustc::dep_graph::{DepKind, DepNode};\n use rustc::hir::def_id::CrateNum;\n use rustc::hir::svh::Svh;\n use rustc_back::tempdir::TempDir;\n use rustc_back::{PanicStrategy, RelroLevel};\n-use rustc_incremental::IncrementalHashesMap;\n use context::get_reloc_model;\n use llvm;\n \n@@ -92,10 +91,9 @@ pub const RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET: usize =\n pub use self::rustc_trans_utils::link::{find_crate_name, filename_for_input,\n                                         default_output_for_target, invalid_output_for_target};\n \n-pub fn build_link_meta(incremental_hashes_map: &IncrementalHashesMap) -> LinkMeta {\n-    let krate_dep_node = &DepNode::new_no_params(DepKind::Krate);\n+pub fn build_link_meta(crate_hash: Fingerprint) -> LinkMeta {\n     let r = LinkMeta {\n-        crate_hash: Svh::new(incremental_hashes_map[krate_dep_node].to_smaller_hash()),\n+        crate_hash: Svh::new(crate_hash.to_smaller_hash()),\n     };\n     info!(\"{:?}\", r);\n     return r;"}, {"sha": "bfa18d84d2705add24ac9d30830a1a42f7813544", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/47d14ccd514f00fbdc46c02156438a62b1f29527/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d14ccd514f00fbdc46c02156438a62b1f29527/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=47d14ccd514f00fbdc46c02156438a62b1f29527", "patch": "@@ -41,12 +41,13 @@ use rustc::middle::trans::{Linkage, Visibility, Stats};\n use rustc::middle::cstore::{EncodedMetadata, EncodedMetadataHashes};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::maps::Providers;\n+use rustc::dep_graph::{DepNode, DepKind};\n use rustc::middle::cstore::{self, LinkMeta, LinkagePreference};\n use rustc::hir::map as hir_map;\n use rustc::util::common::{time, print_time_passes_entry};\n use rustc::session::config::{self, NoDebugInfo};\n use rustc::session::Session;\n-use rustc_incremental::{self, IncrementalHashesMap};\n+use rustc_incremental;\n use abi;\n use allocator;\n use mir::lvalue::LvalueRef;\n@@ -935,12 +936,15 @@ pub fn find_exported_symbols(tcx: TyCtxt) -> NodeSet {\n }\n \n pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             incremental_hashes_map: IncrementalHashesMap,\n                              rx: mpsc::Receiver<Box<Any + Send>>)\n                              -> OngoingCrateTranslation {\n     check_for_rustc_errors_attr(tcx);\n \n-    let link_meta = link::build_link_meta(&incremental_hashes_map);\n+\n+    let crate_hash = tcx.dep_graph\n+                        .fingerprint_of(&DepNode::new_no_params(DepKind::Krate))\n+                        .unwrap();\n+    let link_meta = link::build_link_meta(crate_hash);\n     let exported_symbol_node_ids = find_exported_symbols(tcx);\n \n     let shared_ccx = SharedCrateContext::new(tcx);\n@@ -980,7 +984,6 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         ongoing_translation.translation_finished(tcx);\n \n         assert_and_save_dep_graph(tcx,\n-                                  incremental_hashes_map,\n                                   metadata_incr_hashes,\n                                   link_meta);\n \n@@ -1113,7 +1116,6 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     ongoing_translation.check_for_errors(tcx.sess);\n \n     assert_and_save_dep_graph(tcx,\n-                              incremental_hashes_map,\n                               metadata_incr_hashes,\n                               link_meta);\n     ongoing_translation\n@@ -1124,7 +1126,6 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n thread_local!(static DISPOSITIONS: RefCell<Vec<(String, Disposition)>> = Default::default());\n \n fn assert_and_save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                       incremental_hashes_map: IncrementalHashesMap,\n                                        metadata_incr_hashes: EncodedMetadataHashes,\n                                        link_meta: LinkMeta) {\n     time(tcx.sess.time_passes(),\n@@ -1134,7 +1135,6 @@ fn assert_and_save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     time(tcx.sess.time_passes(),\n          \"serialize dep graph\",\n          || rustc_incremental::save_dep_graph(tcx,\n-                                              incremental_hashes_map,\n                                               &metadata_incr_hashes,\n                                               link_meta.crate_hash));\n }"}, {"sha": "7c29186f4657f721a5424d5c1c9c736569dc76bf", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/47d14ccd514f00fbdc46c02156438a62b1f29527/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d14ccd514f00fbdc46c02156438a62b1f29527/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=47d14ccd514f00fbdc46c02156438a62b1f29527", "patch": "@@ -108,11 +108,12 @@ use rustc::dep_graph::{DepNode, WorkProductId};\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;\n use rustc::middle::trans::{Linkage, Visibility};\n+use rustc::ich::Fingerprint;\n use rustc::session::config::NUMBERED_CODEGEN_UNIT_MARKER;\n use rustc::ty::{self, TyCtxt, InstanceDef};\n use rustc::ty::item_path::characteristic_def_id_of_type;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n-use rustc_incremental::IchHasher;\n+use rustc_data_structures::stable_hasher::StableHasher;\n use std::collections::hash_map::Entry;\n use std::hash::Hash;\n use syntax::ast::NodeId;\n@@ -155,7 +156,7 @@ pub trait CodegenUnitExt<'tcx> {\n     }\n \n     fn compute_symbol_name_hash<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> u64 {\n-        let mut state = IchHasher::new();\n+        let mut state: StableHasher<Fingerprint> = StableHasher::new();\n         let all_items = self.items_in_deterministic_order(tcx);\n         for (item, (linkage, visibility)) in all_items {\n             let symbol_name = item.symbol_name(tcx);"}, {"sha": "2ecb7b546fce2d5ba39a173023aeb8014154c01b", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47d14ccd514f00fbdc46c02156438a62b1f29527/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d14ccd514f00fbdc46c02156438a62b1f29527/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=47d14ccd514f00fbdc46c02156438a62b1f29527", "patch": "@@ -175,7 +175,7 @@ pub fn run_core(search_paths: SearchPaths,\n \n     let arena = DroplessArena::new();\n     let arenas = GlobalArenas::new();\n-    let hir_map = hir_map::map_crate(&mut hir_forest, &defs);\n+    let hir_map = hir_map::map_crate(&sess, &*cstore, &mut hir_forest, &defs);\n     let output_filenames = driver::build_output_filenames(&input,\n                                                           &None,\n                                                           &None,\n@@ -191,7 +191,7 @@ pub fn run_core(search_paths: SearchPaths,\n                                                      &arenas,\n                                                      &name,\n                                                      &output_filenames,\n-                                                     |tcx, analysis, _, _, result| {\n+                                                     |tcx, analysis, _, result| {\n         if let Err(_) = result {\n             sess.fatal(\"Compilation failed, aborting rustdoc\");\n         }"}, {"sha": "f9cb4b84545dd6b05cba6a08c446fa9bd86509e1", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47d14ccd514f00fbdc46c02156438a62b1f29527/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d14ccd514f00fbdc46c02156438a62b1f29527/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=47d14ccd514f00fbdc46c02156438a62b1f29527", "patch": "@@ -124,7 +124,7 @@ pub fn run(input: &str,\n                                        render_type);\n \n     {\n-        let map = hir::map::map_crate(&mut hir_forest, &defs);\n+        let map = hir::map::map_crate(&sess, &*cstore, &mut hir_forest, &defs);\n         let krate = map.krate();\n         let mut hir_collector = HirCollector {\n             sess: &sess,"}]}