{"sha": "0e44876a2d37dda4dc57a6eb20588654e5e92562", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlNDQ4NzZhMmQzN2RkYTRkYzU3YTZlYjIwNTg4NjU0ZTVlOTI1NjI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-22T15:26:06Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-12-03T08:15:18Z"}, "message": "fix mutability gap: do not allow shared mutation when creating frozen reference", "tree": {"sha": "9961c7dfd28d6621f1a0755cc25de6f3bf7ba7ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9961c7dfd28d6621f1a0755cc25de6f3bf7ba7ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e44876a2d37dda4dc57a6eb20588654e5e92562", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e44876a2d37dda4dc57a6eb20588654e5e92562", "html_url": "https://github.com/rust-lang/rust/commit/0e44876a2d37dda4dc57a6eb20588654e5e92562", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e44876a2d37dda4dc57a6eb20588654e5e92562/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21fd5fd16895ccd28644134fb19e5771dcc96522", "url": "https://api.github.com/repos/rust-lang/rust/commits/21fd5fd16895ccd28644134fb19e5771dcc96522", "html_url": "https://github.com/rust-lang/rust/commit/21fd5fd16895ccd28644134fb19e5771dcc96522"}], "stats": {"total": 113, "additions": 82, "deletions": 31}, "files": [{"sha": "a90be317705a8ff203e4aff8630d6d78ae7e46f9", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0e44876a2d37dda4dc57a6eb20588654e5e92562/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e44876a2d37dda4dc57a6eb20588654e5e92562/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=0e44876a2d37dda4dc57a6eb20588654e5e92562", "patch": "@@ -303,14 +303,30 @@ impl<'tcx> Stack {\n     /// is met: We cannot push `Uniq` onto frozen stacks.\n     /// `kind` indicates which kind of reference is being created.\n     fn create(&mut self, bor: Borrow, kind: RefKind) {\n-        if self.frozen_since.is_some() {\n-            // A frozen location?  Possible if we create a barrier, then push again.\n-            assert!(bor.is_shared(), \"We should never try creating a unique borrow for a frozen stack\");\n-            trace!(\"create: Not doing anything on frozen location\");\n+        // When creating a frozen reference, freeze.  This ensures F1.\n+        // We also do *not* push anything else to the stack, making sure that no nother kind\n+        // of access (like writing through raw pointers) is permitted.\n+        if kind == RefKind::Frozen {\n+            let bor_t = match bor {\n+                Borrow::Shr(Some(t)) => t,\n+                _ => bug!(\"Creating illegal borrow {:?} for frozen ref\", bor),\n+            };\n+            // It is possible that we already are frozen (e.g. if we just pushed a barrier,\n+            // the redundancy check would not have kicked in).\n+            match self.frozen_since {\n+                Some(loc_t) => assert!(loc_t <= bor_t, \"Trying to freeze location for longer than it was already frozen\"),\n+                None => {\n+                    trace!(\"create: Freezing\");\n+                    self.frozen_since = Some(bor_t);\n+                }\n+            }\n             return;\n         }\n-        // First, push.  We do this even if we will later freeze, because we\n-        // will allow mutation of shared data at the expense of unfreezing.\n+        if self.frozen_since.is_some() {\n+            bug!(\"Trying to create non-frozen reference to frozen location\");\n+        }\n+\n+        // Push new item to the stack.\n         let itm = match bor {\n             Borrow::Uniq(t) => BorStackItem::Uniq(t),\n             Borrow::Shr(_) => BorStackItem::Shr,\n@@ -325,15 +341,6 @@ impl<'tcx> Stack {\n             trace!(\"create: Pushing {:?}\", itm);\n             self.borrows.push(itm);\n         }\n-        // Then, maybe freeze.  This is part 2 of ensuring F1.\n-        if kind == RefKind::Frozen {\n-            let bor_t = match bor {\n-                Borrow::Shr(Some(t)) => t,\n-                _ => bug!(\"Creating illegal borrow {:?} for frozen ref\", bor),\n-            };\n-            trace!(\"create: Freezing\");\n-            self.frozen_since = Some(bor_t);\n-        }\n     }\n \n     /// Add a barrier"}, {"sha": "a653aa5003f6d4da712027e3f1abe154941ccffe", "filename": "tests/compile-fail-fullmir/stacked_borrows/illegal_write3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e44876a2d37dda4dc57a6eb20588654e5e92562/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fillegal_write3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e44876a2d37dda4dc57a6eb20588654e5e92562/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fillegal_write3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fillegal_write3.rs?ref=0e44876a2d37dda4dc57a6eb20588654e5e92562", "patch": "@@ -3,6 +3,6 @@ fn main() {\n     // Make sure raw ptr with raw tag cannot mutate frozen location without breaking the shared ref.\n     let r#ref = &target; // freeze\n     let ptr = r#ref as *const _ as *mut _; // raw ptr, with raw tag\n-    unsafe { *ptr = 42; }\n-    let _val = *r#ref; //~ ERROR is not frozen\n+    unsafe { *ptr = 42; } //~ ERROR does not exist on the stack\n+    let _val = *r#ref;\n }"}, {"sha": "22a80e27103e1ec126c86de0664ca8c89fde6f07", "filename": "tests/compile-fail-fullmir/stacked_borrows/pass_invalid_shr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e44876a2d37dda4dc57a6eb20588654e5e92562/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fpass_invalid_shr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e44876a2d37dda4dc57a6eb20588654e5e92562/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fpass_invalid_shr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fpass_invalid_shr.rs?ref=0e44876a2d37dda4dc57a6eb20588654e5e92562", "patch": "@@ -3,7 +3,7 @@ fn foo(_: &i32) {}\n \n fn main() {\n     let x = &mut 42;\n-    let xraw = &*x as *const _ as *mut _;\n+    let xraw = x as *mut _;\n     let xref = unsafe { &*xraw };\n     unsafe { *xraw = 42 }; // unfreeze\n     foo(xref); //~ ERROR is not frozen"}, {"sha": "560c9dfb665dd518d2474531f54d1a1d80f1a25e", "filename": "tests/compile-fail-fullmir/stacked_borrows/shr_frozen_violation1.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0e44876a2d37dda4dc57a6eb20588654e5e92562/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fshr_frozen_violation1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e44876a2d37dda4dc57a6eb20588654e5e92562/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fshr_frozen_violation1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fshr_frozen_violation1.rs?ref=0e44876a2d37dda4dc57a6eb20588654e5e92562", "patch": "@@ -0,0 +1,16 @@\n+fn foo(x: &mut i32) -> i32 {\n+  *x = 5;\n+  unknown_code(&*x);\n+  *x // must return 5\n+}\n+\n+fn main() {\n+    println!(\"{}\", foo(&mut 0));\n+}\n+\n+// If we replace the `*const` by `&`, my current dev version of miri\n+// *does* find the problem, but not for a good reason: It finds it because\n+// of barriers, and we shouldn't rely on unknown code using barriers.\n+fn unknown_code(x: *const i32) {\n+    unsafe { *(x as *mut i32) = 7; } //~ ERROR barrier\n+}"}, {"sha": "0bc8b15c5f24ebbf2aed0659ce99378d500578f6", "filename": "tests/run-pass/refcell.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0e44876a2d37dda4dc57a6eb20588654e5e92562/tests%2Frun-pass%2Frefcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e44876a2d37dda4dc57a6eb20588654e5e92562/tests%2Frun-pass%2Frefcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Frefcell.rs?ref=0e44876a2d37dda4dc57a6eb20588654e5e92562", "patch": "@@ -39,6 +39,13 @@ fn aliasing_mut_and_shr() {\n         *aliasing += 4;\n         let _shr = &*rc;\n         *aliasing += 4;\n+        // also turning this into a frozen ref now must work\n+        let aliasing = &*aliasing;\n+        let _val = *aliasing;\n+        let _escape_to_raw = rc as *const _; // this must NOT unfreeze\n+        let _val = *aliasing;\n+        let _shr = &*rc; // this must NOT unfreeze\n+        let _val = *aliasing;\n     }\n \n     let rc = RefCell::new(23);\n@@ -48,7 +55,23 @@ fn aliasing_mut_and_shr() {\n     assert_eq!(*rc.borrow(), 23+12);\n }\n \n+fn aliasing_frz_and_shr() {\n+    fn inner(rc: &RefCell<i32>, aliasing: &i32) {\n+        let _val = *aliasing;\n+        let _escape_to_raw = rc as *const _; // this must NOT unfreeze\n+        let _val = *aliasing;\n+        let _shr = &*rc; // this must NOT unfreeze\n+        let _val = *aliasing;\n+    }\n+\n+    let rc = RefCell::new(23);\n+    let bshr = rc.borrow();\n+    inner(&rc, &*bshr);\n+    assert_eq!(*rc.borrow(), 23);\n+}\n+\n fn main() {\n     lots_of_funny_borrows();\n     aliasing_mut_and_shr();\n+    aliasing_frz_and_shr();\n }"}, {"sha": "388765c29eabd6ff1f646df758852e1fe85e8e9f", "filename": "tests/run-pass/stacked-borrows.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0e44876a2d37dda4dc57a6eb20588654e5e92562/tests%2Frun-pass%2Fstacked-borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e44876a2d37dda4dc57a6eb20588654e5e92562/tests%2Frun-pass%2Fstacked-borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fstacked-borrows.rs?ref=0e44876a2d37dda4dc57a6eb20588654e5e92562", "patch": "@@ -4,10 +4,11 @@ fn main() {\n     read_does_not_invalidate1();\n     read_does_not_invalidate2();\n     ref_raw_int_raw();\n-    mut_shr_raw();\n     mut_raw_then_mut_shr();\n+    mut_shr_then_mut_raw();\n     mut_raw_mut();\n     partially_invalidate_mut();\n+    drop_after_sharing();\n }\n \n // Deref a raw ptr to access a field of a large struct, where the field\n@@ -53,18 +54,6 @@ fn ref_raw_int_raw() {\n     assert_eq!(unsafe { *xraw }, 3);\n }\n \n-// Creating a raw from a `&mut` through an `&` works, even if we\n-// write through that raw.\n-fn mut_shr_raw() {\n-    let mut x = 2;\n-    {\n-        let xref = &mut x;\n-        let xraw = &*xref as *const i32 as *mut i32;\n-        unsafe { *xraw = 4; }\n-    }\n-    assert_eq!(x, 4);\n-}\n-\n // Escape a mut to raw, then share the same mut and use the share, then the raw.\n // That should work.\n fn mut_raw_then_mut_shr() {\n@@ -77,6 +66,16 @@ fn mut_raw_then_mut_shr() {\n     assert_eq!(x, 4);\n }\n \n+// Create first a shared reference and then a raw pointer from a `&mut`\n+// should permit mutation through that raw pointer.\n+fn mut_shr_then_mut_raw() {\n+    let xref = &mut 2;\n+    let _xshr = &*xref;\n+    let xraw = xref as *mut _;\n+    unsafe { *xraw = 3; }\n+    assert_eq!(*xref, 3);\n+}\n+\n // Ensure that if we derive from a mut a raw, and then from that a mut,\n // and then read through the original mut, that does not invalidate the raw.\n // This shows that the read-exception for `&mut` applies even if the `Shr` item\n@@ -107,3 +106,9 @@ fn partially_invalidate_mut() {\n     *shard += 1; // so we can still use `shard`.\n     assert_eq!(*data, (1, 1));\n }\n+\n+// Make sure that we can handle the situation where a loaction is frozen when being dropped.\n+fn drop_after_sharing() {\n+    let x = String::from(\"hello!\");\n+    let _len = x.len();\n+}"}]}