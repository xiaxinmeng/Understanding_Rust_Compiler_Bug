{"sha": "5012d7fb53d9f1e489c1ae1a081347fddbbffe5f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwMTJkN2ZiNTNkOWYxZTQ4OWMxYWUxYTA4MTM0N2ZkZGJiZmZlNWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-13T09:12:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-13T09:12:51Z"}, "message": "Auto merge of #57566 - Centril:const-stabilize-overflowing, r=alexreg\n\nConst-stabilize `const_int_overflowing`\n\nFixes https://github.com/rust-lang/rust/issues/57237.\n\nr? @alexreg", "tree": {"sha": "d310753c22ca69e2d076366dab73616ce87b31f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d310753c22ca69e2d076366dab73616ce87b31f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5012d7fb53d9f1e489c1ae1a081347fddbbffe5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5012d7fb53d9f1e489c1ae1a081347fddbbffe5f", "html_url": "https://github.com/rust-lang/rust/commit/5012d7fb53d9f1e489c1ae1a081347fddbbffe5f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5012d7fb53d9f1e489c1ae1a081347fddbbffe5f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75a369c5b11459baa6bf7734eeb6135998a0a7de", "url": "https://api.github.com/repos/rust-lang/rust/commits/75a369c5b11459baa6bf7734eeb6135998a0a7de", "html_url": "https://github.com/rust-lang/rust/commit/75a369c5b11459baa6bf7734eeb6135998a0a7de"}, {"sha": "b172e89c148d11afc85147294c47496bda48fce7", "url": "https://api.github.com/repos/rust-lang/rust/commits/b172e89c148d11afc85147294c47496bda48fce7", "html_url": "https://github.com/rust-lang/rust/commit/b172e89c148d11afc85147294c47496bda48fce7"}], "stats": {"total": 88, "additions": 58, "deletions": 30}, "files": [{"sha": "8879112fcf0b96bff209558af0c6dcbef975b7a5", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5012d7fb53d9f1e489c1ae1a081347fddbbffe5f/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5012d7fb53d9f1e489c1ae1a081347fddbbffe5f/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=5012d7fb53d9f1e489c1ae1a081347fddbbffe5f", "patch": "@@ -114,6 +114,7 @@\n #![feature(const_slice_len)]\n #![feature(const_str_as_bytes)]\n #![feature(const_str_len)]\n+#![cfg_attr(stage0, feature(const_let))]\n #![cfg_attr(stage0, feature(const_int_rotate))]\n #![feature(const_int_conversion)]\n #![feature(const_transmute)]"}, {"sha": "5326ef1e7c12e1efe68a462dbec62e6dfd5e7754", "filename": "src/libcore/num/bignum.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5012d7fb53d9f1e489c1ae1a081347fddbbffe5f/src%2Flibcore%2Fnum%2Fbignum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5012d7fb53d9f1e489c1ae1a081347fddbbffe5f/src%2Flibcore%2Fnum%2Fbignum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fbignum.rs?ref=5012d7fb53d9f1e489c1ae1a081347fddbbffe5f", "patch": "@@ -46,25 +46,37 @@ macro_rules! impl_full_ops {\n     ($($ty:ty: add($addfn:path), mul/div($bigty:ident);)*) => (\n         $(\n             impl FullOps for $ty {\n+                #[cfg(stage0)]\n                 fn full_add(self, other: $ty, carry: bool) -> (bool, $ty) {\n-                    // this cannot overflow, the output is between 0 and 2*2^nbits - 1\n-                    // FIXME will LLVM optimize this into ADC or similar???\n+                    // This cannot overflow; the output is between `0` and `2 * 2^nbits - 1`.\n+                    // FIXME: will LLVM optimize this into ADC or similar?\n                     let (v, carry1) = unsafe { intrinsics::add_with_overflow(self, other) };\n                     let (v, carry2) = unsafe {\n                         intrinsics::add_with_overflow(v, if carry {1} else {0})\n                     };\n                     (carry1 || carry2, v)\n                 }\n+                #[cfg(not(stage0))]\n+                fn full_add(self, other: $ty, carry: bool) -> (bool, $ty) {\n+                    // This cannot overflow; the output is between `0` and `2 * 2^nbits - 1`.\n+                    // FIXME: will LLVM optimize this into ADC or similar?\n+                    let (v, carry1) = intrinsics::add_with_overflow(self, other);\n+                    let (v, carry2) = intrinsics::add_with_overflow(v, if carry {1} else {0});\n+                    (carry1 || carry2, v)\n+                }\n \n                 fn full_mul(self, other: $ty, carry: $ty) -> ($ty, $ty) {\n-                    // this cannot overflow, the output is between 0 and 2^nbits * (2^nbits - 1)\n+                    // This cannot overflow;\n+                    // the output is between `0` and `2^nbits * (2^nbits - 1)`.\n+                    // FIXME: will LLVM optimize this into ADC or similar?\n                     let nbits = mem::size_of::<$ty>() * 8;\n                     let v = (self as $bigty) * (other as $bigty) + (carry as $bigty);\n                     ((v >> nbits) as $ty, v as $ty)\n                 }\n \n                 fn full_mul_add(self, other: $ty, other2: $ty, carry: $ty) -> ($ty, $ty) {\n-                    // this cannot overflow, the output is between 0 and 2^(2*nbits) - 1\n+                    // This cannot overflow;\n+                    // the output is between `0` and `2^nbits * (2^nbits - 1)`.\n                     let nbits = mem::size_of::<$ty>() * 8;\n                     let v = (self as $bigty) * (other as $bigty) + (other2 as $bigty) +\n                             (carry as $bigty);\n@@ -73,7 +85,7 @@ macro_rules! impl_full_ops {\n \n                 fn full_div_rem(self, other: $ty, borrow: $ty) -> ($ty, $ty) {\n                     debug_assert!(borrow < other);\n-                    // this cannot overflow, the dividend is between 0 and other * 2^nbits - 1\n+                    // This cannot overflow; the output is between `0` and `other * (2^nbits - 1)`.\n                     let nbits = mem::size_of::<$ty>() * 8;\n                     let lhs = ((borrow as $bigty) << nbits) | (self as $bigty);\n                     let rhs = other as $bigty;\n@@ -88,7 +100,8 @@ impl_full_ops! {\n     u8:  add(intrinsics::u8_add_with_overflow),  mul/div(u16);\n     u16: add(intrinsics::u16_add_with_overflow), mul/div(u32);\n     u32: add(intrinsics::u32_add_with_overflow), mul/div(u64);\n-//  u64: add(intrinsics::u64_add_with_overflow), mul/div(u128); // see RFC #521 for enabling this.\n+    // See RFC #521 for enabling this.\n+    // u64: add(intrinsics::u64_add_with_overflow), mul/div(u128);\n }\n \n /// Table of powers of 5 representable in digits. Specifically, the largest {u8, u16, u32} value"}, {"sha": "6827364c0f805d34f153596b93d8cefe9cefe5f3", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 34, "deletions": 22, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/5012d7fb53d9f1e489c1ae1a081347fddbbffe5f/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5012d7fb53d9f1e489c1ae1a081347fddbbffe5f/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=5012d7fb53d9f1e489c1ae1a081347fddbbffe5f", "patch": "@@ -1340,13 +1340,15 @@ assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (\", stringify!($Sel\n \"::MIN, true));\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-            #[rustc_const_unstable(feature = \"const_int_overflowing\")]\n+            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_overflowing\"))]\n             #[inline]\n             pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n+                #[cfg(stage0)]\n                 let (a, b) = unsafe {\n-                    intrinsics::add_with_overflow(self as $ActualT,\n-                                                  rhs as $ActualT)\n+                    intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT)\n                 };\n+                #[cfg(not(stage0))]\n+                let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n                 (a as Self, b)\n             }\n         }\n@@ -1369,13 +1371,15 @@ assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_sub(1), (\", stringify!($Sel\n \"::MAX, true));\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-            #[rustc_const_unstable(feature = \"const_int_overflowing\")]\n+            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_overflowing\"))]\n             #[inline]\n             pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n+                #[cfg(stage0)]\n                 let (a, b) = unsafe {\n-                    intrinsics::sub_with_overflow(self as $ActualT,\n-                                                  rhs as $ActualT)\n+                    intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT)\n                 };\n+                #[cfg(not(stage0))]\n+                let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);\n                 (a as Self, b)\n             }\n         }\n@@ -1396,13 +1400,15 @@ assert_eq!(1_000_000_000i32.overflowing_mul(10), (1410065408, true));\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-            #[rustc_const_unstable(feature = \"const_int_overflowing\")]\n+            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_overflowing\"))]\n             #[inline]\n             pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n+                #[cfg(stage0)]\n                 let (a, b) = unsafe {\n-                    intrinsics::mul_with_overflow(self as $ActualT,\n-                                                  rhs as $ActualT)\n+                    intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT)\n                 };\n+                #[cfg(not(stage0))]\n+                let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);\n                 (a as Self, b)\n             }\n         }\n@@ -1585,7 +1591,7 @@ assert_eq!(0x1i32.overflowing_shl(36), (0x10, true));\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-            #[rustc_const_unstable(feature = \"const_int_overflowing\")]\n+            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_overflowing\"))]\n             #[inline]\n             pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n                 (self.wrapping_shl(rhs), (rhs > ($BITS - 1)))\n@@ -1609,7 +1615,7 @@ assert_eq!(0x10i32.overflowing_shr(36), (0x1, true));\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-            #[rustc_const_unstable(feature = \"const_int_overflowing\")]\n+            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_overflowing\"))]\n             #[inline]\n             pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n                 (self.wrapping_shr(rhs), (rhs > ($BITS - 1)))\n@@ -3213,13 +3219,15 @@ assert_eq!(5\", stringify!($SelfT), \".overflowing_add(2), (7, false));\n assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (0, true));\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-            #[rustc_const_unstable(feature = \"const_int_overflowing\")]\n+            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_overflowing\"))]\n             #[inline]\n             pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n+                #[cfg(stage0)]\n                 let (a, b) = unsafe {\n-                    intrinsics::add_with_overflow(self as $ActualT,\n-                                                  rhs as $ActualT)\n+                    intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT)\n                 };\n+                #[cfg(not(stage0))]\n+                let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n                 (a as Self, b)\n             }\n         }\n@@ -3243,13 +3251,15 @@ assert_eq!(0\", stringify!($SelfT), \".overflowing_sub(1), (\", stringify!($SelfT),\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-            #[rustc_const_unstable(feature = \"const_int_overflowing\")]\n+            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_overflowing\"))]\n             #[inline]\n             pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n+                #[cfg(stage0)]\n                 let (a, b) = unsafe {\n-                    intrinsics::sub_with_overflow(self as $ActualT,\n-                                                  rhs as $ActualT)\n+                    intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT)\n                 };\n+                #[cfg(not(stage0))]\n+                let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);\n                 (a as Self, b)\n             }\n         }\n@@ -3272,13 +3282,15 @@ $EndFeature, \"\n         /// assert_eq!(1_000_000_000u32.overflowing_mul(10), (1410065408, true));\n         /// ```\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-        #[rustc_const_unstable(feature = \"const_int_overflowing\")]\n+        #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_overflowing\"))]\n         #[inline]\n         pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n+            #[cfg(stage0)]\n             let (a, b) = unsafe {\n-                intrinsics::mul_with_overflow(self as $ActualT,\n-                                              rhs as $ActualT)\n+                intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT)\n             };\n+            #[cfg(not(stage0))]\n+            let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);\n             (a as Self, b)\n         }\n \n@@ -3436,7 +3448,7 @@ Basic usage\n assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(132), (0x10, true));\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-            #[rustc_const_unstable(feature = \"const_int_overflowing\")]\n+            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_overflowing\"))]\n             #[inline]\n             pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n                 (self.wrapping_shl(rhs), (rhs > ($BITS - 1)))\n@@ -3461,7 +3473,7 @@ Basic usage\n assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(132), (0x1, true));\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-            #[rustc_const_unstable(feature = \"const_int_overflowing\")]\n+            #[cfg_attr(stage0, rustc_const_unstable(feature = \"const_int_overflowing\"))]\n             #[inline]\n             pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n                 (self.wrapping_shr(rhs), (rhs > ($BITS - 1)))"}, {"sha": "059b88a4d702ae923cff4541b5ba0aa5c5b4a703", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5012d7fb53d9f1e489c1ae1a081347fddbbffe5f/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5012d7fb53d9f1e489c1ae1a081347fddbbffe5f/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=5012d7fb53d9f1e489c1ae1a081347fddbbffe5f", "patch": "@@ -374,6 +374,9 @@ fn is_intrinsic_whitelisted(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> bool\n         | \"min_align_of\"\n         | \"needs_drop\"\n         // Arithmetic:\n+        | \"add_with_overflow\" // ~> .overflowing_add\n+        | \"sub_with_overflow\" // ~> .overflowing_sub\n+        | \"mul_with_overflow\" // ~> .overflowing_mul\n         | \"overflowing_add\" // ~> .wrapping_add\n         | \"overflowing_sub\" // ~> .wrapping_sub\n         | \"overflowing_mul\" // ~> .wrapping_mul"}, {"sha": "9f323b9116d6fd7cc3723a6828fe62f556e98b2b", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5012d7fb53d9f1e489c1ae1a081347fddbbffe5f/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5012d7fb53d9f1e489c1ae1a081347fddbbffe5f/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=5012d7fb53d9f1e489c1ae1a081347fddbbffe5f", "patch": "@@ -70,6 +70,7 @@ fn equate_intrinsic_type<'a, 'tcx>(\n pub fn intrisic_operation_unsafety(intrinsic: &str) -> hir::Unsafety {\n     match intrinsic {\n         \"size_of\" | \"min_align_of\" | \"needs_drop\" |\n+        \"add_with_overflow\" | \"sub_with_overflow\" | \"mul_with_overflow\" |\n         \"overflowing_add\" | \"overflowing_sub\" | \"overflowing_mul\" |\n         \"rotate_left\" | \"rotate_right\" |\n         \"ctpop\" | \"ctlz\" | \"cttz\" | \"bswap\" | \"bitreverse\""}, {"sha": "289b1236cf1e214149afed505a62170ab7aea49a", "filename": "src/test/run-pass/const-int-overflowing.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5012d7fb53d9f1e489c1ae1a081347fddbbffe5f/src%2Ftest%2Frun-pass%2Fconst-int-overflowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5012d7fb53d9f1e489c1ae1a081347fddbbffe5f/src%2Ftest%2Frun-pass%2Fconst-int-overflowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-int-overflowing.rs?ref=5012d7fb53d9f1e489c1ae1a081347fddbbffe5f", "patch": "@@ -1,5 +1,3 @@\n-#![feature(const_int_overflowing)]\n-\n const ADD_A: (u32, bool) = 5u32.overflowing_add(2);\n const ADD_B: (u32, bool) = u32::max_value().overflowing_add(1);\n "}]}