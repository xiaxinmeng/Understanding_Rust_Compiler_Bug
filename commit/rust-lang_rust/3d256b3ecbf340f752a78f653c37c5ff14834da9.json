{"sha": "3d256b3ecbf340f752a78f653c37c5ff14834da9", "node_id": "C_kwDOAAsO6NoAKDNkMjU2YjNlY2JmMzQwZjc1MmE3OGY2NTNjMzdjNWZmMTQ4MzRkYTk", "commit": {"author": {"name": "SparrowLii", "email": "liyuan179@huawei.com", "date": "2022-04-21T10:26:43Z"}, "committer": {"name": "SparrowLii", "email": "liyuan179@huawei.com", "date": "2022-04-21T10:26:43Z"}, "message": "access `local_decls` through `ecx`", "tree": {"sha": "567fea90364657f674a5450ac02ec4fc2dffe11c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/567fea90364657f674a5450ac02ec4fc2dffe11c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d256b3ecbf340f752a78f653c37c5ff14834da9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d256b3ecbf340f752a78f653c37c5ff14834da9", "html_url": "https://github.com/rust-lang/rust/commit/3d256b3ecbf340f752a78f653c37c5ff14834da9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d256b3ecbf340f752a78f653c37c5ff14834da9/comments", "author": {"login": "SparrowLii", "id": 68270294, "node_id": "MDQ6VXNlcjY4MjcwMjk0", "avatar_url": "https://avatars.githubusercontent.com/u/68270294?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SparrowLii", "html_url": "https://github.com/SparrowLii", "followers_url": "https://api.github.com/users/SparrowLii/followers", "following_url": "https://api.github.com/users/SparrowLii/following{/other_user}", "gists_url": "https://api.github.com/users/SparrowLii/gists{/gist_id}", "starred_url": "https://api.github.com/users/SparrowLii/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SparrowLii/subscriptions", "organizations_url": "https://api.github.com/users/SparrowLii/orgs", "repos_url": "https://api.github.com/users/SparrowLii/repos", "events_url": "https://api.github.com/users/SparrowLii/events{/privacy}", "received_events_url": "https://api.github.com/users/SparrowLii/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SparrowLii", "id": 68270294, "node_id": "MDQ6VXNlcjY4MjcwMjk0", "avatar_url": "https://avatars.githubusercontent.com/u/68270294?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SparrowLii", "html_url": "https://github.com/SparrowLii", "followers_url": "https://api.github.com/users/SparrowLii/followers", "following_url": "https://api.github.com/users/SparrowLii/following{/other_user}", "gists_url": "https://api.github.com/users/SparrowLii/gists{/gist_id}", "starred_url": "https://api.github.com/users/SparrowLii/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SparrowLii/subscriptions", "organizations_url": "https://api.github.com/users/SparrowLii/orgs", "repos_url": "https://api.github.com/users/SparrowLii/repos", "events_url": "https://api.github.com/users/SparrowLii/events{/privacy}", "received_events_url": "https://api.github.com/users/SparrowLii/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5176945ad49005b82789be5700f5ae0e6efe5481", "url": "https://api.github.com/repos/rust-lang/rust/commits/5176945ad49005b82789be5700f5ae0e6efe5481", "html_url": "https://github.com/rust-lang/rust/commit/5176945ad49005b82789be5700f5ae0e6efe5481"}], "stats": {"total": 63, "additions": 14, "deletions": 49}, "files": [{"sha": "1efc9c37f21e7595370772e18b0e2880ee395cf3", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 6, "deletions": 23, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3d256b3ecbf340f752a78f653c37c5ff14834da9/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d256b3ecbf340f752a78f653c37c5ff14834da9/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=3d256b3ecbf340f752a78f653c37c5ff14834da9", "patch": "@@ -12,9 +12,8 @@ use rustc_middle::mir::visit::{\n     MutVisitor, MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor,\n };\n use rustc_middle::mir::{\n-    BasicBlock, BinOp, Body, Constant, ConstantKind, Local, LocalDecl, LocalKind, Location,\n-    Operand, Place, Rvalue, SourceInfo, Statement, StatementKind, Terminator, TerminatorKind, UnOp,\n-    RETURN_PLACE,\n+    BasicBlock, BinOp, Body, Constant, ConstantKind, Local, LocalKind, Location, Operand, Place,\n+    Rvalue, SourceInfo, Statement, StatementKind, Terminator, TerminatorKind, UnOp, RETURN_PLACE,\n };\n use rustc_middle::ty::layout::{LayoutError, LayoutOf, LayoutOfHelpers, TyAndLayout};\n use rustc_middle::ty::subst::{InternalSubsts, Subst};\n@@ -313,9 +312,6 @@ struct ConstPropagator<'mir, 'tcx> {\n     ecx: InterpCx<'mir, 'tcx, ConstPropMachine<'mir, 'tcx>>,\n     tcx: TyCtxt<'tcx>,\n     param_env: ParamEnv<'tcx>,\n-    // FIXME(eddyb) avoid cloning this field more than once,\n-    // by accessing it through `ecx` instead.\n-    local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n     // Because we have `MutVisitor` we can't obtain the `SourceInfo` from a `Location`. So we store\n     // the last known `SourceInfo` here and just keep revisiting it.\n     source_info: Option<SourceInfo>,\n@@ -361,10 +357,6 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         let substs = &InternalSubsts::identity_for_item(tcx, def_id);\n         let param_env = tcx.param_env_reveal_all_normalized(def_id);\n \n-        let span = tcx.def_span(def_id);\n-        // FIXME: `CanConstProp::check` computes the layout of all locals, return those layouts\n-        // so we can write them to `ecx.frame_mut().locals.layout, reducing the duplication in\n-        // `layout_of` query invocations.\n         let can_const_prop = CanConstProp::check(tcx, param_env, body);\n         let mut only_propagate_inside_block_locals = BitSet::new_empty(can_const_prop.len());\n         for (l, mode) in can_const_prop.iter_enumerated() {\n@@ -374,7 +366,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n         let mut ecx = InterpCx::new(\n             tcx,\n-            span,\n+            tcx.def_span(def_id),\n             param_env,\n             ConstPropMachine::new(only_propagate_inside_block_locals, can_const_prop),\n         );\n@@ -401,16 +393,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         )\n         .expect(\"failed to push initial stack frame\");\n \n-        ConstPropagator {\n-            ecx,\n-            tcx,\n-            param_env,\n-            // FIXME(eddyb) avoid cloning this field more than once,\n-            // by accessing it through `ecx` instead.\n-            //FIXME(wesleywiser) we can't steal this because `Visitor::super_visit_body()` needs it\n-            local_decls: body.local_decls.clone(),\n-            source_info: None,\n-        }\n+        ConstPropagator { ecx, tcx, param_env, source_info: None }\n     }\n \n     fn get_const(&self, place: Place<'tcx>) -> Option<OpTy<'tcx>> {\n@@ -511,7 +494,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             let r = r?;\n             // We need the type of the LHS. We cannot use `place_layout` as that is the type\n             // of the result, which for checked binops is not the same!\n-            let left_ty = left.ty(&self.local_decls, self.tcx);\n+            let left_ty = left.ty(&self.ecx.frame().body.local_decls, self.tcx);\n             let left_size = self.ecx.layout_of(left_ty).ok()?.size;\n             let right_size = r.layout.size;\n             let r_bits = r.to_scalar().ok();\n@@ -1133,7 +1116,7 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n                 assert!(\n                     self.get_const(local.into()).is_none()\n                         || self\n-                            .layout_of(self.local_decls[local].ty)\n+                            .layout_of(self.ecx.frame().body.local_decls[local].ty)\n                             .map_or(true, |layout| layout.is_zst())\n                 )\n             }"}, {"sha": "2bd90998148e76045512f594d0a84d4cfa5eadf9", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 8, "deletions": 26, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3d256b3ecbf340f752a78f653c37c5ff14834da9/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d256b3ecbf340f752a78f653c37c5ff14834da9/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=3d256b3ecbf340f752a78f653c37c5ff14834da9", "patch": "@@ -11,9 +11,9 @@ use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir::visit::{MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::{\n-    AssertKind, BasicBlock, BinOp, Body, Constant, ConstantKind, Local, LocalDecl, LocalKind,\n-    Location, Operand, Place, Rvalue, SourceInfo, SourceScope, SourceScopeData, Statement,\n-    StatementKind, Terminator, TerminatorKind, UnOp, RETURN_PLACE,\n+    AssertKind, BasicBlock, BinOp, Body, Constant, ConstantKind, Local, LocalKind, Location,\n+    Operand, Place, Rvalue, SourceInfo, Statement, StatementKind, Terminator, TerminatorKind, UnOp,\n+    RETURN_PLACE,\n };\n use rustc_middle::ty::layout::{LayoutError, LayoutOf, LayoutOfHelpers, TyAndLayout};\n use rustc_middle::ty::subst::{InternalSubsts, Subst};\n@@ -308,10 +308,6 @@ struct ConstPropagator<'mir, 'tcx> {\n     ecx: InterpCx<'mir, 'tcx, ConstPropMachine<'mir, 'tcx>>,\n     tcx: TyCtxt<'tcx>,\n     param_env: ParamEnv<'tcx>,\n-    // FIXME(eddyb) avoid cloning these two fields more than once,\n-    // by accessing them through `ecx` instead.\n-    source_scopes: IndexVec<SourceScope, SourceScopeData<'tcx>>,\n-    local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n     // Because we have `MutVisitor` we can't obtain the `SourceInfo` from a `Location`. So we store\n     // the last known `SourceInfo` here and just keep revisiting it.\n     source_info: Option<SourceInfo>,\n@@ -357,10 +353,6 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         let substs = &InternalSubsts::identity_for_item(tcx, def_id);\n         let param_env = tcx.param_env_reveal_all_normalized(def_id);\n \n-        let span = tcx.def_span(def_id);\n-        // FIXME: `CanConstProp::check` computes the layout of all locals, return those layouts\n-        // so we can write them to `ecx.frame_mut().locals.layout, reducing the duplication in\n-        // `layout_of` query invocations.\n         let can_const_prop = CanConstProp::check(tcx, param_env, body);\n         let mut only_propagate_inside_block_locals = BitSet::new_empty(can_const_prop.len());\n         for (l, mode) in can_const_prop.iter_enumerated() {\n@@ -370,7 +362,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n         let mut ecx = InterpCx::new(\n             tcx,\n-            span,\n+            tcx.def_span(def_id),\n             param_env,\n             ConstPropMachine::new(only_propagate_inside_block_locals, can_const_prop),\n         );\n@@ -397,17 +389,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         )\n         .expect(\"failed to push initial stack frame\");\n \n-        ConstPropagator {\n-            ecx,\n-            tcx,\n-            param_env,\n-            // FIXME(eddyb) avoid cloning these two fields more than once,\n-            // by accessing them through `ecx` instead.\n-            source_scopes: body.source_scopes.clone(),\n-            //FIXME(wesleywiser) we can't steal this because `Visitor::super_visit_body()` needs it\n-            local_decls: body.local_decls.clone(),\n-            source_info: None,\n-        }\n+        ConstPropagator { ecx, tcx, param_env, source_info: None }\n     }\n \n     fn get_const(&self, place: Place<'tcx>) -> Option<OpTy<'tcx>> {\n@@ -435,7 +417,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     }\n \n     fn lint_root(&self, source_info: SourceInfo) -> Option<HirId> {\n-        source_info.scope.lint_root(&self.source_scopes)\n+        source_info.scope.lint_root(&self.ecx.frame().body.source_scopes)\n     }\n \n     fn use_ecx<F, T>(&mut self, f: F) -> Option<T>\n@@ -572,7 +554,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             let r = r?;\n             // We need the type of the LHS. We cannot use `place_layout` as that is the type\n             // of the result, which for checked binops is not the same!\n-            let left_ty = left.ty(&self.local_decls, self.tcx);\n+            let left_ty = left.ty(&self.ecx.frame().body.local_decls, self.tcx);\n             let left_size = self.ecx.layout_of(left_ty).ok()?.size;\n             let right_size = r.layout.size;\n             let r_bits = r.to_scalar().ok();\n@@ -1026,7 +1008,7 @@ impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n                 assert!(\n                     self.get_const(local.into()).is_none()\n                         || self\n-                            .layout_of(self.local_decls[local].ty)\n+                            .layout_of(self.ecx.frame().body.local_decls[local].ty)\n                             .map_or(true, |layout| layout.is_zst())\n                 )\n             }"}]}