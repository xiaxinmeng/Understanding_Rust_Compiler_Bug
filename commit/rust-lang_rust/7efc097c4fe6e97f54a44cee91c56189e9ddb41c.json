{"sha": "7efc097c4fe6e97f54a44cee91c56189e9ddb41c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlZmMwOTdjNGZlNmU5N2Y1NGE0NGNlZTkxYzU2MTg5ZTlkZGI0MWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-12T19:41:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-12T19:41:56Z"}, "message": "Auto merge of #79957 - jyn514:smaller-span, r=GuillaumeGomez\n\n[rustdoc] Calculate span information on demand instead of storing it ahead of time\n\nThis brings `size_of<clean::types::Span>()` down from over 100 bytes (!!) to only 12, the same as rustc. It brings `Item` down even more, from `784` to `680`.\n\n~~TODO: I need to figure out how to do this for the JSON backend too. That uses `From` impls everywhere, which don't allow passing in the `Session` as an argument. `@P1n3appl3,` `@tmandry,` maybe one of you have ideas?~~ Figured it out, fortunately only two functions needed to be changed. I like the `convert_x()` format better than `From` everywhere but I'm open to feedback.\n\nHelps with #79103", "tree": {"sha": "f8094e561a815df3c428d239f0e35d1f446325eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8094e561a815df3c428d239f0e35d1f446325eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7efc097c4fe6e97f54a44cee91c56189e9ddb41c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7efc097c4fe6e97f54a44cee91c56189e9ddb41c", "html_url": "https://github.com/rust-lang/rust/commit/7efc097c4fe6e97f54a44cee91c56189e9ddb41c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7efc097c4fe6e97f54a44cee91c56189e9ddb41c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "388eb24b6c479088a83c1b094d79221a32dfc7ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/388eb24b6c479088a83c1b094d79221a32dfc7ff", "html_url": "https://github.com/rust-lang/rust/commit/388eb24b6c479088a83c1b094d79221a32dfc7ff"}, {"sha": "9684557c8f1b9fd55cb6fcc27533044022b0ed22", "url": "https://api.github.com/repos/rust-lang/rust/commits/9684557c8f1b9fd55cb6fcc27533044022b0ed22", "html_url": "https://github.com/rust-lang/rust/commit/9684557c8f1b9fd55cb6fcc27533044022b0ed22"}], "stats": {"total": 211, "additions": 116, "deletions": 95}, "files": [{"sha": "7a61a169c2bd2e1922441d441907cadb92eae5de", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7efc097c4fe6e97f54a44cee91c56189e9ddb41c/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7efc097c4fe6e97f54a44cee91c56189e9ddb41c/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=7efc097c4fe6e97f54a44cee91c56189e9ddb41c", "patch": "@@ -118,7 +118,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 };\n \n                 Some(Item {\n-                    source: Span::empty(),\n+                    source: Span::dummy(),\n                     name: None,\n                     attrs: Default::default(),\n                     visibility: Inherited,"}, {"sha": "f7b6553a9359ad84ddb74c69aaa3373895b983cb", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7efc097c4fe6e97f54a44cee91c56189e9ddb41c/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7efc097c4fe6e97f54a44cee91c56189e9ddb41c/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=7efc097c4fe6e97f54a44cee91c56189e9ddb41c", "patch": "@@ -479,7 +479,7 @@ fn build_module(cx: &DocContext<'_>, did: DefId, visited: &mut FxHashSet<DefId>)\n                     items.push(clean::Item {\n                         name: None,\n                         attrs: clean::Attributes::default(),\n-                        source: clean::Span::empty(),\n+                        source: clean::Span::dummy(),\n                         def_id: DefId::local(CRATE_DEF_INDEX),\n                         visibility: clean::Public,\n                         stability: None,"}, {"sha": "1a63a5092ca0730a70f519642d761de95c9d734e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 24, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7efc097c4fe6e97f54a44cee91c56189e9ddb41c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7efc097c4fe6e97f54a44cee91c56189e9ddb41c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=7efc097c4fe6e97f54a44cee91c56189e9ddb41c", "patch": "@@ -25,7 +25,7 @@ use rustc_middle::ty::{self, AdtKind, Lift, Ty, TyCtxt};\n use rustc_mir::const_eval::{is_const_fn, is_min_const_fn, is_unstable_const_fn};\n use rustc_span::hygiene::{AstPass, MacroKind};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::{self, ExpnKind, Pos};\n+use rustc_span::{self, ExpnKind};\n use rustc_typeck::hir_ty_to_ty;\n \n use std::collections::hash_map::Entry;\n@@ -1881,29 +1881,8 @@ impl Clean<VariantKind> for hir::VariantData<'_> {\n }\n \n impl Clean<Span> for rustc_span::Span {\n-    fn clean(&self, cx: &DocContext<'_>) -> Span {\n-        if self.is_dummy() {\n-            return Span::empty();\n-        }\n-\n-        // Get the macro invocation instead of the definition,\n-        // in case the span is result of a macro expansion.\n-        // (See rust-lang/rust#39726)\n-        let span = self.source_callsite();\n-\n-        let sm = cx.sess().source_map();\n-        let filename = sm.span_to_filename(span);\n-        let lo = sm.lookup_char_pos(span.lo());\n-        let hi = sm.lookup_char_pos(span.hi());\n-        Span {\n-            filename,\n-            cnum: lo.file.cnum,\n-            loline: lo.line,\n-            locol: lo.col.to_usize(),\n-            hiline: hi.line,\n-            hicol: hi.col.to_usize(),\n-            original: span,\n-        }\n+    fn clean(&self, _cx: &DocContext<'_>) -> Span {\n+        Span::from_rustc_span(*self)\n     }\n }\n "}, {"sha": "0228d63ac00e6b904638a70231e5994e3f7b97ac", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 32, "deletions": 22, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/7efc097c4fe6e97f54a44cee91c56189e9ddb41c/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7efc097c4fe6e97f54a44cee91c56189e9ddb41c/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=7efc097c4fe6e97f54a44cee91c56189e9ddb41c", "patch": "@@ -17,15 +17,16 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_feature::UnstableFeatures;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n-use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::Mutability;\n use rustc_index::vec::IndexVec;\n use rustc_middle::ty::{AssocKind, TyCtxt};\n+use rustc_session::Session;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::DUMMY_SP;\n use rustc_span::symbol::{kw, sym, Ident, Symbol, SymbolStr};\n-use rustc_span::{self, FileName};\n+use rustc_span::{self, FileName, Loc};\n use rustc_target::abi::VariantIdx;\n use rustc_target::spec::abi::Abi;\n use smallvec::{smallvec, SmallVec};\n@@ -1609,32 +1610,41 @@ crate enum VariantKind {\n     Struct(VariantStruct),\n }\n \n+/// Small wrapper around `rustc_span::Span` that adds helper methods and enforces calling `source_callsite`.\n #[derive(Clone, Debug)]\n-crate struct Span {\n-    crate filename: FileName,\n-    crate cnum: CrateNum,\n-    crate loline: usize,\n-    crate locol: usize,\n-    crate hiline: usize,\n-    crate hicol: usize,\n-    crate original: rustc_span::Span,\n-}\n+crate struct Span(rustc_span::Span);\n \n impl Span {\n-    crate fn empty() -> Span {\n-        Span {\n-            filename: FileName::Anon(0),\n-            cnum: LOCAL_CRATE,\n-            loline: 0,\n-            locol: 0,\n-            hiline: 0,\n-            hicol: 0,\n-            original: rustc_span::DUMMY_SP,\n-        }\n+    crate fn from_rustc_span(sp: rustc_span::Span) -> Self {\n+        // Get the macro invocation instead of the definition,\n+        // in case the span is result of a macro expansion.\n+        // (See rust-lang/rust#39726)\n+        Self(sp.source_callsite())\n+    }\n+\n+    crate fn dummy() -> Self {\n+        Self(rustc_span::DUMMY_SP)\n     }\n \n     crate fn span(&self) -> rustc_span::Span {\n-        self.original\n+        self.0\n+    }\n+\n+    crate fn filename(&self, sess: &Session) -> FileName {\n+        sess.source_map().span_to_filename(self.0)\n+    }\n+\n+    crate fn lo(&self, sess: &Session) -> Loc {\n+        sess.source_map().lookup_char_pos(self.0.lo())\n+    }\n+\n+    crate fn hi(&self, sess: &Session) -> Loc {\n+        sess.source_map().lookup_char_pos(self.0.hi())\n+    }\n+\n+    crate fn cnum(&self, sess: &Session) -> CrateNum {\n+        // FIXME: is there a time when the lo and hi crate would be different?\n+        self.lo(sess).file.cnum\n     }\n }\n "}, {"sha": "6334524eb1ca39774c0b3be287e330b763a76142", "filename": "src/librustdoc/formats/renderer.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7efc097c4fe6e97f54a44cee91c56189e9ddb41c/src%2Flibrustdoc%2Fformats%2Frenderer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7efc097c4fe6e97f54a44cee91c56189e9ddb41c/src%2Flibrustdoc%2Fformats%2Frenderer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Frenderer.rs?ref=7efc097c4fe6e97f54a44cee91c56189e9ddb41c", "patch": "@@ -1,5 +1,7 @@\n use std::sync::Arc;\n \n+use rustc_data_structures::sync::Lrc;\n+use rustc_session::Session;\n use rustc_span::edition::Edition;\n \n use crate::clean;\n@@ -19,6 +21,7 @@ crate trait FormatRenderer: Clone {\n         render_info: RenderInfo,\n         edition: Edition,\n         cache: &mut Cache,\n+        sess: Lrc<Session>,\n     ) -> Result<(Self, clean::Crate), Error>;\n \n     /// Renders a single non-module item. This means no recursive sub-item rendering is required.\n@@ -49,6 +52,7 @@ crate fn run_format<T: FormatRenderer>(\n     render_info: RenderInfo,\n     diag: &rustc_errors::Handler,\n     edition: Edition,\n+    sess: Lrc<Session>,\n ) -> Result<(), Error> {\n     let (krate, mut cache) = Cache::from_krate(\n         render_info.clone(),\n@@ -59,7 +63,7 @@ crate fn run_format<T: FormatRenderer>(\n     );\n \n     let (mut format_renderer, mut krate) =\n-        T::init(krate, options, render_info, edition, &mut cache)?;\n+        T::init(krate, options, render_info, edition, &mut cache, sess)?;\n \n     let cache = Arc::new(cache);\n     // Freeze the cache now that the index has been built. Put an Arc into TLS for future"}, {"sha": "db04624dca8486544e3cceaf2e7ecf885bff9a97", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7efc097c4fe6e97f54a44cee91c56189e9ddb41c/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7efc097c4fe6e97f54a44cee91c56189e9ddb41c/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=7efc097c4fe6e97f54a44cee91c56189e9ddb41c", "patch": "@@ -52,10 +52,12 @@ use rustc_ast_pretty::pprust;\n use rustc_attr::StabilityLevel;\n use rustc_data_structures::flock;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::sync::Lrc;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_hir::Mutability;\n use rustc_middle::middle::stability;\n+use rustc_session::Session;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::FileName;\n@@ -121,6 +123,7 @@ crate struct Context {\n }\n \n crate struct SharedContext {\n+    crate sess: Lrc<Session>,\n     /// The path to the crate root source minus the file name.\n     /// Used for simplifying paths to the highlighted source code files.\n     crate src_root: PathBuf,\n@@ -171,6 +174,10 @@ impl Context {\n         let filename = format!(\"{}{}.{}\", base, self.shared.resource_suffix, ext);\n         self.dst.join(&filename)\n     }\n+\n+    fn sess(&self) -> &Session {\n+        &self.shared.sess\n+    }\n }\n \n impl SharedContext {\n@@ -381,6 +388,7 @@ impl FormatRenderer for Context {\n         _render_info: RenderInfo,\n         edition: Edition,\n         cache: &mut Cache,\n+        sess: Lrc<Session>,\n     ) -> Result<(Context, clean::Crate), Error> {\n         // need to save a copy of the options for rendering the index page\n         let md_opts = options.clone();\n@@ -453,6 +461,7 @@ impl FormatRenderer for Context {\n         }\n         let (sender, receiver) = channel();\n         let mut scx = SharedContext {\n+            sess,\n             collapsed: krate.collapsed,\n             src_root,\n             include_sources,\n@@ -1629,24 +1638,24 @@ impl Context {\n     /// of their crate documentation isn't known.\n     fn src_href(&self, item: &clean::Item, cache: &Cache) -> Option<String> {\n         let mut root = self.root_path();\n-\n         let mut path = String::new();\n+        let cnum = item.source.cnum(self.sess());\n \n         // We can safely ignore synthetic `SourceFile`s.\n-        let file = match item.source.filename {\n+        let file = match item.source.filename(self.sess()) {\n             FileName::Real(ref path) => path.local_path().to_path_buf(),\n             _ => return None,\n         };\n         let file = &file;\n \n-        let (krate, path) = if item.source.cnum == LOCAL_CRATE {\n+        let (krate, path) = if cnum == LOCAL_CRATE {\n             if let Some(path) = self.shared.local_sources.get(file) {\n                 (&self.shared.layout.krate, path)\n             } else {\n                 return None;\n             }\n         } else {\n-            let (krate, src_root) = match *cache.extern_locations.get(&item.source.cnum)? {\n+            let (krate, src_root) = match *cache.extern_locations.get(&cnum)? {\n                 (ref name, ref src, ExternalLocation::Local) => (name, src),\n                 (ref name, ref src, ExternalLocation::Remote(ref s)) => {\n                     root = s.to_string();\n@@ -1665,11 +1674,10 @@ impl Context {\n             (krate, &path)\n         };\n \n-        let lines = if item.source.loline == item.source.hiline {\n-            item.source.loline.to_string()\n-        } else {\n-            format!(\"{}-{}\", item.source.loline, item.source.hiline)\n-        };\n+        let loline = item.source.lo(self.sess()).line;\n+        let hiline = item.source.hi(self.sess()).line;\n+        let lines =\n+            if loline == hiline { loline.to_string() } else { format!(\"{}-{}\", loline, hiline) };\n         Some(format!(\n             \"{root}src/{krate}/{path}#{lines}\",\n             root = Escape(&root),"}, {"sha": "ef9e9f350fb84a9f00bf4ddebb8ab074e99006c2", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7efc097c4fe6e97f54a44cee91c56189e9ddb41c/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7efc097c4fe6e97f54a44cee91c56189e9ddb41c/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=7efc097c4fe6e97f54a44cee91c56189e9ddb41c", "patch": "@@ -7,6 +7,7 @@ use crate::html::highlight;\n use crate::html::layout;\n use crate::html::render::{SharedContext, BASIC_KEYWORDS};\n use rustc_hir::def_id::LOCAL_CRATE;\n+use rustc_session::Session;\n use rustc_span::source_map::FileName;\n use std::ffi::OsStr;\n use std::fs;\n@@ -34,37 +35,45 @@ struct SourceCollector<'a> {\n \n impl<'a> DocFolder for SourceCollector<'a> {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n+        // If we're not rendering sources, there's nothing to do.\n         // If we're including source files, and we haven't seen this file yet,\n         // then we need to render it out to the filesystem.\n         if self.scx.include_sources\n             // skip all synthetic \"files\"\n-            && item.source.filename.is_real()\n+            && item.source.filename(self.sess()).is_real()\n             // skip non-local files\n-            && item.source.cnum == LOCAL_CRATE\n+            && item.source.cnum(self.sess()) == LOCAL_CRATE\n         {\n+            let filename = item.source.filename(self.sess());\n             // If it turns out that we couldn't read this file, then we probably\n             // can't read any of the files (generating html output from json or\n             // something like that), so just don't include sources for the\n             // entire crate. The other option is maintaining this mapping on a\n             // per-file basis, but that's probably not worth it...\n-            self.scx.include_sources = match self.emit_source(&item.source.filename) {\n+            self.scx.include_sources = match self.emit_source(&filename) {\n                 Ok(()) => true,\n                 Err(e) => {\n                     println!(\n                         \"warning: source code was requested to be rendered, \\\n                          but processing `{}` had an error: {}\",\n-                        item.source.filename, e\n+                        filename, e\n                     );\n                     println!(\"         skipping rendering of source code\");\n                     false\n                 }\n             };\n         }\n+        // FIXME: if `include_sources` isn't set and DocFolder didn't require consuming the crate by value,\n+        // we could return None here without having to walk the rest of the crate.\n         Some(self.fold_item_recur(item))\n     }\n }\n \n impl<'a> SourceCollector<'a> {\n+    fn sess(&self) -> &Session {\n+        &self.scx.sess\n+    }\n+\n     /// Renders the given filename into its corresponding HTML source file.\n     fn emit_source(&mut self, filename: &FileName) -> Result<(), Error> {\n         let p = match *filename {"}, {"sha": "c463481db86d2e5ac6c651214ef3c75d3f73fa7a", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7efc097c4fe6e97f54a44cee91c56189e9ddb41c/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7efc097c4fe6e97f54a44cee91c56189e9ddb41c/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=7efc097c4fe6e97f54a44cee91c56189e9ddb41c", "patch": "@@ -6,14 +6,16 @@ use std::convert::From;\n \n use rustc_ast::ast;\n use rustc_span::def_id::{DefId, CRATE_DEF_INDEX};\n+use rustc_span::Pos;\n \n use crate::clean;\n use crate::doctree;\n use crate::formats::item_type::ItemType;\n use crate::json::types::*;\n+use crate::json::JsonRenderer;\n \n-impl From<clean::Item> for Option<Item> {\n-    fn from(item: clean::Item) -> Self {\n+impl JsonRenderer {\n+    pub(super) fn convert_item(&self, item: clean::Item) -> Option<Item> {\n         let item_type = ItemType::from(&item);\n         let clean::Item {\n             source,\n@@ -32,7 +34,7 @@ impl From<clean::Item> for Option<Item> {\n                 id: def_id.into(),\n                 crate_id: def_id.krate.as_u32(),\n                 name,\n-                source: source.into(),\n+                source: self.convert_span(source),\n                 visibility: visibility.into(),\n                 docs: attrs.collapsed_doc_value().unwrap_or_default(),\n                 links: attrs\n@@ -53,22 +55,23 @@ impl From<clean::Item> for Option<Item> {\n             }),\n         }\n     }\n-}\n \n-impl From<clean::Span> for Option<Span> {\n-    fn from(span: clean::Span) -> Self {\n-        let clean::Span { loline, locol, hiline, hicol, .. } = span;\n-        match span.filename {\n-            rustc_span::FileName::Real(name) => Some(Span {\n-                filename: match name {\n-                    rustc_span::RealFileName::Named(path) => path,\n-                    rustc_span::RealFileName::Devirtualized { local_path, virtual_name: _ } => {\n-                        local_path\n-                    }\n-                },\n-                begin: (loline, locol),\n-                end: (hiline, hicol),\n-            }),\n+    fn convert_span(&self, span: clean::Span) -> Option<Span> {\n+        match span.filename(&self.sess) {\n+            rustc_span::FileName::Real(name) => {\n+                let hi = span.hi(&self.sess);\n+                let lo = span.lo(&self.sess);\n+                Some(Span {\n+                    filename: match name {\n+                        rustc_span::RealFileName::Named(path) => path,\n+                        rustc_span::RealFileName::Devirtualized { local_path, virtual_name: _ } => {\n+                            local_path\n+                        }\n+                    },\n+                    begin: (lo.line, lo.col.to_usize()),\n+                    end: (hi.line, hi.col.to_usize()),\n+                })\n+            }\n             _ => None,\n         }\n     }"}, {"sha": "5c5239d1b6a26f4d33034e3c3a684625206d5522", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7efc097c4fe6e97f54a44cee91c56189e9ddb41c/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7efc097c4fe6e97f54a44cee91c56189e9ddb41c/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=7efc097c4fe6e97f54a44cee91c56189e9ddb41c", "patch": "@@ -13,6 +13,8 @@ use std::path::PathBuf;\n use std::rc::Rc;\n \n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::sync::Lrc;\n+use rustc_session::Session;\n use rustc_span::edition::Edition;\n \n use crate::clean;\n@@ -24,6 +26,7 @@ use crate::html::render::cache::ExternalLocation;\n \n #[derive(Clone)]\n crate struct JsonRenderer {\n+    sess: Lrc<Session>,\n     /// A mapping of IDs that contains all local items for this crate which gets output as a top\n     /// level field of the JSON blob.\n     index: Rc<RefCell<FxHashMap<types::Id, types::Item>>>,\n@@ -124,10 +127,12 @@ impl FormatRenderer for JsonRenderer {\n         _render_info: RenderInfo,\n         _edition: Edition,\n         _cache: &mut Cache,\n+        sess: Lrc<Session>,\n     ) -> Result<(Self, clean::Crate), Error> {\n         debug!(\"Initializing json renderer\");\n         Ok((\n             JsonRenderer {\n+                sess,\n                 index: Rc::new(RefCell::new(FxHashMap::default())),\n                 out_path: options.output,\n             },\n@@ -143,7 +148,7 @@ impl FormatRenderer for JsonRenderer {\n         item.kind.inner_items().for_each(|i| self.item(i.clone(), cache).unwrap());\n \n         let id = item.def_id;\n-        if let Some(mut new_item) = item.into(): Option<types::Item> {\n+        if let Some(mut new_item) = self.convert_item(item) {\n             if let types::ItemEnum::TraitItem(ref mut t) = new_item.inner {\n                 t.implementors = self.get_trait_implementors(id, cache)\n             } else if let types::ItemEnum::StructItem(ref mut s) = new_item.inner {"}, {"sha": "286a29edd95e71243ca61ac955ffff275519163d", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7efc097c4fe6e97f54a44cee91c56189e9ddb41c/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7efc097c4fe6e97f54a44cee91c56189e9ddb41c/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=7efc097c4fe6e97f54a44cee91c56189e9ddb41c", "patch": "@@ -62,9 +62,11 @@ use std::default::Default;\n use std::env;\n use std::process;\n \n+use rustc_data_structures::sync::Lrc;\n use rustc_errors::ErrorReported;\n use rustc_session::config::{make_crate_type_option, ErrorOutputType, RustcOptGroup};\n use rustc_session::getopts;\n+use rustc_session::Session;\n use rustc_session::{early_error, early_warn};\n \n #[macro_use]\n@@ -484,8 +486,9 @@ fn run_renderer<T: formats::FormatRenderer>(\n     render_info: config::RenderInfo,\n     diag: &rustc_errors::Handler,\n     edition: rustc_span::edition::Edition,\n+    sess: Lrc<Session>,\n ) -> MainResult {\n-    match formats::run_format::<T>(krate, renderopts, render_info, &diag, edition) {\n+    match formats::run_format::<T>(krate, renderopts, render_info, &diag, edition, sess) {\n         Ok(_) => Ok(()),\n         Err(e) => {\n             let mut msg = diag.struct_err(&format!(\"couldn't generate documentation: {}\", e.error));\n@@ -553,12 +556,15 @@ fn main_options(options: config::Options) -> MainResult {\n     info!(\"going to format\");\n     let (error_format, edition, debugging_options) = diag_opts;\n     let diag = core::new_handler(error_format, None, &debugging_options);\n+    let sess_time = sess.clone();\n     match output_format {\n-        None | Some(config::OutputFormat::Html) => sess.time(\"render_html\", || {\n-            run_renderer::<html::render::Context>(krate, renderopts, renderinfo, &diag, edition)\n+        None | Some(config::OutputFormat::Html) => sess_time.time(\"render_html\", || {\n+            run_renderer::<html::render::Context>(\n+                krate, renderopts, renderinfo, &diag, edition, sess,\n+            )\n         }),\n-        Some(config::OutputFormat::Json) => sess.time(\"render_json\", || {\n-            run_renderer::<json::JsonRenderer>(krate, renderopts, renderinfo, &diag, edition)\n+        Some(config::OutputFormat::Json) => sess_time.time(\"render_json\", || {\n+            run_renderer::<json::JsonRenderer>(krate, renderopts, renderinfo, &diag, edition, sess)\n         }),\n     }\n }"}, {"sha": "52f6a97089bdef225f9879b86e3b659b55f081e6", "filename": "src/librustdoc/passes/calculate_doc_coverage.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7efc097c4fe6e97f54a44cee91c56189e9ddb41c/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7efc097c4fe6e97f54a44cee91c56189e9ddb41c/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs?ref=7efc097c4fe6e97f54a44cee91c56189e9ddb41c", "patch": "@@ -216,13 +216,9 @@ impl<'a, 'b> fold::DocFolder for CoverageCalculator<'a, 'b> {\n                 return Some(i);\n             }\n             clean::ImplItem(ref impl_) => {\n+                let filename = i.source.filename(self.ctx.sess());\n                 if let Some(ref tr) = impl_.trait_ {\n-                    debug!(\n-                        \"impl {:#} for {:#} in {}\",\n-                        tr.print(),\n-                        impl_.for_.print(),\n-                        i.source.filename\n-                    );\n+                    debug!(\"impl {:#} for {:#} in {}\", tr.print(), impl_.for_.print(), filename,);\n \n                     // don't count trait impls, the missing-docs lint doesn't so we shouldn't\n                     // either\n@@ -231,7 +227,7 @@ impl<'a, 'b> fold::DocFolder for CoverageCalculator<'a, 'b> {\n                     // inherent impls *can* be documented, and those docs show up, but in most\n                     // cases it doesn't make sense, as all methods on a type are in one single\n                     // impl block\n-                    debug!(\"impl {:#} in {}\", impl_.for_.print(), i.source.filename);\n+                    debug!(\"impl {:#} in {}\", impl_.for_.print(), filename);\n                 }\n             }\n             _ => {\n@@ -251,15 +247,16 @@ impl<'a, 'b> fold::DocFolder for CoverageCalculator<'a, 'b> {\n                     None,\n                 );\n \n+                let filename = i.source.filename(self.ctx.sess());\n                 let has_doc_example = tests.found_tests != 0;\n                 let hir_id = self.ctx.tcx.hir().local_def_id_to_hir_id(i.def_id.expect_local());\n                 let (level, source) = self.ctx.tcx.lint_level_at_node(MISSING_DOCS, hir_id);\n                 // `missing_docs` is allow-by-default, so don't treat this as ignoring the item\n                 // unless the user had an explicit `allow`\n                 let should_have_docs =\n                     level != lint::Level::Allow || matches!(source, LintSource::Default);\n-                debug!(\"counting {:?} {:?} in {}\", i.type_(), i.name, i.source.filename);\n-                self.items.entry(i.source.filename.clone()).or_default().count_item(\n+                debug!(\"counting {:?} {:?} in {}\", i.type_(), i.name, filename);\n+                self.items.entry(filename).or_default().count_item(\n                     has_docs,\n                     has_doc_example,\n                     should_have_doc_example(self.ctx, &i),"}]}