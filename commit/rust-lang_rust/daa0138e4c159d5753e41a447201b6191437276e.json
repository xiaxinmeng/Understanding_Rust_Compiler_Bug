{"sha": "daa0138e4c159d5753e41a447201b6191437276e", "node_id": "C_kwDOAAsO6NoAKGRhYTAxMzhlNGMxNTlkNTc1M2U0MWE0NDcyMDFiNjE5MTQzNzI3NmU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-21T18:25:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-21T18:25:02Z"}, "message": "Auto merge of #14001 - Veykril:lang-item, r=Veykril\n\nReplace SmolStr usage with lang item enum for lang items\n\nFixes https://github.com/rust-lang/rust-analyzer/issues/13395", "tree": {"sha": "32f3397e5a9cfaa3d88af26f94a12d4764abe381", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32f3397e5a9cfaa3d88af26f94a12d4764abe381"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/daa0138e4c159d5753e41a447201b6191437276e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/daa0138e4c159d5753e41a447201b6191437276e", "html_url": "https://github.com/rust-lang/rust/commit/daa0138e4c159d5753e41a447201b6191437276e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/daa0138e4c159d5753e41a447201b6191437276e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1afa032f34db45a7018ced2c1a59798139e95bfc", "url": "https://api.github.com/repos/rust-lang/rust/commits/1afa032f34db45a7018ced2c1a59798139e95bfc", "html_url": "https://github.com/rust-lang/rust/commit/1afa032f34db45a7018ced2c1a59798139e95bfc"}, {"sha": "f8ed4d7ae44e7a730f597f1f6618fb3b4aead01b", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8ed4d7ae44e7a730f597f1f6618fb3b4aead01b", "html_url": "https://github.com/rust-lang/rust/commit/f8ed4d7ae44e7a730f597f1f6618fb3b4aead01b"}], "stats": {"total": 867, "additions": 496, "deletions": 371}, "files": [{"sha": "b23427a73b3456f307009aadc51b93bdc301f50d", "filename": "crates/hir-def/src/db.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fhir-def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fhir-def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fdb.rs?ref=daa0138e4c159d5753e41a447201b6191437276e", "patch": "@@ -6,7 +6,7 @@ use either::Either;\n use hir_expand::{db::AstDatabase, HirFileId};\n use intern::Interned;\n use la_arena::ArenaMap;\n-use syntax::{ast, AstPtr, SmolStr};\n+use syntax::{ast, AstPtr};\n \n use crate::{\n     adt::{EnumData, StructData},\n@@ -19,7 +19,7 @@ use crate::{\n     generics::GenericParams,\n     import_map::ImportMap,\n     item_tree::{AttrOwner, ItemTree},\n-    lang_item::{LangItemTarget, LangItems},\n+    lang_item::{LangItem, LangItemTarget, LangItems},\n     nameres::{diagnostics::DefDiagnostic, DefMap},\n     visibility::{self, Visibility},\n     AttrDefId, BlockId, BlockLoc, ConstId, ConstLoc, DefWithBodyId, EnumId, EnumLoc, ExternBlockId,\n@@ -183,7 +183,7 @@ pub trait DefDatabase: InternDatabase + AstDatabase + Upcast<dyn AstDatabase> {\n     fn crate_lang_items(&self, krate: CrateId) -> Arc<LangItems>;\n \n     #[salsa::invoke(LangItems::lang_item_query)]\n-    fn lang_item(&self, start_crate: CrateId, item: SmolStr) -> Option<LangItemTarget>;\n+    fn lang_item(&self, start_crate: CrateId, item: LangItem) -> Option<LangItemTarget>;\n \n     #[salsa::invoke(ImportMap::import_map_query)]\n     fn import_map(&self, krate: CrateId) -> Arc<ImportMap>;"}, {"sha": "ab9bc615daf55aeea42b0ab32c5f9d202f14fd20", "filename": "crates/hir-def/src/lang_item.rs", "status": "modified", "additions": 269, "deletions": 29, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fhir-def%2Fsrc%2Flang_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fhir-def%2Fsrc%2Flang_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Flang_item.rs?ref=daa0138e4c159d5753e41a447201b6191437276e", "patch": "@@ -8,19 +8,21 @@ use rustc_hash::FxHashMap;\n use syntax::SmolStr;\n \n use crate::{\n-    db::DefDatabase, AdtId, AttrDefId, CrateId, EnumId, EnumVariantId, FunctionId, ImplId,\n-    ModuleDefId, StaticId, StructId, TraitId,\n+    db::DefDatabase, AdtId, AssocItemId, AttrDefId, CrateId, EnumId, EnumVariantId, FunctionId,\n+    ImplId, ModuleDefId, StaticId, StructId, TraitId, TypeAliasId, UnionId,\n };\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub enum LangItemTarget {\n     EnumId(EnumId),\n-    FunctionId(FunctionId),\n-    ImplDefId(ImplId),\n-    StaticId(StaticId),\n-    StructId(StructId),\n-    TraitId(TraitId),\n-    EnumVariantId(EnumVariantId),\n+    Function(FunctionId),\n+    ImplDef(ImplId),\n+    Static(StaticId),\n+    Struct(StructId),\n+    Union(UnionId),\n+    TypeAlias(TypeAliasId),\n+    Trait(TraitId),\n+    EnumVariant(EnumVariantId),\n }\n \n impl LangItemTarget {\n@@ -33,55 +35,55 @@ impl LangItemTarget {\n \n     pub fn as_function(self) -> Option<FunctionId> {\n         match self {\n-            LangItemTarget::FunctionId(id) => Some(id),\n+            LangItemTarget::Function(id) => Some(id),\n             _ => None,\n         }\n     }\n \n     pub fn as_impl_def(self) -> Option<ImplId> {\n         match self {\n-            LangItemTarget::ImplDefId(id) => Some(id),\n+            LangItemTarget::ImplDef(id) => Some(id),\n             _ => None,\n         }\n     }\n \n     pub fn as_static(self) -> Option<StaticId> {\n         match self {\n-            LangItemTarget::StaticId(id) => Some(id),\n+            LangItemTarget::Static(id) => Some(id),\n             _ => None,\n         }\n     }\n \n     pub fn as_struct(self) -> Option<StructId> {\n         match self {\n-            LangItemTarget::StructId(id) => Some(id),\n+            LangItemTarget::Struct(id) => Some(id),\n             _ => None,\n         }\n     }\n \n     pub fn as_trait(self) -> Option<TraitId> {\n         match self {\n-            LangItemTarget::TraitId(id) => Some(id),\n+            LangItemTarget::Trait(id) => Some(id),\n             _ => None,\n         }\n     }\n \n     pub fn as_enum_variant(self) -> Option<EnumVariantId> {\n         match self {\n-            LangItemTarget::EnumVariantId(id) => Some(id),\n+            LangItemTarget::EnumVariant(id) => Some(id),\n             _ => None,\n         }\n     }\n }\n \n #[derive(Default, Debug, Clone, PartialEq, Eq)]\n pub struct LangItems {\n-    items: FxHashMap<SmolStr, LangItemTarget>,\n+    items: FxHashMap<LangItem, LangItemTarget>,\n }\n \n impl LangItems {\n-    pub fn target(&self, item: &str) -> Option<LangItemTarget> {\n-        self.items.get(item).copied()\n+    pub fn target(&self, item: LangItem) -> Option<LangItemTarget> {\n+        self.items.get(&item).copied()\n     }\n \n     /// Salsa query. This will look for lang items in a specific crate.\n@@ -94,16 +96,27 @@ impl LangItems {\n \n         for (_, module_data) in crate_def_map.modules() {\n             for impl_def in module_data.scope.impls() {\n-                lang_items.collect_lang_item(db, impl_def, LangItemTarget::ImplDefId)\n+                lang_items.collect_lang_item(db, impl_def, LangItemTarget::ImplDef);\n+                for assoc in db.impl_data(impl_def).items.iter().copied() {\n+                    match assoc {\n+                        AssocItemId::FunctionId(f) => {\n+                            lang_items.collect_lang_item(db, f, LangItemTarget::Function)\n+                        }\n+                        AssocItemId::TypeAliasId(t) => {\n+                            lang_items.collect_lang_item(db, t, LangItemTarget::TypeAlias)\n+                        }\n+                        AssocItemId::ConstId(_) => (),\n+                    }\n+                }\n             }\n \n             for def in module_data.scope.declarations() {\n                 match def {\n                     ModuleDefId::TraitId(trait_) => {\n-                        lang_items.collect_lang_item(db, trait_, LangItemTarget::TraitId);\n+                        lang_items.collect_lang_item(db, trait_, LangItemTarget::Trait);\n                         db.trait_data(trait_).items.iter().for_each(|&(_, assoc_id)| {\n-                            if let crate::AssocItemId::FunctionId(f) = assoc_id {\n-                                lang_items.collect_lang_item(db, f, LangItemTarget::FunctionId);\n+                            if let AssocItemId::FunctionId(f) = assoc_id {\n+                                lang_items.collect_lang_item(db, f, LangItemTarget::Function);\n                             }\n                         });\n                     }\n@@ -113,18 +126,24 @@ impl LangItems {\n                             lang_items.collect_lang_item(\n                                 db,\n                                 EnumVariantId { parent: e, local_id },\n-                                LangItemTarget::EnumVariantId,\n+                                LangItemTarget::EnumVariant,\n                             );\n                         });\n                     }\n                     ModuleDefId::AdtId(AdtId::StructId(s)) => {\n-                        lang_items.collect_lang_item(db, s, LangItemTarget::StructId);\n+                        lang_items.collect_lang_item(db, s, LangItemTarget::Struct);\n+                    }\n+                    ModuleDefId::AdtId(AdtId::UnionId(u)) => {\n+                        lang_items.collect_lang_item(db, u, LangItemTarget::Union);\n                     }\n                     ModuleDefId::FunctionId(f) => {\n-                        lang_items.collect_lang_item(db, f, LangItemTarget::FunctionId);\n+                        lang_items.collect_lang_item(db, f, LangItemTarget::Function);\n                     }\n                     ModuleDefId::StaticId(s) => {\n-                        lang_items.collect_lang_item(db, s, LangItemTarget::StaticId);\n+                        lang_items.collect_lang_item(db, s, LangItemTarget::Static);\n+                    }\n+                    ModuleDefId::TypeAliasId(t) => {\n+                        lang_items.collect_lang_item(db, t, LangItemTarget::TypeAlias);\n                     }\n                     _ => {}\n                 }\n@@ -139,7 +158,7 @@ impl LangItems {\n     pub(crate) fn lang_item_query(\n         db: &dyn DefDatabase,\n         start_crate: CrateId,\n-        item: SmolStr,\n+        item: LangItem,\n     ) -> Option<LangItemTarget> {\n         let _p = profile::span(\"lang_item_query\");\n         let lang_items = db.crate_lang_items(start_crate);\n@@ -150,7 +169,7 @@ impl LangItems {\n         db.crate_graph()[start_crate]\n             .dependencies\n             .iter()\n-            .find_map(|dep| db.lang_item(dep.crate_id, item.clone()))\n+            .find_map(|dep| db.lang_item(dep.crate_id, item))\n     }\n \n     fn collect_lang_item<T>(\n@@ -162,8 +181,8 @@ impl LangItems {\n         T: Into<AttrDefId> + Copy,\n     {\n         let _p = profile::span(\"collect_lang_item\");\n-        if let Some(lang_item_name) = lang_attr(db, item) {\n-            self.items.entry(lang_item_name).or_insert_with(|| constructor(item));\n+        if let Some(lang_item) = lang_attr(db, item).and_then(|it| LangItem::from_str(&it)) {\n+            self.items.entry(lang_item).or_insert_with(|| constructor(item));\n         }\n     }\n }\n@@ -172,3 +191,224 @@ pub fn lang_attr(db: &dyn DefDatabase, item: impl Into<AttrDefId> + Copy) -> Opt\n     let attrs = db.attrs(item.into());\n     attrs.by_key(\"lang\").string_value().cloned()\n }\n+\n+pub enum GenericRequirement {\n+    None,\n+    Minimum(usize),\n+    Exact(usize),\n+}\n+\n+macro_rules! language_item_table {\n+    (\n+        $( $(#[$attr:meta])* $variant:ident, $name:ident, $method:ident, $target:expr, $generics:expr; )*\n+    ) => {\n+\n+        /// A representation of all the valid language items in Rust.\n+        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+        pub enum LangItem {\n+            $(\n+                #[doc = concat!(\"The `\", stringify!($name), \"` lang item.\")]\n+                $(#[$attr])*\n+                $variant,\n+            )*\n+        }\n+\n+        impl LangItem {\n+            pub fn name(self) -> SmolStr {\n+                match self {\n+                    $( LangItem::$variant => SmolStr::new(stringify!($name)), )*\n+                }\n+            }\n+\n+            /// Opposite of [`LangItem::name`]\n+            pub fn from_name(name: &hir_expand::name::Name) -> Option<Self> {\n+                Self::from_str(name.as_str()?)\n+            }\n+\n+            /// Opposite of [`LangItem::name`]\n+            pub fn from_str(name: &str) -> Option<Self> {\n+                match name {\n+                    $( stringify!($name) => Some(LangItem::$variant), )*\n+                    _ => None,\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+language_item_table! {\n+//  Variant name,            Name,                     Getter method name,         Target                  Generic requirements;\n+    Sized,                   sized,               sized_trait,                Target::Trait,          GenericRequirement::Exact(0);\n+    Unsize,                  unsize,              unsize_trait,               Target::Trait,          GenericRequirement::Minimum(1);\n+    /// Trait injected by `#[derive(PartialEq)]`, (i.e. \"Partial EQ\").\n+    StructuralPeq,           structural_peq,      structural_peq_trait,       Target::Trait,          GenericRequirement::None;\n+    /// Trait injected by `#[derive(Eq)]`, (i.e. \"Total EQ\"; no, I will not apologize).\n+    StructuralTeq,           structural_teq,      structural_teq_trait,       Target::Trait,          GenericRequirement::None;\n+    Copy,                    copy,                copy_trait,                 Target::Trait,          GenericRequirement::Exact(0);\n+    Clone,                   clone,               clone_trait,                Target::Trait,          GenericRequirement::None;\n+    Sync,                    sync,                sync_trait,                 Target::Trait,          GenericRequirement::Exact(0);\n+    DiscriminantKind,        discriminant_kind,   discriminant_kind_trait,    Target::Trait,          GenericRequirement::None;\n+    /// The associated item of the [`DiscriminantKind`] trait.\n+    Discriminant,            discriminant_type,   discriminant_type,          Target::AssocTy,        GenericRequirement::None;\n+\n+    PointeeTrait,            pointee_trait,       pointee_trait,              Target::Trait,          GenericRequirement::None;\n+    Metadata,                metadata_type,       metadata_type,              Target::AssocTy,        GenericRequirement::None;\n+    DynMetadata,             dyn_metadata,        dyn_metadata,               Target::Struct,         GenericRequirement::None;\n+\n+    Freeze,                  freeze,              freeze_trait,               Target::Trait,          GenericRequirement::Exact(0);\n+\n+    Drop,                    drop,                drop_trait,                 Target::Trait,          GenericRequirement::None;\n+    Destruct,                destruct,            destruct_trait,             Target::Trait,          GenericRequirement::None;\n+\n+    CoerceUnsized,           coerce_unsized,      coerce_unsized_trait,       Target::Trait,          GenericRequirement::Minimum(1);\n+    DispatchFromDyn,         dispatch_from_dyn,   dispatch_from_dyn_trait,    Target::Trait,          GenericRequirement::Minimum(1);\n+\n+    // language items relating to transmutability\n+    TransmuteOpts,           transmute_opts,      transmute_opts,             Target::Struct,         GenericRequirement::Exact(0);\n+    TransmuteTrait,          transmute_trait,     transmute_trait,            Target::Trait,          GenericRequirement::Exact(3);\n+\n+    Add,                     add,                 add_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    Sub,                     sub,                 sub_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    Mul,                     mul,                 mul_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    Div,                     div,                 div_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    Rem,                     rem,                 rem_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    Neg,                     neg,                 neg_trait,                  Target::Trait,          GenericRequirement::Exact(0);\n+    Not,                     not,                 not_trait,                  Target::Trait,          GenericRequirement::Exact(0);\n+    BitXor,                  bitxor,              bitxor_trait,               Target::Trait,          GenericRequirement::Exact(1);\n+    BitAnd,                  bitand,              bitand_trait,               Target::Trait,          GenericRequirement::Exact(1);\n+    BitOr,                   bitor,               bitor_trait,                Target::Trait,          GenericRequirement::Exact(1);\n+    Shl,                     shl,                 shl_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    Shr,                     shr,                 shr_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    AddAssign,               add_assign,          add_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    SubAssign,               sub_assign,          sub_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    MulAssign,               mul_assign,          mul_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    DivAssign,               div_assign,          div_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    RemAssign,               rem_assign,          rem_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    BitXorAssign,            bitxor_assign,       bitxor_assign_trait,        Target::Trait,          GenericRequirement::Exact(1);\n+    BitAndAssign,            bitand_assign,       bitand_assign_trait,        Target::Trait,          GenericRequirement::Exact(1);\n+    BitOrAssign,             bitor_assign,        bitor_assign_trait,         Target::Trait,          GenericRequirement::Exact(1);\n+    ShlAssign,               shl_assign,          shl_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    ShrAssign,               shr_assign,          shr_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    Index,                   index,               index_trait,                Target::Trait,          GenericRequirement::Exact(1);\n+    IndexMut,                index_mut,           index_mut_trait,            Target::Trait,          GenericRequirement::Exact(1);\n+\n+    UnsafeCell,              unsafe_cell,         unsafe_cell_type,           Target::Struct,         GenericRequirement::None;\n+    VaList,                  va_list,             va_list,                    Target::Struct,         GenericRequirement::None;\n+\n+    Deref,                   deref,               deref_trait,                Target::Trait,          GenericRequirement::Exact(0);\n+    DerefMut,                deref_mut,           deref_mut_trait,            Target::Trait,          GenericRequirement::Exact(0);\n+    DerefTarget,             deref_target,        deref_target,               Target::AssocTy,        GenericRequirement::None;\n+    Receiver,                receiver,            receiver_trait,             Target::Trait,          GenericRequirement::None;\n+\n+    Fn,                      fn,                  fn_trait,                   Target::Trait,          GenericRequirement::Exact(1);\n+    FnMut,                   fn_mut,              fn_mut_trait,               Target::Trait,          GenericRequirement::Exact(1);\n+    FnOnce,                  fn_once,             fn_once_trait,              Target::Trait,          GenericRequirement::Exact(1);\n+\n+    FnOnceOutput,            fn_once_output,      fn_once_output,             Target::AssocTy,        GenericRequirement::None;\n+\n+    Future,                  future_trait,        future_trait,               Target::Trait,          GenericRequirement::Exact(0);\n+    GeneratorState,          generator_state,     gen_state,                  Target::Enum,           GenericRequirement::None;\n+    Generator,               generator,           gen_trait,                  Target::Trait,          GenericRequirement::Minimum(1);\n+    Unpin,                   unpin,               unpin_trait,                Target::Trait,          GenericRequirement::None;\n+    Pin,                     pin,                 pin_type,                   Target::Struct,         GenericRequirement::None;\n+\n+    PartialEq,               eq,                  eq_trait,                   Target::Trait,          GenericRequirement::Exact(1);\n+    PartialOrd,              partial_ord,         partial_ord_trait,          Target::Trait,          GenericRequirement::Exact(1);\n+\n+    // A number of panic-related lang items. The `panic` item corresponds to divide-by-zero and\n+    // various panic cases with `match`. The `panic_bounds_check` item is for indexing arrays.\n+    //\n+    // The `begin_unwind` lang item has a predefined symbol name and is sort of a \"weak lang item\"\n+    // in the sense that a crate is not required to have it defined to use it, but a final product\n+    // is required to define it somewhere. Additionally, there are restrictions on crates that use\n+    // a weak lang item, but do not have it defined.\n+    Panic,                   panic,               panic_fn,                   Target::Fn,             GenericRequirement::Exact(0);\n+    PanicNounwind,           panic_nounwind,      panic_nounwind,             Target::Fn,             GenericRequirement::Exact(0);\n+    PanicFmt,                panic_fmt,           panic_fmt,                  Target::Fn,             GenericRequirement::None;\n+    PanicDisplay,            panic_display,       panic_display,              Target::Fn,             GenericRequirement::None;\n+    ConstPanicFmt,           const_panic_fmt,     const_panic_fmt,            Target::Fn,             GenericRequirement::None;\n+    PanicBoundsCheck,        panic_bounds_check,  panic_bounds_check_fn,      Target::Fn,             GenericRequirement::Exact(0);\n+    PanicInfo,               panic_info,          panic_info,                 Target::Struct,         GenericRequirement::None;\n+    PanicLocation,           panic_location,      panic_location,             Target::Struct,         GenericRequirement::None;\n+    PanicImpl,               panic_impl,          panic_impl,                 Target::Fn,             GenericRequirement::None;\n+    PanicCannotUnwind,       panic_cannot_unwind, panic_cannot_unwind,        Target::Fn,             GenericRequirement::Exact(0);\n+    /// libstd panic entry point. Necessary for const eval to be able to catch it\n+    BeginPanic,              begin_panic,         begin_panic_fn,             Target::Fn,             GenericRequirement::None;\n+\n+    ExchangeMalloc,          exchange_malloc,     exchange_malloc_fn,         Target::Fn,             GenericRequirement::None;\n+    BoxFree,                 box_free,            box_free_fn,                Target::Fn,             GenericRequirement::Minimum(1);\n+    DropInPlace,             drop_in_place,       drop_in_place_fn,           Target::Fn,             GenericRequirement::Minimum(1);\n+    AllocLayout,             alloc_layout,        alloc_layout,               Target::Struct,         GenericRequirement::None;\n+\n+    Start,                   start,               start_fn,                   Target::Fn,             GenericRequirement::Exact(1);\n+\n+    EhPersonality,           eh_personality,      eh_personality,             Target::Fn,             GenericRequirement::None;\n+    EhCatchTypeinfo,         eh_catch_typeinfo,   eh_catch_typeinfo,          Target::Static,         GenericRequirement::None;\n+\n+    OwnedBox,                owned_box,           owned_box,                  Target::Struct,         GenericRequirement::Minimum(1);\n+\n+    PhantomData,             phantom_data,        phantom_data,               Target::Struct,         GenericRequirement::Exact(1);\n+\n+    ManuallyDrop,            manually_drop,       manually_drop,              Target::Struct,         GenericRequirement::None;\n+\n+    MaybeUninit,             maybe_uninit,        maybe_uninit,               Target::Union,          GenericRequirement::None;\n+\n+    /// Align offset for stride != 1; must not panic.\n+    AlignOffset,             align_offset,        align_offset_fn,            Target::Fn,             GenericRequirement::None;\n+\n+    Termination,             termination,         termination,                Target::Trait,          GenericRequirement::None;\n+\n+    Try,                     Try,                 try_trait,                  Target::Trait,          GenericRequirement::None;\n+\n+    Tuple,                   tuple_trait,         tuple_trait,                Target::Trait,          GenericRequirement::Exact(0);\n+\n+    SliceLen,                slice_len_fn,        slice_len_fn,               Target::Method(MethodKind::Inherent), GenericRequirement::None;\n+\n+    // Language items from AST lowering\n+    TryTraitFromResidual,    from_residual,       from_residual_fn,           Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n+    TryTraitFromOutput,      from_output,         from_output_fn,             Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n+    TryTraitBranch,          branch,              branch_fn,                  Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n+    TryTraitFromYeet,        from_yeet,           from_yeet_fn,               Target::Fn,             GenericRequirement::None;\n+\n+    PointerSized,            pointer_sized,       pointer_sized,              Target::Trait,          GenericRequirement::Exact(0);\n+\n+    Poll,                    Poll,                poll,                       Target::Enum,           GenericRequirement::None;\n+    PollReady,               Ready,               poll_ready_variant,         Target::Variant,        GenericRequirement::None;\n+    PollPending,             Pending,             poll_pending_variant,       Target::Variant,        GenericRequirement::None;\n+\n+    // FIXME(swatinem): the following lang items are used for async lowering and\n+    // should become obsolete eventually.\n+    ResumeTy,                ResumeTy,            resume_ty,                  Target::Struct,         GenericRequirement::None;\n+    IdentityFuture,          identity_future,     identity_future_fn,         Target::Fn,             GenericRequirement::None;\n+    GetContext,              get_context,         get_context_fn,             Target::Fn,             GenericRequirement::None;\n+\n+    Context,                 Context,             context,                    Target::Struct,         GenericRequirement::None;\n+    FuturePoll,              poll,                future_poll_fn,             Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n+\n+    FromFrom,                from,                from_fn,                    Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n+\n+    OptionSome,              Some,                option_some_variant,        Target::Variant,        GenericRequirement::None;\n+    OptionNone,              None,                option_none_variant,        Target::Variant,        GenericRequirement::None;\n+\n+    ResultOk,                Ok,                  result_ok_variant,          Target::Variant,        GenericRequirement::None;\n+    ResultErr,               Err,                 result_err_variant,         Target::Variant,        GenericRequirement::None;\n+\n+    ControlFlowContinue,     Continue,            cf_continue_variant,        Target::Variant,        GenericRequirement::None;\n+    ControlFlowBreak,        Break,               cf_break_variant,           Target::Variant,        GenericRequirement::None;\n+\n+    IntoFutureIntoFuture,    into_future,         into_future_fn,             Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n+    IntoIterIntoIter,        into_iter,           into_iter_fn,               Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n+    IteratorNext,            next,                next_fn,                    Target::Method(MethodKind::Trait { body: false}), GenericRequirement::None;\n+\n+    PinNewUnchecked,         new_unchecked,       new_unchecked_fn,           Target::Method(MethodKind::Inherent), GenericRequirement::None;\n+\n+    RangeFrom,               RangeFrom,           range_from_struct,          Target::Struct,         GenericRequirement::None;\n+    RangeFull,               RangeFull,           range_full_struct,          Target::Struct,         GenericRequirement::None;\n+    RangeInclusiveStruct,    RangeInclusive,      range_inclusive_struct,     Target::Struct,         GenericRequirement::None;\n+    RangeInclusiveNew,       range_inclusive_new, range_inclusive_new_method, Target::Method(MethodKind::Inherent), GenericRequirement::None;\n+    Range,                   Range,               range_struct,               Target::Struct,         GenericRequirement::None;\n+    RangeToInclusive,        RangeToInclusive,    range_to_inclusive_struct,  Target::Struct,         GenericRequirement::None;\n+    RangeTo,                 RangeTo,             range_to_struct,            Target::Struct,         GenericRequirement::None;\n+\n+    String,                  String,              string,                     Target::Struct,         GenericRequirement::None;\n+}"}, {"sha": "b62f4fe77016021c61ebaea3cb75352ecadaf903", "filename": "crates/hir-expand/src/name.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fhir-expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fhir-expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fname.rs?ref=daa0138e4c159d5753e41a447201b6191437276e", "patch": "@@ -133,6 +133,14 @@ impl Name {\n         }\n     }\n \n+    /// Returns the text this name represents if it isn't a tuple field.\n+    pub fn as_str(&self) -> Option<&str> {\n+        match &self.0 {\n+            Repr::Text(it) => Some(it),\n+            _ => None,\n+        }\n+    }\n+\n     /// Returns the textual representation of this name as a [`SmolStr`].\n     /// Prefer using this over [`ToString::to_string`] if possible as this conversion is cheaper in\n     /// the general case."}, {"sha": "caddca6d9152e0afc6714043317e996f4a93f0ca", "filename": "crates/hir-ty/src/autoderef.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fhir-ty%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fhir-ty%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fautoderef.rs?ref=daa0138e4c159d5753e41a447201b6191437276e", "patch": "@@ -6,9 +6,9 @@\n use std::sync::Arc;\n \n use chalk_ir::cast::Cast;\n+use hir_def::lang_item::LangItem;\n use hir_expand::name::name;\n use limit::Limit;\n-use syntax::SmolStr;\n \n use crate::{\n     db::HirDatabase, infer::unify::InferenceTable, Canonical, Goal, Interner, ProjectionTyExt,\n@@ -117,9 +117,8 @@ fn deref_by_trait(table: &mut InferenceTable<'_>, ty: Ty) -> Option<Ty> {\n     }\n \n     let db = table.db;\n-    let deref_trait = db\n-        .lang_item(table.trait_env.krate, SmolStr::new_inline(\"deref\"))\n-        .and_then(|l| l.as_trait())?;\n+    let deref_trait =\n+        db.lang_item(table.trait_env.krate, LangItem::Deref).and_then(|l| l.as_trait())?;\n     let target = db.trait_data(deref_trait).associated_type_by_name(&name![Target])?;\n \n     let projection = {"}, {"sha": "bbb6625855d32e55fefd63947da63f0182f3ec71", "filename": "crates/hir-ty/src/chalk_db.rs", "status": "modified", "additions": 40, "deletions": 41, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs?ref=daa0138e4c159d5753e41a447201b6191437276e", "patch": "@@ -3,7 +3,6 @@\n use std::sync::Arc;\n \n use cov_mark::hit;\n-use syntax::SmolStr;\n use tracing::debug;\n \n use chalk_ir::{cast::Cast, fold::shift::Shift, CanonicalVarKinds};\n@@ -12,7 +11,7 @@ use chalk_solve::rust_ir::{self, OpaqueTyDatumBound, WellKnownTrait};\n use base_db::CrateId;\n use hir_def::{\n     expr::Movability,\n-    lang_item::{lang_attr, LangItemTarget},\n+    lang_item::{lang_attr, LangItem, LangItemTarget},\n     AssocItemId, GenericDefId, HasModule, ItemContainerId, Lookup, ModuleId, TypeAliasId,\n };\n use hir_expand::name::name;\n@@ -182,9 +181,9 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n         &self,\n         well_known_trait: rust_ir::WellKnownTrait,\n     ) -> Option<chalk_ir::TraitId<Interner>> {\n-        let lang_attr = lang_attr_from_well_known_trait(well_known_trait);\n+        let lang_attr = lang_item_from_well_known_trait(well_known_trait);\n         let trait_ = match self.db.lang_item(self.krate, lang_attr.into()) {\n-            Some(LangItemTarget::TraitId(trait_)) => trait_,\n+            Some(LangItemTarget::Trait(trait_)) => trait_,\n             _ => return None,\n         };\n         Some(to_chalk_trait_id(trait_))\n@@ -216,7 +215,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n             crate::ImplTraitId::AsyncBlockTypeImplTrait(..) => {\n                 if let Some((future_trait, future_output)) = self\n                     .db\n-                    .lang_item(self.krate, SmolStr::new_inline(\"future_trait\"))\n+                    .lang_item(self.krate, LangItem::Future)\n                     .and_then(|item| item.as_trait())\n                     .and_then(|trait_| {\n                         let alias =\n@@ -246,7 +245,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n                     binder.push(crate::wrap_empty_binders(impl_bound));\n                     let sized_trait = self\n                         .db\n-                        .lang_item(self.krate, SmolStr::new_inline(\"sized\"))\n+                        .lang_item(self.krate, LangItem::Sized)\n                         .and_then(|item| item.as_trait());\n                     if let Some(sized_trait_) = sized_trait {\n                         let sized_bound = WhereClause::Implemented(TraitRef {\n@@ -493,7 +492,7 @@ pub(crate) fn associated_ty_data_query(\n \n     if !ctx.unsized_types.borrow().contains(&self_ty) {\n         let sized_trait = db\n-            .lang_item(resolver.krate(), SmolStr::new_inline(\"sized\"))\n+            .lang_item(resolver.krate(), LangItem::Sized)\n             .and_then(|lang_item| lang_item.as_trait().map(to_chalk_trait_id));\n         let sized_bound = sized_trait.into_iter().map(|sized_trait| {\n             let trait_bound =\n@@ -541,8 +540,8 @@ pub(crate) fn trait_datum_query(\n     let where_clauses = convert_where_clauses(db, trait_.into(), &bound_vars);\n     let associated_ty_ids = trait_data.associated_types().map(to_assoc_type_id).collect();\n     let trait_datum_bound = rust_ir::TraitDatumBound { where_clauses };\n-    let well_known =\n-        lang_attr(db.upcast(), trait_).and_then(|name| well_known_trait_from_lang_attr(&name));\n+    let well_known = lang_attr(db.upcast(), trait_)\n+        .and_then(|name| well_known_trait_from_lang_item(LangItem::from_str(&name)?));\n     let trait_datum = TraitDatum {\n         id: trait_id,\n         binders: make_binders(db, &generic_params, trait_datum_bound),\n@@ -553,42 +552,42 @@ pub(crate) fn trait_datum_query(\n     Arc::new(trait_datum)\n }\n \n-fn well_known_trait_from_lang_attr(name: &str) -> Option<WellKnownTrait> {\n-    Some(match name {\n-        \"clone\" => WellKnownTrait::Clone,\n-        \"coerce_unsized\" => WellKnownTrait::CoerceUnsized,\n-        \"copy\" => WellKnownTrait::Copy,\n-        \"discriminant_kind\" => WellKnownTrait::DiscriminantKind,\n-        \"dispatch_from_dyn\" => WellKnownTrait::DispatchFromDyn,\n-        \"drop\" => WellKnownTrait::Drop,\n-        \"fn\" => WellKnownTrait::Fn,\n-        \"fn_mut\" => WellKnownTrait::FnMut,\n-        \"fn_once\" => WellKnownTrait::FnOnce,\n-        \"generator\" => WellKnownTrait::Generator,\n-        \"sized\" => WellKnownTrait::Sized,\n-        \"unpin\" => WellKnownTrait::Unpin,\n-        \"unsize\" => WellKnownTrait::Unsize,\n-        \"tuple_trait\" => WellKnownTrait::Tuple,\n+fn well_known_trait_from_lang_item(item: LangItem) -> Option<WellKnownTrait> {\n+    Some(match item {\n+        LangItem::Clone => WellKnownTrait::Clone,\n+        LangItem::CoerceUnsized => WellKnownTrait::CoerceUnsized,\n+        LangItem::Copy => WellKnownTrait::Copy,\n+        LangItem::DiscriminantKind => WellKnownTrait::DiscriminantKind,\n+        LangItem::DispatchFromDyn => WellKnownTrait::DispatchFromDyn,\n+        LangItem::Drop => WellKnownTrait::Drop,\n+        LangItem::Fn => WellKnownTrait::Fn,\n+        LangItem::FnMut => WellKnownTrait::FnMut,\n+        LangItem::FnOnce => WellKnownTrait::FnOnce,\n+        LangItem::Generator => WellKnownTrait::Generator,\n+        LangItem::Sized => WellKnownTrait::Sized,\n+        LangItem::Unpin => WellKnownTrait::Unpin,\n+        LangItem::Unsize => WellKnownTrait::Unsize,\n+        LangItem::Tuple => WellKnownTrait::Tuple,\n         _ => return None,\n     })\n }\n \n-fn lang_attr_from_well_known_trait(attr: WellKnownTrait) -> &'static str {\n-    match attr {\n-        WellKnownTrait::Clone => \"clone\",\n-        WellKnownTrait::CoerceUnsized => \"coerce_unsized\",\n-        WellKnownTrait::Copy => \"copy\",\n-        WellKnownTrait::DiscriminantKind => \"discriminant_kind\",\n-        WellKnownTrait::DispatchFromDyn => \"dispatch_from_dyn\",\n-        WellKnownTrait::Drop => \"drop\",\n-        WellKnownTrait::Fn => \"fn\",\n-        WellKnownTrait::FnMut => \"fn_mut\",\n-        WellKnownTrait::FnOnce => \"fn_once\",\n-        WellKnownTrait::Generator => \"generator\",\n-        WellKnownTrait::Sized => \"sized\",\n-        WellKnownTrait::Tuple => \"tuple_trait\",\n-        WellKnownTrait::Unpin => \"unpin\",\n-        WellKnownTrait::Unsize => \"unsize\",\n+fn lang_item_from_well_known_trait(trait_: WellKnownTrait) -> LangItem {\n+    match trait_ {\n+        WellKnownTrait::Clone => LangItem::Clone,\n+        WellKnownTrait::CoerceUnsized => LangItem::CoerceUnsized,\n+        WellKnownTrait::Copy => LangItem::Copy,\n+        WellKnownTrait::DiscriminantKind => LangItem::DiscriminantKind,\n+        WellKnownTrait::DispatchFromDyn => LangItem::DispatchFromDyn,\n+        WellKnownTrait::Drop => LangItem::Drop,\n+        WellKnownTrait::Fn => LangItem::Fn,\n+        WellKnownTrait::FnMut => LangItem::FnMut,\n+        WellKnownTrait::FnOnce => LangItem::FnOnce,\n+        WellKnownTrait::Generator => LangItem::Generator,\n+        WellKnownTrait::Sized => LangItem::Sized,\n+        WellKnownTrait::Tuple => LangItem::Tuple,\n+        WellKnownTrait::Unpin => LangItem::Unpin,\n+        WellKnownTrait::Unsize => LangItem::Unsize,\n     }\n }\n "}, {"sha": "329c87c74e97ebf4f8af9aeb745f3e67246f6d4c", "filename": "crates/hir-ty/src/chalk_ext.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs?ref=daa0138e4c159d5753e41a447201b6191437276e", "patch": "@@ -4,10 +4,10 @@ use chalk_ir::{FloatTy, IntTy, Mutability, Scalar, TyVariableKind, UintTy};\n use hir_def::{\n     builtin_type::{BuiltinFloat, BuiltinInt, BuiltinType, BuiltinUint},\n     generics::TypeOrConstParamData,\n+    lang_item::LangItem,\n     type_ref::Rawness,\n     FunctionId, GenericDefId, HasModule, ItemContainerId, Lookup, TraitId,\n };\n-use syntax::SmolStr;\n \n use crate::{\n     db::HirDatabase, from_assoc_type_id, from_chalk_trait_id, from_foreign_def_id,\n@@ -214,9 +214,8 @@ impl TyExt for Ty {\n                 match db.lookup_intern_impl_trait_id((*opaque_ty_id).into()) {\n                     ImplTraitId::AsyncBlockTypeImplTrait(def, _expr) => {\n                         let krate = def.module(db.upcast()).krate();\n-                        if let Some(future_trait) = db\n-                            .lang_item(krate, SmolStr::new_inline(\"future_trait\"))\n-                            .and_then(|item| item.as_trait())\n+                        if let Some(future_trait) =\n+                            db.lang_item(krate, LangItem::Future).and_then(|item| item.as_trait())\n                         {\n                             // This is only used by type walking.\n                             // Parameters will be walked outside, and projection predicate is not used."}, {"sha": "3286dcb5afd7eed31db7b6195e1f63b4eb0e49e3", "filename": "crates/hir-ty/src/diagnostics/expr.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=daa0138e4c159d5753e41a447201b6191437276e", "patch": "@@ -5,7 +5,9 @@\n use std::fmt;\n use std::sync::Arc;\n \n-use hir_def::{path::path, resolver::HasResolver, AdtId, AssocItemId, DefWithBodyId, HasModule};\n+use hir_def::lang_item::LangItem;\n+use hir_def::{resolver::HasResolver, AdtId, AssocItemId, DefWithBodyId, HasModule};\n+use hir_def::{ItemContainerId, Lookup};\n use hir_expand::name;\n use itertools::Either;\n use itertools::Itertools;\n@@ -245,26 +247,25 @@ struct FilterMapNextChecker {\n impl FilterMapNextChecker {\n     fn new(resolver: &hir_def::resolver::Resolver, db: &dyn HirDatabase) -> Self {\n         // Find and store the FunctionIds for Iterator::filter_map and Iterator::next\n-        let iterator_path = path![core::iter::Iterator];\n-        let mut filter_map_function_id = None;\n-        let mut next_function_id = None;\n-\n-        if let Some(iterator_trait_id) = resolver.resolve_known_trait(db.upcast(), &iterator_path) {\n-            let iterator_trait_items = &db.trait_data(iterator_trait_id).items;\n-            for item in iterator_trait_items.iter() {\n-                if let (name, AssocItemId::FunctionId(id)) = item {\n-                    if *name == name![filter_map] {\n-                        filter_map_function_id = Some(*id);\n+        let (next_function_id, filter_map_function_id) = match db\n+            .lang_item(resolver.krate(), LangItem::IteratorNext)\n+            .and_then(|it| it.as_function())\n+        {\n+            Some(next_function_id) => (\n+                Some(next_function_id),\n+                match next_function_id.lookup(db.upcast()).container {\n+                    ItemContainerId::TraitId(iterator_trait_id) => {\n+                        let iterator_trait_items = &db.trait_data(iterator_trait_id).items;\n+                        iterator_trait_items.iter().find_map(|(name, it)| match it {\n+                            &AssocItemId::FunctionId(id) if *name == name![filter_map] => Some(id),\n+                            _ => None,\n+                        })\n                     }\n-                    if *name == name![next] {\n-                        next_function_id = Some(*id);\n-                    }\n-                }\n-                if filter_map_function_id.is_some() && next_function_id.is_some() {\n-                    break;\n-                }\n-            }\n-        }\n+                    _ => None,\n+                },\n+            ),\n+            None => (None, None),\n+        };\n         Self { filter_map_function_id, next_function_id, prev_filter_map_expr_id: None }\n     }\n "}, {"sha": "ae2162dd7cd248c2242a778f833b1f7a696e7400", "filename": "crates/hir-ty/src/display.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs?ref=daa0138e4c159d5753e41a447201b6191437276e", "patch": "@@ -12,6 +12,7 @@ use hir_def::{\n     find_path,\n     generics::{TypeOrConstParamData, TypeParamProvenance},\n     item_scope::ItemInNs,\n+    lang_item::LangItem,\n     path::{Path, PathKind},\n     type_ref::{ConstScalar, TraitBoundModifier, TypeBound, TypeRef},\n     visibility::Visibility,\n@@ -21,7 +22,6 @@ use hir_expand::{hygiene::Hygiene, name::Name};\n use intern::{Internable, Interned};\n use itertools::Itertools;\n use smallvec::SmallVec;\n-use syntax::SmolStr;\n \n use crate::{\n     db::HirDatabase,\n@@ -925,7 +925,7 @@ impl SizedByDefault {\n             Self::NotSized => false,\n             Self::Sized { anchor } => {\n                 let sized_trait = db\n-                    .lang_item(anchor, SmolStr::new_inline(\"sized\"))\n+                    .lang_item(anchor, LangItem::Sized)\n                     .and_then(|lang_item| lang_item.as_trait());\n                 Some(trait_) == sized_trait\n             }\n@@ -1057,8 +1057,7 @@ fn write_bounds_like_dyn_trait(\n     }\n     if let SizedByDefault::Sized { anchor } = default_sized {\n         let sized_trait =\n-            f.db.lang_item(anchor, SmolStr::new_inline(\"sized\"))\n-                .and_then(|lang_item| lang_item.as_trait());\n+            f.db.lang_item(anchor, LangItem::Sized).and_then(|lang_item| lang_item.as_trait());\n         if !is_sized {\n             if !first {\n                 write!(f, \" + \")?;"}, {"sha": "4402c75947c7b21b94d766d139fb631f866dbcb5", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 32, "deletions": 38, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=daa0138e4c159d5753e41a447201b6191437276e", "patch": "@@ -22,15 +22,15 @@ use hir_def::{\n     builtin_type::{BuiltinInt, BuiltinType, BuiltinUint},\n     data::{ConstData, StaticData},\n     expr::{BindingAnnotation, ExprId, ExprOrPatId, PatId},\n-    lang_item::LangItemTarget,\n+    lang_item::{LangItem, LangItemTarget},\n     layout::Integer,\n-    path::{path, Path},\n+    path::Path,\n     resolver::{HasResolver, ResolveValueResult, Resolver, TypeNs, ValueNs},\n     type_ref::TypeRef,\n     AdtId, AssocItemId, DefWithBodyId, EnumVariantId, FieldId, FunctionId, HasModule,\n     ItemContainerId, Lookup, TraitId, TypeAliasId, VariantId,\n };\n-use hir_expand::name::{name, Name};\n+use hir_expand::name::name;\n use itertools::Either;\n use la_arena::ArenaMap;\n use rustc_hash::FxHashMap;\n@@ -917,95 +917,89 @@ impl<'a> InferenceContext<'a> {\n         }\n     }\n \n-    fn resolve_lang_item(&self, name: Name) -> Option<LangItemTarget> {\n+    fn resolve_lang_item(&self, item: LangItem) -> Option<LangItemTarget> {\n         let krate = self.resolver.krate();\n-        self.db.lang_item(krate, name.to_smol_str())\n+        self.db.lang_item(krate, item)\n     }\n \n     fn resolve_into_iter_item(&self) -> Option<TypeAliasId> {\n-        let path = path![core::iter::IntoIterator];\n-        let trait_ = self.resolver.resolve_known_trait(self.db.upcast(), &path)?;\n+        let ItemContainerId::TraitId(trait_) = self.resolve_lang_item(LangItem::IntoIterIntoIter)?\n+            .as_function()?\n+            .lookup(self.db.upcast()).container\n+        else { return None };\n         self.db.trait_data(trait_).associated_type_by_name(&name![IntoIter])\n     }\n \n     fn resolve_iterator_item(&self) -> Option<TypeAliasId> {\n-        let path = path![core::iter::Iterator];\n-        let trait_ = self.resolver.resolve_known_trait(self.db.upcast(), &path)?;\n+        let ItemContainerId::TraitId(trait_) = self.resolve_lang_item(LangItem::IteratorNext)?\n+            .as_function()?\n+            .lookup(self.db.upcast()).container\n+        else { return None };\n         self.db.trait_data(trait_).associated_type_by_name(&name![Item])\n     }\n \n     fn resolve_ops_try_ok(&self) -> Option<TypeAliasId> {\n-        // FIXME resolve via lang_item once try v2 is stable\n-        let path = path![core::ops::Try];\n-        let trait_ = self.resolver.resolve_known_trait(self.db.upcast(), &path)?;\n-        let trait_data = self.db.trait_data(trait_);\n-        trait_data\n-            // FIXME remove once try v2 is stable\n-            .associated_type_by_name(&name![Ok])\n-            .or_else(|| trait_data.associated_type_by_name(&name![Output]))\n+        let trait_ = self.resolve_lang_item(LangItem::Try)?.as_trait()?;\n+        self.db.trait_data(trait_).associated_type_by_name(&name![Output])\n     }\n \n     fn resolve_ops_neg_output(&self) -> Option<TypeAliasId> {\n-        let trait_ = self.resolve_lang_item(name![neg])?.as_trait()?;\n+        let trait_ = self.resolve_lang_item(LangItem::Neg)?.as_trait()?;\n         self.db.trait_data(trait_).associated_type_by_name(&name![Output])\n     }\n \n     fn resolve_ops_not_output(&self) -> Option<TypeAliasId> {\n-        let trait_ = self.resolve_lang_item(name![not])?.as_trait()?;\n+        let trait_ = self.resolve_lang_item(LangItem::Not)?.as_trait()?;\n         self.db.trait_data(trait_).associated_type_by_name(&name![Output])\n     }\n \n     fn resolve_future_future_output(&self) -> Option<TypeAliasId> {\n-        let trait_ = self\n-            .resolver\n-            .resolve_known_trait(self.db.upcast(), &path![core::future::IntoFuture])\n-            .or_else(|| self.resolve_lang_item(name![future_trait])?.as_trait())?;\n+        let ItemContainerId::TraitId(trait_) = self\n+            .resolve_lang_item(LangItem::IntoFutureIntoFuture)?\n+            .as_function()?\n+            .lookup(self.db.upcast())\n+            .container\n+        else { return None };\n         self.db.trait_data(trait_).associated_type_by_name(&name![Output])\n     }\n \n     fn resolve_boxed_box(&self) -> Option<AdtId> {\n-        let struct_ = self.resolve_lang_item(name![owned_box])?.as_struct()?;\n+        let struct_ = self.resolve_lang_item(LangItem::OwnedBox)?.as_struct()?;\n         Some(struct_.into())\n     }\n \n     fn resolve_range_full(&self) -> Option<AdtId> {\n-        let path = path![core::ops::RangeFull];\n-        let struct_ = self.resolver.resolve_known_struct(self.db.upcast(), &path)?;\n+        let struct_ = self.resolve_lang_item(LangItem::RangeFull)?.as_struct()?;\n         Some(struct_.into())\n     }\n \n     fn resolve_range(&self) -> Option<AdtId> {\n-        let path = path![core::ops::Range];\n-        let struct_ = self.resolver.resolve_known_struct(self.db.upcast(), &path)?;\n+        let struct_ = self.resolve_lang_item(LangItem::Range)?.as_struct()?;\n         Some(struct_.into())\n     }\n \n     fn resolve_range_inclusive(&self) -> Option<AdtId> {\n-        let path = path![core::ops::RangeInclusive];\n-        let struct_ = self.resolver.resolve_known_struct(self.db.upcast(), &path)?;\n+        let struct_ = self.resolve_lang_item(LangItem::RangeInclusiveStruct)?.as_struct()?;\n         Some(struct_.into())\n     }\n \n     fn resolve_range_from(&self) -> Option<AdtId> {\n-        let path = path![core::ops::RangeFrom];\n-        let struct_ = self.resolver.resolve_known_struct(self.db.upcast(), &path)?;\n+        let struct_ = self.resolve_lang_item(LangItem::RangeFrom)?.as_struct()?;\n         Some(struct_.into())\n     }\n \n     fn resolve_range_to(&self) -> Option<AdtId> {\n-        let path = path![core::ops::RangeTo];\n-        let struct_ = self.resolver.resolve_known_struct(self.db.upcast(), &path)?;\n+        let struct_ = self.resolve_lang_item(LangItem::RangeTo)?.as_struct()?;\n         Some(struct_.into())\n     }\n \n     fn resolve_range_to_inclusive(&self) -> Option<AdtId> {\n-        let path = path![core::ops::RangeToInclusive];\n-        let struct_ = self.resolver.resolve_known_struct(self.db.upcast(), &path)?;\n+        let struct_ = self.resolve_lang_item(LangItem::RangeToInclusive)?.as_struct()?;\n         Some(struct_.into())\n     }\n \n     fn resolve_ops_index(&self) -> Option<TraitId> {\n-        self.resolve_lang_item(name![index])?.as_trait()\n+        self.resolve_lang_item(LangItem::Index)?.as_trait()\n     }\n \n     fn resolve_ops_index_output(&self) -> Option<TypeAliasId> {\n@@ -1014,7 +1008,7 @@ impl<'a> InferenceContext<'a> {\n     }\n \n     fn resolve_va_list(&self) -> Option<AdtId> {\n-        let struct_ = self.resolve_lang_item(name![va_list])?.as_struct()?;\n+        let struct_ = self.resolve_lang_item(LangItem::VaList)?.as_struct()?;\n         Some(struct_.into())\n     }\n }"}, {"sha": "3293534a068bd7dba56c0e4ff0e79a304ad68fdb", "filename": "crates/hir-ty/src/infer/coerce.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=daa0138e4c159d5753e41a447201b6191437276e", "patch": "@@ -8,9 +8,11 @@\n use std::{iter, sync::Arc};\n \n use chalk_ir::{cast::Cast, BoundVar, Goal, Mutability, TyVariableKind};\n-use hir_def::{expr::ExprId, lang_item::LangItemTarget};\n+use hir_def::{\n+    expr::ExprId,\n+    lang_item::{LangItem, LangItemTarget},\n+};\n use stdx::always;\n-use syntax::SmolStr;\n \n use crate::{\n     autoderef::{Autoderef, AutoderefKind},\n@@ -570,11 +572,10 @@ impl<'a> InferenceTable<'a> {\n             reborrow.as_ref().map_or_else(|| from_ty.clone(), |(_, adj)| adj.target.clone());\n \n         let krate = self.trait_env.krate;\n-        let coerce_unsized_trait =\n-            match self.db.lang_item(krate, SmolStr::new_inline(\"coerce_unsized\")) {\n-                Some(LangItemTarget::TraitId(trait_)) => trait_,\n-                _ => return Err(TypeError),\n-            };\n+        let coerce_unsized_trait = match self.db.lang_item(krate, LangItem::CoerceUnsized) {\n+            Some(LangItemTarget::Trait(trait_)) => trait_,\n+            _ => return Err(TypeError),\n+        };\n \n         let coerce_unsized_tref = {\n             let b = TyBuilder::trait_ref(self.db, coerce_unsized_trait);"}, {"sha": "7ae85d20611a80f9b367f80e3d2bb08f3b71471d", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=daa0138e4c159d5753e41a447201b6191437276e", "patch": "@@ -29,7 +29,7 @@ use crate::{\n         const_or_path_to_chalk, generic_arg_to_chalk, lower_to_chalk_mutability, ParamLoweringMode,\n     },\n     mapping::{from_chalk, ToChalk},\n-    method_resolution::{self, lang_names_for_bin_op, VisibleFromModule},\n+    method_resolution::{self, lang_items_for_bin_op, VisibleFromModule},\n     primitive::{self, UintTy},\n     static_lifetime, to_chalk_trait_id,\n     utils::{generics, Generics},\n@@ -1008,7 +1008,7 @@ impl<'a> InferenceContext<'a> {\n         let lhs_ty = self.infer_expr(lhs, &lhs_expectation);\n         let rhs_ty = self.table.new_type_var();\n \n-        let trait_func = lang_names_for_bin_op(op).and_then(|(name, lang_item)| {\n+        let trait_func = lang_items_for_bin_op(op).and_then(|(name, lang_item)| {\n             let trait_id = self.resolve_lang_item(lang_item)?.as_trait()?;\n             let func = self.db.trait_data(trait_id).method_by_name(&name)?;\n             Some((trait_id, func))"}, {"sha": "5308c72161b26bb233a0566b0cddbb2f0ea2deae", "filename": "crates/hir-ty/src/lang_items.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fhir-ty%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fhir-ty%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flang_items.rs?ref=daa0138e4c159d5753e41a447201b6191437276e", "patch": "@@ -1,20 +1,19 @@\n //! Functions to detect special lang items\n \n-use hir_def::{AdtId, HasModule};\n-use hir_expand::name;\n+use hir_def::{lang_item::LangItem, AdtId, HasModule};\n \n use crate::db::HirDatabase;\n \n pub fn is_box(adt: AdtId, db: &dyn HirDatabase) -> bool {\n-    let owned_box = name![owned_box].to_smol_str();\n     let krate = adt.module(db.upcast()).krate();\n-    let box_adt = db.lang_item(krate, owned_box).and_then(|it| it.as_struct()).map(AdtId::from);\n+    let box_adt =\n+        db.lang_item(krate, LangItem::OwnedBox).and_then(|it| it.as_struct()).map(AdtId::from);\n     Some(adt) == box_adt\n }\n \n pub fn is_unsafe_cell(adt: AdtId, db: &dyn HirDatabase) -> bool {\n-    let owned_box = name![unsafe_cell].to_smol_str();\n     let krate = adt.module(db.upcast()).krate();\n-    let box_adt = db.lang_item(krate, owned_box).and_then(|it| it.as_struct()).map(AdtId::from);\n+    let box_adt =\n+        db.lang_item(krate, LangItem::UnsafeCell).and_then(|it| it.as_struct()).map(AdtId::from);\n     Some(adt) == box_adt\n }"}, {"sha": "b1a7ad3e940ed2a41e4a4e60d1c68afb6ac6d804", "filename": "crates/hir-ty/src/lower.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flower.rs?ref=daa0138e4c159d5753e41a447201b6191437276e", "patch": "@@ -23,7 +23,7 @@ use hir_def::{\n     generics::{\n         TypeOrConstParamData, TypeParamProvenance, WherePredicate, WherePredicateTypeTarget,\n     },\n-    lang_item::lang_attr,\n+    lang_item::{lang_attr, LangItem},\n     path::{GenericArg, ModPath, Path, PathKind, PathSegment, PathSegments},\n     resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::{\n@@ -40,7 +40,7 @@ use la_arena::ArenaMap;\n use rustc_hash::FxHashSet;\n use smallvec::SmallVec;\n use stdx::{impl_from, never};\n-use syntax::{ast, SmolStr};\n+use syntax::ast;\n \n use crate::{\n     all_super_traits,\n@@ -954,7 +954,7 @@ impl<'a> TyLoweringContext<'a> {\n             TypeBound::Path(path, TraitBoundModifier::Maybe) => {\n                 let sized_trait = self\n                     .db\n-                    .lang_item(self.resolver.krate(), SmolStr::new_inline(\"sized\"))\n+                    .lang_item(self.resolver.krate(), LangItem::Sized)\n                     .and_then(|lang_item| lang_item.as_trait());\n                 // Don't lower associated type bindings as the only possible relaxed trait bound\n                 // `?Sized` has no of them.\n@@ -1150,7 +1150,7 @@ impl<'a> TyLoweringContext<'a> {\n                 let krate = func.lookup(ctx.db.upcast()).module(ctx.db.upcast()).krate();\n                 let sized_trait = ctx\n                     .db\n-                    .lang_item(krate, SmolStr::new_inline(\"sized\"))\n+                    .lang_item(krate, LangItem::Sized)\n                     .and_then(|lang_item| lang_item.as_trait().map(to_chalk_trait_id));\n                 let sized_clause = sized_trait.map(|trait_id| {\n                     let clause = WhereClause::Implemented(TraitRef {\n@@ -1489,7 +1489,7 @@ fn implicitly_sized_clauses<'a>(\n     let is_trait_def = matches!(def, GenericDefId::TraitId(..));\n     let generic_args = &substitution.as_slice(Interner)[is_trait_def as usize..];\n     let sized_trait = db\n-        .lang_item(resolver.krate(), SmolStr::new_inline(\"sized\"))\n+        .lang_item(resolver.krate(), LangItem::Sized)\n         .and_then(|lang_item| lang_item.as_trait().map(to_chalk_trait_id));\n \n     sized_trait.into_iter().flat_map(move |sized_trait| {"}, {"sha": "858de0005962c0c4cb7989290281e302ddc09a03", "filename": "crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=daa0138e4c159d5753e41a447201b6191437276e", "patch": "@@ -7,8 +7,9 @@ use std::{ops::ControlFlow, sync::Arc};\n use base_db::{CrateId, Edition};\n use chalk_ir::{cast::Cast, Mutability, UniverseIndex};\n use hir_def::{\n-    data::ImplData, item_scope::ItemScope, nameres::DefMap, AssocItemId, BlockId, ConstId,\n-    FunctionId, HasModule, ImplId, ItemContainerId, Lookup, ModuleDefId, ModuleId, TraitId,\n+    data::ImplData, item_scope::ItemScope, lang_item::LangItem, nameres::DefMap, AssocItemId,\n+    BlockId, ConstId, FunctionId, HasModule, ImplId, ItemContainerId, Lookup, ModuleDefId,\n+    ModuleId, TraitId,\n };\n use hir_expand::name::Name;\n use rustc_hash::{FxHashMap, FxHashSet};\n@@ -437,49 +438,49 @@ pub fn def_crates(\n     }\n }\n \n-pub fn lang_names_for_bin_op(op: syntax::ast::BinaryOp) -> Option<(Name, Name)> {\n+pub fn lang_items_for_bin_op(op: syntax::ast::BinaryOp) -> Option<(Name, LangItem)> {\n     use hir_expand::name;\n     use syntax::ast::{ArithOp, BinaryOp, CmpOp, Ordering};\n     Some(match op {\n         BinaryOp::LogicOp(_) => return None,\n         BinaryOp::ArithOp(aop) => match aop {\n-            ArithOp::Add => (name!(add), name!(add)),\n-            ArithOp::Mul => (name!(mul), name!(mul)),\n-            ArithOp::Sub => (name!(sub), name!(sub)),\n-            ArithOp::Div => (name!(div), name!(div)),\n-            ArithOp::Rem => (name!(rem), name!(rem)),\n-            ArithOp::Shl => (name!(shl), name!(shl)),\n-            ArithOp::Shr => (name!(shr), name!(shr)),\n-            ArithOp::BitXor => (name!(bitxor), name!(bitxor)),\n-            ArithOp::BitOr => (name!(bitor), name!(bitor)),\n-            ArithOp::BitAnd => (name!(bitand), name!(bitand)),\n+            ArithOp::Add => (name![add], LangItem::Add),\n+            ArithOp::Mul => (name![mul], LangItem::Mul),\n+            ArithOp::Sub => (name![sub], LangItem::Sub),\n+            ArithOp::Div => (name![div], LangItem::Div),\n+            ArithOp::Rem => (name![rem], LangItem::Rem),\n+            ArithOp::Shl => (name![shl], LangItem::Shl),\n+            ArithOp::Shr => (name![shr], LangItem::Shr),\n+            ArithOp::BitXor => (name![bitxor], LangItem::BitXor),\n+            ArithOp::BitOr => (name![bitor], LangItem::BitOr),\n+            ArithOp::BitAnd => (name![bitand], LangItem::BitAnd),\n         },\n         BinaryOp::Assignment { op: Some(aop) } => match aop {\n-            ArithOp::Add => (name!(add_assign), name!(add_assign)),\n-            ArithOp::Mul => (name!(mul_assign), name!(mul_assign)),\n-            ArithOp::Sub => (name!(sub_assign), name!(sub_assign)),\n-            ArithOp::Div => (name!(div_assign), name!(div_assign)),\n-            ArithOp::Rem => (name!(rem_assign), name!(rem_assign)),\n-            ArithOp::Shl => (name!(shl_assign), name!(shl_assign)),\n-            ArithOp::Shr => (name!(shr_assign), name!(shr_assign)),\n-            ArithOp::BitXor => (name!(bitxor_assign), name!(bitxor_assign)),\n-            ArithOp::BitOr => (name!(bitor_assign), name!(bitor_assign)),\n-            ArithOp::BitAnd => (name!(bitand_assign), name!(bitand_assign)),\n+            ArithOp::Add => (name![add_assign], LangItem::AddAssign),\n+            ArithOp::Mul => (name![mul_assign], LangItem::MulAssign),\n+            ArithOp::Sub => (name![sub_assign], LangItem::SubAssign),\n+            ArithOp::Div => (name![div_assign], LangItem::DivAssign),\n+            ArithOp::Rem => (name![rem_assign], LangItem::RemAssign),\n+            ArithOp::Shl => (name![shl_assign], LangItem::ShlAssign),\n+            ArithOp::Shr => (name![shr_assign], LangItem::ShrAssign),\n+            ArithOp::BitXor => (name![bitxor_assign], LangItem::BitXorAssign),\n+            ArithOp::BitOr => (name![bitor_assign], LangItem::BitOrAssign),\n+            ArithOp::BitAnd => (name![bitand_assign], LangItem::BitAndAssign),\n         },\n         BinaryOp::CmpOp(cop) => match cop {\n-            CmpOp::Eq { negated: false } => (name!(eq), name!(eq)),\n-            CmpOp::Eq { negated: true } => (name!(ne), name!(eq)),\n+            CmpOp::Eq { negated: false } => (name![eq], LangItem::PartialEq),\n+            CmpOp::Eq { negated: true } => (name![ne], LangItem::PartialEq),\n             CmpOp::Ord { ordering: Ordering::Less, strict: false } => {\n-                (name!(le), name!(partial_ord))\n+                (name![le], LangItem::PartialOrd)\n             }\n             CmpOp::Ord { ordering: Ordering::Less, strict: true } => {\n-                (name!(lt), name!(partial_ord))\n+                (name![lt], LangItem::PartialOrd)\n             }\n             CmpOp::Ord { ordering: Ordering::Greater, strict: false } => {\n-                (name!(ge), name!(partial_ord))\n+                (name![ge], LangItem::PartialOrd)\n             }\n             CmpOp::Ord { ordering: Ordering::Greater, strict: true } => {\n-                (name!(gt), name!(partial_ord))\n+                (name![gt], LangItem::PartialOrd)\n             }\n         },\n         BinaryOp::Assignment { op: None } => return None,"}, {"sha": "88670364bde05beb6b24a082df2581a16c3223ed", "filename": "crates/hir-ty/src/tests/traits.rs", "status": "modified", "additions": 12, "deletions": 126, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs?ref=daa0138e4c159d5753e41a447201b6191437276e", "patch": "@@ -163,98 +163,22 @@ fn test() {\n }\n \n #[test]\n-fn infer_try() {\n+fn infer_try_trait() {\n     check_types(\n         r#\"\n-//- /main.rs crate:main deps:core\n+//- minicore: try, result\n fn test() {\n     let r: Result<i32, u64> = Result::Ok(1);\n     let v = r?;\n     v;\n } //^ i32\n \n-//- /core.rs crate:core\n-pub mod ops {\n-    pub trait Try {\n-        type Ok;\n-        type Error;\n-    }\n+impl<O, E> core::ops::Try for Result<O, E> {\n+    type Output = O;\n+    type Error = Result<core::convert::Infallible, E>;\n }\n \n-pub mod result {\n-    pub enum Result<O, E> {\n-        Ok(O),\n-        Err(E)\n-    }\n-\n-    impl<O, E> crate::ops::Try for Result<O, E> {\n-        type Ok = O;\n-        type Error = E;\n-    }\n-}\n-\n-pub mod prelude {\n-    pub mod rust_2018 {\n-        pub use crate::{result::*, ops::*};\n-    }\n-}\n-\"#,\n-    );\n-}\n-\n-#[test]\n-fn infer_try_trait_v2() {\n-    check_types(\n-        r#\"\n-//- /main.rs crate:main deps:core\n-fn test() {\n-    let r: Result<i32, u64> = Result::Ok(1);\n-    let v = r?;\n-    v;\n-} //^ i32\n-\n-//- /core.rs crate:core\n-mod ops {\n-    mod try_trait {\n-        pub trait Try: FromResidual {\n-            type Output;\n-            type Residual;\n-        }\n-        pub trait FromResidual<R = <Self as Try>::Residual> {}\n-    }\n-\n-    pub use self::try_trait::FromResidual;\n-    pub use self::try_trait::Try;\n-}\n-\n-mod convert {\n-    pub trait From<T> {}\n-    impl<T> From<T> for T {}\n-}\n-\n-pub mod result {\n-    use crate::convert::From;\n-    use crate::ops::{Try, FromResidual};\n-\n-    pub enum Infallible {}\n-    pub enum Result<O, E> {\n-        Ok(O),\n-        Err(E)\n-    }\n-\n-    impl<O, E> Try for Result<O, E> {\n-        type Output = O;\n-        type Error = Result<Infallible, E>;\n-    }\n-\n-    impl<T, E, F: From<E>> FromResidual<Result<Infallible, E>> for Result<T, F> {}\n-}\n-\n-pub mod prelude {\n-    pub mod rust_2018 {\n-        pub use crate::result::*;\n-    }\n-}\n+impl<T, E, F: From<E>> core::ops::FromResidual<Result<core::convert::Infallible, E>> for Result<T, F> {}\n \"#,\n     );\n }\n@@ -263,7 +187,8 @@ pub mod prelude {\n fn infer_for_loop() {\n     check_types(\n         r#\"\n-//- /main.rs crate:main deps:core,alloc\n+//- minicore: iterator\n+//- /main.rs crate:main deps:alloc\n #![no_std]\n use alloc::collections::Vec;\n \n@@ -275,23 +200,7 @@ fn test() {\n     } //^ &str\n }\n \n-//- /core.rs crate:core\n-pub mod iter {\n-    pub trait IntoIterator {\n-        type Item;\n-        type IntoIter: Iterator<Item = Self::Item>;\n-    }\n-    pub trait Iterator {\n-        type Item;\n-    }\n-}\n-pub mod prelude {\n-    pub mod rust_2018 {\n-        pub use crate::iter::*;\n-    }\n-}\n-\n-//- /alloc.rs crate:alloc deps:core\n+//- /alloc.rs crate:alloc\n #![no_std]\n pub mod collections {\n     pub struct Vec<T> {}\n@@ -2999,40 +2908,17 @@ fn test() {\n fn integer_range_iterate() {\n     check_types(\n         r#\"\n-//- /main.rs crate:main deps:core\n+//- minicore: range, iterator\n+//- /main.rs crate:main\n fn test() {\n     for x in 0..100 { x; }\n }                   //^ i32\n \n-//- /core.rs crate:core\n-pub mod ops {\n-    pub struct Range<Idx> {\n-        pub start: Idx,\n-        pub end: Idx,\n-    }\n-}\n-\n-pub mod iter {\n-    pub trait Iterator {\n-        type Item;\n-    }\n-\n-    pub trait IntoIterator {\n-        type Item;\n-        type IntoIter: Iterator<Item = Self::Item>;\n-    }\n-\n-    impl<T> IntoIterator for T where T: Iterator {\n-        type Item = <T as Iterator>::Item;\n-        type IntoIter = Self;\n-    }\n-}\n-\n trait Step {}\n impl Step for i32 {}\n impl Step for i64 {}\n \n-impl<A: Step> iter::Iterator for ops::Range<A> {\n+impl<A: Step> core::iter::Iterator for core::ops::Range<A> {\n     type Item = A;\n }\n \"#,"}, {"sha": "3ab85c68f5b9db67e809a8d60c8ff1a821c570cf", "filename": "crates/hir-ty/src/traits.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fhir-ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fhir-ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftraits.rs?ref=daa0138e4c159d5753e41a447201b6191437276e", "patch": "@@ -7,9 +7,11 @@ use chalk_recursive::Cache;\n use chalk_solve::{logging_db::LoggingRustIrDatabase, Solver};\n \n use base_db::CrateId;\n-use hir_def::{lang_item::LangItemTarget, TraitId};\n+use hir_def::{\n+    lang_item::{LangItem, LangItemTarget},\n+    TraitId,\n+};\n use stdx::panic_context;\n-use syntax::SmolStr;\n \n use crate::{\n     db::HirDatabase, infer::unify::InferenceTable, AliasEq, AliasTy, Canonical, DomainGoal, Goal,\n@@ -177,18 +179,18 @@ pub enum FnTrait {\n }\n \n impl FnTrait {\n-    const fn lang_item_name(self) -> &'static str {\n+    const fn lang_item(self) -> LangItem {\n         match self {\n-            FnTrait::FnOnce => \"fn_once\",\n-            FnTrait::FnMut => \"fn_mut\",\n-            FnTrait::Fn => \"fn\",\n+            FnTrait::FnOnce => LangItem::FnOnce,\n+            FnTrait::FnMut => LangItem::FnMut,\n+            FnTrait::Fn => LangItem::Fn,\n         }\n     }\n \n     pub fn get_id(&self, db: &dyn HirDatabase, krate: CrateId) -> Option<TraitId> {\n-        let target = db.lang_item(krate, SmolStr::new_inline(self.lang_item_name()))?;\n+        let target = db.lang_item(krate, self.lang_item())?;\n         match target {\n-            LangItemTarget::TraitId(t) => Some(t),\n+            LangItemTarget::Trait(t) => Some(t),\n             _ => None,\n         }\n     }"}, {"sha": "396cba89b67d74403aadee4eb290f6731a7c7268", "filename": "crates/hir-ty/src/utils.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fhir-ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fhir-ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Futils.rs?ref=daa0138e4c159d5753e41a447201b6191437276e", "patch": "@@ -11,6 +11,7 @@ use hir_def::{\n         GenericParams, TypeOrConstParamData, TypeParamProvenance, WherePredicate,\n         WherePredicateTypeTarget,\n     },\n+    lang_item::LangItem,\n     resolver::{HasResolver, TypeNs},\n     type_ref::{TraitBoundModifier, TypeRef},\n     ConstParamId, FunctionId, GenericDefId, ItemContainerId, Lookup, TraitId, TypeAliasId,\n@@ -21,17 +22,16 @@ use intern::Interned;\n use itertools::Either;\n use rustc_hash::FxHashSet;\n use smallvec::{smallvec, SmallVec};\n-use syntax::SmolStr;\n \n use crate::{\n     db::HirDatabase, ChalkTraitId, Interner, Substitution, TraitRef, TraitRefExt, WhereClause,\n };\n \n pub(crate) fn fn_traits(db: &dyn DefDatabase, krate: CrateId) -> impl Iterator<Item = TraitId> {\n     [\n-        db.lang_item(krate, SmolStr::new_inline(\"fn\")),\n-        db.lang_item(krate, SmolStr::new_inline(\"fn_mut\")),\n-        db.lang_item(krate, SmolStr::new_inline(\"fn_once\")),\n+        db.lang_item(krate, LangItem::Fn),\n+        db.lang_item(krate, LangItem::FnMut),\n+        db.lang_item(krate, LangItem::FnOnce),\n     ]\n     .into_iter()\n     .flatten()"}, {"sha": "0d19420127f54fd171dccb521161b1ed0db9c900", "filename": "crates/hir/src/display.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fhir%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fhir%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdisplay.rs?ref=daa0138e4c159d5753e41a447201b6191437276e", "patch": "@@ -4,6 +4,7 @@ use hir_def::{\n     generics::{\n         TypeOrConstParamData, TypeParamProvenance, WherePredicate, WherePredicateTypeTarget,\n     },\n+    lang_item::LangItem,\n     type_ref::{TypeBound, TypeRef},\n     AdtId, GenericDefId,\n };\n@@ -14,7 +15,6 @@ use hir_ty::{\n     },\n     Interner, TraitRefExt, WhereClause,\n };\n-use syntax::SmolStr;\n \n use crate::{\n     Adt, Const, ConstParam, Enum, Field, Function, GenericParam, HasCrate, HasVisibility,\n@@ -261,8 +261,7 @@ impl HirDisplay for TypeParam {\n             bounds.iter().cloned().map(|b| b.substitute(Interner, &substs)).collect();\n         let krate = self.id.parent().krate(f.db).id;\n         let sized_trait =\n-            f.db.lang_item(krate, SmolStr::new_inline(\"sized\"))\n-                .and_then(|lang_item| lang_item.as_trait());\n+            f.db.lang_item(krate, LangItem::Sized).and_then(|lang_item| lang_item.as_trait());\n         let has_only_sized_bound = predicates.iter().all(move |pred| match pred.skip_binders() {\n             WhereClause::Implemented(it) => Some(it.hir_trait_id()) == sized_trait,\n             _ => false,"}, {"sha": "6ec39dfd73fd5177388c579d3670afd0191712ac", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=daa0138e4c159d5753e41a447201b6191437276e", "patch": "@@ -44,7 +44,7 @@ use hir_def::{\n     expr::{BindingAnnotation, ExprOrPatId, LabelId, Pat, PatId},\n     generics::{TypeOrConstParamData, TypeParamProvenance},\n     item_tree::ItemTreeNode,\n-    lang_item::LangItemTarget,\n+    lang_item::{LangItem, LangItemTarget},\n     layout::{Layout, LayoutError, ReprOptions},\n     nameres::{self, diagnostics::DefDiagnostic},\n     per_ns::PerNs,\n@@ -1836,7 +1836,7 @@ pub struct Trait {\n \n impl Trait {\n     pub fn lang(db: &dyn HirDatabase, krate: Crate, name: &Name) -> Option<Trait> {\n-        db.lang_item(krate.into(), name.to_smol_str())\n+        db.lang_item(krate.into(), LangItem::from_name(name)?)\n             .and_then(LangItemTarget::as_trait)\n             .map(Into::into)\n     }\n@@ -3009,16 +3009,15 @@ impl Type {\n     /// This function is used in `.await` syntax completion.\n     pub fn impls_into_future(&self, db: &dyn HirDatabase) -> bool {\n         let trait_ = db\n-            .lang_item(self.env.krate, SmolStr::new_inline(\"into_future\"))\n+            .lang_item(self.env.krate, LangItem::IntoFutureIntoFuture)\n             .and_then(|it| {\n                 let into_future_fn = it.as_function()?;\n                 let assoc_item = as_assoc_item(db, AssocItem::Function, into_future_fn)?;\n                 let into_future_trait = assoc_item.containing_trait_or_trait_impl(db)?;\n                 Some(into_future_trait.id)\n             })\n             .or_else(|| {\n-                let future_trait =\n-                    db.lang_item(self.env.krate, SmolStr::new_inline(\"future_trait\"))?;\n+                let future_trait = db.lang_item(self.env.krate, LangItem::Future)?;\n                 future_trait.as_trait()\n             });\n \n@@ -3111,9 +3110,9 @@ impl Type {\n     }\n \n     pub fn is_copy(&self, db: &dyn HirDatabase) -> bool {\n-        let lang_item = db.lang_item(self.env.krate, SmolStr::new_inline(\"copy\"));\n+        let lang_item = db.lang_item(self.env.krate, LangItem::Copy);\n         let copy_trait = match lang_item {\n-            Some(LangItemTarget::TraitId(it)) => it,\n+            Some(LangItemTarget::Trait(it)) => it,\n             _ => return false,\n         };\n         self.impls_trait(db, copy_trait.into(), &[])"}, {"sha": "5e0c9933a7b6be762406ca917bb26ef4f2de7531", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=daa0138e4c159d5753e41a447201b6191437276e", "patch": "@@ -17,6 +17,7 @@ use hir_def::{\n         Body, BodySourceMap,\n     },\n     expr::{ExprId, Pat, PatId},\n+    lang_item::LangItem,\n     macro_id_to_def_id,\n     path::{ModPath, Path, PathKind},\n     resolver::{resolver_for_scope, Resolver, TypeNs, ValueNs},\n@@ -37,7 +38,7 @@ use hir_ty::{\n         record_literal_missing_fields, record_pattern_missing_fields, unsafe_expressions,\n         UnsafeExpr,\n     },\n-    method_resolution::{self, lang_names_for_bin_op},\n+    method_resolution::{self, lang_items_for_bin_op},\n     Adjustment, InferenceResult, Interner, Substitution, Ty, TyExt, TyKind, TyLoweringContext,\n };\n use itertools::Itertools;\n@@ -294,12 +295,8 @@ impl SourceAnalyzer {\n             }\n         }\n \n-        let future_trait = db\n-            .lang_item(self.resolver.krate(), hir_expand::name![future_trait].to_smol_str())?\n-            .as_trait()?;\n-        let poll_fn = db\n-            .lang_item(self.resolver.krate(), hir_expand::name![poll].to_smol_str())?\n-            .as_function()?;\n+        let future_trait = db.lang_item(self.resolver.krate(), LangItem::Future)?.as_trait()?;\n+        let poll_fn = db.lang_item(self.resolver.krate(), LangItem::FuturePoll)?.as_function()?;\n         // HACK: subst for `poll()` coincides with that for `Future` because `poll()` itself\n         // doesn't have any generic parameters, so we skip building another subst for `poll()`.\n         let substs = hir_ty::TyBuilder::subst_for_def(db, future_trait, None).push(ty).build();\n@@ -311,14 +308,14 @@ impl SourceAnalyzer {\n         db: &dyn HirDatabase,\n         prefix_expr: &ast::PrefixExpr,\n     ) -> Option<FunctionId> {\n-        let lang_item_name = match prefix_expr.op_kind()? {\n-            ast::UnaryOp::Deref => name![deref],\n-            ast::UnaryOp::Not => name![not],\n-            ast::UnaryOp::Neg => name![neg],\n+        let (lang_item, fn_name) = match prefix_expr.op_kind()? {\n+            ast::UnaryOp::Deref => (LangItem::Deref, name![deref]),\n+            ast::UnaryOp::Not => (LangItem::Not, name![not]),\n+            ast::UnaryOp::Neg => (LangItem::Neg, name![neg]),\n         };\n         let ty = self.ty_of_expr(db, &prefix_expr.expr()?)?;\n \n-        let (op_trait, op_fn) = self.lang_trait_fn(db, &lang_item_name, &lang_item_name)?;\n+        let (op_trait, op_fn) = self.lang_trait_fn(db, lang_item, &fn_name)?;\n         // HACK: subst for all methods coincides with that for their trait because the methods\n         // don't have any generic parameters, so we skip building another subst for the methods.\n         let substs = hir_ty::TyBuilder::subst_for_def(db, op_trait, None).push(ty.clone()).build();\n@@ -334,9 +331,7 @@ impl SourceAnalyzer {\n         let base_ty = self.ty_of_expr(db, &index_expr.base()?)?;\n         let index_ty = self.ty_of_expr(db, &index_expr.index()?)?;\n \n-        let lang_item_name = name![index];\n-\n-        let (op_trait, op_fn) = self.lang_trait_fn(db, &lang_item_name, &lang_item_name)?;\n+        let (op_trait, op_fn) = self.lang_trait_fn(db, LangItem::Index, &name![index])?;\n         // HACK: subst for all methods coincides with that for their trait because the methods\n         // don't have any generic parameters, so we skip building another subst for the methods.\n         let substs = hir_ty::TyBuilder::subst_for_def(db, op_trait, None)\n@@ -355,8 +350,8 @@ impl SourceAnalyzer {\n         let lhs = self.ty_of_expr(db, &binop_expr.lhs()?)?;\n         let rhs = self.ty_of_expr(db, &binop_expr.rhs()?)?;\n \n-        let (op_trait, op_fn) = lang_names_for_bin_op(op)\n-            .and_then(|(name, lang_item)| self.lang_trait_fn(db, &lang_item, &name))?;\n+        let (op_trait, op_fn) = lang_items_for_bin_op(op)\n+            .and_then(|(name, lang_item)| self.lang_trait_fn(db, lang_item, &name))?;\n         // HACK: subst for `index()` coincides with that for `Index` because `index()` itself\n         // doesn't have any generic parameters, so we skip building another subst for `index()`.\n         let substs = hir_ty::TyBuilder::subst_for_def(db, op_trait, None)\n@@ -374,8 +369,7 @@ impl SourceAnalyzer {\n     ) -> Option<FunctionId> {\n         let ty = self.ty_of_expr(db, &try_expr.expr()?)?;\n \n-        let op_fn =\n-            db.lang_item(self.resolver.krate(), name![branch].to_smol_str())?.as_function()?;\n+        let op_fn = db.lang_item(self.resolver.krate(), LangItem::TryTraitBranch)?.as_function()?;\n         let op_trait = match op_fn.lookup(db.upcast()).container {\n             ItemContainerId::TraitId(id) => id,\n             _ => return None,\n@@ -821,10 +815,10 @@ impl SourceAnalyzer {\n     fn lang_trait_fn(\n         &self,\n         db: &dyn HirDatabase,\n-        lang_trait: &Name,\n+        lang_trait: LangItem,\n         method_name: &Name,\n     ) -> Option<(TraitId, FunctionId)> {\n-        let trait_id = db.lang_item(self.resolver.krate(), lang_trait.to_smol_str())?.as_trait()?;\n+        let trait_id = db.lang_item(self.resolver.krate(), lang_trait)?.as_trait()?;\n         let fn_id = db.trait_data(trait_id).method_by_name(method_name)?;\n         Some((trait_id, fn_id))\n     }"}, {"sha": "0b485eb776d8a8fc4f30a400cb0a64c89086f74f", "filename": "crates/ide-completion/src/tests/flyimport.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fide-completion%2Fsrc%2Ftests%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fide-completion%2Fsrc%2Ftests%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Fflyimport.rs?ref=daa0138e4c159d5753e41a447201b6191437276e", "patch": "@@ -541,9 +541,9 @@ fn main() {\n }\n \"#,\n         expect![[r#\"\n-                fn weird_function() (use dep::test_mod::TestTrait) fn() DEPRECATED\n-                ct SPECIAL_CONST (use dep::test_mod::TestTrait) DEPRECATED\n-            \"#]],\n+            ct SPECIAL_CONST (use dep::test_mod::TestTrait) DEPRECATED\n+            fn weird_function() (use dep::test_mod::TestTrait) fn() DEPRECATED\n+        \"#]],\n     );\n }\n "}, {"sha": "046786580e7a49d6a0d7fdd4d594924b389df417", "filename": "crates/project-model/src/sysroot.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fproject-model%2Fsrc%2Fsysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fproject-model%2Fsrc%2Fsysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Fsysroot.rs?ref=daa0138e4c159d5753e41a447201b6191437276e", "patch": "@@ -7,6 +7,7 @@\n use std::{env, fs, iter, ops, path::PathBuf, process::Command};\n \n use anyhow::{format_err, Result};\n+use base_db::CrateName;\n use la_arena::{Arena, Idx};\n use paths::{AbsPath, AbsPathBuf};\n use rustc_hash::FxHashMap;\n@@ -50,14 +51,16 @@ impl Sysroot {\n         &self.src_root\n     }\n \n-    pub fn public_deps(&self) -> impl Iterator<Item = (&'static str, SysrootCrate, bool)> + '_ {\n+    pub fn public_deps(&self) -> impl Iterator<Item = (CrateName, SysrootCrate, bool)> + '_ {\n         // core is added as a dependency before std in order to\n         // mimic rustcs dependency order\n         [\"core\", \"alloc\", \"std\"]\n             .into_iter()\n             .zip(iter::repeat(true))\n             .chain(iter::once((\"test\", false)))\n-            .filter_map(move |(name, prelude)| Some((name, self.by_name(name)?, prelude)))\n+            .filter_map(move |(name, prelude)| {\n+                Some((CrateName::new(name).unwrap(), self.by_name(name)?, prelude))\n+            })\n     }\n \n     pub fn proc_macro(&self) -> Option<SysrootCrate> {"}, {"sha": "755bf95199906ce69945f227be296189782244ac", "filename": "crates/project-model/src/workspace.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fproject-model%2Fsrc%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa0138e4c159d5753e41a447201b6191437276e/crates%2Fproject-model%2Fsrc%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Fworkspace.rs?ref=daa0138e4c159d5753e41a447201b6191437276e", "patch": "@@ -1162,9 +1162,7 @@ fn sysroot_to_crate_graph(\n     let public_deps = SysrootPublicDeps {\n         deps: sysroot\n             .public_deps()\n-            .map(|(name, idx, prelude)| {\n-                (CrateName::new(name).unwrap(), sysroot_crates[&idx], prelude)\n-            })\n+            .map(|(name, idx, prelude)| (name, sysroot_crates[&idx], prelude))\n             .collect::<Vec<_>>(),\n     };\n "}, {"sha": "dff60914409a538192e4e3b8fac56c5d88e76ed2", "filename": "crates/test-utils/src/minicore.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/daa0138e4c159d5753e41a447201b6191437276e/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa0138e4c159d5753e41a447201b6191437276e/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest-utils%2Fsrc%2Fminicore.rs?ref=daa0138e4c159d5753e41a447201b6191437276e", "patch": "@@ -28,6 +28,7 @@\n //!     generator: pin\n //!     hash:\n //!     index: sized\n+//!     infallible:\n //!     iterator: option\n //!     iterators: iterator, fn\n //!     non_zero:\n@@ -40,7 +41,7 @@\n //!     sized:\n //!     slice:\n //!     sync: sized\n-//!     try:\n+//!     try: infallible\n //!     unsize: sized\n \n pub mod marker {\n@@ -172,6 +173,9 @@ pub mod convert {\n         fn as_ref(&self) -> &T;\n     }\n     // endregion:as_ref\n+    // region:infallible\n+    pub enum Infallibe {}\n+    // endregion:infallible\n }\n \n pub mod ops {\n@@ -352,7 +356,7 @@ pub mod ops {\n             #[lang = \"from_residual\"]\n             fn from_residual(residual: R) -> Self;\n         }\n-        #[lang = \"try\"]\n+        #[lang = \"Try\"]\n         pub trait Try: FromResidual<Self::Residual> {\n             type Output;\n             type Residual;"}]}