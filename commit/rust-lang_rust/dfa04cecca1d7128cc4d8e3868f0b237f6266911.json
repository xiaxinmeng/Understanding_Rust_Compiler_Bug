{"sha": "dfa04cecca1d7128cc4d8e3868f0b237f6266911", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmYTA0Y2VjY2ExZDcxMjhjYzRkOGUzODY4ZjBiMjM3ZjYyNjY5MTE=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-07-05T21:16:39Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-09-06T20:35:10Z"}, "message": "add fold_mac field to fold.rs", "tree": {"sha": "8962aa6b613ff258c1ea8a899cbed8d88e24fc86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8962aa6b613ff258c1ea8a899cbed8d88e24fc86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dfa04cecca1d7128cc4d8e3868f0b237f6266911", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dfa04cecca1d7128cc4d8e3868f0b237f6266911", "html_url": "https://github.com/rust-lang/rust/commit/dfa04cecca1d7128cc4d8e3868f0b237f6266911", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dfa04cecca1d7128cc4d8e3868f0b237f6266911/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3261b6eece84161355bac8dad8427af5221cbf0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3261b6eece84161355bac8dad8427af5221cbf0d", "html_url": "https://github.com/rust-lang/rust/commit/3261b6eece84161355bac8dad8427af5221cbf0d"}], "stats": {"total": 62, "additions": 38, "deletions": 24}, "files": [{"sha": "823e018a718796df66187ce794ebba1f71cd4841", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 38, "deletions": 24, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/dfa04cecca1d7128cc4d8e3868f0b237f6266911/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfa04cecca1d7128cc4d8e3868f0b237f6266911/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=dfa04cecca1d7128cc4d8e3868f0b237f6266911", "patch": "@@ -14,6 +14,14 @@ use codemap::{Span, Spanned};\n use parse::token;\n use opt_vec::OptVec;\n \n+// this file defines an ast_fold trait for objects that can perform\n+// a \"fold\" on Rust ASTs. It also contains a structure that implements\n+// that trait, and a \"default_fold\" whose fields contain closures\n+// that perform \"default traversals\", visiting all of the sub-elements\n+// and re-assembling the result. The \"fun_to_ident_folder\" in the\n+// test module provides a simple example of creating a very simple\n+// fold that only looks at identifiers.\n+\n pub trait ast_fold {\n     fn fold_crate(@self, &Crate) -> Crate;\n     fn fold_view_item(@self, &view_item) -> view_item;\n@@ -35,6 +43,7 @@ pub trait ast_fold {\n     fn fold_ident(@self, Ident) -> Ident;\n     fn fold_path(@self, &Path) -> Path;\n     fn fold_local(@self, @Local) -> @Local;\n+    fn fold_mac(@self, &mac) -> mac;\n     fn map_exprs(@self, @fn(@Expr) -> @Expr, &[@Expr]) -> ~[@Expr];\n     fn new_id(@self, NodeId) -> NodeId;\n     fn new_span(@self, Span) -> Span;\n@@ -64,6 +73,7 @@ pub struct AstFoldFns {\n     fold_ident: @fn(Ident, @ast_fold) -> Ident,\n     fold_path: @fn(&Path, @ast_fold) -> Path,\n     fold_local: @fn(@Local, @ast_fold) -> @Local,\n+    fold_mac: @fn(&mac_, Span, @ast_fold) -> (mac_, Span),\n     map_exprs: @fn(@fn(@Expr) -> @Expr, &[@Expr]) -> ~[@Expr],\n     new_id: @fn(NodeId) -> NodeId,\n     new_span: @fn(Span) -> Span\n@@ -112,19 +122,6 @@ fn fold_arg_(a: arg, fld: @ast_fold) -> arg {\n     }\n }\n \n-//used in noop_fold_expr, and possibly elsewhere in the future\n-fn fold_mac_(m: &mac, fld: @ast_fold) -> mac {\n-    Spanned {\n-        node: match m.node {\n-            mac_invoc_tt(ref p,ref tts,ctxt) =>\n-            mac_invoc_tt(fld.fold_path(p),\n-                         fold_tts(*tts,fld),\n-                         ctxt)\n-        },\n-        span: fld.new_span(m.span)\n-    }\n-}\n-\n // build a new vector of tts by appling the ast_fold's fold_ident to\n // all of the identifiers in the token trees.\n pub fn fold_tts(tts : &[token_tree], f : @ast_fold) -> ~[token_tree] {\n@@ -326,10 +323,7 @@ pub fn noop_fold_item_underscore(i: &item_, fld: @ast_fold) -> item_ {\n             )\n         }\n         item_mac(ref m) => {\n-            // It would probably be nicer\n-            // to expose this in the ast_fold trait, but I'll defer\n-            // that work.\n-            item_mac(fold_mac_(m,fld))\n+            item_mac(fld.fold_mac(m))\n         }\n     }\n }\n@@ -398,7 +392,6 @@ pub fn noop_fold_block(b: &Block, fld: @ast_fold) -> Block {\n }\n \n fn noop_fold_stmt(s: &Stmt_, fld: @ast_fold) -> Option<Stmt_> {\n-    let fold_mac = |x| fold_mac_(x, fld);\n     match *s {\n         StmtDecl(d, nid) => {\n             match fld.fold_decl(d) {\n@@ -412,7 +405,7 @@ fn noop_fold_stmt(s: &Stmt_, fld: @ast_fold) -> Option<Stmt_> {\n         StmtSemi(e, nid) => {\n             Some(StmtSemi(fld.fold_expr(e), fld.new_id(nid)))\n         }\n-        StmtMac(ref mac, semi) => Some(StmtMac(fold_mac(mac), semi))\n+        StmtMac(ref mac, semi) => Some(StmtMac(fld.fold_mac(mac), semi))\n     }\n }\n \n@@ -480,6 +473,12 @@ fn noop_fold_decl(d: &Decl_, fld: @ast_fold) -> Option<Decl_> {\n     }\n }\n \n+// lift a function in ast-thingy X fold -> ast-thingy to a function\n+// in (ast-thingy X span X fold) -> (ast-thingy X fold). Basically,\n+// carries the span around.\n+// It seems strange to me that the call to new_fold doesn't happen\n+// here but instead in the impl down below.... probably just an\n+// accident?\n pub fn wrap<T>(f: @fn(&T, @ast_fold) -> T)\n             -> @fn(&T, Span, @ast_fold) -> (T, Span) {\n     let result: @fn(&T, Span, @ast_fold) -> (T, Span) = |x, s, fld| {\n@@ -498,8 +497,6 @@ pub fn noop_fold_expr(e: &Expr_, fld: @ast_fold) -> Expr_ {\n     }\n     let fold_field = |x| fold_field_(x, fld);\n \n-    let fold_mac = |x| fold_mac_(x, fld);\n-\n     match *e {\n         ExprVstore(e, v) => {\n             ExprVstore(fld.fold_expr(e), v)\n@@ -631,7 +628,7 @@ pub fn noop_fold_expr(e: &Expr_, fld: @ast_fold) -> Expr_ {\n                 .. (*a).clone()\n             })\n         }\n-        ExprMac(ref mac) => ExprMac(fold_mac(mac)),\n+        ExprMac(ref mac) => ExprMac(fld.fold_mac(mac)),\n         ExprStruct(ref path, ref fields, maybe_expr) => {\n             ExprStruct(\n                 fld.fold_path(path),\n@@ -644,7 +641,6 @@ pub fn noop_fold_expr(e: &Expr_, fld: @ast_fold) -> Expr_ {\n }\n \n pub fn noop_fold_ty(t: &ty_, fld: @ast_fold) -> ty_ {\n-    let fold_mac = |x| fold_mac_(x, fld);\n     fn fold_mt(mt: &mt, fld: @ast_fold) -> mt {\n         mt {\n             ty: ~fld.fold_ty(mt.ty),\n@@ -700,7 +696,7 @@ pub fn noop_fold_ty(t: &ty_, fld: @ast_fold) -> ty_ {\n             )\n         }\n         ty_typeof(e) => ty_typeof(fld.fold_expr(e)),\n-        ty_mac(ref mac) => ty_mac(fold_mac(mac))\n+        ty_mac(ref mac) => ty_mac(fld.fold_mac(mac))\n     }\n }\n \n@@ -787,6 +783,19 @@ fn noop_fold_local(l: @Local, fld: @ast_fold) -> @Local {\n     }\n }\n \n+// the default macro traversal. visit the path\n+// using fold_path, and the tts using fold_tts,\n+// and the span using new_span\n+fn noop_fold_mac(m: &mac_, fld: @ast_fold) -> mac_ {\n+    match *m {\n+        mac_invoc_tt(ref p,ref tts,ctxt) =>\n+        mac_invoc_tt(fld.fold_path(p),\n+                     fold_tts(*tts,fld),\n+                     ctxt)\n+    }\n+}\n+\n+\n /* temporarily eta-expand because of a compiler bug with using `fn<T>` as a\n    value */\n fn noop_map_exprs(f: @fn(@Expr) -> @Expr, es: &[@Expr]) -> ~[@Expr] {\n@@ -819,6 +828,7 @@ pub fn default_ast_fold() -> ast_fold_fns {\n         fold_ident: noop_fold_ident,\n         fold_path: noop_fold_path,\n         fold_local: noop_fold_local,\n+        fold_mac: wrap(noop_fold_mac),\n         map_exprs: noop_map_exprs,\n         new_id: noop_id,\n         new_span: noop_span,\n@@ -924,6 +934,10 @@ impl ast_fold for AstFoldFns {\n     fn fold_local(@self, x: @Local) -> @Local {\n         (self.fold_local)(x, self as @ast_fold)\n     }\n+    fn fold_mac(@self, x: &mac) -> mac {\n+        let (n, s) = (self.fold_mac)(&x.node, x.span, self as @ast_fold);\n+        Spanned { node: n, span: (self.new_span)(s) }\n+    }\n     fn map_exprs(@self,\n                  f: @fn(@Expr) -> @Expr,\n                  e: &[@Expr])"}]}