{"sha": "29780f43e2067ee1c88e73fa76ef1cced28758d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5NzgwZjQzZTIwNjdlZTFjODhlNzNmYTc2ZWYxY2NlZDI4NzU4ZDM=", "commit": {"author": {"name": "LeSeulArtichaut", "email": "leseulartichaut@gmail.com", "date": "2021-03-14T19:10:22Z"}, "committer": {"name": "LeSeulArtichaut", "email": "leseulartichaut@gmail.com", "date": "2021-05-11T13:33:00Z"}, "message": "Introduce the (WIP) THIR unsafety checker", "tree": {"sha": "498a22e3694741ae7d10b828b658f1801bff62c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/498a22e3694741ae7d10b828b658f1801bff62c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29780f43e2067ee1c88e73fa76ef1cced28758d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29780f43e2067ee1c88e73fa76ef1cced28758d3", "html_url": "https://github.com/rust-lang/rust/commit/29780f43e2067ee1c88e73fa76ef1cced28758d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29780f43e2067ee1c88e73fa76ef1cced28758d3/comments", "author": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "committer": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d956122f7e278748310cfe25a982879ed2d90fba", "url": "https://api.github.com/repos/rust-lang/rust/commits/d956122f7e278748310cfe25a982879ed2d90fba", "html_url": "https://github.com/rust-lang/rust/commit/d956122f7e278748310cfe25a982879ed2d90fba"}], "stats": {"total": 344, "additions": 343, "deletions": 1}, "files": [{"sha": "601b6d2b6084cacb9ac591264679420bf8064bd2", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29780f43e2067ee1c88e73fa76ef1cced28758d3/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29780f43e2067ee1c88e73fa76ef1cced28758d3/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=29780f43e2067ee1c88e73fa76ef1cced28758d3", "patch": "@@ -884,7 +884,11 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n \n     sess.time(\"MIR_effect_checking\", || {\n         for def_id in tcx.body_owners() {\n-            mir::transform::check_unsafety::check_unsafety(tcx, def_id);\n+            if tcx.sess.opts.debugging_opts.thir_unsafeck {\n+                tcx.ensure().thir_check_unsafety(def_id);\n+            } else {\n+                mir::transform::check_unsafety::check_unsafety(tcx, def_id);\n+            }\n \n             if tcx.hir().body_const_context(def_id).is_some() {\n                 tcx.ensure()"}, {"sha": "50a0c1067d01ca42d0a2504eec46feca04347711", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/29780f43e2067ee1c88e73fa76ef1cced28758d3/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29780f43e2067ee1c88e73fa76ef1cced28758d3/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=29780f43e2067ee1c88e73fa76ef1cced28758d3", "patch": "@@ -735,6 +735,7 @@ fn test_debugging_options_tracking_hash() {\n     tracked!(symbol_mangling_version, Some(SymbolManglingVersion::V0));\n     tracked!(teach, true);\n     tracked!(thinlto, Some(true));\n+    tracked!(thir_unsafeck, true);\n     tracked!(tune_cpu, Some(String::from(\"abc\")));\n     tracked!(tls_model, Some(TlsModel::GeneralDynamic));\n     tracked!(trap_unreachable, Some(false));"}, {"sha": "699716d820345cf814f53c0f2e4ef46a66d04a71", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/29780f43e2067ee1c88e73fa76ef1cced28758d3/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29780f43e2067ee1c88e73fa76ef1cced28758d3/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=29780f43e2067ee1c88e73fa76ef1cced28758d3", "patch": "@@ -611,6 +611,19 @@ rustc_queries! {\n         }\n     }\n \n+    /// Unsafety-check this `LocalDefId` with THIR unsafeck. This should be\n+    /// used with `-Zthir-unsafeck`.\n+    query thir_check_unsafety(key: LocalDefId) {\n+        desc { |tcx| \"unsafety-checking `{}`\", tcx.def_path_str(key.to_def_id()) }\n+        cache_on_disk_if { true }\n+    }\n+    query thir_check_unsafety_for_const_arg(key: (LocalDefId, DefId)) {\n+        desc {\n+            |tcx| \"unsafety-checking the const argument `{}`\",\n+            tcx.def_path_str(key.0.to_def_id())\n+        }\n+    }\n+\n     /// HACK: when evaluated, this reports a \"unsafe derive on repr(packed)\" error.\n     ///\n     /// Unsafety checking is executed for each method separately, but we only want"}, {"sha": "fb25d6893be2d76b3d408ca9f96ec3dca61d3687", "filename": "compiler/rustc_mir_build/src/check_unsafety.rs", "status": "added", "additions": 319, "deletions": 0, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/29780f43e2067ee1c88e73fa76ef1cced28758d3/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29780f43e2067ee1c88e73fa76ef1cced28758d3/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs?ref=29780f43e2067ee1c88e73fa76ef1cced28758d3", "patch": "@@ -0,0 +1,319 @@\n+use crate::thir::visit::{self, Visitor};\n+use crate::thir::*;\n+\n+use rustc_errors::struct_span_err;\n+use rustc_hir as hir;\n+use rustc_middle::ty::{self, TyCtxt};\n+use rustc_session::lint::builtin::{UNSAFE_OP_IN_UNSAFE_FN, UNUSED_UNSAFE};\n+use rustc_session::lint::Level;\n+use rustc_span::def_id::{DefId, LocalDefId};\n+use rustc_span::Span;\n+\n+struct UnsafetyVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    /// The `HirId` of the current scope, which would be the `HirId`\n+    /// of the current HIR node, modulo adjustments. Used for lint levels.\n+    hir_context: hir::HirId,\n+    /// The current \"safety context\". This notably tracks whether we are in an\n+    /// `unsafe` block, and whether it has been used.\n+    safety_context: SafetyContext,\n+    body_unsafety: BodyUnsafety,\n+}\n+\n+impl<'tcx> UnsafetyVisitor<'tcx> {\n+    fn requires_unsafe(&mut self, span: Span, kind: UnsafeOpKind) {\n+        let (description, note) = kind.description_and_note();\n+        let unsafe_op_in_unsafe_fn_allowed = self.unsafe_op_in_unsafe_fn_allowed();\n+        match self.safety_context {\n+            SafetyContext::UnsafeBlock { ref mut used, .. } => {\n+                if !self.body_unsafety.is_unsafe() || !unsafe_op_in_unsafe_fn_allowed {\n+                    // Mark this block as useful\n+                    *used = true;\n+                }\n+            }\n+            SafetyContext::UnsafeFn if unsafe_op_in_unsafe_fn_allowed => {}\n+            SafetyContext::UnsafeFn => {\n+                // unsafe_op_in_unsafe_fn is disallowed\n+                if kind == BorrowOfPackedField {\n+                    // FIXME handle borrows of packed fields\n+                } else {\n+                    struct_span_err!(\n+                        self.tcx.sess,\n+                        span,\n+                        E0133,\n+                        \"{} is unsafe and requires unsafe block\",\n+                        description,\n+                    )\n+                    .span_label(span, description)\n+                    .note(note)\n+                    .emit();\n+                }\n+            }\n+            SafetyContext::Safe => {\n+                if kind == BorrowOfPackedField {\n+                    // FIXME handle borrows of packed fields\n+                } else {\n+                    let fn_sugg = if unsafe_op_in_unsafe_fn_allowed { \" function or\" } else { \"\" };\n+                    struct_span_err!(\n+                        self.tcx.sess,\n+                        span,\n+                        E0133,\n+                        \"{} is unsafe and requires unsafe{} block\",\n+                        description,\n+                        fn_sugg,\n+                    )\n+                    .span_label(span, description)\n+                    .note(note)\n+                    .emit();\n+                }\n+            }\n+        }\n+    }\n+\n+    fn warn_unused_unsafe(\n+        &self,\n+        hir_id: hir::HirId,\n+        block_span: Span,\n+        enclosing_span: Option<Span>,\n+    ) {\n+        let block_span = self.tcx.sess.source_map().guess_head_span(block_span);\n+        self.tcx.struct_span_lint_hir(UNUSED_UNSAFE, hir_id, block_span, |lint| {\n+            let msg = \"unnecessary `unsafe` block\";\n+            let mut db = lint.build(msg);\n+            db.span_label(block_span, msg);\n+            if let Some(enclosing_span) = enclosing_span {\n+                db.span_label(\n+                    enclosing_span,\n+                    format!(\"because it's nested under this `unsafe` block\"),\n+                );\n+            }\n+            db.emit();\n+        });\n+    }\n+\n+    /// Whether the `unsafe_op_in_unsafe_fn` lint is `allow`ed at the current HIR node.\n+    fn unsafe_op_in_unsafe_fn_allowed(&self) -> bool {\n+        self.tcx.lint_level_at_node(UNSAFE_OP_IN_UNSAFE_FN, self.hir_context).0 == Level::Allow\n+    }\n+}\n+\n+impl<'thir, 'tcx> Visitor<'thir, 'tcx> for UnsafetyVisitor<'tcx> {\n+    fn visit_block(&mut self, block: &Block<'thir, 'tcx>) {\n+        if let BlockSafety::ExplicitUnsafe(hir_id) = block.safety_mode {\n+            if let SafetyContext::UnsafeBlock { span: enclosing_span, .. } = self.safety_context {\n+                self.warn_unused_unsafe(\n+                    hir_id,\n+                    block.span,\n+                    Some(self.tcx.sess.source_map().guess_head_span(enclosing_span)),\n+                );\n+            } else {\n+                let prev_context = self.safety_context;\n+                self.safety_context =\n+                    SafetyContext::UnsafeBlock { span: block.span, hir_id, used: false };\n+                visit::walk_block(self, block);\n+                if let SafetyContext::UnsafeBlock { used: false, span, hir_id } =\n+                    self.safety_context\n+                {\n+                    self.warn_unused_unsafe(hir_id, span, self.body_unsafety.unsafe_fn_sig_span());\n+                }\n+                self.safety_context = prev_context;\n+                return;\n+            }\n+        }\n+\n+        visit::walk_block(self, block);\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'thir Expr<'thir, 'tcx>) {\n+        match expr.kind {\n+            ExprKind::Scope { value, lint_level: LintLevel::Explicit(hir_id), .. } => {\n+                let prev_id = self.hir_context;\n+                self.hir_context = hir_id;\n+                self.visit_expr(value);\n+                self.hir_context = prev_id;\n+                return;\n+            }\n+            ExprKind::Call { fun, .. } => {\n+                if fun.ty.fn_sig(self.tcx).unsafety() == hir::Unsafety::Unsafe {\n+                    self.requires_unsafe(expr.span, CallToUnsafeFunction);\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        visit::walk_expr(self, expr);\n+    }\n+}\n+\n+#[derive(Clone, Copy)]\n+enum SafetyContext {\n+    Safe,\n+    UnsafeFn,\n+    UnsafeBlock { span: Span, hir_id: hir::HirId, used: bool },\n+}\n+\n+#[derive(Clone, Copy)]\n+enum BodyUnsafety {\n+    /// The body is not unsafe.\n+    Safe,\n+    /// The body is an unsafe function. The span points to\n+    /// the signature of the function.\n+    Unsafe(Span),\n+}\n+\n+impl BodyUnsafety {\n+    /// Returns whether the body is unsafe.\n+    fn is_unsafe(&self) -> bool {\n+        matches!(self, BodyUnsafety::Unsafe(_))\n+    }\n+\n+    /// If the body is unsafe, returns the `Span` of its signature.\n+    fn unsafe_fn_sig_span(self) -> Option<Span> {\n+        match self {\n+            BodyUnsafety::Unsafe(span) => Some(span),\n+            BodyUnsafety::Safe => None,\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Copy, PartialEq)]\n+enum UnsafeOpKind {\n+    CallToUnsafeFunction,\n+    #[allow(dead_code)] // FIXME\n+    UseOfInlineAssembly,\n+    #[allow(dead_code)] // FIXME\n+    InitializingTypeWith,\n+    #[allow(dead_code)] // FIXME\n+    CastOfPointerToInt,\n+    #[allow(dead_code)] // FIXME\n+    BorrowOfPackedField,\n+    #[allow(dead_code)] // FIXME\n+    UseOfMutableStatic,\n+    #[allow(dead_code)] // FIXME\n+    UseOfExternStatic,\n+    #[allow(dead_code)] // FIXME\n+    DerefOfRawPointer,\n+    #[allow(dead_code)] // FIXME\n+    AssignToDroppingUnionField,\n+    #[allow(dead_code)] // FIXME\n+    AccessToUnionField,\n+    #[allow(dead_code)] // FIXME\n+    MutationOfLayoutConstrainedField,\n+    #[allow(dead_code)] // FIXME\n+    BorrowOfLayoutConstrainedField,\n+    #[allow(dead_code)] // FIXME\n+    CallToFunctionWith,\n+}\n+\n+use UnsafeOpKind::*;\n+\n+impl UnsafeOpKind {\n+    pub fn description_and_note(&self) -> (&'static str, &'static str) {\n+        match self {\n+            CallToUnsafeFunction => (\n+                \"call to unsafe function\",\n+                \"consult the function's documentation for information on how to avoid undefined \\\n+                 behavior\",\n+            ),\n+            UseOfInlineAssembly => (\n+                \"use of inline assembly\",\n+                \"inline assembly is entirely unchecked and can cause undefined behavior\",\n+            ),\n+            InitializingTypeWith => (\n+                \"initializing type with `rustc_layout_scalar_valid_range` attr\",\n+                \"initializing a layout restricted type's field with a value outside the valid \\\n+                 range is undefined behavior\",\n+            ),\n+            CastOfPointerToInt => {\n+                (\"cast of pointer to int\", \"casting pointers to integers in constants\")\n+            }\n+            BorrowOfPackedField => (\n+                \"borrow of packed field\",\n+                \"fields of packed structs might be misaligned: dereferencing a misaligned pointer \\\n+                 or even just creating a misaligned reference is undefined behavior\",\n+            ),\n+            UseOfMutableStatic => (\n+                \"use of mutable static\",\n+                \"mutable statics can be mutated by multiple threads: aliasing violations or data \\\n+                 races will cause undefined behavior\",\n+            ),\n+            UseOfExternStatic => (\n+                \"use of extern static\",\n+                \"extern statics are not controlled by the Rust type system: invalid data, \\\n+                 aliasing violations or data races will cause undefined behavior\",\n+            ),\n+            DerefOfRawPointer => (\n+                \"dereference of raw pointer\",\n+                \"raw pointers may be NULL, dangling or unaligned; they can violate aliasing rules \\\n+                 and cause data races: all of these are undefined behavior\",\n+            ),\n+            AssignToDroppingUnionField => (\n+                \"assignment to union field that might need dropping\",\n+                \"the previous content of the field will be dropped, which causes undefined \\\n+                 behavior if the field was not properly initialized\",\n+            ),\n+            AccessToUnionField => (\n+                \"access to union field\",\n+                \"the field may not be properly initialized: using uninitialized data will cause \\\n+                 undefined behavior\",\n+            ),\n+            MutationOfLayoutConstrainedField => (\n+                \"mutation of layout constrained field\",\n+                \"mutating layout constrained fields cannot statically be checked for valid values\",\n+            ),\n+            BorrowOfLayoutConstrainedField => (\n+                \"borrow of layout constrained field with interior mutability\",\n+                \"references to fields of layout constrained fields lose the constraints. Coupled \\\n+                 with interior mutability, the field can be changed to invalid values\",\n+            ),\n+            CallToFunctionWith => (\n+                \"call to function with `#[target_feature]`\",\n+                \"can only be called if the required target features are available\",\n+            ),\n+        }\n+    }\n+}\n+\n+// FIXME: checking unsafety for closures should be handled by their parent body,\n+// as they inherit their \"safety context\" from their declaration site.\n+pub fn check_unsafety<'tcx>(tcx: TyCtxt<'tcx>, thir: &Expr<'_, 'tcx>, hir_id: hir::HirId) {\n+    let body_unsafety = tcx.hir().fn_sig_by_hir_id(hir_id).map_or(BodyUnsafety::Safe, |fn_sig| {\n+        if fn_sig.header.unsafety == hir::Unsafety::Unsafe {\n+            BodyUnsafety::Unsafe(fn_sig.span)\n+        } else {\n+            BodyUnsafety::Safe\n+        }\n+    });\n+    let safety_context =\n+        if body_unsafety.is_unsafe() { SafetyContext::UnsafeFn } else { SafetyContext::Safe };\n+    let mut visitor = UnsafetyVisitor { tcx, safety_context, hir_context: hir_id, body_unsafety };\n+    visitor.visit_expr(thir);\n+}\n+\n+crate fn thir_check_unsafety_inner<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def: ty::WithOptConstParam<LocalDefId>,\n+) {\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def.did);\n+    let body_id = tcx.hir().body_owned_by(hir_id);\n+    let body = tcx.hir().body(body_id);\n+\n+    let arena = Arena::default();\n+    let thir = cx::build_thir(tcx, def, &arena, &body.value);\n+    check_unsafety(tcx, thir, hir_id);\n+}\n+\n+crate fn thir_check_unsafety<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) {\n+    if let Some(def) = ty::WithOptConstParam::try_lookup(def_id, tcx) {\n+        tcx.thir_check_unsafety_for_const_arg(def)\n+    } else {\n+        thir_check_unsafety_inner(tcx, ty::WithOptConstParam::unknown(def_id))\n+    }\n+}\n+\n+crate fn thir_check_unsafety_for_const_arg<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    (did, param_did): (LocalDefId, DefId),\n+) {\n+    thir_check_unsafety_inner(tcx, ty::WithOptConstParam { did, const_param_did: Some(param_did) })\n+}"}, {"sha": "d4e9a0a31698583cb15e0c94e45353f06855d820", "filename": "compiler/rustc_mir_build/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/29780f43e2067ee1c88e73fa76ef1cced28758d3/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29780f43e2067ee1c88e73fa76ef1cced28758d3/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs?ref=29780f43e2067ee1c88e73fa76ef1cced28758d3", "patch": "@@ -19,6 +19,7 @@ extern crate tracing;\n extern crate rustc_middle;\n \n mod build;\n+mod check_unsafety;\n mod lints;\n pub mod thir;\n \n@@ -28,4 +29,6 @@ pub fn provide(providers: &mut Providers) {\n     providers.check_match = thir::pattern::check_match;\n     providers.lit_to_const = thir::constant::lit_to_const;\n     providers.mir_built = build::mir_built;\n+    providers.thir_check_unsafety = check_unsafety::thir_check_unsafety;\n+    providers.thir_check_unsafety_for_const_arg = check_unsafety::thir_check_unsafety_for_const_arg;\n }"}, {"sha": "91b619e8e12da72da0bfd750be08b2e02ca73709", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29780f43e2067ee1c88e73fa76ef1cced28758d3/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29780f43e2067ee1c88e73fa76ef1cced28758d3/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=29780f43e2067ee1c88e73fa76ef1cced28758d3", "patch": "@@ -1251,6 +1251,8 @@ options! {\n         \"select processor to schedule for (`rustc --print target-cpus` for details)\"),\n     thinlto: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"enable ThinLTO when possible\"),\n+    thir_unsafeck: bool = (false, parse_bool, [TRACKED],\n+        \"use the work-in-progress THIR unsafety checker. NOTE: this is unsound (default: no)\"),\n     /// We default to 1 here since we want to behave like\n     /// a sequential compiler for now. This'll likely be adjusted\n     /// in the future. Note that -Zthreads=0 is the way to get"}]}