{"sha": "42be687fa1a1070195c25a8e607d1209a9f8c88b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyYmU2ODdmYTFhMTA3MDE5NWMyNWE4ZTYwN2QxMjA5YTlmOGM4OGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-19T14:51:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-19T14:51:31Z"}, "message": "auto merge of #14279 : aochagavia/rust/pr2, r=huonw\n\nThe breaking changes are:\r\n\r\n* Changed `DList::insert_ordered` to use `TotalOrd`, not `Ord`\r\n* Changed `PriorityQueue` to use `TotalOrd`, not `Ord`\r\n* Deprecated `PriorityQueue::maybe_top()` (renamed to replace `PriorityQueue::top()`)\r\n* Deprecated `PriorityQueue::maybe_pop()` (renamed to replace `PriorityQueue::pop()`)\r\n* Deprecated `PriorityQueue::to_vec()` (renamed to `PriorityQueue::into_vec()`)\r\n* Deprecated `PriorityQueue::to_sorted_vec()` (renamed to `PriorityQueue::into_sorted_vec()`)\r\n* Changed `PriorityQueue::replace(...)` to return an `Option<T>` instead of failing when the queue is empty.\r\n\r\n\r\n[breaking-change]", "tree": {"sha": "914dd0b0c4b0cb14397968f4bf95ae69a9759782", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/914dd0b0c4b0cb14397968f4bf95ae69a9759782"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42be687fa1a1070195c25a8e607d1209a9f8c88b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42be687fa1a1070195c25a8e607d1209a9f8c88b", "html_url": "https://github.com/rust-lang/rust/commit/42be687fa1a1070195c25a8e607d1209a9f8c88b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42be687fa1a1070195c25a8e607d1209a9f8c88b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed156772bd95b8d621d50102922e5f5ac886d4a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed156772bd95b8d621d50102922e5f5ac886d4a1", "html_url": "https://github.com/rust-lang/rust/commit/ed156772bd95b8d621d50102922e5f5ac886d4a1"}, {"sha": "3a1b7d47f33ca8004820548a99e562d3f7d60921", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a1b7d47f33ca8004820548a99e562d3f7d60921", "html_url": "https://github.com/rust-lang/rust/commit/3a1b7d47f33ca8004820548a99e562d3f7d60921"}], "stats": {"total": 144, "additions": 73, "deletions": 71}, "files": [{"sha": "58ced1beeed609f8569b398d02183b19102dba4c", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42be687fa1a1070195c25a8e607d1209a9f8c88b/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42be687fa1a1070195c25a8e607d1209a9f8c88b/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=42be687fa1a1070195c25a8e607d1209a9f8c88b", "patch": "@@ -410,7 +410,7 @@ impl<T> DList<T> {\n     }\n }\n \n-impl<T: Ord> DList<T> {\n+impl<T: TotalOrd> DList<T> {\n     /// Insert `elt` sorted in ascending order\n     ///\n     /// O(N)"}, {"sha": "2e8178cd931e555f9895f0baba3ea6aa468715d1", "filename": "src/libcollections/priority_queue.rs", "status": "modified", "additions": 72, "deletions": 70, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/42be687fa1a1070195c25a8e607d1209a9f8c88b/src%2Flibcollections%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42be687fa1a1070195c25a8e607d1209a9f8c88b/src%2Flibcollections%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fpriority_queue.rs?ref=42be687fa1a1070195c25a8e607d1209a9f8c88b", "patch": "@@ -22,31 +22,31 @@ pub struct PriorityQueue<T> {\n     data: Vec<T>,\n }\n \n-impl<T:Ord> Container for PriorityQueue<T> {\n+impl<T: TotalOrd> Container for PriorityQueue<T> {\n     /// Returns the length of the queue\n     fn len(&self) -> uint { self.data.len() }\n }\n \n-impl<T:Ord> Mutable for PriorityQueue<T> {\n+impl<T: TotalOrd> Mutable for PriorityQueue<T> {\n     /// Drop all items from the queue\n     fn clear(&mut self) { self.data.truncate(0) }\n }\n \n-impl<T:Ord> PriorityQueue<T> {\n+impl<T: TotalOrd> PriorityQueue<T> {\n     /// An iterator visiting all values in underlying vector, in\n     /// arbitrary order.\n     pub fn iter<'a>(&'a self) -> Items<'a, T> {\n         Items { iter: self.data.iter() }\n     }\n \n-    /// Returns the greatest item in the queue - fails if empty\n-    pub fn top<'a>(&'a self) -> &'a T { self.data.get(0) }\n-\n-    /// Returns the greatest item in the queue - None if empty\n-    pub fn maybe_top<'a>(&'a self) -> Option<&'a T> {\n-        if self.is_empty() { None } else { Some(self.top()) }\n+    /// Returns the greatest item in a queue or None if it is empty\n+    pub fn top<'a>(&'a self) -> Option<&'a T> {\n+        if self.is_empty() { None } else { Some(self.data.get(0)) }\n     }\n \n+    #[deprecated=\"renamed to `top`\"]\n+    pub fn maybe_top<'a>(&'a self) -> Option<&'a T> { self.top() }\n+\n     /// Returns the number of elements the queue can hold without reallocating\n     pub fn capacity(&self) -> uint { self.data.capacity() }\n \n@@ -60,20 +60,23 @@ impl<T:Ord> PriorityQueue<T> {\n         self.data.reserve(n)\n     }\n \n-    /// Pop the greatest item from the queue - fails if empty\n-    pub fn pop(&mut self) -> T {\n-        let mut item = self.data.pop().unwrap();\n-        if !self.is_empty() {\n-            swap(&mut item, self.data.get_mut(0));\n-            self.siftdown(0);\n+    /// Remove the greatest item from a queue and return it, or `None` if it is\n+    /// empty.\n+    pub fn pop(&mut self) -> Option<T> {\n+        match self.data.pop() {\n+            None           => { None }\n+            Some(mut item) => {\n+                if !self.is_empty() {\n+                    swap(&mut item, self.data.get_mut(0));\n+                    self.siftdown(0);\n+                }\n+                Some(item)\n+            }\n         }\n-        item\n     }\n \n-    /// Pop the greatest item from the queue - None if empty\n-    pub fn maybe_pop(&mut self) -> Option<T> {\n-        if self.is_empty() { None } else { Some(self.pop()) }\n-    }\n+    #[deprecated=\"renamed to `pop`\"]\n+    pub fn maybe_pop(&mut self) -> Option<T> { self.pop() }\n \n     /// Push an item onto the queue\n     pub fn push(&mut self, item: T) {\n@@ -84,34 +87,48 @@ impl<T:Ord> PriorityQueue<T> {\n \n     /// Optimized version of a push followed by a pop\n     pub fn push_pop(&mut self, mut item: T) -> T {\n-        if !self.is_empty() && *self.top() > item {\n+        if !self.is_empty() && *self.top().unwrap() > item {\n             swap(&mut item, self.data.get_mut(0));\n             self.siftdown(0);\n         }\n         item\n     }\n \n-    /// Optimized version of a pop followed by a push - fails if empty\n-    pub fn replace(&mut self, mut item: T) -> T {\n-        swap(&mut item, self.data.get_mut(0));\n-        self.siftdown(0);\n-        item\n+    /// Optimized version of a pop followed by a push. The push is done\n+    /// regardless of whether the queue is empty.\n+    pub fn replace(&mut self, mut item: T) -> Option<T> {\n+        if !self.is_empty() {\n+            swap(&mut item, self.data.get_mut(0));\n+            self.siftdown(0);\n+            Some(item)\n+        } else {\n+            self.push(item);\n+            None\n+        }\n     }\n \n+    #[allow(dead_code)]\n+    #[deprecated=\"renamed to `into_vec`\"]\n+    fn to_vec(self) -> Vec<T> { self.into_vec() }\n+\n+    #[allow(dead_code)]\n+    #[deprecated=\"renamed to `into_sorted_vec`\"]\n+    fn to_sorted_vec(self) -> Vec<T> { self.into_sorted_vec() }\n+\n     /// Consume the PriorityQueue and return the underlying vector\n-    pub fn to_vec(self) -> Vec<T> { let PriorityQueue{data: v} = self; v }\n+    pub fn into_vec(self) -> Vec<T> { let PriorityQueue{data: v} = self; v }\n \n     /// Consume the PriorityQueue and return a vector in sorted\n     /// (ascending) order\n-    pub fn to_sorted_vec(self) -> Vec<T> {\n+    pub fn into_sorted_vec(self) -> Vec<T> {\n         let mut q = self;\n         let mut end = q.len();\n         while end > 1 {\n             end -= 1;\n             q.data.as_mut_slice().swap(0, end);\n             q.siftdown_range(0, end)\n         }\n-        q.to_vec()\n+        q.into_vec()\n     }\n \n     /// Create an empty PriorityQueue\n@@ -197,15 +214,15 @@ impl<'a, T> Iterator<&'a T> for Items<'a, T> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n-impl<T: Ord> FromIterator<T> for PriorityQueue<T> {\n+impl<T: TotalOrd> FromIterator<T> for PriorityQueue<T> {\n     fn from_iter<Iter: Iterator<T>>(iter: Iter) -> PriorityQueue<T> {\n         let mut q = PriorityQueue::new();\n         q.extend(iter);\n         q\n     }\n }\n \n-impl<T: Ord> Extendable<T> for PriorityQueue<T> {\n+impl<T: TotalOrd> Extendable<T> for PriorityQueue<T> {\n     fn extend<Iter: Iterator<T>>(&mut self, mut iter: Iter) {\n         let (lower, _) = iter.size_hint();\n \n@@ -241,53 +258,53 @@ mod tests {\n         sorted.sort();\n         let mut heap = PriorityQueue::from_vec(data);\n         while !heap.is_empty() {\n-            assert_eq!(heap.top(), sorted.last().unwrap());\n-            assert_eq!(heap.pop(), sorted.pop().unwrap());\n+            assert_eq!(heap.top().unwrap(), sorted.last().unwrap());\n+            assert_eq!(heap.pop().unwrap(), sorted.pop().unwrap());\n         }\n     }\n \n     #[test]\n     fn test_push() {\n         let mut heap = PriorityQueue::from_vec(vec!(2, 4, 9));\n         assert_eq!(heap.len(), 3);\n-        assert!(*heap.top() == 9);\n+        assert!(*heap.top().unwrap() == 9);\n         heap.push(11);\n         assert_eq!(heap.len(), 4);\n-        assert!(*heap.top() == 11);\n+        assert!(*heap.top().unwrap() == 11);\n         heap.push(5);\n         assert_eq!(heap.len(), 5);\n-        assert!(*heap.top() == 11);\n+        assert!(*heap.top().unwrap() == 11);\n         heap.push(27);\n         assert_eq!(heap.len(), 6);\n-        assert!(*heap.top() == 27);\n+        assert!(*heap.top().unwrap() == 27);\n         heap.push(3);\n         assert_eq!(heap.len(), 7);\n-        assert!(*heap.top() == 27);\n+        assert!(*heap.top().unwrap() == 27);\n         heap.push(103);\n         assert_eq!(heap.len(), 8);\n-        assert!(*heap.top() == 103);\n+        assert!(*heap.top().unwrap() == 103);\n     }\n \n     #[test]\n     fn test_push_unique() {\n         let mut heap = PriorityQueue::from_vec(vec!(box 2, box 4, box 9));\n         assert_eq!(heap.len(), 3);\n-        assert!(*heap.top() == box 9);\n+        assert!(*heap.top().unwrap() == box 9);\n         heap.push(box 11);\n         assert_eq!(heap.len(), 4);\n-        assert!(*heap.top() == box 11);\n+        assert!(*heap.top().unwrap() == box 11);\n         heap.push(box 5);\n         assert_eq!(heap.len(), 5);\n-        assert!(*heap.top() == box 11);\n+        assert!(*heap.top().unwrap() == box 11);\n         heap.push(box 27);\n         assert_eq!(heap.len(), 6);\n-        assert!(*heap.top() == box 27);\n+        assert!(*heap.top().unwrap() == box 27);\n         heap.push(box 3);\n         assert_eq!(heap.len(), 7);\n-        assert!(*heap.top() == box 27);\n+        assert!(*heap.top().unwrap() == box 27);\n         heap.push(box 103);\n         assert_eq!(heap.len(), 8);\n-        assert!(*heap.top() == box 103);\n+        assert!(*heap.top().unwrap() == box 103);\n     }\n \n     #[test]\n@@ -308,24 +325,24 @@ mod tests {\n     fn test_replace() {\n         let mut heap = PriorityQueue::from_vec(vec!(5, 5, 2, 1, 3));\n         assert_eq!(heap.len(), 5);\n-        assert_eq!(heap.replace(6), 5);\n+        assert_eq!(heap.replace(6).unwrap(), 5);\n         assert_eq!(heap.len(), 5);\n-        assert_eq!(heap.replace(0), 6);\n+        assert_eq!(heap.replace(0).unwrap(), 6);\n         assert_eq!(heap.len(), 5);\n-        assert_eq!(heap.replace(4), 5);\n+        assert_eq!(heap.replace(4).unwrap(), 5);\n         assert_eq!(heap.len(), 5);\n-        assert_eq!(heap.replace(1), 4);\n+        assert_eq!(heap.replace(1).unwrap(), 4);\n         assert_eq!(heap.len(), 5);\n     }\n \n     fn check_to_vec(mut data: Vec<int>) {\n         let heap = PriorityQueue::from_vec(data.clone());\n-        let mut v = heap.clone().to_vec();\n+        let mut v = heap.clone().into_vec();\n         v.sort();\n         data.sort();\n \n         assert_eq!(v, data);\n-        assert_eq!(heap.to_sorted_vec(), data);\n+        assert_eq!(heap.into_sorted_vec(), data);\n     }\n \n     #[test]\n@@ -346,36 +363,21 @@ mod tests {\n     }\n \n     #[test]\n-    #[should_fail]\n     fn test_empty_pop() {\n         let mut heap: PriorityQueue<int> = PriorityQueue::new();\n-        heap.pop();\n-    }\n-\n-    #[test]\n-    fn test_empty_maybe_pop() {\n-        let mut heap: PriorityQueue<int> = PriorityQueue::new();\n-        assert!(heap.maybe_pop().is_none());\n+        assert!(heap.pop().is_none());\n     }\n \n     #[test]\n-    #[should_fail]\n     fn test_empty_top() {\n         let empty: PriorityQueue<int> = PriorityQueue::new();\n-        empty.top();\n-    }\n-\n-    #[test]\n-    fn test_empty_maybe_top() {\n-        let empty: PriorityQueue<int> = PriorityQueue::new();\n-        assert!(empty.maybe_top().is_none());\n+        assert!(empty.top().is_none());\n     }\n \n     #[test]\n-    #[should_fail]\n     fn test_empty_replace() {\n         let mut heap: PriorityQueue<int> = PriorityQueue::new();\n-        heap.replace(5);\n+        heap.replace(5).is_none();\n     }\n \n     #[test]\n@@ -385,7 +387,7 @@ mod tests {\n         let mut q: PriorityQueue<uint> = xs.as_slice().iter().rev().map(|&x| x).collect();\n \n         for &x in xs.iter() {\n-            assert_eq!(q.pop(), x);\n+            assert_eq!(q.pop().unwrap(), x);\n         }\n     }\n }"}]}